Implementation smell,Namespace,Class,File,Method,Description
Long Method,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,property,The method has 140 lines of code.
Long Method,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyName,The method has 113 lines of code.
Long Method,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The method has 361 lines of code.
Complex Method,JFLCSharp,BoolExpression,C:\repos\brad-ross-35_jfl\src\filter\BoolExpression.cs,Evaluate,Cyclomatic complexity of the method is 11
Complex Method,JFLCSharp,ComparisonUtility,C:\repos\brad-ross-35_jfl\src\filter\ComparisonUtility.cs,IsEqual,Cyclomatic complexity of the method is 19
Complex Method,JFLCSharp,ComparisonUtility,C:\repos\brad-ross-35_jfl\src\filter\ComparisonUtility.cs,IsGreater,Cyclomatic complexity of the method is 16
Complex Method,JFLCSharp,ComparisonUtility,C:\repos\brad-ross-35_jfl\src\filter\ComparisonUtility.cs,IsLess,Cyclomatic complexity of the method is 16
Complex Method,JFLCSharp,ComparisonUtility,C:\repos\brad-ross-35_jfl\src\filter\ComparisonUtility.cs,IsGreaterOrEqual,Cyclomatic complexity of the method is 16
Complex Method,JFLCSharp,ComparisonUtility,C:\repos\brad-ross-35_jfl\src\filter\ComparisonUtility.cs,IsLessOrEqual,Cyclomatic complexity of the method is 16
Complex Method,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,block,Cyclomatic complexity of the method is 11
Complex Method,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,property,Cyclomatic complexity of the method is 18
Complex Method,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyName,Cyclomatic complexity of the method is 30
Complex Method,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,Cyclomatic complexity of the method is 107
Complex Method,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyChain,Cyclomatic complexity of the method is 11
Complex Method,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,comparator,Cyclomatic complexity of the method is 11
Long Statement,JFLCSharp,BoolExpression,C:\repos\brad-ross-35_jfl\src\filter\BoolExpression.cs,Evaluate,The length of the statement  "		else if ((LeftOperand.ExprType == NodeType.Bool || LeftOperand.ExprType == NodeType.Property) && (RightOperand.ExprType == NodeType.Bool || RightOperand.ExprType == NodeType.Property)) { " is 186.
Long Statement,JFLCSharp,BoolExpression,C:\repos\brad-ross-35_jfl\src\filter\BoolExpression.cs,EvaluateOr,The length of the statement  "	if (leftValue != null && rightValue != null && leftValue.GetType () == typeof(bool) && rightValue.GetType () == typeof(bool)) " is 125.
Long Statement,JFLCSharp,ComparisonUtility,C:\repos\brad-ross-35_jfl\src\filter\ComparisonUtility.cs,IsNumber,The length of the statement  "	if (obj.GetType () == typeof(double) || obj.GetType () == typeof(int) || obj.GetType () == typeof(Int64) || obj.GetType () == typeof(Single) || obj.GetType () == typeof(UInt64)) " is 177.
Long Statement,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,property,The length of the statement  "			// ./src/Parser/Grammar/JFLWalker.g:23:2: ( ^( propertyName (not= '!' )? ( filter[newProperty] )? ( block[newProperty] )? ) ) " is 125.
Long Statement,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,property,The length of the statement  "			// ./src/Parser/Grammar/JFLWalker.g:23:4: ^( propertyName (not= '!' )? ( filter[newProperty] )? ( block[newProperty] )? ) " is 121.
Long Statement,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,property,The length of the statement  "					parentScope.AddRegexProperty ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).name : default(string))' newProperty); " is 140.
Long Statement,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,property,The length of the statement  "					parentScope.AddProperty ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).name : default(string))' newProperty); " is 135.
Long Statement,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The length of the statement  "			// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL ) " is 254.
Long Statement,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The length of the statement  "							if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) { " is 130.
Long Statement,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyChain,The length of the statement  "			// ./src/Parser/Grammar/JFLWalker.g:147:2: ( ^( ID propertyChain[propertySegments] ) | ^( ESC_ID propertyChain[propertySegments] ) ) " is 132.
Complex Conditional,JFLCSharp,BoolExpression,C:\repos\brad-ross-35_jfl\src\filter\BoolExpression.cs,Evaluate,The conditional expression  "(LeftOperand.ExprType == NodeType.Bool || LeftOperand.ExprType == NodeType.Property) && (RightOperand.ExprType == NodeType.Bool || RightOperand.ExprType == NodeType.Property)"  is complex.
Complex Conditional,JFLCSharp,BoolExpression,C:\repos\brad-ross-35_jfl\src\filter\BoolExpression.cs,EvaluateOr,The conditional expression  "leftValue != null && rightValue != null && leftValue.GetType () == typeof(bool) && rightValue.GetType () == typeof(bool)"  is complex.
Complex Conditional,JFLCSharp,ComparisonUtility,C:\repos\brad-ross-35_jfl\src\filter\ComparisonUtility.cs,IsNumber,The conditional expression  "obj.GetType () == typeof(double) || obj.GetType () == typeof(int) || obj.GetType () == typeof(Int64) || obj.GetType () == typeof(Single) || obj.GetType () == typeof(UInt64)"  is complex.
Complex Conditional,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,block,The conditional expression  "(LA1_1 == ESC_ID || LA1_1 == ID || LA1_1 == REGEX || LA1_1 == 27)"  is complex.
Complex Conditional,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The conditional expression  "((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))"  is complex.
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,walk,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "walk");  	DebugLocation (11' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:12:2: ( block[jfl] )  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:12:4: block[jfl]  		{  			DebugLocation (12' 4);  			PushFollow (Follow._block_in_walk41);  			block (jfl);  			PopFollow ();  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("walk"' 1);  		LeaveRule ("walk"' 1);  		LeaveRule_walk ();  	}  	DebugLocation (13' 1);  }  finally {  	DebugExitRule (GrammarFileName' "walk");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,walk,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "walk");  	DebugLocation (11' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:12:2: ( block[jfl] )  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:12:4: block[jfl]  		{  			DebugLocation (12' 4);  			PushFollow (Follow._block_in_walk41);  			block (jfl);  			PopFollow ();  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("walk"' 1);  		LeaveRule ("walk"' 1);  		LeaveRule_walk ();  	}  	DebugLocation (13' 1);  }  finally {  	DebugExitRule (GrammarFileName' "walk");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,walk,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "walk");  	DebugLocation (11' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:12:2: ( block[jfl] )  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:12:4: block[jfl]  		{  			DebugLocation (12' 4);  			PushFollow (Follow._block_in_walk41);  			block (jfl);  			PopFollow ();  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("walk"' 1);  		LeaveRule ("walk"' 1);  		LeaveRule_walk ();  	}  	DebugLocation (13' 1);  }  finally {  	DebugExitRule (GrammarFileName' "walk");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,walk,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "walk");  	DebugLocation (11' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:12:2: ( block[jfl] )  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:12:4: block[jfl]  		{  			DebugLocation (12' 4);  			PushFollow (Follow._block_in_walk41);  			block (jfl);  			PopFollow ();  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("walk"' 1);  		LeaveRule ("walk"' 1);  		LeaveRule_walk ();  	}  	DebugLocation (13' 1);  }  finally {  	DebugExitRule (GrammarFileName' "walk");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,walk,The following statement contains a magic number: DebugLocation (11' 1);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,walk,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:12:2: ( block[jfl] )  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:12:4: block[jfl]  	{  		DebugLocation (12' 4);  		PushFollow (Follow._block_in_walk41);  		block (jfl);  		PopFollow ();  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("walk"' 1);  	LeaveRule ("walk"' 1);  	LeaveRule_walk ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,walk,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:12:2: ( block[jfl] )  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:12:4: block[jfl]  	{  		DebugLocation (12' 4);  		PushFollow (Follow._block_in_walk41);  		block (jfl);  		PopFollow ();  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("walk"' 1);  	LeaveRule ("walk"' 1);  	LeaveRule_walk ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,walk,The following statement contains a magic number: DebugLocation (12' 4);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,walk,The following statement contains a magic number: DebugLocation (12' 4);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,walk,The following statement contains a magic number: DebugLocation (13' 1);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,block,The following statement contains a magic number: EnterRule ("block"' 2);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,block,The following statement contains a magic number: TraceIn ("block"' 2);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,block,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "block");  	DebugLocation (15' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:16:2: ( ^( BLOCK ( property[currScope] )* ) )  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:16:4: ^( BLOCK ( property[currScope] )* )  		{  			DebugLocation (16' 4);  			DebugLocation (16' 6);  			Match (input' BLOCK' Follow._BLOCK_in_block56);  			if (input.LA (1) == TokenTypes.Down) {  				Match (input' TokenTypes.Down' null);  				DebugLocation (16' 12);  				// ./src/Parser/Grammar/JFLWalker.g:16:12: ( property[currScope] )*  				try {  					DebugEnterSubRule (1);  					while (true) {  						int alt1 = 2;  						try {  							DebugEnterDecision (1' false);  							int LA1_1 = input.LA (1);  							if ((LA1_1 == ESC_ID || LA1_1 == ID || LA1_1 == REGEX || LA1_1 == 27)) {  								alt1 = 1;  							}  						}  						finally {  							DebugExitDecision (1);  						}  						switch (alt1) {  						case 1:  							DebugEnterAlt (1);  							// ./src/Parser/Grammar/JFLWalker.g:16:12: property[currScope]  							{  								DebugLocation (16' 12);  								PushFollow (Follow._property_in_block58);  								property (currScope);  								PopFollow ();  							}  							break;  						default:  							goto loop1;  						}  					}  					loop1:  					;  				}  				finally {  					DebugExitSubRule (1);  				}  				Match (input' TokenTypes.Up' null);  			}  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("block"' 2);  		LeaveRule ("block"' 2);  		LeaveRule_block ();  	}  	DebugLocation (17' 1);  }  finally {  	DebugExitRule (GrammarFileName' "block");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,block,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "block");  	DebugLocation (15' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:16:2: ( ^( BLOCK ( property[currScope] )* ) )  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:16:4: ^( BLOCK ( property[currScope] )* )  		{  			DebugLocation (16' 4);  			DebugLocation (16' 6);  			Match (input' BLOCK' Follow._BLOCK_in_block56);  			if (input.LA (1) == TokenTypes.Down) {  				Match (input' TokenTypes.Down' null);  				DebugLocation (16' 12);  				// ./src/Parser/Grammar/JFLWalker.g:16:12: ( property[currScope] )*  				try {  					DebugEnterSubRule (1);  					while (true) {  						int alt1 = 2;  						try {  							DebugEnterDecision (1' false);  							int LA1_1 = input.LA (1);  							if ((LA1_1 == ESC_ID || LA1_1 == ID || LA1_1 == REGEX || LA1_1 == 27)) {  								alt1 = 1;  							}  						}  						finally {  							DebugExitDecision (1);  						}  						switch (alt1) {  						case 1:  							DebugEnterAlt (1);  							// ./src/Parser/Grammar/JFLWalker.g:16:12: property[currScope]  							{  								DebugLocation (16' 12);  								PushFollow (Follow._property_in_block58);  								property (currScope);  								PopFollow ();  							}  							break;  						default:  							goto loop1;  						}  					}  					loop1:  					;  				}  				finally {  					DebugExitSubRule (1);  				}  				Match (input' TokenTypes.Up' null);  			}  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("block"' 2);  		LeaveRule ("block"' 2);  		LeaveRule_block ();  	}  	DebugLocation (17' 1);  }  finally {  	DebugExitRule (GrammarFileName' "block");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,block,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "block");  	DebugLocation (15' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:16:2: ( ^( BLOCK ( property[currScope] )* ) )  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:16:4: ^( BLOCK ( property[currScope] )* )  		{  			DebugLocation (16' 4);  			DebugLocation (16' 6);  			Match (input' BLOCK' Follow._BLOCK_in_block56);  			if (input.LA (1) == TokenTypes.Down) {  				Match (input' TokenTypes.Down' null);  				DebugLocation (16' 12);  				// ./src/Parser/Grammar/JFLWalker.g:16:12: ( property[currScope] )*  				try {  					DebugEnterSubRule (1);  					while (true) {  						int alt1 = 2;  						try {  							DebugEnterDecision (1' false);  							int LA1_1 = input.LA (1);  							if ((LA1_1 == ESC_ID || LA1_1 == ID || LA1_1 == REGEX || LA1_1 == 27)) {  								alt1 = 1;  							}  						}  						finally {  							DebugExitDecision (1);  						}  						switch (alt1) {  						case 1:  							DebugEnterAlt (1);  							// ./src/Parser/Grammar/JFLWalker.g:16:12: property[currScope]  							{  								DebugLocation (16' 12);  								PushFollow (Follow._property_in_block58);  								property (currScope);  								PopFollow ();  							}  							break;  						default:  							goto loop1;  						}  					}  					loop1:  					;  				}  				finally {  					DebugExitSubRule (1);  				}  				Match (input' TokenTypes.Up' null);  			}  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("block"' 2);  		LeaveRule ("block"' 2);  		LeaveRule_block ();  	}  	DebugLocation (17' 1);  }  finally {  	DebugExitRule (GrammarFileName' "block");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,block,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "block");  	DebugLocation (15' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:16:2: ( ^( BLOCK ( property[currScope] )* ) )  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:16:4: ^( BLOCK ( property[currScope] )* )  		{  			DebugLocation (16' 4);  			DebugLocation (16' 6);  			Match (input' BLOCK' Follow._BLOCK_in_block56);  			if (input.LA (1) == TokenTypes.Down) {  				Match (input' TokenTypes.Down' null);  				DebugLocation (16' 12);  				// ./src/Parser/Grammar/JFLWalker.g:16:12: ( property[currScope] )*  				try {  					DebugEnterSubRule (1);  					while (true) {  						int alt1 = 2;  						try {  							DebugEnterDecision (1' false);  							int LA1_1 = input.LA (1);  							if ((LA1_1 == ESC_ID || LA1_1 == ID || LA1_1 == REGEX || LA1_1 == 27)) {  								alt1 = 1;  							}  						}  						finally {  							DebugExitDecision (1);  						}  						switch (alt1) {  						case 1:  							DebugEnterAlt (1);  							// ./src/Parser/Grammar/JFLWalker.g:16:12: property[currScope]  							{  								DebugLocation (16' 12);  								PushFollow (Follow._property_in_block58);  								property (currScope);  								PopFollow ();  							}  							break;  						default:  							goto loop1;  						}  					}  					loop1:  					;  				}  				finally {  					DebugExitSubRule (1);  				}  				Match (input' TokenTypes.Up' null);  			}  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("block"' 2);  		LeaveRule ("block"' 2);  		LeaveRule_block ();  	}  	DebugLocation (17' 1);  }  finally {  	DebugExitRule (GrammarFileName' "block");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,block,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "block");  	DebugLocation (15' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:16:2: ( ^( BLOCK ( property[currScope] )* ) )  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:16:4: ^( BLOCK ( property[currScope] )* )  		{  			DebugLocation (16' 4);  			DebugLocation (16' 6);  			Match (input' BLOCK' Follow._BLOCK_in_block56);  			if (input.LA (1) == TokenTypes.Down) {  				Match (input' TokenTypes.Down' null);  				DebugLocation (16' 12);  				// ./src/Parser/Grammar/JFLWalker.g:16:12: ( property[currScope] )*  				try {  					DebugEnterSubRule (1);  					while (true) {  						int alt1 = 2;  						try {  							DebugEnterDecision (1' false);  							int LA1_1 = input.LA (1);  							if ((LA1_1 == ESC_ID || LA1_1 == ID || LA1_1 == REGEX || LA1_1 == 27)) {  								alt1 = 1;  							}  						}  						finally {  							DebugExitDecision (1);  						}  						switch (alt1) {  						case 1:  							DebugEnterAlt (1);  							// ./src/Parser/Grammar/JFLWalker.g:16:12: property[currScope]  							{  								DebugLocation (16' 12);  								PushFollow (Follow._property_in_block58);  								property (currScope);  								PopFollow ();  							}  							break;  						default:  							goto loop1;  						}  					}  					loop1:  					;  				}  				finally {  					DebugExitSubRule (1);  				}  				Match (input' TokenTypes.Up' null);  			}  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("block"' 2);  		LeaveRule ("block"' 2);  		LeaveRule_block ();  	}  	DebugLocation (17' 1);  }  finally {  	DebugExitRule (GrammarFileName' "block");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,block,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "block");  	DebugLocation (15' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:16:2: ( ^( BLOCK ( property[currScope] )* ) )  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:16:4: ^( BLOCK ( property[currScope] )* )  		{  			DebugLocation (16' 4);  			DebugLocation (16' 6);  			Match (input' BLOCK' Follow._BLOCK_in_block56);  			if (input.LA (1) == TokenTypes.Down) {  				Match (input' TokenTypes.Down' null);  				DebugLocation (16' 12);  				// ./src/Parser/Grammar/JFLWalker.g:16:12: ( property[currScope] )*  				try {  					DebugEnterSubRule (1);  					while (true) {  						int alt1 = 2;  						try {  							DebugEnterDecision (1' false);  							int LA1_1 = input.LA (1);  							if ((LA1_1 == ESC_ID || LA1_1 == ID || LA1_1 == REGEX || LA1_1 == 27)) {  								alt1 = 1;  							}  						}  						finally {  							DebugExitDecision (1);  						}  						switch (alt1) {  						case 1:  							DebugEnterAlt (1);  							// ./src/Parser/Grammar/JFLWalker.g:16:12: property[currScope]  							{  								DebugLocation (16' 12);  								PushFollow (Follow._property_in_block58);  								property (currScope);  								PopFollow ();  							}  							break;  						default:  							goto loop1;  						}  					}  					loop1:  					;  				}  				finally {  					DebugExitSubRule (1);  				}  				Match (input' TokenTypes.Up' null);  			}  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("block"' 2);  		LeaveRule ("block"' 2);  		LeaveRule_block ();  	}  	DebugLocation (17' 1);  }  finally {  	DebugExitRule (GrammarFileName' "block");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,block,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "block");  	DebugLocation (15' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:16:2: ( ^( BLOCK ( property[currScope] )* ) )  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:16:4: ^( BLOCK ( property[currScope] )* )  		{  			DebugLocation (16' 4);  			DebugLocation (16' 6);  			Match (input' BLOCK' Follow._BLOCK_in_block56);  			if (input.LA (1) == TokenTypes.Down) {  				Match (input' TokenTypes.Down' null);  				DebugLocation (16' 12);  				// ./src/Parser/Grammar/JFLWalker.g:16:12: ( property[currScope] )*  				try {  					DebugEnterSubRule (1);  					while (true) {  						int alt1 = 2;  						try {  							DebugEnterDecision (1' false);  							int LA1_1 = input.LA (1);  							if ((LA1_1 == ESC_ID || LA1_1 == ID || LA1_1 == REGEX || LA1_1 == 27)) {  								alt1 = 1;  							}  						}  						finally {  							DebugExitDecision (1);  						}  						switch (alt1) {  						case 1:  							DebugEnterAlt (1);  							// ./src/Parser/Grammar/JFLWalker.g:16:12: property[currScope]  							{  								DebugLocation (16' 12);  								PushFollow (Follow._property_in_block58);  								property (currScope);  								PopFollow ();  							}  							break;  						default:  							goto loop1;  						}  					}  					loop1:  					;  				}  				finally {  					DebugExitSubRule (1);  				}  				Match (input' TokenTypes.Up' null);  			}  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("block"' 2);  		LeaveRule ("block"' 2);  		LeaveRule_block ();  	}  	DebugLocation (17' 1);  }  finally {  	DebugExitRule (GrammarFileName' "block");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,block,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "block");  	DebugLocation (15' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:16:2: ( ^( BLOCK ( property[currScope] )* ) )  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:16:4: ^( BLOCK ( property[currScope] )* )  		{  			DebugLocation (16' 4);  			DebugLocation (16' 6);  			Match (input' BLOCK' Follow._BLOCK_in_block56);  			if (input.LA (1) == TokenTypes.Down) {  				Match (input' TokenTypes.Down' null);  				DebugLocation (16' 12);  				// ./src/Parser/Grammar/JFLWalker.g:16:12: ( property[currScope] )*  				try {  					DebugEnterSubRule (1);  					while (true) {  						int alt1 = 2;  						try {  							DebugEnterDecision (1' false);  							int LA1_1 = input.LA (1);  							if ((LA1_1 == ESC_ID || LA1_1 == ID || LA1_1 == REGEX || LA1_1 == 27)) {  								alt1 = 1;  							}  						}  						finally {  							DebugExitDecision (1);  						}  						switch (alt1) {  						case 1:  							DebugEnterAlt (1);  							// ./src/Parser/Grammar/JFLWalker.g:16:12: property[currScope]  							{  								DebugLocation (16' 12);  								PushFollow (Follow._property_in_block58);  								property (currScope);  								PopFollow ();  							}  							break;  						default:  							goto loop1;  						}  					}  					loop1:  					;  				}  				finally {  					DebugExitSubRule (1);  				}  				Match (input' TokenTypes.Up' null);  			}  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("block"' 2);  		LeaveRule ("block"' 2);  		LeaveRule_block ();  	}  	DebugLocation (17' 1);  }  finally {  	DebugExitRule (GrammarFileName' "block");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,block,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "block");  	DebugLocation (15' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:16:2: ( ^( BLOCK ( property[currScope] )* ) )  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:16:4: ^( BLOCK ( property[currScope] )* )  		{  			DebugLocation (16' 4);  			DebugLocation (16' 6);  			Match (input' BLOCK' Follow._BLOCK_in_block56);  			if (input.LA (1) == TokenTypes.Down) {  				Match (input' TokenTypes.Down' null);  				DebugLocation (16' 12);  				// ./src/Parser/Grammar/JFLWalker.g:16:12: ( property[currScope] )*  				try {  					DebugEnterSubRule (1);  					while (true) {  						int alt1 = 2;  						try {  							DebugEnterDecision (1' false);  							int LA1_1 = input.LA (1);  							if ((LA1_1 == ESC_ID || LA1_1 == ID || LA1_1 == REGEX || LA1_1 == 27)) {  								alt1 = 1;  							}  						}  						finally {  							DebugExitDecision (1);  						}  						switch (alt1) {  						case 1:  							DebugEnterAlt (1);  							// ./src/Parser/Grammar/JFLWalker.g:16:12: property[currScope]  							{  								DebugLocation (16' 12);  								PushFollow (Follow._property_in_block58);  								property (currScope);  								PopFollow ();  							}  							break;  						default:  							goto loop1;  						}  					}  					loop1:  					;  				}  				finally {  					DebugExitSubRule (1);  				}  				Match (input' TokenTypes.Up' null);  			}  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("block"' 2);  		LeaveRule ("block"' 2);  		LeaveRule_block ();  	}  	DebugLocation (17' 1);  }  finally {  	DebugExitRule (GrammarFileName' "block");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,block,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "block");  	DebugLocation (15' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:16:2: ( ^( BLOCK ( property[currScope] )* ) )  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:16:4: ^( BLOCK ( property[currScope] )* )  		{  			DebugLocation (16' 4);  			DebugLocation (16' 6);  			Match (input' BLOCK' Follow._BLOCK_in_block56);  			if (input.LA (1) == TokenTypes.Down) {  				Match (input' TokenTypes.Down' null);  				DebugLocation (16' 12);  				// ./src/Parser/Grammar/JFLWalker.g:16:12: ( property[currScope] )*  				try {  					DebugEnterSubRule (1);  					while (true) {  						int alt1 = 2;  						try {  							DebugEnterDecision (1' false);  							int LA1_1 = input.LA (1);  							if ((LA1_1 == ESC_ID || LA1_1 == ID || LA1_1 == REGEX || LA1_1 == 27)) {  								alt1 = 1;  							}  						}  						finally {  							DebugExitDecision (1);  						}  						switch (alt1) {  						case 1:  							DebugEnterAlt (1);  							// ./src/Parser/Grammar/JFLWalker.g:16:12: property[currScope]  							{  								DebugLocation (16' 12);  								PushFollow (Follow._property_in_block58);  								property (currScope);  								PopFollow ();  							}  							break;  						default:  							goto loop1;  						}  					}  					loop1:  					;  				}  				finally {  					DebugExitSubRule (1);  				}  				Match (input' TokenTypes.Up' null);  			}  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("block"' 2);  		LeaveRule ("block"' 2);  		LeaveRule_block ();  	}  	DebugLocation (17' 1);  }  finally {  	DebugExitRule (GrammarFileName' "block");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,block,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "block");  	DebugLocation (15' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:16:2: ( ^( BLOCK ( property[currScope] )* ) )  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:16:4: ^( BLOCK ( property[currScope] )* )  		{  			DebugLocation (16' 4);  			DebugLocation (16' 6);  			Match (input' BLOCK' Follow._BLOCK_in_block56);  			if (input.LA (1) == TokenTypes.Down) {  				Match (input' TokenTypes.Down' null);  				DebugLocation (16' 12);  				// ./src/Parser/Grammar/JFLWalker.g:16:12: ( property[currScope] )*  				try {  					DebugEnterSubRule (1);  					while (true) {  						int alt1 = 2;  						try {  							DebugEnterDecision (1' false);  							int LA1_1 = input.LA (1);  							if ((LA1_1 == ESC_ID || LA1_1 == ID || LA1_1 == REGEX || LA1_1 == 27)) {  								alt1 = 1;  							}  						}  						finally {  							DebugExitDecision (1);  						}  						switch (alt1) {  						case 1:  							DebugEnterAlt (1);  							// ./src/Parser/Grammar/JFLWalker.g:16:12: property[currScope]  							{  								DebugLocation (16' 12);  								PushFollow (Follow._property_in_block58);  								property (currScope);  								PopFollow ();  							}  							break;  						default:  							goto loop1;  						}  					}  					loop1:  					;  				}  				finally {  					DebugExitSubRule (1);  				}  				Match (input' TokenTypes.Up' null);  			}  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("block"' 2);  		LeaveRule ("block"' 2);  		LeaveRule_block ();  	}  	DebugLocation (17' 1);  }  finally {  	DebugExitRule (GrammarFileName' "block");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,block,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "block");  	DebugLocation (15' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:16:2: ( ^( BLOCK ( property[currScope] )* ) )  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:16:4: ^( BLOCK ( property[currScope] )* )  		{  			DebugLocation (16' 4);  			DebugLocation (16' 6);  			Match (input' BLOCK' Follow._BLOCK_in_block56);  			if (input.LA (1) == TokenTypes.Down) {  				Match (input' TokenTypes.Down' null);  				DebugLocation (16' 12);  				// ./src/Parser/Grammar/JFLWalker.g:16:12: ( property[currScope] )*  				try {  					DebugEnterSubRule (1);  					while (true) {  						int alt1 = 2;  						try {  							DebugEnterDecision (1' false);  							int LA1_1 = input.LA (1);  							if ((LA1_1 == ESC_ID || LA1_1 == ID || LA1_1 == REGEX || LA1_1 == 27)) {  								alt1 = 1;  							}  						}  						finally {  							DebugExitDecision (1);  						}  						switch (alt1) {  						case 1:  							DebugEnterAlt (1);  							// ./src/Parser/Grammar/JFLWalker.g:16:12: property[currScope]  							{  								DebugLocation (16' 12);  								PushFollow (Follow._property_in_block58);  								property (currScope);  								PopFollow ();  							}  							break;  						default:  							goto loop1;  						}  					}  					loop1:  					;  				}  				finally {  					DebugExitSubRule (1);  				}  				Match (input' TokenTypes.Up' null);  			}  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("block"' 2);  		LeaveRule ("block"' 2);  		LeaveRule_block ();  	}  	DebugLocation (17' 1);  }  finally {  	DebugExitRule (GrammarFileName' "block");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,block,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "block");  	DebugLocation (15' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:16:2: ( ^( BLOCK ( property[currScope] )* ) )  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:16:4: ^( BLOCK ( property[currScope] )* )  		{  			DebugLocation (16' 4);  			DebugLocation (16' 6);  			Match (input' BLOCK' Follow._BLOCK_in_block56);  			if (input.LA (1) == TokenTypes.Down) {  				Match (input' TokenTypes.Down' null);  				DebugLocation (16' 12);  				// ./src/Parser/Grammar/JFLWalker.g:16:12: ( property[currScope] )*  				try {  					DebugEnterSubRule (1);  					while (true) {  						int alt1 = 2;  						try {  							DebugEnterDecision (1' false);  							int LA1_1 = input.LA (1);  							if ((LA1_1 == ESC_ID || LA1_1 == ID || LA1_1 == REGEX || LA1_1 == 27)) {  								alt1 = 1;  							}  						}  						finally {  							DebugExitDecision (1);  						}  						switch (alt1) {  						case 1:  							DebugEnterAlt (1);  							// ./src/Parser/Grammar/JFLWalker.g:16:12: property[currScope]  							{  								DebugLocation (16' 12);  								PushFollow (Follow._property_in_block58);  								property (currScope);  								PopFollow ();  							}  							break;  						default:  							goto loop1;  						}  					}  					loop1:  					;  				}  				finally {  					DebugExitSubRule (1);  				}  				Match (input' TokenTypes.Up' null);  			}  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("block"' 2);  		LeaveRule ("block"' 2);  		LeaveRule_block ();  	}  	DebugLocation (17' 1);  }  finally {  	DebugExitRule (GrammarFileName' "block");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,block,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "block");  	DebugLocation (15' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:16:2: ( ^( BLOCK ( property[currScope] )* ) )  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:16:4: ^( BLOCK ( property[currScope] )* )  		{  			DebugLocation (16' 4);  			DebugLocation (16' 6);  			Match (input' BLOCK' Follow._BLOCK_in_block56);  			if (input.LA (1) == TokenTypes.Down) {  				Match (input' TokenTypes.Down' null);  				DebugLocation (16' 12);  				// ./src/Parser/Grammar/JFLWalker.g:16:12: ( property[currScope] )*  				try {  					DebugEnterSubRule (1);  					while (true) {  						int alt1 = 2;  						try {  							DebugEnterDecision (1' false);  							int LA1_1 = input.LA (1);  							if ((LA1_1 == ESC_ID || LA1_1 == ID || LA1_1 == REGEX || LA1_1 == 27)) {  								alt1 = 1;  							}  						}  						finally {  							DebugExitDecision (1);  						}  						switch (alt1) {  						case 1:  							DebugEnterAlt (1);  							// ./src/Parser/Grammar/JFLWalker.g:16:12: property[currScope]  							{  								DebugLocation (16' 12);  								PushFollow (Follow._property_in_block58);  								property (currScope);  								PopFollow ();  							}  							break;  						default:  							goto loop1;  						}  					}  					loop1:  					;  				}  				finally {  					DebugExitSubRule (1);  				}  				Match (input' TokenTypes.Up' null);  			}  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("block"' 2);  		LeaveRule ("block"' 2);  		LeaveRule_block ();  	}  	DebugLocation (17' 1);  }  finally {  	DebugExitRule (GrammarFileName' "block");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,block,The following statement contains a magic number: DebugLocation (15' 1);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,block,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:16:2: ( ^( BLOCK ( property[currScope] )* ) )  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:16:4: ^( BLOCK ( property[currScope] )* )  	{  		DebugLocation (16' 4);  		DebugLocation (16' 6);  		Match (input' BLOCK' Follow._BLOCK_in_block56);  		if (input.LA (1) == TokenTypes.Down) {  			Match (input' TokenTypes.Down' null);  			DebugLocation (16' 12);  			// ./src/Parser/Grammar/JFLWalker.g:16:12: ( property[currScope] )*  			try {  				DebugEnterSubRule (1);  				while (true) {  					int alt1 = 2;  					try {  						DebugEnterDecision (1' false);  						int LA1_1 = input.LA (1);  						if ((LA1_1 == ESC_ID || LA1_1 == ID || LA1_1 == REGEX || LA1_1 == 27)) {  							alt1 = 1;  						}  					}  					finally {  						DebugExitDecision (1);  					}  					switch (alt1) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:16:12: property[currScope]  						{  							DebugLocation (16' 12);  							PushFollow (Follow._property_in_block58);  							property (currScope);  							PopFollow ();  						}  						break;  					default:  						goto loop1;  					}  				}  				loop1:  				;  			}  			finally {  				DebugExitSubRule (1);  			}  			Match (input' TokenTypes.Up' null);  		}  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("block"' 2);  	LeaveRule ("block"' 2);  	LeaveRule_block ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,block,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:16:2: ( ^( BLOCK ( property[currScope] )* ) )  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:16:4: ^( BLOCK ( property[currScope] )* )  	{  		DebugLocation (16' 4);  		DebugLocation (16' 6);  		Match (input' BLOCK' Follow._BLOCK_in_block56);  		if (input.LA (1) == TokenTypes.Down) {  			Match (input' TokenTypes.Down' null);  			DebugLocation (16' 12);  			// ./src/Parser/Grammar/JFLWalker.g:16:12: ( property[currScope] )*  			try {  				DebugEnterSubRule (1);  				while (true) {  					int alt1 = 2;  					try {  						DebugEnterDecision (1' false);  						int LA1_1 = input.LA (1);  						if ((LA1_1 == ESC_ID || LA1_1 == ID || LA1_1 == REGEX || LA1_1 == 27)) {  							alt1 = 1;  						}  					}  					finally {  						DebugExitDecision (1);  					}  					switch (alt1) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:16:12: property[currScope]  						{  							DebugLocation (16' 12);  							PushFollow (Follow._property_in_block58);  							property (currScope);  							PopFollow ();  						}  						break;  					default:  						goto loop1;  					}  				}  				loop1:  				;  			}  			finally {  				DebugExitSubRule (1);  			}  			Match (input' TokenTypes.Up' null);  		}  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("block"' 2);  	LeaveRule ("block"' 2);  	LeaveRule_block ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,block,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:16:2: ( ^( BLOCK ( property[currScope] )* ) )  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:16:4: ^( BLOCK ( property[currScope] )* )  	{  		DebugLocation (16' 4);  		DebugLocation (16' 6);  		Match (input' BLOCK' Follow._BLOCK_in_block56);  		if (input.LA (1) == TokenTypes.Down) {  			Match (input' TokenTypes.Down' null);  			DebugLocation (16' 12);  			// ./src/Parser/Grammar/JFLWalker.g:16:12: ( property[currScope] )*  			try {  				DebugEnterSubRule (1);  				while (true) {  					int alt1 = 2;  					try {  						DebugEnterDecision (1' false);  						int LA1_1 = input.LA (1);  						if ((LA1_1 == ESC_ID || LA1_1 == ID || LA1_1 == REGEX || LA1_1 == 27)) {  							alt1 = 1;  						}  					}  					finally {  						DebugExitDecision (1);  					}  					switch (alt1) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:16:12: property[currScope]  						{  							DebugLocation (16' 12);  							PushFollow (Follow._property_in_block58);  							property (currScope);  							PopFollow ();  						}  						break;  					default:  						goto loop1;  					}  				}  				loop1:  				;  			}  			finally {  				DebugExitSubRule (1);  			}  			Match (input' TokenTypes.Up' null);  		}  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("block"' 2);  	LeaveRule ("block"' 2);  	LeaveRule_block ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,block,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:16:2: ( ^( BLOCK ( property[currScope] )* ) )  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:16:4: ^( BLOCK ( property[currScope] )* )  	{  		DebugLocation (16' 4);  		DebugLocation (16' 6);  		Match (input' BLOCK' Follow._BLOCK_in_block56);  		if (input.LA (1) == TokenTypes.Down) {  			Match (input' TokenTypes.Down' null);  			DebugLocation (16' 12);  			// ./src/Parser/Grammar/JFLWalker.g:16:12: ( property[currScope] )*  			try {  				DebugEnterSubRule (1);  				while (true) {  					int alt1 = 2;  					try {  						DebugEnterDecision (1' false);  						int LA1_1 = input.LA (1);  						if ((LA1_1 == ESC_ID || LA1_1 == ID || LA1_1 == REGEX || LA1_1 == 27)) {  							alt1 = 1;  						}  					}  					finally {  						DebugExitDecision (1);  					}  					switch (alt1) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:16:12: property[currScope]  						{  							DebugLocation (16' 12);  							PushFollow (Follow._property_in_block58);  							property (currScope);  							PopFollow ();  						}  						break;  					default:  						goto loop1;  					}  				}  				loop1:  				;  			}  			finally {  				DebugExitSubRule (1);  			}  			Match (input' TokenTypes.Up' null);  		}  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("block"' 2);  	LeaveRule ("block"' 2);  	LeaveRule_block ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,block,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:16:2: ( ^( BLOCK ( property[currScope] )* ) )  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:16:4: ^( BLOCK ( property[currScope] )* )  	{  		DebugLocation (16' 4);  		DebugLocation (16' 6);  		Match (input' BLOCK' Follow._BLOCK_in_block56);  		if (input.LA (1) == TokenTypes.Down) {  			Match (input' TokenTypes.Down' null);  			DebugLocation (16' 12);  			// ./src/Parser/Grammar/JFLWalker.g:16:12: ( property[currScope] )*  			try {  				DebugEnterSubRule (1);  				while (true) {  					int alt1 = 2;  					try {  						DebugEnterDecision (1' false);  						int LA1_1 = input.LA (1);  						if ((LA1_1 == ESC_ID || LA1_1 == ID || LA1_1 == REGEX || LA1_1 == 27)) {  							alt1 = 1;  						}  					}  					finally {  						DebugExitDecision (1);  					}  					switch (alt1) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:16:12: property[currScope]  						{  							DebugLocation (16' 12);  							PushFollow (Follow._property_in_block58);  							property (currScope);  							PopFollow ();  						}  						break;  					default:  						goto loop1;  					}  				}  				loop1:  				;  			}  			finally {  				DebugExitSubRule (1);  			}  			Match (input' TokenTypes.Up' null);  		}  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("block"' 2);  	LeaveRule ("block"' 2);  	LeaveRule_block ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,block,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:16:2: ( ^( BLOCK ( property[currScope] )* ) )  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:16:4: ^( BLOCK ( property[currScope] )* )  	{  		DebugLocation (16' 4);  		DebugLocation (16' 6);  		Match (input' BLOCK' Follow._BLOCK_in_block56);  		if (input.LA (1) == TokenTypes.Down) {  			Match (input' TokenTypes.Down' null);  			DebugLocation (16' 12);  			// ./src/Parser/Grammar/JFLWalker.g:16:12: ( property[currScope] )*  			try {  				DebugEnterSubRule (1);  				while (true) {  					int alt1 = 2;  					try {  						DebugEnterDecision (1' false);  						int LA1_1 = input.LA (1);  						if ((LA1_1 == ESC_ID || LA1_1 == ID || LA1_1 == REGEX || LA1_1 == 27)) {  							alt1 = 1;  						}  					}  					finally {  						DebugExitDecision (1);  					}  					switch (alt1) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:16:12: property[currScope]  						{  							DebugLocation (16' 12);  							PushFollow (Follow._property_in_block58);  							property (currScope);  							PopFollow ();  						}  						break;  					default:  						goto loop1;  					}  				}  				loop1:  				;  			}  			finally {  				DebugExitSubRule (1);  			}  			Match (input' TokenTypes.Up' null);  		}  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("block"' 2);  	LeaveRule ("block"' 2);  	LeaveRule_block ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,block,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:16:2: ( ^( BLOCK ( property[currScope] )* ) )  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:16:4: ^( BLOCK ( property[currScope] )* )  	{  		DebugLocation (16' 4);  		DebugLocation (16' 6);  		Match (input' BLOCK' Follow._BLOCK_in_block56);  		if (input.LA (1) == TokenTypes.Down) {  			Match (input' TokenTypes.Down' null);  			DebugLocation (16' 12);  			// ./src/Parser/Grammar/JFLWalker.g:16:12: ( property[currScope] )*  			try {  				DebugEnterSubRule (1);  				while (true) {  					int alt1 = 2;  					try {  						DebugEnterDecision (1' false);  						int LA1_1 = input.LA (1);  						if ((LA1_1 == ESC_ID || LA1_1 == ID || LA1_1 == REGEX || LA1_1 == 27)) {  							alt1 = 1;  						}  					}  					finally {  						DebugExitDecision (1);  					}  					switch (alt1) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:16:12: property[currScope]  						{  							DebugLocation (16' 12);  							PushFollow (Follow._property_in_block58);  							property (currScope);  							PopFollow ();  						}  						break;  					default:  						goto loop1;  					}  				}  				loop1:  				;  			}  			finally {  				DebugExitSubRule (1);  			}  			Match (input' TokenTypes.Up' null);  		}  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("block"' 2);  	LeaveRule ("block"' 2);  	LeaveRule_block ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,block,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:16:2: ( ^( BLOCK ( property[currScope] )* ) )  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:16:4: ^( BLOCK ( property[currScope] )* )  	{  		DebugLocation (16' 4);  		DebugLocation (16' 6);  		Match (input' BLOCK' Follow._BLOCK_in_block56);  		if (input.LA (1) == TokenTypes.Down) {  			Match (input' TokenTypes.Down' null);  			DebugLocation (16' 12);  			// ./src/Parser/Grammar/JFLWalker.g:16:12: ( property[currScope] )*  			try {  				DebugEnterSubRule (1);  				while (true) {  					int alt1 = 2;  					try {  						DebugEnterDecision (1' false);  						int LA1_1 = input.LA (1);  						if ((LA1_1 == ESC_ID || LA1_1 == ID || LA1_1 == REGEX || LA1_1 == 27)) {  							alt1 = 1;  						}  					}  					finally {  						DebugExitDecision (1);  					}  					switch (alt1) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:16:12: property[currScope]  						{  							DebugLocation (16' 12);  							PushFollow (Follow._property_in_block58);  							property (currScope);  							PopFollow ();  						}  						break;  					default:  						goto loop1;  					}  				}  				loop1:  				;  			}  			finally {  				DebugExitSubRule (1);  			}  			Match (input' TokenTypes.Up' null);  		}  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("block"' 2);  	LeaveRule ("block"' 2);  	LeaveRule_block ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,block,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:16:2: ( ^( BLOCK ( property[currScope] )* ) )  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:16:4: ^( BLOCK ( property[currScope] )* )  	{  		DebugLocation (16' 4);  		DebugLocation (16' 6);  		Match (input' BLOCK' Follow._BLOCK_in_block56);  		if (input.LA (1) == TokenTypes.Down) {  			Match (input' TokenTypes.Down' null);  			DebugLocation (16' 12);  			// ./src/Parser/Grammar/JFLWalker.g:16:12: ( property[currScope] )*  			try {  				DebugEnterSubRule (1);  				while (true) {  					int alt1 = 2;  					try {  						DebugEnterDecision (1' false);  						int LA1_1 = input.LA (1);  						if ((LA1_1 == ESC_ID || LA1_1 == ID || LA1_1 == REGEX || LA1_1 == 27)) {  							alt1 = 1;  						}  					}  					finally {  						DebugExitDecision (1);  					}  					switch (alt1) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:16:12: property[currScope]  						{  							DebugLocation (16' 12);  							PushFollow (Follow._property_in_block58);  							property (currScope);  							PopFollow ();  						}  						break;  					default:  						goto loop1;  					}  				}  				loop1:  				;  			}  			finally {  				DebugExitSubRule (1);  			}  			Match (input' TokenTypes.Up' null);  		}  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("block"' 2);  	LeaveRule ("block"' 2);  	LeaveRule_block ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,block,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:16:2: ( ^( BLOCK ( property[currScope] )* ) )  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:16:4: ^( BLOCK ( property[currScope] )* )  	{  		DebugLocation (16' 4);  		DebugLocation (16' 6);  		Match (input' BLOCK' Follow._BLOCK_in_block56);  		if (input.LA (1) == TokenTypes.Down) {  			Match (input' TokenTypes.Down' null);  			DebugLocation (16' 12);  			// ./src/Parser/Grammar/JFLWalker.g:16:12: ( property[currScope] )*  			try {  				DebugEnterSubRule (1);  				while (true) {  					int alt1 = 2;  					try {  						DebugEnterDecision (1' false);  						int LA1_1 = input.LA (1);  						if ((LA1_1 == ESC_ID || LA1_1 == ID || LA1_1 == REGEX || LA1_1 == 27)) {  							alt1 = 1;  						}  					}  					finally {  						DebugExitDecision (1);  					}  					switch (alt1) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:16:12: property[currScope]  						{  							DebugLocation (16' 12);  							PushFollow (Follow._property_in_block58);  							property (currScope);  							PopFollow ();  						}  						break;  					default:  						goto loop1;  					}  				}  				loop1:  				;  			}  			finally {  				DebugExitSubRule (1);  			}  			Match (input' TokenTypes.Up' null);  		}  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("block"' 2);  	LeaveRule ("block"' 2);  	LeaveRule_block ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,block,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:16:2: ( ^( BLOCK ( property[currScope] )* ) )  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:16:4: ^( BLOCK ( property[currScope] )* )  	{  		DebugLocation (16' 4);  		DebugLocation (16' 6);  		Match (input' BLOCK' Follow._BLOCK_in_block56);  		if (input.LA (1) == TokenTypes.Down) {  			Match (input' TokenTypes.Down' null);  			DebugLocation (16' 12);  			// ./src/Parser/Grammar/JFLWalker.g:16:12: ( property[currScope] )*  			try {  				DebugEnterSubRule (1);  				while (true) {  					int alt1 = 2;  					try {  						DebugEnterDecision (1' false);  						int LA1_1 = input.LA (1);  						if ((LA1_1 == ESC_ID || LA1_1 == ID || LA1_1 == REGEX || LA1_1 == 27)) {  							alt1 = 1;  						}  					}  					finally {  						DebugExitDecision (1);  					}  					switch (alt1) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:16:12: property[currScope]  						{  							DebugLocation (16' 12);  							PushFollow (Follow._property_in_block58);  							property (currScope);  							PopFollow ();  						}  						break;  					default:  						goto loop1;  					}  				}  				loop1:  				;  			}  			finally {  				DebugExitSubRule (1);  			}  			Match (input' TokenTypes.Up' null);  		}  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("block"' 2);  	LeaveRule ("block"' 2);  	LeaveRule_block ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,block,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:16:2: ( ^( BLOCK ( property[currScope] )* ) )  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:16:4: ^( BLOCK ( property[currScope] )* )  	{  		DebugLocation (16' 4);  		DebugLocation (16' 6);  		Match (input' BLOCK' Follow._BLOCK_in_block56);  		if (input.LA (1) == TokenTypes.Down) {  			Match (input' TokenTypes.Down' null);  			DebugLocation (16' 12);  			// ./src/Parser/Grammar/JFLWalker.g:16:12: ( property[currScope] )*  			try {  				DebugEnterSubRule (1);  				while (true) {  					int alt1 = 2;  					try {  						DebugEnterDecision (1' false);  						int LA1_1 = input.LA (1);  						if ((LA1_1 == ESC_ID || LA1_1 == ID || LA1_1 == REGEX || LA1_1 == 27)) {  							alt1 = 1;  						}  					}  					finally {  						DebugExitDecision (1);  					}  					switch (alt1) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:16:12: property[currScope]  						{  							DebugLocation (16' 12);  							PushFollow (Follow._property_in_block58);  							property (currScope);  							PopFollow ();  						}  						break;  					default:  						goto loop1;  					}  				}  				loop1:  				;  			}  			finally {  				DebugExitSubRule (1);  			}  			Match (input' TokenTypes.Up' null);  		}  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("block"' 2);  	LeaveRule ("block"' 2);  	LeaveRule_block ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,block,The following statement contains a magic number: DebugLocation (16' 4);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,block,The following statement contains a magic number: DebugLocation (16' 4);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,block,The following statement contains a magic number: DebugLocation (16' 6);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,block,The following statement contains a magic number: DebugLocation (16' 6);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,block,The following statement contains a magic number: if (input.LA (1) == TokenTypes.Down) {  	Match (input' TokenTypes.Down' null);  	DebugLocation (16' 12);  	// ./src/Parser/Grammar/JFLWalker.g:16:12: ( property[currScope] )*  	try {  		DebugEnterSubRule (1);  		while (true) {  			int alt1 = 2;  			try {  				DebugEnterDecision (1' false);  				int LA1_1 = input.LA (1);  				if ((LA1_1 == ESC_ID || LA1_1 == ID || LA1_1 == REGEX || LA1_1 == 27)) {  					alt1 = 1;  				}  			}  			finally {  				DebugExitDecision (1);  			}  			switch (alt1) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:16:12: property[currScope]  				{  					DebugLocation (16' 12);  					PushFollow (Follow._property_in_block58);  					property (currScope);  					PopFollow ();  				}  				break;  			default:  				goto loop1;  			}  		}  		loop1:  		;  	}  	finally {  		DebugExitSubRule (1);  	}  	Match (input' TokenTypes.Up' null);  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,block,The following statement contains a magic number: if (input.LA (1) == TokenTypes.Down) {  	Match (input' TokenTypes.Down' null);  	DebugLocation (16' 12);  	// ./src/Parser/Grammar/JFLWalker.g:16:12: ( property[currScope] )*  	try {  		DebugEnterSubRule (1);  		while (true) {  			int alt1 = 2;  			try {  				DebugEnterDecision (1' false);  				int LA1_1 = input.LA (1);  				if ((LA1_1 == ESC_ID || LA1_1 == ID || LA1_1 == REGEX || LA1_1 == 27)) {  					alt1 = 1;  				}  			}  			finally {  				DebugExitDecision (1);  			}  			switch (alt1) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:16:12: property[currScope]  				{  					DebugLocation (16' 12);  					PushFollow (Follow._property_in_block58);  					property (currScope);  					PopFollow ();  				}  				break;  			default:  				goto loop1;  			}  		}  		loop1:  		;  	}  	finally {  		DebugExitSubRule (1);  	}  	Match (input' TokenTypes.Up' null);  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,block,The following statement contains a magic number: if (input.LA (1) == TokenTypes.Down) {  	Match (input' TokenTypes.Down' null);  	DebugLocation (16' 12);  	// ./src/Parser/Grammar/JFLWalker.g:16:12: ( property[currScope] )*  	try {  		DebugEnterSubRule (1);  		while (true) {  			int alt1 = 2;  			try {  				DebugEnterDecision (1' false);  				int LA1_1 = input.LA (1);  				if ((LA1_1 == ESC_ID || LA1_1 == ID || LA1_1 == REGEX || LA1_1 == 27)) {  					alt1 = 1;  				}  			}  			finally {  				DebugExitDecision (1);  			}  			switch (alt1) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:16:12: property[currScope]  				{  					DebugLocation (16' 12);  					PushFollow (Follow._property_in_block58);  					property (currScope);  					PopFollow ();  				}  				break;  			default:  				goto loop1;  			}  		}  		loop1:  		;  	}  	finally {  		DebugExitSubRule (1);  	}  	Match (input' TokenTypes.Up' null);  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,block,The following statement contains a magic number: if (input.LA (1) == TokenTypes.Down) {  	Match (input' TokenTypes.Down' null);  	DebugLocation (16' 12);  	// ./src/Parser/Grammar/JFLWalker.g:16:12: ( property[currScope] )*  	try {  		DebugEnterSubRule (1);  		while (true) {  			int alt1 = 2;  			try {  				DebugEnterDecision (1' false);  				int LA1_1 = input.LA (1);  				if ((LA1_1 == ESC_ID || LA1_1 == ID || LA1_1 == REGEX || LA1_1 == 27)) {  					alt1 = 1;  				}  			}  			finally {  				DebugExitDecision (1);  			}  			switch (alt1) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:16:12: property[currScope]  				{  					DebugLocation (16' 12);  					PushFollow (Follow._property_in_block58);  					property (currScope);  					PopFollow ();  				}  				break;  			default:  				goto loop1;  			}  		}  		loop1:  		;  	}  	finally {  		DebugExitSubRule (1);  	}  	Match (input' TokenTypes.Up' null);  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,block,The following statement contains a magic number: if (input.LA (1) == TokenTypes.Down) {  	Match (input' TokenTypes.Down' null);  	DebugLocation (16' 12);  	// ./src/Parser/Grammar/JFLWalker.g:16:12: ( property[currScope] )*  	try {  		DebugEnterSubRule (1);  		while (true) {  			int alt1 = 2;  			try {  				DebugEnterDecision (1' false);  				int LA1_1 = input.LA (1);  				if ((LA1_1 == ESC_ID || LA1_1 == ID || LA1_1 == REGEX || LA1_1 == 27)) {  					alt1 = 1;  				}  			}  			finally {  				DebugExitDecision (1);  			}  			switch (alt1) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:16:12: property[currScope]  				{  					DebugLocation (16' 12);  					PushFollow (Follow._property_in_block58);  					property (currScope);  					PopFollow ();  				}  				break;  			default:  				goto loop1;  			}  		}  		loop1:  		;  	}  	finally {  		DebugExitSubRule (1);  	}  	Match (input' TokenTypes.Up' null);  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,block,The following statement contains a magic number: if (input.LA (1) == TokenTypes.Down) {  	Match (input' TokenTypes.Down' null);  	DebugLocation (16' 12);  	// ./src/Parser/Grammar/JFLWalker.g:16:12: ( property[currScope] )*  	try {  		DebugEnterSubRule (1);  		while (true) {  			int alt1 = 2;  			try {  				DebugEnterDecision (1' false);  				int LA1_1 = input.LA (1);  				if ((LA1_1 == ESC_ID || LA1_1 == ID || LA1_1 == REGEX || LA1_1 == 27)) {  					alt1 = 1;  				}  			}  			finally {  				DebugExitDecision (1);  			}  			switch (alt1) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:16:12: property[currScope]  				{  					DebugLocation (16' 12);  					PushFollow (Follow._property_in_block58);  					property (currScope);  					PopFollow ();  				}  				break;  			default:  				goto loop1;  			}  		}  		loop1:  		;  	}  	finally {  		DebugExitSubRule (1);  	}  	Match (input' TokenTypes.Up' null);  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,block,The following statement contains a magic number: DebugLocation (16' 12);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,block,The following statement contains a magic number: DebugLocation (16' 12);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,block,The following statement contains a magic number: try {  	DebugEnterSubRule (1);  	while (true) {  		int alt1 = 2;  		try {  			DebugEnterDecision (1' false);  			int LA1_1 = input.LA (1);  			if ((LA1_1 == ESC_ID || LA1_1 == ID || LA1_1 == REGEX || LA1_1 == 27)) {  				alt1 = 1;  			}  		}  		finally {  			DebugExitDecision (1);  		}  		switch (alt1) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:16:12: property[currScope]  			{  				DebugLocation (16' 12);  				PushFollow (Follow._property_in_block58);  				property (currScope);  				PopFollow ();  			}  			break;  		default:  			goto loop1;  		}  	}  	loop1:  	;  }  finally {  	DebugExitSubRule (1);  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,block,The following statement contains a magic number: try {  	DebugEnterSubRule (1);  	while (true) {  		int alt1 = 2;  		try {  			DebugEnterDecision (1' false);  			int LA1_1 = input.LA (1);  			if ((LA1_1 == ESC_ID || LA1_1 == ID || LA1_1 == REGEX || LA1_1 == 27)) {  				alt1 = 1;  			}  		}  		finally {  			DebugExitDecision (1);  		}  		switch (alt1) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:16:12: property[currScope]  			{  				DebugLocation (16' 12);  				PushFollow (Follow._property_in_block58);  				property (currScope);  				PopFollow ();  			}  			break;  		default:  			goto loop1;  		}  	}  	loop1:  	;  }  finally {  	DebugExitSubRule (1);  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,block,The following statement contains a magic number: try {  	DebugEnterSubRule (1);  	while (true) {  		int alt1 = 2;  		try {  			DebugEnterDecision (1' false);  			int LA1_1 = input.LA (1);  			if ((LA1_1 == ESC_ID || LA1_1 == ID || LA1_1 == REGEX || LA1_1 == 27)) {  				alt1 = 1;  			}  		}  		finally {  			DebugExitDecision (1);  		}  		switch (alt1) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:16:12: property[currScope]  			{  				DebugLocation (16' 12);  				PushFollow (Follow._property_in_block58);  				property (currScope);  				PopFollow ();  			}  			break;  		default:  			goto loop1;  		}  	}  	loop1:  	;  }  finally {  	DebugExitSubRule (1);  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,block,The following statement contains a magic number: try {  	DebugEnterSubRule (1);  	while (true) {  		int alt1 = 2;  		try {  			DebugEnterDecision (1' false);  			int LA1_1 = input.LA (1);  			if ((LA1_1 == ESC_ID || LA1_1 == ID || LA1_1 == REGEX || LA1_1 == 27)) {  				alt1 = 1;  			}  		}  		finally {  			DebugExitDecision (1);  		}  		switch (alt1) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:16:12: property[currScope]  			{  				DebugLocation (16' 12);  				PushFollow (Follow._property_in_block58);  				property (currScope);  				PopFollow ();  			}  			break;  		default:  			goto loop1;  		}  	}  	loop1:  	;  }  finally {  	DebugExitSubRule (1);  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,block,The following statement contains a magic number: while (true) {  	int alt1 = 2;  	try {  		DebugEnterDecision (1' false);  		int LA1_1 = input.LA (1);  		if ((LA1_1 == ESC_ID || LA1_1 == ID || LA1_1 == REGEX || LA1_1 == 27)) {  			alt1 = 1;  		}  	}  	finally {  		DebugExitDecision (1);  	}  	switch (alt1) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:16:12: property[currScope]  		{  			DebugLocation (16' 12);  			PushFollow (Follow._property_in_block58);  			property (currScope);  			PopFollow ();  		}  		break;  	default:  		goto loop1;  	}  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,block,The following statement contains a magic number: while (true) {  	int alt1 = 2;  	try {  		DebugEnterDecision (1' false);  		int LA1_1 = input.LA (1);  		if ((LA1_1 == ESC_ID || LA1_1 == ID || LA1_1 == REGEX || LA1_1 == 27)) {  			alt1 = 1;  		}  	}  	finally {  		DebugExitDecision (1);  	}  	switch (alt1) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:16:12: property[currScope]  		{  			DebugLocation (16' 12);  			PushFollow (Follow._property_in_block58);  			property (currScope);  			PopFollow ();  		}  		break;  	default:  		goto loop1;  	}  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,block,The following statement contains a magic number: while (true) {  	int alt1 = 2;  	try {  		DebugEnterDecision (1' false);  		int LA1_1 = input.LA (1);  		if ((LA1_1 == ESC_ID || LA1_1 == ID || LA1_1 == REGEX || LA1_1 == 27)) {  			alt1 = 1;  		}  	}  	finally {  		DebugExitDecision (1);  	}  	switch (alt1) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:16:12: property[currScope]  		{  			DebugLocation (16' 12);  			PushFollow (Follow._property_in_block58);  			property (currScope);  			PopFollow ();  		}  		break;  	default:  		goto loop1;  	}  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,block,The following statement contains a magic number: while (true) {  	int alt1 = 2;  	try {  		DebugEnterDecision (1' false);  		int LA1_1 = input.LA (1);  		if ((LA1_1 == ESC_ID || LA1_1 == ID || LA1_1 == REGEX || LA1_1 == 27)) {  			alt1 = 1;  		}  	}  	finally {  		DebugExitDecision (1);  	}  	switch (alt1) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:16:12: property[currScope]  		{  			DebugLocation (16' 12);  			PushFollow (Follow._property_in_block58);  			property (currScope);  			PopFollow ();  		}  		break;  	default:  		goto loop1;  	}  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,block,The following statement contains a magic number: try {  	DebugEnterDecision (1' false);  	int LA1_1 = input.LA (1);  	if ((LA1_1 == ESC_ID || LA1_1 == ID || LA1_1 == REGEX || LA1_1 == 27)) {  		alt1 = 1;  	}  }  finally {  	DebugExitDecision (1);  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,block,The following statement contains a magic number: if ((LA1_1 == ESC_ID || LA1_1 == ID || LA1_1 == REGEX || LA1_1 == 27)) {  	alt1 = 1;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,block,The following statement contains a magic number: switch (alt1) {  case 1:  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:16:12: property[currScope]  	{  		DebugLocation (16' 12);  		PushFollow (Follow._property_in_block58);  		property (currScope);  		PopFollow ();  	}  	break;  default:  	goto loop1;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,block,The following statement contains a magic number: switch (alt1) {  case 1:  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:16:12: property[currScope]  	{  		DebugLocation (16' 12);  		PushFollow (Follow._property_in_block58);  		property (currScope);  		PopFollow ();  	}  	break;  default:  	goto loop1;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,block,The following statement contains a magic number: DebugLocation (16' 12);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,block,The following statement contains a magic number: DebugLocation (16' 12);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,block,The following statement contains a magic number: TraceOut ("block"' 2);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,block,The following statement contains a magic number: LeaveRule ("block"' 2);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,block,The following statement contains a magic number: DebugLocation (17' 1);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,property,The following statement contains a magic number: EnterRule ("property"' 3);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,property,The following statement contains a magic number: TraceIn ("property"' 3);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,property,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "property");  	DebugLocation (19' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:23:2: ( ^( propertyName (not= '!' )? ( filter[newProperty] )? ( block[newProperty] )? ) )  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:23:4: ^( propertyName (not= '!' )? ( filter[newProperty] )? ( block[newProperty] )? )  		{  			DebugLocation (23' 4);  			DebugLocation (23' 6);  			PushFollow (Follow._propertyName_in_property80);  			propertyName1 = propertyName ();  			PopFollow ();  			if (input.LA (1) == TokenTypes.Down) {  				Match (input' TokenTypes.Down' null);  				DebugLocation (23' 22);  				// ./src/Parser/Grammar/JFLWalker.g:23:22: (not= '!' )?  				int alt2 = 2;  				try {  					DebugEnterSubRule (2);  					try {  						DebugEnterDecision (2' false);  						int LA2_1 = input.LA (1);  						if ((LA2_1 == 24)) {  							alt2 = 1;  						}  					}  					finally {  						DebugExitDecision (2);  					}  					switch (alt2) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:23:22: not= '!'  						{  							DebugLocation (23' 22);  							not = (CommonTree)Match (input' 24' Follow._24_in_property84);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (2);  				}  				DebugLocation (23' 28);  				// ./src/Parser/Grammar/JFLWalker.g:23:28: ( filter[newProperty] )?  				int alt3 = 2;  				try {  					DebugEnterSubRule (3);  					try {  						DebugEnterDecision (3' false);  						int LA3_1 = input.LA (1);  						if ((LA3_1 == FILTER)) {  							alt3 = 1;  						}  					}  					finally {  						DebugExitDecision (3);  					}  					switch (alt3) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:23:28: filter[newProperty]  						{  							DebugLocation (23' 28);  							PushFollow (Follow._filter_in_property87);  							filter (newProperty);  							PopFollow ();  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (3);  				}  				DebugLocation (23' 49);  				// ./src/Parser/Grammar/JFLWalker.g:23:49: ( block[newProperty] )?  				int alt4 = 2;  				try {  					DebugEnterSubRule (4);  					try {  						DebugEnterDecision (4' false);  						int LA4_1 = input.LA (1);  						if ((LA4_1 == BLOCK)) {  							alt4 = 1;  						}  					}  					finally {  						DebugExitDecision (4);  					}  					switch (alt4) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:23:49: block[newProperty]  						{  							DebugLocation (23' 49);  							PushFollow (Follow._block_in_property91);  							block (newProperty);  							PopFollow ();  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (4);  				}  				Match (input' TokenTypes.Up' null);  			}  			DebugLocation (23' 70);  			if ((not != null ? not.Text : default(string)) == "!")  				newProperty.ToggleInclude ();  			if ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).isRegex : default(bool)))  				parentScope.AddRegexProperty ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).name : default(string))' newProperty);  			else  				parentScope.AddProperty ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).name : default(string))' newProperty);  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("property"' 3);  		LeaveRule ("property"' 3);  		LeaveRule_property ();  	}  	DebugLocation (31' 1);  }  finally {  	DebugExitRule (GrammarFileName' "property");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,property,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "property");  	DebugLocation (19' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:23:2: ( ^( propertyName (not= '!' )? ( filter[newProperty] )? ( block[newProperty] )? ) )  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:23:4: ^( propertyName (not= '!' )? ( filter[newProperty] )? ( block[newProperty] )? )  		{  			DebugLocation (23' 4);  			DebugLocation (23' 6);  			PushFollow (Follow._propertyName_in_property80);  			propertyName1 = propertyName ();  			PopFollow ();  			if (input.LA (1) == TokenTypes.Down) {  				Match (input' TokenTypes.Down' null);  				DebugLocation (23' 22);  				// ./src/Parser/Grammar/JFLWalker.g:23:22: (not= '!' )?  				int alt2 = 2;  				try {  					DebugEnterSubRule (2);  					try {  						DebugEnterDecision (2' false);  						int LA2_1 = input.LA (1);  						if ((LA2_1 == 24)) {  							alt2 = 1;  						}  					}  					finally {  						DebugExitDecision (2);  					}  					switch (alt2) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:23:22: not= '!'  						{  							DebugLocation (23' 22);  							not = (CommonTree)Match (input' 24' Follow._24_in_property84);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (2);  				}  				DebugLocation (23' 28);  				// ./src/Parser/Grammar/JFLWalker.g:23:28: ( filter[newProperty] )?  				int alt3 = 2;  				try {  					DebugEnterSubRule (3);  					try {  						DebugEnterDecision (3' false);  						int LA3_1 = input.LA (1);  						if ((LA3_1 == FILTER)) {  							alt3 = 1;  						}  					}  					finally {  						DebugExitDecision (3);  					}  					switch (alt3) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:23:28: filter[newProperty]  						{  							DebugLocation (23' 28);  							PushFollow (Follow._filter_in_property87);  							filter (newProperty);  							PopFollow ();  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (3);  				}  				DebugLocation (23' 49);  				// ./src/Parser/Grammar/JFLWalker.g:23:49: ( block[newProperty] )?  				int alt4 = 2;  				try {  					DebugEnterSubRule (4);  					try {  						DebugEnterDecision (4' false);  						int LA4_1 = input.LA (1);  						if ((LA4_1 == BLOCK)) {  							alt4 = 1;  						}  					}  					finally {  						DebugExitDecision (4);  					}  					switch (alt4) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:23:49: block[newProperty]  						{  							DebugLocation (23' 49);  							PushFollow (Follow._block_in_property91);  							block (newProperty);  							PopFollow ();  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (4);  				}  				Match (input' TokenTypes.Up' null);  			}  			DebugLocation (23' 70);  			if ((not != null ? not.Text : default(string)) == "!")  				newProperty.ToggleInclude ();  			if ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).isRegex : default(bool)))  				parentScope.AddRegexProperty ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).name : default(string))' newProperty);  			else  				parentScope.AddProperty ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).name : default(string))' newProperty);  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("property"' 3);  		LeaveRule ("property"' 3);  		LeaveRule_property ();  	}  	DebugLocation (31' 1);  }  finally {  	DebugExitRule (GrammarFileName' "property");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,property,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "property");  	DebugLocation (19' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:23:2: ( ^( propertyName (not= '!' )? ( filter[newProperty] )? ( block[newProperty] )? ) )  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:23:4: ^( propertyName (not= '!' )? ( filter[newProperty] )? ( block[newProperty] )? )  		{  			DebugLocation (23' 4);  			DebugLocation (23' 6);  			PushFollow (Follow._propertyName_in_property80);  			propertyName1 = propertyName ();  			PopFollow ();  			if (input.LA (1) == TokenTypes.Down) {  				Match (input' TokenTypes.Down' null);  				DebugLocation (23' 22);  				// ./src/Parser/Grammar/JFLWalker.g:23:22: (not= '!' )?  				int alt2 = 2;  				try {  					DebugEnterSubRule (2);  					try {  						DebugEnterDecision (2' false);  						int LA2_1 = input.LA (1);  						if ((LA2_1 == 24)) {  							alt2 = 1;  						}  					}  					finally {  						DebugExitDecision (2);  					}  					switch (alt2) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:23:22: not= '!'  						{  							DebugLocation (23' 22);  							not = (CommonTree)Match (input' 24' Follow._24_in_property84);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (2);  				}  				DebugLocation (23' 28);  				// ./src/Parser/Grammar/JFLWalker.g:23:28: ( filter[newProperty] )?  				int alt3 = 2;  				try {  					DebugEnterSubRule (3);  					try {  						DebugEnterDecision (3' false);  						int LA3_1 = input.LA (1);  						if ((LA3_1 == FILTER)) {  							alt3 = 1;  						}  					}  					finally {  						DebugExitDecision (3);  					}  					switch (alt3) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:23:28: filter[newProperty]  						{  							DebugLocation (23' 28);  							PushFollow (Follow._filter_in_property87);  							filter (newProperty);  							PopFollow ();  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (3);  				}  				DebugLocation (23' 49);  				// ./src/Parser/Grammar/JFLWalker.g:23:49: ( block[newProperty] )?  				int alt4 = 2;  				try {  					DebugEnterSubRule (4);  					try {  						DebugEnterDecision (4' false);  						int LA4_1 = input.LA (1);  						if ((LA4_1 == BLOCK)) {  							alt4 = 1;  						}  					}  					finally {  						DebugExitDecision (4);  					}  					switch (alt4) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:23:49: block[newProperty]  						{  							DebugLocation (23' 49);  							PushFollow (Follow._block_in_property91);  							block (newProperty);  							PopFollow ();  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (4);  				}  				Match (input' TokenTypes.Up' null);  			}  			DebugLocation (23' 70);  			if ((not != null ? not.Text : default(string)) == "!")  				newProperty.ToggleInclude ();  			if ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).isRegex : default(bool)))  				parentScope.AddRegexProperty ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).name : default(string))' newProperty);  			else  				parentScope.AddProperty ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).name : default(string))' newProperty);  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("property"' 3);  		LeaveRule ("property"' 3);  		LeaveRule_property ();  	}  	DebugLocation (31' 1);  }  finally {  	DebugExitRule (GrammarFileName' "property");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,property,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "property");  	DebugLocation (19' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:23:2: ( ^( propertyName (not= '!' )? ( filter[newProperty] )? ( block[newProperty] )? ) )  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:23:4: ^( propertyName (not= '!' )? ( filter[newProperty] )? ( block[newProperty] )? )  		{  			DebugLocation (23' 4);  			DebugLocation (23' 6);  			PushFollow (Follow._propertyName_in_property80);  			propertyName1 = propertyName ();  			PopFollow ();  			if (input.LA (1) == TokenTypes.Down) {  				Match (input' TokenTypes.Down' null);  				DebugLocation (23' 22);  				// ./src/Parser/Grammar/JFLWalker.g:23:22: (not= '!' )?  				int alt2 = 2;  				try {  					DebugEnterSubRule (2);  					try {  						DebugEnterDecision (2' false);  						int LA2_1 = input.LA (1);  						if ((LA2_1 == 24)) {  							alt2 = 1;  						}  					}  					finally {  						DebugExitDecision (2);  					}  					switch (alt2) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:23:22: not= '!'  						{  							DebugLocation (23' 22);  							not = (CommonTree)Match (input' 24' Follow._24_in_property84);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (2);  				}  				DebugLocation (23' 28);  				// ./src/Parser/Grammar/JFLWalker.g:23:28: ( filter[newProperty] )?  				int alt3 = 2;  				try {  					DebugEnterSubRule (3);  					try {  						DebugEnterDecision (3' false);  						int LA3_1 = input.LA (1);  						if ((LA3_1 == FILTER)) {  							alt3 = 1;  						}  					}  					finally {  						DebugExitDecision (3);  					}  					switch (alt3) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:23:28: filter[newProperty]  						{  							DebugLocation (23' 28);  							PushFollow (Follow._filter_in_property87);  							filter (newProperty);  							PopFollow ();  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (3);  				}  				DebugLocation (23' 49);  				// ./src/Parser/Grammar/JFLWalker.g:23:49: ( block[newProperty] )?  				int alt4 = 2;  				try {  					DebugEnterSubRule (4);  					try {  						DebugEnterDecision (4' false);  						int LA4_1 = input.LA (1);  						if ((LA4_1 == BLOCK)) {  							alt4 = 1;  						}  					}  					finally {  						DebugExitDecision (4);  					}  					switch (alt4) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:23:49: block[newProperty]  						{  							DebugLocation (23' 49);  							PushFollow (Follow._block_in_property91);  							block (newProperty);  							PopFollow ();  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (4);  				}  				Match (input' TokenTypes.Up' null);  			}  			DebugLocation (23' 70);  			if ((not != null ? not.Text : default(string)) == "!")  				newProperty.ToggleInclude ();  			if ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).isRegex : default(bool)))  				parentScope.AddRegexProperty ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).name : default(string))' newProperty);  			else  				parentScope.AddProperty ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).name : default(string))' newProperty);  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("property"' 3);  		LeaveRule ("property"' 3);  		LeaveRule_property ();  	}  	DebugLocation (31' 1);  }  finally {  	DebugExitRule (GrammarFileName' "property");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,property,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "property");  	DebugLocation (19' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:23:2: ( ^( propertyName (not= '!' )? ( filter[newProperty] )? ( block[newProperty] )? ) )  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:23:4: ^( propertyName (not= '!' )? ( filter[newProperty] )? ( block[newProperty] )? )  		{  			DebugLocation (23' 4);  			DebugLocation (23' 6);  			PushFollow (Follow._propertyName_in_property80);  			propertyName1 = propertyName ();  			PopFollow ();  			if (input.LA (1) == TokenTypes.Down) {  				Match (input' TokenTypes.Down' null);  				DebugLocation (23' 22);  				// ./src/Parser/Grammar/JFLWalker.g:23:22: (not= '!' )?  				int alt2 = 2;  				try {  					DebugEnterSubRule (2);  					try {  						DebugEnterDecision (2' false);  						int LA2_1 = input.LA (1);  						if ((LA2_1 == 24)) {  							alt2 = 1;  						}  					}  					finally {  						DebugExitDecision (2);  					}  					switch (alt2) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:23:22: not= '!'  						{  							DebugLocation (23' 22);  							not = (CommonTree)Match (input' 24' Follow._24_in_property84);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (2);  				}  				DebugLocation (23' 28);  				// ./src/Parser/Grammar/JFLWalker.g:23:28: ( filter[newProperty] )?  				int alt3 = 2;  				try {  					DebugEnterSubRule (3);  					try {  						DebugEnterDecision (3' false);  						int LA3_1 = input.LA (1);  						if ((LA3_1 == FILTER)) {  							alt3 = 1;  						}  					}  					finally {  						DebugExitDecision (3);  					}  					switch (alt3) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:23:28: filter[newProperty]  						{  							DebugLocation (23' 28);  							PushFollow (Follow._filter_in_property87);  							filter (newProperty);  							PopFollow ();  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (3);  				}  				DebugLocation (23' 49);  				// ./src/Parser/Grammar/JFLWalker.g:23:49: ( block[newProperty] )?  				int alt4 = 2;  				try {  					DebugEnterSubRule (4);  					try {  						DebugEnterDecision (4' false);  						int LA4_1 = input.LA (1);  						if ((LA4_1 == BLOCK)) {  							alt4 = 1;  						}  					}  					finally {  						DebugExitDecision (4);  					}  					switch (alt4) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:23:49: block[newProperty]  						{  							DebugLocation (23' 49);  							PushFollow (Follow._block_in_property91);  							block (newProperty);  							PopFollow ();  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (4);  				}  				Match (input' TokenTypes.Up' null);  			}  			DebugLocation (23' 70);  			if ((not != null ? not.Text : default(string)) == "!")  				newProperty.ToggleInclude ();  			if ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).isRegex : default(bool)))  				parentScope.AddRegexProperty ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).name : default(string))' newProperty);  			else  				parentScope.AddProperty ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).name : default(string))' newProperty);  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("property"' 3);  		LeaveRule ("property"' 3);  		LeaveRule_property ();  	}  	DebugLocation (31' 1);  }  finally {  	DebugExitRule (GrammarFileName' "property");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,property,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "property");  	DebugLocation (19' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:23:2: ( ^( propertyName (not= '!' )? ( filter[newProperty] )? ( block[newProperty] )? ) )  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:23:4: ^( propertyName (not= '!' )? ( filter[newProperty] )? ( block[newProperty] )? )  		{  			DebugLocation (23' 4);  			DebugLocation (23' 6);  			PushFollow (Follow._propertyName_in_property80);  			propertyName1 = propertyName ();  			PopFollow ();  			if (input.LA (1) == TokenTypes.Down) {  				Match (input' TokenTypes.Down' null);  				DebugLocation (23' 22);  				// ./src/Parser/Grammar/JFLWalker.g:23:22: (not= '!' )?  				int alt2 = 2;  				try {  					DebugEnterSubRule (2);  					try {  						DebugEnterDecision (2' false);  						int LA2_1 = input.LA (1);  						if ((LA2_1 == 24)) {  							alt2 = 1;  						}  					}  					finally {  						DebugExitDecision (2);  					}  					switch (alt2) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:23:22: not= '!'  						{  							DebugLocation (23' 22);  							not = (CommonTree)Match (input' 24' Follow._24_in_property84);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (2);  				}  				DebugLocation (23' 28);  				// ./src/Parser/Grammar/JFLWalker.g:23:28: ( filter[newProperty] )?  				int alt3 = 2;  				try {  					DebugEnterSubRule (3);  					try {  						DebugEnterDecision (3' false);  						int LA3_1 = input.LA (1);  						if ((LA3_1 == FILTER)) {  							alt3 = 1;  						}  					}  					finally {  						DebugExitDecision (3);  					}  					switch (alt3) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:23:28: filter[newProperty]  						{  							DebugLocation (23' 28);  							PushFollow (Follow._filter_in_property87);  							filter (newProperty);  							PopFollow ();  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (3);  				}  				DebugLocation (23' 49);  				// ./src/Parser/Grammar/JFLWalker.g:23:49: ( block[newProperty] )?  				int alt4 = 2;  				try {  					DebugEnterSubRule (4);  					try {  						DebugEnterDecision (4' false);  						int LA4_1 = input.LA (1);  						if ((LA4_1 == BLOCK)) {  							alt4 = 1;  						}  					}  					finally {  						DebugExitDecision (4);  					}  					switch (alt4) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:23:49: block[newProperty]  						{  							DebugLocation (23' 49);  							PushFollow (Follow._block_in_property91);  							block (newProperty);  							PopFollow ();  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (4);  				}  				Match (input' TokenTypes.Up' null);  			}  			DebugLocation (23' 70);  			if ((not != null ? not.Text : default(string)) == "!")  				newProperty.ToggleInclude ();  			if ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).isRegex : default(bool)))  				parentScope.AddRegexProperty ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).name : default(string))' newProperty);  			else  				parentScope.AddProperty ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).name : default(string))' newProperty);  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("property"' 3);  		LeaveRule ("property"' 3);  		LeaveRule_property ();  	}  	DebugLocation (31' 1);  }  finally {  	DebugExitRule (GrammarFileName' "property");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,property,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "property");  	DebugLocation (19' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:23:2: ( ^( propertyName (not= '!' )? ( filter[newProperty] )? ( block[newProperty] )? ) )  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:23:4: ^( propertyName (not= '!' )? ( filter[newProperty] )? ( block[newProperty] )? )  		{  			DebugLocation (23' 4);  			DebugLocation (23' 6);  			PushFollow (Follow._propertyName_in_property80);  			propertyName1 = propertyName ();  			PopFollow ();  			if (input.LA (1) == TokenTypes.Down) {  				Match (input' TokenTypes.Down' null);  				DebugLocation (23' 22);  				// ./src/Parser/Grammar/JFLWalker.g:23:22: (not= '!' )?  				int alt2 = 2;  				try {  					DebugEnterSubRule (2);  					try {  						DebugEnterDecision (2' false);  						int LA2_1 = input.LA (1);  						if ((LA2_1 == 24)) {  							alt2 = 1;  						}  					}  					finally {  						DebugExitDecision (2);  					}  					switch (alt2) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:23:22: not= '!'  						{  							DebugLocation (23' 22);  							not = (CommonTree)Match (input' 24' Follow._24_in_property84);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (2);  				}  				DebugLocation (23' 28);  				// ./src/Parser/Grammar/JFLWalker.g:23:28: ( filter[newProperty] )?  				int alt3 = 2;  				try {  					DebugEnterSubRule (3);  					try {  						DebugEnterDecision (3' false);  						int LA3_1 = input.LA (1);  						if ((LA3_1 == FILTER)) {  							alt3 = 1;  						}  					}  					finally {  						DebugExitDecision (3);  					}  					switch (alt3) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:23:28: filter[newProperty]  						{  							DebugLocation (23' 28);  							PushFollow (Follow._filter_in_property87);  							filter (newProperty);  							PopFollow ();  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (3);  				}  				DebugLocation (23' 49);  				// ./src/Parser/Grammar/JFLWalker.g:23:49: ( block[newProperty] )?  				int alt4 = 2;  				try {  					DebugEnterSubRule (4);  					try {  						DebugEnterDecision (4' false);  						int LA4_1 = input.LA (1);  						if ((LA4_1 == BLOCK)) {  							alt4 = 1;  						}  					}  					finally {  						DebugExitDecision (4);  					}  					switch (alt4) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:23:49: block[newProperty]  						{  							DebugLocation (23' 49);  							PushFollow (Follow._block_in_property91);  							block (newProperty);  							PopFollow ();  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (4);  				}  				Match (input' TokenTypes.Up' null);  			}  			DebugLocation (23' 70);  			if ((not != null ? not.Text : default(string)) == "!")  				newProperty.ToggleInclude ();  			if ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).isRegex : default(bool)))  				parentScope.AddRegexProperty ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).name : default(string))' newProperty);  			else  				parentScope.AddProperty ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).name : default(string))' newProperty);  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("property"' 3);  		LeaveRule ("property"' 3);  		LeaveRule_property ();  	}  	DebugLocation (31' 1);  }  finally {  	DebugExitRule (GrammarFileName' "property");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,property,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "property");  	DebugLocation (19' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:23:2: ( ^( propertyName (not= '!' )? ( filter[newProperty] )? ( block[newProperty] )? ) )  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:23:4: ^( propertyName (not= '!' )? ( filter[newProperty] )? ( block[newProperty] )? )  		{  			DebugLocation (23' 4);  			DebugLocation (23' 6);  			PushFollow (Follow._propertyName_in_property80);  			propertyName1 = propertyName ();  			PopFollow ();  			if (input.LA (1) == TokenTypes.Down) {  				Match (input' TokenTypes.Down' null);  				DebugLocation (23' 22);  				// ./src/Parser/Grammar/JFLWalker.g:23:22: (not= '!' )?  				int alt2 = 2;  				try {  					DebugEnterSubRule (2);  					try {  						DebugEnterDecision (2' false);  						int LA2_1 = input.LA (1);  						if ((LA2_1 == 24)) {  							alt2 = 1;  						}  					}  					finally {  						DebugExitDecision (2);  					}  					switch (alt2) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:23:22: not= '!'  						{  							DebugLocation (23' 22);  							not = (CommonTree)Match (input' 24' Follow._24_in_property84);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (2);  				}  				DebugLocation (23' 28);  				// ./src/Parser/Grammar/JFLWalker.g:23:28: ( filter[newProperty] )?  				int alt3 = 2;  				try {  					DebugEnterSubRule (3);  					try {  						DebugEnterDecision (3' false);  						int LA3_1 = input.LA (1);  						if ((LA3_1 == FILTER)) {  							alt3 = 1;  						}  					}  					finally {  						DebugExitDecision (3);  					}  					switch (alt3) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:23:28: filter[newProperty]  						{  							DebugLocation (23' 28);  							PushFollow (Follow._filter_in_property87);  							filter (newProperty);  							PopFollow ();  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (3);  				}  				DebugLocation (23' 49);  				// ./src/Parser/Grammar/JFLWalker.g:23:49: ( block[newProperty] )?  				int alt4 = 2;  				try {  					DebugEnterSubRule (4);  					try {  						DebugEnterDecision (4' false);  						int LA4_1 = input.LA (1);  						if ((LA4_1 == BLOCK)) {  							alt4 = 1;  						}  					}  					finally {  						DebugExitDecision (4);  					}  					switch (alt4) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:23:49: block[newProperty]  						{  							DebugLocation (23' 49);  							PushFollow (Follow._block_in_property91);  							block (newProperty);  							PopFollow ();  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (4);  				}  				Match (input' TokenTypes.Up' null);  			}  			DebugLocation (23' 70);  			if ((not != null ? not.Text : default(string)) == "!")  				newProperty.ToggleInclude ();  			if ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).isRegex : default(bool)))  				parentScope.AddRegexProperty ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).name : default(string))' newProperty);  			else  				parentScope.AddProperty ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).name : default(string))' newProperty);  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("property"' 3);  		LeaveRule ("property"' 3);  		LeaveRule_property ();  	}  	DebugLocation (31' 1);  }  finally {  	DebugExitRule (GrammarFileName' "property");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,property,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "property");  	DebugLocation (19' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:23:2: ( ^( propertyName (not= '!' )? ( filter[newProperty] )? ( block[newProperty] )? ) )  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:23:4: ^( propertyName (not= '!' )? ( filter[newProperty] )? ( block[newProperty] )? )  		{  			DebugLocation (23' 4);  			DebugLocation (23' 6);  			PushFollow (Follow._propertyName_in_property80);  			propertyName1 = propertyName ();  			PopFollow ();  			if (input.LA (1) == TokenTypes.Down) {  				Match (input' TokenTypes.Down' null);  				DebugLocation (23' 22);  				// ./src/Parser/Grammar/JFLWalker.g:23:22: (not= '!' )?  				int alt2 = 2;  				try {  					DebugEnterSubRule (2);  					try {  						DebugEnterDecision (2' false);  						int LA2_1 = input.LA (1);  						if ((LA2_1 == 24)) {  							alt2 = 1;  						}  					}  					finally {  						DebugExitDecision (2);  					}  					switch (alt2) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:23:22: not= '!'  						{  							DebugLocation (23' 22);  							not = (CommonTree)Match (input' 24' Follow._24_in_property84);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (2);  				}  				DebugLocation (23' 28);  				// ./src/Parser/Grammar/JFLWalker.g:23:28: ( filter[newProperty] )?  				int alt3 = 2;  				try {  					DebugEnterSubRule (3);  					try {  						DebugEnterDecision (3' false);  						int LA3_1 = input.LA (1);  						if ((LA3_1 == FILTER)) {  							alt3 = 1;  						}  					}  					finally {  						DebugExitDecision (3);  					}  					switch (alt3) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:23:28: filter[newProperty]  						{  							DebugLocation (23' 28);  							PushFollow (Follow._filter_in_property87);  							filter (newProperty);  							PopFollow ();  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (3);  				}  				DebugLocation (23' 49);  				// ./src/Parser/Grammar/JFLWalker.g:23:49: ( block[newProperty] )?  				int alt4 = 2;  				try {  					DebugEnterSubRule (4);  					try {  						DebugEnterDecision (4' false);  						int LA4_1 = input.LA (1);  						if ((LA4_1 == BLOCK)) {  							alt4 = 1;  						}  					}  					finally {  						DebugExitDecision (4);  					}  					switch (alt4) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:23:49: block[newProperty]  						{  							DebugLocation (23' 49);  							PushFollow (Follow._block_in_property91);  							block (newProperty);  							PopFollow ();  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (4);  				}  				Match (input' TokenTypes.Up' null);  			}  			DebugLocation (23' 70);  			if ((not != null ? not.Text : default(string)) == "!")  				newProperty.ToggleInclude ();  			if ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).isRegex : default(bool)))  				parentScope.AddRegexProperty ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).name : default(string))' newProperty);  			else  				parentScope.AddProperty ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).name : default(string))' newProperty);  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("property"' 3);  		LeaveRule ("property"' 3);  		LeaveRule_property ();  	}  	DebugLocation (31' 1);  }  finally {  	DebugExitRule (GrammarFileName' "property");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,property,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "property");  	DebugLocation (19' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:23:2: ( ^( propertyName (not= '!' )? ( filter[newProperty] )? ( block[newProperty] )? ) )  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:23:4: ^( propertyName (not= '!' )? ( filter[newProperty] )? ( block[newProperty] )? )  		{  			DebugLocation (23' 4);  			DebugLocation (23' 6);  			PushFollow (Follow._propertyName_in_property80);  			propertyName1 = propertyName ();  			PopFollow ();  			if (input.LA (1) == TokenTypes.Down) {  				Match (input' TokenTypes.Down' null);  				DebugLocation (23' 22);  				// ./src/Parser/Grammar/JFLWalker.g:23:22: (not= '!' )?  				int alt2 = 2;  				try {  					DebugEnterSubRule (2);  					try {  						DebugEnterDecision (2' false);  						int LA2_1 = input.LA (1);  						if ((LA2_1 == 24)) {  							alt2 = 1;  						}  					}  					finally {  						DebugExitDecision (2);  					}  					switch (alt2) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:23:22: not= '!'  						{  							DebugLocation (23' 22);  							not = (CommonTree)Match (input' 24' Follow._24_in_property84);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (2);  				}  				DebugLocation (23' 28);  				// ./src/Parser/Grammar/JFLWalker.g:23:28: ( filter[newProperty] )?  				int alt3 = 2;  				try {  					DebugEnterSubRule (3);  					try {  						DebugEnterDecision (3' false);  						int LA3_1 = input.LA (1);  						if ((LA3_1 == FILTER)) {  							alt3 = 1;  						}  					}  					finally {  						DebugExitDecision (3);  					}  					switch (alt3) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:23:28: filter[newProperty]  						{  							DebugLocation (23' 28);  							PushFollow (Follow._filter_in_property87);  							filter (newProperty);  							PopFollow ();  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (3);  				}  				DebugLocation (23' 49);  				// ./src/Parser/Grammar/JFLWalker.g:23:49: ( block[newProperty] )?  				int alt4 = 2;  				try {  					DebugEnterSubRule (4);  					try {  						DebugEnterDecision (4' false);  						int LA4_1 = input.LA (1);  						if ((LA4_1 == BLOCK)) {  							alt4 = 1;  						}  					}  					finally {  						DebugExitDecision (4);  					}  					switch (alt4) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:23:49: block[newProperty]  						{  							DebugLocation (23' 49);  							PushFollow (Follow._block_in_property91);  							block (newProperty);  							PopFollow ();  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (4);  				}  				Match (input' TokenTypes.Up' null);  			}  			DebugLocation (23' 70);  			if ((not != null ? not.Text : default(string)) == "!")  				newProperty.ToggleInclude ();  			if ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).isRegex : default(bool)))  				parentScope.AddRegexProperty ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).name : default(string))' newProperty);  			else  				parentScope.AddProperty ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).name : default(string))' newProperty);  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("property"' 3);  		LeaveRule ("property"' 3);  		LeaveRule_property ();  	}  	DebugLocation (31' 1);  }  finally {  	DebugExitRule (GrammarFileName' "property");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,property,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "property");  	DebugLocation (19' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:23:2: ( ^( propertyName (not= '!' )? ( filter[newProperty] )? ( block[newProperty] )? ) )  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:23:4: ^( propertyName (not= '!' )? ( filter[newProperty] )? ( block[newProperty] )? )  		{  			DebugLocation (23' 4);  			DebugLocation (23' 6);  			PushFollow (Follow._propertyName_in_property80);  			propertyName1 = propertyName ();  			PopFollow ();  			if (input.LA (1) == TokenTypes.Down) {  				Match (input' TokenTypes.Down' null);  				DebugLocation (23' 22);  				// ./src/Parser/Grammar/JFLWalker.g:23:22: (not= '!' )?  				int alt2 = 2;  				try {  					DebugEnterSubRule (2);  					try {  						DebugEnterDecision (2' false);  						int LA2_1 = input.LA (1);  						if ((LA2_1 == 24)) {  							alt2 = 1;  						}  					}  					finally {  						DebugExitDecision (2);  					}  					switch (alt2) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:23:22: not= '!'  						{  							DebugLocation (23' 22);  							not = (CommonTree)Match (input' 24' Follow._24_in_property84);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (2);  				}  				DebugLocation (23' 28);  				// ./src/Parser/Grammar/JFLWalker.g:23:28: ( filter[newProperty] )?  				int alt3 = 2;  				try {  					DebugEnterSubRule (3);  					try {  						DebugEnterDecision (3' false);  						int LA3_1 = input.LA (1);  						if ((LA3_1 == FILTER)) {  							alt3 = 1;  						}  					}  					finally {  						DebugExitDecision (3);  					}  					switch (alt3) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:23:28: filter[newProperty]  						{  							DebugLocation (23' 28);  							PushFollow (Follow._filter_in_property87);  							filter (newProperty);  							PopFollow ();  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (3);  				}  				DebugLocation (23' 49);  				// ./src/Parser/Grammar/JFLWalker.g:23:49: ( block[newProperty] )?  				int alt4 = 2;  				try {  					DebugEnterSubRule (4);  					try {  						DebugEnterDecision (4' false);  						int LA4_1 = input.LA (1);  						if ((LA4_1 == BLOCK)) {  							alt4 = 1;  						}  					}  					finally {  						DebugExitDecision (4);  					}  					switch (alt4) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:23:49: block[newProperty]  						{  							DebugLocation (23' 49);  							PushFollow (Follow._block_in_property91);  							block (newProperty);  							PopFollow ();  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (4);  				}  				Match (input' TokenTypes.Up' null);  			}  			DebugLocation (23' 70);  			if ((not != null ? not.Text : default(string)) == "!")  				newProperty.ToggleInclude ();  			if ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).isRegex : default(bool)))  				parentScope.AddRegexProperty ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).name : default(string))' newProperty);  			else  				parentScope.AddProperty ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).name : default(string))' newProperty);  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("property"' 3);  		LeaveRule ("property"' 3);  		LeaveRule_property ();  	}  	DebugLocation (31' 1);  }  finally {  	DebugExitRule (GrammarFileName' "property");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,property,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "property");  	DebugLocation (19' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:23:2: ( ^( propertyName (not= '!' )? ( filter[newProperty] )? ( block[newProperty] )? ) )  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:23:4: ^( propertyName (not= '!' )? ( filter[newProperty] )? ( block[newProperty] )? )  		{  			DebugLocation (23' 4);  			DebugLocation (23' 6);  			PushFollow (Follow._propertyName_in_property80);  			propertyName1 = propertyName ();  			PopFollow ();  			if (input.LA (1) == TokenTypes.Down) {  				Match (input' TokenTypes.Down' null);  				DebugLocation (23' 22);  				// ./src/Parser/Grammar/JFLWalker.g:23:22: (not= '!' )?  				int alt2 = 2;  				try {  					DebugEnterSubRule (2);  					try {  						DebugEnterDecision (2' false);  						int LA2_1 = input.LA (1);  						if ((LA2_1 == 24)) {  							alt2 = 1;  						}  					}  					finally {  						DebugExitDecision (2);  					}  					switch (alt2) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:23:22: not= '!'  						{  							DebugLocation (23' 22);  							not = (CommonTree)Match (input' 24' Follow._24_in_property84);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (2);  				}  				DebugLocation (23' 28);  				// ./src/Parser/Grammar/JFLWalker.g:23:28: ( filter[newProperty] )?  				int alt3 = 2;  				try {  					DebugEnterSubRule (3);  					try {  						DebugEnterDecision (3' false);  						int LA3_1 = input.LA (1);  						if ((LA3_1 == FILTER)) {  							alt3 = 1;  						}  					}  					finally {  						DebugExitDecision (3);  					}  					switch (alt3) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:23:28: filter[newProperty]  						{  							DebugLocation (23' 28);  							PushFollow (Follow._filter_in_property87);  							filter (newProperty);  							PopFollow ();  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (3);  				}  				DebugLocation (23' 49);  				// ./src/Parser/Grammar/JFLWalker.g:23:49: ( block[newProperty] )?  				int alt4 = 2;  				try {  					DebugEnterSubRule (4);  					try {  						DebugEnterDecision (4' false);  						int LA4_1 = input.LA (1);  						if ((LA4_1 == BLOCK)) {  							alt4 = 1;  						}  					}  					finally {  						DebugExitDecision (4);  					}  					switch (alt4) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:23:49: block[newProperty]  						{  							DebugLocation (23' 49);  							PushFollow (Follow._block_in_property91);  							block (newProperty);  							PopFollow ();  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (4);  				}  				Match (input' TokenTypes.Up' null);  			}  			DebugLocation (23' 70);  			if ((not != null ? not.Text : default(string)) == "!")  				newProperty.ToggleInclude ();  			if ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).isRegex : default(bool)))  				parentScope.AddRegexProperty ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).name : default(string))' newProperty);  			else  				parentScope.AddProperty ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).name : default(string))' newProperty);  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("property"' 3);  		LeaveRule ("property"' 3);  		LeaveRule_property ();  	}  	DebugLocation (31' 1);  }  finally {  	DebugExitRule (GrammarFileName' "property");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,property,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "property");  	DebugLocation (19' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:23:2: ( ^( propertyName (not= '!' )? ( filter[newProperty] )? ( block[newProperty] )? ) )  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:23:4: ^( propertyName (not= '!' )? ( filter[newProperty] )? ( block[newProperty] )? )  		{  			DebugLocation (23' 4);  			DebugLocation (23' 6);  			PushFollow (Follow._propertyName_in_property80);  			propertyName1 = propertyName ();  			PopFollow ();  			if (input.LA (1) == TokenTypes.Down) {  				Match (input' TokenTypes.Down' null);  				DebugLocation (23' 22);  				// ./src/Parser/Grammar/JFLWalker.g:23:22: (not= '!' )?  				int alt2 = 2;  				try {  					DebugEnterSubRule (2);  					try {  						DebugEnterDecision (2' false);  						int LA2_1 = input.LA (1);  						if ((LA2_1 == 24)) {  							alt2 = 1;  						}  					}  					finally {  						DebugExitDecision (2);  					}  					switch (alt2) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:23:22: not= '!'  						{  							DebugLocation (23' 22);  							not = (CommonTree)Match (input' 24' Follow._24_in_property84);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (2);  				}  				DebugLocation (23' 28);  				// ./src/Parser/Grammar/JFLWalker.g:23:28: ( filter[newProperty] )?  				int alt3 = 2;  				try {  					DebugEnterSubRule (3);  					try {  						DebugEnterDecision (3' false);  						int LA3_1 = input.LA (1);  						if ((LA3_1 == FILTER)) {  							alt3 = 1;  						}  					}  					finally {  						DebugExitDecision (3);  					}  					switch (alt3) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:23:28: filter[newProperty]  						{  							DebugLocation (23' 28);  							PushFollow (Follow._filter_in_property87);  							filter (newProperty);  							PopFollow ();  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (3);  				}  				DebugLocation (23' 49);  				// ./src/Parser/Grammar/JFLWalker.g:23:49: ( block[newProperty] )?  				int alt4 = 2;  				try {  					DebugEnterSubRule (4);  					try {  						DebugEnterDecision (4' false);  						int LA4_1 = input.LA (1);  						if ((LA4_1 == BLOCK)) {  							alt4 = 1;  						}  					}  					finally {  						DebugExitDecision (4);  					}  					switch (alt4) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:23:49: block[newProperty]  						{  							DebugLocation (23' 49);  							PushFollow (Follow._block_in_property91);  							block (newProperty);  							PopFollow ();  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (4);  				}  				Match (input' TokenTypes.Up' null);  			}  			DebugLocation (23' 70);  			if ((not != null ? not.Text : default(string)) == "!")  				newProperty.ToggleInclude ();  			if ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).isRegex : default(bool)))  				parentScope.AddRegexProperty ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).name : default(string))' newProperty);  			else  				parentScope.AddProperty ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).name : default(string))' newProperty);  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("property"' 3);  		LeaveRule ("property"' 3);  		LeaveRule_property ();  	}  	DebugLocation (31' 1);  }  finally {  	DebugExitRule (GrammarFileName' "property");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,property,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "property");  	DebugLocation (19' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:23:2: ( ^( propertyName (not= '!' )? ( filter[newProperty] )? ( block[newProperty] )? ) )  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:23:4: ^( propertyName (not= '!' )? ( filter[newProperty] )? ( block[newProperty] )? )  		{  			DebugLocation (23' 4);  			DebugLocation (23' 6);  			PushFollow (Follow._propertyName_in_property80);  			propertyName1 = propertyName ();  			PopFollow ();  			if (input.LA (1) == TokenTypes.Down) {  				Match (input' TokenTypes.Down' null);  				DebugLocation (23' 22);  				// ./src/Parser/Grammar/JFLWalker.g:23:22: (not= '!' )?  				int alt2 = 2;  				try {  					DebugEnterSubRule (2);  					try {  						DebugEnterDecision (2' false);  						int LA2_1 = input.LA (1);  						if ((LA2_1 == 24)) {  							alt2 = 1;  						}  					}  					finally {  						DebugExitDecision (2);  					}  					switch (alt2) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:23:22: not= '!'  						{  							DebugLocation (23' 22);  							not = (CommonTree)Match (input' 24' Follow._24_in_property84);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (2);  				}  				DebugLocation (23' 28);  				// ./src/Parser/Grammar/JFLWalker.g:23:28: ( filter[newProperty] )?  				int alt3 = 2;  				try {  					DebugEnterSubRule (3);  					try {  						DebugEnterDecision (3' false);  						int LA3_1 = input.LA (1);  						if ((LA3_1 == FILTER)) {  							alt3 = 1;  						}  					}  					finally {  						DebugExitDecision (3);  					}  					switch (alt3) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:23:28: filter[newProperty]  						{  							DebugLocation (23' 28);  							PushFollow (Follow._filter_in_property87);  							filter (newProperty);  							PopFollow ();  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (3);  				}  				DebugLocation (23' 49);  				// ./src/Parser/Grammar/JFLWalker.g:23:49: ( block[newProperty] )?  				int alt4 = 2;  				try {  					DebugEnterSubRule (4);  					try {  						DebugEnterDecision (4' false);  						int LA4_1 = input.LA (1);  						if ((LA4_1 == BLOCK)) {  							alt4 = 1;  						}  					}  					finally {  						DebugExitDecision (4);  					}  					switch (alt4) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:23:49: block[newProperty]  						{  							DebugLocation (23' 49);  							PushFollow (Follow._block_in_property91);  							block (newProperty);  							PopFollow ();  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (4);  				}  				Match (input' TokenTypes.Up' null);  			}  			DebugLocation (23' 70);  			if ((not != null ? not.Text : default(string)) == "!")  				newProperty.ToggleInclude ();  			if ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).isRegex : default(bool)))  				parentScope.AddRegexProperty ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).name : default(string))' newProperty);  			else  				parentScope.AddProperty ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).name : default(string))' newProperty);  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("property"' 3);  		LeaveRule ("property"' 3);  		LeaveRule_property ();  	}  	DebugLocation (31' 1);  }  finally {  	DebugExitRule (GrammarFileName' "property");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,property,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "property");  	DebugLocation (19' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:23:2: ( ^( propertyName (not= '!' )? ( filter[newProperty] )? ( block[newProperty] )? ) )  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:23:4: ^( propertyName (not= '!' )? ( filter[newProperty] )? ( block[newProperty] )? )  		{  			DebugLocation (23' 4);  			DebugLocation (23' 6);  			PushFollow (Follow._propertyName_in_property80);  			propertyName1 = propertyName ();  			PopFollow ();  			if (input.LA (1) == TokenTypes.Down) {  				Match (input' TokenTypes.Down' null);  				DebugLocation (23' 22);  				// ./src/Parser/Grammar/JFLWalker.g:23:22: (not= '!' )?  				int alt2 = 2;  				try {  					DebugEnterSubRule (2);  					try {  						DebugEnterDecision (2' false);  						int LA2_1 = input.LA (1);  						if ((LA2_1 == 24)) {  							alt2 = 1;  						}  					}  					finally {  						DebugExitDecision (2);  					}  					switch (alt2) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:23:22: not= '!'  						{  							DebugLocation (23' 22);  							not = (CommonTree)Match (input' 24' Follow._24_in_property84);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (2);  				}  				DebugLocation (23' 28);  				// ./src/Parser/Grammar/JFLWalker.g:23:28: ( filter[newProperty] )?  				int alt3 = 2;  				try {  					DebugEnterSubRule (3);  					try {  						DebugEnterDecision (3' false);  						int LA3_1 = input.LA (1);  						if ((LA3_1 == FILTER)) {  							alt3 = 1;  						}  					}  					finally {  						DebugExitDecision (3);  					}  					switch (alt3) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:23:28: filter[newProperty]  						{  							DebugLocation (23' 28);  							PushFollow (Follow._filter_in_property87);  							filter (newProperty);  							PopFollow ();  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (3);  				}  				DebugLocation (23' 49);  				// ./src/Parser/Grammar/JFLWalker.g:23:49: ( block[newProperty] )?  				int alt4 = 2;  				try {  					DebugEnterSubRule (4);  					try {  						DebugEnterDecision (4' false);  						int LA4_1 = input.LA (1);  						if ((LA4_1 == BLOCK)) {  							alt4 = 1;  						}  					}  					finally {  						DebugExitDecision (4);  					}  					switch (alt4) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:23:49: block[newProperty]  						{  							DebugLocation (23' 49);  							PushFollow (Follow._block_in_property91);  							block (newProperty);  							PopFollow ();  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (4);  				}  				Match (input' TokenTypes.Up' null);  			}  			DebugLocation (23' 70);  			if ((not != null ? not.Text : default(string)) == "!")  				newProperty.ToggleInclude ();  			if ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).isRegex : default(bool)))  				parentScope.AddRegexProperty ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).name : default(string))' newProperty);  			else  				parentScope.AddProperty ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).name : default(string))' newProperty);  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("property"' 3);  		LeaveRule ("property"' 3);  		LeaveRule_property ();  	}  	DebugLocation (31' 1);  }  finally {  	DebugExitRule (GrammarFileName' "property");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,property,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "property");  	DebugLocation (19' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:23:2: ( ^( propertyName (not= '!' )? ( filter[newProperty] )? ( block[newProperty] )? ) )  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:23:4: ^( propertyName (not= '!' )? ( filter[newProperty] )? ( block[newProperty] )? )  		{  			DebugLocation (23' 4);  			DebugLocation (23' 6);  			PushFollow (Follow._propertyName_in_property80);  			propertyName1 = propertyName ();  			PopFollow ();  			if (input.LA (1) == TokenTypes.Down) {  				Match (input' TokenTypes.Down' null);  				DebugLocation (23' 22);  				// ./src/Parser/Grammar/JFLWalker.g:23:22: (not= '!' )?  				int alt2 = 2;  				try {  					DebugEnterSubRule (2);  					try {  						DebugEnterDecision (2' false);  						int LA2_1 = input.LA (1);  						if ((LA2_1 == 24)) {  							alt2 = 1;  						}  					}  					finally {  						DebugExitDecision (2);  					}  					switch (alt2) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:23:22: not= '!'  						{  							DebugLocation (23' 22);  							not = (CommonTree)Match (input' 24' Follow._24_in_property84);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (2);  				}  				DebugLocation (23' 28);  				// ./src/Parser/Grammar/JFLWalker.g:23:28: ( filter[newProperty] )?  				int alt3 = 2;  				try {  					DebugEnterSubRule (3);  					try {  						DebugEnterDecision (3' false);  						int LA3_1 = input.LA (1);  						if ((LA3_1 == FILTER)) {  							alt3 = 1;  						}  					}  					finally {  						DebugExitDecision (3);  					}  					switch (alt3) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:23:28: filter[newProperty]  						{  							DebugLocation (23' 28);  							PushFollow (Follow._filter_in_property87);  							filter (newProperty);  							PopFollow ();  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (3);  				}  				DebugLocation (23' 49);  				// ./src/Parser/Grammar/JFLWalker.g:23:49: ( block[newProperty] )?  				int alt4 = 2;  				try {  					DebugEnterSubRule (4);  					try {  						DebugEnterDecision (4' false);  						int LA4_1 = input.LA (1);  						if ((LA4_1 == BLOCK)) {  							alt4 = 1;  						}  					}  					finally {  						DebugExitDecision (4);  					}  					switch (alt4) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:23:49: block[newProperty]  						{  							DebugLocation (23' 49);  							PushFollow (Follow._block_in_property91);  							block (newProperty);  							PopFollow ();  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (4);  				}  				Match (input' TokenTypes.Up' null);  			}  			DebugLocation (23' 70);  			if ((not != null ? not.Text : default(string)) == "!")  				newProperty.ToggleInclude ();  			if ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).isRegex : default(bool)))  				parentScope.AddRegexProperty ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).name : default(string))' newProperty);  			else  				parentScope.AddProperty ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).name : default(string))' newProperty);  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("property"' 3);  		LeaveRule ("property"' 3);  		LeaveRule_property ();  	}  	DebugLocation (31' 1);  }  finally {  	DebugExitRule (GrammarFileName' "property");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,property,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "property");  	DebugLocation (19' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:23:2: ( ^( propertyName (not= '!' )? ( filter[newProperty] )? ( block[newProperty] )? ) )  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:23:4: ^( propertyName (not= '!' )? ( filter[newProperty] )? ( block[newProperty] )? )  		{  			DebugLocation (23' 4);  			DebugLocation (23' 6);  			PushFollow (Follow._propertyName_in_property80);  			propertyName1 = propertyName ();  			PopFollow ();  			if (input.LA (1) == TokenTypes.Down) {  				Match (input' TokenTypes.Down' null);  				DebugLocation (23' 22);  				// ./src/Parser/Grammar/JFLWalker.g:23:22: (not= '!' )?  				int alt2 = 2;  				try {  					DebugEnterSubRule (2);  					try {  						DebugEnterDecision (2' false);  						int LA2_1 = input.LA (1);  						if ((LA2_1 == 24)) {  							alt2 = 1;  						}  					}  					finally {  						DebugExitDecision (2);  					}  					switch (alt2) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:23:22: not= '!'  						{  							DebugLocation (23' 22);  							not = (CommonTree)Match (input' 24' Follow._24_in_property84);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (2);  				}  				DebugLocation (23' 28);  				// ./src/Parser/Grammar/JFLWalker.g:23:28: ( filter[newProperty] )?  				int alt3 = 2;  				try {  					DebugEnterSubRule (3);  					try {  						DebugEnterDecision (3' false);  						int LA3_1 = input.LA (1);  						if ((LA3_1 == FILTER)) {  							alt3 = 1;  						}  					}  					finally {  						DebugExitDecision (3);  					}  					switch (alt3) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:23:28: filter[newProperty]  						{  							DebugLocation (23' 28);  							PushFollow (Follow._filter_in_property87);  							filter (newProperty);  							PopFollow ();  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (3);  				}  				DebugLocation (23' 49);  				// ./src/Parser/Grammar/JFLWalker.g:23:49: ( block[newProperty] )?  				int alt4 = 2;  				try {  					DebugEnterSubRule (4);  					try {  						DebugEnterDecision (4' false);  						int LA4_1 = input.LA (1);  						if ((LA4_1 == BLOCK)) {  							alt4 = 1;  						}  					}  					finally {  						DebugExitDecision (4);  					}  					switch (alt4) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:23:49: block[newProperty]  						{  							DebugLocation (23' 49);  							PushFollow (Follow._block_in_property91);  							block (newProperty);  							PopFollow ();  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (4);  				}  				Match (input' TokenTypes.Up' null);  			}  			DebugLocation (23' 70);  			if ((not != null ? not.Text : default(string)) == "!")  				newProperty.ToggleInclude ();  			if ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).isRegex : default(bool)))  				parentScope.AddRegexProperty ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).name : default(string))' newProperty);  			else  				parentScope.AddProperty ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).name : default(string))' newProperty);  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("property"' 3);  		LeaveRule ("property"' 3);  		LeaveRule_property ();  	}  	DebugLocation (31' 1);  }  finally {  	DebugExitRule (GrammarFileName' "property");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,property,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "property");  	DebugLocation (19' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:23:2: ( ^( propertyName (not= '!' )? ( filter[newProperty] )? ( block[newProperty] )? ) )  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:23:4: ^( propertyName (not= '!' )? ( filter[newProperty] )? ( block[newProperty] )? )  		{  			DebugLocation (23' 4);  			DebugLocation (23' 6);  			PushFollow (Follow._propertyName_in_property80);  			propertyName1 = propertyName ();  			PopFollow ();  			if (input.LA (1) == TokenTypes.Down) {  				Match (input' TokenTypes.Down' null);  				DebugLocation (23' 22);  				// ./src/Parser/Grammar/JFLWalker.g:23:22: (not= '!' )?  				int alt2 = 2;  				try {  					DebugEnterSubRule (2);  					try {  						DebugEnterDecision (2' false);  						int LA2_1 = input.LA (1);  						if ((LA2_1 == 24)) {  							alt2 = 1;  						}  					}  					finally {  						DebugExitDecision (2);  					}  					switch (alt2) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:23:22: not= '!'  						{  							DebugLocation (23' 22);  							not = (CommonTree)Match (input' 24' Follow._24_in_property84);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (2);  				}  				DebugLocation (23' 28);  				// ./src/Parser/Grammar/JFLWalker.g:23:28: ( filter[newProperty] )?  				int alt3 = 2;  				try {  					DebugEnterSubRule (3);  					try {  						DebugEnterDecision (3' false);  						int LA3_1 = input.LA (1);  						if ((LA3_1 == FILTER)) {  							alt3 = 1;  						}  					}  					finally {  						DebugExitDecision (3);  					}  					switch (alt3) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:23:28: filter[newProperty]  						{  							DebugLocation (23' 28);  							PushFollow (Follow._filter_in_property87);  							filter (newProperty);  							PopFollow ();  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (3);  				}  				DebugLocation (23' 49);  				// ./src/Parser/Grammar/JFLWalker.g:23:49: ( block[newProperty] )?  				int alt4 = 2;  				try {  					DebugEnterSubRule (4);  					try {  						DebugEnterDecision (4' false);  						int LA4_1 = input.LA (1);  						if ((LA4_1 == BLOCK)) {  							alt4 = 1;  						}  					}  					finally {  						DebugExitDecision (4);  					}  					switch (alt4) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:23:49: block[newProperty]  						{  							DebugLocation (23' 49);  							PushFollow (Follow._block_in_property91);  							block (newProperty);  							PopFollow ();  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (4);  				}  				Match (input' TokenTypes.Up' null);  			}  			DebugLocation (23' 70);  			if ((not != null ? not.Text : default(string)) == "!")  				newProperty.ToggleInclude ();  			if ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).isRegex : default(bool)))  				parentScope.AddRegexProperty ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).name : default(string))' newProperty);  			else  				parentScope.AddProperty ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).name : default(string))' newProperty);  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("property"' 3);  		LeaveRule ("property"' 3);  		LeaveRule_property ();  	}  	DebugLocation (31' 1);  }  finally {  	DebugExitRule (GrammarFileName' "property");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,property,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "property");  	DebugLocation (19' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:23:2: ( ^( propertyName (not= '!' )? ( filter[newProperty] )? ( block[newProperty] )? ) )  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:23:4: ^( propertyName (not= '!' )? ( filter[newProperty] )? ( block[newProperty] )? )  		{  			DebugLocation (23' 4);  			DebugLocation (23' 6);  			PushFollow (Follow._propertyName_in_property80);  			propertyName1 = propertyName ();  			PopFollow ();  			if (input.LA (1) == TokenTypes.Down) {  				Match (input' TokenTypes.Down' null);  				DebugLocation (23' 22);  				// ./src/Parser/Grammar/JFLWalker.g:23:22: (not= '!' )?  				int alt2 = 2;  				try {  					DebugEnterSubRule (2);  					try {  						DebugEnterDecision (2' false);  						int LA2_1 = input.LA (1);  						if ((LA2_1 == 24)) {  							alt2 = 1;  						}  					}  					finally {  						DebugExitDecision (2);  					}  					switch (alt2) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:23:22: not= '!'  						{  							DebugLocation (23' 22);  							not = (CommonTree)Match (input' 24' Follow._24_in_property84);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (2);  				}  				DebugLocation (23' 28);  				// ./src/Parser/Grammar/JFLWalker.g:23:28: ( filter[newProperty] )?  				int alt3 = 2;  				try {  					DebugEnterSubRule (3);  					try {  						DebugEnterDecision (3' false);  						int LA3_1 = input.LA (1);  						if ((LA3_1 == FILTER)) {  							alt3 = 1;  						}  					}  					finally {  						DebugExitDecision (3);  					}  					switch (alt3) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:23:28: filter[newProperty]  						{  							DebugLocation (23' 28);  							PushFollow (Follow._filter_in_property87);  							filter (newProperty);  							PopFollow ();  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (3);  				}  				DebugLocation (23' 49);  				// ./src/Parser/Grammar/JFLWalker.g:23:49: ( block[newProperty] )?  				int alt4 = 2;  				try {  					DebugEnterSubRule (4);  					try {  						DebugEnterDecision (4' false);  						int LA4_1 = input.LA (1);  						if ((LA4_1 == BLOCK)) {  							alt4 = 1;  						}  					}  					finally {  						DebugExitDecision (4);  					}  					switch (alt4) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:23:49: block[newProperty]  						{  							DebugLocation (23' 49);  							PushFollow (Follow._block_in_property91);  							block (newProperty);  							PopFollow ();  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (4);  				}  				Match (input' TokenTypes.Up' null);  			}  			DebugLocation (23' 70);  			if ((not != null ? not.Text : default(string)) == "!")  				newProperty.ToggleInclude ();  			if ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).isRegex : default(bool)))  				parentScope.AddRegexProperty ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).name : default(string))' newProperty);  			else  				parentScope.AddProperty ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).name : default(string))' newProperty);  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("property"' 3);  		LeaveRule ("property"' 3);  		LeaveRule_property ();  	}  	DebugLocation (31' 1);  }  finally {  	DebugExitRule (GrammarFileName' "property");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,property,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "property");  	DebugLocation (19' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:23:2: ( ^( propertyName (not= '!' )? ( filter[newProperty] )? ( block[newProperty] )? ) )  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:23:4: ^( propertyName (not= '!' )? ( filter[newProperty] )? ( block[newProperty] )? )  		{  			DebugLocation (23' 4);  			DebugLocation (23' 6);  			PushFollow (Follow._propertyName_in_property80);  			propertyName1 = propertyName ();  			PopFollow ();  			if (input.LA (1) == TokenTypes.Down) {  				Match (input' TokenTypes.Down' null);  				DebugLocation (23' 22);  				// ./src/Parser/Grammar/JFLWalker.g:23:22: (not= '!' )?  				int alt2 = 2;  				try {  					DebugEnterSubRule (2);  					try {  						DebugEnterDecision (2' false);  						int LA2_1 = input.LA (1);  						if ((LA2_1 == 24)) {  							alt2 = 1;  						}  					}  					finally {  						DebugExitDecision (2);  					}  					switch (alt2) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:23:22: not= '!'  						{  							DebugLocation (23' 22);  							not = (CommonTree)Match (input' 24' Follow._24_in_property84);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (2);  				}  				DebugLocation (23' 28);  				// ./src/Parser/Grammar/JFLWalker.g:23:28: ( filter[newProperty] )?  				int alt3 = 2;  				try {  					DebugEnterSubRule (3);  					try {  						DebugEnterDecision (3' false);  						int LA3_1 = input.LA (1);  						if ((LA3_1 == FILTER)) {  							alt3 = 1;  						}  					}  					finally {  						DebugExitDecision (3);  					}  					switch (alt3) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:23:28: filter[newProperty]  						{  							DebugLocation (23' 28);  							PushFollow (Follow._filter_in_property87);  							filter (newProperty);  							PopFollow ();  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (3);  				}  				DebugLocation (23' 49);  				// ./src/Parser/Grammar/JFLWalker.g:23:49: ( block[newProperty] )?  				int alt4 = 2;  				try {  					DebugEnterSubRule (4);  					try {  						DebugEnterDecision (4' false);  						int LA4_1 = input.LA (1);  						if ((LA4_1 == BLOCK)) {  							alt4 = 1;  						}  					}  					finally {  						DebugExitDecision (4);  					}  					switch (alt4) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:23:49: block[newProperty]  						{  							DebugLocation (23' 49);  							PushFollow (Follow._block_in_property91);  							block (newProperty);  							PopFollow ();  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (4);  				}  				Match (input' TokenTypes.Up' null);  			}  			DebugLocation (23' 70);  			if ((not != null ? not.Text : default(string)) == "!")  				newProperty.ToggleInclude ();  			if ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).isRegex : default(bool)))  				parentScope.AddRegexProperty ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).name : default(string))' newProperty);  			else  				parentScope.AddProperty ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).name : default(string))' newProperty);  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("property"' 3);  		LeaveRule ("property"' 3);  		LeaveRule_property ();  	}  	DebugLocation (31' 1);  }  finally {  	DebugExitRule (GrammarFileName' "property");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,property,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "property");  	DebugLocation (19' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:23:2: ( ^( propertyName (not= '!' )? ( filter[newProperty] )? ( block[newProperty] )? ) )  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:23:4: ^( propertyName (not= '!' )? ( filter[newProperty] )? ( block[newProperty] )? )  		{  			DebugLocation (23' 4);  			DebugLocation (23' 6);  			PushFollow (Follow._propertyName_in_property80);  			propertyName1 = propertyName ();  			PopFollow ();  			if (input.LA (1) == TokenTypes.Down) {  				Match (input' TokenTypes.Down' null);  				DebugLocation (23' 22);  				// ./src/Parser/Grammar/JFLWalker.g:23:22: (not= '!' )?  				int alt2 = 2;  				try {  					DebugEnterSubRule (2);  					try {  						DebugEnterDecision (2' false);  						int LA2_1 = input.LA (1);  						if ((LA2_1 == 24)) {  							alt2 = 1;  						}  					}  					finally {  						DebugExitDecision (2);  					}  					switch (alt2) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:23:22: not= '!'  						{  							DebugLocation (23' 22);  							not = (CommonTree)Match (input' 24' Follow._24_in_property84);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (2);  				}  				DebugLocation (23' 28);  				// ./src/Parser/Grammar/JFLWalker.g:23:28: ( filter[newProperty] )?  				int alt3 = 2;  				try {  					DebugEnterSubRule (3);  					try {  						DebugEnterDecision (3' false);  						int LA3_1 = input.LA (1);  						if ((LA3_1 == FILTER)) {  							alt3 = 1;  						}  					}  					finally {  						DebugExitDecision (3);  					}  					switch (alt3) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:23:28: filter[newProperty]  						{  							DebugLocation (23' 28);  							PushFollow (Follow._filter_in_property87);  							filter (newProperty);  							PopFollow ();  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (3);  				}  				DebugLocation (23' 49);  				// ./src/Parser/Grammar/JFLWalker.g:23:49: ( block[newProperty] )?  				int alt4 = 2;  				try {  					DebugEnterSubRule (4);  					try {  						DebugEnterDecision (4' false);  						int LA4_1 = input.LA (1);  						if ((LA4_1 == BLOCK)) {  							alt4 = 1;  						}  					}  					finally {  						DebugExitDecision (4);  					}  					switch (alt4) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:23:49: block[newProperty]  						{  							DebugLocation (23' 49);  							PushFollow (Follow._block_in_property91);  							block (newProperty);  							PopFollow ();  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (4);  				}  				Match (input' TokenTypes.Up' null);  			}  			DebugLocation (23' 70);  			if ((not != null ? not.Text : default(string)) == "!")  				newProperty.ToggleInclude ();  			if ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).isRegex : default(bool)))  				parentScope.AddRegexProperty ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).name : default(string))' newProperty);  			else  				parentScope.AddProperty ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).name : default(string))' newProperty);  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("property"' 3);  		LeaveRule ("property"' 3);  		LeaveRule_property ();  	}  	DebugLocation (31' 1);  }  finally {  	DebugExitRule (GrammarFileName' "property");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,property,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "property");  	DebugLocation (19' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:23:2: ( ^( propertyName (not= '!' )? ( filter[newProperty] )? ( block[newProperty] )? ) )  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:23:4: ^( propertyName (not= '!' )? ( filter[newProperty] )? ( block[newProperty] )? )  		{  			DebugLocation (23' 4);  			DebugLocation (23' 6);  			PushFollow (Follow._propertyName_in_property80);  			propertyName1 = propertyName ();  			PopFollow ();  			if (input.LA (1) == TokenTypes.Down) {  				Match (input' TokenTypes.Down' null);  				DebugLocation (23' 22);  				// ./src/Parser/Grammar/JFLWalker.g:23:22: (not= '!' )?  				int alt2 = 2;  				try {  					DebugEnterSubRule (2);  					try {  						DebugEnterDecision (2' false);  						int LA2_1 = input.LA (1);  						if ((LA2_1 == 24)) {  							alt2 = 1;  						}  					}  					finally {  						DebugExitDecision (2);  					}  					switch (alt2) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:23:22: not= '!'  						{  							DebugLocation (23' 22);  							not = (CommonTree)Match (input' 24' Follow._24_in_property84);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (2);  				}  				DebugLocation (23' 28);  				// ./src/Parser/Grammar/JFLWalker.g:23:28: ( filter[newProperty] )?  				int alt3 = 2;  				try {  					DebugEnterSubRule (3);  					try {  						DebugEnterDecision (3' false);  						int LA3_1 = input.LA (1);  						if ((LA3_1 == FILTER)) {  							alt3 = 1;  						}  					}  					finally {  						DebugExitDecision (3);  					}  					switch (alt3) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:23:28: filter[newProperty]  						{  							DebugLocation (23' 28);  							PushFollow (Follow._filter_in_property87);  							filter (newProperty);  							PopFollow ();  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (3);  				}  				DebugLocation (23' 49);  				// ./src/Parser/Grammar/JFLWalker.g:23:49: ( block[newProperty] )?  				int alt4 = 2;  				try {  					DebugEnterSubRule (4);  					try {  						DebugEnterDecision (4' false);  						int LA4_1 = input.LA (1);  						if ((LA4_1 == BLOCK)) {  							alt4 = 1;  						}  					}  					finally {  						DebugExitDecision (4);  					}  					switch (alt4) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:23:49: block[newProperty]  						{  							DebugLocation (23' 49);  							PushFollow (Follow._block_in_property91);  							block (newProperty);  							PopFollow ();  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (4);  				}  				Match (input' TokenTypes.Up' null);  			}  			DebugLocation (23' 70);  			if ((not != null ? not.Text : default(string)) == "!")  				newProperty.ToggleInclude ();  			if ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).isRegex : default(bool)))  				parentScope.AddRegexProperty ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).name : default(string))' newProperty);  			else  				parentScope.AddProperty ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).name : default(string))' newProperty);  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("property"' 3);  		LeaveRule ("property"' 3);  		LeaveRule_property ();  	}  	DebugLocation (31' 1);  }  finally {  	DebugExitRule (GrammarFileName' "property");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,property,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "property");  	DebugLocation (19' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:23:2: ( ^( propertyName (not= '!' )? ( filter[newProperty] )? ( block[newProperty] )? ) )  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:23:4: ^( propertyName (not= '!' )? ( filter[newProperty] )? ( block[newProperty] )? )  		{  			DebugLocation (23' 4);  			DebugLocation (23' 6);  			PushFollow (Follow._propertyName_in_property80);  			propertyName1 = propertyName ();  			PopFollow ();  			if (input.LA (1) == TokenTypes.Down) {  				Match (input' TokenTypes.Down' null);  				DebugLocation (23' 22);  				// ./src/Parser/Grammar/JFLWalker.g:23:22: (not= '!' )?  				int alt2 = 2;  				try {  					DebugEnterSubRule (2);  					try {  						DebugEnterDecision (2' false);  						int LA2_1 = input.LA (1);  						if ((LA2_1 == 24)) {  							alt2 = 1;  						}  					}  					finally {  						DebugExitDecision (2);  					}  					switch (alt2) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:23:22: not= '!'  						{  							DebugLocation (23' 22);  							not = (CommonTree)Match (input' 24' Follow._24_in_property84);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (2);  				}  				DebugLocation (23' 28);  				// ./src/Parser/Grammar/JFLWalker.g:23:28: ( filter[newProperty] )?  				int alt3 = 2;  				try {  					DebugEnterSubRule (3);  					try {  						DebugEnterDecision (3' false);  						int LA3_1 = input.LA (1);  						if ((LA3_1 == FILTER)) {  							alt3 = 1;  						}  					}  					finally {  						DebugExitDecision (3);  					}  					switch (alt3) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:23:28: filter[newProperty]  						{  							DebugLocation (23' 28);  							PushFollow (Follow._filter_in_property87);  							filter (newProperty);  							PopFollow ();  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (3);  				}  				DebugLocation (23' 49);  				// ./src/Parser/Grammar/JFLWalker.g:23:49: ( block[newProperty] )?  				int alt4 = 2;  				try {  					DebugEnterSubRule (4);  					try {  						DebugEnterDecision (4' false);  						int LA4_1 = input.LA (1);  						if ((LA4_1 == BLOCK)) {  							alt4 = 1;  						}  					}  					finally {  						DebugExitDecision (4);  					}  					switch (alt4) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:23:49: block[newProperty]  						{  							DebugLocation (23' 49);  							PushFollow (Follow._block_in_property91);  							block (newProperty);  							PopFollow ();  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (4);  				}  				Match (input' TokenTypes.Up' null);  			}  			DebugLocation (23' 70);  			if ((not != null ? not.Text : default(string)) == "!")  				newProperty.ToggleInclude ();  			if ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).isRegex : default(bool)))  				parentScope.AddRegexProperty ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).name : default(string))' newProperty);  			else  				parentScope.AddProperty ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).name : default(string))' newProperty);  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("property"' 3);  		LeaveRule ("property"' 3);  		LeaveRule_property ();  	}  	DebugLocation (31' 1);  }  finally {  	DebugExitRule (GrammarFileName' "property");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,property,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "property");  	DebugLocation (19' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:23:2: ( ^( propertyName (not= '!' )? ( filter[newProperty] )? ( block[newProperty] )? ) )  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:23:4: ^( propertyName (not= '!' )? ( filter[newProperty] )? ( block[newProperty] )? )  		{  			DebugLocation (23' 4);  			DebugLocation (23' 6);  			PushFollow (Follow._propertyName_in_property80);  			propertyName1 = propertyName ();  			PopFollow ();  			if (input.LA (1) == TokenTypes.Down) {  				Match (input' TokenTypes.Down' null);  				DebugLocation (23' 22);  				// ./src/Parser/Grammar/JFLWalker.g:23:22: (not= '!' )?  				int alt2 = 2;  				try {  					DebugEnterSubRule (2);  					try {  						DebugEnterDecision (2' false);  						int LA2_1 = input.LA (1);  						if ((LA2_1 == 24)) {  							alt2 = 1;  						}  					}  					finally {  						DebugExitDecision (2);  					}  					switch (alt2) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:23:22: not= '!'  						{  							DebugLocation (23' 22);  							not = (CommonTree)Match (input' 24' Follow._24_in_property84);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (2);  				}  				DebugLocation (23' 28);  				// ./src/Parser/Grammar/JFLWalker.g:23:28: ( filter[newProperty] )?  				int alt3 = 2;  				try {  					DebugEnterSubRule (3);  					try {  						DebugEnterDecision (3' false);  						int LA3_1 = input.LA (1);  						if ((LA3_1 == FILTER)) {  							alt3 = 1;  						}  					}  					finally {  						DebugExitDecision (3);  					}  					switch (alt3) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:23:28: filter[newProperty]  						{  							DebugLocation (23' 28);  							PushFollow (Follow._filter_in_property87);  							filter (newProperty);  							PopFollow ();  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (3);  				}  				DebugLocation (23' 49);  				// ./src/Parser/Grammar/JFLWalker.g:23:49: ( block[newProperty] )?  				int alt4 = 2;  				try {  					DebugEnterSubRule (4);  					try {  						DebugEnterDecision (4' false);  						int LA4_1 = input.LA (1);  						if ((LA4_1 == BLOCK)) {  							alt4 = 1;  						}  					}  					finally {  						DebugExitDecision (4);  					}  					switch (alt4) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:23:49: block[newProperty]  						{  							DebugLocation (23' 49);  							PushFollow (Follow._block_in_property91);  							block (newProperty);  							PopFollow ();  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (4);  				}  				Match (input' TokenTypes.Up' null);  			}  			DebugLocation (23' 70);  			if ((not != null ? not.Text : default(string)) == "!")  				newProperty.ToggleInclude ();  			if ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).isRegex : default(bool)))  				parentScope.AddRegexProperty ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).name : default(string))' newProperty);  			else  				parentScope.AddProperty ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).name : default(string))' newProperty);  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("property"' 3);  		LeaveRule ("property"' 3);  		LeaveRule_property ();  	}  	DebugLocation (31' 1);  }  finally {  	DebugExitRule (GrammarFileName' "property");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,property,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "property");  	DebugLocation (19' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:23:2: ( ^( propertyName (not= '!' )? ( filter[newProperty] )? ( block[newProperty] )? ) )  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:23:4: ^( propertyName (not= '!' )? ( filter[newProperty] )? ( block[newProperty] )? )  		{  			DebugLocation (23' 4);  			DebugLocation (23' 6);  			PushFollow (Follow._propertyName_in_property80);  			propertyName1 = propertyName ();  			PopFollow ();  			if (input.LA (1) == TokenTypes.Down) {  				Match (input' TokenTypes.Down' null);  				DebugLocation (23' 22);  				// ./src/Parser/Grammar/JFLWalker.g:23:22: (not= '!' )?  				int alt2 = 2;  				try {  					DebugEnterSubRule (2);  					try {  						DebugEnterDecision (2' false);  						int LA2_1 = input.LA (1);  						if ((LA2_1 == 24)) {  							alt2 = 1;  						}  					}  					finally {  						DebugExitDecision (2);  					}  					switch (alt2) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:23:22: not= '!'  						{  							DebugLocation (23' 22);  							not = (CommonTree)Match (input' 24' Follow._24_in_property84);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (2);  				}  				DebugLocation (23' 28);  				// ./src/Parser/Grammar/JFLWalker.g:23:28: ( filter[newProperty] )?  				int alt3 = 2;  				try {  					DebugEnterSubRule (3);  					try {  						DebugEnterDecision (3' false);  						int LA3_1 = input.LA (1);  						if ((LA3_1 == FILTER)) {  							alt3 = 1;  						}  					}  					finally {  						DebugExitDecision (3);  					}  					switch (alt3) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:23:28: filter[newProperty]  						{  							DebugLocation (23' 28);  							PushFollow (Follow._filter_in_property87);  							filter (newProperty);  							PopFollow ();  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (3);  				}  				DebugLocation (23' 49);  				// ./src/Parser/Grammar/JFLWalker.g:23:49: ( block[newProperty] )?  				int alt4 = 2;  				try {  					DebugEnterSubRule (4);  					try {  						DebugEnterDecision (4' false);  						int LA4_1 = input.LA (1);  						if ((LA4_1 == BLOCK)) {  							alt4 = 1;  						}  					}  					finally {  						DebugExitDecision (4);  					}  					switch (alt4) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:23:49: block[newProperty]  						{  							DebugLocation (23' 49);  							PushFollow (Follow._block_in_property91);  							block (newProperty);  							PopFollow ();  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (4);  				}  				Match (input' TokenTypes.Up' null);  			}  			DebugLocation (23' 70);  			if ((not != null ? not.Text : default(string)) == "!")  				newProperty.ToggleInclude ();  			if ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).isRegex : default(bool)))  				parentScope.AddRegexProperty ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).name : default(string))' newProperty);  			else  				parentScope.AddProperty ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).name : default(string))' newProperty);  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("property"' 3);  		LeaveRule ("property"' 3);  		LeaveRule_property ();  	}  	DebugLocation (31' 1);  }  finally {  	DebugExitRule (GrammarFileName' "property");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,property,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "property");  	DebugLocation (19' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:23:2: ( ^( propertyName (not= '!' )? ( filter[newProperty] )? ( block[newProperty] )? ) )  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:23:4: ^( propertyName (not= '!' )? ( filter[newProperty] )? ( block[newProperty] )? )  		{  			DebugLocation (23' 4);  			DebugLocation (23' 6);  			PushFollow (Follow._propertyName_in_property80);  			propertyName1 = propertyName ();  			PopFollow ();  			if (input.LA (1) == TokenTypes.Down) {  				Match (input' TokenTypes.Down' null);  				DebugLocation (23' 22);  				// ./src/Parser/Grammar/JFLWalker.g:23:22: (not= '!' )?  				int alt2 = 2;  				try {  					DebugEnterSubRule (2);  					try {  						DebugEnterDecision (2' false);  						int LA2_1 = input.LA (1);  						if ((LA2_1 == 24)) {  							alt2 = 1;  						}  					}  					finally {  						DebugExitDecision (2);  					}  					switch (alt2) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:23:22: not= '!'  						{  							DebugLocation (23' 22);  							not = (CommonTree)Match (input' 24' Follow._24_in_property84);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (2);  				}  				DebugLocation (23' 28);  				// ./src/Parser/Grammar/JFLWalker.g:23:28: ( filter[newProperty] )?  				int alt3 = 2;  				try {  					DebugEnterSubRule (3);  					try {  						DebugEnterDecision (3' false);  						int LA3_1 = input.LA (1);  						if ((LA3_1 == FILTER)) {  							alt3 = 1;  						}  					}  					finally {  						DebugExitDecision (3);  					}  					switch (alt3) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:23:28: filter[newProperty]  						{  							DebugLocation (23' 28);  							PushFollow (Follow._filter_in_property87);  							filter (newProperty);  							PopFollow ();  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (3);  				}  				DebugLocation (23' 49);  				// ./src/Parser/Grammar/JFLWalker.g:23:49: ( block[newProperty] )?  				int alt4 = 2;  				try {  					DebugEnterSubRule (4);  					try {  						DebugEnterDecision (4' false);  						int LA4_1 = input.LA (1);  						if ((LA4_1 == BLOCK)) {  							alt4 = 1;  						}  					}  					finally {  						DebugExitDecision (4);  					}  					switch (alt4) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:23:49: block[newProperty]  						{  							DebugLocation (23' 49);  							PushFollow (Follow._block_in_property91);  							block (newProperty);  							PopFollow ();  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (4);  				}  				Match (input' TokenTypes.Up' null);  			}  			DebugLocation (23' 70);  			if ((not != null ? not.Text : default(string)) == "!")  				newProperty.ToggleInclude ();  			if ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).isRegex : default(bool)))  				parentScope.AddRegexProperty ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).name : default(string))' newProperty);  			else  				parentScope.AddProperty ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).name : default(string))' newProperty);  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("property"' 3);  		LeaveRule ("property"' 3);  		LeaveRule_property ();  	}  	DebugLocation (31' 1);  }  finally {  	DebugExitRule (GrammarFileName' "property");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,property,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "property");  	DebugLocation (19' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:23:2: ( ^( propertyName (not= '!' )? ( filter[newProperty] )? ( block[newProperty] )? ) )  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:23:4: ^( propertyName (not= '!' )? ( filter[newProperty] )? ( block[newProperty] )? )  		{  			DebugLocation (23' 4);  			DebugLocation (23' 6);  			PushFollow (Follow._propertyName_in_property80);  			propertyName1 = propertyName ();  			PopFollow ();  			if (input.LA (1) == TokenTypes.Down) {  				Match (input' TokenTypes.Down' null);  				DebugLocation (23' 22);  				// ./src/Parser/Grammar/JFLWalker.g:23:22: (not= '!' )?  				int alt2 = 2;  				try {  					DebugEnterSubRule (2);  					try {  						DebugEnterDecision (2' false);  						int LA2_1 = input.LA (1);  						if ((LA2_1 == 24)) {  							alt2 = 1;  						}  					}  					finally {  						DebugExitDecision (2);  					}  					switch (alt2) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:23:22: not= '!'  						{  							DebugLocation (23' 22);  							not = (CommonTree)Match (input' 24' Follow._24_in_property84);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (2);  				}  				DebugLocation (23' 28);  				// ./src/Parser/Grammar/JFLWalker.g:23:28: ( filter[newProperty] )?  				int alt3 = 2;  				try {  					DebugEnterSubRule (3);  					try {  						DebugEnterDecision (3' false);  						int LA3_1 = input.LA (1);  						if ((LA3_1 == FILTER)) {  							alt3 = 1;  						}  					}  					finally {  						DebugExitDecision (3);  					}  					switch (alt3) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:23:28: filter[newProperty]  						{  							DebugLocation (23' 28);  							PushFollow (Follow._filter_in_property87);  							filter (newProperty);  							PopFollow ();  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (3);  				}  				DebugLocation (23' 49);  				// ./src/Parser/Grammar/JFLWalker.g:23:49: ( block[newProperty] )?  				int alt4 = 2;  				try {  					DebugEnterSubRule (4);  					try {  						DebugEnterDecision (4' false);  						int LA4_1 = input.LA (1);  						if ((LA4_1 == BLOCK)) {  							alt4 = 1;  						}  					}  					finally {  						DebugExitDecision (4);  					}  					switch (alt4) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:23:49: block[newProperty]  						{  							DebugLocation (23' 49);  							PushFollow (Follow._block_in_property91);  							block (newProperty);  							PopFollow ();  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (4);  				}  				Match (input' TokenTypes.Up' null);  			}  			DebugLocation (23' 70);  			if ((not != null ? not.Text : default(string)) == "!")  				newProperty.ToggleInclude ();  			if ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).isRegex : default(bool)))  				parentScope.AddRegexProperty ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).name : default(string))' newProperty);  			else  				parentScope.AddProperty ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).name : default(string))' newProperty);  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("property"' 3);  		LeaveRule ("property"' 3);  		LeaveRule_property ();  	}  	DebugLocation (31' 1);  }  finally {  	DebugExitRule (GrammarFileName' "property");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,property,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "property");  	DebugLocation (19' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:23:2: ( ^( propertyName (not= '!' )? ( filter[newProperty] )? ( block[newProperty] )? ) )  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:23:4: ^( propertyName (not= '!' )? ( filter[newProperty] )? ( block[newProperty] )? )  		{  			DebugLocation (23' 4);  			DebugLocation (23' 6);  			PushFollow (Follow._propertyName_in_property80);  			propertyName1 = propertyName ();  			PopFollow ();  			if (input.LA (1) == TokenTypes.Down) {  				Match (input' TokenTypes.Down' null);  				DebugLocation (23' 22);  				// ./src/Parser/Grammar/JFLWalker.g:23:22: (not= '!' )?  				int alt2 = 2;  				try {  					DebugEnterSubRule (2);  					try {  						DebugEnterDecision (2' false);  						int LA2_1 = input.LA (1);  						if ((LA2_1 == 24)) {  							alt2 = 1;  						}  					}  					finally {  						DebugExitDecision (2);  					}  					switch (alt2) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:23:22: not= '!'  						{  							DebugLocation (23' 22);  							not = (CommonTree)Match (input' 24' Follow._24_in_property84);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (2);  				}  				DebugLocation (23' 28);  				// ./src/Parser/Grammar/JFLWalker.g:23:28: ( filter[newProperty] )?  				int alt3 = 2;  				try {  					DebugEnterSubRule (3);  					try {  						DebugEnterDecision (3' false);  						int LA3_1 = input.LA (1);  						if ((LA3_1 == FILTER)) {  							alt3 = 1;  						}  					}  					finally {  						DebugExitDecision (3);  					}  					switch (alt3) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:23:28: filter[newProperty]  						{  							DebugLocation (23' 28);  							PushFollow (Follow._filter_in_property87);  							filter (newProperty);  							PopFollow ();  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (3);  				}  				DebugLocation (23' 49);  				// ./src/Parser/Grammar/JFLWalker.g:23:49: ( block[newProperty] )?  				int alt4 = 2;  				try {  					DebugEnterSubRule (4);  					try {  						DebugEnterDecision (4' false);  						int LA4_1 = input.LA (1);  						if ((LA4_1 == BLOCK)) {  							alt4 = 1;  						}  					}  					finally {  						DebugExitDecision (4);  					}  					switch (alt4) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:23:49: block[newProperty]  						{  							DebugLocation (23' 49);  							PushFollow (Follow._block_in_property91);  							block (newProperty);  							PopFollow ();  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (4);  				}  				Match (input' TokenTypes.Up' null);  			}  			DebugLocation (23' 70);  			if ((not != null ? not.Text : default(string)) == "!")  				newProperty.ToggleInclude ();  			if ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).isRegex : default(bool)))  				parentScope.AddRegexProperty ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).name : default(string))' newProperty);  			else  				parentScope.AddProperty ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).name : default(string))' newProperty);  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("property"' 3);  		LeaveRule ("property"' 3);  		LeaveRule_property ();  	}  	DebugLocation (31' 1);  }  finally {  	DebugExitRule (GrammarFileName' "property");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,property,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "property");  	DebugLocation (19' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:23:2: ( ^( propertyName (not= '!' )? ( filter[newProperty] )? ( block[newProperty] )? ) )  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:23:4: ^( propertyName (not= '!' )? ( filter[newProperty] )? ( block[newProperty] )? )  		{  			DebugLocation (23' 4);  			DebugLocation (23' 6);  			PushFollow (Follow._propertyName_in_property80);  			propertyName1 = propertyName ();  			PopFollow ();  			if (input.LA (1) == TokenTypes.Down) {  				Match (input' TokenTypes.Down' null);  				DebugLocation (23' 22);  				// ./src/Parser/Grammar/JFLWalker.g:23:22: (not= '!' )?  				int alt2 = 2;  				try {  					DebugEnterSubRule (2);  					try {  						DebugEnterDecision (2' false);  						int LA2_1 = input.LA (1);  						if ((LA2_1 == 24)) {  							alt2 = 1;  						}  					}  					finally {  						DebugExitDecision (2);  					}  					switch (alt2) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:23:22: not= '!'  						{  							DebugLocation (23' 22);  							not = (CommonTree)Match (input' 24' Follow._24_in_property84);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (2);  				}  				DebugLocation (23' 28);  				// ./src/Parser/Grammar/JFLWalker.g:23:28: ( filter[newProperty] )?  				int alt3 = 2;  				try {  					DebugEnterSubRule (3);  					try {  						DebugEnterDecision (3' false);  						int LA3_1 = input.LA (1);  						if ((LA3_1 == FILTER)) {  							alt3 = 1;  						}  					}  					finally {  						DebugExitDecision (3);  					}  					switch (alt3) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:23:28: filter[newProperty]  						{  							DebugLocation (23' 28);  							PushFollow (Follow._filter_in_property87);  							filter (newProperty);  							PopFollow ();  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (3);  				}  				DebugLocation (23' 49);  				// ./src/Parser/Grammar/JFLWalker.g:23:49: ( block[newProperty] )?  				int alt4 = 2;  				try {  					DebugEnterSubRule (4);  					try {  						DebugEnterDecision (4' false);  						int LA4_1 = input.LA (1);  						if ((LA4_1 == BLOCK)) {  							alt4 = 1;  						}  					}  					finally {  						DebugExitDecision (4);  					}  					switch (alt4) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:23:49: block[newProperty]  						{  							DebugLocation (23' 49);  							PushFollow (Follow._block_in_property91);  							block (newProperty);  							PopFollow ();  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (4);  				}  				Match (input' TokenTypes.Up' null);  			}  			DebugLocation (23' 70);  			if ((not != null ? not.Text : default(string)) == "!")  				newProperty.ToggleInclude ();  			if ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).isRegex : default(bool)))  				parentScope.AddRegexProperty ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).name : default(string))' newProperty);  			else  				parentScope.AddProperty ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).name : default(string))' newProperty);  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("property"' 3);  		LeaveRule ("property"' 3);  		LeaveRule_property ();  	}  	DebugLocation (31' 1);  }  finally {  	DebugExitRule (GrammarFileName' "property");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,property,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "property");  	DebugLocation (19' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:23:2: ( ^( propertyName (not= '!' )? ( filter[newProperty] )? ( block[newProperty] )? ) )  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:23:4: ^( propertyName (not= '!' )? ( filter[newProperty] )? ( block[newProperty] )? )  		{  			DebugLocation (23' 4);  			DebugLocation (23' 6);  			PushFollow (Follow._propertyName_in_property80);  			propertyName1 = propertyName ();  			PopFollow ();  			if (input.LA (1) == TokenTypes.Down) {  				Match (input' TokenTypes.Down' null);  				DebugLocation (23' 22);  				// ./src/Parser/Grammar/JFLWalker.g:23:22: (not= '!' )?  				int alt2 = 2;  				try {  					DebugEnterSubRule (2);  					try {  						DebugEnterDecision (2' false);  						int LA2_1 = input.LA (1);  						if ((LA2_1 == 24)) {  							alt2 = 1;  						}  					}  					finally {  						DebugExitDecision (2);  					}  					switch (alt2) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:23:22: not= '!'  						{  							DebugLocation (23' 22);  							not = (CommonTree)Match (input' 24' Follow._24_in_property84);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (2);  				}  				DebugLocation (23' 28);  				// ./src/Parser/Grammar/JFLWalker.g:23:28: ( filter[newProperty] )?  				int alt3 = 2;  				try {  					DebugEnterSubRule (3);  					try {  						DebugEnterDecision (3' false);  						int LA3_1 = input.LA (1);  						if ((LA3_1 == FILTER)) {  							alt3 = 1;  						}  					}  					finally {  						DebugExitDecision (3);  					}  					switch (alt3) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:23:28: filter[newProperty]  						{  							DebugLocation (23' 28);  							PushFollow (Follow._filter_in_property87);  							filter (newProperty);  							PopFollow ();  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (3);  				}  				DebugLocation (23' 49);  				// ./src/Parser/Grammar/JFLWalker.g:23:49: ( block[newProperty] )?  				int alt4 = 2;  				try {  					DebugEnterSubRule (4);  					try {  						DebugEnterDecision (4' false);  						int LA4_1 = input.LA (1);  						if ((LA4_1 == BLOCK)) {  							alt4 = 1;  						}  					}  					finally {  						DebugExitDecision (4);  					}  					switch (alt4) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:23:49: block[newProperty]  						{  							DebugLocation (23' 49);  							PushFollow (Follow._block_in_property91);  							block (newProperty);  							PopFollow ();  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (4);  				}  				Match (input' TokenTypes.Up' null);  			}  			DebugLocation (23' 70);  			if ((not != null ? not.Text : default(string)) == "!")  				newProperty.ToggleInclude ();  			if ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).isRegex : default(bool)))  				parentScope.AddRegexProperty ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).name : default(string))' newProperty);  			else  				parentScope.AddProperty ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).name : default(string))' newProperty);  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("property"' 3);  		LeaveRule ("property"' 3);  		LeaveRule_property ();  	}  	DebugLocation (31' 1);  }  finally {  	DebugExitRule (GrammarFileName' "property");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,property,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "property");  	DebugLocation (19' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:23:2: ( ^( propertyName (not= '!' )? ( filter[newProperty] )? ( block[newProperty] )? ) )  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:23:4: ^( propertyName (not= '!' )? ( filter[newProperty] )? ( block[newProperty] )? )  		{  			DebugLocation (23' 4);  			DebugLocation (23' 6);  			PushFollow (Follow._propertyName_in_property80);  			propertyName1 = propertyName ();  			PopFollow ();  			if (input.LA (1) == TokenTypes.Down) {  				Match (input' TokenTypes.Down' null);  				DebugLocation (23' 22);  				// ./src/Parser/Grammar/JFLWalker.g:23:22: (not= '!' )?  				int alt2 = 2;  				try {  					DebugEnterSubRule (2);  					try {  						DebugEnterDecision (2' false);  						int LA2_1 = input.LA (1);  						if ((LA2_1 == 24)) {  							alt2 = 1;  						}  					}  					finally {  						DebugExitDecision (2);  					}  					switch (alt2) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:23:22: not= '!'  						{  							DebugLocation (23' 22);  							not = (CommonTree)Match (input' 24' Follow._24_in_property84);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (2);  				}  				DebugLocation (23' 28);  				// ./src/Parser/Grammar/JFLWalker.g:23:28: ( filter[newProperty] )?  				int alt3 = 2;  				try {  					DebugEnterSubRule (3);  					try {  						DebugEnterDecision (3' false);  						int LA3_1 = input.LA (1);  						if ((LA3_1 == FILTER)) {  							alt3 = 1;  						}  					}  					finally {  						DebugExitDecision (3);  					}  					switch (alt3) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:23:28: filter[newProperty]  						{  							DebugLocation (23' 28);  							PushFollow (Follow._filter_in_property87);  							filter (newProperty);  							PopFollow ();  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (3);  				}  				DebugLocation (23' 49);  				// ./src/Parser/Grammar/JFLWalker.g:23:49: ( block[newProperty] )?  				int alt4 = 2;  				try {  					DebugEnterSubRule (4);  					try {  						DebugEnterDecision (4' false);  						int LA4_1 = input.LA (1);  						if ((LA4_1 == BLOCK)) {  							alt4 = 1;  						}  					}  					finally {  						DebugExitDecision (4);  					}  					switch (alt4) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:23:49: block[newProperty]  						{  							DebugLocation (23' 49);  							PushFollow (Follow._block_in_property91);  							block (newProperty);  							PopFollow ();  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (4);  				}  				Match (input' TokenTypes.Up' null);  			}  			DebugLocation (23' 70);  			if ((not != null ? not.Text : default(string)) == "!")  				newProperty.ToggleInclude ();  			if ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).isRegex : default(bool)))  				parentScope.AddRegexProperty ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).name : default(string))' newProperty);  			else  				parentScope.AddProperty ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).name : default(string))' newProperty);  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("property"' 3);  		LeaveRule ("property"' 3);  		LeaveRule_property ();  	}  	DebugLocation (31' 1);  }  finally {  	DebugExitRule (GrammarFileName' "property");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,property,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "property");  	DebugLocation (19' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:23:2: ( ^( propertyName (not= '!' )? ( filter[newProperty] )? ( block[newProperty] )? ) )  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:23:4: ^( propertyName (not= '!' )? ( filter[newProperty] )? ( block[newProperty] )? )  		{  			DebugLocation (23' 4);  			DebugLocation (23' 6);  			PushFollow (Follow._propertyName_in_property80);  			propertyName1 = propertyName ();  			PopFollow ();  			if (input.LA (1) == TokenTypes.Down) {  				Match (input' TokenTypes.Down' null);  				DebugLocation (23' 22);  				// ./src/Parser/Grammar/JFLWalker.g:23:22: (not= '!' )?  				int alt2 = 2;  				try {  					DebugEnterSubRule (2);  					try {  						DebugEnterDecision (2' false);  						int LA2_1 = input.LA (1);  						if ((LA2_1 == 24)) {  							alt2 = 1;  						}  					}  					finally {  						DebugExitDecision (2);  					}  					switch (alt2) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:23:22: not= '!'  						{  							DebugLocation (23' 22);  							not = (CommonTree)Match (input' 24' Follow._24_in_property84);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (2);  				}  				DebugLocation (23' 28);  				// ./src/Parser/Grammar/JFLWalker.g:23:28: ( filter[newProperty] )?  				int alt3 = 2;  				try {  					DebugEnterSubRule (3);  					try {  						DebugEnterDecision (3' false);  						int LA3_1 = input.LA (1);  						if ((LA3_1 == FILTER)) {  							alt3 = 1;  						}  					}  					finally {  						DebugExitDecision (3);  					}  					switch (alt3) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:23:28: filter[newProperty]  						{  							DebugLocation (23' 28);  							PushFollow (Follow._filter_in_property87);  							filter (newProperty);  							PopFollow ();  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (3);  				}  				DebugLocation (23' 49);  				// ./src/Parser/Grammar/JFLWalker.g:23:49: ( block[newProperty] )?  				int alt4 = 2;  				try {  					DebugEnterSubRule (4);  					try {  						DebugEnterDecision (4' false);  						int LA4_1 = input.LA (1);  						if ((LA4_1 == BLOCK)) {  							alt4 = 1;  						}  					}  					finally {  						DebugExitDecision (4);  					}  					switch (alt4) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:23:49: block[newProperty]  						{  							DebugLocation (23' 49);  							PushFollow (Follow._block_in_property91);  							block (newProperty);  							PopFollow ();  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (4);  				}  				Match (input' TokenTypes.Up' null);  			}  			DebugLocation (23' 70);  			if ((not != null ? not.Text : default(string)) == "!")  				newProperty.ToggleInclude ();  			if ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).isRegex : default(bool)))  				parentScope.AddRegexProperty ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).name : default(string))' newProperty);  			else  				parentScope.AddProperty ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).name : default(string))' newProperty);  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("property"' 3);  		LeaveRule ("property"' 3);  		LeaveRule_property ();  	}  	DebugLocation (31' 1);  }  finally {  	DebugExitRule (GrammarFileName' "property");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,property,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "property");  	DebugLocation (19' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:23:2: ( ^( propertyName (not= '!' )? ( filter[newProperty] )? ( block[newProperty] )? ) )  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:23:4: ^( propertyName (not= '!' )? ( filter[newProperty] )? ( block[newProperty] )? )  		{  			DebugLocation (23' 4);  			DebugLocation (23' 6);  			PushFollow (Follow._propertyName_in_property80);  			propertyName1 = propertyName ();  			PopFollow ();  			if (input.LA (1) == TokenTypes.Down) {  				Match (input' TokenTypes.Down' null);  				DebugLocation (23' 22);  				// ./src/Parser/Grammar/JFLWalker.g:23:22: (not= '!' )?  				int alt2 = 2;  				try {  					DebugEnterSubRule (2);  					try {  						DebugEnterDecision (2' false);  						int LA2_1 = input.LA (1);  						if ((LA2_1 == 24)) {  							alt2 = 1;  						}  					}  					finally {  						DebugExitDecision (2);  					}  					switch (alt2) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:23:22: not= '!'  						{  							DebugLocation (23' 22);  							not = (CommonTree)Match (input' 24' Follow._24_in_property84);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (2);  				}  				DebugLocation (23' 28);  				// ./src/Parser/Grammar/JFLWalker.g:23:28: ( filter[newProperty] )?  				int alt3 = 2;  				try {  					DebugEnterSubRule (3);  					try {  						DebugEnterDecision (3' false);  						int LA3_1 = input.LA (1);  						if ((LA3_1 == FILTER)) {  							alt3 = 1;  						}  					}  					finally {  						DebugExitDecision (3);  					}  					switch (alt3) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:23:28: filter[newProperty]  						{  							DebugLocation (23' 28);  							PushFollow (Follow._filter_in_property87);  							filter (newProperty);  							PopFollow ();  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (3);  				}  				DebugLocation (23' 49);  				// ./src/Parser/Grammar/JFLWalker.g:23:49: ( block[newProperty] )?  				int alt4 = 2;  				try {  					DebugEnterSubRule (4);  					try {  						DebugEnterDecision (4' false);  						int LA4_1 = input.LA (1);  						if ((LA4_1 == BLOCK)) {  							alt4 = 1;  						}  					}  					finally {  						DebugExitDecision (4);  					}  					switch (alt4) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:23:49: block[newProperty]  						{  							DebugLocation (23' 49);  							PushFollow (Follow._block_in_property91);  							block (newProperty);  							PopFollow ();  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (4);  				}  				Match (input' TokenTypes.Up' null);  			}  			DebugLocation (23' 70);  			if ((not != null ? not.Text : default(string)) == "!")  				newProperty.ToggleInclude ();  			if ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).isRegex : default(bool)))  				parentScope.AddRegexProperty ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).name : default(string))' newProperty);  			else  				parentScope.AddProperty ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).name : default(string))' newProperty);  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("property"' 3);  		LeaveRule ("property"' 3);  		LeaveRule_property ();  	}  	DebugLocation (31' 1);  }  finally {  	DebugExitRule (GrammarFileName' "property");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,property,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "property");  	DebugLocation (19' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:23:2: ( ^( propertyName (not= '!' )? ( filter[newProperty] )? ( block[newProperty] )? ) )  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:23:4: ^( propertyName (not= '!' )? ( filter[newProperty] )? ( block[newProperty] )? )  		{  			DebugLocation (23' 4);  			DebugLocation (23' 6);  			PushFollow (Follow._propertyName_in_property80);  			propertyName1 = propertyName ();  			PopFollow ();  			if (input.LA (1) == TokenTypes.Down) {  				Match (input' TokenTypes.Down' null);  				DebugLocation (23' 22);  				// ./src/Parser/Grammar/JFLWalker.g:23:22: (not= '!' )?  				int alt2 = 2;  				try {  					DebugEnterSubRule (2);  					try {  						DebugEnterDecision (2' false);  						int LA2_1 = input.LA (1);  						if ((LA2_1 == 24)) {  							alt2 = 1;  						}  					}  					finally {  						DebugExitDecision (2);  					}  					switch (alt2) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:23:22: not= '!'  						{  							DebugLocation (23' 22);  							not = (CommonTree)Match (input' 24' Follow._24_in_property84);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (2);  				}  				DebugLocation (23' 28);  				// ./src/Parser/Grammar/JFLWalker.g:23:28: ( filter[newProperty] )?  				int alt3 = 2;  				try {  					DebugEnterSubRule (3);  					try {  						DebugEnterDecision (3' false);  						int LA3_1 = input.LA (1);  						if ((LA3_1 == FILTER)) {  							alt3 = 1;  						}  					}  					finally {  						DebugExitDecision (3);  					}  					switch (alt3) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:23:28: filter[newProperty]  						{  							DebugLocation (23' 28);  							PushFollow (Follow._filter_in_property87);  							filter (newProperty);  							PopFollow ();  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (3);  				}  				DebugLocation (23' 49);  				// ./src/Parser/Grammar/JFLWalker.g:23:49: ( block[newProperty] )?  				int alt4 = 2;  				try {  					DebugEnterSubRule (4);  					try {  						DebugEnterDecision (4' false);  						int LA4_1 = input.LA (1);  						if ((LA4_1 == BLOCK)) {  							alt4 = 1;  						}  					}  					finally {  						DebugExitDecision (4);  					}  					switch (alt4) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:23:49: block[newProperty]  						{  							DebugLocation (23' 49);  							PushFollow (Follow._block_in_property91);  							block (newProperty);  							PopFollow ();  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (4);  				}  				Match (input' TokenTypes.Up' null);  			}  			DebugLocation (23' 70);  			if ((not != null ? not.Text : default(string)) == "!")  				newProperty.ToggleInclude ();  			if ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).isRegex : default(bool)))  				parentScope.AddRegexProperty ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).name : default(string))' newProperty);  			else  				parentScope.AddProperty ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).name : default(string))' newProperty);  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("property"' 3);  		LeaveRule ("property"' 3);  		LeaveRule_property ();  	}  	DebugLocation (31' 1);  }  finally {  	DebugExitRule (GrammarFileName' "property");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,property,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "property");  	DebugLocation (19' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:23:2: ( ^( propertyName (not= '!' )? ( filter[newProperty] )? ( block[newProperty] )? ) )  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:23:4: ^( propertyName (not= '!' )? ( filter[newProperty] )? ( block[newProperty] )? )  		{  			DebugLocation (23' 4);  			DebugLocation (23' 6);  			PushFollow (Follow._propertyName_in_property80);  			propertyName1 = propertyName ();  			PopFollow ();  			if (input.LA (1) == TokenTypes.Down) {  				Match (input' TokenTypes.Down' null);  				DebugLocation (23' 22);  				// ./src/Parser/Grammar/JFLWalker.g:23:22: (not= '!' )?  				int alt2 = 2;  				try {  					DebugEnterSubRule (2);  					try {  						DebugEnterDecision (2' false);  						int LA2_1 = input.LA (1);  						if ((LA2_1 == 24)) {  							alt2 = 1;  						}  					}  					finally {  						DebugExitDecision (2);  					}  					switch (alt2) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:23:22: not= '!'  						{  							DebugLocation (23' 22);  							not = (CommonTree)Match (input' 24' Follow._24_in_property84);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (2);  				}  				DebugLocation (23' 28);  				// ./src/Parser/Grammar/JFLWalker.g:23:28: ( filter[newProperty] )?  				int alt3 = 2;  				try {  					DebugEnterSubRule (3);  					try {  						DebugEnterDecision (3' false);  						int LA3_1 = input.LA (1);  						if ((LA3_1 == FILTER)) {  							alt3 = 1;  						}  					}  					finally {  						DebugExitDecision (3);  					}  					switch (alt3) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:23:28: filter[newProperty]  						{  							DebugLocation (23' 28);  							PushFollow (Follow._filter_in_property87);  							filter (newProperty);  							PopFollow ();  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (3);  				}  				DebugLocation (23' 49);  				// ./src/Parser/Grammar/JFLWalker.g:23:49: ( block[newProperty] )?  				int alt4 = 2;  				try {  					DebugEnterSubRule (4);  					try {  						DebugEnterDecision (4' false);  						int LA4_1 = input.LA (1);  						if ((LA4_1 == BLOCK)) {  							alt4 = 1;  						}  					}  					finally {  						DebugExitDecision (4);  					}  					switch (alt4) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:23:49: block[newProperty]  						{  							DebugLocation (23' 49);  							PushFollow (Follow._block_in_property91);  							block (newProperty);  							PopFollow ();  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (4);  				}  				Match (input' TokenTypes.Up' null);  			}  			DebugLocation (23' 70);  			if ((not != null ? not.Text : default(string)) == "!")  				newProperty.ToggleInclude ();  			if ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).isRegex : default(bool)))  				parentScope.AddRegexProperty ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).name : default(string))' newProperty);  			else  				parentScope.AddProperty ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).name : default(string))' newProperty);  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("property"' 3);  		LeaveRule ("property"' 3);  		LeaveRule_property ();  	}  	DebugLocation (31' 1);  }  finally {  	DebugExitRule (GrammarFileName' "property");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,property,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "property");  	DebugLocation (19' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:23:2: ( ^( propertyName (not= '!' )? ( filter[newProperty] )? ( block[newProperty] )? ) )  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:23:4: ^( propertyName (not= '!' )? ( filter[newProperty] )? ( block[newProperty] )? )  		{  			DebugLocation (23' 4);  			DebugLocation (23' 6);  			PushFollow (Follow._propertyName_in_property80);  			propertyName1 = propertyName ();  			PopFollow ();  			if (input.LA (1) == TokenTypes.Down) {  				Match (input' TokenTypes.Down' null);  				DebugLocation (23' 22);  				// ./src/Parser/Grammar/JFLWalker.g:23:22: (not= '!' )?  				int alt2 = 2;  				try {  					DebugEnterSubRule (2);  					try {  						DebugEnterDecision (2' false);  						int LA2_1 = input.LA (1);  						if ((LA2_1 == 24)) {  							alt2 = 1;  						}  					}  					finally {  						DebugExitDecision (2);  					}  					switch (alt2) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:23:22: not= '!'  						{  							DebugLocation (23' 22);  							not = (CommonTree)Match (input' 24' Follow._24_in_property84);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (2);  				}  				DebugLocation (23' 28);  				// ./src/Parser/Grammar/JFLWalker.g:23:28: ( filter[newProperty] )?  				int alt3 = 2;  				try {  					DebugEnterSubRule (3);  					try {  						DebugEnterDecision (3' false);  						int LA3_1 = input.LA (1);  						if ((LA3_1 == FILTER)) {  							alt3 = 1;  						}  					}  					finally {  						DebugExitDecision (3);  					}  					switch (alt3) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:23:28: filter[newProperty]  						{  							DebugLocation (23' 28);  							PushFollow (Follow._filter_in_property87);  							filter (newProperty);  							PopFollow ();  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (3);  				}  				DebugLocation (23' 49);  				// ./src/Parser/Grammar/JFLWalker.g:23:49: ( block[newProperty] )?  				int alt4 = 2;  				try {  					DebugEnterSubRule (4);  					try {  						DebugEnterDecision (4' false);  						int LA4_1 = input.LA (1);  						if ((LA4_1 == BLOCK)) {  							alt4 = 1;  						}  					}  					finally {  						DebugExitDecision (4);  					}  					switch (alt4) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:23:49: block[newProperty]  						{  							DebugLocation (23' 49);  							PushFollow (Follow._block_in_property91);  							block (newProperty);  							PopFollow ();  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (4);  				}  				Match (input' TokenTypes.Up' null);  			}  			DebugLocation (23' 70);  			if ((not != null ? not.Text : default(string)) == "!")  				newProperty.ToggleInclude ();  			if ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).isRegex : default(bool)))  				parentScope.AddRegexProperty ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).name : default(string))' newProperty);  			else  				parentScope.AddProperty ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).name : default(string))' newProperty);  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("property"' 3);  		LeaveRule ("property"' 3);  		LeaveRule_property ();  	}  	DebugLocation (31' 1);  }  finally {  	DebugExitRule (GrammarFileName' "property");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,property,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "property");  	DebugLocation (19' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:23:2: ( ^( propertyName (not= '!' )? ( filter[newProperty] )? ( block[newProperty] )? ) )  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:23:4: ^( propertyName (not= '!' )? ( filter[newProperty] )? ( block[newProperty] )? )  		{  			DebugLocation (23' 4);  			DebugLocation (23' 6);  			PushFollow (Follow._propertyName_in_property80);  			propertyName1 = propertyName ();  			PopFollow ();  			if (input.LA (1) == TokenTypes.Down) {  				Match (input' TokenTypes.Down' null);  				DebugLocation (23' 22);  				// ./src/Parser/Grammar/JFLWalker.g:23:22: (not= '!' )?  				int alt2 = 2;  				try {  					DebugEnterSubRule (2);  					try {  						DebugEnterDecision (2' false);  						int LA2_1 = input.LA (1);  						if ((LA2_1 == 24)) {  							alt2 = 1;  						}  					}  					finally {  						DebugExitDecision (2);  					}  					switch (alt2) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:23:22: not= '!'  						{  							DebugLocation (23' 22);  							not = (CommonTree)Match (input' 24' Follow._24_in_property84);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (2);  				}  				DebugLocation (23' 28);  				// ./src/Parser/Grammar/JFLWalker.g:23:28: ( filter[newProperty] )?  				int alt3 = 2;  				try {  					DebugEnterSubRule (3);  					try {  						DebugEnterDecision (3' false);  						int LA3_1 = input.LA (1);  						if ((LA3_1 == FILTER)) {  							alt3 = 1;  						}  					}  					finally {  						DebugExitDecision (3);  					}  					switch (alt3) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:23:28: filter[newProperty]  						{  							DebugLocation (23' 28);  							PushFollow (Follow._filter_in_property87);  							filter (newProperty);  							PopFollow ();  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (3);  				}  				DebugLocation (23' 49);  				// ./src/Parser/Grammar/JFLWalker.g:23:49: ( block[newProperty] )?  				int alt4 = 2;  				try {  					DebugEnterSubRule (4);  					try {  						DebugEnterDecision (4' false);  						int LA4_1 = input.LA (1);  						if ((LA4_1 == BLOCK)) {  							alt4 = 1;  						}  					}  					finally {  						DebugExitDecision (4);  					}  					switch (alt4) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:23:49: block[newProperty]  						{  							DebugLocation (23' 49);  							PushFollow (Follow._block_in_property91);  							block (newProperty);  							PopFollow ();  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (4);  				}  				Match (input' TokenTypes.Up' null);  			}  			DebugLocation (23' 70);  			if ((not != null ? not.Text : default(string)) == "!")  				newProperty.ToggleInclude ();  			if ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).isRegex : default(bool)))  				parentScope.AddRegexProperty ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).name : default(string))' newProperty);  			else  				parentScope.AddProperty ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).name : default(string))' newProperty);  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("property"' 3);  		LeaveRule ("property"' 3);  		LeaveRule_property ();  	}  	DebugLocation (31' 1);  }  finally {  	DebugExitRule (GrammarFileName' "property");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,property,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "property");  	DebugLocation (19' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:23:2: ( ^( propertyName (not= '!' )? ( filter[newProperty] )? ( block[newProperty] )? ) )  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:23:4: ^( propertyName (not= '!' )? ( filter[newProperty] )? ( block[newProperty] )? )  		{  			DebugLocation (23' 4);  			DebugLocation (23' 6);  			PushFollow (Follow._propertyName_in_property80);  			propertyName1 = propertyName ();  			PopFollow ();  			if (input.LA (1) == TokenTypes.Down) {  				Match (input' TokenTypes.Down' null);  				DebugLocation (23' 22);  				// ./src/Parser/Grammar/JFLWalker.g:23:22: (not= '!' )?  				int alt2 = 2;  				try {  					DebugEnterSubRule (2);  					try {  						DebugEnterDecision (2' false);  						int LA2_1 = input.LA (1);  						if ((LA2_1 == 24)) {  							alt2 = 1;  						}  					}  					finally {  						DebugExitDecision (2);  					}  					switch (alt2) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:23:22: not= '!'  						{  							DebugLocation (23' 22);  							not = (CommonTree)Match (input' 24' Follow._24_in_property84);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (2);  				}  				DebugLocation (23' 28);  				// ./src/Parser/Grammar/JFLWalker.g:23:28: ( filter[newProperty] )?  				int alt3 = 2;  				try {  					DebugEnterSubRule (3);  					try {  						DebugEnterDecision (3' false);  						int LA3_1 = input.LA (1);  						if ((LA3_1 == FILTER)) {  							alt3 = 1;  						}  					}  					finally {  						DebugExitDecision (3);  					}  					switch (alt3) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:23:28: filter[newProperty]  						{  							DebugLocation (23' 28);  							PushFollow (Follow._filter_in_property87);  							filter (newProperty);  							PopFollow ();  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (3);  				}  				DebugLocation (23' 49);  				// ./src/Parser/Grammar/JFLWalker.g:23:49: ( block[newProperty] )?  				int alt4 = 2;  				try {  					DebugEnterSubRule (4);  					try {  						DebugEnterDecision (4' false);  						int LA4_1 = input.LA (1);  						if ((LA4_1 == BLOCK)) {  							alt4 = 1;  						}  					}  					finally {  						DebugExitDecision (4);  					}  					switch (alt4) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:23:49: block[newProperty]  						{  							DebugLocation (23' 49);  							PushFollow (Follow._block_in_property91);  							block (newProperty);  							PopFollow ();  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (4);  				}  				Match (input' TokenTypes.Up' null);  			}  			DebugLocation (23' 70);  			if ((not != null ? not.Text : default(string)) == "!")  				newProperty.ToggleInclude ();  			if ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).isRegex : default(bool)))  				parentScope.AddRegexProperty ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).name : default(string))' newProperty);  			else  				parentScope.AddProperty ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).name : default(string))' newProperty);  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("property"' 3);  		LeaveRule ("property"' 3);  		LeaveRule_property ();  	}  	DebugLocation (31' 1);  }  finally {  	DebugExitRule (GrammarFileName' "property");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,property,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "property");  	DebugLocation (19' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:23:2: ( ^( propertyName (not= '!' )? ( filter[newProperty] )? ( block[newProperty] )? ) )  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:23:4: ^( propertyName (not= '!' )? ( filter[newProperty] )? ( block[newProperty] )? )  		{  			DebugLocation (23' 4);  			DebugLocation (23' 6);  			PushFollow (Follow._propertyName_in_property80);  			propertyName1 = propertyName ();  			PopFollow ();  			if (input.LA (1) == TokenTypes.Down) {  				Match (input' TokenTypes.Down' null);  				DebugLocation (23' 22);  				// ./src/Parser/Grammar/JFLWalker.g:23:22: (not= '!' )?  				int alt2 = 2;  				try {  					DebugEnterSubRule (2);  					try {  						DebugEnterDecision (2' false);  						int LA2_1 = input.LA (1);  						if ((LA2_1 == 24)) {  							alt2 = 1;  						}  					}  					finally {  						DebugExitDecision (2);  					}  					switch (alt2) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:23:22: not= '!'  						{  							DebugLocation (23' 22);  							not = (CommonTree)Match (input' 24' Follow._24_in_property84);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (2);  				}  				DebugLocation (23' 28);  				// ./src/Parser/Grammar/JFLWalker.g:23:28: ( filter[newProperty] )?  				int alt3 = 2;  				try {  					DebugEnterSubRule (3);  					try {  						DebugEnterDecision (3' false);  						int LA3_1 = input.LA (1);  						if ((LA3_1 == FILTER)) {  							alt3 = 1;  						}  					}  					finally {  						DebugExitDecision (3);  					}  					switch (alt3) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:23:28: filter[newProperty]  						{  							DebugLocation (23' 28);  							PushFollow (Follow._filter_in_property87);  							filter (newProperty);  							PopFollow ();  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (3);  				}  				DebugLocation (23' 49);  				// ./src/Parser/Grammar/JFLWalker.g:23:49: ( block[newProperty] )?  				int alt4 = 2;  				try {  					DebugEnterSubRule (4);  					try {  						DebugEnterDecision (4' false);  						int LA4_1 = input.LA (1);  						if ((LA4_1 == BLOCK)) {  							alt4 = 1;  						}  					}  					finally {  						DebugExitDecision (4);  					}  					switch (alt4) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:23:49: block[newProperty]  						{  							DebugLocation (23' 49);  							PushFollow (Follow._block_in_property91);  							block (newProperty);  							PopFollow ();  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (4);  				}  				Match (input' TokenTypes.Up' null);  			}  			DebugLocation (23' 70);  			if ((not != null ? not.Text : default(string)) == "!")  				newProperty.ToggleInclude ();  			if ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).isRegex : default(bool)))  				parentScope.AddRegexProperty ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).name : default(string))' newProperty);  			else  				parentScope.AddProperty ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).name : default(string))' newProperty);  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("property"' 3);  		LeaveRule ("property"' 3);  		LeaveRule_property ();  	}  	DebugLocation (31' 1);  }  finally {  	DebugExitRule (GrammarFileName' "property");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,property,The following statement contains a magic number: DebugLocation (19' 1);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,property,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:23:2: ( ^( propertyName (not= '!' )? ( filter[newProperty] )? ( block[newProperty] )? ) )  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:23:4: ^( propertyName (not= '!' )? ( filter[newProperty] )? ( block[newProperty] )? )  	{  		DebugLocation (23' 4);  		DebugLocation (23' 6);  		PushFollow (Follow._propertyName_in_property80);  		propertyName1 = propertyName ();  		PopFollow ();  		if (input.LA (1) == TokenTypes.Down) {  			Match (input' TokenTypes.Down' null);  			DebugLocation (23' 22);  			// ./src/Parser/Grammar/JFLWalker.g:23:22: (not= '!' )?  			int alt2 = 2;  			try {  				DebugEnterSubRule (2);  				try {  					DebugEnterDecision (2' false);  					int LA2_1 = input.LA (1);  					if ((LA2_1 == 24)) {  						alt2 = 1;  					}  				}  				finally {  					DebugExitDecision (2);  				}  				switch (alt2) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:23:22: not= '!'  					{  						DebugLocation (23' 22);  						not = (CommonTree)Match (input' 24' Follow._24_in_property84);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (2);  			}  			DebugLocation (23' 28);  			// ./src/Parser/Grammar/JFLWalker.g:23:28: ( filter[newProperty] )?  			int alt3 = 2;  			try {  				DebugEnterSubRule (3);  				try {  					DebugEnterDecision (3' false);  					int LA3_1 = input.LA (1);  					if ((LA3_1 == FILTER)) {  						alt3 = 1;  					}  				}  				finally {  					DebugExitDecision (3);  				}  				switch (alt3) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:23:28: filter[newProperty]  					{  						DebugLocation (23' 28);  						PushFollow (Follow._filter_in_property87);  						filter (newProperty);  						PopFollow ();  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (3);  			}  			DebugLocation (23' 49);  			// ./src/Parser/Grammar/JFLWalker.g:23:49: ( block[newProperty] )?  			int alt4 = 2;  			try {  				DebugEnterSubRule (4);  				try {  					DebugEnterDecision (4' false);  					int LA4_1 = input.LA (1);  					if ((LA4_1 == BLOCK)) {  						alt4 = 1;  					}  				}  				finally {  					DebugExitDecision (4);  				}  				switch (alt4) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:23:49: block[newProperty]  					{  						DebugLocation (23' 49);  						PushFollow (Follow._block_in_property91);  						block (newProperty);  						PopFollow ();  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (4);  			}  			Match (input' TokenTypes.Up' null);  		}  		DebugLocation (23' 70);  		if ((not != null ? not.Text : default(string)) == "!")  			newProperty.ToggleInclude ();  		if ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).isRegex : default(bool)))  			parentScope.AddRegexProperty ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).name : default(string))' newProperty);  		else  			parentScope.AddProperty ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).name : default(string))' newProperty);  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("property"' 3);  	LeaveRule ("property"' 3);  	LeaveRule_property ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,property,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:23:2: ( ^( propertyName (not= '!' )? ( filter[newProperty] )? ( block[newProperty] )? ) )  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:23:4: ^( propertyName (not= '!' )? ( filter[newProperty] )? ( block[newProperty] )? )  	{  		DebugLocation (23' 4);  		DebugLocation (23' 6);  		PushFollow (Follow._propertyName_in_property80);  		propertyName1 = propertyName ();  		PopFollow ();  		if (input.LA (1) == TokenTypes.Down) {  			Match (input' TokenTypes.Down' null);  			DebugLocation (23' 22);  			// ./src/Parser/Grammar/JFLWalker.g:23:22: (not= '!' )?  			int alt2 = 2;  			try {  				DebugEnterSubRule (2);  				try {  					DebugEnterDecision (2' false);  					int LA2_1 = input.LA (1);  					if ((LA2_1 == 24)) {  						alt2 = 1;  					}  				}  				finally {  					DebugExitDecision (2);  				}  				switch (alt2) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:23:22: not= '!'  					{  						DebugLocation (23' 22);  						not = (CommonTree)Match (input' 24' Follow._24_in_property84);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (2);  			}  			DebugLocation (23' 28);  			// ./src/Parser/Grammar/JFLWalker.g:23:28: ( filter[newProperty] )?  			int alt3 = 2;  			try {  				DebugEnterSubRule (3);  				try {  					DebugEnterDecision (3' false);  					int LA3_1 = input.LA (1);  					if ((LA3_1 == FILTER)) {  						alt3 = 1;  					}  				}  				finally {  					DebugExitDecision (3);  				}  				switch (alt3) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:23:28: filter[newProperty]  					{  						DebugLocation (23' 28);  						PushFollow (Follow._filter_in_property87);  						filter (newProperty);  						PopFollow ();  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (3);  			}  			DebugLocation (23' 49);  			// ./src/Parser/Grammar/JFLWalker.g:23:49: ( block[newProperty] )?  			int alt4 = 2;  			try {  				DebugEnterSubRule (4);  				try {  					DebugEnterDecision (4' false);  					int LA4_1 = input.LA (1);  					if ((LA4_1 == BLOCK)) {  						alt4 = 1;  					}  				}  				finally {  					DebugExitDecision (4);  				}  				switch (alt4) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:23:49: block[newProperty]  					{  						DebugLocation (23' 49);  						PushFollow (Follow._block_in_property91);  						block (newProperty);  						PopFollow ();  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (4);  			}  			Match (input' TokenTypes.Up' null);  		}  		DebugLocation (23' 70);  		if ((not != null ? not.Text : default(string)) == "!")  			newProperty.ToggleInclude ();  		if ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).isRegex : default(bool)))  			parentScope.AddRegexProperty ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).name : default(string))' newProperty);  		else  			parentScope.AddProperty ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).name : default(string))' newProperty);  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("property"' 3);  	LeaveRule ("property"' 3);  	LeaveRule_property ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,property,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:23:2: ( ^( propertyName (not= '!' )? ( filter[newProperty] )? ( block[newProperty] )? ) )  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:23:4: ^( propertyName (not= '!' )? ( filter[newProperty] )? ( block[newProperty] )? )  	{  		DebugLocation (23' 4);  		DebugLocation (23' 6);  		PushFollow (Follow._propertyName_in_property80);  		propertyName1 = propertyName ();  		PopFollow ();  		if (input.LA (1) == TokenTypes.Down) {  			Match (input' TokenTypes.Down' null);  			DebugLocation (23' 22);  			// ./src/Parser/Grammar/JFLWalker.g:23:22: (not= '!' )?  			int alt2 = 2;  			try {  				DebugEnterSubRule (2);  				try {  					DebugEnterDecision (2' false);  					int LA2_1 = input.LA (1);  					if ((LA2_1 == 24)) {  						alt2 = 1;  					}  				}  				finally {  					DebugExitDecision (2);  				}  				switch (alt2) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:23:22: not= '!'  					{  						DebugLocation (23' 22);  						not = (CommonTree)Match (input' 24' Follow._24_in_property84);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (2);  			}  			DebugLocation (23' 28);  			// ./src/Parser/Grammar/JFLWalker.g:23:28: ( filter[newProperty] )?  			int alt3 = 2;  			try {  				DebugEnterSubRule (3);  				try {  					DebugEnterDecision (3' false);  					int LA3_1 = input.LA (1);  					if ((LA3_1 == FILTER)) {  						alt3 = 1;  					}  				}  				finally {  					DebugExitDecision (3);  				}  				switch (alt3) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:23:28: filter[newProperty]  					{  						DebugLocation (23' 28);  						PushFollow (Follow._filter_in_property87);  						filter (newProperty);  						PopFollow ();  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (3);  			}  			DebugLocation (23' 49);  			// ./src/Parser/Grammar/JFLWalker.g:23:49: ( block[newProperty] )?  			int alt4 = 2;  			try {  				DebugEnterSubRule (4);  				try {  					DebugEnterDecision (4' false);  					int LA4_1 = input.LA (1);  					if ((LA4_1 == BLOCK)) {  						alt4 = 1;  					}  				}  				finally {  					DebugExitDecision (4);  				}  				switch (alt4) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:23:49: block[newProperty]  					{  						DebugLocation (23' 49);  						PushFollow (Follow._block_in_property91);  						block (newProperty);  						PopFollow ();  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (4);  			}  			Match (input' TokenTypes.Up' null);  		}  		DebugLocation (23' 70);  		if ((not != null ? not.Text : default(string)) == "!")  			newProperty.ToggleInclude ();  		if ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).isRegex : default(bool)))  			parentScope.AddRegexProperty ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).name : default(string))' newProperty);  		else  			parentScope.AddProperty ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).name : default(string))' newProperty);  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("property"' 3);  	LeaveRule ("property"' 3);  	LeaveRule_property ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,property,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:23:2: ( ^( propertyName (not= '!' )? ( filter[newProperty] )? ( block[newProperty] )? ) )  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:23:4: ^( propertyName (not= '!' )? ( filter[newProperty] )? ( block[newProperty] )? )  	{  		DebugLocation (23' 4);  		DebugLocation (23' 6);  		PushFollow (Follow._propertyName_in_property80);  		propertyName1 = propertyName ();  		PopFollow ();  		if (input.LA (1) == TokenTypes.Down) {  			Match (input' TokenTypes.Down' null);  			DebugLocation (23' 22);  			// ./src/Parser/Grammar/JFLWalker.g:23:22: (not= '!' )?  			int alt2 = 2;  			try {  				DebugEnterSubRule (2);  				try {  					DebugEnterDecision (2' false);  					int LA2_1 = input.LA (1);  					if ((LA2_1 == 24)) {  						alt2 = 1;  					}  				}  				finally {  					DebugExitDecision (2);  				}  				switch (alt2) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:23:22: not= '!'  					{  						DebugLocation (23' 22);  						not = (CommonTree)Match (input' 24' Follow._24_in_property84);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (2);  			}  			DebugLocation (23' 28);  			// ./src/Parser/Grammar/JFLWalker.g:23:28: ( filter[newProperty] )?  			int alt3 = 2;  			try {  				DebugEnterSubRule (3);  				try {  					DebugEnterDecision (3' false);  					int LA3_1 = input.LA (1);  					if ((LA3_1 == FILTER)) {  						alt3 = 1;  					}  				}  				finally {  					DebugExitDecision (3);  				}  				switch (alt3) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:23:28: filter[newProperty]  					{  						DebugLocation (23' 28);  						PushFollow (Follow._filter_in_property87);  						filter (newProperty);  						PopFollow ();  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (3);  			}  			DebugLocation (23' 49);  			// ./src/Parser/Grammar/JFLWalker.g:23:49: ( block[newProperty] )?  			int alt4 = 2;  			try {  				DebugEnterSubRule (4);  				try {  					DebugEnterDecision (4' false);  					int LA4_1 = input.LA (1);  					if ((LA4_1 == BLOCK)) {  						alt4 = 1;  					}  				}  				finally {  					DebugExitDecision (4);  				}  				switch (alt4) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:23:49: block[newProperty]  					{  						DebugLocation (23' 49);  						PushFollow (Follow._block_in_property91);  						block (newProperty);  						PopFollow ();  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (4);  			}  			Match (input' TokenTypes.Up' null);  		}  		DebugLocation (23' 70);  		if ((not != null ? not.Text : default(string)) == "!")  			newProperty.ToggleInclude ();  		if ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).isRegex : default(bool)))  			parentScope.AddRegexProperty ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).name : default(string))' newProperty);  		else  			parentScope.AddProperty ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).name : default(string))' newProperty);  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("property"' 3);  	LeaveRule ("property"' 3);  	LeaveRule_property ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,property,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:23:2: ( ^( propertyName (not= '!' )? ( filter[newProperty] )? ( block[newProperty] )? ) )  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:23:4: ^( propertyName (not= '!' )? ( filter[newProperty] )? ( block[newProperty] )? )  	{  		DebugLocation (23' 4);  		DebugLocation (23' 6);  		PushFollow (Follow._propertyName_in_property80);  		propertyName1 = propertyName ();  		PopFollow ();  		if (input.LA (1) == TokenTypes.Down) {  			Match (input' TokenTypes.Down' null);  			DebugLocation (23' 22);  			// ./src/Parser/Grammar/JFLWalker.g:23:22: (not= '!' )?  			int alt2 = 2;  			try {  				DebugEnterSubRule (2);  				try {  					DebugEnterDecision (2' false);  					int LA2_1 = input.LA (1);  					if ((LA2_1 == 24)) {  						alt2 = 1;  					}  				}  				finally {  					DebugExitDecision (2);  				}  				switch (alt2) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:23:22: not= '!'  					{  						DebugLocation (23' 22);  						not = (CommonTree)Match (input' 24' Follow._24_in_property84);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (2);  			}  			DebugLocation (23' 28);  			// ./src/Parser/Grammar/JFLWalker.g:23:28: ( filter[newProperty] )?  			int alt3 = 2;  			try {  				DebugEnterSubRule (3);  				try {  					DebugEnterDecision (3' false);  					int LA3_1 = input.LA (1);  					if ((LA3_1 == FILTER)) {  						alt3 = 1;  					}  				}  				finally {  					DebugExitDecision (3);  				}  				switch (alt3) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:23:28: filter[newProperty]  					{  						DebugLocation (23' 28);  						PushFollow (Follow._filter_in_property87);  						filter (newProperty);  						PopFollow ();  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (3);  			}  			DebugLocation (23' 49);  			// ./src/Parser/Grammar/JFLWalker.g:23:49: ( block[newProperty] )?  			int alt4 = 2;  			try {  				DebugEnterSubRule (4);  				try {  					DebugEnterDecision (4' false);  					int LA4_1 = input.LA (1);  					if ((LA4_1 == BLOCK)) {  						alt4 = 1;  					}  				}  				finally {  					DebugExitDecision (4);  				}  				switch (alt4) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:23:49: block[newProperty]  					{  						DebugLocation (23' 49);  						PushFollow (Follow._block_in_property91);  						block (newProperty);  						PopFollow ();  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (4);  			}  			Match (input' TokenTypes.Up' null);  		}  		DebugLocation (23' 70);  		if ((not != null ? not.Text : default(string)) == "!")  			newProperty.ToggleInclude ();  		if ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).isRegex : default(bool)))  			parentScope.AddRegexProperty ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).name : default(string))' newProperty);  		else  			parentScope.AddProperty ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).name : default(string))' newProperty);  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("property"' 3);  	LeaveRule ("property"' 3);  	LeaveRule_property ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,property,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:23:2: ( ^( propertyName (not= '!' )? ( filter[newProperty] )? ( block[newProperty] )? ) )  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:23:4: ^( propertyName (not= '!' )? ( filter[newProperty] )? ( block[newProperty] )? )  	{  		DebugLocation (23' 4);  		DebugLocation (23' 6);  		PushFollow (Follow._propertyName_in_property80);  		propertyName1 = propertyName ();  		PopFollow ();  		if (input.LA (1) == TokenTypes.Down) {  			Match (input' TokenTypes.Down' null);  			DebugLocation (23' 22);  			// ./src/Parser/Grammar/JFLWalker.g:23:22: (not= '!' )?  			int alt2 = 2;  			try {  				DebugEnterSubRule (2);  				try {  					DebugEnterDecision (2' false);  					int LA2_1 = input.LA (1);  					if ((LA2_1 == 24)) {  						alt2 = 1;  					}  				}  				finally {  					DebugExitDecision (2);  				}  				switch (alt2) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:23:22: not= '!'  					{  						DebugLocation (23' 22);  						not = (CommonTree)Match (input' 24' Follow._24_in_property84);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (2);  			}  			DebugLocation (23' 28);  			// ./src/Parser/Grammar/JFLWalker.g:23:28: ( filter[newProperty] )?  			int alt3 = 2;  			try {  				DebugEnterSubRule (3);  				try {  					DebugEnterDecision (3' false);  					int LA3_1 = input.LA (1);  					if ((LA3_1 == FILTER)) {  						alt3 = 1;  					}  				}  				finally {  					DebugExitDecision (3);  				}  				switch (alt3) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:23:28: filter[newProperty]  					{  						DebugLocation (23' 28);  						PushFollow (Follow._filter_in_property87);  						filter (newProperty);  						PopFollow ();  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (3);  			}  			DebugLocation (23' 49);  			// ./src/Parser/Grammar/JFLWalker.g:23:49: ( block[newProperty] )?  			int alt4 = 2;  			try {  				DebugEnterSubRule (4);  				try {  					DebugEnterDecision (4' false);  					int LA4_1 = input.LA (1);  					if ((LA4_1 == BLOCK)) {  						alt4 = 1;  					}  				}  				finally {  					DebugExitDecision (4);  				}  				switch (alt4) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:23:49: block[newProperty]  					{  						DebugLocation (23' 49);  						PushFollow (Follow._block_in_property91);  						block (newProperty);  						PopFollow ();  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (4);  			}  			Match (input' TokenTypes.Up' null);  		}  		DebugLocation (23' 70);  		if ((not != null ? not.Text : default(string)) == "!")  			newProperty.ToggleInclude ();  		if ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).isRegex : default(bool)))  			parentScope.AddRegexProperty ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).name : default(string))' newProperty);  		else  			parentScope.AddProperty ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).name : default(string))' newProperty);  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("property"' 3);  	LeaveRule ("property"' 3);  	LeaveRule_property ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,property,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:23:2: ( ^( propertyName (not= '!' )? ( filter[newProperty] )? ( block[newProperty] )? ) )  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:23:4: ^( propertyName (not= '!' )? ( filter[newProperty] )? ( block[newProperty] )? )  	{  		DebugLocation (23' 4);  		DebugLocation (23' 6);  		PushFollow (Follow._propertyName_in_property80);  		propertyName1 = propertyName ();  		PopFollow ();  		if (input.LA (1) == TokenTypes.Down) {  			Match (input' TokenTypes.Down' null);  			DebugLocation (23' 22);  			// ./src/Parser/Grammar/JFLWalker.g:23:22: (not= '!' )?  			int alt2 = 2;  			try {  				DebugEnterSubRule (2);  				try {  					DebugEnterDecision (2' false);  					int LA2_1 = input.LA (1);  					if ((LA2_1 == 24)) {  						alt2 = 1;  					}  				}  				finally {  					DebugExitDecision (2);  				}  				switch (alt2) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:23:22: not= '!'  					{  						DebugLocation (23' 22);  						not = (CommonTree)Match (input' 24' Follow._24_in_property84);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (2);  			}  			DebugLocation (23' 28);  			// ./src/Parser/Grammar/JFLWalker.g:23:28: ( filter[newProperty] )?  			int alt3 = 2;  			try {  				DebugEnterSubRule (3);  				try {  					DebugEnterDecision (3' false);  					int LA3_1 = input.LA (1);  					if ((LA3_1 == FILTER)) {  						alt3 = 1;  					}  				}  				finally {  					DebugExitDecision (3);  				}  				switch (alt3) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:23:28: filter[newProperty]  					{  						DebugLocation (23' 28);  						PushFollow (Follow._filter_in_property87);  						filter (newProperty);  						PopFollow ();  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (3);  			}  			DebugLocation (23' 49);  			// ./src/Parser/Grammar/JFLWalker.g:23:49: ( block[newProperty] )?  			int alt4 = 2;  			try {  				DebugEnterSubRule (4);  				try {  					DebugEnterDecision (4' false);  					int LA4_1 = input.LA (1);  					if ((LA4_1 == BLOCK)) {  						alt4 = 1;  					}  				}  				finally {  					DebugExitDecision (4);  				}  				switch (alt4) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:23:49: block[newProperty]  					{  						DebugLocation (23' 49);  						PushFollow (Follow._block_in_property91);  						block (newProperty);  						PopFollow ();  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (4);  			}  			Match (input' TokenTypes.Up' null);  		}  		DebugLocation (23' 70);  		if ((not != null ? not.Text : default(string)) == "!")  			newProperty.ToggleInclude ();  		if ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).isRegex : default(bool)))  			parentScope.AddRegexProperty ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).name : default(string))' newProperty);  		else  			parentScope.AddProperty ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).name : default(string))' newProperty);  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("property"' 3);  	LeaveRule ("property"' 3);  	LeaveRule_property ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,property,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:23:2: ( ^( propertyName (not= '!' )? ( filter[newProperty] )? ( block[newProperty] )? ) )  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:23:4: ^( propertyName (not= '!' )? ( filter[newProperty] )? ( block[newProperty] )? )  	{  		DebugLocation (23' 4);  		DebugLocation (23' 6);  		PushFollow (Follow._propertyName_in_property80);  		propertyName1 = propertyName ();  		PopFollow ();  		if (input.LA (1) == TokenTypes.Down) {  			Match (input' TokenTypes.Down' null);  			DebugLocation (23' 22);  			// ./src/Parser/Grammar/JFLWalker.g:23:22: (not= '!' )?  			int alt2 = 2;  			try {  				DebugEnterSubRule (2);  				try {  					DebugEnterDecision (2' false);  					int LA2_1 = input.LA (1);  					if ((LA2_1 == 24)) {  						alt2 = 1;  					}  				}  				finally {  					DebugExitDecision (2);  				}  				switch (alt2) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:23:22: not= '!'  					{  						DebugLocation (23' 22);  						not = (CommonTree)Match (input' 24' Follow._24_in_property84);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (2);  			}  			DebugLocation (23' 28);  			// ./src/Parser/Grammar/JFLWalker.g:23:28: ( filter[newProperty] )?  			int alt3 = 2;  			try {  				DebugEnterSubRule (3);  				try {  					DebugEnterDecision (3' false);  					int LA3_1 = input.LA (1);  					if ((LA3_1 == FILTER)) {  						alt3 = 1;  					}  				}  				finally {  					DebugExitDecision (3);  				}  				switch (alt3) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:23:28: filter[newProperty]  					{  						DebugLocation (23' 28);  						PushFollow (Follow._filter_in_property87);  						filter (newProperty);  						PopFollow ();  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (3);  			}  			DebugLocation (23' 49);  			// ./src/Parser/Grammar/JFLWalker.g:23:49: ( block[newProperty] )?  			int alt4 = 2;  			try {  				DebugEnterSubRule (4);  				try {  					DebugEnterDecision (4' false);  					int LA4_1 = input.LA (1);  					if ((LA4_1 == BLOCK)) {  						alt4 = 1;  					}  				}  				finally {  					DebugExitDecision (4);  				}  				switch (alt4) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:23:49: block[newProperty]  					{  						DebugLocation (23' 49);  						PushFollow (Follow._block_in_property91);  						block (newProperty);  						PopFollow ();  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (4);  			}  			Match (input' TokenTypes.Up' null);  		}  		DebugLocation (23' 70);  		if ((not != null ? not.Text : default(string)) == "!")  			newProperty.ToggleInclude ();  		if ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).isRegex : default(bool)))  			parentScope.AddRegexProperty ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).name : default(string))' newProperty);  		else  			parentScope.AddProperty ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).name : default(string))' newProperty);  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("property"' 3);  	LeaveRule ("property"' 3);  	LeaveRule_property ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,property,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:23:2: ( ^( propertyName (not= '!' )? ( filter[newProperty] )? ( block[newProperty] )? ) )  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:23:4: ^( propertyName (not= '!' )? ( filter[newProperty] )? ( block[newProperty] )? )  	{  		DebugLocation (23' 4);  		DebugLocation (23' 6);  		PushFollow (Follow._propertyName_in_property80);  		propertyName1 = propertyName ();  		PopFollow ();  		if (input.LA (1) == TokenTypes.Down) {  			Match (input' TokenTypes.Down' null);  			DebugLocation (23' 22);  			// ./src/Parser/Grammar/JFLWalker.g:23:22: (not= '!' )?  			int alt2 = 2;  			try {  				DebugEnterSubRule (2);  				try {  					DebugEnterDecision (2' false);  					int LA2_1 = input.LA (1);  					if ((LA2_1 == 24)) {  						alt2 = 1;  					}  				}  				finally {  					DebugExitDecision (2);  				}  				switch (alt2) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:23:22: not= '!'  					{  						DebugLocation (23' 22);  						not = (CommonTree)Match (input' 24' Follow._24_in_property84);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (2);  			}  			DebugLocation (23' 28);  			// ./src/Parser/Grammar/JFLWalker.g:23:28: ( filter[newProperty] )?  			int alt3 = 2;  			try {  				DebugEnterSubRule (3);  				try {  					DebugEnterDecision (3' false);  					int LA3_1 = input.LA (1);  					if ((LA3_1 == FILTER)) {  						alt3 = 1;  					}  				}  				finally {  					DebugExitDecision (3);  				}  				switch (alt3) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:23:28: filter[newProperty]  					{  						DebugLocation (23' 28);  						PushFollow (Follow._filter_in_property87);  						filter (newProperty);  						PopFollow ();  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (3);  			}  			DebugLocation (23' 49);  			// ./src/Parser/Grammar/JFLWalker.g:23:49: ( block[newProperty] )?  			int alt4 = 2;  			try {  				DebugEnterSubRule (4);  				try {  					DebugEnterDecision (4' false);  					int LA4_1 = input.LA (1);  					if ((LA4_1 == BLOCK)) {  						alt4 = 1;  					}  				}  				finally {  					DebugExitDecision (4);  				}  				switch (alt4) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:23:49: block[newProperty]  					{  						DebugLocation (23' 49);  						PushFollow (Follow._block_in_property91);  						block (newProperty);  						PopFollow ();  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (4);  			}  			Match (input' TokenTypes.Up' null);  		}  		DebugLocation (23' 70);  		if ((not != null ? not.Text : default(string)) == "!")  			newProperty.ToggleInclude ();  		if ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).isRegex : default(bool)))  			parentScope.AddRegexProperty ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).name : default(string))' newProperty);  		else  			parentScope.AddProperty ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).name : default(string))' newProperty);  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("property"' 3);  	LeaveRule ("property"' 3);  	LeaveRule_property ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,property,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:23:2: ( ^( propertyName (not= '!' )? ( filter[newProperty] )? ( block[newProperty] )? ) )  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:23:4: ^( propertyName (not= '!' )? ( filter[newProperty] )? ( block[newProperty] )? )  	{  		DebugLocation (23' 4);  		DebugLocation (23' 6);  		PushFollow (Follow._propertyName_in_property80);  		propertyName1 = propertyName ();  		PopFollow ();  		if (input.LA (1) == TokenTypes.Down) {  			Match (input' TokenTypes.Down' null);  			DebugLocation (23' 22);  			// ./src/Parser/Grammar/JFLWalker.g:23:22: (not= '!' )?  			int alt2 = 2;  			try {  				DebugEnterSubRule (2);  				try {  					DebugEnterDecision (2' false);  					int LA2_1 = input.LA (1);  					if ((LA2_1 == 24)) {  						alt2 = 1;  					}  				}  				finally {  					DebugExitDecision (2);  				}  				switch (alt2) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:23:22: not= '!'  					{  						DebugLocation (23' 22);  						not = (CommonTree)Match (input' 24' Follow._24_in_property84);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (2);  			}  			DebugLocation (23' 28);  			// ./src/Parser/Grammar/JFLWalker.g:23:28: ( filter[newProperty] )?  			int alt3 = 2;  			try {  				DebugEnterSubRule (3);  				try {  					DebugEnterDecision (3' false);  					int LA3_1 = input.LA (1);  					if ((LA3_1 == FILTER)) {  						alt3 = 1;  					}  				}  				finally {  					DebugExitDecision (3);  				}  				switch (alt3) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:23:28: filter[newProperty]  					{  						DebugLocation (23' 28);  						PushFollow (Follow._filter_in_property87);  						filter (newProperty);  						PopFollow ();  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (3);  			}  			DebugLocation (23' 49);  			// ./src/Parser/Grammar/JFLWalker.g:23:49: ( block[newProperty] )?  			int alt4 = 2;  			try {  				DebugEnterSubRule (4);  				try {  					DebugEnterDecision (4' false);  					int LA4_1 = input.LA (1);  					if ((LA4_1 == BLOCK)) {  						alt4 = 1;  					}  				}  				finally {  					DebugExitDecision (4);  				}  				switch (alt4) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:23:49: block[newProperty]  					{  						DebugLocation (23' 49);  						PushFollow (Follow._block_in_property91);  						block (newProperty);  						PopFollow ();  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (4);  			}  			Match (input' TokenTypes.Up' null);  		}  		DebugLocation (23' 70);  		if ((not != null ? not.Text : default(string)) == "!")  			newProperty.ToggleInclude ();  		if ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).isRegex : default(bool)))  			parentScope.AddRegexProperty ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).name : default(string))' newProperty);  		else  			parentScope.AddProperty ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).name : default(string))' newProperty);  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("property"' 3);  	LeaveRule ("property"' 3);  	LeaveRule_property ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,property,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:23:2: ( ^( propertyName (not= '!' )? ( filter[newProperty] )? ( block[newProperty] )? ) )  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:23:4: ^( propertyName (not= '!' )? ( filter[newProperty] )? ( block[newProperty] )? )  	{  		DebugLocation (23' 4);  		DebugLocation (23' 6);  		PushFollow (Follow._propertyName_in_property80);  		propertyName1 = propertyName ();  		PopFollow ();  		if (input.LA (1) == TokenTypes.Down) {  			Match (input' TokenTypes.Down' null);  			DebugLocation (23' 22);  			// ./src/Parser/Grammar/JFLWalker.g:23:22: (not= '!' )?  			int alt2 = 2;  			try {  				DebugEnterSubRule (2);  				try {  					DebugEnterDecision (2' false);  					int LA2_1 = input.LA (1);  					if ((LA2_1 == 24)) {  						alt2 = 1;  					}  				}  				finally {  					DebugExitDecision (2);  				}  				switch (alt2) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:23:22: not= '!'  					{  						DebugLocation (23' 22);  						not = (CommonTree)Match (input' 24' Follow._24_in_property84);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (2);  			}  			DebugLocation (23' 28);  			// ./src/Parser/Grammar/JFLWalker.g:23:28: ( filter[newProperty] )?  			int alt3 = 2;  			try {  				DebugEnterSubRule (3);  				try {  					DebugEnterDecision (3' false);  					int LA3_1 = input.LA (1);  					if ((LA3_1 == FILTER)) {  						alt3 = 1;  					}  				}  				finally {  					DebugExitDecision (3);  				}  				switch (alt3) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:23:28: filter[newProperty]  					{  						DebugLocation (23' 28);  						PushFollow (Follow._filter_in_property87);  						filter (newProperty);  						PopFollow ();  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (3);  			}  			DebugLocation (23' 49);  			// ./src/Parser/Grammar/JFLWalker.g:23:49: ( block[newProperty] )?  			int alt4 = 2;  			try {  				DebugEnterSubRule (4);  				try {  					DebugEnterDecision (4' false);  					int LA4_1 = input.LA (1);  					if ((LA4_1 == BLOCK)) {  						alt4 = 1;  					}  				}  				finally {  					DebugExitDecision (4);  				}  				switch (alt4) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:23:49: block[newProperty]  					{  						DebugLocation (23' 49);  						PushFollow (Follow._block_in_property91);  						block (newProperty);  						PopFollow ();  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (4);  			}  			Match (input' TokenTypes.Up' null);  		}  		DebugLocation (23' 70);  		if ((not != null ? not.Text : default(string)) == "!")  			newProperty.ToggleInclude ();  		if ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).isRegex : default(bool)))  			parentScope.AddRegexProperty ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).name : default(string))' newProperty);  		else  			parentScope.AddProperty ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).name : default(string))' newProperty);  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("property"' 3);  	LeaveRule ("property"' 3);  	LeaveRule_property ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,property,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:23:2: ( ^( propertyName (not= '!' )? ( filter[newProperty] )? ( block[newProperty] )? ) )  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:23:4: ^( propertyName (not= '!' )? ( filter[newProperty] )? ( block[newProperty] )? )  	{  		DebugLocation (23' 4);  		DebugLocation (23' 6);  		PushFollow (Follow._propertyName_in_property80);  		propertyName1 = propertyName ();  		PopFollow ();  		if (input.LA (1) == TokenTypes.Down) {  			Match (input' TokenTypes.Down' null);  			DebugLocation (23' 22);  			// ./src/Parser/Grammar/JFLWalker.g:23:22: (not= '!' )?  			int alt2 = 2;  			try {  				DebugEnterSubRule (2);  				try {  					DebugEnterDecision (2' false);  					int LA2_1 = input.LA (1);  					if ((LA2_1 == 24)) {  						alt2 = 1;  					}  				}  				finally {  					DebugExitDecision (2);  				}  				switch (alt2) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:23:22: not= '!'  					{  						DebugLocation (23' 22);  						not = (CommonTree)Match (input' 24' Follow._24_in_property84);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (2);  			}  			DebugLocation (23' 28);  			// ./src/Parser/Grammar/JFLWalker.g:23:28: ( filter[newProperty] )?  			int alt3 = 2;  			try {  				DebugEnterSubRule (3);  				try {  					DebugEnterDecision (3' false);  					int LA3_1 = input.LA (1);  					if ((LA3_1 == FILTER)) {  						alt3 = 1;  					}  				}  				finally {  					DebugExitDecision (3);  				}  				switch (alt3) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:23:28: filter[newProperty]  					{  						DebugLocation (23' 28);  						PushFollow (Follow._filter_in_property87);  						filter (newProperty);  						PopFollow ();  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (3);  			}  			DebugLocation (23' 49);  			// ./src/Parser/Grammar/JFLWalker.g:23:49: ( block[newProperty] )?  			int alt4 = 2;  			try {  				DebugEnterSubRule (4);  				try {  					DebugEnterDecision (4' false);  					int LA4_1 = input.LA (1);  					if ((LA4_1 == BLOCK)) {  						alt4 = 1;  					}  				}  				finally {  					DebugExitDecision (4);  				}  				switch (alt4) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:23:49: block[newProperty]  					{  						DebugLocation (23' 49);  						PushFollow (Follow._block_in_property91);  						block (newProperty);  						PopFollow ();  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (4);  			}  			Match (input' TokenTypes.Up' null);  		}  		DebugLocation (23' 70);  		if ((not != null ? not.Text : default(string)) == "!")  			newProperty.ToggleInclude ();  		if ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).isRegex : default(bool)))  			parentScope.AddRegexProperty ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).name : default(string))' newProperty);  		else  			parentScope.AddProperty ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).name : default(string))' newProperty);  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("property"' 3);  	LeaveRule ("property"' 3);  	LeaveRule_property ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,property,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:23:2: ( ^( propertyName (not= '!' )? ( filter[newProperty] )? ( block[newProperty] )? ) )  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:23:4: ^( propertyName (not= '!' )? ( filter[newProperty] )? ( block[newProperty] )? )  	{  		DebugLocation (23' 4);  		DebugLocation (23' 6);  		PushFollow (Follow._propertyName_in_property80);  		propertyName1 = propertyName ();  		PopFollow ();  		if (input.LA (1) == TokenTypes.Down) {  			Match (input' TokenTypes.Down' null);  			DebugLocation (23' 22);  			// ./src/Parser/Grammar/JFLWalker.g:23:22: (not= '!' )?  			int alt2 = 2;  			try {  				DebugEnterSubRule (2);  				try {  					DebugEnterDecision (2' false);  					int LA2_1 = input.LA (1);  					if ((LA2_1 == 24)) {  						alt2 = 1;  					}  				}  				finally {  					DebugExitDecision (2);  				}  				switch (alt2) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:23:22: not= '!'  					{  						DebugLocation (23' 22);  						not = (CommonTree)Match (input' 24' Follow._24_in_property84);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (2);  			}  			DebugLocation (23' 28);  			// ./src/Parser/Grammar/JFLWalker.g:23:28: ( filter[newProperty] )?  			int alt3 = 2;  			try {  				DebugEnterSubRule (3);  				try {  					DebugEnterDecision (3' false);  					int LA3_1 = input.LA (1);  					if ((LA3_1 == FILTER)) {  						alt3 = 1;  					}  				}  				finally {  					DebugExitDecision (3);  				}  				switch (alt3) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:23:28: filter[newProperty]  					{  						DebugLocation (23' 28);  						PushFollow (Follow._filter_in_property87);  						filter (newProperty);  						PopFollow ();  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (3);  			}  			DebugLocation (23' 49);  			// ./src/Parser/Grammar/JFLWalker.g:23:49: ( block[newProperty] )?  			int alt4 = 2;  			try {  				DebugEnterSubRule (4);  				try {  					DebugEnterDecision (4' false);  					int LA4_1 = input.LA (1);  					if ((LA4_1 == BLOCK)) {  						alt4 = 1;  					}  				}  				finally {  					DebugExitDecision (4);  				}  				switch (alt4) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:23:49: block[newProperty]  					{  						DebugLocation (23' 49);  						PushFollow (Follow._block_in_property91);  						block (newProperty);  						PopFollow ();  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (4);  			}  			Match (input' TokenTypes.Up' null);  		}  		DebugLocation (23' 70);  		if ((not != null ? not.Text : default(string)) == "!")  			newProperty.ToggleInclude ();  		if ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).isRegex : default(bool)))  			parentScope.AddRegexProperty ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).name : default(string))' newProperty);  		else  			parentScope.AddProperty ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).name : default(string))' newProperty);  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("property"' 3);  	LeaveRule ("property"' 3);  	LeaveRule_property ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,property,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:23:2: ( ^( propertyName (not= '!' )? ( filter[newProperty] )? ( block[newProperty] )? ) )  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:23:4: ^( propertyName (not= '!' )? ( filter[newProperty] )? ( block[newProperty] )? )  	{  		DebugLocation (23' 4);  		DebugLocation (23' 6);  		PushFollow (Follow._propertyName_in_property80);  		propertyName1 = propertyName ();  		PopFollow ();  		if (input.LA (1) == TokenTypes.Down) {  			Match (input' TokenTypes.Down' null);  			DebugLocation (23' 22);  			// ./src/Parser/Grammar/JFLWalker.g:23:22: (not= '!' )?  			int alt2 = 2;  			try {  				DebugEnterSubRule (2);  				try {  					DebugEnterDecision (2' false);  					int LA2_1 = input.LA (1);  					if ((LA2_1 == 24)) {  						alt2 = 1;  					}  				}  				finally {  					DebugExitDecision (2);  				}  				switch (alt2) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:23:22: not= '!'  					{  						DebugLocation (23' 22);  						not = (CommonTree)Match (input' 24' Follow._24_in_property84);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (2);  			}  			DebugLocation (23' 28);  			// ./src/Parser/Grammar/JFLWalker.g:23:28: ( filter[newProperty] )?  			int alt3 = 2;  			try {  				DebugEnterSubRule (3);  				try {  					DebugEnterDecision (3' false);  					int LA3_1 = input.LA (1);  					if ((LA3_1 == FILTER)) {  						alt3 = 1;  					}  				}  				finally {  					DebugExitDecision (3);  				}  				switch (alt3) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:23:28: filter[newProperty]  					{  						DebugLocation (23' 28);  						PushFollow (Follow._filter_in_property87);  						filter (newProperty);  						PopFollow ();  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (3);  			}  			DebugLocation (23' 49);  			// ./src/Parser/Grammar/JFLWalker.g:23:49: ( block[newProperty] )?  			int alt4 = 2;  			try {  				DebugEnterSubRule (4);  				try {  					DebugEnterDecision (4' false);  					int LA4_1 = input.LA (1);  					if ((LA4_1 == BLOCK)) {  						alt4 = 1;  					}  				}  				finally {  					DebugExitDecision (4);  				}  				switch (alt4) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:23:49: block[newProperty]  					{  						DebugLocation (23' 49);  						PushFollow (Follow._block_in_property91);  						block (newProperty);  						PopFollow ();  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (4);  			}  			Match (input' TokenTypes.Up' null);  		}  		DebugLocation (23' 70);  		if ((not != null ? not.Text : default(string)) == "!")  			newProperty.ToggleInclude ();  		if ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).isRegex : default(bool)))  			parentScope.AddRegexProperty ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).name : default(string))' newProperty);  		else  			parentScope.AddProperty ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).name : default(string))' newProperty);  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("property"' 3);  	LeaveRule ("property"' 3);  	LeaveRule_property ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,property,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:23:2: ( ^( propertyName (not= '!' )? ( filter[newProperty] )? ( block[newProperty] )? ) )  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:23:4: ^( propertyName (not= '!' )? ( filter[newProperty] )? ( block[newProperty] )? )  	{  		DebugLocation (23' 4);  		DebugLocation (23' 6);  		PushFollow (Follow._propertyName_in_property80);  		propertyName1 = propertyName ();  		PopFollow ();  		if (input.LA (1) == TokenTypes.Down) {  			Match (input' TokenTypes.Down' null);  			DebugLocation (23' 22);  			// ./src/Parser/Grammar/JFLWalker.g:23:22: (not= '!' )?  			int alt2 = 2;  			try {  				DebugEnterSubRule (2);  				try {  					DebugEnterDecision (2' false);  					int LA2_1 = input.LA (1);  					if ((LA2_1 == 24)) {  						alt2 = 1;  					}  				}  				finally {  					DebugExitDecision (2);  				}  				switch (alt2) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:23:22: not= '!'  					{  						DebugLocation (23' 22);  						not = (CommonTree)Match (input' 24' Follow._24_in_property84);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (2);  			}  			DebugLocation (23' 28);  			// ./src/Parser/Grammar/JFLWalker.g:23:28: ( filter[newProperty] )?  			int alt3 = 2;  			try {  				DebugEnterSubRule (3);  				try {  					DebugEnterDecision (3' false);  					int LA3_1 = input.LA (1);  					if ((LA3_1 == FILTER)) {  						alt3 = 1;  					}  				}  				finally {  					DebugExitDecision (3);  				}  				switch (alt3) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:23:28: filter[newProperty]  					{  						DebugLocation (23' 28);  						PushFollow (Follow._filter_in_property87);  						filter (newProperty);  						PopFollow ();  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (3);  			}  			DebugLocation (23' 49);  			// ./src/Parser/Grammar/JFLWalker.g:23:49: ( block[newProperty] )?  			int alt4 = 2;  			try {  				DebugEnterSubRule (4);  				try {  					DebugEnterDecision (4' false);  					int LA4_1 = input.LA (1);  					if ((LA4_1 == BLOCK)) {  						alt4 = 1;  					}  				}  				finally {  					DebugExitDecision (4);  				}  				switch (alt4) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:23:49: block[newProperty]  					{  						DebugLocation (23' 49);  						PushFollow (Follow._block_in_property91);  						block (newProperty);  						PopFollow ();  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (4);  			}  			Match (input' TokenTypes.Up' null);  		}  		DebugLocation (23' 70);  		if ((not != null ? not.Text : default(string)) == "!")  			newProperty.ToggleInclude ();  		if ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).isRegex : default(bool)))  			parentScope.AddRegexProperty ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).name : default(string))' newProperty);  		else  			parentScope.AddProperty ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).name : default(string))' newProperty);  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("property"' 3);  	LeaveRule ("property"' 3);  	LeaveRule_property ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,property,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:23:2: ( ^( propertyName (not= '!' )? ( filter[newProperty] )? ( block[newProperty] )? ) )  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:23:4: ^( propertyName (not= '!' )? ( filter[newProperty] )? ( block[newProperty] )? )  	{  		DebugLocation (23' 4);  		DebugLocation (23' 6);  		PushFollow (Follow._propertyName_in_property80);  		propertyName1 = propertyName ();  		PopFollow ();  		if (input.LA (1) == TokenTypes.Down) {  			Match (input' TokenTypes.Down' null);  			DebugLocation (23' 22);  			// ./src/Parser/Grammar/JFLWalker.g:23:22: (not= '!' )?  			int alt2 = 2;  			try {  				DebugEnterSubRule (2);  				try {  					DebugEnterDecision (2' false);  					int LA2_1 = input.LA (1);  					if ((LA2_1 == 24)) {  						alt2 = 1;  					}  				}  				finally {  					DebugExitDecision (2);  				}  				switch (alt2) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:23:22: not= '!'  					{  						DebugLocation (23' 22);  						not = (CommonTree)Match (input' 24' Follow._24_in_property84);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (2);  			}  			DebugLocation (23' 28);  			// ./src/Parser/Grammar/JFLWalker.g:23:28: ( filter[newProperty] )?  			int alt3 = 2;  			try {  				DebugEnterSubRule (3);  				try {  					DebugEnterDecision (3' false);  					int LA3_1 = input.LA (1);  					if ((LA3_1 == FILTER)) {  						alt3 = 1;  					}  				}  				finally {  					DebugExitDecision (3);  				}  				switch (alt3) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:23:28: filter[newProperty]  					{  						DebugLocation (23' 28);  						PushFollow (Follow._filter_in_property87);  						filter (newProperty);  						PopFollow ();  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (3);  			}  			DebugLocation (23' 49);  			// ./src/Parser/Grammar/JFLWalker.g:23:49: ( block[newProperty] )?  			int alt4 = 2;  			try {  				DebugEnterSubRule (4);  				try {  					DebugEnterDecision (4' false);  					int LA4_1 = input.LA (1);  					if ((LA4_1 == BLOCK)) {  						alt4 = 1;  					}  				}  				finally {  					DebugExitDecision (4);  				}  				switch (alt4) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:23:49: block[newProperty]  					{  						DebugLocation (23' 49);  						PushFollow (Follow._block_in_property91);  						block (newProperty);  						PopFollow ();  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (4);  			}  			Match (input' TokenTypes.Up' null);  		}  		DebugLocation (23' 70);  		if ((not != null ? not.Text : default(string)) == "!")  			newProperty.ToggleInclude ();  		if ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).isRegex : default(bool)))  			parentScope.AddRegexProperty ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).name : default(string))' newProperty);  		else  			parentScope.AddProperty ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).name : default(string))' newProperty);  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("property"' 3);  	LeaveRule ("property"' 3);  	LeaveRule_property ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,property,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:23:2: ( ^( propertyName (not= '!' )? ( filter[newProperty] )? ( block[newProperty] )? ) )  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:23:4: ^( propertyName (not= '!' )? ( filter[newProperty] )? ( block[newProperty] )? )  	{  		DebugLocation (23' 4);  		DebugLocation (23' 6);  		PushFollow (Follow._propertyName_in_property80);  		propertyName1 = propertyName ();  		PopFollow ();  		if (input.LA (1) == TokenTypes.Down) {  			Match (input' TokenTypes.Down' null);  			DebugLocation (23' 22);  			// ./src/Parser/Grammar/JFLWalker.g:23:22: (not= '!' )?  			int alt2 = 2;  			try {  				DebugEnterSubRule (2);  				try {  					DebugEnterDecision (2' false);  					int LA2_1 = input.LA (1);  					if ((LA2_1 == 24)) {  						alt2 = 1;  					}  				}  				finally {  					DebugExitDecision (2);  				}  				switch (alt2) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:23:22: not= '!'  					{  						DebugLocation (23' 22);  						not = (CommonTree)Match (input' 24' Follow._24_in_property84);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (2);  			}  			DebugLocation (23' 28);  			// ./src/Parser/Grammar/JFLWalker.g:23:28: ( filter[newProperty] )?  			int alt3 = 2;  			try {  				DebugEnterSubRule (3);  				try {  					DebugEnterDecision (3' false);  					int LA3_1 = input.LA (1);  					if ((LA3_1 == FILTER)) {  						alt3 = 1;  					}  				}  				finally {  					DebugExitDecision (3);  				}  				switch (alt3) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:23:28: filter[newProperty]  					{  						DebugLocation (23' 28);  						PushFollow (Follow._filter_in_property87);  						filter (newProperty);  						PopFollow ();  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (3);  			}  			DebugLocation (23' 49);  			// ./src/Parser/Grammar/JFLWalker.g:23:49: ( block[newProperty] )?  			int alt4 = 2;  			try {  				DebugEnterSubRule (4);  				try {  					DebugEnterDecision (4' false);  					int LA4_1 = input.LA (1);  					if ((LA4_1 == BLOCK)) {  						alt4 = 1;  					}  				}  				finally {  					DebugExitDecision (4);  				}  				switch (alt4) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:23:49: block[newProperty]  					{  						DebugLocation (23' 49);  						PushFollow (Follow._block_in_property91);  						block (newProperty);  						PopFollow ();  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (4);  			}  			Match (input' TokenTypes.Up' null);  		}  		DebugLocation (23' 70);  		if ((not != null ? not.Text : default(string)) == "!")  			newProperty.ToggleInclude ();  		if ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).isRegex : default(bool)))  			parentScope.AddRegexProperty ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).name : default(string))' newProperty);  		else  			parentScope.AddProperty ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).name : default(string))' newProperty);  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("property"' 3);  	LeaveRule ("property"' 3);  	LeaveRule_property ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,property,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:23:2: ( ^( propertyName (not= '!' )? ( filter[newProperty] )? ( block[newProperty] )? ) )  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:23:4: ^( propertyName (not= '!' )? ( filter[newProperty] )? ( block[newProperty] )? )  	{  		DebugLocation (23' 4);  		DebugLocation (23' 6);  		PushFollow (Follow._propertyName_in_property80);  		propertyName1 = propertyName ();  		PopFollow ();  		if (input.LA (1) == TokenTypes.Down) {  			Match (input' TokenTypes.Down' null);  			DebugLocation (23' 22);  			// ./src/Parser/Grammar/JFLWalker.g:23:22: (not= '!' )?  			int alt2 = 2;  			try {  				DebugEnterSubRule (2);  				try {  					DebugEnterDecision (2' false);  					int LA2_1 = input.LA (1);  					if ((LA2_1 == 24)) {  						alt2 = 1;  					}  				}  				finally {  					DebugExitDecision (2);  				}  				switch (alt2) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:23:22: not= '!'  					{  						DebugLocation (23' 22);  						not = (CommonTree)Match (input' 24' Follow._24_in_property84);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (2);  			}  			DebugLocation (23' 28);  			// ./src/Parser/Grammar/JFLWalker.g:23:28: ( filter[newProperty] )?  			int alt3 = 2;  			try {  				DebugEnterSubRule (3);  				try {  					DebugEnterDecision (3' false);  					int LA3_1 = input.LA (1);  					if ((LA3_1 == FILTER)) {  						alt3 = 1;  					}  				}  				finally {  					DebugExitDecision (3);  				}  				switch (alt3) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:23:28: filter[newProperty]  					{  						DebugLocation (23' 28);  						PushFollow (Follow._filter_in_property87);  						filter (newProperty);  						PopFollow ();  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (3);  			}  			DebugLocation (23' 49);  			// ./src/Parser/Grammar/JFLWalker.g:23:49: ( block[newProperty] )?  			int alt4 = 2;  			try {  				DebugEnterSubRule (4);  				try {  					DebugEnterDecision (4' false);  					int LA4_1 = input.LA (1);  					if ((LA4_1 == BLOCK)) {  						alt4 = 1;  					}  				}  				finally {  					DebugExitDecision (4);  				}  				switch (alt4) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:23:49: block[newProperty]  					{  						DebugLocation (23' 49);  						PushFollow (Follow._block_in_property91);  						block (newProperty);  						PopFollow ();  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (4);  			}  			Match (input' TokenTypes.Up' null);  		}  		DebugLocation (23' 70);  		if ((not != null ? not.Text : default(string)) == "!")  			newProperty.ToggleInclude ();  		if ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).isRegex : default(bool)))  			parentScope.AddRegexProperty ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).name : default(string))' newProperty);  		else  			parentScope.AddProperty ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).name : default(string))' newProperty);  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("property"' 3);  	LeaveRule ("property"' 3);  	LeaveRule_property ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,property,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:23:2: ( ^( propertyName (not= '!' )? ( filter[newProperty] )? ( block[newProperty] )? ) )  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:23:4: ^( propertyName (not= '!' )? ( filter[newProperty] )? ( block[newProperty] )? )  	{  		DebugLocation (23' 4);  		DebugLocation (23' 6);  		PushFollow (Follow._propertyName_in_property80);  		propertyName1 = propertyName ();  		PopFollow ();  		if (input.LA (1) == TokenTypes.Down) {  			Match (input' TokenTypes.Down' null);  			DebugLocation (23' 22);  			// ./src/Parser/Grammar/JFLWalker.g:23:22: (not= '!' )?  			int alt2 = 2;  			try {  				DebugEnterSubRule (2);  				try {  					DebugEnterDecision (2' false);  					int LA2_1 = input.LA (1);  					if ((LA2_1 == 24)) {  						alt2 = 1;  					}  				}  				finally {  					DebugExitDecision (2);  				}  				switch (alt2) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:23:22: not= '!'  					{  						DebugLocation (23' 22);  						not = (CommonTree)Match (input' 24' Follow._24_in_property84);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (2);  			}  			DebugLocation (23' 28);  			// ./src/Parser/Grammar/JFLWalker.g:23:28: ( filter[newProperty] )?  			int alt3 = 2;  			try {  				DebugEnterSubRule (3);  				try {  					DebugEnterDecision (3' false);  					int LA3_1 = input.LA (1);  					if ((LA3_1 == FILTER)) {  						alt3 = 1;  					}  				}  				finally {  					DebugExitDecision (3);  				}  				switch (alt3) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:23:28: filter[newProperty]  					{  						DebugLocation (23' 28);  						PushFollow (Follow._filter_in_property87);  						filter (newProperty);  						PopFollow ();  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (3);  			}  			DebugLocation (23' 49);  			// ./src/Parser/Grammar/JFLWalker.g:23:49: ( block[newProperty] )?  			int alt4 = 2;  			try {  				DebugEnterSubRule (4);  				try {  					DebugEnterDecision (4' false);  					int LA4_1 = input.LA (1);  					if ((LA4_1 == BLOCK)) {  						alt4 = 1;  					}  				}  				finally {  					DebugExitDecision (4);  				}  				switch (alt4) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:23:49: block[newProperty]  					{  						DebugLocation (23' 49);  						PushFollow (Follow._block_in_property91);  						block (newProperty);  						PopFollow ();  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (4);  			}  			Match (input' TokenTypes.Up' null);  		}  		DebugLocation (23' 70);  		if ((not != null ? not.Text : default(string)) == "!")  			newProperty.ToggleInclude ();  		if ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).isRegex : default(bool)))  			parentScope.AddRegexProperty ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).name : default(string))' newProperty);  		else  			parentScope.AddProperty ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).name : default(string))' newProperty);  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("property"' 3);  	LeaveRule ("property"' 3);  	LeaveRule_property ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,property,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:23:2: ( ^( propertyName (not= '!' )? ( filter[newProperty] )? ( block[newProperty] )? ) )  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:23:4: ^( propertyName (not= '!' )? ( filter[newProperty] )? ( block[newProperty] )? )  	{  		DebugLocation (23' 4);  		DebugLocation (23' 6);  		PushFollow (Follow._propertyName_in_property80);  		propertyName1 = propertyName ();  		PopFollow ();  		if (input.LA (1) == TokenTypes.Down) {  			Match (input' TokenTypes.Down' null);  			DebugLocation (23' 22);  			// ./src/Parser/Grammar/JFLWalker.g:23:22: (not= '!' )?  			int alt2 = 2;  			try {  				DebugEnterSubRule (2);  				try {  					DebugEnterDecision (2' false);  					int LA2_1 = input.LA (1);  					if ((LA2_1 == 24)) {  						alt2 = 1;  					}  				}  				finally {  					DebugExitDecision (2);  				}  				switch (alt2) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:23:22: not= '!'  					{  						DebugLocation (23' 22);  						not = (CommonTree)Match (input' 24' Follow._24_in_property84);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (2);  			}  			DebugLocation (23' 28);  			// ./src/Parser/Grammar/JFLWalker.g:23:28: ( filter[newProperty] )?  			int alt3 = 2;  			try {  				DebugEnterSubRule (3);  				try {  					DebugEnterDecision (3' false);  					int LA3_1 = input.LA (1);  					if ((LA3_1 == FILTER)) {  						alt3 = 1;  					}  				}  				finally {  					DebugExitDecision (3);  				}  				switch (alt3) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:23:28: filter[newProperty]  					{  						DebugLocation (23' 28);  						PushFollow (Follow._filter_in_property87);  						filter (newProperty);  						PopFollow ();  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (3);  			}  			DebugLocation (23' 49);  			// ./src/Parser/Grammar/JFLWalker.g:23:49: ( block[newProperty] )?  			int alt4 = 2;  			try {  				DebugEnterSubRule (4);  				try {  					DebugEnterDecision (4' false);  					int LA4_1 = input.LA (1);  					if ((LA4_1 == BLOCK)) {  						alt4 = 1;  					}  				}  				finally {  					DebugExitDecision (4);  				}  				switch (alt4) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:23:49: block[newProperty]  					{  						DebugLocation (23' 49);  						PushFollow (Follow._block_in_property91);  						block (newProperty);  						PopFollow ();  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (4);  			}  			Match (input' TokenTypes.Up' null);  		}  		DebugLocation (23' 70);  		if ((not != null ? not.Text : default(string)) == "!")  			newProperty.ToggleInclude ();  		if ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).isRegex : default(bool)))  			parentScope.AddRegexProperty ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).name : default(string))' newProperty);  		else  			parentScope.AddProperty ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).name : default(string))' newProperty);  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("property"' 3);  	LeaveRule ("property"' 3);  	LeaveRule_property ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,property,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:23:2: ( ^( propertyName (not= '!' )? ( filter[newProperty] )? ( block[newProperty] )? ) )  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:23:4: ^( propertyName (not= '!' )? ( filter[newProperty] )? ( block[newProperty] )? )  	{  		DebugLocation (23' 4);  		DebugLocation (23' 6);  		PushFollow (Follow._propertyName_in_property80);  		propertyName1 = propertyName ();  		PopFollow ();  		if (input.LA (1) == TokenTypes.Down) {  			Match (input' TokenTypes.Down' null);  			DebugLocation (23' 22);  			// ./src/Parser/Grammar/JFLWalker.g:23:22: (not= '!' )?  			int alt2 = 2;  			try {  				DebugEnterSubRule (2);  				try {  					DebugEnterDecision (2' false);  					int LA2_1 = input.LA (1);  					if ((LA2_1 == 24)) {  						alt2 = 1;  					}  				}  				finally {  					DebugExitDecision (2);  				}  				switch (alt2) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:23:22: not= '!'  					{  						DebugLocation (23' 22);  						not = (CommonTree)Match (input' 24' Follow._24_in_property84);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (2);  			}  			DebugLocation (23' 28);  			// ./src/Parser/Grammar/JFLWalker.g:23:28: ( filter[newProperty] )?  			int alt3 = 2;  			try {  				DebugEnterSubRule (3);  				try {  					DebugEnterDecision (3' false);  					int LA3_1 = input.LA (1);  					if ((LA3_1 == FILTER)) {  						alt3 = 1;  					}  				}  				finally {  					DebugExitDecision (3);  				}  				switch (alt3) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:23:28: filter[newProperty]  					{  						DebugLocation (23' 28);  						PushFollow (Follow._filter_in_property87);  						filter (newProperty);  						PopFollow ();  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (3);  			}  			DebugLocation (23' 49);  			// ./src/Parser/Grammar/JFLWalker.g:23:49: ( block[newProperty] )?  			int alt4 = 2;  			try {  				DebugEnterSubRule (4);  				try {  					DebugEnterDecision (4' false);  					int LA4_1 = input.LA (1);  					if ((LA4_1 == BLOCK)) {  						alt4 = 1;  					}  				}  				finally {  					DebugExitDecision (4);  				}  				switch (alt4) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:23:49: block[newProperty]  					{  						DebugLocation (23' 49);  						PushFollow (Follow._block_in_property91);  						block (newProperty);  						PopFollow ();  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (4);  			}  			Match (input' TokenTypes.Up' null);  		}  		DebugLocation (23' 70);  		if ((not != null ? not.Text : default(string)) == "!")  			newProperty.ToggleInclude ();  		if ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).isRegex : default(bool)))  			parentScope.AddRegexProperty ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).name : default(string))' newProperty);  		else  			parentScope.AddProperty ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).name : default(string))' newProperty);  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("property"' 3);  	LeaveRule ("property"' 3);  	LeaveRule_property ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,property,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:23:2: ( ^( propertyName (not= '!' )? ( filter[newProperty] )? ( block[newProperty] )? ) )  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:23:4: ^( propertyName (not= '!' )? ( filter[newProperty] )? ( block[newProperty] )? )  	{  		DebugLocation (23' 4);  		DebugLocation (23' 6);  		PushFollow (Follow._propertyName_in_property80);  		propertyName1 = propertyName ();  		PopFollow ();  		if (input.LA (1) == TokenTypes.Down) {  			Match (input' TokenTypes.Down' null);  			DebugLocation (23' 22);  			// ./src/Parser/Grammar/JFLWalker.g:23:22: (not= '!' )?  			int alt2 = 2;  			try {  				DebugEnterSubRule (2);  				try {  					DebugEnterDecision (2' false);  					int LA2_1 = input.LA (1);  					if ((LA2_1 == 24)) {  						alt2 = 1;  					}  				}  				finally {  					DebugExitDecision (2);  				}  				switch (alt2) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:23:22: not= '!'  					{  						DebugLocation (23' 22);  						not = (CommonTree)Match (input' 24' Follow._24_in_property84);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (2);  			}  			DebugLocation (23' 28);  			// ./src/Parser/Grammar/JFLWalker.g:23:28: ( filter[newProperty] )?  			int alt3 = 2;  			try {  				DebugEnterSubRule (3);  				try {  					DebugEnterDecision (3' false);  					int LA3_1 = input.LA (1);  					if ((LA3_1 == FILTER)) {  						alt3 = 1;  					}  				}  				finally {  					DebugExitDecision (3);  				}  				switch (alt3) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:23:28: filter[newProperty]  					{  						DebugLocation (23' 28);  						PushFollow (Follow._filter_in_property87);  						filter (newProperty);  						PopFollow ();  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (3);  			}  			DebugLocation (23' 49);  			// ./src/Parser/Grammar/JFLWalker.g:23:49: ( block[newProperty] )?  			int alt4 = 2;  			try {  				DebugEnterSubRule (4);  				try {  					DebugEnterDecision (4' false);  					int LA4_1 = input.LA (1);  					if ((LA4_1 == BLOCK)) {  						alt4 = 1;  					}  				}  				finally {  					DebugExitDecision (4);  				}  				switch (alt4) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:23:49: block[newProperty]  					{  						DebugLocation (23' 49);  						PushFollow (Follow._block_in_property91);  						block (newProperty);  						PopFollow ();  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (4);  			}  			Match (input' TokenTypes.Up' null);  		}  		DebugLocation (23' 70);  		if ((not != null ? not.Text : default(string)) == "!")  			newProperty.ToggleInclude ();  		if ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).isRegex : default(bool)))  			parentScope.AddRegexProperty ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).name : default(string))' newProperty);  		else  			parentScope.AddProperty ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).name : default(string))' newProperty);  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("property"' 3);  	LeaveRule ("property"' 3);  	LeaveRule_property ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,property,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:23:2: ( ^( propertyName (not= '!' )? ( filter[newProperty] )? ( block[newProperty] )? ) )  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:23:4: ^( propertyName (not= '!' )? ( filter[newProperty] )? ( block[newProperty] )? )  	{  		DebugLocation (23' 4);  		DebugLocation (23' 6);  		PushFollow (Follow._propertyName_in_property80);  		propertyName1 = propertyName ();  		PopFollow ();  		if (input.LA (1) == TokenTypes.Down) {  			Match (input' TokenTypes.Down' null);  			DebugLocation (23' 22);  			// ./src/Parser/Grammar/JFLWalker.g:23:22: (not= '!' )?  			int alt2 = 2;  			try {  				DebugEnterSubRule (2);  				try {  					DebugEnterDecision (2' false);  					int LA2_1 = input.LA (1);  					if ((LA2_1 == 24)) {  						alt2 = 1;  					}  				}  				finally {  					DebugExitDecision (2);  				}  				switch (alt2) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:23:22: not= '!'  					{  						DebugLocation (23' 22);  						not = (CommonTree)Match (input' 24' Follow._24_in_property84);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (2);  			}  			DebugLocation (23' 28);  			// ./src/Parser/Grammar/JFLWalker.g:23:28: ( filter[newProperty] )?  			int alt3 = 2;  			try {  				DebugEnterSubRule (3);  				try {  					DebugEnterDecision (3' false);  					int LA3_1 = input.LA (1);  					if ((LA3_1 == FILTER)) {  						alt3 = 1;  					}  				}  				finally {  					DebugExitDecision (3);  				}  				switch (alt3) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:23:28: filter[newProperty]  					{  						DebugLocation (23' 28);  						PushFollow (Follow._filter_in_property87);  						filter (newProperty);  						PopFollow ();  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (3);  			}  			DebugLocation (23' 49);  			// ./src/Parser/Grammar/JFLWalker.g:23:49: ( block[newProperty] )?  			int alt4 = 2;  			try {  				DebugEnterSubRule (4);  				try {  					DebugEnterDecision (4' false);  					int LA4_1 = input.LA (1);  					if ((LA4_1 == BLOCK)) {  						alt4 = 1;  					}  				}  				finally {  					DebugExitDecision (4);  				}  				switch (alt4) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:23:49: block[newProperty]  					{  						DebugLocation (23' 49);  						PushFollow (Follow._block_in_property91);  						block (newProperty);  						PopFollow ();  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (4);  			}  			Match (input' TokenTypes.Up' null);  		}  		DebugLocation (23' 70);  		if ((not != null ? not.Text : default(string)) == "!")  			newProperty.ToggleInclude ();  		if ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).isRegex : default(bool)))  			parentScope.AddRegexProperty ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).name : default(string))' newProperty);  		else  			parentScope.AddProperty ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).name : default(string))' newProperty);  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("property"' 3);  	LeaveRule ("property"' 3);  	LeaveRule_property ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,property,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:23:2: ( ^( propertyName (not= '!' )? ( filter[newProperty] )? ( block[newProperty] )? ) )  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:23:4: ^( propertyName (not= '!' )? ( filter[newProperty] )? ( block[newProperty] )? )  	{  		DebugLocation (23' 4);  		DebugLocation (23' 6);  		PushFollow (Follow._propertyName_in_property80);  		propertyName1 = propertyName ();  		PopFollow ();  		if (input.LA (1) == TokenTypes.Down) {  			Match (input' TokenTypes.Down' null);  			DebugLocation (23' 22);  			// ./src/Parser/Grammar/JFLWalker.g:23:22: (not= '!' )?  			int alt2 = 2;  			try {  				DebugEnterSubRule (2);  				try {  					DebugEnterDecision (2' false);  					int LA2_1 = input.LA (1);  					if ((LA2_1 == 24)) {  						alt2 = 1;  					}  				}  				finally {  					DebugExitDecision (2);  				}  				switch (alt2) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:23:22: not= '!'  					{  						DebugLocation (23' 22);  						not = (CommonTree)Match (input' 24' Follow._24_in_property84);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (2);  			}  			DebugLocation (23' 28);  			// ./src/Parser/Grammar/JFLWalker.g:23:28: ( filter[newProperty] )?  			int alt3 = 2;  			try {  				DebugEnterSubRule (3);  				try {  					DebugEnterDecision (3' false);  					int LA3_1 = input.LA (1);  					if ((LA3_1 == FILTER)) {  						alt3 = 1;  					}  				}  				finally {  					DebugExitDecision (3);  				}  				switch (alt3) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:23:28: filter[newProperty]  					{  						DebugLocation (23' 28);  						PushFollow (Follow._filter_in_property87);  						filter (newProperty);  						PopFollow ();  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (3);  			}  			DebugLocation (23' 49);  			// ./src/Parser/Grammar/JFLWalker.g:23:49: ( block[newProperty] )?  			int alt4 = 2;  			try {  				DebugEnterSubRule (4);  				try {  					DebugEnterDecision (4' false);  					int LA4_1 = input.LA (1);  					if ((LA4_1 == BLOCK)) {  						alt4 = 1;  					}  				}  				finally {  					DebugExitDecision (4);  				}  				switch (alt4) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:23:49: block[newProperty]  					{  						DebugLocation (23' 49);  						PushFollow (Follow._block_in_property91);  						block (newProperty);  						PopFollow ();  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (4);  			}  			Match (input' TokenTypes.Up' null);  		}  		DebugLocation (23' 70);  		if ((not != null ? not.Text : default(string)) == "!")  			newProperty.ToggleInclude ();  		if ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).isRegex : default(bool)))  			parentScope.AddRegexProperty ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).name : default(string))' newProperty);  		else  			parentScope.AddProperty ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).name : default(string))' newProperty);  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("property"' 3);  	LeaveRule ("property"' 3);  	LeaveRule_property ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,property,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:23:2: ( ^( propertyName (not= '!' )? ( filter[newProperty] )? ( block[newProperty] )? ) )  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:23:4: ^( propertyName (not= '!' )? ( filter[newProperty] )? ( block[newProperty] )? )  	{  		DebugLocation (23' 4);  		DebugLocation (23' 6);  		PushFollow (Follow._propertyName_in_property80);  		propertyName1 = propertyName ();  		PopFollow ();  		if (input.LA (1) == TokenTypes.Down) {  			Match (input' TokenTypes.Down' null);  			DebugLocation (23' 22);  			// ./src/Parser/Grammar/JFLWalker.g:23:22: (not= '!' )?  			int alt2 = 2;  			try {  				DebugEnterSubRule (2);  				try {  					DebugEnterDecision (2' false);  					int LA2_1 = input.LA (1);  					if ((LA2_1 == 24)) {  						alt2 = 1;  					}  				}  				finally {  					DebugExitDecision (2);  				}  				switch (alt2) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:23:22: not= '!'  					{  						DebugLocation (23' 22);  						not = (CommonTree)Match (input' 24' Follow._24_in_property84);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (2);  			}  			DebugLocation (23' 28);  			// ./src/Parser/Grammar/JFLWalker.g:23:28: ( filter[newProperty] )?  			int alt3 = 2;  			try {  				DebugEnterSubRule (3);  				try {  					DebugEnterDecision (3' false);  					int LA3_1 = input.LA (1);  					if ((LA3_1 == FILTER)) {  						alt3 = 1;  					}  				}  				finally {  					DebugExitDecision (3);  				}  				switch (alt3) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:23:28: filter[newProperty]  					{  						DebugLocation (23' 28);  						PushFollow (Follow._filter_in_property87);  						filter (newProperty);  						PopFollow ();  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (3);  			}  			DebugLocation (23' 49);  			// ./src/Parser/Grammar/JFLWalker.g:23:49: ( block[newProperty] )?  			int alt4 = 2;  			try {  				DebugEnterSubRule (4);  				try {  					DebugEnterDecision (4' false);  					int LA4_1 = input.LA (1);  					if ((LA4_1 == BLOCK)) {  						alt4 = 1;  					}  				}  				finally {  					DebugExitDecision (4);  				}  				switch (alt4) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:23:49: block[newProperty]  					{  						DebugLocation (23' 49);  						PushFollow (Follow._block_in_property91);  						block (newProperty);  						PopFollow ();  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (4);  			}  			Match (input' TokenTypes.Up' null);  		}  		DebugLocation (23' 70);  		if ((not != null ? not.Text : default(string)) == "!")  			newProperty.ToggleInclude ();  		if ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).isRegex : default(bool)))  			parentScope.AddRegexProperty ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).name : default(string))' newProperty);  		else  			parentScope.AddProperty ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).name : default(string))' newProperty);  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("property"' 3);  	LeaveRule ("property"' 3);  	LeaveRule_property ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,property,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:23:2: ( ^( propertyName (not= '!' )? ( filter[newProperty] )? ( block[newProperty] )? ) )  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:23:4: ^( propertyName (not= '!' )? ( filter[newProperty] )? ( block[newProperty] )? )  	{  		DebugLocation (23' 4);  		DebugLocation (23' 6);  		PushFollow (Follow._propertyName_in_property80);  		propertyName1 = propertyName ();  		PopFollow ();  		if (input.LA (1) == TokenTypes.Down) {  			Match (input' TokenTypes.Down' null);  			DebugLocation (23' 22);  			// ./src/Parser/Grammar/JFLWalker.g:23:22: (not= '!' )?  			int alt2 = 2;  			try {  				DebugEnterSubRule (2);  				try {  					DebugEnterDecision (2' false);  					int LA2_1 = input.LA (1);  					if ((LA2_1 == 24)) {  						alt2 = 1;  					}  				}  				finally {  					DebugExitDecision (2);  				}  				switch (alt2) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:23:22: not= '!'  					{  						DebugLocation (23' 22);  						not = (CommonTree)Match (input' 24' Follow._24_in_property84);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (2);  			}  			DebugLocation (23' 28);  			// ./src/Parser/Grammar/JFLWalker.g:23:28: ( filter[newProperty] )?  			int alt3 = 2;  			try {  				DebugEnterSubRule (3);  				try {  					DebugEnterDecision (3' false);  					int LA3_1 = input.LA (1);  					if ((LA3_1 == FILTER)) {  						alt3 = 1;  					}  				}  				finally {  					DebugExitDecision (3);  				}  				switch (alt3) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:23:28: filter[newProperty]  					{  						DebugLocation (23' 28);  						PushFollow (Follow._filter_in_property87);  						filter (newProperty);  						PopFollow ();  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (3);  			}  			DebugLocation (23' 49);  			// ./src/Parser/Grammar/JFLWalker.g:23:49: ( block[newProperty] )?  			int alt4 = 2;  			try {  				DebugEnterSubRule (4);  				try {  					DebugEnterDecision (4' false);  					int LA4_1 = input.LA (1);  					if ((LA4_1 == BLOCK)) {  						alt4 = 1;  					}  				}  				finally {  					DebugExitDecision (4);  				}  				switch (alt4) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:23:49: block[newProperty]  					{  						DebugLocation (23' 49);  						PushFollow (Follow._block_in_property91);  						block (newProperty);  						PopFollow ();  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (4);  			}  			Match (input' TokenTypes.Up' null);  		}  		DebugLocation (23' 70);  		if ((not != null ? not.Text : default(string)) == "!")  			newProperty.ToggleInclude ();  		if ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).isRegex : default(bool)))  			parentScope.AddRegexProperty ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).name : default(string))' newProperty);  		else  			parentScope.AddProperty ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).name : default(string))' newProperty);  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("property"' 3);  	LeaveRule ("property"' 3);  	LeaveRule_property ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,property,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:23:2: ( ^( propertyName (not= '!' )? ( filter[newProperty] )? ( block[newProperty] )? ) )  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:23:4: ^( propertyName (not= '!' )? ( filter[newProperty] )? ( block[newProperty] )? )  	{  		DebugLocation (23' 4);  		DebugLocation (23' 6);  		PushFollow (Follow._propertyName_in_property80);  		propertyName1 = propertyName ();  		PopFollow ();  		if (input.LA (1) == TokenTypes.Down) {  			Match (input' TokenTypes.Down' null);  			DebugLocation (23' 22);  			// ./src/Parser/Grammar/JFLWalker.g:23:22: (not= '!' )?  			int alt2 = 2;  			try {  				DebugEnterSubRule (2);  				try {  					DebugEnterDecision (2' false);  					int LA2_1 = input.LA (1);  					if ((LA2_1 == 24)) {  						alt2 = 1;  					}  				}  				finally {  					DebugExitDecision (2);  				}  				switch (alt2) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:23:22: not= '!'  					{  						DebugLocation (23' 22);  						not = (CommonTree)Match (input' 24' Follow._24_in_property84);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (2);  			}  			DebugLocation (23' 28);  			// ./src/Parser/Grammar/JFLWalker.g:23:28: ( filter[newProperty] )?  			int alt3 = 2;  			try {  				DebugEnterSubRule (3);  				try {  					DebugEnterDecision (3' false);  					int LA3_1 = input.LA (1);  					if ((LA3_1 == FILTER)) {  						alt3 = 1;  					}  				}  				finally {  					DebugExitDecision (3);  				}  				switch (alt3) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:23:28: filter[newProperty]  					{  						DebugLocation (23' 28);  						PushFollow (Follow._filter_in_property87);  						filter (newProperty);  						PopFollow ();  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (3);  			}  			DebugLocation (23' 49);  			// ./src/Parser/Grammar/JFLWalker.g:23:49: ( block[newProperty] )?  			int alt4 = 2;  			try {  				DebugEnterSubRule (4);  				try {  					DebugEnterDecision (4' false);  					int LA4_1 = input.LA (1);  					if ((LA4_1 == BLOCK)) {  						alt4 = 1;  					}  				}  				finally {  					DebugExitDecision (4);  				}  				switch (alt4) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:23:49: block[newProperty]  					{  						DebugLocation (23' 49);  						PushFollow (Follow._block_in_property91);  						block (newProperty);  						PopFollow ();  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (4);  			}  			Match (input' TokenTypes.Up' null);  		}  		DebugLocation (23' 70);  		if ((not != null ? not.Text : default(string)) == "!")  			newProperty.ToggleInclude ();  		if ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).isRegex : default(bool)))  			parentScope.AddRegexProperty ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).name : default(string))' newProperty);  		else  			parentScope.AddProperty ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).name : default(string))' newProperty);  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("property"' 3);  	LeaveRule ("property"' 3);  	LeaveRule_property ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,property,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:23:2: ( ^( propertyName (not= '!' )? ( filter[newProperty] )? ( block[newProperty] )? ) )  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:23:4: ^( propertyName (not= '!' )? ( filter[newProperty] )? ( block[newProperty] )? )  	{  		DebugLocation (23' 4);  		DebugLocation (23' 6);  		PushFollow (Follow._propertyName_in_property80);  		propertyName1 = propertyName ();  		PopFollow ();  		if (input.LA (1) == TokenTypes.Down) {  			Match (input' TokenTypes.Down' null);  			DebugLocation (23' 22);  			// ./src/Parser/Grammar/JFLWalker.g:23:22: (not= '!' )?  			int alt2 = 2;  			try {  				DebugEnterSubRule (2);  				try {  					DebugEnterDecision (2' false);  					int LA2_1 = input.LA (1);  					if ((LA2_1 == 24)) {  						alt2 = 1;  					}  				}  				finally {  					DebugExitDecision (2);  				}  				switch (alt2) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:23:22: not= '!'  					{  						DebugLocation (23' 22);  						not = (CommonTree)Match (input' 24' Follow._24_in_property84);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (2);  			}  			DebugLocation (23' 28);  			// ./src/Parser/Grammar/JFLWalker.g:23:28: ( filter[newProperty] )?  			int alt3 = 2;  			try {  				DebugEnterSubRule (3);  				try {  					DebugEnterDecision (3' false);  					int LA3_1 = input.LA (1);  					if ((LA3_1 == FILTER)) {  						alt3 = 1;  					}  				}  				finally {  					DebugExitDecision (3);  				}  				switch (alt3) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:23:28: filter[newProperty]  					{  						DebugLocation (23' 28);  						PushFollow (Follow._filter_in_property87);  						filter (newProperty);  						PopFollow ();  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (3);  			}  			DebugLocation (23' 49);  			// ./src/Parser/Grammar/JFLWalker.g:23:49: ( block[newProperty] )?  			int alt4 = 2;  			try {  				DebugEnterSubRule (4);  				try {  					DebugEnterDecision (4' false);  					int LA4_1 = input.LA (1);  					if ((LA4_1 == BLOCK)) {  						alt4 = 1;  					}  				}  				finally {  					DebugExitDecision (4);  				}  				switch (alt4) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:23:49: block[newProperty]  					{  						DebugLocation (23' 49);  						PushFollow (Follow._block_in_property91);  						block (newProperty);  						PopFollow ();  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (4);  			}  			Match (input' TokenTypes.Up' null);  		}  		DebugLocation (23' 70);  		if ((not != null ? not.Text : default(string)) == "!")  			newProperty.ToggleInclude ();  		if ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).isRegex : default(bool)))  			parentScope.AddRegexProperty ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).name : default(string))' newProperty);  		else  			parentScope.AddProperty ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).name : default(string))' newProperty);  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("property"' 3);  	LeaveRule ("property"' 3);  	LeaveRule_property ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,property,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:23:2: ( ^( propertyName (not= '!' )? ( filter[newProperty] )? ( block[newProperty] )? ) )  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:23:4: ^( propertyName (not= '!' )? ( filter[newProperty] )? ( block[newProperty] )? )  	{  		DebugLocation (23' 4);  		DebugLocation (23' 6);  		PushFollow (Follow._propertyName_in_property80);  		propertyName1 = propertyName ();  		PopFollow ();  		if (input.LA (1) == TokenTypes.Down) {  			Match (input' TokenTypes.Down' null);  			DebugLocation (23' 22);  			// ./src/Parser/Grammar/JFLWalker.g:23:22: (not= '!' )?  			int alt2 = 2;  			try {  				DebugEnterSubRule (2);  				try {  					DebugEnterDecision (2' false);  					int LA2_1 = input.LA (1);  					if ((LA2_1 == 24)) {  						alt2 = 1;  					}  				}  				finally {  					DebugExitDecision (2);  				}  				switch (alt2) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:23:22: not= '!'  					{  						DebugLocation (23' 22);  						not = (CommonTree)Match (input' 24' Follow._24_in_property84);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (2);  			}  			DebugLocation (23' 28);  			// ./src/Parser/Grammar/JFLWalker.g:23:28: ( filter[newProperty] )?  			int alt3 = 2;  			try {  				DebugEnterSubRule (3);  				try {  					DebugEnterDecision (3' false);  					int LA3_1 = input.LA (1);  					if ((LA3_1 == FILTER)) {  						alt3 = 1;  					}  				}  				finally {  					DebugExitDecision (3);  				}  				switch (alt3) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:23:28: filter[newProperty]  					{  						DebugLocation (23' 28);  						PushFollow (Follow._filter_in_property87);  						filter (newProperty);  						PopFollow ();  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (3);  			}  			DebugLocation (23' 49);  			// ./src/Parser/Grammar/JFLWalker.g:23:49: ( block[newProperty] )?  			int alt4 = 2;  			try {  				DebugEnterSubRule (4);  				try {  					DebugEnterDecision (4' false);  					int LA4_1 = input.LA (1);  					if ((LA4_1 == BLOCK)) {  						alt4 = 1;  					}  				}  				finally {  					DebugExitDecision (4);  				}  				switch (alt4) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:23:49: block[newProperty]  					{  						DebugLocation (23' 49);  						PushFollow (Follow._block_in_property91);  						block (newProperty);  						PopFollow ();  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (4);  			}  			Match (input' TokenTypes.Up' null);  		}  		DebugLocation (23' 70);  		if ((not != null ? not.Text : default(string)) == "!")  			newProperty.ToggleInclude ();  		if ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).isRegex : default(bool)))  			parentScope.AddRegexProperty ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).name : default(string))' newProperty);  		else  			parentScope.AddProperty ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).name : default(string))' newProperty);  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("property"' 3);  	LeaveRule ("property"' 3);  	LeaveRule_property ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,property,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:23:2: ( ^( propertyName (not= '!' )? ( filter[newProperty] )? ( block[newProperty] )? ) )  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:23:4: ^( propertyName (not= '!' )? ( filter[newProperty] )? ( block[newProperty] )? )  	{  		DebugLocation (23' 4);  		DebugLocation (23' 6);  		PushFollow (Follow._propertyName_in_property80);  		propertyName1 = propertyName ();  		PopFollow ();  		if (input.LA (1) == TokenTypes.Down) {  			Match (input' TokenTypes.Down' null);  			DebugLocation (23' 22);  			// ./src/Parser/Grammar/JFLWalker.g:23:22: (not= '!' )?  			int alt2 = 2;  			try {  				DebugEnterSubRule (2);  				try {  					DebugEnterDecision (2' false);  					int LA2_1 = input.LA (1);  					if ((LA2_1 == 24)) {  						alt2 = 1;  					}  				}  				finally {  					DebugExitDecision (2);  				}  				switch (alt2) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:23:22: not= '!'  					{  						DebugLocation (23' 22);  						not = (CommonTree)Match (input' 24' Follow._24_in_property84);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (2);  			}  			DebugLocation (23' 28);  			// ./src/Parser/Grammar/JFLWalker.g:23:28: ( filter[newProperty] )?  			int alt3 = 2;  			try {  				DebugEnterSubRule (3);  				try {  					DebugEnterDecision (3' false);  					int LA3_1 = input.LA (1);  					if ((LA3_1 == FILTER)) {  						alt3 = 1;  					}  				}  				finally {  					DebugExitDecision (3);  				}  				switch (alt3) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:23:28: filter[newProperty]  					{  						DebugLocation (23' 28);  						PushFollow (Follow._filter_in_property87);  						filter (newProperty);  						PopFollow ();  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (3);  			}  			DebugLocation (23' 49);  			// ./src/Parser/Grammar/JFLWalker.g:23:49: ( block[newProperty] )?  			int alt4 = 2;  			try {  				DebugEnterSubRule (4);  				try {  					DebugEnterDecision (4' false);  					int LA4_1 = input.LA (1);  					if ((LA4_1 == BLOCK)) {  						alt4 = 1;  					}  				}  				finally {  					DebugExitDecision (4);  				}  				switch (alt4) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:23:49: block[newProperty]  					{  						DebugLocation (23' 49);  						PushFollow (Follow._block_in_property91);  						block (newProperty);  						PopFollow ();  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (4);  			}  			Match (input' TokenTypes.Up' null);  		}  		DebugLocation (23' 70);  		if ((not != null ? not.Text : default(string)) == "!")  			newProperty.ToggleInclude ();  		if ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).isRegex : default(bool)))  			parentScope.AddRegexProperty ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).name : default(string))' newProperty);  		else  			parentScope.AddProperty ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).name : default(string))' newProperty);  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("property"' 3);  	LeaveRule ("property"' 3);  	LeaveRule_property ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,property,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:23:2: ( ^( propertyName (not= '!' )? ( filter[newProperty] )? ( block[newProperty] )? ) )  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:23:4: ^( propertyName (not= '!' )? ( filter[newProperty] )? ( block[newProperty] )? )  	{  		DebugLocation (23' 4);  		DebugLocation (23' 6);  		PushFollow (Follow._propertyName_in_property80);  		propertyName1 = propertyName ();  		PopFollow ();  		if (input.LA (1) == TokenTypes.Down) {  			Match (input' TokenTypes.Down' null);  			DebugLocation (23' 22);  			// ./src/Parser/Grammar/JFLWalker.g:23:22: (not= '!' )?  			int alt2 = 2;  			try {  				DebugEnterSubRule (2);  				try {  					DebugEnterDecision (2' false);  					int LA2_1 = input.LA (1);  					if ((LA2_1 == 24)) {  						alt2 = 1;  					}  				}  				finally {  					DebugExitDecision (2);  				}  				switch (alt2) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:23:22: not= '!'  					{  						DebugLocation (23' 22);  						not = (CommonTree)Match (input' 24' Follow._24_in_property84);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (2);  			}  			DebugLocation (23' 28);  			// ./src/Parser/Grammar/JFLWalker.g:23:28: ( filter[newProperty] )?  			int alt3 = 2;  			try {  				DebugEnterSubRule (3);  				try {  					DebugEnterDecision (3' false);  					int LA3_1 = input.LA (1);  					if ((LA3_1 == FILTER)) {  						alt3 = 1;  					}  				}  				finally {  					DebugExitDecision (3);  				}  				switch (alt3) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:23:28: filter[newProperty]  					{  						DebugLocation (23' 28);  						PushFollow (Follow._filter_in_property87);  						filter (newProperty);  						PopFollow ();  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (3);  			}  			DebugLocation (23' 49);  			// ./src/Parser/Grammar/JFLWalker.g:23:49: ( block[newProperty] )?  			int alt4 = 2;  			try {  				DebugEnterSubRule (4);  				try {  					DebugEnterDecision (4' false);  					int LA4_1 = input.LA (1);  					if ((LA4_1 == BLOCK)) {  						alt4 = 1;  					}  				}  				finally {  					DebugExitDecision (4);  				}  				switch (alt4) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:23:49: block[newProperty]  					{  						DebugLocation (23' 49);  						PushFollow (Follow._block_in_property91);  						block (newProperty);  						PopFollow ();  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (4);  			}  			Match (input' TokenTypes.Up' null);  		}  		DebugLocation (23' 70);  		if ((not != null ? not.Text : default(string)) == "!")  			newProperty.ToggleInclude ();  		if ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).isRegex : default(bool)))  			parentScope.AddRegexProperty ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).name : default(string))' newProperty);  		else  			parentScope.AddProperty ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).name : default(string))' newProperty);  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("property"' 3);  	LeaveRule ("property"' 3);  	LeaveRule_property ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,property,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:23:2: ( ^( propertyName (not= '!' )? ( filter[newProperty] )? ( block[newProperty] )? ) )  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:23:4: ^( propertyName (not= '!' )? ( filter[newProperty] )? ( block[newProperty] )? )  	{  		DebugLocation (23' 4);  		DebugLocation (23' 6);  		PushFollow (Follow._propertyName_in_property80);  		propertyName1 = propertyName ();  		PopFollow ();  		if (input.LA (1) == TokenTypes.Down) {  			Match (input' TokenTypes.Down' null);  			DebugLocation (23' 22);  			// ./src/Parser/Grammar/JFLWalker.g:23:22: (not= '!' )?  			int alt2 = 2;  			try {  				DebugEnterSubRule (2);  				try {  					DebugEnterDecision (2' false);  					int LA2_1 = input.LA (1);  					if ((LA2_1 == 24)) {  						alt2 = 1;  					}  				}  				finally {  					DebugExitDecision (2);  				}  				switch (alt2) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:23:22: not= '!'  					{  						DebugLocation (23' 22);  						not = (CommonTree)Match (input' 24' Follow._24_in_property84);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (2);  			}  			DebugLocation (23' 28);  			// ./src/Parser/Grammar/JFLWalker.g:23:28: ( filter[newProperty] )?  			int alt3 = 2;  			try {  				DebugEnterSubRule (3);  				try {  					DebugEnterDecision (3' false);  					int LA3_1 = input.LA (1);  					if ((LA3_1 == FILTER)) {  						alt3 = 1;  					}  				}  				finally {  					DebugExitDecision (3);  				}  				switch (alt3) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:23:28: filter[newProperty]  					{  						DebugLocation (23' 28);  						PushFollow (Follow._filter_in_property87);  						filter (newProperty);  						PopFollow ();  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (3);  			}  			DebugLocation (23' 49);  			// ./src/Parser/Grammar/JFLWalker.g:23:49: ( block[newProperty] )?  			int alt4 = 2;  			try {  				DebugEnterSubRule (4);  				try {  					DebugEnterDecision (4' false);  					int LA4_1 = input.LA (1);  					if ((LA4_1 == BLOCK)) {  						alt4 = 1;  					}  				}  				finally {  					DebugExitDecision (4);  				}  				switch (alt4) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:23:49: block[newProperty]  					{  						DebugLocation (23' 49);  						PushFollow (Follow._block_in_property91);  						block (newProperty);  						PopFollow ();  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (4);  			}  			Match (input' TokenTypes.Up' null);  		}  		DebugLocation (23' 70);  		if ((not != null ? not.Text : default(string)) == "!")  			newProperty.ToggleInclude ();  		if ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).isRegex : default(bool)))  			parentScope.AddRegexProperty ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).name : default(string))' newProperty);  		else  			parentScope.AddProperty ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).name : default(string))' newProperty);  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("property"' 3);  	LeaveRule ("property"' 3);  	LeaveRule_property ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,property,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:23:2: ( ^( propertyName (not= '!' )? ( filter[newProperty] )? ( block[newProperty] )? ) )  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:23:4: ^( propertyName (not= '!' )? ( filter[newProperty] )? ( block[newProperty] )? )  	{  		DebugLocation (23' 4);  		DebugLocation (23' 6);  		PushFollow (Follow._propertyName_in_property80);  		propertyName1 = propertyName ();  		PopFollow ();  		if (input.LA (1) == TokenTypes.Down) {  			Match (input' TokenTypes.Down' null);  			DebugLocation (23' 22);  			// ./src/Parser/Grammar/JFLWalker.g:23:22: (not= '!' )?  			int alt2 = 2;  			try {  				DebugEnterSubRule (2);  				try {  					DebugEnterDecision (2' false);  					int LA2_1 = input.LA (1);  					if ((LA2_1 == 24)) {  						alt2 = 1;  					}  				}  				finally {  					DebugExitDecision (2);  				}  				switch (alt2) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:23:22: not= '!'  					{  						DebugLocation (23' 22);  						not = (CommonTree)Match (input' 24' Follow._24_in_property84);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (2);  			}  			DebugLocation (23' 28);  			// ./src/Parser/Grammar/JFLWalker.g:23:28: ( filter[newProperty] )?  			int alt3 = 2;  			try {  				DebugEnterSubRule (3);  				try {  					DebugEnterDecision (3' false);  					int LA3_1 = input.LA (1);  					if ((LA3_1 == FILTER)) {  						alt3 = 1;  					}  				}  				finally {  					DebugExitDecision (3);  				}  				switch (alt3) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:23:28: filter[newProperty]  					{  						DebugLocation (23' 28);  						PushFollow (Follow._filter_in_property87);  						filter (newProperty);  						PopFollow ();  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (3);  			}  			DebugLocation (23' 49);  			// ./src/Parser/Grammar/JFLWalker.g:23:49: ( block[newProperty] )?  			int alt4 = 2;  			try {  				DebugEnterSubRule (4);  				try {  					DebugEnterDecision (4' false);  					int LA4_1 = input.LA (1);  					if ((LA4_1 == BLOCK)) {  						alt4 = 1;  					}  				}  				finally {  					DebugExitDecision (4);  				}  				switch (alt4) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:23:49: block[newProperty]  					{  						DebugLocation (23' 49);  						PushFollow (Follow._block_in_property91);  						block (newProperty);  						PopFollow ();  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (4);  			}  			Match (input' TokenTypes.Up' null);  		}  		DebugLocation (23' 70);  		if ((not != null ? not.Text : default(string)) == "!")  			newProperty.ToggleInclude ();  		if ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).isRegex : default(bool)))  			parentScope.AddRegexProperty ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).name : default(string))' newProperty);  		else  			parentScope.AddProperty ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).name : default(string))' newProperty);  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("property"' 3);  	LeaveRule ("property"' 3);  	LeaveRule_property ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,property,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:23:2: ( ^( propertyName (not= '!' )? ( filter[newProperty] )? ( block[newProperty] )? ) )  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:23:4: ^( propertyName (not= '!' )? ( filter[newProperty] )? ( block[newProperty] )? )  	{  		DebugLocation (23' 4);  		DebugLocation (23' 6);  		PushFollow (Follow._propertyName_in_property80);  		propertyName1 = propertyName ();  		PopFollow ();  		if (input.LA (1) == TokenTypes.Down) {  			Match (input' TokenTypes.Down' null);  			DebugLocation (23' 22);  			// ./src/Parser/Grammar/JFLWalker.g:23:22: (not= '!' )?  			int alt2 = 2;  			try {  				DebugEnterSubRule (2);  				try {  					DebugEnterDecision (2' false);  					int LA2_1 = input.LA (1);  					if ((LA2_1 == 24)) {  						alt2 = 1;  					}  				}  				finally {  					DebugExitDecision (2);  				}  				switch (alt2) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:23:22: not= '!'  					{  						DebugLocation (23' 22);  						not = (CommonTree)Match (input' 24' Follow._24_in_property84);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (2);  			}  			DebugLocation (23' 28);  			// ./src/Parser/Grammar/JFLWalker.g:23:28: ( filter[newProperty] )?  			int alt3 = 2;  			try {  				DebugEnterSubRule (3);  				try {  					DebugEnterDecision (3' false);  					int LA3_1 = input.LA (1);  					if ((LA3_1 == FILTER)) {  						alt3 = 1;  					}  				}  				finally {  					DebugExitDecision (3);  				}  				switch (alt3) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:23:28: filter[newProperty]  					{  						DebugLocation (23' 28);  						PushFollow (Follow._filter_in_property87);  						filter (newProperty);  						PopFollow ();  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (3);  			}  			DebugLocation (23' 49);  			// ./src/Parser/Grammar/JFLWalker.g:23:49: ( block[newProperty] )?  			int alt4 = 2;  			try {  				DebugEnterSubRule (4);  				try {  					DebugEnterDecision (4' false);  					int LA4_1 = input.LA (1);  					if ((LA4_1 == BLOCK)) {  						alt4 = 1;  					}  				}  				finally {  					DebugExitDecision (4);  				}  				switch (alt4) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:23:49: block[newProperty]  					{  						DebugLocation (23' 49);  						PushFollow (Follow._block_in_property91);  						block (newProperty);  						PopFollow ();  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (4);  			}  			Match (input' TokenTypes.Up' null);  		}  		DebugLocation (23' 70);  		if ((not != null ? not.Text : default(string)) == "!")  			newProperty.ToggleInclude ();  		if ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).isRegex : default(bool)))  			parentScope.AddRegexProperty ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).name : default(string))' newProperty);  		else  			parentScope.AddProperty ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).name : default(string))' newProperty);  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("property"' 3);  	LeaveRule ("property"' 3);  	LeaveRule_property ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,property,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:23:2: ( ^( propertyName (not= '!' )? ( filter[newProperty] )? ( block[newProperty] )? ) )  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:23:4: ^( propertyName (not= '!' )? ( filter[newProperty] )? ( block[newProperty] )? )  	{  		DebugLocation (23' 4);  		DebugLocation (23' 6);  		PushFollow (Follow._propertyName_in_property80);  		propertyName1 = propertyName ();  		PopFollow ();  		if (input.LA (1) == TokenTypes.Down) {  			Match (input' TokenTypes.Down' null);  			DebugLocation (23' 22);  			// ./src/Parser/Grammar/JFLWalker.g:23:22: (not= '!' )?  			int alt2 = 2;  			try {  				DebugEnterSubRule (2);  				try {  					DebugEnterDecision (2' false);  					int LA2_1 = input.LA (1);  					if ((LA2_1 == 24)) {  						alt2 = 1;  					}  				}  				finally {  					DebugExitDecision (2);  				}  				switch (alt2) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:23:22: not= '!'  					{  						DebugLocation (23' 22);  						not = (CommonTree)Match (input' 24' Follow._24_in_property84);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (2);  			}  			DebugLocation (23' 28);  			// ./src/Parser/Grammar/JFLWalker.g:23:28: ( filter[newProperty] )?  			int alt3 = 2;  			try {  				DebugEnterSubRule (3);  				try {  					DebugEnterDecision (3' false);  					int LA3_1 = input.LA (1);  					if ((LA3_1 == FILTER)) {  						alt3 = 1;  					}  				}  				finally {  					DebugExitDecision (3);  				}  				switch (alt3) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:23:28: filter[newProperty]  					{  						DebugLocation (23' 28);  						PushFollow (Follow._filter_in_property87);  						filter (newProperty);  						PopFollow ();  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (3);  			}  			DebugLocation (23' 49);  			// ./src/Parser/Grammar/JFLWalker.g:23:49: ( block[newProperty] )?  			int alt4 = 2;  			try {  				DebugEnterSubRule (4);  				try {  					DebugEnterDecision (4' false);  					int LA4_1 = input.LA (1);  					if ((LA4_1 == BLOCK)) {  						alt4 = 1;  					}  				}  				finally {  					DebugExitDecision (4);  				}  				switch (alt4) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:23:49: block[newProperty]  					{  						DebugLocation (23' 49);  						PushFollow (Follow._block_in_property91);  						block (newProperty);  						PopFollow ();  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (4);  			}  			Match (input' TokenTypes.Up' null);  		}  		DebugLocation (23' 70);  		if ((not != null ? not.Text : default(string)) == "!")  			newProperty.ToggleInclude ();  		if ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).isRegex : default(bool)))  			parentScope.AddRegexProperty ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).name : default(string))' newProperty);  		else  			parentScope.AddProperty ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).name : default(string))' newProperty);  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("property"' 3);  	LeaveRule ("property"' 3);  	LeaveRule_property ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,property,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:23:2: ( ^( propertyName (not= '!' )? ( filter[newProperty] )? ( block[newProperty] )? ) )  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:23:4: ^( propertyName (not= '!' )? ( filter[newProperty] )? ( block[newProperty] )? )  	{  		DebugLocation (23' 4);  		DebugLocation (23' 6);  		PushFollow (Follow._propertyName_in_property80);  		propertyName1 = propertyName ();  		PopFollow ();  		if (input.LA (1) == TokenTypes.Down) {  			Match (input' TokenTypes.Down' null);  			DebugLocation (23' 22);  			// ./src/Parser/Grammar/JFLWalker.g:23:22: (not= '!' )?  			int alt2 = 2;  			try {  				DebugEnterSubRule (2);  				try {  					DebugEnterDecision (2' false);  					int LA2_1 = input.LA (1);  					if ((LA2_1 == 24)) {  						alt2 = 1;  					}  				}  				finally {  					DebugExitDecision (2);  				}  				switch (alt2) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:23:22: not= '!'  					{  						DebugLocation (23' 22);  						not = (CommonTree)Match (input' 24' Follow._24_in_property84);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (2);  			}  			DebugLocation (23' 28);  			// ./src/Parser/Grammar/JFLWalker.g:23:28: ( filter[newProperty] )?  			int alt3 = 2;  			try {  				DebugEnterSubRule (3);  				try {  					DebugEnterDecision (3' false);  					int LA3_1 = input.LA (1);  					if ((LA3_1 == FILTER)) {  						alt3 = 1;  					}  				}  				finally {  					DebugExitDecision (3);  				}  				switch (alt3) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:23:28: filter[newProperty]  					{  						DebugLocation (23' 28);  						PushFollow (Follow._filter_in_property87);  						filter (newProperty);  						PopFollow ();  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (3);  			}  			DebugLocation (23' 49);  			// ./src/Parser/Grammar/JFLWalker.g:23:49: ( block[newProperty] )?  			int alt4 = 2;  			try {  				DebugEnterSubRule (4);  				try {  					DebugEnterDecision (4' false);  					int LA4_1 = input.LA (1);  					if ((LA4_1 == BLOCK)) {  						alt4 = 1;  					}  				}  				finally {  					DebugExitDecision (4);  				}  				switch (alt4) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:23:49: block[newProperty]  					{  						DebugLocation (23' 49);  						PushFollow (Follow._block_in_property91);  						block (newProperty);  						PopFollow ();  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (4);  			}  			Match (input' TokenTypes.Up' null);  		}  		DebugLocation (23' 70);  		if ((not != null ? not.Text : default(string)) == "!")  			newProperty.ToggleInclude ();  		if ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).isRegex : default(bool)))  			parentScope.AddRegexProperty ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).name : default(string))' newProperty);  		else  			parentScope.AddProperty ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).name : default(string))' newProperty);  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("property"' 3);  	LeaveRule ("property"' 3);  	LeaveRule_property ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,property,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:23:2: ( ^( propertyName (not= '!' )? ( filter[newProperty] )? ( block[newProperty] )? ) )  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:23:4: ^( propertyName (not= '!' )? ( filter[newProperty] )? ( block[newProperty] )? )  	{  		DebugLocation (23' 4);  		DebugLocation (23' 6);  		PushFollow (Follow._propertyName_in_property80);  		propertyName1 = propertyName ();  		PopFollow ();  		if (input.LA (1) == TokenTypes.Down) {  			Match (input' TokenTypes.Down' null);  			DebugLocation (23' 22);  			// ./src/Parser/Grammar/JFLWalker.g:23:22: (not= '!' )?  			int alt2 = 2;  			try {  				DebugEnterSubRule (2);  				try {  					DebugEnterDecision (2' false);  					int LA2_1 = input.LA (1);  					if ((LA2_1 == 24)) {  						alt2 = 1;  					}  				}  				finally {  					DebugExitDecision (2);  				}  				switch (alt2) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:23:22: not= '!'  					{  						DebugLocation (23' 22);  						not = (CommonTree)Match (input' 24' Follow._24_in_property84);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (2);  			}  			DebugLocation (23' 28);  			// ./src/Parser/Grammar/JFLWalker.g:23:28: ( filter[newProperty] )?  			int alt3 = 2;  			try {  				DebugEnterSubRule (3);  				try {  					DebugEnterDecision (3' false);  					int LA3_1 = input.LA (1);  					if ((LA3_1 == FILTER)) {  						alt3 = 1;  					}  				}  				finally {  					DebugExitDecision (3);  				}  				switch (alt3) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:23:28: filter[newProperty]  					{  						DebugLocation (23' 28);  						PushFollow (Follow._filter_in_property87);  						filter (newProperty);  						PopFollow ();  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (3);  			}  			DebugLocation (23' 49);  			// ./src/Parser/Grammar/JFLWalker.g:23:49: ( block[newProperty] )?  			int alt4 = 2;  			try {  				DebugEnterSubRule (4);  				try {  					DebugEnterDecision (4' false);  					int LA4_1 = input.LA (1);  					if ((LA4_1 == BLOCK)) {  						alt4 = 1;  					}  				}  				finally {  					DebugExitDecision (4);  				}  				switch (alt4) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:23:49: block[newProperty]  					{  						DebugLocation (23' 49);  						PushFollow (Follow._block_in_property91);  						block (newProperty);  						PopFollow ();  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (4);  			}  			Match (input' TokenTypes.Up' null);  		}  		DebugLocation (23' 70);  		if ((not != null ? not.Text : default(string)) == "!")  			newProperty.ToggleInclude ();  		if ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).isRegex : default(bool)))  			parentScope.AddRegexProperty ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).name : default(string))' newProperty);  		else  			parentScope.AddProperty ((propertyName1 != null ? ((JFLWalker.propertyName_return)propertyName1).name : default(string))' newProperty);  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("property"' 3);  	LeaveRule ("property"' 3);  	LeaveRule_property ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,property,The following statement contains a magic number: DebugLocation (23' 4);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,property,The following statement contains a magic number: DebugLocation (23' 4);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,property,The following statement contains a magic number: DebugLocation (23' 6);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,property,The following statement contains a magic number: DebugLocation (23' 6);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,property,The following statement contains a magic number: if (input.LA (1) == TokenTypes.Down) {  	Match (input' TokenTypes.Down' null);  	DebugLocation (23' 22);  	// ./src/Parser/Grammar/JFLWalker.g:23:22: (not= '!' )?  	int alt2 = 2;  	try {  		DebugEnterSubRule (2);  		try {  			DebugEnterDecision (2' false);  			int LA2_1 = input.LA (1);  			if ((LA2_1 == 24)) {  				alt2 = 1;  			}  		}  		finally {  			DebugExitDecision (2);  		}  		switch (alt2) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:23:22: not= '!'  			{  				DebugLocation (23' 22);  				not = (CommonTree)Match (input' 24' Follow._24_in_property84);  			}  			break;  		}  	}  	finally {  		DebugExitSubRule (2);  	}  	DebugLocation (23' 28);  	// ./src/Parser/Grammar/JFLWalker.g:23:28: ( filter[newProperty] )?  	int alt3 = 2;  	try {  		DebugEnterSubRule (3);  		try {  			DebugEnterDecision (3' false);  			int LA3_1 = input.LA (1);  			if ((LA3_1 == FILTER)) {  				alt3 = 1;  			}  		}  		finally {  			DebugExitDecision (3);  		}  		switch (alt3) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:23:28: filter[newProperty]  			{  				DebugLocation (23' 28);  				PushFollow (Follow._filter_in_property87);  				filter (newProperty);  				PopFollow ();  			}  			break;  		}  	}  	finally {  		DebugExitSubRule (3);  	}  	DebugLocation (23' 49);  	// ./src/Parser/Grammar/JFLWalker.g:23:49: ( block[newProperty] )?  	int alt4 = 2;  	try {  		DebugEnterSubRule (4);  		try {  			DebugEnterDecision (4' false);  			int LA4_1 = input.LA (1);  			if ((LA4_1 == BLOCK)) {  				alt4 = 1;  			}  		}  		finally {  			DebugExitDecision (4);  		}  		switch (alt4) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:23:49: block[newProperty]  			{  				DebugLocation (23' 49);  				PushFollow (Follow._block_in_property91);  				block (newProperty);  				PopFollow ();  			}  			break;  		}  	}  	finally {  		DebugExitSubRule (4);  	}  	Match (input' TokenTypes.Up' null);  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,property,The following statement contains a magic number: if (input.LA (1) == TokenTypes.Down) {  	Match (input' TokenTypes.Down' null);  	DebugLocation (23' 22);  	// ./src/Parser/Grammar/JFLWalker.g:23:22: (not= '!' )?  	int alt2 = 2;  	try {  		DebugEnterSubRule (2);  		try {  			DebugEnterDecision (2' false);  			int LA2_1 = input.LA (1);  			if ((LA2_1 == 24)) {  				alt2 = 1;  			}  		}  		finally {  			DebugExitDecision (2);  		}  		switch (alt2) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:23:22: not= '!'  			{  				DebugLocation (23' 22);  				not = (CommonTree)Match (input' 24' Follow._24_in_property84);  			}  			break;  		}  	}  	finally {  		DebugExitSubRule (2);  	}  	DebugLocation (23' 28);  	// ./src/Parser/Grammar/JFLWalker.g:23:28: ( filter[newProperty] )?  	int alt3 = 2;  	try {  		DebugEnterSubRule (3);  		try {  			DebugEnterDecision (3' false);  			int LA3_1 = input.LA (1);  			if ((LA3_1 == FILTER)) {  				alt3 = 1;  			}  		}  		finally {  			DebugExitDecision (3);  		}  		switch (alt3) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:23:28: filter[newProperty]  			{  				DebugLocation (23' 28);  				PushFollow (Follow._filter_in_property87);  				filter (newProperty);  				PopFollow ();  			}  			break;  		}  	}  	finally {  		DebugExitSubRule (3);  	}  	DebugLocation (23' 49);  	// ./src/Parser/Grammar/JFLWalker.g:23:49: ( block[newProperty] )?  	int alt4 = 2;  	try {  		DebugEnterSubRule (4);  		try {  			DebugEnterDecision (4' false);  			int LA4_1 = input.LA (1);  			if ((LA4_1 == BLOCK)) {  				alt4 = 1;  			}  		}  		finally {  			DebugExitDecision (4);  		}  		switch (alt4) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:23:49: block[newProperty]  			{  				DebugLocation (23' 49);  				PushFollow (Follow._block_in_property91);  				block (newProperty);  				PopFollow ();  			}  			break;  		}  	}  	finally {  		DebugExitSubRule (4);  	}  	Match (input' TokenTypes.Up' null);  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,property,The following statement contains a magic number: if (input.LA (1) == TokenTypes.Down) {  	Match (input' TokenTypes.Down' null);  	DebugLocation (23' 22);  	// ./src/Parser/Grammar/JFLWalker.g:23:22: (not= '!' )?  	int alt2 = 2;  	try {  		DebugEnterSubRule (2);  		try {  			DebugEnterDecision (2' false);  			int LA2_1 = input.LA (1);  			if ((LA2_1 == 24)) {  				alt2 = 1;  			}  		}  		finally {  			DebugExitDecision (2);  		}  		switch (alt2) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:23:22: not= '!'  			{  				DebugLocation (23' 22);  				not = (CommonTree)Match (input' 24' Follow._24_in_property84);  			}  			break;  		}  	}  	finally {  		DebugExitSubRule (2);  	}  	DebugLocation (23' 28);  	// ./src/Parser/Grammar/JFLWalker.g:23:28: ( filter[newProperty] )?  	int alt3 = 2;  	try {  		DebugEnterSubRule (3);  		try {  			DebugEnterDecision (3' false);  			int LA3_1 = input.LA (1);  			if ((LA3_1 == FILTER)) {  				alt3 = 1;  			}  		}  		finally {  			DebugExitDecision (3);  		}  		switch (alt3) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:23:28: filter[newProperty]  			{  				DebugLocation (23' 28);  				PushFollow (Follow._filter_in_property87);  				filter (newProperty);  				PopFollow ();  			}  			break;  		}  	}  	finally {  		DebugExitSubRule (3);  	}  	DebugLocation (23' 49);  	// ./src/Parser/Grammar/JFLWalker.g:23:49: ( block[newProperty] )?  	int alt4 = 2;  	try {  		DebugEnterSubRule (4);  		try {  			DebugEnterDecision (4' false);  			int LA4_1 = input.LA (1);  			if ((LA4_1 == BLOCK)) {  				alt4 = 1;  			}  		}  		finally {  			DebugExitDecision (4);  		}  		switch (alt4) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:23:49: block[newProperty]  			{  				DebugLocation (23' 49);  				PushFollow (Follow._block_in_property91);  				block (newProperty);  				PopFollow ();  			}  			break;  		}  	}  	finally {  		DebugExitSubRule (4);  	}  	Match (input' TokenTypes.Up' null);  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,property,The following statement contains a magic number: if (input.LA (1) == TokenTypes.Down) {  	Match (input' TokenTypes.Down' null);  	DebugLocation (23' 22);  	// ./src/Parser/Grammar/JFLWalker.g:23:22: (not= '!' )?  	int alt2 = 2;  	try {  		DebugEnterSubRule (2);  		try {  			DebugEnterDecision (2' false);  			int LA2_1 = input.LA (1);  			if ((LA2_1 == 24)) {  				alt2 = 1;  			}  		}  		finally {  			DebugExitDecision (2);  		}  		switch (alt2) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:23:22: not= '!'  			{  				DebugLocation (23' 22);  				not = (CommonTree)Match (input' 24' Follow._24_in_property84);  			}  			break;  		}  	}  	finally {  		DebugExitSubRule (2);  	}  	DebugLocation (23' 28);  	// ./src/Parser/Grammar/JFLWalker.g:23:28: ( filter[newProperty] )?  	int alt3 = 2;  	try {  		DebugEnterSubRule (3);  		try {  			DebugEnterDecision (3' false);  			int LA3_1 = input.LA (1);  			if ((LA3_1 == FILTER)) {  				alt3 = 1;  			}  		}  		finally {  			DebugExitDecision (3);  		}  		switch (alt3) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:23:28: filter[newProperty]  			{  				DebugLocation (23' 28);  				PushFollow (Follow._filter_in_property87);  				filter (newProperty);  				PopFollow ();  			}  			break;  		}  	}  	finally {  		DebugExitSubRule (3);  	}  	DebugLocation (23' 49);  	// ./src/Parser/Grammar/JFLWalker.g:23:49: ( block[newProperty] )?  	int alt4 = 2;  	try {  		DebugEnterSubRule (4);  		try {  			DebugEnterDecision (4' false);  			int LA4_1 = input.LA (1);  			if ((LA4_1 == BLOCK)) {  				alt4 = 1;  			}  		}  		finally {  			DebugExitDecision (4);  		}  		switch (alt4) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:23:49: block[newProperty]  			{  				DebugLocation (23' 49);  				PushFollow (Follow._block_in_property91);  				block (newProperty);  				PopFollow ();  			}  			break;  		}  	}  	finally {  		DebugExitSubRule (4);  	}  	Match (input' TokenTypes.Up' null);  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,property,The following statement contains a magic number: if (input.LA (1) == TokenTypes.Down) {  	Match (input' TokenTypes.Down' null);  	DebugLocation (23' 22);  	// ./src/Parser/Grammar/JFLWalker.g:23:22: (not= '!' )?  	int alt2 = 2;  	try {  		DebugEnterSubRule (2);  		try {  			DebugEnterDecision (2' false);  			int LA2_1 = input.LA (1);  			if ((LA2_1 == 24)) {  				alt2 = 1;  			}  		}  		finally {  			DebugExitDecision (2);  		}  		switch (alt2) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:23:22: not= '!'  			{  				DebugLocation (23' 22);  				not = (CommonTree)Match (input' 24' Follow._24_in_property84);  			}  			break;  		}  	}  	finally {  		DebugExitSubRule (2);  	}  	DebugLocation (23' 28);  	// ./src/Parser/Grammar/JFLWalker.g:23:28: ( filter[newProperty] )?  	int alt3 = 2;  	try {  		DebugEnterSubRule (3);  		try {  			DebugEnterDecision (3' false);  			int LA3_1 = input.LA (1);  			if ((LA3_1 == FILTER)) {  				alt3 = 1;  			}  		}  		finally {  			DebugExitDecision (3);  		}  		switch (alt3) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:23:28: filter[newProperty]  			{  				DebugLocation (23' 28);  				PushFollow (Follow._filter_in_property87);  				filter (newProperty);  				PopFollow ();  			}  			break;  		}  	}  	finally {  		DebugExitSubRule (3);  	}  	DebugLocation (23' 49);  	// ./src/Parser/Grammar/JFLWalker.g:23:49: ( block[newProperty] )?  	int alt4 = 2;  	try {  		DebugEnterSubRule (4);  		try {  			DebugEnterDecision (4' false);  			int LA4_1 = input.LA (1);  			if ((LA4_1 == BLOCK)) {  				alt4 = 1;  			}  		}  		finally {  			DebugExitDecision (4);  		}  		switch (alt4) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:23:49: block[newProperty]  			{  				DebugLocation (23' 49);  				PushFollow (Follow._block_in_property91);  				block (newProperty);  				PopFollow ();  			}  			break;  		}  	}  	finally {  		DebugExitSubRule (4);  	}  	Match (input' TokenTypes.Up' null);  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,property,The following statement contains a magic number: if (input.LA (1) == TokenTypes.Down) {  	Match (input' TokenTypes.Down' null);  	DebugLocation (23' 22);  	// ./src/Parser/Grammar/JFLWalker.g:23:22: (not= '!' )?  	int alt2 = 2;  	try {  		DebugEnterSubRule (2);  		try {  			DebugEnterDecision (2' false);  			int LA2_1 = input.LA (1);  			if ((LA2_1 == 24)) {  				alt2 = 1;  			}  		}  		finally {  			DebugExitDecision (2);  		}  		switch (alt2) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:23:22: not= '!'  			{  				DebugLocation (23' 22);  				not = (CommonTree)Match (input' 24' Follow._24_in_property84);  			}  			break;  		}  	}  	finally {  		DebugExitSubRule (2);  	}  	DebugLocation (23' 28);  	// ./src/Parser/Grammar/JFLWalker.g:23:28: ( filter[newProperty] )?  	int alt3 = 2;  	try {  		DebugEnterSubRule (3);  		try {  			DebugEnterDecision (3' false);  			int LA3_1 = input.LA (1);  			if ((LA3_1 == FILTER)) {  				alt3 = 1;  			}  		}  		finally {  			DebugExitDecision (3);  		}  		switch (alt3) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:23:28: filter[newProperty]  			{  				DebugLocation (23' 28);  				PushFollow (Follow._filter_in_property87);  				filter (newProperty);  				PopFollow ();  			}  			break;  		}  	}  	finally {  		DebugExitSubRule (3);  	}  	DebugLocation (23' 49);  	// ./src/Parser/Grammar/JFLWalker.g:23:49: ( block[newProperty] )?  	int alt4 = 2;  	try {  		DebugEnterSubRule (4);  		try {  			DebugEnterDecision (4' false);  			int LA4_1 = input.LA (1);  			if ((LA4_1 == BLOCK)) {  				alt4 = 1;  			}  		}  		finally {  			DebugExitDecision (4);  		}  		switch (alt4) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:23:49: block[newProperty]  			{  				DebugLocation (23' 49);  				PushFollow (Follow._block_in_property91);  				block (newProperty);  				PopFollow ();  			}  			break;  		}  	}  	finally {  		DebugExitSubRule (4);  	}  	Match (input' TokenTypes.Up' null);  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,property,The following statement contains a magic number: if (input.LA (1) == TokenTypes.Down) {  	Match (input' TokenTypes.Down' null);  	DebugLocation (23' 22);  	// ./src/Parser/Grammar/JFLWalker.g:23:22: (not= '!' )?  	int alt2 = 2;  	try {  		DebugEnterSubRule (2);  		try {  			DebugEnterDecision (2' false);  			int LA2_1 = input.LA (1);  			if ((LA2_1 == 24)) {  				alt2 = 1;  			}  		}  		finally {  			DebugExitDecision (2);  		}  		switch (alt2) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:23:22: not= '!'  			{  				DebugLocation (23' 22);  				not = (CommonTree)Match (input' 24' Follow._24_in_property84);  			}  			break;  		}  	}  	finally {  		DebugExitSubRule (2);  	}  	DebugLocation (23' 28);  	// ./src/Parser/Grammar/JFLWalker.g:23:28: ( filter[newProperty] )?  	int alt3 = 2;  	try {  		DebugEnterSubRule (3);  		try {  			DebugEnterDecision (3' false);  			int LA3_1 = input.LA (1);  			if ((LA3_1 == FILTER)) {  				alt3 = 1;  			}  		}  		finally {  			DebugExitDecision (3);  		}  		switch (alt3) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:23:28: filter[newProperty]  			{  				DebugLocation (23' 28);  				PushFollow (Follow._filter_in_property87);  				filter (newProperty);  				PopFollow ();  			}  			break;  		}  	}  	finally {  		DebugExitSubRule (3);  	}  	DebugLocation (23' 49);  	// ./src/Parser/Grammar/JFLWalker.g:23:49: ( block[newProperty] )?  	int alt4 = 2;  	try {  		DebugEnterSubRule (4);  		try {  			DebugEnterDecision (4' false);  			int LA4_1 = input.LA (1);  			if ((LA4_1 == BLOCK)) {  				alt4 = 1;  			}  		}  		finally {  			DebugExitDecision (4);  		}  		switch (alt4) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:23:49: block[newProperty]  			{  				DebugLocation (23' 49);  				PushFollow (Follow._block_in_property91);  				block (newProperty);  				PopFollow ();  			}  			break;  		}  	}  	finally {  		DebugExitSubRule (4);  	}  	Match (input' TokenTypes.Up' null);  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,property,The following statement contains a magic number: if (input.LA (1) == TokenTypes.Down) {  	Match (input' TokenTypes.Down' null);  	DebugLocation (23' 22);  	// ./src/Parser/Grammar/JFLWalker.g:23:22: (not= '!' )?  	int alt2 = 2;  	try {  		DebugEnterSubRule (2);  		try {  			DebugEnterDecision (2' false);  			int LA2_1 = input.LA (1);  			if ((LA2_1 == 24)) {  				alt2 = 1;  			}  		}  		finally {  			DebugExitDecision (2);  		}  		switch (alt2) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:23:22: not= '!'  			{  				DebugLocation (23' 22);  				not = (CommonTree)Match (input' 24' Follow._24_in_property84);  			}  			break;  		}  	}  	finally {  		DebugExitSubRule (2);  	}  	DebugLocation (23' 28);  	// ./src/Parser/Grammar/JFLWalker.g:23:28: ( filter[newProperty] )?  	int alt3 = 2;  	try {  		DebugEnterSubRule (3);  		try {  			DebugEnterDecision (3' false);  			int LA3_1 = input.LA (1);  			if ((LA3_1 == FILTER)) {  				alt3 = 1;  			}  		}  		finally {  			DebugExitDecision (3);  		}  		switch (alt3) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:23:28: filter[newProperty]  			{  				DebugLocation (23' 28);  				PushFollow (Follow._filter_in_property87);  				filter (newProperty);  				PopFollow ();  			}  			break;  		}  	}  	finally {  		DebugExitSubRule (3);  	}  	DebugLocation (23' 49);  	// ./src/Parser/Grammar/JFLWalker.g:23:49: ( block[newProperty] )?  	int alt4 = 2;  	try {  		DebugEnterSubRule (4);  		try {  			DebugEnterDecision (4' false);  			int LA4_1 = input.LA (1);  			if ((LA4_1 == BLOCK)) {  				alt4 = 1;  			}  		}  		finally {  			DebugExitDecision (4);  		}  		switch (alt4) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:23:49: block[newProperty]  			{  				DebugLocation (23' 49);  				PushFollow (Follow._block_in_property91);  				block (newProperty);  				PopFollow ();  			}  			break;  		}  	}  	finally {  		DebugExitSubRule (4);  	}  	Match (input' TokenTypes.Up' null);  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,property,The following statement contains a magic number: if (input.LA (1) == TokenTypes.Down) {  	Match (input' TokenTypes.Down' null);  	DebugLocation (23' 22);  	// ./src/Parser/Grammar/JFLWalker.g:23:22: (not= '!' )?  	int alt2 = 2;  	try {  		DebugEnterSubRule (2);  		try {  			DebugEnterDecision (2' false);  			int LA2_1 = input.LA (1);  			if ((LA2_1 == 24)) {  				alt2 = 1;  			}  		}  		finally {  			DebugExitDecision (2);  		}  		switch (alt2) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:23:22: not= '!'  			{  				DebugLocation (23' 22);  				not = (CommonTree)Match (input' 24' Follow._24_in_property84);  			}  			break;  		}  	}  	finally {  		DebugExitSubRule (2);  	}  	DebugLocation (23' 28);  	// ./src/Parser/Grammar/JFLWalker.g:23:28: ( filter[newProperty] )?  	int alt3 = 2;  	try {  		DebugEnterSubRule (3);  		try {  			DebugEnterDecision (3' false);  			int LA3_1 = input.LA (1);  			if ((LA3_1 == FILTER)) {  				alt3 = 1;  			}  		}  		finally {  			DebugExitDecision (3);  		}  		switch (alt3) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:23:28: filter[newProperty]  			{  				DebugLocation (23' 28);  				PushFollow (Follow._filter_in_property87);  				filter (newProperty);  				PopFollow ();  			}  			break;  		}  	}  	finally {  		DebugExitSubRule (3);  	}  	DebugLocation (23' 49);  	// ./src/Parser/Grammar/JFLWalker.g:23:49: ( block[newProperty] )?  	int alt4 = 2;  	try {  		DebugEnterSubRule (4);  		try {  			DebugEnterDecision (4' false);  			int LA4_1 = input.LA (1);  			if ((LA4_1 == BLOCK)) {  				alt4 = 1;  			}  		}  		finally {  			DebugExitDecision (4);  		}  		switch (alt4) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:23:49: block[newProperty]  			{  				DebugLocation (23' 49);  				PushFollow (Follow._block_in_property91);  				block (newProperty);  				PopFollow ();  			}  			break;  		}  	}  	finally {  		DebugExitSubRule (4);  	}  	Match (input' TokenTypes.Up' null);  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,property,The following statement contains a magic number: if (input.LA (1) == TokenTypes.Down) {  	Match (input' TokenTypes.Down' null);  	DebugLocation (23' 22);  	// ./src/Parser/Grammar/JFLWalker.g:23:22: (not= '!' )?  	int alt2 = 2;  	try {  		DebugEnterSubRule (2);  		try {  			DebugEnterDecision (2' false);  			int LA2_1 = input.LA (1);  			if ((LA2_1 == 24)) {  				alt2 = 1;  			}  		}  		finally {  			DebugExitDecision (2);  		}  		switch (alt2) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:23:22: not= '!'  			{  				DebugLocation (23' 22);  				not = (CommonTree)Match (input' 24' Follow._24_in_property84);  			}  			break;  		}  	}  	finally {  		DebugExitSubRule (2);  	}  	DebugLocation (23' 28);  	// ./src/Parser/Grammar/JFLWalker.g:23:28: ( filter[newProperty] )?  	int alt3 = 2;  	try {  		DebugEnterSubRule (3);  		try {  			DebugEnterDecision (3' false);  			int LA3_1 = input.LA (1);  			if ((LA3_1 == FILTER)) {  				alt3 = 1;  			}  		}  		finally {  			DebugExitDecision (3);  		}  		switch (alt3) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:23:28: filter[newProperty]  			{  				DebugLocation (23' 28);  				PushFollow (Follow._filter_in_property87);  				filter (newProperty);  				PopFollow ();  			}  			break;  		}  	}  	finally {  		DebugExitSubRule (3);  	}  	DebugLocation (23' 49);  	// ./src/Parser/Grammar/JFLWalker.g:23:49: ( block[newProperty] )?  	int alt4 = 2;  	try {  		DebugEnterSubRule (4);  		try {  			DebugEnterDecision (4' false);  			int LA4_1 = input.LA (1);  			if ((LA4_1 == BLOCK)) {  				alt4 = 1;  			}  		}  		finally {  			DebugExitDecision (4);  		}  		switch (alt4) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:23:49: block[newProperty]  			{  				DebugLocation (23' 49);  				PushFollow (Follow._block_in_property91);  				block (newProperty);  				PopFollow ();  			}  			break;  		}  	}  	finally {  		DebugExitSubRule (4);  	}  	Match (input' TokenTypes.Up' null);  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,property,The following statement contains a magic number: if (input.LA (1) == TokenTypes.Down) {  	Match (input' TokenTypes.Down' null);  	DebugLocation (23' 22);  	// ./src/Parser/Grammar/JFLWalker.g:23:22: (not= '!' )?  	int alt2 = 2;  	try {  		DebugEnterSubRule (2);  		try {  			DebugEnterDecision (2' false);  			int LA2_1 = input.LA (1);  			if ((LA2_1 == 24)) {  				alt2 = 1;  			}  		}  		finally {  			DebugExitDecision (2);  		}  		switch (alt2) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:23:22: not= '!'  			{  				DebugLocation (23' 22);  				not = (CommonTree)Match (input' 24' Follow._24_in_property84);  			}  			break;  		}  	}  	finally {  		DebugExitSubRule (2);  	}  	DebugLocation (23' 28);  	// ./src/Parser/Grammar/JFLWalker.g:23:28: ( filter[newProperty] )?  	int alt3 = 2;  	try {  		DebugEnterSubRule (3);  		try {  			DebugEnterDecision (3' false);  			int LA3_1 = input.LA (1);  			if ((LA3_1 == FILTER)) {  				alt3 = 1;  			}  		}  		finally {  			DebugExitDecision (3);  		}  		switch (alt3) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:23:28: filter[newProperty]  			{  				DebugLocation (23' 28);  				PushFollow (Follow._filter_in_property87);  				filter (newProperty);  				PopFollow ();  			}  			break;  		}  	}  	finally {  		DebugExitSubRule (3);  	}  	DebugLocation (23' 49);  	// ./src/Parser/Grammar/JFLWalker.g:23:49: ( block[newProperty] )?  	int alt4 = 2;  	try {  		DebugEnterSubRule (4);  		try {  			DebugEnterDecision (4' false);  			int LA4_1 = input.LA (1);  			if ((LA4_1 == BLOCK)) {  				alt4 = 1;  			}  		}  		finally {  			DebugExitDecision (4);  		}  		switch (alt4) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:23:49: block[newProperty]  			{  				DebugLocation (23' 49);  				PushFollow (Follow._block_in_property91);  				block (newProperty);  				PopFollow ();  			}  			break;  		}  	}  	finally {  		DebugExitSubRule (4);  	}  	Match (input' TokenTypes.Up' null);  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,property,The following statement contains a magic number: if (input.LA (1) == TokenTypes.Down) {  	Match (input' TokenTypes.Down' null);  	DebugLocation (23' 22);  	// ./src/Parser/Grammar/JFLWalker.g:23:22: (not= '!' )?  	int alt2 = 2;  	try {  		DebugEnterSubRule (2);  		try {  			DebugEnterDecision (2' false);  			int LA2_1 = input.LA (1);  			if ((LA2_1 == 24)) {  				alt2 = 1;  			}  		}  		finally {  			DebugExitDecision (2);  		}  		switch (alt2) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:23:22: not= '!'  			{  				DebugLocation (23' 22);  				not = (CommonTree)Match (input' 24' Follow._24_in_property84);  			}  			break;  		}  	}  	finally {  		DebugExitSubRule (2);  	}  	DebugLocation (23' 28);  	// ./src/Parser/Grammar/JFLWalker.g:23:28: ( filter[newProperty] )?  	int alt3 = 2;  	try {  		DebugEnterSubRule (3);  		try {  			DebugEnterDecision (3' false);  			int LA3_1 = input.LA (1);  			if ((LA3_1 == FILTER)) {  				alt3 = 1;  			}  		}  		finally {  			DebugExitDecision (3);  		}  		switch (alt3) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:23:28: filter[newProperty]  			{  				DebugLocation (23' 28);  				PushFollow (Follow._filter_in_property87);  				filter (newProperty);  				PopFollow ();  			}  			break;  		}  	}  	finally {  		DebugExitSubRule (3);  	}  	DebugLocation (23' 49);  	// ./src/Parser/Grammar/JFLWalker.g:23:49: ( block[newProperty] )?  	int alt4 = 2;  	try {  		DebugEnterSubRule (4);  		try {  			DebugEnterDecision (4' false);  			int LA4_1 = input.LA (1);  			if ((LA4_1 == BLOCK)) {  				alt4 = 1;  			}  		}  		finally {  			DebugExitDecision (4);  		}  		switch (alt4) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:23:49: block[newProperty]  			{  				DebugLocation (23' 49);  				PushFollow (Follow._block_in_property91);  				block (newProperty);  				PopFollow ();  			}  			break;  		}  	}  	finally {  		DebugExitSubRule (4);  	}  	Match (input' TokenTypes.Up' null);  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,property,The following statement contains a magic number: if (input.LA (1) == TokenTypes.Down) {  	Match (input' TokenTypes.Down' null);  	DebugLocation (23' 22);  	// ./src/Parser/Grammar/JFLWalker.g:23:22: (not= '!' )?  	int alt2 = 2;  	try {  		DebugEnterSubRule (2);  		try {  			DebugEnterDecision (2' false);  			int LA2_1 = input.LA (1);  			if ((LA2_1 == 24)) {  				alt2 = 1;  			}  		}  		finally {  			DebugExitDecision (2);  		}  		switch (alt2) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:23:22: not= '!'  			{  				DebugLocation (23' 22);  				not = (CommonTree)Match (input' 24' Follow._24_in_property84);  			}  			break;  		}  	}  	finally {  		DebugExitSubRule (2);  	}  	DebugLocation (23' 28);  	// ./src/Parser/Grammar/JFLWalker.g:23:28: ( filter[newProperty] )?  	int alt3 = 2;  	try {  		DebugEnterSubRule (3);  		try {  			DebugEnterDecision (3' false);  			int LA3_1 = input.LA (1);  			if ((LA3_1 == FILTER)) {  				alt3 = 1;  			}  		}  		finally {  			DebugExitDecision (3);  		}  		switch (alt3) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:23:28: filter[newProperty]  			{  				DebugLocation (23' 28);  				PushFollow (Follow._filter_in_property87);  				filter (newProperty);  				PopFollow ();  			}  			break;  		}  	}  	finally {  		DebugExitSubRule (3);  	}  	DebugLocation (23' 49);  	// ./src/Parser/Grammar/JFLWalker.g:23:49: ( block[newProperty] )?  	int alt4 = 2;  	try {  		DebugEnterSubRule (4);  		try {  			DebugEnterDecision (4' false);  			int LA4_1 = input.LA (1);  			if ((LA4_1 == BLOCK)) {  				alt4 = 1;  			}  		}  		finally {  			DebugExitDecision (4);  		}  		switch (alt4) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:23:49: block[newProperty]  			{  				DebugLocation (23' 49);  				PushFollow (Follow._block_in_property91);  				block (newProperty);  				PopFollow ();  			}  			break;  		}  	}  	finally {  		DebugExitSubRule (4);  	}  	Match (input' TokenTypes.Up' null);  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,property,The following statement contains a magic number: if (input.LA (1) == TokenTypes.Down) {  	Match (input' TokenTypes.Down' null);  	DebugLocation (23' 22);  	// ./src/Parser/Grammar/JFLWalker.g:23:22: (not= '!' )?  	int alt2 = 2;  	try {  		DebugEnterSubRule (2);  		try {  			DebugEnterDecision (2' false);  			int LA2_1 = input.LA (1);  			if ((LA2_1 == 24)) {  				alt2 = 1;  			}  		}  		finally {  			DebugExitDecision (2);  		}  		switch (alt2) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:23:22: not= '!'  			{  				DebugLocation (23' 22);  				not = (CommonTree)Match (input' 24' Follow._24_in_property84);  			}  			break;  		}  	}  	finally {  		DebugExitSubRule (2);  	}  	DebugLocation (23' 28);  	// ./src/Parser/Grammar/JFLWalker.g:23:28: ( filter[newProperty] )?  	int alt3 = 2;  	try {  		DebugEnterSubRule (3);  		try {  			DebugEnterDecision (3' false);  			int LA3_1 = input.LA (1);  			if ((LA3_1 == FILTER)) {  				alt3 = 1;  			}  		}  		finally {  			DebugExitDecision (3);  		}  		switch (alt3) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:23:28: filter[newProperty]  			{  				DebugLocation (23' 28);  				PushFollow (Follow._filter_in_property87);  				filter (newProperty);  				PopFollow ();  			}  			break;  		}  	}  	finally {  		DebugExitSubRule (3);  	}  	DebugLocation (23' 49);  	// ./src/Parser/Grammar/JFLWalker.g:23:49: ( block[newProperty] )?  	int alt4 = 2;  	try {  		DebugEnterSubRule (4);  		try {  			DebugEnterDecision (4' false);  			int LA4_1 = input.LA (1);  			if ((LA4_1 == BLOCK)) {  				alt4 = 1;  			}  		}  		finally {  			DebugExitDecision (4);  		}  		switch (alt4) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:23:49: block[newProperty]  			{  				DebugLocation (23' 49);  				PushFollow (Follow._block_in_property91);  				block (newProperty);  				PopFollow ();  			}  			break;  		}  	}  	finally {  		DebugExitSubRule (4);  	}  	Match (input' TokenTypes.Up' null);  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,property,The following statement contains a magic number: if (input.LA (1) == TokenTypes.Down) {  	Match (input' TokenTypes.Down' null);  	DebugLocation (23' 22);  	// ./src/Parser/Grammar/JFLWalker.g:23:22: (not= '!' )?  	int alt2 = 2;  	try {  		DebugEnterSubRule (2);  		try {  			DebugEnterDecision (2' false);  			int LA2_1 = input.LA (1);  			if ((LA2_1 == 24)) {  				alt2 = 1;  			}  		}  		finally {  			DebugExitDecision (2);  		}  		switch (alt2) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:23:22: not= '!'  			{  				DebugLocation (23' 22);  				not = (CommonTree)Match (input' 24' Follow._24_in_property84);  			}  			break;  		}  	}  	finally {  		DebugExitSubRule (2);  	}  	DebugLocation (23' 28);  	// ./src/Parser/Grammar/JFLWalker.g:23:28: ( filter[newProperty] )?  	int alt3 = 2;  	try {  		DebugEnterSubRule (3);  		try {  			DebugEnterDecision (3' false);  			int LA3_1 = input.LA (1);  			if ((LA3_1 == FILTER)) {  				alt3 = 1;  			}  		}  		finally {  			DebugExitDecision (3);  		}  		switch (alt3) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:23:28: filter[newProperty]  			{  				DebugLocation (23' 28);  				PushFollow (Follow._filter_in_property87);  				filter (newProperty);  				PopFollow ();  			}  			break;  		}  	}  	finally {  		DebugExitSubRule (3);  	}  	DebugLocation (23' 49);  	// ./src/Parser/Grammar/JFLWalker.g:23:49: ( block[newProperty] )?  	int alt4 = 2;  	try {  		DebugEnterSubRule (4);  		try {  			DebugEnterDecision (4' false);  			int LA4_1 = input.LA (1);  			if ((LA4_1 == BLOCK)) {  				alt4 = 1;  			}  		}  		finally {  			DebugExitDecision (4);  		}  		switch (alt4) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:23:49: block[newProperty]  			{  				DebugLocation (23' 49);  				PushFollow (Follow._block_in_property91);  				block (newProperty);  				PopFollow ();  			}  			break;  		}  	}  	finally {  		DebugExitSubRule (4);  	}  	Match (input' TokenTypes.Up' null);  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,property,The following statement contains a magic number: if (input.LA (1) == TokenTypes.Down) {  	Match (input' TokenTypes.Down' null);  	DebugLocation (23' 22);  	// ./src/Parser/Grammar/JFLWalker.g:23:22: (not= '!' )?  	int alt2 = 2;  	try {  		DebugEnterSubRule (2);  		try {  			DebugEnterDecision (2' false);  			int LA2_1 = input.LA (1);  			if ((LA2_1 == 24)) {  				alt2 = 1;  			}  		}  		finally {  			DebugExitDecision (2);  		}  		switch (alt2) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:23:22: not= '!'  			{  				DebugLocation (23' 22);  				not = (CommonTree)Match (input' 24' Follow._24_in_property84);  			}  			break;  		}  	}  	finally {  		DebugExitSubRule (2);  	}  	DebugLocation (23' 28);  	// ./src/Parser/Grammar/JFLWalker.g:23:28: ( filter[newProperty] )?  	int alt3 = 2;  	try {  		DebugEnterSubRule (3);  		try {  			DebugEnterDecision (3' false);  			int LA3_1 = input.LA (1);  			if ((LA3_1 == FILTER)) {  				alt3 = 1;  			}  		}  		finally {  			DebugExitDecision (3);  		}  		switch (alt3) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:23:28: filter[newProperty]  			{  				DebugLocation (23' 28);  				PushFollow (Follow._filter_in_property87);  				filter (newProperty);  				PopFollow ();  			}  			break;  		}  	}  	finally {  		DebugExitSubRule (3);  	}  	DebugLocation (23' 49);  	// ./src/Parser/Grammar/JFLWalker.g:23:49: ( block[newProperty] )?  	int alt4 = 2;  	try {  		DebugEnterSubRule (4);  		try {  			DebugEnterDecision (4' false);  			int LA4_1 = input.LA (1);  			if ((LA4_1 == BLOCK)) {  				alt4 = 1;  			}  		}  		finally {  			DebugExitDecision (4);  		}  		switch (alt4) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:23:49: block[newProperty]  			{  				DebugLocation (23' 49);  				PushFollow (Follow._block_in_property91);  				block (newProperty);  				PopFollow ();  			}  			break;  		}  	}  	finally {  		DebugExitSubRule (4);  	}  	Match (input' TokenTypes.Up' null);  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,property,The following statement contains a magic number: if (input.LA (1) == TokenTypes.Down) {  	Match (input' TokenTypes.Down' null);  	DebugLocation (23' 22);  	// ./src/Parser/Grammar/JFLWalker.g:23:22: (not= '!' )?  	int alt2 = 2;  	try {  		DebugEnterSubRule (2);  		try {  			DebugEnterDecision (2' false);  			int LA2_1 = input.LA (1);  			if ((LA2_1 == 24)) {  				alt2 = 1;  			}  		}  		finally {  			DebugExitDecision (2);  		}  		switch (alt2) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:23:22: not= '!'  			{  				DebugLocation (23' 22);  				not = (CommonTree)Match (input' 24' Follow._24_in_property84);  			}  			break;  		}  	}  	finally {  		DebugExitSubRule (2);  	}  	DebugLocation (23' 28);  	// ./src/Parser/Grammar/JFLWalker.g:23:28: ( filter[newProperty] )?  	int alt3 = 2;  	try {  		DebugEnterSubRule (3);  		try {  			DebugEnterDecision (3' false);  			int LA3_1 = input.LA (1);  			if ((LA3_1 == FILTER)) {  				alt3 = 1;  			}  		}  		finally {  			DebugExitDecision (3);  		}  		switch (alt3) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:23:28: filter[newProperty]  			{  				DebugLocation (23' 28);  				PushFollow (Follow._filter_in_property87);  				filter (newProperty);  				PopFollow ();  			}  			break;  		}  	}  	finally {  		DebugExitSubRule (3);  	}  	DebugLocation (23' 49);  	// ./src/Parser/Grammar/JFLWalker.g:23:49: ( block[newProperty] )?  	int alt4 = 2;  	try {  		DebugEnterSubRule (4);  		try {  			DebugEnterDecision (4' false);  			int LA4_1 = input.LA (1);  			if ((LA4_1 == BLOCK)) {  				alt4 = 1;  			}  		}  		finally {  			DebugExitDecision (4);  		}  		switch (alt4) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:23:49: block[newProperty]  			{  				DebugLocation (23' 49);  				PushFollow (Follow._block_in_property91);  				block (newProperty);  				PopFollow ();  			}  			break;  		}  	}  	finally {  		DebugExitSubRule (4);  	}  	Match (input' TokenTypes.Up' null);  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,property,The following statement contains a magic number: if (input.LA (1) == TokenTypes.Down) {  	Match (input' TokenTypes.Down' null);  	DebugLocation (23' 22);  	// ./src/Parser/Grammar/JFLWalker.g:23:22: (not= '!' )?  	int alt2 = 2;  	try {  		DebugEnterSubRule (2);  		try {  			DebugEnterDecision (2' false);  			int LA2_1 = input.LA (1);  			if ((LA2_1 == 24)) {  				alt2 = 1;  			}  		}  		finally {  			DebugExitDecision (2);  		}  		switch (alt2) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:23:22: not= '!'  			{  				DebugLocation (23' 22);  				not = (CommonTree)Match (input' 24' Follow._24_in_property84);  			}  			break;  		}  	}  	finally {  		DebugExitSubRule (2);  	}  	DebugLocation (23' 28);  	// ./src/Parser/Grammar/JFLWalker.g:23:28: ( filter[newProperty] )?  	int alt3 = 2;  	try {  		DebugEnterSubRule (3);  		try {  			DebugEnterDecision (3' false);  			int LA3_1 = input.LA (1);  			if ((LA3_1 == FILTER)) {  				alt3 = 1;  			}  		}  		finally {  			DebugExitDecision (3);  		}  		switch (alt3) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:23:28: filter[newProperty]  			{  				DebugLocation (23' 28);  				PushFollow (Follow._filter_in_property87);  				filter (newProperty);  				PopFollow ();  			}  			break;  		}  	}  	finally {  		DebugExitSubRule (3);  	}  	DebugLocation (23' 49);  	// ./src/Parser/Grammar/JFLWalker.g:23:49: ( block[newProperty] )?  	int alt4 = 2;  	try {  		DebugEnterSubRule (4);  		try {  			DebugEnterDecision (4' false);  			int LA4_1 = input.LA (1);  			if ((LA4_1 == BLOCK)) {  				alt4 = 1;  			}  		}  		finally {  			DebugExitDecision (4);  		}  		switch (alt4) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:23:49: block[newProperty]  			{  				DebugLocation (23' 49);  				PushFollow (Follow._block_in_property91);  				block (newProperty);  				PopFollow ();  			}  			break;  		}  	}  	finally {  		DebugExitSubRule (4);  	}  	Match (input' TokenTypes.Up' null);  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,property,The following statement contains a magic number: if (input.LA (1) == TokenTypes.Down) {  	Match (input' TokenTypes.Down' null);  	DebugLocation (23' 22);  	// ./src/Parser/Grammar/JFLWalker.g:23:22: (not= '!' )?  	int alt2 = 2;  	try {  		DebugEnterSubRule (2);  		try {  			DebugEnterDecision (2' false);  			int LA2_1 = input.LA (1);  			if ((LA2_1 == 24)) {  				alt2 = 1;  			}  		}  		finally {  			DebugExitDecision (2);  		}  		switch (alt2) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:23:22: not= '!'  			{  				DebugLocation (23' 22);  				not = (CommonTree)Match (input' 24' Follow._24_in_property84);  			}  			break;  		}  	}  	finally {  		DebugExitSubRule (2);  	}  	DebugLocation (23' 28);  	// ./src/Parser/Grammar/JFLWalker.g:23:28: ( filter[newProperty] )?  	int alt3 = 2;  	try {  		DebugEnterSubRule (3);  		try {  			DebugEnterDecision (3' false);  			int LA3_1 = input.LA (1);  			if ((LA3_1 == FILTER)) {  				alt3 = 1;  			}  		}  		finally {  			DebugExitDecision (3);  		}  		switch (alt3) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:23:28: filter[newProperty]  			{  				DebugLocation (23' 28);  				PushFollow (Follow._filter_in_property87);  				filter (newProperty);  				PopFollow ();  			}  			break;  		}  	}  	finally {  		DebugExitSubRule (3);  	}  	DebugLocation (23' 49);  	// ./src/Parser/Grammar/JFLWalker.g:23:49: ( block[newProperty] )?  	int alt4 = 2;  	try {  		DebugEnterSubRule (4);  		try {  			DebugEnterDecision (4' false);  			int LA4_1 = input.LA (1);  			if ((LA4_1 == BLOCK)) {  				alt4 = 1;  			}  		}  		finally {  			DebugExitDecision (4);  		}  		switch (alt4) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:23:49: block[newProperty]  			{  				DebugLocation (23' 49);  				PushFollow (Follow._block_in_property91);  				block (newProperty);  				PopFollow ();  			}  			break;  		}  	}  	finally {  		DebugExitSubRule (4);  	}  	Match (input' TokenTypes.Up' null);  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,property,The following statement contains a magic number: if (input.LA (1) == TokenTypes.Down) {  	Match (input' TokenTypes.Down' null);  	DebugLocation (23' 22);  	// ./src/Parser/Grammar/JFLWalker.g:23:22: (not= '!' )?  	int alt2 = 2;  	try {  		DebugEnterSubRule (2);  		try {  			DebugEnterDecision (2' false);  			int LA2_1 = input.LA (1);  			if ((LA2_1 == 24)) {  				alt2 = 1;  			}  		}  		finally {  			DebugExitDecision (2);  		}  		switch (alt2) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:23:22: not= '!'  			{  				DebugLocation (23' 22);  				not = (CommonTree)Match (input' 24' Follow._24_in_property84);  			}  			break;  		}  	}  	finally {  		DebugExitSubRule (2);  	}  	DebugLocation (23' 28);  	// ./src/Parser/Grammar/JFLWalker.g:23:28: ( filter[newProperty] )?  	int alt3 = 2;  	try {  		DebugEnterSubRule (3);  		try {  			DebugEnterDecision (3' false);  			int LA3_1 = input.LA (1);  			if ((LA3_1 == FILTER)) {  				alt3 = 1;  			}  		}  		finally {  			DebugExitDecision (3);  		}  		switch (alt3) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:23:28: filter[newProperty]  			{  				DebugLocation (23' 28);  				PushFollow (Follow._filter_in_property87);  				filter (newProperty);  				PopFollow ();  			}  			break;  		}  	}  	finally {  		DebugExitSubRule (3);  	}  	DebugLocation (23' 49);  	// ./src/Parser/Grammar/JFLWalker.g:23:49: ( block[newProperty] )?  	int alt4 = 2;  	try {  		DebugEnterSubRule (4);  		try {  			DebugEnterDecision (4' false);  			int LA4_1 = input.LA (1);  			if ((LA4_1 == BLOCK)) {  				alt4 = 1;  			}  		}  		finally {  			DebugExitDecision (4);  		}  		switch (alt4) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:23:49: block[newProperty]  			{  				DebugLocation (23' 49);  				PushFollow (Follow._block_in_property91);  				block (newProperty);  				PopFollow ();  			}  			break;  		}  	}  	finally {  		DebugExitSubRule (4);  	}  	Match (input' TokenTypes.Up' null);  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,property,The following statement contains a magic number: if (input.LA (1) == TokenTypes.Down) {  	Match (input' TokenTypes.Down' null);  	DebugLocation (23' 22);  	// ./src/Parser/Grammar/JFLWalker.g:23:22: (not= '!' )?  	int alt2 = 2;  	try {  		DebugEnterSubRule (2);  		try {  			DebugEnterDecision (2' false);  			int LA2_1 = input.LA (1);  			if ((LA2_1 == 24)) {  				alt2 = 1;  			}  		}  		finally {  			DebugExitDecision (2);  		}  		switch (alt2) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:23:22: not= '!'  			{  				DebugLocation (23' 22);  				not = (CommonTree)Match (input' 24' Follow._24_in_property84);  			}  			break;  		}  	}  	finally {  		DebugExitSubRule (2);  	}  	DebugLocation (23' 28);  	// ./src/Parser/Grammar/JFLWalker.g:23:28: ( filter[newProperty] )?  	int alt3 = 2;  	try {  		DebugEnterSubRule (3);  		try {  			DebugEnterDecision (3' false);  			int LA3_1 = input.LA (1);  			if ((LA3_1 == FILTER)) {  				alt3 = 1;  			}  		}  		finally {  			DebugExitDecision (3);  		}  		switch (alt3) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:23:28: filter[newProperty]  			{  				DebugLocation (23' 28);  				PushFollow (Follow._filter_in_property87);  				filter (newProperty);  				PopFollow ();  			}  			break;  		}  	}  	finally {  		DebugExitSubRule (3);  	}  	DebugLocation (23' 49);  	// ./src/Parser/Grammar/JFLWalker.g:23:49: ( block[newProperty] )?  	int alt4 = 2;  	try {  		DebugEnterSubRule (4);  		try {  			DebugEnterDecision (4' false);  			int LA4_1 = input.LA (1);  			if ((LA4_1 == BLOCK)) {  				alt4 = 1;  			}  		}  		finally {  			DebugExitDecision (4);  		}  		switch (alt4) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:23:49: block[newProperty]  			{  				DebugLocation (23' 49);  				PushFollow (Follow._block_in_property91);  				block (newProperty);  				PopFollow ();  			}  			break;  		}  	}  	finally {  		DebugExitSubRule (4);  	}  	Match (input' TokenTypes.Up' null);  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,property,The following statement contains a magic number: if (input.LA (1) == TokenTypes.Down) {  	Match (input' TokenTypes.Down' null);  	DebugLocation (23' 22);  	// ./src/Parser/Grammar/JFLWalker.g:23:22: (not= '!' )?  	int alt2 = 2;  	try {  		DebugEnterSubRule (2);  		try {  			DebugEnterDecision (2' false);  			int LA2_1 = input.LA (1);  			if ((LA2_1 == 24)) {  				alt2 = 1;  			}  		}  		finally {  			DebugExitDecision (2);  		}  		switch (alt2) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:23:22: not= '!'  			{  				DebugLocation (23' 22);  				not = (CommonTree)Match (input' 24' Follow._24_in_property84);  			}  			break;  		}  	}  	finally {  		DebugExitSubRule (2);  	}  	DebugLocation (23' 28);  	// ./src/Parser/Grammar/JFLWalker.g:23:28: ( filter[newProperty] )?  	int alt3 = 2;  	try {  		DebugEnterSubRule (3);  		try {  			DebugEnterDecision (3' false);  			int LA3_1 = input.LA (1);  			if ((LA3_1 == FILTER)) {  				alt3 = 1;  			}  		}  		finally {  			DebugExitDecision (3);  		}  		switch (alt3) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:23:28: filter[newProperty]  			{  				DebugLocation (23' 28);  				PushFollow (Follow._filter_in_property87);  				filter (newProperty);  				PopFollow ();  			}  			break;  		}  	}  	finally {  		DebugExitSubRule (3);  	}  	DebugLocation (23' 49);  	// ./src/Parser/Grammar/JFLWalker.g:23:49: ( block[newProperty] )?  	int alt4 = 2;  	try {  		DebugEnterSubRule (4);  		try {  			DebugEnterDecision (4' false);  			int LA4_1 = input.LA (1);  			if ((LA4_1 == BLOCK)) {  				alt4 = 1;  			}  		}  		finally {  			DebugExitDecision (4);  		}  		switch (alt4) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:23:49: block[newProperty]  			{  				DebugLocation (23' 49);  				PushFollow (Follow._block_in_property91);  				block (newProperty);  				PopFollow ();  			}  			break;  		}  	}  	finally {  		DebugExitSubRule (4);  	}  	Match (input' TokenTypes.Up' null);  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,property,The following statement contains a magic number: if (input.LA (1) == TokenTypes.Down) {  	Match (input' TokenTypes.Down' null);  	DebugLocation (23' 22);  	// ./src/Parser/Grammar/JFLWalker.g:23:22: (not= '!' )?  	int alt2 = 2;  	try {  		DebugEnterSubRule (2);  		try {  			DebugEnterDecision (2' false);  			int LA2_1 = input.LA (1);  			if ((LA2_1 == 24)) {  				alt2 = 1;  			}  		}  		finally {  			DebugExitDecision (2);  		}  		switch (alt2) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:23:22: not= '!'  			{  				DebugLocation (23' 22);  				not = (CommonTree)Match (input' 24' Follow._24_in_property84);  			}  			break;  		}  	}  	finally {  		DebugExitSubRule (2);  	}  	DebugLocation (23' 28);  	// ./src/Parser/Grammar/JFLWalker.g:23:28: ( filter[newProperty] )?  	int alt3 = 2;  	try {  		DebugEnterSubRule (3);  		try {  			DebugEnterDecision (3' false);  			int LA3_1 = input.LA (1);  			if ((LA3_1 == FILTER)) {  				alt3 = 1;  			}  		}  		finally {  			DebugExitDecision (3);  		}  		switch (alt3) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:23:28: filter[newProperty]  			{  				DebugLocation (23' 28);  				PushFollow (Follow._filter_in_property87);  				filter (newProperty);  				PopFollow ();  			}  			break;  		}  	}  	finally {  		DebugExitSubRule (3);  	}  	DebugLocation (23' 49);  	// ./src/Parser/Grammar/JFLWalker.g:23:49: ( block[newProperty] )?  	int alt4 = 2;  	try {  		DebugEnterSubRule (4);  		try {  			DebugEnterDecision (4' false);  			int LA4_1 = input.LA (1);  			if ((LA4_1 == BLOCK)) {  				alt4 = 1;  			}  		}  		finally {  			DebugExitDecision (4);  		}  		switch (alt4) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:23:49: block[newProperty]  			{  				DebugLocation (23' 49);  				PushFollow (Follow._block_in_property91);  				block (newProperty);  				PopFollow ();  			}  			break;  		}  	}  	finally {  		DebugExitSubRule (4);  	}  	Match (input' TokenTypes.Up' null);  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,property,The following statement contains a magic number: if (input.LA (1) == TokenTypes.Down) {  	Match (input' TokenTypes.Down' null);  	DebugLocation (23' 22);  	// ./src/Parser/Grammar/JFLWalker.g:23:22: (not= '!' )?  	int alt2 = 2;  	try {  		DebugEnterSubRule (2);  		try {  			DebugEnterDecision (2' false);  			int LA2_1 = input.LA (1);  			if ((LA2_1 == 24)) {  				alt2 = 1;  			}  		}  		finally {  			DebugExitDecision (2);  		}  		switch (alt2) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:23:22: not= '!'  			{  				DebugLocation (23' 22);  				not = (CommonTree)Match (input' 24' Follow._24_in_property84);  			}  			break;  		}  	}  	finally {  		DebugExitSubRule (2);  	}  	DebugLocation (23' 28);  	// ./src/Parser/Grammar/JFLWalker.g:23:28: ( filter[newProperty] )?  	int alt3 = 2;  	try {  		DebugEnterSubRule (3);  		try {  			DebugEnterDecision (3' false);  			int LA3_1 = input.LA (1);  			if ((LA3_1 == FILTER)) {  				alt3 = 1;  			}  		}  		finally {  			DebugExitDecision (3);  		}  		switch (alt3) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:23:28: filter[newProperty]  			{  				DebugLocation (23' 28);  				PushFollow (Follow._filter_in_property87);  				filter (newProperty);  				PopFollow ();  			}  			break;  		}  	}  	finally {  		DebugExitSubRule (3);  	}  	DebugLocation (23' 49);  	// ./src/Parser/Grammar/JFLWalker.g:23:49: ( block[newProperty] )?  	int alt4 = 2;  	try {  		DebugEnterSubRule (4);  		try {  			DebugEnterDecision (4' false);  			int LA4_1 = input.LA (1);  			if ((LA4_1 == BLOCK)) {  				alt4 = 1;  			}  		}  		finally {  			DebugExitDecision (4);  		}  		switch (alt4) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:23:49: block[newProperty]  			{  				DebugLocation (23' 49);  				PushFollow (Follow._block_in_property91);  				block (newProperty);  				PopFollow ();  			}  			break;  		}  	}  	finally {  		DebugExitSubRule (4);  	}  	Match (input' TokenTypes.Up' null);  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,property,The following statement contains a magic number: if (input.LA (1) == TokenTypes.Down) {  	Match (input' TokenTypes.Down' null);  	DebugLocation (23' 22);  	// ./src/Parser/Grammar/JFLWalker.g:23:22: (not= '!' )?  	int alt2 = 2;  	try {  		DebugEnterSubRule (2);  		try {  			DebugEnterDecision (2' false);  			int LA2_1 = input.LA (1);  			if ((LA2_1 == 24)) {  				alt2 = 1;  			}  		}  		finally {  			DebugExitDecision (2);  		}  		switch (alt2) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:23:22: not= '!'  			{  				DebugLocation (23' 22);  				not = (CommonTree)Match (input' 24' Follow._24_in_property84);  			}  			break;  		}  	}  	finally {  		DebugExitSubRule (2);  	}  	DebugLocation (23' 28);  	// ./src/Parser/Grammar/JFLWalker.g:23:28: ( filter[newProperty] )?  	int alt3 = 2;  	try {  		DebugEnterSubRule (3);  		try {  			DebugEnterDecision (3' false);  			int LA3_1 = input.LA (1);  			if ((LA3_1 == FILTER)) {  				alt3 = 1;  			}  		}  		finally {  			DebugExitDecision (3);  		}  		switch (alt3) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:23:28: filter[newProperty]  			{  				DebugLocation (23' 28);  				PushFollow (Follow._filter_in_property87);  				filter (newProperty);  				PopFollow ();  			}  			break;  		}  	}  	finally {  		DebugExitSubRule (3);  	}  	DebugLocation (23' 49);  	// ./src/Parser/Grammar/JFLWalker.g:23:49: ( block[newProperty] )?  	int alt4 = 2;  	try {  		DebugEnterSubRule (4);  		try {  			DebugEnterDecision (4' false);  			int LA4_1 = input.LA (1);  			if ((LA4_1 == BLOCK)) {  				alt4 = 1;  			}  		}  		finally {  			DebugExitDecision (4);  		}  		switch (alt4) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:23:49: block[newProperty]  			{  				DebugLocation (23' 49);  				PushFollow (Follow._block_in_property91);  				block (newProperty);  				PopFollow ();  			}  			break;  		}  	}  	finally {  		DebugExitSubRule (4);  	}  	Match (input' TokenTypes.Up' null);  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,property,The following statement contains a magic number: if (input.LA (1) == TokenTypes.Down) {  	Match (input' TokenTypes.Down' null);  	DebugLocation (23' 22);  	// ./src/Parser/Grammar/JFLWalker.g:23:22: (not= '!' )?  	int alt2 = 2;  	try {  		DebugEnterSubRule (2);  		try {  			DebugEnterDecision (2' false);  			int LA2_1 = input.LA (1);  			if ((LA2_1 == 24)) {  				alt2 = 1;  			}  		}  		finally {  			DebugExitDecision (2);  		}  		switch (alt2) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:23:22: not= '!'  			{  				DebugLocation (23' 22);  				not = (CommonTree)Match (input' 24' Follow._24_in_property84);  			}  			break;  		}  	}  	finally {  		DebugExitSubRule (2);  	}  	DebugLocation (23' 28);  	// ./src/Parser/Grammar/JFLWalker.g:23:28: ( filter[newProperty] )?  	int alt3 = 2;  	try {  		DebugEnterSubRule (3);  		try {  			DebugEnterDecision (3' false);  			int LA3_1 = input.LA (1);  			if ((LA3_1 == FILTER)) {  				alt3 = 1;  			}  		}  		finally {  			DebugExitDecision (3);  		}  		switch (alt3) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:23:28: filter[newProperty]  			{  				DebugLocation (23' 28);  				PushFollow (Follow._filter_in_property87);  				filter (newProperty);  				PopFollow ();  			}  			break;  		}  	}  	finally {  		DebugExitSubRule (3);  	}  	DebugLocation (23' 49);  	// ./src/Parser/Grammar/JFLWalker.g:23:49: ( block[newProperty] )?  	int alt4 = 2;  	try {  		DebugEnterSubRule (4);  		try {  			DebugEnterDecision (4' false);  			int LA4_1 = input.LA (1);  			if ((LA4_1 == BLOCK)) {  				alt4 = 1;  			}  		}  		finally {  			DebugExitDecision (4);  		}  		switch (alt4) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:23:49: block[newProperty]  			{  				DebugLocation (23' 49);  				PushFollow (Follow._block_in_property91);  				block (newProperty);  				PopFollow ();  			}  			break;  		}  	}  	finally {  		DebugExitSubRule (4);  	}  	Match (input' TokenTypes.Up' null);  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,property,The following statement contains a magic number: if (input.LA (1) == TokenTypes.Down) {  	Match (input' TokenTypes.Down' null);  	DebugLocation (23' 22);  	// ./src/Parser/Grammar/JFLWalker.g:23:22: (not= '!' )?  	int alt2 = 2;  	try {  		DebugEnterSubRule (2);  		try {  			DebugEnterDecision (2' false);  			int LA2_1 = input.LA (1);  			if ((LA2_1 == 24)) {  				alt2 = 1;  			}  		}  		finally {  			DebugExitDecision (2);  		}  		switch (alt2) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:23:22: not= '!'  			{  				DebugLocation (23' 22);  				not = (CommonTree)Match (input' 24' Follow._24_in_property84);  			}  			break;  		}  	}  	finally {  		DebugExitSubRule (2);  	}  	DebugLocation (23' 28);  	// ./src/Parser/Grammar/JFLWalker.g:23:28: ( filter[newProperty] )?  	int alt3 = 2;  	try {  		DebugEnterSubRule (3);  		try {  			DebugEnterDecision (3' false);  			int LA3_1 = input.LA (1);  			if ((LA3_1 == FILTER)) {  				alt3 = 1;  			}  		}  		finally {  			DebugExitDecision (3);  		}  		switch (alt3) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:23:28: filter[newProperty]  			{  				DebugLocation (23' 28);  				PushFollow (Follow._filter_in_property87);  				filter (newProperty);  				PopFollow ();  			}  			break;  		}  	}  	finally {  		DebugExitSubRule (3);  	}  	DebugLocation (23' 49);  	// ./src/Parser/Grammar/JFLWalker.g:23:49: ( block[newProperty] )?  	int alt4 = 2;  	try {  		DebugEnterSubRule (4);  		try {  			DebugEnterDecision (4' false);  			int LA4_1 = input.LA (1);  			if ((LA4_1 == BLOCK)) {  				alt4 = 1;  			}  		}  		finally {  			DebugExitDecision (4);  		}  		switch (alt4) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:23:49: block[newProperty]  			{  				DebugLocation (23' 49);  				PushFollow (Follow._block_in_property91);  				block (newProperty);  				PopFollow ();  			}  			break;  		}  	}  	finally {  		DebugExitSubRule (4);  	}  	Match (input' TokenTypes.Up' null);  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,property,The following statement contains a magic number: if (input.LA (1) == TokenTypes.Down) {  	Match (input' TokenTypes.Down' null);  	DebugLocation (23' 22);  	// ./src/Parser/Grammar/JFLWalker.g:23:22: (not= '!' )?  	int alt2 = 2;  	try {  		DebugEnterSubRule (2);  		try {  			DebugEnterDecision (2' false);  			int LA2_1 = input.LA (1);  			if ((LA2_1 == 24)) {  				alt2 = 1;  			}  		}  		finally {  			DebugExitDecision (2);  		}  		switch (alt2) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:23:22: not= '!'  			{  				DebugLocation (23' 22);  				not = (CommonTree)Match (input' 24' Follow._24_in_property84);  			}  			break;  		}  	}  	finally {  		DebugExitSubRule (2);  	}  	DebugLocation (23' 28);  	// ./src/Parser/Grammar/JFLWalker.g:23:28: ( filter[newProperty] )?  	int alt3 = 2;  	try {  		DebugEnterSubRule (3);  		try {  			DebugEnterDecision (3' false);  			int LA3_1 = input.LA (1);  			if ((LA3_1 == FILTER)) {  				alt3 = 1;  			}  		}  		finally {  			DebugExitDecision (3);  		}  		switch (alt3) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:23:28: filter[newProperty]  			{  				DebugLocation (23' 28);  				PushFollow (Follow._filter_in_property87);  				filter (newProperty);  				PopFollow ();  			}  			break;  		}  	}  	finally {  		DebugExitSubRule (3);  	}  	DebugLocation (23' 49);  	// ./src/Parser/Grammar/JFLWalker.g:23:49: ( block[newProperty] )?  	int alt4 = 2;  	try {  		DebugEnterSubRule (4);  		try {  			DebugEnterDecision (4' false);  			int LA4_1 = input.LA (1);  			if ((LA4_1 == BLOCK)) {  				alt4 = 1;  			}  		}  		finally {  			DebugExitDecision (4);  		}  		switch (alt4) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:23:49: block[newProperty]  			{  				DebugLocation (23' 49);  				PushFollow (Follow._block_in_property91);  				block (newProperty);  				PopFollow ();  			}  			break;  		}  	}  	finally {  		DebugExitSubRule (4);  	}  	Match (input' TokenTypes.Up' null);  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,property,The following statement contains a magic number: if (input.LA (1) == TokenTypes.Down) {  	Match (input' TokenTypes.Down' null);  	DebugLocation (23' 22);  	// ./src/Parser/Grammar/JFLWalker.g:23:22: (not= '!' )?  	int alt2 = 2;  	try {  		DebugEnterSubRule (2);  		try {  			DebugEnterDecision (2' false);  			int LA2_1 = input.LA (1);  			if ((LA2_1 == 24)) {  				alt2 = 1;  			}  		}  		finally {  			DebugExitDecision (2);  		}  		switch (alt2) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:23:22: not= '!'  			{  				DebugLocation (23' 22);  				not = (CommonTree)Match (input' 24' Follow._24_in_property84);  			}  			break;  		}  	}  	finally {  		DebugExitSubRule (2);  	}  	DebugLocation (23' 28);  	// ./src/Parser/Grammar/JFLWalker.g:23:28: ( filter[newProperty] )?  	int alt3 = 2;  	try {  		DebugEnterSubRule (3);  		try {  			DebugEnterDecision (3' false);  			int LA3_1 = input.LA (1);  			if ((LA3_1 == FILTER)) {  				alt3 = 1;  			}  		}  		finally {  			DebugExitDecision (3);  		}  		switch (alt3) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:23:28: filter[newProperty]  			{  				DebugLocation (23' 28);  				PushFollow (Follow._filter_in_property87);  				filter (newProperty);  				PopFollow ();  			}  			break;  		}  	}  	finally {  		DebugExitSubRule (3);  	}  	DebugLocation (23' 49);  	// ./src/Parser/Grammar/JFLWalker.g:23:49: ( block[newProperty] )?  	int alt4 = 2;  	try {  		DebugEnterSubRule (4);  		try {  			DebugEnterDecision (4' false);  			int LA4_1 = input.LA (1);  			if ((LA4_1 == BLOCK)) {  				alt4 = 1;  			}  		}  		finally {  			DebugExitDecision (4);  		}  		switch (alt4) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:23:49: block[newProperty]  			{  				DebugLocation (23' 49);  				PushFollow (Follow._block_in_property91);  				block (newProperty);  				PopFollow ();  			}  			break;  		}  	}  	finally {  		DebugExitSubRule (4);  	}  	Match (input' TokenTypes.Up' null);  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,property,The following statement contains a magic number: DebugLocation (23' 22);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,property,The following statement contains a magic number: DebugLocation (23' 22);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,property,The following statement contains a magic number: try {  	DebugEnterSubRule (2);  	try {  		DebugEnterDecision (2' false);  		int LA2_1 = input.LA (1);  		if ((LA2_1 == 24)) {  			alt2 = 1;  		}  	}  	finally {  		DebugExitDecision (2);  	}  	switch (alt2) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:23:22: not= '!'  		{  			DebugLocation (23' 22);  			not = (CommonTree)Match (input' 24' Follow._24_in_property84);  		}  		break;  	}  }  finally {  	DebugExitSubRule (2);  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,property,The following statement contains a magic number: try {  	DebugEnterSubRule (2);  	try {  		DebugEnterDecision (2' false);  		int LA2_1 = input.LA (1);  		if ((LA2_1 == 24)) {  			alt2 = 1;  		}  	}  	finally {  		DebugExitDecision (2);  	}  	switch (alt2) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:23:22: not= '!'  		{  			DebugLocation (23' 22);  			not = (CommonTree)Match (input' 24' Follow._24_in_property84);  		}  		break;  	}  }  finally {  	DebugExitSubRule (2);  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,property,The following statement contains a magic number: try {  	DebugEnterSubRule (2);  	try {  		DebugEnterDecision (2' false);  		int LA2_1 = input.LA (1);  		if ((LA2_1 == 24)) {  			alt2 = 1;  		}  	}  	finally {  		DebugExitDecision (2);  	}  	switch (alt2) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:23:22: not= '!'  		{  			DebugLocation (23' 22);  			not = (CommonTree)Match (input' 24' Follow._24_in_property84);  		}  		break;  	}  }  finally {  	DebugExitSubRule (2);  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,property,The following statement contains a magic number: try {  	DebugEnterSubRule (2);  	try {  		DebugEnterDecision (2' false);  		int LA2_1 = input.LA (1);  		if ((LA2_1 == 24)) {  			alt2 = 1;  		}  	}  	finally {  		DebugExitDecision (2);  	}  	switch (alt2) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:23:22: not= '!'  		{  			DebugLocation (23' 22);  			not = (CommonTree)Match (input' 24' Follow._24_in_property84);  		}  		break;  	}  }  finally {  	DebugExitSubRule (2);  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,property,The following statement contains a magic number: try {  	DebugEnterSubRule (2);  	try {  		DebugEnterDecision (2' false);  		int LA2_1 = input.LA (1);  		if ((LA2_1 == 24)) {  			alt2 = 1;  		}  	}  	finally {  		DebugExitDecision (2);  	}  	switch (alt2) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:23:22: not= '!'  		{  			DebugLocation (23' 22);  			not = (CommonTree)Match (input' 24' Follow._24_in_property84);  		}  		break;  	}  }  finally {  	DebugExitSubRule (2);  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,property,The following statement contains a magic number: try {  	DebugEnterSubRule (2);  	try {  		DebugEnterDecision (2' false);  		int LA2_1 = input.LA (1);  		if ((LA2_1 == 24)) {  			alt2 = 1;  		}  	}  	finally {  		DebugExitDecision (2);  	}  	switch (alt2) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:23:22: not= '!'  		{  			DebugLocation (23' 22);  			not = (CommonTree)Match (input' 24' Follow._24_in_property84);  		}  		break;  	}  }  finally {  	DebugExitSubRule (2);  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,property,The following statement contains a magic number: try {  	DebugEnterSubRule (2);  	try {  		DebugEnterDecision (2' false);  		int LA2_1 = input.LA (1);  		if ((LA2_1 == 24)) {  			alt2 = 1;  		}  	}  	finally {  		DebugExitDecision (2);  	}  	switch (alt2) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:23:22: not= '!'  		{  			DebugLocation (23' 22);  			not = (CommonTree)Match (input' 24' Follow._24_in_property84);  		}  		break;  	}  }  finally {  	DebugExitSubRule (2);  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,property,The following statement contains a magic number: try {  	DebugEnterSubRule (2);  	try {  		DebugEnterDecision (2' false);  		int LA2_1 = input.LA (1);  		if ((LA2_1 == 24)) {  			alt2 = 1;  		}  	}  	finally {  		DebugExitDecision (2);  	}  	switch (alt2) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:23:22: not= '!'  		{  			DebugLocation (23' 22);  			not = (CommonTree)Match (input' 24' Follow._24_in_property84);  		}  		break;  	}  }  finally {  	DebugExitSubRule (2);  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,property,The following statement contains a magic number: DebugEnterSubRule (2);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,property,The following statement contains a magic number: try {  	DebugEnterDecision (2' false);  	int LA2_1 = input.LA (1);  	if ((LA2_1 == 24)) {  		alt2 = 1;  	}  }  finally {  	DebugExitDecision (2);  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,property,The following statement contains a magic number: try {  	DebugEnterDecision (2' false);  	int LA2_1 = input.LA (1);  	if ((LA2_1 == 24)) {  		alt2 = 1;  	}  }  finally {  	DebugExitDecision (2);  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,property,The following statement contains a magic number: try {  	DebugEnterDecision (2' false);  	int LA2_1 = input.LA (1);  	if ((LA2_1 == 24)) {  		alt2 = 1;  	}  }  finally {  	DebugExitDecision (2);  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,property,The following statement contains a magic number: DebugEnterDecision (2' false);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,property,The following statement contains a magic number: if ((LA2_1 == 24)) {  	alt2 = 1;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,property,The following statement contains a magic number: DebugExitDecision (2);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,property,The following statement contains a magic number: switch (alt2) {  case 1:  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:23:22: not= '!'  	{  		DebugLocation (23' 22);  		not = (CommonTree)Match (input' 24' Follow._24_in_property84);  	}  	break;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,property,The following statement contains a magic number: switch (alt2) {  case 1:  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:23:22: not= '!'  	{  		DebugLocation (23' 22);  		not = (CommonTree)Match (input' 24' Follow._24_in_property84);  	}  	break;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,property,The following statement contains a magic number: switch (alt2) {  case 1:  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:23:22: not= '!'  	{  		DebugLocation (23' 22);  		not = (CommonTree)Match (input' 24' Follow._24_in_property84);  	}  	break;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,property,The following statement contains a magic number: DebugLocation (23' 22);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,property,The following statement contains a magic number: DebugLocation (23' 22);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,property,The following statement contains a magic number: not = (CommonTree)Match (input' 24' Follow._24_in_property84);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,property,The following statement contains a magic number: DebugExitSubRule (2);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,property,The following statement contains a magic number: DebugLocation (23' 28);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,property,The following statement contains a magic number: DebugLocation (23' 28);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,property,The following statement contains a magic number: try {  	DebugEnterSubRule (3);  	try {  		DebugEnterDecision (3' false);  		int LA3_1 = input.LA (1);  		if ((LA3_1 == FILTER)) {  			alt3 = 1;  		}  	}  	finally {  		DebugExitDecision (3);  	}  	switch (alt3) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:23:28: filter[newProperty]  		{  			DebugLocation (23' 28);  			PushFollow (Follow._filter_in_property87);  			filter (newProperty);  			PopFollow ();  		}  		break;  	}  }  finally {  	DebugExitSubRule (3);  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,property,The following statement contains a magic number: try {  	DebugEnterSubRule (3);  	try {  		DebugEnterDecision (3' false);  		int LA3_1 = input.LA (1);  		if ((LA3_1 == FILTER)) {  			alt3 = 1;  		}  	}  	finally {  		DebugExitDecision (3);  	}  	switch (alt3) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:23:28: filter[newProperty]  		{  			DebugLocation (23' 28);  			PushFollow (Follow._filter_in_property87);  			filter (newProperty);  			PopFollow ();  		}  		break;  	}  }  finally {  	DebugExitSubRule (3);  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,property,The following statement contains a magic number: try {  	DebugEnterSubRule (3);  	try {  		DebugEnterDecision (3' false);  		int LA3_1 = input.LA (1);  		if ((LA3_1 == FILTER)) {  			alt3 = 1;  		}  	}  	finally {  		DebugExitDecision (3);  	}  	switch (alt3) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:23:28: filter[newProperty]  		{  			DebugLocation (23' 28);  			PushFollow (Follow._filter_in_property87);  			filter (newProperty);  			PopFollow ();  		}  		break;  	}  }  finally {  	DebugExitSubRule (3);  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,property,The following statement contains a magic number: try {  	DebugEnterSubRule (3);  	try {  		DebugEnterDecision (3' false);  		int LA3_1 = input.LA (1);  		if ((LA3_1 == FILTER)) {  			alt3 = 1;  		}  	}  	finally {  		DebugExitDecision (3);  	}  	switch (alt3) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:23:28: filter[newProperty]  		{  			DebugLocation (23' 28);  			PushFollow (Follow._filter_in_property87);  			filter (newProperty);  			PopFollow ();  		}  		break;  	}  }  finally {  	DebugExitSubRule (3);  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,property,The following statement contains a magic number: try {  	DebugEnterSubRule (3);  	try {  		DebugEnterDecision (3' false);  		int LA3_1 = input.LA (1);  		if ((LA3_1 == FILTER)) {  			alt3 = 1;  		}  	}  	finally {  		DebugExitDecision (3);  	}  	switch (alt3) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:23:28: filter[newProperty]  		{  			DebugLocation (23' 28);  			PushFollow (Follow._filter_in_property87);  			filter (newProperty);  			PopFollow ();  		}  		break;  	}  }  finally {  	DebugExitSubRule (3);  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,property,The following statement contains a magic number: try {  	DebugEnterSubRule (3);  	try {  		DebugEnterDecision (3' false);  		int LA3_1 = input.LA (1);  		if ((LA3_1 == FILTER)) {  			alt3 = 1;  		}  	}  	finally {  		DebugExitDecision (3);  	}  	switch (alt3) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:23:28: filter[newProperty]  		{  			DebugLocation (23' 28);  			PushFollow (Follow._filter_in_property87);  			filter (newProperty);  			PopFollow ();  		}  		break;  	}  }  finally {  	DebugExitSubRule (3);  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,property,The following statement contains a magic number: DebugEnterSubRule (3);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,property,The following statement contains a magic number: try {  	DebugEnterDecision (3' false);  	int LA3_1 = input.LA (1);  	if ((LA3_1 == FILTER)) {  		alt3 = 1;  	}  }  finally {  	DebugExitDecision (3);  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,property,The following statement contains a magic number: try {  	DebugEnterDecision (3' false);  	int LA3_1 = input.LA (1);  	if ((LA3_1 == FILTER)) {  		alt3 = 1;  	}  }  finally {  	DebugExitDecision (3);  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,property,The following statement contains a magic number: DebugEnterDecision (3' false);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,property,The following statement contains a magic number: DebugExitDecision (3);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,property,The following statement contains a magic number: switch (alt3) {  case 1:  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:23:28: filter[newProperty]  	{  		DebugLocation (23' 28);  		PushFollow (Follow._filter_in_property87);  		filter (newProperty);  		PopFollow ();  	}  	break;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,property,The following statement contains a magic number: switch (alt3) {  case 1:  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:23:28: filter[newProperty]  	{  		DebugLocation (23' 28);  		PushFollow (Follow._filter_in_property87);  		filter (newProperty);  		PopFollow ();  	}  	break;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,property,The following statement contains a magic number: DebugLocation (23' 28);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,property,The following statement contains a magic number: DebugLocation (23' 28);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,property,The following statement contains a magic number: DebugExitSubRule (3);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,property,The following statement contains a magic number: DebugLocation (23' 49);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,property,The following statement contains a magic number: DebugLocation (23' 49);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,property,The following statement contains a magic number: try {  	DebugEnterSubRule (4);  	try {  		DebugEnterDecision (4' false);  		int LA4_1 = input.LA (1);  		if ((LA4_1 == BLOCK)) {  			alt4 = 1;  		}  	}  	finally {  		DebugExitDecision (4);  	}  	switch (alt4) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:23:49: block[newProperty]  		{  			DebugLocation (23' 49);  			PushFollow (Follow._block_in_property91);  			block (newProperty);  			PopFollow ();  		}  		break;  	}  }  finally {  	DebugExitSubRule (4);  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,property,The following statement contains a magic number: try {  	DebugEnterSubRule (4);  	try {  		DebugEnterDecision (4' false);  		int LA4_1 = input.LA (1);  		if ((LA4_1 == BLOCK)) {  			alt4 = 1;  		}  	}  	finally {  		DebugExitDecision (4);  	}  	switch (alt4) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:23:49: block[newProperty]  		{  			DebugLocation (23' 49);  			PushFollow (Follow._block_in_property91);  			block (newProperty);  			PopFollow ();  		}  		break;  	}  }  finally {  	DebugExitSubRule (4);  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,property,The following statement contains a magic number: try {  	DebugEnterSubRule (4);  	try {  		DebugEnterDecision (4' false);  		int LA4_1 = input.LA (1);  		if ((LA4_1 == BLOCK)) {  			alt4 = 1;  		}  	}  	finally {  		DebugExitDecision (4);  	}  	switch (alt4) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:23:49: block[newProperty]  		{  			DebugLocation (23' 49);  			PushFollow (Follow._block_in_property91);  			block (newProperty);  			PopFollow ();  		}  		break;  	}  }  finally {  	DebugExitSubRule (4);  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,property,The following statement contains a magic number: try {  	DebugEnterSubRule (4);  	try {  		DebugEnterDecision (4' false);  		int LA4_1 = input.LA (1);  		if ((LA4_1 == BLOCK)) {  			alt4 = 1;  		}  	}  	finally {  		DebugExitDecision (4);  	}  	switch (alt4) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:23:49: block[newProperty]  		{  			DebugLocation (23' 49);  			PushFollow (Follow._block_in_property91);  			block (newProperty);  			PopFollow ();  		}  		break;  	}  }  finally {  	DebugExitSubRule (4);  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,property,The following statement contains a magic number: try {  	DebugEnterSubRule (4);  	try {  		DebugEnterDecision (4' false);  		int LA4_1 = input.LA (1);  		if ((LA4_1 == BLOCK)) {  			alt4 = 1;  		}  	}  	finally {  		DebugExitDecision (4);  	}  	switch (alt4) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:23:49: block[newProperty]  		{  			DebugLocation (23' 49);  			PushFollow (Follow._block_in_property91);  			block (newProperty);  			PopFollow ();  		}  		break;  	}  }  finally {  	DebugExitSubRule (4);  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,property,The following statement contains a magic number: try {  	DebugEnterSubRule (4);  	try {  		DebugEnterDecision (4' false);  		int LA4_1 = input.LA (1);  		if ((LA4_1 == BLOCK)) {  			alt4 = 1;  		}  	}  	finally {  		DebugExitDecision (4);  	}  	switch (alt4) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:23:49: block[newProperty]  		{  			DebugLocation (23' 49);  			PushFollow (Follow._block_in_property91);  			block (newProperty);  			PopFollow ();  		}  		break;  	}  }  finally {  	DebugExitSubRule (4);  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,property,The following statement contains a magic number: DebugEnterSubRule (4);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,property,The following statement contains a magic number: try {  	DebugEnterDecision (4' false);  	int LA4_1 = input.LA (1);  	if ((LA4_1 == BLOCK)) {  		alt4 = 1;  	}  }  finally {  	DebugExitDecision (4);  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,property,The following statement contains a magic number: try {  	DebugEnterDecision (4' false);  	int LA4_1 = input.LA (1);  	if ((LA4_1 == BLOCK)) {  		alt4 = 1;  	}  }  finally {  	DebugExitDecision (4);  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,property,The following statement contains a magic number: DebugEnterDecision (4' false);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,property,The following statement contains a magic number: DebugExitDecision (4);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,property,The following statement contains a magic number: switch (alt4) {  case 1:  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:23:49: block[newProperty]  	{  		DebugLocation (23' 49);  		PushFollow (Follow._block_in_property91);  		block (newProperty);  		PopFollow ();  	}  	break;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,property,The following statement contains a magic number: switch (alt4) {  case 1:  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:23:49: block[newProperty]  	{  		DebugLocation (23' 49);  		PushFollow (Follow._block_in_property91);  		block (newProperty);  		PopFollow ();  	}  	break;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,property,The following statement contains a magic number: DebugLocation (23' 49);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,property,The following statement contains a magic number: DebugLocation (23' 49);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,property,The following statement contains a magic number: DebugExitSubRule (4);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,property,The following statement contains a magic number: DebugLocation (23' 70);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,property,The following statement contains a magic number: DebugLocation (23' 70);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,property,The following statement contains a magic number: TraceOut ("property"' 3);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,property,The following statement contains a magic number: LeaveRule ("property"' 3);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,property,The following statement contains a magic number: DebugLocation (31' 1);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyName,The following statement contains a magic number: EnterRule ("propertyName"' 4);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyName,The following statement contains a magic number: TraceIn ("propertyName"' 4);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyName,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "propertyName");  	DebugLocation (33' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:34:2: ( ID | ESC_ID | REGEX | '*' )  		int alt5 = 4;  		try {  			DebugEnterDecision (5' false);  			switch (input.LA (1)) {  			case ID:  				{  					alt5 = 1;  				}  				break;  			case ESC_ID:  				{  					alt5 = 2;  				}  				break;  			case REGEX:  				{  					alt5 = 3;  				}  				break;  			case 27:  				{  					alt5 = 4;  				}  				break;  			default: {  				NoViableAltException nvae = new NoViableAltException (""' 5' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  			}  		}  		finally {  			DebugExitDecision (5);  		}  		switch (alt5) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:34:4: ID  			{  				DebugLocation (34' 4);  				ID2 = (CommonTree)Match (input' ID' Follow._ID_in_propertyName112);  				DebugLocation (34' 7);  				retval.isRegex = false;  				retval.name = (ID2 != null ? ID2.Text : default(string));  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:38:4: ESC_ID  			{  				DebugLocation (38' 4);  				ESC_ID3 = (CommonTree)Match (input' ESC_ID' Follow._ESC_ID_in_propertyName119);  				DebugLocation (38' 11);  				retval.isRegex = false;  				string stringText = (ESC_ID3 != null ? ESC_ID3.Text : default(string));  				retval.name = stringText.Substring (1' stringText.Length - 2);  			}  			break;  		case 3:  			DebugEnterAlt (3);  			// ./src/Parser/Grammar/JFLWalker.g:43:4: REGEX  			{  				DebugLocation (43' 4);  				REGEX4 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_propertyName126);  				DebugLocation (43' 10);  				retval.isRegex = true;  				string regexText = (REGEX4 != null ? REGEX4.Text : default(string));  				retval.name = regexText.Substring (1' regexText.Length - 2);  			}  			break;  		case 4:  			DebugEnterAlt (4);  			// ./src/Parser/Grammar/JFLWalker.g:48:4: '*'  			{  				DebugLocation (48' 4);  				Match (input' 27' Follow._27_in_propertyName133);  				DebugLocation (48' 8);  				retval.isRegex = false;  				retval.name = "*";  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("propertyName"' 4);  		LeaveRule ("propertyName"' 4);  		LeaveRule_propertyName ();  	}  	DebugLocation (52' 1);  }  finally {  	DebugExitRule (GrammarFileName' "propertyName");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyName,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "propertyName");  	DebugLocation (33' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:34:2: ( ID | ESC_ID | REGEX | '*' )  		int alt5 = 4;  		try {  			DebugEnterDecision (5' false);  			switch (input.LA (1)) {  			case ID:  				{  					alt5 = 1;  				}  				break;  			case ESC_ID:  				{  					alt5 = 2;  				}  				break;  			case REGEX:  				{  					alt5 = 3;  				}  				break;  			case 27:  				{  					alt5 = 4;  				}  				break;  			default: {  				NoViableAltException nvae = new NoViableAltException (""' 5' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  			}  		}  		finally {  			DebugExitDecision (5);  		}  		switch (alt5) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:34:4: ID  			{  				DebugLocation (34' 4);  				ID2 = (CommonTree)Match (input' ID' Follow._ID_in_propertyName112);  				DebugLocation (34' 7);  				retval.isRegex = false;  				retval.name = (ID2 != null ? ID2.Text : default(string));  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:38:4: ESC_ID  			{  				DebugLocation (38' 4);  				ESC_ID3 = (CommonTree)Match (input' ESC_ID' Follow._ESC_ID_in_propertyName119);  				DebugLocation (38' 11);  				retval.isRegex = false;  				string stringText = (ESC_ID3 != null ? ESC_ID3.Text : default(string));  				retval.name = stringText.Substring (1' stringText.Length - 2);  			}  			break;  		case 3:  			DebugEnterAlt (3);  			// ./src/Parser/Grammar/JFLWalker.g:43:4: REGEX  			{  				DebugLocation (43' 4);  				REGEX4 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_propertyName126);  				DebugLocation (43' 10);  				retval.isRegex = true;  				string regexText = (REGEX4 != null ? REGEX4.Text : default(string));  				retval.name = regexText.Substring (1' regexText.Length - 2);  			}  			break;  		case 4:  			DebugEnterAlt (4);  			// ./src/Parser/Grammar/JFLWalker.g:48:4: '*'  			{  				DebugLocation (48' 4);  				Match (input' 27' Follow._27_in_propertyName133);  				DebugLocation (48' 8);  				retval.isRegex = false;  				retval.name = "*";  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("propertyName"' 4);  		LeaveRule ("propertyName"' 4);  		LeaveRule_propertyName ();  	}  	DebugLocation (52' 1);  }  finally {  	DebugExitRule (GrammarFileName' "propertyName");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyName,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "propertyName");  	DebugLocation (33' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:34:2: ( ID | ESC_ID | REGEX | '*' )  		int alt5 = 4;  		try {  			DebugEnterDecision (5' false);  			switch (input.LA (1)) {  			case ID:  				{  					alt5 = 1;  				}  				break;  			case ESC_ID:  				{  					alt5 = 2;  				}  				break;  			case REGEX:  				{  					alt5 = 3;  				}  				break;  			case 27:  				{  					alt5 = 4;  				}  				break;  			default: {  				NoViableAltException nvae = new NoViableAltException (""' 5' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  			}  		}  		finally {  			DebugExitDecision (5);  		}  		switch (alt5) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:34:4: ID  			{  				DebugLocation (34' 4);  				ID2 = (CommonTree)Match (input' ID' Follow._ID_in_propertyName112);  				DebugLocation (34' 7);  				retval.isRegex = false;  				retval.name = (ID2 != null ? ID2.Text : default(string));  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:38:4: ESC_ID  			{  				DebugLocation (38' 4);  				ESC_ID3 = (CommonTree)Match (input' ESC_ID' Follow._ESC_ID_in_propertyName119);  				DebugLocation (38' 11);  				retval.isRegex = false;  				string stringText = (ESC_ID3 != null ? ESC_ID3.Text : default(string));  				retval.name = stringText.Substring (1' stringText.Length - 2);  			}  			break;  		case 3:  			DebugEnterAlt (3);  			// ./src/Parser/Grammar/JFLWalker.g:43:4: REGEX  			{  				DebugLocation (43' 4);  				REGEX4 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_propertyName126);  				DebugLocation (43' 10);  				retval.isRegex = true;  				string regexText = (REGEX4 != null ? REGEX4.Text : default(string));  				retval.name = regexText.Substring (1' regexText.Length - 2);  			}  			break;  		case 4:  			DebugEnterAlt (4);  			// ./src/Parser/Grammar/JFLWalker.g:48:4: '*'  			{  				DebugLocation (48' 4);  				Match (input' 27' Follow._27_in_propertyName133);  				DebugLocation (48' 8);  				retval.isRegex = false;  				retval.name = "*";  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("propertyName"' 4);  		LeaveRule ("propertyName"' 4);  		LeaveRule_propertyName ();  	}  	DebugLocation (52' 1);  }  finally {  	DebugExitRule (GrammarFileName' "propertyName");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyName,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "propertyName");  	DebugLocation (33' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:34:2: ( ID | ESC_ID | REGEX | '*' )  		int alt5 = 4;  		try {  			DebugEnterDecision (5' false);  			switch (input.LA (1)) {  			case ID:  				{  					alt5 = 1;  				}  				break;  			case ESC_ID:  				{  					alt5 = 2;  				}  				break;  			case REGEX:  				{  					alt5 = 3;  				}  				break;  			case 27:  				{  					alt5 = 4;  				}  				break;  			default: {  				NoViableAltException nvae = new NoViableAltException (""' 5' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  			}  		}  		finally {  			DebugExitDecision (5);  		}  		switch (alt5) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:34:4: ID  			{  				DebugLocation (34' 4);  				ID2 = (CommonTree)Match (input' ID' Follow._ID_in_propertyName112);  				DebugLocation (34' 7);  				retval.isRegex = false;  				retval.name = (ID2 != null ? ID2.Text : default(string));  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:38:4: ESC_ID  			{  				DebugLocation (38' 4);  				ESC_ID3 = (CommonTree)Match (input' ESC_ID' Follow._ESC_ID_in_propertyName119);  				DebugLocation (38' 11);  				retval.isRegex = false;  				string stringText = (ESC_ID3 != null ? ESC_ID3.Text : default(string));  				retval.name = stringText.Substring (1' stringText.Length - 2);  			}  			break;  		case 3:  			DebugEnterAlt (3);  			// ./src/Parser/Grammar/JFLWalker.g:43:4: REGEX  			{  				DebugLocation (43' 4);  				REGEX4 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_propertyName126);  				DebugLocation (43' 10);  				retval.isRegex = true;  				string regexText = (REGEX4 != null ? REGEX4.Text : default(string));  				retval.name = regexText.Substring (1' regexText.Length - 2);  			}  			break;  		case 4:  			DebugEnterAlt (4);  			// ./src/Parser/Grammar/JFLWalker.g:48:4: '*'  			{  				DebugLocation (48' 4);  				Match (input' 27' Follow._27_in_propertyName133);  				DebugLocation (48' 8);  				retval.isRegex = false;  				retval.name = "*";  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("propertyName"' 4);  		LeaveRule ("propertyName"' 4);  		LeaveRule_propertyName ();  	}  	DebugLocation (52' 1);  }  finally {  	DebugExitRule (GrammarFileName' "propertyName");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyName,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "propertyName");  	DebugLocation (33' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:34:2: ( ID | ESC_ID | REGEX | '*' )  		int alt5 = 4;  		try {  			DebugEnterDecision (5' false);  			switch (input.LA (1)) {  			case ID:  				{  					alt5 = 1;  				}  				break;  			case ESC_ID:  				{  					alt5 = 2;  				}  				break;  			case REGEX:  				{  					alt5 = 3;  				}  				break;  			case 27:  				{  					alt5 = 4;  				}  				break;  			default: {  				NoViableAltException nvae = new NoViableAltException (""' 5' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  			}  		}  		finally {  			DebugExitDecision (5);  		}  		switch (alt5) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:34:4: ID  			{  				DebugLocation (34' 4);  				ID2 = (CommonTree)Match (input' ID' Follow._ID_in_propertyName112);  				DebugLocation (34' 7);  				retval.isRegex = false;  				retval.name = (ID2 != null ? ID2.Text : default(string));  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:38:4: ESC_ID  			{  				DebugLocation (38' 4);  				ESC_ID3 = (CommonTree)Match (input' ESC_ID' Follow._ESC_ID_in_propertyName119);  				DebugLocation (38' 11);  				retval.isRegex = false;  				string stringText = (ESC_ID3 != null ? ESC_ID3.Text : default(string));  				retval.name = stringText.Substring (1' stringText.Length - 2);  			}  			break;  		case 3:  			DebugEnterAlt (3);  			// ./src/Parser/Grammar/JFLWalker.g:43:4: REGEX  			{  				DebugLocation (43' 4);  				REGEX4 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_propertyName126);  				DebugLocation (43' 10);  				retval.isRegex = true;  				string regexText = (REGEX4 != null ? REGEX4.Text : default(string));  				retval.name = regexText.Substring (1' regexText.Length - 2);  			}  			break;  		case 4:  			DebugEnterAlt (4);  			// ./src/Parser/Grammar/JFLWalker.g:48:4: '*'  			{  				DebugLocation (48' 4);  				Match (input' 27' Follow._27_in_propertyName133);  				DebugLocation (48' 8);  				retval.isRegex = false;  				retval.name = "*";  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("propertyName"' 4);  		LeaveRule ("propertyName"' 4);  		LeaveRule_propertyName ();  	}  	DebugLocation (52' 1);  }  finally {  	DebugExitRule (GrammarFileName' "propertyName");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyName,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "propertyName");  	DebugLocation (33' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:34:2: ( ID | ESC_ID | REGEX | '*' )  		int alt5 = 4;  		try {  			DebugEnterDecision (5' false);  			switch (input.LA (1)) {  			case ID:  				{  					alt5 = 1;  				}  				break;  			case ESC_ID:  				{  					alt5 = 2;  				}  				break;  			case REGEX:  				{  					alt5 = 3;  				}  				break;  			case 27:  				{  					alt5 = 4;  				}  				break;  			default: {  				NoViableAltException nvae = new NoViableAltException (""' 5' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  			}  		}  		finally {  			DebugExitDecision (5);  		}  		switch (alt5) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:34:4: ID  			{  				DebugLocation (34' 4);  				ID2 = (CommonTree)Match (input' ID' Follow._ID_in_propertyName112);  				DebugLocation (34' 7);  				retval.isRegex = false;  				retval.name = (ID2 != null ? ID2.Text : default(string));  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:38:4: ESC_ID  			{  				DebugLocation (38' 4);  				ESC_ID3 = (CommonTree)Match (input' ESC_ID' Follow._ESC_ID_in_propertyName119);  				DebugLocation (38' 11);  				retval.isRegex = false;  				string stringText = (ESC_ID3 != null ? ESC_ID3.Text : default(string));  				retval.name = stringText.Substring (1' stringText.Length - 2);  			}  			break;  		case 3:  			DebugEnterAlt (3);  			// ./src/Parser/Grammar/JFLWalker.g:43:4: REGEX  			{  				DebugLocation (43' 4);  				REGEX4 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_propertyName126);  				DebugLocation (43' 10);  				retval.isRegex = true;  				string regexText = (REGEX4 != null ? REGEX4.Text : default(string));  				retval.name = regexText.Substring (1' regexText.Length - 2);  			}  			break;  		case 4:  			DebugEnterAlt (4);  			// ./src/Parser/Grammar/JFLWalker.g:48:4: '*'  			{  				DebugLocation (48' 4);  				Match (input' 27' Follow._27_in_propertyName133);  				DebugLocation (48' 8);  				retval.isRegex = false;  				retval.name = "*";  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("propertyName"' 4);  		LeaveRule ("propertyName"' 4);  		LeaveRule_propertyName ();  	}  	DebugLocation (52' 1);  }  finally {  	DebugExitRule (GrammarFileName' "propertyName");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyName,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "propertyName");  	DebugLocation (33' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:34:2: ( ID | ESC_ID | REGEX | '*' )  		int alt5 = 4;  		try {  			DebugEnterDecision (5' false);  			switch (input.LA (1)) {  			case ID:  				{  					alt5 = 1;  				}  				break;  			case ESC_ID:  				{  					alt5 = 2;  				}  				break;  			case REGEX:  				{  					alt5 = 3;  				}  				break;  			case 27:  				{  					alt5 = 4;  				}  				break;  			default: {  				NoViableAltException nvae = new NoViableAltException (""' 5' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  			}  		}  		finally {  			DebugExitDecision (5);  		}  		switch (alt5) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:34:4: ID  			{  				DebugLocation (34' 4);  				ID2 = (CommonTree)Match (input' ID' Follow._ID_in_propertyName112);  				DebugLocation (34' 7);  				retval.isRegex = false;  				retval.name = (ID2 != null ? ID2.Text : default(string));  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:38:4: ESC_ID  			{  				DebugLocation (38' 4);  				ESC_ID3 = (CommonTree)Match (input' ESC_ID' Follow._ESC_ID_in_propertyName119);  				DebugLocation (38' 11);  				retval.isRegex = false;  				string stringText = (ESC_ID3 != null ? ESC_ID3.Text : default(string));  				retval.name = stringText.Substring (1' stringText.Length - 2);  			}  			break;  		case 3:  			DebugEnterAlt (3);  			// ./src/Parser/Grammar/JFLWalker.g:43:4: REGEX  			{  				DebugLocation (43' 4);  				REGEX4 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_propertyName126);  				DebugLocation (43' 10);  				retval.isRegex = true;  				string regexText = (REGEX4 != null ? REGEX4.Text : default(string));  				retval.name = regexText.Substring (1' regexText.Length - 2);  			}  			break;  		case 4:  			DebugEnterAlt (4);  			// ./src/Parser/Grammar/JFLWalker.g:48:4: '*'  			{  				DebugLocation (48' 4);  				Match (input' 27' Follow._27_in_propertyName133);  				DebugLocation (48' 8);  				retval.isRegex = false;  				retval.name = "*";  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("propertyName"' 4);  		LeaveRule ("propertyName"' 4);  		LeaveRule_propertyName ();  	}  	DebugLocation (52' 1);  }  finally {  	DebugExitRule (GrammarFileName' "propertyName");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyName,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "propertyName");  	DebugLocation (33' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:34:2: ( ID | ESC_ID | REGEX | '*' )  		int alt5 = 4;  		try {  			DebugEnterDecision (5' false);  			switch (input.LA (1)) {  			case ID:  				{  					alt5 = 1;  				}  				break;  			case ESC_ID:  				{  					alt5 = 2;  				}  				break;  			case REGEX:  				{  					alt5 = 3;  				}  				break;  			case 27:  				{  					alt5 = 4;  				}  				break;  			default: {  				NoViableAltException nvae = new NoViableAltException (""' 5' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  			}  		}  		finally {  			DebugExitDecision (5);  		}  		switch (alt5) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:34:4: ID  			{  				DebugLocation (34' 4);  				ID2 = (CommonTree)Match (input' ID' Follow._ID_in_propertyName112);  				DebugLocation (34' 7);  				retval.isRegex = false;  				retval.name = (ID2 != null ? ID2.Text : default(string));  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:38:4: ESC_ID  			{  				DebugLocation (38' 4);  				ESC_ID3 = (CommonTree)Match (input' ESC_ID' Follow._ESC_ID_in_propertyName119);  				DebugLocation (38' 11);  				retval.isRegex = false;  				string stringText = (ESC_ID3 != null ? ESC_ID3.Text : default(string));  				retval.name = stringText.Substring (1' stringText.Length - 2);  			}  			break;  		case 3:  			DebugEnterAlt (3);  			// ./src/Parser/Grammar/JFLWalker.g:43:4: REGEX  			{  				DebugLocation (43' 4);  				REGEX4 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_propertyName126);  				DebugLocation (43' 10);  				retval.isRegex = true;  				string regexText = (REGEX4 != null ? REGEX4.Text : default(string));  				retval.name = regexText.Substring (1' regexText.Length - 2);  			}  			break;  		case 4:  			DebugEnterAlt (4);  			// ./src/Parser/Grammar/JFLWalker.g:48:4: '*'  			{  				DebugLocation (48' 4);  				Match (input' 27' Follow._27_in_propertyName133);  				DebugLocation (48' 8);  				retval.isRegex = false;  				retval.name = "*";  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("propertyName"' 4);  		LeaveRule ("propertyName"' 4);  		LeaveRule_propertyName ();  	}  	DebugLocation (52' 1);  }  finally {  	DebugExitRule (GrammarFileName' "propertyName");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyName,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "propertyName");  	DebugLocation (33' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:34:2: ( ID | ESC_ID | REGEX | '*' )  		int alt5 = 4;  		try {  			DebugEnterDecision (5' false);  			switch (input.LA (1)) {  			case ID:  				{  					alt5 = 1;  				}  				break;  			case ESC_ID:  				{  					alt5 = 2;  				}  				break;  			case REGEX:  				{  					alt5 = 3;  				}  				break;  			case 27:  				{  					alt5 = 4;  				}  				break;  			default: {  				NoViableAltException nvae = new NoViableAltException (""' 5' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  			}  		}  		finally {  			DebugExitDecision (5);  		}  		switch (alt5) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:34:4: ID  			{  				DebugLocation (34' 4);  				ID2 = (CommonTree)Match (input' ID' Follow._ID_in_propertyName112);  				DebugLocation (34' 7);  				retval.isRegex = false;  				retval.name = (ID2 != null ? ID2.Text : default(string));  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:38:4: ESC_ID  			{  				DebugLocation (38' 4);  				ESC_ID3 = (CommonTree)Match (input' ESC_ID' Follow._ESC_ID_in_propertyName119);  				DebugLocation (38' 11);  				retval.isRegex = false;  				string stringText = (ESC_ID3 != null ? ESC_ID3.Text : default(string));  				retval.name = stringText.Substring (1' stringText.Length - 2);  			}  			break;  		case 3:  			DebugEnterAlt (3);  			// ./src/Parser/Grammar/JFLWalker.g:43:4: REGEX  			{  				DebugLocation (43' 4);  				REGEX4 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_propertyName126);  				DebugLocation (43' 10);  				retval.isRegex = true;  				string regexText = (REGEX4 != null ? REGEX4.Text : default(string));  				retval.name = regexText.Substring (1' regexText.Length - 2);  			}  			break;  		case 4:  			DebugEnterAlt (4);  			// ./src/Parser/Grammar/JFLWalker.g:48:4: '*'  			{  				DebugLocation (48' 4);  				Match (input' 27' Follow._27_in_propertyName133);  				DebugLocation (48' 8);  				retval.isRegex = false;  				retval.name = "*";  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("propertyName"' 4);  		LeaveRule ("propertyName"' 4);  		LeaveRule_propertyName ();  	}  	DebugLocation (52' 1);  }  finally {  	DebugExitRule (GrammarFileName' "propertyName");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyName,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "propertyName");  	DebugLocation (33' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:34:2: ( ID | ESC_ID | REGEX | '*' )  		int alt5 = 4;  		try {  			DebugEnterDecision (5' false);  			switch (input.LA (1)) {  			case ID:  				{  					alt5 = 1;  				}  				break;  			case ESC_ID:  				{  					alt5 = 2;  				}  				break;  			case REGEX:  				{  					alt5 = 3;  				}  				break;  			case 27:  				{  					alt5 = 4;  				}  				break;  			default: {  				NoViableAltException nvae = new NoViableAltException (""' 5' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  			}  		}  		finally {  			DebugExitDecision (5);  		}  		switch (alt5) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:34:4: ID  			{  				DebugLocation (34' 4);  				ID2 = (CommonTree)Match (input' ID' Follow._ID_in_propertyName112);  				DebugLocation (34' 7);  				retval.isRegex = false;  				retval.name = (ID2 != null ? ID2.Text : default(string));  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:38:4: ESC_ID  			{  				DebugLocation (38' 4);  				ESC_ID3 = (CommonTree)Match (input' ESC_ID' Follow._ESC_ID_in_propertyName119);  				DebugLocation (38' 11);  				retval.isRegex = false;  				string stringText = (ESC_ID3 != null ? ESC_ID3.Text : default(string));  				retval.name = stringText.Substring (1' stringText.Length - 2);  			}  			break;  		case 3:  			DebugEnterAlt (3);  			// ./src/Parser/Grammar/JFLWalker.g:43:4: REGEX  			{  				DebugLocation (43' 4);  				REGEX4 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_propertyName126);  				DebugLocation (43' 10);  				retval.isRegex = true;  				string regexText = (REGEX4 != null ? REGEX4.Text : default(string));  				retval.name = regexText.Substring (1' regexText.Length - 2);  			}  			break;  		case 4:  			DebugEnterAlt (4);  			// ./src/Parser/Grammar/JFLWalker.g:48:4: '*'  			{  				DebugLocation (48' 4);  				Match (input' 27' Follow._27_in_propertyName133);  				DebugLocation (48' 8);  				retval.isRegex = false;  				retval.name = "*";  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("propertyName"' 4);  		LeaveRule ("propertyName"' 4);  		LeaveRule_propertyName ();  	}  	DebugLocation (52' 1);  }  finally {  	DebugExitRule (GrammarFileName' "propertyName");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyName,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "propertyName");  	DebugLocation (33' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:34:2: ( ID | ESC_ID | REGEX | '*' )  		int alt5 = 4;  		try {  			DebugEnterDecision (5' false);  			switch (input.LA (1)) {  			case ID:  				{  					alt5 = 1;  				}  				break;  			case ESC_ID:  				{  					alt5 = 2;  				}  				break;  			case REGEX:  				{  					alt5 = 3;  				}  				break;  			case 27:  				{  					alt5 = 4;  				}  				break;  			default: {  				NoViableAltException nvae = new NoViableAltException (""' 5' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  			}  		}  		finally {  			DebugExitDecision (5);  		}  		switch (alt5) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:34:4: ID  			{  				DebugLocation (34' 4);  				ID2 = (CommonTree)Match (input' ID' Follow._ID_in_propertyName112);  				DebugLocation (34' 7);  				retval.isRegex = false;  				retval.name = (ID2 != null ? ID2.Text : default(string));  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:38:4: ESC_ID  			{  				DebugLocation (38' 4);  				ESC_ID3 = (CommonTree)Match (input' ESC_ID' Follow._ESC_ID_in_propertyName119);  				DebugLocation (38' 11);  				retval.isRegex = false;  				string stringText = (ESC_ID3 != null ? ESC_ID3.Text : default(string));  				retval.name = stringText.Substring (1' stringText.Length - 2);  			}  			break;  		case 3:  			DebugEnterAlt (3);  			// ./src/Parser/Grammar/JFLWalker.g:43:4: REGEX  			{  				DebugLocation (43' 4);  				REGEX4 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_propertyName126);  				DebugLocation (43' 10);  				retval.isRegex = true;  				string regexText = (REGEX4 != null ? REGEX4.Text : default(string));  				retval.name = regexText.Substring (1' regexText.Length - 2);  			}  			break;  		case 4:  			DebugEnterAlt (4);  			// ./src/Parser/Grammar/JFLWalker.g:48:4: '*'  			{  				DebugLocation (48' 4);  				Match (input' 27' Follow._27_in_propertyName133);  				DebugLocation (48' 8);  				retval.isRegex = false;  				retval.name = "*";  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("propertyName"' 4);  		LeaveRule ("propertyName"' 4);  		LeaveRule_propertyName ();  	}  	DebugLocation (52' 1);  }  finally {  	DebugExitRule (GrammarFileName' "propertyName");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyName,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "propertyName");  	DebugLocation (33' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:34:2: ( ID | ESC_ID | REGEX | '*' )  		int alt5 = 4;  		try {  			DebugEnterDecision (5' false);  			switch (input.LA (1)) {  			case ID:  				{  					alt5 = 1;  				}  				break;  			case ESC_ID:  				{  					alt5 = 2;  				}  				break;  			case REGEX:  				{  					alt5 = 3;  				}  				break;  			case 27:  				{  					alt5 = 4;  				}  				break;  			default: {  				NoViableAltException nvae = new NoViableAltException (""' 5' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  			}  		}  		finally {  			DebugExitDecision (5);  		}  		switch (alt5) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:34:4: ID  			{  				DebugLocation (34' 4);  				ID2 = (CommonTree)Match (input' ID' Follow._ID_in_propertyName112);  				DebugLocation (34' 7);  				retval.isRegex = false;  				retval.name = (ID2 != null ? ID2.Text : default(string));  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:38:4: ESC_ID  			{  				DebugLocation (38' 4);  				ESC_ID3 = (CommonTree)Match (input' ESC_ID' Follow._ESC_ID_in_propertyName119);  				DebugLocation (38' 11);  				retval.isRegex = false;  				string stringText = (ESC_ID3 != null ? ESC_ID3.Text : default(string));  				retval.name = stringText.Substring (1' stringText.Length - 2);  			}  			break;  		case 3:  			DebugEnterAlt (3);  			// ./src/Parser/Grammar/JFLWalker.g:43:4: REGEX  			{  				DebugLocation (43' 4);  				REGEX4 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_propertyName126);  				DebugLocation (43' 10);  				retval.isRegex = true;  				string regexText = (REGEX4 != null ? REGEX4.Text : default(string));  				retval.name = regexText.Substring (1' regexText.Length - 2);  			}  			break;  		case 4:  			DebugEnterAlt (4);  			// ./src/Parser/Grammar/JFLWalker.g:48:4: '*'  			{  				DebugLocation (48' 4);  				Match (input' 27' Follow._27_in_propertyName133);  				DebugLocation (48' 8);  				retval.isRegex = false;  				retval.name = "*";  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("propertyName"' 4);  		LeaveRule ("propertyName"' 4);  		LeaveRule_propertyName ();  	}  	DebugLocation (52' 1);  }  finally {  	DebugExitRule (GrammarFileName' "propertyName");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyName,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "propertyName");  	DebugLocation (33' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:34:2: ( ID | ESC_ID | REGEX | '*' )  		int alt5 = 4;  		try {  			DebugEnterDecision (5' false);  			switch (input.LA (1)) {  			case ID:  				{  					alt5 = 1;  				}  				break;  			case ESC_ID:  				{  					alt5 = 2;  				}  				break;  			case REGEX:  				{  					alt5 = 3;  				}  				break;  			case 27:  				{  					alt5 = 4;  				}  				break;  			default: {  				NoViableAltException nvae = new NoViableAltException (""' 5' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  			}  		}  		finally {  			DebugExitDecision (5);  		}  		switch (alt5) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:34:4: ID  			{  				DebugLocation (34' 4);  				ID2 = (CommonTree)Match (input' ID' Follow._ID_in_propertyName112);  				DebugLocation (34' 7);  				retval.isRegex = false;  				retval.name = (ID2 != null ? ID2.Text : default(string));  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:38:4: ESC_ID  			{  				DebugLocation (38' 4);  				ESC_ID3 = (CommonTree)Match (input' ESC_ID' Follow._ESC_ID_in_propertyName119);  				DebugLocation (38' 11);  				retval.isRegex = false;  				string stringText = (ESC_ID3 != null ? ESC_ID3.Text : default(string));  				retval.name = stringText.Substring (1' stringText.Length - 2);  			}  			break;  		case 3:  			DebugEnterAlt (3);  			// ./src/Parser/Grammar/JFLWalker.g:43:4: REGEX  			{  				DebugLocation (43' 4);  				REGEX4 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_propertyName126);  				DebugLocation (43' 10);  				retval.isRegex = true;  				string regexText = (REGEX4 != null ? REGEX4.Text : default(string));  				retval.name = regexText.Substring (1' regexText.Length - 2);  			}  			break;  		case 4:  			DebugEnterAlt (4);  			// ./src/Parser/Grammar/JFLWalker.g:48:4: '*'  			{  				DebugLocation (48' 4);  				Match (input' 27' Follow._27_in_propertyName133);  				DebugLocation (48' 8);  				retval.isRegex = false;  				retval.name = "*";  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("propertyName"' 4);  		LeaveRule ("propertyName"' 4);  		LeaveRule_propertyName ();  	}  	DebugLocation (52' 1);  }  finally {  	DebugExitRule (GrammarFileName' "propertyName");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyName,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "propertyName");  	DebugLocation (33' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:34:2: ( ID | ESC_ID | REGEX | '*' )  		int alt5 = 4;  		try {  			DebugEnterDecision (5' false);  			switch (input.LA (1)) {  			case ID:  				{  					alt5 = 1;  				}  				break;  			case ESC_ID:  				{  					alt5 = 2;  				}  				break;  			case REGEX:  				{  					alt5 = 3;  				}  				break;  			case 27:  				{  					alt5 = 4;  				}  				break;  			default: {  				NoViableAltException nvae = new NoViableAltException (""' 5' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  			}  		}  		finally {  			DebugExitDecision (5);  		}  		switch (alt5) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:34:4: ID  			{  				DebugLocation (34' 4);  				ID2 = (CommonTree)Match (input' ID' Follow._ID_in_propertyName112);  				DebugLocation (34' 7);  				retval.isRegex = false;  				retval.name = (ID2 != null ? ID2.Text : default(string));  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:38:4: ESC_ID  			{  				DebugLocation (38' 4);  				ESC_ID3 = (CommonTree)Match (input' ESC_ID' Follow._ESC_ID_in_propertyName119);  				DebugLocation (38' 11);  				retval.isRegex = false;  				string stringText = (ESC_ID3 != null ? ESC_ID3.Text : default(string));  				retval.name = stringText.Substring (1' stringText.Length - 2);  			}  			break;  		case 3:  			DebugEnterAlt (3);  			// ./src/Parser/Grammar/JFLWalker.g:43:4: REGEX  			{  				DebugLocation (43' 4);  				REGEX4 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_propertyName126);  				DebugLocation (43' 10);  				retval.isRegex = true;  				string regexText = (REGEX4 != null ? REGEX4.Text : default(string));  				retval.name = regexText.Substring (1' regexText.Length - 2);  			}  			break;  		case 4:  			DebugEnterAlt (4);  			// ./src/Parser/Grammar/JFLWalker.g:48:4: '*'  			{  				DebugLocation (48' 4);  				Match (input' 27' Follow._27_in_propertyName133);  				DebugLocation (48' 8);  				retval.isRegex = false;  				retval.name = "*";  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("propertyName"' 4);  		LeaveRule ("propertyName"' 4);  		LeaveRule_propertyName ();  	}  	DebugLocation (52' 1);  }  finally {  	DebugExitRule (GrammarFileName' "propertyName");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyName,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "propertyName");  	DebugLocation (33' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:34:2: ( ID | ESC_ID | REGEX | '*' )  		int alt5 = 4;  		try {  			DebugEnterDecision (5' false);  			switch (input.LA (1)) {  			case ID:  				{  					alt5 = 1;  				}  				break;  			case ESC_ID:  				{  					alt5 = 2;  				}  				break;  			case REGEX:  				{  					alt5 = 3;  				}  				break;  			case 27:  				{  					alt5 = 4;  				}  				break;  			default: {  				NoViableAltException nvae = new NoViableAltException (""' 5' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  			}  		}  		finally {  			DebugExitDecision (5);  		}  		switch (alt5) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:34:4: ID  			{  				DebugLocation (34' 4);  				ID2 = (CommonTree)Match (input' ID' Follow._ID_in_propertyName112);  				DebugLocation (34' 7);  				retval.isRegex = false;  				retval.name = (ID2 != null ? ID2.Text : default(string));  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:38:4: ESC_ID  			{  				DebugLocation (38' 4);  				ESC_ID3 = (CommonTree)Match (input' ESC_ID' Follow._ESC_ID_in_propertyName119);  				DebugLocation (38' 11);  				retval.isRegex = false;  				string stringText = (ESC_ID3 != null ? ESC_ID3.Text : default(string));  				retval.name = stringText.Substring (1' stringText.Length - 2);  			}  			break;  		case 3:  			DebugEnterAlt (3);  			// ./src/Parser/Grammar/JFLWalker.g:43:4: REGEX  			{  				DebugLocation (43' 4);  				REGEX4 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_propertyName126);  				DebugLocation (43' 10);  				retval.isRegex = true;  				string regexText = (REGEX4 != null ? REGEX4.Text : default(string));  				retval.name = regexText.Substring (1' regexText.Length - 2);  			}  			break;  		case 4:  			DebugEnterAlt (4);  			// ./src/Parser/Grammar/JFLWalker.g:48:4: '*'  			{  				DebugLocation (48' 4);  				Match (input' 27' Follow._27_in_propertyName133);  				DebugLocation (48' 8);  				retval.isRegex = false;  				retval.name = "*";  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("propertyName"' 4);  		LeaveRule ("propertyName"' 4);  		LeaveRule_propertyName ();  	}  	DebugLocation (52' 1);  }  finally {  	DebugExitRule (GrammarFileName' "propertyName");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyName,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "propertyName");  	DebugLocation (33' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:34:2: ( ID | ESC_ID | REGEX | '*' )  		int alt5 = 4;  		try {  			DebugEnterDecision (5' false);  			switch (input.LA (1)) {  			case ID:  				{  					alt5 = 1;  				}  				break;  			case ESC_ID:  				{  					alt5 = 2;  				}  				break;  			case REGEX:  				{  					alt5 = 3;  				}  				break;  			case 27:  				{  					alt5 = 4;  				}  				break;  			default: {  				NoViableAltException nvae = new NoViableAltException (""' 5' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  			}  		}  		finally {  			DebugExitDecision (5);  		}  		switch (alt5) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:34:4: ID  			{  				DebugLocation (34' 4);  				ID2 = (CommonTree)Match (input' ID' Follow._ID_in_propertyName112);  				DebugLocation (34' 7);  				retval.isRegex = false;  				retval.name = (ID2 != null ? ID2.Text : default(string));  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:38:4: ESC_ID  			{  				DebugLocation (38' 4);  				ESC_ID3 = (CommonTree)Match (input' ESC_ID' Follow._ESC_ID_in_propertyName119);  				DebugLocation (38' 11);  				retval.isRegex = false;  				string stringText = (ESC_ID3 != null ? ESC_ID3.Text : default(string));  				retval.name = stringText.Substring (1' stringText.Length - 2);  			}  			break;  		case 3:  			DebugEnterAlt (3);  			// ./src/Parser/Grammar/JFLWalker.g:43:4: REGEX  			{  				DebugLocation (43' 4);  				REGEX4 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_propertyName126);  				DebugLocation (43' 10);  				retval.isRegex = true;  				string regexText = (REGEX4 != null ? REGEX4.Text : default(string));  				retval.name = regexText.Substring (1' regexText.Length - 2);  			}  			break;  		case 4:  			DebugEnterAlt (4);  			// ./src/Parser/Grammar/JFLWalker.g:48:4: '*'  			{  				DebugLocation (48' 4);  				Match (input' 27' Follow._27_in_propertyName133);  				DebugLocation (48' 8);  				retval.isRegex = false;  				retval.name = "*";  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("propertyName"' 4);  		LeaveRule ("propertyName"' 4);  		LeaveRule_propertyName ();  	}  	DebugLocation (52' 1);  }  finally {  	DebugExitRule (GrammarFileName' "propertyName");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyName,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "propertyName");  	DebugLocation (33' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:34:2: ( ID | ESC_ID | REGEX | '*' )  		int alt5 = 4;  		try {  			DebugEnterDecision (5' false);  			switch (input.LA (1)) {  			case ID:  				{  					alt5 = 1;  				}  				break;  			case ESC_ID:  				{  					alt5 = 2;  				}  				break;  			case REGEX:  				{  					alt5 = 3;  				}  				break;  			case 27:  				{  					alt5 = 4;  				}  				break;  			default: {  				NoViableAltException nvae = new NoViableAltException (""' 5' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  			}  		}  		finally {  			DebugExitDecision (5);  		}  		switch (alt5) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:34:4: ID  			{  				DebugLocation (34' 4);  				ID2 = (CommonTree)Match (input' ID' Follow._ID_in_propertyName112);  				DebugLocation (34' 7);  				retval.isRegex = false;  				retval.name = (ID2 != null ? ID2.Text : default(string));  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:38:4: ESC_ID  			{  				DebugLocation (38' 4);  				ESC_ID3 = (CommonTree)Match (input' ESC_ID' Follow._ESC_ID_in_propertyName119);  				DebugLocation (38' 11);  				retval.isRegex = false;  				string stringText = (ESC_ID3 != null ? ESC_ID3.Text : default(string));  				retval.name = stringText.Substring (1' stringText.Length - 2);  			}  			break;  		case 3:  			DebugEnterAlt (3);  			// ./src/Parser/Grammar/JFLWalker.g:43:4: REGEX  			{  				DebugLocation (43' 4);  				REGEX4 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_propertyName126);  				DebugLocation (43' 10);  				retval.isRegex = true;  				string regexText = (REGEX4 != null ? REGEX4.Text : default(string));  				retval.name = regexText.Substring (1' regexText.Length - 2);  			}  			break;  		case 4:  			DebugEnterAlt (4);  			// ./src/Parser/Grammar/JFLWalker.g:48:4: '*'  			{  				DebugLocation (48' 4);  				Match (input' 27' Follow._27_in_propertyName133);  				DebugLocation (48' 8);  				retval.isRegex = false;  				retval.name = "*";  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("propertyName"' 4);  		LeaveRule ("propertyName"' 4);  		LeaveRule_propertyName ();  	}  	DebugLocation (52' 1);  }  finally {  	DebugExitRule (GrammarFileName' "propertyName");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyName,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "propertyName");  	DebugLocation (33' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:34:2: ( ID | ESC_ID | REGEX | '*' )  		int alt5 = 4;  		try {  			DebugEnterDecision (5' false);  			switch (input.LA (1)) {  			case ID:  				{  					alt5 = 1;  				}  				break;  			case ESC_ID:  				{  					alt5 = 2;  				}  				break;  			case REGEX:  				{  					alt5 = 3;  				}  				break;  			case 27:  				{  					alt5 = 4;  				}  				break;  			default: {  				NoViableAltException nvae = new NoViableAltException (""' 5' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  			}  		}  		finally {  			DebugExitDecision (5);  		}  		switch (alt5) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:34:4: ID  			{  				DebugLocation (34' 4);  				ID2 = (CommonTree)Match (input' ID' Follow._ID_in_propertyName112);  				DebugLocation (34' 7);  				retval.isRegex = false;  				retval.name = (ID2 != null ? ID2.Text : default(string));  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:38:4: ESC_ID  			{  				DebugLocation (38' 4);  				ESC_ID3 = (CommonTree)Match (input' ESC_ID' Follow._ESC_ID_in_propertyName119);  				DebugLocation (38' 11);  				retval.isRegex = false;  				string stringText = (ESC_ID3 != null ? ESC_ID3.Text : default(string));  				retval.name = stringText.Substring (1' stringText.Length - 2);  			}  			break;  		case 3:  			DebugEnterAlt (3);  			// ./src/Parser/Grammar/JFLWalker.g:43:4: REGEX  			{  				DebugLocation (43' 4);  				REGEX4 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_propertyName126);  				DebugLocation (43' 10);  				retval.isRegex = true;  				string regexText = (REGEX4 != null ? REGEX4.Text : default(string));  				retval.name = regexText.Substring (1' regexText.Length - 2);  			}  			break;  		case 4:  			DebugEnterAlt (4);  			// ./src/Parser/Grammar/JFLWalker.g:48:4: '*'  			{  				DebugLocation (48' 4);  				Match (input' 27' Follow._27_in_propertyName133);  				DebugLocation (48' 8);  				retval.isRegex = false;  				retval.name = "*";  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("propertyName"' 4);  		LeaveRule ("propertyName"' 4);  		LeaveRule_propertyName ();  	}  	DebugLocation (52' 1);  }  finally {  	DebugExitRule (GrammarFileName' "propertyName");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyName,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "propertyName");  	DebugLocation (33' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:34:2: ( ID | ESC_ID | REGEX | '*' )  		int alt5 = 4;  		try {  			DebugEnterDecision (5' false);  			switch (input.LA (1)) {  			case ID:  				{  					alt5 = 1;  				}  				break;  			case ESC_ID:  				{  					alt5 = 2;  				}  				break;  			case REGEX:  				{  					alt5 = 3;  				}  				break;  			case 27:  				{  					alt5 = 4;  				}  				break;  			default: {  				NoViableAltException nvae = new NoViableAltException (""' 5' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  			}  		}  		finally {  			DebugExitDecision (5);  		}  		switch (alt5) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:34:4: ID  			{  				DebugLocation (34' 4);  				ID2 = (CommonTree)Match (input' ID' Follow._ID_in_propertyName112);  				DebugLocation (34' 7);  				retval.isRegex = false;  				retval.name = (ID2 != null ? ID2.Text : default(string));  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:38:4: ESC_ID  			{  				DebugLocation (38' 4);  				ESC_ID3 = (CommonTree)Match (input' ESC_ID' Follow._ESC_ID_in_propertyName119);  				DebugLocation (38' 11);  				retval.isRegex = false;  				string stringText = (ESC_ID3 != null ? ESC_ID3.Text : default(string));  				retval.name = stringText.Substring (1' stringText.Length - 2);  			}  			break;  		case 3:  			DebugEnterAlt (3);  			// ./src/Parser/Grammar/JFLWalker.g:43:4: REGEX  			{  				DebugLocation (43' 4);  				REGEX4 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_propertyName126);  				DebugLocation (43' 10);  				retval.isRegex = true;  				string regexText = (REGEX4 != null ? REGEX4.Text : default(string));  				retval.name = regexText.Substring (1' regexText.Length - 2);  			}  			break;  		case 4:  			DebugEnterAlt (4);  			// ./src/Parser/Grammar/JFLWalker.g:48:4: '*'  			{  				DebugLocation (48' 4);  				Match (input' 27' Follow._27_in_propertyName133);  				DebugLocation (48' 8);  				retval.isRegex = false;  				retval.name = "*";  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("propertyName"' 4);  		LeaveRule ("propertyName"' 4);  		LeaveRule_propertyName ();  	}  	DebugLocation (52' 1);  }  finally {  	DebugExitRule (GrammarFileName' "propertyName");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyName,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "propertyName");  	DebugLocation (33' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:34:2: ( ID | ESC_ID | REGEX | '*' )  		int alt5 = 4;  		try {  			DebugEnterDecision (5' false);  			switch (input.LA (1)) {  			case ID:  				{  					alt5 = 1;  				}  				break;  			case ESC_ID:  				{  					alt5 = 2;  				}  				break;  			case REGEX:  				{  					alt5 = 3;  				}  				break;  			case 27:  				{  					alt5 = 4;  				}  				break;  			default: {  				NoViableAltException nvae = new NoViableAltException (""' 5' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  			}  		}  		finally {  			DebugExitDecision (5);  		}  		switch (alt5) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:34:4: ID  			{  				DebugLocation (34' 4);  				ID2 = (CommonTree)Match (input' ID' Follow._ID_in_propertyName112);  				DebugLocation (34' 7);  				retval.isRegex = false;  				retval.name = (ID2 != null ? ID2.Text : default(string));  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:38:4: ESC_ID  			{  				DebugLocation (38' 4);  				ESC_ID3 = (CommonTree)Match (input' ESC_ID' Follow._ESC_ID_in_propertyName119);  				DebugLocation (38' 11);  				retval.isRegex = false;  				string stringText = (ESC_ID3 != null ? ESC_ID3.Text : default(string));  				retval.name = stringText.Substring (1' stringText.Length - 2);  			}  			break;  		case 3:  			DebugEnterAlt (3);  			// ./src/Parser/Grammar/JFLWalker.g:43:4: REGEX  			{  				DebugLocation (43' 4);  				REGEX4 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_propertyName126);  				DebugLocation (43' 10);  				retval.isRegex = true;  				string regexText = (REGEX4 != null ? REGEX4.Text : default(string));  				retval.name = regexText.Substring (1' regexText.Length - 2);  			}  			break;  		case 4:  			DebugEnterAlt (4);  			// ./src/Parser/Grammar/JFLWalker.g:48:4: '*'  			{  				DebugLocation (48' 4);  				Match (input' 27' Follow._27_in_propertyName133);  				DebugLocation (48' 8);  				retval.isRegex = false;  				retval.name = "*";  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("propertyName"' 4);  		LeaveRule ("propertyName"' 4);  		LeaveRule_propertyName ();  	}  	DebugLocation (52' 1);  }  finally {  	DebugExitRule (GrammarFileName' "propertyName");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyName,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "propertyName");  	DebugLocation (33' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:34:2: ( ID | ESC_ID | REGEX | '*' )  		int alt5 = 4;  		try {  			DebugEnterDecision (5' false);  			switch (input.LA (1)) {  			case ID:  				{  					alt5 = 1;  				}  				break;  			case ESC_ID:  				{  					alt5 = 2;  				}  				break;  			case REGEX:  				{  					alt5 = 3;  				}  				break;  			case 27:  				{  					alt5 = 4;  				}  				break;  			default: {  				NoViableAltException nvae = new NoViableAltException (""' 5' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  			}  		}  		finally {  			DebugExitDecision (5);  		}  		switch (alt5) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:34:4: ID  			{  				DebugLocation (34' 4);  				ID2 = (CommonTree)Match (input' ID' Follow._ID_in_propertyName112);  				DebugLocation (34' 7);  				retval.isRegex = false;  				retval.name = (ID2 != null ? ID2.Text : default(string));  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:38:4: ESC_ID  			{  				DebugLocation (38' 4);  				ESC_ID3 = (CommonTree)Match (input' ESC_ID' Follow._ESC_ID_in_propertyName119);  				DebugLocation (38' 11);  				retval.isRegex = false;  				string stringText = (ESC_ID3 != null ? ESC_ID3.Text : default(string));  				retval.name = stringText.Substring (1' stringText.Length - 2);  			}  			break;  		case 3:  			DebugEnterAlt (3);  			// ./src/Parser/Grammar/JFLWalker.g:43:4: REGEX  			{  				DebugLocation (43' 4);  				REGEX4 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_propertyName126);  				DebugLocation (43' 10);  				retval.isRegex = true;  				string regexText = (REGEX4 != null ? REGEX4.Text : default(string));  				retval.name = regexText.Substring (1' regexText.Length - 2);  			}  			break;  		case 4:  			DebugEnterAlt (4);  			// ./src/Parser/Grammar/JFLWalker.g:48:4: '*'  			{  				DebugLocation (48' 4);  				Match (input' 27' Follow._27_in_propertyName133);  				DebugLocation (48' 8);  				retval.isRegex = false;  				retval.name = "*";  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("propertyName"' 4);  		LeaveRule ("propertyName"' 4);  		LeaveRule_propertyName ();  	}  	DebugLocation (52' 1);  }  finally {  	DebugExitRule (GrammarFileName' "propertyName");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyName,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "propertyName");  	DebugLocation (33' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:34:2: ( ID | ESC_ID | REGEX | '*' )  		int alt5 = 4;  		try {  			DebugEnterDecision (5' false);  			switch (input.LA (1)) {  			case ID:  				{  					alt5 = 1;  				}  				break;  			case ESC_ID:  				{  					alt5 = 2;  				}  				break;  			case REGEX:  				{  					alt5 = 3;  				}  				break;  			case 27:  				{  					alt5 = 4;  				}  				break;  			default: {  				NoViableAltException nvae = new NoViableAltException (""' 5' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  			}  		}  		finally {  			DebugExitDecision (5);  		}  		switch (alt5) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:34:4: ID  			{  				DebugLocation (34' 4);  				ID2 = (CommonTree)Match (input' ID' Follow._ID_in_propertyName112);  				DebugLocation (34' 7);  				retval.isRegex = false;  				retval.name = (ID2 != null ? ID2.Text : default(string));  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:38:4: ESC_ID  			{  				DebugLocation (38' 4);  				ESC_ID3 = (CommonTree)Match (input' ESC_ID' Follow._ESC_ID_in_propertyName119);  				DebugLocation (38' 11);  				retval.isRegex = false;  				string stringText = (ESC_ID3 != null ? ESC_ID3.Text : default(string));  				retval.name = stringText.Substring (1' stringText.Length - 2);  			}  			break;  		case 3:  			DebugEnterAlt (3);  			// ./src/Parser/Grammar/JFLWalker.g:43:4: REGEX  			{  				DebugLocation (43' 4);  				REGEX4 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_propertyName126);  				DebugLocation (43' 10);  				retval.isRegex = true;  				string regexText = (REGEX4 != null ? REGEX4.Text : default(string));  				retval.name = regexText.Substring (1' regexText.Length - 2);  			}  			break;  		case 4:  			DebugEnterAlt (4);  			// ./src/Parser/Grammar/JFLWalker.g:48:4: '*'  			{  				DebugLocation (48' 4);  				Match (input' 27' Follow._27_in_propertyName133);  				DebugLocation (48' 8);  				retval.isRegex = false;  				retval.name = "*";  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("propertyName"' 4);  		LeaveRule ("propertyName"' 4);  		LeaveRule_propertyName ();  	}  	DebugLocation (52' 1);  }  finally {  	DebugExitRule (GrammarFileName' "propertyName");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyName,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "propertyName");  	DebugLocation (33' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:34:2: ( ID | ESC_ID | REGEX | '*' )  		int alt5 = 4;  		try {  			DebugEnterDecision (5' false);  			switch (input.LA (1)) {  			case ID:  				{  					alt5 = 1;  				}  				break;  			case ESC_ID:  				{  					alt5 = 2;  				}  				break;  			case REGEX:  				{  					alt5 = 3;  				}  				break;  			case 27:  				{  					alt5 = 4;  				}  				break;  			default: {  				NoViableAltException nvae = new NoViableAltException (""' 5' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  			}  		}  		finally {  			DebugExitDecision (5);  		}  		switch (alt5) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:34:4: ID  			{  				DebugLocation (34' 4);  				ID2 = (CommonTree)Match (input' ID' Follow._ID_in_propertyName112);  				DebugLocation (34' 7);  				retval.isRegex = false;  				retval.name = (ID2 != null ? ID2.Text : default(string));  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:38:4: ESC_ID  			{  				DebugLocation (38' 4);  				ESC_ID3 = (CommonTree)Match (input' ESC_ID' Follow._ESC_ID_in_propertyName119);  				DebugLocation (38' 11);  				retval.isRegex = false;  				string stringText = (ESC_ID3 != null ? ESC_ID3.Text : default(string));  				retval.name = stringText.Substring (1' stringText.Length - 2);  			}  			break;  		case 3:  			DebugEnterAlt (3);  			// ./src/Parser/Grammar/JFLWalker.g:43:4: REGEX  			{  				DebugLocation (43' 4);  				REGEX4 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_propertyName126);  				DebugLocation (43' 10);  				retval.isRegex = true;  				string regexText = (REGEX4 != null ? REGEX4.Text : default(string));  				retval.name = regexText.Substring (1' regexText.Length - 2);  			}  			break;  		case 4:  			DebugEnterAlt (4);  			// ./src/Parser/Grammar/JFLWalker.g:48:4: '*'  			{  				DebugLocation (48' 4);  				Match (input' 27' Follow._27_in_propertyName133);  				DebugLocation (48' 8);  				retval.isRegex = false;  				retval.name = "*";  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("propertyName"' 4);  		LeaveRule ("propertyName"' 4);  		LeaveRule_propertyName ();  	}  	DebugLocation (52' 1);  }  finally {  	DebugExitRule (GrammarFileName' "propertyName");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyName,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "propertyName");  	DebugLocation (33' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:34:2: ( ID | ESC_ID | REGEX | '*' )  		int alt5 = 4;  		try {  			DebugEnterDecision (5' false);  			switch (input.LA (1)) {  			case ID:  				{  					alt5 = 1;  				}  				break;  			case ESC_ID:  				{  					alt5 = 2;  				}  				break;  			case REGEX:  				{  					alt5 = 3;  				}  				break;  			case 27:  				{  					alt5 = 4;  				}  				break;  			default: {  				NoViableAltException nvae = new NoViableAltException (""' 5' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  			}  		}  		finally {  			DebugExitDecision (5);  		}  		switch (alt5) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:34:4: ID  			{  				DebugLocation (34' 4);  				ID2 = (CommonTree)Match (input' ID' Follow._ID_in_propertyName112);  				DebugLocation (34' 7);  				retval.isRegex = false;  				retval.name = (ID2 != null ? ID2.Text : default(string));  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:38:4: ESC_ID  			{  				DebugLocation (38' 4);  				ESC_ID3 = (CommonTree)Match (input' ESC_ID' Follow._ESC_ID_in_propertyName119);  				DebugLocation (38' 11);  				retval.isRegex = false;  				string stringText = (ESC_ID3 != null ? ESC_ID3.Text : default(string));  				retval.name = stringText.Substring (1' stringText.Length - 2);  			}  			break;  		case 3:  			DebugEnterAlt (3);  			// ./src/Parser/Grammar/JFLWalker.g:43:4: REGEX  			{  				DebugLocation (43' 4);  				REGEX4 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_propertyName126);  				DebugLocation (43' 10);  				retval.isRegex = true;  				string regexText = (REGEX4 != null ? REGEX4.Text : default(string));  				retval.name = regexText.Substring (1' regexText.Length - 2);  			}  			break;  		case 4:  			DebugEnterAlt (4);  			// ./src/Parser/Grammar/JFLWalker.g:48:4: '*'  			{  				DebugLocation (48' 4);  				Match (input' 27' Follow._27_in_propertyName133);  				DebugLocation (48' 8);  				retval.isRegex = false;  				retval.name = "*";  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("propertyName"' 4);  		LeaveRule ("propertyName"' 4);  		LeaveRule_propertyName ();  	}  	DebugLocation (52' 1);  }  finally {  	DebugExitRule (GrammarFileName' "propertyName");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyName,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "propertyName");  	DebugLocation (33' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:34:2: ( ID | ESC_ID | REGEX | '*' )  		int alt5 = 4;  		try {  			DebugEnterDecision (5' false);  			switch (input.LA (1)) {  			case ID:  				{  					alt5 = 1;  				}  				break;  			case ESC_ID:  				{  					alt5 = 2;  				}  				break;  			case REGEX:  				{  					alt5 = 3;  				}  				break;  			case 27:  				{  					alt5 = 4;  				}  				break;  			default: {  				NoViableAltException nvae = new NoViableAltException (""' 5' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  			}  		}  		finally {  			DebugExitDecision (5);  		}  		switch (alt5) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:34:4: ID  			{  				DebugLocation (34' 4);  				ID2 = (CommonTree)Match (input' ID' Follow._ID_in_propertyName112);  				DebugLocation (34' 7);  				retval.isRegex = false;  				retval.name = (ID2 != null ? ID2.Text : default(string));  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:38:4: ESC_ID  			{  				DebugLocation (38' 4);  				ESC_ID3 = (CommonTree)Match (input' ESC_ID' Follow._ESC_ID_in_propertyName119);  				DebugLocation (38' 11);  				retval.isRegex = false;  				string stringText = (ESC_ID3 != null ? ESC_ID3.Text : default(string));  				retval.name = stringText.Substring (1' stringText.Length - 2);  			}  			break;  		case 3:  			DebugEnterAlt (3);  			// ./src/Parser/Grammar/JFLWalker.g:43:4: REGEX  			{  				DebugLocation (43' 4);  				REGEX4 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_propertyName126);  				DebugLocation (43' 10);  				retval.isRegex = true;  				string regexText = (REGEX4 != null ? REGEX4.Text : default(string));  				retval.name = regexText.Substring (1' regexText.Length - 2);  			}  			break;  		case 4:  			DebugEnterAlt (4);  			// ./src/Parser/Grammar/JFLWalker.g:48:4: '*'  			{  				DebugLocation (48' 4);  				Match (input' 27' Follow._27_in_propertyName133);  				DebugLocation (48' 8);  				retval.isRegex = false;  				retval.name = "*";  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("propertyName"' 4);  		LeaveRule ("propertyName"' 4);  		LeaveRule_propertyName ();  	}  	DebugLocation (52' 1);  }  finally {  	DebugExitRule (GrammarFileName' "propertyName");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyName,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "propertyName");  	DebugLocation (33' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:34:2: ( ID | ESC_ID | REGEX | '*' )  		int alt5 = 4;  		try {  			DebugEnterDecision (5' false);  			switch (input.LA (1)) {  			case ID:  				{  					alt5 = 1;  				}  				break;  			case ESC_ID:  				{  					alt5 = 2;  				}  				break;  			case REGEX:  				{  					alt5 = 3;  				}  				break;  			case 27:  				{  					alt5 = 4;  				}  				break;  			default: {  				NoViableAltException nvae = new NoViableAltException (""' 5' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  			}  		}  		finally {  			DebugExitDecision (5);  		}  		switch (alt5) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:34:4: ID  			{  				DebugLocation (34' 4);  				ID2 = (CommonTree)Match (input' ID' Follow._ID_in_propertyName112);  				DebugLocation (34' 7);  				retval.isRegex = false;  				retval.name = (ID2 != null ? ID2.Text : default(string));  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:38:4: ESC_ID  			{  				DebugLocation (38' 4);  				ESC_ID3 = (CommonTree)Match (input' ESC_ID' Follow._ESC_ID_in_propertyName119);  				DebugLocation (38' 11);  				retval.isRegex = false;  				string stringText = (ESC_ID3 != null ? ESC_ID3.Text : default(string));  				retval.name = stringText.Substring (1' stringText.Length - 2);  			}  			break;  		case 3:  			DebugEnterAlt (3);  			// ./src/Parser/Grammar/JFLWalker.g:43:4: REGEX  			{  				DebugLocation (43' 4);  				REGEX4 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_propertyName126);  				DebugLocation (43' 10);  				retval.isRegex = true;  				string regexText = (REGEX4 != null ? REGEX4.Text : default(string));  				retval.name = regexText.Substring (1' regexText.Length - 2);  			}  			break;  		case 4:  			DebugEnterAlt (4);  			// ./src/Parser/Grammar/JFLWalker.g:48:4: '*'  			{  				DebugLocation (48' 4);  				Match (input' 27' Follow._27_in_propertyName133);  				DebugLocation (48' 8);  				retval.isRegex = false;  				retval.name = "*";  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("propertyName"' 4);  		LeaveRule ("propertyName"' 4);  		LeaveRule_propertyName ();  	}  	DebugLocation (52' 1);  }  finally {  	DebugExitRule (GrammarFileName' "propertyName");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyName,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "propertyName");  	DebugLocation (33' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:34:2: ( ID | ESC_ID | REGEX | '*' )  		int alt5 = 4;  		try {  			DebugEnterDecision (5' false);  			switch (input.LA (1)) {  			case ID:  				{  					alt5 = 1;  				}  				break;  			case ESC_ID:  				{  					alt5 = 2;  				}  				break;  			case REGEX:  				{  					alt5 = 3;  				}  				break;  			case 27:  				{  					alt5 = 4;  				}  				break;  			default: {  				NoViableAltException nvae = new NoViableAltException (""' 5' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  			}  		}  		finally {  			DebugExitDecision (5);  		}  		switch (alt5) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:34:4: ID  			{  				DebugLocation (34' 4);  				ID2 = (CommonTree)Match (input' ID' Follow._ID_in_propertyName112);  				DebugLocation (34' 7);  				retval.isRegex = false;  				retval.name = (ID2 != null ? ID2.Text : default(string));  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:38:4: ESC_ID  			{  				DebugLocation (38' 4);  				ESC_ID3 = (CommonTree)Match (input' ESC_ID' Follow._ESC_ID_in_propertyName119);  				DebugLocation (38' 11);  				retval.isRegex = false;  				string stringText = (ESC_ID3 != null ? ESC_ID3.Text : default(string));  				retval.name = stringText.Substring (1' stringText.Length - 2);  			}  			break;  		case 3:  			DebugEnterAlt (3);  			// ./src/Parser/Grammar/JFLWalker.g:43:4: REGEX  			{  				DebugLocation (43' 4);  				REGEX4 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_propertyName126);  				DebugLocation (43' 10);  				retval.isRegex = true;  				string regexText = (REGEX4 != null ? REGEX4.Text : default(string));  				retval.name = regexText.Substring (1' regexText.Length - 2);  			}  			break;  		case 4:  			DebugEnterAlt (4);  			// ./src/Parser/Grammar/JFLWalker.g:48:4: '*'  			{  				DebugLocation (48' 4);  				Match (input' 27' Follow._27_in_propertyName133);  				DebugLocation (48' 8);  				retval.isRegex = false;  				retval.name = "*";  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("propertyName"' 4);  		LeaveRule ("propertyName"' 4);  		LeaveRule_propertyName ();  	}  	DebugLocation (52' 1);  }  finally {  	DebugExitRule (GrammarFileName' "propertyName");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyName,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "propertyName");  	DebugLocation (33' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:34:2: ( ID | ESC_ID | REGEX | '*' )  		int alt5 = 4;  		try {  			DebugEnterDecision (5' false);  			switch (input.LA (1)) {  			case ID:  				{  					alt5 = 1;  				}  				break;  			case ESC_ID:  				{  					alt5 = 2;  				}  				break;  			case REGEX:  				{  					alt5 = 3;  				}  				break;  			case 27:  				{  					alt5 = 4;  				}  				break;  			default: {  				NoViableAltException nvae = new NoViableAltException (""' 5' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  			}  		}  		finally {  			DebugExitDecision (5);  		}  		switch (alt5) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:34:4: ID  			{  				DebugLocation (34' 4);  				ID2 = (CommonTree)Match (input' ID' Follow._ID_in_propertyName112);  				DebugLocation (34' 7);  				retval.isRegex = false;  				retval.name = (ID2 != null ? ID2.Text : default(string));  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:38:4: ESC_ID  			{  				DebugLocation (38' 4);  				ESC_ID3 = (CommonTree)Match (input' ESC_ID' Follow._ESC_ID_in_propertyName119);  				DebugLocation (38' 11);  				retval.isRegex = false;  				string stringText = (ESC_ID3 != null ? ESC_ID3.Text : default(string));  				retval.name = stringText.Substring (1' stringText.Length - 2);  			}  			break;  		case 3:  			DebugEnterAlt (3);  			// ./src/Parser/Grammar/JFLWalker.g:43:4: REGEX  			{  				DebugLocation (43' 4);  				REGEX4 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_propertyName126);  				DebugLocation (43' 10);  				retval.isRegex = true;  				string regexText = (REGEX4 != null ? REGEX4.Text : default(string));  				retval.name = regexText.Substring (1' regexText.Length - 2);  			}  			break;  		case 4:  			DebugEnterAlt (4);  			// ./src/Parser/Grammar/JFLWalker.g:48:4: '*'  			{  				DebugLocation (48' 4);  				Match (input' 27' Follow._27_in_propertyName133);  				DebugLocation (48' 8);  				retval.isRegex = false;  				retval.name = "*";  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("propertyName"' 4);  		LeaveRule ("propertyName"' 4);  		LeaveRule_propertyName ();  	}  	DebugLocation (52' 1);  }  finally {  	DebugExitRule (GrammarFileName' "propertyName");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyName,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "propertyName");  	DebugLocation (33' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:34:2: ( ID | ESC_ID | REGEX | '*' )  		int alt5 = 4;  		try {  			DebugEnterDecision (5' false);  			switch (input.LA (1)) {  			case ID:  				{  					alt5 = 1;  				}  				break;  			case ESC_ID:  				{  					alt5 = 2;  				}  				break;  			case REGEX:  				{  					alt5 = 3;  				}  				break;  			case 27:  				{  					alt5 = 4;  				}  				break;  			default: {  				NoViableAltException nvae = new NoViableAltException (""' 5' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  			}  		}  		finally {  			DebugExitDecision (5);  		}  		switch (alt5) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:34:4: ID  			{  				DebugLocation (34' 4);  				ID2 = (CommonTree)Match (input' ID' Follow._ID_in_propertyName112);  				DebugLocation (34' 7);  				retval.isRegex = false;  				retval.name = (ID2 != null ? ID2.Text : default(string));  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:38:4: ESC_ID  			{  				DebugLocation (38' 4);  				ESC_ID3 = (CommonTree)Match (input' ESC_ID' Follow._ESC_ID_in_propertyName119);  				DebugLocation (38' 11);  				retval.isRegex = false;  				string stringText = (ESC_ID3 != null ? ESC_ID3.Text : default(string));  				retval.name = stringText.Substring (1' stringText.Length - 2);  			}  			break;  		case 3:  			DebugEnterAlt (3);  			// ./src/Parser/Grammar/JFLWalker.g:43:4: REGEX  			{  				DebugLocation (43' 4);  				REGEX4 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_propertyName126);  				DebugLocation (43' 10);  				retval.isRegex = true;  				string regexText = (REGEX4 != null ? REGEX4.Text : default(string));  				retval.name = regexText.Substring (1' regexText.Length - 2);  			}  			break;  		case 4:  			DebugEnterAlt (4);  			// ./src/Parser/Grammar/JFLWalker.g:48:4: '*'  			{  				DebugLocation (48' 4);  				Match (input' 27' Follow._27_in_propertyName133);  				DebugLocation (48' 8);  				retval.isRegex = false;  				retval.name = "*";  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("propertyName"' 4);  		LeaveRule ("propertyName"' 4);  		LeaveRule_propertyName ();  	}  	DebugLocation (52' 1);  }  finally {  	DebugExitRule (GrammarFileName' "propertyName");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyName,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "propertyName");  	DebugLocation (33' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:34:2: ( ID | ESC_ID | REGEX | '*' )  		int alt5 = 4;  		try {  			DebugEnterDecision (5' false);  			switch (input.LA (1)) {  			case ID:  				{  					alt5 = 1;  				}  				break;  			case ESC_ID:  				{  					alt5 = 2;  				}  				break;  			case REGEX:  				{  					alt5 = 3;  				}  				break;  			case 27:  				{  					alt5 = 4;  				}  				break;  			default: {  				NoViableAltException nvae = new NoViableAltException (""' 5' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  			}  		}  		finally {  			DebugExitDecision (5);  		}  		switch (alt5) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:34:4: ID  			{  				DebugLocation (34' 4);  				ID2 = (CommonTree)Match (input' ID' Follow._ID_in_propertyName112);  				DebugLocation (34' 7);  				retval.isRegex = false;  				retval.name = (ID2 != null ? ID2.Text : default(string));  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:38:4: ESC_ID  			{  				DebugLocation (38' 4);  				ESC_ID3 = (CommonTree)Match (input' ESC_ID' Follow._ESC_ID_in_propertyName119);  				DebugLocation (38' 11);  				retval.isRegex = false;  				string stringText = (ESC_ID3 != null ? ESC_ID3.Text : default(string));  				retval.name = stringText.Substring (1' stringText.Length - 2);  			}  			break;  		case 3:  			DebugEnterAlt (3);  			// ./src/Parser/Grammar/JFLWalker.g:43:4: REGEX  			{  				DebugLocation (43' 4);  				REGEX4 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_propertyName126);  				DebugLocation (43' 10);  				retval.isRegex = true;  				string regexText = (REGEX4 != null ? REGEX4.Text : default(string));  				retval.name = regexText.Substring (1' regexText.Length - 2);  			}  			break;  		case 4:  			DebugEnterAlt (4);  			// ./src/Parser/Grammar/JFLWalker.g:48:4: '*'  			{  				DebugLocation (48' 4);  				Match (input' 27' Follow._27_in_propertyName133);  				DebugLocation (48' 8);  				retval.isRegex = false;  				retval.name = "*";  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("propertyName"' 4);  		LeaveRule ("propertyName"' 4);  		LeaveRule_propertyName ();  	}  	DebugLocation (52' 1);  }  finally {  	DebugExitRule (GrammarFileName' "propertyName");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyName,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "propertyName");  	DebugLocation (33' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:34:2: ( ID | ESC_ID | REGEX | '*' )  		int alt5 = 4;  		try {  			DebugEnterDecision (5' false);  			switch (input.LA (1)) {  			case ID:  				{  					alt5 = 1;  				}  				break;  			case ESC_ID:  				{  					alt5 = 2;  				}  				break;  			case REGEX:  				{  					alt5 = 3;  				}  				break;  			case 27:  				{  					alt5 = 4;  				}  				break;  			default: {  				NoViableAltException nvae = new NoViableAltException (""' 5' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  			}  		}  		finally {  			DebugExitDecision (5);  		}  		switch (alt5) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:34:4: ID  			{  				DebugLocation (34' 4);  				ID2 = (CommonTree)Match (input' ID' Follow._ID_in_propertyName112);  				DebugLocation (34' 7);  				retval.isRegex = false;  				retval.name = (ID2 != null ? ID2.Text : default(string));  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:38:4: ESC_ID  			{  				DebugLocation (38' 4);  				ESC_ID3 = (CommonTree)Match (input' ESC_ID' Follow._ESC_ID_in_propertyName119);  				DebugLocation (38' 11);  				retval.isRegex = false;  				string stringText = (ESC_ID3 != null ? ESC_ID3.Text : default(string));  				retval.name = stringText.Substring (1' stringText.Length - 2);  			}  			break;  		case 3:  			DebugEnterAlt (3);  			// ./src/Parser/Grammar/JFLWalker.g:43:4: REGEX  			{  				DebugLocation (43' 4);  				REGEX4 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_propertyName126);  				DebugLocation (43' 10);  				retval.isRegex = true;  				string regexText = (REGEX4 != null ? REGEX4.Text : default(string));  				retval.name = regexText.Substring (1' regexText.Length - 2);  			}  			break;  		case 4:  			DebugEnterAlt (4);  			// ./src/Parser/Grammar/JFLWalker.g:48:4: '*'  			{  				DebugLocation (48' 4);  				Match (input' 27' Follow._27_in_propertyName133);  				DebugLocation (48' 8);  				retval.isRegex = false;  				retval.name = "*";  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("propertyName"' 4);  		LeaveRule ("propertyName"' 4);  		LeaveRule_propertyName ();  	}  	DebugLocation (52' 1);  }  finally {  	DebugExitRule (GrammarFileName' "propertyName");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyName,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "propertyName");  	DebugLocation (33' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:34:2: ( ID | ESC_ID | REGEX | '*' )  		int alt5 = 4;  		try {  			DebugEnterDecision (5' false);  			switch (input.LA (1)) {  			case ID:  				{  					alt5 = 1;  				}  				break;  			case ESC_ID:  				{  					alt5 = 2;  				}  				break;  			case REGEX:  				{  					alt5 = 3;  				}  				break;  			case 27:  				{  					alt5 = 4;  				}  				break;  			default: {  				NoViableAltException nvae = new NoViableAltException (""' 5' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  			}  		}  		finally {  			DebugExitDecision (5);  		}  		switch (alt5) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:34:4: ID  			{  				DebugLocation (34' 4);  				ID2 = (CommonTree)Match (input' ID' Follow._ID_in_propertyName112);  				DebugLocation (34' 7);  				retval.isRegex = false;  				retval.name = (ID2 != null ? ID2.Text : default(string));  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:38:4: ESC_ID  			{  				DebugLocation (38' 4);  				ESC_ID3 = (CommonTree)Match (input' ESC_ID' Follow._ESC_ID_in_propertyName119);  				DebugLocation (38' 11);  				retval.isRegex = false;  				string stringText = (ESC_ID3 != null ? ESC_ID3.Text : default(string));  				retval.name = stringText.Substring (1' stringText.Length - 2);  			}  			break;  		case 3:  			DebugEnterAlt (3);  			// ./src/Parser/Grammar/JFLWalker.g:43:4: REGEX  			{  				DebugLocation (43' 4);  				REGEX4 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_propertyName126);  				DebugLocation (43' 10);  				retval.isRegex = true;  				string regexText = (REGEX4 != null ? REGEX4.Text : default(string));  				retval.name = regexText.Substring (1' regexText.Length - 2);  			}  			break;  		case 4:  			DebugEnterAlt (4);  			// ./src/Parser/Grammar/JFLWalker.g:48:4: '*'  			{  				DebugLocation (48' 4);  				Match (input' 27' Follow._27_in_propertyName133);  				DebugLocation (48' 8);  				retval.isRegex = false;  				retval.name = "*";  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("propertyName"' 4);  		LeaveRule ("propertyName"' 4);  		LeaveRule_propertyName ();  	}  	DebugLocation (52' 1);  }  finally {  	DebugExitRule (GrammarFileName' "propertyName");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyName,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "propertyName");  	DebugLocation (33' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:34:2: ( ID | ESC_ID | REGEX | '*' )  		int alt5 = 4;  		try {  			DebugEnterDecision (5' false);  			switch (input.LA (1)) {  			case ID:  				{  					alt5 = 1;  				}  				break;  			case ESC_ID:  				{  					alt5 = 2;  				}  				break;  			case REGEX:  				{  					alt5 = 3;  				}  				break;  			case 27:  				{  					alt5 = 4;  				}  				break;  			default: {  				NoViableAltException nvae = new NoViableAltException (""' 5' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  			}  		}  		finally {  			DebugExitDecision (5);  		}  		switch (alt5) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:34:4: ID  			{  				DebugLocation (34' 4);  				ID2 = (CommonTree)Match (input' ID' Follow._ID_in_propertyName112);  				DebugLocation (34' 7);  				retval.isRegex = false;  				retval.name = (ID2 != null ? ID2.Text : default(string));  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:38:4: ESC_ID  			{  				DebugLocation (38' 4);  				ESC_ID3 = (CommonTree)Match (input' ESC_ID' Follow._ESC_ID_in_propertyName119);  				DebugLocation (38' 11);  				retval.isRegex = false;  				string stringText = (ESC_ID3 != null ? ESC_ID3.Text : default(string));  				retval.name = stringText.Substring (1' stringText.Length - 2);  			}  			break;  		case 3:  			DebugEnterAlt (3);  			// ./src/Parser/Grammar/JFLWalker.g:43:4: REGEX  			{  				DebugLocation (43' 4);  				REGEX4 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_propertyName126);  				DebugLocation (43' 10);  				retval.isRegex = true;  				string regexText = (REGEX4 != null ? REGEX4.Text : default(string));  				retval.name = regexText.Substring (1' regexText.Length - 2);  			}  			break;  		case 4:  			DebugEnterAlt (4);  			// ./src/Parser/Grammar/JFLWalker.g:48:4: '*'  			{  				DebugLocation (48' 4);  				Match (input' 27' Follow._27_in_propertyName133);  				DebugLocation (48' 8);  				retval.isRegex = false;  				retval.name = "*";  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("propertyName"' 4);  		LeaveRule ("propertyName"' 4);  		LeaveRule_propertyName ();  	}  	DebugLocation (52' 1);  }  finally {  	DebugExitRule (GrammarFileName' "propertyName");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyName,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "propertyName");  	DebugLocation (33' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:34:2: ( ID | ESC_ID | REGEX | '*' )  		int alt5 = 4;  		try {  			DebugEnterDecision (5' false);  			switch (input.LA (1)) {  			case ID:  				{  					alt5 = 1;  				}  				break;  			case ESC_ID:  				{  					alt5 = 2;  				}  				break;  			case REGEX:  				{  					alt5 = 3;  				}  				break;  			case 27:  				{  					alt5 = 4;  				}  				break;  			default: {  				NoViableAltException nvae = new NoViableAltException (""' 5' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  			}  		}  		finally {  			DebugExitDecision (5);  		}  		switch (alt5) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:34:4: ID  			{  				DebugLocation (34' 4);  				ID2 = (CommonTree)Match (input' ID' Follow._ID_in_propertyName112);  				DebugLocation (34' 7);  				retval.isRegex = false;  				retval.name = (ID2 != null ? ID2.Text : default(string));  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:38:4: ESC_ID  			{  				DebugLocation (38' 4);  				ESC_ID3 = (CommonTree)Match (input' ESC_ID' Follow._ESC_ID_in_propertyName119);  				DebugLocation (38' 11);  				retval.isRegex = false;  				string stringText = (ESC_ID3 != null ? ESC_ID3.Text : default(string));  				retval.name = stringText.Substring (1' stringText.Length - 2);  			}  			break;  		case 3:  			DebugEnterAlt (3);  			// ./src/Parser/Grammar/JFLWalker.g:43:4: REGEX  			{  				DebugLocation (43' 4);  				REGEX4 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_propertyName126);  				DebugLocation (43' 10);  				retval.isRegex = true;  				string regexText = (REGEX4 != null ? REGEX4.Text : default(string));  				retval.name = regexText.Substring (1' regexText.Length - 2);  			}  			break;  		case 4:  			DebugEnterAlt (4);  			// ./src/Parser/Grammar/JFLWalker.g:48:4: '*'  			{  				DebugLocation (48' 4);  				Match (input' 27' Follow._27_in_propertyName133);  				DebugLocation (48' 8);  				retval.isRegex = false;  				retval.name = "*";  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("propertyName"' 4);  		LeaveRule ("propertyName"' 4);  		LeaveRule_propertyName ();  	}  	DebugLocation (52' 1);  }  finally {  	DebugExitRule (GrammarFileName' "propertyName");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyName,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "propertyName");  	DebugLocation (33' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:34:2: ( ID | ESC_ID | REGEX | '*' )  		int alt5 = 4;  		try {  			DebugEnterDecision (5' false);  			switch (input.LA (1)) {  			case ID:  				{  					alt5 = 1;  				}  				break;  			case ESC_ID:  				{  					alt5 = 2;  				}  				break;  			case REGEX:  				{  					alt5 = 3;  				}  				break;  			case 27:  				{  					alt5 = 4;  				}  				break;  			default: {  				NoViableAltException nvae = new NoViableAltException (""' 5' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  			}  		}  		finally {  			DebugExitDecision (5);  		}  		switch (alt5) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:34:4: ID  			{  				DebugLocation (34' 4);  				ID2 = (CommonTree)Match (input' ID' Follow._ID_in_propertyName112);  				DebugLocation (34' 7);  				retval.isRegex = false;  				retval.name = (ID2 != null ? ID2.Text : default(string));  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:38:4: ESC_ID  			{  				DebugLocation (38' 4);  				ESC_ID3 = (CommonTree)Match (input' ESC_ID' Follow._ESC_ID_in_propertyName119);  				DebugLocation (38' 11);  				retval.isRegex = false;  				string stringText = (ESC_ID3 != null ? ESC_ID3.Text : default(string));  				retval.name = stringText.Substring (1' stringText.Length - 2);  			}  			break;  		case 3:  			DebugEnterAlt (3);  			// ./src/Parser/Grammar/JFLWalker.g:43:4: REGEX  			{  				DebugLocation (43' 4);  				REGEX4 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_propertyName126);  				DebugLocation (43' 10);  				retval.isRegex = true;  				string regexText = (REGEX4 != null ? REGEX4.Text : default(string));  				retval.name = regexText.Substring (1' regexText.Length - 2);  			}  			break;  		case 4:  			DebugEnterAlt (4);  			// ./src/Parser/Grammar/JFLWalker.g:48:4: '*'  			{  				DebugLocation (48' 4);  				Match (input' 27' Follow._27_in_propertyName133);  				DebugLocation (48' 8);  				retval.isRegex = false;  				retval.name = "*";  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("propertyName"' 4);  		LeaveRule ("propertyName"' 4);  		LeaveRule_propertyName ();  	}  	DebugLocation (52' 1);  }  finally {  	DebugExitRule (GrammarFileName' "propertyName");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyName,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "propertyName");  	DebugLocation (33' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:34:2: ( ID | ESC_ID | REGEX | '*' )  		int alt5 = 4;  		try {  			DebugEnterDecision (5' false);  			switch (input.LA (1)) {  			case ID:  				{  					alt5 = 1;  				}  				break;  			case ESC_ID:  				{  					alt5 = 2;  				}  				break;  			case REGEX:  				{  					alt5 = 3;  				}  				break;  			case 27:  				{  					alt5 = 4;  				}  				break;  			default: {  				NoViableAltException nvae = new NoViableAltException (""' 5' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  			}  		}  		finally {  			DebugExitDecision (5);  		}  		switch (alt5) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:34:4: ID  			{  				DebugLocation (34' 4);  				ID2 = (CommonTree)Match (input' ID' Follow._ID_in_propertyName112);  				DebugLocation (34' 7);  				retval.isRegex = false;  				retval.name = (ID2 != null ? ID2.Text : default(string));  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:38:4: ESC_ID  			{  				DebugLocation (38' 4);  				ESC_ID3 = (CommonTree)Match (input' ESC_ID' Follow._ESC_ID_in_propertyName119);  				DebugLocation (38' 11);  				retval.isRegex = false;  				string stringText = (ESC_ID3 != null ? ESC_ID3.Text : default(string));  				retval.name = stringText.Substring (1' stringText.Length - 2);  			}  			break;  		case 3:  			DebugEnterAlt (3);  			// ./src/Parser/Grammar/JFLWalker.g:43:4: REGEX  			{  				DebugLocation (43' 4);  				REGEX4 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_propertyName126);  				DebugLocation (43' 10);  				retval.isRegex = true;  				string regexText = (REGEX4 != null ? REGEX4.Text : default(string));  				retval.name = regexText.Substring (1' regexText.Length - 2);  			}  			break;  		case 4:  			DebugEnterAlt (4);  			// ./src/Parser/Grammar/JFLWalker.g:48:4: '*'  			{  				DebugLocation (48' 4);  				Match (input' 27' Follow._27_in_propertyName133);  				DebugLocation (48' 8);  				retval.isRegex = false;  				retval.name = "*";  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("propertyName"' 4);  		LeaveRule ("propertyName"' 4);  		LeaveRule_propertyName ();  	}  	DebugLocation (52' 1);  }  finally {  	DebugExitRule (GrammarFileName' "propertyName");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyName,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "propertyName");  	DebugLocation (33' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:34:2: ( ID | ESC_ID | REGEX | '*' )  		int alt5 = 4;  		try {  			DebugEnterDecision (5' false);  			switch (input.LA (1)) {  			case ID:  				{  					alt5 = 1;  				}  				break;  			case ESC_ID:  				{  					alt5 = 2;  				}  				break;  			case REGEX:  				{  					alt5 = 3;  				}  				break;  			case 27:  				{  					alt5 = 4;  				}  				break;  			default: {  				NoViableAltException nvae = new NoViableAltException (""' 5' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  			}  		}  		finally {  			DebugExitDecision (5);  		}  		switch (alt5) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:34:4: ID  			{  				DebugLocation (34' 4);  				ID2 = (CommonTree)Match (input' ID' Follow._ID_in_propertyName112);  				DebugLocation (34' 7);  				retval.isRegex = false;  				retval.name = (ID2 != null ? ID2.Text : default(string));  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:38:4: ESC_ID  			{  				DebugLocation (38' 4);  				ESC_ID3 = (CommonTree)Match (input' ESC_ID' Follow._ESC_ID_in_propertyName119);  				DebugLocation (38' 11);  				retval.isRegex = false;  				string stringText = (ESC_ID3 != null ? ESC_ID3.Text : default(string));  				retval.name = stringText.Substring (1' stringText.Length - 2);  			}  			break;  		case 3:  			DebugEnterAlt (3);  			// ./src/Parser/Grammar/JFLWalker.g:43:4: REGEX  			{  				DebugLocation (43' 4);  				REGEX4 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_propertyName126);  				DebugLocation (43' 10);  				retval.isRegex = true;  				string regexText = (REGEX4 != null ? REGEX4.Text : default(string));  				retval.name = regexText.Substring (1' regexText.Length - 2);  			}  			break;  		case 4:  			DebugEnterAlt (4);  			// ./src/Parser/Grammar/JFLWalker.g:48:4: '*'  			{  				DebugLocation (48' 4);  				Match (input' 27' Follow._27_in_propertyName133);  				DebugLocation (48' 8);  				retval.isRegex = false;  				retval.name = "*";  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("propertyName"' 4);  		LeaveRule ("propertyName"' 4);  		LeaveRule_propertyName ();  	}  	DebugLocation (52' 1);  }  finally {  	DebugExitRule (GrammarFileName' "propertyName");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyName,The following statement contains a magic number: DebugLocation (33' 1);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyName,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:34:2: ( ID | ESC_ID | REGEX | '*' )  	int alt5 = 4;  	try {  		DebugEnterDecision (5' false);  		switch (input.LA (1)) {  		case ID:  			{  				alt5 = 1;  			}  			break;  		case ESC_ID:  			{  				alt5 = 2;  			}  			break;  		case REGEX:  			{  				alt5 = 3;  			}  			break;  		case 27:  			{  				alt5 = 4;  			}  			break;  		default: {  			NoViableAltException nvae = new NoViableAltException (""' 5' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  		}  	}  	finally {  		DebugExitDecision (5);  	}  	switch (alt5) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:34:4: ID  		{  			DebugLocation (34' 4);  			ID2 = (CommonTree)Match (input' ID' Follow._ID_in_propertyName112);  			DebugLocation (34' 7);  			retval.isRegex = false;  			retval.name = (ID2 != null ? ID2.Text : default(string));  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:38:4: ESC_ID  		{  			DebugLocation (38' 4);  			ESC_ID3 = (CommonTree)Match (input' ESC_ID' Follow._ESC_ID_in_propertyName119);  			DebugLocation (38' 11);  			retval.isRegex = false;  			string stringText = (ESC_ID3 != null ? ESC_ID3.Text : default(string));  			retval.name = stringText.Substring (1' stringText.Length - 2);  		}  		break;  	case 3:  		DebugEnterAlt (3);  		// ./src/Parser/Grammar/JFLWalker.g:43:4: REGEX  		{  			DebugLocation (43' 4);  			REGEX4 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_propertyName126);  			DebugLocation (43' 10);  			retval.isRegex = true;  			string regexText = (REGEX4 != null ? REGEX4.Text : default(string));  			retval.name = regexText.Substring (1' regexText.Length - 2);  		}  		break;  	case 4:  		DebugEnterAlt (4);  		// ./src/Parser/Grammar/JFLWalker.g:48:4: '*'  		{  			DebugLocation (48' 4);  			Match (input' 27' Follow._27_in_propertyName133);  			DebugLocation (48' 8);  			retval.isRegex = false;  			retval.name = "*";  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("propertyName"' 4);  	LeaveRule ("propertyName"' 4);  	LeaveRule_propertyName ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyName,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:34:2: ( ID | ESC_ID | REGEX | '*' )  	int alt5 = 4;  	try {  		DebugEnterDecision (5' false);  		switch (input.LA (1)) {  		case ID:  			{  				alt5 = 1;  			}  			break;  		case ESC_ID:  			{  				alt5 = 2;  			}  			break;  		case REGEX:  			{  				alt5 = 3;  			}  			break;  		case 27:  			{  				alt5 = 4;  			}  			break;  		default: {  			NoViableAltException nvae = new NoViableAltException (""' 5' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  		}  	}  	finally {  		DebugExitDecision (5);  	}  	switch (alt5) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:34:4: ID  		{  			DebugLocation (34' 4);  			ID2 = (CommonTree)Match (input' ID' Follow._ID_in_propertyName112);  			DebugLocation (34' 7);  			retval.isRegex = false;  			retval.name = (ID2 != null ? ID2.Text : default(string));  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:38:4: ESC_ID  		{  			DebugLocation (38' 4);  			ESC_ID3 = (CommonTree)Match (input' ESC_ID' Follow._ESC_ID_in_propertyName119);  			DebugLocation (38' 11);  			retval.isRegex = false;  			string stringText = (ESC_ID3 != null ? ESC_ID3.Text : default(string));  			retval.name = stringText.Substring (1' stringText.Length - 2);  		}  		break;  	case 3:  		DebugEnterAlt (3);  		// ./src/Parser/Grammar/JFLWalker.g:43:4: REGEX  		{  			DebugLocation (43' 4);  			REGEX4 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_propertyName126);  			DebugLocation (43' 10);  			retval.isRegex = true;  			string regexText = (REGEX4 != null ? REGEX4.Text : default(string));  			retval.name = regexText.Substring (1' regexText.Length - 2);  		}  		break;  	case 4:  		DebugEnterAlt (4);  		// ./src/Parser/Grammar/JFLWalker.g:48:4: '*'  		{  			DebugLocation (48' 4);  			Match (input' 27' Follow._27_in_propertyName133);  			DebugLocation (48' 8);  			retval.isRegex = false;  			retval.name = "*";  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("propertyName"' 4);  	LeaveRule ("propertyName"' 4);  	LeaveRule_propertyName ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyName,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:34:2: ( ID | ESC_ID | REGEX | '*' )  	int alt5 = 4;  	try {  		DebugEnterDecision (5' false);  		switch (input.LA (1)) {  		case ID:  			{  				alt5 = 1;  			}  			break;  		case ESC_ID:  			{  				alt5 = 2;  			}  			break;  		case REGEX:  			{  				alt5 = 3;  			}  			break;  		case 27:  			{  				alt5 = 4;  			}  			break;  		default: {  			NoViableAltException nvae = new NoViableAltException (""' 5' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  		}  	}  	finally {  		DebugExitDecision (5);  	}  	switch (alt5) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:34:4: ID  		{  			DebugLocation (34' 4);  			ID2 = (CommonTree)Match (input' ID' Follow._ID_in_propertyName112);  			DebugLocation (34' 7);  			retval.isRegex = false;  			retval.name = (ID2 != null ? ID2.Text : default(string));  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:38:4: ESC_ID  		{  			DebugLocation (38' 4);  			ESC_ID3 = (CommonTree)Match (input' ESC_ID' Follow._ESC_ID_in_propertyName119);  			DebugLocation (38' 11);  			retval.isRegex = false;  			string stringText = (ESC_ID3 != null ? ESC_ID3.Text : default(string));  			retval.name = stringText.Substring (1' stringText.Length - 2);  		}  		break;  	case 3:  		DebugEnterAlt (3);  		// ./src/Parser/Grammar/JFLWalker.g:43:4: REGEX  		{  			DebugLocation (43' 4);  			REGEX4 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_propertyName126);  			DebugLocation (43' 10);  			retval.isRegex = true;  			string regexText = (REGEX4 != null ? REGEX4.Text : default(string));  			retval.name = regexText.Substring (1' regexText.Length - 2);  		}  		break;  	case 4:  		DebugEnterAlt (4);  		// ./src/Parser/Grammar/JFLWalker.g:48:4: '*'  		{  			DebugLocation (48' 4);  			Match (input' 27' Follow._27_in_propertyName133);  			DebugLocation (48' 8);  			retval.isRegex = false;  			retval.name = "*";  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("propertyName"' 4);  	LeaveRule ("propertyName"' 4);  	LeaveRule_propertyName ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyName,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:34:2: ( ID | ESC_ID | REGEX | '*' )  	int alt5 = 4;  	try {  		DebugEnterDecision (5' false);  		switch (input.LA (1)) {  		case ID:  			{  				alt5 = 1;  			}  			break;  		case ESC_ID:  			{  				alt5 = 2;  			}  			break;  		case REGEX:  			{  				alt5 = 3;  			}  			break;  		case 27:  			{  				alt5 = 4;  			}  			break;  		default: {  			NoViableAltException nvae = new NoViableAltException (""' 5' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  		}  	}  	finally {  		DebugExitDecision (5);  	}  	switch (alt5) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:34:4: ID  		{  			DebugLocation (34' 4);  			ID2 = (CommonTree)Match (input' ID' Follow._ID_in_propertyName112);  			DebugLocation (34' 7);  			retval.isRegex = false;  			retval.name = (ID2 != null ? ID2.Text : default(string));  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:38:4: ESC_ID  		{  			DebugLocation (38' 4);  			ESC_ID3 = (CommonTree)Match (input' ESC_ID' Follow._ESC_ID_in_propertyName119);  			DebugLocation (38' 11);  			retval.isRegex = false;  			string stringText = (ESC_ID3 != null ? ESC_ID3.Text : default(string));  			retval.name = stringText.Substring (1' stringText.Length - 2);  		}  		break;  	case 3:  		DebugEnterAlt (3);  		// ./src/Parser/Grammar/JFLWalker.g:43:4: REGEX  		{  			DebugLocation (43' 4);  			REGEX4 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_propertyName126);  			DebugLocation (43' 10);  			retval.isRegex = true;  			string regexText = (REGEX4 != null ? REGEX4.Text : default(string));  			retval.name = regexText.Substring (1' regexText.Length - 2);  		}  		break;  	case 4:  		DebugEnterAlt (4);  		// ./src/Parser/Grammar/JFLWalker.g:48:4: '*'  		{  			DebugLocation (48' 4);  			Match (input' 27' Follow._27_in_propertyName133);  			DebugLocation (48' 8);  			retval.isRegex = false;  			retval.name = "*";  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("propertyName"' 4);  	LeaveRule ("propertyName"' 4);  	LeaveRule_propertyName ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyName,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:34:2: ( ID | ESC_ID | REGEX | '*' )  	int alt5 = 4;  	try {  		DebugEnterDecision (5' false);  		switch (input.LA (1)) {  		case ID:  			{  				alt5 = 1;  			}  			break;  		case ESC_ID:  			{  				alt5 = 2;  			}  			break;  		case REGEX:  			{  				alt5 = 3;  			}  			break;  		case 27:  			{  				alt5 = 4;  			}  			break;  		default: {  			NoViableAltException nvae = new NoViableAltException (""' 5' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  		}  	}  	finally {  		DebugExitDecision (5);  	}  	switch (alt5) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:34:4: ID  		{  			DebugLocation (34' 4);  			ID2 = (CommonTree)Match (input' ID' Follow._ID_in_propertyName112);  			DebugLocation (34' 7);  			retval.isRegex = false;  			retval.name = (ID2 != null ? ID2.Text : default(string));  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:38:4: ESC_ID  		{  			DebugLocation (38' 4);  			ESC_ID3 = (CommonTree)Match (input' ESC_ID' Follow._ESC_ID_in_propertyName119);  			DebugLocation (38' 11);  			retval.isRegex = false;  			string stringText = (ESC_ID3 != null ? ESC_ID3.Text : default(string));  			retval.name = stringText.Substring (1' stringText.Length - 2);  		}  		break;  	case 3:  		DebugEnterAlt (3);  		// ./src/Parser/Grammar/JFLWalker.g:43:4: REGEX  		{  			DebugLocation (43' 4);  			REGEX4 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_propertyName126);  			DebugLocation (43' 10);  			retval.isRegex = true;  			string regexText = (REGEX4 != null ? REGEX4.Text : default(string));  			retval.name = regexText.Substring (1' regexText.Length - 2);  		}  		break;  	case 4:  		DebugEnterAlt (4);  		// ./src/Parser/Grammar/JFLWalker.g:48:4: '*'  		{  			DebugLocation (48' 4);  			Match (input' 27' Follow._27_in_propertyName133);  			DebugLocation (48' 8);  			retval.isRegex = false;  			retval.name = "*";  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("propertyName"' 4);  	LeaveRule ("propertyName"' 4);  	LeaveRule_propertyName ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyName,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:34:2: ( ID | ESC_ID | REGEX | '*' )  	int alt5 = 4;  	try {  		DebugEnterDecision (5' false);  		switch (input.LA (1)) {  		case ID:  			{  				alt5 = 1;  			}  			break;  		case ESC_ID:  			{  				alt5 = 2;  			}  			break;  		case REGEX:  			{  				alt5 = 3;  			}  			break;  		case 27:  			{  				alt5 = 4;  			}  			break;  		default: {  			NoViableAltException nvae = new NoViableAltException (""' 5' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  		}  	}  	finally {  		DebugExitDecision (5);  	}  	switch (alt5) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:34:4: ID  		{  			DebugLocation (34' 4);  			ID2 = (CommonTree)Match (input' ID' Follow._ID_in_propertyName112);  			DebugLocation (34' 7);  			retval.isRegex = false;  			retval.name = (ID2 != null ? ID2.Text : default(string));  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:38:4: ESC_ID  		{  			DebugLocation (38' 4);  			ESC_ID3 = (CommonTree)Match (input' ESC_ID' Follow._ESC_ID_in_propertyName119);  			DebugLocation (38' 11);  			retval.isRegex = false;  			string stringText = (ESC_ID3 != null ? ESC_ID3.Text : default(string));  			retval.name = stringText.Substring (1' stringText.Length - 2);  		}  		break;  	case 3:  		DebugEnterAlt (3);  		// ./src/Parser/Grammar/JFLWalker.g:43:4: REGEX  		{  			DebugLocation (43' 4);  			REGEX4 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_propertyName126);  			DebugLocation (43' 10);  			retval.isRegex = true;  			string regexText = (REGEX4 != null ? REGEX4.Text : default(string));  			retval.name = regexText.Substring (1' regexText.Length - 2);  		}  		break;  	case 4:  		DebugEnterAlt (4);  		// ./src/Parser/Grammar/JFLWalker.g:48:4: '*'  		{  			DebugLocation (48' 4);  			Match (input' 27' Follow._27_in_propertyName133);  			DebugLocation (48' 8);  			retval.isRegex = false;  			retval.name = "*";  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("propertyName"' 4);  	LeaveRule ("propertyName"' 4);  	LeaveRule_propertyName ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyName,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:34:2: ( ID | ESC_ID | REGEX | '*' )  	int alt5 = 4;  	try {  		DebugEnterDecision (5' false);  		switch (input.LA (1)) {  		case ID:  			{  				alt5 = 1;  			}  			break;  		case ESC_ID:  			{  				alt5 = 2;  			}  			break;  		case REGEX:  			{  				alt5 = 3;  			}  			break;  		case 27:  			{  				alt5 = 4;  			}  			break;  		default: {  			NoViableAltException nvae = new NoViableAltException (""' 5' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  		}  	}  	finally {  		DebugExitDecision (5);  	}  	switch (alt5) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:34:4: ID  		{  			DebugLocation (34' 4);  			ID2 = (CommonTree)Match (input' ID' Follow._ID_in_propertyName112);  			DebugLocation (34' 7);  			retval.isRegex = false;  			retval.name = (ID2 != null ? ID2.Text : default(string));  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:38:4: ESC_ID  		{  			DebugLocation (38' 4);  			ESC_ID3 = (CommonTree)Match (input' ESC_ID' Follow._ESC_ID_in_propertyName119);  			DebugLocation (38' 11);  			retval.isRegex = false;  			string stringText = (ESC_ID3 != null ? ESC_ID3.Text : default(string));  			retval.name = stringText.Substring (1' stringText.Length - 2);  		}  		break;  	case 3:  		DebugEnterAlt (3);  		// ./src/Parser/Grammar/JFLWalker.g:43:4: REGEX  		{  			DebugLocation (43' 4);  			REGEX4 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_propertyName126);  			DebugLocation (43' 10);  			retval.isRegex = true;  			string regexText = (REGEX4 != null ? REGEX4.Text : default(string));  			retval.name = regexText.Substring (1' regexText.Length - 2);  		}  		break;  	case 4:  		DebugEnterAlt (4);  		// ./src/Parser/Grammar/JFLWalker.g:48:4: '*'  		{  			DebugLocation (48' 4);  			Match (input' 27' Follow._27_in_propertyName133);  			DebugLocation (48' 8);  			retval.isRegex = false;  			retval.name = "*";  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("propertyName"' 4);  	LeaveRule ("propertyName"' 4);  	LeaveRule_propertyName ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyName,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:34:2: ( ID | ESC_ID | REGEX | '*' )  	int alt5 = 4;  	try {  		DebugEnterDecision (5' false);  		switch (input.LA (1)) {  		case ID:  			{  				alt5 = 1;  			}  			break;  		case ESC_ID:  			{  				alt5 = 2;  			}  			break;  		case REGEX:  			{  				alt5 = 3;  			}  			break;  		case 27:  			{  				alt5 = 4;  			}  			break;  		default: {  			NoViableAltException nvae = new NoViableAltException (""' 5' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  		}  	}  	finally {  		DebugExitDecision (5);  	}  	switch (alt5) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:34:4: ID  		{  			DebugLocation (34' 4);  			ID2 = (CommonTree)Match (input' ID' Follow._ID_in_propertyName112);  			DebugLocation (34' 7);  			retval.isRegex = false;  			retval.name = (ID2 != null ? ID2.Text : default(string));  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:38:4: ESC_ID  		{  			DebugLocation (38' 4);  			ESC_ID3 = (CommonTree)Match (input' ESC_ID' Follow._ESC_ID_in_propertyName119);  			DebugLocation (38' 11);  			retval.isRegex = false;  			string stringText = (ESC_ID3 != null ? ESC_ID3.Text : default(string));  			retval.name = stringText.Substring (1' stringText.Length - 2);  		}  		break;  	case 3:  		DebugEnterAlt (3);  		// ./src/Parser/Grammar/JFLWalker.g:43:4: REGEX  		{  			DebugLocation (43' 4);  			REGEX4 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_propertyName126);  			DebugLocation (43' 10);  			retval.isRegex = true;  			string regexText = (REGEX4 != null ? REGEX4.Text : default(string));  			retval.name = regexText.Substring (1' regexText.Length - 2);  		}  		break;  	case 4:  		DebugEnterAlt (4);  		// ./src/Parser/Grammar/JFLWalker.g:48:4: '*'  		{  			DebugLocation (48' 4);  			Match (input' 27' Follow._27_in_propertyName133);  			DebugLocation (48' 8);  			retval.isRegex = false;  			retval.name = "*";  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("propertyName"' 4);  	LeaveRule ("propertyName"' 4);  	LeaveRule_propertyName ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyName,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:34:2: ( ID | ESC_ID | REGEX | '*' )  	int alt5 = 4;  	try {  		DebugEnterDecision (5' false);  		switch (input.LA (1)) {  		case ID:  			{  				alt5 = 1;  			}  			break;  		case ESC_ID:  			{  				alt5 = 2;  			}  			break;  		case REGEX:  			{  				alt5 = 3;  			}  			break;  		case 27:  			{  				alt5 = 4;  			}  			break;  		default: {  			NoViableAltException nvae = new NoViableAltException (""' 5' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  		}  	}  	finally {  		DebugExitDecision (5);  	}  	switch (alt5) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:34:4: ID  		{  			DebugLocation (34' 4);  			ID2 = (CommonTree)Match (input' ID' Follow._ID_in_propertyName112);  			DebugLocation (34' 7);  			retval.isRegex = false;  			retval.name = (ID2 != null ? ID2.Text : default(string));  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:38:4: ESC_ID  		{  			DebugLocation (38' 4);  			ESC_ID3 = (CommonTree)Match (input' ESC_ID' Follow._ESC_ID_in_propertyName119);  			DebugLocation (38' 11);  			retval.isRegex = false;  			string stringText = (ESC_ID3 != null ? ESC_ID3.Text : default(string));  			retval.name = stringText.Substring (1' stringText.Length - 2);  		}  		break;  	case 3:  		DebugEnterAlt (3);  		// ./src/Parser/Grammar/JFLWalker.g:43:4: REGEX  		{  			DebugLocation (43' 4);  			REGEX4 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_propertyName126);  			DebugLocation (43' 10);  			retval.isRegex = true;  			string regexText = (REGEX4 != null ? REGEX4.Text : default(string));  			retval.name = regexText.Substring (1' regexText.Length - 2);  		}  		break;  	case 4:  		DebugEnterAlt (4);  		// ./src/Parser/Grammar/JFLWalker.g:48:4: '*'  		{  			DebugLocation (48' 4);  			Match (input' 27' Follow._27_in_propertyName133);  			DebugLocation (48' 8);  			retval.isRegex = false;  			retval.name = "*";  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("propertyName"' 4);  	LeaveRule ("propertyName"' 4);  	LeaveRule_propertyName ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyName,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:34:2: ( ID | ESC_ID | REGEX | '*' )  	int alt5 = 4;  	try {  		DebugEnterDecision (5' false);  		switch (input.LA (1)) {  		case ID:  			{  				alt5 = 1;  			}  			break;  		case ESC_ID:  			{  				alt5 = 2;  			}  			break;  		case REGEX:  			{  				alt5 = 3;  			}  			break;  		case 27:  			{  				alt5 = 4;  			}  			break;  		default: {  			NoViableAltException nvae = new NoViableAltException (""' 5' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  		}  	}  	finally {  		DebugExitDecision (5);  	}  	switch (alt5) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:34:4: ID  		{  			DebugLocation (34' 4);  			ID2 = (CommonTree)Match (input' ID' Follow._ID_in_propertyName112);  			DebugLocation (34' 7);  			retval.isRegex = false;  			retval.name = (ID2 != null ? ID2.Text : default(string));  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:38:4: ESC_ID  		{  			DebugLocation (38' 4);  			ESC_ID3 = (CommonTree)Match (input' ESC_ID' Follow._ESC_ID_in_propertyName119);  			DebugLocation (38' 11);  			retval.isRegex = false;  			string stringText = (ESC_ID3 != null ? ESC_ID3.Text : default(string));  			retval.name = stringText.Substring (1' stringText.Length - 2);  		}  		break;  	case 3:  		DebugEnterAlt (3);  		// ./src/Parser/Grammar/JFLWalker.g:43:4: REGEX  		{  			DebugLocation (43' 4);  			REGEX4 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_propertyName126);  			DebugLocation (43' 10);  			retval.isRegex = true;  			string regexText = (REGEX4 != null ? REGEX4.Text : default(string));  			retval.name = regexText.Substring (1' regexText.Length - 2);  		}  		break;  	case 4:  		DebugEnterAlt (4);  		// ./src/Parser/Grammar/JFLWalker.g:48:4: '*'  		{  			DebugLocation (48' 4);  			Match (input' 27' Follow._27_in_propertyName133);  			DebugLocation (48' 8);  			retval.isRegex = false;  			retval.name = "*";  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("propertyName"' 4);  	LeaveRule ("propertyName"' 4);  	LeaveRule_propertyName ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyName,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:34:2: ( ID | ESC_ID | REGEX | '*' )  	int alt5 = 4;  	try {  		DebugEnterDecision (5' false);  		switch (input.LA (1)) {  		case ID:  			{  				alt5 = 1;  			}  			break;  		case ESC_ID:  			{  				alt5 = 2;  			}  			break;  		case REGEX:  			{  				alt5 = 3;  			}  			break;  		case 27:  			{  				alt5 = 4;  			}  			break;  		default: {  			NoViableAltException nvae = new NoViableAltException (""' 5' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  		}  	}  	finally {  		DebugExitDecision (5);  	}  	switch (alt5) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:34:4: ID  		{  			DebugLocation (34' 4);  			ID2 = (CommonTree)Match (input' ID' Follow._ID_in_propertyName112);  			DebugLocation (34' 7);  			retval.isRegex = false;  			retval.name = (ID2 != null ? ID2.Text : default(string));  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:38:4: ESC_ID  		{  			DebugLocation (38' 4);  			ESC_ID3 = (CommonTree)Match (input' ESC_ID' Follow._ESC_ID_in_propertyName119);  			DebugLocation (38' 11);  			retval.isRegex = false;  			string stringText = (ESC_ID3 != null ? ESC_ID3.Text : default(string));  			retval.name = stringText.Substring (1' stringText.Length - 2);  		}  		break;  	case 3:  		DebugEnterAlt (3);  		// ./src/Parser/Grammar/JFLWalker.g:43:4: REGEX  		{  			DebugLocation (43' 4);  			REGEX4 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_propertyName126);  			DebugLocation (43' 10);  			retval.isRegex = true;  			string regexText = (REGEX4 != null ? REGEX4.Text : default(string));  			retval.name = regexText.Substring (1' regexText.Length - 2);  		}  		break;  	case 4:  		DebugEnterAlt (4);  		// ./src/Parser/Grammar/JFLWalker.g:48:4: '*'  		{  			DebugLocation (48' 4);  			Match (input' 27' Follow._27_in_propertyName133);  			DebugLocation (48' 8);  			retval.isRegex = false;  			retval.name = "*";  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("propertyName"' 4);  	LeaveRule ("propertyName"' 4);  	LeaveRule_propertyName ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyName,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:34:2: ( ID | ESC_ID | REGEX | '*' )  	int alt5 = 4;  	try {  		DebugEnterDecision (5' false);  		switch (input.LA (1)) {  		case ID:  			{  				alt5 = 1;  			}  			break;  		case ESC_ID:  			{  				alt5 = 2;  			}  			break;  		case REGEX:  			{  				alt5 = 3;  			}  			break;  		case 27:  			{  				alt5 = 4;  			}  			break;  		default: {  			NoViableAltException nvae = new NoViableAltException (""' 5' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  		}  	}  	finally {  		DebugExitDecision (5);  	}  	switch (alt5) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:34:4: ID  		{  			DebugLocation (34' 4);  			ID2 = (CommonTree)Match (input' ID' Follow._ID_in_propertyName112);  			DebugLocation (34' 7);  			retval.isRegex = false;  			retval.name = (ID2 != null ? ID2.Text : default(string));  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:38:4: ESC_ID  		{  			DebugLocation (38' 4);  			ESC_ID3 = (CommonTree)Match (input' ESC_ID' Follow._ESC_ID_in_propertyName119);  			DebugLocation (38' 11);  			retval.isRegex = false;  			string stringText = (ESC_ID3 != null ? ESC_ID3.Text : default(string));  			retval.name = stringText.Substring (1' stringText.Length - 2);  		}  		break;  	case 3:  		DebugEnterAlt (3);  		// ./src/Parser/Grammar/JFLWalker.g:43:4: REGEX  		{  			DebugLocation (43' 4);  			REGEX4 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_propertyName126);  			DebugLocation (43' 10);  			retval.isRegex = true;  			string regexText = (REGEX4 != null ? REGEX4.Text : default(string));  			retval.name = regexText.Substring (1' regexText.Length - 2);  		}  		break;  	case 4:  		DebugEnterAlt (4);  		// ./src/Parser/Grammar/JFLWalker.g:48:4: '*'  		{  			DebugLocation (48' 4);  			Match (input' 27' Follow._27_in_propertyName133);  			DebugLocation (48' 8);  			retval.isRegex = false;  			retval.name = "*";  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("propertyName"' 4);  	LeaveRule ("propertyName"' 4);  	LeaveRule_propertyName ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyName,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:34:2: ( ID | ESC_ID | REGEX | '*' )  	int alt5 = 4;  	try {  		DebugEnterDecision (5' false);  		switch (input.LA (1)) {  		case ID:  			{  				alt5 = 1;  			}  			break;  		case ESC_ID:  			{  				alt5 = 2;  			}  			break;  		case REGEX:  			{  				alt5 = 3;  			}  			break;  		case 27:  			{  				alt5 = 4;  			}  			break;  		default: {  			NoViableAltException nvae = new NoViableAltException (""' 5' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  		}  	}  	finally {  		DebugExitDecision (5);  	}  	switch (alt5) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:34:4: ID  		{  			DebugLocation (34' 4);  			ID2 = (CommonTree)Match (input' ID' Follow._ID_in_propertyName112);  			DebugLocation (34' 7);  			retval.isRegex = false;  			retval.name = (ID2 != null ? ID2.Text : default(string));  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:38:4: ESC_ID  		{  			DebugLocation (38' 4);  			ESC_ID3 = (CommonTree)Match (input' ESC_ID' Follow._ESC_ID_in_propertyName119);  			DebugLocation (38' 11);  			retval.isRegex = false;  			string stringText = (ESC_ID3 != null ? ESC_ID3.Text : default(string));  			retval.name = stringText.Substring (1' stringText.Length - 2);  		}  		break;  	case 3:  		DebugEnterAlt (3);  		// ./src/Parser/Grammar/JFLWalker.g:43:4: REGEX  		{  			DebugLocation (43' 4);  			REGEX4 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_propertyName126);  			DebugLocation (43' 10);  			retval.isRegex = true;  			string regexText = (REGEX4 != null ? REGEX4.Text : default(string));  			retval.name = regexText.Substring (1' regexText.Length - 2);  		}  		break;  	case 4:  		DebugEnterAlt (4);  		// ./src/Parser/Grammar/JFLWalker.g:48:4: '*'  		{  			DebugLocation (48' 4);  			Match (input' 27' Follow._27_in_propertyName133);  			DebugLocation (48' 8);  			retval.isRegex = false;  			retval.name = "*";  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("propertyName"' 4);  	LeaveRule ("propertyName"' 4);  	LeaveRule_propertyName ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyName,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:34:2: ( ID | ESC_ID | REGEX | '*' )  	int alt5 = 4;  	try {  		DebugEnterDecision (5' false);  		switch (input.LA (1)) {  		case ID:  			{  				alt5 = 1;  			}  			break;  		case ESC_ID:  			{  				alt5 = 2;  			}  			break;  		case REGEX:  			{  				alt5 = 3;  			}  			break;  		case 27:  			{  				alt5 = 4;  			}  			break;  		default: {  			NoViableAltException nvae = new NoViableAltException (""' 5' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  		}  	}  	finally {  		DebugExitDecision (5);  	}  	switch (alt5) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:34:4: ID  		{  			DebugLocation (34' 4);  			ID2 = (CommonTree)Match (input' ID' Follow._ID_in_propertyName112);  			DebugLocation (34' 7);  			retval.isRegex = false;  			retval.name = (ID2 != null ? ID2.Text : default(string));  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:38:4: ESC_ID  		{  			DebugLocation (38' 4);  			ESC_ID3 = (CommonTree)Match (input' ESC_ID' Follow._ESC_ID_in_propertyName119);  			DebugLocation (38' 11);  			retval.isRegex = false;  			string stringText = (ESC_ID3 != null ? ESC_ID3.Text : default(string));  			retval.name = stringText.Substring (1' stringText.Length - 2);  		}  		break;  	case 3:  		DebugEnterAlt (3);  		// ./src/Parser/Grammar/JFLWalker.g:43:4: REGEX  		{  			DebugLocation (43' 4);  			REGEX4 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_propertyName126);  			DebugLocation (43' 10);  			retval.isRegex = true;  			string regexText = (REGEX4 != null ? REGEX4.Text : default(string));  			retval.name = regexText.Substring (1' regexText.Length - 2);  		}  		break;  	case 4:  		DebugEnterAlt (4);  		// ./src/Parser/Grammar/JFLWalker.g:48:4: '*'  		{  			DebugLocation (48' 4);  			Match (input' 27' Follow._27_in_propertyName133);  			DebugLocation (48' 8);  			retval.isRegex = false;  			retval.name = "*";  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("propertyName"' 4);  	LeaveRule ("propertyName"' 4);  	LeaveRule_propertyName ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyName,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:34:2: ( ID | ESC_ID | REGEX | '*' )  	int alt5 = 4;  	try {  		DebugEnterDecision (5' false);  		switch (input.LA (1)) {  		case ID:  			{  				alt5 = 1;  			}  			break;  		case ESC_ID:  			{  				alt5 = 2;  			}  			break;  		case REGEX:  			{  				alt5 = 3;  			}  			break;  		case 27:  			{  				alt5 = 4;  			}  			break;  		default: {  			NoViableAltException nvae = new NoViableAltException (""' 5' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  		}  	}  	finally {  		DebugExitDecision (5);  	}  	switch (alt5) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:34:4: ID  		{  			DebugLocation (34' 4);  			ID2 = (CommonTree)Match (input' ID' Follow._ID_in_propertyName112);  			DebugLocation (34' 7);  			retval.isRegex = false;  			retval.name = (ID2 != null ? ID2.Text : default(string));  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:38:4: ESC_ID  		{  			DebugLocation (38' 4);  			ESC_ID3 = (CommonTree)Match (input' ESC_ID' Follow._ESC_ID_in_propertyName119);  			DebugLocation (38' 11);  			retval.isRegex = false;  			string stringText = (ESC_ID3 != null ? ESC_ID3.Text : default(string));  			retval.name = stringText.Substring (1' stringText.Length - 2);  		}  		break;  	case 3:  		DebugEnterAlt (3);  		// ./src/Parser/Grammar/JFLWalker.g:43:4: REGEX  		{  			DebugLocation (43' 4);  			REGEX4 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_propertyName126);  			DebugLocation (43' 10);  			retval.isRegex = true;  			string regexText = (REGEX4 != null ? REGEX4.Text : default(string));  			retval.name = regexText.Substring (1' regexText.Length - 2);  		}  		break;  	case 4:  		DebugEnterAlt (4);  		// ./src/Parser/Grammar/JFLWalker.g:48:4: '*'  		{  			DebugLocation (48' 4);  			Match (input' 27' Follow._27_in_propertyName133);  			DebugLocation (48' 8);  			retval.isRegex = false;  			retval.name = "*";  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("propertyName"' 4);  	LeaveRule ("propertyName"' 4);  	LeaveRule_propertyName ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyName,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:34:2: ( ID | ESC_ID | REGEX | '*' )  	int alt5 = 4;  	try {  		DebugEnterDecision (5' false);  		switch (input.LA (1)) {  		case ID:  			{  				alt5 = 1;  			}  			break;  		case ESC_ID:  			{  				alt5 = 2;  			}  			break;  		case REGEX:  			{  				alt5 = 3;  			}  			break;  		case 27:  			{  				alt5 = 4;  			}  			break;  		default: {  			NoViableAltException nvae = new NoViableAltException (""' 5' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  		}  	}  	finally {  		DebugExitDecision (5);  	}  	switch (alt5) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:34:4: ID  		{  			DebugLocation (34' 4);  			ID2 = (CommonTree)Match (input' ID' Follow._ID_in_propertyName112);  			DebugLocation (34' 7);  			retval.isRegex = false;  			retval.name = (ID2 != null ? ID2.Text : default(string));  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:38:4: ESC_ID  		{  			DebugLocation (38' 4);  			ESC_ID3 = (CommonTree)Match (input' ESC_ID' Follow._ESC_ID_in_propertyName119);  			DebugLocation (38' 11);  			retval.isRegex = false;  			string stringText = (ESC_ID3 != null ? ESC_ID3.Text : default(string));  			retval.name = stringText.Substring (1' stringText.Length - 2);  		}  		break;  	case 3:  		DebugEnterAlt (3);  		// ./src/Parser/Grammar/JFLWalker.g:43:4: REGEX  		{  			DebugLocation (43' 4);  			REGEX4 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_propertyName126);  			DebugLocation (43' 10);  			retval.isRegex = true;  			string regexText = (REGEX4 != null ? REGEX4.Text : default(string));  			retval.name = regexText.Substring (1' regexText.Length - 2);  		}  		break;  	case 4:  		DebugEnterAlt (4);  		// ./src/Parser/Grammar/JFLWalker.g:48:4: '*'  		{  			DebugLocation (48' 4);  			Match (input' 27' Follow._27_in_propertyName133);  			DebugLocation (48' 8);  			retval.isRegex = false;  			retval.name = "*";  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("propertyName"' 4);  	LeaveRule ("propertyName"' 4);  	LeaveRule_propertyName ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyName,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:34:2: ( ID | ESC_ID | REGEX | '*' )  	int alt5 = 4;  	try {  		DebugEnterDecision (5' false);  		switch (input.LA (1)) {  		case ID:  			{  				alt5 = 1;  			}  			break;  		case ESC_ID:  			{  				alt5 = 2;  			}  			break;  		case REGEX:  			{  				alt5 = 3;  			}  			break;  		case 27:  			{  				alt5 = 4;  			}  			break;  		default: {  			NoViableAltException nvae = new NoViableAltException (""' 5' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  		}  	}  	finally {  		DebugExitDecision (5);  	}  	switch (alt5) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:34:4: ID  		{  			DebugLocation (34' 4);  			ID2 = (CommonTree)Match (input' ID' Follow._ID_in_propertyName112);  			DebugLocation (34' 7);  			retval.isRegex = false;  			retval.name = (ID2 != null ? ID2.Text : default(string));  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:38:4: ESC_ID  		{  			DebugLocation (38' 4);  			ESC_ID3 = (CommonTree)Match (input' ESC_ID' Follow._ESC_ID_in_propertyName119);  			DebugLocation (38' 11);  			retval.isRegex = false;  			string stringText = (ESC_ID3 != null ? ESC_ID3.Text : default(string));  			retval.name = stringText.Substring (1' stringText.Length - 2);  		}  		break;  	case 3:  		DebugEnterAlt (3);  		// ./src/Parser/Grammar/JFLWalker.g:43:4: REGEX  		{  			DebugLocation (43' 4);  			REGEX4 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_propertyName126);  			DebugLocation (43' 10);  			retval.isRegex = true;  			string regexText = (REGEX4 != null ? REGEX4.Text : default(string));  			retval.name = regexText.Substring (1' regexText.Length - 2);  		}  		break;  	case 4:  		DebugEnterAlt (4);  		// ./src/Parser/Grammar/JFLWalker.g:48:4: '*'  		{  			DebugLocation (48' 4);  			Match (input' 27' Follow._27_in_propertyName133);  			DebugLocation (48' 8);  			retval.isRegex = false;  			retval.name = "*";  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("propertyName"' 4);  	LeaveRule ("propertyName"' 4);  	LeaveRule_propertyName ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyName,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:34:2: ( ID | ESC_ID | REGEX | '*' )  	int alt5 = 4;  	try {  		DebugEnterDecision (5' false);  		switch (input.LA (1)) {  		case ID:  			{  				alt5 = 1;  			}  			break;  		case ESC_ID:  			{  				alt5 = 2;  			}  			break;  		case REGEX:  			{  				alt5 = 3;  			}  			break;  		case 27:  			{  				alt5 = 4;  			}  			break;  		default: {  			NoViableAltException nvae = new NoViableAltException (""' 5' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  		}  	}  	finally {  		DebugExitDecision (5);  	}  	switch (alt5) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:34:4: ID  		{  			DebugLocation (34' 4);  			ID2 = (CommonTree)Match (input' ID' Follow._ID_in_propertyName112);  			DebugLocation (34' 7);  			retval.isRegex = false;  			retval.name = (ID2 != null ? ID2.Text : default(string));  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:38:4: ESC_ID  		{  			DebugLocation (38' 4);  			ESC_ID3 = (CommonTree)Match (input' ESC_ID' Follow._ESC_ID_in_propertyName119);  			DebugLocation (38' 11);  			retval.isRegex = false;  			string stringText = (ESC_ID3 != null ? ESC_ID3.Text : default(string));  			retval.name = stringText.Substring (1' stringText.Length - 2);  		}  		break;  	case 3:  		DebugEnterAlt (3);  		// ./src/Parser/Grammar/JFLWalker.g:43:4: REGEX  		{  			DebugLocation (43' 4);  			REGEX4 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_propertyName126);  			DebugLocation (43' 10);  			retval.isRegex = true;  			string regexText = (REGEX4 != null ? REGEX4.Text : default(string));  			retval.name = regexText.Substring (1' regexText.Length - 2);  		}  		break;  	case 4:  		DebugEnterAlt (4);  		// ./src/Parser/Grammar/JFLWalker.g:48:4: '*'  		{  			DebugLocation (48' 4);  			Match (input' 27' Follow._27_in_propertyName133);  			DebugLocation (48' 8);  			retval.isRegex = false;  			retval.name = "*";  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("propertyName"' 4);  	LeaveRule ("propertyName"' 4);  	LeaveRule_propertyName ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyName,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:34:2: ( ID | ESC_ID | REGEX | '*' )  	int alt5 = 4;  	try {  		DebugEnterDecision (5' false);  		switch (input.LA (1)) {  		case ID:  			{  				alt5 = 1;  			}  			break;  		case ESC_ID:  			{  				alt5 = 2;  			}  			break;  		case REGEX:  			{  				alt5 = 3;  			}  			break;  		case 27:  			{  				alt5 = 4;  			}  			break;  		default: {  			NoViableAltException nvae = new NoViableAltException (""' 5' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  		}  	}  	finally {  		DebugExitDecision (5);  	}  	switch (alt5) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:34:4: ID  		{  			DebugLocation (34' 4);  			ID2 = (CommonTree)Match (input' ID' Follow._ID_in_propertyName112);  			DebugLocation (34' 7);  			retval.isRegex = false;  			retval.name = (ID2 != null ? ID2.Text : default(string));  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:38:4: ESC_ID  		{  			DebugLocation (38' 4);  			ESC_ID3 = (CommonTree)Match (input' ESC_ID' Follow._ESC_ID_in_propertyName119);  			DebugLocation (38' 11);  			retval.isRegex = false;  			string stringText = (ESC_ID3 != null ? ESC_ID3.Text : default(string));  			retval.name = stringText.Substring (1' stringText.Length - 2);  		}  		break;  	case 3:  		DebugEnterAlt (3);  		// ./src/Parser/Grammar/JFLWalker.g:43:4: REGEX  		{  			DebugLocation (43' 4);  			REGEX4 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_propertyName126);  			DebugLocation (43' 10);  			retval.isRegex = true;  			string regexText = (REGEX4 != null ? REGEX4.Text : default(string));  			retval.name = regexText.Substring (1' regexText.Length - 2);  		}  		break;  	case 4:  		DebugEnterAlt (4);  		// ./src/Parser/Grammar/JFLWalker.g:48:4: '*'  		{  			DebugLocation (48' 4);  			Match (input' 27' Follow._27_in_propertyName133);  			DebugLocation (48' 8);  			retval.isRegex = false;  			retval.name = "*";  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("propertyName"' 4);  	LeaveRule ("propertyName"' 4);  	LeaveRule_propertyName ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyName,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:34:2: ( ID | ESC_ID | REGEX | '*' )  	int alt5 = 4;  	try {  		DebugEnterDecision (5' false);  		switch (input.LA (1)) {  		case ID:  			{  				alt5 = 1;  			}  			break;  		case ESC_ID:  			{  				alt5 = 2;  			}  			break;  		case REGEX:  			{  				alt5 = 3;  			}  			break;  		case 27:  			{  				alt5 = 4;  			}  			break;  		default: {  			NoViableAltException nvae = new NoViableAltException (""' 5' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  		}  	}  	finally {  		DebugExitDecision (5);  	}  	switch (alt5) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:34:4: ID  		{  			DebugLocation (34' 4);  			ID2 = (CommonTree)Match (input' ID' Follow._ID_in_propertyName112);  			DebugLocation (34' 7);  			retval.isRegex = false;  			retval.name = (ID2 != null ? ID2.Text : default(string));  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:38:4: ESC_ID  		{  			DebugLocation (38' 4);  			ESC_ID3 = (CommonTree)Match (input' ESC_ID' Follow._ESC_ID_in_propertyName119);  			DebugLocation (38' 11);  			retval.isRegex = false;  			string stringText = (ESC_ID3 != null ? ESC_ID3.Text : default(string));  			retval.name = stringText.Substring (1' stringText.Length - 2);  		}  		break;  	case 3:  		DebugEnterAlt (3);  		// ./src/Parser/Grammar/JFLWalker.g:43:4: REGEX  		{  			DebugLocation (43' 4);  			REGEX4 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_propertyName126);  			DebugLocation (43' 10);  			retval.isRegex = true;  			string regexText = (REGEX4 != null ? REGEX4.Text : default(string));  			retval.name = regexText.Substring (1' regexText.Length - 2);  		}  		break;  	case 4:  		DebugEnterAlt (4);  		// ./src/Parser/Grammar/JFLWalker.g:48:4: '*'  		{  			DebugLocation (48' 4);  			Match (input' 27' Follow._27_in_propertyName133);  			DebugLocation (48' 8);  			retval.isRegex = false;  			retval.name = "*";  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("propertyName"' 4);  	LeaveRule ("propertyName"' 4);  	LeaveRule_propertyName ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyName,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:34:2: ( ID | ESC_ID | REGEX | '*' )  	int alt5 = 4;  	try {  		DebugEnterDecision (5' false);  		switch (input.LA (1)) {  		case ID:  			{  				alt5 = 1;  			}  			break;  		case ESC_ID:  			{  				alt5 = 2;  			}  			break;  		case REGEX:  			{  				alt5 = 3;  			}  			break;  		case 27:  			{  				alt5 = 4;  			}  			break;  		default: {  			NoViableAltException nvae = new NoViableAltException (""' 5' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  		}  	}  	finally {  		DebugExitDecision (5);  	}  	switch (alt5) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:34:4: ID  		{  			DebugLocation (34' 4);  			ID2 = (CommonTree)Match (input' ID' Follow._ID_in_propertyName112);  			DebugLocation (34' 7);  			retval.isRegex = false;  			retval.name = (ID2 != null ? ID2.Text : default(string));  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:38:4: ESC_ID  		{  			DebugLocation (38' 4);  			ESC_ID3 = (CommonTree)Match (input' ESC_ID' Follow._ESC_ID_in_propertyName119);  			DebugLocation (38' 11);  			retval.isRegex = false;  			string stringText = (ESC_ID3 != null ? ESC_ID3.Text : default(string));  			retval.name = stringText.Substring (1' stringText.Length - 2);  		}  		break;  	case 3:  		DebugEnterAlt (3);  		// ./src/Parser/Grammar/JFLWalker.g:43:4: REGEX  		{  			DebugLocation (43' 4);  			REGEX4 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_propertyName126);  			DebugLocation (43' 10);  			retval.isRegex = true;  			string regexText = (REGEX4 != null ? REGEX4.Text : default(string));  			retval.name = regexText.Substring (1' regexText.Length - 2);  		}  		break;  	case 4:  		DebugEnterAlt (4);  		// ./src/Parser/Grammar/JFLWalker.g:48:4: '*'  		{  			DebugLocation (48' 4);  			Match (input' 27' Follow._27_in_propertyName133);  			DebugLocation (48' 8);  			retval.isRegex = false;  			retval.name = "*";  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("propertyName"' 4);  	LeaveRule ("propertyName"' 4);  	LeaveRule_propertyName ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyName,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:34:2: ( ID | ESC_ID | REGEX | '*' )  	int alt5 = 4;  	try {  		DebugEnterDecision (5' false);  		switch (input.LA (1)) {  		case ID:  			{  				alt5 = 1;  			}  			break;  		case ESC_ID:  			{  				alt5 = 2;  			}  			break;  		case REGEX:  			{  				alt5 = 3;  			}  			break;  		case 27:  			{  				alt5 = 4;  			}  			break;  		default: {  			NoViableAltException nvae = new NoViableAltException (""' 5' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  		}  	}  	finally {  		DebugExitDecision (5);  	}  	switch (alt5) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:34:4: ID  		{  			DebugLocation (34' 4);  			ID2 = (CommonTree)Match (input' ID' Follow._ID_in_propertyName112);  			DebugLocation (34' 7);  			retval.isRegex = false;  			retval.name = (ID2 != null ? ID2.Text : default(string));  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:38:4: ESC_ID  		{  			DebugLocation (38' 4);  			ESC_ID3 = (CommonTree)Match (input' ESC_ID' Follow._ESC_ID_in_propertyName119);  			DebugLocation (38' 11);  			retval.isRegex = false;  			string stringText = (ESC_ID3 != null ? ESC_ID3.Text : default(string));  			retval.name = stringText.Substring (1' stringText.Length - 2);  		}  		break;  	case 3:  		DebugEnterAlt (3);  		// ./src/Parser/Grammar/JFLWalker.g:43:4: REGEX  		{  			DebugLocation (43' 4);  			REGEX4 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_propertyName126);  			DebugLocation (43' 10);  			retval.isRegex = true;  			string regexText = (REGEX4 != null ? REGEX4.Text : default(string));  			retval.name = regexText.Substring (1' regexText.Length - 2);  		}  		break;  	case 4:  		DebugEnterAlt (4);  		// ./src/Parser/Grammar/JFLWalker.g:48:4: '*'  		{  			DebugLocation (48' 4);  			Match (input' 27' Follow._27_in_propertyName133);  			DebugLocation (48' 8);  			retval.isRegex = false;  			retval.name = "*";  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("propertyName"' 4);  	LeaveRule ("propertyName"' 4);  	LeaveRule_propertyName ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyName,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:34:2: ( ID | ESC_ID | REGEX | '*' )  	int alt5 = 4;  	try {  		DebugEnterDecision (5' false);  		switch (input.LA (1)) {  		case ID:  			{  				alt5 = 1;  			}  			break;  		case ESC_ID:  			{  				alt5 = 2;  			}  			break;  		case REGEX:  			{  				alt5 = 3;  			}  			break;  		case 27:  			{  				alt5 = 4;  			}  			break;  		default: {  			NoViableAltException nvae = new NoViableAltException (""' 5' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  		}  	}  	finally {  		DebugExitDecision (5);  	}  	switch (alt5) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:34:4: ID  		{  			DebugLocation (34' 4);  			ID2 = (CommonTree)Match (input' ID' Follow._ID_in_propertyName112);  			DebugLocation (34' 7);  			retval.isRegex = false;  			retval.name = (ID2 != null ? ID2.Text : default(string));  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:38:4: ESC_ID  		{  			DebugLocation (38' 4);  			ESC_ID3 = (CommonTree)Match (input' ESC_ID' Follow._ESC_ID_in_propertyName119);  			DebugLocation (38' 11);  			retval.isRegex = false;  			string stringText = (ESC_ID3 != null ? ESC_ID3.Text : default(string));  			retval.name = stringText.Substring (1' stringText.Length - 2);  		}  		break;  	case 3:  		DebugEnterAlt (3);  		// ./src/Parser/Grammar/JFLWalker.g:43:4: REGEX  		{  			DebugLocation (43' 4);  			REGEX4 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_propertyName126);  			DebugLocation (43' 10);  			retval.isRegex = true;  			string regexText = (REGEX4 != null ? REGEX4.Text : default(string));  			retval.name = regexText.Substring (1' regexText.Length - 2);  		}  		break;  	case 4:  		DebugEnterAlt (4);  		// ./src/Parser/Grammar/JFLWalker.g:48:4: '*'  		{  			DebugLocation (48' 4);  			Match (input' 27' Follow._27_in_propertyName133);  			DebugLocation (48' 8);  			retval.isRegex = false;  			retval.name = "*";  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("propertyName"' 4);  	LeaveRule ("propertyName"' 4);  	LeaveRule_propertyName ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyName,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:34:2: ( ID | ESC_ID | REGEX | '*' )  	int alt5 = 4;  	try {  		DebugEnterDecision (5' false);  		switch (input.LA (1)) {  		case ID:  			{  				alt5 = 1;  			}  			break;  		case ESC_ID:  			{  				alt5 = 2;  			}  			break;  		case REGEX:  			{  				alt5 = 3;  			}  			break;  		case 27:  			{  				alt5 = 4;  			}  			break;  		default: {  			NoViableAltException nvae = new NoViableAltException (""' 5' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  		}  	}  	finally {  		DebugExitDecision (5);  	}  	switch (alt5) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:34:4: ID  		{  			DebugLocation (34' 4);  			ID2 = (CommonTree)Match (input' ID' Follow._ID_in_propertyName112);  			DebugLocation (34' 7);  			retval.isRegex = false;  			retval.name = (ID2 != null ? ID2.Text : default(string));  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:38:4: ESC_ID  		{  			DebugLocation (38' 4);  			ESC_ID3 = (CommonTree)Match (input' ESC_ID' Follow._ESC_ID_in_propertyName119);  			DebugLocation (38' 11);  			retval.isRegex = false;  			string stringText = (ESC_ID3 != null ? ESC_ID3.Text : default(string));  			retval.name = stringText.Substring (1' stringText.Length - 2);  		}  		break;  	case 3:  		DebugEnterAlt (3);  		// ./src/Parser/Grammar/JFLWalker.g:43:4: REGEX  		{  			DebugLocation (43' 4);  			REGEX4 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_propertyName126);  			DebugLocation (43' 10);  			retval.isRegex = true;  			string regexText = (REGEX4 != null ? REGEX4.Text : default(string));  			retval.name = regexText.Substring (1' regexText.Length - 2);  		}  		break;  	case 4:  		DebugEnterAlt (4);  		// ./src/Parser/Grammar/JFLWalker.g:48:4: '*'  		{  			DebugLocation (48' 4);  			Match (input' 27' Follow._27_in_propertyName133);  			DebugLocation (48' 8);  			retval.isRegex = false;  			retval.name = "*";  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("propertyName"' 4);  	LeaveRule ("propertyName"' 4);  	LeaveRule_propertyName ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyName,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:34:2: ( ID | ESC_ID | REGEX | '*' )  	int alt5 = 4;  	try {  		DebugEnterDecision (5' false);  		switch (input.LA (1)) {  		case ID:  			{  				alt5 = 1;  			}  			break;  		case ESC_ID:  			{  				alt5 = 2;  			}  			break;  		case REGEX:  			{  				alt5 = 3;  			}  			break;  		case 27:  			{  				alt5 = 4;  			}  			break;  		default: {  			NoViableAltException nvae = new NoViableAltException (""' 5' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  		}  	}  	finally {  		DebugExitDecision (5);  	}  	switch (alt5) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:34:4: ID  		{  			DebugLocation (34' 4);  			ID2 = (CommonTree)Match (input' ID' Follow._ID_in_propertyName112);  			DebugLocation (34' 7);  			retval.isRegex = false;  			retval.name = (ID2 != null ? ID2.Text : default(string));  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:38:4: ESC_ID  		{  			DebugLocation (38' 4);  			ESC_ID3 = (CommonTree)Match (input' ESC_ID' Follow._ESC_ID_in_propertyName119);  			DebugLocation (38' 11);  			retval.isRegex = false;  			string stringText = (ESC_ID3 != null ? ESC_ID3.Text : default(string));  			retval.name = stringText.Substring (1' stringText.Length - 2);  		}  		break;  	case 3:  		DebugEnterAlt (3);  		// ./src/Parser/Grammar/JFLWalker.g:43:4: REGEX  		{  			DebugLocation (43' 4);  			REGEX4 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_propertyName126);  			DebugLocation (43' 10);  			retval.isRegex = true;  			string regexText = (REGEX4 != null ? REGEX4.Text : default(string));  			retval.name = regexText.Substring (1' regexText.Length - 2);  		}  		break;  	case 4:  		DebugEnterAlt (4);  		// ./src/Parser/Grammar/JFLWalker.g:48:4: '*'  		{  			DebugLocation (48' 4);  			Match (input' 27' Follow._27_in_propertyName133);  			DebugLocation (48' 8);  			retval.isRegex = false;  			retval.name = "*";  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("propertyName"' 4);  	LeaveRule ("propertyName"' 4);  	LeaveRule_propertyName ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyName,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:34:2: ( ID | ESC_ID | REGEX | '*' )  	int alt5 = 4;  	try {  		DebugEnterDecision (5' false);  		switch (input.LA (1)) {  		case ID:  			{  				alt5 = 1;  			}  			break;  		case ESC_ID:  			{  				alt5 = 2;  			}  			break;  		case REGEX:  			{  				alt5 = 3;  			}  			break;  		case 27:  			{  				alt5 = 4;  			}  			break;  		default: {  			NoViableAltException nvae = new NoViableAltException (""' 5' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  		}  	}  	finally {  		DebugExitDecision (5);  	}  	switch (alt5) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:34:4: ID  		{  			DebugLocation (34' 4);  			ID2 = (CommonTree)Match (input' ID' Follow._ID_in_propertyName112);  			DebugLocation (34' 7);  			retval.isRegex = false;  			retval.name = (ID2 != null ? ID2.Text : default(string));  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:38:4: ESC_ID  		{  			DebugLocation (38' 4);  			ESC_ID3 = (CommonTree)Match (input' ESC_ID' Follow._ESC_ID_in_propertyName119);  			DebugLocation (38' 11);  			retval.isRegex = false;  			string stringText = (ESC_ID3 != null ? ESC_ID3.Text : default(string));  			retval.name = stringText.Substring (1' stringText.Length - 2);  		}  		break;  	case 3:  		DebugEnterAlt (3);  		// ./src/Parser/Grammar/JFLWalker.g:43:4: REGEX  		{  			DebugLocation (43' 4);  			REGEX4 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_propertyName126);  			DebugLocation (43' 10);  			retval.isRegex = true;  			string regexText = (REGEX4 != null ? REGEX4.Text : default(string));  			retval.name = regexText.Substring (1' regexText.Length - 2);  		}  		break;  	case 4:  		DebugEnterAlt (4);  		// ./src/Parser/Grammar/JFLWalker.g:48:4: '*'  		{  			DebugLocation (48' 4);  			Match (input' 27' Follow._27_in_propertyName133);  			DebugLocation (48' 8);  			retval.isRegex = false;  			retval.name = "*";  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("propertyName"' 4);  	LeaveRule ("propertyName"' 4);  	LeaveRule_propertyName ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyName,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:34:2: ( ID | ESC_ID | REGEX | '*' )  	int alt5 = 4;  	try {  		DebugEnterDecision (5' false);  		switch (input.LA (1)) {  		case ID:  			{  				alt5 = 1;  			}  			break;  		case ESC_ID:  			{  				alt5 = 2;  			}  			break;  		case REGEX:  			{  				alt5 = 3;  			}  			break;  		case 27:  			{  				alt5 = 4;  			}  			break;  		default: {  			NoViableAltException nvae = new NoViableAltException (""' 5' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  		}  	}  	finally {  		DebugExitDecision (5);  	}  	switch (alt5) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:34:4: ID  		{  			DebugLocation (34' 4);  			ID2 = (CommonTree)Match (input' ID' Follow._ID_in_propertyName112);  			DebugLocation (34' 7);  			retval.isRegex = false;  			retval.name = (ID2 != null ? ID2.Text : default(string));  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:38:4: ESC_ID  		{  			DebugLocation (38' 4);  			ESC_ID3 = (CommonTree)Match (input' ESC_ID' Follow._ESC_ID_in_propertyName119);  			DebugLocation (38' 11);  			retval.isRegex = false;  			string stringText = (ESC_ID3 != null ? ESC_ID3.Text : default(string));  			retval.name = stringText.Substring (1' stringText.Length - 2);  		}  		break;  	case 3:  		DebugEnterAlt (3);  		// ./src/Parser/Grammar/JFLWalker.g:43:4: REGEX  		{  			DebugLocation (43' 4);  			REGEX4 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_propertyName126);  			DebugLocation (43' 10);  			retval.isRegex = true;  			string regexText = (REGEX4 != null ? REGEX4.Text : default(string));  			retval.name = regexText.Substring (1' regexText.Length - 2);  		}  		break;  	case 4:  		DebugEnterAlt (4);  		// ./src/Parser/Grammar/JFLWalker.g:48:4: '*'  		{  			DebugLocation (48' 4);  			Match (input' 27' Follow._27_in_propertyName133);  			DebugLocation (48' 8);  			retval.isRegex = false;  			retval.name = "*";  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("propertyName"' 4);  	LeaveRule ("propertyName"' 4);  	LeaveRule_propertyName ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyName,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:34:2: ( ID | ESC_ID | REGEX | '*' )  	int alt5 = 4;  	try {  		DebugEnterDecision (5' false);  		switch (input.LA (1)) {  		case ID:  			{  				alt5 = 1;  			}  			break;  		case ESC_ID:  			{  				alt5 = 2;  			}  			break;  		case REGEX:  			{  				alt5 = 3;  			}  			break;  		case 27:  			{  				alt5 = 4;  			}  			break;  		default: {  			NoViableAltException nvae = new NoViableAltException (""' 5' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  		}  	}  	finally {  		DebugExitDecision (5);  	}  	switch (alt5) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:34:4: ID  		{  			DebugLocation (34' 4);  			ID2 = (CommonTree)Match (input' ID' Follow._ID_in_propertyName112);  			DebugLocation (34' 7);  			retval.isRegex = false;  			retval.name = (ID2 != null ? ID2.Text : default(string));  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:38:4: ESC_ID  		{  			DebugLocation (38' 4);  			ESC_ID3 = (CommonTree)Match (input' ESC_ID' Follow._ESC_ID_in_propertyName119);  			DebugLocation (38' 11);  			retval.isRegex = false;  			string stringText = (ESC_ID3 != null ? ESC_ID3.Text : default(string));  			retval.name = stringText.Substring (1' stringText.Length - 2);  		}  		break;  	case 3:  		DebugEnterAlt (3);  		// ./src/Parser/Grammar/JFLWalker.g:43:4: REGEX  		{  			DebugLocation (43' 4);  			REGEX4 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_propertyName126);  			DebugLocation (43' 10);  			retval.isRegex = true;  			string regexText = (REGEX4 != null ? REGEX4.Text : default(string));  			retval.name = regexText.Substring (1' regexText.Length - 2);  		}  		break;  	case 4:  		DebugEnterAlt (4);  		// ./src/Parser/Grammar/JFLWalker.g:48:4: '*'  		{  			DebugLocation (48' 4);  			Match (input' 27' Follow._27_in_propertyName133);  			DebugLocation (48' 8);  			retval.isRegex = false;  			retval.name = "*";  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("propertyName"' 4);  	LeaveRule ("propertyName"' 4);  	LeaveRule_propertyName ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyName,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:34:2: ( ID | ESC_ID | REGEX | '*' )  	int alt5 = 4;  	try {  		DebugEnterDecision (5' false);  		switch (input.LA (1)) {  		case ID:  			{  				alt5 = 1;  			}  			break;  		case ESC_ID:  			{  				alt5 = 2;  			}  			break;  		case REGEX:  			{  				alt5 = 3;  			}  			break;  		case 27:  			{  				alt5 = 4;  			}  			break;  		default: {  			NoViableAltException nvae = new NoViableAltException (""' 5' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  		}  	}  	finally {  		DebugExitDecision (5);  	}  	switch (alt5) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:34:4: ID  		{  			DebugLocation (34' 4);  			ID2 = (CommonTree)Match (input' ID' Follow._ID_in_propertyName112);  			DebugLocation (34' 7);  			retval.isRegex = false;  			retval.name = (ID2 != null ? ID2.Text : default(string));  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:38:4: ESC_ID  		{  			DebugLocation (38' 4);  			ESC_ID3 = (CommonTree)Match (input' ESC_ID' Follow._ESC_ID_in_propertyName119);  			DebugLocation (38' 11);  			retval.isRegex = false;  			string stringText = (ESC_ID3 != null ? ESC_ID3.Text : default(string));  			retval.name = stringText.Substring (1' stringText.Length - 2);  		}  		break;  	case 3:  		DebugEnterAlt (3);  		// ./src/Parser/Grammar/JFLWalker.g:43:4: REGEX  		{  			DebugLocation (43' 4);  			REGEX4 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_propertyName126);  			DebugLocation (43' 10);  			retval.isRegex = true;  			string regexText = (REGEX4 != null ? REGEX4.Text : default(string));  			retval.name = regexText.Substring (1' regexText.Length - 2);  		}  		break;  	case 4:  		DebugEnterAlt (4);  		// ./src/Parser/Grammar/JFLWalker.g:48:4: '*'  		{  			DebugLocation (48' 4);  			Match (input' 27' Follow._27_in_propertyName133);  			DebugLocation (48' 8);  			retval.isRegex = false;  			retval.name = "*";  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("propertyName"' 4);  	LeaveRule ("propertyName"' 4);  	LeaveRule_propertyName ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyName,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:34:2: ( ID | ESC_ID | REGEX | '*' )  	int alt5 = 4;  	try {  		DebugEnterDecision (5' false);  		switch (input.LA (1)) {  		case ID:  			{  				alt5 = 1;  			}  			break;  		case ESC_ID:  			{  				alt5 = 2;  			}  			break;  		case REGEX:  			{  				alt5 = 3;  			}  			break;  		case 27:  			{  				alt5 = 4;  			}  			break;  		default: {  			NoViableAltException nvae = new NoViableAltException (""' 5' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  		}  	}  	finally {  		DebugExitDecision (5);  	}  	switch (alt5) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:34:4: ID  		{  			DebugLocation (34' 4);  			ID2 = (CommonTree)Match (input' ID' Follow._ID_in_propertyName112);  			DebugLocation (34' 7);  			retval.isRegex = false;  			retval.name = (ID2 != null ? ID2.Text : default(string));  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:38:4: ESC_ID  		{  			DebugLocation (38' 4);  			ESC_ID3 = (CommonTree)Match (input' ESC_ID' Follow._ESC_ID_in_propertyName119);  			DebugLocation (38' 11);  			retval.isRegex = false;  			string stringText = (ESC_ID3 != null ? ESC_ID3.Text : default(string));  			retval.name = stringText.Substring (1' stringText.Length - 2);  		}  		break;  	case 3:  		DebugEnterAlt (3);  		// ./src/Parser/Grammar/JFLWalker.g:43:4: REGEX  		{  			DebugLocation (43' 4);  			REGEX4 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_propertyName126);  			DebugLocation (43' 10);  			retval.isRegex = true;  			string regexText = (REGEX4 != null ? REGEX4.Text : default(string));  			retval.name = regexText.Substring (1' regexText.Length - 2);  		}  		break;  	case 4:  		DebugEnterAlt (4);  		// ./src/Parser/Grammar/JFLWalker.g:48:4: '*'  		{  			DebugLocation (48' 4);  			Match (input' 27' Follow._27_in_propertyName133);  			DebugLocation (48' 8);  			retval.isRegex = false;  			retval.name = "*";  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("propertyName"' 4);  	LeaveRule ("propertyName"' 4);  	LeaveRule_propertyName ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyName,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:34:2: ( ID | ESC_ID | REGEX | '*' )  	int alt5 = 4;  	try {  		DebugEnterDecision (5' false);  		switch (input.LA (1)) {  		case ID:  			{  				alt5 = 1;  			}  			break;  		case ESC_ID:  			{  				alt5 = 2;  			}  			break;  		case REGEX:  			{  				alt5 = 3;  			}  			break;  		case 27:  			{  				alt5 = 4;  			}  			break;  		default: {  			NoViableAltException nvae = new NoViableAltException (""' 5' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  		}  	}  	finally {  		DebugExitDecision (5);  	}  	switch (alt5) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:34:4: ID  		{  			DebugLocation (34' 4);  			ID2 = (CommonTree)Match (input' ID' Follow._ID_in_propertyName112);  			DebugLocation (34' 7);  			retval.isRegex = false;  			retval.name = (ID2 != null ? ID2.Text : default(string));  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:38:4: ESC_ID  		{  			DebugLocation (38' 4);  			ESC_ID3 = (CommonTree)Match (input' ESC_ID' Follow._ESC_ID_in_propertyName119);  			DebugLocation (38' 11);  			retval.isRegex = false;  			string stringText = (ESC_ID3 != null ? ESC_ID3.Text : default(string));  			retval.name = stringText.Substring (1' stringText.Length - 2);  		}  		break;  	case 3:  		DebugEnterAlt (3);  		// ./src/Parser/Grammar/JFLWalker.g:43:4: REGEX  		{  			DebugLocation (43' 4);  			REGEX4 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_propertyName126);  			DebugLocation (43' 10);  			retval.isRegex = true;  			string regexText = (REGEX4 != null ? REGEX4.Text : default(string));  			retval.name = regexText.Substring (1' regexText.Length - 2);  		}  		break;  	case 4:  		DebugEnterAlt (4);  		// ./src/Parser/Grammar/JFLWalker.g:48:4: '*'  		{  			DebugLocation (48' 4);  			Match (input' 27' Follow._27_in_propertyName133);  			DebugLocation (48' 8);  			retval.isRegex = false;  			retval.name = "*";  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("propertyName"' 4);  	LeaveRule ("propertyName"' 4);  	LeaveRule_propertyName ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyName,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:34:2: ( ID | ESC_ID | REGEX | '*' )  	int alt5 = 4;  	try {  		DebugEnterDecision (5' false);  		switch (input.LA (1)) {  		case ID:  			{  				alt5 = 1;  			}  			break;  		case ESC_ID:  			{  				alt5 = 2;  			}  			break;  		case REGEX:  			{  				alt5 = 3;  			}  			break;  		case 27:  			{  				alt5 = 4;  			}  			break;  		default: {  			NoViableAltException nvae = new NoViableAltException (""' 5' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  		}  	}  	finally {  		DebugExitDecision (5);  	}  	switch (alt5) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:34:4: ID  		{  			DebugLocation (34' 4);  			ID2 = (CommonTree)Match (input' ID' Follow._ID_in_propertyName112);  			DebugLocation (34' 7);  			retval.isRegex = false;  			retval.name = (ID2 != null ? ID2.Text : default(string));  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:38:4: ESC_ID  		{  			DebugLocation (38' 4);  			ESC_ID3 = (CommonTree)Match (input' ESC_ID' Follow._ESC_ID_in_propertyName119);  			DebugLocation (38' 11);  			retval.isRegex = false;  			string stringText = (ESC_ID3 != null ? ESC_ID3.Text : default(string));  			retval.name = stringText.Substring (1' stringText.Length - 2);  		}  		break;  	case 3:  		DebugEnterAlt (3);  		// ./src/Parser/Grammar/JFLWalker.g:43:4: REGEX  		{  			DebugLocation (43' 4);  			REGEX4 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_propertyName126);  			DebugLocation (43' 10);  			retval.isRegex = true;  			string regexText = (REGEX4 != null ? REGEX4.Text : default(string));  			retval.name = regexText.Substring (1' regexText.Length - 2);  		}  		break;  	case 4:  		DebugEnterAlt (4);  		// ./src/Parser/Grammar/JFLWalker.g:48:4: '*'  		{  			DebugLocation (48' 4);  			Match (input' 27' Follow._27_in_propertyName133);  			DebugLocation (48' 8);  			retval.isRegex = false;  			retval.name = "*";  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("propertyName"' 4);  	LeaveRule ("propertyName"' 4);  	LeaveRule_propertyName ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyName,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:34:2: ( ID | ESC_ID | REGEX | '*' )  	int alt5 = 4;  	try {  		DebugEnterDecision (5' false);  		switch (input.LA (1)) {  		case ID:  			{  				alt5 = 1;  			}  			break;  		case ESC_ID:  			{  				alt5 = 2;  			}  			break;  		case REGEX:  			{  				alt5 = 3;  			}  			break;  		case 27:  			{  				alt5 = 4;  			}  			break;  		default: {  			NoViableAltException nvae = new NoViableAltException (""' 5' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  		}  	}  	finally {  		DebugExitDecision (5);  	}  	switch (alt5) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:34:4: ID  		{  			DebugLocation (34' 4);  			ID2 = (CommonTree)Match (input' ID' Follow._ID_in_propertyName112);  			DebugLocation (34' 7);  			retval.isRegex = false;  			retval.name = (ID2 != null ? ID2.Text : default(string));  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:38:4: ESC_ID  		{  			DebugLocation (38' 4);  			ESC_ID3 = (CommonTree)Match (input' ESC_ID' Follow._ESC_ID_in_propertyName119);  			DebugLocation (38' 11);  			retval.isRegex = false;  			string stringText = (ESC_ID3 != null ? ESC_ID3.Text : default(string));  			retval.name = stringText.Substring (1' stringText.Length - 2);  		}  		break;  	case 3:  		DebugEnterAlt (3);  		// ./src/Parser/Grammar/JFLWalker.g:43:4: REGEX  		{  			DebugLocation (43' 4);  			REGEX4 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_propertyName126);  			DebugLocation (43' 10);  			retval.isRegex = true;  			string regexText = (REGEX4 != null ? REGEX4.Text : default(string));  			retval.name = regexText.Substring (1' regexText.Length - 2);  		}  		break;  	case 4:  		DebugEnterAlt (4);  		// ./src/Parser/Grammar/JFLWalker.g:48:4: '*'  		{  			DebugLocation (48' 4);  			Match (input' 27' Follow._27_in_propertyName133);  			DebugLocation (48' 8);  			retval.isRegex = false;  			retval.name = "*";  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("propertyName"' 4);  	LeaveRule ("propertyName"' 4);  	LeaveRule_propertyName ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyName,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:34:2: ( ID | ESC_ID | REGEX | '*' )  	int alt5 = 4;  	try {  		DebugEnterDecision (5' false);  		switch (input.LA (1)) {  		case ID:  			{  				alt5 = 1;  			}  			break;  		case ESC_ID:  			{  				alt5 = 2;  			}  			break;  		case REGEX:  			{  				alt5 = 3;  			}  			break;  		case 27:  			{  				alt5 = 4;  			}  			break;  		default: {  			NoViableAltException nvae = new NoViableAltException (""' 5' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  		}  	}  	finally {  		DebugExitDecision (5);  	}  	switch (alt5) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:34:4: ID  		{  			DebugLocation (34' 4);  			ID2 = (CommonTree)Match (input' ID' Follow._ID_in_propertyName112);  			DebugLocation (34' 7);  			retval.isRegex = false;  			retval.name = (ID2 != null ? ID2.Text : default(string));  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:38:4: ESC_ID  		{  			DebugLocation (38' 4);  			ESC_ID3 = (CommonTree)Match (input' ESC_ID' Follow._ESC_ID_in_propertyName119);  			DebugLocation (38' 11);  			retval.isRegex = false;  			string stringText = (ESC_ID3 != null ? ESC_ID3.Text : default(string));  			retval.name = stringText.Substring (1' stringText.Length - 2);  		}  		break;  	case 3:  		DebugEnterAlt (3);  		// ./src/Parser/Grammar/JFLWalker.g:43:4: REGEX  		{  			DebugLocation (43' 4);  			REGEX4 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_propertyName126);  			DebugLocation (43' 10);  			retval.isRegex = true;  			string regexText = (REGEX4 != null ? REGEX4.Text : default(string));  			retval.name = regexText.Substring (1' regexText.Length - 2);  		}  		break;  	case 4:  		DebugEnterAlt (4);  		// ./src/Parser/Grammar/JFLWalker.g:48:4: '*'  		{  			DebugLocation (48' 4);  			Match (input' 27' Follow._27_in_propertyName133);  			DebugLocation (48' 8);  			retval.isRegex = false;  			retval.name = "*";  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("propertyName"' 4);  	LeaveRule ("propertyName"' 4);  	LeaveRule_propertyName ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyName,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:34:2: ( ID | ESC_ID | REGEX | '*' )  	int alt5 = 4;  	try {  		DebugEnterDecision (5' false);  		switch (input.LA (1)) {  		case ID:  			{  				alt5 = 1;  			}  			break;  		case ESC_ID:  			{  				alt5 = 2;  			}  			break;  		case REGEX:  			{  				alt5 = 3;  			}  			break;  		case 27:  			{  				alt5 = 4;  			}  			break;  		default: {  			NoViableAltException nvae = new NoViableAltException (""' 5' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  		}  	}  	finally {  		DebugExitDecision (5);  	}  	switch (alt5) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:34:4: ID  		{  			DebugLocation (34' 4);  			ID2 = (CommonTree)Match (input' ID' Follow._ID_in_propertyName112);  			DebugLocation (34' 7);  			retval.isRegex = false;  			retval.name = (ID2 != null ? ID2.Text : default(string));  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:38:4: ESC_ID  		{  			DebugLocation (38' 4);  			ESC_ID3 = (CommonTree)Match (input' ESC_ID' Follow._ESC_ID_in_propertyName119);  			DebugLocation (38' 11);  			retval.isRegex = false;  			string stringText = (ESC_ID3 != null ? ESC_ID3.Text : default(string));  			retval.name = stringText.Substring (1' stringText.Length - 2);  		}  		break;  	case 3:  		DebugEnterAlt (3);  		// ./src/Parser/Grammar/JFLWalker.g:43:4: REGEX  		{  			DebugLocation (43' 4);  			REGEX4 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_propertyName126);  			DebugLocation (43' 10);  			retval.isRegex = true;  			string regexText = (REGEX4 != null ? REGEX4.Text : default(string));  			retval.name = regexText.Substring (1' regexText.Length - 2);  		}  		break;  	case 4:  		DebugEnterAlt (4);  		// ./src/Parser/Grammar/JFLWalker.g:48:4: '*'  		{  			DebugLocation (48' 4);  			Match (input' 27' Follow._27_in_propertyName133);  			DebugLocation (48' 8);  			retval.isRegex = false;  			retval.name = "*";  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("propertyName"' 4);  	LeaveRule ("propertyName"' 4);  	LeaveRule_propertyName ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyName,The following statement contains a magic number: try {  	DebugEnterDecision (5' false);  	switch (input.LA (1)) {  	case ID:  		{  			alt5 = 1;  		}  		break;  	case ESC_ID:  		{  			alt5 = 2;  		}  		break;  	case REGEX:  		{  			alt5 = 3;  		}  		break;  	case 27:  		{  			alt5 = 4;  		}  		break;  	default: {  		NoViableAltException nvae = new NoViableAltException (""' 5' 0' input' 1);  		DebugRecognitionException (nvae);  		throw nvae;  	}  	}  }  finally {  	DebugExitDecision (5);  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyName,The following statement contains a magic number: try {  	DebugEnterDecision (5' false);  	switch (input.LA (1)) {  	case ID:  		{  			alt5 = 1;  		}  		break;  	case ESC_ID:  		{  			alt5 = 2;  		}  		break;  	case REGEX:  		{  			alt5 = 3;  		}  		break;  	case 27:  		{  			alt5 = 4;  		}  		break;  	default: {  		NoViableAltException nvae = new NoViableAltException (""' 5' 0' input' 1);  		DebugRecognitionException (nvae);  		throw nvae;  	}  	}  }  finally {  	DebugExitDecision (5);  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyName,The following statement contains a magic number: try {  	DebugEnterDecision (5' false);  	switch (input.LA (1)) {  	case ID:  		{  			alt5 = 1;  		}  		break;  	case ESC_ID:  		{  			alt5 = 2;  		}  		break;  	case REGEX:  		{  			alt5 = 3;  		}  		break;  	case 27:  		{  			alt5 = 4;  		}  		break;  	default: {  		NoViableAltException nvae = new NoViableAltException (""' 5' 0' input' 1);  		DebugRecognitionException (nvae);  		throw nvae;  	}  	}  }  finally {  	DebugExitDecision (5);  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyName,The following statement contains a magic number: try {  	DebugEnterDecision (5' false);  	switch (input.LA (1)) {  	case ID:  		{  			alt5 = 1;  		}  		break;  	case ESC_ID:  		{  			alt5 = 2;  		}  		break;  	case REGEX:  		{  			alt5 = 3;  		}  		break;  	case 27:  		{  			alt5 = 4;  		}  		break;  	default: {  		NoViableAltException nvae = new NoViableAltException (""' 5' 0' input' 1);  		DebugRecognitionException (nvae);  		throw nvae;  	}  	}  }  finally {  	DebugExitDecision (5);  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyName,The following statement contains a magic number: try {  	DebugEnterDecision (5' false);  	switch (input.LA (1)) {  	case ID:  		{  			alt5 = 1;  		}  		break;  	case ESC_ID:  		{  			alt5 = 2;  		}  		break;  	case REGEX:  		{  			alt5 = 3;  		}  		break;  	case 27:  		{  			alt5 = 4;  		}  		break;  	default: {  		NoViableAltException nvae = new NoViableAltException (""' 5' 0' input' 1);  		DebugRecognitionException (nvae);  		throw nvae;  	}  	}  }  finally {  	DebugExitDecision (5);  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyName,The following statement contains a magic number: try {  	DebugEnterDecision (5' false);  	switch (input.LA (1)) {  	case ID:  		{  			alt5 = 1;  		}  		break;  	case ESC_ID:  		{  			alt5 = 2;  		}  		break;  	case REGEX:  		{  			alt5 = 3;  		}  		break;  	case 27:  		{  			alt5 = 4;  		}  		break;  	default: {  		NoViableAltException nvae = new NoViableAltException (""' 5' 0' input' 1);  		DebugRecognitionException (nvae);  		throw nvae;  	}  	}  }  finally {  	DebugExitDecision (5);  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyName,The following statement contains a magic number: try {  	DebugEnterDecision (5' false);  	switch (input.LA (1)) {  	case ID:  		{  			alt5 = 1;  		}  		break;  	case ESC_ID:  		{  			alt5 = 2;  		}  		break;  	case REGEX:  		{  			alt5 = 3;  		}  		break;  	case 27:  		{  			alt5 = 4;  		}  		break;  	default: {  		NoViableAltException nvae = new NoViableAltException (""' 5' 0' input' 1);  		DebugRecognitionException (nvae);  		throw nvae;  	}  	}  }  finally {  	DebugExitDecision (5);  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyName,The following statement contains a magic number: DebugEnterDecision (5' false);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyName,The following statement contains a magic number: switch (input.LA (1)) {  case ID:  	{  		alt5 = 1;  	}  	break;  case ESC_ID:  	{  		alt5 = 2;  	}  	break;  case REGEX:  	{  		alt5 = 3;  	}  	break;  case 27:  	{  		alt5 = 4;  	}  	break;  default: {  	NoViableAltException nvae = new NoViableAltException (""' 5' 0' input' 1);  	DebugRecognitionException (nvae);  	throw nvae;  }  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyName,The following statement contains a magic number: switch (input.LA (1)) {  case ID:  	{  		alt5 = 1;  	}  	break;  case ESC_ID:  	{  		alt5 = 2;  	}  	break;  case REGEX:  	{  		alt5 = 3;  	}  	break;  case 27:  	{  		alt5 = 4;  	}  	break;  default: {  	NoViableAltException nvae = new NoViableAltException (""' 5' 0' input' 1);  	DebugRecognitionException (nvae);  	throw nvae;  }  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyName,The following statement contains a magic number: switch (input.LA (1)) {  case ID:  	{  		alt5 = 1;  	}  	break;  case ESC_ID:  	{  		alt5 = 2;  	}  	break;  case REGEX:  	{  		alt5 = 3;  	}  	break;  case 27:  	{  		alt5 = 4;  	}  	break;  default: {  	NoViableAltException nvae = new NoViableAltException (""' 5' 0' input' 1);  	DebugRecognitionException (nvae);  	throw nvae;  }  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyName,The following statement contains a magic number: switch (input.LA (1)) {  case ID:  	{  		alt5 = 1;  	}  	break;  case ESC_ID:  	{  		alt5 = 2;  	}  	break;  case REGEX:  	{  		alt5 = 3;  	}  	break;  case 27:  	{  		alt5 = 4;  	}  	break;  default: {  	NoViableAltException nvae = new NoViableAltException (""' 5' 0' input' 1);  	DebugRecognitionException (nvae);  	throw nvae;  }  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyName,The following statement contains a magic number: switch (input.LA (1)) {  case ID:  	{  		alt5 = 1;  	}  	break;  case ESC_ID:  	{  		alt5 = 2;  	}  	break;  case REGEX:  	{  		alt5 = 3;  	}  	break;  case 27:  	{  		alt5 = 4;  	}  	break;  default: {  	NoViableAltException nvae = new NoViableAltException (""' 5' 0' input' 1);  	DebugRecognitionException (nvae);  	throw nvae;  }  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyName,The following statement contains a magic number: alt5 = 2;  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyName,The following statement contains a magic number: alt5 = 3;  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyName,The following statement contains a magic number: alt5 = 4;  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyName,The following statement contains a magic number: DebugExitDecision (5);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyName,The following statement contains a magic number: switch (alt5) {  case 1:  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:34:4: ID  	{  		DebugLocation (34' 4);  		ID2 = (CommonTree)Match (input' ID' Follow._ID_in_propertyName112);  		DebugLocation (34' 7);  		retval.isRegex = false;  		retval.name = (ID2 != null ? ID2.Text : default(string));  	}  	break;  case 2:  	DebugEnterAlt (2);  	// ./src/Parser/Grammar/JFLWalker.g:38:4: ESC_ID  	{  		DebugLocation (38' 4);  		ESC_ID3 = (CommonTree)Match (input' ESC_ID' Follow._ESC_ID_in_propertyName119);  		DebugLocation (38' 11);  		retval.isRegex = false;  		string stringText = (ESC_ID3 != null ? ESC_ID3.Text : default(string));  		retval.name = stringText.Substring (1' stringText.Length - 2);  	}  	break;  case 3:  	DebugEnterAlt (3);  	// ./src/Parser/Grammar/JFLWalker.g:43:4: REGEX  	{  		DebugLocation (43' 4);  		REGEX4 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_propertyName126);  		DebugLocation (43' 10);  		retval.isRegex = true;  		string regexText = (REGEX4 != null ? REGEX4.Text : default(string));  		retval.name = regexText.Substring (1' regexText.Length - 2);  	}  	break;  case 4:  	DebugEnterAlt (4);  	// ./src/Parser/Grammar/JFLWalker.g:48:4: '*'  	{  		DebugLocation (48' 4);  		Match (input' 27' Follow._27_in_propertyName133);  		DebugLocation (48' 8);  		retval.isRegex = false;  		retval.name = "*";  	}  	break;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyName,The following statement contains a magic number: switch (alt5) {  case 1:  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:34:4: ID  	{  		DebugLocation (34' 4);  		ID2 = (CommonTree)Match (input' ID' Follow._ID_in_propertyName112);  		DebugLocation (34' 7);  		retval.isRegex = false;  		retval.name = (ID2 != null ? ID2.Text : default(string));  	}  	break;  case 2:  	DebugEnterAlt (2);  	// ./src/Parser/Grammar/JFLWalker.g:38:4: ESC_ID  	{  		DebugLocation (38' 4);  		ESC_ID3 = (CommonTree)Match (input' ESC_ID' Follow._ESC_ID_in_propertyName119);  		DebugLocation (38' 11);  		retval.isRegex = false;  		string stringText = (ESC_ID3 != null ? ESC_ID3.Text : default(string));  		retval.name = stringText.Substring (1' stringText.Length - 2);  	}  	break;  case 3:  	DebugEnterAlt (3);  	// ./src/Parser/Grammar/JFLWalker.g:43:4: REGEX  	{  		DebugLocation (43' 4);  		REGEX4 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_propertyName126);  		DebugLocation (43' 10);  		retval.isRegex = true;  		string regexText = (REGEX4 != null ? REGEX4.Text : default(string));  		retval.name = regexText.Substring (1' regexText.Length - 2);  	}  	break;  case 4:  	DebugEnterAlt (4);  	// ./src/Parser/Grammar/JFLWalker.g:48:4: '*'  	{  		DebugLocation (48' 4);  		Match (input' 27' Follow._27_in_propertyName133);  		DebugLocation (48' 8);  		retval.isRegex = false;  		retval.name = "*";  	}  	break;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyName,The following statement contains a magic number: switch (alt5) {  case 1:  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:34:4: ID  	{  		DebugLocation (34' 4);  		ID2 = (CommonTree)Match (input' ID' Follow._ID_in_propertyName112);  		DebugLocation (34' 7);  		retval.isRegex = false;  		retval.name = (ID2 != null ? ID2.Text : default(string));  	}  	break;  case 2:  	DebugEnterAlt (2);  	// ./src/Parser/Grammar/JFLWalker.g:38:4: ESC_ID  	{  		DebugLocation (38' 4);  		ESC_ID3 = (CommonTree)Match (input' ESC_ID' Follow._ESC_ID_in_propertyName119);  		DebugLocation (38' 11);  		retval.isRegex = false;  		string stringText = (ESC_ID3 != null ? ESC_ID3.Text : default(string));  		retval.name = stringText.Substring (1' stringText.Length - 2);  	}  	break;  case 3:  	DebugEnterAlt (3);  	// ./src/Parser/Grammar/JFLWalker.g:43:4: REGEX  	{  		DebugLocation (43' 4);  		REGEX4 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_propertyName126);  		DebugLocation (43' 10);  		retval.isRegex = true;  		string regexText = (REGEX4 != null ? REGEX4.Text : default(string));  		retval.name = regexText.Substring (1' regexText.Length - 2);  	}  	break;  case 4:  	DebugEnterAlt (4);  	// ./src/Parser/Grammar/JFLWalker.g:48:4: '*'  	{  		DebugLocation (48' 4);  		Match (input' 27' Follow._27_in_propertyName133);  		DebugLocation (48' 8);  		retval.isRegex = false;  		retval.name = "*";  	}  	break;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyName,The following statement contains a magic number: switch (alt5) {  case 1:  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:34:4: ID  	{  		DebugLocation (34' 4);  		ID2 = (CommonTree)Match (input' ID' Follow._ID_in_propertyName112);  		DebugLocation (34' 7);  		retval.isRegex = false;  		retval.name = (ID2 != null ? ID2.Text : default(string));  	}  	break;  case 2:  	DebugEnterAlt (2);  	// ./src/Parser/Grammar/JFLWalker.g:38:4: ESC_ID  	{  		DebugLocation (38' 4);  		ESC_ID3 = (CommonTree)Match (input' ESC_ID' Follow._ESC_ID_in_propertyName119);  		DebugLocation (38' 11);  		retval.isRegex = false;  		string stringText = (ESC_ID3 != null ? ESC_ID3.Text : default(string));  		retval.name = stringText.Substring (1' stringText.Length - 2);  	}  	break;  case 3:  	DebugEnterAlt (3);  	// ./src/Parser/Grammar/JFLWalker.g:43:4: REGEX  	{  		DebugLocation (43' 4);  		REGEX4 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_propertyName126);  		DebugLocation (43' 10);  		retval.isRegex = true;  		string regexText = (REGEX4 != null ? REGEX4.Text : default(string));  		retval.name = regexText.Substring (1' regexText.Length - 2);  	}  	break;  case 4:  	DebugEnterAlt (4);  	// ./src/Parser/Grammar/JFLWalker.g:48:4: '*'  	{  		DebugLocation (48' 4);  		Match (input' 27' Follow._27_in_propertyName133);  		DebugLocation (48' 8);  		retval.isRegex = false;  		retval.name = "*";  	}  	break;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyName,The following statement contains a magic number: switch (alt5) {  case 1:  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:34:4: ID  	{  		DebugLocation (34' 4);  		ID2 = (CommonTree)Match (input' ID' Follow._ID_in_propertyName112);  		DebugLocation (34' 7);  		retval.isRegex = false;  		retval.name = (ID2 != null ? ID2.Text : default(string));  	}  	break;  case 2:  	DebugEnterAlt (2);  	// ./src/Parser/Grammar/JFLWalker.g:38:4: ESC_ID  	{  		DebugLocation (38' 4);  		ESC_ID3 = (CommonTree)Match (input' ESC_ID' Follow._ESC_ID_in_propertyName119);  		DebugLocation (38' 11);  		retval.isRegex = false;  		string stringText = (ESC_ID3 != null ? ESC_ID3.Text : default(string));  		retval.name = stringText.Substring (1' stringText.Length - 2);  	}  	break;  case 3:  	DebugEnterAlt (3);  	// ./src/Parser/Grammar/JFLWalker.g:43:4: REGEX  	{  		DebugLocation (43' 4);  		REGEX4 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_propertyName126);  		DebugLocation (43' 10);  		retval.isRegex = true;  		string regexText = (REGEX4 != null ? REGEX4.Text : default(string));  		retval.name = regexText.Substring (1' regexText.Length - 2);  	}  	break;  case 4:  	DebugEnterAlt (4);  	// ./src/Parser/Grammar/JFLWalker.g:48:4: '*'  	{  		DebugLocation (48' 4);  		Match (input' 27' Follow._27_in_propertyName133);  		DebugLocation (48' 8);  		retval.isRegex = false;  		retval.name = "*";  	}  	break;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyName,The following statement contains a magic number: switch (alt5) {  case 1:  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:34:4: ID  	{  		DebugLocation (34' 4);  		ID2 = (CommonTree)Match (input' ID' Follow._ID_in_propertyName112);  		DebugLocation (34' 7);  		retval.isRegex = false;  		retval.name = (ID2 != null ? ID2.Text : default(string));  	}  	break;  case 2:  	DebugEnterAlt (2);  	// ./src/Parser/Grammar/JFLWalker.g:38:4: ESC_ID  	{  		DebugLocation (38' 4);  		ESC_ID3 = (CommonTree)Match (input' ESC_ID' Follow._ESC_ID_in_propertyName119);  		DebugLocation (38' 11);  		retval.isRegex = false;  		string stringText = (ESC_ID3 != null ? ESC_ID3.Text : default(string));  		retval.name = stringText.Substring (1' stringText.Length - 2);  	}  	break;  case 3:  	DebugEnterAlt (3);  	// ./src/Parser/Grammar/JFLWalker.g:43:4: REGEX  	{  		DebugLocation (43' 4);  		REGEX4 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_propertyName126);  		DebugLocation (43' 10);  		retval.isRegex = true;  		string regexText = (REGEX4 != null ? REGEX4.Text : default(string));  		retval.name = regexText.Substring (1' regexText.Length - 2);  	}  	break;  case 4:  	DebugEnterAlt (4);  	// ./src/Parser/Grammar/JFLWalker.g:48:4: '*'  	{  		DebugLocation (48' 4);  		Match (input' 27' Follow._27_in_propertyName133);  		DebugLocation (48' 8);  		retval.isRegex = false;  		retval.name = "*";  	}  	break;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyName,The following statement contains a magic number: switch (alt5) {  case 1:  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:34:4: ID  	{  		DebugLocation (34' 4);  		ID2 = (CommonTree)Match (input' ID' Follow._ID_in_propertyName112);  		DebugLocation (34' 7);  		retval.isRegex = false;  		retval.name = (ID2 != null ? ID2.Text : default(string));  	}  	break;  case 2:  	DebugEnterAlt (2);  	// ./src/Parser/Grammar/JFLWalker.g:38:4: ESC_ID  	{  		DebugLocation (38' 4);  		ESC_ID3 = (CommonTree)Match (input' ESC_ID' Follow._ESC_ID_in_propertyName119);  		DebugLocation (38' 11);  		retval.isRegex = false;  		string stringText = (ESC_ID3 != null ? ESC_ID3.Text : default(string));  		retval.name = stringText.Substring (1' stringText.Length - 2);  	}  	break;  case 3:  	DebugEnterAlt (3);  	// ./src/Parser/Grammar/JFLWalker.g:43:4: REGEX  	{  		DebugLocation (43' 4);  		REGEX4 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_propertyName126);  		DebugLocation (43' 10);  		retval.isRegex = true;  		string regexText = (REGEX4 != null ? REGEX4.Text : default(string));  		retval.name = regexText.Substring (1' regexText.Length - 2);  	}  	break;  case 4:  	DebugEnterAlt (4);  	// ./src/Parser/Grammar/JFLWalker.g:48:4: '*'  	{  		DebugLocation (48' 4);  		Match (input' 27' Follow._27_in_propertyName133);  		DebugLocation (48' 8);  		retval.isRegex = false;  		retval.name = "*";  	}  	break;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyName,The following statement contains a magic number: switch (alt5) {  case 1:  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:34:4: ID  	{  		DebugLocation (34' 4);  		ID2 = (CommonTree)Match (input' ID' Follow._ID_in_propertyName112);  		DebugLocation (34' 7);  		retval.isRegex = false;  		retval.name = (ID2 != null ? ID2.Text : default(string));  	}  	break;  case 2:  	DebugEnterAlt (2);  	// ./src/Parser/Grammar/JFLWalker.g:38:4: ESC_ID  	{  		DebugLocation (38' 4);  		ESC_ID3 = (CommonTree)Match (input' ESC_ID' Follow._ESC_ID_in_propertyName119);  		DebugLocation (38' 11);  		retval.isRegex = false;  		string stringText = (ESC_ID3 != null ? ESC_ID3.Text : default(string));  		retval.name = stringText.Substring (1' stringText.Length - 2);  	}  	break;  case 3:  	DebugEnterAlt (3);  	// ./src/Parser/Grammar/JFLWalker.g:43:4: REGEX  	{  		DebugLocation (43' 4);  		REGEX4 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_propertyName126);  		DebugLocation (43' 10);  		retval.isRegex = true;  		string regexText = (REGEX4 != null ? REGEX4.Text : default(string));  		retval.name = regexText.Substring (1' regexText.Length - 2);  	}  	break;  case 4:  	DebugEnterAlt (4);  	// ./src/Parser/Grammar/JFLWalker.g:48:4: '*'  	{  		DebugLocation (48' 4);  		Match (input' 27' Follow._27_in_propertyName133);  		DebugLocation (48' 8);  		retval.isRegex = false;  		retval.name = "*";  	}  	break;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyName,The following statement contains a magic number: switch (alt5) {  case 1:  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:34:4: ID  	{  		DebugLocation (34' 4);  		ID2 = (CommonTree)Match (input' ID' Follow._ID_in_propertyName112);  		DebugLocation (34' 7);  		retval.isRegex = false;  		retval.name = (ID2 != null ? ID2.Text : default(string));  	}  	break;  case 2:  	DebugEnterAlt (2);  	// ./src/Parser/Grammar/JFLWalker.g:38:4: ESC_ID  	{  		DebugLocation (38' 4);  		ESC_ID3 = (CommonTree)Match (input' ESC_ID' Follow._ESC_ID_in_propertyName119);  		DebugLocation (38' 11);  		retval.isRegex = false;  		string stringText = (ESC_ID3 != null ? ESC_ID3.Text : default(string));  		retval.name = stringText.Substring (1' stringText.Length - 2);  	}  	break;  case 3:  	DebugEnterAlt (3);  	// ./src/Parser/Grammar/JFLWalker.g:43:4: REGEX  	{  		DebugLocation (43' 4);  		REGEX4 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_propertyName126);  		DebugLocation (43' 10);  		retval.isRegex = true;  		string regexText = (REGEX4 != null ? REGEX4.Text : default(string));  		retval.name = regexText.Substring (1' regexText.Length - 2);  	}  	break;  case 4:  	DebugEnterAlt (4);  	// ./src/Parser/Grammar/JFLWalker.g:48:4: '*'  	{  		DebugLocation (48' 4);  		Match (input' 27' Follow._27_in_propertyName133);  		DebugLocation (48' 8);  		retval.isRegex = false;  		retval.name = "*";  	}  	break;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyName,The following statement contains a magic number: switch (alt5) {  case 1:  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:34:4: ID  	{  		DebugLocation (34' 4);  		ID2 = (CommonTree)Match (input' ID' Follow._ID_in_propertyName112);  		DebugLocation (34' 7);  		retval.isRegex = false;  		retval.name = (ID2 != null ? ID2.Text : default(string));  	}  	break;  case 2:  	DebugEnterAlt (2);  	// ./src/Parser/Grammar/JFLWalker.g:38:4: ESC_ID  	{  		DebugLocation (38' 4);  		ESC_ID3 = (CommonTree)Match (input' ESC_ID' Follow._ESC_ID_in_propertyName119);  		DebugLocation (38' 11);  		retval.isRegex = false;  		string stringText = (ESC_ID3 != null ? ESC_ID3.Text : default(string));  		retval.name = stringText.Substring (1' stringText.Length - 2);  	}  	break;  case 3:  	DebugEnterAlt (3);  	// ./src/Parser/Grammar/JFLWalker.g:43:4: REGEX  	{  		DebugLocation (43' 4);  		REGEX4 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_propertyName126);  		DebugLocation (43' 10);  		retval.isRegex = true;  		string regexText = (REGEX4 != null ? REGEX4.Text : default(string));  		retval.name = regexText.Substring (1' regexText.Length - 2);  	}  	break;  case 4:  	DebugEnterAlt (4);  	// ./src/Parser/Grammar/JFLWalker.g:48:4: '*'  	{  		DebugLocation (48' 4);  		Match (input' 27' Follow._27_in_propertyName133);  		DebugLocation (48' 8);  		retval.isRegex = false;  		retval.name = "*";  	}  	break;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyName,The following statement contains a magic number: switch (alt5) {  case 1:  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:34:4: ID  	{  		DebugLocation (34' 4);  		ID2 = (CommonTree)Match (input' ID' Follow._ID_in_propertyName112);  		DebugLocation (34' 7);  		retval.isRegex = false;  		retval.name = (ID2 != null ? ID2.Text : default(string));  	}  	break;  case 2:  	DebugEnterAlt (2);  	// ./src/Parser/Grammar/JFLWalker.g:38:4: ESC_ID  	{  		DebugLocation (38' 4);  		ESC_ID3 = (CommonTree)Match (input' ESC_ID' Follow._ESC_ID_in_propertyName119);  		DebugLocation (38' 11);  		retval.isRegex = false;  		string stringText = (ESC_ID3 != null ? ESC_ID3.Text : default(string));  		retval.name = stringText.Substring (1' stringText.Length - 2);  	}  	break;  case 3:  	DebugEnterAlt (3);  	// ./src/Parser/Grammar/JFLWalker.g:43:4: REGEX  	{  		DebugLocation (43' 4);  		REGEX4 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_propertyName126);  		DebugLocation (43' 10);  		retval.isRegex = true;  		string regexText = (REGEX4 != null ? REGEX4.Text : default(string));  		retval.name = regexText.Substring (1' regexText.Length - 2);  	}  	break;  case 4:  	DebugEnterAlt (4);  	// ./src/Parser/Grammar/JFLWalker.g:48:4: '*'  	{  		DebugLocation (48' 4);  		Match (input' 27' Follow._27_in_propertyName133);  		DebugLocation (48' 8);  		retval.isRegex = false;  		retval.name = "*";  	}  	break;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyName,The following statement contains a magic number: switch (alt5) {  case 1:  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:34:4: ID  	{  		DebugLocation (34' 4);  		ID2 = (CommonTree)Match (input' ID' Follow._ID_in_propertyName112);  		DebugLocation (34' 7);  		retval.isRegex = false;  		retval.name = (ID2 != null ? ID2.Text : default(string));  	}  	break;  case 2:  	DebugEnterAlt (2);  	// ./src/Parser/Grammar/JFLWalker.g:38:4: ESC_ID  	{  		DebugLocation (38' 4);  		ESC_ID3 = (CommonTree)Match (input' ESC_ID' Follow._ESC_ID_in_propertyName119);  		DebugLocation (38' 11);  		retval.isRegex = false;  		string stringText = (ESC_ID3 != null ? ESC_ID3.Text : default(string));  		retval.name = stringText.Substring (1' stringText.Length - 2);  	}  	break;  case 3:  	DebugEnterAlt (3);  	// ./src/Parser/Grammar/JFLWalker.g:43:4: REGEX  	{  		DebugLocation (43' 4);  		REGEX4 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_propertyName126);  		DebugLocation (43' 10);  		retval.isRegex = true;  		string regexText = (REGEX4 != null ? REGEX4.Text : default(string));  		retval.name = regexText.Substring (1' regexText.Length - 2);  	}  	break;  case 4:  	DebugEnterAlt (4);  	// ./src/Parser/Grammar/JFLWalker.g:48:4: '*'  	{  		DebugLocation (48' 4);  		Match (input' 27' Follow._27_in_propertyName133);  		DebugLocation (48' 8);  		retval.isRegex = false;  		retval.name = "*";  	}  	break;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyName,The following statement contains a magic number: switch (alt5) {  case 1:  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:34:4: ID  	{  		DebugLocation (34' 4);  		ID2 = (CommonTree)Match (input' ID' Follow._ID_in_propertyName112);  		DebugLocation (34' 7);  		retval.isRegex = false;  		retval.name = (ID2 != null ? ID2.Text : default(string));  	}  	break;  case 2:  	DebugEnterAlt (2);  	// ./src/Parser/Grammar/JFLWalker.g:38:4: ESC_ID  	{  		DebugLocation (38' 4);  		ESC_ID3 = (CommonTree)Match (input' ESC_ID' Follow._ESC_ID_in_propertyName119);  		DebugLocation (38' 11);  		retval.isRegex = false;  		string stringText = (ESC_ID3 != null ? ESC_ID3.Text : default(string));  		retval.name = stringText.Substring (1' stringText.Length - 2);  	}  	break;  case 3:  	DebugEnterAlt (3);  	// ./src/Parser/Grammar/JFLWalker.g:43:4: REGEX  	{  		DebugLocation (43' 4);  		REGEX4 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_propertyName126);  		DebugLocation (43' 10);  		retval.isRegex = true;  		string regexText = (REGEX4 != null ? REGEX4.Text : default(string));  		retval.name = regexText.Substring (1' regexText.Length - 2);  	}  	break;  case 4:  	DebugEnterAlt (4);  	// ./src/Parser/Grammar/JFLWalker.g:48:4: '*'  	{  		DebugLocation (48' 4);  		Match (input' 27' Follow._27_in_propertyName133);  		DebugLocation (48' 8);  		retval.isRegex = false;  		retval.name = "*";  	}  	break;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyName,The following statement contains a magic number: switch (alt5) {  case 1:  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:34:4: ID  	{  		DebugLocation (34' 4);  		ID2 = (CommonTree)Match (input' ID' Follow._ID_in_propertyName112);  		DebugLocation (34' 7);  		retval.isRegex = false;  		retval.name = (ID2 != null ? ID2.Text : default(string));  	}  	break;  case 2:  	DebugEnterAlt (2);  	// ./src/Parser/Grammar/JFLWalker.g:38:4: ESC_ID  	{  		DebugLocation (38' 4);  		ESC_ID3 = (CommonTree)Match (input' ESC_ID' Follow._ESC_ID_in_propertyName119);  		DebugLocation (38' 11);  		retval.isRegex = false;  		string stringText = (ESC_ID3 != null ? ESC_ID3.Text : default(string));  		retval.name = stringText.Substring (1' stringText.Length - 2);  	}  	break;  case 3:  	DebugEnterAlt (3);  	// ./src/Parser/Grammar/JFLWalker.g:43:4: REGEX  	{  		DebugLocation (43' 4);  		REGEX4 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_propertyName126);  		DebugLocation (43' 10);  		retval.isRegex = true;  		string regexText = (REGEX4 != null ? REGEX4.Text : default(string));  		retval.name = regexText.Substring (1' regexText.Length - 2);  	}  	break;  case 4:  	DebugEnterAlt (4);  	// ./src/Parser/Grammar/JFLWalker.g:48:4: '*'  	{  		DebugLocation (48' 4);  		Match (input' 27' Follow._27_in_propertyName133);  		DebugLocation (48' 8);  		retval.isRegex = false;  		retval.name = "*";  	}  	break;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyName,The following statement contains a magic number: switch (alt5) {  case 1:  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:34:4: ID  	{  		DebugLocation (34' 4);  		ID2 = (CommonTree)Match (input' ID' Follow._ID_in_propertyName112);  		DebugLocation (34' 7);  		retval.isRegex = false;  		retval.name = (ID2 != null ? ID2.Text : default(string));  	}  	break;  case 2:  	DebugEnterAlt (2);  	// ./src/Parser/Grammar/JFLWalker.g:38:4: ESC_ID  	{  		DebugLocation (38' 4);  		ESC_ID3 = (CommonTree)Match (input' ESC_ID' Follow._ESC_ID_in_propertyName119);  		DebugLocation (38' 11);  		retval.isRegex = false;  		string stringText = (ESC_ID3 != null ? ESC_ID3.Text : default(string));  		retval.name = stringText.Substring (1' stringText.Length - 2);  	}  	break;  case 3:  	DebugEnterAlt (3);  	// ./src/Parser/Grammar/JFLWalker.g:43:4: REGEX  	{  		DebugLocation (43' 4);  		REGEX4 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_propertyName126);  		DebugLocation (43' 10);  		retval.isRegex = true;  		string regexText = (REGEX4 != null ? REGEX4.Text : default(string));  		retval.name = regexText.Substring (1' regexText.Length - 2);  	}  	break;  case 4:  	DebugEnterAlt (4);  	// ./src/Parser/Grammar/JFLWalker.g:48:4: '*'  	{  		DebugLocation (48' 4);  		Match (input' 27' Follow._27_in_propertyName133);  		DebugLocation (48' 8);  		retval.isRegex = false;  		retval.name = "*";  	}  	break;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyName,The following statement contains a magic number: switch (alt5) {  case 1:  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:34:4: ID  	{  		DebugLocation (34' 4);  		ID2 = (CommonTree)Match (input' ID' Follow._ID_in_propertyName112);  		DebugLocation (34' 7);  		retval.isRegex = false;  		retval.name = (ID2 != null ? ID2.Text : default(string));  	}  	break;  case 2:  	DebugEnterAlt (2);  	// ./src/Parser/Grammar/JFLWalker.g:38:4: ESC_ID  	{  		DebugLocation (38' 4);  		ESC_ID3 = (CommonTree)Match (input' ESC_ID' Follow._ESC_ID_in_propertyName119);  		DebugLocation (38' 11);  		retval.isRegex = false;  		string stringText = (ESC_ID3 != null ? ESC_ID3.Text : default(string));  		retval.name = stringText.Substring (1' stringText.Length - 2);  	}  	break;  case 3:  	DebugEnterAlt (3);  	// ./src/Parser/Grammar/JFLWalker.g:43:4: REGEX  	{  		DebugLocation (43' 4);  		REGEX4 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_propertyName126);  		DebugLocation (43' 10);  		retval.isRegex = true;  		string regexText = (REGEX4 != null ? REGEX4.Text : default(string));  		retval.name = regexText.Substring (1' regexText.Length - 2);  	}  	break;  case 4:  	DebugEnterAlt (4);  	// ./src/Parser/Grammar/JFLWalker.g:48:4: '*'  	{  		DebugLocation (48' 4);  		Match (input' 27' Follow._27_in_propertyName133);  		DebugLocation (48' 8);  		retval.isRegex = false;  		retval.name = "*";  	}  	break;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyName,The following statement contains a magic number: switch (alt5) {  case 1:  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:34:4: ID  	{  		DebugLocation (34' 4);  		ID2 = (CommonTree)Match (input' ID' Follow._ID_in_propertyName112);  		DebugLocation (34' 7);  		retval.isRegex = false;  		retval.name = (ID2 != null ? ID2.Text : default(string));  	}  	break;  case 2:  	DebugEnterAlt (2);  	// ./src/Parser/Grammar/JFLWalker.g:38:4: ESC_ID  	{  		DebugLocation (38' 4);  		ESC_ID3 = (CommonTree)Match (input' ESC_ID' Follow._ESC_ID_in_propertyName119);  		DebugLocation (38' 11);  		retval.isRegex = false;  		string stringText = (ESC_ID3 != null ? ESC_ID3.Text : default(string));  		retval.name = stringText.Substring (1' stringText.Length - 2);  	}  	break;  case 3:  	DebugEnterAlt (3);  	// ./src/Parser/Grammar/JFLWalker.g:43:4: REGEX  	{  		DebugLocation (43' 4);  		REGEX4 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_propertyName126);  		DebugLocation (43' 10);  		retval.isRegex = true;  		string regexText = (REGEX4 != null ? REGEX4.Text : default(string));  		retval.name = regexText.Substring (1' regexText.Length - 2);  	}  	break;  case 4:  	DebugEnterAlt (4);  	// ./src/Parser/Grammar/JFLWalker.g:48:4: '*'  	{  		DebugLocation (48' 4);  		Match (input' 27' Follow._27_in_propertyName133);  		DebugLocation (48' 8);  		retval.isRegex = false;  		retval.name = "*";  	}  	break;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyName,The following statement contains a magic number: switch (alt5) {  case 1:  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:34:4: ID  	{  		DebugLocation (34' 4);  		ID2 = (CommonTree)Match (input' ID' Follow._ID_in_propertyName112);  		DebugLocation (34' 7);  		retval.isRegex = false;  		retval.name = (ID2 != null ? ID2.Text : default(string));  	}  	break;  case 2:  	DebugEnterAlt (2);  	// ./src/Parser/Grammar/JFLWalker.g:38:4: ESC_ID  	{  		DebugLocation (38' 4);  		ESC_ID3 = (CommonTree)Match (input' ESC_ID' Follow._ESC_ID_in_propertyName119);  		DebugLocation (38' 11);  		retval.isRegex = false;  		string stringText = (ESC_ID3 != null ? ESC_ID3.Text : default(string));  		retval.name = stringText.Substring (1' stringText.Length - 2);  	}  	break;  case 3:  	DebugEnterAlt (3);  	// ./src/Parser/Grammar/JFLWalker.g:43:4: REGEX  	{  		DebugLocation (43' 4);  		REGEX4 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_propertyName126);  		DebugLocation (43' 10);  		retval.isRegex = true;  		string regexText = (REGEX4 != null ? REGEX4.Text : default(string));  		retval.name = regexText.Substring (1' regexText.Length - 2);  	}  	break;  case 4:  	DebugEnterAlt (4);  	// ./src/Parser/Grammar/JFLWalker.g:48:4: '*'  	{  		DebugLocation (48' 4);  		Match (input' 27' Follow._27_in_propertyName133);  		DebugLocation (48' 8);  		retval.isRegex = false;  		retval.name = "*";  	}  	break;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyName,The following statement contains a magic number: switch (alt5) {  case 1:  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:34:4: ID  	{  		DebugLocation (34' 4);  		ID2 = (CommonTree)Match (input' ID' Follow._ID_in_propertyName112);  		DebugLocation (34' 7);  		retval.isRegex = false;  		retval.name = (ID2 != null ? ID2.Text : default(string));  	}  	break;  case 2:  	DebugEnterAlt (2);  	// ./src/Parser/Grammar/JFLWalker.g:38:4: ESC_ID  	{  		DebugLocation (38' 4);  		ESC_ID3 = (CommonTree)Match (input' ESC_ID' Follow._ESC_ID_in_propertyName119);  		DebugLocation (38' 11);  		retval.isRegex = false;  		string stringText = (ESC_ID3 != null ? ESC_ID3.Text : default(string));  		retval.name = stringText.Substring (1' stringText.Length - 2);  	}  	break;  case 3:  	DebugEnterAlt (3);  	// ./src/Parser/Grammar/JFLWalker.g:43:4: REGEX  	{  		DebugLocation (43' 4);  		REGEX4 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_propertyName126);  		DebugLocation (43' 10);  		retval.isRegex = true;  		string regexText = (REGEX4 != null ? REGEX4.Text : default(string));  		retval.name = regexText.Substring (1' regexText.Length - 2);  	}  	break;  case 4:  	DebugEnterAlt (4);  	// ./src/Parser/Grammar/JFLWalker.g:48:4: '*'  	{  		DebugLocation (48' 4);  		Match (input' 27' Follow._27_in_propertyName133);  		DebugLocation (48' 8);  		retval.isRegex = false;  		retval.name = "*";  	}  	break;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyName,The following statement contains a magic number: switch (alt5) {  case 1:  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:34:4: ID  	{  		DebugLocation (34' 4);  		ID2 = (CommonTree)Match (input' ID' Follow._ID_in_propertyName112);  		DebugLocation (34' 7);  		retval.isRegex = false;  		retval.name = (ID2 != null ? ID2.Text : default(string));  	}  	break;  case 2:  	DebugEnterAlt (2);  	// ./src/Parser/Grammar/JFLWalker.g:38:4: ESC_ID  	{  		DebugLocation (38' 4);  		ESC_ID3 = (CommonTree)Match (input' ESC_ID' Follow._ESC_ID_in_propertyName119);  		DebugLocation (38' 11);  		retval.isRegex = false;  		string stringText = (ESC_ID3 != null ? ESC_ID3.Text : default(string));  		retval.name = stringText.Substring (1' stringText.Length - 2);  	}  	break;  case 3:  	DebugEnterAlt (3);  	// ./src/Parser/Grammar/JFLWalker.g:43:4: REGEX  	{  		DebugLocation (43' 4);  		REGEX4 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_propertyName126);  		DebugLocation (43' 10);  		retval.isRegex = true;  		string regexText = (REGEX4 != null ? REGEX4.Text : default(string));  		retval.name = regexText.Substring (1' regexText.Length - 2);  	}  	break;  case 4:  	DebugEnterAlt (4);  	// ./src/Parser/Grammar/JFLWalker.g:48:4: '*'  	{  		DebugLocation (48' 4);  		Match (input' 27' Follow._27_in_propertyName133);  		DebugLocation (48' 8);  		retval.isRegex = false;  		retval.name = "*";  	}  	break;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyName,The following statement contains a magic number: switch (alt5) {  case 1:  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:34:4: ID  	{  		DebugLocation (34' 4);  		ID2 = (CommonTree)Match (input' ID' Follow._ID_in_propertyName112);  		DebugLocation (34' 7);  		retval.isRegex = false;  		retval.name = (ID2 != null ? ID2.Text : default(string));  	}  	break;  case 2:  	DebugEnterAlt (2);  	// ./src/Parser/Grammar/JFLWalker.g:38:4: ESC_ID  	{  		DebugLocation (38' 4);  		ESC_ID3 = (CommonTree)Match (input' ESC_ID' Follow._ESC_ID_in_propertyName119);  		DebugLocation (38' 11);  		retval.isRegex = false;  		string stringText = (ESC_ID3 != null ? ESC_ID3.Text : default(string));  		retval.name = stringText.Substring (1' stringText.Length - 2);  	}  	break;  case 3:  	DebugEnterAlt (3);  	// ./src/Parser/Grammar/JFLWalker.g:43:4: REGEX  	{  		DebugLocation (43' 4);  		REGEX4 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_propertyName126);  		DebugLocation (43' 10);  		retval.isRegex = true;  		string regexText = (REGEX4 != null ? REGEX4.Text : default(string));  		retval.name = regexText.Substring (1' regexText.Length - 2);  	}  	break;  case 4:  	DebugEnterAlt (4);  	// ./src/Parser/Grammar/JFLWalker.g:48:4: '*'  	{  		DebugLocation (48' 4);  		Match (input' 27' Follow._27_in_propertyName133);  		DebugLocation (48' 8);  		retval.isRegex = false;  		retval.name = "*";  	}  	break;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyName,The following statement contains a magic number: switch (alt5) {  case 1:  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:34:4: ID  	{  		DebugLocation (34' 4);  		ID2 = (CommonTree)Match (input' ID' Follow._ID_in_propertyName112);  		DebugLocation (34' 7);  		retval.isRegex = false;  		retval.name = (ID2 != null ? ID2.Text : default(string));  	}  	break;  case 2:  	DebugEnterAlt (2);  	// ./src/Parser/Grammar/JFLWalker.g:38:4: ESC_ID  	{  		DebugLocation (38' 4);  		ESC_ID3 = (CommonTree)Match (input' ESC_ID' Follow._ESC_ID_in_propertyName119);  		DebugLocation (38' 11);  		retval.isRegex = false;  		string stringText = (ESC_ID3 != null ? ESC_ID3.Text : default(string));  		retval.name = stringText.Substring (1' stringText.Length - 2);  	}  	break;  case 3:  	DebugEnterAlt (3);  	// ./src/Parser/Grammar/JFLWalker.g:43:4: REGEX  	{  		DebugLocation (43' 4);  		REGEX4 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_propertyName126);  		DebugLocation (43' 10);  		retval.isRegex = true;  		string regexText = (REGEX4 != null ? REGEX4.Text : default(string));  		retval.name = regexText.Substring (1' regexText.Length - 2);  	}  	break;  case 4:  	DebugEnterAlt (4);  	// ./src/Parser/Grammar/JFLWalker.g:48:4: '*'  	{  		DebugLocation (48' 4);  		Match (input' 27' Follow._27_in_propertyName133);  		DebugLocation (48' 8);  		retval.isRegex = false;  		retval.name = "*";  	}  	break;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyName,The following statement contains a magic number: switch (alt5) {  case 1:  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:34:4: ID  	{  		DebugLocation (34' 4);  		ID2 = (CommonTree)Match (input' ID' Follow._ID_in_propertyName112);  		DebugLocation (34' 7);  		retval.isRegex = false;  		retval.name = (ID2 != null ? ID2.Text : default(string));  	}  	break;  case 2:  	DebugEnterAlt (2);  	// ./src/Parser/Grammar/JFLWalker.g:38:4: ESC_ID  	{  		DebugLocation (38' 4);  		ESC_ID3 = (CommonTree)Match (input' ESC_ID' Follow._ESC_ID_in_propertyName119);  		DebugLocation (38' 11);  		retval.isRegex = false;  		string stringText = (ESC_ID3 != null ? ESC_ID3.Text : default(string));  		retval.name = stringText.Substring (1' stringText.Length - 2);  	}  	break;  case 3:  	DebugEnterAlt (3);  	// ./src/Parser/Grammar/JFLWalker.g:43:4: REGEX  	{  		DebugLocation (43' 4);  		REGEX4 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_propertyName126);  		DebugLocation (43' 10);  		retval.isRegex = true;  		string regexText = (REGEX4 != null ? REGEX4.Text : default(string));  		retval.name = regexText.Substring (1' regexText.Length - 2);  	}  	break;  case 4:  	DebugEnterAlt (4);  	// ./src/Parser/Grammar/JFLWalker.g:48:4: '*'  	{  		DebugLocation (48' 4);  		Match (input' 27' Follow._27_in_propertyName133);  		DebugLocation (48' 8);  		retval.isRegex = false;  		retval.name = "*";  	}  	break;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyName,The following statement contains a magic number: switch (alt5) {  case 1:  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:34:4: ID  	{  		DebugLocation (34' 4);  		ID2 = (CommonTree)Match (input' ID' Follow._ID_in_propertyName112);  		DebugLocation (34' 7);  		retval.isRegex = false;  		retval.name = (ID2 != null ? ID2.Text : default(string));  	}  	break;  case 2:  	DebugEnterAlt (2);  	// ./src/Parser/Grammar/JFLWalker.g:38:4: ESC_ID  	{  		DebugLocation (38' 4);  		ESC_ID3 = (CommonTree)Match (input' ESC_ID' Follow._ESC_ID_in_propertyName119);  		DebugLocation (38' 11);  		retval.isRegex = false;  		string stringText = (ESC_ID3 != null ? ESC_ID3.Text : default(string));  		retval.name = stringText.Substring (1' stringText.Length - 2);  	}  	break;  case 3:  	DebugEnterAlt (3);  	// ./src/Parser/Grammar/JFLWalker.g:43:4: REGEX  	{  		DebugLocation (43' 4);  		REGEX4 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_propertyName126);  		DebugLocation (43' 10);  		retval.isRegex = true;  		string regexText = (REGEX4 != null ? REGEX4.Text : default(string));  		retval.name = regexText.Substring (1' regexText.Length - 2);  	}  	break;  case 4:  	DebugEnterAlt (4);  	// ./src/Parser/Grammar/JFLWalker.g:48:4: '*'  	{  		DebugLocation (48' 4);  		Match (input' 27' Follow._27_in_propertyName133);  		DebugLocation (48' 8);  		retval.isRegex = false;  		retval.name = "*";  	}  	break;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyName,The following statement contains a magic number: switch (alt5) {  case 1:  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:34:4: ID  	{  		DebugLocation (34' 4);  		ID2 = (CommonTree)Match (input' ID' Follow._ID_in_propertyName112);  		DebugLocation (34' 7);  		retval.isRegex = false;  		retval.name = (ID2 != null ? ID2.Text : default(string));  	}  	break;  case 2:  	DebugEnterAlt (2);  	// ./src/Parser/Grammar/JFLWalker.g:38:4: ESC_ID  	{  		DebugLocation (38' 4);  		ESC_ID3 = (CommonTree)Match (input' ESC_ID' Follow._ESC_ID_in_propertyName119);  		DebugLocation (38' 11);  		retval.isRegex = false;  		string stringText = (ESC_ID3 != null ? ESC_ID3.Text : default(string));  		retval.name = stringText.Substring (1' stringText.Length - 2);  	}  	break;  case 3:  	DebugEnterAlt (3);  	// ./src/Parser/Grammar/JFLWalker.g:43:4: REGEX  	{  		DebugLocation (43' 4);  		REGEX4 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_propertyName126);  		DebugLocation (43' 10);  		retval.isRegex = true;  		string regexText = (REGEX4 != null ? REGEX4.Text : default(string));  		retval.name = regexText.Substring (1' regexText.Length - 2);  	}  	break;  case 4:  	DebugEnterAlt (4);  	// ./src/Parser/Grammar/JFLWalker.g:48:4: '*'  	{  		DebugLocation (48' 4);  		Match (input' 27' Follow._27_in_propertyName133);  		DebugLocation (48' 8);  		retval.isRegex = false;  		retval.name = "*";  	}  	break;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyName,The following statement contains a magic number: DebugLocation (34' 4);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyName,The following statement contains a magic number: DebugLocation (34' 4);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyName,The following statement contains a magic number: DebugLocation (34' 7);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyName,The following statement contains a magic number: DebugLocation (34' 7);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyName,The following statement contains a magic number: DebugEnterAlt (2);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyName,The following statement contains a magic number: DebugLocation (38' 4);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyName,The following statement contains a magic number: DebugLocation (38' 4);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyName,The following statement contains a magic number: DebugLocation (38' 11);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyName,The following statement contains a magic number: DebugLocation (38' 11);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyName,The following statement contains a magic number: retval.name = stringText.Substring (1' stringText.Length - 2);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyName,The following statement contains a magic number: DebugEnterAlt (3);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyName,The following statement contains a magic number: DebugLocation (43' 4);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyName,The following statement contains a magic number: DebugLocation (43' 4);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyName,The following statement contains a magic number: DebugLocation (43' 10);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyName,The following statement contains a magic number: DebugLocation (43' 10);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyName,The following statement contains a magic number: retval.name = regexText.Substring (1' regexText.Length - 2);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyName,The following statement contains a magic number: DebugEnterAlt (4);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyName,The following statement contains a magic number: DebugLocation (48' 4);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyName,The following statement contains a magic number: DebugLocation (48' 4);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyName,The following statement contains a magic number: Match (input' 27' Follow._27_in_propertyName133);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyName,The following statement contains a magic number: DebugLocation (48' 8);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyName,The following statement contains a magic number: DebugLocation (48' 8);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyName,The following statement contains a magic number: TraceOut ("propertyName"' 4);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyName,The following statement contains a magic number: LeaveRule ("propertyName"' 4);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyName,The following statement contains a magic number: DebugLocation (52' 1);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filter,The following statement contains a magic number: EnterRule ("filter"' 5);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filter,The following statement contains a magic number: TraceIn ("filter"' 5);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filter,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "filter");  	DebugLocation (54' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:55:2: ( ^( FILTER filterExpr ) )  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:55:4: ^( FILTER filterExpr )  		{  			DebugLocation (55' 4);  			DebugLocation (55' 6);  			Match (input' FILTER' Follow._FILTER_in_filter149);  			Match (input' TokenTypes.Down' null);  			DebugLocation (55' 13);  			PushFollow (Follow._filterExpr_in_filter151);  			filterExpr5 = filterExpr ();  			PopFollow ();  			Match (input' TokenTypes.Up' null);  			DebugLocation (55' 25);  			currProperty.AddFilter (filterExpr5);  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("filter"' 5);  		LeaveRule ("filter"' 5);  		LeaveRule_filter ();  	}  	DebugLocation (58' 1);  }  finally {  	DebugExitRule (GrammarFileName' "filter");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filter,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "filter");  	DebugLocation (54' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:55:2: ( ^( FILTER filterExpr ) )  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:55:4: ^( FILTER filterExpr )  		{  			DebugLocation (55' 4);  			DebugLocation (55' 6);  			Match (input' FILTER' Follow._FILTER_in_filter149);  			Match (input' TokenTypes.Down' null);  			DebugLocation (55' 13);  			PushFollow (Follow._filterExpr_in_filter151);  			filterExpr5 = filterExpr ();  			PopFollow ();  			Match (input' TokenTypes.Up' null);  			DebugLocation (55' 25);  			currProperty.AddFilter (filterExpr5);  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("filter"' 5);  		LeaveRule ("filter"' 5);  		LeaveRule_filter ();  	}  	DebugLocation (58' 1);  }  finally {  	DebugExitRule (GrammarFileName' "filter");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filter,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "filter");  	DebugLocation (54' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:55:2: ( ^( FILTER filterExpr ) )  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:55:4: ^( FILTER filterExpr )  		{  			DebugLocation (55' 4);  			DebugLocation (55' 6);  			Match (input' FILTER' Follow._FILTER_in_filter149);  			Match (input' TokenTypes.Down' null);  			DebugLocation (55' 13);  			PushFollow (Follow._filterExpr_in_filter151);  			filterExpr5 = filterExpr ();  			PopFollow ();  			Match (input' TokenTypes.Up' null);  			DebugLocation (55' 25);  			currProperty.AddFilter (filterExpr5);  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("filter"' 5);  		LeaveRule ("filter"' 5);  		LeaveRule_filter ();  	}  	DebugLocation (58' 1);  }  finally {  	DebugExitRule (GrammarFileName' "filter");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filter,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "filter");  	DebugLocation (54' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:55:2: ( ^( FILTER filterExpr ) )  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:55:4: ^( FILTER filterExpr )  		{  			DebugLocation (55' 4);  			DebugLocation (55' 6);  			Match (input' FILTER' Follow._FILTER_in_filter149);  			Match (input' TokenTypes.Down' null);  			DebugLocation (55' 13);  			PushFollow (Follow._filterExpr_in_filter151);  			filterExpr5 = filterExpr ();  			PopFollow ();  			Match (input' TokenTypes.Up' null);  			DebugLocation (55' 25);  			currProperty.AddFilter (filterExpr5);  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("filter"' 5);  		LeaveRule ("filter"' 5);  		LeaveRule_filter ();  	}  	DebugLocation (58' 1);  }  finally {  	DebugExitRule (GrammarFileName' "filter");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filter,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "filter");  	DebugLocation (54' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:55:2: ( ^( FILTER filterExpr ) )  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:55:4: ^( FILTER filterExpr )  		{  			DebugLocation (55' 4);  			DebugLocation (55' 6);  			Match (input' FILTER' Follow._FILTER_in_filter149);  			Match (input' TokenTypes.Down' null);  			DebugLocation (55' 13);  			PushFollow (Follow._filterExpr_in_filter151);  			filterExpr5 = filterExpr ();  			PopFollow ();  			Match (input' TokenTypes.Up' null);  			DebugLocation (55' 25);  			currProperty.AddFilter (filterExpr5);  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("filter"' 5);  		LeaveRule ("filter"' 5);  		LeaveRule_filter ();  	}  	DebugLocation (58' 1);  }  finally {  	DebugExitRule (GrammarFileName' "filter");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filter,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "filter");  	DebugLocation (54' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:55:2: ( ^( FILTER filterExpr ) )  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:55:4: ^( FILTER filterExpr )  		{  			DebugLocation (55' 4);  			DebugLocation (55' 6);  			Match (input' FILTER' Follow._FILTER_in_filter149);  			Match (input' TokenTypes.Down' null);  			DebugLocation (55' 13);  			PushFollow (Follow._filterExpr_in_filter151);  			filterExpr5 = filterExpr ();  			PopFollow ();  			Match (input' TokenTypes.Up' null);  			DebugLocation (55' 25);  			currProperty.AddFilter (filterExpr5);  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("filter"' 5);  		LeaveRule ("filter"' 5);  		LeaveRule_filter ();  	}  	DebugLocation (58' 1);  }  finally {  	DebugExitRule (GrammarFileName' "filter");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filter,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "filter");  	DebugLocation (54' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:55:2: ( ^( FILTER filterExpr ) )  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:55:4: ^( FILTER filterExpr )  		{  			DebugLocation (55' 4);  			DebugLocation (55' 6);  			Match (input' FILTER' Follow._FILTER_in_filter149);  			Match (input' TokenTypes.Down' null);  			DebugLocation (55' 13);  			PushFollow (Follow._filterExpr_in_filter151);  			filterExpr5 = filterExpr ();  			PopFollow ();  			Match (input' TokenTypes.Up' null);  			DebugLocation (55' 25);  			currProperty.AddFilter (filterExpr5);  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("filter"' 5);  		LeaveRule ("filter"' 5);  		LeaveRule_filter ();  	}  	DebugLocation (58' 1);  }  finally {  	DebugExitRule (GrammarFileName' "filter");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filter,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "filter");  	DebugLocation (54' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:55:2: ( ^( FILTER filterExpr ) )  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:55:4: ^( FILTER filterExpr )  		{  			DebugLocation (55' 4);  			DebugLocation (55' 6);  			Match (input' FILTER' Follow._FILTER_in_filter149);  			Match (input' TokenTypes.Down' null);  			DebugLocation (55' 13);  			PushFollow (Follow._filterExpr_in_filter151);  			filterExpr5 = filterExpr ();  			PopFollow ();  			Match (input' TokenTypes.Up' null);  			DebugLocation (55' 25);  			currProperty.AddFilter (filterExpr5);  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("filter"' 5);  		LeaveRule ("filter"' 5);  		LeaveRule_filter ();  	}  	DebugLocation (58' 1);  }  finally {  	DebugExitRule (GrammarFileName' "filter");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filter,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "filter");  	DebugLocation (54' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:55:2: ( ^( FILTER filterExpr ) )  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:55:4: ^( FILTER filterExpr )  		{  			DebugLocation (55' 4);  			DebugLocation (55' 6);  			Match (input' FILTER' Follow._FILTER_in_filter149);  			Match (input' TokenTypes.Down' null);  			DebugLocation (55' 13);  			PushFollow (Follow._filterExpr_in_filter151);  			filterExpr5 = filterExpr ();  			PopFollow ();  			Match (input' TokenTypes.Up' null);  			DebugLocation (55' 25);  			currProperty.AddFilter (filterExpr5);  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("filter"' 5);  		LeaveRule ("filter"' 5);  		LeaveRule_filter ();  	}  	DebugLocation (58' 1);  }  finally {  	DebugExitRule (GrammarFileName' "filter");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filter,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "filter");  	DebugLocation (54' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:55:2: ( ^( FILTER filterExpr ) )  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:55:4: ^( FILTER filterExpr )  		{  			DebugLocation (55' 4);  			DebugLocation (55' 6);  			Match (input' FILTER' Follow._FILTER_in_filter149);  			Match (input' TokenTypes.Down' null);  			DebugLocation (55' 13);  			PushFollow (Follow._filterExpr_in_filter151);  			filterExpr5 = filterExpr ();  			PopFollow ();  			Match (input' TokenTypes.Up' null);  			DebugLocation (55' 25);  			currProperty.AddFilter (filterExpr5);  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("filter"' 5);  		LeaveRule ("filter"' 5);  		LeaveRule_filter ();  	}  	DebugLocation (58' 1);  }  finally {  	DebugExitRule (GrammarFileName' "filter");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filter,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "filter");  	DebugLocation (54' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:55:2: ( ^( FILTER filterExpr ) )  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:55:4: ^( FILTER filterExpr )  		{  			DebugLocation (55' 4);  			DebugLocation (55' 6);  			Match (input' FILTER' Follow._FILTER_in_filter149);  			Match (input' TokenTypes.Down' null);  			DebugLocation (55' 13);  			PushFollow (Follow._filterExpr_in_filter151);  			filterExpr5 = filterExpr ();  			PopFollow ();  			Match (input' TokenTypes.Up' null);  			DebugLocation (55' 25);  			currProperty.AddFilter (filterExpr5);  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("filter"' 5);  		LeaveRule ("filter"' 5);  		LeaveRule_filter ();  	}  	DebugLocation (58' 1);  }  finally {  	DebugExitRule (GrammarFileName' "filter");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filter,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "filter");  	DebugLocation (54' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:55:2: ( ^( FILTER filterExpr ) )  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:55:4: ^( FILTER filterExpr )  		{  			DebugLocation (55' 4);  			DebugLocation (55' 6);  			Match (input' FILTER' Follow._FILTER_in_filter149);  			Match (input' TokenTypes.Down' null);  			DebugLocation (55' 13);  			PushFollow (Follow._filterExpr_in_filter151);  			filterExpr5 = filterExpr ();  			PopFollow ();  			Match (input' TokenTypes.Up' null);  			DebugLocation (55' 25);  			currProperty.AddFilter (filterExpr5);  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("filter"' 5);  		LeaveRule ("filter"' 5);  		LeaveRule_filter ();  	}  	DebugLocation (58' 1);  }  finally {  	DebugExitRule (GrammarFileName' "filter");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filter,The following statement contains a magic number: DebugLocation (54' 1);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filter,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:55:2: ( ^( FILTER filterExpr ) )  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:55:4: ^( FILTER filterExpr )  	{  		DebugLocation (55' 4);  		DebugLocation (55' 6);  		Match (input' FILTER' Follow._FILTER_in_filter149);  		Match (input' TokenTypes.Down' null);  		DebugLocation (55' 13);  		PushFollow (Follow._filterExpr_in_filter151);  		filterExpr5 = filterExpr ();  		PopFollow ();  		Match (input' TokenTypes.Up' null);  		DebugLocation (55' 25);  		currProperty.AddFilter (filterExpr5);  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("filter"' 5);  	LeaveRule ("filter"' 5);  	LeaveRule_filter ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filter,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:55:2: ( ^( FILTER filterExpr ) )  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:55:4: ^( FILTER filterExpr )  	{  		DebugLocation (55' 4);  		DebugLocation (55' 6);  		Match (input' FILTER' Follow._FILTER_in_filter149);  		Match (input' TokenTypes.Down' null);  		DebugLocation (55' 13);  		PushFollow (Follow._filterExpr_in_filter151);  		filterExpr5 = filterExpr ();  		PopFollow ();  		Match (input' TokenTypes.Up' null);  		DebugLocation (55' 25);  		currProperty.AddFilter (filterExpr5);  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("filter"' 5);  	LeaveRule ("filter"' 5);  	LeaveRule_filter ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filter,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:55:2: ( ^( FILTER filterExpr ) )  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:55:4: ^( FILTER filterExpr )  	{  		DebugLocation (55' 4);  		DebugLocation (55' 6);  		Match (input' FILTER' Follow._FILTER_in_filter149);  		Match (input' TokenTypes.Down' null);  		DebugLocation (55' 13);  		PushFollow (Follow._filterExpr_in_filter151);  		filterExpr5 = filterExpr ();  		PopFollow ();  		Match (input' TokenTypes.Up' null);  		DebugLocation (55' 25);  		currProperty.AddFilter (filterExpr5);  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("filter"' 5);  	LeaveRule ("filter"' 5);  	LeaveRule_filter ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filter,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:55:2: ( ^( FILTER filterExpr ) )  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:55:4: ^( FILTER filterExpr )  	{  		DebugLocation (55' 4);  		DebugLocation (55' 6);  		Match (input' FILTER' Follow._FILTER_in_filter149);  		Match (input' TokenTypes.Down' null);  		DebugLocation (55' 13);  		PushFollow (Follow._filterExpr_in_filter151);  		filterExpr5 = filterExpr ();  		PopFollow ();  		Match (input' TokenTypes.Up' null);  		DebugLocation (55' 25);  		currProperty.AddFilter (filterExpr5);  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("filter"' 5);  	LeaveRule ("filter"' 5);  	LeaveRule_filter ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filter,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:55:2: ( ^( FILTER filterExpr ) )  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:55:4: ^( FILTER filterExpr )  	{  		DebugLocation (55' 4);  		DebugLocation (55' 6);  		Match (input' FILTER' Follow._FILTER_in_filter149);  		Match (input' TokenTypes.Down' null);  		DebugLocation (55' 13);  		PushFollow (Follow._filterExpr_in_filter151);  		filterExpr5 = filterExpr ();  		PopFollow ();  		Match (input' TokenTypes.Up' null);  		DebugLocation (55' 25);  		currProperty.AddFilter (filterExpr5);  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("filter"' 5);  	LeaveRule ("filter"' 5);  	LeaveRule_filter ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filter,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:55:2: ( ^( FILTER filterExpr ) )  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:55:4: ^( FILTER filterExpr )  	{  		DebugLocation (55' 4);  		DebugLocation (55' 6);  		Match (input' FILTER' Follow._FILTER_in_filter149);  		Match (input' TokenTypes.Down' null);  		DebugLocation (55' 13);  		PushFollow (Follow._filterExpr_in_filter151);  		filterExpr5 = filterExpr ();  		PopFollow ();  		Match (input' TokenTypes.Up' null);  		DebugLocation (55' 25);  		currProperty.AddFilter (filterExpr5);  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("filter"' 5);  	LeaveRule ("filter"' 5);  	LeaveRule_filter ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filter,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:55:2: ( ^( FILTER filterExpr ) )  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:55:4: ^( FILTER filterExpr )  	{  		DebugLocation (55' 4);  		DebugLocation (55' 6);  		Match (input' FILTER' Follow._FILTER_in_filter149);  		Match (input' TokenTypes.Down' null);  		DebugLocation (55' 13);  		PushFollow (Follow._filterExpr_in_filter151);  		filterExpr5 = filterExpr ();  		PopFollow ();  		Match (input' TokenTypes.Up' null);  		DebugLocation (55' 25);  		currProperty.AddFilter (filterExpr5);  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("filter"' 5);  	LeaveRule ("filter"' 5);  	LeaveRule_filter ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filter,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:55:2: ( ^( FILTER filterExpr ) )  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:55:4: ^( FILTER filterExpr )  	{  		DebugLocation (55' 4);  		DebugLocation (55' 6);  		Match (input' FILTER' Follow._FILTER_in_filter149);  		Match (input' TokenTypes.Down' null);  		DebugLocation (55' 13);  		PushFollow (Follow._filterExpr_in_filter151);  		filterExpr5 = filterExpr ();  		PopFollow ();  		Match (input' TokenTypes.Up' null);  		DebugLocation (55' 25);  		currProperty.AddFilter (filterExpr5);  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("filter"' 5);  	LeaveRule ("filter"' 5);  	LeaveRule_filter ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filter,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:55:2: ( ^( FILTER filterExpr ) )  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:55:4: ^( FILTER filterExpr )  	{  		DebugLocation (55' 4);  		DebugLocation (55' 6);  		Match (input' FILTER' Follow._FILTER_in_filter149);  		Match (input' TokenTypes.Down' null);  		DebugLocation (55' 13);  		PushFollow (Follow._filterExpr_in_filter151);  		filterExpr5 = filterExpr ();  		PopFollow ();  		Match (input' TokenTypes.Up' null);  		DebugLocation (55' 25);  		currProperty.AddFilter (filterExpr5);  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("filter"' 5);  	LeaveRule ("filter"' 5);  	LeaveRule_filter ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filter,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:55:2: ( ^( FILTER filterExpr ) )  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:55:4: ^( FILTER filterExpr )  	{  		DebugLocation (55' 4);  		DebugLocation (55' 6);  		Match (input' FILTER' Follow._FILTER_in_filter149);  		Match (input' TokenTypes.Down' null);  		DebugLocation (55' 13);  		PushFollow (Follow._filterExpr_in_filter151);  		filterExpr5 = filterExpr ();  		PopFollow ();  		Match (input' TokenTypes.Up' null);  		DebugLocation (55' 25);  		currProperty.AddFilter (filterExpr5);  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("filter"' 5);  	LeaveRule ("filter"' 5);  	LeaveRule_filter ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filter,The following statement contains a magic number: DebugLocation (55' 4);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filter,The following statement contains a magic number: DebugLocation (55' 4);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filter,The following statement contains a magic number: DebugLocation (55' 6);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filter,The following statement contains a magic number: DebugLocation (55' 6);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filter,The following statement contains a magic number: DebugLocation (55' 13);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filter,The following statement contains a magic number: DebugLocation (55' 13);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filter,The following statement contains a magic number: DebugLocation (55' 25);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filter,The following statement contains a magic number: DebugLocation (55' 25);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filter,The following statement contains a magic number: TraceOut ("filter"' 5);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filter,The following statement contains a magic number: LeaveRule ("filter"' 5);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filter,The following statement contains a magic number: DebugLocation (58' 1);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: EnterRule ("filterExpr"' 6);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: TraceIn ("filterExpr"' 6);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "filterExpr");  	DebugLocation (60' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  		int alt9 = 9;  		try {  			DebugEnterDecision (9' false);  			switch (input.LA (1)) {  			case CHAIN_OPERATOR:  			case COMPARATOR:  				{  					alt9 = 1;  				}  				break;  			case EXPR:  				{  					int LA9_2 = input.LA (2);  					if ((LA9_2 == DOWN)) {  						int LA9_3 = input.LA (3);  						if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  							alt9 = 2;  						}  						else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  							alt9 = 3;  						}  						else {  							NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  							DebugRecognitionException (nvae);  							throw nvae;  						}  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				break;  			case STRING:  				{  					alt9 = 4;  				}  				break;  			case REGEX:  				{  					alt9 = 5;  				}  				break;  			case NUMBER:  				{  					alt9 = 6;  				}  				break;  			case TRUE:  				{  					alt9 = 7;  				}  				break;  			case FALSE:  				{  					alt9 = 8;  				}  				break;  			case NULL:  				{  					alt9 = 9;  				}  				break;  			default: {  				NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  			}  		}  		finally {  			DebugExitDecision (9);  		}  		switch (alt9) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  			{  				DebugLocation (64' 4);  				DebugLocation (64' 6);  				PushFollow (Follow._comparator_in_filterExpr175);  				comparator6 = comparator ();  				PopFollow ();  				Match (input' TokenTypes.Down' null);  				DebugLocation (64' 18);  				PushFollow (Follow._filterExpr_in_filterExpr179);  				a = filterExpr ();  				PopFollow ();  				DebugLocation (64' 31);  				PushFollow (Follow._filterExpr_in_filterExpr183);  				b = filterExpr ();  				PopFollow ();  				Match (input' TokenTypes.Up' null);  				DebugLocation (65' 4);  				Comparator newComparator;  				switch (comparator6) {  				case "=":  					newComparator = Comparator.Equals;  					break;  				case "!=":  					newComparator = Comparator.NotEquals;  					break;  				case ">":  					newComparator = Comparator.Greater;  					break;  				case "<":  					newComparator = Comparator.Less;  					break;  				case ">=":  					newComparator = Comparator.GreaterOrEqual;  					break;  				case "<=":  					newComparator = Comparator.LessOrEqual;  					break;  				case "&":  					newComparator = Comparator.And;  					break;  				case "|":  					newComparator = Comparator.Or;  					break;  				default:  					newComparator = Comparator.Equals;  					break;  				}  				filterNode = new BoolExpression (a' newComparator' b);  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  			{  				DebugLocation (98' 4);  				DebugLocation (98' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr195);  				Match (input' TokenTypes.Down' null);  				DebugLocation (98' 12);  				PushFollow (Follow._filterExpr_in_filterExpr199);  				f = filterExpr ();  				PopFollow ();  				DebugLocation (98' 31);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  				int alt6 = 2;  				try {  					DebugEnterSubRule (6);  					try {  						DebugEnterDecision (6' false);  						int LA6_1 = input.LA (1);  						if ((LA6_1 == 24)) {  							alt6 = 1;  						}  					}  					finally {  						DebugExitDecision (6);  					}  					switch (alt6) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  						{  							DebugLocation (98' 31);  							inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (6);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (99' 4);  				FilterTreeNode newNode = f;  				if ((inverse != null ? inverse.Text : default(string)) == "!")  					newNode.ToggleInversed ();  				filterNode = newNode;  			}  			break;  		case 3:  			DebugEnterAlt (3);  			// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  			{  				DebugLocation (105' 4);  				DebugLocation (105' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr216);  				Match (input' TokenTypes.Down' null);  				DebugLocation (105' 12);  				PushFollow (Follow._propertyChain_in_filterExpr219);  				propertyChain (propertySegments);  				PopFollow ();  				DebugLocation (105' 51);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  				int alt7 = 2;  				try {  					DebugEnterSubRule (7);  					try {  						DebugEnterDecision (7' false);  						int LA7_1 = input.LA (1);  						if ((LA7_1 == 31)) {  							alt7 = 1;  						}  					}  					finally {  						DebugExitDecision (7);  					}  					switch (alt7) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  						{  							DebugLocation (105' 51);  							inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (7);  				}  				DebugLocation (105' 60);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  				int alt8 = 2;  				try {  					DebugEnterSubRule (8);  					try {  						DebugEnterDecision (8' false);  						int LA8_1 = input.LA (1);  						if ((LA8_1 == 24)) {  							alt8 = 1;  						}  					}  					finally {  						DebugExitDecision (8);  					}  					switch (alt8) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  						{  							DebugLocation (105' 60);  							not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (8);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (106' 4);  				FilterTreeNode newProperty = new Property (propertySegments);  				if ((inverse != null ? inverse.Text : default(string)) == "?")  					filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  				else {  					if ((not != null ? not.Text : default(string)) == "!")  						newProperty.ToggleInversed ();  					filterNode = newProperty;  				}  			}  			break;  		case 4:  			DebugEnterAlt (4);  			// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  			{  				DebugLocation (116' 4);  				STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  				DebugLocation (117' 4);  				string stringText = (STRING7 != null ? STRING7.Text : default(string));  				stringText = stringText.Substring (1' stringText.Length - 2);  				filterNode = new Value (stringText);  			}  			break;  		case 5:  			DebugEnterAlt (5);  			// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  			{  				DebugLocation (122' 4);  				REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  				DebugLocation (123' 4);  				string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  				regexText = regexText.Substring (1' regexText.Length - 2);  				filterNode = new RegExp (regexText);  			}  			break;  		case 6:  			DebugEnterAlt (6);  			// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  			{  				DebugLocation (128' 4);  				NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  				DebugLocation (129' 4);  				filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  			}  			break;  		case 7:  			DebugEnterAlt (7);  			// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  			{  				DebugLocation (132' 4);  				Match (input' TRUE' Follow._TRUE_in_filterExpr271);  				DebugLocation (133' 4);  				filterNode = new Value (true);  			}  			break;  		case 8:  			DebugEnterAlt (8);  			// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  			{  				DebugLocation (136' 4);  				Match (input' FALSE' Follow._FALSE_in_filterExpr281);  				DebugLocation (137' 4);  				filterNode = new Value (false);  			}  			break;  		case 9:  			DebugEnterAlt (9);  			// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  			{  				DebugLocation (140' 4);  				Match (input' NULL' Follow._NULL_in_filterExpr291);  				DebugLocation (141' 4);  				filterNode = new Value (null);  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("filterExpr"' 6);  		LeaveRule ("filterExpr"' 6);  		LeaveRule_filterExpr ();  	}  	DebugLocation (144' 1);  }  finally {  	DebugExitRule (GrammarFileName' "filterExpr");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "filterExpr");  	DebugLocation (60' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  		int alt9 = 9;  		try {  			DebugEnterDecision (9' false);  			switch (input.LA (1)) {  			case CHAIN_OPERATOR:  			case COMPARATOR:  				{  					alt9 = 1;  				}  				break;  			case EXPR:  				{  					int LA9_2 = input.LA (2);  					if ((LA9_2 == DOWN)) {  						int LA9_3 = input.LA (3);  						if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  							alt9 = 2;  						}  						else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  							alt9 = 3;  						}  						else {  							NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  							DebugRecognitionException (nvae);  							throw nvae;  						}  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				break;  			case STRING:  				{  					alt9 = 4;  				}  				break;  			case REGEX:  				{  					alt9 = 5;  				}  				break;  			case NUMBER:  				{  					alt9 = 6;  				}  				break;  			case TRUE:  				{  					alt9 = 7;  				}  				break;  			case FALSE:  				{  					alt9 = 8;  				}  				break;  			case NULL:  				{  					alt9 = 9;  				}  				break;  			default: {  				NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  			}  		}  		finally {  			DebugExitDecision (9);  		}  		switch (alt9) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  			{  				DebugLocation (64' 4);  				DebugLocation (64' 6);  				PushFollow (Follow._comparator_in_filterExpr175);  				comparator6 = comparator ();  				PopFollow ();  				Match (input' TokenTypes.Down' null);  				DebugLocation (64' 18);  				PushFollow (Follow._filterExpr_in_filterExpr179);  				a = filterExpr ();  				PopFollow ();  				DebugLocation (64' 31);  				PushFollow (Follow._filterExpr_in_filterExpr183);  				b = filterExpr ();  				PopFollow ();  				Match (input' TokenTypes.Up' null);  				DebugLocation (65' 4);  				Comparator newComparator;  				switch (comparator6) {  				case "=":  					newComparator = Comparator.Equals;  					break;  				case "!=":  					newComparator = Comparator.NotEquals;  					break;  				case ">":  					newComparator = Comparator.Greater;  					break;  				case "<":  					newComparator = Comparator.Less;  					break;  				case ">=":  					newComparator = Comparator.GreaterOrEqual;  					break;  				case "<=":  					newComparator = Comparator.LessOrEqual;  					break;  				case "&":  					newComparator = Comparator.And;  					break;  				case "|":  					newComparator = Comparator.Or;  					break;  				default:  					newComparator = Comparator.Equals;  					break;  				}  				filterNode = new BoolExpression (a' newComparator' b);  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  			{  				DebugLocation (98' 4);  				DebugLocation (98' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr195);  				Match (input' TokenTypes.Down' null);  				DebugLocation (98' 12);  				PushFollow (Follow._filterExpr_in_filterExpr199);  				f = filterExpr ();  				PopFollow ();  				DebugLocation (98' 31);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  				int alt6 = 2;  				try {  					DebugEnterSubRule (6);  					try {  						DebugEnterDecision (6' false);  						int LA6_1 = input.LA (1);  						if ((LA6_1 == 24)) {  							alt6 = 1;  						}  					}  					finally {  						DebugExitDecision (6);  					}  					switch (alt6) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  						{  							DebugLocation (98' 31);  							inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (6);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (99' 4);  				FilterTreeNode newNode = f;  				if ((inverse != null ? inverse.Text : default(string)) == "!")  					newNode.ToggleInversed ();  				filterNode = newNode;  			}  			break;  		case 3:  			DebugEnterAlt (3);  			// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  			{  				DebugLocation (105' 4);  				DebugLocation (105' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr216);  				Match (input' TokenTypes.Down' null);  				DebugLocation (105' 12);  				PushFollow (Follow._propertyChain_in_filterExpr219);  				propertyChain (propertySegments);  				PopFollow ();  				DebugLocation (105' 51);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  				int alt7 = 2;  				try {  					DebugEnterSubRule (7);  					try {  						DebugEnterDecision (7' false);  						int LA7_1 = input.LA (1);  						if ((LA7_1 == 31)) {  							alt7 = 1;  						}  					}  					finally {  						DebugExitDecision (7);  					}  					switch (alt7) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  						{  							DebugLocation (105' 51);  							inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (7);  				}  				DebugLocation (105' 60);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  				int alt8 = 2;  				try {  					DebugEnterSubRule (8);  					try {  						DebugEnterDecision (8' false);  						int LA8_1 = input.LA (1);  						if ((LA8_1 == 24)) {  							alt8 = 1;  						}  					}  					finally {  						DebugExitDecision (8);  					}  					switch (alt8) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  						{  							DebugLocation (105' 60);  							not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (8);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (106' 4);  				FilterTreeNode newProperty = new Property (propertySegments);  				if ((inverse != null ? inverse.Text : default(string)) == "?")  					filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  				else {  					if ((not != null ? not.Text : default(string)) == "!")  						newProperty.ToggleInversed ();  					filterNode = newProperty;  				}  			}  			break;  		case 4:  			DebugEnterAlt (4);  			// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  			{  				DebugLocation (116' 4);  				STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  				DebugLocation (117' 4);  				string stringText = (STRING7 != null ? STRING7.Text : default(string));  				stringText = stringText.Substring (1' stringText.Length - 2);  				filterNode = new Value (stringText);  			}  			break;  		case 5:  			DebugEnterAlt (5);  			// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  			{  				DebugLocation (122' 4);  				REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  				DebugLocation (123' 4);  				string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  				regexText = regexText.Substring (1' regexText.Length - 2);  				filterNode = new RegExp (regexText);  			}  			break;  		case 6:  			DebugEnterAlt (6);  			// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  			{  				DebugLocation (128' 4);  				NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  				DebugLocation (129' 4);  				filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  			}  			break;  		case 7:  			DebugEnterAlt (7);  			// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  			{  				DebugLocation (132' 4);  				Match (input' TRUE' Follow._TRUE_in_filterExpr271);  				DebugLocation (133' 4);  				filterNode = new Value (true);  			}  			break;  		case 8:  			DebugEnterAlt (8);  			// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  			{  				DebugLocation (136' 4);  				Match (input' FALSE' Follow._FALSE_in_filterExpr281);  				DebugLocation (137' 4);  				filterNode = new Value (false);  			}  			break;  		case 9:  			DebugEnterAlt (9);  			// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  			{  				DebugLocation (140' 4);  				Match (input' NULL' Follow._NULL_in_filterExpr291);  				DebugLocation (141' 4);  				filterNode = new Value (null);  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("filterExpr"' 6);  		LeaveRule ("filterExpr"' 6);  		LeaveRule_filterExpr ();  	}  	DebugLocation (144' 1);  }  finally {  	DebugExitRule (GrammarFileName' "filterExpr");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "filterExpr");  	DebugLocation (60' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  		int alt9 = 9;  		try {  			DebugEnterDecision (9' false);  			switch (input.LA (1)) {  			case CHAIN_OPERATOR:  			case COMPARATOR:  				{  					alt9 = 1;  				}  				break;  			case EXPR:  				{  					int LA9_2 = input.LA (2);  					if ((LA9_2 == DOWN)) {  						int LA9_3 = input.LA (3);  						if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  							alt9 = 2;  						}  						else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  							alt9 = 3;  						}  						else {  							NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  							DebugRecognitionException (nvae);  							throw nvae;  						}  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				break;  			case STRING:  				{  					alt9 = 4;  				}  				break;  			case REGEX:  				{  					alt9 = 5;  				}  				break;  			case NUMBER:  				{  					alt9 = 6;  				}  				break;  			case TRUE:  				{  					alt9 = 7;  				}  				break;  			case FALSE:  				{  					alt9 = 8;  				}  				break;  			case NULL:  				{  					alt9 = 9;  				}  				break;  			default: {  				NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  			}  		}  		finally {  			DebugExitDecision (9);  		}  		switch (alt9) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  			{  				DebugLocation (64' 4);  				DebugLocation (64' 6);  				PushFollow (Follow._comparator_in_filterExpr175);  				comparator6 = comparator ();  				PopFollow ();  				Match (input' TokenTypes.Down' null);  				DebugLocation (64' 18);  				PushFollow (Follow._filterExpr_in_filterExpr179);  				a = filterExpr ();  				PopFollow ();  				DebugLocation (64' 31);  				PushFollow (Follow._filterExpr_in_filterExpr183);  				b = filterExpr ();  				PopFollow ();  				Match (input' TokenTypes.Up' null);  				DebugLocation (65' 4);  				Comparator newComparator;  				switch (comparator6) {  				case "=":  					newComparator = Comparator.Equals;  					break;  				case "!=":  					newComparator = Comparator.NotEquals;  					break;  				case ">":  					newComparator = Comparator.Greater;  					break;  				case "<":  					newComparator = Comparator.Less;  					break;  				case ">=":  					newComparator = Comparator.GreaterOrEqual;  					break;  				case "<=":  					newComparator = Comparator.LessOrEqual;  					break;  				case "&":  					newComparator = Comparator.And;  					break;  				case "|":  					newComparator = Comparator.Or;  					break;  				default:  					newComparator = Comparator.Equals;  					break;  				}  				filterNode = new BoolExpression (a' newComparator' b);  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  			{  				DebugLocation (98' 4);  				DebugLocation (98' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr195);  				Match (input' TokenTypes.Down' null);  				DebugLocation (98' 12);  				PushFollow (Follow._filterExpr_in_filterExpr199);  				f = filterExpr ();  				PopFollow ();  				DebugLocation (98' 31);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  				int alt6 = 2;  				try {  					DebugEnterSubRule (6);  					try {  						DebugEnterDecision (6' false);  						int LA6_1 = input.LA (1);  						if ((LA6_1 == 24)) {  							alt6 = 1;  						}  					}  					finally {  						DebugExitDecision (6);  					}  					switch (alt6) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  						{  							DebugLocation (98' 31);  							inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (6);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (99' 4);  				FilterTreeNode newNode = f;  				if ((inverse != null ? inverse.Text : default(string)) == "!")  					newNode.ToggleInversed ();  				filterNode = newNode;  			}  			break;  		case 3:  			DebugEnterAlt (3);  			// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  			{  				DebugLocation (105' 4);  				DebugLocation (105' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr216);  				Match (input' TokenTypes.Down' null);  				DebugLocation (105' 12);  				PushFollow (Follow._propertyChain_in_filterExpr219);  				propertyChain (propertySegments);  				PopFollow ();  				DebugLocation (105' 51);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  				int alt7 = 2;  				try {  					DebugEnterSubRule (7);  					try {  						DebugEnterDecision (7' false);  						int LA7_1 = input.LA (1);  						if ((LA7_1 == 31)) {  							alt7 = 1;  						}  					}  					finally {  						DebugExitDecision (7);  					}  					switch (alt7) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  						{  							DebugLocation (105' 51);  							inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (7);  				}  				DebugLocation (105' 60);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  				int alt8 = 2;  				try {  					DebugEnterSubRule (8);  					try {  						DebugEnterDecision (8' false);  						int LA8_1 = input.LA (1);  						if ((LA8_1 == 24)) {  							alt8 = 1;  						}  					}  					finally {  						DebugExitDecision (8);  					}  					switch (alt8) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  						{  							DebugLocation (105' 60);  							not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (8);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (106' 4);  				FilterTreeNode newProperty = new Property (propertySegments);  				if ((inverse != null ? inverse.Text : default(string)) == "?")  					filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  				else {  					if ((not != null ? not.Text : default(string)) == "!")  						newProperty.ToggleInversed ();  					filterNode = newProperty;  				}  			}  			break;  		case 4:  			DebugEnterAlt (4);  			// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  			{  				DebugLocation (116' 4);  				STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  				DebugLocation (117' 4);  				string stringText = (STRING7 != null ? STRING7.Text : default(string));  				stringText = stringText.Substring (1' stringText.Length - 2);  				filterNode = new Value (stringText);  			}  			break;  		case 5:  			DebugEnterAlt (5);  			// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  			{  				DebugLocation (122' 4);  				REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  				DebugLocation (123' 4);  				string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  				regexText = regexText.Substring (1' regexText.Length - 2);  				filterNode = new RegExp (regexText);  			}  			break;  		case 6:  			DebugEnterAlt (6);  			// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  			{  				DebugLocation (128' 4);  				NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  				DebugLocation (129' 4);  				filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  			}  			break;  		case 7:  			DebugEnterAlt (7);  			// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  			{  				DebugLocation (132' 4);  				Match (input' TRUE' Follow._TRUE_in_filterExpr271);  				DebugLocation (133' 4);  				filterNode = new Value (true);  			}  			break;  		case 8:  			DebugEnterAlt (8);  			// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  			{  				DebugLocation (136' 4);  				Match (input' FALSE' Follow._FALSE_in_filterExpr281);  				DebugLocation (137' 4);  				filterNode = new Value (false);  			}  			break;  		case 9:  			DebugEnterAlt (9);  			// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  			{  				DebugLocation (140' 4);  				Match (input' NULL' Follow._NULL_in_filterExpr291);  				DebugLocation (141' 4);  				filterNode = new Value (null);  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("filterExpr"' 6);  		LeaveRule ("filterExpr"' 6);  		LeaveRule_filterExpr ();  	}  	DebugLocation (144' 1);  }  finally {  	DebugExitRule (GrammarFileName' "filterExpr");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "filterExpr");  	DebugLocation (60' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  		int alt9 = 9;  		try {  			DebugEnterDecision (9' false);  			switch (input.LA (1)) {  			case CHAIN_OPERATOR:  			case COMPARATOR:  				{  					alt9 = 1;  				}  				break;  			case EXPR:  				{  					int LA9_2 = input.LA (2);  					if ((LA9_2 == DOWN)) {  						int LA9_3 = input.LA (3);  						if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  							alt9 = 2;  						}  						else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  							alt9 = 3;  						}  						else {  							NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  							DebugRecognitionException (nvae);  							throw nvae;  						}  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				break;  			case STRING:  				{  					alt9 = 4;  				}  				break;  			case REGEX:  				{  					alt9 = 5;  				}  				break;  			case NUMBER:  				{  					alt9 = 6;  				}  				break;  			case TRUE:  				{  					alt9 = 7;  				}  				break;  			case FALSE:  				{  					alt9 = 8;  				}  				break;  			case NULL:  				{  					alt9 = 9;  				}  				break;  			default: {  				NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  			}  		}  		finally {  			DebugExitDecision (9);  		}  		switch (alt9) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  			{  				DebugLocation (64' 4);  				DebugLocation (64' 6);  				PushFollow (Follow._comparator_in_filterExpr175);  				comparator6 = comparator ();  				PopFollow ();  				Match (input' TokenTypes.Down' null);  				DebugLocation (64' 18);  				PushFollow (Follow._filterExpr_in_filterExpr179);  				a = filterExpr ();  				PopFollow ();  				DebugLocation (64' 31);  				PushFollow (Follow._filterExpr_in_filterExpr183);  				b = filterExpr ();  				PopFollow ();  				Match (input' TokenTypes.Up' null);  				DebugLocation (65' 4);  				Comparator newComparator;  				switch (comparator6) {  				case "=":  					newComparator = Comparator.Equals;  					break;  				case "!=":  					newComparator = Comparator.NotEquals;  					break;  				case ">":  					newComparator = Comparator.Greater;  					break;  				case "<":  					newComparator = Comparator.Less;  					break;  				case ">=":  					newComparator = Comparator.GreaterOrEqual;  					break;  				case "<=":  					newComparator = Comparator.LessOrEqual;  					break;  				case "&":  					newComparator = Comparator.And;  					break;  				case "|":  					newComparator = Comparator.Or;  					break;  				default:  					newComparator = Comparator.Equals;  					break;  				}  				filterNode = new BoolExpression (a' newComparator' b);  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  			{  				DebugLocation (98' 4);  				DebugLocation (98' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr195);  				Match (input' TokenTypes.Down' null);  				DebugLocation (98' 12);  				PushFollow (Follow._filterExpr_in_filterExpr199);  				f = filterExpr ();  				PopFollow ();  				DebugLocation (98' 31);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  				int alt6 = 2;  				try {  					DebugEnterSubRule (6);  					try {  						DebugEnterDecision (6' false);  						int LA6_1 = input.LA (1);  						if ((LA6_1 == 24)) {  							alt6 = 1;  						}  					}  					finally {  						DebugExitDecision (6);  					}  					switch (alt6) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  						{  							DebugLocation (98' 31);  							inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (6);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (99' 4);  				FilterTreeNode newNode = f;  				if ((inverse != null ? inverse.Text : default(string)) == "!")  					newNode.ToggleInversed ();  				filterNode = newNode;  			}  			break;  		case 3:  			DebugEnterAlt (3);  			// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  			{  				DebugLocation (105' 4);  				DebugLocation (105' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr216);  				Match (input' TokenTypes.Down' null);  				DebugLocation (105' 12);  				PushFollow (Follow._propertyChain_in_filterExpr219);  				propertyChain (propertySegments);  				PopFollow ();  				DebugLocation (105' 51);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  				int alt7 = 2;  				try {  					DebugEnterSubRule (7);  					try {  						DebugEnterDecision (7' false);  						int LA7_1 = input.LA (1);  						if ((LA7_1 == 31)) {  							alt7 = 1;  						}  					}  					finally {  						DebugExitDecision (7);  					}  					switch (alt7) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  						{  							DebugLocation (105' 51);  							inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (7);  				}  				DebugLocation (105' 60);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  				int alt8 = 2;  				try {  					DebugEnterSubRule (8);  					try {  						DebugEnterDecision (8' false);  						int LA8_1 = input.LA (1);  						if ((LA8_1 == 24)) {  							alt8 = 1;  						}  					}  					finally {  						DebugExitDecision (8);  					}  					switch (alt8) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  						{  							DebugLocation (105' 60);  							not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (8);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (106' 4);  				FilterTreeNode newProperty = new Property (propertySegments);  				if ((inverse != null ? inverse.Text : default(string)) == "?")  					filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  				else {  					if ((not != null ? not.Text : default(string)) == "!")  						newProperty.ToggleInversed ();  					filterNode = newProperty;  				}  			}  			break;  		case 4:  			DebugEnterAlt (4);  			// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  			{  				DebugLocation (116' 4);  				STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  				DebugLocation (117' 4);  				string stringText = (STRING7 != null ? STRING7.Text : default(string));  				stringText = stringText.Substring (1' stringText.Length - 2);  				filterNode = new Value (stringText);  			}  			break;  		case 5:  			DebugEnterAlt (5);  			// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  			{  				DebugLocation (122' 4);  				REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  				DebugLocation (123' 4);  				string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  				regexText = regexText.Substring (1' regexText.Length - 2);  				filterNode = new RegExp (regexText);  			}  			break;  		case 6:  			DebugEnterAlt (6);  			// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  			{  				DebugLocation (128' 4);  				NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  				DebugLocation (129' 4);  				filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  			}  			break;  		case 7:  			DebugEnterAlt (7);  			// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  			{  				DebugLocation (132' 4);  				Match (input' TRUE' Follow._TRUE_in_filterExpr271);  				DebugLocation (133' 4);  				filterNode = new Value (true);  			}  			break;  		case 8:  			DebugEnterAlt (8);  			// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  			{  				DebugLocation (136' 4);  				Match (input' FALSE' Follow._FALSE_in_filterExpr281);  				DebugLocation (137' 4);  				filterNode = new Value (false);  			}  			break;  		case 9:  			DebugEnterAlt (9);  			// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  			{  				DebugLocation (140' 4);  				Match (input' NULL' Follow._NULL_in_filterExpr291);  				DebugLocation (141' 4);  				filterNode = new Value (null);  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("filterExpr"' 6);  		LeaveRule ("filterExpr"' 6);  		LeaveRule_filterExpr ();  	}  	DebugLocation (144' 1);  }  finally {  	DebugExitRule (GrammarFileName' "filterExpr");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "filterExpr");  	DebugLocation (60' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  		int alt9 = 9;  		try {  			DebugEnterDecision (9' false);  			switch (input.LA (1)) {  			case CHAIN_OPERATOR:  			case COMPARATOR:  				{  					alt9 = 1;  				}  				break;  			case EXPR:  				{  					int LA9_2 = input.LA (2);  					if ((LA9_2 == DOWN)) {  						int LA9_3 = input.LA (3);  						if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  							alt9 = 2;  						}  						else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  							alt9 = 3;  						}  						else {  							NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  							DebugRecognitionException (nvae);  							throw nvae;  						}  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				break;  			case STRING:  				{  					alt9 = 4;  				}  				break;  			case REGEX:  				{  					alt9 = 5;  				}  				break;  			case NUMBER:  				{  					alt9 = 6;  				}  				break;  			case TRUE:  				{  					alt9 = 7;  				}  				break;  			case FALSE:  				{  					alt9 = 8;  				}  				break;  			case NULL:  				{  					alt9 = 9;  				}  				break;  			default: {  				NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  			}  		}  		finally {  			DebugExitDecision (9);  		}  		switch (alt9) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  			{  				DebugLocation (64' 4);  				DebugLocation (64' 6);  				PushFollow (Follow._comparator_in_filterExpr175);  				comparator6 = comparator ();  				PopFollow ();  				Match (input' TokenTypes.Down' null);  				DebugLocation (64' 18);  				PushFollow (Follow._filterExpr_in_filterExpr179);  				a = filterExpr ();  				PopFollow ();  				DebugLocation (64' 31);  				PushFollow (Follow._filterExpr_in_filterExpr183);  				b = filterExpr ();  				PopFollow ();  				Match (input' TokenTypes.Up' null);  				DebugLocation (65' 4);  				Comparator newComparator;  				switch (comparator6) {  				case "=":  					newComparator = Comparator.Equals;  					break;  				case "!=":  					newComparator = Comparator.NotEquals;  					break;  				case ">":  					newComparator = Comparator.Greater;  					break;  				case "<":  					newComparator = Comparator.Less;  					break;  				case ">=":  					newComparator = Comparator.GreaterOrEqual;  					break;  				case "<=":  					newComparator = Comparator.LessOrEqual;  					break;  				case "&":  					newComparator = Comparator.And;  					break;  				case "|":  					newComparator = Comparator.Or;  					break;  				default:  					newComparator = Comparator.Equals;  					break;  				}  				filterNode = new BoolExpression (a' newComparator' b);  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  			{  				DebugLocation (98' 4);  				DebugLocation (98' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr195);  				Match (input' TokenTypes.Down' null);  				DebugLocation (98' 12);  				PushFollow (Follow._filterExpr_in_filterExpr199);  				f = filterExpr ();  				PopFollow ();  				DebugLocation (98' 31);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  				int alt6 = 2;  				try {  					DebugEnterSubRule (6);  					try {  						DebugEnterDecision (6' false);  						int LA6_1 = input.LA (1);  						if ((LA6_1 == 24)) {  							alt6 = 1;  						}  					}  					finally {  						DebugExitDecision (6);  					}  					switch (alt6) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  						{  							DebugLocation (98' 31);  							inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (6);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (99' 4);  				FilterTreeNode newNode = f;  				if ((inverse != null ? inverse.Text : default(string)) == "!")  					newNode.ToggleInversed ();  				filterNode = newNode;  			}  			break;  		case 3:  			DebugEnterAlt (3);  			// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  			{  				DebugLocation (105' 4);  				DebugLocation (105' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr216);  				Match (input' TokenTypes.Down' null);  				DebugLocation (105' 12);  				PushFollow (Follow._propertyChain_in_filterExpr219);  				propertyChain (propertySegments);  				PopFollow ();  				DebugLocation (105' 51);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  				int alt7 = 2;  				try {  					DebugEnterSubRule (7);  					try {  						DebugEnterDecision (7' false);  						int LA7_1 = input.LA (1);  						if ((LA7_1 == 31)) {  							alt7 = 1;  						}  					}  					finally {  						DebugExitDecision (7);  					}  					switch (alt7) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  						{  							DebugLocation (105' 51);  							inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (7);  				}  				DebugLocation (105' 60);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  				int alt8 = 2;  				try {  					DebugEnterSubRule (8);  					try {  						DebugEnterDecision (8' false);  						int LA8_1 = input.LA (1);  						if ((LA8_1 == 24)) {  							alt8 = 1;  						}  					}  					finally {  						DebugExitDecision (8);  					}  					switch (alt8) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  						{  							DebugLocation (105' 60);  							not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (8);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (106' 4);  				FilterTreeNode newProperty = new Property (propertySegments);  				if ((inverse != null ? inverse.Text : default(string)) == "?")  					filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  				else {  					if ((not != null ? not.Text : default(string)) == "!")  						newProperty.ToggleInversed ();  					filterNode = newProperty;  				}  			}  			break;  		case 4:  			DebugEnterAlt (4);  			// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  			{  				DebugLocation (116' 4);  				STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  				DebugLocation (117' 4);  				string stringText = (STRING7 != null ? STRING7.Text : default(string));  				stringText = stringText.Substring (1' stringText.Length - 2);  				filterNode = new Value (stringText);  			}  			break;  		case 5:  			DebugEnterAlt (5);  			// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  			{  				DebugLocation (122' 4);  				REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  				DebugLocation (123' 4);  				string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  				regexText = regexText.Substring (1' regexText.Length - 2);  				filterNode = new RegExp (regexText);  			}  			break;  		case 6:  			DebugEnterAlt (6);  			// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  			{  				DebugLocation (128' 4);  				NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  				DebugLocation (129' 4);  				filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  			}  			break;  		case 7:  			DebugEnterAlt (7);  			// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  			{  				DebugLocation (132' 4);  				Match (input' TRUE' Follow._TRUE_in_filterExpr271);  				DebugLocation (133' 4);  				filterNode = new Value (true);  			}  			break;  		case 8:  			DebugEnterAlt (8);  			// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  			{  				DebugLocation (136' 4);  				Match (input' FALSE' Follow._FALSE_in_filterExpr281);  				DebugLocation (137' 4);  				filterNode = new Value (false);  			}  			break;  		case 9:  			DebugEnterAlt (9);  			// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  			{  				DebugLocation (140' 4);  				Match (input' NULL' Follow._NULL_in_filterExpr291);  				DebugLocation (141' 4);  				filterNode = new Value (null);  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("filterExpr"' 6);  		LeaveRule ("filterExpr"' 6);  		LeaveRule_filterExpr ();  	}  	DebugLocation (144' 1);  }  finally {  	DebugExitRule (GrammarFileName' "filterExpr");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "filterExpr");  	DebugLocation (60' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  		int alt9 = 9;  		try {  			DebugEnterDecision (9' false);  			switch (input.LA (1)) {  			case CHAIN_OPERATOR:  			case COMPARATOR:  				{  					alt9 = 1;  				}  				break;  			case EXPR:  				{  					int LA9_2 = input.LA (2);  					if ((LA9_2 == DOWN)) {  						int LA9_3 = input.LA (3);  						if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  							alt9 = 2;  						}  						else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  							alt9 = 3;  						}  						else {  							NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  							DebugRecognitionException (nvae);  							throw nvae;  						}  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				break;  			case STRING:  				{  					alt9 = 4;  				}  				break;  			case REGEX:  				{  					alt9 = 5;  				}  				break;  			case NUMBER:  				{  					alt9 = 6;  				}  				break;  			case TRUE:  				{  					alt9 = 7;  				}  				break;  			case FALSE:  				{  					alt9 = 8;  				}  				break;  			case NULL:  				{  					alt9 = 9;  				}  				break;  			default: {  				NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  			}  		}  		finally {  			DebugExitDecision (9);  		}  		switch (alt9) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  			{  				DebugLocation (64' 4);  				DebugLocation (64' 6);  				PushFollow (Follow._comparator_in_filterExpr175);  				comparator6 = comparator ();  				PopFollow ();  				Match (input' TokenTypes.Down' null);  				DebugLocation (64' 18);  				PushFollow (Follow._filterExpr_in_filterExpr179);  				a = filterExpr ();  				PopFollow ();  				DebugLocation (64' 31);  				PushFollow (Follow._filterExpr_in_filterExpr183);  				b = filterExpr ();  				PopFollow ();  				Match (input' TokenTypes.Up' null);  				DebugLocation (65' 4);  				Comparator newComparator;  				switch (comparator6) {  				case "=":  					newComparator = Comparator.Equals;  					break;  				case "!=":  					newComparator = Comparator.NotEquals;  					break;  				case ">":  					newComparator = Comparator.Greater;  					break;  				case "<":  					newComparator = Comparator.Less;  					break;  				case ">=":  					newComparator = Comparator.GreaterOrEqual;  					break;  				case "<=":  					newComparator = Comparator.LessOrEqual;  					break;  				case "&":  					newComparator = Comparator.And;  					break;  				case "|":  					newComparator = Comparator.Or;  					break;  				default:  					newComparator = Comparator.Equals;  					break;  				}  				filterNode = new BoolExpression (a' newComparator' b);  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  			{  				DebugLocation (98' 4);  				DebugLocation (98' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr195);  				Match (input' TokenTypes.Down' null);  				DebugLocation (98' 12);  				PushFollow (Follow._filterExpr_in_filterExpr199);  				f = filterExpr ();  				PopFollow ();  				DebugLocation (98' 31);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  				int alt6 = 2;  				try {  					DebugEnterSubRule (6);  					try {  						DebugEnterDecision (6' false);  						int LA6_1 = input.LA (1);  						if ((LA6_1 == 24)) {  							alt6 = 1;  						}  					}  					finally {  						DebugExitDecision (6);  					}  					switch (alt6) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  						{  							DebugLocation (98' 31);  							inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (6);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (99' 4);  				FilterTreeNode newNode = f;  				if ((inverse != null ? inverse.Text : default(string)) == "!")  					newNode.ToggleInversed ();  				filterNode = newNode;  			}  			break;  		case 3:  			DebugEnterAlt (3);  			// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  			{  				DebugLocation (105' 4);  				DebugLocation (105' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr216);  				Match (input' TokenTypes.Down' null);  				DebugLocation (105' 12);  				PushFollow (Follow._propertyChain_in_filterExpr219);  				propertyChain (propertySegments);  				PopFollow ();  				DebugLocation (105' 51);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  				int alt7 = 2;  				try {  					DebugEnterSubRule (7);  					try {  						DebugEnterDecision (7' false);  						int LA7_1 = input.LA (1);  						if ((LA7_1 == 31)) {  							alt7 = 1;  						}  					}  					finally {  						DebugExitDecision (7);  					}  					switch (alt7) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  						{  							DebugLocation (105' 51);  							inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (7);  				}  				DebugLocation (105' 60);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  				int alt8 = 2;  				try {  					DebugEnterSubRule (8);  					try {  						DebugEnterDecision (8' false);  						int LA8_1 = input.LA (1);  						if ((LA8_1 == 24)) {  							alt8 = 1;  						}  					}  					finally {  						DebugExitDecision (8);  					}  					switch (alt8) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  						{  							DebugLocation (105' 60);  							not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (8);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (106' 4);  				FilterTreeNode newProperty = new Property (propertySegments);  				if ((inverse != null ? inverse.Text : default(string)) == "?")  					filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  				else {  					if ((not != null ? not.Text : default(string)) == "!")  						newProperty.ToggleInversed ();  					filterNode = newProperty;  				}  			}  			break;  		case 4:  			DebugEnterAlt (4);  			// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  			{  				DebugLocation (116' 4);  				STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  				DebugLocation (117' 4);  				string stringText = (STRING7 != null ? STRING7.Text : default(string));  				stringText = stringText.Substring (1' stringText.Length - 2);  				filterNode = new Value (stringText);  			}  			break;  		case 5:  			DebugEnterAlt (5);  			// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  			{  				DebugLocation (122' 4);  				REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  				DebugLocation (123' 4);  				string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  				regexText = regexText.Substring (1' regexText.Length - 2);  				filterNode = new RegExp (regexText);  			}  			break;  		case 6:  			DebugEnterAlt (6);  			// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  			{  				DebugLocation (128' 4);  				NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  				DebugLocation (129' 4);  				filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  			}  			break;  		case 7:  			DebugEnterAlt (7);  			// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  			{  				DebugLocation (132' 4);  				Match (input' TRUE' Follow._TRUE_in_filterExpr271);  				DebugLocation (133' 4);  				filterNode = new Value (true);  			}  			break;  		case 8:  			DebugEnterAlt (8);  			// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  			{  				DebugLocation (136' 4);  				Match (input' FALSE' Follow._FALSE_in_filterExpr281);  				DebugLocation (137' 4);  				filterNode = new Value (false);  			}  			break;  		case 9:  			DebugEnterAlt (9);  			// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  			{  				DebugLocation (140' 4);  				Match (input' NULL' Follow._NULL_in_filterExpr291);  				DebugLocation (141' 4);  				filterNode = new Value (null);  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("filterExpr"' 6);  		LeaveRule ("filterExpr"' 6);  		LeaveRule_filterExpr ();  	}  	DebugLocation (144' 1);  }  finally {  	DebugExitRule (GrammarFileName' "filterExpr");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "filterExpr");  	DebugLocation (60' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  		int alt9 = 9;  		try {  			DebugEnterDecision (9' false);  			switch (input.LA (1)) {  			case CHAIN_OPERATOR:  			case COMPARATOR:  				{  					alt9 = 1;  				}  				break;  			case EXPR:  				{  					int LA9_2 = input.LA (2);  					if ((LA9_2 == DOWN)) {  						int LA9_3 = input.LA (3);  						if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  							alt9 = 2;  						}  						else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  							alt9 = 3;  						}  						else {  							NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  							DebugRecognitionException (nvae);  							throw nvae;  						}  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				break;  			case STRING:  				{  					alt9 = 4;  				}  				break;  			case REGEX:  				{  					alt9 = 5;  				}  				break;  			case NUMBER:  				{  					alt9 = 6;  				}  				break;  			case TRUE:  				{  					alt9 = 7;  				}  				break;  			case FALSE:  				{  					alt9 = 8;  				}  				break;  			case NULL:  				{  					alt9 = 9;  				}  				break;  			default: {  				NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  			}  		}  		finally {  			DebugExitDecision (9);  		}  		switch (alt9) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  			{  				DebugLocation (64' 4);  				DebugLocation (64' 6);  				PushFollow (Follow._comparator_in_filterExpr175);  				comparator6 = comparator ();  				PopFollow ();  				Match (input' TokenTypes.Down' null);  				DebugLocation (64' 18);  				PushFollow (Follow._filterExpr_in_filterExpr179);  				a = filterExpr ();  				PopFollow ();  				DebugLocation (64' 31);  				PushFollow (Follow._filterExpr_in_filterExpr183);  				b = filterExpr ();  				PopFollow ();  				Match (input' TokenTypes.Up' null);  				DebugLocation (65' 4);  				Comparator newComparator;  				switch (comparator6) {  				case "=":  					newComparator = Comparator.Equals;  					break;  				case "!=":  					newComparator = Comparator.NotEquals;  					break;  				case ">":  					newComparator = Comparator.Greater;  					break;  				case "<":  					newComparator = Comparator.Less;  					break;  				case ">=":  					newComparator = Comparator.GreaterOrEqual;  					break;  				case "<=":  					newComparator = Comparator.LessOrEqual;  					break;  				case "&":  					newComparator = Comparator.And;  					break;  				case "|":  					newComparator = Comparator.Or;  					break;  				default:  					newComparator = Comparator.Equals;  					break;  				}  				filterNode = new BoolExpression (a' newComparator' b);  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  			{  				DebugLocation (98' 4);  				DebugLocation (98' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr195);  				Match (input' TokenTypes.Down' null);  				DebugLocation (98' 12);  				PushFollow (Follow._filterExpr_in_filterExpr199);  				f = filterExpr ();  				PopFollow ();  				DebugLocation (98' 31);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  				int alt6 = 2;  				try {  					DebugEnterSubRule (6);  					try {  						DebugEnterDecision (6' false);  						int LA6_1 = input.LA (1);  						if ((LA6_1 == 24)) {  							alt6 = 1;  						}  					}  					finally {  						DebugExitDecision (6);  					}  					switch (alt6) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  						{  							DebugLocation (98' 31);  							inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (6);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (99' 4);  				FilterTreeNode newNode = f;  				if ((inverse != null ? inverse.Text : default(string)) == "!")  					newNode.ToggleInversed ();  				filterNode = newNode;  			}  			break;  		case 3:  			DebugEnterAlt (3);  			// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  			{  				DebugLocation (105' 4);  				DebugLocation (105' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr216);  				Match (input' TokenTypes.Down' null);  				DebugLocation (105' 12);  				PushFollow (Follow._propertyChain_in_filterExpr219);  				propertyChain (propertySegments);  				PopFollow ();  				DebugLocation (105' 51);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  				int alt7 = 2;  				try {  					DebugEnterSubRule (7);  					try {  						DebugEnterDecision (7' false);  						int LA7_1 = input.LA (1);  						if ((LA7_1 == 31)) {  							alt7 = 1;  						}  					}  					finally {  						DebugExitDecision (7);  					}  					switch (alt7) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  						{  							DebugLocation (105' 51);  							inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (7);  				}  				DebugLocation (105' 60);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  				int alt8 = 2;  				try {  					DebugEnterSubRule (8);  					try {  						DebugEnterDecision (8' false);  						int LA8_1 = input.LA (1);  						if ((LA8_1 == 24)) {  							alt8 = 1;  						}  					}  					finally {  						DebugExitDecision (8);  					}  					switch (alt8) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  						{  							DebugLocation (105' 60);  							not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (8);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (106' 4);  				FilterTreeNode newProperty = new Property (propertySegments);  				if ((inverse != null ? inverse.Text : default(string)) == "?")  					filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  				else {  					if ((not != null ? not.Text : default(string)) == "!")  						newProperty.ToggleInversed ();  					filterNode = newProperty;  				}  			}  			break;  		case 4:  			DebugEnterAlt (4);  			// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  			{  				DebugLocation (116' 4);  				STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  				DebugLocation (117' 4);  				string stringText = (STRING7 != null ? STRING7.Text : default(string));  				stringText = stringText.Substring (1' stringText.Length - 2);  				filterNode = new Value (stringText);  			}  			break;  		case 5:  			DebugEnterAlt (5);  			// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  			{  				DebugLocation (122' 4);  				REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  				DebugLocation (123' 4);  				string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  				regexText = regexText.Substring (1' regexText.Length - 2);  				filterNode = new RegExp (regexText);  			}  			break;  		case 6:  			DebugEnterAlt (6);  			// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  			{  				DebugLocation (128' 4);  				NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  				DebugLocation (129' 4);  				filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  			}  			break;  		case 7:  			DebugEnterAlt (7);  			// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  			{  				DebugLocation (132' 4);  				Match (input' TRUE' Follow._TRUE_in_filterExpr271);  				DebugLocation (133' 4);  				filterNode = new Value (true);  			}  			break;  		case 8:  			DebugEnterAlt (8);  			// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  			{  				DebugLocation (136' 4);  				Match (input' FALSE' Follow._FALSE_in_filterExpr281);  				DebugLocation (137' 4);  				filterNode = new Value (false);  			}  			break;  		case 9:  			DebugEnterAlt (9);  			// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  			{  				DebugLocation (140' 4);  				Match (input' NULL' Follow._NULL_in_filterExpr291);  				DebugLocation (141' 4);  				filterNode = new Value (null);  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("filterExpr"' 6);  		LeaveRule ("filterExpr"' 6);  		LeaveRule_filterExpr ();  	}  	DebugLocation (144' 1);  }  finally {  	DebugExitRule (GrammarFileName' "filterExpr");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "filterExpr");  	DebugLocation (60' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  		int alt9 = 9;  		try {  			DebugEnterDecision (9' false);  			switch (input.LA (1)) {  			case CHAIN_OPERATOR:  			case COMPARATOR:  				{  					alt9 = 1;  				}  				break;  			case EXPR:  				{  					int LA9_2 = input.LA (2);  					if ((LA9_2 == DOWN)) {  						int LA9_3 = input.LA (3);  						if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  							alt9 = 2;  						}  						else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  							alt9 = 3;  						}  						else {  							NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  							DebugRecognitionException (nvae);  							throw nvae;  						}  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				break;  			case STRING:  				{  					alt9 = 4;  				}  				break;  			case REGEX:  				{  					alt9 = 5;  				}  				break;  			case NUMBER:  				{  					alt9 = 6;  				}  				break;  			case TRUE:  				{  					alt9 = 7;  				}  				break;  			case FALSE:  				{  					alt9 = 8;  				}  				break;  			case NULL:  				{  					alt9 = 9;  				}  				break;  			default: {  				NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  			}  		}  		finally {  			DebugExitDecision (9);  		}  		switch (alt9) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  			{  				DebugLocation (64' 4);  				DebugLocation (64' 6);  				PushFollow (Follow._comparator_in_filterExpr175);  				comparator6 = comparator ();  				PopFollow ();  				Match (input' TokenTypes.Down' null);  				DebugLocation (64' 18);  				PushFollow (Follow._filterExpr_in_filterExpr179);  				a = filterExpr ();  				PopFollow ();  				DebugLocation (64' 31);  				PushFollow (Follow._filterExpr_in_filterExpr183);  				b = filterExpr ();  				PopFollow ();  				Match (input' TokenTypes.Up' null);  				DebugLocation (65' 4);  				Comparator newComparator;  				switch (comparator6) {  				case "=":  					newComparator = Comparator.Equals;  					break;  				case "!=":  					newComparator = Comparator.NotEquals;  					break;  				case ">":  					newComparator = Comparator.Greater;  					break;  				case "<":  					newComparator = Comparator.Less;  					break;  				case ">=":  					newComparator = Comparator.GreaterOrEqual;  					break;  				case "<=":  					newComparator = Comparator.LessOrEqual;  					break;  				case "&":  					newComparator = Comparator.And;  					break;  				case "|":  					newComparator = Comparator.Or;  					break;  				default:  					newComparator = Comparator.Equals;  					break;  				}  				filterNode = new BoolExpression (a' newComparator' b);  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  			{  				DebugLocation (98' 4);  				DebugLocation (98' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr195);  				Match (input' TokenTypes.Down' null);  				DebugLocation (98' 12);  				PushFollow (Follow._filterExpr_in_filterExpr199);  				f = filterExpr ();  				PopFollow ();  				DebugLocation (98' 31);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  				int alt6 = 2;  				try {  					DebugEnterSubRule (6);  					try {  						DebugEnterDecision (6' false);  						int LA6_1 = input.LA (1);  						if ((LA6_1 == 24)) {  							alt6 = 1;  						}  					}  					finally {  						DebugExitDecision (6);  					}  					switch (alt6) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  						{  							DebugLocation (98' 31);  							inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (6);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (99' 4);  				FilterTreeNode newNode = f;  				if ((inverse != null ? inverse.Text : default(string)) == "!")  					newNode.ToggleInversed ();  				filterNode = newNode;  			}  			break;  		case 3:  			DebugEnterAlt (3);  			// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  			{  				DebugLocation (105' 4);  				DebugLocation (105' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr216);  				Match (input' TokenTypes.Down' null);  				DebugLocation (105' 12);  				PushFollow (Follow._propertyChain_in_filterExpr219);  				propertyChain (propertySegments);  				PopFollow ();  				DebugLocation (105' 51);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  				int alt7 = 2;  				try {  					DebugEnterSubRule (7);  					try {  						DebugEnterDecision (7' false);  						int LA7_1 = input.LA (1);  						if ((LA7_1 == 31)) {  							alt7 = 1;  						}  					}  					finally {  						DebugExitDecision (7);  					}  					switch (alt7) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  						{  							DebugLocation (105' 51);  							inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (7);  				}  				DebugLocation (105' 60);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  				int alt8 = 2;  				try {  					DebugEnterSubRule (8);  					try {  						DebugEnterDecision (8' false);  						int LA8_1 = input.LA (1);  						if ((LA8_1 == 24)) {  							alt8 = 1;  						}  					}  					finally {  						DebugExitDecision (8);  					}  					switch (alt8) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  						{  							DebugLocation (105' 60);  							not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (8);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (106' 4);  				FilterTreeNode newProperty = new Property (propertySegments);  				if ((inverse != null ? inverse.Text : default(string)) == "?")  					filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  				else {  					if ((not != null ? not.Text : default(string)) == "!")  						newProperty.ToggleInversed ();  					filterNode = newProperty;  				}  			}  			break;  		case 4:  			DebugEnterAlt (4);  			// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  			{  				DebugLocation (116' 4);  				STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  				DebugLocation (117' 4);  				string stringText = (STRING7 != null ? STRING7.Text : default(string));  				stringText = stringText.Substring (1' stringText.Length - 2);  				filterNode = new Value (stringText);  			}  			break;  		case 5:  			DebugEnterAlt (5);  			// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  			{  				DebugLocation (122' 4);  				REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  				DebugLocation (123' 4);  				string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  				regexText = regexText.Substring (1' regexText.Length - 2);  				filterNode = new RegExp (regexText);  			}  			break;  		case 6:  			DebugEnterAlt (6);  			// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  			{  				DebugLocation (128' 4);  				NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  				DebugLocation (129' 4);  				filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  			}  			break;  		case 7:  			DebugEnterAlt (7);  			// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  			{  				DebugLocation (132' 4);  				Match (input' TRUE' Follow._TRUE_in_filterExpr271);  				DebugLocation (133' 4);  				filterNode = new Value (true);  			}  			break;  		case 8:  			DebugEnterAlt (8);  			// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  			{  				DebugLocation (136' 4);  				Match (input' FALSE' Follow._FALSE_in_filterExpr281);  				DebugLocation (137' 4);  				filterNode = new Value (false);  			}  			break;  		case 9:  			DebugEnterAlt (9);  			// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  			{  				DebugLocation (140' 4);  				Match (input' NULL' Follow._NULL_in_filterExpr291);  				DebugLocation (141' 4);  				filterNode = new Value (null);  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("filterExpr"' 6);  		LeaveRule ("filterExpr"' 6);  		LeaveRule_filterExpr ();  	}  	DebugLocation (144' 1);  }  finally {  	DebugExitRule (GrammarFileName' "filterExpr");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "filterExpr");  	DebugLocation (60' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  		int alt9 = 9;  		try {  			DebugEnterDecision (9' false);  			switch (input.LA (1)) {  			case CHAIN_OPERATOR:  			case COMPARATOR:  				{  					alt9 = 1;  				}  				break;  			case EXPR:  				{  					int LA9_2 = input.LA (2);  					if ((LA9_2 == DOWN)) {  						int LA9_3 = input.LA (3);  						if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  							alt9 = 2;  						}  						else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  							alt9 = 3;  						}  						else {  							NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  							DebugRecognitionException (nvae);  							throw nvae;  						}  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				break;  			case STRING:  				{  					alt9 = 4;  				}  				break;  			case REGEX:  				{  					alt9 = 5;  				}  				break;  			case NUMBER:  				{  					alt9 = 6;  				}  				break;  			case TRUE:  				{  					alt9 = 7;  				}  				break;  			case FALSE:  				{  					alt9 = 8;  				}  				break;  			case NULL:  				{  					alt9 = 9;  				}  				break;  			default: {  				NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  			}  		}  		finally {  			DebugExitDecision (9);  		}  		switch (alt9) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  			{  				DebugLocation (64' 4);  				DebugLocation (64' 6);  				PushFollow (Follow._comparator_in_filterExpr175);  				comparator6 = comparator ();  				PopFollow ();  				Match (input' TokenTypes.Down' null);  				DebugLocation (64' 18);  				PushFollow (Follow._filterExpr_in_filterExpr179);  				a = filterExpr ();  				PopFollow ();  				DebugLocation (64' 31);  				PushFollow (Follow._filterExpr_in_filterExpr183);  				b = filterExpr ();  				PopFollow ();  				Match (input' TokenTypes.Up' null);  				DebugLocation (65' 4);  				Comparator newComparator;  				switch (comparator6) {  				case "=":  					newComparator = Comparator.Equals;  					break;  				case "!=":  					newComparator = Comparator.NotEquals;  					break;  				case ">":  					newComparator = Comparator.Greater;  					break;  				case "<":  					newComparator = Comparator.Less;  					break;  				case ">=":  					newComparator = Comparator.GreaterOrEqual;  					break;  				case "<=":  					newComparator = Comparator.LessOrEqual;  					break;  				case "&":  					newComparator = Comparator.And;  					break;  				case "|":  					newComparator = Comparator.Or;  					break;  				default:  					newComparator = Comparator.Equals;  					break;  				}  				filterNode = new BoolExpression (a' newComparator' b);  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  			{  				DebugLocation (98' 4);  				DebugLocation (98' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr195);  				Match (input' TokenTypes.Down' null);  				DebugLocation (98' 12);  				PushFollow (Follow._filterExpr_in_filterExpr199);  				f = filterExpr ();  				PopFollow ();  				DebugLocation (98' 31);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  				int alt6 = 2;  				try {  					DebugEnterSubRule (6);  					try {  						DebugEnterDecision (6' false);  						int LA6_1 = input.LA (1);  						if ((LA6_1 == 24)) {  							alt6 = 1;  						}  					}  					finally {  						DebugExitDecision (6);  					}  					switch (alt6) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  						{  							DebugLocation (98' 31);  							inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (6);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (99' 4);  				FilterTreeNode newNode = f;  				if ((inverse != null ? inverse.Text : default(string)) == "!")  					newNode.ToggleInversed ();  				filterNode = newNode;  			}  			break;  		case 3:  			DebugEnterAlt (3);  			// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  			{  				DebugLocation (105' 4);  				DebugLocation (105' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr216);  				Match (input' TokenTypes.Down' null);  				DebugLocation (105' 12);  				PushFollow (Follow._propertyChain_in_filterExpr219);  				propertyChain (propertySegments);  				PopFollow ();  				DebugLocation (105' 51);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  				int alt7 = 2;  				try {  					DebugEnterSubRule (7);  					try {  						DebugEnterDecision (7' false);  						int LA7_1 = input.LA (1);  						if ((LA7_1 == 31)) {  							alt7 = 1;  						}  					}  					finally {  						DebugExitDecision (7);  					}  					switch (alt7) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  						{  							DebugLocation (105' 51);  							inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (7);  				}  				DebugLocation (105' 60);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  				int alt8 = 2;  				try {  					DebugEnterSubRule (8);  					try {  						DebugEnterDecision (8' false);  						int LA8_1 = input.LA (1);  						if ((LA8_1 == 24)) {  							alt8 = 1;  						}  					}  					finally {  						DebugExitDecision (8);  					}  					switch (alt8) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  						{  							DebugLocation (105' 60);  							not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (8);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (106' 4);  				FilterTreeNode newProperty = new Property (propertySegments);  				if ((inverse != null ? inverse.Text : default(string)) == "?")  					filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  				else {  					if ((not != null ? not.Text : default(string)) == "!")  						newProperty.ToggleInversed ();  					filterNode = newProperty;  				}  			}  			break;  		case 4:  			DebugEnterAlt (4);  			// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  			{  				DebugLocation (116' 4);  				STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  				DebugLocation (117' 4);  				string stringText = (STRING7 != null ? STRING7.Text : default(string));  				stringText = stringText.Substring (1' stringText.Length - 2);  				filterNode = new Value (stringText);  			}  			break;  		case 5:  			DebugEnterAlt (5);  			// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  			{  				DebugLocation (122' 4);  				REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  				DebugLocation (123' 4);  				string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  				regexText = regexText.Substring (1' regexText.Length - 2);  				filterNode = new RegExp (regexText);  			}  			break;  		case 6:  			DebugEnterAlt (6);  			// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  			{  				DebugLocation (128' 4);  				NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  				DebugLocation (129' 4);  				filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  			}  			break;  		case 7:  			DebugEnterAlt (7);  			// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  			{  				DebugLocation (132' 4);  				Match (input' TRUE' Follow._TRUE_in_filterExpr271);  				DebugLocation (133' 4);  				filterNode = new Value (true);  			}  			break;  		case 8:  			DebugEnterAlt (8);  			// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  			{  				DebugLocation (136' 4);  				Match (input' FALSE' Follow._FALSE_in_filterExpr281);  				DebugLocation (137' 4);  				filterNode = new Value (false);  			}  			break;  		case 9:  			DebugEnterAlt (9);  			// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  			{  				DebugLocation (140' 4);  				Match (input' NULL' Follow._NULL_in_filterExpr291);  				DebugLocation (141' 4);  				filterNode = new Value (null);  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("filterExpr"' 6);  		LeaveRule ("filterExpr"' 6);  		LeaveRule_filterExpr ();  	}  	DebugLocation (144' 1);  }  finally {  	DebugExitRule (GrammarFileName' "filterExpr");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "filterExpr");  	DebugLocation (60' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  		int alt9 = 9;  		try {  			DebugEnterDecision (9' false);  			switch (input.LA (1)) {  			case CHAIN_OPERATOR:  			case COMPARATOR:  				{  					alt9 = 1;  				}  				break;  			case EXPR:  				{  					int LA9_2 = input.LA (2);  					if ((LA9_2 == DOWN)) {  						int LA9_3 = input.LA (3);  						if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  							alt9 = 2;  						}  						else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  							alt9 = 3;  						}  						else {  							NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  							DebugRecognitionException (nvae);  							throw nvae;  						}  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				break;  			case STRING:  				{  					alt9 = 4;  				}  				break;  			case REGEX:  				{  					alt9 = 5;  				}  				break;  			case NUMBER:  				{  					alt9 = 6;  				}  				break;  			case TRUE:  				{  					alt9 = 7;  				}  				break;  			case FALSE:  				{  					alt9 = 8;  				}  				break;  			case NULL:  				{  					alt9 = 9;  				}  				break;  			default: {  				NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  			}  		}  		finally {  			DebugExitDecision (9);  		}  		switch (alt9) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  			{  				DebugLocation (64' 4);  				DebugLocation (64' 6);  				PushFollow (Follow._comparator_in_filterExpr175);  				comparator6 = comparator ();  				PopFollow ();  				Match (input' TokenTypes.Down' null);  				DebugLocation (64' 18);  				PushFollow (Follow._filterExpr_in_filterExpr179);  				a = filterExpr ();  				PopFollow ();  				DebugLocation (64' 31);  				PushFollow (Follow._filterExpr_in_filterExpr183);  				b = filterExpr ();  				PopFollow ();  				Match (input' TokenTypes.Up' null);  				DebugLocation (65' 4);  				Comparator newComparator;  				switch (comparator6) {  				case "=":  					newComparator = Comparator.Equals;  					break;  				case "!=":  					newComparator = Comparator.NotEquals;  					break;  				case ">":  					newComparator = Comparator.Greater;  					break;  				case "<":  					newComparator = Comparator.Less;  					break;  				case ">=":  					newComparator = Comparator.GreaterOrEqual;  					break;  				case "<=":  					newComparator = Comparator.LessOrEqual;  					break;  				case "&":  					newComparator = Comparator.And;  					break;  				case "|":  					newComparator = Comparator.Or;  					break;  				default:  					newComparator = Comparator.Equals;  					break;  				}  				filterNode = new BoolExpression (a' newComparator' b);  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  			{  				DebugLocation (98' 4);  				DebugLocation (98' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr195);  				Match (input' TokenTypes.Down' null);  				DebugLocation (98' 12);  				PushFollow (Follow._filterExpr_in_filterExpr199);  				f = filterExpr ();  				PopFollow ();  				DebugLocation (98' 31);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  				int alt6 = 2;  				try {  					DebugEnterSubRule (6);  					try {  						DebugEnterDecision (6' false);  						int LA6_1 = input.LA (1);  						if ((LA6_1 == 24)) {  							alt6 = 1;  						}  					}  					finally {  						DebugExitDecision (6);  					}  					switch (alt6) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  						{  							DebugLocation (98' 31);  							inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (6);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (99' 4);  				FilterTreeNode newNode = f;  				if ((inverse != null ? inverse.Text : default(string)) == "!")  					newNode.ToggleInversed ();  				filterNode = newNode;  			}  			break;  		case 3:  			DebugEnterAlt (3);  			// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  			{  				DebugLocation (105' 4);  				DebugLocation (105' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr216);  				Match (input' TokenTypes.Down' null);  				DebugLocation (105' 12);  				PushFollow (Follow._propertyChain_in_filterExpr219);  				propertyChain (propertySegments);  				PopFollow ();  				DebugLocation (105' 51);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  				int alt7 = 2;  				try {  					DebugEnterSubRule (7);  					try {  						DebugEnterDecision (7' false);  						int LA7_1 = input.LA (1);  						if ((LA7_1 == 31)) {  							alt7 = 1;  						}  					}  					finally {  						DebugExitDecision (7);  					}  					switch (alt7) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  						{  							DebugLocation (105' 51);  							inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (7);  				}  				DebugLocation (105' 60);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  				int alt8 = 2;  				try {  					DebugEnterSubRule (8);  					try {  						DebugEnterDecision (8' false);  						int LA8_1 = input.LA (1);  						if ((LA8_1 == 24)) {  							alt8 = 1;  						}  					}  					finally {  						DebugExitDecision (8);  					}  					switch (alt8) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  						{  							DebugLocation (105' 60);  							not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (8);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (106' 4);  				FilterTreeNode newProperty = new Property (propertySegments);  				if ((inverse != null ? inverse.Text : default(string)) == "?")  					filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  				else {  					if ((not != null ? not.Text : default(string)) == "!")  						newProperty.ToggleInversed ();  					filterNode = newProperty;  				}  			}  			break;  		case 4:  			DebugEnterAlt (4);  			// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  			{  				DebugLocation (116' 4);  				STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  				DebugLocation (117' 4);  				string stringText = (STRING7 != null ? STRING7.Text : default(string));  				stringText = stringText.Substring (1' stringText.Length - 2);  				filterNode = new Value (stringText);  			}  			break;  		case 5:  			DebugEnterAlt (5);  			// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  			{  				DebugLocation (122' 4);  				REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  				DebugLocation (123' 4);  				string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  				regexText = regexText.Substring (1' regexText.Length - 2);  				filterNode = new RegExp (regexText);  			}  			break;  		case 6:  			DebugEnterAlt (6);  			// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  			{  				DebugLocation (128' 4);  				NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  				DebugLocation (129' 4);  				filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  			}  			break;  		case 7:  			DebugEnterAlt (7);  			// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  			{  				DebugLocation (132' 4);  				Match (input' TRUE' Follow._TRUE_in_filterExpr271);  				DebugLocation (133' 4);  				filterNode = new Value (true);  			}  			break;  		case 8:  			DebugEnterAlt (8);  			// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  			{  				DebugLocation (136' 4);  				Match (input' FALSE' Follow._FALSE_in_filterExpr281);  				DebugLocation (137' 4);  				filterNode = new Value (false);  			}  			break;  		case 9:  			DebugEnterAlt (9);  			// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  			{  				DebugLocation (140' 4);  				Match (input' NULL' Follow._NULL_in_filterExpr291);  				DebugLocation (141' 4);  				filterNode = new Value (null);  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("filterExpr"' 6);  		LeaveRule ("filterExpr"' 6);  		LeaveRule_filterExpr ();  	}  	DebugLocation (144' 1);  }  finally {  	DebugExitRule (GrammarFileName' "filterExpr");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "filterExpr");  	DebugLocation (60' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  		int alt9 = 9;  		try {  			DebugEnterDecision (9' false);  			switch (input.LA (1)) {  			case CHAIN_OPERATOR:  			case COMPARATOR:  				{  					alt9 = 1;  				}  				break;  			case EXPR:  				{  					int LA9_2 = input.LA (2);  					if ((LA9_2 == DOWN)) {  						int LA9_3 = input.LA (3);  						if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  							alt9 = 2;  						}  						else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  							alt9 = 3;  						}  						else {  							NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  							DebugRecognitionException (nvae);  							throw nvae;  						}  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				break;  			case STRING:  				{  					alt9 = 4;  				}  				break;  			case REGEX:  				{  					alt9 = 5;  				}  				break;  			case NUMBER:  				{  					alt9 = 6;  				}  				break;  			case TRUE:  				{  					alt9 = 7;  				}  				break;  			case FALSE:  				{  					alt9 = 8;  				}  				break;  			case NULL:  				{  					alt9 = 9;  				}  				break;  			default: {  				NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  			}  		}  		finally {  			DebugExitDecision (9);  		}  		switch (alt9) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  			{  				DebugLocation (64' 4);  				DebugLocation (64' 6);  				PushFollow (Follow._comparator_in_filterExpr175);  				comparator6 = comparator ();  				PopFollow ();  				Match (input' TokenTypes.Down' null);  				DebugLocation (64' 18);  				PushFollow (Follow._filterExpr_in_filterExpr179);  				a = filterExpr ();  				PopFollow ();  				DebugLocation (64' 31);  				PushFollow (Follow._filterExpr_in_filterExpr183);  				b = filterExpr ();  				PopFollow ();  				Match (input' TokenTypes.Up' null);  				DebugLocation (65' 4);  				Comparator newComparator;  				switch (comparator6) {  				case "=":  					newComparator = Comparator.Equals;  					break;  				case "!=":  					newComparator = Comparator.NotEquals;  					break;  				case ">":  					newComparator = Comparator.Greater;  					break;  				case "<":  					newComparator = Comparator.Less;  					break;  				case ">=":  					newComparator = Comparator.GreaterOrEqual;  					break;  				case "<=":  					newComparator = Comparator.LessOrEqual;  					break;  				case "&":  					newComparator = Comparator.And;  					break;  				case "|":  					newComparator = Comparator.Or;  					break;  				default:  					newComparator = Comparator.Equals;  					break;  				}  				filterNode = new BoolExpression (a' newComparator' b);  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  			{  				DebugLocation (98' 4);  				DebugLocation (98' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr195);  				Match (input' TokenTypes.Down' null);  				DebugLocation (98' 12);  				PushFollow (Follow._filterExpr_in_filterExpr199);  				f = filterExpr ();  				PopFollow ();  				DebugLocation (98' 31);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  				int alt6 = 2;  				try {  					DebugEnterSubRule (6);  					try {  						DebugEnterDecision (6' false);  						int LA6_1 = input.LA (1);  						if ((LA6_1 == 24)) {  							alt6 = 1;  						}  					}  					finally {  						DebugExitDecision (6);  					}  					switch (alt6) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  						{  							DebugLocation (98' 31);  							inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (6);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (99' 4);  				FilterTreeNode newNode = f;  				if ((inverse != null ? inverse.Text : default(string)) == "!")  					newNode.ToggleInversed ();  				filterNode = newNode;  			}  			break;  		case 3:  			DebugEnterAlt (3);  			// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  			{  				DebugLocation (105' 4);  				DebugLocation (105' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr216);  				Match (input' TokenTypes.Down' null);  				DebugLocation (105' 12);  				PushFollow (Follow._propertyChain_in_filterExpr219);  				propertyChain (propertySegments);  				PopFollow ();  				DebugLocation (105' 51);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  				int alt7 = 2;  				try {  					DebugEnterSubRule (7);  					try {  						DebugEnterDecision (7' false);  						int LA7_1 = input.LA (1);  						if ((LA7_1 == 31)) {  							alt7 = 1;  						}  					}  					finally {  						DebugExitDecision (7);  					}  					switch (alt7) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  						{  							DebugLocation (105' 51);  							inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (7);  				}  				DebugLocation (105' 60);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  				int alt8 = 2;  				try {  					DebugEnterSubRule (8);  					try {  						DebugEnterDecision (8' false);  						int LA8_1 = input.LA (1);  						if ((LA8_1 == 24)) {  							alt8 = 1;  						}  					}  					finally {  						DebugExitDecision (8);  					}  					switch (alt8) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  						{  							DebugLocation (105' 60);  							not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (8);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (106' 4);  				FilterTreeNode newProperty = new Property (propertySegments);  				if ((inverse != null ? inverse.Text : default(string)) == "?")  					filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  				else {  					if ((not != null ? not.Text : default(string)) == "!")  						newProperty.ToggleInversed ();  					filterNode = newProperty;  				}  			}  			break;  		case 4:  			DebugEnterAlt (4);  			// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  			{  				DebugLocation (116' 4);  				STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  				DebugLocation (117' 4);  				string stringText = (STRING7 != null ? STRING7.Text : default(string));  				stringText = stringText.Substring (1' stringText.Length - 2);  				filterNode = new Value (stringText);  			}  			break;  		case 5:  			DebugEnterAlt (5);  			// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  			{  				DebugLocation (122' 4);  				REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  				DebugLocation (123' 4);  				string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  				regexText = regexText.Substring (1' regexText.Length - 2);  				filterNode = new RegExp (regexText);  			}  			break;  		case 6:  			DebugEnterAlt (6);  			// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  			{  				DebugLocation (128' 4);  				NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  				DebugLocation (129' 4);  				filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  			}  			break;  		case 7:  			DebugEnterAlt (7);  			// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  			{  				DebugLocation (132' 4);  				Match (input' TRUE' Follow._TRUE_in_filterExpr271);  				DebugLocation (133' 4);  				filterNode = new Value (true);  			}  			break;  		case 8:  			DebugEnterAlt (8);  			// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  			{  				DebugLocation (136' 4);  				Match (input' FALSE' Follow._FALSE_in_filterExpr281);  				DebugLocation (137' 4);  				filterNode = new Value (false);  			}  			break;  		case 9:  			DebugEnterAlt (9);  			// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  			{  				DebugLocation (140' 4);  				Match (input' NULL' Follow._NULL_in_filterExpr291);  				DebugLocation (141' 4);  				filterNode = new Value (null);  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("filterExpr"' 6);  		LeaveRule ("filterExpr"' 6);  		LeaveRule_filterExpr ();  	}  	DebugLocation (144' 1);  }  finally {  	DebugExitRule (GrammarFileName' "filterExpr");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "filterExpr");  	DebugLocation (60' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  		int alt9 = 9;  		try {  			DebugEnterDecision (9' false);  			switch (input.LA (1)) {  			case CHAIN_OPERATOR:  			case COMPARATOR:  				{  					alt9 = 1;  				}  				break;  			case EXPR:  				{  					int LA9_2 = input.LA (2);  					if ((LA9_2 == DOWN)) {  						int LA9_3 = input.LA (3);  						if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  							alt9 = 2;  						}  						else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  							alt9 = 3;  						}  						else {  							NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  							DebugRecognitionException (nvae);  							throw nvae;  						}  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				break;  			case STRING:  				{  					alt9 = 4;  				}  				break;  			case REGEX:  				{  					alt9 = 5;  				}  				break;  			case NUMBER:  				{  					alt9 = 6;  				}  				break;  			case TRUE:  				{  					alt9 = 7;  				}  				break;  			case FALSE:  				{  					alt9 = 8;  				}  				break;  			case NULL:  				{  					alt9 = 9;  				}  				break;  			default: {  				NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  			}  		}  		finally {  			DebugExitDecision (9);  		}  		switch (alt9) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  			{  				DebugLocation (64' 4);  				DebugLocation (64' 6);  				PushFollow (Follow._comparator_in_filterExpr175);  				comparator6 = comparator ();  				PopFollow ();  				Match (input' TokenTypes.Down' null);  				DebugLocation (64' 18);  				PushFollow (Follow._filterExpr_in_filterExpr179);  				a = filterExpr ();  				PopFollow ();  				DebugLocation (64' 31);  				PushFollow (Follow._filterExpr_in_filterExpr183);  				b = filterExpr ();  				PopFollow ();  				Match (input' TokenTypes.Up' null);  				DebugLocation (65' 4);  				Comparator newComparator;  				switch (comparator6) {  				case "=":  					newComparator = Comparator.Equals;  					break;  				case "!=":  					newComparator = Comparator.NotEquals;  					break;  				case ">":  					newComparator = Comparator.Greater;  					break;  				case "<":  					newComparator = Comparator.Less;  					break;  				case ">=":  					newComparator = Comparator.GreaterOrEqual;  					break;  				case "<=":  					newComparator = Comparator.LessOrEqual;  					break;  				case "&":  					newComparator = Comparator.And;  					break;  				case "|":  					newComparator = Comparator.Or;  					break;  				default:  					newComparator = Comparator.Equals;  					break;  				}  				filterNode = new BoolExpression (a' newComparator' b);  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  			{  				DebugLocation (98' 4);  				DebugLocation (98' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr195);  				Match (input' TokenTypes.Down' null);  				DebugLocation (98' 12);  				PushFollow (Follow._filterExpr_in_filterExpr199);  				f = filterExpr ();  				PopFollow ();  				DebugLocation (98' 31);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  				int alt6 = 2;  				try {  					DebugEnterSubRule (6);  					try {  						DebugEnterDecision (6' false);  						int LA6_1 = input.LA (1);  						if ((LA6_1 == 24)) {  							alt6 = 1;  						}  					}  					finally {  						DebugExitDecision (6);  					}  					switch (alt6) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  						{  							DebugLocation (98' 31);  							inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (6);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (99' 4);  				FilterTreeNode newNode = f;  				if ((inverse != null ? inverse.Text : default(string)) == "!")  					newNode.ToggleInversed ();  				filterNode = newNode;  			}  			break;  		case 3:  			DebugEnterAlt (3);  			// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  			{  				DebugLocation (105' 4);  				DebugLocation (105' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr216);  				Match (input' TokenTypes.Down' null);  				DebugLocation (105' 12);  				PushFollow (Follow._propertyChain_in_filterExpr219);  				propertyChain (propertySegments);  				PopFollow ();  				DebugLocation (105' 51);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  				int alt7 = 2;  				try {  					DebugEnterSubRule (7);  					try {  						DebugEnterDecision (7' false);  						int LA7_1 = input.LA (1);  						if ((LA7_1 == 31)) {  							alt7 = 1;  						}  					}  					finally {  						DebugExitDecision (7);  					}  					switch (alt7) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  						{  							DebugLocation (105' 51);  							inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (7);  				}  				DebugLocation (105' 60);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  				int alt8 = 2;  				try {  					DebugEnterSubRule (8);  					try {  						DebugEnterDecision (8' false);  						int LA8_1 = input.LA (1);  						if ((LA8_1 == 24)) {  							alt8 = 1;  						}  					}  					finally {  						DebugExitDecision (8);  					}  					switch (alt8) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  						{  							DebugLocation (105' 60);  							not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (8);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (106' 4);  				FilterTreeNode newProperty = new Property (propertySegments);  				if ((inverse != null ? inverse.Text : default(string)) == "?")  					filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  				else {  					if ((not != null ? not.Text : default(string)) == "!")  						newProperty.ToggleInversed ();  					filterNode = newProperty;  				}  			}  			break;  		case 4:  			DebugEnterAlt (4);  			// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  			{  				DebugLocation (116' 4);  				STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  				DebugLocation (117' 4);  				string stringText = (STRING7 != null ? STRING7.Text : default(string));  				stringText = stringText.Substring (1' stringText.Length - 2);  				filterNode = new Value (stringText);  			}  			break;  		case 5:  			DebugEnterAlt (5);  			// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  			{  				DebugLocation (122' 4);  				REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  				DebugLocation (123' 4);  				string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  				regexText = regexText.Substring (1' regexText.Length - 2);  				filterNode = new RegExp (regexText);  			}  			break;  		case 6:  			DebugEnterAlt (6);  			// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  			{  				DebugLocation (128' 4);  				NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  				DebugLocation (129' 4);  				filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  			}  			break;  		case 7:  			DebugEnterAlt (7);  			// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  			{  				DebugLocation (132' 4);  				Match (input' TRUE' Follow._TRUE_in_filterExpr271);  				DebugLocation (133' 4);  				filterNode = new Value (true);  			}  			break;  		case 8:  			DebugEnterAlt (8);  			// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  			{  				DebugLocation (136' 4);  				Match (input' FALSE' Follow._FALSE_in_filterExpr281);  				DebugLocation (137' 4);  				filterNode = new Value (false);  			}  			break;  		case 9:  			DebugEnterAlt (9);  			// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  			{  				DebugLocation (140' 4);  				Match (input' NULL' Follow._NULL_in_filterExpr291);  				DebugLocation (141' 4);  				filterNode = new Value (null);  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("filterExpr"' 6);  		LeaveRule ("filterExpr"' 6);  		LeaveRule_filterExpr ();  	}  	DebugLocation (144' 1);  }  finally {  	DebugExitRule (GrammarFileName' "filterExpr");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "filterExpr");  	DebugLocation (60' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  		int alt9 = 9;  		try {  			DebugEnterDecision (9' false);  			switch (input.LA (1)) {  			case CHAIN_OPERATOR:  			case COMPARATOR:  				{  					alt9 = 1;  				}  				break;  			case EXPR:  				{  					int LA9_2 = input.LA (2);  					if ((LA9_2 == DOWN)) {  						int LA9_3 = input.LA (3);  						if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  							alt9 = 2;  						}  						else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  							alt9 = 3;  						}  						else {  							NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  							DebugRecognitionException (nvae);  							throw nvae;  						}  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				break;  			case STRING:  				{  					alt9 = 4;  				}  				break;  			case REGEX:  				{  					alt9 = 5;  				}  				break;  			case NUMBER:  				{  					alt9 = 6;  				}  				break;  			case TRUE:  				{  					alt9 = 7;  				}  				break;  			case FALSE:  				{  					alt9 = 8;  				}  				break;  			case NULL:  				{  					alt9 = 9;  				}  				break;  			default: {  				NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  			}  		}  		finally {  			DebugExitDecision (9);  		}  		switch (alt9) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  			{  				DebugLocation (64' 4);  				DebugLocation (64' 6);  				PushFollow (Follow._comparator_in_filterExpr175);  				comparator6 = comparator ();  				PopFollow ();  				Match (input' TokenTypes.Down' null);  				DebugLocation (64' 18);  				PushFollow (Follow._filterExpr_in_filterExpr179);  				a = filterExpr ();  				PopFollow ();  				DebugLocation (64' 31);  				PushFollow (Follow._filterExpr_in_filterExpr183);  				b = filterExpr ();  				PopFollow ();  				Match (input' TokenTypes.Up' null);  				DebugLocation (65' 4);  				Comparator newComparator;  				switch (comparator6) {  				case "=":  					newComparator = Comparator.Equals;  					break;  				case "!=":  					newComparator = Comparator.NotEquals;  					break;  				case ">":  					newComparator = Comparator.Greater;  					break;  				case "<":  					newComparator = Comparator.Less;  					break;  				case ">=":  					newComparator = Comparator.GreaterOrEqual;  					break;  				case "<=":  					newComparator = Comparator.LessOrEqual;  					break;  				case "&":  					newComparator = Comparator.And;  					break;  				case "|":  					newComparator = Comparator.Or;  					break;  				default:  					newComparator = Comparator.Equals;  					break;  				}  				filterNode = new BoolExpression (a' newComparator' b);  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  			{  				DebugLocation (98' 4);  				DebugLocation (98' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr195);  				Match (input' TokenTypes.Down' null);  				DebugLocation (98' 12);  				PushFollow (Follow._filterExpr_in_filterExpr199);  				f = filterExpr ();  				PopFollow ();  				DebugLocation (98' 31);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  				int alt6 = 2;  				try {  					DebugEnterSubRule (6);  					try {  						DebugEnterDecision (6' false);  						int LA6_1 = input.LA (1);  						if ((LA6_1 == 24)) {  							alt6 = 1;  						}  					}  					finally {  						DebugExitDecision (6);  					}  					switch (alt6) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  						{  							DebugLocation (98' 31);  							inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (6);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (99' 4);  				FilterTreeNode newNode = f;  				if ((inverse != null ? inverse.Text : default(string)) == "!")  					newNode.ToggleInversed ();  				filterNode = newNode;  			}  			break;  		case 3:  			DebugEnterAlt (3);  			// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  			{  				DebugLocation (105' 4);  				DebugLocation (105' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr216);  				Match (input' TokenTypes.Down' null);  				DebugLocation (105' 12);  				PushFollow (Follow._propertyChain_in_filterExpr219);  				propertyChain (propertySegments);  				PopFollow ();  				DebugLocation (105' 51);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  				int alt7 = 2;  				try {  					DebugEnterSubRule (7);  					try {  						DebugEnterDecision (7' false);  						int LA7_1 = input.LA (1);  						if ((LA7_1 == 31)) {  							alt7 = 1;  						}  					}  					finally {  						DebugExitDecision (7);  					}  					switch (alt7) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  						{  							DebugLocation (105' 51);  							inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (7);  				}  				DebugLocation (105' 60);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  				int alt8 = 2;  				try {  					DebugEnterSubRule (8);  					try {  						DebugEnterDecision (8' false);  						int LA8_1 = input.LA (1);  						if ((LA8_1 == 24)) {  							alt8 = 1;  						}  					}  					finally {  						DebugExitDecision (8);  					}  					switch (alt8) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  						{  							DebugLocation (105' 60);  							not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (8);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (106' 4);  				FilterTreeNode newProperty = new Property (propertySegments);  				if ((inverse != null ? inverse.Text : default(string)) == "?")  					filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  				else {  					if ((not != null ? not.Text : default(string)) == "!")  						newProperty.ToggleInversed ();  					filterNode = newProperty;  				}  			}  			break;  		case 4:  			DebugEnterAlt (4);  			// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  			{  				DebugLocation (116' 4);  				STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  				DebugLocation (117' 4);  				string stringText = (STRING7 != null ? STRING7.Text : default(string));  				stringText = stringText.Substring (1' stringText.Length - 2);  				filterNode = new Value (stringText);  			}  			break;  		case 5:  			DebugEnterAlt (5);  			// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  			{  				DebugLocation (122' 4);  				REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  				DebugLocation (123' 4);  				string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  				regexText = regexText.Substring (1' regexText.Length - 2);  				filterNode = new RegExp (regexText);  			}  			break;  		case 6:  			DebugEnterAlt (6);  			// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  			{  				DebugLocation (128' 4);  				NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  				DebugLocation (129' 4);  				filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  			}  			break;  		case 7:  			DebugEnterAlt (7);  			// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  			{  				DebugLocation (132' 4);  				Match (input' TRUE' Follow._TRUE_in_filterExpr271);  				DebugLocation (133' 4);  				filterNode = new Value (true);  			}  			break;  		case 8:  			DebugEnterAlt (8);  			// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  			{  				DebugLocation (136' 4);  				Match (input' FALSE' Follow._FALSE_in_filterExpr281);  				DebugLocation (137' 4);  				filterNode = new Value (false);  			}  			break;  		case 9:  			DebugEnterAlt (9);  			// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  			{  				DebugLocation (140' 4);  				Match (input' NULL' Follow._NULL_in_filterExpr291);  				DebugLocation (141' 4);  				filterNode = new Value (null);  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("filterExpr"' 6);  		LeaveRule ("filterExpr"' 6);  		LeaveRule_filterExpr ();  	}  	DebugLocation (144' 1);  }  finally {  	DebugExitRule (GrammarFileName' "filterExpr");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "filterExpr");  	DebugLocation (60' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  		int alt9 = 9;  		try {  			DebugEnterDecision (9' false);  			switch (input.LA (1)) {  			case CHAIN_OPERATOR:  			case COMPARATOR:  				{  					alt9 = 1;  				}  				break;  			case EXPR:  				{  					int LA9_2 = input.LA (2);  					if ((LA9_2 == DOWN)) {  						int LA9_3 = input.LA (3);  						if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  							alt9 = 2;  						}  						else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  							alt9 = 3;  						}  						else {  							NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  							DebugRecognitionException (nvae);  							throw nvae;  						}  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				break;  			case STRING:  				{  					alt9 = 4;  				}  				break;  			case REGEX:  				{  					alt9 = 5;  				}  				break;  			case NUMBER:  				{  					alt9 = 6;  				}  				break;  			case TRUE:  				{  					alt9 = 7;  				}  				break;  			case FALSE:  				{  					alt9 = 8;  				}  				break;  			case NULL:  				{  					alt9 = 9;  				}  				break;  			default: {  				NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  			}  		}  		finally {  			DebugExitDecision (9);  		}  		switch (alt9) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  			{  				DebugLocation (64' 4);  				DebugLocation (64' 6);  				PushFollow (Follow._comparator_in_filterExpr175);  				comparator6 = comparator ();  				PopFollow ();  				Match (input' TokenTypes.Down' null);  				DebugLocation (64' 18);  				PushFollow (Follow._filterExpr_in_filterExpr179);  				a = filterExpr ();  				PopFollow ();  				DebugLocation (64' 31);  				PushFollow (Follow._filterExpr_in_filterExpr183);  				b = filterExpr ();  				PopFollow ();  				Match (input' TokenTypes.Up' null);  				DebugLocation (65' 4);  				Comparator newComparator;  				switch (comparator6) {  				case "=":  					newComparator = Comparator.Equals;  					break;  				case "!=":  					newComparator = Comparator.NotEquals;  					break;  				case ">":  					newComparator = Comparator.Greater;  					break;  				case "<":  					newComparator = Comparator.Less;  					break;  				case ">=":  					newComparator = Comparator.GreaterOrEqual;  					break;  				case "<=":  					newComparator = Comparator.LessOrEqual;  					break;  				case "&":  					newComparator = Comparator.And;  					break;  				case "|":  					newComparator = Comparator.Or;  					break;  				default:  					newComparator = Comparator.Equals;  					break;  				}  				filterNode = new BoolExpression (a' newComparator' b);  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  			{  				DebugLocation (98' 4);  				DebugLocation (98' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr195);  				Match (input' TokenTypes.Down' null);  				DebugLocation (98' 12);  				PushFollow (Follow._filterExpr_in_filterExpr199);  				f = filterExpr ();  				PopFollow ();  				DebugLocation (98' 31);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  				int alt6 = 2;  				try {  					DebugEnterSubRule (6);  					try {  						DebugEnterDecision (6' false);  						int LA6_1 = input.LA (1);  						if ((LA6_1 == 24)) {  							alt6 = 1;  						}  					}  					finally {  						DebugExitDecision (6);  					}  					switch (alt6) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  						{  							DebugLocation (98' 31);  							inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (6);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (99' 4);  				FilterTreeNode newNode = f;  				if ((inverse != null ? inverse.Text : default(string)) == "!")  					newNode.ToggleInversed ();  				filterNode = newNode;  			}  			break;  		case 3:  			DebugEnterAlt (3);  			// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  			{  				DebugLocation (105' 4);  				DebugLocation (105' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr216);  				Match (input' TokenTypes.Down' null);  				DebugLocation (105' 12);  				PushFollow (Follow._propertyChain_in_filterExpr219);  				propertyChain (propertySegments);  				PopFollow ();  				DebugLocation (105' 51);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  				int alt7 = 2;  				try {  					DebugEnterSubRule (7);  					try {  						DebugEnterDecision (7' false);  						int LA7_1 = input.LA (1);  						if ((LA7_1 == 31)) {  							alt7 = 1;  						}  					}  					finally {  						DebugExitDecision (7);  					}  					switch (alt7) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  						{  							DebugLocation (105' 51);  							inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (7);  				}  				DebugLocation (105' 60);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  				int alt8 = 2;  				try {  					DebugEnterSubRule (8);  					try {  						DebugEnterDecision (8' false);  						int LA8_1 = input.LA (1);  						if ((LA8_1 == 24)) {  							alt8 = 1;  						}  					}  					finally {  						DebugExitDecision (8);  					}  					switch (alt8) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  						{  							DebugLocation (105' 60);  							not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (8);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (106' 4);  				FilterTreeNode newProperty = new Property (propertySegments);  				if ((inverse != null ? inverse.Text : default(string)) == "?")  					filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  				else {  					if ((not != null ? not.Text : default(string)) == "!")  						newProperty.ToggleInversed ();  					filterNode = newProperty;  				}  			}  			break;  		case 4:  			DebugEnterAlt (4);  			// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  			{  				DebugLocation (116' 4);  				STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  				DebugLocation (117' 4);  				string stringText = (STRING7 != null ? STRING7.Text : default(string));  				stringText = stringText.Substring (1' stringText.Length - 2);  				filterNode = new Value (stringText);  			}  			break;  		case 5:  			DebugEnterAlt (5);  			// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  			{  				DebugLocation (122' 4);  				REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  				DebugLocation (123' 4);  				string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  				regexText = regexText.Substring (1' regexText.Length - 2);  				filterNode = new RegExp (regexText);  			}  			break;  		case 6:  			DebugEnterAlt (6);  			// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  			{  				DebugLocation (128' 4);  				NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  				DebugLocation (129' 4);  				filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  			}  			break;  		case 7:  			DebugEnterAlt (7);  			// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  			{  				DebugLocation (132' 4);  				Match (input' TRUE' Follow._TRUE_in_filterExpr271);  				DebugLocation (133' 4);  				filterNode = new Value (true);  			}  			break;  		case 8:  			DebugEnterAlt (8);  			// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  			{  				DebugLocation (136' 4);  				Match (input' FALSE' Follow._FALSE_in_filterExpr281);  				DebugLocation (137' 4);  				filterNode = new Value (false);  			}  			break;  		case 9:  			DebugEnterAlt (9);  			// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  			{  				DebugLocation (140' 4);  				Match (input' NULL' Follow._NULL_in_filterExpr291);  				DebugLocation (141' 4);  				filterNode = new Value (null);  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("filterExpr"' 6);  		LeaveRule ("filterExpr"' 6);  		LeaveRule_filterExpr ();  	}  	DebugLocation (144' 1);  }  finally {  	DebugExitRule (GrammarFileName' "filterExpr");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "filterExpr");  	DebugLocation (60' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  		int alt9 = 9;  		try {  			DebugEnterDecision (9' false);  			switch (input.LA (1)) {  			case CHAIN_OPERATOR:  			case COMPARATOR:  				{  					alt9 = 1;  				}  				break;  			case EXPR:  				{  					int LA9_2 = input.LA (2);  					if ((LA9_2 == DOWN)) {  						int LA9_3 = input.LA (3);  						if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  							alt9 = 2;  						}  						else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  							alt9 = 3;  						}  						else {  							NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  							DebugRecognitionException (nvae);  							throw nvae;  						}  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				break;  			case STRING:  				{  					alt9 = 4;  				}  				break;  			case REGEX:  				{  					alt9 = 5;  				}  				break;  			case NUMBER:  				{  					alt9 = 6;  				}  				break;  			case TRUE:  				{  					alt9 = 7;  				}  				break;  			case FALSE:  				{  					alt9 = 8;  				}  				break;  			case NULL:  				{  					alt9 = 9;  				}  				break;  			default: {  				NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  			}  		}  		finally {  			DebugExitDecision (9);  		}  		switch (alt9) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  			{  				DebugLocation (64' 4);  				DebugLocation (64' 6);  				PushFollow (Follow._comparator_in_filterExpr175);  				comparator6 = comparator ();  				PopFollow ();  				Match (input' TokenTypes.Down' null);  				DebugLocation (64' 18);  				PushFollow (Follow._filterExpr_in_filterExpr179);  				a = filterExpr ();  				PopFollow ();  				DebugLocation (64' 31);  				PushFollow (Follow._filterExpr_in_filterExpr183);  				b = filterExpr ();  				PopFollow ();  				Match (input' TokenTypes.Up' null);  				DebugLocation (65' 4);  				Comparator newComparator;  				switch (comparator6) {  				case "=":  					newComparator = Comparator.Equals;  					break;  				case "!=":  					newComparator = Comparator.NotEquals;  					break;  				case ">":  					newComparator = Comparator.Greater;  					break;  				case "<":  					newComparator = Comparator.Less;  					break;  				case ">=":  					newComparator = Comparator.GreaterOrEqual;  					break;  				case "<=":  					newComparator = Comparator.LessOrEqual;  					break;  				case "&":  					newComparator = Comparator.And;  					break;  				case "|":  					newComparator = Comparator.Or;  					break;  				default:  					newComparator = Comparator.Equals;  					break;  				}  				filterNode = new BoolExpression (a' newComparator' b);  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  			{  				DebugLocation (98' 4);  				DebugLocation (98' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr195);  				Match (input' TokenTypes.Down' null);  				DebugLocation (98' 12);  				PushFollow (Follow._filterExpr_in_filterExpr199);  				f = filterExpr ();  				PopFollow ();  				DebugLocation (98' 31);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  				int alt6 = 2;  				try {  					DebugEnterSubRule (6);  					try {  						DebugEnterDecision (6' false);  						int LA6_1 = input.LA (1);  						if ((LA6_1 == 24)) {  							alt6 = 1;  						}  					}  					finally {  						DebugExitDecision (6);  					}  					switch (alt6) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  						{  							DebugLocation (98' 31);  							inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (6);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (99' 4);  				FilterTreeNode newNode = f;  				if ((inverse != null ? inverse.Text : default(string)) == "!")  					newNode.ToggleInversed ();  				filterNode = newNode;  			}  			break;  		case 3:  			DebugEnterAlt (3);  			// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  			{  				DebugLocation (105' 4);  				DebugLocation (105' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr216);  				Match (input' TokenTypes.Down' null);  				DebugLocation (105' 12);  				PushFollow (Follow._propertyChain_in_filterExpr219);  				propertyChain (propertySegments);  				PopFollow ();  				DebugLocation (105' 51);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  				int alt7 = 2;  				try {  					DebugEnterSubRule (7);  					try {  						DebugEnterDecision (7' false);  						int LA7_1 = input.LA (1);  						if ((LA7_1 == 31)) {  							alt7 = 1;  						}  					}  					finally {  						DebugExitDecision (7);  					}  					switch (alt7) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  						{  							DebugLocation (105' 51);  							inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (7);  				}  				DebugLocation (105' 60);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  				int alt8 = 2;  				try {  					DebugEnterSubRule (8);  					try {  						DebugEnterDecision (8' false);  						int LA8_1 = input.LA (1);  						if ((LA8_1 == 24)) {  							alt8 = 1;  						}  					}  					finally {  						DebugExitDecision (8);  					}  					switch (alt8) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  						{  							DebugLocation (105' 60);  							not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (8);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (106' 4);  				FilterTreeNode newProperty = new Property (propertySegments);  				if ((inverse != null ? inverse.Text : default(string)) == "?")  					filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  				else {  					if ((not != null ? not.Text : default(string)) == "!")  						newProperty.ToggleInversed ();  					filterNode = newProperty;  				}  			}  			break;  		case 4:  			DebugEnterAlt (4);  			// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  			{  				DebugLocation (116' 4);  				STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  				DebugLocation (117' 4);  				string stringText = (STRING7 != null ? STRING7.Text : default(string));  				stringText = stringText.Substring (1' stringText.Length - 2);  				filterNode = new Value (stringText);  			}  			break;  		case 5:  			DebugEnterAlt (5);  			// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  			{  				DebugLocation (122' 4);  				REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  				DebugLocation (123' 4);  				string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  				regexText = regexText.Substring (1' regexText.Length - 2);  				filterNode = new RegExp (regexText);  			}  			break;  		case 6:  			DebugEnterAlt (6);  			// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  			{  				DebugLocation (128' 4);  				NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  				DebugLocation (129' 4);  				filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  			}  			break;  		case 7:  			DebugEnterAlt (7);  			// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  			{  				DebugLocation (132' 4);  				Match (input' TRUE' Follow._TRUE_in_filterExpr271);  				DebugLocation (133' 4);  				filterNode = new Value (true);  			}  			break;  		case 8:  			DebugEnterAlt (8);  			// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  			{  				DebugLocation (136' 4);  				Match (input' FALSE' Follow._FALSE_in_filterExpr281);  				DebugLocation (137' 4);  				filterNode = new Value (false);  			}  			break;  		case 9:  			DebugEnterAlt (9);  			// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  			{  				DebugLocation (140' 4);  				Match (input' NULL' Follow._NULL_in_filterExpr291);  				DebugLocation (141' 4);  				filterNode = new Value (null);  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("filterExpr"' 6);  		LeaveRule ("filterExpr"' 6);  		LeaveRule_filterExpr ();  	}  	DebugLocation (144' 1);  }  finally {  	DebugExitRule (GrammarFileName' "filterExpr");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "filterExpr");  	DebugLocation (60' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  		int alt9 = 9;  		try {  			DebugEnterDecision (9' false);  			switch (input.LA (1)) {  			case CHAIN_OPERATOR:  			case COMPARATOR:  				{  					alt9 = 1;  				}  				break;  			case EXPR:  				{  					int LA9_2 = input.LA (2);  					if ((LA9_2 == DOWN)) {  						int LA9_3 = input.LA (3);  						if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  							alt9 = 2;  						}  						else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  							alt9 = 3;  						}  						else {  							NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  							DebugRecognitionException (nvae);  							throw nvae;  						}  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				break;  			case STRING:  				{  					alt9 = 4;  				}  				break;  			case REGEX:  				{  					alt9 = 5;  				}  				break;  			case NUMBER:  				{  					alt9 = 6;  				}  				break;  			case TRUE:  				{  					alt9 = 7;  				}  				break;  			case FALSE:  				{  					alt9 = 8;  				}  				break;  			case NULL:  				{  					alt9 = 9;  				}  				break;  			default: {  				NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  			}  		}  		finally {  			DebugExitDecision (9);  		}  		switch (alt9) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  			{  				DebugLocation (64' 4);  				DebugLocation (64' 6);  				PushFollow (Follow._comparator_in_filterExpr175);  				comparator6 = comparator ();  				PopFollow ();  				Match (input' TokenTypes.Down' null);  				DebugLocation (64' 18);  				PushFollow (Follow._filterExpr_in_filterExpr179);  				a = filterExpr ();  				PopFollow ();  				DebugLocation (64' 31);  				PushFollow (Follow._filterExpr_in_filterExpr183);  				b = filterExpr ();  				PopFollow ();  				Match (input' TokenTypes.Up' null);  				DebugLocation (65' 4);  				Comparator newComparator;  				switch (comparator6) {  				case "=":  					newComparator = Comparator.Equals;  					break;  				case "!=":  					newComparator = Comparator.NotEquals;  					break;  				case ">":  					newComparator = Comparator.Greater;  					break;  				case "<":  					newComparator = Comparator.Less;  					break;  				case ">=":  					newComparator = Comparator.GreaterOrEqual;  					break;  				case "<=":  					newComparator = Comparator.LessOrEqual;  					break;  				case "&":  					newComparator = Comparator.And;  					break;  				case "|":  					newComparator = Comparator.Or;  					break;  				default:  					newComparator = Comparator.Equals;  					break;  				}  				filterNode = new BoolExpression (a' newComparator' b);  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  			{  				DebugLocation (98' 4);  				DebugLocation (98' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr195);  				Match (input' TokenTypes.Down' null);  				DebugLocation (98' 12);  				PushFollow (Follow._filterExpr_in_filterExpr199);  				f = filterExpr ();  				PopFollow ();  				DebugLocation (98' 31);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  				int alt6 = 2;  				try {  					DebugEnterSubRule (6);  					try {  						DebugEnterDecision (6' false);  						int LA6_1 = input.LA (1);  						if ((LA6_1 == 24)) {  							alt6 = 1;  						}  					}  					finally {  						DebugExitDecision (6);  					}  					switch (alt6) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  						{  							DebugLocation (98' 31);  							inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (6);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (99' 4);  				FilterTreeNode newNode = f;  				if ((inverse != null ? inverse.Text : default(string)) == "!")  					newNode.ToggleInversed ();  				filterNode = newNode;  			}  			break;  		case 3:  			DebugEnterAlt (3);  			// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  			{  				DebugLocation (105' 4);  				DebugLocation (105' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr216);  				Match (input' TokenTypes.Down' null);  				DebugLocation (105' 12);  				PushFollow (Follow._propertyChain_in_filterExpr219);  				propertyChain (propertySegments);  				PopFollow ();  				DebugLocation (105' 51);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  				int alt7 = 2;  				try {  					DebugEnterSubRule (7);  					try {  						DebugEnterDecision (7' false);  						int LA7_1 = input.LA (1);  						if ((LA7_1 == 31)) {  							alt7 = 1;  						}  					}  					finally {  						DebugExitDecision (7);  					}  					switch (alt7) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  						{  							DebugLocation (105' 51);  							inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (7);  				}  				DebugLocation (105' 60);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  				int alt8 = 2;  				try {  					DebugEnterSubRule (8);  					try {  						DebugEnterDecision (8' false);  						int LA8_1 = input.LA (1);  						if ((LA8_1 == 24)) {  							alt8 = 1;  						}  					}  					finally {  						DebugExitDecision (8);  					}  					switch (alt8) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  						{  							DebugLocation (105' 60);  							not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (8);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (106' 4);  				FilterTreeNode newProperty = new Property (propertySegments);  				if ((inverse != null ? inverse.Text : default(string)) == "?")  					filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  				else {  					if ((not != null ? not.Text : default(string)) == "!")  						newProperty.ToggleInversed ();  					filterNode = newProperty;  				}  			}  			break;  		case 4:  			DebugEnterAlt (4);  			// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  			{  				DebugLocation (116' 4);  				STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  				DebugLocation (117' 4);  				string stringText = (STRING7 != null ? STRING7.Text : default(string));  				stringText = stringText.Substring (1' stringText.Length - 2);  				filterNode = new Value (stringText);  			}  			break;  		case 5:  			DebugEnterAlt (5);  			// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  			{  				DebugLocation (122' 4);  				REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  				DebugLocation (123' 4);  				string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  				regexText = regexText.Substring (1' regexText.Length - 2);  				filterNode = new RegExp (regexText);  			}  			break;  		case 6:  			DebugEnterAlt (6);  			// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  			{  				DebugLocation (128' 4);  				NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  				DebugLocation (129' 4);  				filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  			}  			break;  		case 7:  			DebugEnterAlt (7);  			// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  			{  				DebugLocation (132' 4);  				Match (input' TRUE' Follow._TRUE_in_filterExpr271);  				DebugLocation (133' 4);  				filterNode = new Value (true);  			}  			break;  		case 8:  			DebugEnterAlt (8);  			// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  			{  				DebugLocation (136' 4);  				Match (input' FALSE' Follow._FALSE_in_filterExpr281);  				DebugLocation (137' 4);  				filterNode = new Value (false);  			}  			break;  		case 9:  			DebugEnterAlt (9);  			// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  			{  				DebugLocation (140' 4);  				Match (input' NULL' Follow._NULL_in_filterExpr291);  				DebugLocation (141' 4);  				filterNode = new Value (null);  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("filterExpr"' 6);  		LeaveRule ("filterExpr"' 6);  		LeaveRule_filterExpr ();  	}  	DebugLocation (144' 1);  }  finally {  	DebugExitRule (GrammarFileName' "filterExpr");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "filterExpr");  	DebugLocation (60' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  		int alt9 = 9;  		try {  			DebugEnterDecision (9' false);  			switch (input.LA (1)) {  			case CHAIN_OPERATOR:  			case COMPARATOR:  				{  					alt9 = 1;  				}  				break;  			case EXPR:  				{  					int LA9_2 = input.LA (2);  					if ((LA9_2 == DOWN)) {  						int LA9_3 = input.LA (3);  						if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  							alt9 = 2;  						}  						else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  							alt9 = 3;  						}  						else {  							NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  							DebugRecognitionException (nvae);  							throw nvae;  						}  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				break;  			case STRING:  				{  					alt9 = 4;  				}  				break;  			case REGEX:  				{  					alt9 = 5;  				}  				break;  			case NUMBER:  				{  					alt9 = 6;  				}  				break;  			case TRUE:  				{  					alt9 = 7;  				}  				break;  			case FALSE:  				{  					alt9 = 8;  				}  				break;  			case NULL:  				{  					alt9 = 9;  				}  				break;  			default: {  				NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  			}  		}  		finally {  			DebugExitDecision (9);  		}  		switch (alt9) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  			{  				DebugLocation (64' 4);  				DebugLocation (64' 6);  				PushFollow (Follow._comparator_in_filterExpr175);  				comparator6 = comparator ();  				PopFollow ();  				Match (input' TokenTypes.Down' null);  				DebugLocation (64' 18);  				PushFollow (Follow._filterExpr_in_filterExpr179);  				a = filterExpr ();  				PopFollow ();  				DebugLocation (64' 31);  				PushFollow (Follow._filterExpr_in_filterExpr183);  				b = filterExpr ();  				PopFollow ();  				Match (input' TokenTypes.Up' null);  				DebugLocation (65' 4);  				Comparator newComparator;  				switch (comparator6) {  				case "=":  					newComparator = Comparator.Equals;  					break;  				case "!=":  					newComparator = Comparator.NotEquals;  					break;  				case ">":  					newComparator = Comparator.Greater;  					break;  				case "<":  					newComparator = Comparator.Less;  					break;  				case ">=":  					newComparator = Comparator.GreaterOrEqual;  					break;  				case "<=":  					newComparator = Comparator.LessOrEqual;  					break;  				case "&":  					newComparator = Comparator.And;  					break;  				case "|":  					newComparator = Comparator.Or;  					break;  				default:  					newComparator = Comparator.Equals;  					break;  				}  				filterNode = new BoolExpression (a' newComparator' b);  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  			{  				DebugLocation (98' 4);  				DebugLocation (98' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr195);  				Match (input' TokenTypes.Down' null);  				DebugLocation (98' 12);  				PushFollow (Follow._filterExpr_in_filterExpr199);  				f = filterExpr ();  				PopFollow ();  				DebugLocation (98' 31);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  				int alt6 = 2;  				try {  					DebugEnterSubRule (6);  					try {  						DebugEnterDecision (6' false);  						int LA6_1 = input.LA (1);  						if ((LA6_1 == 24)) {  							alt6 = 1;  						}  					}  					finally {  						DebugExitDecision (6);  					}  					switch (alt6) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  						{  							DebugLocation (98' 31);  							inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (6);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (99' 4);  				FilterTreeNode newNode = f;  				if ((inverse != null ? inverse.Text : default(string)) == "!")  					newNode.ToggleInversed ();  				filterNode = newNode;  			}  			break;  		case 3:  			DebugEnterAlt (3);  			// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  			{  				DebugLocation (105' 4);  				DebugLocation (105' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr216);  				Match (input' TokenTypes.Down' null);  				DebugLocation (105' 12);  				PushFollow (Follow._propertyChain_in_filterExpr219);  				propertyChain (propertySegments);  				PopFollow ();  				DebugLocation (105' 51);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  				int alt7 = 2;  				try {  					DebugEnterSubRule (7);  					try {  						DebugEnterDecision (7' false);  						int LA7_1 = input.LA (1);  						if ((LA7_1 == 31)) {  							alt7 = 1;  						}  					}  					finally {  						DebugExitDecision (7);  					}  					switch (alt7) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  						{  							DebugLocation (105' 51);  							inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (7);  				}  				DebugLocation (105' 60);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  				int alt8 = 2;  				try {  					DebugEnterSubRule (8);  					try {  						DebugEnterDecision (8' false);  						int LA8_1 = input.LA (1);  						if ((LA8_1 == 24)) {  							alt8 = 1;  						}  					}  					finally {  						DebugExitDecision (8);  					}  					switch (alt8) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  						{  							DebugLocation (105' 60);  							not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (8);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (106' 4);  				FilterTreeNode newProperty = new Property (propertySegments);  				if ((inverse != null ? inverse.Text : default(string)) == "?")  					filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  				else {  					if ((not != null ? not.Text : default(string)) == "!")  						newProperty.ToggleInversed ();  					filterNode = newProperty;  				}  			}  			break;  		case 4:  			DebugEnterAlt (4);  			// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  			{  				DebugLocation (116' 4);  				STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  				DebugLocation (117' 4);  				string stringText = (STRING7 != null ? STRING7.Text : default(string));  				stringText = stringText.Substring (1' stringText.Length - 2);  				filterNode = new Value (stringText);  			}  			break;  		case 5:  			DebugEnterAlt (5);  			// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  			{  				DebugLocation (122' 4);  				REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  				DebugLocation (123' 4);  				string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  				regexText = regexText.Substring (1' regexText.Length - 2);  				filterNode = new RegExp (regexText);  			}  			break;  		case 6:  			DebugEnterAlt (6);  			// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  			{  				DebugLocation (128' 4);  				NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  				DebugLocation (129' 4);  				filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  			}  			break;  		case 7:  			DebugEnterAlt (7);  			// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  			{  				DebugLocation (132' 4);  				Match (input' TRUE' Follow._TRUE_in_filterExpr271);  				DebugLocation (133' 4);  				filterNode = new Value (true);  			}  			break;  		case 8:  			DebugEnterAlt (8);  			// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  			{  				DebugLocation (136' 4);  				Match (input' FALSE' Follow._FALSE_in_filterExpr281);  				DebugLocation (137' 4);  				filterNode = new Value (false);  			}  			break;  		case 9:  			DebugEnterAlt (9);  			// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  			{  				DebugLocation (140' 4);  				Match (input' NULL' Follow._NULL_in_filterExpr291);  				DebugLocation (141' 4);  				filterNode = new Value (null);  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("filterExpr"' 6);  		LeaveRule ("filterExpr"' 6);  		LeaveRule_filterExpr ();  	}  	DebugLocation (144' 1);  }  finally {  	DebugExitRule (GrammarFileName' "filterExpr");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "filterExpr");  	DebugLocation (60' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  		int alt9 = 9;  		try {  			DebugEnterDecision (9' false);  			switch (input.LA (1)) {  			case CHAIN_OPERATOR:  			case COMPARATOR:  				{  					alt9 = 1;  				}  				break;  			case EXPR:  				{  					int LA9_2 = input.LA (2);  					if ((LA9_2 == DOWN)) {  						int LA9_3 = input.LA (3);  						if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  							alt9 = 2;  						}  						else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  							alt9 = 3;  						}  						else {  							NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  							DebugRecognitionException (nvae);  							throw nvae;  						}  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				break;  			case STRING:  				{  					alt9 = 4;  				}  				break;  			case REGEX:  				{  					alt9 = 5;  				}  				break;  			case NUMBER:  				{  					alt9 = 6;  				}  				break;  			case TRUE:  				{  					alt9 = 7;  				}  				break;  			case FALSE:  				{  					alt9 = 8;  				}  				break;  			case NULL:  				{  					alt9 = 9;  				}  				break;  			default: {  				NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  			}  		}  		finally {  			DebugExitDecision (9);  		}  		switch (alt9) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  			{  				DebugLocation (64' 4);  				DebugLocation (64' 6);  				PushFollow (Follow._comparator_in_filterExpr175);  				comparator6 = comparator ();  				PopFollow ();  				Match (input' TokenTypes.Down' null);  				DebugLocation (64' 18);  				PushFollow (Follow._filterExpr_in_filterExpr179);  				a = filterExpr ();  				PopFollow ();  				DebugLocation (64' 31);  				PushFollow (Follow._filterExpr_in_filterExpr183);  				b = filterExpr ();  				PopFollow ();  				Match (input' TokenTypes.Up' null);  				DebugLocation (65' 4);  				Comparator newComparator;  				switch (comparator6) {  				case "=":  					newComparator = Comparator.Equals;  					break;  				case "!=":  					newComparator = Comparator.NotEquals;  					break;  				case ">":  					newComparator = Comparator.Greater;  					break;  				case "<":  					newComparator = Comparator.Less;  					break;  				case ">=":  					newComparator = Comparator.GreaterOrEqual;  					break;  				case "<=":  					newComparator = Comparator.LessOrEqual;  					break;  				case "&":  					newComparator = Comparator.And;  					break;  				case "|":  					newComparator = Comparator.Or;  					break;  				default:  					newComparator = Comparator.Equals;  					break;  				}  				filterNode = new BoolExpression (a' newComparator' b);  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  			{  				DebugLocation (98' 4);  				DebugLocation (98' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr195);  				Match (input' TokenTypes.Down' null);  				DebugLocation (98' 12);  				PushFollow (Follow._filterExpr_in_filterExpr199);  				f = filterExpr ();  				PopFollow ();  				DebugLocation (98' 31);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  				int alt6 = 2;  				try {  					DebugEnterSubRule (6);  					try {  						DebugEnterDecision (6' false);  						int LA6_1 = input.LA (1);  						if ((LA6_1 == 24)) {  							alt6 = 1;  						}  					}  					finally {  						DebugExitDecision (6);  					}  					switch (alt6) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  						{  							DebugLocation (98' 31);  							inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (6);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (99' 4);  				FilterTreeNode newNode = f;  				if ((inverse != null ? inverse.Text : default(string)) == "!")  					newNode.ToggleInversed ();  				filterNode = newNode;  			}  			break;  		case 3:  			DebugEnterAlt (3);  			// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  			{  				DebugLocation (105' 4);  				DebugLocation (105' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr216);  				Match (input' TokenTypes.Down' null);  				DebugLocation (105' 12);  				PushFollow (Follow._propertyChain_in_filterExpr219);  				propertyChain (propertySegments);  				PopFollow ();  				DebugLocation (105' 51);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  				int alt7 = 2;  				try {  					DebugEnterSubRule (7);  					try {  						DebugEnterDecision (7' false);  						int LA7_1 = input.LA (1);  						if ((LA7_1 == 31)) {  							alt7 = 1;  						}  					}  					finally {  						DebugExitDecision (7);  					}  					switch (alt7) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  						{  							DebugLocation (105' 51);  							inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (7);  				}  				DebugLocation (105' 60);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  				int alt8 = 2;  				try {  					DebugEnterSubRule (8);  					try {  						DebugEnterDecision (8' false);  						int LA8_1 = input.LA (1);  						if ((LA8_1 == 24)) {  							alt8 = 1;  						}  					}  					finally {  						DebugExitDecision (8);  					}  					switch (alt8) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  						{  							DebugLocation (105' 60);  							not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (8);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (106' 4);  				FilterTreeNode newProperty = new Property (propertySegments);  				if ((inverse != null ? inverse.Text : default(string)) == "?")  					filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  				else {  					if ((not != null ? not.Text : default(string)) == "!")  						newProperty.ToggleInversed ();  					filterNode = newProperty;  				}  			}  			break;  		case 4:  			DebugEnterAlt (4);  			// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  			{  				DebugLocation (116' 4);  				STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  				DebugLocation (117' 4);  				string stringText = (STRING7 != null ? STRING7.Text : default(string));  				stringText = stringText.Substring (1' stringText.Length - 2);  				filterNode = new Value (stringText);  			}  			break;  		case 5:  			DebugEnterAlt (5);  			// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  			{  				DebugLocation (122' 4);  				REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  				DebugLocation (123' 4);  				string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  				regexText = regexText.Substring (1' regexText.Length - 2);  				filterNode = new RegExp (regexText);  			}  			break;  		case 6:  			DebugEnterAlt (6);  			// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  			{  				DebugLocation (128' 4);  				NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  				DebugLocation (129' 4);  				filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  			}  			break;  		case 7:  			DebugEnterAlt (7);  			// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  			{  				DebugLocation (132' 4);  				Match (input' TRUE' Follow._TRUE_in_filterExpr271);  				DebugLocation (133' 4);  				filterNode = new Value (true);  			}  			break;  		case 8:  			DebugEnterAlt (8);  			// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  			{  				DebugLocation (136' 4);  				Match (input' FALSE' Follow._FALSE_in_filterExpr281);  				DebugLocation (137' 4);  				filterNode = new Value (false);  			}  			break;  		case 9:  			DebugEnterAlt (9);  			// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  			{  				DebugLocation (140' 4);  				Match (input' NULL' Follow._NULL_in_filterExpr291);  				DebugLocation (141' 4);  				filterNode = new Value (null);  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("filterExpr"' 6);  		LeaveRule ("filterExpr"' 6);  		LeaveRule_filterExpr ();  	}  	DebugLocation (144' 1);  }  finally {  	DebugExitRule (GrammarFileName' "filterExpr");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "filterExpr");  	DebugLocation (60' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  		int alt9 = 9;  		try {  			DebugEnterDecision (9' false);  			switch (input.LA (1)) {  			case CHAIN_OPERATOR:  			case COMPARATOR:  				{  					alt9 = 1;  				}  				break;  			case EXPR:  				{  					int LA9_2 = input.LA (2);  					if ((LA9_2 == DOWN)) {  						int LA9_3 = input.LA (3);  						if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  							alt9 = 2;  						}  						else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  							alt9 = 3;  						}  						else {  							NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  							DebugRecognitionException (nvae);  							throw nvae;  						}  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				break;  			case STRING:  				{  					alt9 = 4;  				}  				break;  			case REGEX:  				{  					alt9 = 5;  				}  				break;  			case NUMBER:  				{  					alt9 = 6;  				}  				break;  			case TRUE:  				{  					alt9 = 7;  				}  				break;  			case FALSE:  				{  					alt9 = 8;  				}  				break;  			case NULL:  				{  					alt9 = 9;  				}  				break;  			default: {  				NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  			}  		}  		finally {  			DebugExitDecision (9);  		}  		switch (alt9) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  			{  				DebugLocation (64' 4);  				DebugLocation (64' 6);  				PushFollow (Follow._comparator_in_filterExpr175);  				comparator6 = comparator ();  				PopFollow ();  				Match (input' TokenTypes.Down' null);  				DebugLocation (64' 18);  				PushFollow (Follow._filterExpr_in_filterExpr179);  				a = filterExpr ();  				PopFollow ();  				DebugLocation (64' 31);  				PushFollow (Follow._filterExpr_in_filterExpr183);  				b = filterExpr ();  				PopFollow ();  				Match (input' TokenTypes.Up' null);  				DebugLocation (65' 4);  				Comparator newComparator;  				switch (comparator6) {  				case "=":  					newComparator = Comparator.Equals;  					break;  				case "!=":  					newComparator = Comparator.NotEquals;  					break;  				case ">":  					newComparator = Comparator.Greater;  					break;  				case "<":  					newComparator = Comparator.Less;  					break;  				case ">=":  					newComparator = Comparator.GreaterOrEqual;  					break;  				case "<=":  					newComparator = Comparator.LessOrEqual;  					break;  				case "&":  					newComparator = Comparator.And;  					break;  				case "|":  					newComparator = Comparator.Or;  					break;  				default:  					newComparator = Comparator.Equals;  					break;  				}  				filterNode = new BoolExpression (a' newComparator' b);  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  			{  				DebugLocation (98' 4);  				DebugLocation (98' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr195);  				Match (input' TokenTypes.Down' null);  				DebugLocation (98' 12);  				PushFollow (Follow._filterExpr_in_filterExpr199);  				f = filterExpr ();  				PopFollow ();  				DebugLocation (98' 31);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  				int alt6 = 2;  				try {  					DebugEnterSubRule (6);  					try {  						DebugEnterDecision (6' false);  						int LA6_1 = input.LA (1);  						if ((LA6_1 == 24)) {  							alt6 = 1;  						}  					}  					finally {  						DebugExitDecision (6);  					}  					switch (alt6) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  						{  							DebugLocation (98' 31);  							inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (6);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (99' 4);  				FilterTreeNode newNode = f;  				if ((inverse != null ? inverse.Text : default(string)) == "!")  					newNode.ToggleInversed ();  				filterNode = newNode;  			}  			break;  		case 3:  			DebugEnterAlt (3);  			// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  			{  				DebugLocation (105' 4);  				DebugLocation (105' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr216);  				Match (input' TokenTypes.Down' null);  				DebugLocation (105' 12);  				PushFollow (Follow._propertyChain_in_filterExpr219);  				propertyChain (propertySegments);  				PopFollow ();  				DebugLocation (105' 51);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  				int alt7 = 2;  				try {  					DebugEnterSubRule (7);  					try {  						DebugEnterDecision (7' false);  						int LA7_1 = input.LA (1);  						if ((LA7_1 == 31)) {  							alt7 = 1;  						}  					}  					finally {  						DebugExitDecision (7);  					}  					switch (alt7) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  						{  							DebugLocation (105' 51);  							inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (7);  				}  				DebugLocation (105' 60);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  				int alt8 = 2;  				try {  					DebugEnterSubRule (8);  					try {  						DebugEnterDecision (8' false);  						int LA8_1 = input.LA (1);  						if ((LA8_1 == 24)) {  							alt8 = 1;  						}  					}  					finally {  						DebugExitDecision (8);  					}  					switch (alt8) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  						{  							DebugLocation (105' 60);  							not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (8);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (106' 4);  				FilterTreeNode newProperty = new Property (propertySegments);  				if ((inverse != null ? inverse.Text : default(string)) == "?")  					filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  				else {  					if ((not != null ? not.Text : default(string)) == "!")  						newProperty.ToggleInversed ();  					filterNode = newProperty;  				}  			}  			break;  		case 4:  			DebugEnterAlt (4);  			// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  			{  				DebugLocation (116' 4);  				STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  				DebugLocation (117' 4);  				string stringText = (STRING7 != null ? STRING7.Text : default(string));  				stringText = stringText.Substring (1' stringText.Length - 2);  				filterNode = new Value (stringText);  			}  			break;  		case 5:  			DebugEnterAlt (5);  			// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  			{  				DebugLocation (122' 4);  				REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  				DebugLocation (123' 4);  				string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  				regexText = regexText.Substring (1' regexText.Length - 2);  				filterNode = new RegExp (regexText);  			}  			break;  		case 6:  			DebugEnterAlt (6);  			// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  			{  				DebugLocation (128' 4);  				NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  				DebugLocation (129' 4);  				filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  			}  			break;  		case 7:  			DebugEnterAlt (7);  			// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  			{  				DebugLocation (132' 4);  				Match (input' TRUE' Follow._TRUE_in_filterExpr271);  				DebugLocation (133' 4);  				filterNode = new Value (true);  			}  			break;  		case 8:  			DebugEnterAlt (8);  			// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  			{  				DebugLocation (136' 4);  				Match (input' FALSE' Follow._FALSE_in_filterExpr281);  				DebugLocation (137' 4);  				filterNode = new Value (false);  			}  			break;  		case 9:  			DebugEnterAlt (9);  			// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  			{  				DebugLocation (140' 4);  				Match (input' NULL' Follow._NULL_in_filterExpr291);  				DebugLocation (141' 4);  				filterNode = new Value (null);  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("filterExpr"' 6);  		LeaveRule ("filterExpr"' 6);  		LeaveRule_filterExpr ();  	}  	DebugLocation (144' 1);  }  finally {  	DebugExitRule (GrammarFileName' "filterExpr");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "filterExpr");  	DebugLocation (60' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  		int alt9 = 9;  		try {  			DebugEnterDecision (9' false);  			switch (input.LA (1)) {  			case CHAIN_OPERATOR:  			case COMPARATOR:  				{  					alt9 = 1;  				}  				break;  			case EXPR:  				{  					int LA9_2 = input.LA (2);  					if ((LA9_2 == DOWN)) {  						int LA9_3 = input.LA (3);  						if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  							alt9 = 2;  						}  						else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  							alt9 = 3;  						}  						else {  							NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  							DebugRecognitionException (nvae);  							throw nvae;  						}  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				break;  			case STRING:  				{  					alt9 = 4;  				}  				break;  			case REGEX:  				{  					alt9 = 5;  				}  				break;  			case NUMBER:  				{  					alt9 = 6;  				}  				break;  			case TRUE:  				{  					alt9 = 7;  				}  				break;  			case FALSE:  				{  					alt9 = 8;  				}  				break;  			case NULL:  				{  					alt9 = 9;  				}  				break;  			default: {  				NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  			}  		}  		finally {  			DebugExitDecision (9);  		}  		switch (alt9) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  			{  				DebugLocation (64' 4);  				DebugLocation (64' 6);  				PushFollow (Follow._comparator_in_filterExpr175);  				comparator6 = comparator ();  				PopFollow ();  				Match (input' TokenTypes.Down' null);  				DebugLocation (64' 18);  				PushFollow (Follow._filterExpr_in_filterExpr179);  				a = filterExpr ();  				PopFollow ();  				DebugLocation (64' 31);  				PushFollow (Follow._filterExpr_in_filterExpr183);  				b = filterExpr ();  				PopFollow ();  				Match (input' TokenTypes.Up' null);  				DebugLocation (65' 4);  				Comparator newComparator;  				switch (comparator6) {  				case "=":  					newComparator = Comparator.Equals;  					break;  				case "!=":  					newComparator = Comparator.NotEquals;  					break;  				case ">":  					newComparator = Comparator.Greater;  					break;  				case "<":  					newComparator = Comparator.Less;  					break;  				case ">=":  					newComparator = Comparator.GreaterOrEqual;  					break;  				case "<=":  					newComparator = Comparator.LessOrEqual;  					break;  				case "&":  					newComparator = Comparator.And;  					break;  				case "|":  					newComparator = Comparator.Or;  					break;  				default:  					newComparator = Comparator.Equals;  					break;  				}  				filterNode = new BoolExpression (a' newComparator' b);  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  			{  				DebugLocation (98' 4);  				DebugLocation (98' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr195);  				Match (input' TokenTypes.Down' null);  				DebugLocation (98' 12);  				PushFollow (Follow._filterExpr_in_filterExpr199);  				f = filterExpr ();  				PopFollow ();  				DebugLocation (98' 31);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  				int alt6 = 2;  				try {  					DebugEnterSubRule (6);  					try {  						DebugEnterDecision (6' false);  						int LA6_1 = input.LA (1);  						if ((LA6_1 == 24)) {  							alt6 = 1;  						}  					}  					finally {  						DebugExitDecision (6);  					}  					switch (alt6) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  						{  							DebugLocation (98' 31);  							inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (6);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (99' 4);  				FilterTreeNode newNode = f;  				if ((inverse != null ? inverse.Text : default(string)) == "!")  					newNode.ToggleInversed ();  				filterNode = newNode;  			}  			break;  		case 3:  			DebugEnterAlt (3);  			// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  			{  				DebugLocation (105' 4);  				DebugLocation (105' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr216);  				Match (input' TokenTypes.Down' null);  				DebugLocation (105' 12);  				PushFollow (Follow._propertyChain_in_filterExpr219);  				propertyChain (propertySegments);  				PopFollow ();  				DebugLocation (105' 51);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  				int alt7 = 2;  				try {  					DebugEnterSubRule (7);  					try {  						DebugEnterDecision (7' false);  						int LA7_1 = input.LA (1);  						if ((LA7_1 == 31)) {  							alt7 = 1;  						}  					}  					finally {  						DebugExitDecision (7);  					}  					switch (alt7) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  						{  							DebugLocation (105' 51);  							inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (7);  				}  				DebugLocation (105' 60);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  				int alt8 = 2;  				try {  					DebugEnterSubRule (8);  					try {  						DebugEnterDecision (8' false);  						int LA8_1 = input.LA (1);  						if ((LA8_1 == 24)) {  							alt8 = 1;  						}  					}  					finally {  						DebugExitDecision (8);  					}  					switch (alt8) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  						{  							DebugLocation (105' 60);  							not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (8);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (106' 4);  				FilterTreeNode newProperty = new Property (propertySegments);  				if ((inverse != null ? inverse.Text : default(string)) == "?")  					filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  				else {  					if ((not != null ? not.Text : default(string)) == "!")  						newProperty.ToggleInversed ();  					filterNode = newProperty;  				}  			}  			break;  		case 4:  			DebugEnterAlt (4);  			// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  			{  				DebugLocation (116' 4);  				STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  				DebugLocation (117' 4);  				string stringText = (STRING7 != null ? STRING7.Text : default(string));  				stringText = stringText.Substring (1' stringText.Length - 2);  				filterNode = new Value (stringText);  			}  			break;  		case 5:  			DebugEnterAlt (5);  			// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  			{  				DebugLocation (122' 4);  				REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  				DebugLocation (123' 4);  				string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  				regexText = regexText.Substring (1' regexText.Length - 2);  				filterNode = new RegExp (regexText);  			}  			break;  		case 6:  			DebugEnterAlt (6);  			// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  			{  				DebugLocation (128' 4);  				NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  				DebugLocation (129' 4);  				filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  			}  			break;  		case 7:  			DebugEnterAlt (7);  			// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  			{  				DebugLocation (132' 4);  				Match (input' TRUE' Follow._TRUE_in_filterExpr271);  				DebugLocation (133' 4);  				filterNode = new Value (true);  			}  			break;  		case 8:  			DebugEnterAlt (8);  			// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  			{  				DebugLocation (136' 4);  				Match (input' FALSE' Follow._FALSE_in_filterExpr281);  				DebugLocation (137' 4);  				filterNode = new Value (false);  			}  			break;  		case 9:  			DebugEnterAlt (9);  			// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  			{  				DebugLocation (140' 4);  				Match (input' NULL' Follow._NULL_in_filterExpr291);  				DebugLocation (141' 4);  				filterNode = new Value (null);  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("filterExpr"' 6);  		LeaveRule ("filterExpr"' 6);  		LeaveRule_filterExpr ();  	}  	DebugLocation (144' 1);  }  finally {  	DebugExitRule (GrammarFileName' "filterExpr");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "filterExpr");  	DebugLocation (60' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  		int alt9 = 9;  		try {  			DebugEnterDecision (9' false);  			switch (input.LA (1)) {  			case CHAIN_OPERATOR:  			case COMPARATOR:  				{  					alt9 = 1;  				}  				break;  			case EXPR:  				{  					int LA9_2 = input.LA (2);  					if ((LA9_2 == DOWN)) {  						int LA9_3 = input.LA (3);  						if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  							alt9 = 2;  						}  						else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  							alt9 = 3;  						}  						else {  							NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  							DebugRecognitionException (nvae);  							throw nvae;  						}  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				break;  			case STRING:  				{  					alt9 = 4;  				}  				break;  			case REGEX:  				{  					alt9 = 5;  				}  				break;  			case NUMBER:  				{  					alt9 = 6;  				}  				break;  			case TRUE:  				{  					alt9 = 7;  				}  				break;  			case FALSE:  				{  					alt9 = 8;  				}  				break;  			case NULL:  				{  					alt9 = 9;  				}  				break;  			default: {  				NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  			}  		}  		finally {  			DebugExitDecision (9);  		}  		switch (alt9) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  			{  				DebugLocation (64' 4);  				DebugLocation (64' 6);  				PushFollow (Follow._comparator_in_filterExpr175);  				comparator6 = comparator ();  				PopFollow ();  				Match (input' TokenTypes.Down' null);  				DebugLocation (64' 18);  				PushFollow (Follow._filterExpr_in_filterExpr179);  				a = filterExpr ();  				PopFollow ();  				DebugLocation (64' 31);  				PushFollow (Follow._filterExpr_in_filterExpr183);  				b = filterExpr ();  				PopFollow ();  				Match (input' TokenTypes.Up' null);  				DebugLocation (65' 4);  				Comparator newComparator;  				switch (comparator6) {  				case "=":  					newComparator = Comparator.Equals;  					break;  				case "!=":  					newComparator = Comparator.NotEquals;  					break;  				case ">":  					newComparator = Comparator.Greater;  					break;  				case "<":  					newComparator = Comparator.Less;  					break;  				case ">=":  					newComparator = Comparator.GreaterOrEqual;  					break;  				case "<=":  					newComparator = Comparator.LessOrEqual;  					break;  				case "&":  					newComparator = Comparator.And;  					break;  				case "|":  					newComparator = Comparator.Or;  					break;  				default:  					newComparator = Comparator.Equals;  					break;  				}  				filterNode = new BoolExpression (a' newComparator' b);  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  			{  				DebugLocation (98' 4);  				DebugLocation (98' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr195);  				Match (input' TokenTypes.Down' null);  				DebugLocation (98' 12);  				PushFollow (Follow._filterExpr_in_filterExpr199);  				f = filterExpr ();  				PopFollow ();  				DebugLocation (98' 31);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  				int alt6 = 2;  				try {  					DebugEnterSubRule (6);  					try {  						DebugEnterDecision (6' false);  						int LA6_1 = input.LA (1);  						if ((LA6_1 == 24)) {  							alt6 = 1;  						}  					}  					finally {  						DebugExitDecision (6);  					}  					switch (alt6) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  						{  							DebugLocation (98' 31);  							inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (6);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (99' 4);  				FilterTreeNode newNode = f;  				if ((inverse != null ? inverse.Text : default(string)) == "!")  					newNode.ToggleInversed ();  				filterNode = newNode;  			}  			break;  		case 3:  			DebugEnterAlt (3);  			// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  			{  				DebugLocation (105' 4);  				DebugLocation (105' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr216);  				Match (input' TokenTypes.Down' null);  				DebugLocation (105' 12);  				PushFollow (Follow._propertyChain_in_filterExpr219);  				propertyChain (propertySegments);  				PopFollow ();  				DebugLocation (105' 51);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  				int alt7 = 2;  				try {  					DebugEnterSubRule (7);  					try {  						DebugEnterDecision (7' false);  						int LA7_1 = input.LA (1);  						if ((LA7_1 == 31)) {  							alt7 = 1;  						}  					}  					finally {  						DebugExitDecision (7);  					}  					switch (alt7) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  						{  							DebugLocation (105' 51);  							inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (7);  				}  				DebugLocation (105' 60);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  				int alt8 = 2;  				try {  					DebugEnterSubRule (8);  					try {  						DebugEnterDecision (8' false);  						int LA8_1 = input.LA (1);  						if ((LA8_1 == 24)) {  							alt8 = 1;  						}  					}  					finally {  						DebugExitDecision (8);  					}  					switch (alt8) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  						{  							DebugLocation (105' 60);  							not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (8);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (106' 4);  				FilterTreeNode newProperty = new Property (propertySegments);  				if ((inverse != null ? inverse.Text : default(string)) == "?")  					filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  				else {  					if ((not != null ? not.Text : default(string)) == "!")  						newProperty.ToggleInversed ();  					filterNode = newProperty;  				}  			}  			break;  		case 4:  			DebugEnterAlt (4);  			// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  			{  				DebugLocation (116' 4);  				STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  				DebugLocation (117' 4);  				string stringText = (STRING7 != null ? STRING7.Text : default(string));  				stringText = stringText.Substring (1' stringText.Length - 2);  				filterNode = new Value (stringText);  			}  			break;  		case 5:  			DebugEnterAlt (5);  			// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  			{  				DebugLocation (122' 4);  				REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  				DebugLocation (123' 4);  				string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  				regexText = regexText.Substring (1' regexText.Length - 2);  				filterNode = new RegExp (regexText);  			}  			break;  		case 6:  			DebugEnterAlt (6);  			// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  			{  				DebugLocation (128' 4);  				NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  				DebugLocation (129' 4);  				filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  			}  			break;  		case 7:  			DebugEnterAlt (7);  			// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  			{  				DebugLocation (132' 4);  				Match (input' TRUE' Follow._TRUE_in_filterExpr271);  				DebugLocation (133' 4);  				filterNode = new Value (true);  			}  			break;  		case 8:  			DebugEnterAlt (8);  			// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  			{  				DebugLocation (136' 4);  				Match (input' FALSE' Follow._FALSE_in_filterExpr281);  				DebugLocation (137' 4);  				filterNode = new Value (false);  			}  			break;  		case 9:  			DebugEnterAlt (9);  			// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  			{  				DebugLocation (140' 4);  				Match (input' NULL' Follow._NULL_in_filterExpr291);  				DebugLocation (141' 4);  				filterNode = new Value (null);  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("filterExpr"' 6);  		LeaveRule ("filterExpr"' 6);  		LeaveRule_filterExpr ();  	}  	DebugLocation (144' 1);  }  finally {  	DebugExitRule (GrammarFileName' "filterExpr");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "filterExpr");  	DebugLocation (60' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  		int alt9 = 9;  		try {  			DebugEnterDecision (9' false);  			switch (input.LA (1)) {  			case CHAIN_OPERATOR:  			case COMPARATOR:  				{  					alt9 = 1;  				}  				break;  			case EXPR:  				{  					int LA9_2 = input.LA (2);  					if ((LA9_2 == DOWN)) {  						int LA9_3 = input.LA (3);  						if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  							alt9 = 2;  						}  						else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  							alt9 = 3;  						}  						else {  							NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  							DebugRecognitionException (nvae);  							throw nvae;  						}  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				break;  			case STRING:  				{  					alt9 = 4;  				}  				break;  			case REGEX:  				{  					alt9 = 5;  				}  				break;  			case NUMBER:  				{  					alt9 = 6;  				}  				break;  			case TRUE:  				{  					alt9 = 7;  				}  				break;  			case FALSE:  				{  					alt9 = 8;  				}  				break;  			case NULL:  				{  					alt9 = 9;  				}  				break;  			default: {  				NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  			}  		}  		finally {  			DebugExitDecision (9);  		}  		switch (alt9) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  			{  				DebugLocation (64' 4);  				DebugLocation (64' 6);  				PushFollow (Follow._comparator_in_filterExpr175);  				comparator6 = comparator ();  				PopFollow ();  				Match (input' TokenTypes.Down' null);  				DebugLocation (64' 18);  				PushFollow (Follow._filterExpr_in_filterExpr179);  				a = filterExpr ();  				PopFollow ();  				DebugLocation (64' 31);  				PushFollow (Follow._filterExpr_in_filterExpr183);  				b = filterExpr ();  				PopFollow ();  				Match (input' TokenTypes.Up' null);  				DebugLocation (65' 4);  				Comparator newComparator;  				switch (comparator6) {  				case "=":  					newComparator = Comparator.Equals;  					break;  				case "!=":  					newComparator = Comparator.NotEquals;  					break;  				case ">":  					newComparator = Comparator.Greater;  					break;  				case "<":  					newComparator = Comparator.Less;  					break;  				case ">=":  					newComparator = Comparator.GreaterOrEqual;  					break;  				case "<=":  					newComparator = Comparator.LessOrEqual;  					break;  				case "&":  					newComparator = Comparator.And;  					break;  				case "|":  					newComparator = Comparator.Or;  					break;  				default:  					newComparator = Comparator.Equals;  					break;  				}  				filterNode = new BoolExpression (a' newComparator' b);  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  			{  				DebugLocation (98' 4);  				DebugLocation (98' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr195);  				Match (input' TokenTypes.Down' null);  				DebugLocation (98' 12);  				PushFollow (Follow._filterExpr_in_filterExpr199);  				f = filterExpr ();  				PopFollow ();  				DebugLocation (98' 31);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  				int alt6 = 2;  				try {  					DebugEnterSubRule (6);  					try {  						DebugEnterDecision (6' false);  						int LA6_1 = input.LA (1);  						if ((LA6_1 == 24)) {  							alt6 = 1;  						}  					}  					finally {  						DebugExitDecision (6);  					}  					switch (alt6) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  						{  							DebugLocation (98' 31);  							inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (6);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (99' 4);  				FilterTreeNode newNode = f;  				if ((inverse != null ? inverse.Text : default(string)) == "!")  					newNode.ToggleInversed ();  				filterNode = newNode;  			}  			break;  		case 3:  			DebugEnterAlt (3);  			// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  			{  				DebugLocation (105' 4);  				DebugLocation (105' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr216);  				Match (input' TokenTypes.Down' null);  				DebugLocation (105' 12);  				PushFollow (Follow._propertyChain_in_filterExpr219);  				propertyChain (propertySegments);  				PopFollow ();  				DebugLocation (105' 51);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  				int alt7 = 2;  				try {  					DebugEnterSubRule (7);  					try {  						DebugEnterDecision (7' false);  						int LA7_1 = input.LA (1);  						if ((LA7_1 == 31)) {  							alt7 = 1;  						}  					}  					finally {  						DebugExitDecision (7);  					}  					switch (alt7) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  						{  							DebugLocation (105' 51);  							inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (7);  				}  				DebugLocation (105' 60);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  				int alt8 = 2;  				try {  					DebugEnterSubRule (8);  					try {  						DebugEnterDecision (8' false);  						int LA8_1 = input.LA (1);  						if ((LA8_1 == 24)) {  							alt8 = 1;  						}  					}  					finally {  						DebugExitDecision (8);  					}  					switch (alt8) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  						{  							DebugLocation (105' 60);  							not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (8);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (106' 4);  				FilterTreeNode newProperty = new Property (propertySegments);  				if ((inverse != null ? inverse.Text : default(string)) == "?")  					filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  				else {  					if ((not != null ? not.Text : default(string)) == "!")  						newProperty.ToggleInversed ();  					filterNode = newProperty;  				}  			}  			break;  		case 4:  			DebugEnterAlt (4);  			// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  			{  				DebugLocation (116' 4);  				STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  				DebugLocation (117' 4);  				string stringText = (STRING7 != null ? STRING7.Text : default(string));  				stringText = stringText.Substring (1' stringText.Length - 2);  				filterNode = new Value (stringText);  			}  			break;  		case 5:  			DebugEnterAlt (5);  			// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  			{  				DebugLocation (122' 4);  				REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  				DebugLocation (123' 4);  				string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  				regexText = regexText.Substring (1' regexText.Length - 2);  				filterNode = new RegExp (regexText);  			}  			break;  		case 6:  			DebugEnterAlt (6);  			// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  			{  				DebugLocation (128' 4);  				NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  				DebugLocation (129' 4);  				filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  			}  			break;  		case 7:  			DebugEnterAlt (7);  			// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  			{  				DebugLocation (132' 4);  				Match (input' TRUE' Follow._TRUE_in_filterExpr271);  				DebugLocation (133' 4);  				filterNode = new Value (true);  			}  			break;  		case 8:  			DebugEnterAlt (8);  			// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  			{  				DebugLocation (136' 4);  				Match (input' FALSE' Follow._FALSE_in_filterExpr281);  				DebugLocation (137' 4);  				filterNode = new Value (false);  			}  			break;  		case 9:  			DebugEnterAlt (9);  			// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  			{  				DebugLocation (140' 4);  				Match (input' NULL' Follow._NULL_in_filterExpr291);  				DebugLocation (141' 4);  				filterNode = new Value (null);  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("filterExpr"' 6);  		LeaveRule ("filterExpr"' 6);  		LeaveRule_filterExpr ();  	}  	DebugLocation (144' 1);  }  finally {  	DebugExitRule (GrammarFileName' "filterExpr");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "filterExpr");  	DebugLocation (60' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  		int alt9 = 9;  		try {  			DebugEnterDecision (9' false);  			switch (input.LA (1)) {  			case CHAIN_OPERATOR:  			case COMPARATOR:  				{  					alt9 = 1;  				}  				break;  			case EXPR:  				{  					int LA9_2 = input.LA (2);  					if ((LA9_2 == DOWN)) {  						int LA9_3 = input.LA (3);  						if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  							alt9 = 2;  						}  						else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  							alt9 = 3;  						}  						else {  							NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  							DebugRecognitionException (nvae);  							throw nvae;  						}  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				break;  			case STRING:  				{  					alt9 = 4;  				}  				break;  			case REGEX:  				{  					alt9 = 5;  				}  				break;  			case NUMBER:  				{  					alt9 = 6;  				}  				break;  			case TRUE:  				{  					alt9 = 7;  				}  				break;  			case FALSE:  				{  					alt9 = 8;  				}  				break;  			case NULL:  				{  					alt9 = 9;  				}  				break;  			default: {  				NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  			}  		}  		finally {  			DebugExitDecision (9);  		}  		switch (alt9) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  			{  				DebugLocation (64' 4);  				DebugLocation (64' 6);  				PushFollow (Follow._comparator_in_filterExpr175);  				comparator6 = comparator ();  				PopFollow ();  				Match (input' TokenTypes.Down' null);  				DebugLocation (64' 18);  				PushFollow (Follow._filterExpr_in_filterExpr179);  				a = filterExpr ();  				PopFollow ();  				DebugLocation (64' 31);  				PushFollow (Follow._filterExpr_in_filterExpr183);  				b = filterExpr ();  				PopFollow ();  				Match (input' TokenTypes.Up' null);  				DebugLocation (65' 4);  				Comparator newComparator;  				switch (comparator6) {  				case "=":  					newComparator = Comparator.Equals;  					break;  				case "!=":  					newComparator = Comparator.NotEquals;  					break;  				case ">":  					newComparator = Comparator.Greater;  					break;  				case "<":  					newComparator = Comparator.Less;  					break;  				case ">=":  					newComparator = Comparator.GreaterOrEqual;  					break;  				case "<=":  					newComparator = Comparator.LessOrEqual;  					break;  				case "&":  					newComparator = Comparator.And;  					break;  				case "|":  					newComparator = Comparator.Or;  					break;  				default:  					newComparator = Comparator.Equals;  					break;  				}  				filterNode = new BoolExpression (a' newComparator' b);  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  			{  				DebugLocation (98' 4);  				DebugLocation (98' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr195);  				Match (input' TokenTypes.Down' null);  				DebugLocation (98' 12);  				PushFollow (Follow._filterExpr_in_filterExpr199);  				f = filterExpr ();  				PopFollow ();  				DebugLocation (98' 31);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  				int alt6 = 2;  				try {  					DebugEnterSubRule (6);  					try {  						DebugEnterDecision (6' false);  						int LA6_1 = input.LA (1);  						if ((LA6_1 == 24)) {  							alt6 = 1;  						}  					}  					finally {  						DebugExitDecision (6);  					}  					switch (alt6) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  						{  							DebugLocation (98' 31);  							inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (6);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (99' 4);  				FilterTreeNode newNode = f;  				if ((inverse != null ? inverse.Text : default(string)) == "!")  					newNode.ToggleInversed ();  				filterNode = newNode;  			}  			break;  		case 3:  			DebugEnterAlt (3);  			// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  			{  				DebugLocation (105' 4);  				DebugLocation (105' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr216);  				Match (input' TokenTypes.Down' null);  				DebugLocation (105' 12);  				PushFollow (Follow._propertyChain_in_filterExpr219);  				propertyChain (propertySegments);  				PopFollow ();  				DebugLocation (105' 51);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  				int alt7 = 2;  				try {  					DebugEnterSubRule (7);  					try {  						DebugEnterDecision (7' false);  						int LA7_1 = input.LA (1);  						if ((LA7_1 == 31)) {  							alt7 = 1;  						}  					}  					finally {  						DebugExitDecision (7);  					}  					switch (alt7) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  						{  							DebugLocation (105' 51);  							inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (7);  				}  				DebugLocation (105' 60);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  				int alt8 = 2;  				try {  					DebugEnterSubRule (8);  					try {  						DebugEnterDecision (8' false);  						int LA8_1 = input.LA (1);  						if ((LA8_1 == 24)) {  							alt8 = 1;  						}  					}  					finally {  						DebugExitDecision (8);  					}  					switch (alt8) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  						{  							DebugLocation (105' 60);  							not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (8);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (106' 4);  				FilterTreeNode newProperty = new Property (propertySegments);  				if ((inverse != null ? inverse.Text : default(string)) == "?")  					filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  				else {  					if ((not != null ? not.Text : default(string)) == "!")  						newProperty.ToggleInversed ();  					filterNode = newProperty;  				}  			}  			break;  		case 4:  			DebugEnterAlt (4);  			// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  			{  				DebugLocation (116' 4);  				STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  				DebugLocation (117' 4);  				string stringText = (STRING7 != null ? STRING7.Text : default(string));  				stringText = stringText.Substring (1' stringText.Length - 2);  				filterNode = new Value (stringText);  			}  			break;  		case 5:  			DebugEnterAlt (5);  			// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  			{  				DebugLocation (122' 4);  				REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  				DebugLocation (123' 4);  				string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  				regexText = regexText.Substring (1' regexText.Length - 2);  				filterNode = new RegExp (regexText);  			}  			break;  		case 6:  			DebugEnterAlt (6);  			// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  			{  				DebugLocation (128' 4);  				NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  				DebugLocation (129' 4);  				filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  			}  			break;  		case 7:  			DebugEnterAlt (7);  			// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  			{  				DebugLocation (132' 4);  				Match (input' TRUE' Follow._TRUE_in_filterExpr271);  				DebugLocation (133' 4);  				filterNode = new Value (true);  			}  			break;  		case 8:  			DebugEnterAlt (8);  			// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  			{  				DebugLocation (136' 4);  				Match (input' FALSE' Follow._FALSE_in_filterExpr281);  				DebugLocation (137' 4);  				filterNode = new Value (false);  			}  			break;  		case 9:  			DebugEnterAlt (9);  			// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  			{  				DebugLocation (140' 4);  				Match (input' NULL' Follow._NULL_in_filterExpr291);  				DebugLocation (141' 4);  				filterNode = new Value (null);  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("filterExpr"' 6);  		LeaveRule ("filterExpr"' 6);  		LeaveRule_filterExpr ();  	}  	DebugLocation (144' 1);  }  finally {  	DebugExitRule (GrammarFileName' "filterExpr");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "filterExpr");  	DebugLocation (60' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  		int alt9 = 9;  		try {  			DebugEnterDecision (9' false);  			switch (input.LA (1)) {  			case CHAIN_OPERATOR:  			case COMPARATOR:  				{  					alt9 = 1;  				}  				break;  			case EXPR:  				{  					int LA9_2 = input.LA (2);  					if ((LA9_2 == DOWN)) {  						int LA9_3 = input.LA (3);  						if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  							alt9 = 2;  						}  						else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  							alt9 = 3;  						}  						else {  							NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  							DebugRecognitionException (nvae);  							throw nvae;  						}  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				break;  			case STRING:  				{  					alt9 = 4;  				}  				break;  			case REGEX:  				{  					alt9 = 5;  				}  				break;  			case NUMBER:  				{  					alt9 = 6;  				}  				break;  			case TRUE:  				{  					alt9 = 7;  				}  				break;  			case FALSE:  				{  					alt9 = 8;  				}  				break;  			case NULL:  				{  					alt9 = 9;  				}  				break;  			default: {  				NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  			}  		}  		finally {  			DebugExitDecision (9);  		}  		switch (alt9) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  			{  				DebugLocation (64' 4);  				DebugLocation (64' 6);  				PushFollow (Follow._comparator_in_filterExpr175);  				comparator6 = comparator ();  				PopFollow ();  				Match (input' TokenTypes.Down' null);  				DebugLocation (64' 18);  				PushFollow (Follow._filterExpr_in_filterExpr179);  				a = filterExpr ();  				PopFollow ();  				DebugLocation (64' 31);  				PushFollow (Follow._filterExpr_in_filterExpr183);  				b = filterExpr ();  				PopFollow ();  				Match (input' TokenTypes.Up' null);  				DebugLocation (65' 4);  				Comparator newComparator;  				switch (comparator6) {  				case "=":  					newComparator = Comparator.Equals;  					break;  				case "!=":  					newComparator = Comparator.NotEquals;  					break;  				case ">":  					newComparator = Comparator.Greater;  					break;  				case "<":  					newComparator = Comparator.Less;  					break;  				case ">=":  					newComparator = Comparator.GreaterOrEqual;  					break;  				case "<=":  					newComparator = Comparator.LessOrEqual;  					break;  				case "&":  					newComparator = Comparator.And;  					break;  				case "|":  					newComparator = Comparator.Or;  					break;  				default:  					newComparator = Comparator.Equals;  					break;  				}  				filterNode = new BoolExpression (a' newComparator' b);  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  			{  				DebugLocation (98' 4);  				DebugLocation (98' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr195);  				Match (input' TokenTypes.Down' null);  				DebugLocation (98' 12);  				PushFollow (Follow._filterExpr_in_filterExpr199);  				f = filterExpr ();  				PopFollow ();  				DebugLocation (98' 31);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  				int alt6 = 2;  				try {  					DebugEnterSubRule (6);  					try {  						DebugEnterDecision (6' false);  						int LA6_1 = input.LA (1);  						if ((LA6_1 == 24)) {  							alt6 = 1;  						}  					}  					finally {  						DebugExitDecision (6);  					}  					switch (alt6) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  						{  							DebugLocation (98' 31);  							inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (6);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (99' 4);  				FilterTreeNode newNode = f;  				if ((inverse != null ? inverse.Text : default(string)) == "!")  					newNode.ToggleInversed ();  				filterNode = newNode;  			}  			break;  		case 3:  			DebugEnterAlt (3);  			// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  			{  				DebugLocation (105' 4);  				DebugLocation (105' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr216);  				Match (input' TokenTypes.Down' null);  				DebugLocation (105' 12);  				PushFollow (Follow._propertyChain_in_filterExpr219);  				propertyChain (propertySegments);  				PopFollow ();  				DebugLocation (105' 51);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  				int alt7 = 2;  				try {  					DebugEnterSubRule (7);  					try {  						DebugEnterDecision (7' false);  						int LA7_1 = input.LA (1);  						if ((LA7_1 == 31)) {  							alt7 = 1;  						}  					}  					finally {  						DebugExitDecision (7);  					}  					switch (alt7) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  						{  							DebugLocation (105' 51);  							inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (7);  				}  				DebugLocation (105' 60);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  				int alt8 = 2;  				try {  					DebugEnterSubRule (8);  					try {  						DebugEnterDecision (8' false);  						int LA8_1 = input.LA (1);  						if ((LA8_1 == 24)) {  							alt8 = 1;  						}  					}  					finally {  						DebugExitDecision (8);  					}  					switch (alt8) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  						{  							DebugLocation (105' 60);  							not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (8);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (106' 4);  				FilterTreeNode newProperty = new Property (propertySegments);  				if ((inverse != null ? inverse.Text : default(string)) == "?")  					filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  				else {  					if ((not != null ? not.Text : default(string)) == "!")  						newProperty.ToggleInversed ();  					filterNode = newProperty;  				}  			}  			break;  		case 4:  			DebugEnterAlt (4);  			// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  			{  				DebugLocation (116' 4);  				STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  				DebugLocation (117' 4);  				string stringText = (STRING7 != null ? STRING7.Text : default(string));  				stringText = stringText.Substring (1' stringText.Length - 2);  				filterNode = new Value (stringText);  			}  			break;  		case 5:  			DebugEnterAlt (5);  			// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  			{  				DebugLocation (122' 4);  				REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  				DebugLocation (123' 4);  				string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  				regexText = regexText.Substring (1' regexText.Length - 2);  				filterNode = new RegExp (regexText);  			}  			break;  		case 6:  			DebugEnterAlt (6);  			// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  			{  				DebugLocation (128' 4);  				NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  				DebugLocation (129' 4);  				filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  			}  			break;  		case 7:  			DebugEnterAlt (7);  			// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  			{  				DebugLocation (132' 4);  				Match (input' TRUE' Follow._TRUE_in_filterExpr271);  				DebugLocation (133' 4);  				filterNode = new Value (true);  			}  			break;  		case 8:  			DebugEnterAlt (8);  			// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  			{  				DebugLocation (136' 4);  				Match (input' FALSE' Follow._FALSE_in_filterExpr281);  				DebugLocation (137' 4);  				filterNode = new Value (false);  			}  			break;  		case 9:  			DebugEnterAlt (9);  			// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  			{  				DebugLocation (140' 4);  				Match (input' NULL' Follow._NULL_in_filterExpr291);  				DebugLocation (141' 4);  				filterNode = new Value (null);  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("filterExpr"' 6);  		LeaveRule ("filterExpr"' 6);  		LeaveRule_filterExpr ();  	}  	DebugLocation (144' 1);  }  finally {  	DebugExitRule (GrammarFileName' "filterExpr");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "filterExpr");  	DebugLocation (60' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  		int alt9 = 9;  		try {  			DebugEnterDecision (9' false);  			switch (input.LA (1)) {  			case CHAIN_OPERATOR:  			case COMPARATOR:  				{  					alt9 = 1;  				}  				break;  			case EXPR:  				{  					int LA9_2 = input.LA (2);  					if ((LA9_2 == DOWN)) {  						int LA9_3 = input.LA (3);  						if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  							alt9 = 2;  						}  						else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  							alt9 = 3;  						}  						else {  							NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  							DebugRecognitionException (nvae);  							throw nvae;  						}  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				break;  			case STRING:  				{  					alt9 = 4;  				}  				break;  			case REGEX:  				{  					alt9 = 5;  				}  				break;  			case NUMBER:  				{  					alt9 = 6;  				}  				break;  			case TRUE:  				{  					alt9 = 7;  				}  				break;  			case FALSE:  				{  					alt9 = 8;  				}  				break;  			case NULL:  				{  					alt9 = 9;  				}  				break;  			default: {  				NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  			}  		}  		finally {  			DebugExitDecision (9);  		}  		switch (alt9) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  			{  				DebugLocation (64' 4);  				DebugLocation (64' 6);  				PushFollow (Follow._comparator_in_filterExpr175);  				comparator6 = comparator ();  				PopFollow ();  				Match (input' TokenTypes.Down' null);  				DebugLocation (64' 18);  				PushFollow (Follow._filterExpr_in_filterExpr179);  				a = filterExpr ();  				PopFollow ();  				DebugLocation (64' 31);  				PushFollow (Follow._filterExpr_in_filterExpr183);  				b = filterExpr ();  				PopFollow ();  				Match (input' TokenTypes.Up' null);  				DebugLocation (65' 4);  				Comparator newComparator;  				switch (comparator6) {  				case "=":  					newComparator = Comparator.Equals;  					break;  				case "!=":  					newComparator = Comparator.NotEquals;  					break;  				case ">":  					newComparator = Comparator.Greater;  					break;  				case "<":  					newComparator = Comparator.Less;  					break;  				case ">=":  					newComparator = Comparator.GreaterOrEqual;  					break;  				case "<=":  					newComparator = Comparator.LessOrEqual;  					break;  				case "&":  					newComparator = Comparator.And;  					break;  				case "|":  					newComparator = Comparator.Or;  					break;  				default:  					newComparator = Comparator.Equals;  					break;  				}  				filterNode = new BoolExpression (a' newComparator' b);  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  			{  				DebugLocation (98' 4);  				DebugLocation (98' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr195);  				Match (input' TokenTypes.Down' null);  				DebugLocation (98' 12);  				PushFollow (Follow._filterExpr_in_filterExpr199);  				f = filterExpr ();  				PopFollow ();  				DebugLocation (98' 31);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  				int alt6 = 2;  				try {  					DebugEnterSubRule (6);  					try {  						DebugEnterDecision (6' false);  						int LA6_1 = input.LA (1);  						if ((LA6_1 == 24)) {  							alt6 = 1;  						}  					}  					finally {  						DebugExitDecision (6);  					}  					switch (alt6) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  						{  							DebugLocation (98' 31);  							inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (6);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (99' 4);  				FilterTreeNode newNode = f;  				if ((inverse != null ? inverse.Text : default(string)) == "!")  					newNode.ToggleInversed ();  				filterNode = newNode;  			}  			break;  		case 3:  			DebugEnterAlt (3);  			// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  			{  				DebugLocation (105' 4);  				DebugLocation (105' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr216);  				Match (input' TokenTypes.Down' null);  				DebugLocation (105' 12);  				PushFollow (Follow._propertyChain_in_filterExpr219);  				propertyChain (propertySegments);  				PopFollow ();  				DebugLocation (105' 51);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  				int alt7 = 2;  				try {  					DebugEnterSubRule (7);  					try {  						DebugEnterDecision (7' false);  						int LA7_1 = input.LA (1);  						if ((LA7_1 == 31)) {  							alt7 = 1;  						}  					}  					finally {  						DebugExitDecision (7);  					}  					switch (alt7) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  						{  							DebugLocation (105' 51);  							inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (7);  				}  				DebugLocation (105' 60);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  				int alt8 = 2;  				try {  					DebugEnterSubRule (8);  					try {  						DebugEnterDecision (8' false);  						int LA8_1 = input.LA (1);  						if ((LA8_1 == 24)) {  							alt8 = 1;  						}  					}  					finally {  						DebugExitDecision (8);  					}  					switch (alt8) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  						{  							DebugLocation (105' 60);  							not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (8);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (106' 4);  				FilterTreeNode newProperty = new Property (propertySegments);  				if ((inverse != null ? inverse.Text : default(string)) == "?")  					filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  				else {  					if ((not != null ? not.Text : default(string)) == "!")  						newProperty.ToggleInversed ();  					filterNode = newProperty;  				}  			}  			break;  		case 4:  			DebugEnterAlt (4);  			// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  			{  				DebugLocation (116' 4);  				STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  				DebugLocation (117' 4);  				string stringText = (STRING7 != null ? STRING7.Text : default(string));  				stringText = stringText.Substring (1' stringText.Length - 2);  				filterNode = new Value (stringText);  			}  			break;  		case 5:  			DebugEnterAlt (5);  			// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  			{  				DebugLocation (122' 4);  				REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  				DebugLocation (123' 4);  				string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  				regexText = regexText.Substring (1' regexText.Length - 2);  				filterNode = new RegExp (regexText);  			}  			break;  		case 6:  			DebugEnterAlt (6);  			// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  			{  				DebugLocation (128' 4);  				NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  				DebugLocation (129' 4);  				filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  			}  			break;  		case 7:  			DebugEnterAlt (7);  			// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  			{  				DebugLocation (132' 4);  				Match (input' TRUE' Follow._TRUE_in_filterExpr271);  				DebugLocation (133' 4);  				filterNode = new Value (true);  			}  			break;  		case 8:  			DebugEnterAlt (8);  			// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  			{  				DebugLocation (136' 4);  				Match (input' FALSE' Follow._FALSE_in_filterExpr281);  				DebugLocation (137' 4);  				filterNode = new Value (false);  			}  			break;  		case 9:  			DebugEnterAlt (9);  			// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  			{  				DebugLocation (140' 4);  				Match (input' NULL' Follow._NULL_in_filterExpr291);  				DebugLocation (141' 4);  				filterNode = new Value (null);  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("filterExpr"' 6);  		LeaveRule ("filterExpr"' 6);  		LeaveRule_filterExpr ();  	}  	DebugLocation (144' 1);  }  finally {  	DebugExitRule (GrammarFileName' "filterExpr");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "filterExpr");  	DebugLocation (60' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  		int alt9 = 9;  		try {  			DebugEnterDecision (9' false);  			switch (input.LA (1)) {  			case CHAIN_OPERATOR:  			case COMPARATOR:  				{  					alt9 = 1;  				}  				break;  			case EXPR:  				{  					int LA9_2 = input.LA (2);  					if ((LA9_2 == DOWN)) {  						int LA9_3 = input.LA (3);  						if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  							alt9 = 2;  						}  						else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  							alt9 = 3;  						}  						else {  							NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  							DebugRecognitionException (nvae);  							throw nvae;  						}  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				break;  			case STRING:  				{  					alt9 = 4;  				}  				break;  			case REGEX:  				{  					alt9 = 5;  				}  				break;  			case NUMBER:  				{  					alt9 = 6;  				}  				break;  			case TRUE:  				{  					alt9 = 7;  				}  				break;  			case FALSE:  				{  					alt9 = 8;  				}  				break;  			case NULL:  				{  					alt9 = 9;  				}  				break;  			default: {  				NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  			}  		}  		finally {  			DebugExitDecision (9);  		}  		switch (alt9) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  			{  				DebugLocation (64' 4);  				DebugLocation (64' 6);  				PushFollow (Follow._comparator_in_filterExpr175);  				comparator6 = comparator ();  				PopFollow ();  				Match (input' TokenTypes.Down' null);  				DebugLocation (64' 18);  				PushFollow (Follow._filterExpr_in_filterExpr179);  				a = filterExpr ();  				PopFollow ();  				DebugLocation (64' 31);  				PushFollow (Follow._filterExpr_in_filterExpr183);  				b = filterExpr ();  				PopFollow ();  				Match (input' TokenTypes.Up' null);  				DebugLocation (65' 4);  				Comparator newComparator;  				switch (comparator6) {  				case "=":  					newComparator = Comparator.Equals;  					break;  				case "!=":  					newComparator = Comparator.NotEquals;  					break;  				case ">":  					newComparator = Comparator.Greater;  					break;  				case "<":  					newComparator = Comparator.Less;  					break;  				case ">=":  					newComparator = Comparator.GreaterOrEqual;  					break;  				case "<=":  					newComparator = Comparator.LessOrEqual;  					break;  				case "&":  					newComparator = Comparator.And;  					break;  				case "|":  					newComparator = Comparator.Or;  					break;  				default:  					newComparator = Comparator.Equals;  					break;  				}  				filterNode = new BoolExpression (a' newComparator' b);  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  			{  				DebugLocation (98' 4);  				DebugLocation (98' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr195);  				Match (input' TokenTypes.Down' null);  				DebugLocation (98' 12);  				PushFollow (Follow._filterExpr_in_filterExpr199);  				f = filterExpr ();  				PopFollow ();  				DebugLocation (98' 31);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  				int alt6 = 2;  				try {  					DebugEnterSubRule (6);  					try {  						DebugEnterDecision (6' false);  						int LA6_1 = input.LA (1);  						if ((LA6_1 == 24)) {  							alt6 = 1;  						}  					}  					finally {  						DebugExitDecision (6);  					}  					switch (alt6) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  						{  							DebugLocation (98' 31);  							inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (6);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (99' 4);  				FilterTreeNode newNode = f;  				if ((inverse != null ? inverse.Text : default(string)) == "!")  					newNode.ToggleInversed ();  				filterNode = newNode;  			}  			break;  		case 3:  			DebugEnterAlt (3);  			// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  			{  				DebugLocation (105' 4);  				DebugLocation (105' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr216);  				Match (input' TokenTypes.Down' null);  				DebugLocation (105' 12);  				PushFollow (Follow._propertyChain_in_filterExpr219);  				propertyChain (propertySegments);  				PopFollow ();  				DebugLocation (105' 51);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  				int alt7 = 2;  				try {  					DebugEnterSubRule (7);  					try {  						DebugEnterDecision (7' false);  						int LA7_1 = input.LA (1);  						if ((LA7_1 == 31)) {  							alt7 = 1;  						}  					}  					finally {  						DebugExitDecision (7);  					}  					switch (alt7) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  						{  							DebugLocation (105' 51);  							inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (7);  				}  				DebugLocation (105' 60);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  				int alt8 = 2;  				try {  					DebugEnterSubRule (8);  					try {  						DebugEnterDecision (8' false);  						int LA8_1 = input.LA (1);  						if ((LA8_1 == 24)) {  							alt8 = 1;  						}  					}  					finally {  						DebugExitDecision (8);  					}  					switch (alt8) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  						{  							DebugLocation (105' 60);  							not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (8);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (106' 4);  				FilterTreeNode newProperty = new Property (propertySegments);  				if ((inverse != null ? inverse.Text : default(string)) == "?")  					filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  				else {  					if ((not != null ? not.Text : default(string)) == "!")  						newProperty.ToggleInversed ();  					filterNode = newProperty;  				}  			}  			break;  		case 4:  			DebugEnterAlt (4);  			// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  			{  				DebugLocation (116' 4);  				STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  				DebugLocation (117' 4);  				string stringText = (STRING7 != null ? STRING7.Text : default(string));  				stringText = stringText.Substring (1' stringText.Length - 2);  				filterNode = new Value (stringText);  			}  			break;  		case 5:  			DebugEnterAlt (5);  			// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  			{  				DebugLocation (122' 4);  				REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  				DebugLocation (123' 4);  				string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  				regexText = regexText.Substring (1' regexText.Length - 2);  				filterNode = new RegExp (regexText);  			}  			break;  		case 6:  			DebugEnterAlt (6);  			// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  			{  				DebugLocation (128' 4);  				NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  				DebugLocation (129' 4);  				filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  			}  			break;  		case 7:  			DebugEnterAlt (7);  			// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  			{  				DebugLocation (132' 4);  				Match (input' TRUE' Follow._TRUE_in_filterExpr271);  				DebugLocation (133' 4);  				filterNode = new Value (true);  			}  			break;  		case 8:  			DebugEnterAlt (8);  			// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  			{  				DebugLocation (136' 4);  				Match (input' FALSE' Follow._FALSE_in_filterExpr281);  				DebugLocation (137' 4);  				filterNode = new Value (false);  			}  			break;  		case 9:  			DebugEnterAlt (9);  			// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  			{  				DebugLocation (140' 4);  				Match (input' NULL' Follow._NULL_in_filterExpr291);  				DebugLocation (141' 4);  				filterNode = new Value (null);  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("filterExpr"' 6);  		LeaveRule ("filterExpr"' 6);  		LeaveRule_filterExpr ();  	}  	DebugLocation (144' 1);  }  finally {  	DebugExitRule (GrammarFileName' "filterExpr");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "filterExpr");  	DebugLocation (60' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  		int alt9 = 9;  		try {  			DebugEnterDecision (9' false);  			switch (input.LA (1)) {  			case CHAIN_OPERATOR:  			case COMPARATOR:  				{  					alt9 = 1;  				}  				break;  			case EXPR:  				{  					int LA9_2 = input.LA (2);  					if ((LA9_2 == DOWN)) {  						int LA9_3 = input.LA (3);  						if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  							alt9 = 2;  						}  						else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  							alt9 = 3;  						}  						else {  							NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  							DebugRecognitionException (nvae);  							throw nvae;  						}  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				break;  			case STRING:  				{  					alt9 = 4;  				}  				break;  			case REGEX:  				{  					alt9 = 5;  				}  				break;  			case NUMBER:  				{  					alt9 = 6;  				}  				break;  			case TRUE:  				{  					alt9 = 7;  				}  				break;  			case FALSE:  				{  					alt9 = 8;  				}  				break;  			case NULL:  				{  					alt9 = 9;  				}  				break;  			default: {  				NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  			}  		}  		finally {  			DebugExitDecision (9);  		}  		switch (alt9) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  			{  				DebugLocation (64' 4);  				DebugLocation (64' 6);  				PushFollow (Follow._comparator_in_filterExpr175);  				comparator6 = comparator ();  				PopFollow ();  				Match (input' TokenTypes.Down' null);  				DebugLocation (64' 18);  				PushFollow (Follow._filterExpr_in_filterExpr179);  				a = filterExpr ();  				PopFollow ();  				DebugLocation (64' 31);  				PushFollow (Follow._filterExpr_in_filterExpr183);  				b = filterExpr ();  				PopFollow ();  				Match (input' TokenTypes.Up' null);  				DebugLocation (65' 4);  				Comparator newComparator;  				switch (comparator6) {  				case "=":  					newComparator = Comparator.Equals;  					break;  				case "!=":  					newComparator = Comparator.NotEquals;  					break;  				case ">":  					newComparator = Comparator.Greater;  					break;  				case "<":  					newComparator = Comparator.Less;  					break;  				case ">=":  					newComparator = Comparator.GreaterOrEqual;  					break;  				case "<=":  					newComparator = Comparator.LessOrEqual;  					break;  				case "&":  					newComparator = Comparator.And;  					break;  				case "|":  					newComparator = Comparator.Or;  					break;  				default:  					newComparator = Comparator.Equals;  					break;  				}  				filterNode = new BoolExpression (a' newComparator' b);  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  			{  				DebugLocation (98' 4);  				DebugLocation (98' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr195);  				Match (input' TokenTypes.Down' null);  				DebugLocation (98' 12);  				PushFollow (Follow._filterExpr_in_filterExpr199);  				f = filterExpr ();  				PopFollow ();  				DebugLocation (98' 31);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  				int alt6 = 2;  				try {  					DebugEnterSubRule (6);  					try {  						DebugEnterDecision (6' false);  						int LA6_1 = input.LA (1);  						if ((LA6_1 == 24)) {  							alt6 = 1;  						}  					}  					finally {  						DebugExitDecision (6);  					}  					switch (alt6) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  						{  							DebugLocation (98' 31);  							inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (6);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (99' 4);  				FilterTreeNode newNode = f;  				if ((inverse != null ? inverse.Text : default(string)) == "!")  					newNode.ToggleInversed ();  				filterNode = newNode;  			}  			break;  		case 3:  			DebugEnterAlt (3);  			// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  			{  				DebugLocation (105' 4);  				DebugLocation (105' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr216);  				Match (input' TokenTypes.Down' null);  				DebugLocation (105' 12);  				PushFollow (Follow._propertyChain_in_filterExpr219);  				propertyChain (propertySegments);  				PopFollow ();  				DebugLocation (105' 51);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  				int alt7 = 2;  				try {  					DebugEnterSubRule (7);  					try {  						DebugEnterDecision (7' false);  						int LA7_1 = input.LA (1);  						if ((LA7_1 == 31)) {  							alt7 = 1;  						}  					}  					finally {  						DebugExitDecision (7);  					}  					switch (alt7) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  						{  							DebugLocation (105' 51);  							inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (7);  				}  				DebugLocation (105' 60);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  				int alt8 = 2;  				try {  					DebugEnterSubRule (8);  					try {  						DebugEnterDecision (8' false);  						int LA8_1 = input.LA (1);  						if ((LA8_1 == 24)) {  							alt8 = 1;  						}  					}  					finally {  						DebugExitDecision (8);  					}  					switch (alt8) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  						{  							DebugLocation (105' 60);  							not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (8);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (106' 4);  				FilterTreeNode newProperty = new Property (propertySegments);  				if ((inverse != null ? inverse.Text : default(string)) == "?")  					filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  				else {  					if ((not != null ? not.Text : default(string)) == "!")  						newProperty.ToggleInversed ();  					filterNode = newProperty;  				}  			}  			break;  		case 4:  			DebugEnterAlt (4);  			// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  			{  				DebugLocation (116' 4);  				STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  				DebugLocation (117' 4);  				string stringText = (STRING7 != null ? STRING7.Text : default(string));  				stringText = stringText.Substring (1' stringText.Length - 2);  				filterNode = new Value (stringText);  			}  			break;  		case 5:  			DebugEnterAlt (5);  			// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  			{  				DebugLocation (122' 4);  				REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  				DebugLocation (123' 4);  				string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  				regexText = regexText.Substring (1' regexText.Length - 2);  				filterNode = new RegExp (regexText);  			}  			break;  		case 6:  			DebugEnterAlt (6);  			// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  			{  				DebugLocation (128' 4);  				NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  				DebugLocation (129' 4);  				filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  			}  			break;  		case 7:  			DebugEnterAlt (7);  			// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  			{  				DebugLocation (132' 4);  				Match (input' TRUE' Follow._TRUE_in_filterExpr271);  				DebugLocation (133' 4);  				filterNode = new Value (true);  			}  			break;  		case 8:  			DebugEnterAlt (8);  			// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  			{  				DebugLocation (136' 4);  				Match (input' FALSE' Follow._FALSE_in_filterExpr281);  				DebugLocation (137' 4);  				filterNode = new Value (false);  			}  			break;  		case 9:  			DebugEnterAlt (9);  			// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  			{  				DebugLocation (140' 4);  				Match (input' NULL' Follow._NULL_in_filterExpr291);  				DebugLocation (141' 4);  				filterNode = new Value (null);  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("filterExpr"' 6);  		LeaveRule ("filterExpr"' 6);  		LeaveRule_filterExpr ();  	}  	DebugLocation (144' 1);  }  finally {  	DebugExitRule (GrammarFileName' "filterExpr");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "filterExpr");  	DebugLocation (60' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  		int alt9 = 9;  		try {  			DebugEnterDecision (9' false);  			switch (input.LA (1)) {  			case CHAIN_OPERATOR:  			case COMPARATOR:  				{  					alt9 = 1;  				}  				break;  			case EXPR:  				{  					int LA9_2 = input.LA (2);  					if ((LA9_2 == DOWN)) {  						int LA9_3 = input.LA (3);  						if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  							alt9 = 2;  						}  						else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  							alt9 = 3;  						}  						else {  							NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  							DebugRecognitionException (nvae);  							throw nvae;  						}  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				break;  			case STRING:  				{  					alt9 = 4;  				}  				break;  			case REGEX:  				{  					alt9 = 5;  				}  				break;  			case NUMBER:  				{  					alt9 = 6;  				}  				break;  			case TRUE:  				{  					alt9 = 7;  				}  				break;  			case FALSE:  				{  					alt9 = 8;  				}  				break;  			case NULL:  				{  					alt9 = 9;  				}  				break;  			default: {  				NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  			}  		}  		finally {  			DebugExitDecision (9);  		}  		switch (alt9) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  			{  				DebugLocation (64' 4);  				DebugLocation (64' 6);  				PushFollow (Follow._comparator_in_filterExpr175);  				comparator6 = comparator ();  				PopFollow ();  				Match (input' TokenTypes.Down' null);  				DebugLocation (64' 18);  				PushFollow (Follow._filterExpr_in_filterExpr179);  				a = filterExpr ();  				PopFollow ();  				DebugLocation (64' 31);  				PushFollow (Follow._filterExpr_in_filterExpr183);  				b = filterExpr ();  				PopFollow ();  				Match (input' TokenTypes.Up' null);  				DebugLocation (65' 4);  				Comparator newComparator;  				switch (comparator6) {  				case "=":  					newComparator = Comparator.Equals;  					break;  				case "!=":  					newComparator = Comparator.NotEquals;  					break;  				case ">":  					newComparator = Comparator.Greater;  					break;  				case "<":  					newComparator = Comparator.Less;  					break;  				case ">=":  					newComparator = Comparator.GreaterOrEqual;  					break;  				case "<=":  					newComparator = Comparator.LessOrEqual;  					break;  				case "&":  					newComparator = Comparator.And;  					break;  				case "|":  					newComparator = Comparator.Or;  					break;  				default:  					newComparator = Comparator.Equals;  					break;  				}  				filterNode = new BoolExpression (a' newComparator' b);  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  			{  				DebugLocation (98' 4);  				DebugLocation (98' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr195);  				Match (input' TokenTypes.Down' null);  				DebugLocation (98' 12);  				PushFollow (Follow._filterExpr_in_filterExpr199);  				f = filterExpr ();  				PopFollow ();  				DebugLocation (98' 31);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  				int alt6 = 2;  				try {  					DebugEnterSubRule (6);  					try {  						DebugEnterDecision (6' false);  						int LA6_1 = input.LA (1);  						if ((LA6_1 == 24)) {  							alt6 = 1;  						}  					}  					finally {  						DebugExitDecision (6);  					}  					switch (alt6) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  						{  							DebugLocation (98' 31);  							inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (6);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (99' 4);  				FilterTreeNode newNode = f;  				if ((inverse != null ? inverse.Text : default(string)) == "!")  					newNode.ToggleInversed ();  				filterNode = newNode;  			}  			break;  		case 3:  			DebugEnterAlt (3);  			// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  			{  				DebugLocation (105' 4);  				DebugLocation (105' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr216);  				Match (input' TokenTypes.Down' null);  				DebugLocation (105' 12);  				PushFollow (Follow._propertyChain_in_filterExpr219);  				propertyChain (propertySegments);  				PopFollow ();  				DebugLocation (105' 51);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  				int alt7 = 2;  				try {  					DebugEnterSubRule (7);  					try {  						DebugEnterDecision (7' false);  						int LA7_1 = input.LA (1);  						if ((LA7_1 == 31)) {  							alt7 = 1;  						}  					}  					finally {  						DebugExitDecision (7);  					}  					switch (alt7) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  						{  							DebugLocation (105' 51);  							inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (7);  				}  				DebugLocation (105' 60);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  				int alt8 = 2;  				try {  					DebugEnterSubRule (8);  					try {  						DebugEnterDecision (8' false);  						int LA8_1 = input.LA (1);  						if ((LA8_1 == 24)) {  							alt8 = 1;  						}  					}  					finally {  						DebugExitDecision (8);  					}  					switch (alt8) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  						{  							DebugLocation (105' 60);  							not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (8);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (106' 4);  				FilterTreeNode newProperty = new Property (propertySegments);  				if ((inverse != null ? inverse.Text : default(string)) == "?")  					filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  				else {  					if ((not != null ? not.Text : default(string)) == "!")  						newProperty.ToggleInversed ();  					filterNode = newProperty;  				}  			}  			break;  		case 4:  			DebugEnterAlt (4);  			// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  			{  				DebugLocation (116' 4);  				STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  				DebugLocation (117' 4);  				string stringText = (STRING7 != null ? STRING7.Text : default(string));  				stringText = stringText.Substring (1' stringText.Length - 2);  				filterNode = new Value (stringText);  			}  			break;  		case 5:  			DebugEnterAlt (5);  			// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  			{  				DebugLocation (122' 4);  				REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  				DebugLocation (123' 4);  				string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  				regexText = regexText.Substring (1' regexText.Length - 2);  				filterNode = new RegExp (regexText);  			}  			break;  		case 6:  			DebugEnterAlt (6);  			// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  			{  				DebugLocation (128' 4);  				NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  				DebugLocation (129' 4);  				filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  			}  			break;  		case 7:  			DebugEnterAlt (7);  			// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  			{  				DebugLocation (132' 4);  				Match (input' TRUE' Follow._TRUE_in_filterExpr271);  				DebugLocation (133' 4);  				filterNode = new Value (true);  			}  			break;  		case 8:  			DebugEnterAlt (8);  			// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  			{  				DebugLocation (136' 4);  				Match (input' FALSE' Follow._FALSE_in_filterExpr281);  				DebugLocation (137' 4);  				filterNode = new Value (false);  			}  			break;  		case 9:  			DebugEnterAlt (9);  			// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  			{  				DebugLocation (140' 4);  				Match (input' NULL' Follow._NULL_in_filterExpr291);  				DebugLocation (141' 4);  				filterNode = new Value (null);  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("filterExpr"' 6);  		LeaveRule ("filterExpr"' 6);  		LeaveRule_filterExpr ();  	}  	DebugLocation (144' 1);  }  finally {  	DebugExitRule (GrammarFileName' "filterExpr");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "filterExpr");  	DebugLocation (60' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  		int alt9 = 9;  		try {  			DebugEnterDecision (9' false);  			switch (input.LA (1)) {  			case CHAIN_OPERATOR:  			case COMPARATOR:  				{  					alt9 = 1;  				}  				break;  			case EXPR:  				{  					int LA9_2 = input.LA (2);  					if ((LA9_2 == DOWN)) {  						int LA9_3 = input.LA (3);  						if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  							alt9 = 2;  						}  						else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  							alt9 = 3;  						}  						else {  							NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  							DebugRecognitionException (nvae);  							throw nvae;  						}  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				break;  			case STRING:  				{  					alt9 = 4;  				}  				break;  			case REGEX:  				{  					alt9 = 5;  				}  				break;  			case NUMBER:  				{  					alt9 = 6;  				}  				break;  			case TRUE:  				{  					alt9 = 7;  				}  				break;  			case FALSE:  				{  					alt9 = 8;  				}  				break;  			case NULL:  				{  					alt9 = 9;  				}  				break;  			default: {  				NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  			}  		}  		finally {  			DebugExitDecision (9);  		}  		switch (alt9) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  			{  				DebugLocation (64' 4);  				DebugLocation (64' 6);  				PushFollow (Follow._comparator_in_filterExpr175);  				comparator6 = comparator ();  				PopFollow ();  				Match (input' TokenTypes.Down' null);  				DebugLocation (64' 18);  				PushFollow (Follow._filterExpr_in_filterExpr179);  				a = filterExpr ();  				PopFollow ();  				DebugLocation (64' 31);  				PushFollow (Follow._filterExpr_in_filterExpr183);  				b = filterExpr ();  				PopFollow ();  				Match (input' TokenTypes.Up' null);  				DebugLocation (65' 4);  				Comparator newComparator;  				switch (comparator6) {  				case "=":  					newComparator = Comparator.Equals;  					break;  				case "!=":  					newComparator = Comparator.NotEquals;  					break;  				case ">":  					newComparator = Comparator.Greater;  					break;  				case "<":  					newComparator = Comparator.Less;  					break;  				case ">=":  					newComparator = Comparator.GreaterOrEqual;  					break;  				case "<=":  					newComparator = Comparator.LessOrEqual;  					break;  				case "&":  					newComparator = Comparator.And;  					break;  				case "|":  					newComparator = Comparator.Or;  					break;  				default:  					newComparator = Comparator.Equals;  					break;  				}  				filterNode = new BoolExpression (a' newComparator' b);  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  			{  				DebugLocation (98' 4);  				DebugLocation (98' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr195);  				Match (input' TokenTypes.Down' null);  				DebugLocation (98' 12);  				PushFollow (Follow._filterExpr_in_filterExpr199);  				f = filterExpr ();  				PopFollow ();  				DebugLocation (98' 31);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  				int alt6 = 2;  				try {  					DebugEnterSubRule (6);  					try {  						DebugEnterDecision (6' false);  						int LA6_1 = input.LA (1);  						if ((LA6_1 == 24)) {  							alt6 = 1;  						}  					}  					finally {  						DebugExitDecision (6);  					}  					switch (alt6) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  						{  							DebugLocation (98' 31);  							inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (6);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (99' 4);  				FilterTreeNode newNode = f;  				if ((inverse != null ? inverse.Text : default(string)) == "!")  					newNode.ToggleInversed ();  				filterNode = newNode;  			}  			break;  		case 3:  			DebugEnterAlt (3);  			// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  			{  				DebugLocation (105' 4);  				DebugLocation (105' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr216);  				Match (input' TokenTypes.Down' null);  				DebugLocation (105' 12);  				PushFollow (Follow._propertyChain_in_filterExpr219);  				propertyChain (propertySegments);  				PopFollow ();  				DebugLocation (105' 51);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  				int alt7 = 2;  				try {  					DebugEnterSubRule (7);  					try {  						DebugEnterDecision (7' false);  						int LA7_1 = input.LA (1);  						if ((LA7_1 == 31)) {  							alt7 = 1;  						}  					}  					finally {  						DebugExitDecision (7);  					}  					switch (alt7) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  						{  							DebugLocation (105' 51);  							inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (7);  				}  				DebugLocation (105' 60);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  				int alt8 = 2;  				try {  					DebugEnterSubRule (8);  					try {  						DebugEnterDecision (8' false);  						int LA8_1 = input.LA (1);  						if ((LA8_1 == 24)) {  							alt8 = 1;  						}  					}  					finally {  						DebugExitDecision (8);  					}  					switch (alt8) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  						{  							DebugLocation (105' 60);  							not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (8);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (106' 4);  				FilterTreeNode newProperty = new Property (propertySegments);  				if ((inverse != null ? inverse.Text : default(string)) == "?")  					filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  				else {  					if ((not != null ? not.Text : default(string)) == "!")  						newProperty.ToggleInversed ();  					filterNode = newProperty;  				}  			}  			break;  		case 4:  			DebugEnterAlt (4);  			// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  			{  				DebugLocation (116' 4);  				STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  				DebugLocation (117' 4);  				string stringText = (STRING7 != null ? STRING7.Text : default(string));  				stringText = stringText.Substring (1' stringText.Length - 2);  				filterNode = new Value (stringText);  			}  			break;  		case 5:  			DebugEnterAlt (5);  			// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  			{  				DebugLocation (122' 4);  				REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  				DebugLocation (123' 4);  				string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  				regexText = regexText.Substring (1' regexText.Length - 2);  				filterNode = new RegExp (regexText);  			}  			break;  		case 6:  			DebugEnterAlt (6);  			// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  			{  				DebugLocation (128' 4);  				NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  				DebugLocation (129' 4);  				filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  			}  			break;  		case 7:  			DebugEnterAlt (7);  			// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  			{  				DebugLocation (132' 4);  				Match (input' TRUE' Follow._TRUE_in_filterExpr271);  				DebugLocation (133' 4);  				filterNode = new Value (true);  			}  			break;  		case 8:  			DebugEnterAlt (8);  			// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  			{  				DebugLocation (136' 4);  				Match (input' FALSE' Follow._FALSE_in_filterExpr281);  				DebugLocation (137' 4);  				filterNode = new Value (false);  			}  			break;  		case 9:  			DebugEnterAlt (9);  			// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  			{  				DebugLocation (140' 4);  				Match (input' NULL' Follow._NULL_in_filterExpr291);  				DebugLocation (141' 4);  				filterNode = new Value (null);  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("filterExpr"' 6);  		LeaveRule ("filterExpr"' 6);  		LeaveRule_filterExpr ();  	}  	DebugLocation (144' 1);  }  finally {  	DebugExitRule (GrammarFileName' "filterExpr");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "filterExpr");  	DebugLocation (60' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  		int alt9 = 9;  		try {  			DebugEnterDecision (9' false);  			switch (input.LA (1)) {  			case CHAIN_OPERATOR:  			case COMPARATOR:  				{  					alt9 = 1;  				}  				break;  			case EXPR:  				{  					int LA9_2 = input.LA (2);  					if ((LA9_2 == DOWN)) {  						int LA9_3 = input.LA (3);  						if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  							alt9 = 2;  						}  						else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  							alt9 = 3;  						}  						else {  							NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  							DebugRecognitionException (nvae);  							throw nvae;  						}  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				break;  			case STRING:  				{  					alt9 = 4;  				}  				break;  			case REGEX:  				{  					alt9 = 5;  				}  				break;  			case NUMBER:  				{  					alt9 = 6;  				}  				break;  			case TRUE:  				{  					alt9 = 7;  				}  				break;  			case FALSE:  				{  					alt9 = 8;  				}  				break;  			case NULL:  				{  					alt9 = 9;  				}  				break;  			default: {  				NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  			}  		}  		finally {  			DebugExitDecision (9);  		}  		switch (alt9) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  			{  				DebugLocation (64' 4);  				DebugLocation (64' 6);  				PushFollow (Follow._comparator_in_filterExpr175);  				comparator6 = comparator ();  				PopFollow ();  				Match (input' TokenTypes.Down' null);  				DebugLocation (64' 18);  				PushFollow (Follow._filterExpr_in_filterExpr179);  				a = filterExpr ();  				PopFollow ();  				DebugLocation (64' 31);  				PushFollow (Follow._filterExpr_in_filterExpr183);  				b = filterExpr ();  				PopFollow ();  				Match (input' TokenTypes.Up' null);  				DebugLocation (65' 4);  				Comparator newComparator;  				switch (comparator6) {  				case "=":  					newComparator = Comparator.Equals;  					break;  				case "!=":  					newComparator = Comparator.NotEquals;  					break;  				case ">":  					newComparator = Comparator.Greater;  					break;  				case "<":  					newComparator = Comparator.Less;  					break;  				case ">=":  					newComparator = Comparator.GreaterOrEqual;  					break;  				case "<=":  					newComparator = Comparator.LessOrEqual;  					break;  				case "&":  					newComparator = Comparator.And;  					break;  				case "|":  					newComparator = Comparator.Or;  					break;  				default:  					newComparator = Comparator.Equals;  					break;  				}  				filterNode = new BoolExpression (a' newComparator' b);  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  			{  				DebugLocation (98' 4);  				DebugLocation (98' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr195);  				Match (input' TokenTypes.Down' null);  				DebugLocation (98' 12);  				PushFollow (Follow._filterExpr_in_filterExpr199);  				f = filterExpr ();  				PopFollow ();  				DebugLocation (98' 31);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  				int alt6 = 2;  				try {  					DebugEnterSubRule (6);  					try {  						DebugEnterDecision (6' false);  						int LA6_1 = input.LA (1);  						if ((LA6_1 == 24)) {  							alt6 = 1;  						}  					}  					finally {  						DebugExitDecision (6);  					}  					switch (alt6) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  						{  							DebugLocation (98' 31);  							inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (6);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (99' 4);  				FilterTreeNode newNode = f;  				if ((inverse != null ? inverse.Text : default(string)) == "!")  					newNode.ToggleInversed ();  				filterNode = newNode;  			}  			break;  		case 3:  			DebugEnterAlt (3);  			// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  			{  				DebugLocation (105' 4);  				DebugLocation (105' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr216);  				Match (input' TokenTypes.Down' null);  				DebugLocation (105' 12);  				PushFollow (Follow._propertyChain_in_filterExpr219);  				propertyChain (propertySegments);  				PopFollow ();  				DebugLocation (105' 51);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  				int alt7 = 2;  				try {  					DebugEnterSubRule (7);  					try {  						DebugEnterDecision (7' false);  						int LA7_1 = input.LA (1);  						if ((LA7_1 == 31)) {  							alt7 = 1;  						}  					}  					finally {  						DebugExitDecision (7);  					}  					switch (alt7) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  						{  							DebugLocation (105' 51);  							inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (7);  				}  				DebugLocation (105' 60);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  				int alt8 = 2;  				try {  					DebugEnterSubRule (8);  					try {  						DebugEnterDecision (8' false);  						int LA8_1 = input.LA (1);  						if ((LA8_1 == 24)) {  							alt8 = 1;  						}  					}  					finally {  						DebugExitDecision (8);  					}  					switch (alt8) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  						{  							DebugLocation (105' 60);  							not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (8);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (106' 4);  				FilterTreeNode newProperty = new Property (propertySegments);  				if ((inverse != null ? inverse.Text : default(string)) == "?")  					filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  				else {  					if ((not != null ? not.Text : default(string)) == "!")  						newProperty.ToggleInversed ();  					filterNode = newProperty;  				}  			}  			break;  		case 4:  			DebugEnterAlt (4);  			// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  			{  				DebugLocation (116' 4);  				STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  				DebugLocation (117' 4);  				string stringText = (STRING7 != null ? STRING7.Text : default(string));  				stringText = stringText.Substring (1' stringText.Length - 2);  				filterNode = new Value (stringText);  			}  			break;  		case 5:  			DebugEnterAlt (5);  			// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  			{  				DebugLocation (122' 4);  				REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  				DebugLocation (123' 4);  				string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  				regexText = regexText.Substring (1' regexText.Length - 2);  				filterNode = new RegExp (regexText);  			}  			break;  		case 6:  			DebugEnterAlt (6);  			// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  			{  				DebugLocation (128' 4);  				NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  				DebugLocation (129' 4);  				filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  			}  			break;  		case 7:  			DebugEnterAlt (7);  			// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  			{  				DebugLocation (132' 4);  				Match (input' TRUE' Follow._TRUE_in_filterExpr271);  				DebugLocation (133' 4);  				filterNode = new Value (true);  			}  			break;  		case 8:  			DebugEnterAlt (8);  			// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  			{  				DebugLocation (136' 4);  				Match (input' FALSE' Follow._FALSE_in_filterExpr281);  				DebugLocation (137' 4);  				filterNode = new Value (false);  			}  			break;  		case 9:  			DebugEnterAlt (9);  			// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  			{  				DebugLocation (140' 4);  				Match (input' NULL' Follow._NULL_in_filterExpr291);  				DebugLocation (141' 4);  				filterNode = new Value (null);  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("filterExpr"' 6);  		LeaveRule ("filterExpr"' 6);  		LeaveRule_filterExpr ();  	}  	DebugLocation (144' 1);  }  finally {  	DebugExitRule (GrammarFileName' "filterExpr");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "filterExpr");  	DebugLocation (60' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  		int alt9 = 9;  		try {  			DebugEnterDecision (9' false);  			switch (input.LA (1)) {  			case CHAIN_OPERATOR:  			case COMPARATOR:  				{  					alt9 = 1;  				}  				break;  			case EXPR:  				{  					int LA9_2 = input.LA (2);  					if ((LA9_2 == DOWN)) {  						int LA9_3 = input.LA (3);  						if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  							alt9 = 2;  						}  						else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  							alt9 = 3;  						}  						else {  							NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  							DebugRecognitionException (nvae);  							throw nvae;  						}  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				break;  			case STRING:  				{  					alt9 = 4;  				}  				break;  			case REGEX:  				{  					alt9 = 5;  				}  				break;  			case NUMBER:  				{  					alt9 = 6;  				}  				break;  			case TRUE:  				{  					alt9 = 7;  				}  				break;  			case FALSE:  				{  					alt9 = 8;  				}  				break;  			case NULL:  				{  					alt9 = 9;  				}  				break;  			default: {  				NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  			}  		}  		finally {  			DebugExitDecision (9);  		}  		switch (alt9) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  			{  				DebugLocation (64' 4);  				DebugLocation (64' 6);  				PushFollow (Follow._comparator_in_filterExpr175);  				comparator6 = comparator ();  				PopFollow ();  				Match (input' TokenTypes.Down' null);  				DebugLocation (64' 18);  				PushFollow (Follow._filterExpr_in_filterExpr179);  				a = filterExpr ();  				PopFollow ();  				DebugLocation (64' 31);  				PushFollow (Follow._filterExpr_in_filterExpr183);  				b = filterExpr ();  				PopFollow ();  				Match (input' TokenTypes.Up' null);  				DebugLocation (65' 4);  				Comparator newComparator;  				switch (comparator6) {  				case "=":  					newComparator = Comparator.Equals;  					break;  				case "!=":  					newComparator = Comparator.NotEquals;  					break;  				case ">":  					newComparator = Comparator.Greater;  					break;  				case "<":  					newComparator = Comparator.Less;  					break;  				case ">=":  					newComparator = Comparator.GreaterOrEqual;  					break;  				case "<=":  					newComparator = Comparator.LessOrEqual;  					break;  				case "&":  					newComparator = Comparator.And;  					break;  				case "|":  					newComparator = Comparator.Or;  					break;  				default:  					newComparator = Comparator.Equals;  					break;  				}  				filterNode = new BoolExpression (a' newComparator' b);  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  			{  				DebugLocation (98' 4);  				DebugLocation (98' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr195);  				Match (input' TokenTypes.Down' null);  				DebugLocation (98' 12);  				PushFollow (Follow._filterExpr_in_filterExpr199);  				f = filterExpr ();  				PopFollow ();  				DebugLocation (98' 31);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  				int alt6 = 2;  				try {  					DebugEnterSubRule (6);  					try {  						DebugEnterDecision (6' false);  						int LA6_1 = input.LA (1);  						if ((LA6_1 == 24)) {  							alt6 = 1;  						}  					}  					finally {  						DebugExitDecision (6);  					}  					switch (alt6) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  						{  							DebugLocation (98' 31);  							inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (6);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (99' 4);  				FilterTreeNode newNode = f;  				if ((inverse != null ? inverse.Text : default(string)) == "!")  					newNode.ToggleInversed ();  				filterNode = newNode;  			}  			break;  		case 3:  			DebugEnterAlt (3);  			// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  			{  				DebugLocation (105' 4);  				DebugLocation (105' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr216);  				Match (input' TokenTypes.Down' null);  				DebugLocation (105' 12);  				PushFollow (Follow._propertyChain_in_filterExpr219);  				propertyChain (propertySegments);  				PopFollow ();  				DebugLocation (105' 51);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  				int alt7 = 2;  				try {  					DebugEnterSubRule (7);  					try {  						DebugEnterDecision (7' false);  						int LA7_1 = input.LA (1);  						if ((LA7_1 == 31)) {  							alt7 = 1;  						}  					}  					finally {  						DebugExitDecision (7);  					}  					switch (alt7) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  						{  							DebugLocation (105' 51);  							inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (7);  				}  				DebugLocation (105' 60);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  				int alt8 = 2;  				try {  					DebugEnterSubRule (8);  					try {  						DebugEnterDecision (8' false);  						int LA8_1 = input.LA (1);  						if ((LA8_1 == 24)) {  							alt8 = 1;  						}  					}  					finally {  						DebugExitDecision (8);  					}  					switch (alt8) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  						{  							DebugLocation (105' 60);  							not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (8);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (106' 4);  				FilterTreeNode newProperty = new Property (propertySegments);  				if ((inverse != null ? inverse.Text : default(string)) == "?")  					filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  				else {  					if ((not != null ? not.Text : default(string)) == "!")  						newProperty.ToggleInversed ();  					filterNode = newProperty;  				}  			}  			break;  		case 4:  			DebugEnterAlt (4);  			// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  			{  				DebugLocation (116' 4);  				STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  				DebugLocation (117' 4);  				string stringText = (STRING7 != null ? STRING7.Text : default(string));  				stringText = stringText.Substring (1' stringText.Length - 2);  				filterNode = new Value (stringText);  			}  			break;  		case 5:  			DebugEnterAlt (5);  			// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  			{  				DebugLocation (122' 4);  				REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  				DebugLocation (123' 4);  				string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  				regexText = regexText.Substring (1' regexText.Length - 2);  				filterNode = new RegExp (regexText);  			}  			break;  		case 6:  			DebugEnterAlt (6);  			// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  			{  				DebugLocation (128' 4);  				NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  				DebugLocation (129' 4);  				filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  			}  			break;  		case 7:  			DebugEnterAlt (7);  			// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  			{  				DebugLocation (132' 4);  				Match (input' TRUE' Follow._TRUE_in_filterExpr271);  				DebugLocation (133' 4);  				filterNode = new Value (true);  			}  			break;  		case 8:  			DebugEnterAlt (8);  			// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  			{  				DebugLocation (136' 4);  				Match (input' FALSE' Follow._FALSE_in_filterExpr281);  				DebugLocation (137' 4);  				filterNode = new Value (false);  			}  			break;  		case 9:  			DebugEnterAlt (9);  			// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  			{  				DebugLocation (140' 4);  				Match (input' NULL' Follow._NULL_in_filterExpr291);  				DebugLocation (141' 4);  				filterNode = new Value (null);  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("filterExpr"' 6);  		LeaveRule ("filterExpr"' 6);  		LeaveRule_filterExpr ();  	}  	DebugLocation (144' 1);  }  finally {  	DebugExitRule (GrammarFileName' "filterExpr");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "filterExpr");  	DebugLocation (60' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  		int alt9 = 9;  		try {  			DebugEnterDecision (9' false);  			switch (input.LA (1)) {  			case CHAIN_OPERATOR:  			case COMPARATOR:  				{  					alt9 = 1;  				}  				break;  			case EXPR:  				{  					int LA9_2 = input.LA (2);  					if ((LA9_2 == DOWN)) {  						int LA9_3 = input.LA (3);  						if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  							alt9 = 2;  						}  						else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  							alt9 = 3;  						}  						else {  							NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  							DebugRecognitionException (nvae);  							throw nvae;  						}  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				break;  			case STRING:  				{  					alt9 = 4;  				}  				break;  			case REGEX:  				{  					alt9 = 5;  				}  				break;  			case NUMBER:  				{  					alt9 = 6;  				}  				break;  			case TRUE:  				{  					alt9 = 7;  				}  				break;  			case FALSE:  				{  					alt9 = 8;  				}  				break;  			case NULL:  				{  					alt9 = 9;  				}  				break;  			default: {  				NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  			}  		}  		finally {  			DebugExitDecision (9);  		}  		switch (alt9) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  			{  				DebugLocation (64' 4);  				DebugLocation (64' 6);  				PushFollow (Follow._comparator_in_filterExpr175);  				comparator6 = comparator ();  				PopFollow ();  				Match (input' TokenTypes.Down' null);  				DebugLocation (64' 18);  				PushFollow (Follow._filterExpr_in_filterExpr179);  				a = filterExpr ();  				PopFollow ();  				DebugLocation (64' 31);  				PushFollow (Follow._filterExpr_in_filterExpr183);  				b = filterExpr ();  				PopFollow ();  				Match (input' TokenTypes.Up' null);  				DebugLocation (65' 4);  				Comparator newComparator;  				switch (comparator6) {  				case "=":  					newComparator = Comparator.Equals;  					break;  				case "!=":  					newComparator = Comparator.NotEquals;  					break;  				case ">":  					newComparator = Comparator.Greater;  					break;  				case "<":  					newComparator = Comparator.Less;  					break;  				case ">=":  					newComparator = Comparator.GreaterOrEqual;  					break;  				case "<=":  					newComparator = Comparator.LessOrEqual;  					break;  				case "&":  					newComparator = Comparator.And;  					break;  				case "|":  					newComparator = Comparator.Or;  					break;  				default:  					newComparator = Comparator.Equals;  					break;  				}  				filterNode = new BoolExpression (a' newComparator' b);  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  			{  				DebugLocation (98' 4);  				DebugLocation (98' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr195);  				Match (input' TokenTypes.Down' null);  				DebugLocation (98' 12);  				PushFollow (Follow._filterExpr_in_filterExpr199);  				f = filterExpr ();  				PopFollow ();  				DebugLocation (98' 31);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  				int alt6 = 2;  				try {  					DebugEnterSubRule (6);  					try {  						DebugEnterDecision (6' false);  						int LA6_1 = input.LA (1);  						if ((LA6_1 == 24)) {  							alt6 = 1;  						}  					}  					finally {  						DebugExitDecision (6);  					}  					switch (alt6) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  						{  							DebugLocation (98' 31);  							inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (6);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (99' 4);  				FilterTreeNode newNode = f;  				if ((inverse != null ? inverse.Text : default(string)) == "!")  					newNode.ToggleInversed ();  				filterNode = newNode;  			}  			break;  		case 3:  			DebugEnterAlt (3);  			// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  			{  				DebugLocation (105' 4);  				DebugLocation (105' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr216);  				Match (input' TokenTypes.Down' null);  				DebugLocation (105' 12);  				PushFollow (Follow._propertyChain_in_filterExpr219);  				propertyChain (propertySegments);  				PopFollow ();  				DebugLocation (105' 51);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  				int alt7 = 2;  				try {  					DebugEnterSubRule (7);  					try {  						DebugEnterDecision (7' false);  						int LA7_1 = input.LA (1);  						if ((LA7_1 == 31)) {  							alt7 = 1;  						}  					}  					finally {  						DebugExitDecision (7);  					}  					switch (alt7) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  						{  							DebugLocation (105' 51);  							inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (7);  				}  				DebugLocation (105' 60);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  				int alt8 = 2;  				try {  					DebugEnterSubRule (8);  					try {  						DebugEnterDecision (8' false);  						int LA8_1 = input.LA (1);  						if ((LA8_1 == 24)) {  							alt8 = 1;  						}  					}  					finally {  						DebugExitDecision (8);  					}  					switch (alt8) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  						{  							DebugLocation (105' 60);  							not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (8);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (106' 4);  				FilterTreeNode newProperty = new Property (propertySegments);  				if ((inverse != null ? inverse.Text : default(string)) == "?")  					filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  				else {  					if ((not != null ? not.Text : default(string)) == "!")  						newProperty.ToggleInversed ();  					filterNode = newProperty;  				}  			}  			break;  		case 4:  			DebugEnterAlt (4);  			// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  			{  				DebugLocation (116' 4);  				STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  				DebugLocation (117' 4);  				string stringText = (STRING7 != null ? STRING7.Text : default(string));  				stringText = stringText.Substring (1' stringText.Length - 2);  				filterNode = new Value (stringText);  			}  			break;  		case 5:  			DebugEnterAlt (5);  			// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  			{  				DebugLocation (122' 4);  				REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  				DebugLocation (123' 4);  				string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  				regexText = regexText.Substring (1' regexText.Length - 2);  				filterNode = new RegExp (regexText);  			}  			break;  		case 6:  			DebugEnterAlt (6);  			// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  			{  				DebugLocation (128' 4);  				NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  				DebugLocation (129' 4);  				filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  			}  			break;  		case 7:  			DebugEnterAlt (7);  			// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  			{  				DebugLocation (132' 4);  				Match (input' TRUE' Follow._TRUE_in_filterExpr271);  				DebugLocation (133' 4);  				filterNode = new Value (true);  			}  			break;  		case 8:  			DebugEnterAlt (8);  			// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  			{  				DebugLocation (136' 4);  				Match (input' FALSE' Follow._FALSE_in_filterExpr281);  				DebugLocation (137' 4);  				filterNode = new Value (false);  			}  			break;  		case 9:  			DebugEnterAlt (9);  			// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  			{  				DebugLocation (140' 4);  				Match (input' NULL' Follow._NULL_in_filterExpr291);  				DebugLocation (141' 4);  				filterNode = new Value (null);  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("filterExpr"' 6);  		LeaveRule ("filterExpr"' 6);  		LeaveRule_filterExpr ();  	}  	DebugLocation (144' 1);  }  finally {  	DebugExitRule (GrammarFileName' "filterExpr");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "filterExpr");  	DebugLocation (60' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  		int alt9 = 9;  		try {  			DebugEnterDecision (9' false);  			switch (input.LA (1)) {  			case CHAIN_OPERATOR:  			case COMPARATOR:  				{  					alt9 = 1;  				}  				break;  			case EXPR:  				{  					int LA9_2 = input.LA (2);  					if ((LA9_2 == DOWN)) {  						int LA9_3 = input.LA (3);  						if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  							alt9 = 2;  						}  						else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  							alt9 = 3;  						}  						else {  							NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  							DebugRecognitionException (nvae);  							throw nvae;  						}  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				break;  			case STRING:  				{  					alt9 = 4;  				}  				break;  			case REGEX:  				{  					alt9 = 5;  				}  				break;  			case NUMBER:  				{  					alt9 = 6;  				}  				break;  			case TRUE:  				{  					alt9 = 7;  				}  				break;  			case FALSE:  				{  					alt9 = 8;  				}  				break;  			case NULL:  				{  					alt9 = 9;  				}  				break;  			default: {  				NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  			}  		}  		finally {  			DebugExitDecision (9);  		}  		switch (alt9) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  			{  				DebugLocation (64' 4);  				DebugLocation (64' 6);  				PushFollow (Follow._comparator_in_filterExpr175);  				comparator6 = comparator ();  				PopFollow ();  				Match (input' TokenTypes.Down' null);  				DebugLocation (64' 18);  				PushFollow (Follow._filterExpr_in_filterExpr179);  				a = filterExpr ();  				PopFollow ();  				DebugLocation (64' 31);  				PushFollow (Follow._filterExpr_in_filterExpr183);  				b = filterExpr ();  				PopFollow ();  				Match (input' TokenTypes.Up' null);  				DebugLocation (65' 4);  				Comparator newComparator;  				switch (comparator6) {  				case "=":  					newComparator = Comparator.Equals;  					break;  				case "!=":  					newComparator = Comparator.NotEquals;  					break;  				case ">":  					newComparator = Comparator.Greater;  					break;  				case "<":  					newComparator = Comparator.Less;  					break;  				case ">=":  					newComparator = Comparator.GreaterOrEqual;  					break;  				case "<=":  					newComparator = Comparator.LessOrEqual;  					break;  				case "&":  					newComparator = Comparator.And;  					break;  				case "|":  					newComparator = Comparator.Or;  					break;  				default:  					newComparator = Comparator.Equals;  					break;  				}  				filterNode = new BoolExpression (a' newComparator' b);  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  			{  				DebugLocation (98' 4);  				DebugLocation (98' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr195);  				Match (input' TokenTypes.Down' null);  				DebugLocation (98' 12);  				PushFollow (Follow._filterExpr_in_filterExpr199);  				f = filterExpr ();  				PopFollow ();  				DebugLocation (98' 31);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  				int alt6 = 2;  				try {  					DebugEnterSubRule (6);  					try {  						DebugEnterDecision (6' false);  						int LA6_1 = input.LA (1);  						if ((LA6_1 == 24)) {  							alt6 = 1;  						}  					}  					finally {  						DebugExitDecision (6);  					}  					switch (alt6) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  						{  							DebugLocation (98' 31);  							inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (6);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (99' 4);  				FilterTreeNode newNode = f;  				if ((inverse != null ? inverse.Text : default(string)) == "!")  					newNode.ToggleInversed ();  				filterNode = newNode;  			}  			break;  		case 3:  			DebugEnterAlt (3);  			// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  			{  				DebugLocation (105' 4);  				DebugLocation (105' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr216);  				Match (input' TokenTypes.Down' null);  				DebugLocation (105' 12);  				PushFollow (Follow._propertyChain_in_filterExpr219);  				propertyChain (propertySegments);  				PopFollow ();  				DebugLocation (105' 51);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  				int alt7 = 2;  				try {  					DebugEnterSubRule (7);  					try {  						DebugEnterDecision (7' false);  						int LA7_1 = input.LA (1);  						if ((LA7_1 == 31)) {  							alt7 = 1;  						}  					}  					finally {  						DebugExitDecision (7);  					}  					switch (alt7) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  						{  							DebugLocation (105' 51);  							inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (7);  				}  				DebugLocation (105' 60);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  				int alt8 = 2;  				try {  					DebugEnterSubRule (8);  					try {  						DebugEnterDecision (8' false);  						int LA8_1 = input.LA (1);  						if ((LA8_1 == 24)) {  							alt8 = 1;  						}  					}  					finally {  						DebugExitDecision (8);  					}  					switch (alt8) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  						{  							DebugLocation (105' 60);  							not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (8);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (106' 4);  				FilterTreeNode newProperty = new Property (propertySegments);  				if ((inverse != null ? inverse.Text : default(string)) == "?")  					filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  				else {  					if ((not != null ? not.Text : default(string)) == "!")  						newProperty.ToggleInversed ();  					filterNode = newProperty;  				}  			}  			break;  		case 4:  			DebugEnterAlt (4);  			// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  			{  				DebugLocation (116' 4);  				STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  				DebugLocation (117' 4);  				string stringText = (STRING7 != null ? STRING7.Text : default(string));  				stringText = stringText.Substring (1' stringText.Length - 2);  				filterNode = new Value (stringText);  			}  			break;  		case 5:  			DebugEnterAlt (5);  			// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  			{  				DebugLocation (122' 4);  				REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  				DebugLocation (123' 4);  				string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  				regexText = regexText.Substring (1' regexText.Length - 2);  				filterNode = new RegExp (regexText);  			}  			break;  		case 6:  			DebugEnterAlt (6);  			// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  			{  				DebugLocation (128' 4);  				NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  				DebugLocation (129' 4);  				filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  			}  			break;  		case 7:  			DebugEnterAlt (7);  			// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  			{  				DebugLocation (132' 4);  				Match (input' TRUE' Follow._TRUE_in_filterExpr271);  				DebugLocation (133' 4);  				filterNode = new Value (true);  			}  			break;  		case 8:  			DebugEnterAlt (8);  			// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  			{  				DebugLocation (136' 4);  				Match (input' FALSE' Follow._FALSE_in_filterExpr281);  				DebugLocation (137' 4);  				filterNode = new Value (false);  			}  			break;  		case 9:  			DebugEnterAlt (9);  			// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  			{  				DebugLocation (140' 4);  				Match (input' NULL' Follow._NULL_in_filterExpr291);  				DebugLocation (141' 4);  				filterNode = new Value (null);  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("filterExpr"' 6);  		LeaveRule ("filterExpr"' 6);  		LeaveRule_filterExpr ();  	}  	DebugLocation (144' 1);  }  finally {  	DebugExitRule (GrammarFileName' "filterExpr");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "filterExpr");  	DebugLocation (60' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  		int alt9 = 9;  		try {  			DebugEnterDecision (9' false);  			switch (input.LA (1)) {  			case CHAIN_OPERATOR:  			case COMPARATOR:  				{  					alt9 = 1;  				}  				break;  			case EXPR:  				{  					int LA9_2 = input.LA (2);  					if ((LA9_2 == DOWN)) {  						int LA9_3 = input.LA (3);  						if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  							alt9 = 2;  						}  						else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  							alt9 = 3;  						}  						else {  							NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  							DebugRecognitionException (nvae);  							throw nvae;  						}  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				break;  			case STRING:  				{  					alt9 = 4;  				}  				break;  			case REGEX:  				{  					alt9 = 5;  				}  				break;  			case NUMBER:  				{  					alt9 = 6;  				}  				break;  			case TRUE:  				{  					alt9 = 7;  				}  				break;  			case FALSE:  				{  					alt9 = 8;  				}  				break;  			case NULL:  				{  					alt9 = 9;  				}  				break;  			default: {  				NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  			}  		}  		finally {  			DebugExitDecision (9);  		}  		switch (alt9) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  			{  				DebugLocation (64' 4);  				DebugLocation (64' 6);  				PushFollow (Follow._comparator_in_filterExpr175);  				comparator6 = comparator ();  				PopFollow ();  				Match (input' TokenTypes.Down' null);  				DebugLocation (64' 18);  				PushFollow (Follow._filterExpr_in_filterExpr179);  				a = filterExpr ();  				PopFollow ();  				DebugLocation (64' 31);  				PushFollow (Follow._filterExpr_in_filterExpr183);  				b = filterExpr ();  				PopFollow ();  				Match (input' TokenTypes.Up' null);  				DebugLocation (65' 4);  				Comparator newComparator;  				switch (comparator6) {  				case "=":  					newComparator = Comparator.Equals;  					break;  				case "!=":  					newComparator = Comparator.NotEquals;  					break;  				case ">":  					newComparator = Comparator.Greater;  					break;  				case "<":  					newComparator = Comparator.Less;  					break;  				case ">=":  					newComparator = Comparator.GreaterOrEqual;  					break;  				case "<=":  					newComparator = Comparator.LessOrEqual;  					break;  				case "&":  					newComparator = Comparator.And;  					break;  				case "|":  					newComparator = Comparator.Or;  					break;  				default:  					newComparator = Comparator.Equals;  					break;  				}  				filterNode = new BoolExpression (a' newComparator' b);  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  			{  				DebugLocation (98' 4);  				DebugLocation (98' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr195);  				Match (input' TokenTypes.Down' null);  				DebugLocation (98' 12);  				PushFollow (Follow._filterExpr_in_filterExpr199);  				f = filterExpr ();  				PopFollow ();  				DebugLocation (98' 31);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  				int alt6 = 2;  				try {  					DebugEnterSubRule (6);  					try {  						DebugEnterDecision (6' false);  						int LA6_1 = input.LA (1);  						if ((LA6_1 == 24)) {  							alt6 = 1;  						}  					}  					finally {  						DebugExitDecision (6);  					}  					switch (alt6) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  						{  							DebugLocation (98' 31);  							inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (6);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (99' 4);  				FilterTreeNode newNode = f;  				if ((inverse != null ? inverse.Text : default(string)) == "!")  					newNode.ToggleInversed ();  				filterNode = newNode;  			}  			break;  		case 3:  			DebugEnterAlt (3);  			// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  			{  				DebugLocation (105' 4);  				DebugLocation (105' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr216);  				Match (input' TokenTypes.Down' null);  				DebugLocation (105' 12);  				PushFollow (Follow._propertyChain_in_filterExpr219);  				propertyChain (propertySegments);  				PopFollow ();  				DebugLocation (105' 51);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  				int alt7 = 2;  				try {  					DebugEnterSubRule (7);  					try {  						DebugEnterDecision (7' false);  						int LA7_1 = input.LA (1);  						if ((LA7_1 == 31)) {  							alt7 = 1;  						}  					}  					finally {  						DebugExitDecision (7);  					}  					switch (alt7) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  						{  							DebugLocation (105' 51);  							inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (7);  				}  				DebugLocation (105' 60);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  				int alt8 = 2;  				try {  					DebugEnterSubRule (8);  					try {  						DebugEnterDecision (8' false);  						int LA8_1 = input.LA (1);  						if ((LA8_1 == 24)) {  							alt8 = 1;  						}  					}  					finally {  						DebugExitDecision (8);  					}  					switch (alt8) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  						{  							DebugLocation (105' 60);  							not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (8);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (106' 4);  				FilterTreeNode newProperty = new Property (propertySegments);  				if ((inverse != null ? inverse.Text : default(string)) == "?")  					filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  				else {  					if ((not != null ? not.Text : default(string)) == "!")  						newProperty.ToggleInversed ();  					filterNode = newProperty;  				}  			}  			break;  		case 4:  			DebugEnterAlt (4);  			// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  			{  				DebugLocation (116' 4);  				STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  				DebugLocation (117' 4);  				string stringText = (STRING7 != null ? STRING7.Text : default(string));  				stringText = stringText.Substring (1' stringText.Length - 2);  				filterNode = new Value (stringText);  			}  			break;  		case 5:  			DebugEnterAlt (5);  			// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  			{  				DebugLocation (122' 4);  				REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  				DebugLocation (123' 4);  				string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  				regexText = regexText.Substring (1' regexText.Length - 2);  				filterNode = new RegExp (regexText);  			}  			break;  		case 6:  			DebugEnterAlt (6);  			// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  			{  				DebugLocation (128' 4);  				NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  				DebugLocation (129' 4);  				filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  			}  			break;  		case 7:  			DebugEnterAlt (7);  			// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  			{  				DebugLocation (132' 4);  				Match (input' TRUE' Follow._TRUE_in_filterExpr271);  				DebugLocation (133' 4);  				filterNode = new Value (true);  			}  			break;  		case 8:  			DebugEnterAlt (8);  			// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  			{  				DebugLocation (136' 4);  				Match (input' FALSE' Follow._FALSE_in_filterExpr281);  				DebugLocation (137' 4);  				filterNode = new Value (false);  			}  			break;  		case 9:  			DebugEnterAlt (9);  			// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  			{  				DebugLocation (140' 4);  				Match (input' NULL' Follow._NULL_in_filterExpr291);  				DebugLocation (141' 4);  				filterNode = new Value (null);  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("filterExpr"' 6);  		LeaveRule ("filterExpr"' 6);  		LeaveRule_filterExpr ();  	}  	DebugLocation (144' 1);  }  finally {  	DebugExitRule (GrammarFileName' "filterExpr");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "filterExpr");  	DebugLocation (60' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  		int alt9 = 9;  		try {  			DebugEnterDecision (9' false);  			switch (input.LA (1)) {  			case CHAIN_OPERATOR:  			case COMPARATOR:  				{  					alt9 = 1;  				}  				break;  			case EXPR:  				{  					int LA9_2 = input.LA (2);  					if ((LA9_2 == DOWN)) {  						int LA9_3 = input.LA (3);  						if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  							alt9 = 2;  						}  						else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  							alt9 = 3;  						}  						else {  							NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  							DebugRecognitionException (nvae);  							throw nvae;  						}  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				break;  			case STRING:  				{  					alt9 = 4;  				}  				break;  			case REGEX:  				{  					alt9 = 5;  				}  				break;  			case NUMBER:  				{  					alt9 = 6;  				}  				break;  			case TRUE:  				{  					alt9 = 7;  				}  				break;  			case FALSE:  				{  					alt9 = 8;  				}  				break;  			case NULL:  				{  					alt9 = 9;  				}  				break;  			default: {  				NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  			}  		}  		finally {  			DebugExitDecision (9);  		}  		switch (alt9) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  			{  				DebugLocation (64' 4);  				DebugLocation (64' 6);  				PushFollow (Follow._comparator_in_filterExpr175);  				comparator6 = comparator ();  				PopFollow ();  				Match (input' TokenTypes.Down' null);  				DebugLocation (64' 18);  				PushFollow (Follow._filterExpr_in_filterExpr179);  				a = filterExpr ();  				PopFollow ();  				DebugLocation (64' 31);  				PushFollow (Follow._filterExpr_in_filterExpr183);  				b = filterExpr ();  				PopFollow ();  				Match (input' TokenTypes.Up' null);  				DebugLocation (65' 4);  				Comparator newComparator;  				switch (comparator6) {  				case "=":  					newComparator = Comparator.Equals;  					break;  				case "!=":  					newComparator = Comparator.NotEquals;  					break;  				case ">":  					newComparator = Comparator.Greater;  					break;  				case "<":  					newComparator = Comparator.Less;  					break;  				case ">=":  					newComparator = Comparator.GreaterOrEqual;  					break;  				case "<=":  					newComparator = Comparator.LessOrEqual;  					break;  				case "&":  					newComparator = Comparator.And;  					break;  				case "|":  					newComparator = Comparator.Or;  					break;  				default:  					newComparator = Comparator.Equals;  					break;  				}  				filterNode = new BoolExpression (a' newComparator' b);  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  			{  				DebugLocation (98' 4);  				DebugLocation (98' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr195);  				Match (input' TokenTypes.Down' null);  				DebugLocation (98' 12);  				PushFollow (Follow._filterExpr_in_filterExpr199);  				f = filterExpr ();  				PopFollow ();  				DebugLocation (98' 31);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  				int alt6 = 2;  				try {  					DebugEnterSubRule (6);  					try {  						DebugEnterDecision (6' false);  						int LA6_1 = input.LA (1);  						if ((LA6_1 == 24)) {  							alt6 = 1;  						}  					}  					finally {  						DebugExitDecision (6);  					}  					switch (alt6) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  						{  							DebugLocation (98' 31);  							inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (6);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (99' 4);  				FilterTreeNode newNode = f;  				if ((inverse != null ? inverse.Text : default(string)) == "!")  					newNode.ToggleInversed ();  				filterNode = newNode;  			}  			break;  		case 3:  			DebugEnterAlt (3);  			// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  			{  				DebugLocation (105' 4);  				DebugLocation (105' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr216);  				Match (input' TokenTypes.Down' null);  				DebugLocation (105' 12);  				PushFollow (Follow._propertyChain_in_filterExpr219);  				propertyChain (propertySegments);  				PopFollow ();  				DebugLocation (105' 51);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  				int alt7 = 2;  				try {  					DebugEnterSubRule (7);  					try {  						DebugEnterDecision (7' false);  						int LA7_1 = input.LA (1);  						if ((LA7_1 == 31)) {  							alt7 = 1;  						}  					}  					finally {  						DebugExitDecision (7);  					}  					switch (alt7) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  						{  							DebugLocation (105' 51);  							inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (7);  				}  				DebugLocation (105' 60);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  				int alt8 = 2;  				try {  					DebugEnterSubRule (8);  					try {  						DebugEnterDecision (8' false);  						int LA8_1 = input.LA (1);  						if ((LA8_1 == 24)) {  							alt8 = 1;  						}  					}  					finally {  						DebugExitDecision (8);  					}  					switch (alt8) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  						{  							DebugLocation (105' 60);  							not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (8);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (106' 4);  				FilterTreeNode newProperty = new Property (propertySegments);  				if ((inverse != null ? inverse.Text : default(string)) == "?")  					filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  				else {  					if ((not != null ? not.Text : default(string)) == "!")  						newProperty.ToggleInversed ();  					filterNode = newProperty;  				}  			}  			break;  		case 4:  			DebugEnterAlt (4);  			// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  			{  				DebugLocation (116' 4);  				STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  				DebugLocation (117' 4);  				string stringText = (STRING7 != null ? STRING7.Text : default(string));  				stringText = stringText.Substring (1' stringText.Length - 2);  				filterNode = new Value (stringText);  			}  			break;  		case 5:  			DebugEnterAlt (5);  			// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  			{  				DebugLocation (122' 4);  				REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  				DebugLocation (123' 4);  				string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  				regexText = regexText.Substring (1' regexText.Length - 2);  				filterNode = new RegExp (regexText);  			}  			break;  		case 6:  			DebugEnterAlt (6);  			// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  			{  				DebugLocation (128' 4);  				NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  				DebugLocation (129' 4);  				filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  			}  			break;  		case 7:  			DebugEnterAlt (7);  			// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  			{  				DebugLocation (132' 4);  				Match (input' TRUE' Follow._TRUE_in_filterExpr271);  				DebugLocation (133' 4);  				filterNode = new Value (true);  			}  			break;  		case 8:  			DebugEnterAlt (8);  			// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  			{  				DebugLocation (136' 4);  				Match (input' FALSE' Follow._FALSE_in_filterExpr281);  				DebugLocation (137' 4);  				filterNode = new Value (false);  			}  			break;  		case 9:  			DebugEnterAlt (9);  			// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  			{  				DebugLocation (140' 4);  				Match (input' NULL' Follow._NULL_in_filterExpr291);  				DebugLocation (141' 4);  				filterNode = new Value (null);  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("filterExpr"' 6);  		LeaveRule ("filterExpr"' 6);  		LeaveRule_filterExpr ();  	}  	DebugLocation (144' 1);  }  finally {  	DebugExitRule (GrammarFileName' "filterExpr");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "filterExpr");  	DebugLocation (60' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  		int alt9 = 9;  		try {  			DebugEnterDecision (9' false);  			switch (input.LA (1)) {  			case CHAIN_OPERATOR:  			case COMPARATOR:  				{  					alt9 = 1;  				}  				break;  			case EXPR:  				{  					int LA9_2 = input.LA (2);  					if ((LA9_2 == DOWN)) {  						int LA9_3 = input.LA (3);  						if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  							alt9 = 2;  						}  						else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  							alt9 = 3;  						}  						else {  							NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  							DebugRecognitionException (nvae);  							throw nvae;  						}  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				break;  			case STRING:  				{  					alt9 = 4;  				}  				break;  			case REGEX:  				{  					alt9 = 5;  				}  				break;  			case NUMBER:  				{  					alt9 = 6;  				}  				break;  			case TRUE:  				{  					alt9 = 7;  				}  				break;  			case FALSE:  				{  					alt9 = 8;  				}  				break;  			case NULL:  				{  					alt9 = 9;  				}  				break;  			default: {  				NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  			}  		}  		finally {  			DebugExitDecision (9);  		}  		switch (alt9) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  			{  				DebugLocation (64' 4);  				DebugLocation (64' 6);  				PushFollow (Follow._comparator_in_filterExpr175);  				comparator6 = comparator ();  				PopFollow ();  				Match (input' TokenTypes.Down' null);  				DebugLocation (64' 18);  				PushFollow (Follow._filterExpr_in_filterExpr179);  				a = filterExpr ();  				PopFollow ();  				DebugLocation (64' 31);  				PushFollow (Follow._filterExpr_in_filterExpr183);  				b = filterExpr ();  				PopFollow ();  				Match (input' TokenTypes.Up' null);  				DebugLocation (65' 4);  				Comparator newComparator;  				switch (comparator6) {  				case "=":  					newComparator = Comparator.Equals;  					break;  				case "!=":  					newComparator = Comparator.NotEquals;  					break;  				case ">":  					newComparator = Comparator.Greater;  					break;  				case "<":  					newComparator = Comparator.Less;  					break;  				case ">=":  					newComparator = Comparator.GreaterOrEqual;  					break;  				case "<=":  					newComparator = Comparator.LessOrEqual;  					break;  				case "&":  					newComparator = Comparator.And;  					break;  				case "|":  					newComparator = Comparator.Or;  					break;  				default:  					newComparator = Comparator.Equals;  					break;  				}  				filterNode = new BoolExpression (a' newComparator' b);  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  			{  				DebugLocation (98' 4);  				DebugLocation (98' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr195);  				Match (input' TokenTypes.Down' null);  				DebugLocation (98' 12);  				PushFollow (Follow._filterExpr_in_filterExpr199);  				f = filterExpr ();  				PopFollow ();  				DebugLocation (98' 31);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  				int alt6 = 2;  				try {  					DebugEnterSubRule (6);  					try {  						DebugEnterDecision (6' false);  						int LA6_1 = input.LA (1);  						if ((LA6_1 == 24)) {  							alt6 = 1;  						}  					}  					finally {  						DebugExitDecision (6);  					}  					switch (alt6) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  						{  							DebugLocation (98' 31);  							inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (6);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (99' 4);  				FilterTreeNode newNode = f;  				if ((inverse != null ? inverse.Text : default(string)) == "!")  					newNode.ToggleInversed ();  				filterNode = newNode;  			}  			break;  		case 3:  			DebugEnterAlt (3);  			// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  			{  				DebugLocation (105' 4);  				DebugLocation (105' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr216);  				Match (input' TokenTypes.Down' null);  				DebugLocation (105' 12);  				PushFollow (Follow._propertyChain_in_filterExpr219);  				propertyChain (propertySegments);  				PopFollow ();  				DebugLocation (105' 51);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  				int alt7 = 2;  				try {  					DebugEnterSubRule (7);  					try {  						DebugEnterDecision (7' false);  						int LA7_1 = input.LA (1);  						if ((LA7_1 == 31)) {  							alt7 = 1;  						}  					}  					finally {  						DebugExitDecision (7);  					}  					switch (alt7) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  						{  							DebugLocation (105' 51);  							inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (7);  				}  				DebugLocation (105' 60);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  				int alt8 = 2;  				try {  					DebugEnterSubRule (8);  					try {  						DebugEnterDecision (8' false);  						int LA8_1 = input.LA (1);  						if ((LA8_1 == 24)) {  							alt8 = 1;  						}  					}  					finally {  						DebugExitDecision (8);  					}  					switch (alt8) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  						{  							DebugLocation (105' 60);  							not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (8);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (106' 4);  				FilterTreeNode newProperty = new Property (propertySegments);  				if ((inverse != null ? inverse.Text : default(string)) == "?")  					filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  				else {  					if ((not != null ? not.Text : default(string)) == "!")  						newProperty.ToggleInversed ();  					filterNode = newProperty;  				}  			}  			break;  		case 4:  			DebugEnterAlt (4);  			// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  			{  				DebugLocation (116' 4);  				STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  				DebugLocation (117' 4);  				string stringText = (STRING7 != null ? STRING7.Text : default(string));  				stringText = stringText.Substring (1' stringText.Length - 2);  				filterNode = new Value (stringText);  			}  			break;  		case 5:  			DebugEnterAlt (5);  			// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  			{  				DebugLocation (122' 4);  				REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  				DebugLocation (123' 4);  				string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  				regexText = regexText.Substring (1' regexText.Length - 2);  				filterNode = new RegExp (regexText);  			}  			break;  		case 6:  			DebugEnterAlt (6);  			// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  			{  				DebugLocation (128' 4);  				NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  				DebugLocation (129' 4);  				filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  			}  			break;  		case 7:  			DebugEnterAlt (7);  			// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  			{  				DebugLocation (132' 4);  				Match (input' TRUE' Follow._TRUE_in_filterExpr271);  				DebugLocation (133' 4);  				filterNode = new Value (true);  			}  			break;  		case 8:  			DebugEnterAlt (8);  			// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  			{  				DebugLocation (136' 4);  				Match (input' FALSE' Follow._FALSE_in_filterExpr281);  				DebugLocation (137' 4);  				filterNode = new Value (false);  			}  			break;  		case 9:  			DebugEnterAlt (9);  			// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  			{  				DebugLocation (140' 4);  				Match (input' NULL' Follow._NULL_in_filterExpr291);  				DebugLocation (141' 4);  				filterNode = new Value (null);  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("filterExpr"' 6);  		LeaveRule ("filterExpr"' 6);  		LeaveRule_filterExpr ();  	}  	DebugLocation (144' 1);  }  finally {  	DebugExitRule (GrammarFileName' "filterExpr");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "filterExpr");  	DebugLocation (60' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  		int alt9 = 9;  		try {  			DebugEnterDecision (9' false);  			switch (input.LA (1)) {  			case CHAIN_OPERATOR:  			case COMPARATOR:  				{  					alt9 = 1;  				}  				break;  			case EXPR:  				{  					int LA9_2 = input.LA (2);  					if ((LA9_2 == DOWN)) {  						int LA9_3 = input.LA (3);  						if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  							alt9 = 2;  						}  						else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  							alt9 = 3;  						}  						else {  							NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  							DebugRecognitionException (nvae);  							throw nvae;  						}  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				break;  			case STRING:  				{  					alt9 = 4;  				}  				break;  			case REGEX:  				{  					alt9 = 5;  				}  				break;  			case NUMBER:  				{  					alt9 = 6;  				}  				break;  			case TRUE:  				{  					alt9 = 7;  				}  				break;  			case FALSE:  				{  					alt9 = 8;  				}  				break;  			case NULL:  				{  					alt9 = 9;  				}  				break;  			default: {  				NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  			}  		}  		finally {  			DebugExitDecision (9);  		}  		switch (alt9) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  			{  				DebugLocation (64' 4);  				DebugLocation (64' 6);  				PushFollow (Follow._comparator_in_filterExpr175);  				comparator6 = comparator ();  				PopFollow ();  				Match (input' TokenTypes.Down' null);  				DebugLocation (64' 18);  				PushFollow (Follow._filterExpr_in_filterExpr179);  				a = filterExpr ();  				PopFollow ();  				DebugLocation (64' 31);  				PushFollow (Follow._filterExpr_in_filterExpr183);  				b = filterExpr ();  				PopFollow ();  				Match (input' TokenTypes.Up' null);  				DebugLocation (65' 4);  				Comparator newComparator;  				switch (comparator6) {  				case "=":  					newComparator = Comparator.Equals;  					break;  				case "!=":  					newComparator = Comparator.NotEquals;  					break;  				case ">":  					newComparator = Comparator.Greater;  					break;  				case "<":  					newComparator = Comparator.Less;  					break;  				case ">=":  					newComparator = Comparator.GreaterOrEqual;  					break;  				case "<=":  					newComparator = Comparator.LessOrEqual;  					break;  				case "&":  					newComparator = Comparator.And;  					break;  				case "|":  					newComparator = Comparator.Or;  					break;  				default:  					newComparator = Comparator.Equals;  					break;  				}  				filterNode = new BoolExpression (a' newComparator' b);  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  			{  				DebugLocation (98' 4);  				DebugLocation (98' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr195);  				Match (input' TokenTypes.Down' null);  				DebugLocation (98' 12);  				PushFollow (Follow._filterExpr_in_filterExpr199);  				f = filterExpr ();  				PopFollow ();  				DebugLocation (98' 31);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  				int alt6 = 2;  				try {  					DebugEnterSubRule (6);  					try {  						DebugEnterDecision (6' false);  						int LA6_1 = input.LA (1);  						if ((LA6_1 == 24)) {  							alt6 = 1;  						}  					}  					finally {  						DebugExitDecision (6);  					}  					switch (alt6) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  						{  							DebugLocation (98' 31);  							inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (6);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (99' 4);  				FilterTreeNode newNode = f;  				if ((inverse != null ? inverse.Text : default(string)) == "!")  					newNode.ToggleInversed ();  				filterNode = newNode;  			}  			break;  		case 3:  			DebugEnterAlt (3);  			// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  			{  				DebugLocation (105' 4);  				DebugLocation (105' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr216);  				Match (input' TokenTypes.Down' null);  				DebugLocation (105' 12);  				PushFollow (Follow._propertyChain_in_filterExpr219);  				propertyChain (propertySegments);  				PopFollow ();  				DebugLocation (105' 51);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  				int alt7 = 2;  				try {  					DebugEnterSubRule (7);  					try {  						DebugEnterDecision (7' false);  						int LA7_1 = input.LA (1);  						if ((LA7_1 == 31)) {  							alt7 = 1;  						}  					}  					finally {  						DebugExitDecision (7);  					}  					switch (alt7) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  						{  							DebugLocation (105' 51);  							inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (7);  				}  				DebugLocation (105' 60);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  				int alt8 = 2;  				try {  					DebugEnterSubRule (8);  					try {  						DebugEnterDecision (8' false);  						int LA8_1 = input.LA (1);  						if ((LA8_1 == 24)) {  							alt8 = 1;  						}  					}  					finally {  						DebugExitDecision (8);  					}  					switch (alt8) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  						{  							DebugLocation (105' 60);  							not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (8);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (106' 4);  				FilterTreeNode newProperty = new Property (propertySegments);  				if ((inverse != null ? inverse.Text : default(string)) == "?")  					filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  				else {  					if ((not != null ? not.Text : default(string)) == "!")  						newProperty.ToggleInversed ();  					filterNode = newProperty;  				}  			}  			break;  		case 4:  			DebugEnterAlt (4);  			// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  			{  				DebugLocation (116' 4);  				STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  				DebugLocation (117' 4);  				string stringText = (STRING7 != null ? STRING7.Text : default(string));  				stringText = stringText.Substring (1' stringText.Length - 2);  				filterNode = new Value (stringText);  			}  			break;  		case 5:  			DebugEnterAlt (5);  			// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  			{  				DebugLocation (122' 4);  				REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  				DebugLocation (123' 4);  				string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  				regexText = regexText.Substring (1' regexText.Length - 2);  				filterNode = new RegExp (regexText);  			}  			break;  		case 6:  			DebugEnterAlt (6);  			// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  			{  				DebugLocation (128' 4);  				NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  				DebugLocation (129' 4);  				filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  			}  			break;  		case 7:  			DebugEnterAlt (7);  			// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  			{  				DebugLocation (132' 4);  				Match (input' TRUE' Follow._TRUE_in_filterExpr271);  				DebugLocation (133' 4);  				filterNode = new Value (true);  			}  			break;  		case 8:  			DebugEnterAlt (8);  			// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  			{  				DebugLocation (136' 4);  				Match (input' FALSE' Follow._FALSE_in_filterExpr281);  				DebugLocation (137' 4);  				filterNode = new Value (false);  			}  			break;  		case 9:  			DebugEnterAlt (9);  			// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  			{  				DebugLocation (140' 4);  				Match (input' NULL' Follow._NULL_in_filterExpr291);  				DebugLocation (141' 4);  				filterNode = new Value (null);  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("filterExpr"' 6);  		LeaveRule ("filterExpr"' 6);  		LeaveRule_filterExpr ();  	}  	DebugLocation (144' 1);  }  finally {  	DebugExitRule (GrammarFileName' "filterExpr");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "filterExpr");  	DebugLocation (60' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  		int alt9 = 9;  		try {  			DebugEnterDecision (9' false);  			switch (input.LA (1)) {  			case CHAIN_OPERATOR:  			case COMPARATOR:  				{  					alt9 = 1;  				}  				break;  			case EXPR:  				{  					int LA9_2 = input.LA (2);  					if ((LA9_2 == DOWN)) {  						int LA9_3 = input.LA (3);  						if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  							alt9 = 2;  						}  						else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  							alt9 = 3;  						}  						else {  							NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  							DebugRecognitionException (nvae);  							throw nvae;  						}  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				break;  			case STRING:  				{  					alt9 = 4;  				}  				break;  			case REGEX:  				{  					alt9 = 5;  				}  				break;  			case NUMBER:  				{  					alt9 = 6;  				}  				break;  			case TRUE:  				{  					alt9 = 7;  				}  				break;  			case FALSE:  				{  					alt9 = 8;  				}  				break;  			case NULL:  				{  					alt9 = 9;  				}  				break;  			default: {  				NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  			}  		}  		finally {  			DebugExitDecision (9);  		}  		switch (alt9) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  			{  				DebugLocation (64' 4);  				DebugLocation (64' 6);  				PushFollow (Follow._comparator_in_filterExpr175);  				comparator6 = comparator ();  				PopFollow ();  				Match (input' TokenTypes.Down' null);  				DebugLocation (64' 18);  				PushFollow (Follow._filterExpr_in_filterExpr179);  				a = filterExpr ();  				PopFollow ();  				DebugLocation (64' 31);  				PushFollow (Follow._filterExpr_in_filterExpr183);  				b = filterExpr ();  				PopFollow ();  				Match (input' TokenTypes.Up' null);  				DebugLocation (65' 4);  				Comparator newComparator;  				switch (comparator6) {  				case "=":  					newComparator = Comparator.Equals;  					break;  				case "!=":  					newComparator = Comparator.NotEquals;  					break;  				case ">":  					newComparator = Comparator.Greater;  					break;  				case "<":  					newComparator = Comparator.Less;  					break;  				case ">=":  					newComparator = Comparator.GreaterOrEqual;  					break;  				case "<=":  					newComparator = Comparator.LessOrEqual;  					break;  				case "&":  					newComparator = Comparator.And;  					break;  				case "|":  					newComparator = Comparator.Or;  					break;  				default:  					newComparator = Comparator.Equals;  					break;  				}  				filterNode = new BoolExpression (a' newComparator' b);  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  			{  				DebugLocation (98' 4);  				DebugLocation (98' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr195);  				Match (input' TokenTypes.Down' null);  				DebugLocation (98' 12);  				PushFollow (Follow._filterExpr_in_filterExpr199);  				f = filterExpr ();  				PopFollow ();  				DebugLocation (98' 31);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  				int alt6 = 2;  				try {  					DebugEnterSubRule (6);  					try {  						DebugEnterDecision (6' false);  						int LA6_1 = input.LA (1);  						if ((LA6_1 == 24)) {  							alt6 = 1;  						}  					}  					finally {  						DebugExitDecision (6);  					}  					switch (alt6) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  						{  							DebugLocation (98' 31);  							inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (6);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (99' 4);  				FilterTreeNode newNode = f;  				if ((inverse != null ? inverse.Text : default(string)) == "!")  					newNode.ToggleInversed ();  				filterNode = newNode;  			}  			break;  		case 3:  			DebugEnterAlt (3);  			// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  			{  				DebugLocation (105' 4);  				DebugLocation (105' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr216);  				Match (input' TokenTypes.Down' null);  				DebugLocation (105' 12);  				PushFollow (Follow._propertyChain_in_filterExpr219);  				propertyChain (propertySegments);  				PopFollow ();  				DebugLocation (105' 51);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  				int alt7 = 2;  				try {  					DebugEnterSubRule (7);  					try {  						DebugEnterDecision (7' false);  						int LA7_1 = input.LA (1);  						if ((LA7_1 == 31)) {  							alt7 = 1;  						}  					}  					finally {  						DebugExitDecision (7);  					}  					switch (alt7) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  						{  							DebugLocation (105' 51);  							inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (7);  				}  				DebugLocation (105' 60);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  				int alt8 = 2;  				try {  					DebugEnterSubRule (8);  					try {  						DebugEnterDecision (8' false);  						int LA8_1 = input.LA (1);  						if ((LA8_1 == 24)) {  							alt8 = 1;  						}  					}  					finally {  						DebugExitDecision (8);  					}  					switch (alt8) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  						{  							DebugLocation (105' 60);  							not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (8);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (106' 4);  				FilterTreeNode newProperty = new Property (propertySegments);  				if ((inverse != null ? inverse.Text : default(string)) == "?")  					filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  				else {  					if ((not != null ? not.Text : default(string)) == "!")  						newProperty.ToggleInversed ();  					filterNode = newProperty;  				}  			}  			break;  		case 4:  			DebugEnterAlt (4);  			// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  			{  				DebugLocation (116' 4);  				STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  				DebugLocation (117' 4);  				string stringText = (STRING7 != null ? STRING7.Text : default(string));  				stringText = stringText.Substring (1' stringText.Length - 2);  				filterNode = new Value (stringText);  			}  			break;  		case 5:  			DebugEnterAlt (5);  			// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  			{  				DebugLocation (122' 4);  				REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  				DebugLocation (123' 4);  				string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  				regexText = regexText.Substring (1' regexText.Length - 2);  				filterNode = new RegExp (regexText);  			}  			break;  		case 6:  			DebugEnterAlt (6);  			// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  			{  				DebugLocation (128' 4);  				NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  				DebugLocation (129' 4);  				filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  			}  			break;  		case 7:  			DebugEnterAlt (7);  			// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  			{  				DebugLocation (132' 4);  				Match (input' TRUE' Follow._TRUE_in_filterExpr271);  				DebugLocation (133' 4);  				filterNode = new Value (true);  			}  			break;  		case 8:  			DebugEnterAlt (8);  			// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  			{  				DebugLocation (136' 4);  				Match (input' FALSE' Follow._FALSE_in_filterExpr281);  				DebugLocation (137' 4);  				filterNode = new Value (false);  			}  			break;  		case 9:  			DebugEnterAlt (9);  			// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  			{  				DebugLocation (140' 4);  				Match (input' NULL' Follow._NULL_in_filterExpr291);  				DebugLocation (141' 4);  				filterNode = new Value (null);  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("filterExpr"' 6);  		LeaveRule ("filterExpr"' 6);  		LeaveRule_filterExpr ();  	}  	DebugLocation (144' 1);  }  finally {  	DebugExitRule (GrammarFileName' "filterExpr");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "filterExpr");  	DebugLocation (60' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  		int alt9 = 9;  		try {  			DebugEnterDecision (9' false);  			switch (input.LA (1)) {  			case CHAIN_OPERATOR:  			case COMPARATOR:  				{  					alt9 = 1;  				}  				break;  			case EXPR:  				{  					int LA9_2 = input.LA (2);  					if ((LA9_2 == DOWN)) {  						int LA9_3 = input.LA (3);  						if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  							alt9 = 2;  						}  						else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  							alt9 = 3;  						}  						else {  							NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  							DebugRecognitionException (nvae);  							throw nvae;  						}  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				break;  			case STRING:  				{  					alt9 = 4;  				}  				break;  			case REGEX:  				{  					alt9 = 5;  				}  				break;  			case NUMBER:  				{  					alt9 = 6;  				}  				break;  			case TRUE:  				{  					alt9 = 7;  				}  				break;  			case FALSE:  				{  					alt9 = 8;  				}  				break;  			case NULL:  				{  					alt9 = 9;  				}  				break;  			default: {  				NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  			}  		}  		finally {  			DebugExitDecision (9);  		}  		switch (alt9) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  			{  				DebugLocation (64' 4);  				DebugLocation (64' 6);  				PushFollow (Follow._comparator_in_filterExpr175);  				comparator6 = comparator ();  				PopFollow ();  				Match (input' TokenTypes.Down' null);  				DebugLocation (64' 18);  				PushFollow (Follow._filterExpr_in_filterExpr179);  				a = filterExpr ();  				PopFollow ();  				DebugLocation (64' 31);  				PushFollow (Follow._filterExpr_in_filterExpr183);  				b = filterExpr ();  				PopFollow ();  				Match (input' TokenTypes.Up' null);  				DebugLocation (65' 4);  				Comparator newComparator;  				switch (comparator6) {  				case "=":  					newComparator = Comparator.Equals;  					break;  				case "!=":  					newComparator = Comparator.NotEquals;  					break;  				case ">":  					newComparator = Comparator.Greater;  					break;  				case "<":  					newComparator = Comparator.Less;  					break;  				case ">=":  					newComparator = Comparator.GreaterOrEqual;  					break;  				case "<=":  					newComparator = Comparator.LessOrEqual;  					break;  				case "&":  					newComparator = Comparator.And;  					break;  				case "|":  					newComparator = Comparator.Or;  					break;  				default:  					newComparator = Comparator.Equals;  					break;  				}  				filterNode = new BoolExpression (a' newComparator' b);  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  			{  				DebugLocation (98' 4);  				DebugLocation (98' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr195);  				Match (input' TokenTypes.Down' null);  				DebugLocation (98' 12);  				PushFollow (Follow._filterExpr_in_filterExpr199);  				f = filterExpr ();  				PopFollow ();  				DebugLocation (98' 31);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  				int alt6 = 2;  				try {  					DebugEnterSubRule (6);  					try {  						DebugEnterDecision (6' false);  						int LA6_1 = input.LA (1);  						if ((LA6_1 == 24)) {  							alt6 = 1;  						}  					}  					finally {  						DebugExitDecision (6);  					}  					switch (alt6) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  						{  							DebugLocation (98' 31);  							inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (6);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (99' 4);  				FilterTreeNode newNode = f;  				if ((inverse != null ? inverse.Text : default(string)) == "!")  					newNode.ToggleInversed ();  				filterNode = newNode;  			}  			break;  		case 3:  			DebugEnterAlt (3);  			// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  			{  				DebugLocation (105' 4);  				DebugLocation (105' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr216);  				Match (input' TokenTypes.Down' null);  				DebugLocation (105' 12);  				PushFollow (Follow._propertyChain_in_filterExpr219);  				propertyChain (propertySegments);  				PopFollow ();  				DebugLocation (105' 51);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  				int alt7 = 2;  				try {  					DebugEnterSubRule (7);  					try {  						DebugEnterDecision (7' false);  						int LA7_1 = input.LA (1);  						if ((LA7_1 == 31)) {  							alt7 = 1;  						}  					}  					finally {  						DebugExitDecision (7);  					}  					switch (alt7) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  						{  							DebugLocation (105' 51);  							inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (7);  				}  				DebugLocation (105' 60);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  				int alt8 = 2;  				try {  					DebugEnterSubRule (8);  					try {  						DebugEnterDecision (8' false);  						int LA8_1 = input.LA (1);  						if ((LA8_1 == 24)) {  							alt8 = 1;  						}  					}  					finally {  						DebugExitDecision (8);  					}  					switch (alt8) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  						{  							DebugLocation (105' 60);  							not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (8);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (106' 4);  				FilterTreeNode newProperty = new Property (propertySegments);  				if ((inverse != null ? inverse.Text : default(string)) == "?")  					filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  				else {  					if ((not != null ? not.Text : default(string)) == "!")  						newProperty.ToggleInversed ();  					filterNode = newProperty;  				}  			}  			break;  		case 4:  			DebugEnterAlt (4);  			// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  			{  				DebugLocation (116' 4);  				STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  				DebugLocation (117' 4);  				string stringText = (STRING7 != null ? STRING7.Text : default(string));  				stringText = stringText.Substring (1' stringText.Length - 2);  				filterNode = new Value (stringText);  			}  			break;  		case 5:  			DebugEnterAlt (5);  			// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  			{  				DebugLocation (122' 4);  				REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  				DebugLocation (123' 4);  				string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  				regexText = regexText.Substring (1' regexText.Length - 2);  				filterNode = new RegExp (regexText);  			}  			break;  		case 6:  			DebugEnterAlt (6);  			// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  			{  				DebugLocation (128' 4);  				NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  				DebugLocation (129' 4);  				filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  			}  			break;  		case 7:  			DebugEnterAlt (7);  			// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  			{  				DebugLocation (132' 4);  				Match (input' TRUE' Follow._TRUE_in_filterExpr271);  				DebugLocation (133' 4);  				filterNode = new Value (true);  			}  			break;  		case 8:  			DebugEnterAlt (8);  			// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  			{  				DebugLocation (136' 4);  				Match (input' FALSE' Follow._FALSE_in_filterExpr281);  				DebugLocation (137' 4);  				filterNode = new Value (false);  			}  			break;  		case 9:  			DebugEnterAlt (9);  			// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  			{  				DebugLocation (140' 4);  				Match (input' NULL' Follow._NULL_in_filterExpr291);  				DebugLocation (141' 4);  				filterNode = new Value (null);  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("filterExpr"' 6);  		LeaveRule ("filterExpr"' 6);  		LeaveRule_filterExpr ();  	}  	DebugLocation (144' 1);  }  finally {  	DebugExitRule (GrammarFileName' "filterExpr");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "filterExpr");  	DebugLocation (60' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  		int alt9 = 9;  		try {  			DebugEnterDecision (9' false);  			switch (input.LA (1)) {  			case CHAIN_OPERATOR:  			case COMPARATOR:  				{  					alt9 = 1;  				}  				break;  			case EXPR:  				{  					int LA9_2 = input.LA (2);  					if ((LA9_2 == DOWN)) {  						int LA9_3 = input.LA (3);  						if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  							alt9 = 2;  						}  						else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  							alt9 = 3;  						}  						else {  							NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  							DebugRecognitionException (nvae);  							throw nvae;  						}  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				break;  			case STRING:  				{  					alt9 = 4;  				}  				break;  			case REGEX:  				{  					alt9 = 5;  				}  				break;  			case NUMBER:  				{  					alt9 = 6;  				}  				break;  			case TRUE:  				{  					alt9 = 7;  				}  				break;  			case FALSE:  				{  					alt9 = 8;  				}  				break;  			case NULL:  				{  					alt9 = 9;  				}  				break;  			default: {  				NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  			}  		}  		finally {  			DebugExitDecision (9);  		}  		switch (alt9) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  			{  				DebugLocation (64' 4);  				DebugLocation (64' 6);  				PushFollow (Follow._comparator_in_filterExpr175);  				comparator6 = comparator ();  				PopFollow ();  				Match (input' TokenTypes.Down' null);  				DebugLocation (64' 18);  				PushFollow (Follow._filterExpr_in_filterExpr179);  				a = filterExpr ();  				PopFollow ();  				DebugLocation (64' 31);  				PushFollow (Follow._filterExpr_in_filterExpr183);  				b = filterExpr ();  				PopFollow ();  				Match (input' TokenTypes.Up' null);  				DebugLocation (65' 4);  				Comparator newComparator;  				switch (comparator6) {  				case "=":  					newComparator = Comparator.Equals;  					break;  				case "!=":  					newComparator = Comparator.NotEquals;  					break;  				case ">":  					newComparator = Comparator.Greater;  					break;  				case "<":  					newComparator = Comparator.Less;  					break;  				case ">=":  					newComparator = Comparator.GreaterOrEqual;  					break;  				case "<=":  					newComparator = Comparator.LessOrEqual;  					break;  				case "&":  					newComparator = Comparator.And;  					break;  				case "|":  					newComparator = Comparator.Or;  					break;  				default:  					newComparator = Comparator.Equals;  					break;  				}  				filterNode = new BoolExpression (a' newComparator' b);  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  			{  				DebugLocation (98' 4);  				DebugLocation (98' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr195);  				Match (input' TokenTypes.Down' null);  				DebugLocation (98' 12);  				PushFollow (Follow._filterExpr_in_filterExpr199);  				f = filterExpr ();  				PopFollow ();  				DebugLocation (98' 31);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  				int alt6 = 2;  				try {  					DebugEnterSubRule (6);  					try {  						DebugEnterDecision (6' false);  						int LA6_1 = input.LA (1);  						if ((LA6_1 == 24)) {  							alt6 = 1;  						}  					}  					finally {  						DebugExitDecision (6);  					}  					switch (alt6) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  						{  							DebugLocation (98' 31);  							inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (6);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (99' 4);  				FilterTreeNode newNode = f;  				if ((inverse != null ? inverse.Text : default(string)) == "!")  					newNode.ToggleInversed ();  				filterNode = newNode;  			}  			break;  		case 3:  			DebugEnterAlt (3);  			// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  			{  				DebugLocation (105' 4);  				DebugLocation (105' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr216);  				Match (input' TokenTypes.Down' null);  				DebugLocation (105' 12);  				PushFollow (Follow._propertyChain_in_filterExpr219);  				propertyChain (propertySegments);  				PopFollow ();  				DebugLocation (105' 51);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  				int alt7 = 2;  				try {  					DebugEnterSubRule (7);  					try {  						DebugEnterDecision (7' false);  						int LA7_1 = input.LA (1);  						if ((LA7_1 == 31)) {  							alt7 = 1;  						}  					}  					finally {  						DebugExitDecision (7);  					}  					switch (alt7) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  						{  							DebugLocation (105' 51);  							inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (7);  				}  				DebugLocation (105' 60);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  				int alt8 = 2;  				try {  					DebugEnterSubRule (8);  					try {  						DebugEnterDecision (8' false);  						int LA8_1 = input.LA (1);  						if ((LA8_1 == 24)) {  							alt8 = 1;  						}  					}  					finally {  						DebugExitDecision (8);  					}  					switch (alt8) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  						{  							DebugLocation (105' 60);  							not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (8);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (106' 4);  				FilterTreeNode newProperty = new Property (propertySegments);  				if ((inverse != null ? inverse.Text : default(string)) == "?")  					filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  				else {  					if ((not != null ? not.Text : default(string)) == "!")  						newProperty.ToggleInversed ();  					filterNode = newProperty;  				}  			}  			break;  		case 4:  			DebugEnterAlt (4);  			// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  			{  				DebugLocation (116' 4);  				STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  				DebugLocation (117' 4);  				string stringText = (STRING7 != null ? STRING7.Text : default(string));  				stringText = stringText.Substring (1' stringText.Length - 2);  				filterNode = new Value (stringText);  			}  			break;  		case 5:  			DebugEnterAlt (5);  			// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  			{  				DebugLocation (122' 4);  				REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  				DebugLocation (123' 4);  				string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  				regexText = regexText.Substring (1' regexText.Length - 2);  				filterNode = new RegExp (regexText);  			}  			break;  		case 6:  			DebugEnterAlt (6);  			// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  			{  				DebugLocation (128' 4);  				NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  				DebugLocation (129' 4);  				filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  			}  			break;  		case 7:  			DebugEnterAlt (7);  			// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  			{  				DebugLocation (132' 4);  				Match (input' TRUE' Follow._TRUE_in_filterExpr271);  				DebugLocation (133' 4);  				filterNode = new Value (true);  			}  			break;  		case 8:  			DebugEnterAlt (8);  			// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  			{  				DebugLocation (136' 4);  				Match (input' FALSE' Follow._FALSE_in_filterExpr281);  				DebugLocation (137' 4);  				filterNode = new Value (false);  			}  			break;  		case 9:  			DebugEnterAlt (9);  			// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  			{  				DebugLocation (140' 4);  				Match (input' NULL' Follow._NULL_in_filterExpr291);  				DebugLocation (141' 4);  				filterNode = new Value (null);  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("filterExpr"' 6);  		LeaveRule ("filterExpr"' 6);  		LeaveRule_filterExpr ();  	}  	DebugLocation (144' 1);  }  finally {  	DebugExitRule (GrammarFileName' "filterExpr");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "filterExpr");  	DebugLocation (60' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  		int alt9 = 9;  		try {  			DebugEnterDecision (9' false);  			switch (input.LA (1)) {  			case CHAIN_OPERATOR:  			case COMPARATOR:  				{  					alt9 = 1;  				}  				break;  			case EXPR:  				{  					int LA9_2 = input.LA (2);  					if ((LA9_2 == DOWN)) {  						int LA9_3 = input.LA (3);  						if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  							alt9 = 2;  						}  						else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  							alt9 = 3;  						}  						else {  							NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  							DebugRecognitionException (nvae);  							throw nvae;  						}  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				break;  			case STRING:  				{  					alt9 = 4;  				}  				break;  			case REGEX:  				{  					alt9 = 5;  				}  				break;  			case NUMBER:  				{  					alt9 = 6;  				}  				break;  			case TRUE:  				{  					alt9 = 7;  				}  				break;  			case FALSE:  				{  					alt9 = 8;  				}  				break;  			case NULL:  				{  					alt9 = 9;  				}  				break;  			default: {  				NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  			}  		}  		finally {  			DebugExitDecision (9);  		}  		switch (alt9) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  			{  				DebugLocation (64' 4);  				DebugLocation (64' 6);  				PushFollow (Follow._comparator_in_filterExpr175);  				comparator6 = comparator ();  				PopFollow ();  				Match (input' TokenTypes.Down' null);  				DebugLocation (64' 18);  				PushFollow (Follow._filterExpr_in_filterExpr179);  				a = filterExpr ();  				PopFollow ();  				DebugLocation (64' 31);  				PushFollow (Follow._filterExpr_in_filterExpr183);  				b = filterExpr ();  				PopFollow ();  				Match (input' TokenTypes.Up' null);  				DebugLocation (65' 4);  				Comparator newComparator;  				switch (comparator6) {  				case "=":  					newComparator = Comparator.Equals;  					break;  				case "!=":  					newComparator = Comparator.NotEquals;  					break;  				case ">":  					newComparator = Comparator.Greater;  					break;  				case "<":  					newComparator = Comparator.Less;  					break;  				case ">=":  					newComparator = Comparator.GreaterOrEqual;  					break;  				case "<=":  					newComparator = Comparator.LessOrEqual;  					break;  				case "&":  					newComparator = Comparator.And;  					break;  				case "|":  					newComparator = Comparator.Or;  					break;  				default:  					newComparator = Comparator.Equals;  					break;  				}  				filterNode = new BoolExpression (a' newComparator' b);  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  			{  				DebugLocation (98' 4);  				DebugLocation (98' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr195);  				Match (input' TokenTypes.Down' null);  				DebugLocation (98' 12);  				PushFollow (Follow._filterExpr_in_filterExpr199);  				f = filterExpr ();  				PopFollow ();  				DebugLocation (98' 31);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  				int alt6 = 2;  				try {  					DebugEnterSubRule (6);  					try {  						DebugEnterDecision (6' false);  						int LA6_1 = input.LA (1);  						if ((LA6_1 == 24)) {  							alt6 = 1;  						}  					}  					finally {  						DebugExitDecision (6);  					}  					switch (alt6) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  						{  							DebugLocation (98' 31);  							inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (6);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (99' 4);  				FilterTreeNode newNode = f;  				if ((inverse != null ? inverse.Text : default(string)) == "!")  					newNode.ToggleInversed ();  				filterNode = newNode;  			}  			break;  		case 3:  			DebugEnterAlt (3);  			// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  			{  				DebugLocation (105' 4);  				DebugLocation (105' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr216);  				Match (input' TokenTypes.Down' null);  				DebugLocation (105' 12);  				PushFollow (Follow._propertyChain_in_filterExpr219);  				propertyChain (propertySegments);  				PopFollow ();  				DebugLocation (105' 51);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  				int alt7 = 2;  				try {  					DebugEnterSubRule (7);  					try {  						DebugEnterDecision (7' false);  						int LA7_1 = input.LA (1);  						if ((LA7_1 == 31)) {  							alt7 = 1;  						}  					}  					finally {  						DebugExitDecision (7);  					}  					switch (alt7) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  						{  							DebugLocation (105' 51);  							inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (7);  				}  				DebugLocation (105' 60);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  				int alt8 = 2;  				try {  					DebugEnterSubRule (8);  					try {  						DebugEnterDecision (8' false);  						int LA8_1 = input.LA (1);  						if ((LA8_1 == 24)) {  							alt8 = 1;  						}  					}  					finally {  						DebugExitDecision (8);  					}  					switch (alt8) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  						{  							DebugLocation (105' 60);  							not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (8);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (106' 4);  				FilterTreeNode newProperty = new Property (propertySegments);  				if ((inverse != null ? inverse.Text : default(string)) == "?")  					filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  				else {  					if ((not != null ? not.Text : default(string)) == "!")  						newProperty.ToggleInversed ();  					filterNode = newProperty;  				}  			}  			break;  		case 4:  			DebugEnterAlt (4);  			// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  			{  				DebugLocation (116' 4);  				STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  				DebugLocation (117' 4);  				string stringText = (STRING7 != null ? STRING7.Text : default(string));  				stringText = stringText.Substring (1' stringText.Length - 2);  				filterNode = new Value (stringText);  			}  			break;  		case 5:  			DebugEnterAlt (5);  			// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  			{  				DebugLocation (122' 4);  				REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  				DebugLocation (123' 4);  				string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  				regexText = regexText.Substring (1' regexText.Length - 2);  				filterNode = new RegExp (regexText);  			}  			break;  		case 6:  			DebugEnterAlt (6);  			// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  			{  				DebugLocation (128' 4);  				NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  				DebugLocation (129' 4);  				filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  			}  			break;  		case 7:  			DebugEnterAlt (7);  			// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  			{  				DebugLocation (132' 4);  				Match (input' TRUE' Follow._TRUE_in_filterExpr271);  				DebugLocation (133' 4);  				filterNode = new Value (true);  			}  			break;  		case 8:  			DebugEnterAlt (8);  			// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  			{  				DebugLocation (136' 4);  				Match (input' FALSE' Follow._FALSE_in_filterExpr281);  				DebugLocation (137' 4);  				filterNode = new Value (false);  			}  			break;  		case 9:  			DebugEnterAlt (9);  			// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  			{  				DebugLocation (140' 4);  				Match (input' NULL' Follow._NULL_in_filterExpr291);  				DebugLocation (141' 4);  				filterNode = new Value (null);  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("filterExpr"' 6);  		LeaveRule ("filterExpr"' 6);  		LeaveRule_filterExpr ();  	}  	DebugLocation (144' 1);  }  finally {  	DebugExitRule (GrammarFileName' "filterExpr");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "filterExpr");  	DebugLocation (60' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  		int alt9 = 9;  		try {  			DebugEnterDecision (9' false);  			switch (input.LA (1)) {  			case CHAIN_OPERATOR:  			case COMPARATOR:  				{  					alt9 = 1;  				}  				break;  			case EXPR:  				{  					int LA9_2 = input.LA (2);  					if ((LA9_2 == DOWN)) {  						int LA9_3 = input.LA (3);  						if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  							alt9 = 2;  						}  						else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  							alt9 = 3;  						}  						else {  							NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  							DebugRecognitionException (nvae);  							throw nvae;  						}  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				break;  			case STRING:  				{  					alt9 = 4;  				}  				break;  			case REGEX:  				{  					alt9 = 5;  				}  				break;  			case NUMBER:  				{  					alt9 = 6;  				}  				break;  			case TRUE:  				{  					alt9 = 7;  				}  				break;  			case FALSE:  				{  					alt9 = 8;  				}  				break;  			case NULL:  				{  					alt9 = 9;  				}  				break;  			default: {  				NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  			}  		}  		finally {  			DebugExitDecision (9);  		}  		switch (alt9) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  			{  				DebugLocation (64' 4);  				DebugLocation (64' 6);  				PushFollow (Follow._comparator_in_filterExpr175);  				comparator6 = comparator ();  				PopFollow ();  				Match (input' TokenTypes.Down' null);  				DebugLocation (64' 18);  				PushFollow (Follow._filterExpr_in_filterExpr179);  				a = filterExpr ();  				PopFollow ();  				DebugLocation (64' 31);  				PushFollow (Follow._filterExpr_in_filterExpr183);  				b = filterExpr ();  				PopFollow ();  				Match (input' TokenTypes.Up' null);  				DebugLocation (65' 4);  				Comparator newComparator;  				switch (comparator6) {  				case "=":  					newComparator = Comparator.Equals;  					break;  				case "!=":  					newComparator = Comparator.NotEquals;  					break;  				case ">":  					newComparator = Comparator.Greater;  					break;  				case "<":  					newComparator = Comparator.Less;  					break;  				case ">=":  					newComparator = Comparator.GreaterOrEqual;  					break;  				case "<=":  					newComparator = Comparator.LessOrEqual;  					break;  				case "&":  					newComparator = Comparator.And;  					break;  				case "|":  					newComparator = Comparator.Or;  					break;  				default:  					newComparator = Comparator.Equals;  					break;  				}  				filterNode = new BoolExpression (a' newComparator' b);  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  			{  				DebugLocation (98' 4);  				DebugLocation (98' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr195);  				Match (input' TokenTypes.Down' null);  				DebugLocation (98' 12);  				PushFollow (Follow._filterExpr_in_filterExpr199);  				f = filterExpr ();  				PopFollow ();  				DebugLocation (98' 31);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  				int alt6 = 2;  				try {  					DebugEnterSubRule (6);  					try {  						DebugEnterDecision (6' false);  						int LA6_1 = input.LA (1);  						if ((LA6_1 == 24)) {  							alt6 = 1;  						}  					}  					finally {  						DebugExitDecision (6);  					}  					switch (alt6) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  						{  							DebugLocation (98' 31);  							inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (6);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (99' 4);  				FilterTreeNode newNode = f;  				if ((inverse != null ? inverse.Text : default(string)) == "!")  					newNode.ToggleInversed ();  				filterNode = newNode;  			}  			break;  		case 3:  			DebugEnterAlt (3);  			// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  			{  				DebugLocation (105' 4);  				DebugLocation (105' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr216);  				Match (input' TokenTypes.Down' null);  				DebugLocation (105' 12);  				PushFollow (Follow._propertyChain_in_filterExpr219);  				propertyChain (propertySegments);  				PopFollow ();  				DebugLocation (105' 51);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  				int alt7 = 2;  				try {  					DebugEnterSubRule (7);  					try {  						DebugEnterDecision (7' false);  						int LA7_1 = input.LA (1);  						if ((LA7_1 == 31)) {  							alt7 = 1;  						}  					}  					finally {  						DebugExitDecision (7);  					}  					switch (alt7) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  						{  							DebugLocation (105' 51);  							inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (7);  				}  				DebugLocation (105' 60);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  				int alt8 = 2;  				try {  					DebugEnterSubRule (8);  					try {  						DebugEnterDecision (8' false);  						int LA8_1 = input.LA (1);  						if ((LA8_1 == 24)) {  							alt8 = 1;  						}  					}  					finally {  						DebugExitDecision (8);  					}  					switch (alt8) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  						{  							DebugLocation (105' 60);  							not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (8);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (106' 4);  				FilterTreeNode newProperty = new Property (propertySegments);  				if ((inverse != null ? inverse.Text : default(string)) == "?")  					filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  				else {  					if ((not != null ? not.Text : default(string)) == "!")  						newProperty.ToggleInversed ();  					filterNode = newProperty;  				}  			}  			break;  		case 4:  			DebugEnterAlt (4);  			// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  			{  				DebugLocation (116' 4);  				STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  				DebugLocation (117' 4);  				string stringText = (STRING7 != null ? STRING7.Text : default(string));  				stringText = stringText.Substring (1' stringText.Length - 2);  				filterNode = new Value (stringText);  			}  			break;  		case 5:  			DebugEnterAlt (5);  			// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  			{  				DebugLocation (122' 4);  				REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  				DebugLocation (123' 4);  				string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  				regexText = regexText.Substring (1' regexText.Length - 2);  				filterNode = new RegExp (regexText);  			}  			break;  		case 6:  			DebugEnterAlt (6);  			// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  			{  				DebugLocation (128' 4);  				NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  				DebugLocation (129' 4);  				filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  			}  			break;  		case 7:  			DebugEnterAlt (7);  			// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  			{  				DebugLocation (132' 4);  				Match (input' TRUE' Follow._TRUE_in_filterExpr271);  				DebugLocation (133' 4);  				filterNode = new Value (true);  			}  			break;  		case 8:  			DebugEnterAlt (8);  			// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  			{  				DebugLocation (136' 4);  				Match (input' FALSE' Follow._FALSE_in_filterExpr281);  				DebugLocation (137' 4);  				filterNode = new Value (false);  			}  			break;  		case 9:  			DebugEnterAlt (9);  			// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  			{  				DebugLocation (140' 4);  				Match (input' NULL' Follow._NULL_in_filterExpr291);  				DebugLocation (141' 4);  				filterNode = new Value (null);  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("filterExpr"' 6);  		LeaveRule ("filterExpr"' 6);  		LeaveRule_filterExpr ();  	}  	DebugLocation (144' 1);  }  finally {  	DebugExitRule (GrammarFileName' "filterExpr");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "filterExpr");  	DebugLocation (60' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  		int alt9 = 9;  		try {  			DebugEnterDecision (9' false);  			switch (input.LA (1)) {  			case CHAIN_OPERATOR:  			case COMPARATOR:  				{  					alt9 = 1;  				}  				break;  			case EXPR:  				{  					int LA9_2 = input.LA (2);  					if ((LA9_2 == DOWN)) {  						int LA9_3 = input.LA (3);  						if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  							alt9 = 2;  						}  						else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  							alt9 = 3;  						}  						else {  							NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  							DebugRecognitionException (nvae);  							throw nvae;  						}  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				break;  			case STRING:  				{  					alt9 = 4;  				}  				break;  			case REGEX:  				{  					alt9 = 5;  				}  				break;  			case NUMBER:  				{  					alt9 = 6;  				}  				break;  			case TRUE:  				{  					alt9 = 7;  				}  				break;  			case FALSE:  				{  					alt9 = 8;  				}  				break;  			case NULL:  				{  					alt9 = 9;  				}  				break;  			default: {  				NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  			}  		}  		finally {  			DebugExitDecision (9);  		}  		switch (alt9) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  			{  				DebugLocation (64' 4);  				DebugLocation (64' 6);  				PushFollow (Follow._comparator_in_filterExpr175);  				comparator6 = comparator ();  				PopFollow ();  				Match (input' TokenTypes.Down' null);  				DebugLocation (64' 18);  				PushFollow (Follow._filterExpr_in_filterExpr179);  				a = filterExpr ();  				PopFollow ();  				DebugLocation (64' 31);  				PushFollow (Follow._filterExpr_in_filterExpr183);  				b = filterExpr ();  				PopFollow ();  				Match (input' TokenTypes.Up' null);  				DebugLocation (65' 4);  				Comparator newComparator;  				switch (comparator6) {  				case "=":  					newComparator = Comparator.Equals;  					break;  				case "!=":  					newComparator = Comparator.NotEquals;  					break;  				case ">":  					newComparator = Comparator.Greater;  					break;  				case "<":  					newComparator = Comparator.Less;  					break;  				case ">=":  					newComparator = Comparator.GreaterOrEqual;  					break;  				case "<=":  					newComparator = Comparator.LessOrEqual;  					break;  				case "&":  					newComparator = Comparator.And;  					break;  				case "|":  					newComparator = Comparator.Or;  					break;  				default:  					newComparator = Comparator.Equals;  					break;  				}  				filterNode = new BoolExpression (a' newComparator' b);  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  			{  				DebugLocation (98' 4);  				DebugLocation (98' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr195);  				Match (input' TokenTypes.Down' null);  				DebugLocation (98' 12);  				PushFollow (Follow._filterExpr_in_filterExpr199);  				f = filterExpr ();  				PopFollow ();  				DebugLocation (98' 31);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  				int alt6 = 2;  				try {  					DebugEnterSubRule (6);  					try {  						DebugEnterDecision (6' false);  						int LA6_1 = input.LA (1);  						if ((LA6_1 == 24)) {  							alt6 = 1;  						}  					}  					finally {  						DebugExitDecision (6);  					}  					switch (alt6) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  						{  							DebugLocation (98' 31);  							inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (6);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (99' 4);  				FilterTreeNode newNode = f;  				if ((inverse != null ? inverse.Text : default(string)) == "!")  					newNode.ToggleInversed ();  				filterNode = newNode;  			}  			break;  		case 3:  			DebugEnterAlt (3);  			// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  			{  				DebugLocation (105' 4);  				DebugLocation (105' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr216);  				Match (input' TokenTypes.Down' null);  				DebugLocation (105' 12);  				PushFollow (Follow._propertyChain_in_filterExpr219);  				propertyChain (propertySegments);  				PopFollow ();  				DebugLocation (105' 51);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  				int alt7 = 2;  				try {  					DebugEnterSubRule (7);  					try {  						DebugEnterDecision (7' false);  						int LA7_1 = input.LA (1);  						if ((LA7_1 == 31)) {  							alt7 = 1;  						}  					}  					finally {  						DebugExitDecision (7);  					}  					switch (alt7) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  						{  							DebugLocation (105' 51);  							inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (7);  				}  				DebugLocation (105' 60);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  				int alt8 = 2;  				try {  					DebugEnterSubRule (8);  					try {  						DebugEnterDecision (8' false);  						int LA8_1 = input.LA (1);  						if ((LA8_1 == 24)) {  							alt8 = 1;  						}  					}  					finally {  						DebugExitDecision (8);  					}  					switch (alt8) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  						{  							DebugLocation (105' 60);  							not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (8);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (106' 4);  				FilterTreeNode newProperty = new Property (propertySegments);  				if ((inverse != null ? inverse.Text : default(string)) == "?")  					filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  				else {  					if ((not != null ? not.Text : default(string)) == "!")  						newProperty.ToggleInversed ();  					filterNode = newProperty;  				}  			}  			break;  		case 4:  			DebugEnterAlt (4);  			// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  			{  				DebugLocation (116' 4);  				STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  				DebugLocation (117' 4);  				string stringText = (STRING7 != null ? STRING7.Text : default(string));  				stringText = stringText.Substring (1' stringText.Length - 2);  				filterNode = new Value (stringText);  			}  			break;  		case 5:  			DebugEnterAlt (5);  			// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  			{  				DebugLocation (122' 4);  				REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  				DebugLocation (123' 4);  				string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  				regexText = regexText.Substring (1' regexText.Length - 2);  				filterNode = new RegExp (regexText);  			}  			break;  		case 6:  			DebugEnterAlt (6);  			// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  			{  				DebugLocation (128' 4);  				NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  				DebugLocation (129' 4);  				filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  			}  			break;  		case 7:  			DebugEnterAlt (7);  			// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  			{  				DebugLocation (132' 4);  				Match (input' TRUE' Follow._TRUE_in_filterExpr271);  				DebugLocation (133' 4);  				filterNode = new Value (true);  			}  			break;  		case 8:  			DebugEnterAlt (8);  			// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  			{  				DebugLocation (136' 4);  				Match (input' FALSE' Follow._FALSE_in_filterExpr281);  				DebugLocation (137' 4);  				filterNode = new Value (false);  			}  			break;  		case 9:  			DebugEnterAlt (9);  			// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  			{  				DebugLocation (140' 4);  				Match (input' NULL' Follow._NULL_in_filterExpr291);  				DebugLocation (141' 4);  				filterNode = new Value (null);  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("filterExpr"' 6);  		LeaveRule ("filterExpr"' 6);  		LeaveRule_filterExpr ();  	}  	DebugLocation (144' 1);  }  finally {  	DebugExitRule (GrammarFileName' "filterExpr");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "filterExpr");  	DebugLocation (60' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  		int alt9 = 9;  		try {  			DebugEnterDecision (9' false);  			switch (input.LA (1)) {  			case CHAIN_OPERATOR:  			case COMPARATOR:  				{  					alt9 = 1;  				}  				break;  			case EXPR:  				{  					int LA9_2 = input.LA (2);  					if ((LA9_2 == DOWN)) {  						int LA9_3 = input.LA (3);  						if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  							alt9 = 2;  						}  						else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  							alt9 = 3;  						}  						else {  							NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  							DebugRecognitionException (nvae);  							throw nvae;  						}  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				break;  			case STRING:  				{  					alt9 = 4;  				}  				break;  			case REGEX:  				{  					alt9 = 5;  				}  				break;  			case NUMBER:  				{  					alt9 = 6;  				}  				break;  			case TRUE:  				{  					alt9 = 7;  				}  				break;  			case FALSE:  				{  					alt9 = 8;  				}  				break;  			case NULL:  				{  					alt9 = 9;  				}  				break;  			default: {  				NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  			}  		}  		finally {  			DebugExitDecision (9);  		}  		switch (alt9) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  			{  				DebugLocation (64' 4);  				DebugLocation (64' 6);  				PushFollow (Follow._comparator_in_filterExpr175);  				comparator6 = comparator ();  				PopFollow ();  				Match (input' TokenTypes.Down' null);  				DebugLocation (64' 18);  				PushFollow (Follow._filterExpr_in_filterExpr179);  				a = filterExpr ();  				PopFollow ();  				DebugLocation (64' 31);  				PushFollow (Follow._filterExpr_in_filterExpr183);  				b = filterExpr ();  				PopFollow ();  				Match (input' TokenTypes.Up' null);  				DebugLocation (65' 4);  				Comparator newComparator;  				switch (comparator6) {  				case "=":  					newComparator = Comparator.Equals;  					break;  				case "!=":  					newComparator = Comparator.NotEquals;  					break;  				case ">":  					newComparator = Comparator.Greater;  					break;  				case "<":  					newComparator = Comparator.Less;  					break;  				case ">=":  					newComparator = Comparator.GreaterOrEqual;  					break;  				case "<=":  					newComparator = Comparator.LessOrEqual;  					break;  				case "&":  					newComparator = Comparator.And;  					break;  				case "|":  					newComparator = Comparator.Or;  					break;  				default:  					newComparator = Comparator.Equals;  					break;  				}  				filterNode = new BoolExpression (a' newComparator' b);  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  			{  				DebugLocation (98' 4);  				DebugLocation (98' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr195);  				Match (input' TokenTypes.Down' null);  				DebugLocation (98' 12);  				PushFollow (Follow._filterExpr_in_filterExpr199);  				f = filterExpr ();  				PopFollow ();  				DebugLocation (98' 31);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  				int alt6 = 2;  				try {  					DebugEnterSubRule (6);  					try {  						DebugEnterDecision (6' false);  						int LA6_1 = input.LA (1);  						if ((LA6_1 == 24)) {  							alt6 = 1;  						}  					}  					finally {  						DebugExitDecision (6);  					}  					switch (alt6) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  						{  							DebugLocation (98' 31);  							inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (6);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (99' 4);  				FilterTreeNode newNode = f;  				if ((inverse != null ? inverse.Text : default(string)) == "!")  					newNode.ToggleInversed ();  				filterNode = newNode;  			}  			break;  		case 3:  			DebugEnterAlt (3);  			// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  			{  				DebugLocation (105' 4);  				DebugLocation (105' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr216);  				Match (input' TokenTypes.Down' null);  				DebugLocation (105' 12);  				PushFollow (Follow._propertyChain_in_filterExpr219);  				propertyChain (propertySegments);  				PopFollow ();  				DebugLocation (105' 51);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  				int alt7 = 2;  				try {  					DebugEnterSubRule (7);  					try {  						DebugEnterDecision (7' false);  						int LA7_1 = input.LA (1);  						if ((LA7_1 == 31)) {  							alt7 = 1;  						}  					}  					finally {  						DebugExitDecision (7);  					}  					switch (alt7) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  						{  							DebugLocation (105' 51);  							inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (7);  				}  				DebugLocation (105' 60);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  				int alt8 = 2;  				try {  					DebugEnterSubRule (8);  					try {  						DebugEnterDecision (8' false);  						int LA8_1 = input.LA (1);  						if ((LA8_1 == 24)) {  							alt8 = 1;  						}  					}  					finally {  						DebugExitDecision (8);  					}  					switch (alt8) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  						{  							DebugLocation (105' 60);  							not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (8);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (106' 4);  				FilterTreeNode newProperty = new Property (propertySegments);  				if ((inverse != null ? inverse.Text : default(string)) == "?")  					filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  				else {  					if ((not != null ? not.Text : default(string)) == "!")  						newProperty.ToggleInversed ();  					filterNode = newProperty;  				}  			}  			break;  		case 4:  			DebugEnterAlt (4);  			// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  			{  				DebugLocation (116' 4);  				STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  				DebugLocation (117' 4);  				string stringText = (STRING7 != null ? STRING7.Text : default(string));  				stringText = stringText.Substring (1' stringText.Length - 2);  				filterNode = new Value (stringText);  			}  			break;  		case 5:  			DebugEnterAlt (5);  			// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  			{  				DebugLocation (122' 4);  				REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  				DebugLocation (123' 4);  				string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  				regexText = regexText.Substring (1' regexText.Length - 2);  				filterNode = new RegExp (regexText);  			}  			break;  		case 6:  			DebugEnterAlt (6);  			// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  			{  				DebugLocation (128' 4);  				NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  				DebugLocation (129' 4);  				filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  			}  			break;  		case 7:  			DebugEnterAlt (7);  			// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  			{  				DebugLocation (132' 4);  				Match (input' TRUE' Follow._TRUE_in_filterExpr271);  				DebugLocation (133' 4);  				filterNode = new Value (true);  			}  			break;  		case 8:  			DebugEnterAlt (8);  			// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  			{  				DebugLocation (136' 4);  				Match (input' FALSE' Follow._FALSE_in_filterExpr281);  				DebugLocation (137' 4);  				filterNode = new Value (false);  			}  			break;  		case 9:  			DebugEnterAlt (9);  			// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  			{  				DebugLocation (140' 4);  				Match (input' NULL' Follow._NULL_in_filterExpr291);  				DebugLocation (141' 4);  				filterNode = new Value (null);  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("filterExpr"' 6);  		LeaveRule ("filterExpr"' 6);  		LeaveRule_filterExpr ();  	}  	DebugLocation (144' 1);  }  finally {  	DebugExitRule (GrammarFileName' "filterExpr");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "filterExpr");  	DebugLocation (60' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  		int alt9 = 9;  		try {  			DebugEnterDecision (9' false);  			switch (input.LA (1)) {  			case CHAIN_OPERATOR:  			case COMPARATOR:  				{  					alt9 = 1;  				}  				break;  			case EXPR:  				{  					int LA9_2 = input.LA (2);  					if ((LA9_2 == DOWN)) {  						int LA9_3 = input.LA (3);  						if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  							alt9 = 2;  						}  						else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  							alt9 = 3;  						}  						else {  							NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  							DebugRecognitionException (nvae);  							throw nvae;  						}  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				break;  			case STRING:  				{  					alt9 = 4;  				}  				break;  			case REGEX:  				{  					alt9 = 5;  				}  				break;  			case NUMBER:  				{  					alt9 = 6;  				}  				break;  			case TRUE:  				{  					alt9 = 7;  				}  				break;  			case FALSE:  				{  					alt9 = 8;  				}  				break;  			case NULL:  				{  					alt9 = 9;  				}  				break;  			default: {  				NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  			}  		}  		finally {  			DebugExitDecision (9);  		}  		switch (alt9) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  			{  				DebugLocation (64' 4);  				DebugLocation (64' 6);  				PushFollow (Follow._comparator_in_filterExpr175);  				comparator6 = comparator ();  				PopFollow ();  				Match (input' TokenTypes.Down' null);  				DebugLocation (64' 18);  				PushFollow (Follow._filterExpr_in_filterExpr179);  				a = filterExpr ();  				PopFollow ();  				DebugLocation (64' 31);  				PushFollow (Follow._filterExpr_in_filterExpr183);  				b = filterExpr ();  				PopFollow ();  				Match (input' TokenTypes.Up' null);  				DebugLocation (65' 4);  				Comparator newComparator;  				switch (comparator6) {  				case "=":  					newComparator = Comparator.Equals;  					break;  				case "!=":  					newComparator = Comparator.NotEquals;  					break;  				case ">":  					newComparator = Comparator.Greater;  					break;  				case "<":  					newComparator = Comparator.Less;  					break;  				case ">=":  					newComparator = Comparator.GreaterOrEqual;  					break;  				case "<=":  					newComparator = Comparator.LessOrEqual;  					break;  				case "&":  					newComparator = Comparator.And;  					break;  				case "|":  					newComparator = Comparator.Or;  					break;  				default:  					newComparator = Comparator.Equals;  					break;  				}  				filterNode = new BoolExpression (a' newComparator' b);  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  			{  				DebugLocation (98' 4);  				DebugLocation (98' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr195);  				Match (input' TokenTypes.Down' null);  				DebugLocation (98' 12);  				PushFollow (Follow._filterExpr_in_filterExpr199);  				f = filterExpr ();  				PopFollow ();  				DebugLocation (98' 31);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  				int alt6 = 2;  				try {  					DebugEnterSubRule (6);  					try {  						DebugEnterDecision (6' false);  						int LA6_1 = input.LA (1);  						if ((LA6_1 == 24)) {  							alt6 = 1;  						}  					}  					finally {  						DebugExitDecision (6);  					}  					switch (alt6) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  						{  							DebugLocation (98' 31);  							inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (6);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (99' 4);  				FilterTreeNode newNode = f;  				if ((inverse != null ? inverse.Text : default(string)) == "!")  					newNode.ToggleInversed ();  				filterNode = newNode;  			}  			break;  		case 3:  			DebugEnterAlt (3);  			// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  			{  				DebugLocation (105' 4);  				DebugLocation (105' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr216);  				Match (input' TokenTypes.Down' null);  				DebugLocation (105' 12);  				PushFollow (Follow._propertyChain_in_filterExpr219);  				propertyChain (propertySegments);  				PopFollow ();  				DebugLocation (105' 51);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  				int alt7 = 2;  				try {  					DebugEnterSubRule (7);  					try {  						DebugEnterDecision (7' false);  						int LA7_1 = input.LA (1);  						if ((LA7_1 == 31)) {  							alt7 = 1;  						}  					}  					finally {  						DebugExitDecision (7);  					}  					switch (alt7) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  						{  							DebugLocation (105' 51);  							inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (7);  				}  				DebugLocation (105' 60);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  				int alt8 = 2;  				try {  					DebugEnterSubRule (8);  					try {  						DebugEnterDecision (8' false);  						int LA8_1 = input.LA (1);  						if ((LA8_1 == 24)) {  							alt8 = 1;  						}  					}  					finally {  						DebugExitDecision (8);  					}  					switch (alt8) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  						{  							DebugLocation (105' 60);  							not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (8);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (106' 4);  				FilterTreeNode newProperty = new Property (propertySegments);  				if ((inverse != null ? inverse.Text : default(string)) == "?")  					filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  				else {  					if ((not != null ? not.Text : default(string)) == "!")  						newProperty.ToggleInversed ();  					filterNode = newProperty;  				}  			}  			break;  		case 4:  			DebugEnterAlt (4);  			// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  			{  				DebugLocation (116' 4);  				STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  				DebugLocation (117' 4);  				string stringText = (STRING7 != null ? STRING7.Text : default(string));  				stringText = stringText.Substring (1' stringText.Length - 2);  				filterNode = new Value (stringText);  			}  			break;  		case 5:  			DebugEnterAlt (5);  			// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  			{  				DebugLocation (122' 4);  				REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  				DebugLocation (123' 4);  				string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  				regexText = regexText.Substring (1' regexText.Length - 2);  				filterNode = new RegExp (regexText);  			}  			break;  		case 6:  			DebugEnterAlt (6);  			// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  			{  				DebugLocation (128' 4);  				NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  				DebugLocation (129' 4);  				filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  			}  			break;  		case 7:  			DebugEnterAlt (7);  			// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  			{  				DebugLocation (132' 4);  				Match (input' TRUE' Follow._TRUE_in_filterExpr271);  				DebugLocation (133' 4);  				filterNode = new Value (true);  			}  			break;  		case 8:  			DebugEnterAlt (8);  			// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  			{  				DebugLocation (136' 4);  				Match (input' FALSE' Follow._FALSE_in_filterExpr281);  				DebugLocation (137' 4);  				filterNode = new Value (false);  			}  			break;  		case 9:  			DebugEnterAlt (9);  			// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  			{  				DebugLocation (140' 4);  				Match (input' NULL' Follow._NULL_in_filterExpr291);  				DebugLocation (141' 4);  				filterNode = new Value (null);  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("filterExpr"' 6);  		LeaveRule ("filterExpr"' 6);  		LeaveRule_filterExpr ();  	}  	DebugLocation (144' 1);  }  finally {  	DebugExitRule (GrammarFileName' "filterExpr");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "filterExpr");  	DebugLocation (60' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  		int alt9 = 9;  		try {  			DebugEnterDecision (9' false);  			switch (input.LA (1)) {  			case CHAIN_OPERATOR:  			case COMPARATOR:  				{  					alt9 = 1;  				}  				break;  			case EXPR:  				{  					int LA9_2 = input.LA (2);  					if ((LA9_2 == DOWN)) {  						int LA9_3 = input.LA (3);  						if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  							alt9 = 2;  						}  						else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  							alt9 = 3;  						}  						else {  							NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  							DebugRecognitionException (nvae);  							throw nvae;  						}  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				break;  			case STRING:  				{  					alt9 = 4;  				}  				break;  			case REGEX:  				{  					alt9 = 5;  				}  				break;  			case NUMBER:  				{  					alt9 = 6;  				}  				break;  			case TRUE:  				{  					alt9 = 7;  				}  				break;  			case FALSE:  				{  					alt9 = 8;  				}  				break;  			case NULL:  				{  					alt9 = 9;  				}  				break;  			default: {  				NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  			}  		}  		finally {  			DebugExitDecision (9);  		}  		switch (alt9) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  			{  				DebugLocation (64' 4);  				DebugLocation (64' 6);  				PushFollow (Follow._comparator_in_filterExpr175);  				comparator6 = comparator ();  				PopFollow ();  				Match (input' TokenTypes.Down' null);  				DebugLocation (64' 18);  				PushFollow (Follow._filterExpr_in_filterExpr179);  				a = filterExpr ();  				PopFollow ();  				DebugLocation (64' 31);  				PushFollow (Follow._filterExpr_in_filterExpr183);  				b = filterExpr ();  				PopFollow ();  				Match (input' TokenTypes.Up' null);  				DebugLocation (65' 4);  				Comparator newComparator;  				switch (comparator6) {  				case "=":  					newComparator = Comparator.Equals;  					break;  				case "!=":  					newComparator = Comparator.NotEquals;  					break;  				case ">":  					newComparator = Comparator.Greater;  					break;  				case "<":  					newComparator = Comparator.Less;  					break;  				case ">=":  					newComparator = Comparator.GreaterOrEqual;  					break;  				case "<=":  					newComparator = Comparator.LessOrEqual;  					break;  				case "&":  					newComparator = Comparator.And;  					break;  				case "|":  					newComparator = Comparator.Or;  					break;  				default:  					newComparator = Comparator.Equals;  					break;  				}  				filterNode = new BoolExpression (a' newComparator' b);  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  			{  				DebugLocation (98' 4);  				DebugLocation (98' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr195);  				Match (input' TokenTypes.Down' null);  				DebugLocation (98' 12);  				PushFollow (Follow._filterExpr_in_filterExpr199);  				f = filterExpr ();  				PopFollow ();  				DebugLocation (98' 31);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  				int alt6 = 2;  				try {  					DebugEnterSubRule (6);  					try {  						DebugEnterDecision (6' false);  						int LA6_1 = input.LA (1);  						if ((LA6_1 == 24)) {  							alt6 = 1;  						}  					}  					finally {  						DebugExitDecision (6);  					}  					switch (alt6) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  						{  							DebugLocation (98' 31);  							inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (6);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (99' 4);  				FilterTreeNode newNode = f;  				if ((inverse != null ? inverse.Text : default(string)) == "!")  					newNode.ToggleInversed ();  				filterNode = newNode;  			}  			break;  		case 3:  			DebugEnterAlt (3);  			// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  			{  				DebugLocation (105' 4);  				DebugLocation (105' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr216);  				Match (input' TokenTypes.Down' null);  				DebugLocation (105' 12);  				PushFollow (Follow._propertyChain_in_filterExpr219);  				propertyChain (propertySegments);  				PopFollow ();  				DebugLocation (105' 51);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  				int alt7 = 2;  				try {  					DebugEnterSubRule (7);  					try {  						DebugEnterDecision (7' false);  						int LA7_1 = input.LA (1);  						if ((LA7_1 == 31)) {  							alt7 = 1;  						}  					}  					finally {  						DebugExitDecision (7);  					}  					switch (alt7) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  						{  							DebugLocation (105' 51);  							inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (7);  				}  				DebugLocation (105' 60);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  				int alt8 = 2;  				try {  					DebugEnterSubRule (8);  					try {  						DebugEnterDecision (8' false);  						int LA8_1 = input.LA (1);  						if ((LA8_1 == 24)) {  							alt8 = 1;  						}  					}  					finally {  						DebugExitDecision (8);  					}  					switch (alt8) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  						{  							DebugLocation (105' 60);  							not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (8);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (106' 4);  				FilterTreeNode newProperty = new Property (propertySegments);  				if ((inverse != null ? inverse.Text : default(string)) == "?")  					filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  				else {  					if ((not != null ? not.Text : default(string)) == "!")  						newProperty.ToggleInversed ();  					filterNode = newProperty;  				}  			}  			break;  		case 4:  			DebugEnterAlt (4);  			// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  			{  				DebugLocation (116' 4);  				STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  				DebugLocation (117' 4);  				string stringText = (STRING7 != null ? STRING7.Text : default(string));  				stringText = stringText.Substring (1' stringText.Length - 2);  				filterNode = new Value (stringText);  			}  			break;  		case 5:  			DebugEnterAlt (5);  			// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  			{  				DebugLocation (122' 4);  				REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  				DebugLocation (123' 4);  				string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  				regexText = regexText.Substring (1' regexText.Length - 2);  				filterNode = new RegExp (regexText);  			}  			break;  		case 6:  			DebugEnterAlt (6);  			// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  			{  				DebugLocation (128' 4);  				NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  				DebugLocation (129' 4);  				filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  			}  			break;  		case 7:  			DebugEnterAlt (7);  			// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  			{  				DebugLocation (132' 4);  				Match (input' TRUE' Follow._TRUE_in_filterExpr271);  				DebugLocation (133' 4);  				filterNode = new Value (true);  			}  			break;  		case 8:  			DebugEnterAlt (8);  			// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  			{  				DebugLocation (136' 4);  				Match (input' FALSE' Follow._FALSE_in_filterExpr281);  				DebugLocation (137' 4);  				filterNode = new Value (false);  			}  			break;  		case 9:  			DebugEnterAlt (9);  			// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  			{  				DebugLocation (140' 4);  				Match (input' NULL' Follow._NULL_in_filterExpr291);  				DebugLocation (141' 4);  				filterNode = new Value (null);  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("filterExpr"' 6);  		LeaveRule ("filterExpr"' 6);  		LeaveRule_filterExpr ();  	}  	DebugLocation (144' 1);  }  finally {  	DebugExitRule (GrammarFileName' "filterExpr");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "filterExpr");  	DebugLocation (60' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  		int alt9 = 9;  		try {  			DebugEnterDecision (9' false);  			switch (input.LA (1)) {  			case CHAIN_OPERATOR:  			case COMPARATOR:  				{  					alt9 = 1;  				}  				break;  			case EXPR:  				{  					int LA9_2 = input.LA (2);  					if ((LA9_2 == DOWN)) {  						int LA9_3 = input.LA (3);  						if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  							alt9 = 2;  						}  						else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  							alt9 = 3;  						}  						else {  							NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  							DebugRecognitionException (nvae);  							throw nvae;  						}  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				break;  			case STRING:  				{  					alt9 = 4;  				}  				break;  			case REGEX:  				{  					alt9 = 5;  				}  				break;  			case NUMBER:  				{  					alt9 = 6;  				}  				break;  			case TRUE:  				{  					alt9 = 7;  				}  				break;  			case FALSE:  				{  					alt9 = 8;  				}  				break;  			case NULL:  				{  					alt9 = 9;  				}  				break;  			default: {  				NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  			}  		}  		finally {  			DebugExitDecision (9);  		}  		switch (alt9) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  			{  				DebugLocation (64' 4);  				DebugLocation (64' 6);  				PushFollow (Follow._comparator_in_filterExpr175);  				comparator6 = comparator ();  				PopFollow ();  				Match (input' TokenTypes.Down' null);  				DebugLocation (64' 18);  				PushFollow (Follow._filterExpr_in_filterExpr179);  				a = filterExpr ();  				PopFollow ();  				DebugLocation (64' 31);  				PushFollow (Follow._filterExpr_in_filterExpr183);  				b = filterExpr ();  				PopFollow ();  				Match (input' TokenTypes.Up' null);  				DebugLocation (65' 4);  				Comparator newComparator;  				switch (comparator6) {  				case "=":  					newComparator = Comparator.Equals;  					break;  				case "!=":  					newComparator = Comparator.NotEquals;  					break;  				case ">":  					newComparator = Comparator.Greater;  					break;  				case "<":  					newComparator = Comparator.Less;  					break;  				case ">=":  					newComparator = Comparator.GreaterOrEqual;  					break;  				case "<=":  					newComparator = Comparator.LessOrEqual;  					break;  				case "&":  					newComparator = Comparator.And;  					break;  				case "|":  					newComparator = Comparator.Or;  					break;  				default:  					newComparator = Comparator.Equals;  					break;  				}  				filterNode = new BoolExpression (a' newComparator' b);  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  			{  				DebugLocation (98' 4);  				DebugLocation (98' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr195);  				Match (input' TokenTypes.Down' null);  				DebugLocation (98' 12);  				PushFollow (Follow._filterExpr_in_filterExpr199);  				f = filterExpr ();  				PopFollow ();  				DebugLocation (98' 31);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  				int alt6 = 2;  				try {  					DebugEnterSubRule (6);  					try {  						DebugEnterDecision (6' false);  						int LA6_1 = input.LA (1);  						if ((LA6_1 == 24)) {  							alt6 = 1;  						}  					}  					finally {  						DebugExitDecision (6);  					}  					switch (alt6) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  						{  							DebugLocation (98' 31);  							inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (6);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (99' 4);  				FilterTreeNode newNode = f;  				if ((inverse != null ? inverse.Text : default(string)) == "!")  					newNode.ToggleInversed ();  				filterNode = newNode;  			}  			break;  		case 3:  			DebugEnterAlt (3);  			// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  			{  				DebugLocation (105' 4);  				DebugLocation (105' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr216);  				Match (input' TokenTypes.Down' null);  				DebugLocation (105' 12);  				PushFollow (Follow._propertyChain_in_filterExpr219);  				propertyChain (propertySegments);  				PopFollow ();  				DebugLocation (105' 51);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  				int alt7 = 2;  				try {  					DebugEnterSubRule (7);  					try {  						DebugEnterDecision (7' false);  						int LA7_1 = input.LA (1);  						if ((LA7_1 == 31)) {  							alt7 = 1;  						}  					}  					finally {  						DebugExitDecision (7);  					}  					switch (alt7) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  						{  							DebugLocation (105' 51);  							inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (7);  				}  				DebugLocation (105' 60);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  				int alt8 = 2;  				try {  					DebugEnterSubRule (8);  					try {  						DebugEnterDecision (8' false);  						int LA8_1 = input.LA (1);  						if ((LA8_1 == 24)) {  							alt8 = 1;  						}  					}  					finally {  						DebugExitDecision (8);  					}  					switch (alt8) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  						{  							DebugLocation (105' 60);  							not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (8);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (106' 4);  				FilterTreeNode newProperty = new Property (propertySegments);  				if ((inverse != null ? inverse.Text : default(string)) == "?")  					filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  				else {  					if ((not != null ? not.Text : default(string)) == "!")  						newProperty.ToggleInversed ();  					filterNode = newProperty;  				}  			}  			break;  		case 4:  			DebugEnterAlt (4);  			// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  			{  				DebugLocation (116' 4);  				STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  				DebugLocation (117' 4);  				string stringText = (STRING7 != null ? STRING7.Text : default(string));  				stringText = stringText.Substring (1' stringText.Length - 2);  				filterNode = new Value (stringText);  			}  			break;  		case 5:  			DebugEnterAlt (5);  			// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  			{  				DebugLocation (122' 4);  				REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  				DebugLocation (123' 4);  				string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  				regexText = regexText.Substring (1' regexText.Length - 2);  				filterNode = new RegExp (regexText);  			}  			break;  		case 6:  			DebugEnterAlt (6);  			// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  			{  				DebugLocation (128' 4);  				NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  				DebugLocation (129' 4);  				filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  			}  			break;  		case 7:  			DebugEnterAlt (7);  			// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  			{  				DebugLocation (132' 4);  				Match (input' TRUE' Follow._TRUE_in_filterExpr271);  				DebugLocation (133' 4);  				filterNode = new Value (true);  			}  			break;  		case 8:  			DebugEnterAlt (8);  			// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  			{  				DebugLocation (136' 4);  				Match (input' FALSE' Follow._FALSE_in_filterExpr281);  				DebugLocation (137' 4);  				filterNode = new Value (false);  			}  			break;  		case 9:  			DebugEnterAlt (9);  			// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  			{  				DebugLocation (140' 4);  				Match (input' NULL' Follow._NULL_in_filterExpr291);  				DebugLocation (141' 4);  				filterNode = new Value (null);  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("filterExpr"' 6);  		LeaveRule ("filterExpr"' 6);  		LeaveRule_filterExpr ();  	}  	DebugLocation (144' 1);  }  finally {  	DebugExitRule (GrammarFileName' "filterExpr");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "filterExpr");  	DebugLocation (60' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  		int alt9 = 9;  		try {  			DebugEnterDecision (9' false);  			switch (input.LA (1)) {  			case CHAIN_OPERATOR:  			case COMPARATOR:  				{  					alt9 = 1;  				}  				break;  			case EXPR:  				{  					int LA9_2 = input.LA (2);  					if ((LA9_2 == DOWN)) {  						int LA9_3 = input.LA (3);  						if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  							alt9 = 2;  						}  						else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  							alt9 = 3;  						}  						else {  							NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  							DebugRecognitionException (nvae);  							throw nvae;  						}  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				break;  			case STRING:  				{  					alt9 = 4;  				}  				break;  			case REGEX:  				{  					alt9 = 5;  				}  				break;  			case NUMBER:  				{  					alt9 = 6;  				}  				break;  			case TRUE:  				{  					alt9 = 7;  				}  				break;  			case FALSE:  				{  					alt9 = 8;  				}  				break;  			case NULL:  				{  					alt9 = 9;  				}  				break;  			default: {  				NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  			}  		}  		finally {  			DebugExitDecision (9);  		}  		switch (alt9) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  			{  				DebugLocation (64' 4);  				DebugLocation (64' 6);  				PushFollow (Follow._comparator_in_filterExpr175);  				comparator6 = comparator ();  				PopFollow ();  				Match (input' TokenTypes.Down' null);  				DebugLocation (64' 18);  				PushFollow (Follow._filterExpr_in_filterExpr179);  				a = filterExpr ();  				PopFollow ();  				DebugLocation (64' 31);  				PushFollow (Follow._filterExpr_in_filterExpr183);  				b = filterExpr ();  				PopFollow ();  				Match (input' TokenTypes.Up' null);  				DebugLocation (65' 4);  				Comparator newComparator;  				switch (comparator6) {  				case "=":  					newComparator = Comparator.Equals;  					break;  				case "!=":  					newComparator = Comparator.NotEquals;  					break;  				case ">":  					newComparator = Comparator.Greater;  					break;  				case "<":  					newComparator = Comparator.Less;  					break;  				case ">=":  					newComparator = Comparator.GreaterOrEqual;  					break;  				case "<=":  					newComparator = Comparator.LessOrEqual;  					break;  				case "&":  					newComparator = Comparator.And;  					break;  				case "|":  					newComparator = Comparator.Or;  					break;  				default:  					newComparator = Comparator.Equals;  					break;  				}  				filterNode = new BoolExpression (a' newComparator' b);  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  			{  				DebugLocation (98' 4);  				DebugLocation (98' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr195);  				Match (input' TokenTypes.Down' null);  				DebugLocation (98' 12);  				PushFollow (Follow._filterExpr_in_filterExpr199);  				f = filterExpr ();  				PopFollow ();  				DebugLocation (98' 31);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  				int alt6 = 2;  				try {  					DebugEnterSubRule (6);  					try {  						DebugEnterDecision (6' false);  						int LA6_1 = input.LA (1);  						if ((LA6_1 == 24)) {  							alt6 = 1;  						}  					}  					finally {  						DebugExitDecision (6);  					}  					switch (alt6) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  						{  							DebugLocation (98' 31);  							inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (6);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (99' 4);  				FilterTreeNode newNode = f;  				if ((inverse != null ? inverse.Text : default(string)) == "!")  					newNode.ToggleInversed ();  				filterNode = newNode;  			}  			break;  		case 3:  			DebugEnterAlt (3);  			// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  			{  				DebugLocation (105' 4);  				DebugLocation (105' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr216);  				Match (input' TokenTypes.Down' null);  				DebugLocation (105' 12);  				PushFollow (Follow._propertyChain_in_filterExpr219);  				propertyChain (propertySegments);  				PopFollow ();  				DebugLocation (105' 51);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  				int alt7 = 2;  				try {  					DebugEnterSubRule (7);  					try {  						DebugEnterDecision (7' false);  						int LA7_1 = input.LA (1);  						if ((LA7_1 == 31)) {  							alt7 = 1;  						}  					}  					finally {  						DebugExitDecision (7);  					}  					switch (alt7) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  						{  							DebugLocation (105' 51);  							inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (7);  				}  				DebugLocation (105' 60);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  				int alt8 = 2;  				try {  					DebugEnterSubRule (8);  					try {  						DebugEnterDecision (8' false);  						int LA8_1 = input.LA (1);  						if ((LA8_1 == 24)) {  							alt8 = 1;  						}  					}  					finally {  						DebugExitDecision (8);  					}  					switch (alt8) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  						{  							DebugLocation (105' 60);  							not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (8);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (106' 4);  				FilterTreeNode newProperty = new Property (propertySegments);  				if ((inverse != null ? inverse.Text : default(string)) == "?")  					filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  				else {  					if ((not != null ? not.Text : default(string)) == "!")  						newProperty.ToggleInversed ();  					filterNode = newProperty;  				}  			}  			break;  		case 4:  			DebugEnterAlt (4);  			// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  			{  				DebugLocation (116' 4);  				STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  				DebugLocation (117' 4);  				string stringText = (STRING7 != null ? STRING7.Text : default(string));  				stringText = stringText.Substring (1' stringText.Length - 2);  				filterNode = new Value (stringText);  			}  			break;  		case 5:  			DebugEnterAlt (5);  			// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  			{  				DebugLocation (122' 4);  				REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  				DebugLocation (123' 4);  				string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  				regexText = regexText.Substring (1' regexText.Length - 2);  				filterNode = new RegExp (regexText);  			}  			break;  		case 6:  			DebugEnterAlt (6);  			// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  			{  				DebugLocation (128' 4);  				NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  				DebugLocation (129' 4);  				filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  			}  			break;  		case 7:  			DebugEnterAlt (7);  			// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  			{  				DebugLocation (132' 4);  				Match (input' TRUE' Follow._TRUE_in_filterExpr271);  				DebugLocation (133' 4);  				filterNode = new Value (true);  			}  			break;  		case 8:  			DebugEnterAlt (8);  			// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  			{  				DebugLocation (136' 4);  				Match (input' FALSE' Follow._FALSE_in_filterExpr281);  				DebugLocation (137' 4);  				filterNode = new Value (false);  			}  			break;  		case 9:  			DebugEnterAlt (9);  			// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  			{  				DebugLocation (140' 4);  				Match (input' NULL' Follow._NULL_in_filterExpr291);  				DebugLocation (141' 4);  				filterNode = new Value (null);  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("filterExpr"' 6);  		LeaveRule ("filterExpr"' 6);  		LeaveRule_filterExpr ();  	}  	DebugLocation (144' 1);  }  finally {  	DebugExitRule (GrammarFileName' "filterExpr");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "filterExpr");  	DebugLocation (60' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  		int alt9 = 9;  		try {  			DebugEnterDecision (9' false);  			switch (input.LA (1)) {  			case CHAIN_OPERATOR:  			case COMPARATOR:  				{  					alt9 = 1;  				}  				break;  			case EXPR:  				{  					int LA9_2 = input.LA (2);  					if ((LA9_2 == DOWN)) {  						int LA9_3 = input.LA (3);  						if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  							alt9 = 2;  						}  						else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  							alt9 = 3;  						}  						else {  							NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  							DebugRecognitionException (nvae);  							throw nvae;  						}  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				break;  			case STRING:  				{  					alt9 = 4;  				}  				break;  			case REGEX:  				{  					alt9 = 5;  				}  				break;  			case NUMBER:  				{  					alt9 = 6;  				}  				break;  			case TRUE:  				{  					alt9 = 7;  				}  				break;  			case FALSE:  				{  					alt9 = 8;  				}  				break;  			case NULL:  				{  					alt9 = 9;  				}  				break;  			default: {  				NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  			}  		}  		finally {  			DebugExitDecision (9);  		}  		switch (alt9) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  			{  				DebugLocation (64' 4);  				DebugLocation (64' 6);  				PushFollow (Follow._comparator_in_filterExpr175);  				comparator6 = comparator ();  				PopFollow ();  				Match (input' TokenTypes.Down' null);  				DebugLocation (64' 18);  				PushFollow (Follow._filterExpr_in_filterExpr179);  				a = filterExpr ();  				PopFollow ();  				DebugLocation (64' 31);  				PushFollow (Follow._filterExpr_in_filterExpr183);  				b = filterExpr ();  				PopFollow ();  				Match (input' TokenTypes.Up' null);  				DebugLocation (65' 4);  				Comparator newComparator;  				switch (comparator6) {  				case "=":  					newComparator = Comparator.Equals;  					break;  				case "!=":  					newComparator = Comparator.NotEquals;  					break;  				case ">":  					newComparator = Comparator.Greater;  					break;  				case "<":  					newComparator = Comparator.Less;  					break;  				case ">=":  					newComparator = Comparator.GreaterOrEqual;  					break;  				case "<=":  					newComparator = Comparator.LessOrEqual;  					break;  				case "&":  					newComparator = Comparator.And;  					break;  				case "|":  					newComparator = Comparator.Or;  					break;  				default:  					newComparator = Comparator.Equals;  					break;  				}  				filterNode = new BoolExpression (a' newComparator' b);  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  			{  				DebugLocation (98' 4);  				DebugLocation (98' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr195);  				Match (input' TokenTypes.Down' null);  				DebugLocation (98' 12);  				PushFollow (Follow._filterExpr_in_filterExpr199);  				f = filterExpr ();  				PopFollow ();  				DebugLocation (98' 31);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  				int alt6 = 2;  				try {  					DebugEnterSubRule (6);  					try {  						DebugEnterDecision (6' false);  						int LA6_1 = input.LA (1);  						if ((LA6_1 == 24)) {  							alt6 = 1;  						}  					}  					finally {  						DebugExitDecision (6);  					}  					switch (alt6) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  						{  							DebugLocation (98' 31);  							inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (6);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (99' 4);  				FilterTreeNode newNode = f;  				if ((inverse != null ? inverse.Text : default(string)) == "!")  					newNode.ToggleInversed ();  				filterNode = newNode;  			}  			break;  		case 3:  			DebugEnterAlt (3);  			// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  			{  				DebugLocation (105' 4);  				DebugLocation (105' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr216);  				Match (input' TokenTypes.Down' null);  				DebugLocation (105' 12);  				PushFollow (Follow._propertyChain_in_filterExpr219);  				propertyChain (propertySegments);  				PopFollow ();  				DebugLocation (105' 51);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  				int alt7 = 2;  				try {  					DebugEnterSubRule (7);  					try {  						DebugEnterDecision (7' false);  						int LA7_1 = input.LA (1);  						if ((LA7_1 == 31)) {  							alt7 = 1;  						}  					}  					finally {  						DebugExitDecision (7);  					}  					switch (alt7) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  						{  							DebugLocation (105' 51);  							inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (7);  				}  				DebugLocation (105' 60);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  				int alt8 = 2;  				try {  					DebugEnterSubRule (8);  					try {  						DebugEnterDecision (8' false);  						int LA8_1 = input.LA (1);  						if ((LA8_1 == 24)) {  							alt8 = 1;  						}  					}  					finally {  						DebugExitDecision (8);  					}  					switch (alt8) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  						{  							DebugLocation (105' 60);  							not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (8);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (106' 4);  				FilterTreeNode newProperty = new Property (propertySegments);  				if ((inverse != null ? inverse.Text : default(string)) == "?")  					filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  				else {  					if ((not != null ? not.Text : default(string)) == "!")  						newProperty.ToggleInversed ();  					filterNode = newProperty;  				}  			}  			break;  		case 4:  			DebugEnterAlt (4);  			// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  			{  				DebugLocation (116' 4);  				STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  				DebugLocation (117' 4);  				string stringText = (STRING7 != null ? STRING7.Text : default(string));  				stringText = stringText.Substring (1' stringText.Length - 2);  				filterNode = new Value (stringText);  			}  			break;  		case 5:  			DebugEnterAlt (5);  			// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  			{  				DebugLocation (122' 4);  				REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  				DebugLocation (123' 4);  				string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  				regexText = regexText.Substring (1' regexText.Length - 2);  				filterNode = new RegExp (regexText);  			}  			break;  		case 6:  			DebugEnterAlt (6);  			// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  			{  				DebugLocation (128' 4);  				NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  				DebugLocation (129' 4);  				filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  			}  			break;  		case 7:  			DebugEnterAlt (7);  			// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  			{  				DebugLocation (132' 4);  				Match (input' TRUE' Follow._TRUE_in_filterExpr271);  				DebugLocation (133' 4);  				filterNode = new Value (true);  			}  			break;  		case 8:  			DebugEnterAlt (8);  			// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  			{  				DebugLocation (136' 4);  				Match (input' FALSE' Follow._FALSE_in_filterExpr281);  				DebugLocation (137' 4);  				filterNode = new Value (false);  			}  			break;  		case 9:  			DebugEnterAlt (9);  			// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  			{  				DebugLocation (140' 4);  				Match (input' NULL' Follow._NULL_in_filterExpr291);  				DebugLocation (141' 4);  				filterNode = new Value (null);  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("filterExpr"' 6);  		LeaveRule ("filterExpr"' 6);  		LeaveRule_filterExpr ();  	}  	DebugLocation (144' 1);  }  finally {  	DebugExitRule (GrammarFileName' "filterExpr");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "filterExpr");  	DebugLocation (60' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  		int alt9 = 9;  		try {  			DebugEnterDecision (9' false);  			switch (input.LA (1)) {  			case CHAIN_OPERATOR:  			case COMPARATOR:  				{  					alt9 = 1;  				}  				break;  			case EXPR:  				{  					int LA9_2 = input.LA (2);  					if ((LA9_2 == DOWN)) {  						int LA9_3 = input.LA (3);  						if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  							alt9 = 2;  						}  						else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  							alt9 = 3;  						}  						else {  							NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  							DebugRecognitionException (nvae);  							throw nvae;  						}  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				break;  			case STRING:  				{  					alt9 = 4;  				}  				break;  			case REGEX:  				{  					alt9 = 5;  				}  				break;  			case NUMBER:  				{  					alt9 = 6;  				}  				break;  			case TRUE:  				{  					alt9 = 7;  				}  				break;  			case FALSE:  				{  					alt9 = 8;  				}  				break;  			case NULL:  				{  					alt9 = 9;  				}  				break;  			default: {  				NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  			}  		}  		finally {  			DebugExitDecision (9);  		}  		switch (alt9) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  			{  				DebugLocation (64' 4);  				DebugLocation (64' 6);  				PushFollow (Follow._comparator_in_filterExpr175);  				comparator6 = comparator ();  				PopFollow ();  				Match (input' TokenTypes.Down' null);  				DebugLocation (64' 18);  				PushFollow (Follow._filterExpr_in_filterExpr179);  				a = filterExpr ();  				PopFollow ();  				DebugLocation (64' 31);  				PushFollow (Follow._filterExpr_in_filterExpr183);  				b = filterExpr ();  				PopFollow ();  				Match (input' TokenTypes.Up' null);  				DebugLocation (65' 4);  				Comparator newComparator;  				switch (comparator6) {  				case "=":  					newComparator = Comparator.Equals;  					break;  				case "!=":  					newComparator = Comparator.NotEquals;  					break;  				case ">":  					newComparator = Comparator.Greater;  					break;  				case "<":  					newComparator = Comparator.Less;  					break;  				case ">=":  					newComparator = Comparator.GreaterOrEqual;  					break;  				case "<=":  					newComparator = Comparator.LessOrEqual;  					break;  				case "&":  					newComparator = Comparator.And;  					break;  				case "|":  					newComparator = Comparator.Or;  					break;  				default:  					newComparator = Comparator.Equals;  					break;  				}  				filterNode = new BoolExpression (a' newComparator' b);  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  			{  				DebugLocation (98' 4);  				DebugLocation (98' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr195);  				Match (input' TokenTypes.Down' null);  				DebugLocation (98' 12);  				PushFollow (Follow._filterExpr_in_filterExpr199);  				f = filterExpr ();  				PopFollow ();  				DebugLocation (98' 31);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  				int alt6 = 2;  				try {  					DebugEnterSubRule (6);  					try {  						DebugEnterDecision (6' false);  						int LA6_1 = input.LA (1);  						if ((LA6_1 == 24)) {  							alt6 = 1;  						}  					}  					finally {  						DebugExitDecision (6);  					}  					switch (alt6) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  						{  							DebugLocation (98' 31);  							inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (6);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (99' 4);  				FilterTreeNode newNode = f;  				if ((inverse != null ? inverse.Text : default(string)) == "!")  					newNode.ToggleInversed ();  				filterNode = newNode;  			}  			break;  		case 3:  			DebugEnterAlt (3);  			// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  			{  				DebugLocation (105' 4);  				DebugLocation (105' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr216);  				Match (input' TokenTypes.Down' null);  				DebugLocation (105' 12);  				PushFollow (Follow._propertyChain_in_filterExpr219);  				propertyChain (propertySegments);  				PopFollow ();  				DebugLocation (105' 51);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  				int alt7 = 2;  				try {  					DebugEnterSubRule (7);  					try {  						DebugEnterDecision (7' false);  						int LA7_1 = input.LA (1);  						if ((LA7_1 == 31)) {  							alt7 = 1;  						}  					}  					finally {  						DebugExitDecision (7);  					}  					switch (alt7) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  						{  							DebugLocation (105' 51);  							inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (7);  				}  				DebugLocation (105' 60);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  				int alt8 = 2;  				try {  					DebugEnterSubRule (8);  					try {  						DebugEnterDecision (8' false);  						int LA8_1 = input.LA (1);  						if ((LA8_1 == 24)) {  							alt8 = 1;  						}  					}  					finally {  						DebugExitDecision (8);  					}  					switch (alt8) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  						{  							DebugLocation (105' 60);  							not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (8);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (106' 4);  				FilterTreeNode newProperty = new Property (propertySegments);  				if ((inverse != null ? inverse.Text : default(string)) == "?")  					filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  				else {  					if ((not != null ? not.Text : default(string)) == "!")  						newProperty.ToggleInversed ();  					filterNode = newProperty;  				}  			}  			break;  		case 4:  			DebugEnterAlt (4);  			// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  			{  				DebugLocation (116' 4);  				STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  				DebugLocation (117' 4);  				string stringText = (STRING7 != null ? STRING7.Text : default(string));  				stringText = stringText.Substring (1' stringText.Length - 2);  				filterNode = new Value (stringText);  			}  			break;  		case 5:  			DebugEnterAlt (5);  			// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  			{  				DebugLocation (122' 4);  				REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  				DebugLocation (123' 4);  				string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  				regexText = regexText.Substring (1' regexText.Length - 2);  				filterNode = new RegExp (regexText);  			}  			break;  		case 6:  			DebugEnterAlt (6);  			// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  			{  				DebugLocation (128' 4);  				NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  				DebugLocation (129' 4);  				filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  			}  			break;  		case 7:  			DebugEnterAlt (7);  			// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  			{  				DebugLocation (132' 4);  				Match (input' TRUE' Follow._TRUE_in_filterExpr271);  				DebugLocation (133' 4);  				filterNode = new Value (true);  			}  			break;  		case 8:  			DebugEnterAlt (8);  			// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  			{  				DebugLocation (136' 4);  				Match (input' FALSE' Follow._FALSE_in_filterExpr281);  				DebugLocation (137' 4);  				filterNode = new Value (false);  			}  			break;  		case 9:  			DebugEnterAlt (9);  			// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  			{  				DebugLocation (140' 4);  				Match (input' NULL' Follow._NULL_in_filterExpr291);  				DebugLocation (141' 4);  				filterNode = new Value (null);  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("filterExpr"' 6);  		LeaveRule ("filterExpr"' 6);  		LeaveRule_filterExpr ();  	}  	DebugLocation (144' 1);  }  finally {  	DebugExitRule (GrammarFileName' "filterExpr");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "filterExpr");  	DebugLocation (60' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  		int alt9 = 9;  		try {  			DebugEnterDecision (9' false);  			switch (input.LA (1)) {  			case CHAIN_OPERATOR:  			case COMPARATOR:  				{  					alt9 = 1;  				}  				break;  			case EXPR:  				{  					int LA9_2 = input.LA (2);  					if ((LA9_2 == DOWN)) {  						int LA9_3 = input.LA (3);  						if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  							alt9 = 2;  						}  						else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  							alt9 = 3;  						}  						else {  							NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  							DebugRecognitionException (nvae);  							throw nvae;  						}  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				break;  			case STRING:  				{  					alt9 = 4;  				}  				break;  			case REGEX:  				{  					alt9 = 5;  				}  				break;  			case NUMBER:  				{  					alt9 = 6;  				}  				break;  			case TRUE:  				{  					alt9 = 7;  				}  				break;  			case FALSE:  				{  					alt9 = 8;  				}  				break;  			case NULL:  				{  					alt9 = 9;  				}  				break;  			default: {  				NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  			}  		}  		finally {  			DebugExitDecision (9);  		}  		switch (alt9) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  			{  				DebugLocation (64' 4);  				DebugLocation (64' 6);  				PushFollow (Follow._comparator_in_filterExpr175);  				comparator6 = comparator ();  				PopFollow ();  				Match (input' TokenTypes.Down' null);  				DebugLocation (64' 18);  				PushFollow (Follow._filterExpr_in_filterExpr179);  				a = filterExpr ();  				PopFollow ();  				DebugLocation (64' 31);  				PushFollow (Follow._filterExpr_in_filterExpr183);  				b = filterExpr ();  				PopFollow ();  				Match (input' TokenTypes.Up' null);  				DebugLocation (65' 4);  				Comparator newComparator;  				switch (comparator6) {  				case "=":  					newComparator = Comparator.Equals;  					break;  				case "!=":  					newComparator = Comparator.NotEquals;  					break;  				case ">":  					newComparator = Comparator.Greater;  					break;  				case "<":  					newComparator = Comparator.Less;  					break;  				case ">=":  					newComparator = Comparator.GreaterOrEqual;  					break;  				case "<=":  					newComparator = Comparator.LessOrEqual;  					break;  				case "&":  					newComparator = Comparator.And;  					break;  				case "|":  					newComparator = Comparator.Or;  					break;  				default:  					newComparator = Comparator.Equals;  					break;  				}  				filterNode = new BoolExpression (a' newComparator' b);  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  			{  				DebugLocation (98' 4);  				DebugLocation (98' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr195);  				Match (input' TokenTypes.Down' null);  				DebugLocation (98' 12);  				PushFollow (Follow._filterExpr_in_filterExpr199);  				f = filterExpr ();  				PopFollow ();  				DebugLocation (98' 31);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  				int alt6 = 2;  				try {  					DebugEnterSubRule (6);  					try {  						DebugEnterDecision (6' false);  						int LA6_1 = input.LA (1);  						if ((LA6_1 == 24)) {  							alt6 = 1;  						}  					}  					finally {  						DebugExitDecision (6);  					}  					switch (alt6) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  						{  							DebugLocation (98' 31);  							inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (6);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (99' 4);  				FilterTreeNode newNode = f;  				if ((inverse != null ? inverse.Text : default(string)) == "!")  					newNode.ToggleInversed ();  				filterNode = newNode;  			}  			break;  		case 3:  			DebugEnterAlt (3);  			// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  			{  				DebugLocation (105' 4);  				DebugLocation (105' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr216);  				Match (input' TokenTypes.Down' null);  				DebugLocation (105' 12);  				PushFollow (Follow._propertyChain_in_filterExpr219);  				propertyChain (propertySegments);  				PopFollow ();  				DebugLocation (105' 51);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  				int alt7 = 2;  				try {  					DebugEnterSubRule (7);  					try {  						DebugEnterDecision (7' false);  						int LA7_1 = input.LA (1);  						if ((LA7_1 == 31)) {  							alt7 = 1;  						}  					}  					finally {  						DebugExitDecision (7);  					}  					switch (alt7) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  						{  							DebugLocation (105' 51);  							inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (7);  				}  				DebugLocation (105' 60);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  				int alt8 = 2;  				try {  					DebugEnterSubRule (8);  					try {  						DebugEnterDecision (8' false);  						int LA8_1 = input.LA (1);  						if ((LA8_1 == 24)) {  							alt8 = 1;  						}  					}  					finally {  						DebugExitDecision (8);  					}  					switch (alt8) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  						{  							DebugLocation (105' 60);  							not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (8);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (106' 4);  				FilterTreeNode newProperty = new Property (propertySegments);  				if ((inverse != null ? inverse.Text : default(string)) == "?")  					filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  				else {  					if ((not != null ? not.Text : default(string)) == "!")  						newProperty.ToggleInversed ();  					filterNode = newProperty;  				}  			}  			break;  		case 4:  			DebugEnterAlt (4);  			// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  			{  				DebugLocation (116' 4);  				STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  				DebugLocation (117' 4);  				string stringText = (STRING7 != null ? STRING7.Text : default(string));  				stringText = stringText.Substring (1' stringText.Length - 2);  				filterNode = new Value (stringText);  			}  			break;  		case 5:  			DebugEnterAlt (5);  			// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  			{  				DebugLocation (122' 4);  				REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  				DebugLocation (123' 4);  				string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  				regexText = regexText.Substring (1' regexText.Length - 2);  				filterNode = new RegExp (regexText);  			}  			break;  		case 6:  			DebugEnterAlt (6);  			// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  			{  				DebugLocation (128' 4);  				NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  				DebugLocation (129' 4);  				filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  			}  			break;  		case 7:  			DebugEnterAlt (7);  			// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  			{  				DebugLocation (132' 4);  				Match (input' TRUE' Follow._TRUE_in_filterExpr271);  				DebugLocation (133' 4);  				filterNode = new Value (true);  			}  			break;  		case 8:  			DebugEnterAlt (8);  			// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  			{  				DebugLocation (136' 4);  				Match (input' FALSE' Follow._FALSE_in_filterExpr281);  				DebugLocation (137' 4);  				filterNode = new Value (false);  			}  			break;  		case 9:  			DebugEnterAlt (9);  			// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  			{  				DebugLocation (140' 4);  				Match (input' NULL' Follow._NULL_in_filterExpr291);  				DebugLocation (141' 4);  				filterNode = new Value (null);  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("filterExpr"' 6);  		LeaveRule ("filterExpr"' 6);  		LeaveRule_filterExpr ();  	}  	DebugLocation (144' 1);  }  finally {  	DebugExitRule (GrammarFileName' "filterExpr");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "filterExpr");  	DebugLocation (60' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  		int alt9 = 9;  		try {  			DebugEnterDecision (9' false);  			switch (input.LA (1)) {  			case CHAIN_OPERATOR:  			case COMPARATOR:  				{  					alt9 = 1;  				}  				break;  			case EXPR:  				{  					int LA9_2 = input.LA (2);  					if ((LA9_2 == DOWN)) {  						int LA9_3 = input.LA (3);  						if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  							alt9 = 2;  						}  						else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  							alt9 = 3;  						}  						else {  							NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  							DebugRecognitionException (nvae);  							throw nvae;  						}  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				break;  			case STRING:  				{  					alt9 = 4;  				}  				break;  			case REGEX:  				{  					alt9 = 5;  				}  				break;  			case NUMBER:  				{  					alt9 = 6;  				}  				break;  			case TRUE:  				{  					alt9 = 7;  				}  				break;  			case FALSE:  				{  					alt9 = 8;  				}  				break;  			case NULL:  				{  					alt9 = 9;  				}  				break;  			default: {  				NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  			}  		}  		finally {  			DebugExitDecision (9);  		}  		switch (alt9) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  			{  				DebugLocation (64' 4);  				DebugLocation (64' 6);  				PushFollow (Follow._comparator_in_filterExpr175);  				comparator6 = comparator ();  				PopFollow ();  				Match (input' TokenTypes.Down' null);  				DebugLocation (64' 18);  				PushFollow (Follow._filterExpr_in_filterExpr179);  				a = filterExpr ();  				PopFollow ();  				DebugLocation (64' 31);  				PushFollow (Follow._filterExpr_in_filterExpr183);  				b = filterExpr ();  				PopFollow ();  				Match (input' TokenTypes.Up' null);  				DebugLocation (65' 4);  				Comparator newComparator;  				switch (comparator6) {  				case "=":  					newComparator = Comparator.Equals;  					break;  				case "!=":  					newComparator = Comparator.NotEquals;  					break;  				case ">":  					newComparator = Comparator.Greater;  					break;  				case "<":  					newComparator = Comparator.Less;  					break;  				case ">=":  					newComparator = Comparator.GreaterOrEqual;  					break;  				case "<=":  					newComparator = Comparator.LessOrEqual;  					break;  				case "&":  					newComparator = Comparator.And;  					break;  				case "|":  					newComparator = Comparator.Or;  					break;  				default:  					newComparator = Comparator.Equals;  					break;  				}  				filterNode = new BoolExpression (a' newComparator' b);  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  			{  				DebugLocation (98' 4);  				DebugLocation (98' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr195);  				Match (input' TokenTypes.Down' null);  				DebugLocation (98' 12);  				PushFollow (Follow._filterExpr_in_filterExpr199);  				f = filterExpr ();  				PopFollow ();  				DebugLocation (98' 31);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  				int alt6 = 2;  				try {  					DebugEnterSubRule (6);  					try {  						DebugEnterDecision (6' false);  						int LA6_1 = input.LA (1);  						if ((LA6_1 == 24)) {  							alt6 = 1;  						}  					}  					finally {  						DebugExitDecision (6);  					}  					switch (alt6) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  						{  							DebugLocation (98' 31);  							inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (6);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (99' 4);  				FilterTreeNode newNode = f;  				if ((inverse != null ? inverse.Text : default(string)) == "!")  					newNode.ToggleInversed ();  				filterNode = newNode;  			}  			break;  		case 3:  			DebugEnterAlt (3);  			// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  			{  				DebugLocation (105' 4);  				DebugLocation (105' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr216);  				Match (input' TokenTypes.Down' null);  				DebugLocation (105' 12);  				PushFollow (Follow._propertyChain_in_filterExpr219);  				propertyChain (propertySegments);  				PopFollow ();  				DebugLocation (105' 51);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  				int alt7 = 2;  				try {  					DebugEnterSubRule (7);  					try {  						DebugEnterDecision (7' false);  						int LA7_1 = input.LA (1);  						if ((LA7_1 == 31)) {  							alt7 = 1;  						}  					}  					finally {  						DebugExitDecision (7);  					}  					switch (alt7) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  						{  							DebugLocation (105' 51);  							inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (7);  				}  				DebugLocation (105' 60);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  				int alt8 = 2;  				try {  					DebugEnterSubRule (8);  					try {  						DebugEnterDecision (8' false);  						int LA8_1 = input.LA (1);  						if ((LA8_1 == 24)) {  							alt8 = 1;  						}  					}  					finally {  						DebugExitDecision (8);  					}  					switch (alt8) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  						{  							DebugLocation (105' 60);  							not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (8);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (106' 4);  				FilterTreeNode newProperty = new Property (propertySegments);  				if ((inverse != null ? inverse.Text : default(string)) == "?")  					filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  				else {  					if ((not != null ? not.Text : default(string)) == "!")  						newProperty.ToggleInversed ();  					filterNode = newProperty;  				}  			}  			break;  		case 4:  			DebugEnterAlt (4);  			// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  			{  				DebugLocation (116' 4);  				STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  				DebugLocation (117' 4);  				string stringText = (STRING7 != null ? STRING7.Text : default(string));  				stringText = stringText.Substring (1' stringText.Length - 2);  				filterNode = new Value (stringText);  			}  			break;  		case 5:  			DebugEnterAlt (5);  			// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  			{  				DebugLocation (122' 4);  				REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  				DebugLocation (123' 4);  				string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  				regexText = regexText.Substring (1' regexText.Length - 2);  				filterNode = new RegExp (regexText);  			}  			break;  		case 6:  			DebugEnterAlt (6);  			// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  			{  				DebugLocation (128' 4);  				NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  				DebugLocation (129' 4);  				filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  			}  			break;  		case 7:  			DebugEnterAlt (7);  			// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  			{  				DebugLocation (132' 4);  				Match (input' TRUE' Follow._TRUE_in_filterExpr271);  				DebugLocation (133' 4);  				filterNode = new Value (true);  			}  			break;  		case 8:  			DebugEnterAlt (8);  			// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  			{  				DebugLocation (136' 4);  				Match (input' FALSE' Follow._FALSE_in_filterExpr281);  				DebugLocation (137' 4);  				filterNode = new Value (false);  			}  			break;  		case 9:  			DebugEnterAlt (9);  			// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  			{  				DebugLocation (140' 4);  				Match (input' NULL' Follow._NULL_in_filterExpr291);  				DebugLocation (141' 4);  				filterNode = new Value (null);  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("filterExpr"' 6);  		LeaveRule ("filterExpr"' 6);  		LeaveRule_filterExpr ();  	}  	DebugLocation (144' 1);  }  finally {  	DebugExitRule (GrammarFileName' "filterExpr");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "filterExpr");  	DebugLocation (60' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  		int alt9 = 9;  		try {  			DebugEnterDecision (9' false);  			switch (input.LA (1)) {  			case CHAIN_OPERATOR:  			case COMPARATOR:  				{  					alt9 = 1;  				}  				break;  			case EXPR:  				{  					int LA9_2 = input.LA (2);  					if ((LA9_2 == DOWN)) {  						int LA9_3 = input.LA (3);  						if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  							alt9 = 2;  						}  						else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  							alt9 = 3;  						}  						else {  							NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  							DebugRecognitionException (nvae);  							throw nvae;  						}  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				break;  			case STRING:  				{  					alt9 = 4;  				}  				break;  			case REGEX:  				{  					alt9 = 5;  				}  				break;  			case NUMBER:  				{  					alt9 = 6;  				}  				break;  			case TRUE:  				{  					alt9 = 7;  				}  				break;  			case FALSE:  				{  					alt9 = 8;  				}  				break;  			case NULL:  				{  					alt9 = 9;  				}  				break;  			default: {  				NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  			}  		}  		finally {  			DebugExitDecision (9);  		}  		switch (alt9) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  			{  				DebugLocation (64' 4);  				DebugLocation (64' 6);  				PushFollow (Follow._comparator_in_filterExpr175);  				comparator6 = comparator ();  				PopFollow ();  				Match (input' TokenTypes.Down' null);  				DebugLocation (64' 18);  				PushFollow (Follow._filterExpr_in_filterExpr179);  				a = filterExpr ();  				PopFollow ();  				DebugLocation (64' 31);  				PushFollow (Follow._filterExpr_in_filterExpr183);  				b = filterExpr ();  				PopFollow ();  				Match (input' TokenTypes.Up' null);  				DebugLocation (65' 4);  				Comparator newComparator;  				switch (comparator6) {  				case "=":  					newComparator = Comparator.Equals;  					break;  				case "!=":  					newComparator = Comparator.NotEquals;  					break;  				case ">":  					newComparator = Comparator.Greater;  					break;  				case "<":  					newComparator = Comparator.Less;  					break;  				case ">=":  					newComparator = Comparator.GreaterOrEqual;  					break;  				case "<=":  					newComparator = Comparator.LessOrEqual;  					break;  				case "&":  					newComparator = Comparator.And;  					break;  				case "|":  					newComparator = Comparator.Or;  					break;  				default:  					newComparator = Comparator.Equals;  					break;  				}  				filterNode = new BoolExpression (a' newComparator' b);  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  			{  				DebugLocation (98' 4);  				DebugLocation (98' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr195);  				Match (input' TokenTypes.Down' null);  				DebugLocation (98' 12);  				PushFollow (Follow._filterExpr_in_filterExpr199);  				f = filterExpr ();  				PopFollow ();  				DebugLocation (98' 31);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  				int alt6 = 2;  				try {  					DebugEnterSubRule (6);  					try {  						DebugEnterDecision (6' false);  						int LA6_1 = input.LA (1);  						if ((LA6_1 == 24)) {  							alt6 = 1;  						}  					}  					finally {  						DebugExitDecision (6);  					}  					switch (alt6) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  						{  							DebugLocation (98' 31);  							inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (6);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (99' 4);  				FilterTreeNode newNode = f;  				if ((inverse != null ? inverse.Text : default(string)) == "!")  					newNode.ToggleInversed ();  				filterNode = newNode;  			}  			break;  		case 3:  			DebugEnterAlt (3);  			// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  			{  				DebugLocation (105' 4);  				DebugLocation (105' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr216);  				Match (input' TokenTypes.Down' null);  				DebugLocation (105' 12);  				PushFollow (Follow._propertyChain_in_filterExpr219);  				propertyChain (propertySegments);  				PopFollow ();  				DebugLocation (105' 51);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  				int alt7 = 2;  				try {  					DebugEnterSubRule (7);  					try {  						DebugEnterDecision (7' false);  						int LA7_1 = input.LA (1);  						if ((LA7_1 == 31)) {  							alt7 = 1;  						}  					}  					finally {  						DebugExitDecision (7);  					}  					switch (alt7) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  						{  							DebugLocation (105' 51);  							inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (7);  				}  				DebugLocation (105' 60);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  				int alt8 = 2;  				try {  					DebugEnterSubRule (8);  					try {  						DebugEnterDecision (8' false);  						int LA8_1 = input.LA (1);  						if ((LA8_1 == 24)) {  							alt8 = 1;  						}  					}  					finally {  						DebugExitDecision (8);  					}  					switch (alt8) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  						{  							DebugLocation (105' 60);  							not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (8);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (106' 4);  				FilterTreeNode newProperty = new Property (propertySegments);  				if ((inverse != null ? inverse.Text : default(string)) == "?")  					filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  				else {  					if ((not != null ? not.Text : default(string)) == "!")  						newProperty.ToggleInversed ();  					filterNode = newProperty;  				}  			}  			break;  		case 4:  			DebugEnterAlt (4);  			// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  			{  				DebugLocation (116' 4);  				STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  				DebugLocation (117' 4);  				string stringText = (STRING7 != null ? STRING7.Text : default(string));  				stringText = stringText.Substring (1' stringText.Length - 2);  				filterNode = new Value (stringText);  			}  			break;  		case 5:  			DebugEnterAlt (5);  			// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  			{  				DebugLocation (122' 4);  				REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  				DebugLocation (123' 4);  				string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  				regexText = regexText.Substring (1' regexText.Length - 2);  				filterNode = new RegExp (regexText);  			}  			break;  		case 6:  			DebugEnterAlt (6);  			// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  			{  				DebugLocation (128' 4);  				NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  				DebugLocation (129' 4);  				filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  			}  			break;  		case 7:  			DebugEnterAlt (7);  			// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  			{  				DebugLocation (132' 4);  				Match (input' TRUE' Follow._TRUE_in_filterExpr271);  				DebugLocation (133' 4);  				filterNode = new Value (true);  			}  			break;  		case 8:  			DebugEnterAlt (8);  			// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  			{  				DebugLocation (136' 4);  				Match (input' FALSE' Follow._FALSE_in_filterExpr281);  				DebugLocation (137' 4);  				filterNode = new Value (false);  			}  			break;  		case 9:  			DebugEnterAlt (9);  			// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  			{  				DebugLocation (140' 4);  				Match (input' NULL' Follow._NULL_in_filterExpr291);  				DebugLocation (141' 4);  				filterNode = new Value (null);  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("filterExpr"' 6);  		LeaveRule ("filterExpr"' 6);  		LeaveRule_filterExpr ();  	}  	DebugLocation (144' 1);  }  finally {  	DebugExitRule (GrammarFileName' "filterExpr");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "filterExpr");  	DebugLocation (60' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  		int alt9 = 9;  		try {  			DebugEnterDecision (9' false);  			switch (input.LA (1)) {  			case CHAIN_OPERATOR:  			case COMPARATOR:  				{  					alt9 = 1;  				}  				break;  			case EXPR:  				{  					int LA9_2 = input.LA (2);  					if ((LA9_2 == DOWN)) {  						int LA9_3 = input.LA (3);  						if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  							alt9 = 2;  						}  						else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  							alt9 = 3;  						}  						else {  							NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  							DebugRecognitionException (nvae);  							throw nvae;  						}  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				break;  			case STRING:  				{  					alt9 = 4;  				}  				break;  			case REGEX:  				{  					alt9 = 5;  				}  				break;  			case NUMBER:  				{  					alt9 = 6;  				}  				break;  			case TRUE:  				{  					alt9 = 7;  				}  				break;  			case FALSE:  				{  					alt9 = 8;  				}  				break;  			case NULL:  				{  					alt9 = 9;  				}  				break;  			default: {  				NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  			}  		}  		finally {  			DebugExitDecision (9);  		}  		switch (alt9) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  			{  				DebugLocation (64' 4);  				DebugLocation (64' 6);  				PushFollow (Follow._comparator_in_filterExpr175);  				comparator6 = comparator ();  				PopFollow ();  				Match (input' TokenTypes.Down' null);  				DebugLocation (64' 18);  				PushFollow (Follow._filterExpr_in_filterExpr179);  				a = filterExpr ();  				PopFollow ();  				DebugLocation (64' 31);  				PushFollow (Follow._filterExpr_in_filterExpr183);  				b = filterExpr ();  				PopFollow ();  				Match (input' TokenTypes.Up' null);  				DebugLocation (65' 4);  				Comparator newComparator;  				switch (comparator6) {  				case "=":  					newComparator = Comparator.Equals;  					break;  				case "!=":  					newComparator = Comparator.NotEquals;  					break;  				case ">":  					newComparator = Comparator.Greater;  					break;  				case "<":  					newComparator = Comparator.Less;  					break;  				case ">=":  					newComparator = Comparator.GreaterOrEqual;  					break;  				case "<=":  					newComparator = Comparator.LessOrEqual;  					break;  				case "&":  					newComparator = Comparator.And;  					break;  				case "|":  					newComparator = Comparator.Or;  					break;  				default:  					newComparator = Comparator.Equals;  					break;  				}  				filterNode = new BoolExpression (a' newComparator' b);  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  			{  				DebugLocation (98' 4);  				DebugLocation (98' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr195);  				Match (input' TokenTypes.Down' null);  				DebugLocation (98' 12);  				PushFollow (Follow._filterExpr_in_filterExpr199);  				f = filterExpr ();  				PopFollow ();  				DebugLocation (98' 31);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  				int alt6 = 2;  				try {  					DebugEnterSubRule (6);  					try {  						DebugEnterDecision (6' false);  						int LA6_1 = input.LA (1);  						if ((LA6_1 == 24)) {  							alt6 = 1;  						}  					}  					finally {  						DebugExitDecision (6);  					}  					switch (alt6) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  						{  							DebugLocation (98' 31);  							inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (6);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (99' 4);  				FilterTreeNode newNode = f;  				if ((inverse != null ? inverse.Text : default(string)) == "!")  					newNode.ToggleInversed ();  				filterNode = newNode;  			}  			break;  		case 3:  			DebugEnterAlt (3);  			// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  			{  				DebugLocation (105' 4);  				DebugLocation (105' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr216);  				Match (input' TokenTypes.Down' null);  				DebugLocation (105' 12);  				PushFollow (Follow._propertyChain_in_filterExpr219);  				propertyChain (propertySegments);  				PopFollow ();  				DebugLocation (105' 51);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  				int alt7 = 2;  				try {  					DebugEnterSubRule (7);  					try {  						DebugEnterDecision (7' false);  						int LA7_1 = input.LA (1);  						if ((LA7_1 == 31)) {  							alt7 = 1;  						}  					}  					finally {  						DebugExitDecision (7);  					}  					switch (alt7) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  						{  							DebugLocation (105' 51);  							inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (7);  				}  				DebugLocation (105' 60);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  				int alt8 = 2;  				try {  					DebugEnterSubRule (8);  					try {  						DebugEnterDecision (8' false);  						int LA8_1 = input.LA (1);  						if ((LA8_1 == 24)) {  							alt8 = 1;  						}  					}  					finally {  						DebugExitDecision (8);  					}  					switch (alt8) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  						{  							DebugLocation (105' 60);  							not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (8);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (106' 4);  				FilterTreeNode newProperty = new Property (propertySegments);  				if ((inverse != null ? inverse.Text : default(string)) == "?")  					filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  				else {  					if ((not != null ? not.Text : default(string)) == "!")  						newProperty.ToggleInversed ();  					filterNode = newProperty;  				}  			}  			break;  		case 4:  			DebugEnterAlt (4);  			// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  			{  				DebugLocation (116' 4);  				STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  				DebugLocation (117' 4);  				string stringText = (STRING7 != null ? STRING7.Text : default(string));  				stringText = stringText.Substring (1' stringText.Length - 2);  				filterNode = new Value (stringText);  			}  			break;  		case 5:  			DebugEnterAlt (5);  			// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  			{  				DebugLocation (122' 4);  				REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  				DebugLocation (123' 4);  				string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  				regexText = regexText.Substring (1' regexText.Length - 2);  				filterNode = new RegExp (regexText);  			}  			break;  		case 6:  			DebugEnterAlt (6);  			// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  			{  				DebugLocation (128' 4);  				NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  				DebugLocation (129' 4);  				filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  			}  			break;  		case 7:  			DebugEnterAlt (7);  			// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  			{  				DebugLocation (132' 4);  				Match (input' TRUE' Follow._TRUE_in_filterExpr271);  				DebugLocation (133' 4);  				filterNode = new Value (true);  			}  			break;  		case 8:  			DebugEnterAlt (8);  			// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  			{  				DebugLocation (136' 4);  				Match (input' FALSE' Follow._FALSE_in_filterExpr281);  				DebugLocation (137' 4);  				filterNode = new Value (false);  			}  			break;  		case 9:  			DebugEnterAlt (9);  			// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  			{  				DebugLocation (140' 4);  				Match (input' NULL' Follow._NULL_in_filterExpr291);  				DebugLocation (141' 4);  				filterNode = new Value (null);  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("filterExpr"' 6);  		LeaveRule ("filterExpr"' 6);  		LeaveRule_filterExpr ();  	}  	DebugLocation (144' 1);  }  finally {  	DebugExitRule (GrammarFileName' "filterExpr");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "filterExpr");  	DebugLocation (60' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  		int alt9 = 9;  		try {  			DebugEnterDecision (9' false);  			switch (input.LA (1)) {  			case CHAIN_OPERATOR:  			case COMPARATOR:  				{  					alt9 = 1;  				}  				break;  			case EXPR:  				{  					int LA9_2 = input.LA (2);  					if ((LA9_2 == DOWN)) {  						int LA9_3 = input.LA (3);  						if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  							alt9 = 2;  						}  						else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  							alt9 = 3;  						}  						else {  							NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  							DebugRecognitionException (nvae);  							throw nvae;  						}  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				break;  			case STRING:  				{  					alt9 = 4;  				}  				break;  			case REGEX:  				{  					alt9 = 5;  				}  				break;  			case NUMBER:  				{  					alt9 = 6;  				}  				break;  			case TRUE:  				{  					alt9 = 7;  				}  				break;  			case FALSE:  				{  					alt9 = 8;  				}  				break;  			case NULL:  				{  					alt9 = 9;  				}  				break;  			default: {  				NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  			}  		}  		finally {  			DebugExitDecision (9);  		}  		switch (alt9) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  			{  				DebugLocation (64' 4);  				DebugLocation (64' 6);  				PushFollow (Follow._comparator_in_filterExpr175);  				comparator6 = comparator ();  				PopFollow ();  				Match (input' TokenTypes.Down' null);  				DebugLocation (64' 18);  				PushFollow (Follow._filterExpr_in_filterExpr179);  				a = filterExpr ();  				PopFollow ();  				DebugLocation (64' 31);  				PushFollow (Follow._filterExpr_in_filterExpr183);  				b = filterExpr ();  				PopFollow ();  				Match (input' TokenTypes.Up' null);  				DebugLocation (65' 4);  				Comparator newComparator;  				switch (comparator6) {  				case "=":  					newComparator = Comparator.Equals;  					break;  				case "!=":  					newComparator = Comparator.NotEquals;  					break;  				case ">":  					newComparator = Comparator.Greater;  					break;  				case "<":  					newComparator = Comparator.Less;  					break;  				case ">=":  					newComparator = Comparator.GreaterOrEqual;  					break;  				case "<=":  					newComparator = Comparator.LessOrEqual;  					break;  				case "&":  					newComparator = Comparator.And;  					break;  				case "|":  					newComparator = Comparator.Or;  					break;  				default:  					newComparator = Comparator.Equals;  					break;  				}  				filterNode = new BoolExpression (a' newComparator' b);  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  			{  				DebugLocation (98' 4);  				DebugLocation (98' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr195);  				Match (input' TokenTypes.Down' null);  				DebugLocation (98' 12);  				PushFollow (Follow._filterExpr_in_filterExpr199);  				f = filterExpr ();  				PopFollow ();  				DebugLocation (98' 31);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  				int alt6 = 2;  				try {  					DebugEnterSubRule (6);  					try {  						DebugEnterDecision (6' false);  						int LA6_1 = input.LA (1);  						if ((LA6_1 == 24)) {  							alt6 = 1;  						}  					}  					finally {  						DebugExitDecision (6);  					}  					switch (alt6) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  						{  							DebugLocation (98' 31);  							inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (6);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (99' 4);  				FilterTreeNode newNode = f;  				if ((inverse != null ? inverse.Text : default(string)) == "!")  					newNode.ToggleInversed ();  				filterNode = newNode;  			}  			break;  		case 3:  			DebugEnterAlt (3);  			// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  			{  				DebugLocation (105' 4);  				DebugLocation (105' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr216);  				Match (input' TokenTypes.Down' null);  				DebugLocation (105' 12);  				PushFollow (Follow._propertyChain_in_filterExpr219);  				propertyChain (propertySegments);  				PopFollow ();  				DebugLocation (105' 51);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  				int alt7 = 2;  				try {  					DebugEnterSubRule (7);  					try {  						DebugEnterDecision (7' false);  						int LA7_1 = input.LA (1);  						if ((LA7_1 == 31)) {  							alt7 = 1;  						}  					}  					finally {  						DebugExitDecision (7);  					}  					switch (alt7) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  						{  							DebugLocation (105' 51);  							inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (7);  				}  				DebugLocation (105' 60);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  				int alt8 = 2;  				try {  					DebugEnterSubRule (8);  					try {  						DebugEnterDecision (8' false);  						int LA8_1 = input.LA (1);  						if ((LA8_1 == 24)) {  							alt8 = 1;  						}  					}  					finally {  						DebugExitDecision (8);  					}  					switch (alt8) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  						{  							DebugLocation (105' 60);  							not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (8);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (106' 4);  				FilterTreeNode newProperty = new Property (propertySegments);  				if ((inverse != null ? inverse.Text : default(string)) == "?")  					filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  				else {  					if ((not != null ? not.Text : default(string)) == "!")  						newProperty.ToggleInversed ();  					filterNode = newProperty;  				}  			}  			break;  		case 4:  			DebugEnterAlt (4);  			// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  			{  				DebugLocation (116' 4);  				STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  				DebugLocation (117' 4);  				string stringText = (STRING7 != null ? STRING7.Text : default(string));  				stringText = stringText.Substring (1' stringText.Length - 2);  				filterNode = new Value (stringText);  			}  			break;  		case 5:  			DebugEnterAlt (5);  			// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  			{  				DebugLocation (122' 4);  				REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  				DebugLocation (123' 4);  				string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  				regexText = regexText.Substring (1' regexText.Length - 2);  				filterNode = new RegExp (regexText);  			}  			break;  		case 6:  			DebugEnterAlt (6);  			// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  			{  				DebugLocation (128' 4);  				NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  				DebugLocation (129' 4);  				filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  			}  			break;  		case 7:  			DebugEnterAlt (7);  			// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  			{  				DebugLocation (132' 4);  				Match (input' TRUE' Follow._TRUE_in_filterExpr271);  				DebugLocation (133' 4);  				filterNode = new Value (true);  			}  			break;  		case 8:  			DebugEnterAlt (8);  			// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  			{  				DebugLocation (136' 4);  				Match (input' FALSE' Follow._FALSE_in_filterExpr281);  				DebugLocation (137' 4);  				filterNode = new Value (false);  			}  			break;  		case 9:  			DebugEnterAlt (9);  			// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  			{  				DebugLocation (140' 4);  				Match (input' NULL' Follow._NULL_in_filterExpr291);  				DebugLocation (141' 4);  				filterNode = new Value (null);  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("filterExpr"' 6);  		LeaveRule ("filterExpr"' 6);  		LeaveRule_filterExpr ();  	}  	DebugLocation (144' 1);  }  finally {  	DebugExitRule (GrammarFileName' "filterExpr");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "filterExpr");  	DebugLocation (60' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  		int alt9 = 9;  		try {  			DebugEnterDecision (9' false);  			switch (input.LA (1)) {  			case CHAIN_OPERATOR:  			case COMPARATOR:  				{  					alt9 = 1;  				}  				break;  			case EXPR:  				{  					int LA9_2 = input.LA (2);  					if ((LA9_2 == DOWN)) {  						int LA9_3 = input.LA (3);  						if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  							alt9 = 2;  						}  						else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  							alt9 = 3;  						}  						else {  							NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  							DebugRecognitionException (nvae);  							throw nvae;  						}  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				break;  			case STRING:  				{  					alt9 = 4;  				}  				break;  			case REGEX:  				{  					alt9 = 5;  				}  				break;  			case NUMBER:  				{  					alt9 = 6;  				}  				break;  			case TRUE:  				{  					alt9 = 7;  				}  				break;  			case FALSE:  				{  					alt9 = 8;  				}  				break;  			case NULL:  				{  					alt9 = 9;  				}  				break;  			default: {  				NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  			}  		}  		finally {  			DebugExitDecision (9);  		}  		switch (alt9) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  			{  				DebugLocation (64' 4);  				DebugLocation (64' 6);  				PushFollow (Follow._comparator_in_filterExpr175);  				comparator6 = comparator ();  				PopFollow ();  				Match (input' TokenTypes.Down' null);  				DebugLocation (64' 18);  				PushFollow (Follow._filterExpr_in_filterExpr179);  				a = filterExpr ();  				PopFollow ();  				DebugLocation (64' 31);  				PushFollow (Follow._filterExpr_in_filterExpr183);  				b = filterExpr ();  				PopFollow ();  				Match (input' TokenTypes.Up' null);  				DebugLocation (65' 4);  				Comparator newComparator;  				switch (comparator6) {  				case "=":  					newComparator = Comparator.Equals;  					break;  				case "!=":  					newComparator = Comparator.NotEquals;  					break;  				case ">":  					newComparator = Comparator.Greater;  					break;  				case "<":  					newComparator = Comparator.Less;  					break;  				case ">=":  					newComparator = Comparator.GreaterOrEqual;  					break;  				case "<=":  					newComparator = Comparator.LessOrEqual;  					break;  				case "&":  					newComparator = Comparator.And;  					break;  				case "|":  					newComparator = Comparator.Or;  					break;  				default:  					newComparator = Comparator.Equals;  					break;  				}  				filterNode = new BoolExpression (a' newComparator' b);  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  			{  				DebugLocation (98' 4);  				DebugLocation (98' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr195);  				Match (input' TokenTypes.Down' null);  				DebugLocation (98' 12);  				PushFollow (Follow._filterExpr_in_filterExpr199);  				f = filterExpr ();  				PopFollow ();  				DebugLocation (98' 31);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  				int alt6 = 2;  				try {  					DebugEnterSubRule (6);  					try {  						DebugEnterDecision (6' false);  						int LA6_1 = input.LA (1);  						if ((LA6_1 == 24)) {  							alt6 = 1;  						}  					}  					finally {  						DebugExitDecision (6);  					}  					switch (alt6) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  						{  							DebugLocation (98' 31);  							inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (6);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (99' 4);  				FilterTreeNode newNode = f;  				if ((inverse != null ? inverse.Text : default(string)) == "!")  					newNode.ToggleInversed ();  				filterNode = newNode;  			}  			break;  		case 3:  			DebugEnterAlt (3);  			// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  			{  				DebugLocation (105' 4);  				DebugLocation (105' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr216);  				Match (input' TokenTypes.Down' null);  				DebugLocation (105' 12);  				PushFollow (Follow._propertyChain_in_filterExpr219);  				propertyChain (propertySegments);  				PopFollow ();  				DebugLocation (105' 51);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  				int alt7 = 2;  				try {  					DebugEnterSubRule (7);  					try {  						DebugEnterDecision (7' false);  						int LA7_1 = input.LA (1);  						if ((LA7_1 == 31)) {  							alt7 = 1;  						}  					}  					finally {  						DebugExitDecision (7);  					}  					switch (alt7) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  						{  							DebugLocation (105' 51);  							inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (7);  				}  				DebugLocation (105' 60);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  				int alt8 = 2;  				try {  					DebugEnterSubRule (8);  					try {  						DebugEnterDecision (8' false);  						int LA8_1 = input.LA (1);  						if ((LA8_1 == 24)) {  							alt8 = 1;  						}  					}  					finally {  						DebugExitDecision (8);  					}  					switch (alt8) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  						{  							DebugLocation (105' 60);  							not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (8);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (106' 4);  				FilterTreeNode newProperty = new Property (propertySegments);  				if ((inverse != null ? inverse.Text : default(string)) == "?")  					filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  				else {  					if ((not != null ? not.Text : default(string)) == "!")  						newProperty.ToggleInversed ();  					filterNode = newProperty;  				}  			}  			break;  		case 4:  			DebugEnterAlt (4);  			// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  			{  				DebugLocation (116' 4);  				STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  				DebugLocation (117' 4);  				string stringText = (STRING7 != null ? STRING7.Text : default(string));  				stringText = stringText.Substring (1' stringText.Length - 2);  				filterNode = new Value (stringText);  			}  			break;  		case 5:  			DebugEnterAlt (5);  			// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  			{  				DebugLocation (122' 4);  				REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  				DebugLocation (123' 4);  				string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  				regexText = regexText.Substring (1' regexText.Length - 2);  				filterNode = new RegExp (regexText);  			}  			break;  		case 6:  			DebugEnterAlt (6);  			// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  			{  				DebugLocation (128' 4);  				NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  				DebugLocation (129' 4);  				filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  			}  			break;  		case 7:  			DebugEnterAlt (7);  			// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  			{  				DebugLocation (132' 4);  				Match (input' TRUE' Follow._TRUE_in_filterExpr271);  				DebugLocation (133' 4);  				filterNode = new Value (true);  			}  			break;  		case 8:  			DebugEnterAlt (8);  			// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  			{  				DebugLocation (136' 4);  				Match (input' FALSE' Follow._FALSE_in_filterExpr281);  				DebugLocation (137' 4);  				filterNode = new Value (false);  			}  			break;  		case 9:  			DebugEnterAlt (9);  			// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  			{  				DebugLocation (140' 4);  				Match (input' NULL' Follow._NULL_in_filterExpr291);  				DebugLocation (141' 4);  				filterNode = new Value (null);  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("filterExpr"' 6);  		LeaveRule ("filterExpr"' 6);  		LeaveRule_filterExpr ();  	}  	DebugLocation (144' 1);  }  finally {  	DebugExitRule (GrammarFileName' "filterExpr");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "filterExpr");  	DebugLocation (60' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  		int alt9 = 9;  		try {  			DebugEnterDecision (9' false);  			switch (input.LA (1)) {  			case CHAIN_OPERATOR:  			case COMPARATOR:  				{  					alt9 = 1;  				}  				break;  			case EXPR:  				{  					int LA9_2 = input.LA (2);  					if ((LA9_2 == DOWN)) {  						int LA9_3 = input.LA (3);  						if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  							alt9 = 2;  						}  						else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  							alt9 = 3;  						}  						else {  							NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  							DebugRecognitionException (nvae);  							throw nvae;  						}  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				break;  			case STRING:  				{  					alt9 = 4;  				}  				break;  			case REGEX:  				{  					alt9 = 5;  				}  				break;  			case NUMBER:  				{  					alt9 = 6;  				}  				break;  			case TRUE:  				{  					alt9 = 7;  				}  				break;  			case FALSE:  				{  					alt9 = 8;  				}  				break;  			case NULL:  				{  					alt9 = 9;  				}  				break;  			default: {  				NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  			}  		}  		finally {  			DebugExitDecision (9);  		}  		switch (alt9) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  			{  				DebugLocation (64' 4);  				DebugLocation (64' 6);  				PushFollow (Follow._comparator_in_filterExpr175);  				comparator6 = comparator ();  				PopFollow ();  				Match (input' TokenTypes.Down' null);  				DebugLocation (64' 18);  				PushFollow (Follow._filterExpr_in_filterExpr179);  				a = filterExpr ();  				PopFollow ();  				DebugLocation (64' 31);  				PushFollow (Follow._filterExpr_in_filterExpr183);  				b = filterExpr ();  				PopFollow ();  				Match (input' TokenTypes.Up' null);  				DebugLocation (65' 4);  				Comparator newComparator;  				switch (comparator6) {  				case "=":  					newComparator = Comparator.Equals;  					break;  				case "!=":  					newComparator = Comparator.NotEquals;  					break;  				case ">":  					newComparator = Comparator.Greater;  					break;  				case "<":  					newComparator = Comparator.Less;  					break;  				case ">=":  					newComparator = Comparator.GreaterOrEqual;  					break;  				case "<=":  					newComparator = Comparator.LessOrEqual;  					break;  				case "&":  					newComparator = Comparator.And;  					break;  				case "|":  					newComparator = Comparator.Or;  					break;  				default:  					newComparator = Comparator.Equals;  					break;  				}  				filterNode = new BoolExpression (a' newComparator' b);  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  			{  				DebugLocation (98' 4);  				DebugLocation (98' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr195);  				Match (input' TokenTypes.Down' null);  				DebugLocation (98' 12);  				PushFollow (Follow._filterExpr_in_filterExpr199);  				f = filterExpr ();  				PopFollow ();  				DebugLocation (98' 31);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  				int alt6 = 2;  				try {  					DebugEnterSubRule (6);  					try {  						DebugEnterDecision (6' false);  						int LA6_1 = input.LA (1);  						if ((LA6_1 == 24)) {  							alt6 = 1;  						}  					}  					finally {  						DebugExitDecision (6);  					}  					switch (alt6) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  						{  							DebugLocation (98' 31);  							inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (6);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (99' 4);  				FilterTreeNode newNode = f;  				if ((inverse != null ? inverse.Text : default(string)) == "!")  					newNode.ToggleInversed ();  				filterNode = newNode;  			}  			break;  		case 3:  			DebugEnterAlt (3);  			// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  			{  				DebugLocation (105' 4);  				DebugLocation (105' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr216);  				Match (input' TokenTypes.Down' null);  				DebugLocation (105' 12);  				PushFollow (Follow._propertyChain_in_filterExpr219);  				propertyChain (propertySegments);  				PopFollow ();  				DebugLocation (105' 51);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  				int alt7 = 2;  				try {  					DebugEnterSubRule (7);  					try {  						DebugEnterDecision (7' false);  						int LA7_1 = input.LA (1);  						if ((LA7_1 == 31)) {  							alt7 = 1;  						}  					}  					finally {  						DebugExitDecision (7);  					}  					switch (alt7) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  						{  							DebugLocation (105' 51);  							inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (7);  				}  				DebugLocation (105' 60);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  				int alt8 = 2;  				try {  					DebugEnterSubRule (8);  					try {  						DebugEnterDecision (8' false);  						int LA8_1 = input.LA (1);  						if ((LA8_1 == 24)) {  							alt8 = 1;  						}  					}  					finally {  						DebugExitDecision (8);  					}  					switch (alt8) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  						{  							DebugLocation (105' 60);  							not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (8);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (106' 4);  				FilterTreeNode newProperty = new Property (propertySegments);  				if ((inverse != null ? inverse.Text : default(string)) == "?")  					filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  				else {  					if ((not != null ? not.Text : default(string)) == "!")  						newProperty.ToggleInversed ();  					filterNode = newProperty;  				}  			}  			break;  		case 4:  			DebugEnterAlt (4);  			// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  			{  				DebugLocation (116' 4);  				STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  				DebugLocation (117' 4);  				string stringText = (STRING7 != null ? STRING7.Text : default(string));  				stringText = stringText.Substring (1' stringText.Length - 2);  				filterNode = new Value (stringText);  			}  			break;  		case 5:  			DebugEnterAlt (5);  			// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  			{  				DebugLocation (122' 4);  				REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  				DebugLocation (123' 4);  				string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  				regexText = regexText.Substring (1' regexText.Length - 2);  				filterNode = new RegExp (regexText);  			}  			break;  		case 6:  			DebugEnterAlt (6);  			// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  			{  				DebugLocation (128' 4);  				NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  				DebugLocation (129' 4);  				filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  			}  			break;  		case 7:  			DebugEnterAlt (7);  			// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  			{  				DebugLocation (132' 4);  				Match (input' TRUE' Follow._TRUE_in_filterExpr271);  				DebugLocation (133' 4);  				filterNode = new Value (true);  			}  			break;  		case 8:  			DebugEnterAlt (8);  			// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  			{  				DebugLocation (136' 4);  				Match (input' FALSE' Follow._FALSE_in_filterExpr281);  				DebugLocation (137' 4);  				filterNode = new Value (false);  			}  			break;  		case 9:  			DebugEnterAlt (9);  			// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  			{  				DebugLocation (140' 4);  				Match (input' NULL' Follow._NULL_in_filterExpr291);  				DebugLocation (141' 4);  				filterNode = new Value (null);  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("filterExpr"' 6);  		LeaveRule ("filterExpr"' 6);  		LeaveRule_filterExpr ();  	}  	DebugLocation (144' 1);  }  finally {  	DebugExitRule (GrammarFileName' "filterExpr");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "filterExpr");  	DebugLocation (60' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  		int alt9 = 9;  		try {  			DebugEnterDecision (9' false);  			switch (input.LA (1)) {  			case CHAIN_OPERATOR:  			case COMPARATOR:  				{  					alt9 = 1;  				}  				break;  			case EXPR:  				{  					int LA9_2 = input.LA (2);  					if ((LA9_2 == DOWN)) {  						int LA9_3 = input.LA (3);  						if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  							alt9 = 2;  						}  						else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  							alt9 = 3;  						}  						else {  							NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  							DebugRecognitionException (nvae);  							throw nvae;  						}  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				break;  			case STRING:  				{  					alt9 = 4;  				}  				break;  			case REGEX:  				{  					alt9 = 5;  				}  				break;  			case NUMBER:  				{  					alt9 = 6;  				}  				break;  			case TRUE:  				{  					alt9 = 7;  				}  				break;  			case FALSE:  				{  					alt9 = 8;  				}  				break;  			case NULL:  				{  					alt9 = 9;  				}  				break;  			default: {  				NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  			}  		}  		finally {  			DebugExitDecision (9);  		}  		switch (alt9) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  			{  				DebugLocation (64' 4);  				DebugLocation (64' 6);  				PushFollow (Follow._comparator_in_filterExpr175);  				comparator6 = comparator ();  				PopFollow ();  				Match (input' TokenTypes.Down' null);  				DebugLocation (64' 18);  				PushFollow (Follow._filterExpr_in_filterExpr179);  				a = filterExpr ();  				PopFollow ();  				DebugLocation (64' 31);  				PushFollow (Follow._filterExpr_in_filterExpr183);  				b = filterExpr ();  				PopFollow ();  				Match (input' TokenTypes.Up' null);  				DebugLocation (65' 4);  				Comparator newComparator;  				switch (comparator6) {  				case "=":  					newComparator = Comparator.Equals;  					break;  				case "!=":  					newComparator = Comparator.NotEquals;  					break;  				case ">":  					newComparator = Comparator.Greater;  					break;  				case "<":  					newComparator = Comparator.Less;  					break;  				case ">=":  					newComparator = Comparator.GreaterOrEqual;  					break;  				case "<=":  					newComparator = Comparator.LessOrEqual;  					break;  				case "&":  					newComparator = Comparator.And;  					break;  				case "|":  					newComparator = Comparator.Or;  					break;  				default:  					newComparator = Comparator.Equals;  					break;  				}  				filterNode = new BoolExpression (a' newComparator' b);  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  			{  				DebugLocation (98' 4);  				DebugLocation (98' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr195);  				Match (input' TokenTypes.Down' null);  				DebugLocation (98' 12);  				PushFollow (Follow._filterExpr_in_filterExpr199);  				f = filterExpr ();  				PopFollow ();  				DebugLocation (98' 31);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  				int alt6 = 2;  				try {  					DebugEnterSubRule (6);  					try {  						DebugEnterDecision (6' false);  						int LA6_1 = input.LA (1);  						if ((LA6_1 == 24)) {  							alt6 = 1;  						}  					}  					finally {  						DebugExitDecision (6);  					}  					switch (alt6) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  						{  							DebugLocation (98' 31);  							inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (6);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (99' 4);  				FilterTreeNode newNode = f;  				if ((inverse != null ? inverse.Text : default(string)) == "!")  					newNode.ToggleInversed ();  				filterNode = newNode;  			}  			break;  		case 3:  			DebugEnterAlt (3);  			// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  			{  				DebugLocation (105' 4);  				DebugLocation (105' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr216);  				Match (input' TokenTypes.Down' null);  				DebugLocation (105' 12);  				PushFollow (Follow._propertyChain_in_filterExpr219);  				propertyChain (propertySegments);  				PopFollow ();  				DebugLocation (105' 51);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  				int alt7 = 2;  				try {  					DebugEnterSubRule (7);  					try {  						DebugEnterDecision (7' false);  						int LA7_1 = input.LA (1);  						if ((LA7_1 == 31)) {  							alt7 = 1;  						}  					}  					finally {  						DebugExitDecision (7);  					}  					switch (alt7) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  						{  							DebugLocation (105' 51);  							inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (7);  				}  				DebugLocation (105' 60);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  				int alt8 = 2;  				try {  					DebugEnterSubRule (8);  					try {  						DebugEnterDecision (8' false);  						int LA8_1 = input.LA (1);  						if ((LA8_1 == 24)) {  							alt8 = 1;  						}  					}  					finally {  						DebugExitDecision (8);  					}  					switch (alt8) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  						{  							DebugLocation (105' 60);  							not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (8);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (106' 4);  				FilterTreeNode newProperty = new Property (propertySegments);  				if ((inverse != null ? inverse.Text : default(string)) == "?")  					filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  				else {  					if ((not != null ? not.Text : default(string)) == "!")  						newProperty.ToggleInversed ();  					filterNode = newProperty;  				}  			}  			break;  		case 4:  			DebugEnterAlt (4);  			// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  			{  				DebugLocation (116' 4);  				STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  				DebugLocation (117' 4);  				string stringText = (STRING7 != null ? STRING7.Text : default(string));  				stringText = stringText.Substring (1' stringText.Length - 2);  				filterNode = new Value (stringText);  			}  			break;  		case 5:  			DebugEnterAlt (5);  			// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  			{  				DebugLocation (122' 4);  				REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  				DebugLocation (123' 4);  				string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  				regexText = regexText.Substring (1' regexText.Length - 2);  				filterNode = new RegExp (regexText);  			}  			break;  		case 6:  			DebugEnterAlt (6);  			// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  			{  				DebugLocation (128' 4);  				NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  				DebugLocation (129' 4);  				filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  			}  			break;  		case 7:  			DebugEnterAlt (7);  			// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  			{  				DebugLocation (132' 4);  				Match (input' TRUE' Follow._TRUE_in_filterExpr271);  				DebugLocation (133' 4);  				filterNode = new Value (true);  			}  			break;  		case 8:  			DebugEnterAlt (8);  			// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  			{  				DebugLocation (136' 4);  				Match (input' FALSE' Follow._FALSE_in_filterExpr281);  				DebugLocation (137' 4);  				filterNode = new Value (false);  			}  			break;  		case 9:  			DebugEnterAlt (9);  			// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  			{  				DebugLocation (140' 4);  				Match (input' NULL' Follow._NULL_in_filterExpr291);  				DebugLocation (141' 4);  				filterNode = new Value (null);  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("filterExpr"' 6);  		LeaveRule ("filterExpr"' 6);  		LeaveRule_filterExpr ();  	}  	DebugLocation (144' 1);  }  finally {  	DebugExitRule (GrammarFileName' "filterExpr");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "filterExpr");  	DebugLocation (60' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  		int alt9 = 9;  		try {  			DebugEnterDecision (9' false);  			switch (input.LA (1)) {  			case CHAIN_OPERATOR:  			case COMPARATOR:  				{  					alt9 = 1;  				}  				break;  			case EXPR:  				{  					int LA9_2 = input.LA (2);  					if ((LA9_2 == DOWN)) {  						int LA9_3 = input.LA (3);  						if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  							alt9 = 2;  						}  						else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  							alt9 = 3;  						}  						else {  							NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  							DebugRecognitionException (nvae);  							throw nvae;  						}  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				break;  			case STRING:  				{  					alt9 = 4;  				}  				break;  			case REGEX:  				{  					alt9 = 5;  				}  				break;  			case NUMBER:  				{  					alt9 = 6;  				}  				break;  			case TRUE:  				{  					alt9 = 7;  				}  				break;  			case FALSE:  				{  					alt9 = 8;  				}  				break;  			case NULL:  				{  					alt9 = 9;  				}  				break;  			default: {  				NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  			}  		}  		finally {  			DebugExitDecision (9);  		}  		switch (alt9) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  			{  				DebugLocation (64' 4);  				DebugLocation (64' 6);  				PushFollow (Follow._comparator_in_filterExpr175);  				comparator6 = comparator ();  				PopFollow ();  				Match (input' TokenTypes.Down' null);  				DebugLocation (64' 18);  				PushFollow (Follow._filterExpr_in_filterExpr179);  				a = filterExpr ();  				PopFollow ();  				DebugLocation (64' 31);  				PushFollow (Follow._filterExpr_in_filterExpr183);  				b = filterExpr ();  				PopFollow ();  				Match (input' TokenTypes.Up' null);  				DebugLocation (65' 4);  				Comparator newComparator;  				switch (comparator6) {  				case "=":  					newComparator = Comparator.Equals;  					break;  				case "!=":  					newComparator = Comparator.NotEquals;  					break;  				case ">":  					newComparator = Comparator.Greater;  					break;  				case "<":  					newComparator = Comparator.Less;  					break;  				case ">=":  					newComparator = Comparator.GreaterOrEqual;  					break;  				case "<=":  					newComparator = Comparator.LessOrEqual;  					break;  				case "&":  					newComparator = Comparator.And;  					break;  				case "|":  					newComparator = Comparator.Or;  					break;  				default:  					newComparator = Comparator.Equals;  					break;  				}  				filterNode = new BoolExpression (a' newComparator' b);  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  			{  				DebugLocation (98' 4);  				DebugLocation (98' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr195);  				Match (input' TokenTypes.Down' null);  				DebugLocation (98' 12);  				PushFollow (Follow._filterExpr_in_filterExpr199);  				f = filterExpr ();  				PopFollow ();  				DebugLocation (98' 31);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  				int alt6 = 2;  				try {  					DebugEnterSubRule (6);  					try {  						DebugEnterDecision (6' false);  						int LA6_1 = input.LA (1);  						if ((LA6_1 == 24)) {  							alt6 = 1;  						}  					}  					finally {  						DebugExitDecision (6);  					}  					switch (alt6) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  						{  							DebugLocation (98' 31);  							inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (6);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (99' 4);  				FilterTreeNode newNode = f;  				if ((inverse != null ? inverse.Text : default(string)) == "!")  					newNode.ToggleInversed ();  				filterNode = newNode;  			}  			break;  		case 3:  			DebugEnterAlt (3);  			// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  			{  				DebugLocation (105' 4);  				DebugLocation (105' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr216);  				Match (input' TokenTypes.Down' null);  				DebugLocation (105' 12);  				PushFollow (Follow._propertyChain_in_filterExpr219);  				propertyChain (propertySegments);  				PopFollow ();  				DebugLocation (105' 51);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  				int alt7 = 2;  				try {  					DebugEnterSubRule (7);  					try {  						DebugEnterDecision (7' false);  						int LA7_1 = input.LA (1);  						if ((LA7_1 == 31)) {  							alt7 = 1;  						}  					}  					finally {  						DebugExitDecision (7);  					}  					switch (alt7) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  						{  							DebugLocation (105' 51);  							inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (7);  				}  				DebugLocation (105' 60);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  				int alt8 = 2;  				try {  					DebugEnterSubRule (8);  					try {  						DebugEnterDecision (8' false);  						int LA8_1 = input.LA (1);  						if ((LA8_1 == 24)) {  							alt8 = 1;  						}  					}  					finally {  						DebugExitDecision (8);  					}  					switch (alt8) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  						{  							DebugLocation (105' 60);  							not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (8);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (106' 4);  				FilterTreeNode newProperty = new Property (propertySegments);  				if ((inverse != null ? inverse.Text : default(string)) == "?")  					filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  				else {  					if ((not != null ? not.Text : default(string)) == "!")  						newProperty.ToggleInversed ();  					filterNode = newProperty;  				}  			}  			break;  		case 4:  			DebugEnterAlt (4);  			// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  			{  				DebugLocation (116' 4);  				STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  				DebugLocation (117' 4);  				string stringText = (STRING7 != null ? STRING7.Text : default(string));  				stringText = stringText.Substring (1' stringText.Length - 2);  				filterNode = new Value (stringText);  			}  			break;  		case 5:  			DebugEnterAlt (5);  			// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  			{  				DebugLocation (122' 4);  				REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  				DebugLocation (123' 4);  				string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  				regexText = regexText.Substring (1' regexText.Length - 2);  				filterNode = new RegExp (regexText);  			}  			break;  		case 6:  			DebugEnterAlt (6);  			// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  			{  				DebugLocation (128' 4);  				NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  				DebugLocation (129' 4);  				filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  			}  			break;  		case 7:  			DebugEnterAlt (7);  			// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  			{  				DebugLocation (132' 4);  				Match (input' TRUE' Follow._TRUE_in_filterExpr271);  				DebugLocation (133' 4);  				filterNode = new Value (true);  			}  			break;  		case 8:  			DebugEnterAlt (8);  			// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  			{  				DebugLocation (136' 4);  				Match (input' FALSE' Follow._FALSE_in_filterExpr281);  				DebugLocation (137' 4);  				filterNode = new Value (false);  			}  			break;  		case 9:  			DebugEnterAlt (9);  			// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  			{  				DebugLocation (140' 4);  				Match (input' NULL' Follow._NULL_in_filterExpr291);  				DebugLocation (141' 4);  				filterNode = new Value (null);  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("filterExpr"' 6);  		LeaveRule ("filterExpr"' 6);  		LeaveRule_filterExpr ();  	}  	DebugLocation (144' 1);  }  finally {  	DebugExitRule (GrammarFileName' "filterExpr");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "filterExpr");  	DebugLocation (60' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  		int alt9 = 9;  		try {  			DebugEnterDecision (9' false);  			switch (input.LA (1)) {  			case CHAIN_OPERATOR:  			case COMPARATOR:  				{  					alt9 = 1;  				}  				break;  			case EXPR:  				{  					int LA9_2 = input.LA (2);  					if ((LA9_2 == DOWN)) {  						int LA9_3 = input.LA (3);  						if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  							alt9 = 2;  						}  						else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  							alt9 = 3;  						}  						else {  							NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  							DebugRecognitionException (nvae);  							throw nvae;  						}  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				break;  			case STRING:  				{  					alt9 = 4;  				}  				break;  			case REGEX:  				{  					alt9 = 5;  				}  				break;  			case NUMBER:  				{  					alt9 = 6;  				}  				break;  			case TRUE:  				{  					alt9 = 7;  				}  				break;  			case FALSE:  				{  					alt9 = 8;  				}  				break;  			case NULL:  				{  					alt9 = 9;  				}  				break;  			default: {  				NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  			}  		}  		finally {  			DebugExitDecision (9);  		}  		switch (alt9) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  			{  				DebugLocation (64' 4);  				DebugLocation (64' 6);  				PushFollow (Follow._comparator_in_filterExpr175);  				comparator6 = comparator ();  				PopFollow ();  				Match (input' TokenTypes.Down' null);  				DebugLocation (64' 18);  				PushFollow (Follow._filterExpr_in_filterExpr179);  				a = filterExpr ();  				PopFollow ();  				DebugLocation (64' 31);  				PushFollow (Follow._filterExpr_in_filterExpr183);  				b = filterExpr ();  				PopFollow ();  				Match (input' TokenTypes.Up' null);  				DebugLocation (65' 4);  				Comparator newComparator;  				switch (comparator6) {  				case "=":  					newComparator = Comparator.Equals;  					break;  				case "!=":  					newComparator = Comparator.NotEquals;  					break;  				case ">":  					newComparator = Comparator.Greater;  					break;  				case "<":  					newComparator = Comparator.Less;  					break;  				case ">=":  					newComparator = Comparator.GreaterOrEqual;  					break;  				case "<=":  					newComparator = Comparator.LessOrEqual;  					break;  				case "&":  					newComparator = Comparator.And;  					break;  				case "|":  					newComparator = Comparator.Or;  					break;  				default:  					newComparator = Comparator.Equals;  					break;  				}  				filterNode = new BoolExpression (a' newComparator' b);  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  			{  				DebugLocation (98' 4);  				DebugLocation (98' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr195);  				Match (input' TokenTypes.Down' null);  				DebugLocation (98' 12);  				PushFollow (Follow._filterExpr_in_filterExpr199);  				f = filterExpr ();  				PopFollow ();  				DebugLocation (98' 31);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  				int alt6 = 2;  				try {  					DebugEnterSubRule (6);  					try {  						DebugEnterDecision (6' false);  						int LA6_1 = input.LA (1);  						if ((LA6_1 == 24)) {  							alt6 = 1;  						}  					}  					finally {  						DebugExitDecision (6);  					}  					switch (alt6) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  						{  							DebugLocation (98' 31);  							inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (6);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (99' 4);  				FilterTreeNode newNode = f;  				if ((inverse != null ? inverse.Text : default(string)) == "!")  					newNode.ToggleInversed ();  				filterNode = newNode;  			}  			break;  		case 3:  			DebugEnterAlt (3);  			// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  			{  				DebugLocation (105' 4);  				DebugLocation (105' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr216);  				Match (input' TokenTypes.Down' null);  				DebugLocation (105' 12);  				PushFollow (Follow._propertyChain_in_filterExpr219);  				propertyChain (propertySegments);  				PopFollow ();  				DebugLocation (105' 51);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  				int alt7 = 2;  				try {  					DebugEnterSubRule (7);  					try {  						DebugEnterDecision (7' false);  						int LA7_1 = input.LA (1);  						if ((LA7_1 == 31)) {  							alt7 = 1;  						}  					}  					finally {  						DebugExitDecision (7);  					}  					switch (alt7) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  						{  							DebugLocation (105' 51);  							inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (7);  				}  				DebugLocation (105' 60);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  				int alt8 = 2;  				try {  					DebugEnterSubRule (8);  					try {  						DebugEnterDecision (8' false);  						int LA8_1 = input.LA (1);  						if ((LA8_1 == 24)) {  							alt8 = 1;  						}  					}  					finally {  						DebugExitDecision (8);  					}  					switch (alt8) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  						{  							DebugLocation (105' 60);  							not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (8);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (106' 4);  				FilterTreeNode newProperty = new Property (propertySegments);  				if ((inverse != null ? inverse.Text : default(string)) == "?")  					filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  				else {  					if ((not != null ? not.Text : default(string)) == "!")  						newProperty.ToggleInversed ();  					filterNode = newProperty;  				}  			}  			break;  		case 4:  			DebugEnterAlt (4);  			// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  			{  				DebugLocation (116' 4);  				STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  				DebugLocation (117' 4);  				string stringText = (STRING7 != null ? STRING7.Text : default(string));  				stringText = stringText.Substring (1' stringText.Length - 2);  				filterNode = new Value (stringText);  			}  			break;  		case 5:  			DebugEnterAlt (5);  			// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  			{  				DebugLocation (122' 4);  				REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  				DebugLocation (123' 4);  				string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  				regexText = regexText.Substring (1' regexText.Length - 2);  				filterNode = new RegExp (regexText);  			}  			break;  		case 6:  			DebugEnterAlt (6);  			// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  			{  				DebugLocation (128' 4);  				NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  				DebugLocation (129' 4);  				filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  			}  			break;  		case 7:  			DebugEnterAlt (7);  			// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  			{  				DebugLocation (132' 4);  				Match (input' TRUE' Follow._TRUE_in_filterExpr271);  				DebugLocation (133' 4);  				filterNode = new Value (true);  			}  			break;  		case 8:  			DebugEnterAlt (8);  			// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  			{  				DebugLocation (136' 4);  				Match (input' FALSE' Follow._FALSE_in_filterExpr281);  				DebugLocation (137' 4);  				filterNode = new Value (false);  			}  			break;  		case 9:  			DebugEnterAlt (9);  			// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  			{  				DebugLocation (140' 4);  				Match (input' NULL' Follow._NULL_in_filterExpr291);  				DebugLocation (141' 4);  				filterNode = new Value (null);  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("filterExpr"' 6);  		LeaveRule ("filterExpr"' 6);  		LeaveRule_filterExpr ();  	}  	DebugLocation (144' 1);  }  finally {  	DebugExitRule (GrammarFileName' "filterExpr");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "filterExpr");  	DebugLocation (60' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  		int alt9 = 9;  		try {  			DebugEnterDecision (9' false);  			switch (input.LA (1)) {  			case CHAIN_OPERATOR:  			case COMPARATOR:  				{  					alt9 = 1;  				}  				break;  			case EXPR:  				{  					int LA9_2 = input.LA (2);  					if ((LA9_2 == DOWN)) {  						int LA9_3 = input.LA (3);  						if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  							alt9 = 2;  						}  						else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  							alt9 = 3;  						}  						else {  							NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  							DebugRecognitionException (nvae);  							throw nvae;  						}  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				break;  			case STRING:  				{  					alt9 = 4;  				}  				break;  			case REGEX:  				{  					alt9 = 5;  				}  				break;  			case NUMBER:  				{  					alt9 = 6;  				}  				break;  			case TRUE:  				{  					alt9 = 7;  				}  				break;  			case FALSE:  				{  					alt9 = 8;  				}  				break;  			case NULL:  				{  					alt9 = 9;  				}  				break;  			default: {  				NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  			}  		}  		finally {  			DebugExitDecision (9);  		}  		switch (alt9) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  			{  				DebugLocation (64' 4);  				DebugLocation (64' 6);  				PushFollow (Follow._comparator_in_filterExpr175);  				comparator6 = comparator ();  				PopFollow ();  				Match (input' TokenTypes.Down' null);  				DebugLocation (64' 18);  				PushFollow (Follow._filterExpr_in_filterExpr179);  				a = filterExpr ();  				PopFollow ();  				DebugLocation (64' 31);  				PushFollow (Follow._filterExpr_in_filterExpr183);  				b = filterExpr ();  				PopFollow ();  				Match (input' TokenTypes.Up' null);  				DebugLocation (65' 4);  				Comparator newComparator;  				switch (comparator6) {  				case "=":  					newComparator = Comparator.Equals;  					break;  				case "!=":  					newComparator = Comparator.NotEquals;  					break;  				case ">":  					newComparator = Comparator.Greater;  					break;  				case "<":  					newComparator = Comparator.Less;  					break;  				case ">=":  					newComparator = Comparator.GreaterOrEqual;  					break;  				case "<=":  					newComparator = Comparator.LessOrEqual;  					break;  				case "&":  					newComparator = Comparator.And;  					break;  				case "|":  					newComparator = Comparator.Or;  					break;  				default:  					newComparator = Comparator.Equals;  					break;  				}  				filterNode = new BoolExpression (a' newComparator' b);  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  			{  				DebugLocation (98' 4);  				DebugLocation (98' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr195);  				Match (input' TokenTypes.Down' null);  				DebugLocation (98' 12);  				PushFollow (Follow._filterExpr_in_filterExpr199);  				f = filterExpr ();  				PopFollow ();  				DebugLocation (98' 31);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  				int alt6 = 2;  				try {  					DebugEnterSubRule (6);  					try {  						DebugEnterDecision (6' false);  						int LA6_1 = input.LA (1);  						if ((LA6_1 == 24)) {  							alt6 = 1;  						}  					}  					finally {  						DebugExitDecision (6);  					}  					switch (alt6) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  						{  							DebugLocation (98' 31);  							inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (6);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (99' 4);  				FilterTreeNode newNode = f;  				if ((inverse != null ? inverse.Text : default(string)) == "!")  					newNode.ToggleInversed ();  				filterNode = newNode;  			}  			break;  		case 3:  			DebugEnterAlt (3);  			// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  			{  				DebugLocation (105' 4);  				DebugLocation (105' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr216);  				Match (input' TokenTypes.Down' null);  				DebugLocation (105' 12);  				PushFollow (Follow._propertyChain_in_filterExpr219);  				propertyChain (propertySegments);  				PopFollow ();  				DebugLocation (105' 51);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  				int alt7 = 2;  				try {  					DebugEnterSubRule (7);  					try {  						DebugEnterDecision (7' false);  						int LA7_1 = input.LA (1);  						if ((LA7_1 == 31)) {  							alt7 = 1;  						}  					}  					finally {  						DebugExitDecision (7);  					}  					switch (alt7) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  						{  							DebugLocation (105' 51);  							inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (7);  				}  				DebugLocation (105' 60);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  				int alt8 = 2;  				try {  					DebugEnterSubRule (8);  					try {  						DebugEnterDecision (8' false);  						int LA8_1 = input.LA (1);  						if ((LA8_1 == 24)) {  							alt8 = 1;  						}  					}  					finally {  						DebugExitDecision (8);  					}  					switch (alt8) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  						{  							DebugLocation (105' 60);  							not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (8);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (106' 4);  				FilterTreeNode newProperty = new Property (propertySegments);  				if ((inverse != null ? inverse.Text : default(string)) == "?")  					filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  				else {  					if ((not != null ? not.Text : default(string)) == "!")  						newProperty.ToggleInversed ();  					filterNode = newProperty;  				}  			}  			break;  		case 4:  			DebugEnterAlt (4);  			// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  			{  				DebugLocation (116' 4);  				STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  				DebugLocation (117' 4);  				string stringText = (STRING7 != null ? STRING7.Text : default(string));  				stringText = stringText.Substring (1' stringText.Length - 2);  				filterNode = new Value (stringText);  			}  			break;  		case 5:  			DebugEnterAlt (5);  			// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  			{  				DebugLocation (122' 4);  				REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  				DebugLocation (123' 4);  				string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  				regexText = regexText.Substring (1' regexText.Length - 2);  				filterNode = new RegExp (regexText);  			}  			break;  		case 6:  			DebugEnterAlt (6);  			// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  			{  				DebugLocation (128' 4);  				NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  				DebugLocation (129' 4);  				filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  			}  			break;  		case 7:  			DebugEnterAlt (7);  			// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  			{  				DebugLocation (132' 4);  				Match (input' TRUE' Follow._TRUE_in_filterExpr271);  				DebugLocation (133' 4);  				filterNode = new Value (true);  			}  			break;  		case 8:  			DebugEnterAlt (8);  			// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  			{  				DebugLocation (136' 4);  				Match (input' FALSE' Follow._FALSE_in_filterExpr281);  				DebugLocation (137' 4);  				filterNode = new Value (false);  			}  			break;  		case 9:  			DebugEnterAlt (9);  			// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  			{  				DebugLocation (140' 4);  				Match (input' NULL' Follow._NULL_in_filterExpr291);  				DebugLocation (141' 4);  				filterNode = new Value (null);  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("filterExpr"' 6);  		LeaveRule ("filterExpr"' 6);  		LeaveRule_filterExpr ();  	}  	DebugLocation (144' 1);  }  finally {  	DebugExitRule (GrammarFileName' "filterExpr");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "filterExpr");  	DebugLocation (60' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  		int alt9 = 9;  		try {  			DebugEnterDecision (9' false);  			switch (input.LA (1)) {  			case CHAIN_OPERATOR:  			case COMPARATOR:  				{  					alt9 = 1;  				}  				break;  			case EXPR:  				{  					int LA9_2 = input.LA (2);  					if ((LA9_2 == DOWN)) {  						int LA9_3 = input.LA (3);  						if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  							alt9 = 2;  						}  						else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  							alt9 = 3;  						}  						else {  							NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  							DebugRecognitionException (nvae);  							throw nvae;  						}  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				break;  			case STRING:  				{  					alt9 = 4;  				}  				break;  			case REGEX:  				{  					alt9 = 5;  				}  				break;  			case NUMBER:  				{  					alt9 = 6;  				}  				break;  			case TRUE:  				{  					alt9 = 7;  				}  				break;  			case FALSE:  				{  					alt9 = 8;  				}  				break;  			case NULL:  				{  					alt9 = 9;  				}  				break;  			default: {  				NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  			}  		}  		finally {  			DebugExitDecision (9);  		}  		switch (alt9) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  			{  				DebugLocation (64' 4);  				DebugLocation (64' 6);  				PushFollow (Follow._comparator_in_filterExpr175);  				comparator6 = comparator ();  				PopFollow ();  				Match (input' TokenTypes.Down' null);  				DebugLocation (64' 18);  				PushFollow (Follow._filterExpr_in_filterExpr179);  				a = filterExpr ();  				PopFollow ();  				DebugLocation (64' 31);  				PushFollow (Follow._filterExpr_in_filterExpr183);  				b = filterExpr ();  				PopFollow ();  				Match (input' TokenTypes.Up' null);  				DebugLocation (65' 4);  				Comparator newComparator;  				switch (comparator6) {  				case "=":  					newComparator = Comparator.Equals;  					break;  				case "!=":  					newComparator = Comparator.NotEquals;  					break;  				case ">":  					newComparator = Comparator.Greater;  					break;  				case "<":  					newComparator = Comparator.Less;  					break;  				case ">=":  					newComparator = Comparator.GreaterOrEqual;  					break;  				case "<=":  					newComparator = Comparator.LessOrEqual;  					break;  				case "&":  					newComparator = Comparator.And;  					break;  				case "|":  					newComparator = Comparator.Or;  					break;  				default:  					newComparator = Comparator.Equals;  					break;  				}  				filterNode = new BoolExpression (a' newComparator' b);  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  			{  				DebugLocation (98' 4);  				DebugLocation (98' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr195);  				Match (input' TokenTypes.Down' null);  				DebugLocation (98' 12);  				PushFollow (Follow._filterExpr_in_filterExpr199);  				f = filterExpr ();  				PopFollow ();  				DebugLocation (98' 31);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  				int alt6 = 2;  				try {  					DebugEnterSubRule (6);  					try {  						DebugEnterDecision (6' false);  						int LA6_1 = input.LA (1);  						if ((LA6_1 == 24)) {  							alt6 = 1;  						}  					}  					finally {  						DebugExitDecision (6);  					}  					switch (alt6) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  						{  							DebugLocation (98' 31);  							inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (6);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (99' 4);  				FilterTreeNode newNode = f;  				if ((inverse != null ? inverse.Text : default(string)) == "!")  					newNode.ToggleInversed ();  				filterNode = newNode;  			}  			break;  		case 3:  			DebugEnterAlt (3);  			// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  			{  				DebugLocation (105' 4);  				DebugLocation (105' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr216);  				Match (input' TokenTypes.Down' null);  				DebugLocation (105' 12);  				PushFollow (Follow._propertyChain_in_filterExpr219);  				propertyChain (propertySegments);  				PopFollow ();  				DebugLocation (105' 51);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  				int alt7 = 2;  				try {  					DebugEnterSubRule (7);  					try {  						DebugEnterDecision (7' false);  						int LA7_1 = input.LA (1);  						if ((LA7_1 == 31)) {  							alt7 = 1;  						}  					}  					finally {  						DebugExitDecision (7);  					}  					switch (alt7) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  						{  							DebugLocation (105' 51);  							inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (7);  				}  				DebugLocation (105' 60);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  				int alt8 = 2;  				try {  					DebugEnterSubRule (8);  					try {  						DebugEnterDecision (8' false);  						int LA8_1 = input.LA (1);  						if ((LA8_1 == 24)) {  							alt8 = 1;  						}  					}  					finally {  						DebugExitDecision (8);  					}  					switch (alt8) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  						{  							DebugLocation (105' 60);  							not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (8);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (106' 4);  				FilterTreeNode newProperty = new Property (propertySegments);  				if ((inverse != null ? inverse.Text : default(string)) == "?")  					filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  				else {  					if ((not != null ? not.Text : default(string)) == "!")  						newProperty.ToggleInversed ();  					filterNode = newProperty;  				}  			}  			break;  		case 4:  			DebugEnterAlt (4);  			// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  			{  				DebugLocation (116' 4);  				STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  				DebugLocation (117' 4);  				string stringText = (STRING7 != null ? STRING7.Text : default(string));  				stringText = stringText.Substring (1' stringText.Length - 2);  				filterNode = new Value (stringText);  			}  			break;  		case 5:  			DebugEnterAlt (5);  			// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  			{  				DebugLocation (122' 4);  				REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  				DebugLocation (123' 4);  				string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  				regexText = regexText.Substring (1' regexText.Length - 2);  				filterNode = new RegExp (regexText);  			}  			break;  		case 6:  			DebugEnterAlt (6);  			// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  			{  				DebugLocation (128' 4);  				NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  				DebugLocation (129' 4);  				filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  			}  			break;  		case 7:  			DebugEnterAlt (7);  			// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  			{  				DebugLocation (132' 4);  				Match (input' TRUE' Follow._TRUE_in_filterExpr271);  				DebugLocation (133' 4);  				filterNode = new Value (true);  			}  			break;  		case 8:  			DebugEnterAlt (8);  			// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  			{  				DebugLocation (136' 4);  				Match (input' FALSE' Follow._FALSE_in_filterExpr281);  				DebugLocation (137' 4);  				filterNode = new Value (false);  			}  			break;  		case 9:  			DebugEnterAlt (9);  			// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  			{  				DebugLocation (140' 4);  				Match (input' NULL' Follow._NULL_in_filterExpr291);  				DebugLocation (141' 4);  				filterNode = new Value (null);  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("filterExpr"' 6);  		LeaveRule ("filterExpr"' 6);  		LeaveRule_filterExpr ();  	}  	DebugLocation (144' 1);  }  finally {  	DebugExitRule (GrammarFileName' "filterExpr");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "filterExpr");  	DebugLocation (60' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  		int alt9 = 9;  		try {  			DebugEnterDecision (9' false);  			switch (input.LA (1)) {  			case CHAIN_OPERATOR:  			case COMPARATOR:  				{  					alt9 = 1;  				}  				break;  			case EXPR:  				{  					int LA9_2 = input.LA (2);  					if ((LA9_2 == DOWN)) {  						int LA9_3 = input.LA (3);  						if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  							alt9 = 2;  						}  						else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  							alt9 = 3;  						}  						else {  							NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  							DebugRecognitionException (nvae);  							throw nvae;  						}  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				break;  			case STRING:  				{  					alt9 = 4;  				}  				break;  			case REGEX:  				{  					alt9 = 5;  				}  				break;  			case NUMBER:  				{  					alt9 = 6;  				}  				break;  			case TRUE:  				{  					alt9 = 7;  				}  				break;  			case FALSE:  				{  					alt9 = 8;  				}  				break;  			case NULL:  				{  					alt9 = 9;  				}  				break;  			default: {  				NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  			}  		}  		finally {  			DebugExitDecision (9);  		}  		switch (alt9) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  			{  				DebugLocation (64' 4);  				DebugLocation (64' 6);  				PushFollow (Follow._comparator_in_filterExpr175);  				comparator6 = comparator ();  				PopFollow ();  				Match (input' TokenTypes.Down' null);  				DebugLocation (64' 18);  				PushFollow (Follow._filterExpr_in_filterExpr179);  				a = filterExpr ();  				PopFollow ();  				DebugLocation (64' 31);  				PushFollow (Follow._filterExpr_in_filterExpr183);  				b = filterExpr ();  				PopFollow ();  				Match (input' TokenTypes.Up' null);  				DebugLocation (65' 4);  				Comparator newComparator;  				switch (comparator6) {  				case "=":  					newComparator = Comparator.Equals;  					break;  				case "!=":  					newComparator = Comparator.NotEquals;  					break;  				case ">":  					newComparator = Comparator.Greater;  					break;  				case "<":  					newComparator = Comparator.Less;  					break;  				case ">=":  					newComparator = Comparator.GreaterOrEqual;  					break;  				case "<=":  					newComparator = Comparator.LessOrEqual;  					break;  				case "&":  					newComparator = Comparator.And;  					break;  				case "|":  					newComparator = Comparator.Or;  					break;  				default:  					newComparator = Comparator.Equals;  					break;  				}  				filterNode = new BoolExpression (a' newComparator' b);  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  			{  				DebugLocation (98' 4);  				DebugLocation (98' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr195);  				Match (input' TokenTypes.Down' null);  				DebugLocation (98' 12);  				PushFollow (Follow._filterExpr_in_filterExpr199);  				f = filterExpr ();  				PopFollow ();  				DebugLocation (98' 31);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  				int alt6 = 2;  				try {  					DebugEnterSubRule (6);  					try {  						DebugEnterDecision (6' false);  						int LA6_1 = input.LA (1);  						if ((LA6_1 == 24)) {  							alt6 = 1;  						}  					}  					finally {  						DebugExitDecision (6);  					}  					switch (alt6) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  						{  							DebugLocation (98' 31);  							inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (6);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (99' 4);  				FilterTreeNode newNode = f;  				if ((inverse != null ? inverse.Text : default(string)) == "!")  					newNode.ToggleInversed ();  				filterNode = newNode;  			}  			break;  		case 3:  			DebugEnterAlt (3);  			// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  			{  				DebugLocation (105' 4);  				DebugLocation (105' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr216);  				Match (input' TokenTypes.Down' null);  				DebugLocation (105' 12);  				PushFollow (Follow._propertyChain_in_filterExpr219);  				propertyChain (propertySegments);  				PopFollow ();  				DebugLocation (105' 51);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  				int alt7 = 2;  				try {  					DebugEnterSubRule (7);  					try {  						DebugEnterDecision (7' false);  						int LA7_1 = input.LA (1);  						if ((LA7_1 == 31)) {  							alt7 = 1;  						}  					}  					finally {  						DebugExitDecision (7);  					}  					switch (alt7) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  						{  							DebugLocation (105' 51);  							inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (7);  				}  				DebugLocation (105' 60);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  				int alt8 = 2;  				try {  					DebugEnterSubRule (8);  					try {  						DebugEnterDecision (8' false);  						int LA8_1 = input.LA (1);  						if ((LA8_1 == 24)) {  							alt8 = 1;  						}  					}  					finally {  						DebugExitDecision (8);  					}  					switch (alt8) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  						{  							DebugLocation (105' 60);  							not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (8);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (106' 4);  				FilterTreeNode newProperty = new Property (propertySegments);  				if ((inverse != null ? inverse.Text : default(string)) == "?")  					filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  				else {  					if ((not != null ? not.Text : default(string)) == "!")  						newProperty.ToggleInversed ();  					filterNode = newProperty;  				}  			}  			break;  		case 4:  			DebugEnterAlt (4);  			// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  			{  				DebugLocation (116' 4);  				STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  				DebugLocation (117' 4);  				string stringText = (STRING7 != null ? STRING7.Text : default(string));  				stringText = stringText.Substring (1' stringText.Length - 2);  				filterNode = new Value (stringText);  			}  			break;  		case 5:  			DebugEnterAlt (5);  			// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  			{  				DebugLocation (122' 4);  				REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  				DebugLocation (123' 4);  				string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  				regexText = regexText.Substring (1' regexText.Length - 2);  				filterNode = new RegExp (regexText);  			}  			break;  		case 6:  			DebugEnterAlt (6);  			// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  			{  				DebugLocation (128' 4);  				NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  				DebugLocation (129' 4);  				filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  			}  			break;  		case 7:  			DebugEnterAlt (7);  			// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  			{  				DebugLocation (132' 4);  				Match (input' TRUE' Follow._TRUE_in_filterExpr271);  				DebugLocation (133' 4);  				filterNode = new Value (true);  			}  			break;  		case 8:  			DebugEnterAlt (8);  			// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  			{  				DebugLocation (136' 4);  				Match (input' FALSE' Follow._FALSE_in_filterExpr281);  				DebugLocation (137' 4);  				filterNode = new Value (false);  			}  			break;  		case 9:  			DebugEnterAlt (9);  			// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  			{  				DebugLocation (140' 4);  				Match (input' NULL' Follow._NULL_in_filterExpr291);  				DebugLocation (141' 4);  				filterNode = new Value (null);  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("filterExpr"' 6);  		LeaveRule ("filterExpr"' 6);  		LeaveRule_filterExpr ();  	}  	DebugLocation (144' 1);  }  finally {  	DebugExitRule (GrammarFileName' "filterExpr");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "filterExpr");  	DebugLocation (60' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  		int alt9 = 9;  		try {  			DebugEnterDecision (9' false);  			switch (input.LA (1)) {  			case CHAIN_OPERATOR:  			case COMPARATOR:  				{  					alt9 = 1;  				}  				break;  			case EXPR:  				{  					int LA9_2 = input.LA (2);  					if ((LA9_2 == DOWN)) {  						int LA9_3 = input.LA (3);  						if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  							alt9 = 2;  						}  						else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  							alt9 = 3;  						}  						else {  							NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  							DebugRecognitionException (nvae);  							throw nvae;  						}  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				break;  			case STRING:  				{  					alt9 = 4;  				}  				break;  			case REGEX:  				{  					alt9 = 5;  				}  				break;  			case NUMBER:  				{  					alt9 = 6;  				}  				break;  			case TRUE:  				{  					alt9 = 7;  				}  				break;  			case FALSE:  				{  					alt9 = 8;  				}  				break;  			case NULL:  				{  					alt9 = 9;  				}  				break;  			default: {  				NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  			}  		}  		finally {  			DebugExitDecision (9);  		}  		switch (alt9) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  			{  				DebugLocation (64' 4);  				DebugLocation (64' 6);  				PushFollow (Follow._comparator_in_filterExpr175);  				comparator6 = comparator ();  				PopFollow ();  				Match (input' TokenTypes.Down' null);  				DebugLocation (64' 18);  				PushFollow (Follow._filterExpr_in_filterExpr179);  				a = filterExpr ();  				PopFollow ();  				DebugLocation (64' 31);  				PushFollow (Follow._filterExpr_in_filterExpr183);  				b = filterExpr ();  				PopFollow ();  				Match (input' TokenTypes.Up' null);  				DebugLocation (65' 4);  				Comparator newComparator;  				switch (comparator6) {  				case "=":  					newComparator = Comparator.Equals;  					break;  				case "!=":  					newComparator = Comparator.NotEquals;  					break;  				case ">":  					newComparator = Comparator.Greater;  					break;  				case "<":  					newComparator = Comparator.Less;  					break;  				case ">=":  					newComparator = Comparator.GreaterOrEqual;  					break;  				case "<=":  					newComparator = Comparator.LessOrEqual;  					break;  				case "&":  					newComparator = Comparator.And;  					break;  				case "|":  					newComparator = Comparator.Or;  					break;  				default:  					newComparator = Comparator.Equals;  					break;  				}  				filterNode = new BoolExpression (a' newComparator' b);  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  			{  				DebugLocation (98' 4);  				DebugLocation (98' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr195);  				Match (input' TokenTypes.Down' null);  				DebugLocation (98' 12);  				PushFollow (Follow._filterExpr_in_filterExpr199);  				f = filterExpr ();  				PopFollow ();  				DebugLocation (98' 31);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  				int alt6 = 2;  				try {  					DebugEnterSubRule (6);  					try {  						DebugEnterDecision (6' false);  						int LA6_1 = input.LA (1);  						if ((LA6_1 == 24)) {  							alt6 = 1;  						}  					}  					finally {  						DebugExitDecision (6);  					}  					switch (alt6) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  						{  							DebugLocation (98' 31);  							inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (6);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (99' 4);  				FilterTreeNode newNode = f;  				if ((inverse != null ? inverse.Text : default(string)) == "!")  					newNode.ToggleInversed ();  				filterNode = newNode;  			}  			break;  		case 3:  			DebugEnterAlt (3);  			// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  			{  				DebugLocation (105' 4);  				DebugLocation (105' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr216);  				Match (input' TokenTypes.Down' null);  				DebugLocation (105' 12);  				PushFollow (Follow._propertyChain_in_filterExpr219);  				propertyChain (propertySegments);  				PopFollow ();  				DebugLocation (105' 51);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  				int alt7 = 2;  				try {  					DebugEnterSubRule (7);  					try {  						DebugEnterDecision (7' false);  						int LA7_1 = input.LA (1);  						if ((LA7_1 == 31)) {  							alt7 = 1;  						}  					}  					finally {  						DebugExitDecision (7);  					}  					switch (alt7) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  						{  							DebugLocation (105' 51);  							inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (7);  				}  				DebugLocation (105' 60);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  				int alt8 = 2;  				try {  					DebugEnterSubRule (8);  					try {  						DebugEnterDecision (8' false);  						int LA8_1 = input.LA (1);  						if ((LA8_1 == 24)) {  							alt8 = 1;  						}  					}  					finally {  						DebugExitDecision (8);  					}  					switch (alt8) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  						{  							DebugLocation (105' 60);  							not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (8);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (106' 4);  				FilterTreeNode newProperty = new Property (propertySegments);  				if ((inverse != null ? inverse.Text : default(string)) == "?")  					filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  				else {  					if ((not != null ? not.Text : default(string)) == "!")  						newProperty.ToggleInversed ();  					filterNode = newProperty;  				}  			}  			break;  		case 4:  			DebugEnterAlt (4);  			// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  			{  				DebugLocation (116' 4);  				STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  				DebugLocation (117' 4);  				string stringText = (STRING7 != null ? STRING7.Text : default(string));  				stringText = stringText.Substring (1' stringText.Length - 2);  				filterNode = new Value (stringText);  			}  			break;  		case 5:  			DebugEnterAlt (5);  			// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  			{  				DebugLocation (122' 4);  				REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  				DebugLocation (123' 4);  				string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  				regexText = regexText.Substring (1' regexText.Length - 2);  				filterNode = new RegExp (regexText);  			}  			break;  		case 6:  			DebugEnterAlt (6);  			// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  			{  				DebugLocation (128' 4);  				NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  				DebugLocation (129' 4);  				filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  			}  			break;  		case 7:  			DebugEnterAlt (7);  			// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  			{  				DebugLocation (132' 4);  				Match (input' TRUE' Follow._TRUE_in_filterExpr271);  				DebugLocation (133' 4);  				filterNode = new Value (true);  			}  			break;  		case 8:  			DebugEnterAlt (8);  			// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  			{  				DebugLocation (136' 4);  				Match (input' FALSE' Follow._FALSE_in_filterExpr281);  				DebugLocation (137' 4);  				filterNode = new Value (false);  			}  			break;  		case 9:  			DebugEnterAlt (9);  			// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  			{  				DebugLocation (140' 4);  				Match (input' NULL' Follow._NULL_in_filterExpr291);  				DebugLocation (141' 4);  				filterNode = new Value (null);  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("filterExpr"' 6);  		LeaveRule ("filterExpr"' 6);  		LeaveRule_filterExpr ();  	}  	DebugLocation (144' 1);  }  finally {  	DebugExitRule (GrammarFileName' "filterExpr");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "filterExpr");  	DebugLocation (60' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  		int alt9 = 9;  		try {  			DebugEnterDecision (9' false);  			switch (input.LA (1)) {  			case CHAIN_OPERATOR:  			case COMPARATOR:  				{  					alt9 = 1;  				}  				break;  			case EXPR:  				{  					int LA9_2 = input.LA (2);  					if ((LA9_2 == DOWN)) {  						int LA9_3 = input.LA (3);  						if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  							alt9 = 2;  						}  						else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  							alt9 = 3;  						}  						else {  							NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  							DebugRecognitionException (nvae);  							throw nvae;  						}  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				break;  			case STRING:  				{  					alt9 = 4;  				}  				break;  			case REGEX:  				{  					alt9 = 5;  				}  				break;  			case NUMBER:  				{  					alt9 = 6;  				}  				break;  			case TRUE:  				{  					alt9 = 7;  				}  				break;  			case FALSE:  				{  					alt9 = 8;  				}  				break;  			case NULL:  				{  					alt9 = 9;  				}  				break;  			default: {  				NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  			}  		}  		finally {  			DebugExitDecision (9);  		}  		switch (alt9) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  			{  				DebugLocation (64' 4);  				DebugLocation (64' 6);  				PushFollow (Follow._comparator_in_filterExpr175);  				comparator6 = comparator ();  				PopFollow ();  				Match (input' TokenTypes.Down' null);  				DebugLocation (64' 18);  				PushFollow (Follow._filterExpr_in_filterExpr179);  				a = filterExpr ();  				PopFollow ();  				DebugLocation (64' 31);  				PushFollow (Follow._filterExpr_in_filterExpr183);  				b = filterExpr ();  				PopFollow ();  				Match (input' TokenTypes.Up' null);  				DebugLocation (65' 4);  				Comparator newComparator;  				switch (comparator6) {  				case "=":  					newComparator = Comparator.Equals;  					break;  				case "!=":  					newComparator = Comparator.NotEquals;  					break;  				case ">":  					newComparator = Comparator.Greater;  					break;  				case "<":  					newComparator = Comparator.Less;  					break;  				case ">=":  					newComparator = Comparator.GreaterOrEqual;  					break;  				case "<=":  					newComparator = Comparator.LessOrEqual;  					break;  				case "&":  					newComparator = Comparator.And;  					break;  				case "|":  					newComparator = Comparator.Or;  					break;  				default:  					newComparator = Comparator.Equals;  					break;  				}  				filterNode = new BoolExpression (a' newComparator' b);  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  			{  				DebugLocation (98' 4);  				DebugLocation (98' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr195);  				Match (input' TokenTypes.Down' null);  				DebugLocation (98' 12);  				PushFollow (Follow._filterExpr_in_filterExpr199);  				f = filterExpr ();  				PopFollow ();  				DebugLocation (98' 31);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  				int alt6 = 2;  				try {  					DebugEnterSubRule (6);  					try {  						DebugEnterDecision (6' false);  						int LA6_1 = input.LA (1);  						if ((LA6_1 == 24)) {  							alt6 = 1;  						}  					}  					finally {  						DebugExitDecision (6);  					}  					switch (alt6) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  						{  							DebugLocation (98' 31);  							inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (6);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (99' 4);  				FilterTreeNode newNode = f;  				if ((inverse != null ? inverse.Text : default(string)) == "!")  					newNode.ToggleInversed ();  				filterNode = newNode;  			}  			break;  		case 3:  			DebugEnterAlt (3);  			// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  			{  				DebugLocation (105' 4);  				DebugLocation (105' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr216);  				Match (input' TokenTypes.Down' null);  				DebugLocation (105' 12);  				PushFollow (Follow._propertyChain_in_filterExpr219);  				propertyChain (propertySegments);  				PopFollow ();  				DebugLocation (105' 51);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  				int alt7 = 2;  				try {  					DebugEnterSubRule (7);  					try {  						DebugEnterDecision (7' false);  						int LA7_1 = input.LA (1);  						if ((LA7_1 == 31)) {  							alt7 = 1;  						}  					}  					finally {  						DebugExitDecision (7);  					}  					switch (alt7) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  						{  							DebugLocation (105' 51);  							inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (7);  				}  				DebugLocation (105' 60);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  				int alt8 = 2;  				try {  					DebugEnterSubRule (8);  					try {  						DebugEnterDecision (8' false);  						int LA8_1 = input.LA (1);  						if ((LA8_1 == 24)) {  							alt8 = 1;  						}  					}  					finally {  						DebugExitDecision (8);  					}  					switch (alt8) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  						{  							DebugLocation (105' 60);  							not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (8);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (106' 4);  				FilterTreeNode newProperty = new Property (propertySegments);  				if ((inverse != null ? inverse.Text : default(string)) == "?")  					filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  				else {  					if ((not != null ? not.Text : default(string)) == "!")  						newProperty.ToggleInversed ();  					filterNode = newProperty;  				}  			}  			break;  		case 4:  			DebugEnterAlt (4);  			// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  			{  				DebugLocation (116' 4);  				STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  				DebugLocation (117' 4);  				string stringText = (STRING7 != null ? STRING7.Text : default(string));  				stringText = stringText.Substring (1' stringText.Length - 2);  				filterNode = new Value (stringText);  			}  			break;  		case 5:  			DebugEnterAlt (5);  			// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  			{  				DebugLocation (122' 4);  				REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  				DebugLocation (123' 4);  				string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  				regexText = regexText.Substring (1' regexText.Length - 2);  				filterNode = new RegExp (regexText);  			}  			break;  		case 6:  			DebugEnterAlt (6);  			// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  			{  				DebugLocation (128' 4);  				NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  				DebugLocation (129' 4);  				filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  			}  			break;  		case 7:  			DebugEnterAlt (7);  			// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  			{  				DebugLocation (132' 4);  				Match (input' TRUE' Follow._TRUE_in_filterExpr271);  				DebugLocation (133' 4);  				filterNode = new Value (true);  			}  			break;  		case 8:  			DebugEnterAlt (8);  			// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  			{  				DebugLocation (136' 4);  				Match (input' FALSE' Follow._FALSE_in_filterExpr281);  				DebugLocation (137' 4);  				filterNode = new Value (false);  			}  			break;  		case 9:  			DebugEnterAlt (9);  			// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  			{  				DebugLocation (140' 4);  				Match (input' NULL' Follow._NULL_in_filterExpr291);  				DebugLocation (141' 4);  				filterNode = new Value (null);  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("filterExpr"' 6);  		LeaveRule ("filterExpr"' 6);  		LeaveRule_filterExpr ();  	}  	DebugLocation (144' 1);  }  finally {  	DebugExitRule (GrammarFileName' "filterExpr");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "filterExpr");  	DebugLocation (60' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  		int alt9 = 9;  		try {  			DebugEnterDecision (9' false);  			switch (input.LA (1)) {  			case CHAIN_OPERATOR:  			case COMPARATOR:  				{  					alt9 = 1;  				}  				break;  			case EXPR:  				{  					int LA9_2 = input.LA (2);  					if ((LA9_2 == DOWN)) {  						int LA9_3 = input.LA (3);  						if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  							alt9 = 2;  						}  						else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  							alt9 = 3;  						}  						else {  							NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  							DebugRecognitionException (nvae);  							throw nvae;  						}  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				break;  			case STRING:  				{  					alt9 = 4;  				}  				break;  			case REGEX:  				{  					alt9 = 5;  				}  				break;  			case NUMBER:  				{  					alt9 = 6;  				}  				break;  			case TRUE:  				{  					alt9 = 7;  				}  				break;  			case FALSE:  				{  					alt9 = 8;  				}  				break;  			case NULL:  				{  					alt9 = 9;  				}  				break;  			default: {  				NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  			}  		}  		finally {  			DebugExitDecision (9);  		}  		switch (alt9) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  			{  				DebugLocation (64' 4);  				DebugLocation (64' 6);  				PushFollow (Follow._comparator_in_filterExpr175);  				comparator6 = comparator ();  				PopFollow ();  				Match (input' TokenTypes.Down' null);  				DebugLocation (64' 18);  				PushFollow (Follow._filterExpr_in_filterExpr179);  				a = filterExpr ();  				PopFollow ();  				DebugLocation (64' 31);  				PushFollow (Follow._filterExpr_in_filterExpr183);  				b = filterExpr ();  				PopFollow ();  				Match (input' TokenTypes.Up' null);  				DebugLocation (65' 4);  				Comparator newComparator;  				switch (comparator6) {  				case "=":  					newComparator = Comparator.Equals;  					break;  				case "!=":  					newComparator = Comparator.NotEquals;  					break;  				case ">":  					newComparator = Comparator.Greater;  					break;  				case "<":  					newComparator = Comparator.Less;  					break;  				case ">=":  					newComparator = Comparator.GreaterOrEqual;  					break;  				case "<=":  					newComparator = Comparator.LessOrEqual;  					break;  				case "&":  					newComparator = Comparator.And;  					break;  				case "|":  					newComparator = Comparator.Or;  					break;  				default:  					newComparator = Comparator.Equals;  					break;  				}  				filterNode = new BoolExpression (a' newComparator' b);  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  			{  				DebugLocation (98' 4);  				DebugLocation (98' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr195);  				Match (input' TokenTypes.Down' null);  				DebugLocation (98' 12);  				PushFollow (Follow._filterExpr_in_filterExpr199);  				f = filterExpr ();  				PopFollow ();  				DebugLocation (98' 31);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  				int alt6 = 2;  				try {  					DebugEnterSubRule (6);  					try {  						DebugEnterDecision (6' false);  						int LA6_1 = input.LA (1);  						if ((LA6_1 == 24)) {  							alt6 = 1;  						}  					}  					finally {  						DebugExitDecision (6);  					}  					switch (alt6) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  						{  							DebugLocation (98' 31);  							inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (6);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (99' 4);  				FilterTreeNode newNode = f;  				if ((inverse != null ? inverse.Text : default(string)) == "!")  					newNode.ToggleInversed ();  				filterNode = newNode;  			}  			break;  		case 3:  			DebugEnterAlt (3);  			// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  			{  				DebugLocation (105' 4);  				DebugLocation (105' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr216);  				Match (input' TokenTypes.Down' null);  				DebugLocation (105' 12);  				PushFollow (Follow._propertyChain_in_filterExpr219);  				propertyChain (propertySegments);  				PopFollow ();  				DebugLocation (105' 51);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  				int alt7 = 2;  				try {  					DebugEnterSubRule (7);  					try {  						DebugEnterDecision (7' false);  						int LA7_1 = input.LA (1);  						if ((LA7_1 == 31)) {  							alt7 = 1;  						}  					}  					finally {  						DebugExitDecision (7);  					}  					switch (alt7) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  						{  							DebugLocation (105' 51);  							inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (7);  				}  				DebugLocation (105' 60);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  				int alt8 = 2;  				try {  					DebugEnterSubRule (8);  					try {  						DebugEnterDecision (8' false);  						int LA8_1 = input.LA (1);  						if ((LA8_1 == 24)) {  							alt8 = 1;  						}  					}  					finally {  						DebugExitDecision (8);  					}  					switch (alt8) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  						{  							DebugLocation (105' 60);  							not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (8);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (106' 4);  				FilterTreeNode newProperty = new Property (propertySegments);  				if ((inverse != null ? inverse.Text : default(string)) == "?")  					filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  				else {  					if ((not != null ? not.Text : default(string)) == "!")  						newProperty.ToggleInversed ();  					filterNode = newProperty;  				}  			}  			break;  		case 4:  			DebugEnterAlt (4);  			// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  			{  				DebugLocation (116' 4);  				STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  				DebugLocation (117' 4);  				string stringText = (STRING7 != null ? STRING7.Text : default(string));  				stringText = stringText.Substring (1' stringText.Length - 2);  				filterNode = new Value (stringText);  			}  			break;  		case 5:  			DebugEnterAlt (5);  			// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  			{  				DebugLocation (122' 4);  				REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  				DebugLocation (123' 4);  				string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  				regexText = regexText.Substring (1' regexText.Length - 2);  				filterNode = new RegExp (regexText);  			}  			break;  		case 6:  			DebugEnterAlt (6);  			// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  			{  				DebugLocation (128' 4);  				NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  				DebugLocation (129' 4);  				filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  			}  			break;  		case 7:  			DebugEnterAlt (7);  			// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  			{  				DebugLocation (132' 4);  				Match (input' TRUE' Follow._TRUE_in_filterExpr271);  				DebugLocation (133' 4);  				filterNode = new Value (true);  			}  			break;  		case 8:  			DebugEnterAlt (8);  			// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  			{  				DebugLocation (136' 4);  				Match (input' FALSE' Follow._FALSE_in_filterExpr281);  				DebugLocation (137' 4);  				filterNode = new Value (false);  			}  			break;  		case 9:  			DebugEnterAlt (9);  			// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  			{  				DebugLocation (140' 4);  				Match (input' NULL' Follow._NULL_in_filterExpr291);  				DebugLocation (141' 4);  				filterNode = new Value (null);  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("filterExpr"' 6);  		LeaveRule ("filterExpr"' 6);  		LeaveRule_filterExpr ();  	}  	DebugLocation (144' 1);  }  finally {  	DebugExitRule (GrammarFileName' "filterExpr");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "filterExpr");  	DebugLocation (60' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  		int alt9 = 9;  		try {  			DebugEnterDecision (9' false);  			switch (input.LA (1)) {  			case CHAIN_OPERATOR:  			case COMPARATOR:  				{  					alt9 = 1;  				}  				break;  			case EXPR:  				{  					int LA9_2 = input.LA (2);  					if ((LA9_2 == DOWN)) {  						int LA9_3 = input.LA (3);  						if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  							alt9 = 2;  						}  						else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  							alt9 = 3;  						}  						else {  							NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  							DebugRecognitionException (nvae);  							throw nvae;  						}  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				break;  			case STRING:  				{  					alt9 = 4;  				}  				break;  			case REGEX:  				{  					alt9 = 5;  				}  				break;  			case NUMBER:  				{  					alt9 = 6;  				}  				break;  			case TRUE:  				{  					alt9 = 7;  				}  				break;  			case FALSE:  				{  					alt9 = 8;  				}  				break;  			case NULL:  				{  					alt9 = 9;  				}  				break;  			default: {  				NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  			}  		}  		finally {  			DebugExitDecision (9);  		}  		switch (alt9) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  			{  				DebugLocation (64' 4);  				DebugLocation (64' 6);  				PushFollow (Follow._comparator_in_filterExpr175);  				comparator6 = comparator ();  				PopFollow ();  				Match (input' TokenTypes.Down' null);  				DebugLocation (64' 18);  				PushFollow (Follow._filterExpr_in_filterExpr179);  				a = filterExpr ();  				PopFollow ();  				DebugLocation (64' 31);  				PushFollow (Follow._filterExpr_in_filterExpr183);  				b = filterExpr ();  				PopFollow ();  				Match (input' TokenTypes.Up' null);  				DebugLocation (65' 4);  				Comparator newComparator;  				switch (comparator6) {  				case "=":  					newComparator = Comparator.Equals;  					break;  				case "!=":  					newComparator = Comparator.NotEquals;  					break;  				case ">":  					newComparator = Comparator.Greater;  					break;  				case "<":  					newComparator = Comparator.Less;  					break;  				case ">=":  					newComparator = Comparator.GreaterOrEqual;  					break;  				case "<=":  					newComparator = Comparator.LessOrEqual;  					break;  				case "&":  					newComparator = Comparator.And;  					break;  				case "|":  					newComparator = Comparator.Or;  					break;  				default:  					newComparator = Comparator.Equals;  					break;  				}  				filterNode = new BoolExpression (a' newComparator' b);  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  			{  				DebugLocation (98' 4);  				DebugLocation (98' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr195);  				Match (input' TokenTypes.Down' null);  				DebugLocation (98' 12);  				PushFollow (Follow._filterExpr_in_filterExpr199);  				f = filterExpr ();  				PopFollow ();  				DebugLocation (98' 31);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  				int alt6 = 2;  				try {  					DebugEnterSubRule (6);  					try {  						DebugEnterDecision (6' false);  						int LA6_1 = input.LA (1);  						if ((LA6_1 == 24)) {  							alt6 = 1;  						}  					}  					finally {  						DebugExitDecision (6);  					}  					switch (alt6) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  						{  							DebugLocation (98' 31);  							inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (6);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (99' 4);  				FilterTreeNode newNode = f;  				if ((inverse != null ? inverse.Text : default(string)) == "!")  					newNode.ToggleInversed ();  				filterNode = newNode;  			}  			break;  		case 3:  			DebugEnterAlt (3);  			// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  			{  				DebugLocation (105' 4);  				DebugLocation (105' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr216);  				Match (input' TokenTypes.Down' null);  				DebugLocation (105' 12);  				PushFollow (Follow._propertyChain_in_filterExpr219);  				propertyChain (propertySegments);  				PopFollow ();  				DebugLocation (105' 51);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  				int alt7 = 2;  				try {  					DebugEnterSubRule (7);  					try {  						DebugEnterDecision (7' false);  						int LA7_1 = input.LA (1);  						if ((LA7_1 == 31)) {  							alt7 = 1;  						}  					}  					finally {  						DebugExitDecision (7);  					}  					switch (alt7) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  						{  							DebugLocation (105' 51);  							inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (7);  				}  				DebugLocation (105' 60);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  				int alt8 = 2;  				try {  					DebugEnterSubRule (8);  					try {  						DebugEnterDecision (8' false);  						int LA8_1 = input.LA (1);  						if ((LA8_1 == 24)) {  							alt8 = 1;  						}  					}  					finally {  						DebugExitDecision (8);  					}  					switch (alt8) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  						{  							DebugLocation (105' 60);  							not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (8);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (106' 4);  				FilterTreeNode newProperty = new Property (propertySegments);  				if ((inverse != null ? inverse.Text : default(string)) == "?")  					filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  				else {  					if ((not != null ? not.Text : default(string)) == "!")  						newProperty.ToggleInversed ();  					filterNode = newProperty;  				}  			}  			break;  		case 4:  			DebugEnterAlt (4);  			// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  			{  				DebugLocation (116' 4);  				STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  				DebugLocation (117' 4);  				string stringText = (STRING7 != null ? STRING7.Text : default(string));  				stringText = stringText.Substring (1' stringText.Length - 2);  				filterNode = new Value (stringText);  			}  			break;  		case 5:  			DebugEnterAlt (5);  			// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  			{  				DebugLocation (122' 4);  				REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  				DebugLocation (123' 4);  				string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  				regexText = regexText.Substring (1' regexText.Length - 2);  				filterNode = new RegExp (regexText);  			}  			break;  		case 6:  			DebugEnterAlt (6);  			// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  			{  				DebugLocation (128' 4);  				NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  				DebugLocation (129' 4);  				filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  			}  			break;  		case 7:  			DebugEnterAlt (7);  			// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  			{  				DebugLocation (132' 4);  				Match (input' TRUE' Follow._TRUE_in_filterExpr271);  				DebugLocation (133' 4);  				filterNode = new Value (true);  			}  			break;  		case 8:  			DebugEnterAlt (8);  			// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  			{  				DebugLocation (136' 4);  				Match (input' FALSE' Follow._FALSE_in_filterExpr281);  				DebugLocation (137' 4);  				filterNode = new Value (false);  			}  			break;  		case 9:  			DebugEnterAlt (9);  			// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  			{  				DebugLocation (140' 4);  				Match (input' NULL' Follow._NULL_in_filterExpr291);  				DebugLocation (141' 4);  				filterNode = new Value (null);  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("filterExpr"' 6);  		LeaveRule ("filterExpr"' 6);  		LeaveRule_filterExpr ();  	}  	DebugLocation (144' 1);  }  finally {  	DebugExitRule (GrammarFileName' "filterExpr");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "filterExpr");  	DebugLocation (60' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  		int alt9 = 9;  		try {  			DebugEnterDecision (9' false);  			switch (input.LA (1)) {  			case CHAIN_OPERATOR:  			case COMPARATOR:  				{  					alt9 = 1;  				}  				break;  			case EXPR:  				{  					int LA9_2 = input.LA (2);  					if ((LA9_2 == DOWN)) {  						int LA9_3 = input.LA (3);  						if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  							alt9 = 2;  						}  						else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  							alt9 = 3;  						}  						else {  							NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  							DebugRecognitionException (nvae);  							throw nvae;  						}  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				break;  			case STRING:  				{  					alt9 = 4;  				}  				break;  			case REGEX:  				{  					alt9 = 5;  				}  				break;  			case NUMBER:  				{  					alt9 = 6;  				}  				break;  			case TRUE:  				{  					alt9 = 7;  				}  				break;  			case FALSE:  				{  					alt9 = 8;  				}  				break;  			case NULL:  				{  					alt9 = 9;  				}  				break;  			default: {  				NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  			}  		}  		finally {  			DebugExitDecision (9);  		}  		switch (alt9) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  			{  				DebugLocation (64' 4);  				DebugLocation (64' 6);  				PushFollow (Follow._comparator_in_filterExpr175);  				comparator6 = comparator ();  				PopFollow ();  				Match (input' TokenTypes.Down' null);  				DebugLocation (64' 18);  				PushFollow (Follow._filterExpr_in_filterExpr179);  				a = filterExpr ();  				PopFollow ();  				DebugLocation (64' 31);  				PushFollow (Follow._filterExpr_in_filterExpr183);  				b = filterExpr ();  				PopFollow ();  				Match (input' TokenTypes.Up' null);  				DebugLocation (65' 4);  				Comparator newComparator;  				switch (comparator6) {  				case "=":  					newComparator = Comparator.Equals;  					break;  				case "!=":  					newComparator = Comparator.NotEquals;  					break;  				case ">":  					newComparator = Comparator.Greater;  					break;  				case "<":  					newComparator = Comparator.Less;  					break;  				case ">=":  					newComparator = Comparator.GreaterOrEqual;  					break;  				case "<=":  					newComparator = Comparator.LessOrEqual;  					break;  				case "&":  					newComparator = Comparator.And;  					break;  				case "|":  					newComparator = Comparator.Or;  					break;  				default:  					newComparator = Comparator.Equals;  					break;  				}  				filterNode = new BoolExpression (a' newComparator' b);  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  			{  				DebugLocation (98' 4);  				DebugLocation (98' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr195);  				Match (input' TokenTypes.Down' null);  				DebugLocation (98' 12);  				PushFollow (Follow._filterExpr_in_filterExpr199);  				f = filterExpr ();  				PopFollow ();  				DebugLocation (98' 31);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  				int alt6 = 2;  				try {  					DebugEnterSubRule (6);  					try {  						DebugEnterDecision (6' false);  						int LA6_1 = input.LA (1);  						if ((LA6_1 == 24)) {  							alt6 = 1;  						}  					}  					finally {  						DebugExitDecision (6);  					}  					switch (alt6) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  						{  							DebugLocation (98' 31);  							inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (6);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (99' 4);  				FilterTreeNode newNode = f;  				if ((inverse != null ? inverse.Text : default(string)) == "!")  					newNode.ToggleInversed ();  				filterNode = newNode;  			}  			break;  		case 3:  			DebugEnterAlt (3);  			// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  			{  				DebugLocation (105' 4);  				DebugLocation (105' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr216);  				Match (input' TokenTypes.Down' null);  				DebugLocation (105' 12);  				PushFollow (Follow._propertyChain_in_filterExpr219);  				propertyChain (propertySegments);  				PopFollow ();  				DebugLocation (105' 51);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  				int alt7 = 2;  				try {  					DebugEnterSubRule (7);  					try {  						DebugEnterDecision (7' false);  						int LA7_1 = input.LA (1);  						if ((LA7_1 == 31)) {  							alt7 = 1;  						}  					}  					finally {  						DebugExitDecision (7);  					}  					switch (alt7) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  						{  							DebugLocation (105' 51);  							inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (7);  				}  				DebugLocation (105' 60);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  				int alt8 = 2;  				try {  					DebugEnterSubRule (8);  					try {  						DebugEnterDecision (8' false);  						int LA8_1 = input.LA (1);  						if ((LA8_1 == 24)) {  							alt8 = 1;  						}  					}  					finally {  						DebugExitDecision (8);  					}  					switch (alt8) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  						{  							DebugLocation (105' 60);  							not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (8);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (106' 4);  				FilterTreeNode newProperty = new Property (propertySegments);  				if ((inverse != null ? inverse.Text : default(string)) == "?")  					filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  				else {  					if ((not != null ? not.Text : default(string)) == "!")  						newProperty.ToggleInversed ();  					filterNode = newProperty;  				}  			}  			break;  		case 4:  			DebugEnterAlt (4);  			// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  			{  				DebugLocation (116' 4);  				STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  				DebugLocation (117' 4);  				string stringText = (STRING7 != null ? STRING7.Text : default(string));  				stringText = stringText.Substring (1' stringText.Length - 2);  				filterNode = new Value (stringText);  			}  			break;  		case 5:  			DebugEnterAlt (5);  			// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  			{  				DebugLocation (122' 4);  				REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  				DebugLocation (123' 4);  				string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  				regexText = regexText.Substring (1' regexText.Length - 2);  				filterNode = new RegExp (regexText);  			}  			break;  		case 6:  			DebugEnterAlt (6);  			// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  			{  				DebugLocation (128' 4);  				NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  				DebugLocation (129' 4);  				filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  			}  			break;  		case 7:  			DebugEnterAlt (7);  			// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  			{  				DebugLocation (132' 4);  				Match (input' TRUE' Follow._TRUE_in_filterExpr271);  				DebugLocation (133' 4);  				filterNode = new Value (true);  			}  			break;  		case 8:  			DebugEnterAlt (8);  			// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  			{  				DebugLocation (136' 4);  				Match (input' FALSE' Follow._FALSE_in_filterExpr281);  				DebugLocation (137' 4);  				filterNode = new Value (false);  			}  			break;  		case 9:  			DebugEnterAlt (9);  			// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  			{  				DebugLocation (140' 4);  				Match (input' NULL' Follow._NULL_in_filterExpr291);  				DebugLocation (141' 4);  				filterNode = new Value (null);  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("filterExpr"' 6);  		LeaveRule ("filterExpr"' 6);  		LeaveRule_filterExpr ();  	}  	DebugLocation (144' 1);  }  finally {  	DebugExitRule (GrammarFileName' "filterExpr");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "filterExpr");  	DebugLocation (60' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  		int alt9 = 9;  		try {  			DebugEnterDecision (9' false);  			switch (input.LA (1)) {  			case CHAIN_OPERATOR:  			case COMPARATOR:  				{  					alt9 = 1;  				}  				break;  			case EXPR:  				{  					int LA9_2 = input.LA (2);  					if ((LA9_2 == DOWN)) {  						int LA9_3 = input.LA (3);  						if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  							alt9 = 2;  						}  						else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  							alt9 = 3;  						}  						else {  							NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  							DebugRecognitionException (nvae);  							throw nvae;  						}  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				break;  			case STRING:  				{  					alt9 = 4;  				}  				break;  			case REGEX:  				{  					alt9 = 5;  				}  				break;  			case NUMBER:  				{  					alt9 = 6;  				}  				break;  			case TRUE:  				{  					alt9 = 7;  				}  				break;  			case FALSE:  				{  					alt9 = 8;  				}  				break;  			case NULL:  				{  					alt9 = 9;  				}  				break;  			default: {  				NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  			}  		}  		finally {  			DebugExitDecision (9);  		}  		switch (alt9) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  			{  				DebugLocation (64' 4);  				DebugLocation (64' 6);  				PushFollow (Follow._comparator_in_filterExpr175);  				comparator6 = comparator ();  				PopFollow ();  				Match (input' TokenTypes.Down' null);  				DebugLocation (64' 18);  				PushFollow (Follow._filterExpr_in_filterExpr179);  				a = filterExpr ();  				PopFollow ();  				DebugLocation (64' 31);  				PushFollow (Follow._filterExpr_in_filterExpr183);  				b = filterExpr ();  				PopFollow ();  				Match (input' TokenTypes.Up' null);  				DebugLocation (65' 4);  				Comparator newComparator;  				switch (comparator6) {  				case "=":  					newComparator = Comparator.Equals;  					break;  				case "!=":  					newComparator = Comparator.NotEquals;  					break;  				case ">":  					newComparator = Comparator.Greater;  					break;  				case "<":  					newComparator = Comparator.Less;  					break;  				case ">=":  					newComparator = Comparator.GreaterOrEqual;  					break;  				case "<=":  					newComparator = Comparator.LessOrEqual;  					break;  				case "&":  					newComparator = Comparator.And;  					break;  				case "|":  					newComparator = Comparator.Or;  					break;  				default:  					newComparator = Comparator.Equals;  					break;  				}  				filterNode = new BoolExpression (a' newComparator' b);  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  			{  				DebugLocation (98' 4);  				DebugLocation (98' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr195);  				Match (input' TokenTypes.Down' null);  				DebugLocation (98' 12);  				PushFollow (Follow._filterExpr_in_filterExpr199);  				f = filterExpr ();  				PopFollow ();  				DebugLocation (98' 31);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  				int alt6 = 2;  				try {  					DebugEnterSubRule (6);  					try {  						DebugEnterDecision (6' false);  						int LA6_1 = input.LA (1);  						if ((LA6_1 == 24)) {  							alt6 = 1;  						}  					}  					finally {  						DebugExitDecision (6);  					}  					switch (alt6) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  						{  							DebugLocation (98' 31);  							inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (6);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (99' 4);  				FilterTreeNode newNode = f;  				if ((inverse != null ? inverse.Text : default(string)) == "!")  					newNode.ToggleInversed ();  				filterNode = newNode;  			}  			break;  		case 3:  			DebugEnterAlt (3);  			// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  			{  				DebugLocation (105' 4);  				DebugLocation (105' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr216);  				Match (input' TokenTypes.Down' null);  				DebugLocation (105' 12);  				PushFollow (Follow._propertyChain_in_filterExpr219);  				propertyChain (propertySegments);  				PopFollow ();  				DebugLocation (105' 51);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  				int alt7 = 2;  				try {  					DebugEnterSubRule (7);  					try {  						DebugEnterDecision (7' false);  						int LA7_1 = input.LA (1);  						if ((LA7_1 == 31)) {  							alt7 = 1;  						}  					}  					finally {  						DebugExitDecision (7);  					}  					switch (alt7) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  						{  							DebugLocation (105' 51);  							inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (7);  				}  				DebugLocation (105' 60);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  				int alt8 = 2;  				try {  					DebugEnterSubRule (8);  					try {  						DebugEnterDecision (8' false);  						int LA8_1 = input.LA (1);  						if ((LA8_1 == 24)) {  							alt8 = 1;  						}  					}  					finally {  						DebugExitDecision (8);  					}  					switch (alt8) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  						{  							DebugLocation (105' 60);  							not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (8);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (106' 4);  				FilterTreeNode newProperty = new Property (propertySegments);  				if ((inverse != null ? inverse.Text : default(string)) == "?")  					filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  				else {  					if ((not != null ? not.Text : default(string)) == "!")  						newProperty.ToggleInversed ();  					filterNode = newProperty;  				}  			}  			break;  		case 4:  			DebugEnterAlt (4);  			// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  			{  				DebugLocation (116' 4);  				STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  				DebugLocation (117' 4);  				string stringText = (STRING7 != null ? STRING7.Text : default(string));  				stringText = stringText.Substring (1' stringText.Length - 2);  				filterNode = new Value (stringText);  			}  			break;  		case 5:  			DebugEnterAlt (5);  			// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  			{  				DebugLocation (122' 4);  				REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  				DebugLocation (123' 4);  				string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  				regexText = regexText.Substring (1' regexText.Length - 2);  				filterNode = new RegExp (regexText);  			}  			break;  		case 6:  			DebugEnterAlt (6);  			// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  			{  				DebugLocation (128' 4);  				NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  				DebugLocation (129' 4);  				filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  			}  			break;  		case 7:  			DebugEnterAlt (7);  			// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  			{  				DebugLocation (132' 4);  				Match (input' TRUE' Follow._TRUE_in_filterExpr271);  				DebugLocation (133' 4);  				filterNode = new Value (true);  			}  			break;  		case 8:  			DebugEnterAlt (8);  			// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  			{  				DebugLocation (136' 4);  				Match (input' FALSE' Follow._FALSE_in_filterExpr281);  				DebugLocation (137' 4);  				filterNode = new Value (false);  			}  			break;  		case 9:  			DebugEnterAlt (9);  			// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  			{  				DebugLocation (140' 4);  				Match (input' NULL' Follow._NULL_in_filterExpr291);  				DebugLocation (141' 4);  				filterNode = new Value (null);  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("filterExpr"' 6);  		LeaveRule ("filterExpr"' 6);  		LeaveRule_filterExpr ();  	}  	DebugLocation (144' 1);  }  finally {  	DebugExitRule (GrammarFileName' "filterExpr");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "filterExpr");  	DebugLocation (60' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  		int alt9 = 9;  		try {  			DebugEnterDecision (9' false);  			switch (input.LA (1)) {  			case CHAIN_OPERATOR:  			case COMPARATOR:  				{  					alt9 = 1;  				}  				break;  			case EXPR:  				{  					int LA9_2 = input.LA (2);  					if ((LA9_2 == DOWN)) {  						int LA9_3 = input.LA (3);  						if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  							alt9 = 2;  						}  						else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  							alt9 = 3;  						}  						else {  							NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  							DebugRecognitionException (nvae);  							throw nvae;  						}  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				break;  			case STRING:  				{  					alt9 = 4;  				}  				break;  			case REGEX:  				{  					alt9 = 5;  				}  				break;  			case NUMBER:  				{  					alt9 = 6;  				}  				break;  			case TRUE:  				{  					alt9 = 7;  				}  				break;  			case FALSE:  				{  					alt9 = 8;  				}  				break;  			case NULL:  				{  					alt9 = 9;  				}  				break;  			default: {  				NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  			}  		}  		finally {  			DebugExitDecision (9);  		}  		switch (alt9) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  			{  				DebugLocation (64' 4);  				DebugLocation (64' 6);  				PushFollow (Follow._comparator_in_filterExpr175);  				comparator6 = comparator ();  				PopFollow ();  				Match (input' TokenTypes.Down' null);  				DebugLocation (64' 18);  				PushFollow (Follow._filterExpr_in_filterExpr179);  				a = filterExpr ();  				PopFollow ();  				DebugLocation (64' 31);  				PushFollow (Follow._filterExpr_in_filterExpr183);  				b = filterExpr ();  				PopFollow ();  				Match (input' TokenTypes.Up' null);  				DebugLocation (65' 4);  				Comparator newComparator;  				switch (comparator6) {  				case "=":  					newComparator = Comparator.Equals;  					break;  				case "!=":  					newComparator = Comparator.NotEquals;  					break;  				case ">":  					newComparator = Comparator.Greater;  					break;  				case "<":  					newComparator = Comparator.Less;  					break;  				case ">=":  					newComparator = Comparator.GreaterOrEqual;  					break;  				case "<=":  					newComparator = Comparator.LessOrEqual;  					break;  				case "&":  					newComparator = Comparator.And;  					break;  				case "|":  					newComparator = Comparator.Or;  					break;  				default:  					newComparator = Comparator.Equals;  					break;  				}  				filterNode = new BoolExpression (a' newComparator' b);  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  			{  				DebugLocation (98' 4);  				DebugLocation (98' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr195);  				Match (input' TokenTypes.Down' null);  				DebugLocation (98' 12);  				PushFollow (Follow._filterExpr_in_filterExpr199);  				f = filterExpr ();  				PopFollow ();  				DebugLocation (98' 31);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  				int alt6 = 2;  				try {  					DebugEnterSubRule (6);  					try {  						DebugEnterDecision (6' false);  						int LA6_1 = input.LA (1);  						if ((LA6_1 == 24)) {  							alt6 = 1;  						}  					}  					finally {  						DebugExitDecision (6);  					}  					switch (alt6) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  						{  							DebugLocation (98' 31);  							inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (6);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (99' 4);  				FilterTreeNode newNode = f;  				if ((inverse != null ? inverse.Text : default(string)) == "!")  					newNode.ToggleInversed ();  				filterNode = newNode;  			}  			break;  		case 3:  			DebugEnterAlt (3);  			// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  			{  				DebugLocation (105' 4);  				DebugLocation (105' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr216);  				Match (input' TokenTypes.Down' null);  				DebugLocation (105' 12);  				PushFollow (Follow._propertyChain_in_filterExpr219);  				propertyChain (propertySegments);  				PopFollow ();  				DebugLocation (105' 51);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  				int alt7 = 2;  				try {  					DebugEnterSubRule (7);  					try {  						DebugEnterDecision (7' false);  						int LA7_1 = input.LA (1);  						if ((LA7_1 == 31)) {  							alt7 = 1;  						}  					}  					finally {  						DebugExitDecision (7);  					}  					switch (alt7) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  						{  							DebugLocation (105' 51);  							inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (7);  				}  				DebugLocation (105' 60);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  				int alt8 = 2;  				try {  					DebugEnterSubRule (8);  					try {  						DebugEnterDecision (8' false);  						int LA8_1 = input.LA (1);  						if ((LA8_1 == 24)) {  							alt8 = 1;  						}  					}  					finally {  						DebugExitDecision (8);  					}  					switch (alt8) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  						{  							DebugLocation (105' 60);  							not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (8);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (106' 4);  				FilterTreeNode newProperty = new Property (propertySegments);  				if ((inverse != null ? inverse.Text : default(string)) == "?")  					filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  				else {  					if ((not != null ? not.Text : default(string)) == "!")  						newProperty.ToggleInversed ();  					filterNode = newProperty;  				}  			}  			break;  		case 4:  			DebugEnterAlt (4);  			// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  			{  				DebugLocation (116' 4);  				STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  				DebugLocation (117' 4);  				string stringText = (STRING7 != null ? STRING7.Text : default(string));  				stringText = stringText.Substring (1' stringText.Length - 2);  				filterNode = new Value (stringText);  			}  			break;  		case 5:  			DebugEnterAlt (5);  			// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  			{  				DebugLocation (122' 4);  				REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  				DebugLocation (123' 4);  				string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  				regexText = regexText.Substring (1' regexText.Length - 2);  				filterNode = new RegExp (regexText);  			}  			break;  		case 6:  			DebugEnterAlt (6);  			// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  			{  				DebugLocation (128' 4);  				NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  				DebugLocation (129' 4);  				filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  			}  			break;  		case 7:  			DebugEnterAlt (7);  			// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  			{  				DebugLocation (132' 4);  				Match (input' TRUE' Follow._TRUE_in_filterExpr271);  				DebugLocation (133' 4);  				filterNode = new Value (true);  			}  			break;  		case 8:  			DebugEnterAlt (8);  			// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  			{  				DebugLocation (136' 4);  				Match (input' FALSE' Follow._FALSE_in_filterExpr281);  				DebugLocation (137' 4);  				filterNode = new Value (false);  			}  			break;  		case 9:  			DebugEnterAlt (9);  			// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  			{  				DebugLocation (140' 4);  				Match (input' NULL' Follow._NULL_in_filterExpr291);  				DebugLocation (141' 4);  				filterNode = new Value (null);  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("filterExpr"' 6);  		LeaveRule ("filterExpr"' 6);  		LeaveRule_filterExpr ();  	}  	DebugLocation (144' 1);  }  finally {  	DebugExitRule (GrammarFileName' "filterExpr");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "filterExpr");  	DebugLocation (60' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  		int alt9 = 9;  		try {  			DebugEnterDecision (9' false);  			switch (input.LA (1)) {  			case CHAIN_OPERATOR:  			case COMPARATOR:  				{  					alt9 = 1;  				}  				break;  			case EXPR:  				{  					int LA9_2 = input.LA (2);  					if ((LA9_2 == DOWN)) {  						int LA9_3 = input.LA (3);  						if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  							alt9 = 2;  						}  						else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  							alt9 = 3;  						}  						else {  							NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  							DebugRecognitionException (nvae);  							throw nvae;  						}  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				break;  			case STRING:  				{  					alt9 = 4;  				}  				break;  			case REGEX:  				{  					alt9 = 5;  				}  				break;  			case NUMBER:  				{  					alt9 = 6;  				}  				break;  			case TRUE:  				{  					alt9 = 7;  				}  				break;  			case FALSE:  				{  					alt9 = 8;  				}  				break;  			case NULL:  				{  					alt9 = 9;  				}  				break;  			default: {  				NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  			}  		}  		finally {  			DebugExitDecision (9);  		}  		switch (alt9) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  			{  				DebugLocation (64' 4);  				DebugLocation (64' 6);  				PushFollow (Follow._comparator_in_filterExpr175);  				comparator6 = comparator ();  				PopFollow ();  				Match (input' TokenTypes.Down' null);  				DebugLocation (64' 18);  				PushFollow (Follow._filterExpr_in_filterExpr179);  				a = filterExpr ();  				PopFollow ();  				DebugLocation (64' 31);  				PushFollow (Follow._filterExpr_in_filterExpr183);  				b = filterExpr ();  				PopFollow ();  				Match (input' TokenTypes.Up' null);  				DebugLocation (65' 4);  				Comparator newComparator;  				switch (comparator6) {  				case "=":  					newComparator = Comparator.Equals;  					break;  				case "!=":  					newComparator = Comparator.NotEquals;  					break;  				case ">":  					newComparator = Comparator.Greater;  					break;  				case "<":  					newComparator = Comparator.Less;  					break;  				case ">=":  					newComparator = Comparator.GreaterOrEqual;  					break;  				case "<=":  					newComparator = Comparator.LessOrEqual;  					break;  				case "&":  					newComparator = Comparator.And;  					break;  				case "|":  					newComparator = Comparator.Or;  					break;  				default:  					newComparator = Comparator.Equals;  					break;  				}  				filterNode = new BoolExpression (a' newComparator' b);  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  			{  				DebugLocation (98' 4);  				DebugLocation (98' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr195);  				Match (input' TokenTypes.Down' null);  				DebugLocation (98' 12);  				PushFollow (Follow._filterExpr_in_filterExpr199);  				f = filterExpr ();  				PopFollow ();  				DebugLocation (98' 31);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  				int alt6 = 2;  				try {  					DebugEnterSubRule (6);  					try {  						DebugEnterDecision (6' false);  						int LA6_1 = input.LA (1);  						if ((LA6_1 == 24)) {  							alt6 = 1;  						}  					}  					finally {  						DebugExitDecision (6);  					}  					switch (alt6) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  						{  							DebugLocation (98' 31);  							inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (6);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (99' 4);  				FilterTreeNode newNode = f;  				if ((inverse != null ? inverse.Text : default(string)) == "!")  					newNode.ToggleInversed ();  				filterNode = newNode;  			}  			break;  		case 3:  			DebugEnterAlt (3);  			// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  			{  				DebugLocation (105' 4);  				DebugLocation (105' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr216);  				Match (input' TokenTypes.Down' null);  				DebugLocation (105' 12);  				PushFollow (Follow._propertyChain_in_filterExpr219);  				propertyChain (propertySegments);  				PopFollow ();  				DebugLocation (105' 51);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  				int alt7 = 2;  				try {  					DebugEnterSubRule (7);  					try {  						DebugEnterDecision (7' false);  						int LA7_1 = input.LA (1);  						if ((LA7_1 == 31)) {  							alt7 = 1;  						}  					}  					finally {  						DebugExitDecision (7);  					}  					switch (alt7) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  						{  							DebugLocation (105' 51);  							inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (7);  				}  				DebugLocation (105' 60);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  				int alt8 = 2;  				try {  					DebugEnterSubRule (8);  					try {  						DebugEnterDecision (8' false);  						int LA8_1 = input.LA (1);  						if ((LA8_1 == 24)) {  							alt8 = 1;  						}  					}  					finally {  						DebugExitDecision (8);  					}  					switch (alt8) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  						{  							DebugLocation (105' 60);  							not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (8);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (106' 4);  				FilterTreeNode newProperty = new Property (propertySegments);  				if ((inverse != null ? inverse.Text : default(string)) == "?")  					filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  				else {  					if ((not != null ? not.Text : default(string)) == "!")  						newProperty.ToggleInversed ();  					filterNode = newProperty;  				}  			}  			break;  		case 4:  			DebugEnterAlt (4);  			// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  			{  				DebugLocation (116' 4);  				STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  				DebugLocation (117' 4);  				string stringText = (STRING7 != null ? STRING7.Text : default(string));  				stringText = stringText.Substring (1' stringText.Length - 2);  				filterNode = new Value (stringText);  			}  			break;  		case 5:  			DebugEnterAlt (5);  			// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  			{  				DebugLocation (122' 4);  				REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  				DebugLocation (123' 4);  				string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  				regexText = regexText.Substring (1' regexText.Length - 2);  				filterNode = new RegExp (regexText);  			}  			break;  		case 6:  			DebugEnterAlt (6);  			// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  			{  				DebugLocation (128' 4);  				NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  				DebugLocation (129' 4);  				filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  			}  			break;  		case 7:  			DebugEnterAlt (7);  			// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  			{  				DebugLocation (132' 4);  				Match (input' TRUE' Follow._TRUE_in_filterExpr271);  				DebugLocation (133' 4);  				filterNode = new Value (true);  			}  			break;  		case 8:  			DebugEnterAlt (8);  			// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  			{  				DebugLocation (136' 4);  				Match (input' FALSE' Follow._FALSE_in_filterExpr281);  				DebugLocation (137' 4);  				filterNode = new Value (false);  			}  			break;  		case 9:  			DebugEnterAlt (9);  			// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  			{  				DebugLocation (140' 4);  				Match (input' NULL' Follow._NULL_in_filterExpr291);  				DebugLocation (141' 4);  				filterNode = new Value (null);  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("filterExpr"' 6);  		LeaveRule ("filterExpr"' 6);  		LeaveRule_filterExpr ();  	}  	DebugLocation (144' 1);  }  finally {  	DebugExitRule (GrammarFileName' "filterExpr");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "filterExpr");  	DebugLocation (60' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  		int alt9 = 9;  		try {  			DebugEnterDecision (9' false);  			switch (input.LA (1)) {  			case CHAIN_OPERATOR:  			case COMPARATOR:  				{  					alt9 = 1;  				}  				break;  			case EXPR:  				{  					int LA9_2 = input.LA (2);  					if ((LA9_2 == DOWN)) {  						int LA9_3 = input.LA (3);  						if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  							alt9 = 2;  						}  						else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  							alt9 = 3;  						}  						else {  							NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  							DebugRecognitionException (nvae);  							throw nvae;  						}  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				break;  			case STRING:  				{  					alt9 = 4;  				}  				break;  			case REGEX:  				{  					alt9 = 5;  				}  				break;  			case NUMBER:  				{  					alt9 = 6;  				}  				break;  			case TRUE:  				{  					alt9 = 7;  				}  				break;  			case FALSE:  				{  					alt9 = 8;  				}  				break;  			case NULL:  				{  					alt9 = 9;  				}  				break;  			default: {  				NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  			}  		}  		finally {  			DebugExitDecision (9);  		}  		switch (alt9) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  			{  				DebugLocation (64' 4);  				DebugLocation (64' 6);  				PushFollow (Follow._comparator_in_filterExpr175);  				comparator6 = comparator ();  				PopFollow ();  				Match (input' TokenTypes.Down' null);  				DebugLocation (64' 18);  				PushFollow (Follow._filterExpr_in_filterExpr179);  				a = filterExpr ();  				PopFollow ();  				DebugLocation (64' 31);  				PushFollow (Follow._filterExpr_in_filterExpr183);  				b = filterExpr ();  				PopFollow ();  				Match (input' TokenTypes.Up' null);  				DebugLocation (65' 4);  				Comparator newComparator;  				switch (comparator6) {  				case "=":  					newComparator = Comparator.Equals;  					break;  				case "!=":  					newComparator = Comparator.NotEquals;  					break;  				case ">":  					newComparator = Comparator.Greater;  					break;  				case "<":  					newComparator = Comparator.Less;  					break;  				case ">=":  					newComparator = Comparator.GreaterOrEqual;  					break;  				case "<=":  					newComparator = Comparator.LessOrEqual;  					break;  				case "&":  					newComparator = Comparator.And;  					break;  				case "|":  					newComparator = Comparator.Or;  					break;  				default:  					newComparator = Comparator.Equals;  					break;  				}  				filterNode = new BoolExpression (a' newComparator' b);  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  			{  				DebugLocation (98' 4);  				DebugLocation (98' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr195);  				Match (input' TokenTypes.Down' null);  				DebugLocation (98' 12);  				PushFollow (Follow._filterExpr_in_filterExpr199);  				f = filterExpr ();  				PopFollow ();  				DebugLocation (98' 31);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  				int alt6 = 2;  				try {  					DebugEnterSubRule (6);  					try {  						DebugEnterDecision (6' false);  						int LA6_1 = input.LA (1);  						if ((LA6_1 == 24)) {  							alt6 = 1;  						}  					}  					finally {  						DebugExitDecision (6);  					}  					switch (alt6) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  						{  							DebugLocation (98' 31);  							inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (6);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (99' 4);  				FilterTreeNode newNode = f;  				if ((inverse != null ? inverse.Text : default(string)) == "!")  					newNode.ToggleInversed ();  				filterNode = newNode;  			}  			break;  		case 3:  			DebugEnterAlt (3);  			// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  			{  				DebugLocation (105' 4);  				DebugLocation (105' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr216);  				Match (input' TokenTypes.Down' null);  				DebugLocation (105' 12);  				PushFollow (Follow._propertyChain_in_filterExpr219);  				propertyChain (propertySegments);  				PopFollow ();  				DebugLocation (105' 51);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  				int alt7 = 2;  				try {  					DebugEnterSubRule (7);  					try {  						DebugEnterDecision (7' false);  						int LA7_1 = input.LA (1);  						if ((LA7_1 == 31)) {  							alt7 = 1;  						}  					}  					finally {  						DebugExitDecision (7);  					}  					switch (alt7) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  						{  							DebugLocation (105' 51);  							inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (7);  				}  				DebugLocation (105' 60);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  				int alt8 = 2;  				try {  					DebugEnterSubRule (8);  					try {  						DebugEnterDecision (8' false);  						int LA8_1 = input.LA (1);  						if ((LA8_1 == 24)) {  							alt8 = 1;  						}  					}  					finally {  						DebugExitDecision (8);  					}  					switch (alt8) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  						{  							DebugLocation (105' 60);  							not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (8);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (106' 4);  				FilterTreeNode newProperty = new Property (propertySegments);  				if ((inverse != null ? inverse.Text : default(string)) == "?")  					filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  				else {  					if ((not != null ? not.Text : default(string)) == "!")  						newProperty.ToggleInversed ();  					filterNode = newProperty;  				}  			}  			break;  		case 4:  			DebugEnterAlt (4);  			// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  			{  				DebugLocation (116' 4);  				STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  				DebugLocation (117' 4);  				string stringText = (STRING7 != null ? STRING7.Text : default(string));  				stringText = stringText.Substring (1' stringText.Length - 2);  				filterNode = new Value (stringText);  			}  			break;  		case 5:  			DebugEnterAlt (5);  			// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  			{  				DebugLocation (122' 4);  				REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  				DebugLocation (123' 4);  				string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  				regexText = regexText.Substring (1' regexText.Length - 2);  				filterNode = new RegExp (regexText);  			}  			break;  		case 6:  			DebugEnterAlt (6);  			// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  			{  				DebugLocation (128' 4);  				NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  				DebugLocation (129' 4);  				filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  			}  			break;  		case 7:  			DebugEnterAlt (7);  			// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  			{  				DebugLocation (132' 4);  				Match (input' TRUE' Follow._TRUE_in_filterExpr271);  				DebugLocation (133' 4);  				filterNode = new Value (true);  			}  			break;  		case 8:  			DebugEnterAlt (8);  			// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  			{  				DebugLocation (136' 4);  				Match (input' FALSE' Follow._FALSE_in_filterExpr281);  				DebugLocation (137' 4);  				filterNode = new Value (false);  			}  			break;  		case 9:  			DebugEnterAlt (9);  			// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  			{  				DebugLocation (140' 4);  				Match (input' NULL' Follow._NULL_in_filterExpr291);  				DebugLocation (141' 4);  				filterNode = new Value (null);  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("filterExpr"' 6);  		LeaveRule ("filterExpr"' 6);  		LeaveRule_filterExpr ();  	}  	DebugLocation (144' 1);  }  finally {  	DebugExitRule (GrammarFileName' "filterExpr");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "filterExpr");  	DebugLocation (60' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  		int alt9 = 9;  		try {  			DebugEnterDecision (9' false);  			switch (input.LA (1)) {  			case CHAIN_OPERATOR:  			case COMPARATOR:  				{  					alt9 = 1;  				}  				break;  			case EXPR:  				{  					int LA9_2 = input.LA (2);  					if ((LA9_2 == DOWN)) {  						int LA9_3 = input.LA (3);  						if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  							alt9 = 2;  						}  						else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  							alt9 = 3;  						}  						else {  							NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  							DebugRecognitionException (nvae);  							throw nvae;  						}  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				break;  			case STRING:  				{  					alt9 = 4;  				}  				break;  			case REGEX:  				{  					alt9 = 5;  				}  				break;  			case NUMBER:  				{  					alt9 = 6;  				}  				break;  			case TRUE:  				{  					alt9 = 7;  				}  				break;  			case FALSE:  				{  					alt9 = 8;  				}  				break;  			case NULL:  				{  					alt9 = 9;  				}  				break;  			default: {  				NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  			}  		}  		finally {  			DebugExitDecision (9);  		}  		switch (alt9) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  			{  				DebugLocation (64' 4);  				DebugLocation (64' 6);  				PushFollow (Follow._comparator_in_filterExpr175);  				comparator6 = comparator ();  				PopFollow ();  				Match (input' TokenTypes.Down' null);  				DebugLocation (64' 18);  				PushFollow (Follow._filterExpr_in_filterExpr179);  				a = filterExpr ();  				PopFollow ();  				DebugLocation (64' 31);  				PushFollow (Follow._filterExpr_in_filterExpr183);  				b = filterExpr ();  				PopFollow ();  				Match (input' TokenTypes.Up' null);  				DebugLocation (65' 4);  				Comparator newComparator;  				switch (comparator6) {  				case "=":  					newComparator = Comparator.Equals;  					break;  				case "!=":  					newComparator = Comparator.NotEquals;  					break;  				case ">":  					newComparator = Comparator.Greater;  					break;  				case "<":  					newComparator = Comparator.Less;  					break;  				case ">=":  					newComparator = Comparator.GreaterOrEqual;  					break;  				case "<=":  					newComparator = Comparator.LessOrEqual;  					break;  				case "&":  					newComparator = Comparator.And;  					break;  				case "|":  					newComparator = Comparator.Or;  					break;  				default:  					newComparator = Comparator.Equals;  					break;  				}  				filterNode = new BoolExpression (a' newComparator' b);  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  			{  				DebugLocation (98' 4);  				DebugLocation (98' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr195);  				Match (input' TokenTypes.Down' null);  				DebugLocation (98' 12);  				PushFollow (Follow._filterExpr_in_filterExpr199);  				f = filterExpr ();  				PopFollow ();  				DebugLocation (98' 31);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  				int alt6 = 2;  				try {  					DebugEnterSubRule (6);  					try {  						DebugEnterDecision (6' false);  						int LA6_1 = input.LA (1);  						if ((LA6_1 == 24)) {  							alt6 = 1;  						}  					}  					finally {  						DebugExitDecision (6);  					}  					switch (alt6) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  						{  							DebugLocation (98' 31);  							inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (6);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (99' 4);  				FilterTreeNode newNode = f;  				if ((inverse != null ? inverse.Text : default(string)) == "!")  					newNode.ToggleInversed ();  				filterNode = newNode;  			}  			break;  		case 3:  			DebugEnterAlt (3);  			// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  			{  				DebugLocation (105' 4);  				DebugLocation (105' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr216);  				Match (input' TokenTypes.Down' null);  				DebugLocation (105' 12);  				PushFollow (Follow._propertyChain_in_filterExpr219);  				propertyChain (propertySegments);  				PopFollow ();  				DebugLocation (105' 51);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  				int alt7 = 2;  				try {  					DebugEnterSubRule (7);  					try {  						DebugEnterDecision (7' false);  						int LA7_1 = input.LA (1);  						if ((LA7_1 == 31)) {  							alt7 = 1;  						}  					}  					finally {  						DebugExitDecision (7);  					}  					switch (alt7) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  						{  							DebugLocation (105' 51);  							inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (7);  				}  				DebugLocation (105' 60);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  				int alt8 = 2;  				try {  					DebugEnterSubRule (8);  					try {  						DebugEnterDecision (8' false);  						int LA8_1 = input.LA (1);  						if ((LA8_1 == 24)) {  							alt8 = 1;  						}  					}  					finally {  						DebugExitDecision (8);  					}  					switch (alt8) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  						{  							DebugLocation (105' 60);  							not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (8);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (106' 4);  				FilterTreeNode newProperty = new Property (propertySegments);  				if ((inverse != null ? inverse.Text : default(string)) == "?")  					filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  				else {  					if ((not != null ? not.Text : default(string)) == "!")  						newProperty.ToggleInversed ();  					filterNode = newProperty;  				}  			}  			break;  		case 4:  			DebugEnterAlt (4);  			// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  			{  				DebugLocation (116' 4);  				STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  				DebugLocation (117' 4);  				string stringText = (STRING7 != null ? STRING7.Text : default(string));  				stringText = stringText.Substring (1' stringText.Length - 2);  				filterNode = new Value (stringText);  			}  			break;  		case 5:  			DebugEnterAlt (5);  			// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  			{  				DebugLocation (122' 4);  				REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  				DebugLocation (123' 4);  				string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  				regexText = regexText.Substring (1' regexText.Length - 2);  				filterNode = new RegExp (regexText);  			}  			break;  		case 6:  			DebugEnterAlt (6);  			// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  			{  				DebugLocation (128' 4);  				NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  				DebugLocation (129' 4);  				filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  			}  			break;  		case 7:  			DebugEnterAlt (7);  			// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  			{  				DebugLocation (132' 4);  				Match (input' TRUE' Follow._TRUE_in_filterExpr271);  				DebugLocation (133' 4);  				filterNode = new Value (true);  			}  			break;  		case 8:  			DebugEnterAlt (8);  			// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  			{  				DebugLocation (136' 4);  				Match (input' FALSE' Follow._FALSE_in_filterExpr281);  				DebugLocation (137' 4);  				filterNode = new Value (false);  			}  			break;  		case 9:  			DebugEnterAlt (9);  			// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  			{  				DebugLocation (140' 4);  				Match (input' NULL' Follow._NULL_in_filterExpr291);  				DebugLocation (141' 4);  				filterNode = new Value (null);  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("filterExpr"' 6);  		LeaveRule ("filterExpr"' 6);  		LeaveRule_filterExpr ();  	}  	DebugLocation (144' 1);  }  finally {  	DebugExitRule (GrammarFileName' "filterExpr");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "filterExpr");  	DebugLocation (60' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  		int alt9 = 9;  		try {  			DebugEnterDecision (9' false);  			switch (input.LA (1)) {  			case CHAIN_OPERATOR:  			case COMPARATOR:  				{  					alt9 = 1;  				}  				break;  			case EXPR:  				{  					int LA9_2 = input.LA (2);  					if ((LA9_2 == DOWN)) {  						int LA9_3 = input.LA (3);  						if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  							alt9 = 2;  						}  						else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  							alt9 = 3;  						}  						else {  							NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  							DebugRecognitionException (nvae);  							throw nvae;  						}  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				break;  			case STRING:  				{  					alt9 = 4;  				}  				break;  			case REGEX:  				{  					alt9 = 5;  				}  				break;  			case NUMBER:  				{  					alt9 = 6;  				}  				break;  			case TRUE:  				{  					alt9 = 7;  				}  				break;  			case FALSE:  				{  					alt9 = 8;  				}  				break;  			case NULL:  				{  					alt9 = 9;  				}  				break;  			default: {  				NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  			}  		}  		finally {  			DebugExitDecision (9);  		}  		switch (alt9) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  			{  				DebugLocation (64' 4);  				DebugLocation (64' 6);  				PushFollow (Follow._comparator_in_filterExpr175);  				comparator6 = comparator ();  				PopFollow ();  				Match (input' TokenTypes.Down' null);  				DebugLocation (64' 18);  				PushFollow (Follow._filterExpr_in_filterExpr179);  				a = filterExpr ();  				PopFollow ();  				DebugLocation (64' 31);  				PushFollow (Follow._filterExpr_in_filterExpr183);  				b = filterExpr ();  				PopFollow ();  				Match (input' TokenTypes.Up' null);  				DebugLocation (65' 4);  				Comparator newComparator;  				switch (comparator6) {  				case "=":  					newComparator = Comparator.Equals;  					break;  				case "!=":  					newComparator = Comparator.NotEquals;  					break;  				case ">":  					newComparator = Comparator.Greater;  					break;  				case "<":  					newComparator = Comparator.Less;  					break;  				case ">=":  					newComparator = Comparator.GreaterOrEqual;  					break;  				case "<=":  					newComparator = Comparator.LessOrEqual;  					break;  				case "&":  					newComparator = Comparator.And;  					break;  				case "|":  					newComparator = Comparator.Or;  					break;  				default:  					newComparator = Comparator.Equals;  					break;  				}  				filterNode = new BoolExpression (a' newComparator' b);  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  			{  				DebugLocation (98' 4);  				DebugLocation (98' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr195);  				Match (input' TokenTypes.Down' null);  				DebugLocation (98' 12);  				PushFollow (Follow._filterExpr_in_filterExpr199);  				f = filterExpr ();  				PopFollow ();  				DebugLocation (98' 31);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  				int alt6 = 2;  				try {  					DebugEnterSubRule (6);  					try {  						DebugEnterDecision (6' false);  						int LA6_1 = input.LA (1);  						if ((LA6_1 == 24)) {  							alt6 = 1;  						}  					}  					finally {  						DebugExitDecision (6);  					}  					switch (alt6) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  						{  							DebugLocation (98' 31);  							inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (6);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (99' 4);  				FilterTreeNode newNode = f;  				if ((inverse != null ? inverse.Text : default(string)) == "!")  					newNode.ToggleInversed ();  				filterNode = newNode;  			}  			break;  		case 3:  			DebugEnterAlt (3);  			// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  			{  				DebugLocation (105' 4);  				DebugLocation (105' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr216);  				Match (input' TokenTypes.Down' null);  				DebugLocation (105' 12);  				PushFollow (Follow._propertyChain_in_filterExpr219);  				propertyChain (propertySegments);  				PopFollow ();  				DebugLocation (105' 51);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  				int alt7 = 2;  				try {  					DebugEnterSubRule (7);  					try {  						DebugEnterDecision (7' false);  						int LA7_1 = input.LA (1);  						if ((LA7_1 == 31)) {  							alt7 = 1;  						}  					}  					finally {  						DebugExitDecision (7);  					}  					switch (alt7) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  						{  							DebugLocation (105' 51);  							inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (7);  				}  				DebugLocation (105' 60);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  				int alt8 = 2;  				try {  					DebugEnterSubRule (8);  					try {  						DebugEnterDecision (8' false);  						int LA8_1 = input.LA (1);  						if ((LA8_1 == 24)) {  							alt8 = 1;  						}  					}  					finally {  						DebugExitDecision (8);  					}  					switch (alt8) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  						{  							DebugLocation (105' 60);  							not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (8);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (106' 4);  				FilterTreeNode newProperty = new Property (propertySegments);  				if ((inverse != null ? inverse.Text : default(string)) == "?")  					filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  				else {  					if ((not != null ? not.Text : default(string)) == "!")  						newProperty.ToggleInversed ();  					filterNode = newProperty;  				}  			}  			break;  		case 4:  			DebugEnterAlt (4);  			// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  			{  				DebugLocation (116' 4);  				STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  				DebugLocation (117' 4);  				string stringText = (STRING7 != null ? STRING7.Text : default(string));  				stringText = stringText.Substring (1' stringText.Length - 2);  				filterNode = new Value (stringText);  			}  			break;  		case 5:  			DebugEnterAlt (5);  			// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  			{  				DebugLocation (122' 4);  				REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  				DebugLocation (123' 4);  				string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  				regexText = regexText.Substring (1' regexText.Length - 2);  				filterNode = new RegExp (regexText);  			}  			break;  		case 6:  			DebugEnterAlt (6);  			// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  			{  				DebugLocation (128' 4);  				NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  				DebugLocation (129' 4);  				filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  			}  			break;  		case 7:  			DebugEnterAlt (7);  			// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  			{  				DebugLocation (132' 4);  				Match (input' TRUE' Follow._TRUE_in_filterExpr271);  				DebugLocation (133' 4);  				filterNode = new Value (true);  			}  			break;  		case 8:  			DebugEnterAlt (8);  			// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  			{  				DebugLocation (136' 4);  				Match (input' FALSE' Follow._FALSE_in_filterExpr281);  				DebugLocation (137' 4);  				filterNode = new Value (false);  			}  			break;  		case 9:  			DebugEnterAlt (9);  			// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  			{  				DebugLocation (140' 4);  				Match (input' NULL' Follow._NULL_in_filterExpr291);  				DebugLocation (141' 4);  				filterNode = new Value (null);  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("filterExpr"' 6);  		LeaveRule ("filterExpr"' 6);  		LeaveRule_filterExpr ();  	}  	DebugLocation (144' 1);  }  finally {  	DebugExitRule (GrammarFileName' "filterExpr");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "filterExpr");  	DebugLocation (60' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  		int alt9 = 9;  		try {  			DebugEnterDecision (9' false);  			switch (input.LA (1)) {  			case CHAIN_OPERATOR:  			case COMPARATOR:  				{  					alt9 = 1;  				}  				break;  			case EXPR:  				{  					int LA9_2 = input.LA (2);  					if ((LA9_2 == DOWN)) {  						int LA9_3 = input.LA (3);  						if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  							alt9 = 2;  						}  						else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  							alt9 = 3;  						}  						else {  							NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  							DebugRecognitionException (nvae);  							throw nvae;  						}  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				break;  			case STRING:  				{  					alt9 = 4;  				}  				break;  			case REGEX:  				{  					alt9 = 5;  				}  				break;  			case NUMBER:  				{  					alt9 = 6;  				}  				break;  			case TRUE:  				{  					alt9 = 7;  				}  				break;  			case FALSE:  				{  					alt9 = 8;  				}  				break;  			case NULL:  				{  					alt9 = 9;  				}  				break;  			default: {  				NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  			}  		}  		finally {  			DebugExitDecision (9);  		}  		switch (alt9) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  			{  				DebugLocation (64' 4);  				DebugLocation (64' 6);  				PushFollow (Follow._comparator_in_filterExpr175);  				comparator6 = comparator ();  				PopFollow ();  				Match (input' TokenTypes.Down' null);  				DebugLocation (64' 18);  				PushFollow (Follow._filterExpr_in_filterExpr179);  				a = filterExpr ();  				PopFollow ();  				DebugLocation (64' 31);  				PushFollow (Follow._filterExpr_in_filterExpr183);  				b = filterExpr ();  				PopFollow ();  				Match (input' TokenTypes.Up' null);  				DebugLocation (65' 4);  				Comparator newComparator;  				switch (comparator6) {  				case "=":  					newComparator = Comparator.Equals;  					break;  				case "!=":  					newComparator = Comparator.NotEquals;  					break;  				case ">":  					newComparator = Comparator.Greater;  					break;  				case "<":  					newComparator = Comparator.Less;  					break;  				case ">=":  					newComparator = Comparator.GreaterOrEqual;  					break;  				case "<=":  					newComparator = Comparator.LessOrEqual;  					break;  				case "&":  					newComparator = Comparator.And;  					break;  				case "|":  					newComparator = Comparator.Or;  					break;  				default:  					newComparator = Comparator.Equals;  					break;  				}  				filterNode = new BoolExpression (a' newComparator' b);  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  			{  				DebugLocation (98' 4);  				DebugLocation (98' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr195);  				Match (input' TokenTypes.Down' null);  				DebugLocation (98' 12);  				PushFollow (Follow._filterExpr_in_filterExpr199);  				f = filterExpr ();  				PopFollow ();  				DebugLocation (98' 31);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  				int alt6 = 2;  				try {  					DebugEnterSubRule (6);  					try {  						DebugEnterDecision (6' false);  						int LA6_1 = input.LA (1);  						if ((LA6_1 == 24)) {  							alt6 = 1;  						}  					}  					finally {  						DebugExitDecision (6);  					}  					switch (alt6) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  						{  							DebugLocation (98' 31);  							inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (6);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (99' 4);  				FilterTreeNode newNode = f;  				if ((inverse != null ? inverse.Text : default(string)) == "!")  					newNode.ToggleInversed ();  				filterNode = newNode;  			}  			break;  		case 3:  			DebugEnterAlt (3);  			// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  			{  				DebugLocation (105' 4);  				DebugLocation (105' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr216);  				Match (input' TokenTypes.Down' null);  				DebugLocation (105' 12);  				PushFollow (Follow._propertyChain_in_filterExpr219);  				propertyChain (propertySegments);  				PopFollow ();  				DebugLocation (105' 51);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  				int alt7 = 2;  				try {  					DebugEnterSubRule (7);  					try {  						DebugEnterDecision (7' false);  						int LA7_1 = input.LA (1);  						if ((LA7_1 == 31)) {  							alt7 = 1;  						}  					}  					finally {  						DebugExitDecision (7);  					}  					switch (alt7) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  						{  							DebugLocation (105' 51);  							inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (7);  				}  				DebugLocation (105' 60);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  				int alt8 = 2;  				try {  					DebugEnterSubRule (8);  					try {  						DebugEnterDecision (8' false);  						int LA8_1 = input.LA (1);  						if ((LA8_1 == 24)) {  							alt8 = 1;  						}  					}  					finally {  						DebugExitDecision (8);  					}  					switch (alt8) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  						{  							DebugLocation (105' 60);  							not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (8);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (106' 4);  				FilterTreeNode newProperty = new Property (propertySegments);  				if ((inverse != null ? inverse.Text : default(string)) == "?")  					filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  				else {  					if ((not != null ? not.Text : default(string)) == "!")  						newProperty.ToggleInversed ();  					filterNode = newProperty;  				}  			}  			break;  		case 4:  			DebugEnterAlt (4);  			// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  			{  				DebugLocation (116' 4);  				STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  				DebugLocation (117' 4);  				string stringText = (STRING7 != null ? STRING7.Text : default(string));  				stringText = stringText.Substring (1' stringText.Length - 2);  				filterNode = new Value (stringText);  			}  			break;  		case 5:  			DebugEnterAlt (5);  			// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  			{  				DebugLocation (122' 4);  				REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  				DebugLocation (123' 4);  				string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  				regexText = regexText.Substring (1' regexText.Length - 2);  				filterNode = new RegExp (regexText);  			}  			break;  		case 6:  			DebugEnterAlt (6);  			// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  			{  				DebugLocation (128' 4);  				NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  				DebugLocation (129' 4);  				filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  			}  			break;  		case 7:  			DebugEnterAlt (7);  			// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  			{  				DebugLocation (132' 4);  				Match (input' TRUE' Follow._TRUE_in_filterExpr271);  				DebugLocation (133' 4);  				filterNode = new Value (true);  			}  			break;  		case 8:  			DebugEnterAlt (8);  			// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  			{  				DebugLocation (136' 4);  				Match (input' FALSE' Follow._FALSE_in_filterExpr281);  				DebugLocation (137' 4);  				filterNode = new Value (false);  			}  			break;  		case 9:  			DebugEnterAlt (9);  			// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  			{  				DebugLocation (140' 4);  				Match (input' NULL' Follow._NULL_in_filterExpr291);  				DebugLocation (141' 4);  				filterNode = new Value (null);  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("filterExpr"' 6);  		LeaveRule ("filterExpr"' 6);  		LeaveRule_filterExpr ();  	}  	DebugLocation (144' 1);  }  finally {  	DebugExitRule (GrammarFileName' "filterExpr");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "filterExpr");  	DebugLocation (60' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  		int alt9 = 9;  		try {  			DebugEnterDecision (9' false);  			switch (input.LA (1)) {  			case CHAIN_OPERATOR:  			case COMPARATOR:  				{  					alt9 = 1;  				}  				break;  			case EXPR:  				{  					int LA9_2 = input.LA (2);  					if ((LA9_2 == DOWN)) {  						int LA9_3 = input.LA (3);  						if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  							alt9 = 2;  						}  						else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  							alt9 = 3;  						}  						else {  							NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  							DebugRecognitionException (nvae);  							throw nvae;  						}  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				break;  			case STRING:  				{  					alt9 = 4;  				}  				break;  			case REGEX:  				{  					alt9 = 5;  				}  				break;  			case NUMBER:  				{  					alt9 = 6;  				}  				break;  			case TRUE:  				{  					alt9 = 7;  				}  				break;  			case FALSE:  				{  					alt9 = 8;  				}  				break;  			case NULL:  				{  					alt9 = 9;  				}  				break;  			default: {  				NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  			}  		}  		finally {  			DebugExitDecision (9);  		}  		switch (alt9) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  			{  				DebugLocation (64' 4);  				DebugLocation (64' 6);  				PushFollow (Follow._comparator_in_filterExpr175);  				comparator6 = comparator ();  				PopFollow ();  				Match (input' TokenTypes.Down' null);  				DebugLocation (64' 18);  				PushFollow (Follow._filterExpr_in_filterExpr179);  				a = filterExpr ();  				PopFollow ();  				DebugLocation (64' 31);  				PushFollow (Follow._filterExpr_in_filterExpr183);  				b = filterExpr ();  				PopFollow ();  				Match (input' TokenTypes.Up' null);  				DebugLocation (65' 4);  				Comparator newComparator;  				switch (comparator6) {  				case "=":  					newComparator = Comparator.Equals;  					break;  				case "!=":  					newComparator = Comparator.NotEquals;  					break;  				case ">":  					newComparator = Comparator.Greater;  					break;  				case "<":  					newComparator = Comparator.Less;  					break;  				case ">=":  					newComparator = Comparator.GreaterOrEqual;  					break;  				case "<=":  					newComparator = Comparator.LessOrEqual;  					break;  				case "&":  					newComparator = Comparator.And;  					break;  				case "|":  					newComparator = Comparator.Or;  					break;  				default:  					newComparator = Comparator.Equals;  					break;  				}  				filterNode = new BoolExpression (a' newComparator' b);  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  			{  				DebugLocation (98' 4);  				DebugLocation (98' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr195);  				Match (input' TokenTypes.Down' null);  				DebugLocation (98' 12);  				PushFollow (Follow._filterExpr_in_filterExpr199);  				f = filterExpr ();  				PopFollow ();  				DebugLocation (98' 31);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  				int alt6 = 2;  				try {  					DebugEnterSubRule (6);  					try {  						DebugEnterDecision (6' false);  						int LA6_1 = input.LA (1);  						if ((LA6_1 == 24)) {  							alt6 = 1;  						}  					}  					finally {  						DebugExitDecision (6);  					}  					switch (alt6) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  						{  							DebugLocation (98' 31);  							inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (6);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (99' 4);  				FilterTreeNode newNode = f;  				if ((inverse != null ? inverse.Text : default(string)) == "!")  					newNode.ToggleInversed ();  				filterNode = newNode;  			}  			break;  		case 3:  			DebugEnterAlt (3);  			// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  			{  				DebugLocation (105' 4);  				DebugLocation (105' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr216);  				Match (input' TokenTypes.Down' null);  				DebugLocation (105' 12);  				PushFollow (Follow._propertyChain_in_filterExpr219);  				propertyChain (propertySegments);  				PopFollow ();  				DebugLocation (105' 51);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  				int alt7 = 2;  				try {  					DebugEnterSubRule (7);  					try {  						DebugEnterDecision (7' false);  						int LA7_1 = input.LA (1);  						if ((LA7_1 == 31)) {  							alt7 = 1;  						}  					}  					finally {  						DebugExitDecision (7);  					}  					switch (alt7) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  						{  							DebugLocation (105' 51);  							inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (7);  				}  				DebugLocation (105' 60);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  				int alt8 = 2;  				try {  					DebugEnterSubRule (8);  					try {  						DebugEnterDecision (8' false);  						int LA8_1 = input.LA (1);  						if ((LA8_1 == 24)) {  							alt8 = 1;  						}  					}  					finally {  						DebugExitDecision (8);  					}  					switch (alt8) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  						{  							DebugLocation (105' 60);  							not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (8);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (106' 4);  				FilterTreeNode newProperty = new Property (propertySegments);  				if ((inverse != null ? inverse.Text : default(string)) == "?")  					filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  				else {  					if ((not != null ? not.Text : default(string)) == "!")  						newProperty.ToggleInversed ();  					filterNode = newProperty;  				}  			}  			break;  		case 4:  			DebugEnterAlt (4);  			// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  			{  				DebugLocation (116' 4);  				STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  				DebugLocation (117' 4);  				string stringText = (STRING7 != null ? STRING7.Text : default(string));  				stringText = stringText.Substring (1' stringText.Length - 2);  				filterNode = new Value (stringText);  			}  			break;  		case 5:  			DebugEnterAlt (5);  			// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  			{  				DebugLocation (122' 4);  				REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  				DebugLocation (123' 4);  				string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  				regexText = regexText.Substring (1' regexText.Length - 2);  				filterNode = new RegExp (regexText);  			}  			break;  		case 6:  			DebugEnterAlt (6);  			// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  			{  				DebugLocation (128' 4);  				NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  				DebugLocation (129' 4);  				filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  			}  			break;  		case 7:  			DebugEnterAlt (7);  			// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  			{  				DebugLocation (132' 4);  				Match (input' TRUE' Follow._TRUE_in_filterExpr271);  				DebugLocation (133' 4);  				filterNode = new Value (true);  			}  			break;  		case 8:  			DebugEnterAlt (8);  			// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  			{  				DebugLocation (136' 4);  				Match (input' FALSE' Follow._FALSE_in_filterExpr281);  				DebugLocation (137' 4);  				filterNode = new Value (false);  			}  			break;  		case 9:  			DebugEnterAlt (9);  			// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  			{  				DebugLocation (140' 4);  				Match (input' NULL' Follow._NULL_in_filterExpr291);  				DebugLocation (141' 4);  				filterNode = new Value (null);  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("filterExpr"' 6);  		LeaveRule ("filterExpr"' 6);  		LeaveRule_filterExpr ();  	}  	DebugLocation (144' 1);  }  finally {  	DebugExitRule (GrammarFileName' "filterExpr");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "filterExpr");  	DebugLocation (60' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  		int alt9 = 9;  		try {  			DebugEnterDecision (9' false);  			switch (input.LA (1)) {  			case CHAIN_OPERATOR:  			case COMPARATOR:  				{  					alt9 = 1;  				}  				break;  			case EXPR:  				{  					int LA9_2 = input.LA (2);  					if ((LA9_2 == DOWN)) {  						int LA9_3 = input.LA (3);  						if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  							alt9 = 2;  						}  						else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  							alt9 = 3;  						}  						else {  							NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  							DebugRecognitionException (nvae);  							throw nvae;  						}  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				break;  			case STRING:  				{  					alt9 = 4;  				}  				break;  			case REGEX:  				{  					alt9 = 5;  				}  				break;  			case NUMBER:  				{  					alt9 = 6;  				}  				break;  			case TRUE:  				{  					alt9 = 7;  				}  				break;  			case FALSE:  				{  					alt9 = 8;  				}  				break;  			case NULL:  				{  					alt9 = 9;  				}  				break;  			default: {  				NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  			}  		}  		finally {  			DebugExitDecision (9);  		}  		switch (alt9) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  			{  				DebugLocation (64' 4);  				DebugLocation (64' 6);  				PushFollow (Follow._comparator_in_filterExpr175);  				comparator6 = comparator ();  				PopFollow ();  				Match (input' TokenTypes.Down' null);  				DebugLocation (64' 18);  				PushFollow (Follow._filterExpr_in_filterExpr179);  				a = filterExpr ();  				PopFollow ();  				DebugLocation (64' 31);  				PushFollow (Follow._filterExpr_in_filterExpr183);  				b = filterExpr ();  				PopFollow ();  				Match (input' TokenTypes.Up' null);  				DebugLocation (65' 4);  				Comparator newComparator;  				switch (comparator6) {  				case "=":  					newComparator = Comparator.Equals;  					break;  				case "!=":  					newComparator = Comparator.NotEquals;  					break;  				case ">":  					newComparator = Comparator.Greater;  					break;  				case "<":  					newComparator = Comparator.Less;  					break;  				case ">=":  					newComparator = Comparator.GreaterOrEqual;  					break;  				case "<=":  					newComparator = Comparator.LessOrEqual;  					break;  				case "&":  					newComparator = Comparator.And;  					break;  				case "|":  					newComparator = Comparator.Or;  					break;  				default:  					newComparator = Comparator.Equals;  					break;  				}  				filterNode = new BoolExpression (a' newComparator' b);  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  			{  				DebugLocation (98' 4);  				DebugLocation (98' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr195);  				Match (input' TokenTypes.Down' null);  				DebugLocation (98' 12);  				PushFollow (Follow._filterExpr_in_filterExpr199);  				f = filterExpr ();  				PopFollow ();  				DebugLocation (98' 31);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  				int alt6 = 2;  				try {  					DebugEnterSubRule (6);  					try {  						DebugEnterDecision (6' false);  						int LA6_1 = input.LA (1);  						if ((LA6_1 == 24)) {  							alt6 = 1;  						}  					}  					finally {  						DebugExitDecision (6);  					}  					switch (alt6) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  						{  							DebugLocation (98' 31);  							inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (6);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (99' 4);  				FilterTreeNode newNode = f;  				if ((inverse != null ? inverse.Text : default(string)) == "!")  					newNode.ToggleInversed ();  				filterNode = newNode;  			}  			break;  		case 3:  			DebugEnterAlt (3);  			// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  			{  				DebugLocation (105' 4);  				DebugLocation (105' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr216);  				Match (input' TokenTypes.Down' null);  				DebugLocation (105' 12);  				PushFollow (Follow._propertyChain_in_filterExpr219);  				propertyChain (propertySegments);  				PopFollow ();  				DebugLocation (105' 51);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  				int alt7 = 2;  				try {  					DebugEnterSubRule (7);  					try {  						DebugEnterDecision (7' false);  						int LA7_1 = input.LA (1);  						if ((LA7_1 == 31)) {  							alt7 = 1;  						}  					}  					finally {  						DebugExitDecision (7);  					}  					switch (alt7) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  						{  							DebugLocation (105' 51);  							inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (7);  				}  				DebugLocation (105' 60);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  				int alt8 = 2;  				try {  					DebugEnterSubRule (8);  					try {  						DebugEnterDecision (8' false);  						int LA8_1 = input.LA (1);  						if ((LA8_1 == 24)) {  							alt8 = 1;  						}  					}  					finally {  						DebugExitDecision (8);  					}  					switch (alt8) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  						{  							DebugLocation (105' 60);  							not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (8);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (106' 4);  				FilterTreeNode newProperty = new Property (propertySegments);  				if ((inverse != null ? inverse.Text : default(string)) == "?")  					filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  				else {  					if ((not != null ? not.Text : default(string)) == "!")  						newProperty.ToggleInversed ();  					filterNode = newProperty;  				}  			}  			break;  		case 4:  			DebugEnterAlt (4);  			// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  			{  				DebugLocation (116' 4);  				STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  				DebugLocation (117' 4);  				string stringText = (STRING7 != null ? STRING7.Text : default(string));  				stringText = stringText.Substring (1' stringText.Length - 2);  				filterNode = new Value (stringText);  			}  			break;  		case 5:  			DebugEnterAlt (5);  			// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  			{  				DebugLocation (122' 4);  				REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  				DebugLocation (123' 4);  				string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  				regexText = regexText.Substring (1' regexText.Length - 2);  				filterNode = new RegExp (regexText);  			}  			break;  		case 6:  			DebugEnterAlt (6);  			// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  			{  				DebugLocation (128' 4);  				NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  				DebugLocation (129' 4);  				filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  			}  			break;  		case 7:  			DebugEnterAlt (7);  			// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  			{  				DebugLocation (132' 4);  				Match (input' TRUE' Follow._TRUE_in_filterExpr271);  				DebugLocation (133' 4);  				filterNode = new Value (true);  			}  			break;  		case 8:  			DebugEnterAlt (8);  			// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  			{  				DebugLocation (136' 4);  				Match (input' FALSE' Follow._FALSE_in_filterExpr281);  				DebugLocation (137' 4);  				filterNode = new Value (false);  			}  			break;  		case 9:  			DebugEnterAlt (9);  			// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  			{  				DebugLocation (140' 4);  				Match (input' NULL' Follow._NULL_in_filterExpr291);  				DebugLocation (141' 4);  				filterNode = new Value (null);  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("filterExpr"' 6);  		LeaveRule ("filterExpr"' 6);  		LeaveRule_filterExpr ();  	}  	DebugLocation (144' 1);  }  finally {  	DebugExitRule (GrammarFileName' "filterExpr");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "filterExpr");  	DebugLocation (60' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  		int alt9 = 9;  		try {  			DebugEnterDecision (9' false);  			switch (input.LA (1)) {  			case CHAIN_OPERATOR:  			case COMPARATOR:  				{  					alt9 = 1;  				}  				break;  			case EXPR:  				{  					int LA9_2 = input.LA (2);  					if ((LA9_2 == DOWN)) {  						int LA9_3 = input.LA (3);  						if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  							alt9 = 2;  						}  						else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  							alt9 = 3;  						}  						else {  							NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  							DebugRecognitionException (nvae);  							throw nvae;  						}  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				break;  			case STRING:  				{  					alt9 = 4;  				}  				break;  			case REGEX:  				{  					alt9 = 5;  				}  				break;  			case NUMBER:  				{  					alt9 = 6;  				}  				break;  			case TRUE:  				{  					alt9 = 7;  				}  				break;  			case FALSE:  				{  					alt9 = 8;  				}  				break;  			case NULL:  				{  					alt9 = 9;  				}  				break;  			default: {  				NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  			}  		}  		finally {  			DebugExitDecision (9);  		}  		switch (alt9) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  			{  				DebugLocation (64' 4);  				DebugLocation (64' 6);  				PushFollow (Follow._comparator_in_filterExpr175);  				comparator6 = comparator ();  				PopFollow ();  				Match (input' TokenTypes.Down' null);  				DebugLocation (64' 18);  				PushFollow (Follow._filterExpr_in_filterExpr179);  				a = filterExpr ();  				PopFollow ();  				DebugLocation (64' 31);  				PushFollow (Follow._filterExpr_in_filterExpr183);  				b = filterExpr ();  				PopFollow ();  				Match (input' TokenTypes.Up' null);  				DebugLocation (65' 4);  				Comparator newComparator;  				switch (comparator6) {  				case "=":  					newComparator = Comparator.Equals;  					break;  				case "!=":  					newComparator = Comparator.NotEquals;  					break;  				case ">":  					newComparator = Comparator.Greater;  					break;  				case "<":  					newComparator = Comparator.Less;  					break;  				case ">=":  					newComparator = Comparator.GreaterOrEqual;  					break;  				case "<=":  					newComparator = Comparator.LessOrEqual;  					break;  				case "&":  					newComparator = Comparator.And;  					break;  				case "|":  					newComparator = Comparator.Or;  					break;  				default:  					newComparator = Comparator.Equals;  					break;  				}  				filterNode = new BoolExpression (a' newComparator' b);  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  			{  				DebugLocation (98' 4);  				DebugLocation (98' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr195);  				Match (input' TokenTypes.Down' null);  				DebugLocation (98' 12);  				PushFollow (Follow._filterExpr_in_filterExpr199);  				f = filterExpr ();  				PopFollow ();  				DebugLocation (98' 31);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  				int alt6 = 2;  				try {  					DebugEnterSubRule (6);  					try {  						DebugEnterDecision (6' false);  						int LA6_1 = input.LA (1);  						if ((LA6_1 == 24)) {  							alt6 = 1;  						}  					}  					finally {  						DebugExitDecision (6);  					}  					switch (alt6) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  						{  							DebugLocation (98' 31);  							inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (6);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (99' 4);  				FilterTreeNode newNode = f;  				if ((inverse != null ? inverse.Text : default(string)) == "!")  					newNode.ToggleInversed ();  				filterNode = newNode;  			}  			break;  		case 3:  			DebugEnterAlt (3);  			// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  			{  				DebugLocation (105' 4);  				DebugLocation (105' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr216);  				Match (input' TokenTypes.Down' null);  				DebugLocation (105' 12);  				PushFollow (Follow._propertyChain_in_filterExpr219);  				propertyChain (propertySegments);  				PopFollow ();  				DebugLocation (105' 51);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  				int alt7 = 2;  				try {  					DebugEnterSubRule (7);  					try {  						DebugEnterDecision (7' false);  						int LA7_1 = input.LA (1);  						if ((LA7_1 == 31)) {  							alt7 = 1;  						}  					}  					finally {  						DebugExitDecision (7);  					}  					switch (alt7) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  						{  							DebugLocation (105' 51);  							inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (7);  				}  				DebugLocation (105' 60);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  				int alt8 = 2;  				try {  					DebugEnterSubRule (8);  					try {  						DebugEnterDecision (8' false);  						int LA8_1 = input.LA (1);  						if ((LA8_1 == 24)) {  							alt8 = 1;  						}  					}  					finally {  						DebugExitDecision (8);  					}  					switch (alt8) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  						{  							DebugLocation (105' 60);  							not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (8);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (106' 4);  				FilterTreeNode newProperty = new Property (propertySegments);  				if ((inverse != null ? inverse.Text : default(string)) == "?")  					filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  				else {  					if ((not != null ? not.Text : default(string)) == "!")  						newProperty.ToggleInversed ();  					filterNode = newProperty;  				}  			}  			break;  		case 4:  			DebugEnterAlt (4);  			// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  			{  				DebugLocation (116' 4);  				STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  				DebugLocation (117' 4);  				string stringText = (STRING7 != null ? STRING7.Text : default(string));  				stringText = stringText.Substring (1' stringText.Length - 2);  				filterNode = new Value (stringText);  			}  			break;  		case 5:  			DebugEnterAlt (5);  			// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  			{  				DebugLocation (122' 4);  				REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  				DebugLocation (123' 4);  				string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  				regexText = regexText.Substring (1' regexText.Length - 2);  				filterNode = new RegExp (regexText);  			}  			break;  		case 6:  			DebugEnterAlt (6);  			// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  			{  				DebugLocation (128' 4);  				NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  				DebugLocation (129' 4);  				filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  			}  			break;  		case 7:  			DebugEnterAlt (7);  			// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  			{  				DebugLocation (132' 4);  				Match (input' TRUE' Follow._TRUE_in_filterExpr271);  				DebugLocation (133' 4);  				filterNode = new Value (true);  			}  			break;  		case 8:  			DebugEnterAlt (8);  			// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  			{  				DebugLocation (136' 4);  				Match (input' FALSE' Follow._FALSE_in_filterExpr281);  				DebugLocation (137' 4);  				filterNode = new Value (false);  			}  			break;  		case 9:  			DebugEnterAlt (9);  			// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  			{  				DebugLocation (140' 4);  				Match (input' NULL' Follow._NULL_in_filterExpr291);  				DebugLocation (141' 4);  				filterNode = new Value (null);  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("filterExpr"' 6);  		LeaveRule ("filterExpr"' 6);  		LeaveRule_filterExpr ();  	}  	DebugLocation (144' 1);  }  finally {  	DebugExitRule (GrammarFileName' "filterExpr");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "filterExpr");  	DebugLocation (60' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  		int alt9 = 9;  		try {  			DebugEnterDecision (9' false);  			switch (input.LA (1)) {  			case CHAIN_OPERATOR:  			case COMPARATOR:  				{  					alt9 = 1;  				}  				break;  			case EXPR:  				{  					int LA9_2 = input.LA (2);  					if ((LA9_2 == DOWN)) {  						int LA9_3 = input.LA (3);  						if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  							alt9 = 2;  						}  						else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  							alt9 = 3;  						}  						else {  							NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  							DebugRecognitionException (nvae);  							throw nvae;  						}  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				break;  			case STRING:  				{  					alt9 = 4;  				}  				break;  			case REGEX:  				{  					alt9 = 5;  				}  				break;  			case NUMBER:  				{  					alt9 = 6;  				}  				break;  			case TRUE:  				{  					alt9 = 7;  				}  				break;  			case FALSE:  				{  					alt9 = 8;  				}  				break;  			case NULL:  				{  					alt9 = 9;  				}  				break;  			default: {  				NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  			}  		}  		finally {  			DebugExitDecision (9);  		}  		switch (alt9) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  			{  				DebugLocation (64' 4);  				DebugLocation (64' 6);  				PushFollow (Follow._comparator_in_filterExpr175);  				comparator6 = comparator ();  				PopFollow ();  				Match (input' TokenTypes.Down' null);  				DebugLocation (64' 18);  				PushFollow (Follow._filterExpr_in_filterExpr179);  				a = filterExpr ();  				PopFollow ();  				DebugLocation (64' 31);  				PushFollow (Follow._filterExpr_in_filterExpr183);  				b = filterExpr ();  				PopFollow ();  				Match (input' TokenTypes.Up' null);  				DebugLocation (65' 4);  				Comparator newComparator;  				switch (comparator6) {  				case "=":  					newComparator = Comparator.Equals;  					break;  				case "!=":  					newComparator = Comparator.NotEquals;  					break;  				case ">":  					newComparator = Comparator.Greater;  					break;  				case "<":  					newComparator = Comparator.Less;  					break;  				case ">=":  					newComparator = Comparator.GreaterOrEqual;  					break;  				case "<=":  					newComparator = Comparator.LessOrEqual;  					break;  				case "&":  					newComparator = Comparator.And;  					break;  				case "|":  					newComparator = Comparator.Or;  					break;  				default:  					newComparator = Comparator.Equals;  					break;  				}  				filterNode = new BoolExpression (a' newComparator' b);  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  			{  				DebugLocation (98' 4);  				DebugLocation (98' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr195);  				Match (input' TokenTypes.Down' null);  				DebugLocation (98' 12);  				PushFollow (Follow._filterExpr_in_filterExpr199);  				f = filterExpr ();  				PopFollow ();  				DebugLocation (98' 31);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  				int alt6 = 2;  				try {  					DebugEnterSubRule (6);  					try {  						DebugEnterDecision (6' false);  						int LA6_1 = input.LA (1);  						if ((LA6_1 == 24)) {  							alt6 = 1;  						}  					}  					finally {  						DebugExitDecision (6);  					}  					switch (alt6) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  						{  							DebugLocation (98' 31);  							inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (6);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (99' 4);  				FilterTreeNode newNode = f;  				if ((inverse != null ? inverse.Text : default(string)) == "!")  					newNode.ToggleInversed ();  				filterNode = newNode;  			}  			break;  		case 3:  			DebugEnterAlt (3);  			// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  			{  				DebugLocation (105' 4);  				DebugLocation (105' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr216);  				Match (input' TokenTypes.Down' null);  				DebugLocation (105' 12);  				PushFollow (Follow._propertyChain_in_filterExpr219);  				propertyChain (propertySegments);  				PopFollow ();  				DebugLocation (105' 51);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  				int alt7 = 2;  				try {  					DebugEnterSubRule (7);  					try {  						DebugEnterDecision (7' false);  						int LA7_1 = input.LA (1);  						if ((LA7_1 == 31)) {  							alt7 = 1;  						}  					}  					finally {  						DebugExitDecision (7);  					}  					switch (alt7) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  						{  							DebugLocation (105' 51);  							inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (7);  				}  				DebugLocation (105' 60);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  				int alt8 = 2;  				try {  					DebugEnterSubRule (8);  					try {  						DebugEnterDecision (8' false);  						int LA8_1 = input.LA (1);  						if ((LA8_1 == 24)) {  							alt8 = 1;  						}  					}  					finally {  						DebugExitDecision (8);  					}  					switch (alt8) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  						{  							DebugLocation (105' 60);  							not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (8);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (106' 4);  				FilterTreeNode newProperty = new Property (propertySegments);  				if ((inverse != null ? inverse.Text : default(string)) == "?")  					filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  				else {  					if ((not != null ? not.Text : default(string)) == "!")  						newProperty.ToggleInversed ();  					filterNode = newProperty;  				}  			}  			break;  		case 4:  			DebugEnterAlt (4);  			// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  			{  				DebugLocation (116' 4);  				STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  				DebugLocation (117' 4);  				string stringText = (STRING7 != null ? STRING7.Text : default(string));  				stringText = stringText.Substring (1' stringText.Length - 2);  				filterNode = new Value (stringText);  			}  			break;  		case 5:  			DebugEnterAlt (5);  			// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  			{  				DebugLocation (122' 4);  				REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  				DebugLocation (123' 4);  				string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  				regexText = regexText.Substring (1' regexText.Length - 2);  				filterNode = new RegExp (regexText);  			}  			break;  		case 6:  			DebugEnterAlt (6);  			// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  			{  				DebugLocation (128' 4);  				NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  				DebugLocation (129' 4);  				filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  			}  			break;  		case 7:  			DebugEnterAlt (7);  			// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  			{  				DebugLocation (132' 4);  				Match (input' TRUE' Follow._TRUE_in_filterExpr271);  				DebugLocation (133' 4);  				filterNode = new Value (true);  			}  			break;  		case 8:  			DebugEnterAlt (8);  			// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  			{  				DebugLocation (136' 4);  				Match (input' FALSE' Follow._FALSE_in_filterExpr281);  				DebugLocation (137' 4);  				filterNode = new Value (false);  			}  			break;  		case 9:  			DebugEnterAlt (9);  			// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  			{  				DebugLocation (140' 4);  				Match (input' NULL' Follow._NULL_in_filterExpr291);  				DebugLocation (141' 4);  				filterNode = new Value (null);  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("filterExpr"' 6);  		LeaveRule ("filterExpr"' 6);  		LeaveRule_filterExpr ();  	}  	DebugLocation (144' 1);  }  finally {  	DebugExitRule (GrammarFileName' "filterExpr");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "filterExpr");  	DebugLocation (60' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  		int alt9 = 9;  		try {  			DebugEnterDecision (9' false);  			switch (input.LA (1)) {  			case CHAIN_OPERATOR:  			case COMPARATOR:  				{  					alt9 = 1;  				}  				break;  			case EXPR:  				{  					int LA9_2 = input.LA (2);  					if ((LA9_2 == DOWN)) {  						int LA9_3 = input.LA (3);  						if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  							alt9 = 2;  						}  						else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  							alt9 = 3;  						}  						else {  							NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  							DebugRecognitionException (nvae);  							throw nvae;  						}  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				break;  			case STRING:  				{  					alt9 = 4;  				}  				break;  			case REGEX:  				{  					alt9 = 5;  				}  				break;  			case NUMBER:  				{  					alt9 = 6;  				}  				break;  			case TRUE:  				{  					alt9 = 7;  				}  				break;  			case FALSE:  				{  					alt9 = 8;  				}  				break;  			case NULL:  				{  					alt9 = 9;  				}  				break;  			default: {  				NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  			}  		}  		finally {  			DebugExitDecision (9);  		}  		switch (alt9) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  			{  				DebugLocation (64' 4);  				DebugLocation (64' 6);  				PushFollow (Follow._comparator_in_filterExpr175);  				comparator6 = comparator ();  				PopFollow ();  				Match (input' TokenTypes.Down' null);  				DebugLocation (64' 18);  				PushFollow (Follow._filterExpr_in_filterExpr179);  				a = filterExpr ();  				PopFollow ();  				DebugLocation (64' 31);  				PushFollow (Follow._filterExpr_in_filterExpr183);  				b = filterExpr ();  				PopFollow ();  				Match (input' TokenTypes.Up' null);  				DebugLocation (65' 4);  				Comparator newComparator;  				switch (comparator6) {  				case "=":  					newComparator = Comparator.Equals;  					break;  				case "!=":  					newComparator = Comparator.NotEquals;  					break;  				case ">":  					newComparator = Comparator.Greater;  					break;  				case "<":  					newComparator = Comparator.Less;  					break;  				case ">=":  					newComparator = Comparator.GreaterOrEqual;  					break;  				case "<=":  					newComparator = Comparator.LessOrEqual;  					break;  				case "&":  					newComparator = Comparator.And;  					break;  				case "|":  					newComparator = Comparator.Or;  					break;  				default:  					newComparator = Comparator.Equals;  					break;  				}  				filterNode = new BoolExpression (a' newComparator' b);  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  			{  				DebugLocation (98' 4);  				DebugLocation (98' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr195);  				Match (input' TokenTypes.Down' null);  				DebugLocation (98' 12);  				PushFollow (Follow._filterExpr_in_filterExpr199);  				f = filterExpr ();  				PopFollow ();  				DebugLocation (98' 31);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  				int alt6 = 2;  				try {  					DebugEnterSubRule (6);  					try {  						DebugEnterDecision (6' false);  						int LA6_1 = input.LA (1);  						if ((LA6_1 == 24)) {  							alt6 = 1;  						}  					}  					finally {  						DebugExitDecision (6);  					}  					switch (alt6) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  						{  							DebugLocation (98' 31);  							inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (6);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (99' 4);  				FilterTreeNode newNode = f;  				if ((inverse != null ? inverse.Text : default(string)) == "!")  					newNode.ToggleInversed ();  				filterNode = newNode;  			}  			break;  		case 3:  			DebugEnterAlt (3);  			// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  			{  				DebugLocation (105' 4);  				DebugLocation (105' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr216);  				Match (input' TokenTypes.Down' null);  				DebugLocation (105' 12);  				PushFollow (Follow._propertyChain_in_filterExpr219);  				propertyChain (propertySegments);  				PopFollow ();  				DebugLocation (105' 51);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  				int alt7 = 2;  				try {  					DebugEnterSubRule (7);  					try {  						DebugEnterDecision (7' false);  						int LA7_1 = input.LA (1);  						if ((LA7_1 == 31)) {  							alt7 = 1;  						}  					}  					finally {  						DebugExitDecision (7);  					}  					switch (alt7) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  						{  							DebugLocation (105' 51);  							inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (7);  				}  				DebugLocation (105' 60);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  				int alt8 = 2;  				try {  					DebugEnterSubRule (8);  					try {  						DebugEnterDecision (8' false);  						int LA8_1 = input.LA (1);  						if ((LA8_1 == 24)) {  							alt8 = 1;  						}  					}  					finally {  						DebugExitDecision (8);  					}  					switch (alt8) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  						{  							DebugLocation (105' 60);  							not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (8);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (106' 4);  				FilterTreeNode newProperty = new Property (propertySegments);  				if ((inverse != null ? inverse.Text : default(string)) == "?")  					filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  				else {  					if ((not != null ? not.Text : default(string)) == "!")  						newProperty.ToggleInversed ();  					filterNode = newProperty;  				}  			}  			break;  		case 4:  			DebugEnterAlt (4);  			// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  			{  				DebugLocation (116' 4);  				STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  				DebugLocation (117' 4);  				string stringText = (STRING7 != null ? STRING7.Text : default(string));  				stringText = stringText.Substring (1' stringText.Length - 2);  				filterNode = new Value (stringText);  			}  			break;  		case 5:  			DebugEnterAlt (5);  			// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  			{  				DebugLocation (122' 4);  				REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  				DebugLocation (123' 4);  				string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  				regexText = regexText.Substring (1' regexText.Length - 2);  				filterNode = new RegExp (regexText);  			}  			break;  		case 6:  			DebugEnterAlt (6);  			// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  			{  				DebugLocation (128' 4);  				NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  				DebugLocation (129' 4);  				filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  			}  			break;  		case 7:  			DebugEnterAlt (7);  			// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  			{  				DebugLocation (132' 4);  				Match (input' TRUE' Follow._TRUE_in_filterExpr271);  				DebugLocation (133' 4);  				filterNode = new Value (true);  			}  			break;  		case 8:  			DebugEnterAlt (8);  			// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  			{  				DebugLocation (136' 4);  				Match (input' FALSE' Follow._FALSE_in_filterExpr281);  				DebugLocation (137' 4);  				filterNode = new Value (false);  			}  			break;  		case 9:  			DebugEnterAlt (9);  			// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  			{  				DebugLocation (140' 4);  				Match (input' NULL' Follow._NULL_in_filterExpr291);  				DebugLocation (141' 4);  				filterNode = new Value (null);  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("filterExpr"' 6);  		LeaveRule ("filterExpr"' 6);  		LeaveRule_filterExpr ();  	}  	DebugLocation (144' 1);  }  finally {  	DebugExitRule (GrammarFileName' "filterExpr");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "filterExpr");  	DebugLocation (60' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  		int alt9 = 9;  		try {  			DebugEnterDecision (9' false);  			switch (input.LA (1)) {  			case CHAIN_OPERATOR:  			case COMPARATOR:  				{  					alt9 = 1;  				}  				break;  			case EXPR:  				{  					int LA9_2 = input.LA (2);  					if ((LA9_2 == DOWN)) {  						int LA9_3 = input.LA (3);  						if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  							alt9 = 2;  						}  						else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  							alt9 = 3;  						}  						else {  							NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  							DebugRecognitionException (nvae);  							throw nvae;  						}  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				break;  			case STRING:  				{  					alt9 = 4;  				}  				break;  			case REGEX:  				{  					alt9 = 5;  				}  				break;  			case NUMBER:  				{  					alt9 = 6;  				}  				break;  			case TRUE:  				{  					alt9 = 7;  				}  				break;  			case FALSE:  				{  					alt9 = 8;  				}  				break;  			case NULL:  				{  					alt9 = 9;  				}  				break;  			default: {  				NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  			}  		}  		finally {  			DebugExitDecision (9);  		}  		switch (alt9) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  			{  				DebugLocation (64' 4);  				DebugLocation (64' 6);  				PushFollow (Follow._comparator_in_filterExpr175);  				comparator6 = comparator ();  				PopFollow ();  				Match (input' TokenTypes.Down' null);  				DebugLocation (64' 18);  				PushFollow (Follow._filterExpr_in_filterExpr179);  				a = filterExpr ();  				PopFollow ();  				DebugLocation (64' 31);  				PushFollow (Follow._filterExpr_in_filterExpr183);  				b = filterExpr ();  				PopFollow ();  				Match (input' TokenTypes.Up' null);  				DebugLocation (65' 4);  				Comparator newComparator;  				switch (comparator6) {  				case "=":  					newComparator = Comparator.Equals;  					break;  				case "!=":  					newComparator = Comparator.NotEquals;  					break;  				case ">":  					newComparator = Comparator.Greater;  					break;  				case "<":  					newComparator = Comparator.Less;  					break;  				case ">=":  					newComparator = Comparator.GreaterOrEqual;  					break;  				case "<=":  					newComparator = Comparator.LessOrEqual;  					break;  				case "&":  					newComparator = Comparator.And;  					break;  				case "|":  					newComparator = Comparator.Or;  					break;  				default:  					newComparator = Comparator.Equals;  					break;  				}  				filterNode = new BoolExpression (a' newComparator' b);  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  			{  				DebugLocation (98' 4);  				DebugLocation (98' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr195);  				Match (input' TokenTypes.Down' null);  				DebugLocation (98' 12);  				PushFollow (Follow._filterExpr_in_filterExpr199);  				f = filterExpr ();  				PopFollow ();  				DebugLocation (98' 31);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  				int alt6 = 2;  				try {  					DebugEnterSubRule (6);  					try {  						DebugEnterDecision (6' false);  						int LA6_1 = input.LA (1);  						if ((LA6_1 == 24)) {  							alt6 = 1;  						}  					}  					finally {  						DebugExitDecision (6);  					}  					switch (alt6) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  						{  							DebugLocation (98' 31);  							inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (6);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (99' 4);  				FilterTreeNode newNode = f;  				if ((inverse != null ? inverse.Text : default(string)) == "!")  					newNode.ToggleInversed ();  				filterNode = newNode;  			}  			break;  		case 3:  			DebugEnterAlt (3);  			// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  			{  				DebugLocation (105' 4);  				DebugLocation (105' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr216);  				Match (input' TokenTypes.Down' null);  				DebugLocation (105' 12);  				PushFollow (Follow._propertyChain_in_filterExpr219);  				propertyChain (propertySegments);  				PopFollow ();  				DebugLocation (105' 51);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  				int alt7 = 2;  				try {  					DebugEnterSubRule (7);  					try {  						DebugEnterDecision (7' false);  						int LA7_1 = input.LA (1);  						if ((LA7_1 == 31)) {  							alt7 = 1;  						}  					}  					finally {  						DebugExitDecision (7);  					}  					switch (alt7) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  						{  							DebugLocation (105' 51);  							inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (7);  				}  				DebugLocation (105' 60);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  				int alt8 = 2;  				try {  					DebugEnterSubRule (8);  					try {  						DebugEnterDecision (8' false);  						int LA8_1 = input.LA (1);  						if ((LA8_1 == 24)) {  							alt8 = 1;  						}  					}  					finally {  						DebugExitDecision (8);  					}  					switch (alt8) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  						{  							DebugLocation (105' 60);  							not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (8);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (106' 4);  				FilterTreeNode newProperty = new Property (propertySegments);  				if ((inverse != null ? inverse.Text : default(string)) == "?")  					filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  				else {  					if ((not != null ? not.Text : default(string)) == "!")  						newProperty.ToggleInversed ();  					filterNode = newProperty;  				}  			}  			break;  		case 4:  			DebugEnterAlt (4);  			// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  			{  				DebugLocation (116' 4);  				STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  				DebugLocation (117' 4);  				string stringText = (STRING7 != null ? STRING7.Text : default(string));  				stringText = stringText.Substring (1' stringText.Length - 2);  				filterNode = new Value (stringText);  			}  			break;  		case 5:  			DebugEnterAlt (5);  			// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  			{  				DebugLocation (122' 4);  				REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  				DebugLocation (123' 4);  				string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  				regexText = regexText.Substring (1' regexText.Length - 2);  				filterNode = new RegExp (regexText);  			}  			break;  		case 6:  			DebugEnterAlt (6);  			// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  			{  				DebugLocation (128' 4);  				NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  				DebugLocation (129' 4);  				filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  			}  			break;  		case 7:  			DebugEnterAlt (7);  			// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  			{  				DebugLocation (132' 4);  				Match (input' TRUE' Follow._TRUE_in_filterExpr271);  				DebugLocation (133' 4);  				filterNode = new Value (true);  			}  			break;  		case 8:  			DebugEnterAlt (8);  			// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  			{  				DebugLocation (136' 4);  				Match (input' FALSE' Follow._FALSE_in_filterExpr281);  				DebugLocation (137' 4);  				filterNode = new Value (false);  			}  			break;  		case 9:  			DebugEnterAlt (9);  			// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  			{  				DebugLocation (140' 4);  				Match (input' NULL' Follow._NULL_in_filterExpr291);  				DebugLocation (141' 4);  				filterNode = new Value (null);  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("filterExpr"' 6);  		LeaveRule ("filterExpr"' 6);  		LeaveRule_filterExpr ();  	}  	DebugLocation (144' 1);  }  finally {  	DebugExitRule (GrammarFileName' "filterExpr");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "filterExpr");  	DebugLocation (60' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  		int alt9 = 9;  		try {  			DebugEnterDecision (9' false);  			switch (input.LA (1)) {  			case CHAIN_OPERATOR:  			case COMPARATOR:  				{  					alt9 = 1;  				}  				break;  			case EXPR:  				{  					int LA9_2 = input.LA (2);  					if ((LA9_2 == DOWN)) {  						int LA9_3 = input.LA (3);  						if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  							alt9 = 2;  						}  						else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  							alt9 = 3;  						}  						else {  							NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  							DebugRecognitionException (nvae);  							throw nvae;  						}  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				break;  			case STRING:  				{  					alt9 = 4;  				}  				break;  			case REGEX:  				{  					alt9 = 5;  				}  				break;  			case NUMBER:  				{  					alt9 = 6;  				}  				break;  			case TRUE:  				{  					alt9 = 7;  				}  				break;  			case FALSE:  				{  					alt9 = 8;  				}  				break;  			case NULL:  				{  					alt9 = 9;  				}  				break;  			default: {  				NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  			}  		}  		finally {  			DebugExitDecision (9);  		}  		switch (alt9) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  			{  				DebugLocation (64' 4);  				DebugLocation (64' 6);  				PushFollow (Follow._comparator_in_filterExpr175);  				comparator6 = comparator ();  				PopFollow ();  				Match (input' TokenTypes.Down' null);  				DebugLocation (64' 18);  				PushFollow (Follow._filterExpr_in_filterExpr179);  				a = filterExpr ();  				PopFollow ();  				DebugLocation (64' 31);  				PushFollow (Follow._filterExpr_in_filterExpr183);  				b = filterExpr ();  				PopFollow ();  				Match (input' TokenTypes.Up' null);  				DebugLocation (65' 4);  				Comparator newComparator;  				switch (comparator6) {  				case "=":  					newComparator = Comparator.Equals;  					break;  				case "!=":  					newComparator = Comparator.NotEquals;  					break;  				case ">":  					newComparator = Comparator.Greater;  					break;  				case "<":  					newComparator = Comparator.Less;  					break;  				case ">=":  					newComparator = Comparator.GreaterOrEqual;  					break;  				case "<=":  					newComparator = Comparator.LessOrEqual;  					break;  				case "&":  					newComparator = Comparator.And;  					break;  				case "|":  					newComparator = Comparator.Or;  					break;  				default:  					newComparator = Comparator.Equals;  					break;  				}  				filterNode = new BoolExpression (a' newComparator' b);  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  			{  				DebugLocation (98' 4);  				DebugLocation (98' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr195);  				Match (input' TokenTypes.Down' null);  				DebugLocation (98' 12);  				PushFollow (Follow._filterExpr_in_filterExpr199);  				f = filterExpr ();  				PopFollow ();  				DebugLocation (98' 31);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  				int alt6 = 2;  				try {  					DebugEnterSubRule (6);  					try {  						DebugEnterDecision (6' false);  						int LA6_1 = input.LA (1);  						if ((LA6_1 == 24)) {  							alt6 = 1;  						}  					}  					finally {  						DebugExitDecision (6);  					}  					switch (alt6) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  						{  							DebugLocation (98' 31);  							inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (6);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (99' 4);  				FilterTreeNode newNode = f;  				if ((inverse != null ? inverse.Text : default(string)) == "!")  					newNode.ToggleInversed ();  				filterNode = newNode;  			}  			break;  		case 3:  			DebugEnterAlt (3);  			// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  			{  				DebugLocation (105' 4);  				DebugLocation (105' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr216);  				Match (input' TokenTypes.Down' null);  				DebugLocation (105' 12);  				PushFollow (Follow._propertyChain_in_filterExpr219);  				propertyChain (propertySegments);  				PopFollow ();  				DebugLocation (105' 51);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  				int alt7 = 2;  				try {  					DebugEnterSubRule (7);  					try {  						DebugEnterDecision (7' false);  						int LA7_1 = input.LA (1);  						if ((LA7_1 == 31)) {  							alt7 = 1;  						}  					}  					finally {  						DebugExitDecision (7);  					}  					switch (alt7) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  						{  							DebugLocation (105' 51);  							inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (7);  				}  				DebugLocation (105' 60);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  				int alt8 = 2;  				try {  					DebugEnterSubRule (8);  					try {  						DebugEnterDecision (8' false);  						int LA8_1 = input.LA (1);  						if ((LA8_1 == 24)) {  							alt8 = 1;  						}  					}  					finally {  						DebugExitDecision (8);  					}  					switch (alt8) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  						{  							DebugLocation (105' 60);  							not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (8);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (106' 4);  				FilterTreeNode newProperty = new Property (propertySegments);  				if ((inverse != null ? inverse.Text : default(string)) == "?")  					filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  				else {  					if ((not != null ? not.Text : default(string)) == "!")  						newProperty.ToggleInversed ();  					filterNode = newProperty;  				}  			}  			break;  		case 4:  			DebugEnterAlt (4);  			// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  			{  				DebugLocation (116' 4);  				STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  				DebugLocation (117' 4);  				string stringText = (STRING7 != null ? STRING7.Text : default(string));  				stringText = stringText.Substring (1' stringText.Length - 2);  				filterNode = new Value (stringText);  			}  			break;  		case 5:  			DebugEnterAlt (5);  			// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  			{  				DebugLocation (122' 4);  				REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  				DebugLocation (123' 4);  				string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  				regexText = regexText.Substring (1' regexText.Length - 2);  				filterNode = new RegExp (regexText);  			}  			break;  		case 6:  			DebugEnterAlt (6);  			// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  			{  				DebugLocation (128' 4);  				NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  				DebugLocation (129' 4);  				filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  			}  			break;  		case 7:  			DebugEnterAlt (7);  			// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  			{  				DebugLocation (132' 4);  				Match (input' TRUE' Follow._TRUE_in_filterExpr271);  				DebugLocation (133' 4);  				filterNode = new Value (true);  			}  			break;  		case 8:  			DebugEnterAlt (8);  			// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  			{  				DebugLocation (136' 4);  				Match (input' FALSE' Follow._FALSE_in_filterExpr281);  				DebugLocation (137' 4);  				filterNode = new Value (false);  			}  			break;  		case 9:  			DebugEnterAlt (9);  			// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  			{  				DebugLocation (140' 4);  				Match (input' NULL' Follow._NULL_in_filterExpr291);  				DebugLocation (141' 4);  				filterNode = new Value (null);  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("filterExpr"' 6);  		LeaveRule ("filterExpr"' 6);  		LeaveRule_filterExpr ();  	}  	DebugLocation (144' 1);  }  finally {  	DebugExitRule (GrammarFileName' "filterExpr");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "filterExpr");  	DebugLocation (60' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  		int alt9 = 9;  		try {  			DebugEnterDecision (9' false);  			switch (input.LA (1)) {  			case CHAIN_OPERATOR:  			case COMPARATOR:  				{  					alt9 = 1;  				}  				break;  			case EXPR:  				{  					int LA9_2 = input.LA (2);  					if ((LA9_2 == DOWN)) {  						int LA9_3 = input.LA (3);  						if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  							alt9 = 2;  						}  						else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  							alt9 = 3;  						}  						else {  							NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  							DebugRecognitionException (nvae);  							throw nvae;  						}  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				break;  			case STRING:  				{  					alt9 = 4;  				}  				break;  			case REGEX:  				{  					alt9 = 5;  				}  				break;  			case NUMBER:  				{  					alt9 = 6;  				}  				break;  			case TRUE:  				{  					alt9 = 7;  				}  				break;  			case FALSE:  				{  					alt9 = 8;  				}  				break;  			case NULL:  				{  					alt9 = 9;  				}  				break;  			default: {  				NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  			}  		}  		finally {  			DebugExitDecision (9);  		}  		switch (alt9) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  			{  				DebugLocation (64' 4);  				DebugLocation (64' 6);  				PushFollow (Follow._comparator_in_filterExpr175);  				comparator6 = comparator ();  				PopFollow ();  				Match (input' TokenTypes.Down' null);  				DebugLocation (64' 18);  				PushFollow (Follow._filterExpr_in_filterExpr179);  				a = filterExpr ();  				PopFollow ();  				DebugLocation (64' 31);  				PushFollow (Follow._filterExpr_in_filterExpr183);  				b = filterExpr ();  				PopFollow ();  				Match (input' TokenTypes.Up' null);  				DebugLocation (65' 4);  				Comparator newComparator;  				switch (comparator6) {  				case "=":  					newComparator = Comparator.Equals;  					break;  				case "!=":  					newComparator = Comparator.NotEquals;  					break;  				case ">":  					newComparator = Comparator.Greater;  					break;  				case "<":  					newComparator = Comparator.Less;  					break;  				case ">=":  					newComparator = Comparator.GreaterOrEqual;  					break;  				case "<=":  					newComparator = Comparator.LessOrEqual;  					break;  				case "&":  					newComparator = Comparator.And;  					break;  				case "|":  					newComparator = Comparator.Or;  					break;  				default:  					newComparator = Comparator.Equals;  					break;  				}  				filterNode = new BoolExpression (a' newComparator' b);  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  			{  				DebugLocation (98' 4);  				DebugLocation (98' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr195);  				Match (input' TokenTypes.Down' null);  				DebugLocation (98' 12);  				PushFollow (Follow._filterExpr_in_filterExpr199);  				f = filterExpr ();  				PopFollow ();  				DebugLocation (98' 31);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  				int alt6 = 2;  				try {  					DebugEnterSubRule (6);  					try {  						DebugEnterDecision (6' false);  						int LA6_1 = input.LA (1);  						if ((LA6_1 == 24)) {  							alt6 = 1;  						}  					}  					finally {  						DebugExitDecision (6);  					}  					switch (alt6) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  						{  							DebugLocation (98' 31);  							inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (6);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (99' 4);  				FilterTreeNode newNode = f;  				if ((inverse != null ? inverse.Text : default(string)) == "!")  					newNode.ToggleInversed ();  				filterNode = newNode;  			}  			break;  		case 3:  			DebugEnterAlt (3);  			// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  			{  				DebugLocation (105' 4);  				DebugLocation (105' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr216);  				Match (input' TokenTypes.Down' null);  				DebugLocation (105' 12);  				PushFollow (Follow._propertyChain_in_filterExpr219);  				propertyChain (propertySegments);  				PopFollow ();  				DebugLocation (105' 51);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  				int alt7 = 2;  				try {  					DebugEnterSubRule (7);  					try {  						DebugEnterDecision (7' false);  						int LA7_1 = input.LA (1);  						if ((LA7_1 == 31)) {  							alt7 = 1;  						}  					}  					finally {  						DebugExitDecision (7);  					}  					switch (alt7) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  						{  							DebugLocation (105' 51);  							inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (7);  				}  				DebugLocation (105' 60);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  				int alt8 = 2;  				try {  					DebugEnterSubRule (8);  					try {  						DebugEnterDecision (8' false);  						int LA8_1 = input.LA (1);  						if ((LA8_1 == 24)) {  							alt8 = 1;  						}  					}  					finally {  						DebugExitDecision (8);  					}  					switch (alt8) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  						{  							DebugLocation (105' 60);  							not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (8);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (106' 4);  				FilterTreeNode newProperty = new Property (propertySegments);  				if ((inverse != null ? inverse.Text : default(string)) == "?")  					filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  				else {  					if ((not != null ? not.Text : default(string)) == "!")  						newProperty.ToggleInversed ();  					filterNode = newProperty;  				}  			}  			break;  		case 4:  			DebugEnterAlt (4);  			// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  			{  				DebugLocation (116' 4);  				STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  				DebugLocation (117' 4);  				string stringText = (STRING7 != null ? STRING7.Text : default(string));  				stringText = stringText.Substring (1' stringText.Length - 2);  				filterNode = new Value (stringText);  			}  			break;  		case 5:  			DebugEnterAlt (5);  			// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  			{  				DebugLocation (122' 4);  				REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  				DebugLocation (123' 4);  				string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  				regexText = regexText.Substring (1' regexText.Length - 2);  				filterNode = new RegExp (regexText);  			}  			break;  		case 6:  			DebugEnterAlt (6);  			// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  			{  				DebugLocation (128' 4);  				NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  				DebugLocation (129' 4);  				filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  			}  			break;  		case 7:  			DebugEnterAlt (7);  			// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  			{  				DebugLocation (132' 4);  				Match (input' TRUE' Follow._TRUE_in_filterExpr271);  				DebugLocation (133' 4);  				filterNode = new Value (true);  			}  			break;  		case 8:  			DebugEnterAlt (8);  			// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  			{  				DebugLocation (136' 4);  				Match (input' FALSE' Follow._FALSE_in_filterExpr281);  				DebugLocation (137' 4);  				filterNode = new Value (false);  			}  			break;  		case 9:  			DebugEnterAlt (9);  			// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  			{  				DebugLocation (140' 4);  				Match (input' NULL' Follow._NULL_in_filterExpr291);  				DebugLocation (141' 4);  				filterNode = new Value (null);  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("filterExpr"' 6);  		LeaveRule ("filterExpr"' 6);  		LeaveRule_filterExpr ();  	}  	DebugLocation (144' 1);  }  finally {  	DebugExitRule (GrammarFileName' "filterExpr");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "filterExpr");  	DebugLocation (60' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  		int alt9 = 9;  		try {  			DebugEnterDecision (9' false);  			switch (input.LA (1)) {  			case CHAIN_OPERATOR:  			case COMPARATOR:  				{  					alt9 = 1;  				}  				break;  			case EXPR:  				{  					int LA9_2 = input.LA (2);  					if ((LA9_2 == DOWN)) {  						int LA9_3 = input.LA (3);  						if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  							alt9 = 2;  						}  						else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  							alt9 = 3;  						}  						else {  							NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  							DebugRecognitionException (nvae);  							throw nvae;  						}  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				break;  			case STRING:  				{  					alt9 = 4;  				}  				break;  			case REGEX:  				{  					alt9 = 5;  				}  				break;  			case NUMBER:  				{  					alt9 = 6;  				}  				break;  			case TRUE:  				{  					alt9 = 7;  				}  				break;  			case FALSE:  				{  					alt9 = 8;  				}  				break;  			case NULL:  				{  					alt9 = 9;  				}  				break;  			default: {  				NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  			}  		}  		finally {  			DebugExitDecision (9);  		}  		switch (alt9) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  			{  				DebugLocation (64' 4);  				DebugLocation (64' 6);  				PushFollow (Follow._comparator_in_filterExpr175);  				comparator6 = comparator ();  				PopFollow ();  				Match (input' TokenTypes.Down' null);  				DebugLocation (64' 18);  				PushFollow (Follow._filterExpr_in_filterExpr179);  				a = filterExpr ();  				PopFollow ();  				DebugLocation (64' 31);  				PushFollow (Follow._filterExpr_in_filterExpr183);  				b = filterExpr ();  				PopFollow ();  				Match (input' TokenTypes.Up' null);  				DebugLocation (65' 4);  				Comparator newComparator;  				switch (comparator6) {  				case "=":  					newComparator = Comparator.Equals;  					break;  				case "!=":  					newComparator = Comparator.NotEquals;  					break;  				case ">":  					newComparator = Comparator.Greater;  					break;  				case "<":  					newComparator = Comparator.Less;  					break;  				case ">=":  					newComparator = Comparator.GreaterOrEqual;  					break;  				case "<=":  					newComparator = Comparator.LessOrEqual;  					break;  				case "&":  					newComparator = Comparator.And;  					break;  				case "|":  					newComparator = Comparator.Or;  					break;  				default:  					newComparator = Comparator.Equals;  					break;  				}  				filterNode = new BoolExpression (a' newComparator' b);  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  			{  				DebugLocation (98' 4);  				DebugLocation (98' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr195);  				Match (input' TokenTypes.Down' null);  				DebugLocation (98' 12);  				PushFollow (Follow._filterExpr_in_filterExpr199);  				f = filterExpr ();  				PopFollow ();  				DebugLocation (98' 31);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  				int alt6 = 2;  				try {  					DebugEnterSubRule (6);  					try {  						DebugEnterDecision (6' false);  						int LA6_1 = input.LA (1);  						if ((LA6_1 == 24)) {  							alt6 = 1;  						}  					}  					finally {  						DebugExitDecision (6);  					}  					switch (alt6) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  						{  							DebugLocation (98' 31);  							inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (6);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (99' 4);  				FilterTreeNode newNode = f;  				if ((inverse != null ? inverse.Text : default(string)) == "!")  					newNode.ToggleInversed ();  				filterNode = newNode;  			}  			break;  		case 3:  			DebugEnterAlt (3);  			// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  			{  				DebugLocation (105' 4);  				DebugLocation (105' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr216);  				Match (input' TokenTypes.Down' null);  				DebugLocation (105' 12);  				PushFollow (Follow._propertyChain_in_filterExpr219);  				propertyChain (propertySegments);  				PopFollow ();  				DebugLocation (105' 51);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  				int alt7 = 2;  				try {  					DebugEnterSubRule (7);  					try {  						DebugEnterDecision (7' false);  						int LA7_1 = input.LA (1);  						if ((LA7_1 == 31)) {  							alt7 = 1;  						}  					}  					finally {  						DebugExitDecision (7);  					}  					switch (alt7) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  						{  							DebugLocation (105' 51);  							inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (7);  				}  				DebugLocation (105' 60);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  				int alt8 = 2;  				try {  					DebugEnterSubRule (8);  					try {  						DebugEnterDecision (8' false);  						int LA8_1 = input.LA (1);  						if ((LA8_1 == 24)) {  							alt8 = 1;  						}  					}  					finally {  						DebugExitDecision (8);  					}  					switch (alt8) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  						{  							DebugLocation (105' 60);  							not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (8);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (106' 4);  				FilterTreeNode newProperty = new Property (propertySegments);  				if ((inverse != null ? inverse.Text : default(string)) == "?")  					filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  				else {  					if ((not != null ? not.Text : default(string)) == "!")  						newProperty.ToggleInversed ();  					filterNode = newProperty;  				}  			}  			break;  		case 4:  			DebugEnterAlt (4);  			// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  			{  				DebugLocation (116' 4);  				STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  				DebugLocation (117' 4);  				string stringText = (STRING7 != null ? STRING7.Text : default(string));  				stringText = stringText.Substring (1' stringText.Length - 2);  				filterNode = new Value (stringText);  			}  			break;  		case 5:  			DebugEnterAlt (5);  			// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  			{  				DebugLocation (122' 4);  				REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  				DebugLocation (123' 4);  				string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  				regexText = regexText.Substring (1' regexText.Length - 2);  				filterNode = new RegExp (regexText);  			}  			break;  		case 6:  			DebugEnterAlt (6);  			// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  			{  				DebugLocation (128' 4);  				NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  				DebugLocation (129' 4);  				filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  			}  			break;  		case 7:  			DebugEnterAlt (7);  			// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  			{  				DebugLocation (132' 4);  				Match (input' TRUE' Follow._TRUE_in_filterExpr271);  				DebugLocation (133' 4);  				filterNode = new Value (true);  			}  			break;  		case 8:  			DebugEnterAlt (8);  			// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  			{  				DebugLocation (136' 4);  				Match (input' FALSE' Follow._FALSE_in_filterExpr281);  				DebugLocation (137' 4);  				filterNode = new Value (false);  			}  			break;  		case 9:  			DebugEnterAlt (9);  			// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  			{  				DebugLocation (140' 4);  				Match (input' NULL' Follow._NULL_in_filterExpr291);  				DebugLocation (141' 4);  				filterNode = new Value (null);  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("filterExpr"' 6);  		LeaveRule ("filterExpr"' 6);  		LeaveRule_filterExpr ();  	}  	DebugLocation (144' 1);  }  finally {  	DebugExitRule (GrammarFileName' "filterExpr");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "filterExpr");  	DebugLocation (60' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  		int alt9 = 9;  		try {  			DebugEnterDecision (9' false);  			switch (input.LA (1)) {  			case CHAIN_OPERATOR:  			case COMPARATOR:  				{  					alt9 = 1;  				}  				break;  			case EXPR:  				{  					int LA9_2 = input.LA (2);  					if ((LA9_2 == DOWN)) {  						int LA9_3 = input.LA (3);  						if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  							alt9 = 2;  						}  						else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  							alt9 = 3;  						}  						else {  							NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  							DebugRecognitionException (nvae);  							throw nvae;  						}  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				break;  			case STRING:  				{  					alt9 = 4;  				}  				break;  			case REGEX:  				{  					alt9 = 5;  				}  				break;  			case NUMBER:  				{  					alt9 = 6;  				}  				break;  			case TRUE:  				{  					alt9 = 7;  				}  				break;  			case FALSE:  				{  					alt9 = 8;  				}  				break;  			case NULL:  				{  					alt9 = 9;  				}  				break;  			default: {  				NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  			}  		}  		finally {  			DebugExitDecision (9);  		}  		switch (alt9) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  			{  				DebugLocation (64' 4);  				DebugLocation (64' 6);  				PushFollow (Follow._comparator_in_filterExpr175);  				comparator6 = comparator ();  				PopFollow ();  				Match (input' TokenTypes.Down' null);  				DebugLocation (64' 18);  				PushFollow (Follow._filterExpr_in_filterExpr179);  				a = filterExpr ();  				PopFollow ();  				DebugLocation (64' 31);  				PushFollow (Follow._filterExpr_in_filterExpr183);  				b = filterExpr ();  				PopFollow ();  				Match (input' TokenTypes.Up' null);  				DebugLocation (65' 4);  				Comparator newComparator;  				switch (comparator6) {  				case "=":  					newComparator = Comparator.Equals;  					break;  				case "!=":  					newComparator = Comparator.NotEquals;  					break;  				case ">":  					newComparator = Comparator.Greater;  					break;  				case "<":  					newComparator = Comparator.Less;  					break;  				case ">=":  					newComparator = Comparator.GreaterOrEqual;  					break;  				case "<=":  					newComparator = Comparator.LessOrEqual;  					break;  				case "&":  					newComparator = Comparator.And;  					break;  				case "|":  					newComparator = Comparator.Or;  					break;  				default:  					newComparator = Comparator.Equals;  					break;  				}  				filterNode = new BoolExpression (a' newComparator' b);  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  			{  				DebugLocation (98' 4);  				DebugLocation (98' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr195);  				Match (input' TokenTypes.Down' null);  				DebugLocation (98' 12);  				PushFollow (Follow._filterExpr_in_filterExpr199);  				f = filterExpr ();  				PopFollow ();  				DebugLocation (98' 31);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  				int alt6 = 2;  				try {  					DebugEnterSubRule (6);  					try {  						DebugEnterDecision (6' false);  						int LA6_1 = input.LA (1);  						if ((LA6_1 == 24)) {  							alt6 = 1;  						}  					}  					finally {  						DebugExitDecision (6);  					}  					switch (alt6) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  						{  							DebugLocation (98' 31);  							inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (6);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (99' 4);  				FilterTreeNode newNode = f;  				if ((inverse != null ? inverse.Text : default(string)) == "!")  					newNode.ToggleInversed ();  				filterNode = newNode;  			}  			break;  		case 3:  			DebugEnterAlt (3);  			// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  			{  				DebugLocation (105' 4);  				DebugLocation (105' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr216);  				Match (input' TokenTypes.Down' null);  				DebugLocation (105' 12);  				PushFollow (Follow._propertyChain_in_filterExpr219);  				propertyChain (propertySegments);  				PopFollow ();  				DebugLocation (105' 51);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  				int alt7 = 2;  				try {  					DebugEnterSubRule (7);  					try {  						DebugEnterDecision (7' false);  						int LA7_1 = input.LA (1);  						if ((LA7_1 == 31)) {  							alt7 = 1;  						}  					}  					finally {  						DebugExitDecision (7);  					}  					switch (alt7) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  						{  							DebugLocation (105' 51);  							inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (7);  				}  				DebugLocation (105' 60);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  				int alt8 = 2;  				try {  					DebugEnterSubRule (8);  					try {  						DebugEnterDecision (8' false);  						int LA8_1 = input.LA (1);  						if ((LA8_1 == 24)) {  							alt8 = 1;  						}  					}  					finally {  						DebugExitDecision (8);  					}  					switch (alt8) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  						{  							DebugLocation (105' 60);  							not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (8);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (106' 4);  				FilterTreeNode newProperty = new Property (propertySegments);  				if ((inverse != null ? inverse.Text : default(string)) == "?")  					filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  				else {  					if ((not != null ? not.Text : default(string)) == "!")  						newProperty.ToggleInversed ();  					filterNode = newProperty;  				}  			}  			break;  		case 4:  			DebugEnterAlt (4);  			// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  			{  				DebugLocation (116' 4);  				STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  				DebugLocation (117' 4);  				string stringText = (STRING7 != null ? STRING7.Text : default(string));  				stringText = stringText.Substring (1' stringText.Length - 2);  				filterNode = new Value (stringText);  			}  			break;  		case 5:  			DebugEnterAlt (5);  			// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  			{  				DebugLocation (122' 4);  				REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  				DebugLocation (123' 4);  				string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  				regexText = regexText.Substring (1' regexText.Length - 2);  				filterNode = new RegExp (regexText);  			}  			break;  		case 6:  			DebugEnterAlt (6);  			// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  			{  				DebugLocation (128' 4);  				NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  				DebugLocation (129' 4);  				filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  			}  			break;  		case 7:  			DebugEnterAlt (7);  			// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  			{  				DebugLocation (132' 4);  				Match (input' TRUE' Follow._TRUE_in_filterExpr271);  				DebugLocation (133' 4);  				filterNode = new Value (true);  			}  			break;  		case 8:  			DebugEnterAlt (8);  			// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  			{  				DebugLocation (136' 4);  				Match (input' FALSE' Follow._FALSE_in_filterExpr281);  				DebugLocation (137' 4);  				filterNode = new Value (false);  			}  			break;  		case 9:  			DebugEnterAlt (9);  			// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  			{  				DebugLocation (140' 4);  				Match (input' NULL' Follow._NULL_in_filterExpr291);  				DebugLocation (141' 4);  				filterNode = new Value (null);  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("filterExpr"' 6);  		LeaveRule ("filterExpr"' 6);  		LeaveRule_filterExpr ();  	}  	DebugLocation (144' 1);  }  finally {  	DebugExitRule (GrammarFileName' "filterExpr");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "filterExpr");  	DebugLocation (60' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  		int alt9 = 9;  		try {  			DebugEnterDecision (9' false);  			switch (input.LA (1)) {  			case CHAIN_OPERATOR:  			case COMPARATOR:  				{  					alt9 = 1;  				}  				break;  			case EXPR:  				{  					int LA9_2 = input.LA (2);  					if ((LA9_2 == DOWN)) {  						int LA9_3 = input.LA (3);  						if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  							alt9 = 2;  						}  						else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  							alt9 = 3;  						}  						else {  							NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  							DebugRecognitionException (nvae);  							throw nvae;  						}  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				break;  			case STRING:  				{  					alt9 = 4;  				}  				break;  			case REGEX:  				{  					alt9 = 5;  				}  				break;  			case NUMBER:  				{  					alt9 = 6;  				}  				break;  			case TRUE:  				{  					alt9 = 7;  				}  				break;  			case FALSE:  				{  					alt9 = 8;  				}  				break;  			case NULL:  				{  					alt9 = 9;  				}  				break;  			default: {  				NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  			}  		}  		finally {  			DebugExitDecision (9);  		}  		switch (alt9) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  			{  				DebugLocation (64' 4);  				DebugLocation (64' 6);  				PushFollow (Follow._comparator_in_filterExpr175);  				comparator6 = comparator ();  				PopFollow ();  				Match (input' TokenTypes.Down' null);  				DebugLocation (64' 18);  				PushFollow (Follow._filterExpr_in_filterExpr179);  				a = filterExpr ();  				PopFollow ();  				DebugLocation (64' 31);  				PushFollow (Follow._filterExpr_in_filterExpr183);  				b = filterExpr ();  				PopFollow ();  				Match (input' TokenTypes.Up' null);  				DebugLocation (65' 4);  				Comparator newComparator;  				switch (comparator6) {  				case "=":  					newComparator = Comparator.Equals;  					break;  				case "!=":  					newComparator = Comparator.NotEquals;  					break;  				case ">":  					newComparator = Comparator.Greater;  					break;  				case "<":  					newComparator = Comparator.Less;  					break;  				case ">=":  					newComparator = Comparator.GreaterOrEqual;  					break;  				case "<=":  					newComparator = Comparator.LessOrEqual;  					break;  				case "&":  					newComparator = Comparator.And;  					break;  				case "|":  					newComparator = Comparator.Or;  					break;  				default:  					newComparator = Comparator.Equals;  					break;  				}  				filterNode = new BoolExpression (a' newComparator' b);  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  			{  				DebugLocation (98' 4);  				DebugLocation (98' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr195);  				Match (input' TokenTypes.Down' null);  				DebugLocation (98' 12);  				PushFollow (Follow._filterExpr_in_filterExpr199);  				f = filterExpr ();  				PopFollow ();  				DebugLocation (98' 31);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  				int alt6 = 2;  				try {  					DebugEnterSubRule (6);  					try {  						DebugEnterDecision (6' false);  						int LA6_1 = input.LA (1);  						if ((LA6_1 == 24)) {  							alt6 = 1;  						}  					}  					finally {  						DebugExitDecision (6);  					}  					switch (alt6) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  						{  							DebugLocation (98' 31);  							inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (6);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (99' 4);  				FilterTreeNode newNode = f;  				if ((inverse != null ? inverse.Text : default(string)) == "!")  					newNode.ToggleInversed ();  				filterNode = newNode;  			}  			break;  		case 3:  			DebugEnterAlt (3);  			// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  			{  				DebugLocation (105' 4);  				DebugLocation (105' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr216);  				Match (input' TokenTypes.Down' null);  				DebugLocation (105' 12);  				PushFollow (Follow._propertyChain_in_filterExpr219);  				propertyChain (propertySegments);  				PopFollow ();  				DebugLocation (105' 51);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  				int alt7 = 2;  				try {  					DebugEnterSubRule (7);  					try {  						DebugEnterDecision (7' false);  						int LA7_1 = input.LA (1);  						if ((LA7_1 == 31)) {  							alt7 = 1;  						}  					}  					finally {  						DebugExitDecision (7);  					}  					switch (alt7) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  						{  							DebugLocation (105' 51);  							inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (7);  				}  				DebugLocation (105' 60);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  				int alt8 = 2;  				try {  					DebugEnterSubRule (8);  					try {  						DebugEnterDecision (8' false);  						int LA8_1 = input.LA (1);  						if ((LA8_1 == 24)) {  							alt8 = 1;  						}  					}  					finally {  						DebugExitDecision (8);  					}  					switch (alt8) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  						{  							DebugLocation (105' 60);  							not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (8);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (106' 4);  				FilterTreeNode newProperty = new Property (propertySegments);  				if ((inverse != null ? inverse.Text : default(string)) == "?")  					filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  				else {  					if ((not != null ? not.Text : default(string)) == "!")  						newProperty.ToggleInversed ();  					filterNode = newProperty;  				}  			}  			break;  		case 4:  			DebugEnterAlt (4);  			// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  			{  				DebugLocation (116' 4);  				STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  				DebugLocation (117' 4);  				string stringText = (STRING7 != null ? STRING7.Text : default(string));  				stringText = stringText.Substring (1' stringText.Length - 2);  				filterNode = new Value (stringText);  			}  			break;  		case 5:  			DebugEnterAlt (5);  			// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  			{  				DebugLocation (122' 4);  				REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  				DebugLocation (123' 4);  				string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  				regexText = regexText.Substring (1' regexText.Length - 2);  				filterNode = new RegExp (regexText);  			}  			break;  		case 6:  			DebugEnterAlt (6);  			// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  			{  				DebugLocation (128' 4);  				NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  				DebugLocation (129' 4);  				filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  			}  			break;  		case 7:  			DebugEnterAlt (7);  			// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  			{  				DebugLocation (132' 4);  				Match (input' TRUE' Follow._TRUE_in_filterExpr271);  				DebugLocation (133' 4);  				filterNode = new Value (true);  			}  			break;  		case 8:  			DebugEnterAlt (8);  			// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  			{  				DebugLocation (136' 4);  				Match (input' FALSE' Follow._FALSE_in_filterExpr281);  				DebugLocation (137' 4);  				filterNode = new Value (false);  			}  			break;  		case 9:  			DebugEnterAlt (9);  			// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  			{  				DebugLocation (140' 4);  				Match (input' NULL' Follow._NULL_in_filterExpr291);  				DebugLocation (141' 4);  				filterNode = new Value (null);  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("filterExpr"' 6);  		LeaveRule ("filterExpr"' 6);  		LeaveRule_filterExpr ();  	}  	DebugLocation (144' 1);  }  finally {  	DebugExitRule (GrammarFileName' "filterExpr");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "filterExpr");  	DebugLocation (60' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  		int alt9 = 9;  		try {  			DebugEnterDecision (9' false);  			switch (input.LA (1)) {  			case CHAIN_OPERATOR:  			case COMPARATOR:  				{  					alt9 = 1;  				}  				break;  			case EXPR:  				{  					int LA9_2 = input.LA (2);  					if ((LA9_2 == DOWN)) {  						int LA9_3 = input.LA (3);  						if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  							alt9 = 2;  						}  						else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  							alt9 = 3;  						}  						else {  							NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  							DebugRecognitionException (nvae);  							throw nvae;  						}  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				break;  			case STRING:  				{  					alt9 = 4;  				}  				break;  			case REGEX:  				{  					alt9 = 5;  				}  				break;  			case NUMBER:  				{  					alt9 = 6;  				}  				break;  			case TRUE:  				{  					alt9 = 7;  				}  				break;  			case FALSE:  				{  					alt9 = 8;  				}  				break;  			case NULL:  				{  					alt9 = 9;  				}  				break;  			default: {  				NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  			}  		}  		finally {  			DebugExitDecision (9);  		}  		switch (alt9) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  			{  				DebugLocation (64' 4);  				DebugLocation (64' 6);  				PushFollow (Follow._comparator_in_filterExpr175);  				comparator6 = comparator ();  				PopFollow ();  				Match (input' TokenTypes.Down' null);  				DebugLocation (64' 18);  				PushFollow (Follow._filterExpr_in_filterExpr179);  				a = filterExpr ();  				PopFollow ();  				DebugLocation (64' 31);  				PushFollow (Follow._filterExpr_in_filterExpr183);  				b = filterExpr ();  				PopFollow ();  				Match (input' TokenTypes.Up' null);  				DebugLocation (65' 4);  				Comparator newComparator;  				switch (comparator6) {  				case "=":  					newComparator = Comparator.Equals;  					break;  				case "!=":  					newComparator = Comparator.NotEquals;  					break;  				case ">":  					newComparator = Comparator.Greater;  					break;  				case "<":  					newComparator = Comparator.Less;  					break;  				case ">=":  					newComparator = Comparator.GreaterOrEqual;  					break;  				case "<=":  					newComparator = Comparator.LessOrEqual;  					break;  				case "&":  					newComparator = Comparator.And;  					break;  				case "|":  					newComparator = Comparator.Or;  					break;  				default:  					newComparator = Comparator.Equals;  					break;  				}  				filterNode = new BoolExpression (a' newComparator' b);  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  			{  				DebugLocation (98' 4);  				DebugLocation (98' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr195);  				Match (input' TokenTypes.Down' null);  				DebugLocation (98' 12);  				PushFollow (Follow._filterExpr_in_filterExpr199);  				f = filterExpr ();  				PopFollow ();  				DebugLocation (98' 31);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  				int alt6 = 2;  				try {  					DebugEnterSubRule (6);  					try {  						DebugEnterDecision (6' false);  						int LA6_1 = input.LA (1);  						if ((LA6_1 == 24)) {  							alt6 = 1;  						}  					}  					finally {  						DebugExitDecision (6);  					}  					switch (alt6) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  						{  							DebugLocation (98' 31);  							inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (6);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (99' 4);  				FilterTreeNode newNode = f;  				if ((inverse != null ? inverse.Text : default(string)) == "!")  					newNode.ToggleInversed ();  				filterNode = newNode;  			}  			break;  		case 3:  			DebugEnterAlt (3);  			// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  			{  				DebugLocation (105' 4);  				DebugLocation (105' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr216);  				Match (input' TokenTypes.Down' null);  				DebugLocation (105' 12);  				PushFollow (Follow._propertyChain_in_filterExpr219);  				propertyChain (propertySegments);  				PopFollow ();  				DebugLocation (105' 51);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  				int alt7 = 2;  				try {  					DebugEnterSubRule (7);  					try {  						DebugEnterDecision (7' false);  						int LA7_1 = input.LA (1);  						if ((LA7_1 == 31)) {  							alt7 = 1;  						}  					}  					finally {  						DebugExitDecision (7);  					}  					switch (alt7) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  						{  							DebugLocation (105' 51);  							inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (7);  				}  				DebugLocation (105' 60);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  				int alt8 = 2;  				try {  					DebugEnterSubRule (8);  					try {  						DebugEnterDecision (8' false);  						int LA8_1 = input.LA (1);  						if ((LA8_1 == 24)) {  							alt8 = 1;  						}  					}  					finally {  						DebugExitDecision (8);  					}  					switch (alt8) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  						{  							DebugLocation (105' 60);  							not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (8);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (106' 4);  				FilterTreeNode newProperty = new Property (propertySegments);  				if ((inverse != null ? inverse.Text : default(string)) == "?")  					filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  				else {  					if ((not != null ? not.Text : default(string)) == "!")  						newProperty.ToggleInversed ();  					filterNode = newProperty;  				}  			}  			break;  		case 4:  			DebugEnterAlt (4);  			// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  			{  				DebugLocation (116' 4);  				STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  				DebugLocation (117' 4);  				string stringText = (STRING7 != null ? STRING7.Text : default(string));  				stringText = stringText.Substring (1' stringText.Length - 2);  				filterNode = new Value (stringText);  			}  			break;  		case 5:  			DebugEnterAlt (5);  			// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  			{  				DebugLocation (122' 4);  				REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  				DebugLocation (123' 4);  				string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  				regexText = regexText.Substring (1' regexText.Length - 2);  				filterNode = new RegExp (regexText);  			}  			break;  		case 6:  			DebugEnterAlt (6);  			// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  			{  				DebugLocation (128' 4);  				NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  				DebugLocation (129' 4);  				filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  			}  			break;  		case 7:  			DebugEnterAlt (7);  			// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  			{  				DebugLocation (132' 4);  				Match (input' TRUE' Follow._TRUE_in_filterExpr271);  				DebugLocation (133' 4);  				filterNode = new Value (true);  			}  			break;  		case 8:  			DebugEnterAlt (8);  			// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  			{  				DebugLocation (136' 4);  				Match (input' FALSE' Follow._FALSE_in_filterExpr281);  				DebugLocation (137' 4);  				filterNode = new Value (false);  			}  			break;  		case 9:  			DebugEnterAlt (9);  			// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  			{  				DebugLocation (140' 4);  				Match (input' NULL' Follow._NULL_in_filterExpr291);  				DebugLocation (141' 4);  				filterNode = new Value (null);  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("filterExpr"' 6);  		LeaveRule ("filterExpr"' 6);  		LeaveRule_filterExpr ();  	}  	DebugLocation (144' 1);  }  finally {  	DebugExitRule (GrammarFileName' "filterExpr");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "filterExpr");  	DebugLocation (60' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  		int alt9 = 9;  		try {  			DebugEnterDecision (9' false);  			switch (input.LA (1)) {  			case CHAIN_OPERATOR:  			case COMPARATOR:  				{  					alt9 = 1;  				}  				break;  			case EXPR:  				{  					int LA9_2 = input.LA (2);  					if ((LA9_2 == DOWN)) {  						int LA9_3 = input.LA (3);  						if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  							alt9 = 2;  						}  						else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  							alt9 = 3;  						}  						else {  							NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  							DebugRecognitionException (nvae);  							throw nvae;  						}  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				break;  			case STRING:  				{  					alt9 = 4;  				}  				break;  			case REGEX:  				{  					alt9 = 5;  				}  				break;  			case NUMBER:  				{  					alt9 = 6;  				}  				break;  			case TRUE:  				{  					alt9 = 7;  				}  				break;  			case FALSE:  				{  					alt9 = 8;  				}  				break;  			case NULL:  				{  					alt9 = 9;  				}  				break;  			default: {  				NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  			}  		}  		finally {  			DebugExitDecision (9);  		}  		switch (alt9) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  			{  				DebugLocation (64' 4);  				DebugLocation (64' 6);  				PushFollow (Follow._comparator_in_filterExpr175);  				comparator6 = comparator ();  				PopFollow ();  				Match (input' TokenTypes.Down' null);  				DebugLocation (64' 18);  				PushFollow (Follow._filterExpr_in_filterExpr179);  				a = filterExpr ();  				PopFollow ();  				DebugLocation (64' 31);  				PushFollow (Follow._filterExpr_in_filterExpr183);  				b = filterExpr ();  				PopFollow ();  				Match (input' TokenTypes.Up' null);  				DebugLocation (65' 4);  				Comparator newComparator;  				switch (comparator6) {  				case "=":  					newComparator = Comparator.Equals;  					break;  				case "!=":  					newComparator = Comparator.NotEquals;  					break;  				case ">":  					newComparator = Comparator.Greater;  					break;  				case "<":  					newComparator = Comparator.Less;  					break;  				case ">=":  					newComparator = Comparator.GreaterOrEqual;  					break;  				case "<=":  					newComparator = Comparator.LessOrEqual;  					break;  				case "&":  					newComparator = Comparator.And;  					break;  				case "|":  					newComparator = Comparator.Or;  					break;  				default:  					newComparator = Comparator.Equals;  					break;  				}  				filterNode = new BoolExpression (a' newComparator' b);  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  			{  				DebugLocation (98' 4);  				DebugLocation (98' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr195);  				Match (input' TokenTypes.Down' null);  				DebugLocation (98' 12);  				PushFollow (Follow._filterExpr_in_filterExpr199);  				f = filterExpr ();  				PopFollow ();  				DebugLocation (98' 31);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  				int alt6 = 2;  				try {  					DebugEnterSubRule (6);  					try {  						DebugEnterDecision (6' false);  						int LA6_1 = input.LA (1);  						if ((LA6_1 == 24)) {  							alt6 = 1;  						}  					}  					finally {  						DebugExitDecision (6);  					}  					switch (alt6) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  						{  							DebugLocation (98' 31);  							inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (6);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (99' 4);  				FilterTreeNode newNode = f;  				if ((inverse != null ? inverse.Text : default(string)) == "!")  					newNode.ToggleInversed ();  				filterNode = newNode;  			}  			break;  		case 3:  			DebugEnterAlt (3);  			// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  			{  				DebugLocation (105' 4);  				DebugLocation (105' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr216);  				Match (input' TokenTypes.Down' null);  				DebugLocation (105' 12);  				PushFollow (Follow._propertyChain_in_filterExpr219);  				propertyChain (propertySegments);  				PopFollow ();  				DebugLocation (105' 51);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  				int alt7 = 2;  				try {  					DebugEnterSubRule (7);  					try {  						DebugEnterDecision (7' false);  						int LA7_1 = input.LA (1);  						if ((LA7_1 == 31)) {  							alt7 = 1;  						}  					}  					finally {  						DebugExitDecision (7);  					}  					switch (alt7) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  						{  							DebugLocation (105' 51);  							inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (7);  				}  				DebugLocation (105' 60);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  				int alt8 = 2;  				try {  					DebugEnterSubRule (8);  					try {  						DebugEnterDecision (8' false);  						int LA8_1 = input.LA (1);  						if ((LA8_1 == 24)) {  							alt8 = 1;  						}  					}  					finally {  						DebugExitDecision (8);  					}  					switch (alt8) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  						{  							DebugLocation (105' 60);  							not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (8);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (106' 4);  				FilterTreeNode newProperty = new Property (propertySegments);  				if ((inverse != null ? inverse.Text : default(string)) == "?")  					filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  				else {  					if ((not != null ? not.Text : default(string)) == "!")  						newProperty.ToggleInversed ();  					filterNode = newProperty;  				}  			}  			break;  		case 4:  			DebugEnterAlt (4);  			// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  			{  				DebugLocation (116' 4);  				STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  				DebugLocation (117' 4);  				string stringText = (STRING7 != null ? STRING7.Text : default(string));  				stringText = stringText.Substring (1' stringText.Length - 2);  				filterNode = new Value (stringText);  			}  			break;  		case 5:  			DebugEnterAlt (5);  			// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  			{  				DebugLocation (122' 4);  				REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  				DebugLocation (123' 4);  				string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  				regexText = regexText.Substring (1' regexText.Length - 2);  				filterNode = new RegExp (regexText);  			}  			break;  		case 6:  			DebugEnterAlt (6);  			// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  			{  				DebugLocation (128' 4);  				NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  				DebugLocation (129' 4);  				filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  			}  			break;  		case 7:  			DebugEnterAlt (7);  			// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  			{  				DebugLocation (132' 4);  				Match (input' TRUE' Follow._TRUE_in_filterExpr271);  				DebugLocation (133' 4);  				filterNode = new Value (true);  			}  			break;  		case 8:  			DebugEnterAlt (8);  			// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  			{  				DebugLocation (136' 4);  				Match (input' FALSE' Follow._FALSE_in_filterExpr281);  				DebugLocation (137' 4);  				filterNode = new Value (false);  			}  			break;  		case 9:  			DebugEnterAlt (9);  			// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  			{  				DebugLocation (140' 4);  				Match (input' NULL' Follow._NULL_in_filterExpr291);  				DebugLocation (141' 4);  				filterNode = new Value (null);  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("filterExpr"' 6);  		LeaveRule ("filterExpr"' 6);  		LeaveRule_filterExpr ();  	}  	DebugLocation (144' 1);  }  finally {  	DebugExitRule (GrammarFileName' "filterExpr");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "filterExpr");  	DebugLocation (60' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  		int alt9 = 9;  		try {  			DebugEnterDecision (9' false);  			switch (input.LA (1)) {  			case CHAIN_OPERATOR:  			case COMPARATOR:  				{  					alt9 = 1;  				}  				break;  			case EXPR:  				{  					int LA9_2 = input.LA (2);  					if ((LA9_2 == DOWN)) {  						int LA9_3 = input.LA (3);  						if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  							alt9 = 2;  						}  						else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  							alt9 = 3;  						}  						else {  							NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  							DebugRecognitionException (nvae);  							throw nvae;  						}  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				break;  			case STRING:  				{  					alt9 = 4;  				}  				break;  			case REGEX:  				{  					alt9 = 5;  				}  				break;  			case NUMBER:  				{  					alt9 = 6;  				}  				break;  			case TRUE:  				{  					alt9 = 7;  				}  				break;  			case FALSE:  				{  					alt9 = 8;  				}  				break;  			case NULL:  				{  					alt9 = 9;  				}  				break;  			default: {  				NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  			}  		}  		finally {  			DebugExitDecision (9);  		}  		switch (alt9) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  			{  				DebugLocation (64' 4);  				DebugLocation (64' 6);  				PushFollow (Follow._comparator_in_filterExpr175);  				comparator6 = comparator ();  				PopFollow ();  				Match (input' TokenTypes.Down' null);  				DebugLocation (64' 18);  				PushFollow (Follow._filterExpr_in_filterExpr179);  				a = filterExpr ();  				PopFollow ();  				DebugLocation (64' 31);  				PushFollow (Follow._filterExpr_in_filterExpr183);  				b = filterExpr ();  				PopFollow ();  				Match (input' TokenTypes.Up' null);  				DebugLocation (65' 4);  				Comparator newComparator;  				switch (comparator6) {  				case "=":  					newComparator = Comparator.Equals;  					break;  				case "!=":  					newComparator = Comparator.NotEquals;  					break;  				case ">":  					newComparator = Comparator.Greater;  					break;  				case "<":  					newComparator = Comparator.Less;  					break;  				case ">=":  					newComparator = Comparator.GreaterOrEqual;  					break;  				case "<=":  					newComparator = Comparator.LessOrEqual;  					break;  				case "&":  					newComparator = Comparator.And;  					break;  				case "|":  					newComparator = Comparator.Or;  					break;  				default:  					newComparator = Comparator.Equals;  					break;  				}  				filterNode = new BoolExpression (a' newComparator' b);  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  			{  				DebugLocation (98' 4);  				DebugLocation (98' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr195);  				Match (input' TokenTypes.Down' null);  				DebugLocation (98' 12);  				PushFollow (Follow._filterExpr_in_filterExpr199);  				f = filterExpr ();  				PopFollow ();  				DebugLocation (98' 31);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  				int alt6 = 2;  				try {  					DebugEnterSubRule (6);  					try {  						DebugEnterDecision (6' false);  						int LA6_1 = input.LA (1);  						if ((LA6_1 == 24)) {  							alt6 = 1;  						}  					}  					finally {  						DebugExitDecision (6);  					}  					switch (alt6) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  						{  							DebugLocation (98' 31);  							inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (6);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (99' 4);  				FilterTreeNode newNode = f;  				if ((inverse != null ? inverse.Text : default(string)) == "!")  					newNode.ToggleInversed ();  				filterNode = newNode;  			}  			break;  		case 3:  			DebugEnterAlt (3);  			// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  			{  				DebugLocation (105' 4);  				DebugLocation (105' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr216);  				Match (input' TokenTypes.Down' null);  				DebugLocation (105' 12);  				PushFollow (Follow._propertyChain_in_filterExpr219);  				propertyChain (propertySegments);  				PopFollow ();  				DebugLocation (105' 51);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  				int alt7 = 2;  				try {  					DebugEnterSubRule (7);  					try {  						DebugEnterDecision (7' false);  						int LA7_1 = input.LA (1);  						if ((LA7_1 == 31)) {  							alt7 = 1;  						}  					}  					finally {  						DebugExitDecision (7);  					}  					switch (alt7) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  						{  							DebugLocation (105' 51);  							inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (7);  				}  				DebugLocation (105' 60);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  				int alt8 = 2;  				try {  					DebugEnterSubRule (8);  					try {  						DebugEnterDecision (8' false);  						int LA8_1 = input.LA (1);  						if ((LA8_1 == 24)) {  							alt8 = 1;  						}  					}  					finally {  						DebugExitDecision (8);  					}  					switch (alt8) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  						{  							DebugLocation (105' 60);  							not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (8);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (106' 4);  				FilterTreeNode newProperty = new Property (propertySegments);  				if ((inverse != null ? inverse.Text : default(string)) == "?")  					filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  				else {  					if ((not != null ? not.Text : default(string)) == "!")  						newProperty.ToggleInversed ();  					filterNode = newProperty;  				}  			}  			break;  		case 4:  			DebugEnterAlt (4);  			// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  			{  				DebugLocation (116' 4);  				STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  				DebugLocation (117' 4);  				string stringText = (STRING7 != null ? STRING7.Text : default(string));  				stringText = stringText.Substring (1' stringText.Length - 2);  				filterNode = new Value (stringText);  			}  			break;  		case 5:  			DebugEnterAlt (5);  			// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  			{  				DebugLocation (122' 4);  				REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  				DebugLocation (123' 4);  				string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  				regexText = regexText.Substring (1' regexText.Length - 2);  				filterNode = new RegExp (regexText);  			}  			break;  		case 6:  			DebugEnterAlt (6);  			// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  			{  				DebugLocation (128' 4);  				NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  				DebugLocation (129' 4);  				filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  			}  			break;  		case 7:  			DebugEnterAlt (7);  			// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  			{  				DebugLocation (132' 4);  				Match (input' TRUE' Follow._TRUE_in_filterExpr271);  				DebugLocation (133' 4);  				filterNode = new Value (true);  			}  			break;  		case 8:  			DebugEnterAlt (8);  			// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  			{  				DebugLocation (136' 4);  				Match (input' FALSE' Follow._FALSE_in_filterExpr281);  				DebugLocation (137' 4);  				filterNode = new Value (false);  			}  			break;  		case 9:  			DebugEnterAlt (9);  			// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  			{  				DebugLocation (140' 4);  				Match (input' NULL' Follow._NULL_in_filterExpr291);  				DebugLocation (141' 4);  				filterNode = new Value (null);  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("filterExpr"' 6);  		LeaveRule ("filterExpr"' 6);  		LeaveRule_filterExpr ();  	}  	DebugLocation (144' 1);  }  finally {  	DebugExitRule (GrammarFileName' "filterExpr");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "filterExpr");  	DebugLocation (60' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  		int alt9 = 9;  		try {  			DebugEnterDecision (9' false);  			switch (input.LA (1)) {  			case CHAIN_OPERATOR:  			case COMPARATOR:  				{  					alt9 = 1;  				}  				break;  			case EXPR:  				{  					int LA9_2 = input.LA (2);  					if ((LA9_2 == DOWN)) {  						int LA9_3 = input.LA (3);  						if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  							alt9 = 2;  						}  						else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  							alt9 = 3;  						}  						else {  							NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  							DebugRecognitionException (nvae);  							throw nvae;  						}  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				break;  			case STRING:  				{  					alt9 = 4;  				}  				break;  			case REGEX:  				{  					alt9 = 5;  				}  				break;  			case NUMBER:  				{  					alt9 = 6;  				}  				break;  			case TRUE:  				{  					alt9 = 7;  				}  				break;  			case FALSE:  				{  					alt9 = 8;  				}  				break;  			case NULL:  				{  					alt9 = 9;  				}  				break;  			default: {  				NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  			}  		}  		finally {  			DebugExitDecision (9);  		}  		switch (alt9) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  			{  				DebugLocation (64' 4);  				DebugLocation (64' 6);  				PushFollow (Follow._comparator_in_filterExpr175);  				comparator6 = comparator ();  				PopFollow ();  				Match (input' TokenTypes.Down' null);  				DebugLocation (64' 18);  				PushFollow (Follow._filterExpr_in_filterExpr179);  				a = filterExpr ();  				PopFollow ();  				DebugLocation (64' 31);  				PushFollow (Follow._filterExpr_in_filterExpr183);  				b = filterExpr ();  				PopFollow ();  				Match (input' TokenTypes.Up' null);  				DebugLocation (65' 4);  				Comparator newComparator;  				switch (comparator6) {  				case "=":  					newComparator = Comparator.Equals;  					break;  				case "!=":  					newComparator = Comparator.NotEquals;  					break;  				case ">":  					newComparator = Comparator.Greater;  					break;  				case "<":  					newComparator = Comparator.Less;  					break;  				case ">=":  					newComparator = Comparator.GreaterOrEqual;  					break;  				case "<=":  					newComparator = Comparator.LessOrEqual;  					break;  				case "&":  					newComparator = Comparator.And;  					break;  				case "|":  					newComparator = Comparator.Or;  					break;  				default:  					newComparator = Comparator.Equals;  					break;  				}  				filterNode = new BoolExpression (a' newComparator' b);  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  			{  				DebugLocation (98' 4);  				DebugLocation (98' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr195);  				Match (input' TokenTypes.Down' null);  				DebugLocation (98' 12);  				PushFollow (Follow._filterExpr_in_filterExpr199);  				f = filterExpr ();  				PopFollow ();  				DebugLocation (98' 31);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  				int alt6 = 2;  				try {  					DebugEnterSubRule (6);  					try {  						DebugEnterDecision (6' false);  						int LA6_1 = input.LA (1);  						if ((LA6_1 == 24)) {  							alt6 = 1;  						}  					}  					finally {  						DebugExitDecision (6);  					}  					switch (alt6) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  						{  							DebugLocation (98' 31);  							inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (6);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (99' 4);  				FilterTreeNode newNode = f;  				if ((inverse != null ? inverse.Text : default(string)) == "!")  					newNode.ToggleInversed ();  				filterNode = newNode;  			}  			break;  		case 3:  			DebugEnterAlt (3);  			// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  			{  				DebugLocation (105' 4);  				DebugLocation (105' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr216);  				Match (input' TokenTypes.Down' null);  				DebugLocation (105' 12);  				PushFollow (Follow._propertyChain_in_filterExpr219);  				propertyChain (propertySegments);  				PopFollow ();  				DebugLocation (105' 51);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  				int alt7 = 2;  				try {  					DebugEnterSubRule (7);  					try {  						DebugEnterDecision (7' false);  						int LA7_1 = input.LA (1);  						if ((LA7_1 == 31)) {  							alt7 = 1;  						}  					}  					finally {  						DebugExitDecision (7);  					}  					switch (alt7) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  						{  							DebugLocation (105' 51);  							inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (7);  				}  				DebugLocation (105' 60);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  				int alt8 = 2;  				try {  					DebugEnterSubRule (8);  					try {  						DebugEnterDecision (8' false);  						int LA8_1 = input.LA (1);  						if ((LA8_1 == 24)) {  							alt8 = 1;  						}  					}  					finally {  						DebugExitDecision (8);  					}  					switch (alt8) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  						{  							DebugLocation (105' 60);  							not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (8);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (106' 4);  				FilterTreeNode newProperty = new Property (propertySegments);  				if ((inverse != null ? inverse.Text : default(string)) == "?")  					filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  				else {  					if ((not != null ? not.Text : default(string)) == "!")  						newProperty.ToggleInversed ();  					filterNode = newProperty;  				}  			}  			break;  		case 4:  			DebugEnterAlt (4);  			// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  			{  				DebugLocation (116' 4);  				STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  				DebugLocation (117' 4);  				string stringText = (STRING7 != null ? STRING7.Text : default(string));  				stringText = stringText.Substring (1' stringText.Length - 2);  				filterNode = new Value (stringText);  			}  			break;  		case 5:  			DebugEnterAlt (5);  			// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  			{  				DebugLocation (122' 4);  				REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  				DebugLocation (123' 4);  				string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  				regexText = regexText.Substring (1' regexText.Length - 2);  				filterNode = new RegExp (regexText);  			}  			break;  		case 6:  			DebugEnterAlt (6);  			// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  			{  				DebugLocation (128' 4);  				NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  				DebugLocation (129' 4);  				filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  			}  			break;  		case 7:  			DebugEnterAlt (7);  			// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  			{  				DebugLocation (132' 4);  				Match (input' TRUE' Follow._TRUE_in_filterExpr271);  				DebugLocation (133' 4);  				filterNode = new Value (true);  			}  			break;  		case 8:  			DebugEnterAlt (8);  			// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  			{  				DebugLocation (136' 4);  				Match (input' FALSE' Follow._FALSE_in_filterExpr281);  				DebugLocation (137' 4);  				filterNode = new Value (false);  			}  			break;  		case 9:  			DebugEnterAlt (9);  			// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  			{  				DebugLocation (140' 4);  				Match (input' NULL' Follow._NULL_in_filterExpr291);  				DebugLocation (141' 4);  				filterNode = new Value (null);  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("filterExpr"' 6);  		LeaveRule ("filterExpr"' 6);  		LeaveRule_filterExpr ();  	}  	DebugLocation (144' 1);  }  finally {  	DebugExitRule (GrammarFileName' "filterExpr");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "filterExpr");  	DebugLocation (60' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  		int alt9 = 9;  		try {  			DebugEnterDecision (9' false);  			switch (input.LA (1)) {  			case CHAIN_OPERATOR:  			case COMPARATOR:  				{  					alt9 = 1;  				}  				break;  			case EXPR:  				{  					int LA9_2 = input.LA (2);  					if ((LA9_2 == DOWN)) {  						int LA9_3 = input.LA (3);  						if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  							alt9 = 2;  						}  						else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  							alt9 = 3;  						}  						else {  							NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  							DebugRecognitionException (nvae);  							throw nvae;  						}  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				break;  			case STRING:  				{  					alt9 = 4;  				}  				break;  			case REGEX:  				{  					alt9 = 5;  				}  				break;  			case NUMBER:  				{  					alt9 = 6;  				}  				break;  			case TRUE:  				{  					alt9 = 7;  				}  				break;  			case FALSE:  				{  					alt9 = 8;  				}  				break;  			case NULL:  				{  					alt9 = 9;  				}  				break;  			default: {  				NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  			}  		}  		finally {  			DebugExitDecision (9);  		}  		switch (alt9) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  			{  				DebugLocation (64' 4);  				DebugLocation (64' 6);  				PushFollow (Follow._comparator_in_filterExpr175);  				comparator6 = comparator ();  				PopFollow ();  				Match (input' TokenTypes.Down' null);  				DebugLocation (64' 18);  				PushFollow (Follow._filterExpr_in_filterExpr179);  				a = filterExpr ();  				PopFollow ();  				DebugLocation (64' 31);  				PushFollow (Follow._filterExpr_in_filterExpr183);  				b = filterExpr ();  				PopFollow ();  				Match (input' TokenTypes.Up' null);  				DebugLocation (65' 4);  				Comparator newComparator;  				switch (comparator6) {  				case "=":  					newComparator = Comparator.Equals;  					break;  				case "!=":  					newComparator = Comparator.NotEquals;  					break;  				case ">":  					newComparator = Comparator.Greater;  					break;  				case "<":  					newComparator = Comparator.Less;  					break;  				case ">=":  					newComparator = Comparator.GreaterOrEqual;  					break;  				case "<=":  					newComparator = Comparator.LessOrEqual;  					break;  				case "&":  					newComparator = Comparator.And;  					break;  				case "|":  					newComparator = Comparator.Or;  					break;  				default:  					newComparator = Comparator.Equals;  					break;  				}  				filterNode = new BoolExpression (a' newComparator' b);  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  			{  				DebugLocation (98' 4);  				DebugLocation (98' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr195);  				Match (input' TokenTypes.Down' null);  				DebugLocation (98' 12);  				PushFollow (Follow._filterExpr_in_filterExpr199);  				f = filterExpr ();  				PopFollow ();  				DebugLocation (98' 31);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  				int alt6 = 2;  				try {  					DebugEnterSubRule (6);  					try {  						DebugEnterDecision (6' false);  						int LA6_1 = input.LA (1);  						if ((LA6_1 == 24)) {  							alt6 = 1;  						}  					}  					finally {  						DebugExitDecision (6);  					}  					switch (alt6) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  						{  							DebugLocation (98' 31);  							inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (6);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (99' 4);  				FilterTreeNode newNode = f;  				if ((inverse != null ? inverse.Text : default(string)) == "!")  					newNode.ToggleInversed ();  				filterNode = newNode;  			}  			break;  		case 3:  			DebugEnterAlt (3);  			// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  			{  				DebugLocation (105' 4);  				DebugLocation (105' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr216);  				Match (input' TokenTypes.Down' null);  				DebugLocation (105' 12);  				PushFollow (Follow._propertyChain_in_filterExpr219);  				propertyChain (propertySegments);  				PopFollow ();  				DebugLocation (105' 51);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  				int alt7 = 2;  				try {  					DebugEnterSubRule (7);  					try {  						DebugEnterDecision (7' false);  						int LA7_1 = input.LA (1);  						if ((LA7_1 == 31)) {  							alt7 = 1;  						}  					}  					finally {  						DebugExitDecision (7);  					}  					switch (alt7) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  						{  							DebugLocation (105' 51);  							inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (7);  				}  				DebugLocation (105' 60);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  				int alt8 = 2;  				try {  					DebugEnterSubRule (8);  					try {  						DebugEnterDecision (8' false);  						int LA8_1 = input.LA (1);  						if ((LA8_1 == 24)) {  							alt8 = 1;  						}  					}  					finally {  						DebugExitDecision (8);  					}  					switch (alt8) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  						{  							DebugLocation (105' 60);  							not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (8);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (106' 4);  				FilterTreeNode newProperty = new Property (propertySegments);  				if ((inverse != null ? inverse.Text : default(string)) == "?")  					filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  				else {  					if ((not != null ? not.Text : default(string)) == "!")  						newProperty.ToggleInversed ();  					filterNode = newProperty;  				}  			}  			break;  		case 4:  			DebugEnterAlt (4);  			// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  			{  				DebugLocation (116' 4);  				STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  				DebugLocation (117' 4);  				string stringText = (STRING7 != null ? STRING7.Text : default(string));  				stringText = stringText.Substring (1' stringText.Length - 2);  				filterNode = new Value (stringText);  			}  			break;  		case 5:  			DebugEnterAlt (5);  			// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  			{  				DebugLocation (122' 4);  				REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  				DebugLocation (123' 4);  				string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  				regexText = regexText.Substring (1' regexText.Length - 2);  				filterNode = new RegExp (regexText);  			}  			break;  		case 6:  			DebugEnterAlt (6);  			// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  			{  				DebugLocation (128' 4);  				NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  				DebugLocation (129' 4);  				filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  			}  			break;  		case 7:  			DebugEnterAlt (7);  			// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  			{  				DebugLocation (132' 4);  				Match (input' TRUE' Follow._TRUE_in_filterExpr271);  				DebugLocation (133' 4);  				filterNode = new Value (true);  			}  			break;  		case 8:  			DebugEnterAlt (8);  			// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  			{  				DebugLocation (136' 4);  				Match (input' FALSE' Follow._FALSE_in_filterExpr281);  				DebugLocation (137' 4);  				filterNode = new Value (false);  			}  			break;  		case 9:  			DebugEnterAlt (9);  			// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  			{  				DebugLocation (140' 4);  				Match (input' NULL' Follow._NULL_in_filterExpr291);  				DebugLocation (141' 4);  				filterNode = new Value (null);  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("filterExpr"' 6);  		LeaveRule ("filterExpr"' 6);  		LeaveRule_filterExpr ();  	}  	DebugLocation (144' 1);  }  finally {  	DebugExitRule (GrammarFileName' "filterExpr");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "filterExpr");  	DebugLocation (60' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  		int alt9 = 9;  		try {  			DebugEnterDecision (9' false);  			switch (input.LA (1)) {  			case CHAIN_OPERATOR:  			case COMPARATOR:  				{  					alt9 = 1;  				}  				break;  			case EXPR:  				{  					int LA9_2 = input.LA (2);  					if ((LA9_2 == DOWN)) {  						int LA9_3 = input.LA (3);  						if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  							alt9 = 2;  						}  						else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  							alt9 = 3;  						}  						else {  							NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  							DebugRecognitionException (nvae);  							throw nvae;  						}  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				break;  			case STRING:  				{  					alt9 = 4;  				}  				break;  			case REGEX:  				{  					alt9 = 5;  				}  				break;  			case NUMBER:  				{  					alt9 = 6;  				}  				break;  			case TRUE:  				{  					alt9 = 7;  				}  				break;  			case FALSE:  				{  					alt9 = 8;  				}  				break;  			case NULL:  				{  					alt9 = 9;  				}  				break;  			default: {  				NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  			}  		}  		finally {  			DebugExitDecision (9);  		}  		switch (alt9) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  			{  				DebugLocation (64' 4);  				DebugLocation (64' 6);  				PushFollow (Follow._comparator_in_filterExpr175);  				comparator6 = comparator ();  				PopFollow ();  				Match (input' TokenTypes.Down' null);  				DebugLocation (64' 18);  				PushFollow (Follow._filterExpr_in_filterExpr179);  				a = filterExpr ();  				PopFollow ();  				DebugLocation (64' 31);  				PushFollow (Follow._filterExpr_in_filterExpr183);  				b = filterExpr ();  				PopFollow ();  				Match (input' TokenTypes.Up' null);  				DebugLocation (65' 4);  				Comparator newComparator;  				switch (comparator6) {  				case "=":  					newComparator = Comparator.Equals;  					break;  				case "!=":  					newComparator = Comparator.NotEquals;  					break;  				case ">":  					newComparator = Comparator.Greater;  					break;  				case "<":  					newComparator = Comparator.Less;  					break;  				case ">=":  					newComparator = Comparator.GreaterOrEqual;  					break;  				case "<=":  					newComparator = Comparator.LessOrEqual;  					break;  				case "&":  					newComparator = Comparator.And;  					break;  				case "|":  					newComparator = Comparator.Or;  					break;  				default:  					newComparator = Comparator.Equals;  					break;  				}  				filterNode = new BoolExpression (a' newComparator' b);  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  			{  				DebugLocation (98' 4);  				DebugLocation (98' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr195);  				Match (input' TokenTypes.Down' null);  				DebugLocation (98' 12);  				PushFollow (Follow._filterExpr_in_filterExpr199);  				f = filterExpr ();  				PopFollow ();  				DebugLocation (98' 31);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  				int alt6 = 2;  				try {  					DebugEnterSubRule (6);  					try {  						DebugEnterDecision (6' false);  						int LA6_1 = input.LA (1);  						if ((LA6_1 == 24)) {  							alt6 = 1;  						}  					}  					finally {  						DebugExitDecision (6);  					}  					switch (alt6) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  						{  							DebugLocation (98' 31);  							inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (6);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (99' 4);  				FilterTreeNode newNode = f;  				if ((inverse != null ? inverse.Text : default(string)) == "!")  					newNode.ToggleInversed ();  				filterNode = newNode;  			}  			break;  		case 3:  			DebugEnterAlt (3);  			// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  			{  				DebugLocation (105' 4);  				DebugLocation (105' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr216);  				Match (input' TokenTypes.Down' null);  				DebugLocation (105' 12);  				PushFollow (Follow._propertyChain_in_filterExpr219);  				propertyChain (propertySegments);  				PopFollow ();  				DebugLocation (105' 51);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  				int alt7 = 2;  				try {  					DebugEnterSubRule (7);  					try {  						DebugEnterDecision (7' false);  						int LA7_1 = input.LA (1);  						if ((LA7_1 == 31)) {  							alt7 = 1;  						}  					}  					finally {  						DebugExitDecision (7);  					}  					switch (alt7) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  						{  							DebugLocation (105' 51);  							inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (7);  				}  				DebugLocation (105' 60);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  				int alt8 = 2;  				try {  					DebugEnterSubRule (8);  					try {  						DebugEnterDecision (8' false);  						int LA8_1 = input.LA (1);  						if ((LA8_1 == 24)) {  							alt8 = 1;  						}  					}  					finally {  						DebugExitDecision (8);  					}  					switch (alt8) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  						{  							DebugLocation (105' 60);  							not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (8);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (106' 4);  				FilterTreeNode newProperty = new Property (propertySegments);  				if ((inverse != null ? inverse.Text : default(string)) == "?")  					filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  				else {  					if ((not != null ? not.Text : default(string)) == "!")  						newProperty.ToggleInversed ();  					filterNode = newProperty;  				}  			}  			break;  		case 4:  			DebugEnterAlt (4);  			// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  			{  				DebugLocation (116' 4);  				STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  				DebugLocation (117' 4);  				string stringText = (STRING7 != null ? STRING7.Text : default(string));  				stringText = stringText.Substring (1' stringText.Length - 2);  				filterNode = new Value (stringText);  			}  			break;  		case 5:  			DebugEnterAlt (5);  			// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  			{  				DebugLocation (122' 4);  				REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  				DebugLocation (123' 4);  				string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  				regexText = regexText.Substring (1' regexText.Length - 2);  				filterNode = new RegExp (regexText);  			}  			break;  		case 6:  			DebugEnterAlt (6);  			// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  			{  				DebugLocation (128' 4);  				NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  				DebugLocation (129' 4);  				filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  			}  			break;  		case 7:  			DebugEnterAlt (7);  			// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  			{  				DebugLocation (132' 4);  				Match (input' TRUE' Follow._TRUE_in_filterExpr271);  				DebugLocation (133' 4);  				filterNode = new Value (true);  			}  			break;  		case 8:  			DebugEnterAlt (8);  			// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  			{  				DebugLocation (136' 4);  				Match (input' FALSE' Follow._FALSE_in_filterExpr281);  				DebugLocation (137' 4);  				filterNode = new Value (false);  			}  			break;  		case 9:  			DebugEnterAlt (9);  			// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  			{  				DebugLocation (140' 4);  				Match (input' NULL' Follow._NULL_in_filterExpr291);  				DebugLocation (141' 4);  				filterNode = new Value (null);  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("filterExpr"' 6);  		LeaveRule ("filterExpr"' 6);  		LeaveRule_filterExpr ();  	}  	DebugLocation (144' 1);  }  finally {  	DebugExitRule (GrammarFileName' "filterExpr");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "filterExpr");  	DebugLocation (60' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  		int alt9 = 9;  		try {  			DebugEnterDecision (9' false);  			switch (input.LA (1)) {  			case CHAIN_OPERATOR:  			case COMPARATOR:  				{  					alt9 = 1;  				}  				break;  			case EXPR:  				{  					int LA9_2 = input.LA (2);  					if ((LA9_2 == DOWN)) {  						int LA9_3 = input.LA (3);  						if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  							alt9 = 2;  						}  						else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  							alt9 = 3;  						}  						else {  							NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  							DebugRecognitionException (nvae);  							throw nvae;  						}  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				break;  			case STRING:  				{  					alt9 = 4;  				}  				break;  			case REGEX:  				{  					alt9 = 5;  				}  				break;  			case NUMBER:  				{  					alt9 = 6;  				}  				break;  			case TRUE:  				{  					alt9 = 7;  				}  				break;  			case FALSE:  				{  					alt9 = 8;  				}  				break;  			case NULL:  				{  					alt9 = 9;  				}  				break;  			default: {  				NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  			}  		}  		finally {  			DebugExitDecision (9);  		}  		switch (alt9) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  			{  				DebugLocation (64' 4);  				DebugLocation (64' 6);  				PushFollow (Follow._comparator_in_filterExpr175);  				comparator6 = comparator ();  				PopFollow ();  				Match (input' TokenTypes.Down' null);  				DebugLocation (64' 18);  				PushFollow (Follow._filterExpr_in_filterExpr179);  				a = filterExpr ();  				PopFollow ();  				DebugLocation (64' 31);  				PushFollow (Follow._filterExpr_in_filterExpr183);  				b = filterExpr ();  				PopFollow ();  				Match (input' TokenTypes.Up' null);  				DebugLocation (65' 4);  				Comparator newComparator;  				switch (comparator6) {  				case "=":  					newComparator = Comparator.Equals;  					break;  				case "!=":  					newComparator = Comparator.NotEquals;  					break;  				case ">":  					newComparator = Comparator.Greater;  					break;  				case "<":  					newComparator = Comparator.Less;  					break;  				case ">=":  					newComparator = Comparator.GreaterOrEqual;  					break;  				case "<=":  					newComparator = Comparator.LessOrEqual;  					break;  				case "&":  					newComparator = Comparator.And;  					break;  				case "|":  					newComparator = Comparator.Or;  					break;  				default:  					newComparator = Comparator.Equals;  					break;  				}  				filterNode = new BoolExpression (a' newComparator' b);  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  			{  				DebugLocation (98' 4);  				DebugLocation (98' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr195);  				Match (input' TokenTypes.Down' null);  				DebugLocation (98' 12);  				PushFollow (Follow._filterExpr_in_filterExpr199);  				f = filterExpr ();  				PopFollow ();  				DebugLocation (98' 31);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  				int alt6 = 2;  				try {  					DebugEnterSubRule (6);  					try {  						DebugEnterDecision (6' false);  						int LA6_1 = input.LA (1);  						if ((LA6_1 == 24)) {  							alt6 = 1;  						}  					}  					finally {  						DebugExitDecision (6);  					}  					switch (alt6) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  						{  							DebugLocation (98' 31);  							inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (6);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (99' 4);  				FilterTreeNode newNode = f;  				if ((inverse != null ? inverse.Text : default(string)) == "!")  					newNode.ToggleInversed ();  				filterNode = newNode;  			}  			break;  		case 3:  			DebugEnterAlt (3);  			// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  			{  				DebugLocation (105' 4);  				DebugLocation (105' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr216);  				Match (input' TokenTypes.Down' null);  				DebugLocation (105' 12);  				PushFollow (Follow._propertyChain_in_filterExpr219);  				propertyChain (propertySegments);  				PopFollow ();  				DebugLocation (105' 51);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  				int alt7 = 2;  				try {  					DebugEnterSubRule (7);  					try {  						DebugEnterDecision (7' false);  						int LA7_1 = input.LA (1);  						if ((LA7_1 == 31)) {  							alt7 = 1;  						}  					}  					finally {  						DebugExitDecision (7);  					}  					switch (alt7) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  						{  							DebugLocation (105' 51);  							inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (7);  				}  				DebugLocation (105' 60);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  				int alt8 = 2;  				try {  					DebugEnterSubRule (8);  					try {  						DebugEnterDecision (8' false);  						int LA8_1 = input.LA (1);  						if ((LA8_1 == 24)) {  							alt8 = 1;  						}  					}  					finally {  						DebugExitDecision (8);  					}  					switch (alt8) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  						{  							DebugLocation (105' 60);  							not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (8);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (106' 4);  				FilterTreeNode newProperty = new Property (propertySegments);  				if ((inverse != null ? inverse.Text : default(string)) == "?")  					filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  				else {  					if ((not != null ? not.Text : default(string)) == "!")  						newProperty.ToggleInversed ();  					filterNode = newProperty;  				}  			}  			break;  		case 4:  			DebugEnterAlt (4);  			// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  			{  				DebugLocation (116' 4);  				STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  				DebugLocation (117' 4);  				string stringText = (STRING7 != null ? STRING7.Text : default(string));  				stringText = stringText.Substring (1' stringText.Length - 2);  				filterNode = new Value (stringText);  			}  			break;  		case 5:  			DebugEnterAlt (5);  			// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  			{  				DebugLocation (122' 4);  				REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  				DebugLocation (123' 4);  				string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  				regexText = regexText.Substring (1' regexText.Length - 2);  				filterNode = new RegExp (regexText);  			}  			break;  		case 6:  			DebugEnterAlt (6);  			// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  			{  				DebugLocation (128' 4);  				NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  				DebugLocation (129' 4);  				filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  			}  			break;  		case 7:  			DebugEnterAlt (7);  			// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  			{  				DebugLocation (132' 4);  				Match (input' TRUE' Follow._TRUE_in_filterExpr271);  				DebugLocation (133' 4);  				filterNode = new Value (true);  			}  			break;  		case 8:  			DebugEnterAlt (8);  			// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  			{  				DebugLocation (136' 4);  				Match (input' FALSE' Follow._FALSE_in_filterExpr281);  				DebugLocation (137' 4);  				filterNode = new Value (false);  			}  			break;  		case 9:  			DebugEnterAlt (9);  			// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  			{  				DebugLocation (140' 4);  				Match (input' NULL' Follow._NULL_in_filterExpr291);  				DebugLocation (141' 4);  				filterNode = new Value (null);  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("filterExpr"' 6);  		LeaveRule ("filterExpr"' 6);  		LeaveRule_filterExpr ();  	}  	DebugLocation (144' 1);  }  finally {  	DebugExitRule (GrammarFileName' "filterExpr");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "filterExpr");  	DebugLocation (60' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  		int alt9 = 9;  		try {  			DebugEnterDecision (9' false);  			switch (input.LA (1)) {  			case CHAIN_OPERATOR:  			case COMPARATOR:  				{  					alt9 = 1;  				}  				break;  			case EXPR:  				{  					int LA9_2 = input.LA (2);  					if ((LA9_2 == DOWN)) {  						int LA9_3 = input.LA (3);  						if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  							alt9 = 2;  						}  						else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  							alt9 = 3;  						}  						else {  							NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  							DebugRecognitionException (nvae);  							throw nvae;  						}  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				break;  			case STRING:  				{  					alt9 = 4;  				}  				break;  			case REGEX:  				{  					alt9 = 5;  				}  				break;  			case NUMBER:  				{  					alt9 = 6;  				}  				break;  			case TRUE:  				{  					alt9 = 7;  				}  				break;  			case FALSE:  				{  					alt9 = 8;  				}  				break;  			case NULL:  				{  					alt9 = 9;  				}  				break;  			default: {  				NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  			}  		}  		finally {  			DebugExitDecision (9);  		}  		switch (alt9) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  			{  				DebugLocation (64' 4);  				DebugLocation (64' 6);  				PushFollow (Follow._comparator_in_filterExpr175);  				comparator6 = comparator ();  				PopFollow ();  				Match (input' TokenTypes.Down' null);  				DebugLocation (64' 18);  				PushFollow (Follow._filterExpr_in_filterExpr179);  				a = filterExpr ();  				PopFollow ();  				DebugLocation (64' 31);  				PushFollow (Follow._filterExpr_in_filterExpr183);  				b = filterExpr ();  				PopFollow ();  				Match (input' TokenTypes.Up' null);  				DebugLocation (65' 4);  				Comparator newComparator;  				switch (comparator6) {  				case "=":  					newComparator = Comparator.Equals;  					break;  				case "!=":  					newComparator = Comparator.NotEquals;  					break;  				case ">":  					newComparator = Comparator.Greater;  					break;  				case "<":  					newComparator = Comparator.Less;  					break;  				case ">=":  					newComparator = Comparator.GreaterOrEqual;  					break;  				case "<=":  					newComparator = Comparator.LessOrEqual;  					break;  				case "&":  					newComparator = Comparator.And;  					break;  				case "|":  					newComparator = Comparator.Or;  					break;  				default:  					newComparator = Comparator.Equals;  					break;  				}  				filterNode = new BoolExpression (a' newComparator' b);  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  			{  				DebugLocation (98' 4);  				DebugLocation (98' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr195);  				Match (input' TokenTypes.Down' null);  				DebugLocation (98' 12);  				PushFollow (Follow._filterExpr_in_filterExpr199);  				f = filterExpr ();  				PopFollow ();  				DebugLocation (98' 31);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  				int alt6 = 2;  				try {  					DebugEnterSubRule (6);  					try {  						DebugEnterDecision (6' false);  						int LA6_1 = input.LA (1);  						if ((LA6_1 == 24)) {  							alt6 = 1;  						}  					}  					finally {  						DebugExitDecision (6);  					}  					switch (alt6) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  						{  							DebugLocation (98' 31);  							inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (6);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (99' 4);  				FilterTreeNode newNode = f;  				if ((inverse != null ? inverse.Text : default(string)) == "!")  					newNode.ToggleInversed ();  				filterNode = newNode;  			}  			break;  		case 3:  			DebugEnterAlt (3);  			// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  			{  				DebugLocation (105' 4);  				DebugLocation (105' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr216);  				Match (input' TokenTypes.Down' null);  				DebugLocation (105' 12);  				PushFollow (Follow._propertyChain_in_filterExpr219);  				propertyChain (propertySegments);  				PopFollow ();  				DebugLocation (105' 51);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  				int alt7 = 2;  				try {  					DebugEnterSubRule (7);  					try {  						DebugEnterDecision (7' false);  						int LA7_1 = input.LA (1);  						if ((LA7_1 == 31)) {  							alt7 = 1;  						}  					}  					finally {  						DebugExitDecision (7);  					}  					switch (alt7) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  						{  							DebugLocation (105' 51);  							inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (7);  				}  				DebugLocation (105' 60);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  				int alt8 = 2;  				try {  					DebugEnterSubRule (8);  					try {  						DebugEnterDecision (8' false);  						int LA8_1 = input.LA (1);  						if ((LA8_1 == 24)) {  							alt8 = 1;  						}  					}  					finally {  						DebugExitDecision (8);  					}  					switch (alt8) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  						{  							DebugLocation (105' 60);  							not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (8);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (106' 4);  				FilterTreeNode newProperty = new Property (propertySegments);  				if ((inverse != null ? inverse.Text : default(string)) == "?")  					filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  				else {  					if ((not != null ? not.Text : default(string)) == "!")  						newProperty.ToggleInversed ();  					filterNode = newProperty;  				}  			}  			break;  		case 4:  			DebugEnterAlt (4);  			// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  			{  				DebugLocation (116' 4);  				STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  				DebugLocation (117' 4);  				string stringText = (STRING7 != null ? STRING7.Text : default(string));  				stringText = stringText.Substring (1' stringText.Length - 2);  				filterNode = new Value (stringText);  			}  			break;  		case 5:  			DebugEnterAlt (5);  			// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  			{  				DebugLocation (122' 4);  				REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  				DebugLocation (123' 4);  				string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  				regexText = regexText.Substring (1' regexText.Length - 2);  				filterNode = new RegExp (regexText);  			}  			break;  		case 6:  			DebugEnterAlt (6);  			// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  			{  				DebugLocation (128' 4);  				NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  				DebugLocation (129' 4);  				filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  			}  			break;  		case 7:  			DebugEnterAlt (7);  			// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  			{  				DebugLocation (132' 4);  				Match (input' TRUE' Follow._TRUE_in_filterExpr271);  				DebugLocation (133' 4);  				filterNode = new Value (true);  			}  			break;  		case 8:  			DebugEnterAlt (8);  			// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  			{  				DebugLocation (136' 4);  				Match (input' FALSE' Follow._FALSE_in_filterExpr281);  				DebugLocation (137' 4);  				filterNode = new Value (false);  			}  			break;  		case 9:  			DebugEnterAlt (9);  			// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  			{  				DebugLocation (140' 4);  				Match (input' NULL' Follow._NULL_in_filterExpr291);  				DebugLocation (141' 4);  				filterNode = new Value (null);  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("filterExpr"' 6);  		LeaveRule ("filterExpr"' 6);  		LeaveRule_filterExpr ();  	}  	DebugLocation (144' 1);  }  finally {  	DebugExitRule (GrammarFileName' "filterExpr");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "filterExpr");  	DebugLocation (60' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  		int alt9 = 9;  		try {  			DebugEnterDecision (9' false);  			switch (input.LA (1)) {  			case CHAIN_OPERATOR:  			case COMPARATOR:  				{  					alt9 = 1;  				}  				break;  			case EXPR:  				{  					int LA9_2 = input.LA (2);  					if ((LA9_2 == DOWN)) {  						int LA9_3 = input.LA (3);  						if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  							alt9 = 2;  						}  						else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  							alt9 = 3;  						}  						else {  							NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  							DebugRecognitionException (nvae);  							throw nvae;  						}  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				break;  			case STRING:  				{  					alt9 = 4;  				}  				break;  			case REGEX:  				{  					alt9 = 5;  				}  				break;  			case NUMBER:  				{  					alt9 = 6;  				}  				break;  			case TRUE:  				{  					alt9 = 7;  				}  				break;  			case FALSE:  				{  					alt9 = 8;  				}  				break;  			case NULL:  				{  					alt9 = 9;  				}  				break;  			default: {  				NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  			}  		}  		finally {  			DebugExitDecision (9);  		}  		switch (alt9) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  			{  				DebugLocation (64' 4);  				DebugLocation (64' 6);  				PushFollow (Follow._comparator_in_filterExpr175);  				comparator6 = comparator ();  				PopFollow ();  				Match (input' TokenTypes.Down' null);  				DebugLocation (64' 18);  				PushFollow (Follow._filterExpr_in_filterExpr179);  				a = filterExpr ();  				PopFollow ();  				DebugLocation (64' 31);  				PushFollow (Follow._filterExpr_in_filterExpr183);  				b = filterExpr ();  				PopFollow ();  				Match (input' TokenTypes.Up' null);  				DebugLocation (65' 4);  				Comparator newComparator;  				switch (comparator6) {  				case "=":  					newComparator = Comparator.Equals;  					break;  				case "!=":  					newComparator = Comparator.NotEquals;  					break;  				case ">":  					newComparator = Comparator.Greater;  					break;  				case "<":  					newComparator = Comparator.Less;  					break;  				case ">=":  					newComparator = Comparator.GreaterOrEqual;  					break;  				case "<=":  					newComparator = Comparator.LessOrEqual;  					break;  				case "&":  					newComparator = Comparator.And;  					break;  				case "|":  					newComparator = Comparator.Or;  					break;  				default:  					newComparator = Comparator.Equals;  					break;  				}  				filterNode = new BoolExpression (a' newComparator' b);  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  			{  				DebugLocation (98' 4);  				DebugLocation (98' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr195);  				Match (input' TokenTypes.Down' null);  				DebugLocation (98' 12);  				PushFollow (Follow._filterExpr_in_filterExpr199);  				f = filterExpr ();  				PopFollow ();  				DebugLocation (98' 31);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  				int alt6 = 2;  				try {  					DebugEnterSubRule (6);  					try {  						DebugEnterDecision (6' false);  						int LA6_1 = input.LA (1);  						if ((LA6_1 == 24)) {  							alt6 = 1;  						}  					}  					finally {  						DebugExitDecision (6);  					}  					switch (alt6) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  						{  							DebugLocation (98' 31);  							inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (6);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (99' 4);  				FilterTreeNode newNode = f;  				if ((inverse != null ? inverse.Text : default(string)) == "!")  					newNode.ToggleInversed ();  				filterNode = newNode;  			}  			break;  		case 3:  			DebugEnterAlt (3);  			// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  			{  				DebugLocation (105' 4);  				DebugLocation (105' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr216);  				Match (input' TokenTypes.Down' null);  				DebugLocation (105' 12);  				PushFollow (Follow._propertyChain_in_filterExpr219);  				propertyChain (propertySegments);  				PopFollow ();  				DebugLocation (105' 51);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  				int alt7 = 2;  				try {  					DebugEnterSubRule (7);  					try {  						DebugEnterDecision (7' false);  						int LA7_1 = input.LA (1);  						if ((LA7_1 == 31)) {  							alt7 = 1;  						}  					}  					finally {  						DebugExitDecision (7);  					}  					switch (alt7) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  						{  							DebugLocation (105' 51);  							inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (7);  				}  				DebugLocation (105' 60);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  				int alt8 = 2;  				try {  					DebugEnterSubRule (8);  					try {  						DebugEnterDecision (8' false);  						int LA8_1 = input.LA (1);  						if ((LA8_1 == 24)) {  							alt8 = 1;  						}  					}  					finally {  						DebugExitDecision (8);  					}  					switch (alt8) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  						{  							DebugLocation (105' 60);  							not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (8);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (106' 4);  				FilterTreeNode newProperty = new Property (propertySegments);  				if ((inverse != null ? inverse.Text : default(string)) == "?")  					filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  				else {  					if ((not != null ? not.Text : default(string)) == "!")  						newProperty.ToggleInversed ();  					filterNode = newProperty;  				}  			}  			break;  		case 4:  			DebugEnterAlt (4);  			// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  			{  				DebugLocation (116' 4);  				STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  				DebugLocation (117' 4);  				string stringText = (STRING7 != null ? STRING7.Text : default(string));  				stringText = stringText.Substring (1' stringText.Length - 2);  				filterNode = new Value (stringText);  			}  			break;  		case 5:  			DebugEnterAlt (5);  			// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  			{  				DebugLocation (122' 4);  				REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  				DebugLocation (123' 4);  				string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  				regexText = regexText.Substring (1' regexText.Length - 2);  				filterNode = new RegExp (regexText);  			}  			break;  		case 6:  			DebugEnterAlt (6);  			// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  			{  				DebugLocation (128' 4);  				NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  				DebugLocation (129' 4);  				filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  			}  			break;  		case 7:  			DebugEnterAlt (7);  			// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  			{  				DebugLocation (132' 4);  				Match (input' TRUE' Follow._TRUE_in_filterExpr271);  				DebugLocation (133' 4);  				filterNode = new Value (true);  			}  			break;  		case 8:  			DebugEnterAlt (8);  			// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  			{  				DebugLocation (136' 4);  				Match (input' FALSE' Follow._FALSE_in_filterExpr281);  				DebugLocation (137' 4);  				filterNode = new Value (false);  			}  			break;  		case 9:  			DebugEnterAlt (9);  			// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  			{  				DebugLocation (140' 4);  				Match (input' NULL' Follow._NULL_in_filterExpr291);  				DebugLocation (141' 4);  				filterNode = new Value (null);  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("filterExpr"' 6);  		LeaveRule ("filterExpr"' 6);  		LeaveRule_filterExpr ();  	}  	DebugLocation (144' 1);  }  finally {  	DebugExitRule (GrammarFileName' "filterExpr");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "filterExpr");  	DebugLocation (60' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  		int alt9 = 9;  		try {  			DebugEnterDecision (9' false);  			switch (input.LA (1)) {  			case CHAIN_OPERATOR:  			case COMPARATOR:  				{  					alt9 = 1;  				}  				break;  			case EXPR:  				{  					int LA9_2 = input.LA (2);  					if ((LA9_2 == DOWN)) {  						int LA9_3 = input.LA (3);  						if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  							alt9 = 2;  						}  						else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  							alt9 = 3;  						}  						else {  							NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  							DebugRecognitionException (nvae);  							throw nvae;  						}  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				break;  			case STRING:  				{  					alt9 = 4;  				}  				break;  			case REGEX:  				{  					alt9 = 5;  				}  				break;  			case NUMBER:  				{  					alt9 = 6;  				}  				break;  			case TRUE:  				{  					alt9 = 7;  				}  				break;  			case FALSE:  				{  					alt9 = 8;  				}  				break;  			case NULL:  				{  					alt9 = 9;  				}  				break;  			default: {  				NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  			}  		}  		finally {  			DebugExitDecision (9);  		}  		switch (alt9) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  			{  				DebugLocation (64' 4);  				DebugLocation (64' 6);  				PushFollow (Follow._comparator_in_filterExpr175);  				comparator6 = comparator ();  				PopFollow ();  				Match (input' TokenTypes.Down' null);  				DebugLocation (64' 18);  				PushFollow (Follow._filterExpr_in_filterExpr179);  				a = filterExpr ();  				PopFollow ();  				DebugLocation (64' 31);  				PushFollow (Follow._filterExpr_in_filterExpr183);  				b = filterExpr ();  				PopFollow ();  				Match (input' TokenTypes.Up' null);  				DebugLocation (65' 4);  				Comparator newComparator;  				switch (comparator6) {  				case "=":  					newComparator = Comparator.Equals;  					break;  				case "!=":  					newComparator = Comparator.NotEquals;  					break;  				case ">":  					newComparator = Comparator.Greater;  					break;  				case "<":  					newComparator = Comparator.Less;  					break;  				case ">=":  					newComparator = Comparator.GreaterOrEqual;  					break;  				case "<=":  					newComparator = Comparator.LessOrEqual;  					break;  				case "&":  					newComparator = Comparator.And;  					break;  				case "|":  					newComparator = Comparator.Or;  					break;  				default:  					newComparator = Comparator.Equals;  					break;  				}  				filterNode = new BoolExpression (a' newComparator' b);  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  			{  				DebugLocation (98' 4);  				DebugLocation (98' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr195);  				Match (input' TokenTypes.Down' null);  				DebugLocation (98' 12);  				PushFollow (Follow._filterExpr_in_filterExpr199);  				f = filterExpr ();  				PopFollow ();  				DebugLocation (98' 31);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  				int alt6 = 2;  				try {  					DebugEnterSubRule (6);  					try {  						DebugEnterDecision (6' false);  						int LA6_1 = input.LA (1);  						if ((LA6_1 == 24)) {  							alt6 = 1;  						}  					}  					finally {  						DebugExitDecision (6);  					}  					switch (alt6) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  						{  							DebugLocation (98' 31);  							inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (6);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (99' 4);  				FilterTreeNode newNode = f;  				if ((inverse != null ? inverse.Text : default(string)) == "!")  					newNode.ToggleInversed ();  				filterNode = newNode;  			}  			break;  		case 3:  			DebugEnterAlt (3);  			// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  			{  				DebugLocation (105' 4);  				DebugLocation (105' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr216);  				Match (input' TokenTypes.Down' null);  				DebugLocation (105' 12);  				PushFollow (Follow._propertyChain_in_filterExpr219);  				propertyChain (propertySegments);  				PopFollow ();  				DebugLocation (105' 51);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  				int alt7 = 2;  				try {  					DebugEnterSubRule (7);  					try {  						DebugEnterDecision (7' false);  						int LA7_1 = input.LA (1);  						if ((LA7_1 == 31)) {  							alt7 = 1;  						}  					}  					finally {  						DebugExitDecision (7);  					}  					switch (alt7) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  						{  							DebugLocation (105' 51);  							inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (7);  				}  				DebugLocation (105' 60);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  				int alt8 = 2;  				try {  					DebugEnterSubRule (8);  					try {  						DebugEnterDecision (8' false);  						int LA8_1 = input.LA (1);  						if ((LA8_1 == 24)) {  							alt8 = 1;  						}  					}  					finally {  						DebugExitDecision (8);  					}  					switch (alt8) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  						{  							DebugLocation (105' 60);  							not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (8);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (106' 4);  				FilterTreeNode newProperty = new Property (propertySegments);  				if ((inverse != null ? inverse.Text : default(string)) == "?")  					filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  				else {  					if ((not != null ? not.Text : default(string)) == "!")  						newProperty.ToggleInversed ();  					filterNode = newProperty;  				}  			}  			break;  		case 4:  			DebugEnterAlt (4);  			// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  			{  				DebugLocation (116' 4);  				STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  				DebugLocation (117' 4);  				string stringText = (STRING7 != null ? STRING7.Text : default(string));  				stringText = stringText.Substring (1' stringText.Length - 2);  				filterNode = new Value (stringText);  			}  			break;  		case 5:  			DebugEnterAlt (5);  			// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  			{  				DebugLocation (122' 4);  				REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  				DebugLocation (123' 4);  				string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  				regexText = regexText.Substring (1' regexText.Length - 2);  				filterNode = new RegExp (regexText);  			}  			break;  		case 6:  			DebugEnterAlt (6);  			// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  			{  				DebugLocation (128' 4);  				NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  				DebugLocation (129' 4);  				filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  			}  			break;  		case 7:  			DebugEnterAlt (7);  			// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  			{  				DebugLocation (132' 4);  				Match (input' TRUE' Follow._TRUE_in_filterExpr271);  				DebugLocation (133' 4);  				filterNode = new Value (true);  			}  			break;  		case 8:  			DebugEnterAlt (8);  			// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  			{  				DebugLocation (136' 4);  				Match (input' FALSE' Follow._FALSE_in_filterExpr281);  				DebugLocation (137' 4);  				filterNode = new Value (false);  			}  			break;  		case 9:  			DebugEnterAlt (9);  			// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  			{  				DebugLocation (140' 4);  				Match (input' NULL' Follow._NULL_in_filterExpr291);  				DebugLocation (141' 4);  				filterNode = new Value (null);  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("filterExpr"' 6);  		LeaveRule ("filterExpr"' 6);  		LeaveRule_filterExpr ();  	}  	DebugLocation (144' 1);  }  finally {  	DebugExitRule (GrammarFileName' "filterExpr");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "filterExpr");  	DebugLocation (60' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  		int alt9 = 9;  		try {  			DebugEnterDecision (9' false);  			switch (input.LA (1)) {  			case CHAIN_OPERATOR:  			case COMPARATOR:  				{  					alt9 = 1;  				}  				break;  			case EXPR:  				{  					int LA9_2 = input.LA (2);  					if ((LA9_2 == DOWN)) {  						int LA9_3 = input.LA (3);  						if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  							alt9 = 2;  						}  						else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  							alt9 = 3;  						}  						else {  							NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  							DebugRecognitionException (nvae);  							throw nvae;  						}  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				break;  			case STRING:  				{  					alt9 = 4;  				}  				break;  			case REGEX:  				{  					alt9 = 5;  				}  				break;  			case NUMBER:  				{  					alt9 = 6;  				}  				break;  			case TRUE:  				{  					alt9 = 7;  				}  				break;  			case FALSE:  				{  					alt9 = 8;  				}  				break;  			case NULL:  				{  					alt9 = 9;  				}  				break;  			default: {  				NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  			}  		}  		finally {  			DebugExitDecision (9);  		}  		switch (alt9) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  			{  				DebugLocation (64' 4);  				DebugLocation (64' 6);  				PushFollow (Follow._comparator_in_filterExpr175);  				comparator6 = comparator ();  				PopFollow ();  				Match (input' TokenTypes.Down' null);  				DebugLocation (64' 18);  				PushFollow (Follow._filterExpr_in_filterExpr179);  				a = filterExpr ();  				PopFollow ();  				DebugLocation (64' 31);  				PushFollow (Follow._filterExpr_in_filterExpr183);  				b = filterExpr ();  				PopFollow ();  				Match (input' TokenTypes.Up' null);  				DebugLocation (65' 4);  				Comparator newComparator;  				switch (comparator6) {  				case "=":  					newComparator = Comparator.Equals;  					break;  				case "!=":  					newComparator = Comparator.NotEquals;  					break;  				case ">":  					newComparator = Comparator.Greater;  					break;  				case "<":  					newComparator = Comparator.Less;  					break;  				case ">=":  					newComparator = Comparator.GreaterOrEqual;  					break;  				case "<=":  					newComparator = Comparator.LessOrEqual;  					break;  				case "&":  					newComparator = Comparator.And;  					break;  				case "|":  					newComparator = Comparator.Or;  					break;  				default:  					newComparator = Comparator.Equals;  					break;  				}  				filterNode = new BoolExpression (a' newComparator' b);  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  			{  				DebugLocation (98' 4);  				DebugLocation (98' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr195);  				Match (input' TokenTypes.Down' null);  				DebugLocation (98' 12);  				PushFollow (Follow._filterExpr_in_filterExpr199);  				f = filterExpr ();  				PopFollow ();  				DebugLocation (98' 31);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  				int alt6 = 2;  				try {  					DebugEnterSubRule (6);  					try {  						DebugEnterDecision (6' false);  						int LA6_1 = input.LA (1);  						if ((LA6_1 == 24)) {  							alt6 = 1;  						}  					}  					finally {  						DebugExitDecision (6);  					}  					switch (alt6) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  						{  							DebugLocation (98' 31);  							inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (6);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (99' 4);  				FilterTreeNode newNode = f;  				if ((inverse != null ? inverse.Text : default(string)) == "!")  					newNode.ToggleInversed ();  				filterNode = newNode;  			}  			break;  		case 3:  			DebugEnterAlt (3);  			// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  			{  				DebugLocation (105' 4);  				DebugLocation (105' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr216);  				Match (input' TokenTypes.Down' null);  				DebugLocation (105' 12);  				PushFollow (Follow._propertyChain_in_filterExpr219);  				propertyChain (propertySegments);  				PopFollow ();  				DebugLocation (105' 51);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  				int alt7 = 2;  				try {  					DebugEnterSubRule (7);  					try {  						DebugEnterDecision (7' false);  						int LA7_1 = input.LA (1);  						if ((LA7_1 == 31)) {  							alt7 = 1;  						}  					}  					finally {  						DebugExitDecision (7);  					}  					switch (alt7) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  						{  							DebugLocation (105' 51);  							inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (7);  				}  				DebugLocation (105' 60);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  				int alt8 = 2;  				try {  					DebugEnterSubRule (8);  					try {  						DebugEnterDecision (8' false);  						int LA8_1 = input.LA (1);  						if ((LA8_1 == 24)) {  							alt8 = 1;  						}  					}  					finally {  						DebugExitDecision (8);  					}  					switch (alt8) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  						{  							DebugLocation (105' 60);  							not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (8);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (106' 4);  				FilterTreeNode newProperty = new Property (propertySegments);  				if ((inverse != null ? inverse.Text : default(string)) == "?")  					filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  				else {  					if ((not != null ? not.Text : default(string)) == "!")  						newProperty.ToggleInversed ();  					filterNode = newProperty;  				}  			}  			break;  		case 4:  			DebugEnterAlt (4);  			// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  			{  				DebugLocation (116' 4);  				STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  				DebugLocation (117' 4);  				string stringText = (STRING7 != null ? STRING7.Text : default(string));  				stringText = stringText.Substring (1' stringText.Length - 2);  				filterNode = new Value (stringText);  			}  			break;  		case 5:  			DebugEnterAlt (5);  			// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  			{  				DebugLocation (122' 4);  				REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  				DebugLocation (123' 4);  				string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  				regexText = regexText.Substring (1' regexText.Length - 2);  				filterNode = new RegExp (regexText);  			}  			break;  		case 6:  			DebugEnterAlt (6);  			// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  			{  				DebugLocation (128' 4);  				NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  				DebugLocation (129' 4);  				filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  			}  			break;  		case 7:  			DebugEnterAlt (7);  			// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  			{  				DebugLocation (132' 4);  				Match (input' TRUE' Follow._TRUE_in_filterExpr271);  				DebugLocation (133' 4);  				filterNode = new Value (true);  			}  			break;  		case 8:  			DebugEnterAlt (8);  			// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  			{  				DebugLocation (136' 4);  				Match (input' FALSE' Follow._FALSE_in_filterExpr281);  				DebugLocation (137' 4);  				filterNode = new Value (false);  			}  			break;  		case 9:  			DebugEnterAlt (9);  			// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  			{  				DebugLocation (140' 4);  				Match (input' NULL' Follow._NULL_in_filterExpr291);  				DebugLocation (141' 4);  				filterNode = new Value (null);  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("filterExpr"' 6);  		LeaveRule ("filterExpr"' 6);  		LeaveRule_filterExpr ();  	}  	DebugLocation (144' 1);  }  finally {  	DebugExitRule (GrammarFileName' "filterExpr");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "filterExpr");  	DebugLocation (60' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  		int alt9 = 9;  		try {  			DebugEnterDecision (9' false);  			switch (input.LA (1)) {  			case CHAIN_OPERATOR:  			case COMPARATOR:  				{  					alt9 = 1;  				}  				break;  			case EXPR:  				{  					int LA9_2 = input.LA (2);  					if ((LA9_2 == DOWN)) {  						int LA9_3 = input.LA (3);  						if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  							alt9 = 2;  						}  						else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  							alt9 = 3;  						}  						else {  							NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  							DebugRecognitionException (nvae);  							throw nvae;  						}  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				break;  			case STRING:  				{  					alt9 = 4;  				}  				break;  			case REGEX:  				{  					alt9 = 5;  				}  				break;  			case NUMBER:  				{  					alt9 = 6;  				}  				break;  			case TRUE:  				{  					alt9 = 7;  				}  				break;  			case FALSE:  				{  					alt9 = 8;  				}  				break;  			case NULL:  				{  					alt9 = 9;  				}  				break;  			default: {  				NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  			}  		}  		finally {  			DebugExitDecision (9);  		}  		switch (alt9) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  			{  				DebugLocation (64' 4);  				DebugLocation (64' 6);  				PushFollow (Follow._comparator_in_filterExpr175);  				comparator6 = comparator ();  				PopFollow ();  				Match (input' TokenTypes.Down' null);  				DebugLocation (64' 18);  				PushFollow (Follow._filterExpr_in_filterExpr179);  				a = filterExpr ();  				PopFollow ();  				DebugLocation (64' 31);  				PushFollow (Follow._filterExpr_in_filterExpr183);  				b = filterExpr ();  				PopFollow ();  				Match (input' TokenTypes.Up' null);  				DebugLocation (65' 4);  				Comparator newComparator;  				switch (comparator6) {  				case "=":  					newComparator = Comparator.Equals;  					break;  				case "!=":  					newComparator = Comparator.NotEquals;  					break;  				case ">":  					newComparator = Comparator.Greater;  					break;  				case "<":  					newComparator = Comparator.Less;  					break;  				case ">=":  					newComparator = Comparator.GreaterOrEqual;  					break;  				case "<=":  					newComparator = Comparator.LessOrEqual;  					break;  				case "&":  					newComparator = Comparator.And;  					break;  				case "|":  					newComparator = Comparator.Or;  					break;  				default:  					newComparator = Comparator.Equals;  					break;  				}  				filterNode = new BoolExpression (a' newComparator' b);  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  			{  				DebugLocation (98' 4);  				DebugLocation (98' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr195);  				Match (input' TokenTypes.Down' null);  				DebugLocation (98' 12);  				PushFollow (Follow._filterExpr_in_filterExpr199);  				f = filterExpr ();  				PopFollow ();  				DebugLocation (98' 31);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  				int alt6 = 2;  				try {  					DebugEnterSubRule (6);  					try {  						DebugEnterDecision (6' false);  						int LA6_1 = input.LA (1);  						if ((LA6_1 == 24)) {  							alt6 = 1;  						}  					}  					finally {  						DebugExitDecision (6);  					}  					switch (alt6) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  						{  							DebugLocation (98' 31);  							inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (6);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (99' 4);  				FilterTreeNode newNode = f;  				if ((inverse != null ? inverse.Text : default(string)) == "!")  					newNode.ToggleInversed ();  				filterNode = newNode;  			}  			break;  		case 3:  			DebugEnterAlt (3);  			// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  			{  				DebugLocation (105' 4);  				DebugLocation (105' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr216);  				Match (input' TokenTypes.Down' null);  				DebugLocation (105' 12);  				PushFollow (Follow._propertyChain_in_filterExpr219);  				propertyChain (propertySegments);  				PopFollow ();  				DebugLocation (105' 51);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  				int alt7 = 2;  				try {  					DebugEnterSubRule (7);  					try {  						DebugEnterDecision (7' false);  						int LA7_1 = input.LA (1);  						if ((LA7_1 == 31)) {  							alt7 = 1;  						}  					}  					finally {  						DebugExitDecision (7);  					}  					switch (alt7) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  						{  							DebugLocation (105' 51);  							inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (7);  				}  				DebugLocation (105' 60);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  				int alt8 = 2;  				try {  					DebugEnterSubRule (8);  					try {  						DebugEnterDecision (8' false);  						int LA8_1 = input.LA (1);  						if ((LA8_1 == 24)) {  							alt8 = 1;  						}  					}  					finally {  						DebugExitDecision (8);  					}  					switch (alt8) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  						{  							DebugLocation (105' 60);  							not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (8);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (106' 4);  				FilterTreeNode newProperty = new Property (propertySegments);  				if ((inverse != null ? inverse.Text : default(string)) == "?")  					filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  				else {  					if ((not != null ? not.Text : default(string)) == "!")  						newProperty.ToggleInversed ();  					filterNode = newProperty;  				}  			}  			break;  		case 4:  			DebugEnterAlt (4);  			// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  			{  				DebugLocation (116' 4);  				STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  				DebugLocation (117' 4);  				string stringText = (STRING7 != null ? STRING7.Text : default(string));  				stringText = stringText.Substring (1' stringText.Length - 2);  				filterNode = new Value (stringText);  			}  			break;  		case 5:  			DebugEnterAlt (5);  			// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  			{  				DebugLocation (122' 4);  				REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  				DebugLocation (123' 4);  				string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  				regexText = regexText.Substring (1' regexText.Length - 2);  				filterNode = new RegExp (regexText);  			}  			break;  		case 6:  			DebugEnterAlt (6);  			// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  			{  				DebugLocation (128' 4);  				NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  				DebugLocation (129' 4);  				filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  			}  			break;  		case 7:  			DebugEnterAlt (7);  			// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  			{  				DebugLocation (132' 4);  				Match (input' TRUE' Follow._TRUE_in_filterExpr271);  				DebugLocation (133' 4);  				filterNode = new Value (true);  			}  			break;  		case 8:  			DebugEnterAlt (8);  			// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  			{  				DebugLocation (136' 4);  				Match (input' FALSE' Follow._FALSE_in_filterExpr281);  				DebugLocation (137' 4);  				filterNode = new Value (false);  			}  			break;  		case 9:  			DebugEnterAlt (9);  			// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  			{  				DebugLocation (140' 4);  				Match (input' NULL' Follow._NULL_in_filterExpr291);  				DebugLocation (141' 4);  				filterNode = new Value (null);  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("filterExpr"' 6);  		LeaveRule ("filterExpr"' 6);  		LeaveRule_filterExpr ();  	}  	DebugLocation (144' 1);  }  finally {  	DebugExitRule (GrammarFileName' "filterExpr");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "filterExpr");  	DebugLocation (60' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  		int alt9 = 9;  		try {  			DebugEnterDecision (9' false);  			switch (input.LA (1)) {  			case CHAIN_OPERATOR:  			case COMPARATOR:  				{  					alt9 = 1;  				}  				break;  			case EXPR:  				{  					int LA9_2 = input.LA (2);  					if ((LA9_2 == DOWN)) {  						int LA9_3 = input.LA (3);  						if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  							alt9 = 2;  						}  						else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  							alt9 = 3;  						}  						else {  							NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  							DebugRecognitionException (nvae);  							throw nvae;  						}  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				break;  			case STRING:  				{  					alt9 = 4;  				}  				break;  			case REGEX:  				{  					alt9 = 5;  				}  				break;  			case NUMBER:  				{  					alt9 = 6;  				}  				break;  			case TRUE:  				{  					alt9 = 7;  				}  				break;  			case FALSE:  				{  					alt9 = 8;  				}  				break;  			case NULL:  				{  					alt9 = 9;  				}  				break;  			default: {  				NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  			}  		}  		finally {  			DebugExitDecision (9);  		}  		switch (alt9) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  			{  				DebugLocation (64' 4);  				DebugLocation (64' 6);  				PushFollow (Follow._comparator_in_filterExpr175);  				comparator6 = comparator ();  				PopFollow ();  				Match (input' TokenTypes.Down' null);  				DebugLocation (64' 18);  				PushFollow (Follow._filterExpr_in_filterExpr179);  				a = filterExpr ();  				PopFollow ();  				DebugLocation (64' 31);  				PushFollow (Follow._filterExpr_in_filterExpr183);  				b = filterExpr ();  				PopFollow ();  				Match (input' TokenTypes.Up' null);  				DebugLocation (65' 4);  				Comparator newComparator;  				switch (comparator6) {  				case "=":  					newComparator = Comparator.Equals;  					break;  				case "!=":  					newComparator = Comparator.NotEquals;  					break;  				case ">":  					newComparator = Comparator.Greater;  					break;  				case "<":  					newComparator = Comparator.Less;  					break;  				case ">=":  					newComparator = Comparator.GreaterOrEqual;  					break;  				case "<=":  					newComparator = Comparator.LessOrEqual;  					break;  				case "&":  					newComparator = Comparator.And;  					break;  				case "|":  					newComparator = Comparator.Or;  					break;  				default:  					newComparator = Comparator.Equals;  					break;  				}  				filterNode = new BoolExpression (a' newComparator' b);  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  			{  				DebugLocation (98' 4);  				DebugLocation (98' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr195);  				Match (input' TokenTypes.Down' null);  				DebugLocation (98' 12);  				PushFollow (Follow._filterExpr_in_filterExpr199);  				f = filterExpr ();  				PopFollow ();  				DebugLocation (98' 31);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  				int alt6 = 2;  				try {  					DebugEnterSubRule (6);  					try {  						DebugEnterDecision (6' false);  						int LA6_1 = input.LA (1);  						if ((LA6_1 == 24)) {  							alt6 = 1;  						}  					}  					finally {  						DebugExitDecision (6);  					}  					switch (alt6) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  						{  							DebugLocation (98' 31);  							inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (6);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (99' 4);  				FilterTreeNode newNode = f;  				if ((inverse != null ? inverse.Text : default(string)) == "!")  					newNode.ToggleInversed ();  				filterNode = newNode;  			}  			break;  		case 3:  			DebugEnterAlt (3);  			// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  			{  				DebugLocation (105' 4);  				DebugLocation (105' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr216);  				Match (input' TokenTypes.Down' null);  				DebugLocation (105' 12);  				PushFollow (Follow._propertyChain_in_filterExpr219);  				propertyChain (propertySegments);  				PopFollow ();  				DebugLocation (105' 51);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  				int alt7 = 2;  				try {  					DebugEnterSubRule (7);  					try {  						DebugEnterDecision (7' false);  						int LA7_1 = input.LA (1);  						if ((LA7_1 == 31)) {  							alt7 = 1;  						}  					}  					finally {  						DebugExitDecision (7);  					}  					switch (alt7) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  						{  							DebugLocation (105' 51);  							inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (7);  				}  				DebugLocation (105' 60);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  				int alt8 = 2;  				try {  					DebugEnterSubRule (8);  					try {  						DebugEnterDecision (8' false);  						int LA8_1 = input.LA (1);  						if ((LA8_1 == 24)) {  							alt8 = 1;  						}  					}  					finally {  						DebugExitDecision (8);  					}  					switch (alt8) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  						{  							DebugLocation (105' 60);  							not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (8);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (106' 4);  				FilterTreeNode newProperty = new Property (propertySegments);  				if ((inverse != null ? inverse.Text : default(string)) == "?")  					filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  				else {  					if ((not != null ? not.Text : default(string)) == "!")  						newProperty.ToggleInversed ();  					filterNode = newProperty;  				}  			}  			break;  		case 4:  			DebugEnterAlt (4);  			// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  			{  				DebugLocation (116' 4);  				STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  				DebugLocation (117' 4);  				string stringText = (STRING7 != null ? STRING7.Text : default(string));  				stringText = stringText.Substring (1' stringText.Length - 2);  				filterNode = new Value (stringText);  			}  			break;  		case 5:  			DebugEnterAlt (5);  			// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  			{  				DebugLocation (122' 4);  				REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  				DebugLocation (123' 4);  				string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  				regexText = regexText.Substring (1' regexText.Length - 2);  				filterNode = new RegExp (regexText);  			}  			break;  		case 6:  			DebugEnterAlt (6);  			// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  			{  				DebugLocation (128' 4);  				NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  				DebugLocation (129' 4);  				filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  			}  			break;  		case 7:  			DebugEnterAlt (7);  			// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  			{  				DebugLocation (132' 4);  				Match (input' TRUE' Follow._TRUE_in_filterExpr271);  				DebugLocation (133' 4);  				filterNode = new Value (true);  			}  			break;  		case 8:  			DebugEnterAlt (8);  			// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  			{  				DebugLocation (136' 4);  				Match (input' FALSE' Follow._FALSE_in_filterExpr281);  				DebugLocation (137' 4);  				filterNode = new Value (false);  			}  			break;  		case 9:  			DebugEnterAlt (9);  			// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  			{  				DebugLocation (140' 4);  				Match (input' NULL' Follow._NULL_in_filterExpr291);  				DebugLocation (141' 4);  				filterNode = new Value (null);  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("filterExpr"' 6);  		LeaveRule ("filterExpr"' 6);  		LeaveRule_filterExpr ();  	}  	DebugLocation (144' 1);  }  finally {  	DebugExitRule (GrammarFileName' "filterExpr");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "filterExpr");  	DebugLocation (60' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  		int alt9 = 9;  		try {  			DebugEnterDecision (9' false);  			switch (input.LA (1)) {  			case CHAIN_OPERATOR:  			case COMPARATOR:  				{  					alt9 = 1;  				}  				break;  			case EXPR:  				{  					int LA9_2 = input.LA (2);  					if ((LA9_2 == DOWN)) {  						int LA9_3 = input.LA (3);  						if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  							alt9 = 2;  						}  						else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  							alt9 = 3;  						}  						else {  							NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  							DebugRecognitionException (nvae);  							throw nvae;  						}  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				break;  			case STRING:  				{  					alt9 = 4;  				}  				break;  			case REGEX:  				{  					alt9 = 5;  				}  				break;  			case NUMBER:  				{  					alt9 = 6;  				}  				break;  			case TRUE:  				{  					alt9 = 7;  				}  				break;  			case FALSE:  				{  					alt9 = 8;  				}  				break;  			case NULL:  				{  					alt9 = 9;  				}  				break;  			default: {  				NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  			}  		}  		finally {  			DebugExitDecision (9);  		}  		switch (alt9) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  			{  				DebugLocation (64' 4);  				DebugLocation (64' 6);  				PushFollow (Follow._comparator_in_filterExpr175);  				comparator6 = comparator ();  				PopFollow ();  				Match (input' TokenTypes.Down' null);  				DebugLocation (64' 18);  				PushFollow (Follow._filterExpr_in_filterExpr179);  				a = filterExpr ();  				PopFollow ();  				DebugLocation (64' 31);  				PushFollow (Follow._filterExpr_in_filterExpr183);  				b = filterExpr ();  				PopFollow ();  				Match (input' TokenTypes.Up' null);  				DebugLocation (65' 4);  				Comparator newComparator;  				switch (comparator6) {  				case "=":  					newComparator = Comparator.Equals;  					break;  				case "!=":  					newComparator = Comparator.NotEquals;  					break;  				case ">":  					newComparator = Comparator.Greater;  					break;  				case "<":  					newComparator = Comparator.Less;  					break;  				case ">=":  					newComparator = Comparator.GreaterOrEqual;  					break;  				case "<=":  					newComparator = Comparator.LessOrEqual;  					break;  				case "&":  					newComparator = Comparator.And;  					break;  				case "|":  					newComparator = Comparator.Or;  					break;  				default:  					newComparator = Comparator.Equals;  					break;  				}  				filterNode = new BoolExpression (a' newComparator' b);  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  			{  				DebugLocation (98' 4);  				DebugLocation (98' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr195);  				Match (input' TokenTypes.Down' null);  				DebugLocation (98' 12);  				PushFollow (Follow._filterExpr_in_filterExpr199);  				f = filterExpr ();  				PopFollow ();  				DebugLocation (98' 31);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  				int alt6 = 2;  				try {  					DebugEnterSubRule (6);  					try {  						DebugEnterDecision (6' false);  						int LA6_1 = input.LA (1);  						if ((LA6_1 == 24)) {  							alt6 = 1;  						}  					}  					finally {  						DebugExitDecision (6);  					}  					switch (alt6) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  						{  							DebugLocation (98' 31);  							inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (6);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (99' 4);  				FilterTreeNode newNode = f;  				if ((inverse != null ? inverse.Text : default(string)) == "!")  					newNode.ToggleInversed ();  				filterNode = newNode;  			}  			break;  		case 3:  			DebugEnterAlt (3);  			// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  			{  				DebugLocation (105' 4);  				DebugLocation (105' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr216);  				Match (input' TokenTypes.Down' null);  				DebugLocation (105' 12);  				PushFollow (Follow._propertyChain_in_filterExpr219);  				propertyChain (propertySegments);  				PopFollow ();  				DebugLocation (105' 51);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  				int alt7 = 2;  				try {  					DebugEnterSubRule (7);  					try {  						DebugEnterDecision (7' false);  						int LA7_1 = input.LA (1);  						if ((LA7_1 == 31)) {  							alt7 = 1;  						}  					}  					finally {  						DebugExitDecision (7);  					}  					switch (alt7) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  						{  							DebugLocation (105' 51);  							inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (7);  				}  				DebugLocation (105' 60);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  				int alt8 = 2;  				try {  					DebugEnterSubRule (8);  					try {  						DebugEnterDecision (8' false);  						int LA8_1 = input.LA (1);  						if ((LA8_1 == 24)) {  							alt8 = 1;  						}  					}  					finally {  						DebugExitDecision (8);  					}  					switch (alt8) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  						{  							DebugLocation (105' 60);  							not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (8);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (106' 4);  				FilterTreeNode newProperty = new Property (propertySegments);  				if ((inverse != null ? inverse.Text : default(string)) == "?")  					filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  				else {  					if ((not != null ? not.Text : default(string)) == "!")  						newProperty.ToggleInversed ();  					filterNode = newProperty;  				}  			}  			break;  		case 4:  			DebugEnterAlt (4);  			// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  			{  				DebugLocation (116' 4);  				STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  				DebugLocation (117' 4);  				string stringText = (STRING7 != null ? STRING7.Text : default(string));  				stringText = stringText.Substring (1' stringText.Length - 2);  				filterNode = new Value (stringText);  			}  			break;  		case 5:  			DebugEnterAlt (5);  			// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  			{  				DebugLocation (122' 4);  				REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  				DebugLocation (123' 4);  				string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  				regexText = regexText.Substring (1' regexText.Length - 2);  				filterNode = new RegExp (regexText);  			}  			break;  		case 6:  			DebugEnterAlt (6);  			// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  			{  				DebugLocation (128' 4);  				NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  				DebugLocation (129' 4);  				filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  			}  			break;  		case 7:  			DebugEnterAlt (7);  			// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  			{  				DebugLocation (132' 4);  				Match (input' TRUE' Follow._TRUE_in_filterExpr271);  				DebugLocation (133' 4);  				filterNode = new Value (true);  			}  			break;  		case 8:  			DebugEnterAlt (8);  			// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  			{  				DebugLocation (136' 4);  				Match (input' FALSE' Follow._FALSE_in_filterExpr281);  				DebugLocation (137' 4);  				filterNode = new Value (false);  			}  			break;  		case 9:  			DebugEnterAlt (9);  			// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  			{  				DebugLocation (140' 4);  				Match (input' NULL' Follow._NULL_in_filterExpr291);  				DebugLocation (141' 4);  				filterNode = new Value (null);  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("filterExpr"' 6);  		LeaveRule ("filterExpr"' 6);  		LeaveRule_filterExpr ();  	}  	DebugLocation (144' 1);  }  finally {  	DebugExitRule (GrammarFileName' "filterExpr");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "filterExpr");  	DebugLocation (60' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  		int alt9 = 9;  		try {  			DebugEnterDecision (9' false);  			switch (input.LA (1)) {  			case CHAIN_OPERATOR:  			case COMPARATOR:  				{  					alt9 = 1;  				}  				break;  			case EXPR:  				{  					int LA9_2 = input.LA (2);  					if ((LA9_2 == DOWN)) {  						int LA9_3 = input.LA (3);  						if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  							alt9 = 2;  						}  						else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  							alt9 = 3;  						}  						else {  							NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  							DebugRecognitionException (nvae);  							throw nvae;  						}  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				break;  			case STRING:  				{  					alt9 = 4;  				}  				break;  			case REGEX:  				{  					alt9 = 5;  				}  				break;  			case NUMBER:  				{  					alt9 = 6;  				}  				break;  			case TRUE:  				{  					alt9 = 7;  				}  				break;  			case FALSE:  				{  					alt9 = 8;  				}  				break;  			case NULL:  				{  					alt9 = 9;  				}  				break;  			default: {  				NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  			}  		}  		finally {  			DebugExitDecision (9);  		}  		switch (alt9) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  			{  				DebugLocation (64' 4);  				DebugLocation (64' 6);  				PushFollow (Follow._comparator_in_filterExpr175);  				comparator6 = comparator ();  				PopFollow ();  				Match (input' TokenTypes.Down' null);  				DebugLocation (64' 18);  				PushFollow (Follow._filterExpr_in_filterExpr179);  				a = filterExpr ();  				PopFollow ();  				DebugLocation (64' 31);  				PushFollow (Follow._filterExpr_in_filterExpr183);  				b = filterExpr ();  				PopFollow ();  				Match (input' TokenTypes.Up' null);  				DebugLocation (65' 4);  				Comparator newComparator;  				switch (comparator6) {  				case "=":  					newComparator = Comparator.Equals;  					break;  				case "!=":  					newComparator = Comparator.NotEquals;  					break;  				case ">":  					newComparator = Comparator.Greater;  					break;  				case "<":  					newComparator = Comparator.Less;  					break;  				case ">=":  					newComparator = Comparator.GreaterOrEqual;  					break;  				case "<=":  					newComparator = Comparator.LessOrEqual;  					break;  				case "&":  					newComparator = Comparator.And;  					break;  				case "|":  					newComparator = Comparator.Or;  					break;  				default:  					newComparator = Comparator.Equals;  					break;  				}  				filterNode = new BoolExpression (a' newComparator' b);  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  			{  				DebugLocation (98' 4);  				DebugLocation (98' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr195);  				Match (input' TokenTypes.Down' null);  				DebugLocation (98' 12);  				PushFollow (Follow._filterExpr_in_filterExpr199);  				f = filterExpr ();  				PopFollow ();  				DebugLocation (98' 31);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  				int alt6 = 2;  				try {  					DebugEnterSubRule (6);  					try {  						DebugEnterDecision (6' false);  						int LA6_1 = input.LA (1);  						if ((LA6_1 == 24)) {  							alt6 = 1;  						}  					}  					finally {  						DebugExitDecision (6);  					}  					switch (alt6) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  						{  							DebugLocation (98' 31);  							inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (6);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (99' 4);  				FilterTreeNode newNode = f;  				if ((inverse != null ? inverse.Text : default(string)) == "!")  					newNode.ToggleInversed ();  				filterNode = newNode;  			}  			break;  		case 3:  			DebugEnterAlt (3);  			// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  			{  				DebugLocation (105' 4);  				DebugLocation (105' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr216);  				Match (input' TokenTypes.Down' null);  				DebugLocation (105' 12);  				PushFollow (Follow._propertyChain_in_filterExpr219);  				propertyChain (propertySegments);  				PopFollow ();  				DebugLocation (105' 51);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  				int alt7 = 2;  				try {  					DebugEnterSubRule (7);  					try {  						DebugEnterDecision (7' false);  						int LA7_1 = input.LA (1);  						if ((LA7_1 == 31)) {  							alt7 = 1;  						}  					}  					finally {  						DebugExitDecision (7);  					}  					switch (alt7) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  						{  							DebugLocation (105' 51);  							inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (7);  				}  				DebugLocation (105' 60);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  				int alt8 = 2;  				try {  					DebugEnterSubRule (8);  					try {  						DebugEnterDecision (8' false);  						int LA8_1 = input.LA (1);  						if ((LA8_1 == 24)) {  							alt8 = 1;  						}  					}  					finally {  						DebugExitDecision (8);  					}  					switch (alt8) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  						{  							DebugLocation (105' 60);  							not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (8);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (106' 4);  				FilterTreeNode newProperty = new Property (propertySegments);  				if ((inverse != null ? inverse.Text : default(string)) == "?")  					filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  				else {  					if ((not != null ? not.Text : default(string)) == "!")  						newProperty.ToggleInversed ();  					filterNode = newProperty;  				}  			}  			break;  		case 4:  			DebugEnterAlt (4);  			// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  			{  				DebugLocation (116' 4);  				STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  				DebugLocation (117' 4);  				string stringText = (STRING7 != null ? STRING7.Text : default(string));  				stringText = stringText.Substring (1' stringText.Length - 2);  				filterNode = new Value (stringText);  			}  			break;  		case 5:  			DebugEnterAlt (5);  			// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  			{  				DebugLocation (122' 4);  				REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  				DebugLocation (123' 4);  				string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  				regexText = regexText.Substring (1' regexText.Length - 2);  				filterNode = new RegExp (regexText);  			}  			break;  		case 6:  			DebugEnterAlt (6);  			// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  			{  				DebugLocation (128' 4);  				NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  				DebugLocation (129' 4);  				filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  			}  			break;  		case 7:  			DebugEnterAlt (7);  			// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  			{  				DebugLocation (132' 4);  				Match (input' TRUE' Follow._TRUE_in_filterExpr271);  				DebugLocation (133' 4);  				filterNode = new Value (true);  			}  			break;  		case 8:  			DebugEnterAlt (8);  			// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  			{  				DebugLocation (136' 4);  				Match (input' FALSE' Follow._FALSE_in_filterExpr281);  				DebugLocation (137' 4);  				filterNode = new Value (false);  			}  			break;  		case 9:  			DebugEnterAlt (9);  			// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  			{  				DebugLocation (140' 4);  				Match (input' NULL' Follow._NULL_in_filterExpr291);  				DebugLocation (141' 4);  				filterNode = new Value (null);  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("filterExpr"' 6);  		LeaveRule ("filterExpr"' 6);  		LeaveRule_filterExpr ();  	}  	DebugLocation (144' 1);  }  finally {  	DebugExitRule (GrammarFileName' "filterExpr");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "filterExpr");  	DebugLocation (60' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  		int alt9 = 9;  		try {  			DebugEnterDecision (9' false);  			switch (input.LA (1)) {  			case CHAIN_OPERATOR:  			case COMPARATOR:  				{  					alt9 = 1;  				}  				break;  			case EXPR:  				{  					int LA9_2 = input.LA (2);  					if ((LA9_2 == DOWN)) {  						int LA9_3 = input.LA (3);  						if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  							alt9 = 2;  						}  						else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  							alt9 = 3;  						}  						else {  							NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  							DebugRecognitionException (nvae);  							throw nvae;  						}  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				break;  			case STRING:  				{  					alt9 = 4;  				}  				break;  			case REGEX:  				{  					alt9 = 5;  				}  				break;  			case NUMBER:  				{  					alt9 = 6;  				}  				break;  			case TRUE:  				{  					alt9 = 7;  				}  				break;  			case FALSE:  				{  					alt9 = 8;  				}  				break;  			case NULL:  				{  					alt9 = 9;  				}  				break;  			default: {  				NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  			}  		}  		finally {  			DebugExitDecision (9);  		}  		switch (alt9) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  			{  				DebugLocation (64' 4);  				DebugLocation (64' 6);  				PushFollow (Follow._comparator_in_filterExpr175);  				comparator6 = comparator ();  				PopFollow ();  				Match (input' TokenTypes.Down' null);  				DebugLocation (64' 18);  				PushFollow (Follow._filterExpr_in_filterExpr179);  				a = filterExpr ();  				PopFollow ();  				DebugLocation (64' 31);  				PushFollow (Follow._filterExpr_in_filterExpr183);  				b = filterExpr ();  				PopFollow ();  				Match (input' TokenTypes.Up' null);  				DebugLocation (65' 4);  				Comparator newComparator;  				switch (comparator6) {  				case "=":  					newComparator = Comparator.Equals;  					break;  				case "!=":  					newComparator = Comparator.NotEquals;  					break;  				case ">":  					newComparator = Comparator.Greater;  					break;  				case "<":  					newComparator = Comparator.Less;  					break;  				case ">=":  					newComparator = Comparator.GreaterOrEqual;  					break;  				case "<=":  					newComparator = Comparator.LessOrEqual;  					break;  				case "&":  					newComparator = Comparator.And;  					break;  				case "|":  					newComparator = Comparator.Or;  					break;  				default:  					newComparator = Comparator.Equals;  					break;  				}  				filterNode = new BoolExpression (a' newComparator' b);  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  			{  				DebugLocation (98' 4);  				DebugLocation (98' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr195);  				Match (input' TokenTypes.Down' null);  				DebugLocation (98' 12);  				PushFollow (Follow._filterExpr_in_filterExpr199);  				f = filterExpr ();  				PopFollow ();  				DebugLocation (98' 31);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  				int alt6 = 2;  				try {  					DebugEnterSubRule (6);  					try {  						DebugEnterDecision (6' false);  						int LA6_1 = input.LA (1);  						if ((LA6_1 == 24)) {  							alt6 = 1;  						}  					}  					finally {  						DebugExitDecision (6);  					}  					switch (alt6) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  						{  							DebugLocation (98' 31);  							inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (6);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (99' 4);  				FilterTreeNode newNode = f;  				if ((inverse != null ? inverse.Text : default(string)) == "!")  					newNode.ToggleInversed ();  				filterNode = newNode;  			}  			break;  		case 3:  			DebugEnterAlt (3);  			// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  			{  				DebugLocation (105' 4);  				DebugLocation (105' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr216);  				Match (input' TokenTypes.Down' null);  				DebugLocation (105' 12);  				PushFollow (Follow._propertyChain_in_filterExpr219);  				propertyChain (propertySegments);  				PopFollow ();  				DebugLocation (105' 51);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  				int alt7 = 2;  				try {  					DebugEnterSubRule (7);  					try {  						DebugEnterDecision (7' false);  						int LA7_1 = input.LA (1);  						if ((LA7_1 == 31)) {  							alt7 = 1;  						}  					}  					finally {  						DebugExitDecision (7);  					}  					switch (alt7) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  						{  							DebugLocation (105' 51);  							inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (7);  				}  				DebugLocation (105' 60);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  				int alt8 = 2;  				try {  					DebugEnterSubRule (8);  					try {  						DebugEnterDecision (8' false);  						int LA8_1 = input.LA (1);  						if ((LA8_1 == 24)) {  							alt8 = 1;  						}  					}  					finally {  						DebugExitDecision (8);  					}  					switch (alt8) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  						{  							DebugLocation (105' 60);  							not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (8);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (106' 4);  				FilterTreeNode newProperty = new Property (propertySegments);  				if ((inverse != null ? inverse.Text : default(string)) == "?")  					filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  				else {  					if ((not != null ? not.Text : default(string)) == "!")  						newProperty.ToggleInversed ();  					filterNode = newProperty;  				}  			}  			break;  		case 4:  			DebugEnterAlt (4);  			// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  			{  				DebugLocation (116' 4);  				STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  				DebugLocation (117' 4);  				string stringText = (STRING7 != null ? STRING7.Text : default(string));  				stringText = stringText.Substring (1' stringText.Length - 2);  				filterNode = new Value (stringText);  			}  			break;  		case 5:  			DebugEnterAlt (5);  			// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  			{  				DebugLocation (122' 4);  				REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  				DebugLocation (123' 4);  				string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  				regexText = regexText.Substring (1' regexText.Length - 2);  				filterNode = new RegExp (regexText);  			}  			break;  		case 6:  			DebugEnterAlt (6);  			// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  			{  				DebugLocation (128' 4);  				NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  				DebugLocation (129' 4);  				filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  			}  			break;  		case 7:  			DebugEnterAlt (7);  			// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  			{  				DebugLocation (132' 4);  				Match (input' TRUE' Follow._TRUE_in_filterExpr271);  				DebugLocation (133' 4);  				filterNode = new Value (true);  			}  			break;  		case 8:  			DebugEnterAlt (8);  			// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  			{  				DebugLocation (136' 4);  				Match (input' FALSE' Follow._FALSE_in_filterExpr281);  				DebugLocation (137' 4);  				filterNode = new Value (false);  			}  			break;  		case 9:  			DebugEnterAlt (9);  			// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  			{  				DebugLocation (140' 4);  				Match (input' NULL' Follow._NULL_in_filterExpr291);  				DebugLocation (141' 4);  				filterNode = new Value (null);  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("filterExpr"' 6);  		LeaveRule ("filterExpr"' 6);  		LeaveRule_filterExpr ();  	}  	DebugLocation (144' 1);  }  finally {  	DebugExitRule (GrammarFileName' "filterExpr");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "filterExpr");  	DebugLocation (60' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  		int alt9 = 9;  		try {  			DebugEnterDecision (9' false);  			switch (input.LA (1)) {  			case CHAIN_OPERATOR:  			case COMPARATOR:  				{  					alt9 = 1;  				}  				break;  			case EXPR:  				{  					int LA9_2 = input.LA (2);  					if ((LA9_2 == DOWN)) {  						int LA9_3 = input.LA (3);  						if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  							alt9 = 2;  						}  						else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  							alt9 = 3;  						}  						else {  							NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  							DebugRecognitionException (nvae);  							throw nvae;  						}  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				break;  			case STRING:  				{  					alt9 = 4;  				}  				break;  			case REGEX:  				{  					alt9 = 5;  				}  				break;  			case NUMBER:  				{  					alt9 = 6;  				}  				break;  			case TRUE:  				{  					alt9 = 7;  				}  				break;  			case FALSE:  				{  					alt9 = 8;  				}  				break;  			case NULL:  				{  					alt9 = 9;  				}  				break;  			default: {  				NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  			}  		}  		finally {  			DebugExitDecision (9);  		}  		switch (alt9) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  			{  				DebugLocation (64' 4);  				DebugLocation (64' 6);  				PushFollow (Follow._comparator_in_filterExpr175);  				comparator6 = comparator ();  				PopFollow ();  				Match (input' TokenTypes.Down' null);  				DebugLocation (64' 18);  				PushFollow (Follow._filterExpr_in_filterExpr179);  				a = filterExpr ();  				PopFollow ();  				DebugLocation (64' 31);  				PushFollow (Follow._filterExpr_in_filterExpr183);  				b = filterExpr ();  				PopFollow ();  				Match (input' TokenTypes.Up' null);  				DebugLocation (65' 4);  				Comparator newComparator;  				switch (comparator6) {  				case "=":  					newComparator = Comparator.Equals;  					break;  				case "!=":  					newComparator = Comparator.NotEquals;  					break;  				case ">":  					newComparator = Comparator.Greater;  					break;  				case "<":  					newComparator = Comparator.Less;  					break;  				case ">=":  					newComparator = Comparator.GreaterOrEqual;  					break;  				case "<=":  					newComparator = Comparator.LessOrEqual;  					break;  				case "&":  					newComparator = Comparator.And;  					break;  				case "|":  					newComparator = Comparator.Or;  					break;  				default:  					newComparator = Comparator.Equals;  					break;  				}  				filterNode = new BoolExpression (a' newComparator' b);  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  			{  				DebugLocation (98' 4);  				DebugLocation (98' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr195);  				Match (input' TokenTypes.Down' null);  				DebugLocation (98' 12);  				PushFollow (Follow._filterExpr_in_filterExpr199);  				f = filterExpr ();  				PopFollow ();  				DebugLocation (98' 31);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  				int alt6 = 2;  				try {  					DebugEnterSubRule (6);  					try {  						DebugEnterDecision (6' false);  						int LA6_1 = input.LA (1);  						if ((LA6_1 == 24)) {  							alt6 = 1;  						}  					}  					finally {  						DebugExitDecision (6);  					}  					switch (alt6) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  						{  							DebugLocation (98' 31);  							inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (6);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (99' 4);  				FilterTreeNode newNode = f;  				if ((inverse != null ? inverse.Text : default(string)) == "!")  					newNode.ToggleInversed ();  				filterNode = newNode;  			}  			break;  		case 3:  			DebugEnterAlt (3);  			// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  			{  				DebugLocation (105' 4);  				DebugLocation (105' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr216);  				Match (input' TokenTypes.Down' null);  				DebugLocation (105' 12);  				PushFollow (Follow._propertyChain_in_filterExpr219);  				propertyChain (propertySegments);  				PopFollow ();  				DebugLocation (105' 51);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  				int alt7 = 2;  				try {  					DebugEnterSubRule (7);  					try {  						DebugEnterDecision (7' false);  						int LA7_1 = input.LA (1);  						if ((LA7_1 == 31)) {  							alt7 = 1;  						}  					}  					finally {  						DebugExitDecision (7);  					}  					switch (alt7) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  						{  							DebugLocation (105' 51);  							inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (7);  				}  				DebugLocation (105' 60);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  				int alt8 = 2;  				try {  					DebugEnterSubRule (8);  					try {  						DebugEnterDecision (8' false);  						int LA8_1 = input.LA (1);  						if ((LA8_1 == 24)) {  							alt8 = 1;  						}  					}  					finally {  						DebugExitDecision (8);  					}  					switch (alt8) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  						{  							DebugLocation (105' 60);  							not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (8);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (106' 4);  				FilterTreeNode newProperty = new Property (propertySegments);  				if ((inverse != null ? inverse.Text : default(string)) == "?")  					filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  				else {  					if ((not != null ? not.Text : default(string)) == "!")  						newProperty.ToggleInversed ();  					filterNode = newProperty;  				}  			}  			break;  		case 4:  			DebugEnterAlt (4);  			// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  			{  				DebugLocation (116' 4);  				STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  				DebugLocation (117' 4);  				string stringText = (STRING7 != null ? STRING7.Text : default(string));  				stringText = stringText.Substring (1' stringText.Length - 2);  				filterNode = new Value (stringText);  			}  			break;  		case 5:  			DebugEnterAlt (5);  			// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  			{  				DebugLocation (122' 4);  				REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  				DebugLocation (123' 4);  				string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  				regexText = regexText.Substring (1' regexText.Length - 2);  				filterNode = new RegExp (regexText);  			}  			break;  		case 6:  			DebugEnterAlt (6);  			// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  			{  				DebugLocation (128' 4);  				NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  				DebugLocation (129' 4);  				filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  			}  			break;  		case 7:  			DebugEnterAlt (7);  			// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  			{  				DebugLocation (132' 4);  				Match (input' TRUE' Follow._TRUE_in_filterExpr271);  				DebugLocation (133' 4);  				filterNode = new Value (true);  			}  			break;  		case 8:  			DebugEnterAlt (8);  			// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  			{  				DebugLocation (136' 4);  				Match (input' FALSE' Follow._FALSE_in_filterExpr281);  				DebugLocation (137' 4);  				filterNode = new Value (false);  			}  			break;  		case 9:  			DebugEnterAlt (9);  			// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  			{  				DebugLocation (140' 4);  				Match (input' NULL' Follow._NULL_in_filterExpr291);  				DebugLocation (141' 4);  				filterNode = new Value (null);  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("filterExpr"' 6);  		LeaveRule ("filterExpr"' 6);  		LeaveRule_filterExpr ();  	}  	DebugLocation (144' 1);  }  finally {  	DebugExitRule (GrammarFileName' "filterExpr");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "filterExpr");  	DebugLocation (60' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  		int alt9 = 9;  		try {  			DebugEnterDecision (9' false);  			switch (input.LA (1)) {  			case CHAIN_OPERATOR:  			case COMPARATOR:  				{  					alt9 = 1;  				}  				break;  			case EXPR:  				{  					int LA9_2 = input.LA (2);  					if ((LA9_2 == DOWN)) {  						int LA9_3 = input.LA (3);  						if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  							alt9 = 2;  						}  						else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  							alt9 = 3;  						}  						else {  							NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  							DebugRecognitionException (nvae);  							throw nvae;  						}  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				break;  			case STRING:  				{  					alt9 = 4;  				}  				break;  			case REGEX:  				{  					alt9 = 5;  				}  				break;  			case NUMBER:  				{  					alt9 = 6;  				}  				break;  			case TRUE:  				{  					alt9 = 7;  				}  				break;  			case FALSE:  				{  					alt9 = 8;  				}  				break;  			case NULL:  				{  					alt9 = 9;  				}  				break;  			default: {  				NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  			}  		}  		finally {  			DebugExitDecision (9);  		}  		switch (alt9) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  			{  				DebugLocation (64' 4);  				DebugLocation (64' 6);  				PushFollow (Follow._comparator_in_filterExpr175);  				comparator6 = comparator ();  				PopFollow ();  				Match (input' TokenTypes.Down' null);  				DebugLocation (64' 18);  				PushFollow (Follow._filterExpr_in_filterExpr179);  				a = filterExpr ();  				PopFollow ();  				DebugLocation (64' 31);  				PushFollow (Follow._filterExpr_in_filterExpr183);  				b = filterExpr ();  				PopFollow ();  				Match (input' TokenTypes.Up' null);  				DebugLocation (65' 4);  				Comparator newComparator;  				switch (comparator6) {  				case "=":  					newComparator = Comparator.Equals;  					break;  				case "!=":  					newComparator = Comparator.NotEquals;  					break;  				case ">":  					newComparator = Comparator.Greater;  					break;  				case "<":  					newComparator = Comparator.Less;  					break;  				case ">=":  					newComparator = Comparator.GreaterOrEqual;  					break;  				case "<=":  					newComparator = Comparator.LessOrEqual;  					break;  				case "&":  					newComparator = Comparator.And;  					break;  				case "|":  					newComparator = Comparator.Or;  					break;  				default:  					newComparator = Comparator.Equals;  					break;  				}  				filterNode = new BoolExpression (a' newComparator' b);  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  			{  				DebugLocation (98' 4);  				DebugLocation (98' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr195);  				Match (input' TokenTypes.Down' null);  				DebugLocation (98' 12);  				PushFollow (Follow._filterExpr_in_filterExpr199);  				f = filterExpr ();  				PopFollow ();  				DebugLocation (98' 31);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  				int alt6 = 2;  				try {  					DebugEnterSubRule (6);  					try {  						DebugEnterDecision (6' false);  						int LA6_1 = input.LA (1);  						if ((LA6_1 == 24)) {  							alt6 = 1;  						}  					}  					finally {  						DebugExitDecision (6);  					}  					switch (alt6) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  						{  							DebugLocation (98' 31);  							inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (6);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (99' 4);  				FilterTreeNode newNode = f;  				if ((inverse != null ? inverse.Text : default(string)) == "!")  					newNode.ToggleInversed ();  				filterNode = newNode;  			}  			break;  		case 3:  			DebugEnterAlt (3);  			// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  			{  				DebugLocation (105' 4);  				DebugLocation (105' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr216);  				Match (input' TokenTypes.Down' null);  				DebugLocation (105' 12);  				PushFollow (Follow._propertyChain_in_filterExpr219);  				propertyChain (propertySegments);  				PopFollow ();  				DebugLocation (105' 51);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  				int alt7 = 2;  				try {  					DebugEnterSubRule (7);  					try {  						DebugEnterDecision (7' false);  						int LA7_1 = input.LA (1);  						if ((LA7_1 == 31)) {  							alt7 = 1;  						}  					}  					finally {  						DebugExitDecision (7);  					}  					switch (alt7) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  						{  							DebugLocation (105' 51);  							inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (7);  				}  				DebugLocation (105' 60);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  				int alt8 = 2;  				try {  					DebugEnterSubRule (8);  					try {  						DebugEnterDecision (8' false);  						int LA8_1 = input.LA (1);  						if ((LA8_1 == 24)) {  							alt8 = 1;  						}  					}  					finally {  						DebugExitDecision (8);  					}  					switch (alt8) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  						{  							DebugLocation (105' 60);  							not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (8);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (106' 4);  				FilterTreeNode newProperty = new Property (propertySegments);  				if ((inverse != null ? inverse.Text : default(string)) == "?")  					filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  				else {  					if ((not != null ? not.Text : default(string)) == "!")  						newProperty.ToggleInversed ();  					filterNode = newProperty;  				}  			}  			break;  		case 4:  			DebugEnterAlt (4);  			// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  			{  				DebugLocation (116' 4);  				STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  				DebugLocation (117' 4);  				string stringText = (STRING7 != null ? STRING7.Text : default(string));  				stringText = stringText.Substring (1' stringText.Length - 2);  				filterNode = new Value (stringText);  			}  			break;  		case 5:  			DebugEnterAlt (5);  			// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  			{  				DebugLocation (122' 4);  				REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  				DebugLocation (123' 4);  				string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  				regexText = regexText.Substring (1' regexText.Length - 2);  				filterNode = new RegExp (regexText);  			}  			break;  		case 6:  			DebugEnterAlt (6);  			// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  			{  				DebugLocation (128' 4);  				NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  				DebugLocation (129' 4);  				filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  			}  			break;  		case 7:  			DebugEnterAlt (7);  			// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  			{  				DebugLocation (132' 4);  				Match (input' TRUE' Follow._TRUE_in_filterExpr271);  				DebugLocation (133' 4);  				filterNode = new Value (true);  			}  			break;  		case 8:  			DebugEnterAlt (8);  			// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  			{  				DebugLocation (136' 4);  				Match (input' FALSE' Follow._FALSE_in_filterExpr281);  				DebugLocation (137' 4);  				filterNode = new Value (false);  			}  			break;  		case 9:  			DebugEnterAlt (9);  			// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  			{  				DebugLocation (140' 4);  				Match (input' NULL' Follow._NULL_in_filterExpr291);  				DebugLocation (141' 4);  				filterNode = new Value (null);  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("filterExpr"' 6);  		LeaveRule ("filterExpr"' 6);  		LeaveRule_filterExpr ();  	}  	DebugLocation (144' 1);  }  finally {  	DebugExitRule (GrammarFileName' "filterExpr");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "filterExpr");  	DebugLocation (60' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  		int alt9 = 9;  		try {  			DebugEnterDecision (9' false);  			switch (input.LA (1)) {  			case CHAIN_OPERATOR:  			case COMPARATOR:  				{  					alt9 = 1;  				}  				break;  			case EXPR:  				{  					int LA9_2 = input.LA (2);  					if ((LA9_2 == DOWN)) {  						int LA9_3 = input.LA (3);  						if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  							alt9 = 2;  						}  						else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  							alt9 = 3;  						}  						else {  							NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  							DebugRecognitionException (nvae);  							throw nvae;  						}  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				break;  			case STRING:  				{  					alt9 = 4;  				}  				break;  			case REGEX:  				{  					alt9 = 5;  				}  				break;  			case NUMBER:  				{  					alt9 = 6;  				}  				break;  			case TRUE:  				{  					alt9 = 7;  				}  				break;  			case FALSE:  				{  					alt9 = 8;  				}  				break;  			case NULL:  				{  					alt9 = 9;  				}  				break;  			default: {  				NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  			}  		}  		finally {  			DebugExitDecision (9);  		}  		switch (alt9) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  			{  				DebugLocation (64' 4);  				DebugLocation (64' 6);  				PushFollow (Follow._comparator_in_filterExpr175);  				comparator6 = comparator ();  				PopFollow ();  				Match (input' TokenTypes.Down' null);  				DebugLocation (64' 18);  				PushFollow (Follow._filterExpr_in_filterExpr179);  				a = filterExpr ();  				PopFollow ();  				DebugLocation (64' 31);  				PushFollow (Follow._filterExpr_in_filterExpr183);  				b = filterExpr ();  				PopFollow ();  				Match (input' TokenTypes.Up' null);  				DebugLocation (65' 4);  				Comparator newComparator;  				switch (comparator6) {  				case "=":  					newComparator = Comparator.Equals;  					break;  				case "!=":  					newComparator = Comparator.NotEquals;  					break;  				case ">":  					newComparator = Comparator.Greater;  					break;  				case "<":  					newComparator = Comparator.Less;  					break;  				case ">=":  					newComparator = Comparator.GreaterOrEqual;  					break;  				case "<=":  					newComparator = Comparator.LessOrEqual;  					break;  				case "&":  					newComparator = Comparator.And;  					break;  				case "|":  					newComparator = Comparator.Or;  					break;  				default:  					newComparator = Comparator.Equals;  					break;  				}  				filterNode = new BoolExpression (a' newComparator' b);  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  			{  				DebugLocation (98' 4);  				DebugLocation (98' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr195);  				Match (input' TokenTypes.Down' null);  				DebugLocation (98' 12);  				PushFollow (Follow._filterExpr_in_filterExpr199);  				f = filterExpr ();  				PopFollow ();  				DebugLocation (98' 31);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  				int alt6 = 2;  				try {  					DebugEnterSubRule (6);  					try {  						DebugEnterDecision (6' false);  						int LA6_1 = input.LA (1);  						if ((LA6_1 == 24)) {  							alt6 = 1;  						}  					}  					finally {  						DebugExitDecision (6);  					}  					switch (alt6) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  						{  							DebugLocation (98' 31);  							inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (6);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (99' 4);  				FilterTreeNode newNode = f;  				if ((inverse != null ? inverse.Text : default(string)) == "!")  					newNode.ToggleInversed ();  				filterNode = newNode;  			}  			break;  		case 3:  			DebugEnterAlt (3);  			// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  			{  				DebugLocation (105' 4);  				DebugLocation (105' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr216);  				Match (input' TokenTypes.Down' null);  				DebugLocation (105' 12);  				PushFollow (Follow._propertyChain_in_filterExpr219);  				propertyChain (propertySegments);  				PopFollow ();  				DebugLocation (105' 51);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  				int alt7 = 2;  				try {  					DebugEnterSubRule (7);  					try {  						DebugEnterDecision (7' false);  						int LA7_1 = input.LA (1);  						if ((LA7_1 == 31)) {  							alt7 = 1;  						}  					}  					finally {  						DebugExitDecision (7);  					}  					switch (alt7) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  						{  							DebugLocation (105' 51);  							inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (7);  				}  				DebugLocation (105' 60);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  				int alt8 = 2;  				try {  					DebugEnterSubRule (8);  					try {  						DebugEnterDecision (8' false);  						int LA8_1 = input.LA (1);  						if ((LA8_1 == 24)) {  							alt8 = 1;  						}  					}  					finally {  						DebugExitDecision (8);  					}  					switch (alt8) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  						{  							DebugLocation (105' 60);  							not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (8);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (106' 4);  				FilterTreeNode newProperty = new Property (propertySegments);  				if ((inverse != null ? inverse.Text : default(string)) == "?")  					filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  				else {  					if ((not != null ? not.Text : default(string)) == "!")  						newProperty.ToggleInversed ();  					filterNode = newProperty;  				}  			}  			break;  		case 4:  			DebugEnterAlt (4);  			// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  			{  				DebugLocation (116' 4);  				STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  				DebugLocation (117' 4);  				string stringText = (STRING7 != null ? STRING7.Text : default(string));  				stringText = stringText.Substring (1' stringText.Length - 2);  				filterNode = new Value (stringText);  			}  			break;  		case 5:  			DebugEnterAlt (5);  			// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  			{  				DebugLocation (122' 4);  				REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  				DebugLocation (123' 4);  				string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  				regexText = regexText.Substring (1' regexText.Length - 2);  				filterNode = new RegExp (regexText);  			}  			break;  		case 6:  			DebugEnterAlt (6);  			// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  			{  				DebugLocation (128' 4);  				NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  				DebugLocation (129' 4);  				filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  			}  			break;  		case 7:  			DebugEnterAlt (7);  			// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  			{  				DebugLocation (132' 4);  				Match (input' TRUE' Follow._TRUE_in_filterExpr271);  				DebugLocation (133' 4);  				filterNode = new Value (true);  			}  			break;  		case 8:  			DebugEnterAlt (8);  			// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  			{  				DebugLocation (136' 4);  				Match (input' FALSE' Follow._FALSE_in_filterExpr281);  				DebugLocation (137' 4);  				filterNode = new Value (false);  			}  			break;  		case 9:  			DebugEnterAlt (9);  			// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  			{  				DebugLocation (140' 4);  				Match (input' NULL' Follow._NULL_in_filterExpr291);  				DebugLocation (141' 4);  				filterNode = new Value (null);  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("filterExpr"' 6);  		LeaveRule ("filterExpr"' 6);  		LeaveRule_filterExpr ();  	}  	DebugLocation (144' 1);  }  finally {  	DebugExitRule (GrammarFileName' "filterExpr");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "filterExpr");  	DebugLocation (60' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  		int alt9 = 9;  		try {  			DebugEnterDecision (9' false);  			switch (input.LA (1)) {  			case CHAIN_OPERATOR:  			case COMPARATOR:  				{  					alt9 = 1;  				}  				break;  			case EXPR:  				{  					int LA9_2 = input.LA (2);  					if ((LA9_2 == DOWN)) {  						int LA9_3 = input.LA (3);  						if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  							alt9 = 2;  						}  						else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  							alt9 = 3;  						}  						else {  							NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  							DebugRecognitionException (nvae);  							throw nvae;  						}  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				break;  			case STRING:  				{  					alt9 = 4;  				}  				break;  			case REGEX:  				{  					alt9 = 5;  				}  				break;  			case NUMBER:  				{  					alt9 = 6;  				}  				break;  			case TRUE:  				{  					alt9 = 7;  				}  				break;  			case FALSE:  				{  					alt9 = 8;  				}  				break;  			case NULL:  				{  					alt9 = 9;  				}  				break;  			default: {  				NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  			}  		}  		finally {  			DebugExitDecision (9);  		}  		switch (alt9) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  			{  				DebugLocation (64' 4);  				DebugLocation (64' 6);  				PushFollow (Follow._comparator_in_filterExpr175);  				comparator6 = comparator ();  				PopFollow ();  				Match (input' TokenTypes.Down' null);  				DebugLocation (64' 18);  				PushFollow (Follow._filterExpr_in_filterExpr179);  				a = filterExpr ();  				PopFollow ();  				DebugLocation (64' 31);  				PushFollow (Follow._filterExpr_in_filterExpr183);  				b = filterExpr ();  				PopFollow ();  				Match (input' TokenTypes.Up' null);  				DebugLocation (65' 4);  				Comparator newComparator;  				switch (comparator6) {  				case "=":  					newComparator = Comparator.Equals;  					break;  				case "!=":  					newComparator = Comparator.NotEquals;  					break;  				case ">":  					newComparator = Comparator.Greater;  					break;  				case "<":  					newComparator = Comparator.Less;  					break;  				case ">=":  					newComparator = Comparator.GreaterOrEqual;  					break;  				case "<=":  					newComparator = Comparator.LessOrEqual;  					break;  				case "&":  					newComparator = Comparator.And;  					break;  				case "|":  					newComparator = Comparator.Or;  					break;  				default:  					newComparator = Comparator.Equals;  					break;  				}  				filterNode = new BoolExpression (a' newComparator' b);  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  			{  				DebugLocation (98' 4);  				DebugLocation (98' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr195);  				Match (input' TokenTypes.Down' null);  				DebugLocation (98' 12);  				PushFollow (Follow._filterExpr_in_filterExpr199);  				f = filterExpr ();  				PopFollow ();  				DebugLocation (98' 31);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  				int alt6 = 2;  				try {  					DebugEnterSubRule (6);  					try {  						DebugEnterDecision (6' false);  						int LA6_1 = input.LA (1);  						if ((LA6_1 == 24)) {  							alt6 = 1;  						}  					}  					finally {  						DebugExitDecision (6);  					}  					switch (alt6) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  						{  							DebugLocation (98' 31);  							inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (6);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (99' 4);  				FilterTreeNode newNode = f;  				if ((inverse != null ? inverse.Text : default(string)) == "!")  					newNode.ToggleInversed ();  				filterNode = newNode;  			}  			break;  		case 3:  			DebugEnterAlt (3);  			// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  			{  				DebugLocation (105' 4);  				DebugLocation (105' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr216);  				Match (input' TokenTypes.Down' null);  				DebugLocation (105' 12);  				PushFollow (Follow._propertyChain_in_filterExpr219);  				propertyChain (propertySegments);  				PopFollow ();  				DebugLocation (105' 51);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  				int alt7 = 2;  				try {  					DebugEnterSubRule (7);  					try {  						DebugEnterDecision (7' false);  						int LA7_1 = input.LA (1);  						if ((LA7_1 == 31)) {  							alt7 = 1;  						}  					}  					finally {  						DebugExitDecision (7);  					}  					switch (alt7) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  						{  							DebugLocation (105' 51);  							inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (7);  				}  				DebugLocation (105' 60);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  				int alt8 = 2;  				try {  					DebugEnterSubRule (8);  					try {  						DebugEnterDecision (8' false);  						int LA8_1 = input.LA (1);  						if ((LA8_1 == 24)) {  							alt8 = 1;  						}  					}  					finally {  						DebugExitDecision (8);  					}  					switch (alt8) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  						{  							DebugLocation (105' 60);  							not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (8);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (106' 4);  				FilterTreeNode newProperty = new Property (propertySegments);  				if ((inverse != null ? inverse.Text : default(string)) == "?")  					filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  				else {  					if ((not != null ? not.Text : default(string)) == "!")  						newProperty.ToggleInversed ();  					filterNode = newProperty;  				}  			}  			break;  		case 4:  			DebugEnterAlt (4);  			// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  			{  				DebugLocation (116' 4);  				STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  				DebugLocation (117' 4);  				string stringText = (STRING7 != null ? STRING7.Text : default(string));  				stringText = stringText.Substring (1' stringText.Length - 2);  				filterNode = new Value (stringText);  			}  			break;  		case 5:  			DebugEnterAlt (5);  			// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  			{  				DebugLocation (122' 4);  				REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  				DebugLocation (123' 4);  				string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  				regexText = regexText.Substring (1' regexText.Length - 2);  				filterNode = new RegExp (regexText);  			}  			break;  		case 6:  			DebugEnterAlt (6);  			// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  			{  				DebugLocation (128' 4);  				NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  				DebugLocation (129' 4);  				filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  			}  			break;  		case 7:  			DebugEnterAlt (7);  			// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  			{  				DebugLocation (132' 4);  				Match (input' TRUE' Follow._TRUE_in_filterExpr271);  				DebugLocation (133' 4);  				filterNode = new Value (true);  			}  			break;  		case 8:  			DebugEnterAlt (8);  			// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  			{  				DebugLocation (136' 4);  				Match (input' FALSE' Follow._FALSE_in_filterExpr281);  				DebugLocation (137' 4);  				filterNode = new Value (false);  			}  			break;  		case 9:  			DebugEnterAlt (9);  			// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  			{  				DebugLocation (140' 4);  				Match (input' NULL' Follow._NULL_in_filterExpr291);  				DebugLocation (141' 4);  				filterNode = new Value (null);  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("filterExpr"' 6);  		LeaveRule ("filterExpr"' 6);  		LeaveRule_filterExpr ();  	}  	DebugLocation (144' 1);  }  finally {  	DebugExitRule (GrammarFileName' "filterExpr");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "filterExpr");  	DebugLocation (60' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  		int alt9 = 9;  		try {  			DebugEnterDecision (9' false);  			switch (input.LA (1)) {  			case CHAIN_OPERATOR:  			case COMPARATOR:  				{  					alt9 = 1;  				}  				break;  			case EXPR:  				{  					int LA9_2 = input.LA (2);  					if ((LA9_2 == DOWN)) {  						int LA9_3 = input.LA (3);  						if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  							alt9 = 2;  						}  						else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  							alt9 = 3;  						}  						else {  							NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  							DebugRecognitionException (nvae);  							throw nvae;  						}  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				break;  			case STRING:  				{  					alt9 = 4;  				}  				break;  			case REGEX:  				{  					alt9 = 5;  				}  				break;  			case NUMBER:  				{  					alt9 = 6;  				}  				break;  			case TRUE:  				{  					alt9 = 7;  				}  				break;  			case FALSE:  				{  					alt9 = 8;  				}  				break;  			case NULL:  				{  					alt9 = 9;  				}  				break;  			default: {  				NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  			}  		}  		finally {  			DebugExitDecision (9);  		}  		switch (alt9) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  			{  				DebugLocation (64' 4);  				DebugLocation (64' 6);  				PushFollow (Follow._comparator_in_filterExpr175);  				comparator6 = comparator ();  				PopFollow ();  				Match (input' TokenTypes.Down' null);  				DebugLocation (64' 18);  				PushFollow (Follow._filterExpr_in_filterExpr179);  				a = filterExpr ();  				PopFollow ();  				DebugLocation (64' 31);  				PushFollow (Follow._filterExpr_in_filterExpr183);  				b = filterExpr ();  				PopFollow ();  				Match (input' TokenTypes.Up' null);  				DebugLocation (65' 4);  				Comparator newComparator;  				switch (comparator6) {  				case "=":  					newComparator = Comparator.Equals;  					break;  				case "!=":  					newComparator = Comparator.NotEquals;  					break;  				case ">":  					newComparator = Comparator.Greater;  					break;  				case "<":  					newComparator = Comparator.Less;  					break;  				case ">=":  					newComparator = Comparator.GreaterOrEqual;  					break;  				case "<=":  					newComparator = Comparator.LessOrEqual;  					break;  				case "&":  					newComparator = Comparator.And;  					break;  				case "|":  					newComparator = Comparator.Or;  					break;  				default:  					newComparator = Comparator.Equals;  					break;  				}  				filterNode = new BoolExpression (a' newComparator' b);  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  			{  				DebugLocation (98' 4);  				DebugLocation (98' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr195);  				Match (input' TokenTypes.Down' null);  				DebugLocation (98' 12);  				PushFollow (Follow._filterExpr_in_filterExpr199);  				f = filterExpr ();  				PopFollow ();  				DebugLocation (98' 31);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  				int alt6 = 2;  				try {  					DebugEnterSubRule (6);  					try {  						DebugEnterDecision (6' false);  						int LA6_1 = input.LA (1);  						if ((LA6_1 == 24)) {  							alt6 = 1;  						}  					}  					finally {  						DebugExitDecision (6);  					}  					switch (alt6) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  						{  							DebugLocation (98' 31);  							inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (6);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (99' 4);  				FilterTreeNode newNode = f;  				if ((inverse != null ? inverse.Text : default(string)) == "!")  					newNode.ToggleInversed ();  				filterNode = newNode;  			}  			break;  		case 3:  			DebugEnterAlt (3);  			// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  			{  				DebugLocation (105' 4);  				DebugLocation (105' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr216);  				Match (input' TokenTypes.Down' null);  				DebugLocation (105' 12);  				PushFollow (Follow._propertyChain_in_filterExpr219);  				propertyChain (propertySegments);  				PopFollow ();  				DebugLocation (105' 51);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  				int alt7 = 2;  				try {  					DebugEnterSubRule (7);  					try {  						DebugEnterDecision (7' false);  						int LA7_1 = input.LA (1);  						if ((LA7_1 == 31)) {  							alt7 = 1;  						}  					}  					finally {  						DebugExitDecision (7);  					}  					switch (alt7) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  						{  							DebugLocation (105' 51);  							inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (7);  				}  				DebugLocation (105' 60);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  				int alt8 = 2;  				try {  					DebugEnterSubRule (8);  					try {  						DebugEnterDecision (8' false);  						int LA8_1 = input.LA (1);  						if ((LA8_1 == 24)) {  							alt8 = 1;  						}  					}  					finally {  						DebugExitDecision (8);  					}  					switch (alt8) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  						{  							DebugLocation (105' 60);  							not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (8);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (106' 4);  				FilterTreeNode newProperty = new Property (propertySegments);  				if ((inverse != null ? inverse.Text : default(string)) == "?")  					filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  				else {  					if ((not != null ? not.Text : default(string)) == "!")  						newProperty.ToggleInversed ();  					filterNode = newProperty;  				}  			}  			break;  		case 4:  			DebugEnterAlt (4);  			// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  			{  				DebugLocation (116' 4);  				STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  				DebugLocation (117' 4);  				string stringText = (STRING7 != null ? STRING7.Text : default(string));  				stringText = stringText.Substring (1' stringText.Length - 2);  				filterNode = new Value (stringText);  			}  			break;  		case 5:  			DebugEnterAlt (5);  			// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  			{  				DebugLocation (122' 4);  				REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  				DebugLocation (123' 4);  				string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  				regexText = regexText.Substring (1' regexText.Length - 2);  				filterNode = new RegExp (regexText);  			}  			break;  		case 6:  			DebugEnterAlt (6);  			// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  			{  				DebugLocation (128' 4);  				NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  				DebugLocation (129' 4);  				filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  			}  			break;  		case 7:  			DebugEnterAlt (7);  			// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  			{  				DebugLocation (132' 4);  				Match (input' TRUE' Follow._TRUE_in_filterExpr271);  				DebugLocation (133' 4);  				filterNode = new Value (true);  			}  			break;  		case 8:  			DebugEnterAlt (8);  			// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  			{  				DebugLocation (136' 4);  				Match (input' FALSE' Follow._FALSE_in_filterExpr281);  				DebugLocation (137' 4);  				filterNode = new Value (false);  			}  			break;  		case 9:  			DebugEnterAlt (9);  			// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  			{  				DebugLocation (140' 4);  				Match (input' NULL' Follow._NULL_in_filterExpr291);  				DebugLocation (141' 4);  				filterNode = new Value (null);  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("filterExpr"' 6);  		LeaveRule ("filterExpr"' 6);  		LeaveRule_filterExpr ();  	}  	DebugLocation (144' 1);  }  finally {  	DebugExitRule (GrammarFileName' "filterExpr");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "filterExpr");  	DebugLocation (60' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  		int alt9 = 9;  		try {  			DebugEnterDecision (9' false);  			switch (input.LA (1)) {  			case CHAIN_OPERATOR:  			case COMPARATOR:  				{  					alt9 = 1;  				}  				break;  			case EXPR:  				{  					int LA9_2 = input.LA (2);  					if ((LA9_2 == DOWN)) {  						int LA9_3 = input.LA (3);  						if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  							alt9 = 2;  						}  						else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  							alt9 = 3;  						}  						else {  							NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  							DebugRecognitionException (nvae);  							throw nvae;  						}  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				break;  			case STRING:  				{  					alt9 = 4;  				}  				break;  			case REGEX:  				{  					alt9 = 5;  				}  				break;  			case NUMBER:  				{  					alt9 = 6;  				}  				break;  			case TRUE:  				{  					alt9 = 7;  				}  				break;  			case FALSE:  				{  					alt9 = 8;  				}  				break;  			case NULL:  				{  					alt9 = 9;  				}  				break;  			default: {  				NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  			}  		}  		finally {  			DebugExitDecision (9);  		}  		switch (alt9) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  			{  				DebugLocation (64' 4);  				DebugLocation (64' 6);  				PushFollow (Follow._comparator_in_filterExpr175);  				comparator6 = comparator ();  				PopFollow ();  				Match (input' TokenTypes.Down' null);  				DebugLocation (64' 18);  				PushFollow (Follow._filterExpr_in_filterExpr179);  				a = filterExpr ();  				PopFollow ();  				DebugLocation (64' 31);  				PushFollow (Follow._filterExpr_in_filterExpr183);  				b = filterExpr ();  				PopFollow ();  				Match (input' TokenTypes.Up' null);  				DebugLocation (65' 4);  				Comparator newComparator;  				switch (comparator6) {  				case "=":  					newComparator = Comparator.Equals;  					break;  				case "!=":  					newComparator = Comparator.NotEquals;  					break;  				case ">":  					newComparator = Comparator.Greater;  					break;  				case "<":  					newComparator = Comparator.Less;  					break;  				case ">=":  					newComparator = Comparator.GreaterOrEqual;  					break;  				case "<=":  					newComparator = Comparator.LessOrEqual;  					break;  				case "&":  					newComparator = Comparator.And;  					break;  				case "|":  					newComparator = Comparator.Or;  					break;  				default:  					newComparator = Comparator.Equals;  					break;  				}  				filterNode = new BoolExpression (a' newComparator' b);  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  			{  				DebugLocation (98' 4);  				DebugLocation (98' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr195);  				Match (input' TokenTypes.Down' null);  				DebugLocation (98' 12);  				PushFollow (Follow._filterExpr_in_filterExpr199);  				f = filterExpr ();  				PopFollow ();  				DebugLocation (98' 31);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  				int alt6 = 2;  				try {  					DebugEnterSubRule (6);  					try {  						DebugEnterDecision (6' false);  						int LA6_1 = input.LA (1);  						if ((LA6_1 == 24)) {  							alt6 = 1;  						}  					}  					finally {  						DebugExitDecision (6);  					}  					switch (alt6) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  						{  							DebugLocation (98' 31);  							inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (6);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (99' 4);  				FilterTreeNode newNode = f;  				if ((inverse != null ? inverse.Text : default(string)) == "!")  					newNode.ToggleInversed ();  				filterNode = newNode;  			}  			break;  		case 3:  			DebugEnterAlt (3);  			// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  			{  				DebugLocation (105' 4);  				DebugLocation (105' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr216);  				Match (input' TokenTypes.Down' null);  				DebugLocation (105' 12);  				PushFollow (Follow._propertyChain_in_filterExpr219);  				propertyChain (propertySegments);  				PopFollow ();  				DebugLocation (105' 51);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  				int alt7 = 2;  				try {  					DebugEnterSubRule (7);  					try {  						DebugEnterDecision (7' false);  						int LA7_1 = input.LA (1);  						if ((LA7_1 == 31)) {  							alt7 = 1;  						}  					}  					finally {  						DebugExitDecision (7);  					}  					switch (alt7) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  						{  							DebugLocation (105' 51);  							inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (7);  				}  				DebugLocation (105' 60);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  				int alt8 = 2;  				try {  					DebugEnterSubRule (8);  					try {  						DebugEnterDecision (8' false);  						int LA8_1 = input.LA (1);  						if ((LA8_1 == 24)) {  							alt8 = 1;  						}  					}  					finally {  						DebugExitDecision (8);  					}  					switch (alt8) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  						{  							DebugLocation (105' 60);  							not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (8);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (106' 4);  				FilterTreeNode newProperty = new Property (propertySegments);  				if ((inverse != null ? inverse.Text : default(string)) == "?")  					filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  				else {  					if ((not != null ? not.Text : default(string)) == "!")  						newProperty.ToggleInversed ();  					filterNode = newProperty;  				}  			}  			break;  		case 4:  			DebugEnterAlt (4);  			// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  			{  				DebugLocation (116' 4);  				STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  				DebugLocation (117' 4);  				string stringText = (STRING7 != null ? STRING7.Text : default(string));  				stringText = stringText.Substring (1' stringText.Length - 2);  				filterNode = new Value (stringText);  			}  			break;  		case 5:  			DebugEnterAlt (5);  			// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  			{  				DebugLocation (122' 4);  				REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  				DebugLocation (123' 4);  				string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  				regexText = regexText.Substring (1' regexText.Length - 2);  				filterNode = new RegExp (regexText);  			}  			break;  		case 6:  			DebugEnterAlt (6);  			// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  			{  				DebugLocation (128' 4);  				NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  				DebugLocation (129' 4);  				filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  			}  			break;  		case 7:  			DebugEnterAlt (7);  			// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  			{  				DebugLocation (132' 4);  				Match (input' TRUE' Follow._TRUE_in_filterExpr271);  				DebugLocation (133' 4);  				filterNode = new Value (true);  			}  			break;  		case 8:  			DebugEnterAlt (8);  			// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  			{  				DebugLocation (136' 4);  				Match (input' FALSE' Follow._FALSE_in_filterExpr281);  				DebugLocation (137' 4);  				filterNode = new Value (false);  			}  			break;  		case 9:  			DebugEnterAlt (9);  			// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  			{  				DebugLocation (140' 4);  				Match (input' NULL' Follow._NULL_in_filterExpr291);  				DebugLocation (141' 4);  				filterNode = new Value (null);  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("filterExpr"' 6);  		LeaveRule ("filterExpr"' 6);  		LeaveRule_filterExpr ();  	}  	DebugLocation (144' 1);  }  finally {  	DebugExitRule (GrammarFileName' "filterExpr");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "filterExpr");  	DebugLocation (60' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  		int alt9 = 9;  		try {  			DebugEnterDecision (9' false);  			switch (input.LA (1)) {  			case CHAIN_OPERATOR:  			case COMPARATOR:  				{  					alt9 = 1;  				}  				break;  			case EXPR:  				{  					int LA9_2 = input.LA (2);  					if ((LA9_2 == DOWN)) {  						int LA9_3 = input.LA (3);  						if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  							alt9 = 2;  						}  						else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  							alt9 = 3;  						}  						else {  							NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  							DebugRecognitionException (nvae);  							throw nvae;  						}  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				break;  			case STRING:  				{  					alt9 = 4;  				}  				break;  			case REGEX:  				{  					alt9 = 5;  				}  				break;  			case NUMBER:  				{  					alt9 = 6;  				}  				break;  			case TRUE:  				{  					alt9 = 7;  				}  				break;  			case FALSE:  				{  					alt9 = 8;  				}  				break;  			case NULL:  				{  					alt9 = 9;  				}  				break;  			default: {  				NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  			}  		}  		finally {  			DebugExitDecision (9);  		}  		switch (alt9) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  			{  				DebugLocation (64' 4);  				DebugLocation (64' 6);  				PushFollow (Follow._comparator_in_filterExpr175);  				comparator6 = comparator ();  				PopFollow ();  				Match (input' TokenTypes.Down' null);  				DebugLocation (64' 18);  				PushFollow (Follow._filterExpr_in_filterExpr179);  				a = filterExpr ();  				PopFollow ();  				DebugLocation (64' 31);  				PushFollow (Follow._filterExpr_in_filterExpr183);  				b = filterExpr ();  				PopFollow ();  				Match (input' TokenTypes.Up' null);  				DebugLocation (65' 4);  				Comparator newComparator;  				switch (comparator6) {  				case "=":  					newComparator = Comparator.Equals;  					break;  				case "!=":  					newComparator = Comparator.NotEquals;  					break;  				case ">":  					newComparator = Comparator.Greater;  					break;  				case "<":  					newComparator = Comparator.Less;  					break;  				case ">=":  					newComparator = Comparator.GreaterOrEqual;  					break;  				case "<=":  					newComparator = Comparator.LessOrEqual;  					break;  				case "&":  					newComparator = Comparator.And;  					break;  				case "|":  					newComparator = Comparator.Or;  					break;  				default:  					newComparator = Comparator.Equals;  					break;  				}  				filterNode = new BoolExpression (a' newComparator' b);  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  			{  				DebugLocation (98' 4);  				DebugLocation (98' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr195);  				Match (input' TokenTypes.Down' null);  				DebugLocation (98' 12);  				PushFollow (Follow._filterExpr_in_filterExpr199);  				f = filterExpr ();  				PopFollow ();  				DebugLocation (98' 31);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  				int alt6 = 2;  				try {  					DebugEnterSubRule (6);  					try {  						DebugEnterDecision (6' false);  						int LA6_1 = input.LA (1);  						if ((LA6_1 == 24)) {  							alt6 = 1;  						}  					}  					finally {  						DebugExitDecision (6);  					}  					switch (alt6) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  						{  							DebugLocation (98' 31);  							inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (6);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (99' 4);  				FilterTreeNode newNode = f;  				if ((inverse != null ? inverse.Text : default(string)) == "!")  					newNode.ToggleInversed ();  				filterNode = newNode;  			}  			break;  		case 3:  			DebugEnterAlt (3);  			// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  			{  				DebugLocation (105' 4);  				DebugLocation (105' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr216);  				Match (input' TokenTypes.Down' null);  				DebugLocation (105' 12);  				PushFollow (Follow._propertyChain_in_filterExpr219);  				propertyChain (propertySegments);  				PopFollow ();  				DebugLocation (105' 51);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  				int alt7 = 2;  				try {  					DebugEnterSubRule (7);  					try {  						DebugEnterDecision (7' false);  						int LA7_1 = input.LA (1);  						if ((LA7_1 == 31)) {  							alt7 = 1;  						}  					}  					finally {  						DebugExitDecision (7);  					}  					switch (alt7) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  						{  							DebugLocation (105' 51);  							inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (7);  				}  				DebugLocation (105' 60);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  				int alt8 = 2;  				try {  					DebugEnterSubRule (8);  					try {  						DebugEnterDecision (8' false);  						int LA8_1 = input.LA (1);  						if ((LA8_1 == 24)) {  							alt8 = 1;  						}  					}  					finally {  						DebugExitDecision (8);  					}  					switch (alt8) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  						{  							DebugLocation (105' 60);  							not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (8);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (106' 4);  				FilterTreeNode newProperty = new Property (propertySegments);  				if ((inverse != null ? inverse.Text : default(string)) == "?")  					filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  				else {  					if ((not != null ? not.Text : default(string)) == "!")  						newProperty.ToggleInversed ();  					filterNode = newProperty;  				}  			}  			break;  		case 4:  			DebugEnterAlt (4);  			// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  			{  				DebugLocation (116' 4);  				STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  				DebugLocation (117' 4);  				string stringText = (STRING7 != null ? STRING7.Text : default(string));  				stringText = stringText.Substring (1' stringText.Length - 2);  				filterNode = new Value (stringText);  			}  			break;  		case 5:  			DebugEnterAlt (5);  			// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  			{  				DebugLocation (122' 4);  				REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  				DebugLocation (123' 4);  				string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  				regexText = regexText.Substring (1' regexText.Length - 2);  				filterNode = new RegExp (regexText);  			}  			break;  		case 6:  			DebugEnterAlt (6);  			// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  			{  				DebugLocation (128' 4);  				NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  				DebugLocation (129' 4);  				filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  			}  			break;  		case 7:  			DebugEnterAlt (7);  			// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  			{  				DebugLocation (132' 4);  				Match (input' TRUE' Follow._TRUE_in_filterExpr271);  				DebugLocation (133' 4);  				filterNode = new Value (true);  			}  			break;  		case 8:  			DebugEnterAlt (8);  			// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  			{  				DebugLocation (136' 4);  				Match (input' FALSE' Follow._FALSE_in_filterExpr281);  				DebugLocation (137' 4);  				filterNode = new Value (false);  			}  			break;  		case 9:  			DebugEnterAlt (9);  			// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  			{  				DebugLocation (140' 4);  				Match (input' NULL' Follow._NULL_in_filterExpr291);  				DebugLocation (141' 4);  				filterNode = new Value (null);  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("filterExpr"' 6);  		LeaveRule ("filterExpr"' 6);  		LeaveRule_filterExpr ();  	}  	DebugLocation (144' 1);  }  finally {  	DebugExitRule (GrammarFileName' "filterExpr");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "filterExpr");  	DebugLocation (60' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  		int alt9 = 9;  		try {  			DebugEnterDecision (9' false);  			switch (input.LA (1)) {  			case CHAIN_OPERATOR:  			case COMPARATOR:  				{  					alt9 = 1;  				}  				break;  			case EXPR:  				{  					int LA9_2 = input.LA (2);  					if ((LA9_2 == DOWN)) {  						int LA9_3 = input.LA (3);  						if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  							alt9 = 2;  						}  						else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  							alt9 = 3;  						}  						else {  							NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  							DebugRecognitionException (nvae);  							throw nvae;  						}  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				break;  			case STRING:  				{  					alt9 = 4;  				}  				break;  			case REGEX:  				{  					alt9 = 5;  				}  				break;  			case NUMBER:  				{  					alt9 = 6;  				}  				break;  			case TRUE:  				{  					alt9 = 7;  				}  				break;  			case FALSE:  				{  					alt9 = 8;  				}  				break;  			case NULL:  				{  					alt9 = 9;  				}  				break;  			default: {  				NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  			}  		}  		finally {  			DebugExitDecision (9);  		}  		switch (alt9) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  			{  				DebugLocation (64' 4);  				DebugLocation (64' 6);  				PushFollow (Follow._comparator_in_filterExpr175);  				comparator6 = comparator ();  				PopFollow ();  				Match (input' TokenTypes.Down' null);  				DebugLocation (64' 18);  				PushFollow (Follow._filterExpr_in_filterExpr179);  				a = filterExpr ();  				PopFollow ();  				DebugLocation (64' 31);  				PushFollow (Follow._filterExpr_in_filterExpr183);  				b = filterExpr ();  				PopFollow ();  				Match (input' TokenTypes.Up' null);  				DebugLocation (65' 4);  				Comparator newComparator;  				switch (comparator6) {  				case "=":  					newComparator = Comparator.Equals;  					break;  				case "!=":  					newComparator = Comparator.NotEquals;  					break;  				case ">":  					newComparator = Comparator.Greater;  					break;  				case "<":  					newComparator = Comparator.Less;  					break;  				case ">=":  					newComparator = Comparator.GreaterOrEqual;  					break;  				case "<=":  					newComparator = Comparator.LessOrEqual;  					break;  				case "&":  					newComparator = Comparator.And;  					break;  				case "|":  					newComparator = Comparator.Or;  					break;  				default:  					newComparator = Comparator.Equals;  					break;  				}  				filterNode = new BoolExpression (a' newComparator' b);  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  			{  				DebugLocation (98' 4);  				DebugLocation (98' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr195);  				Match (input' TokenTypes.Down' null);  				DebugLocation (98' 12);  				PushFollow (Follow._filterExpr_in_filterExpr199);  				f = filterExpr ();  				PopFollow ();  				DebugLocation (98' 31);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  				int alt6 = 2;  				try {  					DebugEnterSubRule (6);  					try {  						DebugEnterDecision (6' false);  						int LA6_1 = input.LA (1);  						if ((LA6_1 == 24)) {  							alt6 = 1;  						}  					}  					finally {  						DebugExitDecision (6);  					}  					switch (alt6) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  						{  							DebugLocation (98' 31);  							inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (6);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (99' 4);  				FilterTreeNode newNode = f;  				if ((inverse != null ? inverse.Text : default(string)) == "!")  					newNode.ToggleInversed ();  				filterNode = newNode;  			}  			break;  		case 3:  			DebugEnterAlt (3);  			// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  			{  				DebugLocation (105' 4);  				DebugLocation (105' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr216);  				Match (input' TokenTypes.Down' null);  				DebugLocation (105' 12);  				PushFollow (Follow._propertyChain_in_filterExpr219);  				propertyChain (propertySegments);  				PopFollow ();  				DebugLocation (105' 51);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  				int alt7 = 2;  				try {  					DebugEnterSubRule (7);  					try {  						DebugEnterDecision (7' false);  						int LA7_1 = input.LA (1);  						if ((LA7_1 == 31)) {  							alt7 = 1;  						}  					}  					finally {  						DebugExitDecision (7);  					}  					switch (alt7) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  						{  							DebugLocation (105' 51);  							inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (7);  				}  				DebugLocation (105' 60);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  				int alt8 = 2;  				try {  					DebugEnterSubRule (8);  					try {  						DebugEnterDecision (8' false);  						int LA8_1 = input.LA (1);  						if ((LA8_1 == 24)) {  							alt8 = 1;  						}  					}  					finally {  						DebugExitDecision (8);  					}  					switch (alt8) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  						{  							DebugLocation (105' 60);  							not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (8);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (106' 4);  				FilterTreeNode newProperty = new Property (propertySegments);  				if ((inverse != null ? inverse.Text : default(string)) == "?")  					filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  				else {  					if ((not != null ? not.Text : default(string)) == "!")  						newProperty.ToggleInversed ();  					filterNode = newProperty;  				}  			}  			break;  		case 4:  			DebugEnterAlt (4);  			// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  			{  				DebugLocation (116' 4);  				STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  				DebugLocation (117' 4);  				string stringText = (STRING7 != null ? STRING7.Text : default(string));  				stringText = stringText.Substring (1' stringText.Length - 2);  				filterNode = new Value (stringText);  			}  			break;  		case 5:  			DebugEnterAlt (5);  			// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  			{  				DebugLocation (122' 4);  				REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  				DebugLocation (123' 4);  				string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  				regexText = regexText.Substring (1' regexText.Length - 2);  				filterNode = new RegExp (regexText);  			}  			break;  		case 6:  			DebugEnterAlt (6);  			// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  			{  				DebugLocation (128' 4);  				NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  				DebugLocation (129' 4);  				filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  			}  			break;  		case 7:  			DebugEnterAlt (7);  			// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  			{  				DebugLocation (132' 4);  				Match (input' TRUE' Follow._TRUE_in_filterExpr271);  				DebugLocation (133' 4);  				filterNode = new Value (true);  			}  			break;  		case 8:  			DebugEnterAlt (8);  			// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  			{  				DebugLocation (136' 4);  				Match (input' FALSE' Follow._FALSE_in_filterExpr281);  				DebugLocation (137' 4);  				filterNode = new Value (false);  			}  			break;  		case 9:  			DebugEnterAlt (9);  			// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  			{  				DebugLocation (140' 4);  				Match (input' NULL' Follow._NULL_in_filterExpr291);  				DebugLocation (141' 4);  				filterNode = new Value (null);  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("filterExpr"' 6);  		LeaveRule ("filterExpr"' 6);  		LeaveRule_filterExpr ();  	}  	DebugLocation (144' 1);  }  finally {  	DebugExitRule (GrammarFileName' "filterExpr");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "filterExpr");  	DebugLocation (60' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  		int alt9 = 9;  		try {  			DebugEnterDecision (9' false);  			switch (input.LA (1)) {  			case CHAIN_OPERATOR:  			case COMPARATOR:  				{  					alt9 = 1;  				}  				break;  			case EXPR:  				{  					int LA9_2 = input.LA (2);  					if ((LA9_2 == DOWN)) {  						int LA9_3 = input.LA (3);  						if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  							alt9 = 2;  						}  						else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  							alt9 = 3;  						}  						else {  							NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  							DebugRecognitionException (nvae);  							throw nvae;  						}  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				break;  			case STRING:  				{  					alt9 = 4;  				}  				break;  			case REGEX:  				{  					alt9 = 5;  				}  				break;  			case NUMBER:  				{  					alt9 = 6;  				}  				break;  			case TRUE:  				{  					alt9 = 7;  				}  				break;  			case FALSE:  				{  					alt9 = 8;  				}  				break;  			case NULL:  				{  					alt9 = 9;  				}  				break;  			default: {  				NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  			}  		}  		finally {  			DebugExitDecision (9);  		}  		switch (alt9) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  			{  				DebugLocation (64' 4);  				DebugLocation (64' 6);  				PushFollow (Follow._comparator_in_filterExpr175);  				comparator6 = comparator ();  				PopFollow ();  				Match (input' TokenTypes.Down' null);  				DebugLocation (64' 18);  				PushFollow (Follow._filterExpr_in_filterExpr179);  				a = filterExpr ();  				PopFollow ();  				DebugLocation (64' 31);  				PushFollow (Follow._filterExpr_in_filterExpr183);  				b = filterExpr ();  				PopFollow ();  				Match (input' TokenTypes.Up' null);  				DebugLocation (65' 4);  				Comparator newComparator;  				switch (comparator6) {  				case "=":  					newComparator = Comparator.Equals;  					break;  				case "!=":  					newComparator = Comparator.NotEquals;  					break;  				case ">":  					newComparator = Comparator.Greater;  					break;  				case "<":  					newComparator = Comparator.Less;  					break;  				case ">=":  					newComparator = Comparator.GreaterOrEqual;  					break;  				case "<=":  					newComparator = Comparator.LessOrEqual;  					break;  				case "&":  					newComparator = Comparator.And;  					break;  				case "|":  					newComparator = Comparator.Or;  					break;  				default:  					newComparator = Comparator.Equals;  					break;  				}  				filterNode = new BoolExpression (a' newComparator' b);  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  			{  				DebugLocation (98' 4);  				DebugLocation (98' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr195);  				Match (input' TokenTypes.Down' null);  				DebugLocation (98' 12);  				PushFollow (Follow._filterExpr_in_filterExpr199);  				f = filterExpr ();  				PopFollow ();  				DebugLocation (98' 31);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  				int alt6 = 2;  				try {  					DebugEnterSubRule (6);  					try {  						DebugEnterDecision (6' false);  						int LA6_1 = input.LA (1);  						if ((LA6_1 == 24)) {  							alt6 = 1;  						}  					}  					finally {  						DebugExitDecision (6);  					}  					switch (alt6) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  						{  							DebugLocation (98' 31);  							inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (6);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (99' 4);  				FilterTreeNode newNode = f;  				if ((inverse != null ? inverse.Text : default(string)) == "!")  					newNode.ToggleInversed ();  				filterNode = newNode;  			}  			break;  		case 3:  			DebugEnterAlt (3);  			// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  			{  				DebugLocation (105' 4);  				DebugLocation (105' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr216);  				Match (input' TokenTypes.Down' null);  				DebugLocation (105' 12);  				PushFollow (Follow._propertyChain_in_filterExpr219);  				propertyChain (propertySegments);  				PopFollow ();  				DebugLocation (105' 51);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  				int alt7 = 2;  				try {  					DebugEnterSubRule (7);  					try {  						DebugEnterDecision (7' false);  						int LA7_1 = input.LA (1);  						if ((LA7_1 == 31)) {  							alt7 = 1;  						}  					}  					finally {  						DebugExitDecision (7);  					}  					switch (alt7) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  						{  							DebugLocation (105' 51);  							inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (7);  				}  				DebugLocation (105' 60);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  				int alt8 = 2;  				try {  					DebugEnterSubRule (8);  					try {  						DebugEnterDecision (8' false);  						int LA8_1 = input.LA (1);  						if ((LA8_1 == 24)) {  							alt8 = 1;  						}  					}  					finally {  						DebugExitDecision (8);  					}  					switch (alt8) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  						{  							DebugLocation (105' 60);  							not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (8);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (106' 4);  				FilterTreeNode newProperty = new Property (propertySegments);  				if ((inverse != null ? inverse.Text : default(string)) == "?")  					filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  				else {  					if ((not != null ? not.Text : default(string)) == "!")  						newProperty.ToggleInversed ();  					filterNode = newProperty;  				}  			}  			break;  		case 4:  			DebugEnterAlt (4);  			// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  			{  				DebugLocation (116' 4);  				STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  				DebugLocation (117' 4);  				string stringText = (STRING7 != null ? STRING7.Text : default(string));  				stringText = stringText.Substring (1' stringText.Length - 2);  				filterNode = new Value (stringText);  			}  			break;  		case 5:  			DebugEnterAlt (5);  			// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  			{  				DebugLocation (122' 4);  				REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  				DebugLocation (123' 4);  				string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  				regexText = regexText.Substring (1' regexText.Length - 2);  				filterNode = new RegExp (regexText);  			}  			break;  		case 6:  			DebugEnterAlt (6);  			// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  			{  				DebugLocation (128' 4);  				NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  				DebugLocation (129' 4);  				filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  			}  			break;  		case 7:  			DebugEnterAlt (7);  			// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  			{  				DebugLocation (132' 4);  				Match (input' TRUE' Follow._TRUE_in_filterExpr271);  				DebugLocation (133' 4);  				filterNode = new Value (true);  			}  			break;  		case 8:  			DebugEnterAlt (8);  			// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  			{  				DebugLocation (136' 4);  				Match (input' FALSE' Follow._FALSE_in_filterExpr281);  				DebugLocation (137' 4);  				filterNode = new Value (false);  			}  			break;  		case 9:  			DebugEnterAlt (9);  			// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  			{  				DebugLocation (140' 4);  				Match (input' NULL' Follow._NULL_in_filterExpr291);  				DebugLocation (141' 4);  				filterNode = new Value (null);  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("filterExpr"' 6);  		LeaveRule ("filterExpr"' 6);  		LeaveRule_filterExpr ();  	}  	DebugLocation (144' 1);  }  finally {  	DebugExitRule (GrammarFileName' "filterExpr");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "filterExpr");  	DebugLocation (60' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  		int alt9 = 9;  		try {  			DebugEnterDecision (9' false);  			switch (input.LA (1)) {  			case CHAIN_OPERATOR:  			case COMPARATOR:  				{  					alt9 = 1;  				}  				break;  			case EXPR:  				{  					int LA9_2 = input.LA (2);  					if ((LA9_2 == DOWN)) {  						int LA9_3 = input.LA (3);  						if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  							alt9 = 2;  						}  						else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  							alt9 = 3;  						}  						else {  							NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  							DebugRecognitionException (nvae);  							throw nvae;  						}  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				break;  			case STRING:  				{  					alt9 = 4;  				}  				break;  			case REGEX:  				{  					alt9 = 5;  				}  				break;  			case NUMBER:  				{  					alt9 = 6;  				}  				break;  			case TRUE:  				{  					alt9 = 7;  				}  				break;  			case FALSE:  				{  					alt9 = 8;  				}  				break;  			case NULL:  				{  					alt9 = 9;  				}  				break;  			default: {  				NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  			}  		}  		finally {  			DebugExitDecision (9);  		}  		switch (alt9) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  			{  				DebugLocation (64' 4);  				DebugLocation (64' 6);  				PushFollow (Follow._comparator_in_filterExpr175);  				comparator6 = comparator ();  				PopFollow ();  				Match (input' TokenTypes.Down' null);  				DebugLocation (64' 18);  				PushFollow (Follow._filterExpr_in_filterExpr179);  				a = filterExpr ();  				PopFollow ();  				DebugLocation (64' 31);  				PushFollow (Follow._filterExpr_in_filterExpr183);  				b = filterExpr ();  				PopFollow ();  				Match (input' TokenTypes.Up' null);  				DebugLocation (65' 4);  				Comparator newComparator;  				switch (comparator6) {  				case "=":  					newComparator = Comparator.Equals;  					break;  				case "!=":  					newComparator = Comparator.NotEquals;  					break;  				case ">":  					newComparator = Comparator.Greater;  					break;  				case "<":  					newComparator = Comparator.Less;  					break;  				case ">=":  					newComparator = Comparator.GreaterOrEqual;  					break;  				case "<=":  					newComparator = Comparator.LessOrEqual;  					break;  				case "&":  					newComparator = Comparator.And;  					break;  				case "|":  					newComparator = Comparator.Or;  					break;  				default:  					newComparator = Comparator.Equals;  					break;  				}  				filterNode = new BoolExpression (a' newComparator' b);  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  			{  				DebugLocation (98' 4);  				DebugLocation (98' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr195);  				Match (input' TokenTypes.Down' null);  				DebugLocation (98' 12);  				PushFollow (Follow._filterExpr_in_filterExpr199);  				f = filterExpr ();  				PopFollow ();  				DebugLocation (98' 31);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  				int alt6 = 2;  				try {  					DebugEnterSubRule (6);  					try {  						DebugEnterDecision (6' false);  						int LA6_1 = input.LA (1);  						if ((LA6_1 == 24)) {  							alt6 = 1;  						}  					}  					finally {  						DebugExitDecision (6);  					}  					switch (alt6) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  						{  							DebugLocation (98' 31);  							inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (6);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (99' 4);  				FilterTreeNode newNode = f;  				if ((inverse != null ? inverse.Text : default(string)) == "!")  					newNode.ToggleInversed ();  				filterNode = newNode;  			}  			break;  		case 3:  			DebugEnterAlt (3);  			// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  			{  				DebugLocation (105' 4);  				DebugLocation (105' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr216);  				Match (input' TokenTypes.Down' null);  				DebugLocation (105' 12);  				PushFollow (Follow._propertyChain_in_filterExpr219);  				propertyChain (propertySegments);  				PopFollow ();  				DebugLocation (105' 51);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  				int alt7 = 2;  				try {  					DebugEnterSubRule (7);  					try {  						DebugEnterDecision (7' false);  						int LA7_1 = input.LA (1);  						if ((LA7_1 == 31)) {  							alt7 = 1;  						}  					}  					finally {  						DebugExitDecision (7);  					}  					switch (alt7) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  						{  							DebugLocation (105' 51);  							inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (7);  				}  				DebugLocation (105' 60);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  				int alt8 = 2;  				try {  					DebugEnterSubRule (8);  					try {  						DebugEnterDecision (8' false);  						int LA8_1 = input.LA (1);  						if ((LA8_1 == 24)) {  							alt8 = 1;  						}  					}  					finally {  						DebugExitDecision (8);  					}  					switch (alt8) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  						{  							DebugLocation (105' 60);  							not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (8);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (106' 4);  				FilterTreeNode newProperty = new Property (propertySegments);  				if ((inverse != null ? inverse.Text : default(string)) == "?")  					filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  				else {  					if ((not != null ? not.Text : default(string)) == "!")  						newProperty.ToggleInversed ();  					filterNode = newProperty;  				}  			}  			break;  		case 4:  			DebugEnterAlt (4);  			// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  			{  				DebugLocation (116' 4);  				STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  				DebugLocation (117' 4);  				string stringText = (STRING7 != null ? STRING7.Text : default(string));  				stringText = stringText.Substring (1' stringText.Length - 2);  				filterNode = new Value (stringText);  			}  			break;  		case 5:  			DebugEnterAlt (5);  			// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  			{  				DebugLocation (122' 4);  				REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  				DebugLocation (123' 4);  				string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  				regexText = regexText.Substring (1' regexText.Length - 2);  				filterNode = new RegExp (regexText);  			}  			break;  		case 6:  			DebugEnterAlt (6);  			// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  			{  				DebugLocation (128' 4);  				NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  				DebugLocation (129' 4);  				filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  			}  			break;  		case 7:  			DebugEnterAlt (7);  			// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  			{  				DebugLocation (132' 4);  				Match (input' TRUE' Follow._TRUE_in_filterExpr271);  				DebugLocation (133' 4);  				filterNode = new Value (true);  			}  			break;  		case 8:  			DebugEnterAlt (8);  			// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  			{  				DebugLocation (136' 4);  				Match (input' FALSE' Follow._FALSE_in_filterExpr281);  				DebugLocation (137' 4);  				filterNode = new Value (false);  			}  			break;  		case 9:  			DebugEnterAlt (9);  			// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  			{  				DebugLocation (140' 4);  				Match (input' NULL' Follow._NULL_in_filterExpr291);  				DebugLocation (141' 4);  				filterNode = new Value (null);  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("filterExpr"' 6);  		LeaveRule ("filterExpr"' 6);  		LeaveRule_filterExpr ();  	}  	DebugLocation (144' 1);  }  finally {  	DebugExitRule (GrammarFileName' "filterExpr");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "filterExpr");  	DebugLocation (60' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  		int alt9 = 9;  		try {  			DebugEnterDecision (9' false);  			switch (input.LA (1)) {  			case CHAIN_OPERATOR:  			case COMPARATOR:  				{  					alt9 = 1;  				}  				break;  			case EXPR:  				{  					int LA9_2 = input.LA (2);  					if ((LA9_2 == DOWN)) {  						int LA9_3 = input.LA (3);  						if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  							alt9 = 2;  						}  						else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  							alt9 = 3;  						}  						else {  							NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  							DebugRecognitionException (nvae);  							throw nvae;  						}  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				break;  			case STRING:  				{  					alt9 = 4;  				}  				break;  			case REGEX:  				{  					alt9 = 5;  				}  				break;  			case NUMBER:  				{  					alt9 = 6;  				}  				break;  			case TRUE:  				{  					alt9 = 7;  				}  				break;  			case FALSE:  				{  					alt9 = 8;  				}  				break;  			case NULL:  				{  					alt9 = 9;  				}  				break;  			default: {  				NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  			}  		}  		finally {  			DebugExitDecision (9);  		}  		switch (alt9) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  			{  				DebugLocation (64' 4);  				DebugLocation (64' 6);  				PushFollow (Follow._comparator_in_filterExpr175);  				comparator6 = comparator ();  				PopFollow ();  				Match (input' TokenTypes.Down' null);  				DebugLocation (64' 18);  				PushFollow (Follow._filterExpr_in_filterExpr179);  				a = filterExpr ();  				PopFollow ();  				DebugLocation (64' 31);  				PushFollow (Follow._filterExpr_in_filterExpr183);  				b = filterExpr ();  				PopFollow ();  				Match (input' TokenTypes.Up' null);  				DebugLocation (65' 4);  				Comparator newComparator;  				switch (comparator6) {  				case "=":  					newComparator = Comparator.Equals;  					break;  				case "!=":  					newComparator = Comparator.NotEquals;  					break;  				case ">":  					newComparator = Comparator.Greater;  					break;  				case "<":  					newComparator = Comparator.Less;  					break;  				case ">=":  					newComparator = Comparator.GreaterOrEqual;  					break;  				case "<=":  					newComparator = Comparator.LessOrEqual;  					break;  				case "&":  					newComparator = Comparator.And;  					break;  				case "|":  					newComparator = Comparator.Or;  					break;  				default:  					newComparator = Comparator.Equals;  					break;  				}  				filterNode = new BoolExpression (a' newComparator' b);  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  			{  				DebugLocation (98' 4);  				DebugLocation (98' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr195);  				Match (input' TokenTypes.Down' null);  				DebugLocation (98' 12);  				PushFollow (Follow._filterExpr_in_filterExpr199);  				f = filterExpr ();  				PopFollow ();  				DebugLocation (98' 31);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  				int alt6 = 2;  				try {  					DebugEnterSubRule (6);  					try {  						DebugEnterDecision (6' false);  						int LA6_1 = input.LA (1);  						if ((LA6_1 == 24)) {  							alt6 = 1;  						}  					}  					finally {  						DebugExitDecision (6);  					}  					switch (alt6) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  						{  							DebugLocation (98' 31);  							inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (6);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (99' 4);  				FilterTreeNode newNode = f;  				if ((inverse != null ? inverse.Text : default(string)) == "!")  					newNode.ToggleInversed ();  				filterNode = newNode;  			}  			break;  		case 3:  			DebugEnterAlt (3);  			// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  			{  				DebugLocation (105' 4);  				DebugLocation (105' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr216);  				Match (input' TokenTypes.Down' null);  				DebugLocation (105' 12);  				PushFollow (Follow._propertyChain_in_filterExpr219);  				propertyChain (propertySegments);  				PopFollow ();  				DebugLocation (105' 51);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  				int alt7 = 2;  				try {  					DebugEnterSubRule (7);  					try {  						DebugEnterDecision (7' false);  						int LA7_1 = input.LA (1);  						if ((LA7_1 == 31)) {  							alt7 = 1;  						}  					}  					finally {  						DebugExitDecision (7);  					}  					switch (alt7) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  						{  							DebugLocation (105' 51);  							inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (7);  				}  				DebugLocation (105' 60);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  				int alt8 = 2;  				try {  					DebugEnterSubRule (8);  					try {  						DebugEnterDecision (8' false);  						int LA8_1 = input.LA (1);  						if ((LA8_1 == 24)) {  							alt8 = 1;  						}  					}  					finally {  						DebugExitDecision (8);  					}  					switch (alt8) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  						{  							DebugLocation (105' 60);  							not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (8);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (106' 4);  				FilterTreeNode newProperty = new Property (propertySegments);  				if ((inverse != null ? inverse.Text : default(string)) == "?")  					filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  				else {  					if ((not != null ? not.Text : default(string)) == "!")  						newProperty.ToggleInversed ();  					filterNode = newProperty;  				}  			}  			break;  		case 4:  			DebugEnterAlt (4);  			// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  			{  				DebugLocation (116' 4);  				STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  				DebugLocation (117' 4);  				string stringText = (STRING7 != null ? STRING7.Text : default(string));  				stringText = stringText.Substring (1' stringText.Length - 2);  				filterNode = new Value (stringText);  			}  			break;  		case 5:  			DebugEnterAlt (5);  			// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  			{  				DebugLocation (122' 4);  				REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  				DebugLocation (123' 4);  				string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  				regexText = regexText.Substring (1' regexText.Length - 2);  				filterNode = new RegExp (regexText);  			}  			break;  		case 6:  			DebugEnterAlt (6);  			// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  			{  				DebugLocation (128' 4);  				NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  				DebugLocation (129' 4);  				filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  			}  			break;  		case 7:  			DebugEnterAlt (7);  			// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  			{  				DebugLocation (132' 4);  				Match (input' TRUE' Follow._TRUE_in_filterExpr271);  				DebugLocation (133' 4);  				filterNode = new Value (true);  			}  			break;  		case 8:  			DebugEnterAlt (8);  			// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  			{  				DebugLocation (136' 4);  				Match (input' FALSE' Follow._FALSE_in_filterExpr281);  				DebugLocation (137' 4);  				filterNode = new Value (false);  			}  			break;  		case 9:  			DebugEnterAlt (9);  			// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  			{  				DebugLocation (140' 4);  				Match (input' NULL' Follow._NULL_in_filterExpr291);  				DebugLocation (141' 4);  				filterNode = new Value (null);  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("filterExpr"' 6);  		LeaveRule ("filterExpr"' 6);  		LeaveRule_filterExpr ();  	}  	DebugLocation (144' 1);  }  finally {  	DebugExitRule (GrammarFileName' "filterExpr");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "filterExpr");  	DebugLocation (60' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  		int alt9 = 9;  		try {  			DebugEnterDecision (9' false);  			switch (input.LA (1)) {  			case CHAIN_OPERATOR:  			case COMPARATOR:  				{  					alt9 = 1;  				}  				break;  			case EXPR:  				{  					int LA9_2 = input.LA (2);  					if ((LA9_2 == DOWN)) {  						int LA9_3 = input.LA (3);  						if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  							alt9 = 2;  						}  						else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  							alt9 = 3;  						}  						else {  							NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  							DebugRecognitionException (nvae);  							throw nvae;  						}  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				break;  			case STRING:  				{  					alt9 = 4;  				}  				break;  			case REGEX:  				{  					alt9 = 5;  				}  				break;  			case NUMBER:  				{  					alt9 = 6;  				}  				break;  			case TRUE:  				{  					alt9 = 7;  				}  				break;  			case FALSE:  				{  					alt9 = 8;  				}  				break;  			case NULL:  				{  					alt9 = 9;  				}  				break;  			default: {  				NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  			}  		}  		finally {  			DebugExitDecision (9);  		}  		switch (alt9) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  			{  				DebugLocation (64' 4);  				DebugLocation (64' 6);  				PushFollow (Follow._comparator_in_filterExpr175);  				comparator6 = comparator ();  				PopFollow ();  				Match (input' TokenTypes.Down' null);  				DebugLocation (64' 18);  				PushFollow (Follow._filterExpr_in_filterExpr179);  				a = filterExpr ();  				PopFollow ();  				DebugLocation (64' 31);  				PushFollow (Follow._filterExpr_in_filterExpr183);  				b = filterExpr ();  				PopFollow ();  				Match (input' TokenTypes.Up' null);  				DebugLocation (65' 4);  				Comparator newComparator;  				switch (comparator6) {  				case "=":  					newComparator = Comparator.Equals;  					break;  				case "!=":  					newComparator = Comparator.NotEquals;  					break;  				case ">":  					newComparator = Comparator.Greater;  					break;  				case "<":  					newComparator = Comparator.Less;  					break;  				case ">=":  					newComparator = Comparator.GreaterOrEqual;  					break;  				case "<=":  					newComparator = Comparator.LessOrEqual;  					break;  				case "&":  					newComparator = Comparator.And;  					break;  				case "|":  					newComparator = Comparator.Or;  					break;  				default:  					newComparator = Comparator.Equals;  					break;  				}  				filterNode = new BoolExpression (a' newComparator' b);  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  			{  				DebugLocation (98' 4);  				DebugLocation (98' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr195);  				Match (input' TokenTypes.Down' null);  				DebugLocation (98' 12);  				PushFollow (Follow._filterExpr_in_filterExpr199);  				f = filterExpr ();  				PopFollow ();  				DebugLocation (98' 31);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  				int alt6 = 2;  				try {  					DebugEnterSubRule (6);  					try {  						DebugEnterDecision (6' false);  						int LA6_1 = input.LA (1);  						if ((LA6_1 == 24)) {  							alt6 = 1;  						}  					}  					finally {  						DebugExitDecision (6);  					}  					switch (alt6) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  						{  							DebugLocation (98' 31);  							inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (6);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (99' 4);  				FilterTreeNode newNode = f;  				if ((inverse != null ? inverse.Text : default(string)) == "!")  					newNode.ToggleInversed ();  				filterNode = newNode;  			}  			break;  		case 3:  			DebugEnterAlt (3);  			// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  			{  				DebugLocation (105' 4);  				DebugLocation (105' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr216);  				Match (input' TokenTypes.Down' null);  				DebugLocation (105' 12);  				PushFollow (Follow._propertyChain_in_filterExpr219);  				propertyChain (propertySegments);  				PopFollow ();  				DebugLocation (105' 51);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  				int alt7 = 2;  				try {  					DebugEnterSubRule (7);  					try {  						DebugEnterDecision (7' false);  						int LA7_1 = input.LA (1);  						if ((LA7_1 == 31)) {  							alt7 = 1;  						}  					}  					finally {  						DebugExitDecision (7);  					}  					switch (alt7) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  						{  							DebugLocation (105' 51);  							inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (7);  				}  				DebugLocation (105' 60);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  				int alt8 = 2;  				try {  					DebugEnterSubRule (8);  					try {  						DebugEnterDecision (8' false);  						int LA8_1 = input.LA (1);  						if ((LA8_1 == 24)) {  							alt8 = 1;  						}  					}  					finally {  						DebugExitDecision (8);  					}  					switch (alt8) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  						{  							DebugLocation (105' 60);  							not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (8);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (106' 4);  				FilterTreeNode newProperty = new Property (propertySegments);  				if ((inverse != null ? inverse.Text : default(string)) == "?")  					filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  				else {  					if ((not != null ? not.Text : default(string)) == "!")  						newProperty.ToggleInversed ();  					filterNode = newProperty;  				}  			}  			break;  		case 4:  			DebugEnterAlt (4);  			// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  			{  				DebugLocation (116' 4);  				STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  				DebugLocation (117' 4);  				string stringText = (STRING7 != null ? STRING7.Text : default(string));  				stringText = stringText.Substring (1' stringText.Length - 2);  				filterNode = new Value (stringText);  			}  			break;  		case 5:  			DebugEnterAlt (5);  			// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  			{  				DebugLocation (122' 4);  				REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  				DebugLocation (123' 4);  				string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  				regexText = regexText.Substring (1' regexText.Length - 2);  				filterNode = new RegExp (regexText);  			}  			break;  		case 6:  			DebugEnterAlt (6);  			// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  			{  				DebugLocation (128' 4);  				NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  				DebugLocation (129' 4);  				filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  			}  			break;  		case 7:  			DebugEnterAlt (7);  			// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  			{  				DebugLocation (132' 4);  				Match (input' TRUE' Follow._TRUE_in_filterExpr271);  				DebugLocation (133' 4);  				filterNode = new Value (true);  			}  			break;  		case 8:  			DebugEnterAlt (8);  			// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  			{  				DebugLocation (136' 4);  				Match (input' FALSE' Follow._FALSE_in_filterExpr281);  				DebugLocation (137' 4);  				filterNode = new Value (false);  			}  			break;  		case 9:  			DebugEnterAlt (9);  			// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  			{  				DebugLocation (140' 4);  				Match (input' NULL' Follow._NULL_in_filterExpr291);  				DebugLocation (141' 4);  				filterNode = new Value (null);  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("filterExpr"' 6);  		LeaveRule ("filterExpr"' 6);  		LeaveRule_filterExpr ();  	}  	DebugLocation (144' 1);  }  finally {  	DebugExitRule (GrammarFileName' "filterExpr");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "filterExpr");  	DebugLocation (60' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  		int alt9 = 9;  		try {  			DebugEnterDecision (9' false);  			switch (input.LA (1)) {  			case CHAIN_OPERATOR:  			case COMPARATOR:  				{  					alt9 = 1;  				}  				break;  			case EXPR:  				{  					int LA9_2 = input.LA (2);  					if ((LA9_2 == DOWN)) {  						int LA9_3 = input.LA (3);  						if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  							alt9 = 2;  						}  						else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  							alt9 = 3;  						}  						else {  							NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  							DebugRecognitionException (nvae);  							throw nvae;  						}  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				break;  			case STRING:  				{  					alt9 = 4;  				}  				break;  			case REGEX:  				{  					alt9 = 5;  				}  				break;  			case NUMBER:  				{  					alt9 = 6;  				}  				break;  			case TRUE:  				{  					alt9 = 7;  				}  				break;  			case FALSE:  				{  					alt9 = 8;  				}  				break;  			case NULL:  				{  					alt9 = 9;  				}  				break;  			default: {  				NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  			}  		}  		finally {  			DebugExitDecision (9);  		}  		switch (alt9) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  			{  				DebugLocation (64' 4);  				DebugLocation (64' 6);  				PushFollow (Follow._comparator_in_filterExpr175);  				comparator6 = comparator ();  				PopFollow ();  				Match (input' TokenTypes.Down' null);  				DebugLocation (64' 18);  				PushFollow (Follow._filterExpr_in_filterExpr179);  				a = filterExpr ();  				PopFollow ();  				DebugLocation (64' 31);  				PushFollow (Follow._filterExpr_in_filterExpr183);  				b = filterExpr ();  				PopFollow ();  				Match (input' TokenTypes.Up' null);  				DebugLocation (65' 4);  				Comparator newComparator;  				switch (comparator6) {  				case "=":  					newComparator = Comparator.Equals;  					break;  				case "!=":  					newComparator = Comparator.NotEquals;  					break;  				case ">":  					newComparator = Comparator.Greater;  					break;  				case "<":  					newComparator = Comparator.Less;  					break;  				case ">=":  					newComparator = Comparator.GreaterOrEqual;  					break;  				case "<=":  					newComparator = Comparator.LessOrEqual;  					break;  				case "&":  					newComparator = Comparator.And;  					break;  				case "|":  					newComparator = Comparator.Or;  					break;  				default:  					newComparator = Comparator.Equals;  					break;  				}  				filterNode = new BoolExpression (a' newComparator' b);  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  			{  				DebugLocation (98' 4);  				DebugLocation (98' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr195);  				Match (input' TokenTypes.Down' null);  				DebugLocation (98' 12);  				PushFollow (Follow._filterExpr_in_filterExpr199);  				f = filterExpr ();  				PopFollow ();  				DebugLocation (98' 31);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  				int alt6 = 2;  				try {  					DebugEnterSubRule (6);  					try {  						DebugEnterDecision (6' false);  						int LA6_1 = input.LA (1);  						if ((LA6_1 == 24)) {  							alt6 = 1;  						}  					}  					finally {  						DebugExitDecision (6);  					}  					switch (alt6) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  						{  							DebugLocation (98' 31);  							inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (6);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (99' 4);  				FilterTreeNode newNode = f;  				if ((inverse != null ? inverse.Text : default(string)) == "!")  					newNode.ToggleInversed ();  				filterNode = newNode;  			}  			break;  		case 3:  			DebugEnterAlt (3);  			// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  			{  				DebugLocation (105' 4);  				DebugLocation (105' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr216);  				Match (input' TokenTypes.Down' null);  				DebugLocation (105' 12);  				PushFollow (Follow._propertyChain_in_filterExpr219);  				propertyChain (propertySegments);  				PopFollow ();  				DebugLocation (105' 51);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  				int alt7 = 2;  				try {  					DebugEnterSubRule (7);  					try {  						DebugEnterDecision (7' false);  						int LA7_1 = input.LA (1);  						if ((LA7_1 == 31)) {  							alt7 = 1;  						}  					}  					finally {  						DebugExitDecision (7);  					}  					switch (alt7) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  						{  							DebugLocation (105' 51);  							inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (7);  				}  				DebugLocation (105' 60);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  				int alt8 = 2;  				try {  					DebugEnterSubRule (8);  					try {  						DebugEnterDecision (8' false);  						int LA8_1 = input.LA (1);  						if ((LA8_1 == 24)) {  							alt8 = 1;  						}  					}  					finally {  						DebugExitDecision (8);  					}  					switch (alt8) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  						{  							DebugLocation (105' 60);  							not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (8);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (106' 4);  				FilterTreeNode newProperty = new Property (propertySegments);  				if ((inverse != null ? inverse.Text : default(string)) == "?")  					filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  				else {  					if ((not != null ? not.Text : default(string)) == "!")  						newProperty.ToggleInversed ();  					filterNode = newProperty;  				}  			}  			break;  		case 4:  			DebugEnterAlt (4);  			// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  			{  				DebugLocation (116' 4);  				STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  				DebugLocation (117' 4);  				string stringText = (STRING7 != null ? STRING7.Text : default(string));  				stringText = stringText.Substring (1' stringText.Length - 2);  				filterNode = new Value (stringText);  			}  			break;  		case 5:  			DebugEnterAlt (5);  			// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  			{  				DebugLocation (122' 4);  				REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  				DebugLocation (123' 4);  				string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  				regexText = regexText.Substring (1' regexText.Length - 2);  				filterNode = new RegExp (regexText);  			}  			break;  		case 6:  			DebugEnterAlt (6);  			// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  			{  				DebugLocation (128' 4);  				NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  				DebugLocation (129' 4);  				filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  			}  			break;  		case 7:  			DebugEnterAlt (7);  			// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  			{  				DebugLocation (132' 4);  				Match (input' TRUE' Follow._TRUE_in_filterExpr271);  				DebugLocation (133' 4);  				filterNode = new Value (true);  			}  			break;  		case 8:  			DebugEnterAlt (8);  			// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  			{  				DebugLocation (136' 4);  				Match (input' FALSE' Follow._FALSE_in_filterExpr281);  				DebugLocation (137' 4);  				filterNode = new Value (false);  			}  			break;  		case 9:  			DebugEnterAlt (9);  			// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  			{  				DebugLocation (140' 4);  				Match (input' NULL' Follow._NULL_in_filterExpr291);  				DebugLocation (141' 4);  				filterNode = new Value (null);  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("filterExpr"' 6);  		LeaveRule ("filterExpr"' 6);  		LeaveRule_filterExpr ();  	}  	DebugLocation (144' 1);  }  finally {  	DebugExitRule (GrammarFileName' "filterExpr");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "filterExpr");  	DebugLocation (60' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  		int alt9 = 9;  		try {  			DebugEnterDecision (9' false);  			switch (input.LA (1)) {  			case CHAIN_OPERATOR:  			case COMPARATOR:  				{  					alt9 = 1;  				}  				break;  			case EXPR:  				{  					int LA9_2 = input.LA (2);  					if ((LA9_2 == DOWN)) {  						int LA9_3 = input.LA (3);  						if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  							alt9 = 2;  						}  						else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  							alt9 = 3;  						}  						else {  							NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  							DebugRecognitionException (nvae);  							throw nvae;  						}  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				break;  			case STRING:  				{  					alt9 = 4;  				}  				break;  			case REGEX:  				{  					alt9 = 5;  				}  				break;  			case NUMBER:  				{  					alt9 = 6;  				}  				break;  			case TRUE:  				{  					alt9 = 7;  				}  				break;  			case FALSE:  				{  					alt9 = 8;  				}  				break;  			case NULL:  				{  					alt9 = 9;  				}  				break;  			default: {  				NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  			}  		}  		finally {  			DebugExitDecision (9);  		}  		switch (alt9) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  			{  				DebugLocation (64' 4);  				DebugLocation (64' 6);  				PushFollow (Follow._comparator_in_filterExpr175);  				comparator6 = comparator ();  				PopFollow ();  				Match (input' TokenTypes.Down' null);  				DebugLocation (64' 18);  				PushFollow (Follow._filterExpr_in_filterExpr179);  				a = filterExpr ();  				PopFollow ();  				DebugLocation (64' 31);  				PushFollow (Follow._filterExpr_in_filterExpr183);  				b = filterExpr ();  				PopFollow ();  				Match (input' TokenTypes.Up' null);  				DebugLocation (65' 4);  				Comparator newComparator;  				switch (comparator6) {  				case "=":  					newComparator = Comparator.Equals;  					break;  				case "!=":  					newComparator = Comparator.NotEquals;  					break;  				case ">":  					newComparator = Comparator.Greater;  					break;  				case "<":  					newComparator = Comparator.Less;  					break;  				case ">=":  					newComparator = Comparator.GreaterOrEqual;  					break;  				case "<=":  					newComparator = Comparator.LessOrEqual;  					break;  				case "&":  					newComparator = Comparator.And;  					break;  				case "|":  					newComparator = Comparator.Or;  					break;  				default:  					newComparator = Comparator.Equals;  					break;  				}  				filterNode = new BoolExpression (a' newComparator' b);  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  			{  				DebugLocation (98' 4);  				DebugLocation (98' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr195);  				Match (input' TokenTypes.Down' null);  				DebugLocation (98' 12);  				PushFollow (Follow._filterExpr_in_filterExpr199);  				f = filterExpr ();  				PopFollow ();  				DebugLocation (98' 31);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  				int alt6 = 2;  				try {  					DebugEnterSubRule (6);  					try {  						DebugEnterDecision (6' false);  						int LA6_1 = input.LA (1);  						if ((LA6_1 == 24)) {  							alt6 = 1;  						}  					}  					finally {  						DebugExitDecision (6);  					}  					switch (alt6) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  						{  							DebugLocation (98' 31);  							inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (6);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (99' 4);  				FilterTreeNode newNode = f;  				if ((inverse != null ? inverse.Text : default(string)) == "!")  					newNode.ToggleInversed ();  				filterNode = newNode;  			}  			break;  		case 3:  			DebugEnterAlt (3);  			// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  			{  				DebugLocation (105' 4);  				DebugLocation (105' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr216);  				Match (input' TokenTypes.Down' null);  				DebugLocation (105' 12);  				PushFollow (Follow._propertyChain_in_filterExpr219);  				propertyChain (propertySegments);  				PopFollow ();  				DebugLocation (105' 51);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  				int alt7 = 2;  				try {  					DebugEnterSubRule (7);  					try {  						DebugEnterDecision (7' false);  						int LA7_1 = input.LA (1);  						if ((LA7_1 == 31)) {  							alt7 = 1;  						}  					}  					finally {  						DebugExitDecision (7);  					}  					switch (alt7) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  						{  							DebugLocation (105' 51);  							inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (7);  				}  				DebugLocation (105' 60);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  				int alt8 = 2;  				try {  					DebugEnterSubRule (8);  					try {  						DebugEnterDecision (8' false);  						int LA8_1 = input.LA (1);  						if ((LA8_1 == 24)) {  							alt8 = 1;  						}  					}  					finally {  						DebugExitDecision (8);  					}  					switch (alt8) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  						{  							DebugLocation (105' 60);  							not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (8);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (106' 4);  				FilterTreeNode newProperty = new Property (propertySegments);  				if ((inverse != null ? inverse.Text : default(string)) == "?")  					filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  				else {  					if ((not != null ? not.Text : default(string)) == "!")  						newProperty.ToggleInversed ();  					filterNode = newProperty;  				}  			}  			break;  		case 4:  			DebugEnterAlt (4);  			// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  			{  				DebugLocation (116' 4);  				STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  				DebugLocation (117' 4);  				string stringText = (STRING7 != null ? STRING7.Text : default(string));  				stringText = stringText.Substring (1' stringText.Length - 2);  				filterNode = new Value (stringText);  			}  			break;  		case 5:  			DebugEnterAlt (5);  			// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  			{  				DebugLocation (122' 4);  				REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  				DebugLocation (123' 4);  				string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  				regexText = regexText.Substring (1' regexText.Length - 2);  				filterNode = new RegExp (regexText);  			}  			break;  		case 6:  			DebugEnterAlt (6);  			// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  			{  				DebugLocation (128' 4);  				NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  				DebugLocation (129' 4);  				filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  			}  			break;  		case 7:  			DebugEnterAlt (7);  			// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  			{  				DebugLocation (132' 4);  				Match (input' TRUE' Follow._TRUE_in_filterExpr271);  				DebugLocation (133' 4);  				filterNode = new Value (true);  			}  			break;  		case 8:  			DebugEnterAlt (8);  			// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  			{  				DebugLocation (136' 4);  				Match (input' FALSE' Follow._FALSE_in_filterExpr281);  				DebugLocation (137' 4);  				filterNode = new Value (false);  			}  			break;  		case 9:  			DebugEnterAlt (9);  			// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  			{  				DebugLocation (140' 4);  				Match (input' NULL' Follow._NULL_in_filterExpr291);  				DebugLocation (141' 4);  				filterNode = new Value (null);  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("filterExpr"' 6);  		LeaveRule ("filterExpr"' 6);  		LeaveRule_filterExpr ();  	}  	DebugLocation (144' 1);  }  finally {  	DebugExitRule (GrammarFileName' "filterExpr");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "filterExpr");  	DebugLocation (60' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  		int alt9 = 9;  		try {  			DebugEnterDecision (9' false);  			switch (input.LA (1)) {  			case CHAIN_OPERATOR:  			case COMPARATOR:  				{  					alt9 = 1;  				}  				break;  			case EXPR:  				{  					int LA9_2 = input.LA (2);  					if ((LA9_2 == DOWN)) {  						int LA9_3 = input.LA (3);  						if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  							alt9 = 2;  						}  						else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  							alt9 = 3;  						}  						else {  							NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  							DebugRecognitionException (nvae);  							throw nvae;  						}  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				break;  			case STRING:  				{  					alt9 = 4;  				}  				break;  			case REGEX:  				{  					alt9 = 5;  				}  				break;  			case NUMBER:  				{  					alt9 = 6;  				}  				break;  			case TRUE:  				{  					alt9 = 7;  				}  				break;  			case FALSE:  				{  					alt9 = 8;  				}  				break;  			case NULL:  				{  					alt9 = 9;  				}  				break;  			default: {  				NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  			}  		}  		finally {  			DebugExitDecision (9);  		}  		switch (alt9) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  			{  				DebugLocation (64' 4);  				DebugLocation (64' 6);  				PushFollow (Follow._comparator_in_filterExpr175);  				comparator6 = comparator ();  				PopFollow ();  				Match (input' TokenTypes.Down' null);  				DebugLocation (64' 18);  				PushFollow (Follow._filterExpr_in_filterExpr179);  				a = filterExpr ();  				PopFollow ();  				DebugLocation (64' 31);  				PushFollow (Follow._filterExpr_in_filterExpr183);  				b = filterExpr ();  				PopFollow ();  				Match (input' TokenTypes.Up' null);  				DebugLocation (65' 4);  				Comparator newComparator;  				switch (comparator6) {  				case "=":  					newComparator = Comparator.Equals;  					break;  				case "!=":  					newComparator = Comparator.NotEquals;  					break;  				case ">":  					newComparator = Comparator.Greater;  					break;  				case "<":  					newComparator = Comparator.Less;  					break;  				case ">=":  					newComparator = Comparator.GreaterOrEqual;  					break;  				case "<=":  					newComparator = Comparator.LessOrEqual;  					break;  				case "&":  					newComparator = Comparator.And;  					break;  				case "|":  					newComparator = Comparator.Or;  					break;  				default:  					newComparator = Comparator.Equals;  					break;  				}  				filterNode = new BoolExpression (a' newComparator' b);  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  			{  				DebugLocation (98' 4);  				DebugLocation (98' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr195);  				Match (input' TokenTypes.Down' null);  				DebugLocation (98' 12);  				PushFollow (Follow._filterExpr_in_filterExpr199);  				f = filterExpr ();  				PopFollow ();  				DebugLocation (98' 31);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  				int alt6 = 2;  				try {  					DebugEnterSubRule (6);  					try {  						DebugEnterDecision (6' false);  						int LA6_1 = input.LA (1);  						if ((LA6_1 == 24)) {  							alt6 = 1;  						}  					}  					finally {  						DebugExitDecision (6);  					}  					switch (alt6) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  						{  							DebugLocation (98' 31);  							inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (6);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (99' 4);  				FilterTreeNode newNode = f;  				if ((inverse != null ? inverse.Text : default(string)) == "!")  					newNode.ToggleInversed ();  				filterNode = newNode;  			}  			break;  		case 3:  			DebugEnterAlt (3);  			// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  			{  				DebugLocation (105' 4);  				DebugLocation (105' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr216);  				Match (input' TokenTypes.Down' null);  				DebugLocation (105' 12);  				PushFollow (Follow._propertyChain_in_filterExpr219);  				propertyChain (propertySegments);  				PopFollow ();  				DebugLocation (105' 51);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  				int alt7 = 2;  				try {  					DebugEnterSubRule (7);  					try {  						DebugEnterDecision (7' false);  						int LA7_1 = input.LA (1);  						if ((LA7_1 == 31)) {  							alt7 = 1;  						}  					}  					finally {  						DebugExitDecision (7);  					}  					switch (alt7) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  						{  							DebugLocation (105' 51);  							inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (7);  				}  				DebugLocation (105' 60);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  				int alt8 = 2;  				try {  					DebugEnterSubRule (8);  					try {  						DebugEnterDecision (8' false);  						int LA8_1 = input.LA (1);  						if ((LA8_1 == 24)) {  							alt8 = 1;  						}  					}  					finally {  						DebugExitDecision (8);  					}  					switch (alt8) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  						{  							DebugLocation (105' 60);  							not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (8);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (106' 4);  				FilterTreeNode newProperty = new Property (propertySegments);  				if ((inverse != null ? inverse.Text : default(string)) == "?")  					filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  				else {  					if ((not != null ? not.Text : default(string)) == "!")  						newProperty.ToggleInversed ();  					filterNode = newProperty;  				}  			}  			break;  		case 4:  			DebugEnterAlt (4);  			// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  			{  				DebugLocation (116' 4);  				STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  				DebugLocation (117' 4);  				string stringText = (STRING7 != null ? STRING7.Text : default(string));  				stringText = stringText.Substring (1' stringText.Length - 2);  				filterNode = new Value (stringText);  			}  			break;  		case 5:  			DebugEnterAlt (5);  			// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  			{  				DebugLocation (122' 4);  				REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  				DebugLocation (123' 4);  				string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  				regexText = regexText.Substring (1' regexText.Length - 2);  				filterNode = new RegExp (regexText);  			}  			break;  		case 6:  			DebugEnterAlt (6);  			// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  			{  				DebugLocation (128' 4);  				NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  				DebugLocation (129' 4);  				filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  			}  			break;  		case 7:  			DebugEnterAlt (7);  			// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  			{  				DebugLocation (132' 4);  				Match (input' TRUE' Follow._TRUE_in_filterExpr271);  				DebugLocation (133' 4);  				filterNode = new Value (true);  			}  			break;  		case 8:  			DebugEnterAlt (8);  			// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  			{  				DebugLocation (136' 4);  				Match (input' FALSE' Follow._FALSE_in_filterExpr281);  				DebugLocation (137' 4);  				filterNode = new Value (false);  			}  			break;  		case 9:  			DebugEnterAlt (9);  			// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  			{  				DebugLocation (140' 4);  				Match (input' NULL' Follow._NULL_in_filterExpr291);  				DebugLocation (141' 4);  				filterNode = new Value (null);  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("filterExpr"' 6);  		LeaveRule ("filterExpr"' 6);  		LeaveRule_filterExpr ();  	}  	DebugLocation (144' 1);  }  finally {  	DebugExitRule (GrammarFileName' "filterExpr");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "filterExpr");  	DebugLocation (60' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  		int alt9 = 9;  		try {  			DebugEnterDecision (9' false);  			switch (input.LA (1)) {  			case CHAIN_OPERATOR:  			case COMPARATOR:  				{  					alt9 = 1;  				}  				break;  			case EXPR:  				{  					int LA9_2 = input.LA (2);  					if ((LA9_2 == DOWN)) {  						int LA9_3 = input.LA (3);  						if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  							alt9 = 2;  						}  						else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  							alt9 = 3;  						}  						else {  							NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  							DebugRecognitionException (nvae);  							throw nvae;  						}  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				break;  			case STRING:  				{  					alt9 = 4;  				}  				break;  			case REGEX:  				{  					alt9 = 5;  				}  				break;  			case NUMBER:  				{  					alt9 = 6;  				}  				break;  			case TRUE:  				{  					alt9 = 7;  				}  				break;  			case FALSE:  				{  					alt9 = 8;  				}  				break;  			case NULL:  				{  					alt9 = 9;  				}  				break;  			default: {  				NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  			}  		}  		finally {  			DebugExitDecision (9);  		}  		switch (alt9) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  			{  				DebugLocation (64' 4);  				DebugLocation (64' 6);  				PushFollow (Follow._comparator_in_filterExpr175);  				comparator6 = comparator ();  				PopFollow ();  				Match (input' TokenTypes.Down' null);  				DebugLocation (64' 18);  				PushFollow (Follow._filterExpr_in_filterExpr179);  				a = filterExpr ();  				PopFollow ();  				DebugLocation (64' 31);  				PushFollow (Follow._filterExpr_in_filterExpr183);  				b = filterExpr ();  				PopFollow ();  				Match (input' TokenTypes.Up' null);  				DebugLocation (65' 4);  				Comparator newComparator;  				switch (comparator6) {  				case "=":  					newComparator = Comparator.Equals;  					break;  				case "!=":  					newComparator = Comparator.NotEquals;  					break;  				case ">":  					newComparator = Comparator.Greater;  					break;  				case "<":  					newComparator = Comparator.Less;  					break;  				case ">=":  					newComparator = Comparator.GreaterOrEqual;  					break;  				case "<=":  					newComparator = Comparator.LessOrEqual;  					break;  				case "&":  					newComparator = Comparator.And;  					break;  				case "|":  					newComparator = Comparator.Or;  					break;  				default:  					newComparator = Comparator.Equals;  					break;  				}  				filterNode = new BoolExpression (a' newComparator' b);  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  			{  				DebugLocation (98' 4);  				DebugLocation (98' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr195);  				Match (input' TokenTypes.Down' null);  				DebugLocation (98' 12);  				PushFollow (Follow._filterExpr_in_filterExpr199);  				f = filterExpr ();  				PopFollow ();  				DebugLocation (98' 31);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  				int alt6 = 2;  				try {  					DebugEnterSubRule (6);  					try {  						DebugEnterDecision (6' false);  						int LA6_1 = input.LA (1);  						if ((LA6_1 == 24)) {  							alt6 = 1;  						}  					}  					finally {  						DebugExitDecision (6);  					}  					switch (alt6) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  						{  							DebugLocation (98' 31);  							inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (6);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (99' 4);  				FilterTreeNode newNode = f;  				if ((inverse != null ? inverse.Text : default(string)) == "!")  					newNode.ToggleInversed ();  				filterNode = newNode;  			}  			break;  		case 3:  			DebugEnterAlt (3);  			// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  			{  				DebugLocation (105' 4);  				DebugLocation (105' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr216);  				Match (input' TokenTypes.Down' null);  				DebugLocation (105' 12);  				PushFollow (Follow._propertyChain_in_filterExpr219);  				propertyChain (propertySegments);  				PopFollow ();  				DebugLocation (105' 51);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  				int alt7 = 2;  				try {  					DebugEnterSubRule (7);  					try {  						DebugEnterDecision (7' false);  						int LA7_1 = input.LA (1);  						if ((LA7_1 == 31)) {  							alt7 = 1;  						}  					}  					finally {  						DebugExitDecision (7);  					}  					switch (alt7) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  						{  							DebugLocation (105' 51);  							inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (7);  				}  				DebugLocation (105' 60);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  				int alt8 = 2;  				try {  					DebugEnterSubRule (8);  					try {  						DebugEnterDecision (8' false);  						int LA8_1 = input.LA (1);  						if ((LA8_1 == 24)) {  							alt8 = 1;  						}  					}  					finally {  						DebugExitDecision (8);  					}  					switch (alt8) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  						{  							DebugLocation (105' 60);  							not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (8);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (106' 4);  				FilterTreeNode newProperty = new Property (propertySegments);  				if ((inverse != null ? inverse.Text : default(string)) == "?")  					filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  				else {  					if ((not != null ? not.Text : default(string)) == "!")  						newProperty.ToggleInversed ();  					filterNode = newProperty;  				}  			}  			break;  		case 4:  			DebugEnterAlt (4);  			// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  			{  				DebugLocation (116' 4);  				STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  				DebugLocation (117' 4);  				string stringText = (STRING7 != null ? STRING7.Text : default(string));  				stringText = stringText.Substring (1' stringText.Length - 2);  				filterNode = new Value (stringText);  			}  			break;  		case 5:  			DebugEnterAlt (5);  			// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  			{  				DebugLocation (122' 4);  				REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  				DebugLocation (123' 4);  				string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  				regexText = regexText.Substring (1' regexText.Length - 2);  				filterNode = new RegExp (regexText);  			}  			break;  		case 6:  			DebugEnterAlt (6);  			// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  			{  				DebugLocation (128' 4);  				NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  				DebugLocation (129' 4);  				filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  			}  			break;  		case 7:  			DebugEnterAlt (7);  			// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  			{  				DebugLocation (132' 4);  				Match (input' TRUE' Follow._TRUE_in_filterExpr271);  				DebugLocation (133' 4);  				filterNode = new Value (true);  			}  			break;  		case 8:  			DebugEnterAlt (8);  			// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  			{  				DebugLocation (136' 4);  				Match (input' FALSE' Follow._FALSE_in_filterExpr281);  				DebugLocation (137' 4);  				filterNode = new Value (false);  			}  			break;  		case 9:  			DebugEnterAlt (9);  			// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  			{  				DebugLocation (140' 4);  				Match (input' NULL' Follow._NULL_in_filterExpr291);  				DebugLocation (141' 4);  				filterNode = new Value (null);  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("filterExpr"' 6);  		LeaveRule ("filterExpr"' 6);  		LeaveRule_filterExpr ();  	}  	DebugLocation (144' 1);  }  finally {  	DebugExitRule (GrammarFileName' "filterExpr");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "filterExpr");  	DebugLocation (60' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  		int alt9 = 9;  		try {  			DebugEnterDecision (9' false);  			switch (input.LA (1)) {  			case CHAIN_OPERATOR:  			case COMPARATOR:  				{  					alt9 = 1;  				}  				break;  			case EXPR:  				{  					int LA9_2 = input.LA (2);  					if ((LA9_2 == DOWN)) {  						int LA9_3 = input.LA (3);  						if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  							alt9 = 2;  						}  						else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  							alt9 = 3;  						}  						else {  							NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  							DebugRecognitionException (nvae);  							throw nvae;  						}  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				break;  			case STRING:  				{  					alt9 = 4;  				}  				break;  			case REGEX:  				{  					alt9 = 5;  				}  				break;  			case NUMBER:  				{  					alt9 = 6;  				}  				break;  			case TRUE:  				{  					alt9 = 7;  				}  				break;  			case FALSE:  				{  					alt9 = 8;  				}  				break;  			case NULL:  				{  					alt9 = 9;  				}  				break;  			default: {  				NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  			}  		}  		finally {  			DebugExitDecision (9);  		}  		switch (alt9) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  			{  				DebugLocation (64' 4);  				DebugLocation (64' 6);  				PushFollow (Follow._comparator_in_filterExpr175);  				comparator6 = comparator ();  				PopFollow ();  				Match (input' TokenTypes.Down' null);  				DebugLocation (64' 18);  				PushFollow (Follow._filterExpr_in_filterExpr179);  				a = filterExpr ();  				PopFollow ();  				DebugLocation (64' 31);  				PushFollow (Follow._filterExpr_in_filterExpr183);  				b = filterExpr ();  				PopFollow ();  				Match (input' TokenTypes.Up' null);  				DebugLocation (65' 4);  				Comparator newComparator;  				switch (comparator6) {  				case "=":  					newComparator = Comparator.Equals;  					break;  				case "!=":  					newComparator = Comparator.NotEquals;  					break;  				case ">":  					newComparator = Comparator.Greater;  					break;  				case "<":  					newComparator = Comparator.Less;  					break;  				case ">=":  					newComparator = Comparator.GreaterOrEqual;  					break;  				case "<=":  					newComparator = Comparator.LessOrEqual;  					break;  				case "&":  					newComparator = Comparator.And;  					break;  				case "|":  					newComparator = Comparator.Or;  					break;  				default:  					newComparator = Comparator.Equals;  					break;  				}  				filterNode = new BoolExpression (a' newComparator' b);  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  			{  				DebugLocation (98' 4);  				DebugLocation (98' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr195);  				Match (input' TokenTypes.Down' null);  				DebugLocation (98' 12);  				PushFollow (Follow._filterExpr_in_filterExpr199);  				f = filterExpr ();  				PopFollow ();  				DebugLocation (98' 31);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  				int alt6 = 2;  				try {  					DebugEnterSubRule (6);  					try {  						DebugEnterDecision (6' false);  						int LA6_1 = input.LA (1);  						if ((LA6_1 == 24)) {  							alt6 = 1;  						}  					}  					finally {  						DebugExitDecision (6);  					}  					switch (alt6) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  						{  							DebugLocation (98' 31);  							inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (6);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (99' 4);  				FilterTreeNode newNode = f;  				if ((inverse != null ? inverse.Text : default(string)) == "!")  					newNode.ToggleInversed ();  				filterNode = newNode;  			}  			break;  		case 3:  			DebugEnterAlt (3);  			// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  			{  				DebugLocation (105' 4);  				DebugLocation (105' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr216);  				Match (input' TokenTypes.Down' null);  				DebugLocation (105' 12);  				PushFollow (Follow._propertyChain_in_filterExpr219);  				propertyChain (propertySegments);  				PopFollow ();  				DebugLocation (105' 51);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  				int alt7 = 2;  				try {  					DebugEnterSubRule (7);  					try {  						DebugEnterDecision (7' false);  						int LA7_1 = input.LA (1);  						if ((LA7_1 == 31)) {  							alt7 = 1;  						}  					}  					finally {  						DebugExitDecision (7);  					}  					switch (alt7) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  						{  							DebugLocation (105' 51);  							inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (7);  				}  				DebugLocation (105' 60);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  				int alt8 = 2;  				try {  					DebugEnterSubRule (8);  					try {  						DebugEnterDecision (8' false);  						int LA8_1 = input.LA (1);  						if ((LA8_1 == 24)) {  							alt8 = 1;  						}  					}  					finally {  						DebugExitDecision (8);  					}  					switch (alt8) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  						{  							DebugLocation (105' 60);  							not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (8);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (106' 4);  				FilterTreeNode newProperty = new Property (propertySegments);  				if ((inverse != null ? inverse.Text : default(string)) == "?")  					filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  				else {  					if ((not != null ? not.Text : default(string)) == "!")  						newProperty.ToggleInversed ();  					filterNode = newProperty;  				}  			}  			break;  		case 4:  			DebugEnterAlt (4);  			// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  			{  				DebugLocation (116' 4);  				STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  				DebugLocation (117' 4);  				string stringText = (STRING7 != null ? STRING7.Text : default(string));  				stringText = stringText.Substring (1' stringText.Length - 2);  				filterNode = new Value (stringText);  			}  			break;  		case 5:  			DebugEnterAlt (5);  			// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  			{  				DebugLocation (122' 4);  				REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  				DebugLocation (123' 4);  				string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  				regexText = regexText.Substring (1' regexText.Length - 2);  				filterNode = new RegExp (regexText);  			}  			break;  		case 6:  			DebugEnterAlt (6);  			// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  			{  				DebugLocation (128' 4);  				NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  				DebugLocation (129' 4);  				filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  			}  			break;  		case 7:  			DebugEnterAlt (7);  			// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  			{  				DebugLocation (132' 4);  				Match (input' TRUE' Follow._TRUE_in_filterExpr271);  				DebugLocation (133' 4);  				filterNode = new Value (true);  			}  			break;  		case 8:  			DebugEnterAlt (8);  			// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  			{  				DebugLocation (136' 4);  				Match (input' FALSE' Follow._FALSE_in_filterExpr281);  				DebugLocation (137' 4);  				filterNode = new Value (false);  			}  			break;  		case 9:  			DebugEnterAlt (9);  			// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  			{  				DebugLocation (140' 4);  				Match (input' NULL' Follow._NULL_in_filterExpr291);  				DebugLocation (141' 4);  				filterNode = new Value (null);  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("filterExpr"' 6);  		LeaveRule ("filterExpr"' 6);  		LeaveRule_filterExpr ();  	}  	DebugLocation (144' 1);  }  finally {  	DebugExitRule (GrammarFileName' "filterExpr");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "filterExpr");  	DebugLocation (60' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  		int alt9 = 9;  		try {  			DebugEnterDecision (9' false);  			switch (input.LA (1)) {  			case CHAIN_OPERATOR:  			case COMPARATOR:  				{  					alt9 = 1;  				}  				break;  			case EXPR:  				{  					int LA9_2 = input.LA (2);  					if ((LA9_2 == DOWN)) {  						int LA9_3 = input.LA (3);  						if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  							alt9 = 2;  						}  						else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  							alt9 = 3;  						}  						else {  							NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  							DebugRecognitionException (nvae);  							throw nvae;  						}  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				break;  			case STRING:  				{  					alt9 = 4;  				}  				break;  			case REGEX:  				{  					alt9 = 5;  				}  				break;  			case NUMBER:  				{  					alt9 = 6;  				}  				break;  			case TRUE:  				{  					alt9 = 7;  				}  				break;  			case FALSE:  				{  					alt9 = 8;  				}  				break;  			case NULL:  				{  					alt9 = 9;  				}  				break;  			default: {  				NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  			}  		}  		finally {  			DebugExitDecision (9);  		}  		switch (alt9) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  			{  				DebugLocation (64' 4);  				DebugLocation (64' 6);  				PushFollow (Follow._comparator_in_filterExpr175);  				comparator6 = comparator ();  				PopFollow ();  				Match (input' TokenTypes.Down' null);  				DebugLocation (64' 18);  				PushFollow (Follow._filterExpr_in_filterExpr179);  				a = filterExpr ();  				PopFollow ();  				DebugLocation (64' 31);  				PushFollow (Follow._filterExpr_in_filterExpr183);  				b = filterExpr ();  				PopFollow ();  				Match (input' TokenTypes.Up' null);  				DebugLocation (65' 4);  				Comparator newComparator;  				switch (comparator6) {  				case "=":  					newComparator = Comparator.Equals;  					break;  				case "!=":  					newComparator = Comparator.NotEquals;  					break;  				case ">":  					newComparator = Comparator.Greater;  					break;  				case "<":  					newComparator = Comparator.Less;  					break;  				case ">=":  					newComparator = Comparator.GreaterOrEqual;  					break;  				case "<=":  					newComparator = Comparator.LessOrEqual;  					break;  				case "&":  					newComparator = Comparator.And;  					break;  				case "|":  					newComparator = Comparator.Or;  					break;  				default:  					newComparator = Comparator.Equals;  					break;  				}  				filterNode = new BoolExpression (a' newComparator' b);  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  			{  				DebugLocation (98' 4);  				DebugLocation (98' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr195);  				Match (input' TokenTypes.Down' null);  				DebugLocation (98' 12);  				PushFollow (Follow._filterExpr_in_filterExpr199);  				f = filterExpr ();  				PopFollow ();  				DebugLocation (98' 31);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  				int alt6 = 2;  				try {  					DebugEnterSubRule (6);  					try {  						DebugEnterDecision (6' false);  						int LA6_1 = input.LA (1);  						if ((LA6_1 == 24)) {  							alt6 = 1;  						}  					}  					finally {  						DebugExitDecision (6);  					}  					switch (alt6) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  						{  							DebugLocation (98' 31);  							inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (6);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (99' 4);  				FilterTreeNode newNode = f;  				if ((inverse != null ? inverse.Text : default(string)) == "!")  					newNode.ToggleInversed ();  				filterNode = newNode;  			}  			break;  		case 3:  			DebugEnterAlt (3);  			// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  			{  				DebugLocation (105' 4);  				DebugLocation (105' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr216);  				Match (input' TokenTypes.Down' null);  				DebugLocation (105' 12);  				PushFollow (Follow._propertyChain_in_filterExpr219);  				propertyChain (propertySegments);  				PopFollow ();  				DebugLocation (105' 51);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  				int alt7 = 2;  				try {  					DebugEnterSubRule (7);  					try {  						DebugEnterDecision (7' false);  						int LA7_1 = input.LA (1);  						if ((LA7_1 == 31)) {  							alt7 = 1;  						}  					}  					finally {  						DebugExitDecision (7);  					}  					switch (alt7) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  						{  							DebugLocation (105' 51);  							inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (7);  				}  				DebugLocation (105' 60);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  				int alt8 = 2;  				try {  					DebugEnterSubRule (8);  					try {  						DebugEnterDecision (8' false);  						int LA8_1 = input.LA (1);  						if ((LA8_1 == 24)) {  							alt8 = 1;  						}  					}  					finally {  						DebugExitDecision (8);  					}  					switch (alt8) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  						{  							DebugLocation (105' 60);  							not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (8);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (106' 4);  				FilterTreeNode newProperty = new Property (propertySegments);  				if ((inverse != null ? inverse.Text : default(string)) == "?")  					filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  				else {  					if ((not != null ? not.Text : default(string)) == "!")  						newProperty.ToggleInversed ();  					filterNode = newProperty;  				}  			}  			break;  		case 4:  			DebugEnterAlt (4);  			// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  			{  				DebugLocation (116' 4);  				STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  				DebugLocation (117' 4);  				string stringText = (STRING7 != null ? STRING7.Text : default(string));  				stringText = stringText.Substring (1' stringText.Length - 2);  				filterNode = new Value (stringText);  			}  			break;  		case 5:  			DebugEnterAlt (5);  			// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  			{  				DebugLocation (122' 4);  				REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  				DebugLocation (123' 4);  				string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  				regexText = regexText.Substring (1' regexText.Length - 2);  				filterNode = new RegExp (regexText);  			}  			break;  		case 6:  			DebugEnterAlt (6);  			// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  			{  				DebugLocation (128' 4);  				NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  				DebugLocation (129' 4);  				filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  			}  			break;  		case 7:  			DebugEnterAlt (7);  			// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  			{  				DebugLocation (132' 4);  				Match (input' TRUE' Follow._TRUE_in_filterExpr271);  				DebugLocation (133' 4);  				filterNode = new Value (true);  			}  			break;  		case 8:  			DebugEnterAlt (8);  			// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  			{  				DebugLocation (136' 4);  				Match (input' FALSE' Follow._FALSE_in_filterExpr281);  				DebugLocation (137' 4);  				filterNode = new Value (false);  			}  			break;  		case 9:  			DebugEnterAlt (9);  			// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  			{  				DebugLocation (140' 4);  				Match (input' NULL' Follow._NULL_in_filterExpr291);  				DebugLocation (141' 4);  				filterNode = new Value (null);  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("filterExpr"' 6);  		LeaveRule ("filterExpr"' 6);  		LeaveRule_filterExpr ();  	}  	DebugLocation (144' 1);  }  finally {  	DebugExitRule (GrammarFileName' "filterExpr");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "filterExpr");  	DebugLocation (60' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  		int alt9 = 9;  		try {  			DebugEnterDecision (9' false);  			switch (input.LA (1)) {  			case CHAIN_OPERATOR:  			case COMPARATOR:  				{  					alt9 = 1;  				}  				break;  			case EXPR:  				{  					int LA9_2 = input.LA (2);  					if ((LA9_2 == DOWN)) {  						int LA9_3 = input.LA (3);  						if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  							alt9 = 2;  						}  						else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  							alt9 = 3;  						}  						else {  							NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  							DebugRecognitionException (nvae);  							throw nvae;  						}  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				break;  			case STRING:  				{  					alt9 = 4;  				}  				break;  			case REGEX:  				{  					alt9 = 5;  				}  				break;  			case NUMBER:  				{  					alt9 = 6;  				}  				break;  			case TRUE:  				{  					alt9 = 7;  				}  				break;  			case FALSE:  				{  					alt9 = 8;  				}  				break;  			case NULL:  				{  					alt9 = 9;  				}  				break;  			default: {  				NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  			}  		}  		finally {  			DebugExitDecision (9);  		}  		switch (alt9) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  			{  				DebugLocation (64' 4);  				DebugLocation (64' 6);  				PushFollow (Follow._comparator_in_filterExpr175);  				comparator6 = comparator ();  				PopFollow ();  				Match (input' TokenTypes.Down' null);  				DebugLocation (64' 18);  				PushFollow (Follow._filterExpr_in_filterExpr179);  				a = filterExpr ();  				PopFollow ();  				DebugLocation (64' 31);  				PushFollow (Follow._filterExpr_in_filterExpr183);  				b = filterExpr ();  				PopFollow ();  				Match (input' TokenTypes.Up' null);  				DebugLocation (65' 4);  				Comparator newComparator;  				switch (comparator6) {  				case "=":  					newComparator = Comparator.Equals;  					break;  				case "!=":  					newComparator = Comparator.NotEquals;  					break;  				case ">":  					newComparator = Comparator.Greater;  					break;  				case "<":  					newComparator = Comparator.Less;  					break;  				case ">=":  					newComparator = Comparator.GreaterOrEqual;  					break;  				case "<=":  					newComparator = Comparator.LessOrEqual;  					break;  				case "&":  					newComparator = Comparator.And;  					break;  				case "|":  					newComparator = Comparator.Or;  					break;  				default:  					newComparator = Comparator.Equals;  					break;  				}  				filterNode = new BoolExpression (a' newComparator' b);  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  			{  				DebugLocation (98' 4);  				DebugLocation (98' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr195);  				Match (input' TokenTypes.Down' null);  				DebugLocation (98' 12);  				PushFollow (Follow._filterExpr_in_filterExpr199);  				f = filterExpr ();  				PopFollow ();  				DebugLocation (98' 31);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  				int alt6 = 2;  				try {  					DebugEnterSubRule (6);  					try {  						DebugEnterDecision (6' false);  						int LA6_1 = input.LA (1);  						if ((LA6_1 == 24)) {  							alt6 = 1;  						}  					}  					finally {  						DebugExitDecision (6);  					}  					switch (alt6) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  						{  							DebugLocation (98' 31);  							inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (6);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (99' 4);  				FilterTreeNode newNode = f;  				if ((inverse != null ? inverse.Text : default(string)) == "!")  					newNode.ToggleInversed ();  				filterNode = newNode;  			}  			break;  		case 3:  			DebugEnterAlt (3);  			// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  			{  				DebugLocation (105' 4);  				DebugLocation (105' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr216);  				Match (input' TokenTypes.Down' null);  				DebugLocation (105' 12);  				PushFollow (Follow._propertyChain_in_filterExpr219);  				propertyChain (propertySegments);  				PopFollow ();  				DebugLocation (105' 51);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  				int alt7 = 2;  				try {  					DebugEnterSubRule (7);  					try {  						DebugEnterDecision (7' false);  						int LA7_1 = input.LA (1);  						if ((LA7_1 == 31)) {  							alt7 = 1;  						}  					}  					finally {  						DebugExitDecision (7);  					}  					switch (alt7) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  						{  							DebugLocation (105' 51);  							inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (7);  				}  				DebugLocation (105' 60);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  				int alt8 = 2;  				try {  					DebugEnterSubRule (8);  					try {  						DebugEnterDecision (8' false);  						int LA8_1 = input.LA (1);  						if ((LA8_1 == 24)) {  							alt8 = 1;  						}  					}  					finally {  						DebugExitDecision (8);  					}  					switch (alt8) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  						{  							DebugLocation (105' 60);  							not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (8);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (106' 4);  				FilterTreeNode newProperty = new Property (propertySegments);  				if ((inverse != null ? inverse.Text : default(string)) == "?")  					filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  				else {  					if ((not != null ? not.Text : default(string)) == "!")  						newProperty.ToggleInversed ();  					filterNode = newProperty;  				}  			}  			break;  		case 4:  			DebugEnterAlt (4);  			// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  			{  				DebugLocation (116' 4);  				STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  				DebugLocation (117' 4);  				string stringText = (STRING7 != null ? STRING7.Text : default(string));  				stringText = stringText.Substring (1' stringText.Length - 2);  				filterNode = new Value (stringText);  			}  			break;  		case 5:  			DebugEnterAlt (5);  			// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  			{  				DebugLocation (122' 4);  				REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  				DebugLocation (123' 4);  				string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  				regexText = regexText.Substring (1' regexText.Length - 2);  				filterNode = new RegExp (regexText);  			}  			break;  		case 6:  			DebugEnterAlt (6);  			// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  			{  				DebugLocation (128' 4);  				NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  				DebugLocation (129' 4);  				filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  			}  			break;  		case 7:  			DebugEnterAlt (7);  			// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  			{  				DebugLocation (132' 4);  				Match (input' TRUE' Follow._TRUE_in_filterExpr271);  				DebugLocation (133' 4);  				filterNode = new Value (true);  			}  			break;  		case 8:  			DebugEnterAlt (8);  			// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  			{  				DebugLocation (136' 4);  				Match (input' FALSE' Follow._FALSE_in_filterExpr281);  				DebugLocation (137' 4);  				filterNode = new Value (false);  			}  			break;  		case 9:  			DebugEnterAlt (9);  			// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  			{  				DebugLocation (140' 4);  				Match (input' NULL' Follow._NULL_in_filterExpr291);  				DebugLocation (141' 4);  				filterNode = new Value (null);  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("filterExpr"' 6);  		LeaveRule ("filterExpr"' 6);  		LeaveRule_filterExpr ();  	}  	DebugLocation (144' 1);  }  finally {  	DebugExitRule (GrammarFileName' "filterExpr");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "filterExpr");  	DebugLocation (60' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  		int alt9 = 9;  		try {  			DebugEnterDecision (9' false);  			switch (input.LA (1)) {  			case CHAIN_OPERATOR:  			case COMPARATOR:  				{  					alt9 = 1;  				}  				break;  			case EXPR:  				{  					int LA9_2 = input.LA (2);  					if ((LA9_2 == DOWN)) {  						int LA9_3 = input.LA (3);  						if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  							alt9 = 2;  						}  						else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  							alt9 = 3;  						}  						else {  							NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  							DebugRecognitionException (nvae);  							throw nvae;  						}  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				break;  			case STRING:  				{  					alt9 = 4;  				}  				break;  			case REGEX:  				{  					alt9 = 5;  				}  				break;  			case NUMBER:  				{  					alt9 = 6;  				}  				break;  			case TRUE:  				{  					alt9 = 7;  				}  				break;  			case FALSE:  				{  					alt9 = 8;  				}  				break;  			case NULL:  				{  					alt9 = 9;  				}  				break;  			default: {  				NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  			}  		}  		finally {  			DebugExitDecision (9);  		}  		switch (alt9) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  			{  				DebugLocation (64' 4);  				DebugLocation (64' 6);  				PushFollow (Follow._comparator_in_filterExpr175);  				comparator6 = comparator ();  				PopFollow ();  				Match (input' TokenTypes.Down' null);  				DebugLocation (64' 18);  				PushFollow (Follow._filterExpr_in_filterExpr179);  				a = filterExpr ();  				PopFollow ();  				DebugLocation (64' 31);  				PushFollow (Follow._filterExpr_in_filterExpr183);  				b = filterExpr ();  				PopFollow ();  				Match (input' TokenTypes.Up' null);  				DebugLocation (65' 4);  				Comparator newComparator;  				switch (comparator6) {  				case "=":  					newComparator = Comparator.Equals;  					break;  				case "!=":  					newComparator = Comparator.NotEquals;  					break;  				case ">":  					newComparator = Comparator.Greater;  					break;  				case "<":  					newComparator = Comparator.Less;  					break;  				case ">=":  					newComparator = Comparator.GreaterOrEqual;  					break;  				case "<=":  					newComparator = Comparator.LessOrEqual;  					break;  				case "&":  					newComparator = Comparator.And;  					break;  				case "|":  					newComparator = Comparator.Or;  					break;  				default:  					newComparator = Comparator.Equals;  					break;  				}  				filterNode = new BoolExpression (a' newComparator' b);  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  			{  				DebugLocation (98' 4);  				DebugLocation (98' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr195);  				Match (input' TokenTypes.Down' null);  				DebugLocation (98' 12);  				PushFollow (Follow._filterExpr_in_filterExpr199);  				f = filterExpr ();  				PopFollow ();  				DebugLocation (98' 31);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  				int alt6 = 2;  				try {  					DebugEnterSubRule (6);  					try {  						DebugEnterDecision (6' false);  						int LA6_1 = input.LA (1);  						if ((LA6_1 == 24)) {  							alt6 = 1;  						}  					}  					finally {  						DebugExitDecision (6);  					}  					switch (alt6) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  						{  							DebugLocation (98' 31);  							inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (6);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (99' 4);  				FilterTreeNode newNode = f;  				if ((inverse != null ? inverse.Text : default(string)) == "!")  					newNode.ToggleInversed ();  				filterNode = newNode;  			}  			break;  		case 3:  			DebugEnterAlt (3);  			// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  			{  				DebugLocation (105' 4);  				DebugLocation (105' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr216);  				Match (input' TokenTypes.Down' null);  				DebugLocation (105' 12);  				PushFollow (Follow._propertyChain_in_filterExpr219);  				propertyChain (propertySegments);  				PopFollow ();  				DebugLocation (105' 51);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  				int alt7 = 2;  				try {  					DebugEnterSubRule (7);  					try {  						DebugEnterDecision (7' false);  						int LA7_1 = input.LA (1);  						if ((LA7_1 == 31)) {  							alt7 = 1;  						}  					}  					finally {  						DebugExitDecision (7);  					}  					switch (alt7) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  						{  							DebugLocation (105' 51);  							inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (7);  				}  				DebugLocation (105' 60);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  				int alt8 = 2;  				try {  					DebugEnterSubRule (8);  					try {  						DebugEnterDecision (8' false);  						int LA8_1 = input.LA (1);  						if ((LA8_1 == 24)) {  							alt8 = 1;  						}  					}  					finally {  						DebugExitDecision (8);  					}  					switch (alt8) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  						{  							DebugLocation (105' 60);  							not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (8);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (106' 4);  				FilterTreeNode newProperty = new Property (propertySegments);  				if ((inverse != null ? inverse.Text : default(string)) == "?")  					filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  				else {  					if ((not != null ? not.Text : default(string)) == "!")  						newProperty.ToggleInversed ();  					filterNode = newProperty;  				}  			}  			break;  		case 4:  			DebugEnterAlt (4);  			// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  			{  				DebugLocation (116' 4);  				STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  				DebugLocation (117' 4);  				string stringText = (STRING7 != null ? STRING7.Text : default(string));  				stringText = stringText.Substring (1' stringText.Length - 2);  				filterNode = new Value (stringText);  			}  			break;  		case 5:  			DebugEnterAlt (5);  			// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  			{  				DebugLocation (122' 4);  				REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  				DebugLocation (123' 4);  				string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  				regexText = regexText.Substring (1' regexText.Length - 2);  				filterNode = new RegExp (regexText);  			}  			break;  		case 6:  			DebugEnterAlt (6);  			// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  			{  				DebugLocation (128' 4);  				NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  				DebugLocation (129' 4);  				filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  			}  			break;  		case 7:  			DebugEnterAlt (7);  			// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  			{  				DebugLocation (132' 4);  				Match (input' TRUE' Follow._TRUE_in_filterExpr271);  				DebugLocation (133' 4);  				filterNode = new Value (true);  			}  			break;  		case 8:  			DebugEnterAlt (8);  			// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  			{  				DebugLocation (136' 4);  				Match (input' FALSE' Follow._FALSE_in_filterExpr281);  				DebugLocation (137' 4);  				filterNode = new Value (false);  			}  			break;  		case 9:  			DebugEnterAlt (9);  			// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  			{  				DebugLocation (140' 4);  				Match (input' NULL' Follow._NULL_in_filterExpr291);  				DebugLocation (141' 4);  				filterNode = new Value (null);  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("filterExpr"' 6);  		LeaveRule ("filterExpr"' 6);  		LeaveRule_filterExpr ();  	}  	DebugLocation (144' 1);  }  finally {  	DebugExitRule (GrammarFileName' "filterExpr");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "filterExpr");  	DebugLocation (60' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  		int alt9 = 9;  		try {  			DebugEnterDecision (9' false);  			switch (input.LA (1)) {  			case CHAIN_OPERATOR:  			case COMPARATOR:  				{  					alt9 = 1;  				}  				break;  			case EXPR:  				{  					int LA9_2 = input.LA (2);  					if ((LA9_2 == DOWN)) {  						int LA9_3 = input.LA (3);  						if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  							alt9 = 2;  						}  						else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  							alt9 = 3;  						}  						else {  							NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  							DebugRecognitionException (nvae);  							throw nvae;  						}  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				break;  			case STRING:  				{  					alt9 = 4;  				}  				break;  			case REGEX:  				{  					alt9 = 5;  				}  				break;  			case NUMBER:  				{  					alt9 = 6;  				}  				break;  			case TRUE:  				{  					alt9 = 7;  				}  				break;  			case FALSE:  				{  					alt9 = 8;  				}  				break;  			case NULL:  				{  					alt9 = 9;  				}  				break;  			default: {  				NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  			}  		}  		finally {  			DebugExitDecision (9);  		}  		switch (alt9) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  			{  				DebugLocation (64' 4);  				DebugLocation (64' 6);  				PushFollow (Follow._comparator_in_filterExpr175);  				comparator6 = comparator ();  				PopFollow ();  				Match (input' TokenTypes.Down' null);  				DebugLocation (64' 18);  				PushFollow (Follow._filterExpr_in_filterExpr179);  				a = filterExpr ();  				PopFollow ();  				DebugLocation (64' 31);  				PushFollow (Follow._filterExpr_in_filterExpr183);  				b = filterExpr ();  				PopFollow ();  				Match (input' TokenTypes.Up' null);  				DebugLocation (65' 4);  				Comparator newComparator;  				switch (comparator6) {  				case "=":  					newComparator = Comparator.Equals;  					break;  				case "!=":  					newComparator = Comparator.NotEquals;  					break;  				case ">":  					newComparator = Comparator.Greater;  					break;  				case "<":  					newComparator = Comparator.Less;  					break;  				case ">=":  					newComparator = Comparator.GreaterOrEqual;  					break;  				case "<=":  					newComparator = Comparator.LessOrEqual;  					break;  				case "&":  					newComparator = Comparator.And;  					break;  				case "|":  					newComparator = Comparator.Or;  					break;  				default:  					newComparator = Comparator.Equals;  					break;  				}  				filterNode = new BoolExpression (a' newComparator' b);  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  			{  				DebugLocation (98' 4);  				DebugLocation (98' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr195);  				Match (input' TokenTypes.Down' null);  				DebugLocation (98' 12);  				PushFollow (Follow._filterExpr_in_filterExpr199);  				f = filterExpr ();  				PopFollow ();  				DebugLocation (98' 31);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  				int alt6 = 2;  				try {  					DebugEnterSubRule (6);  					try {  						DebugEnterDecision (6' false);  						int LA6_1 = input.LA (1);  						if ((LA6_1 == 24)) {  							alt6 = 1;  						}  					}  					finally {  						DebugExitDecision (6);  					}  					switch (alt6) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  						{  							DebugLocation (98' 31);  							inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (6);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (99' 4);  				FilterTreeNode newNode = f;  				if ((inverse != null ? inverse.Text : default(string)) == "!")  					newNode.ToggleInversed ();  				filterNode = newNode;  			}  			break;  		case 3:  			DebugEnterAlt (3);  			// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  			{  				DebugLocation (105' 4);  				DebugLocation (105' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr216);  				Match (input' TokenTypes.Down' null);  				DebugLocation (105' 12);  				PushFollow (Follow._propertyChain_in_filterExpr219);  				propertyChain (propertySegments);  				PopFollow ();  				DebugLocation (105' 51);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  				int alt7 = 2;  				try {  					DebugEnterSubRule (7);  					try {  						DebugEnterDecision (7' false);  						int LA7_1 = input.LA (1);  						if ((LA7_1 == 31)) {  							alt7 = 1;  						}  					}  					finally {  						DebugExitDecision (7);  					}  					switch (alt7) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  						{  							DebugLocation (105' 51);  							inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (7);  				}  				DebugLocation (105' 60);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  				int alt8 = 2;  				try {  					DebugEnterSubRule (8);  					try {  						DebugEnterDecision (8' false);  						int LA8_1 = input.LA (1);  						if ((LA8_1 == 24)) {  							alt8 = 1;  						}  					}  					finally {  						DebugExitDecision (8);  					}  					switch (alt8) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  						{  							DebugLocation (105' 60);  							not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (8);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (106' 4);  				FilterTreeNode newProperty = new Property (propertySegments);  				if ((inverse != null ? inverse.Text : default(string)) == "?")  					filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  				else {  					if ((not != null ? not.Text : default(string)) == "!")  						newProperty.ToggleInversed ();  					filterNode = newProperty;  				}  			}  			break;  		case 4:  			DebugEnterAlt (4);  			// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  			{  				DebugLocation (116' 4);  				STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  				DebugLocation (117' 4);  				string stringText = (STRING7 != null ? STRING7.Text : default(string));  				stringText = stringText.Substring (1' stringText.Length - 2);  				filterNode = new Value (stringText);  			}  			break;  		case 5:  			DebugEnterAlt (5);  			// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  			{  				DebugLocation (122' 4);  				REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  				DebugLocation (123' 4);  				string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  				regexText = regexText.Substring (1' regexText.Length - 2);  				filterNode = new RegExp (regexText);  			}  			break;  		case 6:  			DebugEnterAlt (6);  			// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  			{  				DebugLocation (128' 4);  				NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  				DebugLocation (129' 4);  				filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  			}  			break;  		case 7:  			DebugEnterAlt (7);  			// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  			{  				DebugLocation (132' 4);  				Match (input' TRUE' Follow._TRUE_in_filterExpr271);  				DebugLocation (133' 4);  				filterNode = new Value (true);  			}  			break;  		case 8:  			DebugEnterAlt (8);  			// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  			{  				DebugLocation (136' 4);  				Match (input' FALSE' Follow._FALSE_in_filterExpr281);  				DebugLocation (137' 4);  				filterNode = new Value (false);  			}  			break;  		case 9:  			DebugEnterAlt (9);  			// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  			{  				DebugLocation (140' 4);  				Match (input' NULL' Follow._NULL_in_filterExpr291);  				DebugLocation (141' 4);  				filterNode = new Value (null);  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("filterExpr"' 6);  		LeaveRule ("filterExpr"' 6);  		LeaveRule_filterExpr ();  	}  	DebugLocation (144' 1);  }  finally {  	DebugExitRule (GrammarFileName' "filterExpr");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "filterExpr");  	DebugLocation (60' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  		int alt9 = 9;  		try {  			DebugEnterDecision (9' false);  			switch (input.LA (1)) {  			case CHAIN_OPERATOR:  			case COMPARATOR:  				{  					alt9 = 1;  				}  				break;  			case EXPR:  				{  					int LA9_2 = input.LA (2);  					if ((LA9_2 == DOWN)) {  						int LA9_3 = input.LA (3);  						if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  							alt9 = 2;  						}  						else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  							alt9 = 3;  						}  						else {  							NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  							DebugRecognitionException (nvae);  							throw nvae;  						}  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				break;  			case STRING:  				{  					alt9 = 4;  				}  				break;  			case REGEX:  				{  					alt9 = 5;  				}  				break;  			case NUMBER:  				{  					alt9 = 6;  				}  				break;  			case TRUE:  				{  					alt9 = 7;  				}  				break;  			case FALSE:  				{  					alt9 = 8;  				}  				break;  			case NULL:  				{  					alt9 = 9;  				}  				break;  			default: {  				NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  			}  		}  		finally {  			DebugExitDecision (9);  		}  		switch (alt9) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  			{  				DebugLocation (64' 4);  				DebugLocation (64' 6);  				PushFollow (Follow._comparator_in_filterExpr175);  				comparator6 = comparator ();  				PopFollow ();  				Match (input' TokenTypes.Down' null);  				DebugLocation (64' 18);  				PushFollow (Follow._filterExpr_in_filterExpr179);  				a = filterExpr ();  				PopFollow ();  				DebugLocation (64' 31);  				PushFollow (Follow._filterExpr_in_filterExpr183);  				b = filterExpr ();  				PopFollow ();  				Match (input' TokenTypes.Up' null);  				DebugLocation (65' 4);  				Comparator newComparator;  				switch (comparator6) {  				case "=":  					newComparator = Comparator.Equals;  					break;  				case "!=":  					newComparator = Comparator.NotEquals;  					break;  				case ">":  					newComparator = Comparator.Greater;  					break;  				case "<":  					newComparator = Comparator.Less;  					break;  				case ">=":  					newComparator = Comparator.GreaterOrEqual;  					break;  				case "<=":  					newComparator = Comparator.LessOrEqual;  					break;  				case "&":  					newComparator = Comparator.And;  					break;  				case "|":  					newComparator = Comparator.Or;  					break;  				default:  					newComparator = Comparator.Equals;  					break;  				}  				filterNode = new BoolExpression (a' newComparator' b);  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  			{  				DebugLocation (98' 4);  				DebugLocation (98' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr195);  				Match (input' TokenTypes.Down' null);  				DebugLocation (98' 12);  				PushFollow (Follow._filterExpr_in_filterExpr199);  				f = filterExpr ();  				PopFollow ();  				DebugLocation (98' 31);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  				int alt6 = 2;  				try {  					DebugEnterSubRule (6);  					try {  						DebugEnterDecision (6' false);  						int LA6_1 = input.LA (1);  						if ((LA6_1 == 24)) {  							alt6 = 1;  						}  					}  					finally {  						DebugExitDecision (6);  					}  					switch (alt6) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  						{  							DebugLocation (98' 31);  							inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (6);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (99' 4);  				FilterTreeNode newNode = f;  				if ((inverse != null ? inverse.Text : default(string)) == "!")  					newNode.ToggleInversed ();  				filterNode = newNode;  			}  			break;  		case 3:  			DebugEnterAlt (3);  			// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  			{  				DebugLocation (105' 4);  				DebugLocation (105' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr216);  				Match (input' TokenTypes.Down' null);  				DebugLocation (105' 12);  				PushFollow (Follow._propertyChain_in_filterExpr219);  				propertyChain (propertySegments);  				PopFollow ();  				DebugLocation (105' 51);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  				int alt7 = 2;  				try {  					DebugEnterSubRule (7);  					try {  						DebugEnterDecision (7' false);  						int LA7_1 = input.LA (1);  						if ((LA7_1 == 31)) {  							alt7 = 1;  						}  					}  					finally {  						DebugExitDecision (7);  					}  					switch (alt7) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  						{  							DebugLocation (105' 51);  							inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (7);  				}  				DebugLocation (105' 60);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  				int alt8 = 2;  				try {  					DebugEnterSubRule (8);  					try {  						DebugEnterDecision (8' false);  						int LA8_1 = input.LA (1);  						if ((LA8_1 == 24)) {  							alt8 = 1;  						}  					}  					finally {  						DebugExitDecision (8);  					}  					switch (alt8) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  						{  							DebugLocation (105' 60);  							not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (8);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (106' 4);  				FilterTreeNode newProperty = new Property (propertySegments);  				if ((inverse != null ? inverse.Text : default(string)) == "?")  					filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  				else {  					if ((not != null ? not.Text : default(string)) == "!")  						newProperty.ToggleInversed ();  					filterNode = newProperty;  				}  			}  			break;  		case 4:  			DebugEnterAlt (4);  			// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  			{  				DebugLocation (116' 4);  				STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  				DebugLocation (117' 4);  				string stringText = (STRING7 != null ? STRING7.Text : default(string));  				stringText = stringText.Substring (1' stringText.Length - 2);  				filterNode = new Value (stringText);  			}  			break;  		case 5:  			DebugEnterAlt (5);  			// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  			{  				DebugLocation (122' 4);  				REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  				DebugLocation (123' 4);  				string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  				regexText = regexText.Substring (1' regexText.Length - 2);  				filterNode = new RegExp (regexText);  			}  			break;  		case 6:  			DebugEnterAlt (6);  			// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  			{  				DebugLocation (128' 4);  				NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  				DebugLocation (129' 4);  				filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  			}  			break;  		case 7:  			DebugEnterAlt (7);  			// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  			{  				DebugLocation (132' 4);  				Match (input' TRUE' Follow._TRUE_in_filterExpr271);  				DebugLocation (133' 4);  				filterNode = new Value (true);  			}  			break;  		case 8:  			DebugEnterAlt (8);  			// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  			{  				DebugLocation (136' 4);  				Match (input' FALSE' Follow._FALSE_in_filterExpr281);  				DebugLocation (137' 4);  				filterNode = new Value (false);  			}  			break;  		case 9:  			DebugEnterAlt (9);  			// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  			{  				DebugLocation (140' 4);  				Match (input' NULL' Follow._NULL_in_filterExpr291);  				DebugLocation (141' 4);  				filterNode = new Value (null);  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("filterExpr"' 6);  		LeaveRule ("filterExpr"' 6);  		LeaveRule_filterExpr ();  	}  	DebugLocation (144' 1);  }  finally {  	DebugExitRule (GrammarFileName' "filterExpr");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "filterExpr");  	DebugLocation (60' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  		int alt9 = 9;  		try {  			DebugEnterDecision (9' false);  			switch (input.LA (1)) {  			case CHAIN_OPERATOR:  			case COMPARATOR:  				{  					alt9 = 1;  				}  				break;  			case EXPR:  				{  					int LA9_2 = input.LA (2);  					if ((LA9_2 == DOWN)) {  						int LA9_3 = input.LA (3);  						if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  							alt9 = 2;  						}  						else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  							alt9 = 3;  						}  						else {  							NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  							DebugRecognitionException (nvae);  							throw nvae;  						}  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				break;  			case STRING:  				{  					alt9 = 4;  				}  				break;  			case REGEX:  				{  					alt9 = 5;  				}  				break;  			case NUMBER:  				{  					alt9 = 6;  				}  				break;  			case TRUE:  				{  					alt9 = 7;  				}  				break;  			case FALSE:  				{  					alt9 = 8;  				}  				break;  			case NULL:  				{  					alt9 = 9;  				}  				break;  			default: {  				NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  			}  		}  		finally {  			DebugExitDecision (9);  		}  		switch (alt9) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  			{  				DebugLocation (64' 4);  				DebugLocation (64' 6);  				PushFollow (Follow._comparator_in_filterExpr175);  				comparator6 = comparator ();  				PopFollow ();  				Match (input' TokenTypes.Down' null);  				DebugLocation (64' 18);  				PushFollow (Follow._filterExpr_in_filterExpr179);  				a = filterExpr ();  				PopFollow ();  				DebugLocation (64' 31);  				PushFollow (Follow._filterExpr_in_filterExpr183);  				b = filterExpr ();  				PopFollow ();  				Match (input' TokenTypes.Up' null);  				DebugLocation (65' 4);  				Comparator newComparator;  				switch (comparator6) {  				case "=":  					newComparator = Comparator.Equals;  					break;  				case "!=":  					newComparator = Comparator.NotEquals;  					break;  				case ">":  					newComparator = Comparator.Greater;  					break;  				case "<":  					newComparator = Comparator.Less;  					break;  				case ">=":  					newComparator = Comparator.GreaterOrEqual;  					break;  				case "<=":  					newComparator = Comparator.LessOrEqual;  					break;  				case "&":  					newComparator = Comparator.And;  					break;  				case "|":  					newComparator = Comparator.Or;  					break;  				default:  					newComparator = Comparator.Equals;  					break;  				}  				filterNode = new BoolExpression (a' newComparator' b);  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  			{  				DebugLocation (98' 4);  				DebugLocation (98' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr195);  				Match (input' TokenTypes.Down' null);  				DebugLocation (98' 12);  				PushFollow (Follow._filterExpr_in_filterExpr199);  				f = filterExpr ();  				PopFollow ();  				DebugLocation (98' 31);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  				int alt6 = 2;  				try {  					DebugEnterSubRule (6);  					try {  						DebugEnterDecision (6' false);  						int LA6_1 = input.LA (1);  						if ((LA6_1 == 24)) {  							alt6 = 1;  						}  					}  					finally {  						DebugExitDecision (6);  					}  					switch (alt6) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  						{  							DebugLocation (98' 31);  							inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (6);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (99' 4);  				FilterTreeNode newNode = f;  				if ((inverse != null ? inverse.Text : default(string)) == "!")  					newNode.ToggleInversed ();  				filterNode = newNode;  			}  			break;  		case 3:  			DebugEnterAlt (3);  			// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  			{  				DebugLocation (105' 4);  				DebugLocation (105' 6);  				Match (input' EXPR' Follow._EXPR_in_filterExpr216);  				Match (input' TokenTypes.Down' null);  				DebugLocation (105' 12);  				PushFollow (Follow._propertyChain_in_filterExpr219);  				propertyChain (propertySegments);  				PopFollow ();  				DebugLocation (105' 51);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  				int alt7 = 2;  				try {  					DebugEnterSubRule (7);  					try {  						DebugEnterDecision (7' false);  						int LA7_1 = input.LA (1);  						if ((LA7_1 == 31)) {  							alt7 = 1;  						}  					}  					finally {  						DebugExitDecision (7);  					}  					switch (alt7) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  						{  							DebugLocation (105' 51);  							inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (7);  				}  				DebugLocation (105' 60);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  				int alt8 = 2;  				try {  					DebugEnterSubRule (8);  					try {  						DebugEnterDecision (8' false);  						int LA8_1 = input.LA (1);  						if ((LA8_1 == 24)) {  							alt8 = 1;  						}  					}  					finally {  						DebugExitDecision (8);  					}  					switch (alt8) {  					case 1:  						DebugEnterAlt (1);  						// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  						{  							DebugLocation (105' 60);  							not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  						}  						break;  					}  				}  				finally {  					DebugExitSubRule (8);  				}  				Match (input' TokenTypes.Up' null);  				DebugLocation (106' 4);  				FilterTreeNode newProperty = new Property (propertySegments);  				if ((inverse != null ? inverse.Text : default(string)) == "?")  					filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  				else {  					if ((not != null ? not.Text : default(string)) == "!")  						newProperty.ToggleInversed ();  					filterNode = newProperty;  				}  			}  			break;  		case 4:  			DebugEnterAlt (4);  			// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  			{  				DebugLocation (116' 4);  				STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  				DebugLocation (117' 4);  				string stringText = (STRING7 != null ? STRING7.Text : default(string));  				stringText = stringText.Substring (1' stringText.Length - 2);  				filterNode = new Value (stringText);  			}  			break;  		case 5:  			DebugEnterAlt (5);  			// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  			{  				DebugLocation (122' 4);  				REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  				DebugLocation (123' 4);  				string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  				regexText = regexText.Substring (1' regexText.Length - 2);  				filterNode = new RegExp (regexText);  			}  			break;  		case 6:  			DebugEnterAlt (6);  			// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  			{  				DebugLocation (128' 4);  				NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  				DebugLocation (129' 4);  				filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  			}  			break;  		case 7:  			DebugEnterAlt (7);  			// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  			{  				DebugLocation (132' 4);  				Match (input' TRUE' Follow._TRUE_in_filterExpr271);  				DebugLocation (133' 4);  				filterNode = new Value (true);  			}  			break;  		case 8:  			DebugEnterAlt (8);  			// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  			{  				DebugLocation (136' 4);  				Match (input' FALSE' Follow._FALSE_in_filterExpr281);  				DebugLocation (137' 4);  				filterNode = new Value (false);  			}  			break;  		case 9:  			DebugEnterAlt (9);  			// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  			{  				DebugLocation (140' 4);  				Match (input' NULL' Follow._NULL_in_filterExpr291);  				DebugLocation (141' 4);  				filterNode = new Value (null);  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("filterExpr"' 6);  		LeaveRule ("filterExpr"' 6);  		LeaveRule_filterExpr ();  	}  	DebugLocation (144' 1);  }  finally {  	DebugExitRule (GrammarFileName' "filterExpr");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: DebugLocation (60' 1);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  	int alt9 = 9;  	try {  		DebugEnterDecision (9' false);  		switch (input.LA (1)) {  		case CHAIN_OPERATOR:  		case COMPARATOR:  			{  				alt9 = 1;  			}  			break;  		case EXPR:  			{  				int LA9_2 = input.LA (2);  				if ((LA9_2 == DOWN)) {  					int LA9_3 = input.LA (3);  					if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  						alt9 = 2;  					}  					else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  						alt9 = 3;  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				else {  					NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  					DebugRecognitionException (nvae);  					throw nvae;  				}  			}  			break;  		case STRING:  			{  				alt9 = 4;  			}  			break;  		case REGEX:  			{  				alt9 = 5;  			}  			break;  		case NUMBER:  			{  				alt9 = 6;  			}  			break;  		case TRUE:  			{  				alt9 = 7;  			}  			break;  		case FALSE:  			{  				alt9 = 8;  			}  			break;  		case NULL:  			{  				alt9 = 9;  			}  			break;  		default: {  			NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  		}  	}  	finally {  		DebugExitDecision (9);  	}  	switch (alt9) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  		{  			DebugLocation (64' 4);  			DebugLocation (64' 6);  			PushFollow (Follow._comparator_in_filterExpr175);  			comparator6 = comparator ();  			PopFollow ();  			Match (input' TokenTypes.Down' null);  			DebugLocation (64' 18);  			PushFollow (Follow._filterExpr_in_filterExpr179);  			a = filterExpr ();  			PopFollow ();  			DebugLocation (64' 31);  			PushFollow (Follow._filterExpr_in_filterExpr183);  			b = filterExpr ();  			PopFollow ();  			Match (input' TokenTypes.Up' null);  			DebugLocation (65' 4);  			Comparator newComparator;  			switch (comparator6) {  			case "=":  				newComparator = Comparator.Equals;  				break;  			case "!=":  				newComparator = Comparator.NotEquals;  				break;  			case ">":  				newComparator = Comparator.Greater;  				break;  			case "<":  				newComparator = Comparator.Less;  				break;  			case ">=":  				newComparator = Comparator.GreaterOrEqual;  				break;  			case "<=":  				newComparator = Comparator.LessOrEqual;  				break;  			case "&":  				newComparator = Comparator.And;  				break;  			case "|":  				newComparator = Comparator.Or;  				break;  			default:  				newComparator = Comparator.Equals;  				break;  			}  			filterNode = new BoolExpression (a' newComparator' b);  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  		{  			DebugLocation (98' 4);  			DebugLocation (98' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr195);  			Match (input' TokenTypes.Down' null);  			DebugLocation (98' 12);  			PushFollow (Follow._filterExpr_in_filterExpr199);  			f = filterExpr ();  			PopFollow ();  			DebugLocation (98' 31);  			// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  			int alt6 = 2;  			try {  				DebugEnterSubRule (6);  				try {  					DebugEnterDecision (6' false);  					int LA6_1 = input.LA (1);  					if ((LA6_1 == 24)) {  						alt6 = 1;  					}  				}  				finally {  					DebugExitDecision (6);  				}  				switch (alt6) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  					{  						DebugLocation (98' 31);  						inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (6);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (99' 4);  			FilterTreeNode newNode = f;  			if ((inverse != null ? inverse.Text : default(string)) == "!")  				newNode.ToggleInversed ();  			filterNode = newNode;  		}  		break;  	case 3:  		DebugEnterAlt (3);  		// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  		{  			DebugLocation (105' 4);  			DebugLocation (105' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr216);  			Match (input' TokenTypes.Down' null);  			DebugLocation (105' 12);  			PushFollow (Follow._propertyChain_in_filterExpr219);  			propertyChain (propertySegments);  			PopFollow ();  			DebugLocation (105' 51);  			// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  			int alt7 = 2;  			try {  				DebugEnterSubRule (7);  				try {  					DebugEnterDecision (7' false);  					int LA7_1 = input.LA (1);  					if ((LA7_1 == 31)) {  						alt7 = 1;  					}  				}  				finally {  					DebugExitDecision (7);  				}  				switch (alt7) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  					{  						DebugLocation (105' 51);  						inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (7);  			}  			DebugLocation (105' 60);  			// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  			int alt8 = 2;  			try {  				DebugEnterSubRule (8);  				try {  					DebugEnterDecision (8' false);  					int LA8_1 = input.LA (1);  					if ((LA8_1 == 24)) {  						alt8 = 1;  					}  				}  				finally {  					DebugExitDecision (8);  				}  				switch (alt8) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  					{  						DebugLocation (105' 60);  						not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (8);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (106' 4);  			FilterTreeNode newProperty = new Property (propertySegments);  			if ((inverse != null ? inverse.Text : default(string)) == "?")  				filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  			else {  				if ((not != null ? not.Text : default(string)) == "!")  					newProperty.ToggleInversed ();  				filterNode = newProperty;  			}  		}  		break;  	case 4:  		DebugEnterAlt (4);  		// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  		{  			DebugLocation (116' 4);  			STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  			DebugLocation (117' 4);  			string stringText = (STRING7 != null ? STRING7.Text : default(string));  			stringText = stringText.Substring (1' stringText.Length - 2);  			filterNode = new Value (stringText);  		}  		break;  	case 5:  		DebugEnterAlt (5);  		// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  		{  			DebugLocation (122' 4);  			REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  			DebugLocation (123' 4);  			string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  			regexText = regexText.Substring (1' regexText.Length - 2);  			filterNode = new RegExp (regexText);  		}  		break;  	case 6:  		DebugEnterAlt (6);  		// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  		{  			DebugLocation (128' 4);  			NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  			DebugLocation (129' 4);  			filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  		}  		break;  	case 7:  		DebugEnterAlt (7);  		// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  		{  			DebugLocation (132' 4);  			Match (input' TRUE' Follow._TRUE_in_filterExpr271);  			DebugLocation (133' 4);  			filterNode = new Value (true);  		}  		break;  	case 8:  		DebugEnterAlt (8);  		// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  		{  			DebugLocation (136' 4);  			Match (input' FALSE' Follow._FALSE_in_filterExpr281);  			DebugLocation (137' 4);  			filterNode = new Value (false);  		}  		break;  	case 9:  		DebugEnterAlt (9);  		// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  		{  			DebugLocation (140' 4);  			Match (input' NULL' Follow._NULL_in_filterExpr291);  			DebugLocation (141' 4);  			filterNode = new Value (null);  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("filterExpr"' 6);  	LeaveRule ("filterExpr"' 6);  	LeaveRule_filterExpr ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  	int alt9 = 9;  	try {  		DebugEnterDecision (9' false);  		switch (input.LA (1)) {  		case CHAIN_OPERATOR:  		case COMPARATOR:  			{  				alt9 = 1;  			}  			break;  		case EXPR:  			{  				int LA9_2 = input.LA (2);  				if ((LA9_2 == DOWN)) {  					int LA9_3 = input.LA (3);  					if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  						alt9 = 2;  					}  					else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  						alt9 = 3;  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				else {  					NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  					DebugRecognitionException (nvae);  					throw nvae;  				}  			}  			break;  		case STRING:  			{  				alt9 = 4;  			}  			break;  		case REGEX:  			{  				alt9 = 5;  			}  			break;  		case NUMBER:  			{  				alt9 = 6;  			}  			break;  		case TRUE:  			{  				alt9 = 7;  			}  			break;  		case FALSE:  			{  				alt9 = 8;  			}  			break;  		case NULL:  			{  				alt9 = 9;  			}  			break;  		default: {  			NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  		}  	}  	finally {  		DebugExitDecision (9);  	}  	switch (alt9) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  		{  			DebugLocation (64' 4);  			DebugLocation (64' 6);  			PushFollow (Follow._comparator_in_filterExpr175);  			comparator6 = comparator ();  			PopFollow ();  			Match (input' TokenTypes.Down' null);  			DebugLocation (64' 18);  			PushFollow (Follow._filterExpr_in_filterExpr179);  			a = filterExpr ();  			PopFollow ();  			DebugLocation (64' 31);  			PushFollow (Follow._filterExpr_in_filterExpr183);  			b = filterExpr ();  			PopFollow ();  			Match (input' TokenTypes.Up' null);  			DebugLocation (65' 4);  			Comparator newComparator;  			switch (comparator6) {  			case "=":  				newComparator = Comparator.Equals;  				break;  			case "!=":  				newComparator = Comparator.NotEquals;  				break;  			case ">":  				newComparator = Comparator.Greater;  				break;  			case "<":  				newComparator = Comparator.Less;  				break;  			case ">=":  				newComparator = Comparator.GreaterOrEqual;  				break;  			case "<=":  				newComparator = Comparator.LessOrEqual;  				break;  			case "&":  				newComparator = Comparator.And;  				break;  			case "|":  				newComparator = Comparator.Or;  				break;  			default:  				newComparator = Comparator.Equals;  				break;  			}  			filterNode = new BoolExpression (a' newComparator' b);  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  		{  			DebugLocation (98' 4);  			DebugLocation (98' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr195);  			Match (input' TokenTypes.Down' null);  			DebugLocation (98' 12);  			PushFollow (Follow._filterExpr_in_filterExpr199);  			f = filterExpr ();  			PopFollow ();  			DebugLocation (98' 31);  			// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  			int alt6 = 2;  			try {  				DebugEnterSubRule (6);  				try {  					DebugEnterDecision (6' false);  					int LA6_1 = input.LA (1);  					if ((LA6_1 == 24)) {  						alt6 = 1;  					}  				}  				finally {  					DebugExitDecision (6);  				}  				switch (alt6) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  					{  						DebugLocation (98' 31);  						inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (6);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (99' 4);  			FilterTreeNode newNode = f;  			if ((inverse != null ? inverse.Text : default(string)) == "!")  				newNode.ToggleInversed ();  			filterNode = newNode;  		}  		break;  	case 3:  		DebugEnterAlt (3);  		// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  		{  			DebugLocation (105' 4);  			DebugLocation (105' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr216);  			Match (input' TokenTypes.Down' null);  			DebugLocation (105' 12);  			PushFollow (Follow._propertyChain_in_filterExpr219);  			propertyChain (propertySegments);  			PopFollow ();  			DebugLocation (105' 51);  			// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  			int alt7 = 2;  			try {  				DebugEnterSubRule (7);  				try {  					DebugEnterDecision (7' false);  					int LA7_1 = input.LA (1);  					if ((LA7_1 == 31)) {  						alt7 = 1;  					}  				}  				finally {  					DebugExitDecision (7);  				}  				switch (alt7) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  					{  						DebugLocation (105' 51);  						inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (7);  			}  			DebugLocation (105' 60);  			// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  			int alt8 = 2;  			try {  				DebugEnterSubRule (8);  				try {  					DebugEnterDecision (8' false);  					int LA8_1 = input.LA (1);  					if ((LA8_1 == 24)) {  						alt8 = 1;  					}  				}  				finally {  					DebugExitDecision (8);  				}  				switch (alt8) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  					{  						DebugLocation (105' 60);  						not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (8);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (106' 4);  			FilterTreeNode newProperty = new Property (propertySegments);  			if ((inverse != null ? inverse.Text : default(string)) == "?")  				filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  			else {  				if ((not != null ? not.Text : default(string)) == "!")  					newProperty.ToggleInversed ();  				filterNode = newProperty;  			}  		}  		break;  	case 4:  		DebugEnterAlt (4);  		// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  		{  			DebugLocation (116' 4);  			STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  			DebugLocation (117' 4);  			string stringText = (STRING7 != null ? STRING7.Text : default(string));  			stringText = stringText.Substring (1' stringText.Length - 2);  			filterNode = new Value (stringText);  		}  		break;  	case 5:  		DebugEnterAlt (5);  		// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  		{  			DebugLocation (122' 4);  			REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  			DebugLocation (123' 4);  			string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  			regexText = regexText.Substring (1' regexText.Length - 2);  			filterNode = new RegExp (regexText);  		}  		break;  	case 6:  		DebugEnterAlt (6);  		// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  		{  			DebugLocation (128' 4);  			NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  			DebugLocation (129' 4);  			filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  		}  		break;  	case 7:  		DebugEnterAlt (7);  		// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  		{  			DebugLocation (132' 4);  			Match (input' TRUE' Follow._TRUE_in_filterExpr271);  			DebugLocation (133' 4);  			filterNode = new Value (true);  		}  		break;  	case 8:  		DebugEnterAlt (8);  		// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  		{  			DebugLocation (136' 4);  			Match (input' FALSE' Follow._FALSE_in_filterExpr281);  			DebugLocation (137' 4);  			filterNode = new Value (false);  		}  		break;  	case 9:  		DebugEnterAlt (9);  		// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  		{  			DebugLocation (140' 4);  			Match (input' NULL' Follow._NULL_in_filterExpr291);  			DebugLocation (141' 4);  			filterNode = new Value (null);  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("filterExpr"' 6);  	LeaveRule ("filterExpr"' 6);  	LeaveRule_filterExpr ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  	int alt9 = 9;  	try {  		DebugEnterDecision (9' false);  		switch (input.LA (1)) {  		case CHAIN_OPERATOR:  		case COMPARATOR:  			{  				alt9 = 1;  			}  			break;  		case EXPR:  			{  				int LA9_2 = input.LA (2);  				if ((LA9_2 == DOWN)) {  					int LA9_3 = input.LA (3);  					if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  						alt9 = 2;  					}  					else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  						alt9 = 3;  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				else {  					NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  					DebugRecognitionException (nvae);  					throw nvae;  				}  			}  			break;  		case STRING:  			{  				alt9 = 4;  			}  			break;  		case REGEX:  			{  				alt9 = 5;  			}  			break;  		case NUMBER:  			{  				alt9 = 6;  			}  			break;  		case TRUE:  			{  				alt9 = 7;  			}  			break;  		case FALSE:  			{  				alt9 = 8;  			}  			break;  		case NULL:  			{  				alt9 = 9;  			}  			break;  		default: {  			NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  		}  	}  	finally {  		DebugExitDecision (9);  	}  	switch (alt9) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  		{  			DebugLocation (64' 4);  			DebugLocation (64' 6);  			PushFollow (Follow._comparator_in_filterExpr175);  			comparator6 = comparator ();  			PopFollow ();  			Match (input' TokenTypes.Down' null);  			DebugLocation (64' 18);  			PushFollow (Follow._filterExpr_in_filterExpr179);  			a = filterExpr ();  			PopFollow ();  			DebugLocation (64' 31);  			PushFollow (Follow._filterExpr_in_filterExpr183);  			b = filterExpr ();  			PopFollow ();  			Match (input' TokenTypes.Up' null);  			DebugLocation (65' 4);  			Comparator newComparator;  			switch (comparator6) {  			case "=":  				newComparator = Comparator.Equals;  				break;  			case "!=":  				newComparator = Comparator.NotEquals;  				break;  			case ">":  				newComparator = Comparator.Greater;  				break;  			case "<":  				newComparator = Comparator.Less;  				break;  			case ">=":  				newComparator = Comparator.GreaterOrEqual;  				break;  			case "<=":  				newComparator = Comparator.LessOrEqual;  				break;  			case "&":  				newComparator = Comparator.And;  				break;  			case "|":  				newComparator = Comparator.Or;  				break;  			default:  				newComparator = Comparator.Equals;  				break;  			}  			filterNode = new BoolExpression (a' newComparator' b);  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  		{  			DebugLocation (98' 4);  			DebugLocation (98' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr195);  			Match (input' TokenTypes.Down' null);  			DebugLocation (98' 12);  			PushFollow (Follow._filterExpr_in_filterExpr199);  			f = filterExpr ();  			PopFollow ();  			DebugLocation (98' 31);  			// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  			int alt6 = 2;  			try {  				DebugEnterSubRule (6);  				try {  					DebugEnterDecision (6' false);  					int LA6_1 = input.LA (1);  					if ((LA6_1 == 24)) {  						alt6 = 1;  					}  				}  				finally {  					DebugExitDecision (6);  				}  				switch (alt6) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  					{  						DebugLocation (98' 31);  						inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (6);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (99' 4);  			FilterTreeNode newNode = f;  			if ((inverse != null ? inverse.Text : default(string)) == "!")  				newNode.ToggleInversed ();  			filterNode = newNode;  		}  		break;  	case 3:  		DebugEnterAlt (3);  		// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  		{  			DebugLocation (105' 4);  			DebugLocation (105' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr216);  			Match (input' TokenTypes.Down' null);  			DebugLocation (105' 12);  			PushFollow (Follow._propertyChain_in_filterExpr219);  			propertyChain (propertySegments);  			PopFollow ();  			DebugLocation (105' 51);  			// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  			int alt7 = 2;  			try {  				DebugEnterSubRule (7);  				try {  					DebugEnterDecision (7' false);  					int LA7_1 = input.LA (1);  					if ((LA7_1 == 31)) {  						alt7 = 1;  					}  				}  				finally {  					DebugExitDecision (7);  				}  				switch (alt7) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  					{  						DebugLocation (105' 51);  						inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (7);  			}  			DebugLocation (105' 60);  			// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  			int alt8 = 2;  			try {  				DebugEnterSubRule (8);  				try {  					DebugEnterDecision (8' false);  					int LA8_1 = input.LA (1);  					if ((LA8_1 == 24)) {  						alt8 = 1;  					}  				}  				finally {  					DebugExitDecision (8);  				}  				switch (alt8) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  					{  						DebugLocation (105' 60);  						not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (8);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (106' 4);  			FilterTreeNode newProperty = new Property (propertySegments);  			if ((inverse != null ? inverse.Text : default(string)) == "?")  				filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  			else {  				if ((not != null ? not.Text : default(string)) == "!")  					newProperty.ToggleInversed ();  				filterNode = newProperty;  			}  		}  		break;  	case 4:  		DebugEnterAlt (4);  		// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  		{  			DebugLocation (116' 4);  			STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  			DebugLocation (117' 4);  			string stringText = (STRING7 != null ? STRING7.Text : default(string));  			stringText = stringText.Substring (1' stringText.Length - 2);  			filterNode = new Value (stringText);  		}  		break;  	case 5:  		DebugEnterAlt (5);  		// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  		{  			DebugLocation (122' 4);  			REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  			DebugLocation (123' 4);  			string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  			regexText = regexText.Substring (1' regexText.Length - 2);  			filterNode = new RegExp (regexText);  		}  		break;  	case 6:  		DebugEnterAlt (6);  		// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  		{  			DebugLocation (128' 4);  			NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  			DebugLocation (129' 4);  			filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  		}  		break;  	case 7:  		DebugEnterAlt (7);  		// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  		{  			DebugLocation (132' 4);  			Match (input' TRUE' Follow._TRUE_in_filterExpr271);  			DebugLocation (133' 4);  			filterNode = new Value (true);  		}  		break;  	case 8:  		DebugEnterAlt (8);  		// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  		{  			DebugLocation (136' 4);  			Match (input' FALSE' Follow._FALSE_in_filterExpr281);  			DebugLocation (137' 4);  			filterNode = new Value (false);  		}  		break;  	case 9:  		DebugEnterAlt (9);  		// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  		{  			DebugLocation (140' 4);  			Match (input' NULL' Follow._NULL_in_filterExpr291);  			DebugLocation (141' 4);  			filterNode = new Value (null);  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("filterExpr"' 6);  	LeaveRule ("filterExpr"' 6);  	LeaveRule_filterExpr ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  	int alt9 = 9;  	try {  		DebugEnterDecision (9' false);  		switch (input.LA (1)) {  		case CHAIN_OPERATOR:  		case COMPARATOR:  			{  				alt9 = 1;  			}  			break;  		case EXPR:  			{  				int LA9_2 = input.LA (2);  				if ((LA9_2 == DOWN)) {  					int LA9_3 = input.LA (3);  					if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  						alt9 = 2;  					}  					else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  						alt9 = 3;  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				else {  					NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  					DebugRecognitionException (nvae);  					throw nvae;  				}  			}  			break;  		case STRING:  			{  				alt9 = 4;  			}  			break;  		case REGEX:  			{  				alt9 = 5;  			}  			break;  		case NUMBER:  			{  				alt9 = 6;  			}  			break;  		case TRUE:  			{  				alt9 = 7;  			}  			break;  		case FALSE:  			{  				alt9 = 8;  			}  			break;  		case NULL:  			{  				alt9 = 9;  			}  			break;  		default: {  			NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  		}  	}  	finally {  		DebugExitDecision (9);  	}  	switch (alt9) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  		{  			DebugLocation (64' 4);  			DebugLocation (64' 6);  			PushFollow (Follow._comparator_in_filterExpr175);  			comparator6 = comparator ();  			PopFollow ();  			Match (input' TokenTypes.Down' null);  			DebugLocation (64' 18);  			PushFollow (Follow._filterExpr_in_filterExpr179);  			a = filterExpr ();  			PopFollow ();  			DebugLocation (64' 31);  			PushFollow (Follow._filterExpr_in_filterExpr183);  			b = filterExpr ();  			PopFollow ();  			Match (input' TokenTypes.Up' null);  			DebugLocation (65' 4);  			Comparator newComparator;  			switch (comparator6) {  			case "=":  				newComparator = Comparator.Equals;  				break;  			case "!=":  				newComparator = Comparator.NotEquals;  				break;  			case ">":  				newComparator = Comparator.Greater;  				break;  			case "<":  				newComparator = Comparator.Less;  				break;  			case ">=":  				newComparator = Comparator.GreaterOrEqual;  				break;  			case "<=":  				newComparator = Comparator.LessOrEqual;  				break;  			case "&":  				newComparator = Comparator.And;  				break;  			case "|":  				newComparator = Comparator.Or;  				break;  			default:  				newComparator = Comparator.Equals;  				break;  			}  			filterNode = new BoolExpression (a' newComparator' b);  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  		{  			DebugLocation (98' 4);  			DebugLocation (98' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr195);  			Match (input' TokenTypes.Down' null);  			DebugLocation (98' 12);  			PushFollow (Follow._filterExpr_in_filterExpr199);  			f = filterExpr ();  			PopFollow ();  			DebugLocation (98' 31);  			// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  			int alt6 = 2;  			try {  				DebugEnterSubRule (6);  				try {  					DebugEnterDecision (6' false);  					int LA6_1 = input.LA (1);  					if ((LA6_1 == 24)) {  						alt6 = 1;  					}  				}  				finally {  					DebugExitDecision (6);  				}  				switch (alt6) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  					{  						DebugLocation (98' 31);  						inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (6);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (99' 4);  			FilterTreeNode newNode = f;  			if ((inverse != null ? inverse.Text : default(string)) == "!")  				newNode.ToggleInversed ();  			filterNode = newNode;  		}  		break;  	case 3:  		DebugEnterAlt (3);  		// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  		{  			DebugLocation (105' 4);  			DebugLocation (105' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr216);  			Match (input' TokenTypes.Down' null);  			DebugLocation (105' 12);  			PushFollow (Follow._propertyChain_in_filterExpr219);  			propertyChain (propertySegments);  			PopFollow ();  			DebugLocation (105' 51);  			// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  			int alt7 = 2;  			try {  				DebugEnterSubRule (7);  				try {  					DebugEnterDecision (7' false);  					int LA7_1 = input.LA (1);  					if ((LA7_1 == 31)) {  						alt7 = 1;  					}  				}  				finally {  					DebugExitDecision (7);  				}  				switch (alt7) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  					{  						DebugLocation (105' 51);  						inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (7);  			}  			DebugLocation (105' 60);  			// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  			int alt8 = 2;  			try {  				DebugEnterSubRule (8);  				try {  					DebugEnterDecision (8' false);  					int LA8_1 = input.LA (1);  					if ((LA8_1 == 24)) {  						alt8 = 1;  					}  				}  				finally {  					DebugExitDecision (8);  				}  				switch (alt8) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  					{  						DebugLocation (105' 60);  						not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (8);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (106' 4);  			FilterTreeNode newProperty = new Property (propertySegments);  			if ((inverse != null ? inverse.Text : default(string)) == "?")  				filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  			else {  				if ((not != null ? not.Text : default(string)) == "!")  					newProperty.ToggleInversed ();  				filterNode = newProperty;  			}  		}  		break;  	case 4:  		DebugEnterAlt (4);  		// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  		{  			DebugLocation (116' 4);  			STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  			DebugLocation (117' 4);  			string stringText = (STRING7 != null ? STRING7.Text : default(string));  			stringText = stringText.Substring (1' stringText.Length - 2);  			filterNode = new Value (stringText);  		}  		break;  	case 5:  		DebugEnterAlt (5);  		// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  		{  			DebugLocation (122' 4);  			REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  			DebugLocation (123' 4);  			string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  			regexText = regexText.Substring (1' regexText.Length - 2);  			filterNode = new RegExp (regexText);  		}  		break;  	case 6:  		DebugEnterAlt (6);  		// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  		{  			DebugLocation (128' 4);  			NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  			DebugLocation (129' 4);  			filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  		}  		break;  	case 7:  		DebugEnterAlt (7);  		// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  		{  			DebugLocation (132' 4);  			Match (input' TRUE' Follow._TRUE_in_filterExpr271);  			DebugLocation (133' 4);  			filterNode = new Value (true);  		}  		break;  	case 8:  		DebugEnterAlt (8);  		// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  		{  			DebugLocation (136' 4);  			Match (input' FALSE' Follow._FALSE_in_filterExpr281);  			DebugLocation (137' 4);  			filterNode = new Value (false);  		}  		break;  	case 9:  		DebugEnterAlt (9);  		// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  		{  			DebugLocation (140' 4);  			Match (input' NULL' Follow._NULL_in_filterExpr291);  			DebugLocation (141' 4);  			filterNode = new Value (null);  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("filterExpr"' 6);  	LeaveRule ("filterExpr"' 6);  	LeaveRule_filterExpr ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  	int alt9 = 9;  	try {  		DebugEnterDecision (9' false);  		switch (input.LA (1)) {  		case CHAIN_OPERATOR:  		case COMPARATOR:  			{  				alt9 = 1;  			}  			break;  		case EXPR:  			{  				int LA9_2 = input.LA (2);  				if ((LA9_2 == DOWN)) {  					int LA9_3 = input.LA (3);  					if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  						alt9 = 2;  					}  					else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  						alt9 = 3;  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				else {  					NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  					DebugRecognitionException (nvae);  					throw nvae;  				}  			}  			break;  		case STRING:  			{  				alt9 = 4;  			}  			break;  		case REGEX:  			{  				alt9 = 5;  			}  			break;  		case NUMBER:  			{  				alt9 = 6;  			}  			break;  		case TRUE:  			{  				alt9 = 7;  			}  			break;  		case FALSE:  			{  				alt9 = 8;  			}  			break;  		case NULL:  			{  				alt9 = 9;  			}  			break;  		default: {  			NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  		}  	}  	finally {  		DebugExitDecision (9);  	}  	switch (alt9) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  		{  			DebugLocation (64' 4);  			DebugLocation (64' 6);  			PushFollow (Follow._comparator_in_filterExpr175);  			comparator6 = comparator ();  			PopFollow ();  			Match (input' TokenTypes.Down' null);  			DebugLocation (64' 18);  			PushFollow (Follow._filterExpr_in_filterExpr179);  			a = filterExpr ();  			PopFollow ();  			DebugLocation (64' 31);  			PushFollow (Follow._filterExpr_in_filterExpr183);  			b = filterExpr ();  			PopFollow ();  			Match (input' TokenTypes.Up' null);  			DebugLocation (65' 4);  			Comparator newComparator;  			switch (comparator6) {  			case "=":  				newComparator = Comparator.Equals;  				break;  			case "!=":  				newComparator = Comparator.NotEquals;  				break;  			case ">":  				newComparator = Comparator.Greater;  				break;  			case "<":  				newComparator = Comparator.Less;  				break;  			case ">=":  				newComparator = Comparator.GreaterOrEqual;  				break;  			case "<=":  				newComparator = Comparator.LessOrEqual;  				break;  			case "&":  				newComparator = Comparator.And;  				break;  			case "|":  				newComparator = Comparator.Or;  				break;  			default:  				newComparator = Comparator.Equals;  				break;  			}  			filterNode = new BoolExpression (a' newComparator' b);  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  		{  			DebugLocation (98' 4);  			DebugLocation (98' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr195);  			Match (input' TokenTypes.Down' null);  			DebugLocation (98' 12);  			PushFollow (Follow._filterExpr_in_filterExpr199);  			f = filterExpr ();  			PopFollow ();  			DebugLocation (98' 31);  			// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  			int alt6 = 2;  			try {  				DebugEnterSubRule (6);  				try {  					DebugEnterDecision (6' false);  					int LA6_1 = input.LA (1);  					if ((LA6_1 == 24)) {  						alt6 = 1;  					}  				}  				finally {  					DebugExitDecision (6);  				}  				switch (alt6) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  					{  						DebugLocation (98' 31);  						inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (6);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (99' 4);  			FilterTreeNode newNode = f;  			if ((inverse != null ? inverse.Text : default(string)) == "!")  				newNode.ToggleInversed ();  			filterNode = newNode;  		}  		break;  	case 3:  		DebugEnterAlt (3);  		// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  		{  			DebugLocation (105' 4);  			DebugLocation (105' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr216);  			Match (input' TokenTypes.Down' null);  			DebugLocation (105' 12);  			PushFollow (Follow._propertyChain_in_filterExpr219);  			propertyChain (propertySegments);  			PopFollow ();  			DebugLocation (105' 51);  			// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  			int alt7 = 2;  			try {  				DebugEnterSubRule (7);  				try {  					DebugEnterDecision (7' false);  					int LA7_1 = input.LA (1);  					if ((LA7_1 == 31)) {  						alt7 = 1;  					}  				}  				finally {  					DebugExitDecision (7);  				}  				switch (alt7) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  					{  						DebugLocation (105' 51);  						inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (7);  			}  			DebugLocation (105' 60);  			// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  			int alt8 = 2;  			try {  				DebugEnterSubRule (8);  				try {  					DebugEnterDecision (8' false);  					int LA8_1 = input.LA (1);  					if ((LA8_1 == 24)) {  						alt8 = 1;  					}  				}  				finally {  					DebugExitDecision (8);  				}  				switch (alt8) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  					{  						DebugLocation (105' 60);  						not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (8);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (106' 4);  			FilterTreeNode newProperty = new Property (propertySegments);  			if ((inverse != null ? inverse.Text : default(string)) == "?")  				filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  			else {  				if ((not != null ? not.Text : default(string)) == "!")  					newProperty.ToggleInversed ();  				filterNode = newProperty;  			}  		}  		break;  	case 4:  		DebugEnterAlt (4);  		// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  		{  			DebugLocation (116' 4);  			STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  			DebugLocation (117' 4);  			string stringText = (STRING7 != null ? STRING7.Text : default(string));  			stringText = stringText.Substring (1' stringText.Length - 2);  			filterNode = new Value (stringText);  		}  		break;  	case 5:  		DebugEnterAlt (5);  		// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  		{  			DebugLocation (122' 4);  			REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  			DebugLocation (123' 4);  			string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  			regexText = regexText.Substring (1' regexText.Length - 2);  			filterNode = new RegExp (regexText);  		}  		break;  	case 6:  		DebugEnterAlt (6);  		// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  		{  			DebugLocation (128' 4);  			NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  			DebugLocation (129' 4);  			filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  		}  		break;  	case 7:  		DebugEnterAlt (7);  		// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  		{  			DebugLocation (132' 4);  			Match (input' TRUE' Follow._TRUE_in_filterExpr271);  			DebugLocation (133' 4);  			filterNode = new Value (true);  		}  		break;  	case 8:  		DebugEnterAlt (8);  		// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  		{  			DebugLocation (136' 4);  			Match (input' FALSE' Follow._FALSE_in_filterExpr281);  			DebugLocation (137' 4);  			filterNode = new Value (false);  		}  		break;  	case 9:  		DebugEnterAlt (9);  		// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  		{  			DebugLocation (140' 4);  			Match (input' NULL' Follow._NULL_in_filterExpr291);  			DebugLocation (141' 4);  			filterNode = new Value (null);  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("filterExpr"' 6);  	LeaveRule ("filterExpr"' 6);  	LeaveRule_filterExpr ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  	int alt9 = 9;  	try {  		DebugEnterDecision (9' false);  		switch (input.LA (1)) {  		case CHAIN_OPERATOR:  		case COMPARATOR:  			{  				alt9 = 1;  			}  			break;  		case EXPR:  			{  				int LA9_2 = input.LA (2);  				if ((LA9_2 == DOWN)) {  					int LA9_3 = input.LA (3);  					if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  						alt9 = 2;  					}  					else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  						alt9 = 3;  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				else {  					NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  					DebugRecognitionException (nvae);  					throw nvae;  				}  			}  			break;  		case STRING:  			{  				alt9 = 4;  			}  			break;  		case REGEX:  			{  				alt9 = 5;  			}  			break;  		case NUMBER:  			{  				alt9 = 6;  			}  			break;  		case TRUE:  			{  				alt9 = 7;  			}  			break;  		case FALSE:  			{  				alt9 = 8;  			}  			break;  		case NULL:  			{  				alt9 = 9;  			}  			break;  		default: {  			NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  		}  	}  	finally {  		DebugExitDecision (9);  	}  	switch (alt9) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  		{  			DebugLocation (64' 4);  			DebugLocation (64' 6);  			PushFollow (Follow._comparator_in_filterExpr175);  			comparator6 = comparator ();  			PopFollow ();  			Match (input' TokenTypes.Down' null);  			DebugLocation (64' 18);  			PushFollow (Follow._filterExpr_in_filterExpr179);  			a = filterExpr ();  			PopFollow ();  			DebugLocation (64' 31);  			PushFollow (Follow._filterExpr_in_filterExpr183);  			b = filterExpr ();  			PopFollow ();  			Match (input' TokenTypes.Up' null);  			DebugLocation (65' 4);  			Comparator newComparator;  			switch (comparator6) {  			case "=":  				newComparator = Comparator.Equals;  				break;  			case "!=":  				newComparator = Comparator.NotEquals;  				break;  			case ">":  				newComparator = Comparator.Greater;  				break;  			case "<":  				newComparator = Comparator.Less;  				break;  			case ">=":  				newComparator = Comparator.GreaterOrEqual;  				break;  			case "<=":  				newComparator = Comparator.LessOrEqual;  				break;  			case "&":  				newComparator = Comparator.And;  				break;  			case "|":  				newComparator = Comparator.Or;  				break;  			default:  				newComparator = Comparator.Equals;  				break;  			}  			filterNode = new BoolExpression (a' newComparator' b);  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  		{  			DebugLocation (98' 4);  			DebugLocation (98' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr195);  			Match (input' TokenTypes.Down' null);  			DebugLocation (98' 12);  			PushFollow (Follow._filterExpr_in_filterExpr199);  			f = filterExpr ();  			PopFollow ();  			DebugLocation (98' 31);  			// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  			int alt6 = 2;  			try {  				DebugEnterSubRule (6);  				try {  					DebugEnterDecision (6' false);  					int LA6_1 = input.LA (1);  					if ((LA6_1 == 24)) {  						alt6 = 1;  					}  				}  				finally {  					DebugExitDecision (6);  				}  				switch (alt6) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  					{  						DebugLocation (98' 31);  						inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (6);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (99' 4);  			FilterTreeNode newNode = f;  			if ((inverse != null ? inverse.Text : default(string)) == "!")  				newNode.ToggleInversed ();  			filterNode = newNode;  		}  		break;  	case 3:  		DebugEnterAlt (3);  		// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  		{  			DebugLocation (105' 4);  			DebugLocation (105' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr216);  			Match (input' TokenTypes.Down' null);  			DebugLocation (105' 12);  			PushFollow (Follow._propertyChain_in_filterExpr219);  			propertyChain (propertySegments);  			PopFollow ();  			DebugLocation (105' 51);  			// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  			int alt7 = 2;  			try {  				DebugEnterSubRule (7);  				try {  					DebugEnterDecision (7' false);  					int LA7_1 = input.LA (1);  					if ((LA7_1 == 31)) {  						alt7 = 1;  					}  				}  				finally {  					DebugExitDecision (7);  				}  				switch (alt7) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  					{  						DebugLocation (105' 51);  						inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (7);  			}  			DebugLocation (105' 60);  			// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  			int alt8 = 2;  			try {  				DebugEnterSubRule (8);  				try {  					DebugEnterDecision (8' false);  					int LA8_1 = input.LA (1);  					if ((LA8_1 == 24)) {  						alt8 = 1;  					}  				}  				finally {  					DebugExitDecision (8);  				}  				switch (alt8) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  					{  						DebugLocation (105' 60);  						not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (8);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (106' 4);  			FilterTreeNode newProperty = new Property (propertySegments);  			if ((inverse != null ? inverse.Text : default(string)) == "?")  				filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  			else {  				if ((not != null ? not.Text : default(string)) == "!")  					newProperty.ToggleInversed ();  				filterNode = newProperty;  			}  		}  		break;  	case 4:  		DebugEnterAlt (4);  		// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  		{  			DebugLocation (116' 4);  			STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  			DebugLocation (117' 4);  			string stringText = (STRING7 != null ? STRING7.Text : default(string));  			stringText = stringText.Substring (1' stringText.Length - 2);  			filterNode = new Value (stringText);  		}  		break;  	case 5:  		DebugEnterAlt (5);  		// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  		{  			DebugLocation (122' 4);  			REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  			DebugLocation (123' 4);  			string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  			regexText = regexText.Substring (1' regexText.Length - 2);  			filterNode = new RegExp (regexText);  		}  		break;  	case 6:  		DebugEnterAlt (6);  		// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  		{  			DebugLocation (128' 4);  			NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  			DebugLocation (129' 4);  			filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  		}  		break;  	case 7:  		DebugEnterAlt (7);  		// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  		{  			DebugLocation (132' 4);  			Match (input' TRUE' Follow._TRUE_in_filterExpr271);  			DebugLocation (133' 4);  			filterNode = new Value (true);  		}  		break;  	case 8:  		DebugEnterAlt (8);  		// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  		{  			DebugLocation (136' 4);  			Match (input' FALSE' Follow._FALSE_in_filterExpr281);  			DebugLocation (137' 4);  			filterNode = new Value (false);  		}  		break;  	case 9:  		DebugEnterAlt (9);  		// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  		{  			DebugLocation (140' 4);  			Match (input' NULL' Follow._NULL_in_filterExpr291);  			DebugLocation (141' 4);  			filterNode = new Value (null);  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("filterExpr"' 6);  	LeaveRule ("filterExpr"' 6);  	LeaveRule_filterExpr ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  	int alt9 = 9;  	try {  		DebugEnterDecision (9' false);  		switch (input.LA (1)) {  		case CHAIN_OPERATOR:  		case COMPARATOR:  			{  				alt9 = 1;  			}  			break;  		case EXPR:  			{  				int LA9_2 = input.LA (2);  				if ((LA9_2 == DOWN)) {  					int LA9_3 = input.LA (3);  					if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  						alt9 = 2;  					}  					else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  						alt9 = 3;  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				else {  					NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  					DebugRecognitionException (nvae);  					throw nvae;  				}  			}  			break;  		case STRING:  			{  				alt9 = 4;  			}  			break;  		case REGEX:  			{  				alt9 = 5;  			}  			break;  		case NUMBER:  			{  				alt9 = 6;  			}  			break;  		case TRUE:  			{  				alt9 = 7;  			}  			break;  		case FALSE:  			{  				alt9 = 8;  			}  			break;  		case NULL:  			{  				alt9 = 9;  			}  			break;  		default: {  			NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  		}  	}  	finally {  		DebugExitDecision (9);  	}  	switch (alt9) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  		{  			DebugLocation (64' 4);  			DebugLocation (64' 6);  			PushFollow (Follow._comparator_in_filterExpr175);  			comparator6 = comparator ();  			PopFollow ();  			Match (input' TokenTypes.Down' null);  			DebugLocation (64' 18);  			PushFollow (Follow._filterExpr_in_filterExpr179);  			a = filterExpr ();  			PopFollow ();  			DebugLocation (64' 31);  			PushFollow (Follow._filterExpr_in_filterExpr183);  			b = filterExpr ();  			PopFollow ();  			Match (input' TokenTypes.Up' null);  			DebugLocation (65' 4);  			Comparator newComparator;  			switch (comparator6) {  			case "=":  				newComparator = Comparator.Equals;  				break;  			case "!=":  				newComparator = Comparator.NotEquals;  				break;  			case ">":  				newComparator = Comparator.Greater;  				break;  			case "<":  				newComparator = Comparator.Less;  				break;  			case ">=":  				newComparator = Comparator.GreaterOrEqual;  				break;  			case "<=":  				newComparator = Comparator.LessOrEqual;  				break;  			case "&":  				newComparator = Comparator.And;  				break;  			case "|":  				newComparator = Comparator.Or;  				break;  			default:  				newComparator = Comparator.Equals;  				break;  			}  			filterNode = new BoolExpression (a' newComparator' b);  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  		{  			DebugLocation (98' 4);  			DebugLocation (98' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr195);  			Match (input' TokenTypes.Down' null);  			DebugLocation (98' 12);  			PushFollow (Follow._filterExpr_in_filterExpr199);  			f = filterExpr ();  			PopFollow ();  			DebugLocation (98' 31);  			// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  			int alt6 = 2;  			try {  				DebugEnterSubRule (6);  				try {  					DebugEnterDecision (6' false);  					int LA6_1 = input.LA (1);  					if ((LA6_1 == 24)) {  						alt6 = 1;  					}  				}  				finally {  					DebugExitDecision (6);  				}  				switch (alt6) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  					{  						DebugLocation (98' 31);  						inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (6);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (99' 4);  			FilterTreeNode newNode = f;  			if ((inverse != null ? inverse.Text : default(string)) == "!")  				newNode.ToggleInversed ();  			filterNode = newNode;  		}  		break;  	case 3:  		DebugEnterAlt (3);  		// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  		{  			DebugLocation (105' 4);  			DebugLocation (105' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr216);  			Match (input' TokenTypes.Down' null);  			DebugLocation (105' 12);  			PushFollow (Follow._propertyChain_in_filterExpr219);  			propertyChain (propertySegments);  			PopFollow ();  			DebugLocation (105' 51);  			// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  			int alt7 = 2;  			try {  				DebugEnterSubRule (7);  				try {  					DebugEnterDecision (7' false);  					int LA7_1 = input.LA (1);  					if ((LA7_1 == 31)) {  						alt7 = 1;  					}  				}  				finally {  					DebugExitDecision (7);  				}  				switch (alt7) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  					{  						DebugLocation (105' 51);  						inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (7);  			}  			DebugLocation (105' 60);  			// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  			int alt8 = 2;  			try {  				DebugEnterSubRule (8);  				try {  					DebugEnterDecision (8' false);  					int LA8_1 = input.LA (1);  					if ((LA8_1 == 24)) {  						alt8 = 1;  					}  				}  				finally {  					DebugExitDecision (8);  				}  				switch (alt8) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  					{  						DebugLocation (105' 60);  						not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (8);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (106' 4);  			FilterTreeNode newProperty = new Property (propertySegments);  			if ((inverse != null ? inverse.Text : default(string)) == "?")  				filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  			else {  				if ((not != null ? not.Text : default(string)) == "!")  					newProperty.ToggleInversed ();  				filterNode = newProperty;  			}  		}  		break;  	case 4:  		DebugEnterAlt (4);  		// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  		{  			DebugLocation (116' 4);  			STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  			DebugLocation (117' 4);  			string stringText = (STRING7 != null ? STRING7.Text : default(string));  			stringText = stringText.Substring (1' stringText.Length - 2);  			filterNode = new Value (stringText);  		}  		break;  	case 5:  		DebugEnterAlt (5);  		// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  		{  			DebugLocation (122' 4);  			REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  			DebugLocation (123' 4);  			string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  			regexText = regexText.Substring (1' regexText.Length - 2);  			filterNode = new RegExp (regexText);  		}  		break;  	case 6:  		DebugEnterAlt (6);  		// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  		{  			DebugLocation (128' 4);  			NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  			DebugLocation (129' 4);  			filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  		}  		break;  	case 7:  		DebugEnterAlt (7);  		// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  		{  			DebugLocation (132' 4);  			Match (input' TRUE' Follow._TRUE_in_filterExpr271);  			DebugLocation (133' 4);  			filterNode = new Value (true);  		}  		break;  	case 8:  		DebugEnterAlt (8);  		// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  		{  			DebugLocation (136' 4);  			Match (input' FALSE' Follow._FALSE_in_filterExpr281);  			DebugLocation (137' 4);  			filterNode = new Value (false);  		}  		break;  	case 9:  		DebugEnterAlt (9);  		// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  		{  			DebugLocation (140' 4);  			Match (input' NULL' Follow._NULL_in_filterExpr291);  			DebugLocation (141' 4);  			filterNode = new Value (null);  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("filterExpr"' 6);  	LeaveRule ("filterExpr"' 6);  	LeaveRule_filterExpr ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  	int alt9 = 9;  	try {  		DebugEnterDecision (9' false);  		switch (input.LA (1)) {  		case CHAIN_OPERATOR:  		case COMPARATOR:  			{  				alt9 = 1;  			}  			break;  		case EXPR:  			{  				int LA9_2 = input.LA (2);  				if ((LA9_2 == DOWN)) {  					int LA9_3 = input.LA (3);  					if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  						alt9 = 2;  					}  					else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  						alt9 = 3;  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				else {  					NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  					DebugRecognitionException (nvae);  					throw nvae;  				}  			}  			break;  		case STRING:  			{  				alt9 = 4;  			}  			break;  		case REGEX:  			{  				alt9 = 5;  			}  			break;  		case NUMBER:  			{  				alt9 = 6;  			}  			break;  		case TRUE:  			{  				alt9 = 7;  			}  			break;  		case FALSE:  			{  				alt9 = 8;  			}  			break;  		case NULL:  			{  				alt9 = 9;  			}  			break;  		default: {  			NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  		}  	}  	finally {  		DebugExitDecision (9);  	}  	switch (alt9) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  		{  			DebugLocation (64' 4);  			DebugLocation (64' 6);  			PushFollow (Follow._comparator_in_filterExpr175);  			comparator6 = comparator ();  			PopFollow ();  			Match (input' TokenTypes.Down' null);  			DebugLocation (64' 18);  			PushFollow (Follow._filterExpr_in_filterExpr179);  			a = filterExpr ();  			PopFollow ();  			DebugLocation (64' 31);  			PushFollow (Follow._filterExpr_in_filterExpr183);  			b = filterExpr ();  			PopFollow ();  			Match (input' TokenTypes.Up' null);  			DebugLocation (65' 4);  			Comparator newComparator;  			switch (comparator6) {  			case "=":  				newComparator = Comparator.Equals;  				break;  			case "!=":  				newComparator = Comparator.NotEquals;  				break;  			case ">":  				newComparator = Comparator.Greater;  				break;  			case "<":  				newComparator = Comparator.Less;  				break;  			case ">=":  				newComparator = Comparator.GreaterOrEqual;  				break;  			case "<=":  				newComparator = Comparator.LessOrEqual;  				break;  			case "&":  				newComparator = Comparator.And;  				break;  			case "|":  				newComparator = Comparator.Or;  				break;  			default:  				newComparator = Comparator.Equals;  				break;  			}  			filterNode = new BoolExpression (a' newComparator' b);  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  		{  			DebugLocation (98' 4);  			DebugLocation (98' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr195);  			Match (input' TokenTypes.Down' null);  			DebugLocation (98' 12);  			PushFollow (Follow._filterExpr_in_filterExpr199);  			f = filterExpr ();  			PopFollow ();  			DebugLocation (98' 31);  			// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  			int alt6 = 2;  			try {  				DebugEnterSubRule (6);  				try {  					DebugEnterDecision (6' false);  					int LA6_1 = input.LA (1);  					if ((LA6_1 == 24)) {  						alt6 = 1;  					}  				}  				finally {  					DebugExitDecision (6);  				}  				switch (alt6) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  					{  						DebugLocation (98' 31);  						inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (6);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (99' 4);  			FilterTreeNode newNode = f;  			if ((inverse != null ? inverse.Text : default(string)) == "!")  				newNode.ToggleInversed ();  			filterNode = newNode;  		}  		break;  	case 3:  		DebugEnterAlt (3);  		// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  		{  			DebugLocation (105' 4);  			DebugLocation (105' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr216);  			Match (input' TokenTypes.Down' null);  			DebugLocation (105' 12);  			PushFollow (Follow._propertyChain_in_filterExpr219);  			propertyChain (propertySegments);  			PopFollow ();  			DebugLocation (105' 51);  			// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  			int alt7 = 2;  			try {  				DebugEnterSubRule (7);  				try {  					DebugEnterDecision (7' false);  					int LA7_1 = input.LA (1);  					if ((LA7_1 == 31)) {  						alt7 = 1;  					}  				}  				finally {  					DebugExitDecision (7);  				}  				switch (alt7) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  					{  						DebugLocation (105' 51);  						inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (7);  			}  			DebugLocation (105' 60);  			// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  			int alt8 = 2;  			try {  				DebugEnterSubRule (8);  				try {  					DebugEnterDecision (8' false);  					int LA8_1 = input.LA (1);  					if ((LA8_1 == 24)) {  						alt8 = 1;  					}  				}  				finally {  					DebugExitDecision (8);  				}  				switch (alt8) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  					{  						DebugLocation (105' 60);  						not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (8);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (106' 4);  			FilterTreeNode newProperty = new Property (propertySegments);  			if ((inverse != null ? inverse.Text : default(string)) == "?")  				filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  			else {  				if ((not != null ? not.Text : default(string)) == "!")  					newProperty.ToggleInversed ();  				filterNode = newProperty;  			}  		}  		break;  	case 4:  		DebugEnterAlt (4);  		// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  		{  			DebugLocation (116' 4);  			STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  			DebugLocation (117' 4);  			string stringText = (STRING7 != null ? STRING7.Text : default(string));  			stringText = stringText.Substring (1' stringText.Length - 2);  			filterNode = new Value (stringText);  		}  		break;  	case 5:  		DebugEnterAlt (5);  		// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  		{  			DebugLocation (122' 4);  			REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  			DebugLocation (123' 4);  			string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  			regexText = regexText.Substring (1' regexText.Length - 2);  			filterNode = new RegExp (regexText);  		}  		break;  	case 6:  		DebugEnterAlt (6);  		// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  		{  			DebugLocation (128' 4);  			NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  			DebugLocation (129' 4);  			filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  		}  		break;  	case 7:  		DebugEnterAlt (7);  		// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  		{  			DebugLocation (132' 4);  			Match (input' TRUE' Follow._TRUE_in_filterExpr271);  			DebugLocation (133' 4);  			filterNode = new Value (true);  		}  		break;  	case 8:  		DebugEnterAlt (8);  		// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  		{  			DebugLocation (136' 4);  			Match (input' FALSE' Follow._FALSE_in_filterExpr281);  			DebugLocation (137' 4);  			filterNode = new Value (false);  		}  		break;  	case 9:  		DebugEnterAlt (9);  		// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  		{  			DebugLocation (140' 4);  			Match (input' NULL' Follow._NULL_in_filterExpr291);  			DebugLocation (141' 4);  			filterNode = new Value (null);  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("filterExpr"' 6);  	LeaveRule ("filterExpr"' 6);  	LeaveRule_filterExpr ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  	int alt9 = 9;  	try {  		DebugEnterDecision (9' false);  		switch (input.LA (1)) {  		case CHAIN_OPERATOR:  		case COMPARATOR:  			{  				alt9 = 1;  			}  			break;  		case EXPR:  			{  				int LA9_2 = input.LA (2);  				if ((LA9_2 == DOWN)) {  					int LA9_3 = input.LA (3);  					if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  						alt9 = 2;  					}  					else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  						alt9 = 3;  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				else {  					NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  					DebugRecognitionException (nvae);  					throw nvae;  				}  			}  			break;  		case STRING:  			{  				alt9 = 4;  			}  			break;  		case REGEX:  			{  				alt9 = 5;  			}  			break;  		case NUMBER:  			{  				alt9 = 6;  			}  			break;  		case TRUE:  			{  				alt9 = 7;  			}  			break;  		case FALSE:  			{  				alt9 = 8;  			}  			break;  		case NULL:  			{  				alt9 = 9;  			}  			break;  		default: {  			NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  		}  	}  	finally {  		DebugExitDecision (9);  	}  	switch (alt9) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  		{  			DebugLocation (64' 4);  			DebugLocation (64' 6);  			PushFollow (Follow._comparator_in_filterExpr175);  			comparator6 = comparator ();  			PopFollow ();  			Match (input' TokenTypes.Down' null);  			DebugLocation (64' 18);  			PushFollow (Follow._filterExpr_in_filterExpr179);  			a = filterExpr ();  			PopFollow ();  			DebugLocation (64' 31);  			PushFollow (Follow._filterExpr_in_filterExpr183);  			b = filterExpr ();  			PopFollow ();  			Match (input' TokenTypes.Up' null);  			DebugLocation (65' 4);  			Comparator newComparator;  			switch (comparator6) {  			case "=":  				newComparator = Comparator.Equals;  				break;  			case "!=":  				newComparator = Comparator.NotEquals;  				break;  			case ">":  				newComparator = Comparator.Greater;  				break;  			case "<":  				newComparator = Comparator.Less;  				break;  			case ">=":  				newComparator = Comparator.GreaterOrEqual;  				break;  			case "<=":  				newComparator = Comparator.LessOrEqual;  				break;  			case "&":  				newComparator = Comparator.And;  				break;  			case "|":  				newComparator = Comparator.Or;  				break;  			default:  				newComparator = Comparator.Equals;  				break;  			}  			filterNode = new BoolExpression (a' newComparator' b);  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  		{  			DebugLocation (98' 4);  			DebugLocation (98' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr195);  			Match (input' TokenTypes.Down' null);  			DebugLocation (98' 12);  			PushFollow (Follow._filterExpr_in_filterExpr199);  			f = filterExpr ();  			PopFollow ();  			DebugLocation (98' 31);  			// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  			int alt6 = 2;  			try {  				DebugEnterSubRule (6);  				try {  					DebugEnterDecision (6' false);  					int LA6_1 = input.LA (1);  					if ((LA6_1 == 24)) {  						alt6 = 1;  					}  				}  				finally {  					DebugExitDecision (6);  				}  				switch (alt6) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  					{  						DebugLocation (98' 31);  						inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (6);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (99' 4);  			FilterTreeNode newNode = f;  			if ((inverse != null ? inverse.Text : default(string)) == "!")  				newNode.ToggleInversed ();  			filterNode = newNode;  		}  		break;  	case 3:  		DebugEnterAlt (3);  		// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  		{  			DebugLocation (105' 4);  			DebugLocation (105' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr216);  			Match (input' TokenTypes.Down' null);  			DebugLocation (105' 12);  			PushFollow (Follow._propertyChain_in_filterExpr219);  			propertyChain (propertySegments);  			PopFollow ();  			DebugLocation (105' 51);  			// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  			int alt7 = 2;  			try {  				DebugEnterSubRule (7);  				try {  					DebugEnterDecision (7' false);  					int LA7_1 = input.LA (1);  					if ((LA7_1 == 31)) {  						alt7 = 1;  					}  				}  				finally {  					DebugExitDecision (7);  				}  				switch (alt7) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  					{  						DebugLocation (105' 51);  						inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (7);  			}  			DebugLocation (105' 60);  			// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  			int alt8 = 2;  			try {  				DebugEnterSubRule (8);  				try {  					DebugEnterDecision (8' false);  					int LA8_1 = input.LA (1);  					if ((LA8_1 == 24)) {  						alt8 = 1;  					}  				}  				finally {  					DebugExitDecision (8);  				}  				switch (alt8) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  					{  						DebugLocation (105' 60);  						not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (8);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (106' 4);  			FilterTreeNode newProperty = new Property (propertySegments);  			if ((inverse != null ? inverse.Text : default(string)) == "?")  				filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  			else {  				if ((not != null ? not.Text : default(string)) == "!")  					newProperty.ToggleInversed ();  				filterNode = newProperty;  			}  		}  		break;  	case 4:  		DebugEnterAlt (4);  		// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  		{  			DebugLocation (116' 4);  			STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  			DebugLocation (117' 4);  			string stringText = (STRING7 != null ? STRING7.Text : default(string));  			stringText = stringText.Substring (1' stringText.Length - 2);  			filterNode = new Value (stringText);  		}  		break;  	case 5:  		DebugEnterAlt (5);  		// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  		{  			DebugLocation (122' 4);  			REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  			DebugLocation (123' 4);  			string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  			regexText = regexText.Substring (1' regexText.Length - 2);  			filterNode = new RegExp (regexText);  		}  		break;  	case 6:  		DebugEnterAlt (6);  		// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  		{  			DebugLocation (128' 4);  			NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  			DebugLocation (129' 4);  			filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  		}  		break;  	case 7:  		DebugEnterAlt (7);  		// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  		{  			DebugLocation (132' 4);  			Match (input' TRUE' Follow._TRUE_in_filterExpr271);  			DebugLocation (133' 4);  			filterNode = new Value (true);  		}  		break;  	case 8:  		DebugEnterAlt (8);  		// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  		{  			DebugLocation (136' 4);  			Match (input' FALSE' Follow._FALSE_in_filterExpr281);  			DebugLocation (137' 4);  			filterNode = new Value (false);  		}  		break;  	case 9:  		DebugEnterAlt (9);  		// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  		{  			DebugLocation (140' 4);  			Match (input' NULL' Follow._NULL_in_filterExpr291);  			DebugLocation (141' 4);  			filterNode = new Value (null);  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("filterExpr"' 6);  	LeaveRule ("filterExpr"' 6);  	LeaveRule_filterExpr ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  	int alt9 = 9;  	try {  		DebugEnterDecision (9' false);  		switch (input.LA (1)) {  		case CHAIN_OPERATOR:  		case COMPARATOR:  			{  				alt9 = 1;  			}  			break;  		case EXPR:  			{  				int LA9_2 = input.LA (2);  				if ((LA9_2 == DOWN)) {  					int LA9_3 = input.LA (3);  					if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  						alt9 = 2;  					}  					else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  						alt9 = 3;  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				else {  					NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  					DebugRecognitionException (nvae);  					throw nvae;  				}  			}  			break;  		case STRING:  			{  				alt9 = 4;  			}  			break;  		case REGEX:  			{  				alt9 = 5;  			}  			break;  		case NUMBER:  			{  				alt9 = 6;  			}  			break;  		case TRUE:  			{  				alt9 = 7;  			}  			break;  		case FALSE:  			{  				alt9 = 8;  			}  			break;  		case NULL:  			{  				alt9 = 9;  			}  			break;  		default: {  			NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  		}  	}  	finally {  		DebugExitDecision (9);  	}  	switch (alt9) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  		{  			DebugLocation (64' 4);  			DebugLocation (64' 6);  			PushFollow (Follow._comparator_in_filterExpr175);  			comparator6 = comparator ();  			PopFollow ();  			Match (input' TokenTypes.Down' null);  			DebugLocation (64' 18);  			PushFollow (Follow._filterExpr_in_filterExpr179);  			a = filterExpr ();  			PopFollow ();  			DebugLocation (64' 31);  			PushFollow (Follow._filterExpr_in_filterExpr183);  			b = filterExpr ();  			PopFollow ();  			Match (input' TokenTypes.Up' null);  			DebugLocation (65' 4);  			Comparator newComparator;  			switch (comparator6) {  			case "=":  				newComparator = Comparator.Equals;  				break;  			case "!=":  				newComparator = Comparator.NotEquals;  				break;  			case ">":  				newComparator = Comparator.Greater;  				break;  			case "<":  				newComparator = Comparator.Less;  				break;  			case ">=":  				newComparator = Comparator.GreaterOrEqual;  				break;  			case "<=":  				newComparator = Comparator.LessOrEqual;  				break;  			case "&":  				newComparator = Comparator.And;  				break;  			case "|":  				newComparator = Comparator.Or;  				break;  			default:  				newComparator = Comparator.Equals;  				break;  			}  			filterNode = new BoolExpression (a' newComparator' b);  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  		{  			DebugLocation (98' 4);  			DebugLocation (98' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr195);  			Match (input' TokenTypes.Down' null);  			DebugLocation (98' 12);  			PushFollow (Follow._filterExpr_in_filterExpr199);  			f = filterExpr ();  			PopFollow ();  			DebugLocation (98' 31);  			// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  			int alt6 = 2;  			try {  				DebugEnterSubRule (6);  				try {  					DebugEnterDecision (6' false);  					int LA6_1 = input.LA (1);  					if ((LA6_1 == 24)) {  						alt6 = 1;  					}  				}  				finally {  					DebugExitDecision (6);  				}  				switch (alt6) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  					{  						DebugLocation (98' 31);  						inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (6);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (99' 4);  			FilterTreeNode newNode = f;  			if ((inverse != null ? inverse.Text : default(string)) == "!")  				newNode.ToggleInversed ();  			filterNode = newNode;  		}  		break;  	case 3:  		DebugEnterAlt (3);  		// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  		{  			DebugLocation (105' 4);  			DebugLocation (105' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr216);  			Match (input' TokenTypes.Down' null);  			DebugLocation (105' 12);  			PushFollow (Follow._propertyChain_in_filterExpr219);  			propertyChain (propertySegments);  			PopFollow ();  			DebugLocation (105' 51);  			// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  			int alt7 = 2;  			try {  				DebugEnterSubRule (7);  				try {  					DebugEnterDecision (7' false);  					int LA7_1 = input.LA (1);  					if ((LA7_1 == 31)) {  						alt7 = 1;  					}  				}  				finally {  					DebugExitDecision (7);  				}  				switch (alt7) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  					{  						DebugLocation (105' 51);  						inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (7);  			}  			DebugLocation (105' 60);  			// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  			int alt8 = 2;  			try {  				DebugEnterSubRule (8);  				try {  					DebugEnterDecision (8' false);  					int LA8_1 = input.LA (1);  					if ((LA8_1 == 24)) {  						alt8 = 1;  					}  				}  				finally {  					DebugExitDecision (8);  				}  				switch (alt8) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  					{  						DebugLocation (105' 60);  						not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (8);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (106' 4);  			FilterTreeNode newProperty = new Property (propertySegments);  			if ((inverse != null ? inverse.Text : default(string)) == "?")  				filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  			else {  				if ((not != null ? not.Text : default(string)) == "!")  					newProperty.ToggleInversed ();  				filterNode = newProperty;  			}  		}  		break;  	case 4:  		DebugEnterAlt (4);  		// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  		{  			DebugLocation (116' 4);  			STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  			DebugLocation (117' 4);  			string stringText = (STRING7 != null ? STRING7.Text : default(string));  			stringText = stringText.Substring (1' stringText.Length - 2);  			filterNode = new Value (stringText);  		}  		break;  	case 5:  		DebugEnterAlt (5);  		// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  		{  			DebugLocation (122' 4);  			REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  			DebugLocation (123' 4);  			string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  			regexText = regexText.Substring (1' regexText.Length - 2);  			filterNode = new RegExp (regexText);  		}  		break;  	case 6:  		DebugEnterAlt (6);  		// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  		{  			DebugLocation (128' 4);  			NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  			DebugLocation (129' 4);  			filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  		}  		break;  	case 7:  		DebugEnterAlt (7);  		// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  		{  			DebugLocation (132' 4);  			Match (input' TRUE' Follow._TRUE_in_filterExpr271);  			DebugLocation (133' 4);  			filterNode = new Value (true);  		}  		break;  	case 8:  		DebugEnterAlt (8);  		// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  		{  			DebugLocation (136' 4);  			Match (input' FALSE' Follow._FALSE_in_filterExpr281);  			DebugLocation (137' 4);  			filterNode = new Value (false);  		}  		break;  	case 9:  		DebugEnterAlt (9);  		// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  		{  			DebugLocation (140' 4);  			Match (input' NULL' Follow._NULL_in_filterExpr291);  			DebugLocation (141' 4);  			filterNode = new Value (null);  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("filterExpr"' 6);  	LeaveRule ("filterExpr"' 6);  	LeaveRule_filterExpr ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  	int alt9 = 9;  	try {  		DebugEnterDecision (9' false);  		switch (input.LA (1)) {  		case CHAIN_OPERATOR:  		case COMPARATOR:  			{  				alt9 = 1;  			}  			break;  		case EXPR:  			{  				int LA9_2 = input.LA (2);  				if ((LA9_2 == DOWN)) {  					int LA9_3 = input.LA (3);  					if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  						alt9 = 2;  					}  					else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  						alt9 = 3;  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				else {  					NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  					DebugRecognitionException (nvae);  					throw nvae;  				}  			}  			break;  		case STRING:  			{  				alt9 = 4;  			}  			break;  		case REGEX:  			{  				alt9 = 5;  			}  			break;  		case NUMBER:  			{  				alt9 = 6;  			}  			break;  		case TRUE:  			{  				alt9 = 7;  			}  			break;  		case FALSE:  			{  				alt9 = 8;  			}  			break;  		case NULL:  			{  				alt9 = 9;  			}  			break;  		default: {  			NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  		}  	}  	finally {  		DebugExitDecision (9);  	}  	switch (alt9) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  		{  			DebugLocation (64' 4);  			DebugLocation (64' 6);  			PushFollow (Follow._comparator_in_filterExpr175);  			comparator6 = comparator ();  			PopFollow ();  			Match (input' TokenTypes.Down' null);  			DebugLocation (64' 18);  			PushFollow (Follow._filterExpr_in_filterExpr179);  			a = filterExpr ();  			PopFollow ();  			DebugLocation (64' 31);  			PushFollow (Follow._filterExpr_in_filterExpr183);  			b = filterExpr ();  			PopFollow ();  			Match (input' TokenTypes.Up' null);  			DebugLocation (65' 4);  			Comparator newComparator;  			switch (comparator6) {  			case "=":  				newComparator = Comparator.Equals;  				break;  			case "!=":  				newComparator = Comparator.NotEquals;  				break;  			case ">":  				newComparator = Comparator.Greater;  				break;  			case "<":  				newComparator = Comparator.Less;  				break;  			case ">=":  				newComparator = Comparator.GreaterOrEqual;  				break;  			case "<=":  				newComparator = Comparator.LessOrEqual;  				break;  			case "&":  				newComparator = Comparator.And;  				break;  			case "|":  				newComparator = Comparator.Or;  				break;  			default:  				newComparator = Comparator.Equals;  				break;  			}  			filterNode = new BoolExpression (a' newComparator' b);  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  		{  			DebugLocation (98' 4);  			DebugLocation (98' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr195);  			Match (input' TokenTypes.Down' null);  			DebugLocation (98' 12);  			PushFollow (Follow._filterExpr_in_filterExpr199);  			f = filterExpr ();  			PopFollow ();  			DebugLocation (98' 31);  			// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  			int alt6 = 2;  			try {  				DebugEnterSubRule (6);  				try {  					DebugEnterDecision (6' false);  					int LA6_1 = input.LA (1);  					if ((LA6_1 == 24)) {  						alt6 = 1;  					}  				}  				finally {  					DebugExitDecision (6);  				}  				switch (alt6) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  					{  						DebugLocation (98' 31);  						inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (6);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (99' 4);  			FilterTreeNode newNode = f;  			if ((inverse != null ? inverse.Text : default(string)) == "!")  				newNode.ToggleInversed ();  			filterNode = newNode;  		}  		break;  	case 3:  		DebugEnterAlt (3);  		// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  		{  			DebugLocation (105' 4);  			DebugLocation (105' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr216);  			Match (input' TokenTypes.Down' null);  			DebugLocation (105' 12);  			PushFollow (Follow._propertyChain_in_filterExpr219);  			propertyChain (propertySegments);  			PopFollow ();  			DebugLocation (105' 51);  			// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  			int alt7 = 2;  			try {  				DebugEnterSubRule (7);  				try {  					DebugEnterDecision (7' false);  					int LA7_1 = input.LA (1);  					if ((LA7_1 == 31)) {  						alt7 = 1;  					}  				}  				finally {  					DebugExitDecision (7);  				}  				switch (alt7) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  					{  						DebugLocation (105' 51);  						inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (7);  			}  			DebugLocation (105' 60);  			// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  			int alt8 = 2;  			try {  				DebugEnterSubRule (8);  				try {  					DebugEnterDecision (8' false);  					int LA8_1 = input.LA (1);  					if ((LA8_1 == 24)) {  						alt8 = 1;  					}  				}  				finally {  					DebugExitDecision (8);  				}  				switch (alt8) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  					{  						DebugLocation (105' 60);  						not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (8);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (106' 4);  			FilterTreeNode newProperty = new Property (propertySegments);  			if ((inverse != null ? inverse.Text : default(string)) == "?")  				filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  			else {  				if ((not != null ? not.Text : default(string)) == "!")  					newProperty.ToggleInversed ();  				filterNode = newProperty;  			}  		}  		break;  	case 4:  		DebugEnterAlt (4);  		// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  		{  			DebugLocation (116' 4);  			STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  			DebugLocation (117' 4);  			string stringText = (STRING7 != null ? STRING7.Text : default(string));  			stringText = stringText.Substring (1' stringText.Length - 2);  			filterNode = new Value (stringText);  		}  		break;  	case 5:  		DebugEnterAlt (5);  		// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  		{  			DebugLocation (122' 4);  			REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  			DebugLocation (123' 4);  			string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  			regexText = regexText.Substring (1' regexText.Length - 2);  			filterNode = new RegExp (regexText);  		}  		break;  	case 6:  		DebugEnterAlt (6);  		// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  		{  			DebugLocation (128' 4);  			NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  			DebugLocation (129' 4);  			filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  		}  		break;  	case 7:  		DebugEnterAlt (7);  		// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  		{  			DebugLocation (132' 4);  			Match (input' TRUE' Follow._TRUE_in_filterExpr271);  			DebugLocation (133' 4);  			filterNode = new Value (true);  		}  		break;  	case 8:  		DebugEnterAlt (8);  		// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  		{  			DebugLocation (136' 4);  			Match (input' FALSE' Follow._FALSE_in_filterExpr281);  			DebugLocation (137' 4);  			filterNode = new Value (false);  		}  		break;  	case 9:  		DebugEnterAlt (9);  		// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  		{  			DebugLocation (140' 4);  			Match (input' NULL' Follow._NULL_in_filterExpr291);  			DebugLocation (141' 4);  			filterNode = new Value (null);  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("filterExpr"' 6);  	LeaveRule ("filterExpr"' 6);  	LeaveRule_filterExpr ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  	int alt9 = 9;  	try {  		DebugEnterDecision (9' false);  		switch (input.LA (1)) {  		case CHAIN_OPERATOR:  		case COMPARATOR:  			{  				alt9 = 1;  			}  			break;  		case EXPR:  			{  				int LA9_2 = input.LA (2);  				if ((LA9_2 == DOWN)) {  					int LA9_3 = input.LA (3);  					if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  						alt9 = 2;  					}  					else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  						alt9 = 3;  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				else {  					NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  					DebugRecognitionException (nvae);  					throw nvae;  				}  			}  			break;  		case STRING:  			{  				alt9 = 4;  			}  			break;  		case REGEX:  			{  				alt9 = 5;  			}  			break;  		case NUMBER:  			{  				alt9 = 6;  			}  			break;  		case TRUE:  			{  				alt9 = 7;  			}  			break;  		case FALSE:  			{  				alt9 = 8;  			}  			break;  		case NULL:  			{  				alt9 = 9;  			}  			break;  		default: {  			NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  		}  	}  	finally {  		DebugExitDecision (9);  	}  	switch (alt9) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  		{  			DebugLocation (64' 4);  			DebugLocation (64' 6);  			PushFollow (Follow._comparator_in_filterExpr175);  			comparator6 = comparator ();  			PopFollow ();  			Match (input' TokenTypes.Down' null);  			DebugLocation (64' 18);  			PushFollow (Follow._filterExpr_in_filterExpr179);  			a = filterExpr ();  			PopFollow ();  			DebugLocation (64' 31);  			PushFollow (Follow._filterExpr_in_filterExpr183);  			b = filterExpr ();  			PopFollow ();  			Match (input' TokenTypes.Up' null);  			DebugLocation (65' 4);  			Comparator newComparator;  			switch (comparator6) {  			case "=":  				newComparator = Comparator.Equals;  				break;  			case "!=":  				newComparator = Comparator.NotEquals;  				break;  			case ">":  				newComparator = Comparator.Greater;  				break;  			case "<":  				newComparator = Comparator.Less;  				break;  			case ">=":  				newComparator = Comparator.GreaterOrEqual;  				break;  			case "<=":  				newComparator = Comparator.LessOrEqual;  				break;  			case "&":  				newComparator = Comparator.And;  				break;  			case "|":  				newComparator = Comparator.Or;  				break;  			default:  				newComparator = Comparator.Equals;  				break;  			}  			filterNode = new BoolExpression (a' newComparator' b);  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  		{  			DebugLocation (98' 4);  			DebugLocation (98' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr195);  			Match (input' TokenTypes.Down' null);  			DebugLocation (98' 12);  			PushFollow (Follow._filterExpr_in_filterExpr199);  			f = filterExpr ();  			PopFollow ();  			DebugLocation (98' 31);  			// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  			int alt6 = 2;  			try {  				DebugEnterSubRule (6);  				try {  					DebugEnterDecision (6' false);  					int LA6_1 = input.LA (1);  					if ((LA6_1 == 24)) {  						alt6 = 1;  					}  				}  				finally {  					DebugExitDecision (6);  				}  				switch (alt6) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  					{  						DebugLocation (98' 31);  						inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (6);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (99' 4);  			FilterTreeNode newNode = f;  			if ((inverse != null ? inverse.Text : default(string)) == "!")  				newNode.ToggleInversed ();  			filterNode = newNode;  		}  		break;  	case 3:  		DebugEnterAlt (3);  		// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  		{  			DebugLocation (105' 4);  			DebugLocation (105' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr216);  			Match (input' TokenTypes.Down' null);  			DebugLocation (105' 12);  			PushFollow (Follow._propertyChain_in_filterExpr219);  			propertyChain (propertySegments);  			PopFollow ();  			DebugLocation (105' 51);  			// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  			int alt7 = 2;  			try {  				DebugEnterSubRule (7);  				try {  					DebugEnterDecision (7' false);  					int LA7_1 = input.LA (1);  					if ((LA7_1 == 31)) {  						alt7 = 1;  					}  				}  				finally {  					DebugExitDecision (7);  				}  				switch (alt7) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  					{  						DebugLocation (105' 51);  						inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (7);  			}  			DebugLocation (105' 60);  			// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  			int alt8 = 2;  			try {  				DebugEnterSubRule (8);  				try {  					DebugEnterDecision (8' false);  					int LA8_1 = input.LA (1);  					if ((LA8_1 == 24)) {  						alt8 = 1;  					}  				}  				finally {  					DebugExitDecision (8);  				}  				switch (alt8) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  					{  						DebugLocation (105' 60);  						not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (8);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (106' 4);  			FilterTreeNode newProperty = new Property (propertySegments);  			if ((inverse != null ? inverse.Text : default(string)) == "?")  				filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  			else {  				if ((not != null ? not.Text : default(string)) == "!")  					newProperty.ToggleInversed ();  				filterNode = newProperty;  			}  		}  		break;  	case 4:  		DebugEnterAlt (4);  		// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  		{  			DebugLocation (116' 4);  			STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  			DebugLocation (117' 4);  			string stringText = (STRING7 != null ? STRING7.Text : default(string));  			stringText = stringText.Substring (1' stringText.Length - 2);  			filterNode = new Value (stringText);  		}  		break;  	case 5:  		DebugEnterAlt (5);  		// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  		{  			DebugLocation (122' 4);  			REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  			DebugLocation (123' 4);  			string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  			regexText = regexText.Substring (1' regexText.Length - 2);  			filterNode = new RegExp (regexText);  		}  		break;  	case 6:  		DebugEnterAlt (6);  		// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  		{  			DebugLocation (128' 4);  			NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  			DebugLocation (129' 4);  			filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  		}  		break;  	case 7:  		DebugEnterAlt (7);  		// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  		{  			DebugLocation (132' 4);  			Match (input' TRUE' Follow._TRUE_in_filterExpr271);  			DebugLocation (133' 4);  			filterNode = new Value (true);  		}  		break;  	case 8:  		DebugEnterAlt (8);  		// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  		{  			DebugLocation (136' 4);  			Match (input' FALSE' Follow._FALSE_in_filterExpr281);  			DebugLocation (137' 4);  			filterNode = new Value (false);  		}  		break;  	case 9:  		DebugEnterAlt (9);  		// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  		{  			DebugLocation (140' 4);  			Match (input' NULL' Follow._NULL_in_filterExpr291);  			DebugLocation (141' 4);  			filterNode = new Value (null);  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("filterExpr"' 6);  	LeaveRule ("filterExpr"' 6);  	LeaveRule_filterExpr ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  	int alt9 = 9;  	try {  		DebugEnterDecision (9' false);  		switch (input.LA (1)) {  		case CHAIN_OPERATOR:  		case COMPARATOR:  			{  				alt9 = 1;  			}  			break;  		case EXPR:  			{  				int LA9_2 = input.LA (2);  				if ((LA9_2 == DOWN)) {  					int LA9_3 = input.LA (3);  					if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  						alt9 = 2;  					}  					else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  						alt9 = 3;  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				else {  					NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  					DebugRecognitionException (nvae);  					throw nvae;  				}  			}  			break;  		case STRING:  			{  				alt9 = 4;  			}  			break;  		case REGEX:  			{  				alt9 = 5;  			}  			break;  		case NUMBER:  			{  				alt9 = 6;  			}  			break;  		case TRUE:  			{  				alt9 = 7;  			}  			break;  		case FALSE:  			{  				alt9 = 8;  			}  			break;  		case NULL:  			{  				alt9 = 9;  			}  			break;  		default: {  			NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  		}  	}  	finally {  		DebugExitDecision (9);  	}  	switch (alt9) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  		{  			DebugLocation (64' 4);  			DebugLocation (64' 6);  			PushFollow (Follow._comparator_in_filterExpr175);  			comparator6 = comparator ();  			PopFollow ();  			Match (input' TokenTypes.Down' null);  			DebugLocation (64' 18);  			PushFollow (Follow._filterExpr_in_filterExpr179);  			a = filterExpr ();  			PopFollow ();  			DebugLocation (64' 31);  			PushFollow (Follow._filterExpr_in_filterExpr183);  			b = filterExpr ();  			PopFollow ();  			Match (input' TokenTypes.Up' null);  			DebugLocation (65' 4);  			Comparator newComparator;  			switch (comparator6) {  			case "=":  				newComparator = Comparator.Equals;  				break;  			case "!=":  				newComparator = Comparator.NotEquals;  				break;  			case ">":  				newComparator = Comparator.Greater;  				break;  			case "<":  				newComparator = Comparator.Less;  				break;  			case ">=":  				newComparator = Comparator.GreaterOrEqual;  				break;  			case "<=":  				newComparator = Comparator.LessOrEqual;  				break;  			case "&":  				newComparator = Comparator.And;  				break;  			case "|":  				newComparator = Comparator.Or;  				break;  			default:  				newComparator = Comparator.Equals;  				break;  			}  			filterNode = new BoolExpression (a' newComparator' b);  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  		{  			DebugLocation (98' 4);  			DebugLocation (98' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr195);  			Match (input' TokenTypes.Down' null);  			DebugLocation (98' 12);  			PushFollow (Follow._filterExpr_in_filterExpr199);  			f = filterExpr ();  			PopFollow ();  			DebugLocation (98' 31);  			// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  			int alt6 = 2;  			try {  				DebugEnterSubRule (6);  				try {  					DebugEnterDecision (6' false);  					int LA6_1 = input.LA (1);  					if ((LA6_1 == 24)) {  						alt6 = 1;  					}  				}  				finally {  					DebugExitDecision (6);  				}  				switch (alt6) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  					{  						DebugLocation (98' 31);  						inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (6);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (99' 4);  			FilterTreeNode newNode = f;  			if ((inverse != null ? inverse.Text : default(string)) == "!")  				newNode.ToggleInversed ();  			filterNode = newNode;  		}  		break;  	case 3:  		DebugEnterAlt (3);  		// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  		{  			DebugLocation (105' 4);  			DebugLocation (105' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr216);  			Match (input' TokenTypes.Down' null);  			DebugLocation (105' 12);  			PushFollow (Follow._propertyChain_in_filterExpr219);  			propertyChain (propertySegments);  			PopFollow ();  			DebugLocation (105' 51);  			// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  			int alt7 = 2;  			try {  				DebugEnterSubRule (7);  				try {  					DebugEnterDecision (7' false);  					int LA7_1 = input.LA (1);  					if ((LA7_1 == 31)) {  						alt7 = 1;  					}  				}  				finally {  					DebugExitDecision (7);  				}  				switch (alt7) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  					{  						DebugLocation (105' 51);  						inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (7);  			}  			DebugLocation (105' 60);  			// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  			int alt8 = 2;  			try {  				DebugEnterSubRule (8);  				try {  					DebugEnterDecision (8' false);  					int LA8_1 = input.LA (1);  					if ((LA8_1 == 24)) {  						alt8 = 1;  					}  				}  				finally {  					DebugExitDecision (8);  				}  				switch (alt8) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  					{  						DebugLocation (105' 60);  						not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (8);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (106' 4);  			FilterTreeNode newProperty = new Property (propertySegments);  			if ((inverse != null ? inverse.Text : default(string)) == "?")  				filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  			else {  				if ((not != null ? not.Text : default(string)) == "!")  					newProperty.ToggleInversed ();  				filterNode = newProperty;  			}  		}  		break;  	case 4:  		DebugEnterAlt (4);  		// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  		{  			DebugLocation (116' 4);  			STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  			DebugLocation (117' 4);  			string stringText = (STRING7 != null ? STRING7.Text : default(string));  			stringText = stringText.Substring (1' stringText.Length - 2);  			filterNode = new Value (stringText);  		}  		break;  	case 5:  		DebugEnterAlt (5);  		// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  		{  			DebugLocation (122' 4);  			REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  			DebugLocation (123' 4);  			string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  			regexText = regexText.Substring (1' regexText.Length - 2);  			filterNode = new RegExp (regexText);  		}  		break;  	case 6:  		DebugEnterAlt (6);  		// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  		{  			DebugLocation (128' 4);  			NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  			DebugLocation (129' 4);  			filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  		}  		break;  	case 7:  		DebugEnterAlt (7);  		// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  		{  			DebugLocation (132' 4);  			Match (input' TRUE' Follow._TRUE_in_filterExpr271);  			DebugLocation (133' 4);  			filterNode = new Value (true);  		}  		break;  	case 8:  		DebugEnterAlt (8);  		// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  		{  			DebugLocation (136' 4);  			Match (input' FALSE' Follow._FALSE_in_filterExpr281);  			DebugLocation (137' 4);  			filterNode = new Value (false);  		}  		break;  	case 9:  		DebugEnterAlt (9);  		// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  		{  			DebugLocation (140' 4);  			Match (input' NULL' Follow._NULL_in_filterExpr291);  			DebugLocation (141' 4);  			filterNode = new Value (null);  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("filterExpr"' 6);  	LeaveRule ("filterExpr"' 6);  	LeaveRule_filterExpr ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  	int alt9 = 9;  	try {  		DebugEnterDecision (9' false);  		switch (input.LA (1)) {  		case CHAIN_OPERATOR:  		case COMPARATOR:  			{  				alt9 = 1;  			}  			break;  		case EXPR:  			{  				int LA9_2 = input.LA (2);  				if ((LA9_2 == DOWN)) {  					int LA9_3 = input.LA (3);  					if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  						alt9 = 2;  					}  					else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  						alt9 = 3;  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				else {  					NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  					DebugRecognitionException (nvae);  					throw nvae;  				}  			}  			break;  		case STRING:  			{  				alt9 = 4;  			}  			break;  		case REGEX:  			{  				alt9 = 5;  			}  			break;  		case NUMBER:  			{  				alt9 = 6;  			}  			break;  		case TRUE:  			{  				alt9 = 7;  			}  			break;  		case FALSE:  			{  				alt9 = 8;  			}  			break;  		case NULL:  			{  				alt9 = 9;  			}  			break;  		default: {  			NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  		}  	}  	finally {  		DebugExitDecision (9);  	}  	switch (alt9) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  		{  			DebugLocation (64' 4);  			DebugLocation (64' 6);  			PushFollow (Follow._comparator_in_filterExpr175);  			comparator6 = comparator ();  			PopFollow ();  			Match (input' TokenTypes.Down' null);  			DebugLocation (64' 18);  			PushFollow (Follow._filterExpr_in_filterExpr179);  			a = filterExpr ();  			PopFollow ();  			DebugLocation (64' 31);  			PushFollow (Follow._filterExpr_in_filterExpr183);  			b = filterExpr ();  			PopFollow ();  			Match (input' TokenTypes.Up' null);  			DebugLocation (65' 4);  			Comparator newComparator;  			switch (comparator6) {  			case "=":  				newComparator = Comparator.Equals;  				break;  			case "!=":  				newComparator = Comparator.NotEquals;  				break;  			case ">":  				newComparator = Comparator.Greater;  				break;  			case "<":  				newComparator = Comparator.Less;  				break;  			case ">=":  				newComparator = Comparator.GreaterOrEqual;  				break;  			case "<=":  				newComparator = Comparator.LessOrEqual;  				break;  			case "&":  				newComparator = Comparator.And;  				break;  			case "|":  				newComparator = Comparator.Or;  				break;  			default:  				newComparator = Comparator.Equals;  				break;  			}  			filterNode = new BoolExpression (a' newComparator' b);  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  		{  			DebugLocation (98' 4);  			DebugLocation (98' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr195);  			Match (input' TokenTypes.Down' null);  			DebugLocation (98' 12);  			PushFollow (Follow._filterExpr_in_filterExpr199);  			f = filterExpr ();  			PopFollow ();  			DebugLocation (98' 31);  			// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  			int alt6 = 2;  			try {  				DebugEnterSubRule (6);  				try {  					DebugEnterDecision (6' false);  					int LA6_1 = input.LA (1);  					if ((LA6_1 == 24)) {  						alt6 = 1;  					}  				}  				finally {  					DebugExitDecision (6);  				}  				switch (alt6) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  					{  						DebugLocation (98' 31);  						inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (6);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (99' 4);  			FilterTreeNode newNode = f;  			if ((inverse != null ? inverse.Text : default(string)) == "!")  				newNode.ToggleInversed ();  			filterNode = newNode;  		}  		break;  	case 3:  		DebugEnterAlt (3);  		// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  		{  			DebugLocation (105' 4);  			DebugLocation (105' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr216);  			Match (input' TokenTypes.Down' null);  			DebugLocation (105' 12);  			PushFollow (Follow._propertyChain_in_filterExpr219);  			propertyChain (propertySegments);  			PopFollow ();  			DebugLocation (105' 51);  			// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  			int alt7 = 2;  			try {  				DebugEnterSubRule (7);  				try {  					DebugEnterDecision (7' false);  					int LA7_1 = input.LA (1);  					if ((LA7_1 == 31)) {  						alt7 = 1;  					}  				}  				finally {  					DebugExitDecision (7);  				}  				switch (alt7) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  					{  						DebugLocation (105' 51);  						inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (7);  			}  			DebugLocation (105' 60);  			// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  			int alt8 = 2;  			try {  				DebugEnterSubRule (8);  				try {  					DebugEnterDecision (8' false);  					int LA8_1 = input.LA (1);  					if ((LA8_1 == 24)) {  						alt8 = 1;  					}  				}  				finally {  					DebugExitDecision (8);  				}  				switch (alt8) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  					{  						DebugLocation (105' 60);  						not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (8);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (106' 4);  			FilterTreeNode newProperty = new Property (propertySegments);  			if ((inverse != null ? inverse.Text : default(string)) == "?")  				filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  			else {  				if ((not != null ? not.Text : default(string)) == "!")  					newProperty.ToggleInversed ();  				filterNode = newProperty;  			}  		}  		break;  	case 4:  		DebugEnterAlt (4);  		// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  		{  			DebugLocation (116' 4);  			STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  			DebugLocation (117' 4);  			string stringText = (STRING7 != null ? STRING7.Text : default(string));  			stringText = stringText.Substring (1' stringText.Length - 2);  			filterNode = new Value (stringText);  		}  		break;  	case 5:  		DebugEnterAlt (5);  		// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  		{  			DebugLocation (122' 4);  			REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  			DebugLocation (123' 4);  			string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  			regexText = regexText.Substring (1' regexText.Length - 2);  			filterNode = new RegExp (regexText);  		}  		break;  	case 6:  		DebugEnterAlt (6);  		// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  		{  			DebugLocation (128' 4);  			NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  			DebugLocation (129' 4);  			filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  		}  		break;  	case 7:  		DebugEnterAlt (7);  		// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  		{  			DebugLocation (132' 4);  			Match (input' TRUE' Follow._TRUE_in_filterExpr271);  			DebugLocation (133' 4);  			filterNode = new Value (true);  		}  		break;  	case 8:  		DebugEnterAlt (8);  		// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  		{  			DebugLocation (136' 4);  			Match (input' FALSE' Follow._FALSE_in_filterExpr281);  			DebugLocation (137' 4);  			filterNode = new Value (false);  		}  		break;  	case 9:  		DebugEnterAlt (9);  		// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  		{  			DebugLocation (140' 4);  			Match (input' NULL' Follow._NULL_in_filterExpr291);  			DebugLocation (141' 4);  			filterNode = new Value (null);  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("filterExpr"' 6);  	LeaveRule ("filterExpr"' 6);  	LeaveRule_filterExpr ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  	int alt9 = 9;  	try {  		DebugEnterDecision (9' false);  		switch (input.LA (1)) {  		case CHAIN_OPERATOR:  		case COMPARATOR:  			{  				alt9 = 1;  			}  			break;  		case EXPR:  			{  				int LA9_2 = input.LA (2);  				if ((LA9_2 == DOWN)) {  					int LA9_3 = input.LA (3);  					if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  						alt9 = 2;  					}  					else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  						alt9 = 3;  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				else {  					NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  					DebugRecognitionException (nvae);  					throw nvae;  				}  			}  			break;  		case STRING:  			{  				alt9 = 4;  			}  			break;  		case REGEX:  			{  				alt9 = 5;  			}  			break;  		case NUMBER:  			{  				alt9 = 6;  			}  			break;  		case TRUE:  			{  				alt9 = 7;  			}  			break;  		case FALSE:  			{  				alt9 = 8;  			}  			break;  		case NULL:  			{  				alt9 = 9;  			}  			break;  		default: {  			NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  		}  	}  	finally {  		DebugExitDecision (9);  	}  	switch (alt9) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  		{  			DebugLocation (64' 4);  			DebugLocation (64' 6);  			PushFollow (Follow._comparator_in_filterExpr175);  			comparator6 = comparator ();  			PopFollow ();  			Match (input' TokenTypes.Down' null);  			DebugLocation (64' 18);  			PushFollow (Follow._filterExpr_in_filterExpr179);  			a = filterExpr ();  			PopFollow ();  			DebugLocation (64' 31);  			PushFollow (Follow._filterExpr_in_filterExpr183);  			b = filterExpr ();  			PopFollow ();  			Match (input' TokenTypes.Up' null);  			DebugLocation (65' 4);  			Comparator newComparator;  			switch (comparator6) {  			case "=":  				newComparator = Comparator.Equals;  				break;  			case "!=":  				newComparator = Comparator.NotEquals;  				break;  			case ">":  				newComparator = Comparator.Greater;  				break;  			case "<":  				newComparator = Comparator.Less;  				break;  			case ">=":  				newComparator = Comparator.GreaterOrEqual;  				break;  			case "<=":  				newComparator = Comparator.LessOrEqual;  				break;  			case "&":  				newComparator = Comparator.And;  				break;  			case "|":  				newComparator = Comparator.Or;  				break;  			default:  				newComparator = Comparator.Equals;  				break;  			}  			filterNode = new BoolExpression (a' newComparator' b);  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  		{  			DebugLocation (98' 4);  			DebugLocation (98' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr195);  			Match (input' TokenTypes.Down' null);  			DebugLocation (98' 12);  			PushFollow (Follow._filterExpr_in_filterExpr199);  			f = filterExpr ();  			PopFollow ();  			DebugLocation (98' 31);  			// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  			int alt6 = 2;  			try {  				DebugEnterSubRule (6);  				try {  					DebugEnterDecision (6' false);  					int LA6_1 = input.LA (1);  					if ((LA6_1 == 24)) {  						alt6 = 1;  					}  				}  				finally {  					DebugExitDecision (6);  				}  				switch (alt6) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  					{  						DebugLocation (98' 31);  						inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (6);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (99' 4);  			FilterTreeNode newNode = f;  			if ((inverse != null ? inverse.Text : default(string)) == "!")  				newNode.ToggleInversed ();  			filterNode = newNode;  		}  		break;  	case 3:  		DebugEnterAlt (3);  		// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  		{  			DebugLocation (105' 4);  			DebugLocation (105' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr216);  			Match (input' TokenTypes.Down' null);  			DebugLocation (105' 12);  			PushFollow (Follow._propertyChain_in_filterExpr219);  			propertyChain (propertySegments);  			PopFollow ();  			DebugLocation (105' 51);  			// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  			int alt7 = 2;  			try {  				DebugEnterSubRule (7);  				try {  					DebugEnterDecision (7' false);  					int LA7_1 = input.LA (1);  					if ((LA7_1 == 31)) {  						alt7 = 1;  					}  				}  				finally {  					DebugExitDecision (7);  				}  				switch (alt7) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  					{  						DebugLocation (105' 51);  						inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (7);  			}  			DebugLocation (105' 60);  			// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  			int alt8 = 2;  			try {  				DebugEnterSubRule (8);  				try {  					DebugEnterDecision (8' false);  					int LA8_1 = input.LA (1);  					if ((LA8_1 == 24)) {  						alt8 = 1;  					}  				}  				finally {  					DebugExitDecision (8);  				}  				switch (alt8) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  					{  						DebugLocation (105' 60);  						not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (8);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (106' 4);  			FilterTreeNode newProperty = new Property (propertySegments);  			if ((inverse != null ? inverse.Text : default(string)) == "?")  				filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  			else {  				if ((not != null ? not.Text : default(string)) == "!")  					newProperty.ToggleInversed ();  				filterNode = newProperty;  			}  		}  		break;  	case 4:  		DebugEnterAlt (4);  		// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  		{  			DebugLocation (116' 4);  			STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  			DebugLocation (117' 4);  			string stringText = (STRING7 != null ? STRING7.Text : default(string));  			stringText = stringText.Substring (1' stringText.Length - 2);  			filterNode = new Value (stringText);  		}  		break;  	case 5:  		DebugEnterAlt (5);  		// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  		{  			DebugLocation (122' 4);  			REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  			DebugLocation (123' 4);  			string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  			regexText = regexText.Substring (1' regexText.Length - 2);  			filterNode = new RegExp (regexText);  		}  		break;  	case 6:  		DebugEnterAlt (6);  		// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  		{  			DebugLocation (128' 4);  			NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  			DebugLocation (129' 4);  			filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  		}  		break;  	case 7:  		DebugEnterAlt (7);  		// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  		{  			DebugLocation (132' 4);  			Match (input' TRUE' Follow._TRUE_in_filterExpr271);  			DebugLocation (133' 4);  			filterNode = new Value (true);  		}  		break;  	case 8:  		DebugEnterAlt (8);  		// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  		{  			DebugLocation (136' 4);  			Match (input' FALSE' Follow._FALSE_in_filterExpr281);  			DebugLocation (137' 4);  			filterNode = new Value (false);  		}  		break;  	case 9:  		DebugEnterAlt (9);  		// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  		{  			DebugLocation (140' 4);  			Match (input' NULL' Follow._NULL_in_filterExpr291);  			DebugLocation (141' 4);  			filterNode = new Value (null);  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("filterExpr"' 6);  	LeaveRule ("filterExpr"' 6);  	LeaveRule_filterExpr ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  	int alt9 = 9;  	try {  		DebugEnterDecision (9' false);  		switch (input.LA (1)) {  		case CHAIN_OPERATOR:  		case COMPARATOR:  			{  				alt9 = 1;  			}  			break;  		case EXPR:  			{  				int LA9_2 = input.LA (2);  				if ((LA9_2 == DOWN)) {  					int LA9_3 = input.LA (3);  					if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  						alt9 = 2;  					}  					else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  						alt9 = 3;  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				else {  					NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  					DebugRecognitionException (nvae);  					throw nvae;  				}  			}  			break;  		case STRING:  			{  				alt9 = 4;  			}  			break;  		case REGEX:  			{  				alt9 = 5;  			}  			break;  		case NUMBER:  			{  				alt9 = 6;  			}  			break;  		case TRUE:  			{  				alt9 = 7;  			}  			break;  		case FALSE:  			{  				alt9 = 8;  			}  			break;  		case NULL:  			{  				alt9 = 9;  			}  			break;  		default: {  			NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  		}  	}  	finally {  		DebugExitDecision (9);  	}  	switch (alt9) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  		{  			DebugLocation (64' 4);  			DebugLocation (64' 6);  			PushFollow (Follow._comparator_in_filterExpr175);  			comparator6 = comparator ();  			PopFollow ();  			Match (input' TokenTypes.Down' null);  			DebugLocation (64' 18);  			PushFollow (Follow._filterExpr_in_filterExpr179);  			a = filterExpr ();  			PopFollow ();  			DebugLocation (64' 31);  			PushFollow (Follow._filterExpr_in_filterExpr183);  			b = filterExpr ();  			PopFollow ();  			Match (input' TokenTypes.Up' null);  			DebugLocation (65' 4);  			Comparator newComparator;  			switch (comparator6) {  			case "=":  				newComparator = Comparator.Equals;  				break;  			case "!=":  				newComparator = Comparator.NotEquals;  				break;  			case ">":  				newComparator = Comparator.Greater;  				break;  			case "<":  				newComparator = Comparator.Less;  				break;  			case ">=":  				newComparator = Comparator.GreaterOrEqual;  				break;  			case "<=":  				newComparator = Comparator.LessOrEqual;  				break;  			case "&":  				newComparator = Comparator.And;  				break;  			case "|":  				newComparator = Comparator.Or;  				break;  			default:  				newComparator = Comparator.Equals;  				break;  			}  			filterNode = new BoolExpression (a' newComparator' b);  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  		{  			DebugLocation (98' 4);  			DebugLocation (98' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr195);  			Match (input' TokenTypes.Down' null);  			DebugLocation (98' 12);  			PushFollow (Follow._filterExpr_in_filterExpr199);  			f = filterExpr ();  			PopFollow ();  			DebugLocation (98' 31);  			// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  			int alt6 = 2;  			try {  				DebugEnterSubRule (6);  				try {  					DebugEnterDecision (6' false);  					int LA6_1 = input.LA (1);  					if ((LA6_1 == 24)) {  						alt6 = 1;  					}  				}  				finally {  					DebugExitDecision (6);  				}  				switch (alt6) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  					{  						DebugLocation (98' 31);  						inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (6);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (99' 4);  			FilterTreeNode newNode = f;  			if ((inverse != null ? inverse.Text : default(string)) == "!")  				newNode.ToggleInversed ();  			filterNode = newNode;  		}  		break;  	case 3:  		DebugEnterAlt (3);  		// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  		{  			DebugLocation (105' 4);  			DebugLocation (105' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr216);  			Match (input' TokenTypes.Down' null);  			DebugLocation (105' 12);  			PushFollow (Follow._propertyChain_in_filterExpr219);  			propertyChain (propertySegments);  			PopFollow ();  			DebugLocation (105' 51);  			// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  			int alt7 = 2;  			try {  				DebugEnterSubRule (7);  				try {  					DebugEnterDecision (7' false);  					int LA7_1 = input.LA (1);  					if ((LA7_1 == 31)) {  						alt7 = 1;  					}  				}  				finally {  					DebugExitDecision (7);  				}  				switch (alt7) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  					{  						DebugLocation (105' 51);  						inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (7);  			}  			DebugLocation (105' 60);  			// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  			int alt8 = 2;  			try {  				DebugEnterSubRule (8);  				try {  					DebugEnterDecision (8' false);  					int LA8_1 = input.LA (1);  					if ((LA8_1 == 24)) {  						alt8 = 1;  					}  				}  				finally {  					DebugExitDecision (8);  				}  				switch (alt8) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  					{  						DebugLocation (105' 60);  						not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (8);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (106' 4);  			FilterTreeNode newProperty = new Property (propertySegments);  			if ((inverse != null ? inverse.Text : default(string)) == "?")  				filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  			else {  				if ((not != null ? not.Text : default(string)) == "!")  					newProperty.ToggleInversed ();  				filterNode = newProperty;  			}  		}  		break;  	case 4:  		DebugEnterAlt (4);  		// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  		{  			DebugLocation (116' 4);  			STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  			DebugLocation (117' 4);  			string stringText = (STRING7 != null ? STRING7.Text : default(string));  			stringText = stringText.Substring (1' stringText.Length - 2);  			filterNode = new Value (stringText);  		}  		break;  	case 5:  		DebugEnterAlt (5);  		// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  		{  			DebugLocation (122' 4);  			REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  			DebugLocation (123' 4);  			string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  			regexText = regexText.Substring (1' regexText.Length - 2);  			filterNode = new RegExp (regexText);  		}  		break;  	case 6:  		DebugEnterAlt (6);  		// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  		{  			DebugLocation (128' 4);  			NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  			DebugLocation (129' 4);  			filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  		}  		break;  	case 7:  		DebugEnterAlt (7);  		// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  		{  			DebugLocation (132' 4);  			Match (input' TRUE' Follow._TRUE_in_filterExpr271);  			DebugLocation (133' 4);  			filterNode = new Value (true);  		}  		break;  	case 8:  		DebugEnterAlt (8);  		// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  		{  			DebugLocation (136' 4);  			Match (input' FALSE' Follow._FALSE_in_filterExpr281);  			DebugLocation (137' 4);  			filterNode = new Value (false);  		}  		break;  	case 9:  		DebugEnterAlt (9);  		// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  		{  			DebugLocation (140' 4);  			Match (input' NULL' Follow._NULL_in_filterExpr291);  			DebugLocation (141' 4);  			filterNode = new Value (null);  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("filterExpr"' 6);  	LeaveRule ("filterExpr"' 6);  	LeaveRule_filterExpr ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  	int alt9 = 9;  	try {  		DebugEnterDecision (9' false);  		switch (input.LA (1)) {  		case CHAIN_OPERATOR:  		case COMPARATOR:  			{  				alt9 = 1;  			}  			break;  		case EXPR:  			{  				int LA9_2 = input.LA (2);  				if ((LA9_2 == DOWN)) {  					int LA9_3 = input.LA (3);  					if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  						alt9 = 2;  					}  					else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  						alt9 = 3;  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				else {  					NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  					DebugRecognitionException (nvae);  					throw nvae;  				}  			}  			break;  		case STRING:  			{  				alt9 = 4;  			}  			break;  		case REGEX:  			{  				alt9 = 5;  			}  			break;  		case NUMBER:  			{  				alt9 = 6;  			}  			break;  		case TRUE:  			{  				alt9 = 7;  			}  			break;  		case FALSE:  			{  				alt9 = 8;  			}  			break;  		case NULL:  			{  				alt9 = 9;  			}  			break;  		default: {  			NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  		}  	}  	finally {  		DebugExitDecision (9);  	}  	switch (alt9) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  		{  			DebugLocation (64' 4);  			DebugLocation (64' 6);  			PushFollow (Follow._comparator_in_filterExpr175);  			comparator6 = comparator ();  			PopFollow ();  			Match (input' TokenTypes.Down' null);  			DebugLocation (64' 18);  			PushFollow (Follow._filterExpr_in_filterExpr179);  			a = filterExpr ();  			PopFollow ();  			DebugLocation (64' 31);  			PushFollow (Follow._filterExpr_in_filterExpr183);  			b = filterExpr ();  			PopFollow ();  			Match (input' TokenTypes.Up' null);  			DebugLocation (65' 4);  			Comparator newComparator;  			switch (comparator6) {  			case "=":  				newComparator = Comparator.Equals;  				break;  			case "!=":  				newComparator = Comparator.NotEquals;  				break;  			case ">":  				newComparator = Comparator.Greater;  				break;  			case "<":  				newComparator = Comparator.Less;  				break;  			case ">=":  				newComparator = Comparator.GreaterOrEqual;  				break;  			case "<=":  				newComparator = Comparator.LessOrEqual;  				break;  			case "&":  				newComparator = Comparator.And;  				break;  			case "|":  				newComparator = Comparator.Or;  				break;  			default:  				newComparator = Comparator.Equals;  				break;  			}  			filterNode = new BoolExpression (a' newComparator' b);  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  		{  			DebugLocation (98' 4);  			DebugLocation (98' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr195);  			Match (input' TokenTypes.Down' null);  			DebugLocation (98' 12);  			PushFollow (Follow._filterExpr_in_filterExpr199);  			f = filterExpr ();  			PopFollow ();  			DebugLocation (98' 31);  			// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  			int alt6 = 2;  			try {  				DebugEnterSubRule (6);  				try {  					DebugEnterDecision (6' false);  					int LA6_1 = input.LA (1);  					if ((LA6_1 == 24)) {  						alt6 = 1;  					}  				}  				finally {  					DebugExitDecision (6);  				}  				switch (alt6) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  					{  						DebugLocation (98' 31);  						inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (6);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (99' 4);  			FilterTreeNode newNode = f;  			if ((inverse != null ? inverse.Text : default(string)) == "!")  				newNode.ToggleInversed ();  			filterNode = newNode;  		}  		break;  	case 3:  		DebugEnterAlt (3);  		// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  		{  			DebugLocation (105' 4);  			DebugLocation (105' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr216);  			Match (input' TokenTypes.Down' null);  			DebugLocation (105' 12);  			PushFollow (Follow._propertyChain_in_filterExpr219);  			propertyChain (propertySegments);  			PopFollow ();  			DebugLocation (105' 51);  			// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  			int alt7 = 2;  			try {  				DebugEnterSubRule (7);  				try {  					DebugEnterDecision (7' false);  					int LA7_1 = input.LA (1);  					if ((LA7_1 == 31)) {  						alt7 = 1;  					}  				}  				finally {  					DebugExitDecision (7);  				}  				switch (alt7) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  					{  						DebugLocation (105' 51);  						inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (7);  			}  			DebugLocation (105' 60);  			// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  			int alt8 = 2;  			try {  				DebugEnterSubRule (8);  				try {  					DebugEnterDecision (8' false);  					int LA8_1 = input.LA (1);  					if ((LA8_1 == 24)) {  						alt8 = 1;  					}  				}  				finally {  					DebugExitDecision (8);  				}  				switch (alt8) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  					{  						DebugLocation (105' 60);  						not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (8);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (106' 4);  			FilterTreeNode newProperty = new Property (propertySegments);  			if ((inverse != null ? inverse.Text : default(string)) == "?")  				filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  			else {  				if ((not != null ? not.Text : default(string)) == "!")  					newProperty.ToggleInversed ();  				filterNode = newProperty;  			}  		}  		break;  	case 4:  		DebugEnterAlt (4);  		// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  		{  			DebugLocation (116' 4);  			STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  			DebugLocation (117' 4);  			string stringText = (STRING7 != null ? STRING7.Text : default(string));  			stringText = stringText.Substring (1' stringText.Length - 2);  			filterNode = new Value (stringText);  		}  		break;  	case 5:  		DebugEnterAlt (5);  		// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  		{  			DebugLocation (122' 4);  			REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  			DebugLocation (123' 4);  			string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  			regexText = regexText.Substring (1' regexText.Length - 2);  			filterNode = new RegExp (regexText);  		}  		break;  	case 6:  		DebugEnterAlt (6);  		// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  		{  			DebugLocation (128' 4);  			NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  			DebugLocation (129' 4);  			filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  		}  		break;  	case 7:  		DebugEnterAlt (7);  		// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  		{  			DebugLocation (132' 4);  			Match (input' TRUE' Follow._TRUE_in_filterExpr271);  			DebugLocation (133' 4);  			filterNode = new Value (true);  		}  		break;  	case 8:  		DebugEnterAlt (8);  		// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  		{  			DebugLocation (136' 4);  			Match (input' FALSE' Follow._FALSE_in_filterExpr281);  			DebugLocation (137' 4);  			filterNode = new Value (false);  		}  		break;  	case 9:  		DebugEnterAlt (9);  		// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  		{  			DebugLocation (140' 4);  			Match (input' NULL' Follow._NULL_in_filterExpr291);  			DebugLocation (141' 4);  			filterNode = new Value (null);  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("filterExpr"' 6);  	LeaveRule ("filterExpr"' 6);  	LeaveRule_filterExpr ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  	int alt9 = 9;  	try {  		DebugEnterDecision (9' false);  		switch (input.LA (1)) {  		case CHAIN_OPERATOR:  		case COMPARATOR:  			{  				alt9 = 1;  			}  			break;  		case EXPR:  			{  				int LA9_2 = input.LA (2);  				if ((LA9_2 == DOWN)) {  					int LA9_3 = input.LA (3);  					if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  						alt9 = 2;  					}  					else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  						alt9 = 3;  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				else {  					NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  					DebugRecognitionException (nvae);  					throw nvae;  				}  			}  			break;  		case STRING:  			{  				alt9 = 4;  			}  			break;  		case REGEX:  			{  				alt9 = 5;  			}  			break;  		case NUMBER:  			{  				alt9 = 6;  			}  			break;  		case TRUE:  			{  				alt9 = 7;  			}  			break;  		case FALSE:  			{  				alt9 = 8;  			}  			break;  		case NULL:  			{  				alt9 = 9;  			}  			break;  		default: {  			NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  		}  	}  	finally {  		DebugExitDecision (9);  	}  	switch (alt9) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  		{  			DebugLocation (64' 4);  			DebugLocation (64' 6);  			PushFollow (Follow._comparator_in_filterExpr175);  			comparator6 = comparator ();  			PopFollow ();  			Match (input' TokenTypes.Down' null);  			DebugLocation (64' 18);  			PushFollow (Follow._filterExpr_in_filterExpr179);  			a = filterExpr ();  			PopFollow ();  			DebugLocation (64' 31);  			PushFollow (Follow._filterExpr_in_filterExpr183);  			b = filterExpr ();  			PopFollow ();  			Match (input' TokenTypes.Up' null);  			DebugLocation (65' 4);  			Comparator newComparator;  			switch (comparator6) {  			case "=":  				newComparator = Comparator.Equals;  				break;  			case "!=":  				newComparator = Comparator.NotEquals;  				break;  			case ">":  				newComparator = Comparator.Greater;  				break;  			case "<":  				newComparator = Comparator.Less;  				break;  			case ">=":  				newComparator = Comparator.GreaterOrEqual;  				break;  			case "<=":  				newComparator = Comparator.LessOrEqual;  				break;  			case "&":  				newComparator = Comparator.And;  				break;  			case "|":  				newComparator = Comparator.Or;  				break;  			default:  				newComparator = Comparator.Equals;  				break;  			}  			filterNode = new BoolExpression (a' newComparator' b);  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  		{  			DebugLocation (98' 4);  			DebugLocation (98' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr195);  			Match (input' TokenTypes.Down' null);  			DebugLocation (98' 12);  			PushFollow (Follow._filterExpr_in_filterExpr199);  			f = filterExpr ();  			PopFollow ();  			DebugLocation (98' 31);  			// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  			int alt6 = 2;  			try {  				DebugEnterSubRule (6);  				try {  					DebugEnterDecision (6' false);  					int LA6_1 = input.LA (1);  					if ((LA6_1 == 24)) {  						alt6 = 1;  					}  				}  				finally {  					DebugExitDecision (6);  				}  				switch (alt6) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  					{  						DebugLocation (98' 31);  						inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (6);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (99' 4);  			FilterTreeNode newNode = f;  			if ((inverse != null ? inverse.Text : default(string)) == "!")  				newNode.ToggleInversed ();  			filterNode = newNode;  		}  		break;  	case 3:  		DebugEnterAlt (3);  		// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  		{  			DebugLocation (105' 4);  			DebugLocation (105' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr216);  			Match (input' TokenTypes.Down' null);  			DebugLocation (105' 12);  			PushFollow (Follow._propertyChain_in_filterExpr219);  			propertyChain (propertySegments);  			PopFollow ();  			DebugLocation (105' 51);  			// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  			int alt7 = 2;  			try {  				DebugEnterSubRule (7);  				try {  					DebugEnterDecision (7' false);  					int LA7_1 = input.LA (1);  					if ((LA7_1 == 31)) {  						alt7 = 1;  					}  				}  				finally {  					DebugExitDecision (7);  				}  				switch (alt7) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  					{  						DebugLocation (105' 51);  						inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (7);  			}  			DebugLocation (105' 60);  			// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  			int alt8 = 2;  			try {  				DebugEnterSubRule (8);  				try {  					DebugEnterDecision (8' false);  					int LA8_1 = input.LA (1);  					if ((LA8_1 == 24)) {  						alt8 = 1;  					}  				}  				finally {  					DebugExitDecision (8);  				}  				switch (alt8) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  					{  						DebugLocation (105' 60);  						not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (8);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (106' 4);  			FilterTreeNode newProperty = new Property (propertySegments);  			if ((inverse != null ? inverse.Text : default(string)) == "?")  				filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  			else {  				if ((not != null ? not.Text : default(string)) == "!")  					newProperty.ToggleInversed ();  				filterNode = newProperty;  			}  		}  		break;  	case 4:  		DebugEnterAlt (4);  		// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  		{  			DebugLocation (116' 4);  			STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  			DebugLocation (117' 4);  			string stringText = (STRING7 != null ? STRING7.Text : default(string));  			stringText = stringText.Substring (1' stringText.Length - 2);  			filterNode = new Value (stringText);  		}  		break;  	case 5:  		DebugEnterAlt (5);  		// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  		{  			DebugLocation (122' 4);  			REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  			DebugLocation (123' 4);  			string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  			regexText = regexText.Substring (1' regexText.Length - 2);  			filterNode = new RegExp (regexText);  		}  		break;  	case 6:  		DebugEnterAlt (6);  		// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  		{  			DebugLocation (128' 4);  			NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  			DebugLocation (129' 4);  			filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  		}  		break;  	case 7:  		DebugEnterAlt (7);  		// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  		{  			DebugLocation (132' 4);  			Match (input' TRUE' Follow._TRUE_in_filterExpr271);  			DebugLocation (133' 4);  			filterNode = new Value (true);  		}  		break;  	case 8:  		DebugEnterAlt (8);  		// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  		{  			DebugLocation (136' 4);  			Match (input' FALSE' Follow._FALSE_in_filterExpr281);  			DebugLocation (137' 4);  			filterNode = new Value (false);  		}  		break;  	case 9:  		DebugEnterAlt (9);  		// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  		{  			DebugLocation (140' 4);  			Match (input' NULL' Follow._NULL_in_filterExpr291);  			DebugLocation (141' 4);  			filterNode = new Value (null);  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("filterExpr"' 6);  	LeaveRule ("filterExpr"' 6);  	LeaveRule_filterExpr ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  	int alt9 = 9;  	try {  		DebugEnterDecision (9' false);  		switch (input.LA (1)) {  		case CHAIN_OPERATOR:  		case COMPARATOR:  			{  				alt9 = 1;  			}  			break;  		case EXPR:  			{  				int LA9_2 = input.LA (2);  				if ((LA9_2 == DOWN)) {  					int LA9_3 = input.LA (3);  					if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  						alt9 = 2;  					}  					else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  						alt9 = 3;  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				else {  					NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  					DebugRecognitionException (nvae);  					throw nvae;  				}  			}  			break;  		case STRING:  			{  				alt9 = 4;  			}  			break;  		case REGEX:  			{  				alt9 = 5;  			}  			break;  		case NUMBER:  			{  				alt9 = 6;  			}  			break;  		case TRUE:  			{  				alt9 = 7;  			}  			break;  		case FALSE:  			{  				alt9 = 8;  			}  			break;  		case NULL:  			{  				alt9 = 9;  			}  			break;  		default: {  			NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  		}  	}  	finally {  		DebugExitDecision (9);  	}  	switch (alt9) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  		{  			DebugLocation (64' 4);  			DebugLocation (64' 6);  			PushFollow (Follow._comparator_in_filterExpr175);  			comparator6 = comparator ();  			PopFollow ();  			Match (input' TokenTypes.Down' null);  			DebugLocation (64' 18);  			PushFollow (Follow._filterExpr_in_filterExpr179);  			a = filterExpr ();  			PopFollow ();  			DebugLocation (64' 31);  			PushFollow (Follow._filterExpr_in_filterExpr183);  			b = filterExpr ();  			PopFollow ();  			Match (input' TokenTypes.Up' null);  			DebugLocation (65' 4);  			Comparator newComparator;  			switch (comparator6) {  			case "=":  				newComparator = Comparator.Equals;  				break;  			case "!=":  				newComparator = Comparator.NotEquals;  				break;  			case ">":  				newComparator = Comparator.Greater;  				break;  			case "<":  				newComparator = Comparator.Less;  				break;  			case ">=":  				newComparator = Comparator.GreaterOrEqual;  				break;  			case "<=":  				newComparator = Comparator.LessOrEqual;  				break;  			case "&":  				newComparator = Comparator.And;  				break;  			case "|":  				newComparator = Comparator.Or;  				break;  			default:  				newComparator = Comparator.Equals;  				break;  			}  			filterNode = new BoolExpression (a' newComparator' b);  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  		{  			DebugLocation (98' 4);  			DebugLocation (98' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr195);  			Match (input' TokenTypes.Down' null);  			DebugLocation (98' 12);  			PushFollow (Follow._filterExpr_in_filterExpr199);  			f = filterExpr ();  			PopFollow ();  			DebugLocation (98' 31);  			// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  			int alt6 = 2;  			try {  				DebugEnterSubRule (6);  				try {  					DebugEnterDecision (6' false);  					int LA6_1 = input.LA (1);  					if ((LA6_1 == 24)) {  						alt6 = 1;  					}  				}  				finally {  					DebugExitDecision (6);  				}  				switch (alt6) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  					{  						DebugLocation (98' 31);  						inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (6);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (99' 4);  			FilterTreeNode newNode = f;  			if ((inverse != null ? inverse.Text : default(string)) == "!")  				newNode.ToggleInversed ();  			filterNode = newNode;  		}  		break;  	case 3:  		DebugEnterAlt (3);  		// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  		{  			DebugLocation (105' 4);  			DebugLocation (105' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr216);  			Match (input' TokenTypes.Down' null);  			DebugLocation (105' 12);  			PushFollow (Follow._propertyChain_in_filterExpr219);  			propertyChain (propertySegments);  			PopFollow ();  			DebugLocation (105' 51);  			// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  			int alt7 = 2;  			try {  				DebugEnterSubRule (7);  				try {  					DebugEnterDecision (7' false);  					int LA7_1 = input.LA (1);  					if ((LA7_1 == 31)) {  						alt7 = 1;  					}  				}  				finally {  					DebugExitDecision (7);  				}  				switch (alt7) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  					{  						DebugLocation (105' 51);  						inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (7);  			}  			DebugLocation (105' 60);  			// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  			int alt8 = 2;  			try {  				DebugEnterSubRule (8);  				try {  					DebugEnterDecision (8' false);  					int LA8_1 = input.LA (1);  					if ((LA8_1 == 24)) {  						alt8 = 1;  					}  				}  				finally {  					DebugExitDecision (8);  				}  				switch (alt8) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  					{  						DebugLocation (105' 60);  						not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (8);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (106' 4);  			FilterTreeNode newProperty = new Property (propertySegments);  			if ((inverse != null ? inverse.Text : default(string)) == "?")  				filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  			else {  				if ((not != null ? not.Text : default(string)) == "!")  					newProperty.ToggleInversed ();  				filterNode = newProperty;  			}  		}  		break;  	case 4:  		DebugEnterAlt (4);  		// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  		{  			DebugLocation (116' 4);  			STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  			DebugLocation (117' 4);  			string stringText = (STRING7 != null ? STRING7.Text : default(string));  			stringText = stringText.Substring (1' stringText.Length - 2);  			filterNode = new Value (stringText);  		}  		break;  	case 5:  		DebugEnterAlt (5);  		// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  		{  			DebugLocation (122' 4);  			REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  			DebugLocation (123' 4);  			string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  			regexText = regexText.Substring (1' regexText.Length - 2);  			filterNode = new RegExp (regexText);  		}  		break;  	case 6:  		DebugEnterAlt (6);  		// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  		{  			DebugLocation (128' 4);  			NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  			DebugLocation (129' 4);  			filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  		}  		break;  	case 7:  		DebugEnterAlt (7);  		// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  		{  			DebugLocation (132' 4);  			Match (input' TRUE' Follow._TRUE_in_filterExpr271);  			DebugLocation (133' 4);  			filterNode = new Value (true);  		}  		break;  	case 8:  		DebugEnterAlt (8);  		// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  		{  			DebugLocation (136' 4);  			Match (input' FALSE' Follow._FALSE_in_filterExpr281);  			DebugLocation (137' 4);  			filterNode = new Value (false);  		}  		break;  	case 9:  		DebugEnterAlt (9);  		// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  		{  			DebugLocation (140' 4);  			Match (input' NULL' Follow._NULL_in_filterExpr291);  			DebugLocation (141' 4);  			filterNode = new Value (null);  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("filterExpr"' 6);  	LeaveRule ("filterExpr"' 6);  	LeaveRule_filterExpr ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  	int alt9 = 9;  	try {  		DebugEnterDecision (9' false);  		switch (input.LA (1)) {  		case CHAIN_OPERATOR:  		case COMPARATOR:  			{  				alt9 = 1;  			}  			break;  		case EXPR:  			{  				int LA9_2 = input.LA (2);  				if ((LA9_2 == DOWN)) {  					int LA9_3 = input.LA (3);  					if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  						alt9 = 2;  					}  					else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  						alt9 = 3;  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				else {  					NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  					DebugRecognitionException (nvae);  					throw nvae;  				}  			}  			break;  		case STRING:  			{  				alt9 = 4;  			}  			break;  		case REGEX:  			{  				alt9 = 5;  			}  			break;  		case NUMBER:  			{  				alt9 = 6;  			}  			break;  		case TRUE:  			{  				alt9 = 7;  			}  			break;  		case FALSE:  			{  				alt9 = 8;  			}  			break;  		case NULL:  			{  				alt9 = 9;  			}  			break;  		default: {  			NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  		}  	}  	finally {  		DebugExitDecision (9);  	}  	switch (alt9) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  		{  			DebugLocation (64' 4);  			DebugLocation (64' 6);  			PushFollow (Follow._comparator_in_filterExpr175);  			comparator6 = comparator ();  			PopFollow ();  			Match (input' TokenTypes.Down' null);  			DebugLocation (64' 18);  			PushFollow (Follow._filterExpr_in_filterExpr179);  			a = filterExpr ();  			PopFollow ();  			DebugLocation (64' 31);  			PushFollow (Follow._filterExpr_in_filterExpr183);  			b = filterExpr ();  			PopFollow ();  			Match (input' TokenTypes.Up' null);  			DebugLocation (65' 4);  			Comparator newComparator;  			switch (comparator6) {  			case "=":  				newComparator = Comparator.Equals;  				break;  			case "!=":  				newComparator = Comparator.NotEquals;  				break;  			case ">":  				newComparator = Comparator.Greater;  				break;  			case "<":  				newComparator = Comparator.Less;  				break;  			case ">=":  				newComparator = Comparator.GreaterOrEqual;  				break;  			case "<=":  				newComparator = Comparator.LessOrEqual;  				break;  			case "&":  				newComparator = Comparator.And;  				break;  			case "|":  				newComparator = Comparator.Or;  				break;  			default:  				newComparator = Comparator.Equals;  				break;  			}  			filterNode = new BoolExpression (a' newComparator' b);  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  		{  			DebugLocation (98' 4);  			DebugLocation (98' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr195);  			Match (input' TokenTypes.Down' null);  			DebugLocation (98' 12);  			PushFollow (Follow._filterExpr_in_filterExpr199);  			f = filterExpr ();  			PopFollow ();  			DebugLocation (98' 31);  			// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  			int alt6 = 2;  			try {  				DebugEnterSubRule (6);  				try {  					DebugEnterDecision (6' false);  					int LA6_1 = input.LA (1);  					if ((LA6_1 == 24)) {  						alt6 = 1;  					}  				}  				finally {  					DebugExitDecision (6);  				}  				switch (alt6) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  					{  						DebugLocation (98' 31);  						inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (6);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (99' 4);  			FilterTreeNode newNode = f;  			if ((inverse != null ? inverse.Text : default(string)) == "!")  				newNode.ToggleInversed ();  			filterNode = newNode;  		}  		break;  	case 3:  		DebugEnterAlt (3);  		// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  		{  			DebugLocation (105' 4);  			DebugLocation (105' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr216);  			Match (input' TokenTypes.Down' null);  			DebugLocation (105' 12);  			PushFollow (Follow._propertyChain_in_filterExpr219);  			propertyChain (propertySegments);  			PopFollow ();  			DebugLocation (105' 51);  			// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  			int alt7 = 2;  			try {  				DebugEnterSubRule (7);  				try {  					DebugEnterDecision (7' false);  					int LA7_1 = input.LA (1);  					if ((LA7_1 == 31)) {  						alt7 = 1;  					}  				}  				finally {  					DebugExitDecision (7);  				}  				switch (alt7) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  					{  						DebugLocation (105' 51);  						inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (7);  			}  			DebugLocation (105' 60);  			// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  			int alt8 = 2;  			try {  				DebugEnterSubRule (8);  				try {  					DebugEnterDecision (8' false);  					int LA8_1 = input.LA (1);  					if ((LA8_1 == 24)) {  						alt8 = 1;  					}  				}  				finally {  					DebugExitDecision (8);  				}  				switch (alt8) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  					{  						DebugLocation (105' 60);  						not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (8);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (106' 4);  			FilterTreeNode newProperty = new Property (propertySegments);  			if ((inverse != null ? inverse.Text : default(string)) == "?")  				filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  			else {  				if ((not != null ? not.Text : default(string)) == "!")  					newProperty.ToggleInversed ();  				filterNode = newProperty;  			}  		}  		break;  	case 4:  		DebugEnterAlt (4);  		// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  		{  			DebugLocation (116' 4);  			STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  			DebugLocation (117' 4);  			string stringText = (STRING7 != null ? STRING7.Text : default(string));  			stringText = stringText.Substring (1' stringText.Length - 2);  			filterNode = new Value (stringText);  		}  		break;  	case 5:  		DebugEnterAlt (5);  		// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  		{  			DebugLocation (122' 4);  			REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  			DebugLocation (123' 4);  			string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  			regexText = regexText.Substring (1' regexText.Length - 2);  			filterNode = new RegExp (regexText);  		}  		break;  	case 6:  		DebugEnterAlt (6);  		// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  		{  			DebugLocation (128' 4);  			NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  			DebugLocation (129' 4);  			filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  		}  		break;  	case 7:  		DebugEnterAlt (7);  		// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  		{  			DebugLocation (132' 4);  			Match (input' TRUE' Follow._TRUE_in_filterExpr271);  			DebugLocation (133' 4);  			filterNode = new Value (true);  		}  		break;  	case 8:  		DebugEnterAlt (8);  		// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  		{  			DebugLocation (136' 4);  			Match (input' FALSE' Follow._FALSE_in_filterExpr281);  			DebugLocation (137' 4);  			filterNode = new Value (false);  		}  		break;  	case 9:  		DebugEnterAlt (9);  		// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  		{  			DebugLocation (140' 4);  			Match (input' NULL' Follow._NULL_in_filterExpr291);  			DebugLocation (141' 4);  			filterNode = new Value (null);  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("filterExpr"' 6);  	LeaveRule ("filterExpr"' 6);  	LeaveRule_filterExpr ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  	int alt9 = 9;  	try {  		DebugEnterDecision (9' false);  		switch (input.LA (1)) {  		case CHAIN_OPERATOR:  		case COMPARATOR:  			{  				alt9 = 1;  			}  			break;  		case EXPR:  			{  				int LA9_2 = input.LA (2);  				if ((LA9_2 == DOWN)) {  					int LA9_3 = input.LA (3);  					if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  						alt9 = 2;  					}  					else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  						alt9 = 3;  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				else {  					NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  					DebugRecognitionException (nvae);  					throw nvae;  				}  			}  			break;  		case STRING:  			{  				alt9 = 4;  			}  			break;  		case REGEX:  			{  				alt9 = 5;  			}  			break;  		case NUMBER:  			{  				alt9 = 6;  			}  			break;  		case TRUE:  			{  				alt9 = 7;  			}  			break;  		case FALSE:  			{  				alt9 = 8;  			}  			break;  		case NULL:  			{  				alt9 = 9;  			}  			break;  		default: {  			NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  		}  	}  	finally {  		DebugExitDecision (9);  	}  	switch (alt9) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  		{  			DebugLocation (64' 4);  			DebugLocation (64' 6);  			PushFollow (Follow._comparator_in_filterExpr175);  			comparator6 = comparator ();  			PopFollow ();  			Match (input' TokenTypes.Down' null);  			DebugLocation (64' 18);  			PushFollow (Follow._filterExpr_in_filterExpr179);  			a = filterExpr ();  			PopFollow ();  			DebugLocation (64' 31);  			PushFollow (Follow._filterExpr_in_filterExpr183);  			b = filterExpr ();  			PopFollow ();  			Match (input' TokenTypes.Up' null);  			DebugLocation (65' 4);  			Comparator newComparator;  			switch (comparator6) {  			case "=":  				newComparator = Comparator.Equals;  				break;  			case "!=":  				newComparator = Comparator.NotEquals;  				break;  			case ">":  				newComparator = Comparator.Greater;  				break;  			case "<":  				newComparator = Comparator.Less;  				break;  			case ">=":  				newComparator = Comparator.GreaterOrEqual;  				break;  			case "<=":  				newComparator = Comparator.LessOrEqual;  				break;  			case "&":  				newComparator = Comparator.And;  				break;  			case "|":  				newComparator = Comparator.Or;  				break;  			default:  				newComparator = Comparator.Equals;  				break;  			}  			filterNode = new BoolExpression (a' newComparator' b);  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  		{  			DebugLocation (98' 4);  			DebugLocation (98' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr195);  			Match (input' TokenTypes.Down' null);  			DebugLocation (98' 12);  			PushFollow (Follow._filterExpr_in_filterExpr199);  			f = filterExpr ();  			PopFollow ();  			DebugLocation (98' 31);  			// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  			int alt6 = 2;  			try {  				DebugEnterSubRule (6);  				try {  					DebugEnterDecision (6' false);  					int LA6_1 = input.LA (1);  					if ((LA6_1 == 24)) {  						alt6 = 1;  					}  				}  				finally {  					DebugExitDecision (6);  				}  				switch (alt6) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  					{  						DebugLocation (98' 31);  						inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (6);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (99' 4);  			FilterTreeNode newNode = f;  			if ((inverse != null ? inverse.Text : default(string)) == "!")  				newNode.ToggleInversed ();  			filterNode = newNode;  		}  		break;  	case 3:  		DebugEnterAlt (3);  		// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  		{  			DebugLocation (105' 4);  			DebugLocation (105' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr216);  			Match (input' TokenTypes.Down' null);  			DebugLocation (105' 12);  			PushFollow (Follow._propertyChain_in_filterExpr219);  			propertyChain (propertySegments);  			PopFollow ();  			DebugLocation (105' 51);  			// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  			int alt7 = 2;  			try {  				DebugEnterSubRule (7);  				try {  					DebugEnterDecision (7' false);  					int LA7_1 = input.LA (1);  					if ((LA7_1 == 31)) {  						alt7 = 1;  					}  				}  				finally {  					DebugExitDecision (7);  				}  				switch (alt7) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  					{  						DebugLocation (105' 51);  						inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (7);  			}  			DebugLocation (105' 60);  			// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  			int alt8 = 2;  			try {  				DebugEnterSubRule (8);  				try {  					DebugEnterDecision (8' false);  					int LA8_1 = input.LA (1);  					if ((LA8_1 == 24)) {  						alt8 = 1;  					}  				}  				finally {  					DebugExitDecision (8);  				}  				switch (alt8) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  					{  						DebugLocation (105' 60);  						not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (8);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (106' 4);  			FilterTreeNode newProperty = new Property (propertySegments);  			if ((inverse != null ? inverse.Text : default(string)) == "?")  				filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  			else {  				if ((not != null ? not.Text : default(string)) == "!")  					newProperty.ToggleInversed ();  				filterNode = newProperty;  			}  		}  		break;  	case 4:  		DebugEnterAlt (4);  		// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  		{  			DebugLocation (116' 4);  			STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  			DebugLocation (117' 4);  			string stringText = (STRING7 != null ? STRING7.Text : default(string));  			stringText = stringText.Substring (1' stringText.Length - 2);  			filterNode = new Value (stringText);  		}  		break;  	case 5:  		DebugEnterAlt (5);  		// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  		{  			DebugLocation (122' 4);  			REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  			DebugLocation (123' 4);  			string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  			regexText = regexText.Substring (1' regexText.Length - 2);  			filterNode = new RegExp (regexText);  		}  		break;  	case 6:  		DebugEnterAlt (6);  		// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  		{  			DebugLocation (128' 4);  			NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  			DebugLocation (129' 4);  			filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  		}  		break;  	case 7:  		DebugEnterAlt (7);  		// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  		{  			DebugLocation (132' 4);  			Match (input' TRUE' Follow._TRUE_in_filterExpr271);  			DebugLocation (133' 4);  			filterNode = new Value (true);  		}  		break;  	case 8:  		DebugEnterAlt (8);  		// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  		{  			DebugLocation (136' 4);  			Match (input' FALSE' Follow._FALSE_in_filterExpr281);  			DebugLocation (137' 4);  			filterNode = new Value (false);  		}  		break;  	case 9:  		DebugEnterAlt (9);  		// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  		{  			DebugLocation (140' 4);  			Match (input' NULL' Follow._NULL_in_filterExpr291);  			DebugLocation (141' 4);  			filterNode = new Value (null);  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("filterExpr"' 6);  	LeaveRule ("filterExpr"' 6);  	LeaveRule_filterExpr ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  	int alt9 = 9;  	try {  		DebugEnterDecision (9' false);  		switch (input.LA (1)) {  		case CHAIN_OPERATOR:  		case COMPARATOR:  			{  				alt9 = 1;  			}  			break;  		case EXPR:  			{  				int LA9_2 = input.LA (2);  				if ((LA9_2 == DOWN)) {  					int LA9_3 = input.LA (3);  					if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  						alt9 = 2;  					}  					else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  						alt9 = 3;  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				else {  					NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  					DebugRecognitionException (nvae);  					throw nvae;  				}  			}  			break;  		case STRING:  			{  				alt9 = 4;  			}  			break;  		case REGEX:  			{  				alt9 = 5;  			}  			break;  		case NUMBER:  			{  				alt9 = 6;  			}  			break;  		case TRUE:  			{  				alt9 = 7;  			}  			break;  		case FALSE:  			{  				alt9 = 8;  			}  			break;  		case NULL:  			{  				alt9 = 9;  			}  			break;  		default: {  			NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  		}  	}  	finally {  		DebugExitDecision (9);  	}  	switch (alt9) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  		{  			DebugLocation (64' 4);  			DebugLocation (64' 6);  			PushFollow (Follow._comparator_in_filterExpr175);  			comparator6 = comparator ();  			PopFollow ();  			Match (input' TokenTypes.Down' null);  			DebugLocation (64' 18);  			PushFollow (Follow._filterExpr_in_filterExpr179);  			a = filterExpr ();  			PopFollow ();  			DebugLocation (64' 31);  			PushFollow (Follow._filterExpr_in_filterExpr183);  			b = filterExpr ();  			PopFollow ();  			Match (input' TokenTypes.Up' null);  			DebugLocation (65' 4);  			Comparator newComparator;  			switch (comparator6) {  			case "=":  				newComparator = Comparator.Equals;  				break;  			case "!=":  				newComparator = Comparator.NotEquals;  				break;  			case ">":  				newComparator = Comparator.Greater;  				break;  			case "<":  				newComparator = Comparator.Less;  				break;  			case ">=":  				newComparator = Comparator.GreaterOrEqual;  				break;  			case "<=":  				newComparator = Comparator.LessOrEqual;  				break;  			case "&":  				newComparator = Comparator.And;  				break;  			case "|":  				newComparator = Comparator.Or;  				break;  			default:  				newComparator = Comparator.Equals;  				break;  			}  			filterNode = new BoolExpression (a' newComparator' b);  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  		{  			DebugLocation (98' 4);  			DebugLocation (98' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr195);  			Match (input' TokenTypes.Down' null);  			DebugLocation (98' 12);  			PushFollow (Follow._filterExpr_in_filterExpr199);  			f = filterExpr ();  			PopFollow ();  			DebugLocation (98' 31);  			// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  			int alt6 = 2;  			try {  				DebugEnterSubRule (6);  				try {  					DebugEnterDecision (6' false);  					int LA6_1 = input.LA (1);  					if ((LA6_1 == 24)) {  						alt6 = 1;  					}  				}  				finally {  					DebugExitDecision (6);  				}  				switch (alt6) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  					{  						DebugLocation (98' 31);  						inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (6);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (99' 4);  			FilterTreeNode newNode = f;  			if ((inverse != null ? inverse.Text : default(string)) == "!")  				newNode.ToggleInversed ();  			filterNode = newNode;  		}  		break;  	case 3:  		DebugEnterAlt (3);  		// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  		{  			DebugLocation (105' 4);  			DebugLocation (105' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr216);  			Match (input' TokenTypes.Down' null);  			DebugLocation (105' 12);  			PushFollow (Follow._propertyChain_in_filterExpr219);  			propertyChain (propertySegments);  			PopFollow ();  			DebugLocation (105' 51);  			// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  			int alt7 = 2;  			try {  				DebugEnterSubRule (7);  				try {  					DebugEnterDecision (7' false);  					int LA7_1 = input.LA (1);  					if ((LA7_1 == 31)) {  						alt7 = 1;  					}  				}  				finally {  					DebugExitDecision (7);  				}  				switch (alt7) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  					{  						DebugLocation (105' 51);  						inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (7);  			}  			DebugLocation (105' 60);  			// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  			int alt8 = 2;  			try {  				DebugEnterSubRule (8);  				try {  					DebugEnterDecision (8' false);  					int LA8_1 = input.LA (1);  					if ((LA8_1 == 24)) {  						alt8 = 1;  					}  				}  				finally {  					DebugExitDecision (8);  				}  				switch (alt8) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  					{  						DebugLocation (105' 60);  						not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (8);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (106' 4);  			FilterTreeNode newProperty = new Property (propertySegments);  			if ((inverse != null ? inverse.Text : default(string)) == "?")  				filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  			else {  				if ((not != null ? not.Text : default(string)) == "!")  					newProperty.ToggleInversed ();  				filterNode = newProperty;  			}  		}  		break;  	case 4:  		DebugEnterAlt (4);  		// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  		{  			DebugLocation (116' 4);  			STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  			DebugLocation (117' 4);  			string stringText = (STRING7 != null ? STRING7.Text : default(string));  			stringText = stringText.Substring (1' stringText.Length - 2);  			filterNode = new Value (stringText);  		}  		break;  	case 5:  		DebugEnterAlt (5);  		// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  		{  			DebugLocation (122' 4);  			REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  			DebugLocation (123' 4);  			string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  			regexText = regexText.Substring (1' regexText.Length - 2);  			filterNode = new RegExp (regexText);  		}  		break;  	case 6:  		DebugEnterAlt (6);  		// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  		{  			DebugLocation (128' 4);  			NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  			DebugLocation (129' 4);  			filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  		}  		break;  	case 7:  		DebugEnterAlt (7);  		// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  		{  			DebugLocation (132' 4);  			Match (input' TRUE' Follow._TRUE_in_filterExpr271);  			DebugLocation (133' 4);  			filterNode = new Value (true);  		}  		break;  	case 8:  		DebugEnterAlt (8);  		// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  		{  			DebugLocation (136' 4);  			Match (input' FALSE' Follow._FALSE_in_filterExpr281);  			DebugLocation (137' 4);  			filterNode = new Value (false);  		}  		break;  	case 9:  		DebugEnterAlt (9);  		// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  		{  			DebugLocation (140' 4);  			Match (input' NULL' Follow._NULL_in_filterExpr291);  			DebugLocation (141' 4);  			filterNode = new Value (null);  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("filterExpr"' 6);  	LeaveRule ("filterExpr"' 6);  	LeaveRule_filterExpr ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  	int alt9 = 9;  	try {  		DebugEnterDecision (9' false);  		switch (input.LA (1)) {  		case CHAIN_OPERATOR:  		case COMPARATOR:  			{  				alt9 = 1;  			}  			break;  		case EXPR:  			{  				int LA9_2 = input.LA (2);  				if ((LA9_2 == DOWN)) {  					int LA9_3 = input.LA (3);  					if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  						alt9 = 2;  					}  					else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  						alt9 = 3;  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				else {  					NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  					DebugRecognitionException (nvae);  					throw nvae;  				}  			}  			break;  		case STRING:  			{  				alt9 = 4;  			}  			break;  		case REGEX:  			{  				alt9 = 5;  			}  			break;  		case NUMBER:  			{  				alt9 = 6;  			}  			break;  		case TRUE:  			{  				alt9 = 7;  			}  			break;  		case FALSE:  			{  				alt9 = 8;  			}  			break;  		case NULL:  			{  				alt9 = 9;  			}  			break;  		default: {  			NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  		}  	}  	finally {  		DebugExitDecision (9);  	}  	switch (alt9) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  		{  			DebugLocation (64' 4);  			DebugLocation (64' 6);  			PushFollow (Follow._comparator_in_filterExpr175);  			comparator6 = comparator ();  			PopFollow ();  			Match (input' TokenTypes.Down' null);  			DebugLocation (64' 18);  			PushFollow (Follow._filterExpr_in_filterExpr179);  			a = filterExpr ();  			PopFollow ();  			DebugLocation (64' 31);  			PushFollow (Follow._filterExpr_in_filterExpr183);  			b = filterExpr ();  			PopFollow ();  			Match (input' TokenTypes.Up' null);  			DebugLocation (65' 4);  			Comparator newComparator;  			switch (comparator6) {  			case "=":  				newComparator = Comparator.Equals;  				break;  			case "!=":  				newComparator = Comparator.NotEquals;  				break;  			case ">":  				newComparator = Comparator.Greater;  				break;  			case "<":  				newComparator = Comparator.Less;  				break;  			case ">=":  				newComparator = Comparator.GreaterOrEqual;  				break;  			case "<=":  				newComparator = Comparator.LessOrEqual;  				break;  			case "&":  				newComparator = Comparator.And;  				break;  			case "|":  				newComparator = Comparator.Or;  				break;  			default:  				newComparator = Comparator.Equals;  				break;  			}  			filterNode = new BoolExpression (a' newComparator' b);  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  		{  			DebugLocation (98' 4);  			DebugLocation (98' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr195);  			Match (input' TokenTypes.Down' null);  			DebugLocation (98' 12);  			PushFollow (Follow._filterExpr_in_filterExpr199);  			f = filterExpr ();  			PopFollow ();  			DebugLocation (98' 31);  			// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  			int alt6 = 2;  			try {  				DebugEnterSubRule (6);  				try {  					DebugEnterDecision (6' false);  					int LA6_1 = input.LA (1);  					if ((LA6_1 == 24)) {  						alt6 = 1;  					}  				}  				finally {  					DebugExitDecision (6);  				}  				switch (alt6) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  					{  						DebugLocation (98' 31);  						inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (6);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (99' 4);  			FilterTreeNode newNode = f;  			if ((inverse != null ? inverse.Text : default(string)) == "!")  				newNode.ToggleInversed ();  			filterNode = newNode;  		}  		break;  	case 3:  		DebugEnterAlt (3);  		// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  		{  			DebugLocation (105' 4);  			DebugLocation (105' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr216);  			Match (input' TokenTypes.Down' null);  			DebugLocation (105' 12);  			PushFollow (Follow._propertyChain_in_filterExpr219);  			propertyChain (propertySegments);  			PopFollow ();  			DebugLocation (105' 51);  			// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  			int alt7 = 2;  			try {  				DebugEnterSubRule (7);  				try {  					DebugEnterDecision (7' false);  					int LA7_1 = input.LA (1);  					if ((LA7_1 == 31)) {  						alt7 = 1;  					}  				}  				finally {  					DebugExitDecision (7);  				}  				switch (alt7) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  					{  						DebugLocation (105' 51);  						inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (7);  			}  			DebugLocation (105' 60);  			// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  			int alt8 = 2;  			try {  				DebugEnterSubRule (8);  				try {  					DebugEnterDecision (8' false);  					int LA8_1 = input.LA (1);  					if ((LA8_1 == 24)) {  						alt8 = 1;  					}  				}  				finally {  					DebugExitDecision (8);  				}  				switch (alt8) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  					{  						DebugLocation (105' 60);  						not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (8);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (106' 4);  			FilterTreeNode newProperty = new Property (propertySegments);  			if ((inverse != null ? inverse.Text : default(string)) == "?")  				filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  			else {  				if ((not != null ? not.Text : default(string)) == "!")  					newProperty.ToggleInversed ();  				filterNode = newProperty;  			}  		}  		break;  	case 4:  		DebugEnterAlt (4);  		// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  		{  			DebugLocation (116' 4);  			STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  			DebugLocation (117' 4);  			string stringText = (STRING7 != null ? STRING7.Text : default(string));  			stringText = stringText.Substring (1' stringText.Length - 2);  			filterNode = new Value (stringText);  		}  		break;  	case 5:  		DebugEnterAlt (5);  		// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  		{  			DebugLocation (122' 4);  			REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  			DebugLocation (123' 4);  			string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  			regexText = regexText.Substring (1' regexText.Length - 2);  			filterNode = new RegExp (regexText);  		}  		break;  	case 6:  		DebugEnterAlt (6);  		// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  		{  			DebugLocation (128' 4);  			NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  			DebugLocation (129' 4);  			filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  		}  		break;  	case 7:  		DebugEnterAlt (7);  		// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  		{  			DebugLocation (132' 4);  			Match (input' TRUE' Follow._TRUE_in_filterExpr271);  			DebugLocation (133' 4);  			filterNode = new Value (true);  		}  		break;  	case 8:  		DebugEnterAlt (8);  		// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  		{  			DebugLocation (136' 4);  			Match (input' FALSE' Follow._FALSE_in_filterExpr281);  			DebugLocation (137' 4);  			filterNode = new Value (false);  		}  		break;  	case 9:  		DebugEnterAlt (9);  		// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  		{  			DebugLocation (140' 4);  			Match (input' NULL' Follow._NULL_in_filterExpr291);  			DebugLocation (141' 4);  			filterNode = new Value (null);  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("filterExpr"' 6);  	LeaveRule ("filterExpr"' 6);  	LeaveRule_filterExpr ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  	int alt9 = 9;  	try {  		DebugEnterDecision (9' false);  		switch (input.LA (1)) {  		case CHAIN_OPERATOR:  		case COMPARATOR:  			{  				alt9 = 1;  			}  			break;  		case EXPR:  			{  				int LA9_2 = input.LA (2);  				if ((LA9_2 == DOWN)) {  					int LA9_3 = input.LA (3);  					if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  						alt9 = 2;  					}  					else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  						alt9 = 3;  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				else {  					NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  					DebugRecognitionException (nvae);  					throw nvae;  				}  			}  			break;  		case STRING:  			{  				alt9 = 4;  			}  			break;  		case REGEX:  			{  				alt9 = 5;  			}  			break;  		case NUMBER:  			{  				alt9 = 6;  			}  			break;  		case TRUE:  			{  				alt9 = 7;  			}  			break;  		case FALSE:  			{  				alt9 = 8;  			}  			break;  		case NULL:  			{  				alt9 = 9;  			}  			break;  		default: {  			NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  		}  	}  	finally {  		DebugExitDecision (9);  	}  	switch (alt9) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  		{  			DebugLocation (64' 4);  			DebugLocation (64' 6);  			PushFollow (Follow._comparator_in_filterExpr175);  			comparator6 = comparator ();  			PopFollow ();  			Match (input' TokenTypes.Down' null);  			DebugLocation (64' 18);  			PushFollow (Follow._filterExpr_in_filterExpr179);  			a = filterExpr ();  			PopFollow ();  			DebugLocation (64' 31);  			PushFollow (Follow._filterExpr_in_filterExpr183);  			b = filterExpr ();  			PopFollow ();  			Match (input' TokenTypes.Up' null);  			DebugLocation (65' 4);  			Comparator newComparator;  			switch (comparator6) {  			case "=":  				newComparator = Comparator.Equals;  				break;  			case "!=":  				newComparator = Comparator.NotEquals;  				break;  			case ">":  				newComparator = Comparator.Greater;  				break;  			case "<":  				newComparator = Comparator.Less;  				break;  			case ">=":  				newComparator = Comparator.GreaterOrEqual;  				break;  			case "<=":  				newComparator = Comparator.LessOrEqual;  				break;  			case "&":  				newComparator = Comparator.And;  				break;  			case "|":  				newComparator = Comparator.Or;  				break;  			default:  				newComparator = Comparator.Equals;  				break;  			}  			filterNode = new BoolExpression (a' newComparator' b);  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  		{  			DebugLocation (98' 4);  			DebugLocation (98' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr195);  			Match (input' TokenTypes.Down' null);  			DebugLocation (98' 12);  			PushFollow (Follow._filterExpr_in_filterExpr199);  			f = filterExpr ();  			PopFollow ();  			DebugLocation (98' 31);  			// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  			int alt6 = 2;  			try {  				DebugEnterSubRule (6);  				try {  					DebugEnterDecision (6' false);  					int LA6_1 = input.LA (1);  					if ((LA6_1 == 24)) {  						alt6 = 1;  					}  				}  				finally {  					DebugExitDecision (6);  				}  				switch (alt6) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  					{  						DebugLocation (98' 31);  						inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (6);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (99' 4);  			FilterTreeNode newNode = f;  			if ((inverse != null ? inverse.Text : default(string)) == "!")  				newNode.ToggleInversed ();  			filterNode = newNode;  		}  		break;  	case 3:  		DebugEnterAlt (3);  		// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  		{  			DebugLocation (105' 4);  			DebugLocation (105' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr216);  			Match (input' TokenTypes.Down' null);  			DebugLocation (105' 12);  			PushFollow (Follow._propertyChain_in_filterExpr219);  			propertyChain (propertySegments);  			PopFollow ();  			DebugLocation (105' 51);  			// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  			int alt7 = 2;  			try {  				DebugEnterSubRule (7);  				try {  					DebugEnterDecision (7' false);  					int LA7_1 = input.LA (1);  					if ((LA7_1 == 31)) {  						alt7 = 1;  					}  				}  				finally {  					DebugExitDecision (7);  				}  				switch (alt7) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  					{  						DebugLocation (105' 51);  						inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (7);  			}  			DebugLocation (105' 60);  			// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  			int alt8 = 2;  			try {  				DebugEnterSubRule (8);  				try {  					DebugEnterDecision (8' false);  					int LA8_1 = input.LA (1);  					if ((LA8_1 == 24)) {  						alt8 = 1;  					}  				}  				finally {  					DebugExitDecision (8);  				}  				switch (alt8) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  					{  						DebugLocation (105' 60);  						not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (8);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (106' 4);  			FilterTreeNode newProperty = new Property (propertySegments);  			if ((inverse != null ? inverse.Text : default(string)) == "?")  				filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  			else {  				if ((not != null ? not.Text : default(string)) == "!")  					newProperty.ToggleInversed ();  				filterNode = newProperty;  			}  		}  		break;  	case 4:  		DebugEnterAlt (4);  		// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  		{  			DebugLocation (116' 4);  			STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  			DebugLocation (117' 4);  			string stringText = (STRING7 != null ? STRING7.Text : default(string));  			stringText = stringText.Substring (1' stringText.Length - 2);  			filterNode = new Value (stringText);  		}  		break;  	case 5:  		DebugEnterAlt (5);  		// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  		{  			DebugLocation (122' 4);  			REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  			DebugLocation (123' 4);  			string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  			regexText = regexText.Substring (1' regexText.Length - 2);  			filterNode = new RegExp (regexText);  		}  		break;  	case 6:  		DebugEnterAlt (6);  		// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  		{  			DebugLocation (128' 4);  			NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  			DebugLocation (129' 4);  			filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  		}  		break;  	case 7:  		DebugEnterAlt (7);  		// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  		{  			DebugLocation (132' 4);  			Match (input' TRUE' Follow._TRUE_in_filterExpr271);  			DebugLocation (133' 4);  			filterNode = new Value (true);  		}  		break;  	case 8:  		DebugEnterAlt (8);  		// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  		{  			DebugLocation (136' 4);  			Match (input' FALSE' Follow._FALSE_in_filterExpr281);  			DebugLocation (137' 4);  			filterNode = new Value (false);  		}  		break;  	case 9:  		DebugEnterAlt (9);  		// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  		{  			DebugLocation (140' 4);  			Match (input' NULL' Follow._NULL_in_filterExpr291);  			DebugLocation (141' 4);  			filterNode = new Value (null);  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("filterExpr"' 6);  	LeaveRule ("filterExpr"' 6);  	LeaveRule_filterExpr ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  	int alt9 = 9;  	try {  		DebugEnterDecision (9' false);  		switch (input.LA (1)) {  		case CHAIN_OPERATOR:  		case COMPARATOR:  			{  				alt9 = 1;  			}  			break;  		case EXPR:  			{  				int LA9_2 = input.LA (2);  				if ((LA9_2 == DOWN)) {  					int LA9_3 = input.LA (3);  					if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  						alt9 = 2;  					}  					else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  						alt9 = 3;  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				else {  					NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  					DebugRecognitionException (nvae);  					throw nvae;  				}  			}  			break;  		case STRING:  			{  				alt9 = 4;  			}  			break;  		case REGEX:  			{  				alt9 = 5;  			}  			break;  		case NUMBER:  			{  				alt9 = 6;  			}  			break;  		case TRUE:  			{  				alt9 = 7;  			}  			break;  		case FALSE:  			{  				alt9 = 8;  			}  			break;  		case NULL:  			{  				alt9 = 9;  			}  			break;  		default: {  			NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  		}  	}  	finally {  		DebugExitDecision (9);  	}  	switch (alt9) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  		{  			DebugLocation (64' 4);  			DebugLocation (64' 6);  			PushFollow (Follow._comparator_in_filterExpr175);  			comparator6 = comparator ();  			PopFollow ();  			Match (input' TokenTypes.Down' null);  			DebugLocation (64' 18);  			PushFollow (Follow._filterExpr_in_filterExpr179);  			a = filterExpr ();  			PopFollow ();  			DebugLocation (64' 31);  			PushFollow (Follow._filterExpr_in_filterExpr183);  			b = filterExpr ();  			PopFollow ();  			Match (input' TokenTypes.Up' null);  			DebugLocation (65' 4);  			Comparator newComparator;  			switch (comparator6) {  			case "=":  				newComparator = Comparator.Equals;  				break;  			case "!=":  				newComparator = Comparator.NotEquals;  				break;  			case ">":  				newComparator = Comparator.Greater;  				break;  			case "<":  				newComparator = Comparator.Less;  				break;  			case ">=":  				newComparator = Comparator.GreaterOrEqual;  				break;  			case "<=":  				newComparator = Comparator.LessOrEqual;  				break;  			case "&":  				newComparator = Comparator.And;  				break;  			case "|":  				newComparator = Comparator.Or;  				break;  			default:  				newComparator = Comparator.Equals;  				break;  			}  			filterNode = new BoolExpression (a' newComparator' b);  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  		{  			DebugLocation (98' 4);  			DebugLocation (98' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr195);  			Match (input' TokenTypes.Down' null);  			DebugLocation (98' 12);  			PushFollow (Follow._filterExpr_in_filterExpr199);  			f = filterExpr ();  			PopFollow ();  			DebugLocation (98' 31);  			// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  			int alt6 = 2;  			try {  				DebugEnterSubRule (6);  				try {  					DebugEnterDecision (6' false);  					int LA6_1 = input.LA (1);  					if ((LA6_1 == 24)) {  						alt6 = 1;  					}  				}  				finally {  					DebugExitDecision (6);  				}  				switch (alt6) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  					{  						DebugLocation (98' 31);  						inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (6);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (99' 4);  			FilterTreeNode newNode = f;  			if ((inverse != null ? inverse.Text : default(string)) == "!")  				newNode.ToggleInversed ();  			filterNode = newNode;  		}  		break;  	case 3:  		DebugEnterAlt (3);  		// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  		{  			DebugLocation (105' 4);  			DebugLocation (105' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr216);  			Match (input' TokenTypes.Down' null);  			DebugLocation (105' 12);  			PushFollow (Follow._propertyChain_in_filterExpr219);  			propertyChain (propertySegments);  			PopFollow ();  			DebugLocation (105' 51);  			// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  			int alt7 = 2;  			try {  				DebugEnterSubRule (7);  				try {  					DebugEnterDecision (7' false);  					int LA7_1 = input.LA (1);  					if ((LA7_1 == 31)) {  						alt7 = 1;  					}  				}  				finally {  					DebugExitDecision (7);  				}  				switch (alt7) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  					{  						DebugLocation (105' 51);  						inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (7);  			}  			DebugLocation (105' 60);  			// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  			int alt8 = 2;  			try {  				DebugEnterSubRule (8);  				try {  					DebugEnterDecision (8' false);  					int LA8_1 = input.LA (1);  					if ((LA8_1 == 24)) {  						alt8 = 1;  					}  				}  				finally {  					DebugExitDecision (8);  				}  				switch (alt8) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  					{  						DebugLocation (105' 60);  						not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (8);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (106' 4);  			FilterTreeNode newProperty = new Property (propertySegments);  			if ((inverse != null ? inverse.Text : default(string)) == "?")  				filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  			else {  				if ((not != null ? not.Text : default(string)) == "!")  					newProperty.ToggleInversed ();  				filterNode = newProperty;  			}  		}  		break;  	case 4:  		DebugEnterAlt (4);  		// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  		{  			DebugLocation (116' 4);  			STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  			DebugLocation (117' 4);  			string stringText = (STRING7 != null ? STRING7.Text : default(string));  			stringText = stringText.Substring (1' stringText.Length - 2);  			filterNode = new Value (stringText);  		}  		break;  	case 5:  		DebugEnterAlt (5);  		// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  		{  			DebugLocation (122' 4);  			REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  			DebugLocation (123' 4);  			string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  			regexText = regexText.Substring (1' regexText.Length - 2);  			filterNode = new RegExp (regexText);  		}  		break;  	case 6:  		DebugEnterAlt (6);  		// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  		{  			DebugLocation (128' 4);  			NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  			DebugLocation (129' 4);  			filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  		}  		break;  	case 7:  		DebugEnterAlt (7);  		// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  		{  			DebugLocation (132' 4);  			Match (input' TRUE' Follow._TRUE_in_filterExpr271);  			DebugLocation (133' 4);  			filterNode = new Value (true);  		}  		break;  	case 8:  		DebugEnterAlt (8);  		// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  		{  			DebugLocation (136' 4);  			Match (input' FALSE' Follow._FALSE_in_filterExpr281);  			DebugLocation (137' 4);  			filterNode = new Value (false);  		}  		break;  	case 9:  		DebugEnterAlt (9);  		// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  		{  			DebugLocation (140' 4);  			Match (input' NULL' Follow._NULL_in_filterExpr291);  			DebugLocation (141' 4);  			filterNode = new Value (null);  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("filterExpr"' 6);  	LeaveRule ("filterExpr"' 6);  	LeaveRule_filterExpr ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  	int alt9 = 9;  	try {  		DebugEnterDecision (9' false);  		switch (input.LA (1)) {  		case CHAIN_OPERATOR:  		case COMPARATOR:  			{  				alt9 = 1;  			}  			break;  		case EXPR:  			{  				int LA9_2 = input.LA (2);  				if ((LA9_2 == DOWN)) {  					int LA9_3 = input.LA (3);  					if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  						alt9 = 2;  					}  					else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  						alt9 = 3;  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				else {  					NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  					DebugRecognitionException (nvae);  					throw nvae;  				}  			}  			break;  		case STRING:  			{  				alt9 = 4;  			}  			break;  		case REGEX:  			{  				alt9 = 5;  			}  			break;  		case NUMBER:  			{  				alt9 = 6;  			}  			break;  		case TRUE:  			{  				alt9 = 7;  			}  			break;  		case FALSE:  			{  				alt9 = 8;  			}  			break;  		case NULL:  			{  				alt9 = 9;  			}  			break;  		default: {  			NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  		}  	}  	finally {  		DebugExitDecision (9);  	}  	switch (alt9) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  		{  			DebugLocation (64' 4);  			DebugLocation (64' 6);  			PushFollow (Follow._comparator_in_filterExpr175);  			comparator6 = comparator ();  			PopFollow ();  			Match (input' TokenTypes.Down' null);  			DebugLocation (64' 18);  			PushFollow (Follow._filterExpr_in_filterExpr179);  			a = filterExpr ();  			PopFollow ();  			DebugLocation (64' 31);  			PushFollow (Follow._filterExpr_in_filterExpr183);  			b = filterExpr ();  			PopFollow ();  			Match (input' TokenTypes.Up' null);  			DebugLocation (65' 4);  			Comparator newComparator;  			switch (comparator6) {  			case "=":  				newComparator = Comparator.Equals;  				break;  			case "!=":  				newComparator = Comparator.NotEquals;  				break;  			case ">":  				newComparator = Comparator.Greater;  				break;  			case "<":  				newComparator = Comparator.Less;  				break;  			case ">=":  				newComparator = Comparator.GreaterOrEqual;  				break;  			case "<=":  				newComparator = Comparator.LessOrEqual;  				break;  			case "&":  				newComparator = Comparator.And;  				break;  			case "|":  				newComparator = Comparator.Or;  				break;  			default:  				newComparator = Comparator.Equals;  				break;  			}  			filterNode = new BoolExpression (a' newComparator' b);  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  		{  			DebugLocation (98' 4);  			DebugLocation (98' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr195);  			Match (input' TokenTypes.Down' null);  			DebugLocation (98' 12);  			PushFollow (Follow._filterExpr_in_filterExpr199);  			f = filterExpr ();  			PopFollow ();  			DebugLocation (98' 31);  			// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  			int alt6 = 2;  			try {  				DebugEnterSubRule (6);  				try {  					DebugEnterDecision (6' false);  					int LA6_1 = input.LA (1);  					if ((LA6_1 == 24)) {  						alt6 = 1;  					}  				}  				finally {  					DebugExitDecision (6);  				}  				switch (alt6) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  					{  						DebugLocation (98' 31);  						inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (6);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (99' 4);  			FilterTreeNode newNode = f;  			if ((inverse != null ? inverse.Text : default(string)) == "!")  				newNode.ToggleInversed ();  			filterNode = newNode;  		}  		break;  	case 3:  		DebugEnterAlt (3);  		// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  		{  			DebugLocation (105' 4);  			DebugLocation (105' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr216);  			Match (input' TokenTypes.Down' null);  			DebugLocation (105' 12);  			PushFollow (Follow._propertyChain_in_filterExpr219);  			propertyChain (propertySegments);  			PopFollow ();  			DebugLocation (105' 51);  			// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  			int alt7 = 2;  			try {  				DebugEnterSubRule (7);  				try {  					DebugEnterDecision (7' false);  					int LA7_1 = input.LA (1);  					if ((LA7_1 == 31)) {  						alt7 = 1;  					}  				}  				finally {  					DebugExitDecision (7);  				}  				switch (alt7) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  					{  						DebugLocation (105' 51);  						inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (7);  			}  			DebugLocation (105' 60);  			// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  			int alt8 = 2;  			try {  				DebugEnterSubRule (8);  				try {  					DebugEnterDecision (8' false);  					int LA8_1 = input.LA (1);  					if ((LA8_1 == 24)) {  						alt8 = 1;  					}  				}  				finally {  					DebugExitDecision (8);  				}  				switch (alt8) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  					{  						DebugLocation (105' 60);  						not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (8);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (106' 4);  			FilterTreeNode newProperty = new Property (propertySegments);  			if ((inverse != null ? inverse.Text : default(string)) == "?")  				filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  			else {  				if ((not != null ? not.Text : default(string)) == "!")  					newProperty.ToggleInversed ();  				filterNode = newProperty;  			}  		}  		break;  	case 4:  		DebugEnterAlt (4);  		// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  		{  			DebugLocation (116' 4);  			STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  			DebugLocation (117' 4);  			string stringText = (STRING7 != null ? STRING7.Text : default(string));  			stringText = stringText.Substring (1' stringText.Length - 2);  			filterNode = new Value (stringText);  		}  		break;  	case 5:  		DebugEnterAlt (5);  		// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  		{  			DebugLocation (122' 4);  			REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  			DebugLocation (123' 4);  			string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  			regexText = regexText.Substring (1' regexText.Length - 2);  			filterNode = new RegExp (regexText);  		}  		break;  	case 6:  		DebugEnterAlt (6);  		// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  		{  			DebugLocation (128' 4);  			NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  			DebugLocation (129' 4);  			filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  		}  		break;  	case 7:  		DebugEnterAlt (7);  		// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  		{  			DebugLocation (132' 4);  			Match (input' TRUE' Follow._TRUE_in_filterExpr271);  			DebugLocation (133' 4);  			filterNode = new Value (true);  		}  		break;  	case 8:  		DebugEnterAlt (8);  		// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  		{  			DebugLocation (136' 4);  			Match (input' FALSE' Follow._FALSE_in_filterExpr281);  			DebugLocation (137' 4);  			filterNode = new Value (false);  		}  		break;  	case 9:  		DebugEnterAlt (9);  		// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  		{  			DebugLocation (140' 4);  			Match (input' NULL' Follow._NULL_in_filterExpr291);  			DebugLocation (141' 4);  			filterNode = new Value (null);  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("filterExpr"' 6);  	LeaveRule ("filterExpr"' 6);  	LeaveRule_filterExpr ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  	int alt9 = 9;  	try {  		DebugEnterDecision (9' false);  		switch (input.LA (1)) {  		case CHAIN_OPERATOR:  		case COMPARATOR:  			{  				alt9 = 1;  			}  			break;  		case EXPR:  			{  				int LA9_2 = input.LA (2);  				if ((LA9_2 == DOWN)) {  					int LA9_3 = input.LA (3);  					if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  						alt9 = 2;  					}  					else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  						alt9 = 3;  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				else {  					NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  					DebugRecognitionException (nvae);  					throw nvae;  				}  			}  			break;  		case STRING:  			{  				alt9 = 4;  			}  			break;  		case REGEX:  			{  				alt9 = 5;  			}  			break;  		case NUMBER:  			{  				alt9 = 6;  			}  			break;  		case TRUE:  			{  				alt9 = 7;  			}  			break;  		case FALSE:  			{  				alt9 = 8;  			}  			break;  		case NULL:  			{  				alt9 = 9;  			}  			break;  		default: {  			NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  		}  	}  	finally {  		DebugExitDecision (9);  	}  	switch (alt9) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  		{  			DebugLocation (64' 4);  			DebugLocation (64' 6);  			PushFollow (Follow._comparator_in_filterExpr175);  			comparator6 = comparator ();  			PopFollow ();  			Match (input' TokenTypes.Down' null);  			DebugLocation (64' 18);  			PushFollow (Follow._filterExpr_in_filterExpr179);  			a = filterExpr ();  			PopFollow ();  			DebugLocation (64' 31);  			PushFollow (Follow._filterExpr_in_filterExpr183);  			b = filterExpr ();  			PopFollow ();  			Match (input' TokenTypes.Up' null);  			DebugLocation (65' 4);  			Comparator newComparator;  			switch (comparator6) {  			case "=":  				newComparator = Comparator.Equals;  				break;  			case "!=":  				newComparator = Comparator.NotEquals;  				break;  			case ">":  				newComparator = Comparator.Greater;  				break;  			case "<":  				newComparator = Comparator.Less;  				break;  			case ">=":  				newComparator = Comparator.GreaterOrEqual;  				break;  			case "<=":  				newComparator = Comparator.LessOrEqual;  				break;  			case "&":  				newComparator = Comparator.And;  				break;  			case "|":  				newComparator = Comparator.Or;  				break;  			default:  				newComparator = Comparator.Equals;  				break;  			}  			filterNode = new BoolExpression (a' newComparator' b);  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  		{  			DebugLocation (98' 4);  			DebugLocation (98' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr195);  			Match (input' TokenTypes.Down' null);  			DebugLocation (98' 12);  			PushFollow (Follow._filterExpr_in_filterExpr199);  			f = filterExpr ();  			PopFollow ();  			DebugLocation (98' 31);  			// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  			int alt6 = 2;  			try {  				DebugEnterSubRule (6);  				try {  					DebugEnterDecision (6' false);  					int LA6_1 = input.LA (1);  					if ((LA6_1 == 24)) {  						alt6 = 1;  					}  				}  				finally {  					DebugExitDecision (6);  				}  				switch (alt6) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  					{  						DebugLocation (98' 31);  						inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (6);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (99' 4);  			FilterTreeNode newNode = f;  			if ((inverse != null ? inverse.Text : default(string)) == "!")  				newNode.ToggleInversed ();  			filterNode = newNode;  		}  		break;  	case 3:  		DebugEnterAlt (3);  		// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  		{  			DebugLocation (105' 4);  			DebugLocation (105' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr216);  			Match (input' TokenTypes.Down' null);  			DebugLocation (105' 12);  			PushFollow (Follow._propertyChain_in_filterExpr219);  			propertyChain (propertySegments);  			PopFollow ();  			DebugLocation (105' 51);  			// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  			int alt7 = 2;  			try {  				DebugEnterSubRule (7);  				try {  					DebugEnterDecision (7' false);  					int LA7_1 = input.LA (1);  					if ((LA7_1 == 31)) {  						alt7 = 1;  					}  				}  				finally {  					DebugExitDecision (7);  				}  				switch (alt7) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  					{  						DebugLocation (105' 51);  						inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (7);  			}  			DebugLocation (105' 60);  			// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  			int alt8 = 2;  			try {  				DebugEnterSubRule (8);  				try {  					DebugEnterDecision (8' false);  					int LA8_1 = input.LA (1);  					if ((LA8_1 == 24)) {  						alt8 = 1;  					}  				}  				finally {  					DebugExitDecision (8);  				}  				switch (alt8) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  					{  						DebugLocation (105' 60);  						not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (8);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (106' 4);  			FilterTreeNode newProperty = new Property (propertySegments);  			if ((inverse != null ? inverse.Text : default(string)) == "?")  				filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  			else {  				if ((not != null ? not.Text : default(string)) == "!")  					newProperty.ToggleInversed ();  				filterNode = newProperty;  			}  		}  		break;  	case 4:  		DebugEnterAlt (4);  		// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  		{  			DebugLocation (116' 4);  			STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  			DebugLocation (117' 4);  			string stringText = (STRING7 != null ? STRING7.Text : default(string));  			stringText = stringText.Substring (1' stringText.Length - 2);  			filterNode = new Value (stringText);  		}  		break;  	case 5:  		DebugEnterAlt (5);  		// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  		{  			DebugLocation (122' 4);  			REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  			DebugLocation (123' 4);  			string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  			regexText = regexText.Substring (1' regexText.Length - 2);  			filterNode = new RegExp (regexText);  		}  		break;  	case 6:  		DebugEnterAlt (6);  		// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  		{  			DebugLocation (128' 4);  			NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  			DebugLocation (129' 4);  			filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  		}  		break;  	case 7:  		DebugEnterAlt (7);  		// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  		{  			DebugLocation (132' 4);  			Match (input' TRUE' Follow._TRUE_in_filterExpr271);  			DebugLocation (133' 4);  			filterNode = new Value (true);  		}  		break;  	case 8:  		DebugEnterAlt (8);  		// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  		{  			DebugLocation (136' 4);  			Match (input' FALSE' Follow._FALSE_in_filterExpr281);  			DebugLocation (137' 4);  			filterNode = new Value (false);  		}  		break;  	case 9:  		DebugEnterAlt (9);  		// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  		{  			DebugLocation (140' 4);  			Match (input' NULL' Follow._NULL_in_filterExpr291);  			DebugLocation (141' 4);  			filterNode = new Value (null);  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("filterExpr"' 6);  	LeaveRule ("filterExpr"' 6);  	LeaveRule_filterExpr ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  	int alt9 = 9;  	try {  		DebugEnterDecision (9' false);  		switch (input.LA (1)) {  		case CHAIN_OPERATOR:  		case COMPARATOR:  			{  				alt9 = 1;  			}  			break;  		case EXPR:  			{  				int LA9_2 = input.LA (2);  				if ((LA9_2 == DOWN)) {  					int LA9_3 = input.LA (3);  					if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  						alt9 = 2;  					}  					else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  						alt9 = 3;  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				else {  					NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  					DebugRecognitionException (nvae);  					throw nvae;  				}  			}  			break;  		case STRING:  			{  				alt9 = 4;  			}  			break;  		case REGEX:  			{  				alt9 = 5;  			}  			break;  		case NUMBER:  			{  				alt9 = 6;  			}  			break;  		case TRUE:  			{  				alt9 = 7;  			}  			break;  		case FALSE:  			{  				alt9 = 8;  			}  			break;  		case NULL:  			{  				alt9 = 9;  			}  			break;  		default: {  			NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  		}  	}  	finally {  		DebugExitDecision (9);  	}  	switch (alt9) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  		{  			DebugLocation (64' 4);  			DebugLocation (64' 6);  			PushFollow (Follow._comparator_in_filterExpr175);  			comparator6 = comparator ();  			PopFollow ();  			Match (input' TokenTypes.Down' null);  			DebugLocation (64' 18);  			PushFollow (Follow._filterExpr_in_filterExpr179);  			a = filterExpr ();  			PopFollow ();  			DebugLocation (64' 31);  			PushFollow (Follow._filterExpr_in_filterExpr183);  			b = filterExpr ();  			PopFollow ();  			Match (input' TokenTypes.Up' null);  			DebugLocation (65' 4);  			Comparator newComparator;  			switch (comparator6) {  			case "=":  				newComparator = Comparator.Equals;  				break;  			case "!=":  				newComparator = Comparator.NotEquals;  				break;  			case ">":  				newComparator = Comparator.Greater;  				break;  			case "<":  				newComparator = Comparator.Less;  				break;  			case ">=":  				newComparator = Comparator.GreaterOrEqual;  				break;  			case "<=":  				newComparator = Comparator.LessOrEqual;  				break;  			case "&":  				newComparator = Comparator.And;  				break;  			case "|":  				newComparator = Comparator.Or;  				break;  			default:  				newComparator = Comparator.Equals;  				break;  			}  			filterNode = new BoolExpression (a' newComparator' b);  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  		{  			DebugLocation (98' 4);  			DebugLocation (98' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr195);  			Match (input' TokenTypes.Down' null);  			DebugLocation (98' 12);  			PushFollow (Follow._filterExpr_in_filterExpr199);  			f = filterExpr ();  			PopFollow ();  			DebugLocation (98' 31);  			// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  			int alt6 = 2;  			try {  				DebugEnterSubRule (6);  				try {  					DebugEnterDecision (6' false);  					int LA6_1 = input.LA (1);  					if ((LA6_1 == 24)) {  						alt6 = 1;  					}  				}  				finally {  					DebugExitDecision (6);  				}  				switch (alt6) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  					{  						DebugLocation (98' 31);  						inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (6);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (99' 4);  			FilterTreeNode newNode = f;  			if ((inverse != null ? inverse.Text : default(string)) == "!")  				newNode.ToggleInversed ();  			filterNode = newNode;  		}  		break;  	case 3:  		DebugEnterAlt (3);  		// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  		{  			DebugLocation (105' 4);  			DebugLocation (105' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr216);  			Match (input' TokenTypes.Down' null);  			DebugLocation (105' 12);  			PushFollow (Follow._propertyChain_in_filterExpr219);  			propertyChain (propertySegments);  			PopFollow ();  			DebugLocation (105' 51);  			// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  			int alt7 = 2;  			try {  				DebugEnterSubRule (7);  				try {  					DebugEnterDecision (7' false);  					int LA7_1 = input.LA (1);  					if ((LA7_1 == 31)) {  						alt7 = 1;  					}  				}  				finally {  					DebugExitDecision (7);  				}  				switch (alt7) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  					{  						DebugLocation (105' 51);  						inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (7);  			}  			DebugLocation (105' 60);  			// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  			int alt8 = 2;  			try {  				DebugEnterSubRule (8);  				try {  					DebugEnterDecision (8' false);  					int LA8_1 = input.LA (1);  					if ((LA8_1 == 24)) {  						alt8 = 1;  					}  				}  				finally {  					DebugExitDecision (8);  				}  				switch (alt8) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  					{  						DebugLocation (105' 60);  						not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (8);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (106' 4);  			FilterTreeNode newProperty = new Property (propertySegments);  			if ((inverse != null ? inverse.Text : default(string)) == "?")  				filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  			else {  				if ((not != null ? not.Text : default(string)) == "!")  					newProperty.ToggleInversed ();  				filterNode = newProperty;  			}  		}  		break;  	case 4:  		DebugEnterAlt (4);  		// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  		{  			DebugLocation (116' 4);  			STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  			DebugLocation (117' 4);  			string stringText = (STRING7 != null ? STRING7.Text : default(string));  			stringText = stringText.Substring (1' stringText.Length - 2);  			filterNode = new Value (stringText);  		}  		break;  	case 5:  		DebugEnterAlt (5);  		// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  		{  			DebugLocation (122' 4);  			REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  			DebugLocation (123' 4);  			string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  			regexText = regexText.Substring (1' regexText.Length - 2);  			filterNode = new RegExp (regexText);  		}  		break;  	case 6:  		DebugEnterAlt (6);  		// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  		{  			DebugLocation (128' 4);  			NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  			DebugLocation (129' 4);  			filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  		}  		break;  	case 7:  		DebugEnterAlt (7);  		// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  		{  			DebugLocation (132' 4);  			Match (input' TRUE' Follow._TRUE_in_filterExpr271);  			DebugLocation (133' 4);  			filterNode = new Value (true);  		}  		break;  	case 8:  		DebugEnterAlt (8);  		// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  		{  			DebugLocation (136' 4);  			Match (input' FALSE' Follow._FALSE_in_filterExpr281);  			DebugLocation (137' 4);  			filterNode = new Value (false);  		}  		break;  	case 9:  		DebugEnterAlt (9);  		// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  		{  			DebugLocation (140' 4);  			Match (input' NULL' Follow._NULL_in_filterExpr291);  			DebugLocation (141' 4);  			filterNode = new Value (null);  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("filterExpr"' 6);  	LeaveRule ("filterExpr"' 6);  	LeaveRule_filterExpr ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  	int alt9 = 9;  	try {  		DebugEnterDecision (9' false);  		switch (input.LA (1)) {  		case CHAIN_OPERATOR:  		case COMPARATOR:  			{  				alt9 = 1;  			}  			break;  		case EXPR:  			{  				int LA9_2 = input.LA (2);  				if ((LA9_2 == DOWN)) {  					int LA9_3 = input.LA (3);  					if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  						alt9 = 2;  					}  					else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  						alt9 = 3;  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				else {  					NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  					DebugRecognitionException (nvae);  					throw nvae;  				}  			}  			break;  		case STRING:  			{  				alt9 = 4;  			}  			break;  		case REGEX:  			{  				alt9 = 5;  			}  			break;  		case NUMBER:  			{  				alt9 = 6;  			}  			break;  		case TRUE:  			{  				alt9 = 7;  			}  			break;  		case FALSE:  			{  				alt9 = 8;  			}  			break;  		case NULL:  			{  				alt9 = 9;  			}  			break;  		default: {  			NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  		}  	}  	finally {  		DebugExitDecision (9);  	}  	switch (alt9) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  		{  			DebugLocation (64' 4);  			DebugLocation (64' 6);  			PushFollow (Follow._comparator_in_filterExpr175);  			comparator6 = comparator ();  			PopFollow ();  			Match (input' TokenTypes.Down' null);  			DebugLocation (64' 18);  			PushFollow (Follow._filterExpr_in_filterExpr179);  			a = filterExpr ();  			PopFollow ();  			DebugLocation (64' 31);  			PushFollow (Follow._filterExpr_in_filterExpr183);  			b = filterExpr ();  			PopFollow ();  			Match (input' TokenTypes.Up' null);  			DebugLocation (65' 4);  			Comparator newComparator;  			switch (comparator6) {  			case "=":  				newComparator = Comparator.Equals;  				break;  			case "!=":  				newComparator = Comparator.NotEquals;  				break;  			case ">":  				newComparator = Comparator.Greater;  				break;  			case "<":  				newComparator = Comparator.Less;  				break;  			case ">=":  				newComparator = Comparator.GreaterOrEqual;  				break;  			case "<=":  				newComparator = Comparator.LessOrEqual;  				break;  			case "&":  				newComparator = Comparator.And;  				break;  			case "|":  				newComparator = Comparator.Or;  				break;  			default:  				newComparator = Comparator.Equals;  				break;  			}  			filterNode = new BoolExpression (a' newComparator' b);  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  		{  			DebugLocation (98' 4);  			DebugLocation (98' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr195);  			Match (input' TokenTypes.Down' null);  			DebugLocation (98' 12);  			PushFollow (Follow._filterExpr_in_filterExpr199);  			f = filterExpr ();  			PopFollow ();  			DebugLocation (98' 31);  			// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  			int alt6 = 2;  			try {  				DebugEnterSubRule (6);  				try {  					DebugEnterDecision (6' false);  					int LA6_1 = input.LA (1);  					if ((LA6_1 == 24)) {  						alt6 = 1;  					}  				}  				finally {  					DebugExitDecision (6);  				}  				switch (alt6) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  					{  						DebugLocation (98' 31);  						inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (6);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (99' 4);  			FilterTreeNode newNode = f;  			if ((inverse != null ? inverse.Text : default(string)) == "!")  				newNode.ToggleInversed ();  			filterNode = newNode;  		}  		break;  	case 3:  		DebugEnterAlt (3);  		// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  		{  			DebugLocation (105' 4);  			DebugLocation (105' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr216);  			Match (input' TokenTypes.Down' null);  			DebugLocation (105' 12);  			PushFollow (Follow._propertyChain_in_filterExpr219);  			propertyChain (propertySegments);  			PopFollow ();  			DebugLocation (105' 51);  			// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  			int alt7 = 2;  			try {  				DebugEnterSubRule (7);  				try {  					DebugEnterDecision (7' false);  					int LA7_1 = input.LA (1);  					if ((LA7_1 == 31)) {  						alt7 = 1;  					}  				}  				finally {  					DebugExitDecision (7);  				}  				switch (alt7) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  					{  						DebugLocation (105' 51);  						inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (7);  			}  			DebugLocation (105' 60);  			// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  			int alt8 = 2;  			try {  				DebugEnterSubRule (8);  				try {  					DebugEnterDecision (8' false);  					int LA8_1 = input.LA (1);  					if ((LA8_1 == 24)) {  						alt8 = 1;  					}  				}  				finally {  					DebugExitDecision (8);  				}  				switch (alt8) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  					{  						DebugLocation (105' 60);  						not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (8);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (106' 4);  			FilterTreeNode newProperty = new Property (propertySegments);  			if ((inverse != null ? inverse.Text : default(string)) == "?")  				filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  			else {  				if ((not != null ? not.Text : default(string)) == "!")  					newProperty.ToggleInversed ();  				filterNode = newProperty;  			}  		}  		break;  	case 4:  		DebugEnterAlt (4);  		// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  		{  			DebugLocation (116' 4);  			STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  			DebugLocation (117' 4);  			string stringText = (STRING7 != null ? STRING7.Text : default(string));  			stringText = stringText.Substring (1' stringText.Length - 2);  			filterNode = new Value (stringText);  		}  		break;  	case 5:  		DebugEnterAlt (5);  		// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  		{  			DebugLocation (122' 4);  			REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  			DebugLocation (123' 4);  			string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  			regexText = regexText.Substring (1' regexText.Length - 2);  			filterNode = new RegExp (regexText);  		}  		break;  	case 6:  		DebugEnterAlt (6);  		// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  		{  			DebugLocation (128' 4);  			NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  			DebugLocation (129' 4);  			filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  		}  		break;  	case 7:  		DebugEnterAlt (7);  		// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  		{  			DebugLocation (132' 4);  			Match (input' TRUE' Follow._TRUE_in_filterExpr271);  			DebugLocation (133' 4);  			filterNode = new Value (true);  		}  		break;  	case 8:  		DebugEnterAlt (8);  		// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  		{  			DebugLocation (136' 4);  			Match (input' FALSE' Follow._FALSE_in_filterExpr281);  			DebugLocation (137' 4);  			filterNode = new Value (false);  		}  		break;  	case 9:  		DebugEnterAlt (9);  		// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  		{  			DebugLocation (140' 4);  			Match (input' NULL' Follow._NULL_in_filterExpr291);  			DebugLocation (141' 4);  			filterNode = new Value (null);  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("filterExpr"' 6);  	LeaveRule ("filterExpr"' 6);  	LeaveRule_filterExpr ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  	int alt9 = 9;  	try {  		DebugEnterDecision (9' false);  		switch (input.LA (1)) {  		case CHAIN_OPERATOR:  		case COMPARATOR:  			{  				alt9 = 1;  			}  			break;  		case EXPR:  			{  				int LA9_2 = input.LA (2);  				if ((LA9_2 == DOWN)) {  					int LA9_3 = input.LA (3);  					if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  						alt9 = 2;  					}  					else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  						alt9 = 3;  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				else {  					NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  					DebugRecognitionException (nvae);  					throw nvae;  				}  			}  			break;  		case STRING:  			{  				alt9 = 4;  			}  			break;  		case REGEX:  			{  				alt9 = 5;  			}  			break;  		case NUMBER:  			{  				alt9 = 6;  			}  			break;  		case TRUE:  			{  				alt9 = 7;  			}  			break;  		case FALSE:  			{  				alt9 = 8;  			}  			break;  		case NULL:  			{  				alt9 = 9;  			}  			break;  		default: {  			NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  		}  	}  	finally {  		DebugExitDecision (9);  	}  	switch (alt9) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  		{  			DebugLocation (64' 4);  			DebugLocation (64' 6);  			PushFollow (Follow._comparator_in_filterExpr175);  			comparator6 = comparator ();  			PopFollow ();  			Match (input' TokenTypes.Down' null);  			DebugLocation (64' 18);  			PushFollow (Follow._filterExpr_in_filterExpr179);  			a = filterExpr ();  			PopFollow ();  			DebugLocation (64' 31);  			PushFollow (Follow._filterExpr_in_filterExpr183);  			b = filterExpr ();  			PopFollow ();  			Match (input' TokenTypes.Up' null);  			DebugLocation (65' 4);  			Comparator newComparator;  			switch (comparator6) {  			case "=":  				newComparator = Comparator.Equals;  				break;  			case "!=":  				newComparator = Comparator.NotEquals;  				break;  			case ">":  				newComparator = Comparator.Greater;  				break;  			case "<":  				newComparator = Comparator.Less;  				break;  			case ">=":  				newComparator = Comparator.GreaterOrEqual;  				break;  			case "<=":  				newComparator = Comparator.LessOrEqual;  				break;  			case "&":  				newComparator = Comparator.And;  				break;  			case "|":  				newComparator = Comparator.Or;  				break;  			default:  				newComparator = Comparator.Equals;  				break;  			}  			filterNode = new BoolExpression (a' newComparator' b);  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  		{  			DebugLocation (98' 4);  			DebugLocation (98' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr195);  			Match (input' TokenTypes.Down' null);  			DebugLocation (98' 12);  			PushFollow (Follow._filterExpr_in_filterExpr199);  			f = filterExpr ();  			PopFollow ();  			DebugLocation (98' 31);  			// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  			int alt6 = 2;  			try {  				DebugEnterSubRule (6);  				try {  					DebugEnterDecision (6' false);  					int LA6_1 = input.LA (1);  					if ((LA6_1 == 24)) {  						alt6 = 1;  					}  				}  				finally {  					DebugExitDecision (6);  				}  				switch (alt6) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  					{  						DebugLocation (98' 31);  						inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (6);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (99' 4);  			FilterTreeNode newNode = f;  			if ((inverse != null ? inverse.Text : default(string)) == "!")  				newNode.ToggleInversed ();  			filterNode = newNode;  		}  		break;  	case 3:  		DebugEnterAlt (3);  		// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  		{  			DebugLocation (105' 4);  			DebugLocation (105' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr216);  			Match (input' TokenTypes.Down' null);  			DebugLocation (105' 12);  			PushFollow (Follow._propertyChain_in_filterExpr219);  			propertyChain (propertySegments);  			PopFollow ();  			DebugLocation (105' 51);  			// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  			int alt7 = 2;  			try {  				DebugEnterSubRule (7);  				try {  					DebugEnterDecision (7' false);  					int LA7_1 = input.LA (1);  					if ((LA7_1 == 31)) {  						alt7 = 1;  					}  				}  				finally {  					DebugExitDecision (7);  				}  				switch (alt7) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  					{  						DebugLocation (105' 51);  						inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (7);  			}  			DebugLocation (105' 60);  			// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  			int alt8 = 2;  			try {  				DebugEnterSubRule (8);  				try {  					DebugEnterDecision (8' false);  					int LA8_1 = input.LA (1);  					if ((LA8_1 == 24)) {  						alt8 = 1;  					}  				}  				finally {  					DebugExitDecision (8);  				}  				switch (alt8) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  					{  						DebugLocation (105' 60);  						not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (8);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (106' 4);  			FilterTreeNode newProperty = new Property (propertySegments);  			if ((inverse != null ? inverse.Text : default(string)) == "?")  				filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  			else {  				if ((not != null ? not.Text : default(string)) == "!")  					newProperty.ToggleInversed ();  				filterNode = newProperty;  			}  		}  		break;  	case 4:  		DebugEnterAlt (4);  		// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  		{  			DebugLocation (116' 4);  			STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  			DebugLocation (117' 4);  			string stringText = (STRING7 != null ? STRING7.Text : default(string));  			stringText = stringText.Substring (1' stringText.Length - 2);  			filterNode = new Value (stringText);  		}  		break;  	case 5:  		DebugEnterAlt (5);  		// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  		{  			DebugLocation (122' 4);  			REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  			DebugLocation (123' 4);  			string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  			regexText = regexText.Substring (1' regexText.Length - 2);  			filterNode = new RegExp (regexText);  		}  		break;  	case 6:  		DebugEnterAlt (6);  		// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  		{  			DebugLocation (128' 4);  			NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  			DebugLocation (129' 4);  			filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  		}  		break;  	case 7:  		DebugEnterAlt (7);  		// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  		{  			DebugLocation (132' 4);  			Match (input' TRUE' Follow._TRUE_in_filterExpr271);  			DebugLocation (133' 4);  			filterNode = new Value (true);  		}  		break;  	case 8:  		DebugEnterAlt (8);  		// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  		{  			DebugLocation (136' 4);  			Match (input' FALSE' Follow._FALSE_in_filterExpr281);  			DebugLocation (137' 4);  			filterNode = new Value (false);  		}  		break;  	case 9:  		DebugEnterAlt (9);  		// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  		{  			DebugLocation (140' 4);  			Match (input' NULL' Follow._NULL_in_filterExpr291);  			DebugLocation (141' 4);  			filterNode = new Value (null);  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("filterExpr"' 6);  	LeaveRule ("filterExpr"' 6);  	LeaveRule_filterExpr ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  	int alt9 = 9;  	try {  		DebugEnterDecision (9' false);  		switch (input.LA (1)) {  		case CHAIN_OPERATOR:  		case COMPARATOR:  			{  				alt9 = 1;  			}  			break;  		case EXPR:  			{  				int LA9_2 = input.LA (2);  				if ((LA9_2 == DOWN)) {  					int LA9_3 = input.LA (3);  					if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  						alt9 = 2;  					}  					else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  						alt9 = 3;  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				else {  					NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  					DebugRecognitionException (nvae);  					throw nvae;  				}  			}  			break;  		case STRING:  			{  				alt9 = 4;  			}  			break;  		case REGEX:  			{  				alt9 = 5;  			}  			break;  		case NUMBER:  			{  				alt9 = 6;  			}  			break;  		case TRUE:  			{  				alt9 = 7;  			}  			break;  		case FALSE:  			{  				alt9 = 8;  			}  			break;  		case NULL:  			{  				alt9 = 9;  			}  			break;  		default: {  			NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  		}  	}  	finally {  		DebugExitDecision (9);  	}  	switch (alt9) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  		{  			DebugLocation (64' 4);  			DebugLocation (64' 6);  			PushFollow (Follow._comparator_in_filterExpr175);  			comparator6 = comparator ();  			PopFollow ();  			Match (input' TokenTypes.Down' null);  			DebugLocation (64' 18);  			PushFollow (Follow._filterExpr_in_filterExpr179);  			a = filterExpr ();  			PopFollow ();  			DebugLocation (64' 31);  			PushFollow (Follow._filterExpr_in_filterExpr183);  			b = filterExpr ();  			PopFollow ();  			Match (input' TokenTypes.Up' null);  			DebugLocation (65' 4);  			Comparator newComparator;  			switch (comparator6) {  			case "=":  				newComparator = Comparator.Equals;  				break;  			case "!=":  				newComparator = Comparator.NotEquals;  				break;  			case ">":  				newComparator = Comparator.Greater;  				break;  			case "<":  				newComparator = Comparator.Less;  				break;  			case ">=":  				newComparator = Comparator.GreaterOrEqual;  				break;  			case "<=":  				newComparator = Comparator.LessOrEqual;  				break;  			case "&":  				newComparator = Comparator.And;  				break;  			case "|":  				newComparator = Comparator.Or;  				break;  			default:  				newComparator = Comparator.Equals;  				break;  			}  			filterNode = new BoolExpression (a' newComparator' b);  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  		{  			DebugLocation (98' 4);  			DebugLocation (98' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr195);  			Match (input' TokenTypes.Down' null);  			DebugLocation (98' 12);  			PushFollow (Follow._filterExpr_in_filterExpr199);  			f = filterExpr ();  			PopFollow ();  			DebugLocation (98' 31);  			// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  			int alt6 = 2;  			try {  				DebugEnterSubRule (6);  				try {  					DebugEnterDecision (6' false);  					int LA6_1 = input.LA (1);  					if ((LA6_1 == 24)) {  						alt6 = 1;  					}  				}  				finally {  					DebugExitDecision (6);  				}  				switch (alt6) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  					{  						DebugLocation (98' 31);  						inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (6);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (99' 4);  			FilterTreeNode newNode = f;  			if ((inverse != null ? inverse.Text : default(string)) == "!")  				newNode.ToggleInversed ();  			filterNode = newNode;  		}  		break;  	case 3:  		DebugEnterAlt (3);  		// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  		{  			DebugLocation (105' 4);  			DebugLocation (105' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr216);  			Match (input' TokenTypes.Down' null);  			DebugLocation (105' 12);  			PushFollow (Follow._propertyChain_in_filterExpr219);  			propertyChain (propertySegments);  			PopFollow ();  			DebugLocation (105' 51);  			// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  			int alt7 = 2;  			try {  				DebugEnterSubRule (7);  				try {  					DebugEnterDecision (7' false);  					int LA7_1 = input.LA (1);  					if ((LA7_1 == 31)) {  						alt7 = 1;  					}  				}  				finally {  					DebugExitDecision (7);  				}  				switch (alt7) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  					{  						DebugLocation (105' 51);  						inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (7);  			}  			DebugLocation (105' 60);  			// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  			int alt8 = 2;  			try {  				DebugEnterSubRule (8);  				try {  					DebugEnterDecision (8' false);  					int LA8_1 = input.LA (1);  					if ((LA8_1 == 24)) {  						alt8 = 1;  					}  				}  				finally {  					DebugExitDecision (8);  				}  				switch (alt8) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  					{  						DebugLocation (105' 60);  						not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (8);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (106' 4);  			FilterTreeNode newProperty = new Property (propertySegments);  			if ((inverse != null ? inverse.Text : default(string)) == "?")  				filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  			else {  				if ((not != null ? not.Text : default(string)) == "!")  					newProperty.ToggleInversed ();  				filterNode = newProperty;  			}  		}  		break;  	case 4:  		DebugEnterAlt (4);  		// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  		{  			DebugLocation (116' 4);  			STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  			DebugLocation (117' 4);  			string stringText = (STRING7 != null ? STRING7.Text : default(string));  			stringText = stringText.Substring (1' stringText.Length - 2);  			filterNode = new Value (stringText);  		}  		break;  	case 5:  		DebugEnterAlt (5);  		// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  		{  			DebugLocation (122' 4);  			REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  			DebugLocation (123' 4);  			string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  			regexText = regexText.Substring (1' regexText.Length - 2);  			filterNode = new RegExp (regexText);  		}  		break;  	case 6:  		DebugEnterAlt (6);  		// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  		{  			DebugLocation (128' 4);  			NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  			DebugLocation (129' 4);  			filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  		}  		break;  	case 7:  		DebugEnterAlt (7);  		// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  		{  			DebugLocation (132' 4);  			Match (input' TRUE' Follow._TRUE_in_filterExpr271);  			DebugLocation (133' 4);  			filterNode = new Value (true);  		}  		break;  	case 8:  		DebugEnterAlt (8);  		// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  		{  			DebugLocation (136' 4);  			Match (input' FALSE' Follow._FALSE_in_filterExpr281);  			DebugLocation (137' 4);  			filterNode = new Value (false);  		}  		break;  	case 9:  		DebugEnterAlt (9);  		// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  		{  			DebugLocation (140' 4);  			Match (input' NULL' Follow._NULL_in_filterExpr291);  			DebugLocation (141' 4);  			filterNode = new Value (null);  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("filterExpr"' 6);  	LeaveRule ("filterExpr"' 6);  	LeaveRule_filterExpr ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  	int alt9 = 9;  	try {  		DebugEnterDecision (9' false);  		switch (input.LA (1)) {  		case CHAIN_OPERATOR:  		case COMPARATOR:  			{  				alt9 = 1;  			}  			break;  		case EXPR:  			{  				int LA9_2 = input.LA (2);  				if ((LA9_2 == DOWN)) {  					int LA9_3 = input.LA (3);  					if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  						alt9 = 2;  					}  					else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  						alt9 = 3;  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				else {  					NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  					DebugRecognitionException (nvae);  					throw nvae;  				}  			}  			break;  		case STRING:  			{  				alt9 = 4;  			}  			break;  		case REGEX:  			{  				alt9 = 5;  			}  			break;  		case NUMBER:  			{  				alt9 = 6;  			}  			break;  		case TRUE:  			{  				alt9 = 7;  			}  			break;  		case FALSE:  			{  				alt9 = 8;  			}  			break;  		case NULL:  			{  				alt9 = 9;  			}  			break;  		default: {  			NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  		}  	}  	finally {  		DebugExitDecision (9);  	}  	switch (alt9) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  		{  			DebugLocation (64' 4);  			DebugLocation (64' 6);  			PushFollow (Follow._comparator_in_filterExpr175);  			comparator6 = comparator ();  			PopFollow ();  			Match (input' TokenTypes.Down' null);  			DebugLocation (64' 18);  			PushFollow (Follow._filterExpr_in_filterExpr179);  			a = filterExpr ();  			PopFollow ();  			DebugLocation (64' 31);  			PushFollow (Follow._filterExpr_in_filterExpr183);  			b = filterExpr ();  			PopFollow ();  			Match (input' TokenTypes.Up' null);  			DebugLocation (65' 4);  			Comparator newComparator;  			switch (comparator6) {  			case "=":  				newComparator = Comparator.Equals;  				break;  			case "!=":  				newComparator = Comparator.NotEquals;  				break;  			case ">":  				newComparator = Comparator.Greater;  				break;  			case "<":  				newComparator = Comparator.Less;  				break;  			case ">=":  				newComparator = Comparator.GreaterOrEqual;  				break;  			case "<=":  				newComparator = Comparator.LessOrEqual;  				break;  			case "&":  				newComparator = Comparator.And;  				break;  			case "|":  				newComparator = Comparator.Or;  				break;  			default:  				newComparator = Comparator.Equals;  				break;  			}  			filterNode = new BoolExpression (a' newComparator' b);  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  		{  			DebugLocation (98' 4);  			DebugLocation (98' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr195);  			Match (input' TokenTypes.Down' null);  			DebugLocation (98' 12);  			PushFollow (Follow._filterExpr_in_filterExpr199);  			f = filterExpr ();  			PopFollow ();  			DebugLocation (98' 31);  			// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  			int alt6 = 2;  			try {  				DebugEnterSubRule (6);  				try {  					DebugEnterDecision (6' false);  					int LA6_1 = input.LA (1);  					if ((LA6_1 == 24)) {  						alt6 = 1;  					}  				}  				finally {  					DebugExitDecision (6);  				}  				switch (alt6) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  					{  						DebugLocation (98' 31);  						inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (6);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (99' 4);  			FilterTreeNode newNode = f;  			if ((inverse != null ? inverse.Text : default(string)) == "!")  				newNode.ToggleInversed ();  			filterNode = newNode;  		}  		break;  	case 3:  		DebugEnterAlt (3);  		// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  		{  			DebugLocation (105' 4);  			DebugLocation (105' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr216);  			Match (input' TokenTypes.Down' null);  			DebugLocation (105' 12);  			PushFollow (Follow._propertyChain_in_filterExpr219);  			propertyChain (propertySegments);  			PopFollow ();  			DebugLocation (105' 51);  			// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  			int alt7 = 2;  			try {  				DebugEnterSubRule (7);  				try {  					DebugEnterDecision (7' false);  					int LA7_1 = input.LA (1);  					if ((LA7_1 == 31)) {  						alt7 = 1;  					}  				}  				finally {  					DebugExitDecision (7);  				}  				switch (alt7) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  					{  						DebugLocation (105' 51);  						inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (7);  			}  			DebugLocation (105' 60);  			// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  			int alt8 = 2;  			try {  				DebugEnterSubRule (8);  				try {  					DebugEnterDecision (8' false);  					int LA8_1 = input.LA (1);  					if ((LA8_1 == 24)) {  						alt8 = 1;  					}  				}  				finally {  					DebugExitDecision (8);  				}  				switch (alt8) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  					{  						DebugLocation (105' 60);  						not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (8);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (106' 4);  			FilterTreeNode newProperty = new Property (propertySegments);  			if ((inverse != null ? inverse.Text : default(string)) == "?")  				filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  			else {  				if ((not != null ? not.Text : default(string)) == "!")  					newProperty.ToggleInversed ();  				filterNode = newProperty;  			}  		}  		break;  	case 4:  		DebugEnterAlt (4);  		// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  		{  			DebugLocation (116' 4);  			STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  			DebugLocation (117' 4);  			string stringText = (STRING7 != null ? STRING7.Text : default(string));  			stringText = stringText.Substring (1' stringText.Length - 2);  			filterNode = new Value (stringText);  		}  		break;  	case 5:  		DebugEnterAlt (5);  		// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  		{  			DebugLocation (122' 4);  			REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  			DebugLocation (123' 4);  			string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  			regexText = regexText.Substring (1' regexText.Length - 2);  			filterNode = new RegExp (regexText);  		}  		break;  	case 6:  		DebugEnterAlt (6);  		// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  		{  			DebugLocation (128' 4);  			NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  			DebugLocation (129' 4);  			filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  		}  		break;  	case 7:  		DebugEnterAlt (7);  		// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  		{  			DebugLocation (132' 4);  			Match (input' TRUE' Follow._TRUE_in_filterExpr271);  			DebugLocation (133' 4);  			filterNode = new Value (true);  		}  		break;  	case 8:  		DebugEnterAlt (8);  		// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  		{  			DebugLocation (136' 4);  			Match (input' FALSE' Follow._FALSE_in_filterExpr281);  			DebugLocation (137' 4);  			filterNode = new Value (false);  		}  		break;  	case 9:  		DebugEnterAlt (9);  		// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  		{  			DebugLocation (140' 4);  			Match (input' NULL' Follow._NULL_in_filterExpr291);  			DebugLocation (141' 4);  			filterNode = new Value (null);  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("filterExpr"' 6);  	LeaveRule ("filterExpr"' 6);  	LeaveRule_filterExpr ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  	int alt9 = 9;  	try {  		DebugEnterDecision (9' false);  		switch (input.LA (1)) {  		case CHAIN_OPERATOR:  		case COMPARATOR:  			{  				alt9 = 1;  			}  			break;  		case EXPR:  			{  				int LA9_2 = input.LA (2);  				if ((LA9_2 == DOWN)) {  					int LA9_3 = input.LA (3);  					if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  						alt9 = 2;  					}  					else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  						alt9 = 3;  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				else {  					NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  					DebugRecognitionException (nvae);  					throw nvae;  				}  			}  			break;  		case STRING:  			{  				alt9 = 4;  			}  			break;  		case REGEX:  			{  				alt9 = 5;  			}  			break;  		case NUMBER:  			{  				alt9 = 6;  			}  			break;  		case TRUE:  			{  				alt9 = 7;  			}  			break;  		case FALSE:  			{  				alt9 = 8;  			}  			break;  		case NULL:  			{  				alt9 = 9;  			}  			break;  		default: {  			NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  		}  	}  	finally {  		DebugExitDecision (9);  	}  	switch (alt9) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  		{  			DebugLocation (64' 4);  			DebugLocation (64' 6);  			PushFollow (Follow._comparator_in_filterExpr175);  			comparator6 = comparator ();  			PopFollow ();  			Match (input' TokenTypes.Down' null);  			DebugLocation (64' 18);  			PushFollow (Follow._filterExpr_in_filterExpr179);  			a = filterExpr ();  			PopFollow ();  			DebugLocation (64' 31);  			PushFollow (Follow._filterExpr_in_filterExpr183);  			b = filterExpr ();  			PopFollow ();  			Match (input' TokenTypes.Up' null);  			DebugLocation (65' 4);  			Comparator newComparator;  			switch (comparator6) {  			case "=":  				newComparator = Comparator.Equals;  				break;  			case "!=":  				newComparator = Comparator.NotEquals;  				break;  			case ">":  				newComparator = Comparator.Greater;  				break;  			case "<":  				newComparator = Comparator.Less;  				break;  			case ">=":  				newComparator = Comparator.GreaterOrEqual;  				break;  			case "<=":  				newComparator = Comparator.LessOrEqual;  				break;  			case "&":  				newComparator = Comparator.And;  				break;  			case "|":  				newComparator = Comparator.Or;  				break;  			default:  				newComparator = Comparator.Equals;  				break;  			}  			filterNode = new BoolExpression (a' newComparator' b);  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  		{  			DebugLocation (98' 4);  			DebugLocation (98' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr195);  			Match (input' TokenTypes.Down' null);  			DebugLocation (98' 12);  			PushFollow (Follow._filterExpr_in_filterExpr199);  			f = filterExpr ();  			PopFollow ();  			DebugLocation (98' 31);  			// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  			int alt6 = 2;  			try {  				DebugEnterSubRule (6);  				try {  					DebugEnterDecision (6' false);  					int LA6_1 = input.LA (1);  					if ((LA6_1 == 24)) {  						alt6 = 1;  					}  				}  				finally {  					DebugExitDecision (6);  				}  				switch (alt6) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  					{  						DebugLocation (98' 31);  						inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (6);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (99' 4);  			FilterTreeNode newNode = f;  			if ((inverse != null ? inverse.Text : default(string)) == "!")  				newNode.ToggleInversed ();  			filterNode = newNode;  		}  		break;  	case 3:  		DebugEnterAlt (3);  		// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  		{  			DebugLocation (105' 4);  			DebugLocation (105' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr216);  			Match (input' TokenTypes.Down' null);  			DebugLocation (105' 12);  			PushFollow (Follow._propertyChain_in_filterExpr219);  			propertyChain (propertySegments);  			PopFollow ();  			DebugLocation (105' 51);  			// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  			int alt7 = 2;  			try {  				DebugEnterSubRule (7);  				try {  					DebugEnterDecision (7' false);  					int LA7_1 = input.LA (1);  					if ((LA7_1 == 31)) {  						alt7 = 1;  					}  				}  				finally {  					DebugExitDecision (7);  				}  				switch (alt7) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  					{  						DebugLocation (105' 51);  						inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (7);  			}  			DebugLocation (105' 60);  			// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  			int alt8 = 2;  			try {  				DebugEnterSubRule (8);  				try {  					DebugEnterDecision (8' false);  					int LA8_1 = input.LA (1);  					if ((LA8_1 == 24)) {  						alt8 = 1;  					}  				}  				finally {  					DebugExitDecision (8);  				}  				switch (alt8) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  					{  						DebugLocation (105' 60);  						not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (8);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (106' 4);  			FilterTreeNode newProperty = new Property (propertySegments);  			if ((inverse != null ? inverse.Text : default(string)) == "?")  				filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  			else {  				if ((not != null ? not.Text : default(string)) == "!")  					newProperty.ToggleInversed ();  				filterNode = newProperty;  			}  		}  		break;  	case 4:  		DebugEnterAlt (4);  		// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  		{  			DebugLocation (116' 4);  			STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  			DebugLocation (117' 4);  			string stringText = (STRING7 != null ? STRING7.Text : default(string));  			stringText = stringText.Substring (1' stringText.Length - 2);  			filterNode = new Value (stringText);  		}  		break;  	case 5:  		DebugEnterAlt (5);  		// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  		{  			DebugLocation (122' 4);  			REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  			DebugLocation (123' 4);  			string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  			regexText = regexText.Substring (1' regexText.Length - 2);  			filterNode = new RegExp (regexText);  		}  		break;  	case 6:  		DebugEnterAlt (6);  		// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  		{  			DebugLocation (128' 4);  			NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  			DebugLocation (129' 4);  			filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  		}  		break;  	case 7:  		DebugEnterAlt (7);  		// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  		{  			DebugLocation (132' 4);  			Match (input' TRUE' Follow._TRUE_in_filterExpr271);  			DebugLocation (133' 4);  			filterNode = new Value (true);  		}  		break;  	case 8:  		DebugEnterAlt (8);  		// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  		{  			DebugLocation (136' 4);  			Match (input' FALSE' Follow._FALSE_in_filterExpr281);  			DebugLocation (137' 4);  			filterNode = new Value (false);  		}  		break;  	case 9:  		DebugEnterAlt (9);  		// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  		{  			DebugLocation (140' 4);  			Match (input' NULL' Follow._NULL_in_filterExpr291);  			DebugLocation (141' 4);  			filterNode = new Value (null);  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("filterExpr"' 6);  	LeaveRule ("filterExpr"' 6);  	LeaveRule_filterExpr ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  	int alt9 = 9;  	try {  		DebugEnterDecision (9' false);  		switch (input.LA (1)) {  		case CHAIN_OPERATOR:  		case COMPARATOR:  			{  				alt9 = 1;  			}  			break;  		case EXPR:  			{  				int LA9_2 = input.LA (2);  				if ((LA9_2 == DOWN)) {  					int LA9_3 = input.LA (3);  					if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  						alt9 = 2;  					}  					else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  						alt9 = 3;  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				else {  					NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  					DebugRecognitionException (nvae);  					throw nvae;  				}  			}  			break;  		case STRING:  			{  				alt9 = 4;  			}  			break;  		case REGEX:  			{  				alt9 = 5;  			}  			break;  		case NUMBER:  			{  				alt9 = 6;  			}  			break;  		case TRUE:  			{  				alt9 = 7;  			}  			break;  		case FALSE:  			{  				alt9 = 8;  			}  			break;  		case NULL:  			{  				alt9 = 9;  			}  			break;  		default: {  			NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  		}  	}  	finally {  		DebugExitDecision (9);  	}  	switch (alt9) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  		{  			DebugLocation (64' 4);  			DebugLocation (64' 6);  			PushFollow (Follow._comparator_in_filterExpr175);  			comparator6 = comparator ();  			PopFollow ();  			Match (input' TokenTypes.Down' null);  			DebugLocation (64' 18);  			PushFollow (Follow._filterExpr_in_filterExpr179);  			a = filterExpr ();  			PopFollow ();  			DebugLocation (64' 31);  			PushFollow (Follow._filterExpr_in_filterExpr183);  			b = filterExpr ();  			PopFollow ();  			Match (input' TokenTypes.Up' null);  			DebugLocation (65' 4);  			Comparator newComparator;  			switch (comparator6) {  			case "=":  				newComparator = Comparator.Equals;  				break;  			case "!=":  				newComparator = Comparator.NotEquals;  				break;  			case ">":  				newComparator = Comparator.Greater;  				break;  			case "<":  				newComparator = Comparator.Less;  				break;  			case ">=":  				newComparator = Comparator.GreaterOrEqual;  				break;  			case "<=":  				newComparator = Comparator.LessOrEqual;  				break;  			case "&":  				newComparator = Comparator.And;  				break;  			case "|":  				newComparator = Comparator.Or;  				break;  			default:  				newComparator = Comparator.Equals;  				break;  			}  			filterNode = new BoolExpression (a' newComparator' b);  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  		{  			DebugLocation (98' 4);  			DebugLocation (98' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr195);  			Match (input' TokenTypes.Down' null);  			DebugLocation (98' 12);  			PushFollow (Follow._filterExpr_in_filterExpr199);  			f = filterExpr ();  			PopFollow ();  			DebugLocation (98' 31);  			// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  			int alt6 = 2;  			try {  				DebugEnterSubRule (6);  				try {  					DebugEnterDecision (6' false);  					int LA6_1 = input.LA (1);  					if ((LA6_1 == 24)) {  						alt6 = 1;  					}  				}  				finally {  					DebugExitDecision (6);  				}  				switch (alt6) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  					{  						DebugLocation (98' 31);  						inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (6);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (99' 4);  			FilterTreeNode newNode = f;  			if ((inverse != null ? inverse.Text : default(string)) == "!")  				newNode.ToggleInversed ();  			filterNode = newNode;  		}  		break;  	case 3:  		DebugEnterAlt (3);  		// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  		{  			DebugLocation (105' 4);  			DebugLocation (105' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr216);  			Match (input' TokenTypes.Down' null);  			DebugLocation (105' 12);  			PushFollow (Follow._propertyChain_in_filterExpr219);  			propertyChain (propertySegments);  			PopFollow ();  			DebugLocation (105' 51);  			// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  			int alt7 = 2;  			try {  				DebugEnterSubRule (7);  				try {  					DebugEnterDecision (7' false);  					int LA7_1 = input.LA (1);  					if ((LA7_1 == 31)) {  						alt7 = 1;  					}  				}  				finally {  					DebugExitDecision (7);  				}  				switch (alt7) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  					{  						DebugLocation (105' 51);  						inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (7);  			}  			DebugLocation (105' 60);  			// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  			int alt8 = 2;  			try {  				DebugEnterSubRule (8);  				try {  					DebugEnterDecision (8' false);  					int LA8_1 = input.LA (1);  					if ((LA8_1 == 24)) {  						alt8 = 1;  					}  				}  				finally {  					DebugExitDecision (8);  				}  				switch (alt8) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  					{  						DebugLocation (105' 60);  						not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (8);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (106' 4);  			FilterTreeNode newProperty = new Property (propertySegments);  			if ((inverse != null ? inverse.Text : default(string)) == "?")  				filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  			else {  				if ((not != null ? not.Text : default(string)) == "!")  					newProperty.ToggleInversed ();  				filterNode = newProperty;  			}  		}  		break;  	case 4:  		DebugEnterAlt (4);  		// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  		{  			DebugLocation (116' 4);  			STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  			DebugLocation (117' 4);  			string stringText = (STRING7 != null ? STRING7.Text : default(string));  			stringText = stringText.Substring (1' stringText.Length - 2);  			filterNode = new Value (stringText);  		}  		break;  	case 5:  		DebugEnterAlt (5);  		// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  		{  			DebugLocation (122' 4);  			REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  			DebugLocation (123' 4);  			string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  			regexText = regexText.Substring (1' regexText.Length - 2);  			filterNode = new RegExp (regexText);  		}  		break;  	case 6:  		DebugEnterAlt (6);  		// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  		{  			DebugLocation (128' 4);  			NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  			DebugLocation (129' 4);  			filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  		}  		break;  	case 7:  		DebugEnterAlt (7);  		// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  		{  			DebugLocation (132' 4);  			Match (input' TRUE' Follow._TRUE_in_filterExpr271);  			DebugLocation (133' 4);  			filterNode = new Value (true);  		}  		break;  	case 8:  		DebugEnterAlt (8);  		// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  		{  			DebugLocation (136' 4);  			Match (input' FALSE' Follow._FALSE_in_filterExpr281);  			DebugLocation (137' 4);  			filterNode = new Value (false);  		}  		break;  	case 9:  		DebugEnterAlt (9);  		// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  		{  			DebugLocation (140' 4);  			Match (input' NULL' Follow._NULL_in_filterExpr291);  			DebugLocation (141' 4);  			filterNode = new Value (null);  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("filterExpr"' 6);  	LeaveRule ("filterExpr"' 6);  	LeaveRule_filterExpr ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  	int alt9 = 9;  	try {  		DebugEnterDecision (9' false);  		switch (input.LA (1)) {  		case CHAIN_OPERATOR:  		case COMPARATOR:  			{  				alt9 = 1;  			}  			break;  		case EXPR:  			{  				int LA9_2 = input.LA (2);  				if ((LA9_2 == DOWN)) {  					int LA9_3 = input.LA (3);  					if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  						alt9 = 2;  					}  					else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  						alt9 = 3;  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				else {  					NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  					DebugRecognitionException (nvae);  					throw nvae;  				}  			}  			break;  		case STRING:  			{  				alt9 = 4;  			}  			break;  		case REGEX:  			{  				alt9 = 5;  			}  			break;  		case NUMBER:  			{  				alt9 = 6;  			}  			break;  		case TRUE:  			{  				alt9 = 7;  			}  			break;  		case FALSE:  			{  				alt9 = 8;  			}  			break;  		case NULL:  			{  				alt9 = 9;  			}  			break;  		default: {  			NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  		}  	}  	finally {  		DebugExitDecision (9);  	}  	switch (alt9) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  		{  			DebugLocation (64' 4);  			DebugLocation (64' 6);  			PushFollow (Follow._comparator_in_filterExpr175);  			comparator6 = comparator ();  			PopFollow ();  			Match (input' TokenTypes.Down' null);  			DebugLocation (64' 18);  			PushFollow (Follow._filterExpr_in_filterExpr179);  			a = filterExpr ();  			PopFollow ();  			DebugLocation (64' 31);  			PushFollow (Follow._filterExpr_in_filterExpr183);  			b = filterExpr ();  			PopFollow ();  			Match (input' TokenTypes.Up' null);  			DebugLocation (65' 4);  			Comparator newComparator;  			switch (comparator6) {  			case "=":  				newComparator = Comparator.Equals;  				break;  			case "!=":  				newComparator = Comparator.NotEquals;  				break;  			case ">":  				newComparator = Comparator.Greater;  				break;  			case "<":  				newComparator = Comparator.Less;  				break;  			case ">=":  				newComparator = Comparator.GreaterOrEqual;  				break;  			case "<=":  				newComparator = Comparator.LessOrEqual;  				break;  			case "&":  				newComparator = Comparator.And;  				break;  			case "|":  				newComparator = Comparator.Or;  				break;  			default:  				newComparator = Comparator.Equals;  				break;  			}  			filterNode = new BoolExpression (a' newComparator' b);  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  		{  			DebugLocation (98' 4);  			DebugLocation (98' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr195);  			Match (input' TokenTypes.Down' null);  			DebugLocation (98' 12);  			PushFollow (Follow._filterExpr_in_filterExpr199);  			f = filterExpr ();  			PopFollow ();  			DebugLocation (98' 31);  			// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  			int alt6 = 2;  			try {  				DebugEnterSubRule (6);  				try {  					DebugEnterDecision (6' false);  					int LA6_1 = input.LA (1);  					if ((LA6_1 == 24)) {  						alt6 = 1;  					}  				}  				finally {  					DebugExitDecision (6);  				}  				switch (alt6) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  					{  						DebugLocation (98' 31);  						inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (6);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (99' 4);  			FilterTreeNode newNode = f;  			if ((inverse != null ? inverse.Text : default(string)) == "!")  				newNode.ToggleInversed ();  			filterNode = newNode;  		}  		break;  	case 3:  		DebugEnterAlt (3);  		// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  		{  			DebugLocation (105' 4);  			DebugLocation (105' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr216);  			Match (input' TokenTypes.Down' null);  			DebugLocation (105' 12);  			PushFollow (Follow._propertyChain_in_filterExpr219);  			propertyChain (propertySegments);  			PopFollow ();  			DebugLocation (105' 51);  			// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  			int alt7 = 2;  			try {  				DebugEnterSubRule (7);  				try {  					DebugEnterDecision (7' false);  					int LA7_1 = input.LA (1);  					if ((LA7_1 == 31)) {  						alt7 = 1;  					}  				}  				finally {  					DebugExitDecision (7);  				}  				switch (alt7) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  					{  						DebugLocation (105' 51);  						inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (7);  			}  			DebugLocation (105' 60);  			// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  			int alt8 = 2;  			try {  				DebugEnterSubRule (8);  				try {  					DebugEnterDecision (8' false);  					int LA8_1 = input.LA (1);  					if ((LA8_1 == 24)) {  						alt8 = 1;  					}  				}  				finally {  					DebugExitDecision (8);  				}  				switch (alt8) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  					{  						DebugLocation (105' 60);  						not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (8);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (106' 4);  			FilterTreeNode newProperty = new Property (propertySegments);  			if ((inverse != null ? inverse.Text : default(string)) == "?")  				filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  			else {  				if ((not != null ? not.Text : default(string)) == "!")  					newProperty.ToggleInversed ();  				filterNode = newProperty;  			}  		}  		break;  	case 4:  		DebugEnterAlt (4);  		// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  		{  			DebugLocation (116' 4);  			STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  			DebugLocation (117' 4);  			string stringText = (STRING7 != null ? STRING7.Text : default(string));  			stringText = stringText.Substring (1' stringText.Length - 2);  			filterNode = new Value (stringText);  		}  		break;  	case 5:  		DebugEnterAlt (5);  		// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  		{  			DebugLocation (122' 4);  			REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  			DebugLocation (123' 4);  			string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  			regexText = regexText.Substring (1' regexText.Length - 2);  			filterNode = new RegExp (regexText);  		}  		break;  	case 6:  		DebugEnterAlt (6);  		// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  		{  			DebugLocation (128' 4);  			NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  			DebugLocation (129' 4);  			filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  		}  		break;  	case 7:  		DebugEnterAlt (7);  		// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  		{  			DebugLocation (132' 4);  			Match (input' TRUE' Follow._TRUE_in_filterExpr271);  			DebugLocation (133' 4);  			filterNode = new Value (true);  		}  		break;  	case 8:  		DebugEnterAlt (8);  		// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  		{  			DebugLocation (136' 4);  			Match (input' FALSE' Follow._FALSE_in_filterExpr281);  			DebugLocation (137' 4);  			filterNode = new Value (false);  		}  		break;  	case 9:  		DebugEnterAlt (9);  		// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  		{  			DebugLocation (140' 4);  			Match (input' NULL' Follow._NULL_in_filterExpr291);  			DebugLocation (141' 4);  			filterNode = new Value (null);  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("filterExpr"' 6);  	LeaveRule ("filterExpr"' 6);  	LeaveRule_filterExpr ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  	int alt9 = 9;  	try {  		DebugEnterDecision (9' false);  		switch (input.LA (1)) {  		case CHAIN_OPERATOR:  		case COMPARATOR:  			{  				alt9 = 1;  			}  			break;  		case EXPR:  			{  				int LA9_2 = input.LA (2);  				if ((LA9_2 == DOWN)) {  					int LA9_3 = input.LA (3);  					if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  						alt9 = 2;  					}  					else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  						alt9 = 3;  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				else {  					NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  					DebugRecognitionException (nvae);  					throw nvae;  				}  			}  			break;  		case STRING:  			{  				alt9 = 4;  			}  			break;  		case REGEX:  			{  				alt9 = 5;  			}  			break;  		case NUMBER:  			{  				alt9 = 6;  			}  			break;  		case TRUE:  			{  				alt9 = 7;  			}  			break;  		case FALSE:  			{  				alt9 = 8;  			}  			break;  		case NULL:  			{  				alt9 = 9;  			}  			break;  		default: {  			NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  		}  	}  	finally {  		DebugExitDecision (9);  	}  	switch (alt9) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  		{  			DebugLocation (64' 4);  			DebugLocation (64' 6);  			PushFollow (Follow._comparator_in_filterExpr175);  			comparator6 = comparator ();  			PopFollow ();  			Match (input' TokenTypes.Down' null);  			DebugLocation (64' 18);  			PushFollow (Follow._filterExpr_in_filterExpr179);  			a = filterExpr ();  			PopFollow ();  			DebugLocation (64' 31);  			PushFollow (Follow._filterExpr_in_filterExpr183);  			b = filterExpr ();  			PopFollow ();  			Match (input' TokenTypes.Up' null);  			DebugLocation (65' 4);  			Comparator newComparator;  			switch (comparator6) {  			case "=":  				newComparator = Comparator.Equals;  				break;  			case "!=":  				newComparator = Comparator.NotEquals;  				break;  			case ">":  				newComparator = Comparator.Greater;  				break;  			case "<":  				newComparator = Comparator.Less;  				break;  			case ">=":  				newComparator = Comparator.GreaterOrEqual;  				break;  			case "<=":  				newComparator = Comparator.LessOrEqual;  				break;  			case "&":  				newComparator = Comparator.And;  				break;  			case "|":  				newComparator = Comparator.Or;  				break;  			default:  				newComparator = Comparator.Equals;  				break;  			}  			filterNode = new BoolExpression (a' newComparator' b);  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  		{  			DebugLocation (98' 4);  			DebugLocation (98' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr195);  			Match (input' TokenTypes.Down' null);  			DebugLocation (98' 12);  			PushFollow (Follow._filterExpr_in_filterExpr199);  			f = filterExpr ();  			PopFollow ();  			DebugLocation (98' 31);  			// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  			int alt6 = 2;  			try {  				DebugEnterSubRule (6);  				try {  					DebugEnterDecision (6' false);  					int LA6_1 = input.LA (1);  					if ((LA6_1 == 24)) {  						alt6 = 1;  					}  				}  				finally {  					DebugExitDecision (6);  				}  				switch (alt6) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  					{  						DebugLocation (98' 31);  						inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (6);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (99' 4);  			FilterTreeNode newNode = f;  			if ((inverse != null ? inverse.Text : default(string)) == "!")  				newNode.ToggleInversed ();  			filterNode = newNode;  		}  		break;  	case 3:  		DebugEnterAlt (3);  		// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  		{  			DebugLocation (105' 4);  			DebugLocation (105' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr216);  			Match (input' TokenTypes.Down' null);  			DebugLocation (105' 12);  			PushFollow (Follow._propertyChain_in_filterExpr219);  			propertyChain (propertySegments);  			PopFollow ();  			DebugLocation (105' 51);  			// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  			int alt7 = 2;  			try {  				DebugEnterSubRule (7);  				try {  					DebugEnterDecision (7' false);  					int LA7_1 = input.LA (1);  					if ((LA7_1 == 31)) {  						alt7 = 1;  					}  				}  				finally {  					DebugExitDecision (7);  				}  				switch (alt7) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  					{  						DebugLocation (105' 51);  						inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (7);  			}  			DebugLocation (105' 60);  			// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  			int alt8 = 2;  			try {  				DebugEnterSubRule (8);  				try {  					DebugEnterDecision (8' false);  					int LA8_1 = input.LA (1);  					if ((LA8_1 == 24)) {  						alt8 = 1;  					}  				}  				finally {  					DebugExitDecision (8);  				}  				switch (alt8) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  					{  						DebugLocation (105' 60);  						not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (8);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (106' 4);  			FilterTreeNode newProperty = new Property (propertySegments);  			if ((inverse != null ? inverse.Text : default(string)) == "?")  				filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  			else {  				if ((not != null ? not.Text : default(string)) == "!")  					newProperty.ToggleInversed ();  				filterNode = newProperty;  			}  		}  		break;  	case 4:  		DebugEnterAlt (4);  		// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  		{  			DebugLocation (116' 4);  			STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  			DebugLocation (117' 4);  			string stringText = (STRING7 != null ? STRING7.Text : default(string));  			stringText = stringText.Substring (1' stringText.Length - 2);  			filterNode = new Value (stringText);  		}  		break;  	case 5:  		DebugEnterAlt (5);  		// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  		{  			DebugLocation (122' 4);  			REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  			DebugLocation (123' 4);  			string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  			regexText = regexText.Substring (1' regexText.Length - 2);  			filterNode = new RegExp (regexText);  		}  		break;  	case 6:  		DebugEnterAlt (6);  		// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  		{  			DebugLocation (128' 4);  			NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  			DebugLocation (129' 4);  			filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  		}  		break;  	case 7:  		DebugEnterAlt (7);  		// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  		{  			DebugLocation (132' 4);  			Match (input' TRUE' Follow._TRUE_in_filterExpr271);  			DebugLocation (133' 4);  			filterNode = new Value (true);  		}  		break;  	case 8:  		DebugEnterAlt (8);  		// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  		{  			DebugLocation (136' 4);  			Match (input' FALSE' Follow._FALSE_in_filterExpr281);  			DebugLocation (137' 4);  			filterNode = new Value (false);  		}  		break;  	case 9:  		DebugEnterAlt (9);  		// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  		{  			DebugLocation (140' 4);  			Match (input' NULL' Follow._NULL_in_filterExpr291);  			DebugLocation (141' 4);  			filterNode = new Value (null);  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("filterExpr"' 6);  	LeaveRule ("filterExpr"' 6);  	LeaveRule_filterExpr ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  	int alt9 = 9;  	try {  		DebugEnterDecision (9' false);  		switch (input.LA (1)) {  		case CHAIN_OPERATOR:  		case COMPARATOR:  			{  				alt9 = 1;  			}  			break;  		case EXPR:  			{  				int LA9_2 = input.LA (2);  				if ((LA9_2 == DOWN)) {  					int LA9_3 = input.LA (3);  					if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  						alt9 = 2;  					}  					else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  						alt9 = 3;  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				else {  					NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  					DebugRecognitionException (nvae);  					throw nvae;  				}  			}  			break;  		case STRING:  			{  				alt9 = 4;  			}  			break;  		case REGEX:  			{  				alt9 = 5;  			}  			break;  		case NUMBER:  			{  				alt9 = 6;  			}  			break;  		case TRUE:  			{  				alt9 = 7;  			}  			break;  		case FALSE:  			{  				alt9 = 8;  			}  			break;  		case NULL:  			{  				alt9 = 9;  			}  			break;  		default: {  			NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  		}  	}  	finally {  		DebugExitDecision (9);  	}  	switch (alt9) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  		{  			DebugLocation (64' 4);  			DebugLocation (64' 6);  			PushFollow (Follow._comparator_in_filterExpr175);  			comparator6 = comparator ();  			PopFollow ();  			Match (input' TokenTypes.Down' null);  			DebugLocation (64' 18);  			PushFollow (Follow._filterExpr_in_filterExpr179);  			a = filterExpr ();  			PopFollow ();  			DebugLocation (64' 31);  			PushFollow (Follow._filterExpr_in_filterExpr183);  			b = filterExpr ();  			PopFollow ();  			Match (input' TokenTypes.Up' null);  			DebugLocation (65' 4);  			Comparator newComparator;  			switch (comparator6) {  			case "=":  				newComparator = Comparator.Equals;  				break;  			case "!=":  				newComparator = Comparator.NotEquals;  				break;  			case ">":  				newComparator = Comparator.Greater;  				break;  			case "<":  				newComparator = Comparator.Less;  				break;  			case ">=":  				newComparator = Comparator.GreaterOrEqual;  				break;  			case "<=":  				newComparator = Comparator.LessOrEqual;  				break;  			case "&":  				newComparator = Comparator.And;  				break;  			case "|":  				newComparator = Comparator.Or;  				break;  			default:  				newComparator = Comparator.Equals;  				break;  			}  			filterNode = new BoolExpression (a' newComparator' b);  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  		{  			DebugLocation (98' 4);  			DebugLocation (98' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr195);  			Match (input' TokenTypes.Down' null);  			DebugLocation (98' 12);  			PushFollow (Follow._filterExpr_in_filterExpr199);  			f = filterExpr ();  			PopFollow ();  			DebugLocation (98' 31);  			// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  			int alt6 = 2;  			try {  				DebugEnterSubRule (6);  				try {  					DebugEnterDecision (6' false);  					int LA6_1 = input.LA (1);  					if ((LA6_1 == 24)) {  						alt6 = 1;  					}  				}  				finally {  					DebugExitDecision (6);  				}  				switch (alt6) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  					{  						DebugLocation (98' 31);  						inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (6);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (99' 4);  			FilterTreeNode newNode = f;  			if ((inverse != null ? inverse.Text : default(string)) == "!")  				newNode.ToggleInversed ();  			filterNode = newNode;  		}  		break;  	case 3:  		DebugEnterAlt (3);  		// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  		{  			DebugLocation (105' 4);  			DebugLocation (105' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr216);  			Match (input' TokenTypes.Down' null);  			DebugLocation (105' 12);  			PushFollow (Follow._propertyChain_in_filterExpr219);  			propertyChain (propertySegments);  			PopFollow ();  			DebugLocation (105' 51);  			// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  			int alt7 = 2;  			try {  				DebugEnterSubRule (7);  				try {  					DebugEnterDecision (7' false);  					int LA7_1 = input.LA (1);  					if ((LA7_1 == 31)) {  						alt7 = 1;  					}  				}  				finally {  					DebugExitDecision (7);  				}  				switch (alt7) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  					{  						DebugLocation (105' 51);  						inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (7);  			}  			DebugLocation (105' 60);  			// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  			int alt8 = 2;  			try {  				DebugEnterSubRule (8);  				try {  					DebugEnterDecision (8' false);  					int LA8_1 = input.LA (1);  					if ((LA8_1 == 24)) {  						alt8 = 1;  					}  				}  				finally {  					DebugExitDecision (8);  				}  				switch (alt8) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  					{  						DebugLocation (105' 60);  						not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (8);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (106' 4);  			FilterTreeNode newProperty = new Property (propertySegments);  			if ((inverse != null ? inverse.Text : default(string)) == "?")  				filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  			else {  				if ((not != null ? not.Text : default(string)) == "!")  					newProperty.ToggleInversed ();  				filterNode = newProperty;  			}  		}  		break;  	case 4:  		DebugEnterAlt (4);  		// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  		{  			DebugLocation (116' 4);  			STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  			DebugLocation (117' 4);  			string stringText = (STRING7 != null ? STRING7.Text : default(string));  			stringText = stringText.Substring (1' stringText.Length - 2);  			filterNode = new Value (stringText);  		}  		break;  	case 5:  		DebugEnterAlt (5);  		// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  		{  			DebugLocation (122' 4);  			REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  			DebugLocation (123' 4);  			string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  			regexText = regexText.Substring (1' regexText.Length - 2);  			filterNode = new RegExp (regexText);  		}  		break;  	case 6:  		DebugEnterAlt (6);  		// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  		{  			DebugLocation (128' 4);  			NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  			DebugLocation (129' 4);  			filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  		}  		break;  	case 7:  		DebugEnterAlt (7);  		// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  		{  			DebugLocation (132' 4);  			Match (input' TRUE' Follow._TRUE_in_filterExpr271);  			DebugLocation (133' 4);  			filterNode = new Value (true);  		}  		break;  	case 8:  		DebugEnterAlt (8);  		// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  		{  			DebugLocation (136' 4);  			Match (input' FALSE' Follow._FALSE_in_filterExpr281);  			DebugLocation (137' 4);  			filterNode = new Value (false);  		}  		break;  	case 9:  		DebugEnterAlt (9);  		// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  		{  			DebugLocation (140' 4);  			Match (input' NULL' Follow._NULL_in_filterExpr291);  			DebugLocation (141' 4);  			filterNode = new Value (null);  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("filterExpr"' 6);  	LeaveRule ("filterExpr"' 6);  	LeaveRule_filterExpr ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  	int alt9 = 9;  	try {  		DebugEnterDecision (9' false);  		switch (input.LA (1)) {  		case CHAIN_OPERATOR:  		case COMPARATOR:  			{  				alt9 = 1;  			}  			break;  		case EXPR:  			{  				int LA9_2 = input.LA (2);  				if ((LA9_2 == DOWN)) {  					int LA9_3 = input.LA (3);  					if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  						alt9 = 2;  					}  					else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  						alt9 = 3;  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				else {  					NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  					DebugRecognitionException (nvae);  					throw nvae;  				}  			}  			break;  		case STRING:  			{  				alt9 = 4;  			}  			break;  		case REGEX:  			{  				alt9 = 5;  			}  			break;  		case NUMBER:  			{  				alt9 = 6;  			}  			break;  		case TRUE:  			{  				alt9 = 7;  			}  			break;  		case FALSE:  			{  				alt9 = 8;  			}  			break;  		case NULL:  			{  				alt9 = 9;  			}  			break;  		default: {  			NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  		}  	}  	finally {  		DebugExitDecision (9);  	}  	switch (alt9) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  		{  			DebugLocation (64' 4);  			DebugLocation (64' 6);  			PushFollow (Follow._comparator_in_filterExpr175);  			comparator6 = comparator ();  			PopFollow ();  			Match (input' TokenTypes.Down' null);  			DebugLocation (64' 18);  			PushFollow (Follow._filterExpr_in_filterExpr179);  			a = filterExpr ();  			PopFollow ();  			DebugLocation (64' 31);  			PushFollow (Follow._filterExpr_in_filterExpr183);  			b = filterExpr ();  			PopFollow ();  			Match (input' TokenTypes.Up' null);  			DebugLocation (65' 4);  			Comparator newComparator;  			switch (comparator6) {  			case "=":  				newComparator = Comparator.Equals;  				break;  			case "!=":  				newComparator = Comparator.NotEquals;  				break;  			case ">":  				newComparator = Comparator.Greater;  				break;  			case "<":  				newComparator = Comparator.Less;  				break;  			case ">=":  				newComparator = Comparator.GreaterOrEqual;  				break;  			case "<=":  				newComparator = Comparator.LessOrEqual;  				break;  			case "&":  				newComparator = Comparator.And;  				break;  			case "|":  				newComparator = Comparator.Or;  				break;  			default:  				newComparator = Comparator.Equals;  				break;  			}  			filterNode = new BoolExpression (a' newComparator' b);  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  		{  			DebugLocation (98' 4);  			DebugLocation (98' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr195);  			Match (input' TokenTypes.Down' null);  			DebugLocation (98' 12);  			PushFollow (Follow._filterExpr_in_filterExpr199);  			f = filterExpr ();  			PopFollow ();  			DebugLocation (98' 31);  			// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  			int alt6 = 2;  			try {  				DebugEnterSubRule (6);  				try {  					DebugEnterDecision (6' false);  					int LA6_1 = input.LA (1);  					if ((LA6_1 == 24)) {  						alt6 = 1;  					}  				}  				finally {  					DebugExitDecision (6);  				}  				switch (alt6) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  					{  						DebugLocation (98' 31);  						inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (6);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (99' 4);  			FilterTreeNode newNode = f;  			if ((inverse != null ? inverse.Text : default(string)) == "!")  				newNode.ToggleInversed ();  			filterNode = newNode;  		}  		break;  	case 3:  		DebugEnterAlt (3);  		// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  		{  			DebugLocation (105' 4);  			DebugLocation (105' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr216);  			Match (input' TokenTypes.Down' null);  			DebugLocation (105' 12);  			PushFollow (Follow._propertyChain_in_filterExpr219);  			propertyChain (propertySegments);  			PopFollow ();  			DebugLocation (105' 51);  			// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  			int alt7 = 2;  			try {  				DebugEnterSubRule (7);  				try {  					DebugEnterDecision (7' false);  					int LA7_1 = input.LA (1);  					if ((LA7_1 == 31)) {  						alt7 = 1;  					}  				}  				finally {  					DebugExitDecision (7);  				}  				switch (alt7) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  					{  						DebugLocation (105' 51);  						inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (7);  			}  			DebugLocation (105' 60);  			// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  			int alt8 = 2;  			try {  				DebugEnterSubRule (8);  				try {  					DebugEnterDecision (8' false);  					int LA8_1 = input.LA (1);  					if ((LA8_1 == 24)) {  						alt8 = 1;  					}  				}  				finally {  					DebugExitDecision (8);  				}  				switch (alt8) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  					{  						DebugLocation (105' 60);  						not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (8);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (106' 4);  			FilterTreeNode newProperty = new Property (propertySegments);  			if ((inverse != null ? inverse.Text : default(string)) == "?")  				filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  			else {  				if ((not != null ? not.Text : default(string)) == "!")  					newProperty.ToggleInversed ();  				filterNode = newProperty;  			}  		}  		break;  	case 4:  		DebugEnterAlt (4);  		// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  		{  			DebugLocation (116' 4);  			STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  			DebugLocation (117' 4);  			string stringText = (STRING7 != null ? STRING7.Text : default(string));  			stringText = stringText.Substring (1' stringText.Length - 2);  			filterNode = new Value (stringText);  		}  		break;  	case 5:  		DebugEnterAlt (5);  		// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  		{  			DebugLocation (122' 4);  			REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  			DebugLocation (123' 4);  			string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  			regexText = regexText.Substring (1' regexText.Length - 2);  			filterNode = new RegExp (regexText);  		}  		break;  	case 6:  		DebugEnterAlt (6);  		// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  		{  			DebugLocation (128' 4);  			NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  			DebugLocation (129' 4);  			filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  		}  		break;  	case 7:  		DebugEnterAlt (7);  		// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  		{  			DebugLocation (132' 4);  			Match (input' TRUE' Follow._TRUE_in_filterExpr271);  			DebugLocation (133' 4);  			filterNode = new Value (true);  		}  		break;  	case 8:  		DebugEnterAlt (8);  		// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  		{  			DebugLocation (136' 4);  			Match (input' FALSE' Follow._FALSE_in_filterExpr281);  			DebugLocation (137' 4);  			filterNode = new Value (false);  		}  		break;  	case 9:  		DebugEnterAlt (9);  		// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  		{  			DebugLocation (140' 4);  			Match (input' NULL' Follow._NULL_in_filterExpr291);  			DebugLocation (141' 4);  			filterNode = new Value (null);  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("filterExpr"' 6);  	LeaveRule ("filterExpr"' 6);  	LeaveRule_filterExpr ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  	int alt9 = 9;  	try {  		DebugEnterDecision (9' false);  		switch (input.LA (1)) {  		case CHAIN_OPERATOR:  		case COMPARATOR:  			{  				alt9 = 1;  			}  			break;  		case EXPR:  			{  				int LA9_2 = input.LA (2);  				if ((LA9_2 == DOWN)) {  					int LA9_3 = input.LA (3);  					if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  						alt9 = 2;  					}  					else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  						alt9 = 3;  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				else {  					NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  					DebugRecognitionException (nvae);  					throw nvae;  				}  			}  			break;  		case STRING:  			{  				alt9 = 4;  			}  			break;  		case REGEX:  			{  				alt9 = 5;  			}  			break;  		case NUMBER:  			{  				alt9 = 6;  			}  			break;  		case TRUE:  			{  				alt9 = 7;  			}  			break;  		case FALSE:  			{  				alt9 = 8;  			}  			break;  		case NULL:  			{  				alt9 = 9;  			}  			break;  		default: {  			NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  		}  	}  	finally {  		DebugExitDecision (9);  	}  	switch (alt9) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  		{  			DebugLocation (64' 4);  			DebugLocation (64' 6);  			PushFollow (Follow._comparator_in_filterExpr175);  			comparator6 = comparator ();  			PopFollow ();  			Match (input' TokenTypes.Down' null);  			DebugLocation (64' 18);  			PushFollow (Follow._filterExpr_in_filterExpr179);  			a = filterExpr ();  			PopFollow ();  			DebugLocation (64' 31);  			PushFollow (Follow._filterExpr_in_filterExpr183);  			b = filterExpr ();  			PopFollow ();  			Match (input' TokenTypes.Up' null);  			DebugLocation (65' 4);  			Comparator newComparator;  			switch (comparator6) {  			case "=":  				newComparator = Comparator.Equals;  				break;  			case "!=":  				newComparator = Comparator.NotEquals;  				break;  			case ">":  				newComparator = Comparator.Greater;  				break;  			case "<":  				newComparator = Comparator.Less;  				break;  			case ">=":  				newComparator = Comparator.GreaterOrEqual;  				break;  			case "<=":  				newComparator = Comparator.LessOrEqual;  				break;  			case "&":  				newComparator = Comparator.And;  				break;  			case "|":  				newComparator = Comparator.Or;  				break;  			default:  				newComparator = Comparator.Equals;  				break;  			}  			filterNode = new BoolExpression (a' newComparator' b);  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  		{  			DebugLocation (98' 4);  			DebugLocation (98' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr195);  			Match (input' TokenTypes.Down' null);  			DebugLocation (98' 12);  			PushFollow (Follow._filterExpr_in_filterExpr199);  			f = filterExpr ();  			PopFollow ();  			DebugLocation (98' 31);  			// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  			int alt6 = 2;  			try {  				DebugEnterSubRule (6);  				try {  					DebugEnterDecision (6' false);  					int LA6_1 = input.LA (1);  					if ((LA6_1 == 24)) {  						alt6 = 1;  					}  				}  				finally {  					DebugExitDecision (6);  				}  				switch (alt6) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  					{  						DebugLocation (98' 31);  						inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (6);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (99' 4);  			FilterTreeNode newNode = f;  			if ((inverse != null ? inverse.Text : default(string)) == "!")  				newNode.ToggleInversed ();  			filterNode = newNode;  		}  		break;  	case 3:  		DebugEnterAlt (3);  		// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  		{  			DebugLocation (105' 4);  			DebugLocation (105' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr216);  			Match (input' TokenTypes.Down' null);  			DebugLocation (105' 12);  			PushFollow (Follow._propertyChain_in_filterExpr219);  			propertyChain (propertySegments);  			PopFollow ();  			DebugLocation (105' 51);  			// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  			int alt7 = 2;  			try {  				DebugEnterSubRule (7);  				try {  					DebugEnterDecision (7' false);  					int LA7_1 = input.LA (1);  					if ((LA7_1 == 31)) {  						alt7 = 1;  					}  				}  				finally {  					DebugExitDecision (7);  				}  				switch (alt7) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  					{  						DebugLocation (105' 51);  						inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (7);  			}  			DebugLocation (105' 60);  			// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  			int alt8 = 2;  			try {  				DebugEnterSubRule (8);  				try {  					DebugEnterDecision (8' false);  					int LA8_1 = input.LA (1);  					if ((LA8_1 == 24)) {  						alt8 = 1;  					}  				}  				finally {  					DebugExitDecision (8);  				}  				switch (alt8) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  					{  						DebugLocation (105' 60);  						not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (8);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (106' 4);  			FilterTreeNode newProperty = new Property (propertySegments);  			if ((inverse != null ? inverse.Text : default(string)) == "?")  				filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  			else {  				if ((not != null ? not.Text : default(string)) == "!")  					newProperty.ToggleInversed ();  				filterNode = newProperty;  			}  		}  		break;  	case 4:  		DebugEnterAlt (4);  		// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  		{  			DebugLocation (116' 4);  			STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  			DebugLocation (117' 4);  			string stringText = (STRING7 != null ? STRING7.Text : default(string));  			stringText = stringText.Substring (1' stringText.Length - 2);  			filterNode = new Value (stringText);  		}  		break;  	case 5:  		DebugEnterAlt (5);  		// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  		{  			DebugLocation (122' 4);  			REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  			DebugLocation (123' 4);  			string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  			regexText = regexText.Substring (1' regexText.Length - 2);  			filterNode = new RegExp (regexText);  		}  		break;  	case 6:  		DebugEnterAlt (6);  		// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  		{  			DebugLocation (128' 4);  			NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  			DebugLocation (129' 4);  			filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  		}  		break;  	case 7:  		DebugEnterAlt (7);  		// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  		{  			DebugLocation (132' 4);  			Match (input' TRUE' Follow._TRUE_in_filterExpr271);  			DebugLocation (133' 4);  			filterNode = new Value (true);  		}  		break;  	case 8:  		DebugEnterAlt (8);  		// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  		{  			DebugLocation (136' 4);  			Match (input' FALSE' Follow._FALSE_in_filterExpr281);  			DebugLocation (137' 4);  			filterNode = new Value (false);  		}  		break;  	case 9:  		DebugEnterAlt (9);  		// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  		{  			DebugLocation (140' 4);  			Match (input' NULL' Follow._NULL_in_filterExpr291);  			DebugLocation (141' 4);  			filterNode = new Value (null);  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("filterExpr"' 6);  	LeaveRule ("filterExpr"' 6);  	LeaveRule_filterExpr ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  	int alt9 = 9;  	try {  		DebugEnterDecision (9' false);  		switch (input.LA (1)) {  		case CHAIN_OPERATOR:  		case COMPARATOR:  			{  				alt9 = 1;  			}  			break;  		case EXPR:  			{  				int LA9_2 = input.LA (2);  				if ((LA9_2 == DOWN)) {  					int LA9_3 = input.LA (3);  					if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  						alt9 = 2;  					}  					else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  						alt9 = 3;  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				else {  					NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  					DebugRecognitionException (nvae);  					throw nvae;  				}  			}  			break;  		case STRING:  			{  				alt9 = 4;  			}  			break;  		case REGEX:  			{  				alt9 = 5;  			}  			break;  		case NUMBER:  			{  				alt9 = 6;  			}  			break;  		case TRUE:  			{  				alt9 = 7;  			}  			break;  		case FALSE:  			{  				alt9 = 8;  			}  			break;  		case NULL:  			{  				alt9 = 9;  			}  			break;  		default: {  			NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  		}  	}  	finally {  		DebugExitDecision (9);  	}  	switch (alt9) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  		{  			DebugLocation (64' 4);  			DebugLocation (64' 6);  			PushFollow (Follow._comparator_in_filterExpr175);  			comparator6 = comparator ();  			PopFollow ();  			Match (input' TokenTypes.Down' null);  			DebugLocation (64' 18);  			PushFollow (Follow._filterExpr_in_filterExpr179);  			a = filterExpr ();  			PopFollow ();  			DebugLocation (64' 31);  			PushFollow (Follow._filterExpr_in_filterExpr183);  			b = filterExpr ();  			PopFollow ();  			Match (input' TokenTypes.Up' null);  			DebugLocation (65' 4);  			Comparator newComparator;  			switch (comparator6) {  			case "=":  				newComparator = Comparator.Equals;  				break;  			case "!=":  				newComparator = Comparator.NotEquals;  				break;  			case ">":  				newComparator = Comparator.Greater;  				break;  			case "<":  				newComparator = Comparator.Less;  				break;  			case ">=":  				newComparator = Comparator.GreaterOrEqual;  				break;  			case "<=":  				newComparator = Comparator.LessOrEqual;  				break;  			case "&":  				newComparator = Comparator.And;  				break;  			case "|":  				newComparator = Comparator.Or;  				break;  			default:  				newComparator = Comparator.Equals;  				break;  			}  			filterNode = new BoolExpression (a' newComparator' b);  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  		{  			DebugLocation (98' 4);  			DebugLocation (98' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr195);  			Match (input' TokenTypes.Down' null);  			DebugLocation (98' 12);  			PushFollow (Follow._filterExpr_in_filterExpr199);  			f = filterExpr ();  			PopFollow ();  			DebugLocation (98' 31);  			// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  			int alt6 = 2;  			try {  				DebugEnterSubRule (6);  				try {  					DebugEnterDecision (6' false);  					int LA6_1 = input.LA (1);  					if ((LA6_1 == 24)) {  						alt6 = 1;  					}  				}  				finally {  					DebugExitDecision (6);  				}  				switch (alt6) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  					{  						DebugLocation (98' 31);  						inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (6);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (99' 4);  			FilterTreeNode newNode = f;  			if ((inverse != null ? inverse.Text : default(string)) == "!")  				newNode.ToggleInversed ();  			filterNode = newNode;  		}  		break;  	case 3:  		DebugEnterAlt (3);  		// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  		{  			DebugLocation (105' 4);  			DebugLocation (105' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr216);  			Match (input' TokenTypes.Down' null);  			DebugLocation (105' 12);  			PushFollow (Follow._propertyChain_in_filterExpr219);  			propertyChain (propertySegments);  			PopFollow ();  			DebugLocation (105' 51);  			// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  			int alt7 = 2;  			try {  				DebugEnterSubRule (7);  				try {  					DebugEnterDecision (7' false);  					int LA7_1 = input.LA (1);  					if ((LA7_1 == 31)) {  						alt7 = 1;  					}  				}  				finally {  					DebugExitDecision (7);  				}  				switch (alt7) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  					{  						DebugLocation (105' 51);  						inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (7);  			}  			DebugLocation (105' 60);  			// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  			int alt8 = 2;  			try {  				DebugEnterSubRule (8);  				try {  					DebugEnterDecision (8' false);  					int LA8_1 = input.LA (1);  					if ((LA8_1 == 24)) {  						alt8 = 1;  					}  				}  				finally {  					DebugExitDecision (8);  				}  				switch (alt8) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  					{  						DebugLocation (105' 60);  						not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (8);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (106' 4);  			FilterTreeNode newProperty = new Property (propertySegments);  			if ((inverse != null ? inverse.Text : default(string)) == "?")  				filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  			else {  				if ((not != null ? not.Text : default(string)) == "!")  					newProperty.ToggleInversed ();  				filterNode = newProperty;  			}  		}  		break;  	case 4:  		DebugEnterAlt (4);  		// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  		{  			DebugLocation (116' 4);  			STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  			DebugLocation (117' 4);  			string stringText = (STRING7 != null ? STRING7.Text : default(string));  			stringText = stringText.Substring (1' stringText.Length - 2);  			filterNode = new Value (stringText);  		}  		break;  	case 5:  		DebugEnterAlt (5);  		// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  		{  			DebugLocation (122' 4);  			REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  			DebugLocation (123' 4);  			string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  			regexText = regexText.Substring (1' regexText.Length - 2);  			filterNode = new RegExp (regexText);  		}  		break;  	case 6:  		DebugEnterAlt (6);  		// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  		{  			DebugLocation (128' 4);  			NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  			DebugLocation (129' 4);  			filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  		}  		break;  	case 7:  		DebugEnterAlt (7);  		// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  		{  			DebugLocation (132' 4);  			Match (input' TRUE' Follow._TRUE_in_filterExpr271);  			DebugLocation (133' 4);  			filterNode = new Value (true);  		}  		break;  	case 8:  		DebugEnterAlt (8);  		// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  		{  			DebugLocation (136' 4);  			Match (input' FALSE' Follow._FALSE_in_filterExpr281);  			DebugLocation (137' 4);  			filterNode = new Value (false);  		}  		break;  	case 9:  		DebugEnterAlt (9);  		// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  		{  			DebugLocation (140' 4);  			Match (input' NULL' Follow._NULL_in_filterExpr291);  			DebugLocation (141' 4);  			filterNode = new Value (null);  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("filterExpr"' 6);  	LeaveRule ("filterExpr"' 6);  	LeaveRule_filterExpr ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  	int alt9 = 9;  	try {  		DebugEnterDecision (9' false);  		switch (input.LA (1)) {  		case CHAIN_OPERATOR:  		case COMPARATOR:  			{  				alt9 = 1;  			}  			break;  		case EXPR:  			{  				int LA9_2 = input.LA (2);  				if ((LA9_2 == DOWN)) {  					int LA9_3 = input.LA (3);  					if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  						alt9 = 2;  					}  					else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  						alt9 = 3;  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				else {  					NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  					DebugRecognitionException (nvae);  					throw nvae;  				}  			}  			break;  		case STRING:  			{  				alt9 = 4;  			}  			break;  		case REGEX:  			{  				alt9 = 5;  			}  			break;  		case NUMBER:  			{  				alt9 = 6;  			}  			break;  		case TRUE:  			{  				alt9 = 7;  			}  			break;  		case FALSE:  			{  				alt9 = 8;  			}  			break;  		case NULL:  			{  				alt9 = 9;  			}  			break;  		default: {  			NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  		}  	}  	finally {  		DebugExitDecision (9);  	}  	switch (alt9) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  		{  			DebugLocation (64' 4);  			DebugLocation (64' 6);  			PushFollow (Follow._comparator_in_filterExpr175);  			comparator6 = comparator ();  			PopFollow ();  			Match (input' TokenTypes.Down' null);  			DebugLocation (64' 18);  			PushFollow (Follow._filterExpr_in_filterExpr179);  			a = filterExpr ();  			PopFollow ();  			DebugLocation (64' 31);  			PushFollow (Follow._filterExpr_in_filterExpr183);  			b = filterExpr ();  			PopFollow ();  			Match (input' TokenTypes.Up' null);  			DebugLocation (65' 4);  			Comparator newComparator;  			switch (comparator6) {  			case "=":  				newComparator = Comparator.Equals;  				break;  			case "!=":  				newComparator = Comparator.NotEquals;  				break;  			case ">":  				newComparator = Comparator.Greater;  				break;  			case "<":  				newComparator = Comparator.Less;  				break;  			case ">=":  				newComparator = Comparator.GreaterOrEqual;  				break;  			case "<=":  				newComparator = Comparator.LessOrEqual;  				break;  			case "&":  				newComparator = Comparator.And;  				break;  			case "|":  				newComparator = Comparator.Or;  				break;  			default:  				newComparator = Comparator.Equals;  				break;  			}  			filterNode = new BoolExpression (a' newComparator' b);  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  		{  			DebugLocation (98' 4);  			DebugLocation (98' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr195);  			Match (input' TokenTypes.Down' null);  			DebugLocation (98' 12);  			PushFollow (Follow._filterExpr_in_filterExpr199);  			f = filterExpr ();  			PopFollow ();  			DebugLocation (98' 31);  			// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  			int alt6 = 2;  			try {  				DebugEnterSubRule (6);  				try {  					DebugEnterDecision (6' false);  					int LA6_1 = input.LA (1);  					if ((LA6_1 == 24)) {  						alt6 = 1;  					}  				}  				finally {  					DebugExitDecision (6);  				}  				switch (alt6) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  					{  						DebugLocation (98' 31);  						inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (6);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (99' 4);  			FilterTreeNode newNode = f;  			if ((inverse != null ? inverse.Text : default(string)) == "!")  				newNode.ToggleInversed ();  			filterNode = newNode;  		}  		break;  	case 3:  		DebugEnterAlt (3);  		// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  		{  			DebugLocation (105' 4);  			DebugLocation (105' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr216);  			Match (input' TokenTypes.Down' null);  			DebugLocation (105' 12);  			PushFollow (Follow._propertyChain_in_filterExpr219);  			propertyChain (propertySegments);  			PopFollow ();  			DebugLocation (105' 51);  			// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  			int alt7 = 2;  			try {  				DebugEnterSubRule (7);  				try {  					DebugEnterDecision (7' false);  					int LA7_1 = input.LA (1);  					if ((LA7_1 == 31)) {  						alt7 = 1;  					}  				}  				finally {  					DebugExitDecision (7);  				}  				switch (alt7) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  					{  						DebugLocation (105' 51);  						inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (7);  			}  			DebugLocation (105' 60);  			// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  			int alt8 = 2;  			try {  				DebugEnterSubRule (8);  				try {  					DebugEnterDecision (8' false);  					int LA8_1 = input.LA (1);  					if ((LA8_1 == 24)) {  						alt8 = 1;  					}  				}  				finally {  					DebugExitDecision (8);  				}  				switch (alt8) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  					{  						DebugLocation (105' 60);  						not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (8);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (106' 4);  			FilterTreeNode newProperty = new Property (propertySegments);  			if ((inverse != null ? inverse.Text : default(string)) == "?")  				filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  			else {  				if ((not != null ? not.Text : default(string)) == "!")  					newProperty.ToggleInversed ();  				filterNode = newProperty;  			}  		}  		break;  	case 4:  		DebugEnterAlt (4);  		// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  		{  			DebugLocation (116' 4);  			STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  			DebugLocation (117' 4);  			string stringText = (STRING7 != null ? STRING7.Text : default(string));  			stringText = stringText.Substring (1' stringText.Length - 2);  			filterNode = new Value (stringText);  		}  		break;  	case 5:  		DebugEnterAlt (5);  		// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  		{  			DebugLocation (122' 4);  			REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  			DebugLocation (123' 4);  			string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  			regexText = regexText.Substring (1' regexText.Length - 2);  			filterNode = new RegExp (regexText);  		}  		break;  	case 6:  		DebugEnterAlt (6);  		// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  		{  			DebugLocation (128' 4);  			NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  			DebugLocation (129' 4);  			filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  		}  		break;  	case 7:  		DebugEnterAlt (7);  		// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  		{  			DebugLocation (132' 4);  			Match (input' TRUE' Follow._TRUE_in_filterExpr271);  			DebugLocation (133' 4);  			filterNode = new Value (true);  		}  		break;  	case 8:  		DebugEnterAlt (8);  		// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  		{  			DebugLocation (136' 4);  			Match (input' FALSE' Follow._FALSE_in_filterExpr281);  			DebugLocation (137' 4);  			filterNode = new Value (false);  		}  		break;  	case 9:  		DebugEnterAlt (9);  		// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  		{  			DebugLocation (140' 4);  			Match (input' NULL' Follow._NULL_in_filterExpr291);  			DebugLocation (141' 4);  			filterNode = new Value (null);  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("filterExpr"' 6);  	LeaveRule ("filterExpr"' 6);  	LeaveRule_filterExpr ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  	int alt9 = 9;  	try {  		DebugEnterDecision (9' false);  		switch (input.LA (1)) {  		case CHAIN_OPERATOR:  		case COMPARATOR:  			{  				alt9 = 1;  			}  			break;  		case EXPR:  			{  				int LA9_2 = input.LA (2);  				if ((LA9_2 == DOWN)) {  					int LA9_3 = input.LA (3);  					if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  						alt9 = 2;  					}  					else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  						alt9 = 3;  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				else {  					NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  					DebugRecognitionException (nvae);  					throw nvae;  				}  			}  			break;  		case STRING:  			{  				alt9 = 4;  			}  			break;  		case REGEX:  			{  				alt9 = 5;  			}  			break;  		case NUMBER:  			{  				alt9 = 6;  			}  			break;  		case TRUE:  			{  				alt9 = 7;  			}  			break;  		case FALSE:  			{  				alt9 = 8;  			}  			break;  		case NULL:  			{  				alt9 = 9;  			}  			break;  		default: {  			NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  		}  	}  	finally {  		DebugExitDecision (9);  	}  	switch (alt9) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  		{  			DebugLocation (64' 4);  			DebugLocation (64' 6);  			PushFollow (Follow._comparator_in_filterExpr175);  			comparator6 = comparator ();  			PopFollow ();  			Match (input' TokenTypes.Down' null);  			DebugLocation (64' 18);  			PushFollow (Follow._filterExpr_in_filterExpr179);  			a = filterExpr ();  			PopFollow ();  			DebugLocation (64' 31);  			PushFollow (Follow._filterExpr_in_filterExpr183);  			b = filterExpr ();  			PopFollow ();  			Match (input' TokenTypes.Up' null);  			DebugLocation (65' 4);  			Comparator newComparator;  			switch (comparator6) {  			case "=":  				newComparator = Comparator.Equals;  				break;  			case "!=":  				newComparator = Comparator.NotEquals;  				break;  			case ">":  				newComparator = Comparator.Greater;  				break;  			case "<":  				newComparator = Comparator.Less;  				break;  			case ">=":  				newComparator = Comparator.GreaterOrEqual;  				break;  			case "<=":  				newComparator = Comparator.LessOrEqual;  				break;  			case "&":  				newComparator = Comparator.And;  				break;  			case "|":  				newComparator = Comparator.Or;  				break;  			default:  				newComparator = Comparator.Equals;  				break;  			}  			filterNode = new BoolExpression (a' newComparator' b);  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  		{  			DebugLocation (98' 4);  			DebugLocation (98' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr195);  			Match (input' TokenTypes.Down' null);  			DebugLocation (98' 12);  			PushFollow (Follow._filterExpr_in_filterExpr199);  			f = filterExpr ();  			PopFollow ();  			DebugLocation (98' 31);  			// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  			int alt6 = 2;  			try {  				DebugEnterSubRule (6);  				try {  					DebugEnterDecision (6' false);  					int LA6_1 = input.LA (1);  					if ((LA6_1 == 24)) {  						alt6 = 1;  					}  				}  				finally {  					DebugExitDecision (6);  				}  				switch (alt6) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  					{  						DebugLocation (98' 31);  						inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (6);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (99' 4);  			FilterTreeNode newNode = f;  			if ((inverse != null ? inverse.Text : default(string)) == "!")  				newNode.ToggleInversed ();  			filterNode = newNode;  		}  		break;  	case 3:  		DebugEnterAlt (3);  		// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  		{  			DebugLocation (105' 4);  			DebugLocation (105' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr216);  			Match (input' TokenTypes.Down' null);  			DebugLocation (105' 12);  			PushFollow (Follow._propertyChain_in_filterExpr219);  			propertyChain (propertySegments);  			PopFollow ();  			DebugLocation (105' 51);  			// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  			int alt7 = 2;  			try {  				DebugEnterSubRule (7);  				try {  					DebugEnterDecision (7' false);  					int LA7_1 = input.LA (1);  					if ((LA7_1 == 31)) {  						alt7 = 1;  					}  				}  				finally {  					DebugExitDecision (7);  				}  				switch (alt7) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  					{  						DebugLocation (105' 51);  						inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (7);  			}  			DebugLocation (105' 60);  			// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  			int alt8 = 2;  			try {  				DebugEnterSubRule (8);  				try {  					DebugEnterDecision (8' false);  					int LA8_1 = input.LA (1);  					if ((LA8_1 == 24)) {  						alt8 = 1;  					}  				}  				finally {  					DebugExitDecision (8);  				}  				switch (alt8) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  					{  						DebugLocation (105' 60);  						not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (8);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (106' 4);  			FilterTreeNode newProperty = new Property (propertySegments);  			if ((inverse != null ? inverse.Text : default(string)) == "?")  				filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  			else {  				if ((not != null ? not.Text : default(string)) == "!")  					newProperty.ToggleInversed ();  				filterNode = newProperty;  			}  		}  		break;  	case 4:  		DebugEnterAlt (4);  		// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  		{  			DebugLocation (116' 4);  			STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  			DebugLocation (117' 4);  			string stringText = (STRING7 != null ? STRING7.Text : default(string));  			stringText = stringText.Substring (1' stringText.Length - 2);  			filterNode = new Value (stringText);  		}  		break;  	case 5:  		DebugEnterAlt (5);  		// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  		{  			DebugLocation (122' 4);  			REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  			DebugLocation (123' 4);  			string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  			regexText = regexText.Substring (1' regexText.Length - 2);  			filterNode = new RegExp (regexText);  		}  		break;  	case 6:  		DebugEnterAlt (6);  		// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  		{  			DebugLocation (128' 4);  			NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  			DebugLocation (129' 4);  			filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  		}  		break;  	case 7:  		DebugEnterAlt (7);  		// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  		{  			DebugLocation (132' 4);  			Match (input' TRUE' Follow._TRUE_in_filterExpr271);  			DebugLocation (133' 4);  			filterNode = new Value (true);  		}  		break;  	case 8:  		DebugEnterAlt (8);  		// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  		{  			DebugLocation (136' 4);  			Match (input' FALSE' Follow._FALSE_in_filterExpr281);  			DebugLocation (137' 4);  			filterNode = new Value (false);  		}  		break;  	case 9:  		DebugEnterAlt (9);  		// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  		{  			DebugLocation (140' 4);  			Match (input' NULL' Follow._NULL_in_filterExpr291);  			DebugLocation (141' 4);  			filterNode = new Value (null);  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("filterExpr"' 6);  	LeaveRule ("filterExpr"' 6);  	LeaveRule_filterExpr ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  	int alt9 = 9;  	try {  		DebugEnterDecision (9' false);  		switch (input.LA (1)) {  		case CHAIN_OPERATOR:  		case COMPARATOR:  			{  				alt9 = 1;  			}  			break;  		case EXPR:  			{  				int LA9_2 = input.LA (2);  				if ((LA9_2 == DOWN)) {  					int LA9_3 = input.LA (3);  					if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  						alt9 = 2;  					}  					else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  						alt9 = 3;  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				else {  					NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  					DebugRecognitionException (nvae);  					throw nvae;  				}  			}  			break;  		case STRING:  			{  				alt9 = 4;  			}  			break;  		case REGEX:  			{  				alt9 = 5;  			}  			break;  		case NUMBER:  			{  				alt9 = 6;  			}  			break;  		case TRUE:  			{  				alt9 = 7;  			}  			break;  		case FALSE:  			{  				alt9 = 8;  			}  			break;  		case NULL:  			{  				alt9 = 9;  			}  			break;  		default: {  			NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  		}  	}  	finally {  		DebugExitDecision (9);  	}  	switch (alt9) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  		{  			DebugLocation (64' 4);  			DebugLocation (64' 6);  			PushFollow (Follow._comparator_in_filterExpr175);  			comparator6 = comparator ();  			PopFollow ();  			Match (input' TokenTypes.Down' null);  			DebugLocation (64' 18);  			PushFollow (Follow._filterExpr_in_filterExpr179);  			a = filterExpr ();  			PopFollow ();  			DebugLocation (64' 31);  			PushFollow (Follow._filterExpr_in_filterExpr183);  			b = filterExpr ();  			PopFollow ();  			Match (input' TokenTypes.Up' null);  			DebugLocation (65' 4);  			Comparator newComparator;  			switch (comparator6) {  			case "=":  				newComparator = Comparator.Equals;  				break;  			case "!=":  				newComparator = Comparator.NotEquals;  				break;  			case ">":  				newComparator = Comparator.Greater;  				break;  			case "<":  				newComparator = Comparator.Less;  				break;  			case ">=":  				newComparator = Comparator.GreaterOrEqual;  				break;  			case "<=":  				newComparator = Comparator.LessOrEqual;  				break;  			case "&":  				newComparator = Comparator.And;  				break;  			case "|":  				newComparator = Comparator.Or;  				break;  			default:  				newComparator = Comparator.Equals;  				break;  			}  			filterNode = new BoolExpression (a' newComparator' b);  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  		{  			DebugLocation (98' 4);  			DebugLocation (98' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr195);  			Match (input' TokenTypes.Down' null);  			DebugLocation (98' 12);  			PushFollow (Follow._filterExpr_in_filterExpr199);  			f = filterExpr ();  			PopFollow ();  			DebugLocation (98' 31);  			// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  			int alt6 = 2;  			try {  				DebugEnterSubRule (6);  				try {  					DebugEnterDecision (6' false);  					int LA6_1 = input.LA (1);  					if ((LA6_1 == 24)) {  						alt6 = 1;  					}  				}  				finally {  					DebugExitDecision (6);  				}  				switch (alt6) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  					{  						DebugLocation (98' 31);  						inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (6);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (99' 4);  			FilterTreeNode newNode = f;  			if ((inverse != null ? inverse.Text : default(string)) == "!")  				newNode.ToggleInversed ();  			filterNode = newNode;  		}  		break;  	case 3:  		DebugEnterAlt (3);  		// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  		{  			DebugLocation (105' 4);  			DebugLocation (105' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr216);  			Match (input' TokenTypes.Down' null);  			DebugLocation (105' 12);  			PushFollow (Follow._propertyChain_in_filterExpr219);  			propertyChain (propertySegments);  			PopFollow ();  			DebugLocation (105' 51);  			// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  			int alt7 = 2;  			try {  				DebugEnterSubRule (7);  				try {  					DebugEnterDecision (7' false);  					int LA7_1 = input.LA (1);  					if ((LA7_1 == 31)) {  						alt7 = 1;  					}  				}  				finally {  					DebugExitDecision (7);  				}  				switch (alt7) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  					{  						DebugLocation (105' 51);  						inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (7);  			}  			DebugLocation (105' 60);  			// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  			int alt8 = 2;  			try {  				DebugEnterSubRule (8);  				try {  					DebugEnterDecision (8' false);  					int LA8_1 = input.LA (1);  					if ((LA8_1 == 24)) {  						alt8 = 1;  					}  				}  				finally {  					DebugExitDecision (8);  				}  				switch (alt8) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  					{  						DebugLocation (105' 60);  						not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (8);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (106' 4);  			FilterTreeNode newProperty = new Property (propertySegments);  			if ((inverse != null ? inverse.Text : default(string)) == "?")  				filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  			else {  				if ((not != null ? not.Text : default(string)) == "!")  					newProperty.ToggleInversed ();  				filterNode = newProperty;  			}  		}  		break;  	case 4:  		DebugEnterAlt (4);  		// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  		{  			DebugLocation (116' 4);  			STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  			DebugLocation (117' 4);  			string stringText = (STRING7 != null ? STRING7.Text : default(string));  			stringText = stringText.Substring (1' stringText.Length - 2);  			filterNode = new Value (stringText);  		}  		break;  	case 5:  		DebugEnterAlt (5);  		// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  		{  			DebugLocation (122' 4);  			REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  			DebugLocation (123' 4);  			string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  			regexText = regexText.Substring (1' regexText.Length - 2);  			filterNode = new RegExp (regexText);  		}  		break;  	case 6:  		DebugEnterAlt (6);  		// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  		{  			DebugLocation (128' 4);  			NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  			DebugLocation (129' 4);  			filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  		}  		break;  	case 7:  		DebugEnterAlt (7);  		// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  		{  			DebugLocation (132' 4);  			Match (input' TRUE' Follow._TRUE_in_filterExpr271);  			DebugLocation (133' 4);  			filterNode = new Value (true);  		}  		break;  	case 8:  		DebugEnterAlt (8);  		// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  		{  			DebugLocation (136' 4);  			Match (input' FALSE' Follow._FALSE_in_filterExpr281);  			DebugLocation (137' 4);  			filterNode = new Value (false);  		}  		break;  	case 9:  		DebugEnterAlt (9);  		// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  		{  			DebugLocation (140' 4);  			Match (input' NULL' Follow._NULL_in_filterExpr291);  			DebugLocation (141' 4);  			filterNode = new Value (null);  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("filterExpr"' 6);  	LeaveRule ("filterExpr"' 6);  	LeaveRule_filterExpr ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  	int alt9 = 9;  	try {  		DebugEnterDecision (9' false);  		switch (input.LA (1)) {  		case CHAIN_OPERATOR:  		case COMPARATOR:  			{  				alt9 = 1;  			}  			break;  		case EXPR:  			{  				int LA9_2 = input.LA (2);  				if ((LA9_2 == DOWN)) {  					int LA9_3 = input.LA (3);  					if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  						alt9 = 2;  					}  					else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  						alt9 = 3;  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				else {  					NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  					DebugRecognitionException (nvae);  					throw nvae;  				}  			}  			break;  		case STRING:  			{  				alt9 = 4;  			}  			break;  		case REGEX:  			{  				alt9 = 5;  			}  			break;  		case NUMBER:  			{  				alt9 = 6;  			}  			break;  		case TRUE:  			{  				alt9 = 7;  			}  			break;  		case FALSE:  			{  				alt9 = 8;  			}  			break;  		case NULL:  			{  				alt9 = 9;  			}  			break;  		default: {  			NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  		}  	}  	finally {  		DebugExitDecision (9);  	}  	switch (alt9) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  		{  			DebugLocation (64' 4);  			DebugLocation (64' 6);  			PushFollow (Follow._comparator_in_filterExpr175);  			comparator6 = comparator ();  			PopFollow ();  			Match (input' TokenTypes.Down' null);  			DebugLocation (64' 18);  			PushFollow (Follow._filterExpr_in_filterExpr179);  			a = filterExpr ();  			PopFollow ();  			DebugLocation (64' 31);  			PushFollow (Follow._filterExpr_in_filterExpr183);  			b = filterExpr ();  			PopFollow ();  			Match (input' TokenTypes.Up' null);  			DebugLocation (65' 4);  			Comparator newComparator;  			switch (comparator6) {  			case "=":  				newComparator = Comparator.Equals;  				break;  			case "!=":  				newComparator = Comparator.NotEquals;  				break;  			case ">":  				newComparator = Comparator.Greater;  				break;  			case "<":  				newComparator = Comparator.Less;  				break;  			case ">=":  				newComparator = Comparator.GreaterOrEqual;  				break;  			case "<=":  				newComparator = Comparator.LessOrEqual;  				break;  			case "&":  				newComparator = Comparator.And;  				break;  			case "|":  				newComparator = Comparator.Or;  				break;  			default:  				newComparator = Comparator.Equals;  				break;  			}  			filterNode = new BoolExpression (a' newComparator' b);  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  		{  			DebugLocation (98' 4);  			DebugLocation (98' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr195);  			Match (input' TokenTypes.Down' null);  			DebugLocation (98' 12);  			PushFollow (Follow._filterExpr_in_filterExpr199);  			f = filterExpr ();  			PopFollow ();  			DebugLocation (98' 31);  			// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  			int alt6 = 2;  			try {  				DebugEnterSubRule (6);  				try {  					DebugEnterDecision (6' false);  					int LA6_1 = input.LA (1);  					if ((LA6_1 == 24)) {  						alt6 = 1;  					}  				}  				finally {  					DebugExitDecision (6);  				}  				switch (alt6) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  					{  						DebugLocation (98' 31);  						inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (6);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (99' 4);  			FilterTreeNode newNode = f;  			if ((inverse != null ? inverse.Text : default(string)) == "!")  				newNode.ToggleInversed ();  			filterNode = newNode;  		}  		break;  	case 3:  		DebugEnterAlt (3);  		// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  		{  			DebugLocation (105' 4);  			DebugLocation (105' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr216);  			Match (input' TokenTypes.Down' null);  			DebugLocation (105' 12);  			PushFollow (Follow._propertyChain_in_filterExpr219);  			propertyChain (propertySegments);  			PopFollow ();  			DebugLocation (105' 51);  			// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  			int alt7 = 2;  			try {  				DebugEnterSubRule (7);  				try {  					DebugEnterDecision (7' false);  					int LA7_1 = input.LA (1);  					if ((LA7_1 == 31)) {  						alt7 = 1;  					}  				}  				finally {  					DebugExitDecision (7);  				}  				switch (alt7) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  					{  						DebugLocation (105' 51);  						inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (7);  			}  			DebugLocation (105' 60);  			// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  			int alt8 = 2;  			try {  				DebugEnterSubRule (8);  				try {  					DebugEnterDecision (8' false);  					int LA8_1 = input.LA (1);  					if ((LA8_1 == 24)) {  						alt8 = 1;  					}  				}  				finally {  					DebugExitDecision (8);  				}  				switch (alt8) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  					{  						DebugLocation (105' 60);  						not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (8);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (106' 4);  			FilterTreeNode newProperty = new Property (propertySegments);  			if ((inverse != null ? inverse.Text : default(string)) == "?")  				filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  			else {  				if ((not != null ? not.Text : default(string)) == "!")  					newProperty.ToggleInversed ();  				filterNode = newProperty;  			}  		}  		break;  	case 4:  		DebugEnterAlt (4);  		// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  		{  			DebugLocation (116' 4);  			STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  			DebugLocation (117' 4);  			string stringText = (STRING7 != null ? STRING7.Text : default(string));  			stringText = stringText.Substring (1' stringText.Length - 2);  			filterNode = new Value (stringText);  		}  		break;  	case 5:  		DebugEnterAlt (5);  		// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  		{  			DebugLocation (122' 4);  			REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  			DebugLocation (123' 4);  			string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  			regexText = regexText.Substring (1' regexText.Length - 2);  			filterNode = new RegExp (regexText);  		}  		break;  	case 6:  		DebugEnterAlt (6);  		// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  		{  			DebugLocation (128' 4);  			NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  			DebugLocation (129' 4);  			filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  		}  		break;  	case 7:  		DebugEnterAlt (7);  		// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  		{  			DebugLocation (132' 4);  			Match (input' TRUE' Follow._TRUE_in_filterExpr271);  			DebugLocation (133' 4);  			filterNode = new Value (true);  		}  		break;  	case 8:  		DebugEnterAlt (8);  		// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  		{  			DebugLocation (136' 4);  			Match (input' FALSE' Follow._FALSE_in_filterExpr281);  			DebugLocation (137' 4);  			filterNode = new Value (false);  		}  		break;  	case 9:  		DebugEnterAlt (9);  		// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  		{  			DebugLocation (140' 4);  			Match (input' NULL' Follow._NULL_in_filterExpr291);  			DebugLocation (141' 4);  			filterNode = new Value (null);  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("filterExpr"' 6);  	LeaveRule ("filterExpr"' 6);  	LeaveRule_filterExpr ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  	int alt9 = 9;  	try {  		DebugEnterDecision (9' false);  		switch (input.LA (1)) {  		case CHAIN_OPERATOR:  		case COMPARATOR:  			{  				alt9 = 1;  			}  			break;  		case EXPR:  			{  				int LA9_2 = input.LA (2);  				if ((LA9_2 == DOWN)) {  					int LA9_3 = input.LA (3);  					if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  						alt9 = 2;  					}  					else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  						alt9 = 3;  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				else {  					NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  					DebugRecognitionException (nvae);  					throw nvae;  				}  			}  			break;  		case STRING:  			{  				alt9 = 4;  			}  			break;  		case REGEX:  			{  				alt9 = 5;  			}  			break;  		case NUMBER:  			{  				alt9 = 6;  			}  			break;  		case TRUE:  			{  				alt9 = 7;  			}  			break;  		case FALSE:  			{  				alt9 = 8;  			}  			break;  		case NULL:  			{  				alt9 = 9;  			}  			break;  		default: {  			NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  		}  	}  	finally {  		DebugExitDecision (9);  	}  	switch (alt9) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  		{  			DebugLocation (64' 4);  			DebugLocation (64' 6);  			PushFollow (Follow._comparator_in_filterExpr175);  			comparator6 = comparator ();  			PopFollow ();  			Match (input' TokenTypes.Down' null);  			DebugLocation (64' 18);  			PushFollow (Follow._filterExpr_in_filterExpr179);  			a = filterExpr ();  			PopFollow ();  			DebugLocation (64' 31);  			PushFollow (Follow._filterExpr_in_filterExpr183);  			b = filterExpr ();  			PopFollow ();  			Match (input' TokenTypes.Up' null);  			DebugLocation (65' 4);  			Comparator newComparator;  			switch (comparator6) {  			case "=":  				newComparator = Comparator.Equals;  				break;  			case "!=":  				newComparator = Comparator.NotEquals;  				break;  			case ">":  				newComparator = Comparator.Greater;  				break;  			case "<":  				newComparator = Comparator.Less;  				break;  			case ">=":  				newComparator = Comparator.GreaterOrEqual;  				break;  			case "<=":  				newComparator = Comparator.LessOrEqual;  				break;  			case "&":  				newComparator = Comparator.And;  				break;  			case "|":  				newComparator = Comparator.Or;  				break;  			default:  				newComparator = Comparator.Equals;  				break;  			}  			filterNode = new BoolExpression (a' newComparator' b);  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  		{  			DebugLocation (98' 4);  			DebugLocation (98' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr195);  			Match (input' TokenTypes.Down' null);  			DebugLocation (98' 12);  			PushFollow (Follow._filterExpr_in_filterExpr199);  			f = filterExpr ();  			PopFollow ();  			DebugLocation (98' 31);  			// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  			int alt6 = 2;  			try {  				DebugEnterSubRule (6);  				try {  					DebugEnterDecision (6' false);  					int LA6_1 = input.LA (1);  					if ((LA6_1 == 24)) {  						alt6 = 1;  					}  				}  				finally {  					DebugExitDecision (6);  				}  				switch (alt6) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  					{  						DebugLocation (98' 31);  						inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (6);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (99' 4);  			FilterTreeNode newNode = f;  			if ((inverse != null ? inverse.Text : default(string)) == "!")  				newNode.ToggleInversed ();  			filterNode = newNode;  		}  		break;  	case 3:  		DebugEnterAlt (3);  		// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  		{  			DebugLocation (105' 4);  			DebugLocation (105' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr216);  			Match (input' TokenTypes.Down' null);  			DebugLocation (105' 12);  			PushFollow (Follow._propertyChain_in_filterExpr219);  			propertyChain (propertySegments);  			PopFollow ();  			DebugLocation (105' 51);  			// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  			int alt7 = 2;  			try {  				DebugEnterSubRule (7);  				try {  					DebugEnterDecision (7' false);  					int LA7_1 = input.LA (1);  					if ((LA7_1 == 31)) {  						alt7 = 1;  					}  				}  				finally {  					DebugExitDecision (7);  				}  				switch (alt7) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  					{  						DebugLocation (105' 51);  						inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (7);  			}  			DebugLocation (105' 60);  			// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  			int alt8 = 2;  			try {  				DebugEnterSubRule (8);  				try {  					DebugEnterDecision (8' false);  					int LA8_1 = input.LA (1);  					if ((LA8_1 == 24)) {  						alt8 = 1;  					}  				}  				finally {  					DebugExitDecision (8);  				}  				switch (alt8) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  					{  						DebugLocation (105' 60);  						not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (8);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (106' 4);  			FilterTreeNode newProperty = new Property (propertySegments);  			if ((inverse != null ? inverse.Text : default(string)) == "?")  				filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  			else {  				if ((not != null ? not.Text : default(string)) == "!")  					newProperty.ToggleInversed ();  				filterNode = newProperty;  			}  		}  		break;  	case 4:  		DebugEnterAlt (4);  		// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  		{  			DebugLocation (116' 4);  			STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  			DebugLocation (117' 4);  			string stringText = (STRING7 != null ? STRING7.Text : default(string));  			stringText = stringText.Substring (1' stringText.Length - 2);  			filterNode = new Value (stringText);  		}  		break;  	case 5:  		DebugEnterAlt (5);  		// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  		{  			DebugLocation (122' 4);  			REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  			DebugLocation (123' 4);  			string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  			regexText = regexText.Substring (1' regexText.Length - 2);  			filterNode = new RegExp (regexText);  		}  		break;  	case 6:  		DebugEnterAlt (6);  		// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  		{  			DebugLocation (128' 4);  			NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  			DebugLocation (129' 4);  			filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  		}  		break;  	case 7:  		DebugEnterAlt (7);  		// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  		{  			DebugLocation (132' 4);  			Match (input' TRUE' Follow._TRUE_in_filterExpr271);  			DebugLocation (133' 4);  			filterNode = new Value (true);  		}  		break;  	case 8:  		DebugEnterAlt (8);  		// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  		{  			DebugLocation (136' 4);  			Match (input' FALSE' Follow._FALSE_in_filterExpr281);  			DebugLocation (137' 4);  			filterNode = new Value (false);  		}  		break;  	case 9:  		DebugEnterAlt (9);  		// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  		{  			DebugLocation (140' 4);  			Match (input' NULL' Follow._NULL_in_filterExpr291);  			DebugLocation (141' 4);  			filterNode = new Value (null);  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("filterExpr"' 6);  	LeaveRule ("filterExpr"' 6);  	LeaveRule_filterExpr ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  	int alt9 = 9;  	try {  		DebugEnterDecision (9' false);  		switch (input.LA (1)) {  		case CHAIN_OPERATOR:  		case COMPARATOR:  			{  				alt9 = 1;  			}  			break;  		case EXPR:  			{  				int LA9_2 = input.LA (2);  				if ((LA9_2 == DOWN)) {  					int LA9_3 = input.LA (3);  					if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  						alt9 = 2;  					}  					else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  						alt9 = 3;  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				else {  					NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  					DebugRecognitionException (nvae);  					throw nvae;  				}  			}  			break;  		case STRING:  			{  				alt9 = 4;  			}  			break;  		case REGEX:  			{  				alt9 = 5;  			}  			break;  		case NUMBER:  			{  				alt9 = 6;  			}  			break;  		case TRUE:  			{  				alt9 = 7;  			}  			break;  		case FALSE:  			{  				alt9 = 8;  			}  			break;  		case NULL:  			{  				alt9 = 9;  			}  			break;  		default: {  			NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  		}  	}  	finally {  		DebugExitDecision (9);  	}  	switch (alt9) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  		{  			DebugLocation (64' 4);  			DebugLocation (64' 6);  			PushFollow (Follow._comparator_in_filterExpr175);  			comparator6 = comparator ();  			PopFollow ();  			Match (input' TokenTypes.Down' null);  			DebugLocation (64' 18);  			PushFollow (Follow._filterExpr_in_filterExpr179);  			a = filterExpr ();  			PopFollow ();  			DebugLocation (64' 31);  			PushFollow (Follow._filterExpr_in_filterExpr183);  			b = filterExpr ();  			PopFollow ();  			Match (input' TokenTypes.Up' null);  			DebugLocation (65' 4);  			Comparator newComparator;  			switch (comparator6) {  			case "=":  				newComparator = Comparator.Equals;  				break;  			case "!=":  				newComparator = Comparator.NotEquals;  				break;  			case ">":  				newComparator = Comparator.Greater;  				break;  			case "<":  				newComparator = Comparator.Less;  				break;  			case ">=":  				newComparator = Comparator.GreaterOrEqual;  				break;  			case "<=":  				newComparator = Comparator.LessOrEqual;  				break;  			case "&":  				newComparator = Comparator.And;  				break;  			case "|":  				newComparator = Comparator.Or;  				break;  			default:  				newComparator = Comparator.Equals;  				break;  			}  			filterNode = new BoolExpression (a' newComparator' b);  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  		{  			DebugLocation (98' 4);  			DebugLocation (98' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr195);  			Match (input' TokenTypes.Down' null);  			DebugLocation (98' 12);  			PushFollow (Follow._filterExpr_in_filterExpr199);  			f = filterExpr ();  			PopFollow ();  			DebugLocation (98' 31);  			// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  			int alt6 = 2;  			try {  				DebugEnterSubRule (6);  				try {  					DebugEnterDecision (6' false);  					int LA6_1 = input.LA (1);  					if ((LA6_1 == 24)) {  						alt6 = 1;  					}  				}  				finally {  					DebugExitDecision (6);  				}  				switch (alt6) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  					{  						DebugLocation (98' 31);  						inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (6);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (99' 4);  			FilterTreeNode newNode = f;  			if ((inverse != null ? inverse.Text : default(string)) == "!")  				newNode.ToggleInversed ();  			filterNode = newNode;  		}  		break;  	case 3:  		DebugEnterAlt (3);  		// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  		{  			DebugLocation (105' 4);  			DebugLocation (105' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr216);  			Match (input' TokenTypes.Down' null);  			DebugLocation (105' 12);  			PushFollow (Follow._propertyChain_in_filterExpr219);  			propertyChain (propertySegments);  			PopFollow ();  			DebugLocation (105' 51);  			// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  			int alt7 = 2;  			try {  				DebugEnterSubRule (7);  				try {  					DebugEnterDecision (7' false);  					int LA7_1 = input.LA (1);  					if ((LA7_1 == 31)) {  						alt7 = 1;  					}  				}  				finally {  					DebugExitDecision (7);  				}  				switch (alt7) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  					{  						DebugLocation (105' 51);  						inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (7);  			}  			DebugLocation (105' 60);  			// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  			int alt8 = 2;  			try {  				DebugEnterSubRule (8);  				try {  					DebugEnterDecision (8' false);  					int LA8_1 = input.LA (1);  					if ((LA8_1 == 24)) {  						alt8 = 1;  					}  				}  				finally {  					DebugExitDecision (8);  				}  				switch (alt8) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  					{  						DebugLocation (105' 60);  						not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (8);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (106' 4);  			FilterTreeNode newProperty = new Property (propertySegments);  			if ((inverse != null ? inverse.Text : default(string)) == "?")  				filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  			else {  				if ((not != null ? not.Text : default(string)) == "!")  					newProperty.ToggleInversed ();  				filterNode = newProperty;  			}  		}  		break;  	case 4:  		DebugEnterAlt (4);  		// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  		{  			DebugLocation (116' 4);  			STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  			DebugLocation (117' 4);  			string stringText = (STRING7 != null ? STRING7.Text : default(string));  			stringText = stringText.Substring (1' stringText.Length - 2);  			filterNode = new Value (stringText);  		}  		break;  	case 5:  		DebugEnterAlt (5);  		// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  		{  			DebugLocation (122' 4);  			REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  			DebugLocation (123' 4);  			string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  			regexText = regexText.Substring (1' regexText.Length - 2);  			filterNode = new RegExp (regexText);  		}  		break;  	case 6:  		DebugEnterAlt (6);  		// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  		{  			DebugLocation (128' 4);  			NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  			DebugLocation (129' 4);  			filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  		}  		break;  	case 7:  		DebugEnterAlt (7);  		// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  		{  			DebugLocation (132' 4);  			Match (input' TRUE' Follow._TRUE_in_filterExpr271);  			DebugLocation (133' 4);  			filterNode = new Value (true);  		}  		break;  	case 8:  		DebugEnterAlt (8);  		// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  		{  			DebugLocation (136' 4);  			Match (input' FALSE' Follow._FALSE_in_filterExpr281);  			DebugLocation (137' 4);  			filterNode = new Value (false);  		}  		break;  	case 9:  		DebugEnterAlt (9);  		// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  		{  			DebugLocation (140' 4);  			Match (input' NULL' Follow._NULL_in_filterExpr291);  			DebugLocation (141' 4);  			filterNode = new Value (null);  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("filterExpr"' 6);  	LeaveRule ("filterExpr"' 6);  	LeaveRule_filterExpr ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  	int alt9 = 9;  	try {  		DebugEnterDecision (9' false);  		switch (input.LA (1)) {  		case CHAIN_OPERATOR:  		case COMPARATOR:  			{  				alt9 = 1;  			}  			break;  		case EXPR:  			{  				int LA9_2 = input.LA (2);  				if ((LA9_2 == DOWN)) {  					int LA9_3 = input.LA (3);  					if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  						alt9 = 2;  					}  					else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  						alt9 = 3;  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				else {  					NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  					DebugRecognitionException (nvae);  					throw nvae;  				}  			}  			break;  		case STRING:  			{  				alt9 = 4;  			}  			break;  		case REGEX:  			{  				alt9 = 5;  			}  			break;  		case NUMBER:  			{  				alt9 = 6;  			}  			break;  		case TRUE:  			{  				alt9 = 7;  			}  			break;  		case FALSE:  			{  				alt9 = 8;  			}  			break;  		case NULL:  			{  				alt9 = 9;  			}  			break;  		default: {  			NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  		}  	}  	finally {  		DebugExitDecision (9);  	}  	switch (alt9) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  		{  			DebugLocation (64' 4);  			DebugLocation (64' 6);  			PushFollow (Follow._comparator_in_filterExpr175);  			comparator6 = comparator ();  			PopFollow ();  			Match (input' TokenTypes.Down' null);  			DebugLocation (64' 18);  			PushFollow (Follow._filterExpr_in_filterExpr179);  			a = filterExpr ();  			PopFollow ();  			DebugLocation (64' 31);  			PushFollow (Follow._filterExpr_in_filterExpr183);  			b = filterExpr ();  			PopFollow ();  			Match (input' TokenTypes.Up' null);  			DebugLocation (65' 4);  			Comparator newComparator;  			switch (comparator6) {  			case "=":  				newComparator = Comparator.Equals;  				break;  			case "!=":  				newComparator = Comparator.NotEquals;  				break;  			case ">":  				newComparator = Comparator.Greater;  				break;  			case "<":  				newComparator = Comparator.Less;  				break;  			case ">=":  				newComparator = Comparator.GreaterOrEqual;  				break;  			case "<=":  				newComparator = Comparator.LessOrEqual;  				break;  			case "&":  				newComparator = Comparator.And;  				break;  			case "|":  				newComparator = Comparator.Or;  				break;  			default:  				newComparator = Comparator.Equals;  				break;  			}  			filterNode = new BoolExpression (a' newComparator' b);  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  		{  			DebugLocation (98' 4);  			DebugLocation (98' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr195);  			Match (input' TokenTypes.Down' null);  			DebugLocation (98' 12);  			PushFollow (Follow._filterExpr_in_filterExpr199);  			f = filterExpr ();  			PopFollow ();  			DebugLocation (98' 31);  			// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  			int alt6 = 2;  			try {  				DebugEnterSubRule (6);  				try {  					DebugEnterDecision (6' false);  					int LA6_1 = input.LA (1);  					if ((LA6_1 == 24)) {  						alt6 = 1;  					}  				}  				finally {  					DebugExitDecision (6);  				}  				switch (alt6) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  					{  						DebugLocation (98' 31);  						inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (6);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (99' 4);  			FilterTreeNode newNode = f;  			if ((inverse != null ? inverse.Text : default(string)) == "!")  				newNode.ToggleInversed ();  			filterNode = newNode;  		}  		break;  	case 3:  		DebugEnterAlt (3);  		// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  		{  			DebugLocation (105' 4);  			DebugLocation (105' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr216);  			Match (input' TokenTypes.Down' null);  			DebugLocation (105' 12);  			PushFollow (Follow._propertyChain_in_filterExpr219);  			propertyChain (propertySegments);  			PopFollow ();  			DebugLocation (105' 51);  			// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  			int alt7 = 2;  			try {  				DebugEnterSubRule (7);  				try {  					DebugEnterDecision (7' false);  					int LA7_1 = input.LA (1);  					if ((LA7_1 == 31)) {  						alt7 = 1;  					}  				}  				finally {  					DebugExitDecision (7);  				}  				switch (alt7) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  					{  						DebugLocation (105' 51);  						inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (7);  			}  			DebugLocation (105' 60);  			// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  			int alt8 = 2;  			try {  				DebugEnterSubRule (8);  				try {  					DebugEnterDecision (8' false);  					int LA8_1 = input.LA (1);  					if ((LA8_1 == 24)) {  						alt8 = 1;  					}  				}  				finally {  					DebugExitDecision (8);  				}  				switch (alt8) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  					{  						DebugLocation (105' 60);  						not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (8);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (106' 4);  			FilterTreeNode newProperty = new Property (propertySegments);  			if ((inverse != null ? inverse.Text : default(string)) == "?")  				filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  			else {  				if ((not != null ? not.Text : default(string)) == "!")  					newProperty.ToggleInversed ();  				filterNode = newProperty;  			}  		}  		break;  	case 4:  		DebugEnterAlt (4);  		// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  		{  			DebugLocation (116' 4);  			STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  			DebugLocation (117' 4);  			string stringText = (STRING7 != null ? STRING7.Text : default(string));  			stringText = stringText.Substring (1' stringText.Length - 2);  			filterNode = new Value (stringText);  		}  		break;  	case 5:  		DebugEnterAlt (5);  		// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  		{  			DebugLocation (122' 4);  			REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  			DebugLocation (123' 4);  			string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  			regexText = regexText.Substring (1' regexText.Length - 2);  			filterNode = new RegExp (regexText);  		}  		break;  	case 6:  		DebugEnterAlt (6);  		// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  		{  			DebugLocation (128' 4);  			NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  			DebugLocation (129' 4);  			filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  		}  		break;  	case 7:  		DebugEnterAlt (7);  		// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  		{  			DebugLocation (132' 4);  			Match (input' TRUE' Follow._TRUE_in_filterExpr271);  			DebugLocation (133' 4);  			filterNode = new Value (true);  		}  		break;  	case 8:  		DebugEnterAlt (8);  		// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  		{  			DebugLocation (136' 4);  			Match (input' FALSE' Follow._FALSE_in_filterExpr281);  			DebugLocation (137' 4);  			filterNode = new Value (false);  		}  		break;  	case 9:  		DebugEnterAlt (9);  		// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  		{  			DebugLocation (140' 4);  			Match (input' NULL' Follow._NULL_in_filterExpr291);  			DebugLocation (141' 4);  			filterNode = new Value (null);  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("filterExpr"' 6);  	LeaveRule ("filterExpr"' 6);  	LeaveRule_filterExpr ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  	int alt9 = 9;  	try {  		DebugEnterDecision (9' false);  		switch (input.LA (1)) {  		case CHAIN_OPERATOR:  		case COMPARATOR:  			{  				alt9 = 1;  			}  			break;  		case EXPR:  			{  				int LA9_2 = input.LA (2);  				if ((LA9_2 == DOWN)) {  					int LA9_3 = input.LA (3);  					if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  						alt9 = 2;  					}  					else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  						alt9 = 3;  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				else {  					NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  					DebugRecognitionException (nvae);  					throw nvae;  				}  			}  			break;  		case STRING:  			{  				alt9 = 4;  			}  			break;  		case REGEX:  			{  				alt9 = 5;  			}  			break;  		case NUMBER:  			{  				alt9 = 6;  			}  			break;  		case TRUE:  			{  				alt9 = 7;  			}  			break;  		case FALSE:  			{  				alt9 = 8;  			}  			break;  		case NULL:  			{  				alt9 = 9;  			}  			break;  		default: {  			NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  		}  	}  	finally {  		DebugExitDecision (9);  	}  	switch (alt9) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  		{  			DebugLocation (64' 4);  			DebugLocation (64' 6);  			PushFollow (Follow._comparator_in_filterExpr175);  			comparator6 = comparator ();  			PopFollow ();  			Match (input' TokenTypes.Down' null);  			DebugLocation (64' 18);  			PushFollow (Follow._filterExpr_in_filterExpr179);  			a = filterExpr ();  			PopFollow ();  			DebugLocation (64' 31);  			PushFollow (Follow._filterExpr_in_filterExpr183);  			b = filterExpr ();  			PopFollow ();  			Match (input' TokenTypes.Up' null);  			DebugLocation (65' 4);  			Comparator newComparator;  			switch (comparator6) {  			case "=":  				newComparator = Comparator.Equals;  				break;  			case "!=":  				newComparator = Comparator.NotEquals;  				break;  			case ">":  				newComparator = Comparator.Greater;  				break;  			case "<":  				newComparator = Comparator.Less;  				break;  			case ">=":  				newComparator = Comparator.GreaterOrEqual;  				break;  			case "<=":  				newComparator = Comparator.LessOrEqual;  				break;  			case "&":  				newComparator = Comparator.And;  				break;  			case "|":  				newComparator = Comparator.Or;  				break;  			default:  				newComparator = Comparator.Equals;  				break;  			}  			filterNode = new BoolExpression (a' newComparator' b);  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  		{  			DebugLocation (98' 4);  			DebugLocation (98' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr195);  			Match (input' TokenTypes.Down' null);  			DebugLocation (98' 12);  			PushFollow (Follow._filterExpr_in_filterExpr199);  			f = filterExpr ();  			PopFollow ();  			DebugLocation (98' 31);  			// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  			int alt6 = 2;  			try {  				DebugEnterSubRule (6);  				try {  					DebugEnterDecision (6' false);  					int LA6_1 = input.LA (1);  					if ((LA6_1 == 24)) {  						alt6 = 1;  					}  				}  				finally {  					DebugExitDecision (6);  				}  				switch (alt6) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  					{  						DebugLocation (98' 31);  						inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (6);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (99' 4);  			FilterTreeNode newNode = f;  			if ((inverse != null ? inverse.Text : default(string)) == "!")  				newNode.ToggleInversed ();  			filterNode = newNode;  		}  		break;  	case 3:  		DebugEnterAlt (3);  		// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  		{  			DebugLocation (105' 4);  			DebugLocation (105' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr216);  			Match (input' TokenTypes.Down' null);  			DebugLocation (105' 12);  			PushFollow (Follow._propertyChain_in_filterExpr219);  			propertyChain (propertySegments);  			PopFollow ();  			DebugLocation (105' 51);  			// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  			int alt7 = 2;  			try {  				DebugEnterSubRule (7);  				try {  					DebugEnterDecision (7' false);  					int LA7_1 = input.LA (1);  					if ((LA7_1 == 31)) {  						alt7 = 1;  					}  				}  				finally {  					DebugExitDecision (7);  				}  				switch (alt7) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  					{  						DebugLocation (105' 51);  						inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (7);  			}  			DebugLocation (105' 60);  			// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  			int alt8 = 2;  			try {  				DebugEnterSubRule (8);  				try {  					DebugEnterDecision (8' false);  					int LA8_1 = input.LA (1);  					if ((LA8_1 == 24)) {  						alt8 = 1;  					}  				}  				finally {  					DebugExitDecision (8);  				}  				switch (alt8) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  					{  						DebugLocation (105' 60);  						not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (8);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (106' 4);  			FilterTreeNode newProperty = new Property (propertySegments);  			if ((inverse != null ? inverse.Text : default(string)) == "?")  				filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  			else {  				if ((not != null ? not.Text : default(string)) == "!")  					newProperty.ToggleInversed ();  				filterNode = newProperty;  			}  		}  		break;  	case 4:  		DebugEnterAlt (4);  		// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  		{  			DebugLocation (116' 4);  			STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  			DebugLocation (117' 4);  			string stringText = (STRING7 != null ? STRING7.Text : default(string));  			stringText = stringText.Substring (1' stringText.Length - 2);  			filterNode = new Value (stringText);  		}  		break;  	case 5:  		DebugEnterAlt (5);  		// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  		{  			DebugLocation (122' 4);  			REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  			DebugLocation (123' 4);  			string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  			regexText = regexText.Substring (1' regexText.Length - 2);  			filterNode = new RegExp (regexText);  		}  		break;  	case 6:  		DebugEnterAlt (6);  		// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  		{  			DebugLocation (128' 4);  			NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  			DebugLocation (129' 4);  			filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  		}  		break;  	case 7:  		DebugEnterAlt (7);  		// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  		{  			DebugLocation (132' 4);  			Match (input' TRUE' Follow._TRUE_in_filterExpr271);  			DebugLocation (133' 4);  			filterNode = new Value (true);  		}  		break;  	case 8:  		DebugEnterAlt (8);  		// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  		{  			DebugLocation (136' 4);  			Match (input' FALSE' Follow._FALSE_in_filterExpr281);  			DebugLocation (137' 4);  			filterNode = new Value (false);  		}  		break;  	case 9:  		DebugEnterAlt (9);  		// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  		{  			DebugLocation (140' 4);  			Match (input' NULL' Follow._NULL_in_filterExpr291);  			DebugLocation (141' 4);  			filterNode = new Value (null);  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("filterExpr"' 6);  	LeaveRule ("filterExpr"' 6);  	LeaveRule_filterExpr ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  	int alt9 = 9;  	try {  		DebugEnterDecision (9' false);  		switch (input.LA (1)) {  		case CHAIN_OPERATOR:  		case COMPARATOR:  			{  				alt9 = 1;  			}  			break;  		case EXPR:  			{  				int LA9_2 = input.LA (2);  				if ((LA9_2 == DOWN)) {  					int LA9_3 = input.LA (3);  					if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  						alt9 = 2;  					}  					else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  						alt9 = 3;  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				else {  					NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  					DebugRecognitionException (nvae);  					throw nvae;  				}  			}  			break;  		case STRING:  			{  				alt9 = 4;  			}  			break;  		case REGEX:  			{  				alt9 = 5;  			}  			break;  		case NUMBER:  			{  				alt9 = 6;  			}  			break;  		case TRUE:  			{  				alt9 = 7;  			}  			break;  		case FALSE:  			{  				alt9 = 8;  			}  			break;  		case NULL:  			{  				alt9 = 9;  			}  			break;  		default: {  			NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  		}  	}  	finally {  		DebugExitDecision (9);  	}  	switch (alt9) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  		{  			DebugLocation (64' 4);  			DebugLocation (64' 6);  			PushFollow (Follow._comparator_in_filterExpr175);  			comparator6 = comparator ();  			PopFollow ();  			Match (input' TokenTypes.Down' null);  			DebugLocation (64' 18);  			PushFollow (Follow._filterExpr_in_filterExpr179);  			a = filterExpr ();  			PopFollow ();  			DebugLocation (64' 31);  			PushFollow (Follow._filterExpr_in_filterExpr183);  			b = filterExpr ();  			PopFollow ();  			Match (input' TokenTypes.Up' null);  			DebugLocation (65' 4);  			Comparator newComparator;  			switch (comparator6) {  			case "=":  				newComparator = Comparator.Equals;  				break;  			case "!=":  				newComparator = Comparator.NotEquals;  				break;  			case ">":  				newComparator = Comparator.Greater;  				break;  			case "<":  				newComparator = Comparator.Less;  				break;  			case ">=":  				newComparator = Comparator.GreaterOrEqual;  				break;  			case "<=":  				newComparator = Comparator.LessOrEqual;  				break;  			case "&":  				newComparator = Comparator.And;  				break;  			case "|":  				newComparator = Comparator.Or;  				break;  			default:  				newComparator = Comparator.Equals;  				break;  			}  			filterNode = new BoolExpression (a' newComparator' b);  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  		{  			DebugLocation (98' 4);  			DebugLocation (98' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr195);  			Match (input' TokenTypes.Down' null);  			DebugLocation (98' 12);  			PushFollow (Follow._filterExpr_in_filterExpr199);  			f = filterExpr ();  			PopFollow ();  			DebugLocation (98' 31);  			// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  			int alt6 = 2;  			try {  				DebugEnterSubRule (6);  				try {  					DebugEnterDecision (6' false);  					int LA6_1 = input.LA (1);  					if ((LA6_1 == 24)) {  						alt6 = 1;  					}  				}  				finally {  					DebugExitDecision (6);  				}  				switch (alt6) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  					{  						DebugLocation (98' 31);  						inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (6);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (99' 4);  			FilterTreeNode newNode = f;  			if ((inverse != null ? inverse.Text : default(string)) == "!")  				newNode.ToggleInversed ();  			filterNode = newNode;  		}  		break;  	case 3:  		DebugEnterAlt (3);  		// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  		{  			DebugLocation (105' 4);  			DebugLocation (105' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr216);  			Match (input' TokenTypes.Down' null);  			DebugLocation (105' 12);  			PushFollow (Follow._propertyChain_in_filterExpr219);  			propertyChain (propertySegments);  			PopFollow ();  			DebugLocation (105' 51);  			// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  			int alt7 = 2;  			try {  				DebugEnterSubRule (7);  				try {  					DebugEnterDecision (7' false);  					int LA7_1 = input.LA (1);  					if ((LA7_1 == 31)) {  						alt7 = 1;  					}  				}  				finally {  					DebugExitDecision (7);  				}  				switch (alt7) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  					{  						DebugLocation (105' 51);  						inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (7);  			}  			DebugLocation (105' 60);  			// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  			int alt8 = 2;  			try {  				DebugEnterSubRule (8);  				try {  					DebugEnterDecision (8' false);  					int LA8_1 = input.LA (1);  					if ((LA8_1 == 24)) {  						alt8 = 1;  					}  				}  				finally {  					DebugExitDecision (8);  				}  				switch (alt8) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  					{  						DebugLocation (105' 60);  						not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (8);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (106' 4);  			FilterTreeNode newProperty = new Property (propertySegments);  			if ((inverse != null ? inverse.Text : default(string)) == "?")  				filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  			else {  				if ((not != null ? not.Text : default(string)) == "!")  					newProperty.ToggleInversed ();  				filterNode = newProperty;  			}  		}  		break;  	case 4:  		DebugEnterAlt (4);  		// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  		{  			DebugLocation (116' 4);  			STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  			DebugLocation (117' 4);  			string stringText = (STRING7 != null ? STRING7.Text : default(string));  			stringText = stringText.Substring (1' stringText.Length - 2);  			filterNode = new Value (stringText);  		}  		break;  	case 5:  		DebugEnterAlt (5);  		// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  		{  			DebugLocation (122' 4);  			REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  			DebugLocation (123' 4);  			string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  			regexText = regexText.Substring (1' regexText.Length - 2);  			filterNode = new RegExp (regexText);  		}  		break;  	case 6:  		DebugEnterAlt (6);  		// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  		{  			DebugLocation (128' 4);  			NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  			DebugLocation (129' 4);  			filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  		}  		break;  	case 7:  		DebugEnterAlt (7);  		// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  		{  			DebugLocation (132' 4);  			Match (input' TRUE' Follow._TRUE_in_filterExpr271);  			DebugLocation (133' 4);  			filterNode = new Value (true);  		}  		break;  	case 8:  		DebugEnterAlt (8);  		// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  		{  			DebugLocation (136' 4);  			Match (input' FALSE' Follow._FALSE_in_filterExpr281);  			DebugLocation (137' 4);  			filterNode = new Value (false);  		}  		break;  	case 9:  		DebugEnterAlt (9);  		// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  		{  			DebugLocation (140' 4);  			Match (input' NULL' Follow._NULL_in_filterExpr291);  			DebugLocation (141' 4);  			filterNode = new Value (null);  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("filterExpr"' 6);  	LeaveRule ("filterExpr"' 6);  	LeaveRule_filterExpr ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  	int alt9 = 9;  	try {  		DebugEnterDecision (9' false);  		switch (input.LA (1)) {  		case CHAIN_OPERATOR:  		case COMPARATOR:  			{  				alt9 = 1;  			}  			break;  		case EXPR:  			{  				int LA9_2 = input.LA (2);  				if ((LA9_2 == DOWN)) {  					int LA9_3 = input.LA (3);  					if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  						alt9 = 2;  					}  					else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  						alt9 = 3;  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				else {  					NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  					DebugRecognitionException (nvae);  					throw nvae;  				}  			}  			break;  		case STRING:  			{  				alt9 = 4;  			}  			break;  		case REGEX:  			{  				alt9 = 5;  			}  			break;  		case NUMBER:  			{  				alt9 = 6;  			}  			break;  		case TRUE:  			{  				alt9 = 7;  			}  			break;  		case FALSE:  			{  				alt9 = 8;  			}  			break;  		case NULL:  			{  				alt9 = 9;  			}  			break;  		default: {  			NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  		}  	}  	finally {  		DebugExitDecision (9);  	}  	switch (alt9) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  		{  			DebugLocation (64' 4);  			DebugLocation (64' 6);  			PushFollow (Follow._comparator_in_filterExpr175);  			comparator6 = comparator ();  			PopFollow ();  			Match (input' TokenTypes.Down' null);  			DebugLocation (64' 18);  			PushFollow (Follow._filterExpr_in_filterExpr179);  			a = filterExpr ();  			PopFollow ();  			DebugLocation (64' 31);  			PushFollow (Follow._filterExpr_in_filterExpr183);  			b = filterExpr ();  			PopFollow ();  			Match (input' TokenTypes.Up' null);  			DebugLocation (65' 4);  			Comparator newComparator;  			switch (comparator6) {  			case "=":  				newComparator = Comparator.Equals;  				break;  			case "!=":  				newComparator = Comparator.NotEquals;  				break;  			case ">":  				newComparator = Comparator.Greater;  				break;  			case "<":  				newComparator = Comparator.Less;  				break;  			case ">=":  				newComparator = Comparator.GreaterOrEqual;  				break;  			case "<=":  				newComparator = Comparator.LessOrEqual;  				break;  			case "&":  				newComparator = Comparator.And;  				break;  			case "|":  				newComparator = Comparator.Or;  				break;  			default:  				newComparator = Comparator.Equals;  				break;  			}  			filterNode = new BoolExpression (a' newComparator' b);  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  		{  			DebugLocation (98' 4);  			DebugLocation (98' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr195);  			Match (input' TokenTypes.Down' null);  			DebugLocation (98' 12);  			PushFollow (Follow._filterExpr_in_filterExpr199);  			f = filterExpr ();  			PopFollow ();  			DebugLocation (98' 31);  			// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  			int alt6 = 2;  			try {  				DebugEnterSubRule (6);  				try {  					DebugEnterDecision (6' false);  					int LA6_1 = input.LA (1);  					if ((LA6_1 == 24)) {  						alt6 = 1;  					}  				}  				finally {  					DebugExitDecision (6);  				}  				switch (alt6) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  					{  						DebugLocation (98' 31);  						inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (6);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (99' 4);  			FilterTreeNode newNode = f;  			if ((inverse != null ? inverse.Text : default(string)) == "!")  				newNode.ToggleInversed ();  			filterNode = newNode;  		}  		break;  	case 3:  		DebugEnterAlt (3);  		// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  		{  			DebugLocation (105' 4);  			DebugLocation (105' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr216);  			Match (input' TokenTypes.Down' null);  			DebugLocation (105' 12);  			PushFollow (Follow._propertyChain_in_filterExpr219);  			propertyChain (propertySegments);  			PopFollow ();  			DebugLocation (105' 51);  			// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  			int alt7 = 2;  			try {  				DebugEnterSubRule (7);  				try {  					DebugEnterDecision (7' false);  					int LA7_1 = input.LA (1);  					if ((LA7_1 == 31)) {  						alt7 = 1;  					}  				}  				finally {  					DebugExitDecision (7);  				}  				switch (alt7) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  					{  						DebugLocation (105' 51);  						inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (7);  			}  			DebugLocation (105' 60);  			// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  			int alt8 = 2;  			try {  				DebugEnterSubRule (8);  				try {  					DebugEnterDecision (8' false);  					int LA8_1 = input.LA (1);  					if ((LA8_1 == 24)) {  						alt8 = 1;  					}  				}  				finally {  					DebugExitDecision (8);  				}  				switch (alt8) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  					{  						DebugLocation (105' 60);  						not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (8);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (106' 4);  			FilterTreeNode newProperty = new Property (propertySegments);  			if ((inverse != null ? inverse.Text : default(string)) == "?")  				filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  			else {  				if ((not != null ? not.Text : default(string)) == "!")  					newProperty.ToggleInversed ();  				filterNode = newProperty;  			}  		}  		break;  	case 4:  		DebugEnterAlt (4);  		// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  		{  			DebugLocation (116' 4);  			STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  			DebugLocation (117' 4);  			string stringText = (STRING7 != null ? STRING7.Text : default(string));  			stringText = stringText.Substring (1' stringText.Length - 2);  			filterNode = new Value (stringText);  		}  		break;  	case 5:  		DebugEnterAlt (5);  		// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  		{  			DebugLocation (122' 4);  			REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  			DebugLocation (123' 4);  			string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  			regexText = regexText.Substring (1' regexText.Length - 2);  			filterNode = new RegExp (regexText);  		}  		break;  	case 6:  		DebugEnterAlt (6);  		// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  		{  			DebugLocation (128' 4);  			NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  			DebugLocation (129' 4);  			filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  		}  		break;  	case 7:  		DebugEnterAlt (7);  		// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  		{  			DebugLocation (132' 4);  			Match (input' TRUE' Follow._TRUE_in_filterExpr271);  			DebugLocation (133' 4);  			filterNode = new Value (true);  		}  		break;  	case 8:  		DebugEnterAlt (8);  		// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  		{  			DebugLocation (136' 4);  			Match (input' FALSE' Follow._FALSE_in_filterExpr281);  			DebugLocation (137' 4);  			filterNode = new Value (false);  		}  		break;  	case 9:  		DebugEnterAlt (9);  		// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  		{  			DebugLocation (140' 4);  			Match (input' NULL' Follow._NULL_in_filterExpr291);  			DebugLocation (141' 4);  			filterNode = new Value (null);  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("filterExpr"' 6);  	LeaveRule ("filterExpr"' 6);  	LeaveRule_filterExpr ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  	int alt9 = 9;  	try {  		DebugEnterDecision (9' false);  		switch (input.LA (1)) {  		case CHAIN_OPERATOR:  		case COMPARATOR:  			{  				alt9 = 1;  			}  			break;  		case EXPR:  			{  				int LA9_2 = input.LA (2);  				if ((LA9_2 == DOWN)) {  					int LA9_3 = input.LA (3);  					if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  						alt9 = 2;  					}  					else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  						alt9 = 3;  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				else {  					NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  					DebugRecognitionException (nvae);  					throw nvae;  				}  			}  			break;  		case STRING:  			{  				alt9 = 4;  			}  			break;  		case REGEX:  			{  				alt9 = 5;  			}  			break;  		case NUMBER:  			{  				alt9 = 6;  			}  			break;  		case TRUE:  			{  				alt9 = 7;  			}  			break;  		case FALSE:  			{  				alt9 = 8;  			}  			break;  		case NULL:  			{  				alt9 = 9;  			}  			break;  		default: {  			NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  		}  	}  	finally {  		DebugExitDecision (9);  	}  	switch (alt9) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  		{  			DebugLocation (64' 4);  			DebugLocation (64' 6);  			PushFollow (Follow._comparator_in_filterExpr175);  			comparator6 = comparator ();  			PopFollow ();  			Match (input' TokenTypes.Down' null);  			DebugLocation (64' 18);  			PushFollow (Follow._filterExpr_in_filterExpr179);  			a = filterExpr ();  			PopFollow ();  			DebugLocation (64' 31);  			PushFollow (Follow._filterExpr_in_filterExpr183);  			b = filterExpr ();  			PopFollow ();  			Match (input' TokenTypes.Up' null);  			DebugLocation (65' 4);  			Comparator newComparator;  			switch (comparator6) {  			case "=":  				newComparator = Comparator.Equals;  				break;  			case "!=":  				newComparator = Comparator.NotEquals;  				break;  			case ">":  				newComparator = Comparator.Greater;  				break;  			case "<":  				newComparator = Comparator.Less;  				break;  			case ">=":  				newComparator = Comparator.GreaterOrEqual;  				break;  			case "<=":  				newComparator = Comparator.LessOrEqual;  				break;  			case "&":  				newComparator = Comparator.And;  				break;  			case "|":  				newComparator = Comparator.Or;  				break;  			default:  				newComparator = Comparator.Equals;  				break;  			}  			filterNode = new BoolExpression (a' newComparator' b);  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  		{  			DebugLocation (98' 4);  			DebugLocation (98' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr195);  			Match (input' TokenTypes.Down' null);  			DebugLocation (98' 12);  			PushFollow (Follow._filterExpr_in_filterExpr199);  			f = filterExpr ();  			PopFollow ();  			DebugLocation (98' 31);  			// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  			int alt6 = 2;  			try {  				DebugEnterSubRule (6);  				try {  					DebugEnterDecision (6' false);  					int LA6_1 = input.LA (1);  					if ((LA6_1 == 24)) {  						alt6 = 1;  					}  				}  				finally {  					DebugExitDecision (6);  				}  				switch (alt6) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  					{  						DebugLocation (98' 31);  						inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (6);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (99' 4);  			FilterTreeNode newNode = f;  			if ((inverse != null ? inverse.Text : default(string)) == "!")  				newNode.ToggleInversed ();  			filterNode = newNode;  		}  		break;  	case 3:  		DebugEnterAlt (3);  		// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  		{  			DebugLocation (105' 4);  			DebugLocation (105' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr216);  			Match (input' TokenTypes.Down' null);  			DebugLocation (105' 12);  			PushFollow (Follow._propertyChain_in_filterExpr219);  			propertyChain (propertySegments);  			PopFollow ();  			DebugLocation (105' 51);  			// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  			int alt7 = 2;  			try {  				DebugEnterSubRule (7);  				try {  					DebugEnterDecision (7' false);  					int LA7_1 = input.LA (1);  					if ((LA7_1 == 31)) {  						alt7 = 1;  					}  				}  				finally {  					DebugExitDecision (7);  				}  				switch (alt7) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  					{  						DebugLocation (105' 51);  						inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (7);  			}  			DebugLocation (105' 60);  			// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  			int alt8 = 2;  			try {  				DebugEnterSubRule (8);  				try {  					DebugEnterDecision (8' false);  					int LA8_1 = input.LA (1);  					if ((LA8_1 == 24)) {  						alt8 = 1;  					}  				}  				finally {  					DebugExitDecision (8);  				}  				switch (alt8) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  					{  						DebugLocation (105' 60);  						not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (8);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (106' 4);  			FilterTreeNode newProperty = new Property (propertySegments);  			if ((inverse != null ? inverse.Text : default(string)) == "?")  				filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  			else {  				if ((not != null ? not.Text : default(string)) == "!")  					newProperty.ToggleInversed ();  				filterNode = newProperty;  			}  		}  		break;  	case 4:  		DebugEnterAlt (4);  		// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  		{  			DebugLocation (116' 4);  			STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  			DebugLocation (117' 4);  			string stringText = (STRING7 != null ? STRING7.Text : default(string));  			stringText = stringText.Substring (1' stringText.Length - 2);  			filterNode = new Value (stringText);  		}  		break;  	case 5:  		DebugEnterAlt (5);  		// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  		{  			DebugLocation (122' 4);  			REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  			DebugLocation (123' 4);  			string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  			regexText = regexText.Substring (1' regexText.Length - 2);  			filterNode = new RegExp (regexText);  		}  		break;  	case 6:  		DebugEnterAlt (6);  		// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  		{  			DebugLocation (128' 4);  			NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  			DebugLocation (129' 4);  			filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  		}  		break;  	case 7:  		DebugEnterAlt (7);  		// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  		{  			DebugLocation (132' 4);  			Match (input' TRUE' Follow._TRUE_in_filterExpr271);  			DebugLocation (133' 4);  			filterNode = new Value (true);  		}  		break;  	case 8:  		DebugEnterAlt (8);  		// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  		{  			DebugLocation (136' 4);  			Match (input' FALSE' Follow._FALSE_in_filterExpr281);  			DebugLocation (137' 4);  			filterNode = new Value (false);  		}  		break;  	case 9:  		DebugEnterAlt (9);  		// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  		{  			DebugLocation (140' 4);  			Match (input' NULL' Follow._NULL_in_filterExpr291);  			DebugLocation (141' 4);  			filterNode = new Value (null);  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("filterExpr"' 6);  	LeaveRule ("filterExpr"' 6);  	LeaveRule_filterExpr ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  	int alt9 = 9;  	try {  		DebugEnterDecision (9' false);  		switch (input.LA (1)) {  		case CHAIN_OPERATOR:  		case COMPARATOR:  			{  				alt9 = 1;  			}  			break;  		case EXPR:  			{  				int LA9_2 = input.LA (2);  				if ((LA9_2 == DOWN)) {  					int LA9_3 = input.LA (3);  					if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  						alt9 = 2;  					}  					else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  						alt9 = 3;  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				else {  					NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  					DebugRecognitionException (nvae);  					throw nvae;  				}  			}  			break;  		case STRING:  			{  				alt9 = 4;  			}  			break;  		case REGEX:  			{  				alt9 = 5;  			}  			break;  		case NUMBER:  			{  				alt9 = 6;  			}  			break;  		case TRUE:  			{  				alt9 = 7;  			}  			break;  		case FALSE:  			{  				alt9 = 8;  			}  			break;  		case NULL:  			{  				alt9 = 9;  			}  			break;  		default: {  			NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  		}  	}  	finally {  		DebugExitDecision (9);  	}  	switch (alt9) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  		{  			DebugLocation (64' 4);  			DebugLocation (64' 6);  			PushFollow (Follow._comparator_in_filterExpr175);  			comparator6 = comparator ();  			PopFollow ();  			Match (input' TokenTypes.Down' null);  			DebugLocation (64' 18);  			PushFollow (Follow._filterExpr_in_filterExpr179);  			a = filterExpr ();  			PopFollow ();  			DebugLocation (64' 31);  			PushFollow (Follow._filterExpr_in_filterExpr183);  			b = filterExpr ();  			PopFollow ();  			Match (input' TokenTypes.Up' null);  			DebugLocation (65' 4);  			Comparator newComparator;  			switch (comparator6) {  			case "=":  				newComparator = Comparator.Equals;  				break;  			case "!=":  				newComparator = Comparator.NotEquals;  				break;  			case ">":  				newComparator = Comparator.Greater;  				break;  			case "<":  				newComparator = Comparator.Less;  				break;  			case ">=":  				newComparator = Comparator.GreaterOrEqual;  				break;  			case "<=":  				newComparator = Comparator.LessOrEqual;  				break;  			case "&":  				newComparator = Comparator.And;  				break;  			case "|":  				newComparator = Comparator.Or;  				break;  			default:  				newComparator = Comparator.Equals;  				break;  			}  			filterNode = new BoolExpression (a' newComparator' b);  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  		{  			DebugLocation (98' 4);  			DebugLocation (98' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr195);  			Match (input' TokenTypes.Down' null);  			DebugLocation (98' 12);  			PushFollow (Follow._filterExpr_in_filterExpr199);  			f = filterExpr ();  			PopFollow ();  			DebugLocation (98' 31);  			// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  			int alt6 = 2;  			try {  				DebugEnterSubRule (6);  				try {  					DebugEnterDecision (6' false);  					int LA6_1 = input.LA (1);  					if ((LA6_1 == 24)) {  						alt6 = 1;  					}  				}  				finally {  					DebugExitDecision (6);  				}  				switch (alt6) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  					{  						DebugLocation (98' 31);  						inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (6);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (99' 4);  			FilterTreeNode newNode = f;  			if ((inverse != null ? inverse.Text : default(string)) == "!")  				newNode.ToggleInversed ();  			filterNode = newNode;  		}  		break;  	case 3:  		DebugEnterAlt (3);  		// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  		{  			DebugLocation (105' 4);  			DebugLocation (105' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr216);  			Match (input' TokenTypes.Down' null);  			DebugLocation (105' 12);  			PushFollow (Follow._propertyChain_in_filterExpr219);  			propertyChain (propertySegments);  			PopFollow ();  			DebugLocation (105' 51);  			// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  			int alt7 = 2;  			try {  				DebugEnterSubRule (7);  				try {  					DebugEnterDecision (7' false);  					int LA7_1 = input.LA (1);  					if ((LA7_1 == 31)) {  						alt7 = 1;  					}  				}  				finally {  					DebugExitDecision (7);  				}  				switch (alt7) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  					{  						DebugLocation (105' 51);  						inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (7);  			}  			DebugLocation (105' 60);  			// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  			int alt8 = 2;  			try {  				DebugEnterSubRule (8);  				try {  					DebugEnterDecision (8' false);  					int LA8_1 = input.LA (1);  					if ((LA8_1 == 24)) {  						alt8 = 1;  					}  				}  				finally {  					DebugExitDecision (8);  				}  				switch (alt8) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  					{  						DebugLocation (105' 60);  						not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (8);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (106' 4);  			FilterTreeNode newProperty = new Property (propertySegments);  			if ((inverse != null ? inverse.Text : default(string)) == "?")  				filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  			else {  				if ((not != null ? not.Text : default(string)) == "!")  					newProperty.ToggleInversed ();  				filterNode = newProperty;  			}  		}  		break;  	case 4:  		DebugEnterAlt (4);  		// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  		{  			DebugLocation (116' 4);  			STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  			DebugLocation (117' 4);  			string stringText = (STRING7 != null ? STRING7.Text : default(string));  			stringText = stringText.Substring (1' stringText.Length - 2);  			filterNode = new Value (stringText);  		}  		break;  	case 5:  		DebugEnterAlt (5);  		// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  		{  			DebugLocation (122' 4);  			REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  			DebugLocation (123' 4);  			string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  			regexText = regexText.Substring (1' regexText.Length - 2);  			filterNode = new RegExp (regexText);  		}  		break;  	case 6:  		DebugEnterAlt (6);  		// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  		{  			DebugLocation (128' 4);  			NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  			DebugLocation (129' 4);  			filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  		}  		break;  	case 7:  		DebugEnterAlt (7);  		// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  		{  			DebugLocation (132' 4);  			Match (input' TRUE' Follow._TRUE_in_filterExpr271);  			DebugLocation (133' 4);  			filterNode = new Value (true);  		}  		break;  	case 8:  		DebugEnterAlt (8);  		// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  		{  			DebugLocation (136' 4);  			Match (input' FALSE' Follow._FALSE_in_filterExpr281);  			DebugLocation (137' 4);  			filterNode = new Value (false);  		}  		break;  	case 9:  		DebugEnterAlt (9);  		// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  		{  			DebugLocation (140' 4);  			Match (input' NULL' Follow._NULL_in_filterExpr291);  			DebugLocation (141' 4);  			filterNode = new Value (null);  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("filterExpr"' 6);  	LeaveRule ("filterExpr"' 6);  	LeaveRule_filterExpr ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  	int alt9 = 9;  	try {  		DebugEnterDecision (9' false);  		switch (input.LA (1)) {  		case CHAIN_OPERATOR:  		case COMPARATOR:  			{  				alt9 = 1;  			}  			break;  		case EXPR:  			{  				int LA9_2 = input.LA (2);  				if ((LA9_2 == DOWN)) {  					int LA9_3 = input.LA (3);  					if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  						alt9 = 2;  					}  					else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  						alt9 = 3;  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				else {  					NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  					DebugRecognitionException (nvae);  					throw nvae;  				}  			}  			break;  		case STRING:  			{  				alt9 = 4;  			}  			break;  		case REGEX:  			{  				alt9 = 5;  			}  			break;  		case NUMBER:  			{  				alt9 = 6;  			}  			break;  		case TRUE:  			{  				alt9 = 7;  			}  			break;  		case FALSE:  			{  				alt9 = 8;  			}  			break;  		case NULL:  			{  				alt9 = 9;  			}  			break;  		default: {  			NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  		}  	}  	finally {  		DebugExitDecision (9);  	}  	switch (alt9) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  		{  			DebugLocation (64' 4);  			DebugLocation (64' 6);  			PushFollow (Follow._comparator_in_filterExpr175);  			comparator6 = comparator ();  			PopFollow ();  			Match (input' TokenTypes.Down' null);  			DebugLocation (64' 18);  			PushFollow (Follow._filterExpr_in_filterExpr179);  			a = filterExpr ();  			PopFollow ();  			DebugLocation (64' 31);  			PushFollow (Follow._filterExpr_in_filterExpr183);  			b = filterExpr ();  			PopFollow ();  			Match (input' TokenTypes.Up' null);  			DebugLocation (65' 4);  			Comparator newComparator;  			switch (comparator6) {  			case "=":  				newComparator = Comparator.Equals;  				break;  			case "!=":  				newComparator = Comparator.NotEquals;  				break;  			case ">":  				newComparator = Comparator.Greater;  				break;  			case "<":  				newComparator = Comparator.Less;  				break;  			case ">=":  				newComparator = Comparator.GreaterOrEqual;  				break;  			case "<=":  				newComparator = Comparator.LessOrEqual;  				break;  			case "&":  				newComparator = Comparator.And;  				break;  			case "|":  				newComparator = Comparator.Or;  				break;  			default:  				newComparator = Comparator.Equals;  				break;  			}  			filterNode = new BoolExpression (a' newComparator' b);  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  		{  			DebugLocation (98' 4);  			DebugLocation (98' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr195);  			Match (input' TokenTypes.Down' null);  			DebugLocation (98' 12);  			PushFollow (Follow._filterExpr_in_filterExpr199);  			f = filterExpr ();  			PopFollow ();  			DebugLocation (98' 31);  			// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  			int alt6 = 2;  			try {  				DebugEnterSubRule (6);  				try {  					DebugEnterDecision (6' false);  					int LA6_1 = input.LA (1);  					if ((LA6_1 == 24)) {  						alt6 = 1;  					}  				}  				finally {  					DebugExitDecision (6);  				}  				switch (alt6) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  					{  						DebugLocation (98' 31);  						inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (6);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (99' 4);  			FilterTreeNode newNode = f;  			if ((inverse != null ? inverse.Text : default(string)) == "!")  				newNode.ToggleInversed ();  			filterNode = newNode;  		}  		break;  	case 3:  		DebugEnterAlt (3);  		// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  		{  			DebugLocation (105' 4);  			DebugLocation (105' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr216);  			Match (input' TokenTypes.Down' null);  			DebugLocation (105' 12);  			PushFollow (Follow._propertyChain_in_filterExpr219);  			propertyChain (propertySegments);  			PopFollow ();  			DebugLocation (105' 51);  			// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  			int alt7 = 2;  			try {  				DebugEnterSubRule (7);  				try {  					DebugEnterDecision (7' false);  					int LA7_1 = input.LA (1);  					if ((LA7_1 == 31)) {  						alt7 = 1;  					}  				}  				finally {  					DebugExitDecision (7);  				}  				switch (alt7) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  					{  						DebugLocation (105' 51);  						inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (7);  			}  			DebugLocation (105' 60);  			// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  			int alt8 = 2;  			try {  				DebugEnterSubRule (8);  				try {  					DebugEnterDecision (8' false);  					int LA8_1 = input.LA (1);  					if ((LA8_1 == 24)) {  						alt8 = 1;  					}  				}  				finally {  					DebugExitDecision (8);  				}  				switch (alt8) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  					{  						DebugLocation (105' 60);  						not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (8);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (106' 4);  			FilterTreeNode newProperty = new Property (propertySegments);  			if ((inverse != null ? inverse.Text : default(string)) == "?")  				filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  			else {  				if ((not != null ? not.Text : default(string)) == "!")  					newProperty.ToggleInversed ();  				filterNode = newProperty;  			}  		}  		break;  	case 4:  		DebugEnterAlt (4);  		// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  		{  			DebugLocation (116' 4);  			STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  			DebugLocation (117' 4);  			string stringText = (STRING7 != null ? STRING7.Text : default(string));  			stringText = stringText.Substring (1' stringText.Length - 2);  			filterNode = new Value (stringText);  		}  		break;  	case 5:  		DebugEnterAlt (5);  		// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  		{  			DebugLocation (122' 4);  			REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  			DebugLocation (123' 4);  			string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  			regexText = regexText.Substring (1' regexText.Length - 2);  			filterNode = new RegExp (regexText);  		}  		break;  	case 6:  		DebugEnterAlt (6);  		// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  		{  			DebugLocation (128' 4);  			NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  			DebugLocation (129' 4);  			filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  		}  		break;  	case 7:  		DebugEnterAlt (7);  		// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  		{  			DebugLocation (132' 4);  			Match (input' TRUE' Follow._TRUE_in_filterExpr271);  			DebugLocation (133' 4);  			filterNode = new Value (true);  		}  		break;  	case 8:  		DebugEnterAlt (8);  		// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  		{  			DebugLocation (136' 4);  			Match (input' FALSE' Follow._FALSE_in_filterExpr281);  			DebugLocation (137' 4);  			filterNode = new Value (false);  		}  		break;  	case 9:  		DebugEnterAlt (9);  		// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  		{  			DebugLocation (140' 4);  			Match (input' NULL' Follow._NULL_in_filterExpr291);  			DebugLocation (141' 4);  			filterNode = new Value (null);  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("filterExpr"' 6);  	LeaveRule ("filterExpr"' 6);  	LeaveRule_filterExpr ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  	int alt9 = 9;  	try {  		DebugEnterDecision (9' false);  		switch (input.LA (1)) {  		case CHAIN_OPERATOR:  		case COMPARATOR:  			{  				alt9 = 1;  			}  			break;  		case EXPR:  			{  				int LA9_2 = input.LA (2);  				if ((LA9_2 == DOWN)) {  					int LA9_3 = input.LA (3);  					if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  						alt9 = 2;  					}  					else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  						alt9 = 3;  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				else {  					NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  					DebugRecognitionException (nvae);  					throw nvae;  				}  			}  			break;  		case STRING:  			{  				alt9 = 4;  			}  			break;  		case REGEX:  			{  				alt9 = 5;  			}  			break;  		case NUMBER:  			{  				alt9 = 6;  			}  			break;  		case TRUE:  			{  				alt9 = 7;  			}  			break;  		case FALSE:  			{  				alt9 = 8;  			}  			break;  		case NULL:  			{  				alt9 = 9;  			}  			break;  		default: {  			NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  		}  	}  	finally {  		DebugExitDecision (9);  	}  	switch (alt9) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  		{  			DebugLocation (64' 4);  			DebugLocation (64' 6);  			PushFollow (Follow._comparator_in_filterExpr175);  			comparator6 = comparator ();  			PopFollow ();  			Match (input' TokenTypes.Down' null);  			DebugLocation (64' 18);  			PushFollow (Follow._filterExpr_in_filterExpr179);  			a = filterExpr ();  			PopFollow ();  			DebugLocation (64' 31);  			PushFollow (Follow._filterExpr_in_filterExpr183);  			b = filterExpr ();  			PopFollow ();  			Match (input' TokenTypes.Up' null);  			DebugLocation (65' 4);  			Comparator newComparator;  			switch (comparator6) {  			case "=":  				newComparator = Comparator.Equals;  				break;  			case "!=":  				newComparator = Comparator.NotEquals;  				break;  			case ">":  				newComparator = Comparator.Greater;  				break;  			case "<":  				newComparator = Comparator.Less;  				break;  			case ">=":  				newComparator = Comparator.GreaterOrEqual;  				break;  			case "<=":  				newComparator = Comparator.LessOrEqual;  				break;  			case "&":  				newComparator = Comparator.And;  				break;  			case "|":  				newComparator = Comparator.Or;  				break;  			default:  				newComparator = Comparator.Equals;  				break;  			}  			filterNode = new BoolExpression (a' newComparator' b);  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  		{  			DebugLocation (98' 4);  			DebugLocation (98' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr195);  			Match (input' TokenTypes.Down' null);  			DebugLocation (98' 12);  			PushFollow (Follow._filterExpr_in_filterExpr199);  			f = filterExpr ();  			PopFollow ();  			DebugLocation (98' 31);  			// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  			int alt6 = 2;  			try {  				DebugEnterSubRule (6);  				try {  					DebugEnterDecision (6' false);  					int LA6_1 = input.LA (1);  					if ((LA6_1 == 24)) {  						alt6 = 1;  					}  				}  				finally {  					DebugExitDecision (6);  				}  				switch (alt6) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  					{  						DebugLocation (98' 31);  						inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (6);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (99' 4);  			FilterTreeNode newNode = f;  			if ((inverse != null ? inverse.Text : default(string)) == "!")  				newNode.ToggleInversed ();  			filterNode = newNode;  		}  		break;  	case 3:  		DebugEnterAlt (3);  		// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  		{  			DebugLocation (105' 4);  			DebugLocation (105' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr216);  			Match (input' TokenTypes.Down' null);  			DebugLocation (105' 12);  			PushFollow (Follow._propertyChain_in_filterExpr219);  			propertyChain (propertySegments);  			PopFollow ();  			DebugLocation (105' 51);  			// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  			int alt7 = 2;  			try {  				DebugEnterSubRule (7);  				try {  					DebugEnterDecision (7' false);  					int LA7_1 = input.LA (1);  					if ((LA7_1 == 31)) {  						alt7 = 1;  					}  				}  				finally {  					DebugExitDecision (7);  				}  				switch (alt7) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  					{  						DebugLocation (105' 51);  						inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (7);  			}  			DebugLocation (105' 60);  			// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  			int alt8 = 2;  			try {  				DebugEnterSubRule (8);  				try {  					DebugEnterDecision (8' false);  					int LA8_1 = input.LA (1);  					if ((LA8_1 == 24)) {  						alt8 = 1;  					}  				}  				finally {  					DebugExitDecision (8);  				}  				switch (alt8) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  					{  						DebugLocation (105' 60);  						not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (8);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (106' 4);  			FilterTreeNode newProperty = new Property (propertySegments);  			if ((inverse != null ? inverse.Text : default(string)) == "?")  				filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  			else {  				if ((not != null ? not.Text : default(string)) == "!")  					newProperty.ToggleInversed ();  				filterNode = newProperty;  			}  		}  		break;  	case 4:  		DebugEnterAlt (4);  		// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  		{  			DebugLocation (116' 4);  			STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  			DebugLocation (117' 4);  			string stringText = (STRING7 != null ? STRING7.Text : default(string));  			stringText = stringText.Substring (1' stringText.Length - 2);  			filterNode = new Value (stringText);  		}  		break;  	case 5:  		DebugEnterAlt (5);  		// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  		{  			DebugLocation (122' 4);  			REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  			DebugLocation (123' 4);  			string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  			regexText = regexText.Substring (1' regexText.Length - 2);  			filterNode = new RegExp (regexText);  		}  		break;  	case 6:  		DebugEnterAlt (6);  		// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  		{  			DebugLocation (128' 4);  			NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  			DebugLocation (129' 4);  			filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  		}  		break;  	case 7:  		DebugEnterAlt (7);  		// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  		{  			DebugLocation (132' 4);  			Match (input' TRUE' Follow._TRUE_in_filterExpr271);  			DebugLocation (133' 4);  			filterNode = new Value (true);  		}  		break;  	case 8:  		DebugEnterAlt (8);  		// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  		{  			DebugLocation (136' 4);  			Match (input' FALSE' Follow._FALSE_in_filterExpr281);  			DebugLocation (137' 4);  			filterNode = new Value (false);  		}  		break;  	case 9:  		DebugEnterAlt (9);  		// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  		{  			DebugLocation (140' 4);  			Match (input' NULL' Follow._NULL_in_filterExpr291);  			DebugLocation (141' 4);  			filterNode = new Value (null);  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("filterExpr"' 6);  	LeaveRule ("filterExpr"' 6);  	LeaveRule_filterExpr ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  	int alt9 = 9;  	try {  		DebugEnterDecision (9' false);  		switch (input.LA (1)) {  		case CHAIN_OPERATOR:  		case COMPARATOR:  			{  				alt9 = 1;  			}  			break;  		case EXPR:  			{  				int LA9_2 = input.LA (2);  				if ((LA9_2 == DOWN)) {  					int LA9_3 = input.LA (3);  					if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  						alt9 = 2;  					}  					else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  						alt9 = 3;  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				else {  					NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  					DebugRecognitionException (nvae);  					throw nvae;  				}  			}  			break;  		case STRING:  			{  				alt9 = 4;  			}  			break;  		case REGEX:  			{  				alt9 = 5;  			}  			break;  		case NUMBER:  			{  				alt9 = 6;  			}  			break;  		case TRUE:  			{  				alt9 = 7;  			}  			break;  		case FALSE:  			{  				alt9 = 8;  			}  			break;  		case NULL:  			{  				alt9 = 9;  			}  			break;  		default: {  			NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  		}  	}  	finally {  		DebugExitDecision (9);  	}  	switch (alt9) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  		{  			DebugLocation (64' 4);  			DebugLocation (64' 6);  			PushFollow (Follow._comparator_in_filterExpr175);  			comparator6 = comparator ();  			PopFollow ();  			Match (input' TokenTypes.Down' null);  			DebugLocation (64' 18);  			PushFollow (Follow._filterExpr_in_filterExpr179);  			a = filterExpr ();  			PopFollow ();  			DebugLocation (64' 31);  			PushFollow (Follow._filterExpr_in_filterExpr183);  			b = filterExpr ();  			PopFollow ();  			Match (input' TokenTypes.Up' null);  			DebugLocation (65' 4);  			Comparator newComparator;  			switch (comparator6) {  			case "=":  				newComparator = Comparator.Equals;  				break;  			case "!=":  				newComparator = Comparator.NotEquals;  				break;  			case ">":  				newComparator = Comparator.Greater;  				break;  			case "<":  				newComparator = Comparator.Less;  				break;  			case ">=":  				newComparator = Comparator.GreaterOrEqual;  				break;  			case "<=":  				newComparator = Comparator.LessOrEqual;  				break;  			case "&":  				newComparator = Comparator.And;  				break;  			case "|":  				newComparator = Comparator.Or;  				break;  			default:  				newComparator = Comparator.Equals;  				break;  			}  			filterNode = new BoolExpression (a' newComparator' b);  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  		{  			DebugLocation (98' 4);  			DebugLocation (98' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr195);  			Match (input' TokenTypes.Down' null);  			DebugLocation (98' 12);  			PushFollow (Follow._filterExpr_in_filterExpr199);  			f = filterExpr ();  			PopFollow ();  			DebugLocation (98' 31);  			// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  			int alt6 = 2;  			try {  				DebugEnterSubRule (6);  				try {  					DebugEnterDecision (6' false);  					int LA6_1 = input.LA (1);  					if ((LA6_1 == 24)) {  						alt6 = 1;  					}  				}  				finally {  					DebugExitDecision (6);  				}  				switch (alt6) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  					{  						DebugLocation (98' 31);  						inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (6);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (99' 4);  			FilterTreeNode newNode = f;  			if ((inverse != null ? inverse.Text : default(string)) == "!")  				newNode.ToggleInversed ();  			filterNode = newNode;  		}  		break;  	case 3:  		DebugEnterAlt (3);  		// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  		{  			DebugLocation (105' 4);  			DebugLocation (105' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr216);  			Match (input' TokenTypes.Down' null);  			DebugLocation (105' 12);  			PushFollow (Follow._propertyChain_in_filterExpr219);  			propertyChain (propertySegments);  			PopFollow ();  			DebugLocation (105' 51);  			// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  			int alt7 = 2;  			try {  				DebugEnterSubRule (7);  				try {  					DebugEnterDecision (7' false);  					int LA7_1 = input.LA (1);  					if ((LA7_1 == 31)) {  						alt7 = 1;  					}  				}  				finally {  					DebugExitDecision (7);  				}  				switch (alt7) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  					{  						DebugLocation (105' 51);  						inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (7);  			}  			DebugLocation (105' 60);  			// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  			int alt8 = 2;  			try {  				DebugEnterSubRule (8);  				try {  					DebugEnterDecision (8' false);  					int LA8_1 = input.LA (1);  					if ((LA8_1 == 24)) {  						alt8 = 1;  					}  				}  				finally {  					DebugExitDecision (8);  				}  				switch (alt8) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  					{  						DebugLocation (105' 60);  						not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (8);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (106' 4);  			FilterTreeNode newProperty = new Property (propertySegments);  			if ((inverse != null ? inverse.Text : default(string)) == "?")  				filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  			else {  				if ((not != null ? not.Text : default(string)) == "!")  					newProperty.ToggleInversed ();  				filterNode = newProperty;  			}  		}  		break;  	case 4:  		DebugEnterAlt (4);  		// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  		{  			DebugLocation (116' 4);  			STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  			DebugLocation (117' 4);  			string stringText = (STRING7 != null ? STRING7.Text : default(string));  			stringText = stringText.Substring (1' stringText.Length - 2);  			filterNode = new Value (stringText);  		}  		break;  	case 5:  		DebugEnterAlt (5);  		// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  		{  			DebugLocation (122' 4);  			REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  			DebugLocation (123' 4);  			string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  			regexText = regexText.Substring (1' regexText.Length - 2);  			filterNode = new RegExp (regexText);  		}  		break;  	case 6:  		DebugEnterAlt (6);  		// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  		{  			DebugLocation (128' 4);  			NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  			DebugLocation (129' 4);  			filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  		}  		break;  	case 7:  		DebugEnterAlt (7);  		// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  		{  			DebugLocation (132' 4);  			Match (input' TRUE' Follow._TRUE_in_filterExpr271);  			DebugLocation (133' 4);  			filterNode = new Value (true);  		}  		break;  	case 8:  		DebugEnterAlt (8);  		// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  		{  			DebugLocation (136' 4);  			Match (input' FALSE' Follow._FALSE_in_filterExpr281);  			DebugLocation (137' 4);  			filterNode = new Value (false);  		}  		break;  	case 9:  		DebugEnterAlt (9);  		// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  		{  			DebugLocation (140' 4);  			Match (input' NULL' Follow._NULL_in_filterExpr291);  			DebugLocation (141' 4);  			filterNode = new Value (null);  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("filterExpr"' 6);  	LeaveRule ("filterExpr"' 6);  	LeaveRule_filterExpr ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  	int alt9 = 9;  	try {  		DebugEnterDecision (9' false);  		switch (input.LA (1)) {  		case CHAIN_OPERATOR:  		case COMPARATOR:  			{  				alt9 = 1;  			}  			break;  		case EXPR:  			{  				int LA9_2 = input.LA (2);  				if ((LA9_2 == DOWN)) {  					int LA9_3 = input.LA (3);  					if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  						alt9 = 2;  					}  					else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  						alt9 = 3;  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				else {  					NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  					DebugRecognitionException (nvae);  					throw nvae;  				}  			}  			break;  		case STRING:  			{  				alt9 = 4;  			}  			break;  		case REGEX:  			{  				alt9 = 5;  			}  			break;  		case NUMBER:  			{  				alt9 = 6;  			}  			break;  		case TRUE:  			{  				alt9 = 7;  			}  			break;  		case FALSE:  			{  				alt9 = 8;  			}  			break;  		case NULL:  			{  				alt9 = 9;  			}  			break;  		default: {  			NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  		}  	}  	finally {  		DebugExitDecision (9);  	}  	switch (alt9) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  		{  			DebugLocation (64' 4);  			DebugLocation (64' 6);  			PushFollow (Follow._comparator_in_filterExpr175);  			comparator6 = comparator ();  			PopFollow ();  			Match (input' TokenTypes.Down' null);  			DebugLocation (64' 18);  			PushFollow (Follow._filterExpr_in_filterExpr179);  			a = filterExpr ();  			PopFollow ();  			DebugLocation (64' 31);  			PushFollow (Follow._filterExpr_in_filterExpr183);  			b = filterExpr ();  			PopFollow ();  			Match (input' TokenTypes.Up' null);  			DebugLocation (65' 4);  			Comparator newComparator;  			switch (comparator6) {  			case "=":  				newComparator = Comparator.Equals;  				break;  			case "!=":  				newComparator = Comparator.NotEquals;  				break;  			case ">":  				newComparator = Comparator.Greater;  				break;  			case "<":  				newComparator = Comparator.Less;  				break;  			case ">=":  				newComparator = Comparator.GreaterOrEqual;  				break;  			case "<=":  				newComparator = Comparator.LessOrEqual;  				break;  			case "&":  				newComparator = Comparator.And;  				break;  			case "|":  				newComparator = Comparator.Or;  				break;  			default:  				newComparator = Comparator.Equals;  				break;  			}  			filterNode = new BoolExpression (a' newComparator' b);  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  		{  			DebugLocation (98' 4);  			DebugLocation (98' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr195);  			Match (input' TokenTypes.Down' null);  			DebugLocation (98' 12);  			PushFollow (Follow._filterExpr_in_filterExpr199);  			f = filterExpr ();  			PopFollow ();  			DebugLocation (98' 31);  			// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  			int alt6 = 2;  			try {  				DebugEnterSubRule (6);  				try {  					DebugEnterDecision (6' false);  					int LA6_1 = input.LA (1);  					if ((LA6_1 == 24)) {  						alt6 = 1;  					}  				}  				finally {  					DebugExitDecision (6);  				}  				switch (alt6) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  					{  						DebugLocation (98' 31);  						inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (6);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (99' 4);  			FilterTreeNode newNode = f;  			if ((inverse != null ? inverse.Text : default(string)) == "!")  				newNode.ToggleInversed ();  			filterNode = newNode;  		}  		break;  	case 3:  		DebugEnterAlt (3);  		// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  		{  			DebugLocation (105' 4);  			DebugLocation (105' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr216);  			Match (input' TokenTypes.Down' null);  			DebugLocation (105' 12);  			PushFollow (Follow._propertyChain_in_filterExpr219);  			propertyChain (propertySegments);  			PopFollow ();  			DebugLocation (105' 51);  			// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  			int alt7 = 2;  			try {  				DebugEnterSubRule (7);  				try {  					DebugEnterDecision (7' false);  					int LA7_1 = input.LA (1);  					if ((LA7_1 == 31)) {  						alt7 = 1;  					}  				}  				finally {  					DebugExitDecision (7);  				}  				switch (alt7) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  					{  						DebugLocation (105' 51);  						inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (7);  			}  			DebugLocation (105' 60);  			// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  			int alt8 = 2;  			try {  				DebugEnterSubRule (8);  				try {  					DebugEnterDecision (8' false);  					int LA8_1 = input.LA (1);  					if ((LA8_1 == 24)) {  						alt8 = 1;  					}  				}  				finally {  					DebugExitDecision (8);  				}  				switch (alt8) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  					{  						DebugLocation (105' 60);  						not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (8);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (106' 4);  			FilterTreeNode newProperty = new Property (propertySegments);  			if ((inverse != null ? inverse.Text : default(string)) == "?")  				filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  			else {  				if ((not != null ? not.Text : default(string)) == "!")  					newProperty.ToggleInversed ();  				filterNode = newProperty;  			}  		}  		break;  	case 4:  		DebugEnterAlt (4);  		// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  		{  			DebugLocation (116' 4);  			STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  			DebugLocation (117' 4);  			string stringText = (STRING7 != null ? STRING7.Text : default(string));  			stringText = stringText.Substring (1' stringText.Length - 2);  			filterNode = new Value (stringText);  		}  		break;  	case 5:  		DebugEnterAlt (5);  		// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  		{  			DebugLocation (122' 4);  			REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  			DebugLocation (123' 4);  			string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  			regexText = regexText.Substring (1' regexText.Length - 2);  			filterNode = new RegExp (regexText);  		}  		break;  	case 6:  		DebugEnterAlt (6);  		// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  		{  			DebugLocation (128' 4);  			NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  			DebugLocation (129' 4);  			filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  		}  		break;  	case 7:  		DebugEnterAlt (7);  		// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  		{  			DebugLocation (132' 4);  			Match (input' TRUE' Follow._TRUE_in_filterExpr271);  			DebugLocation (133' 4);  			filterNode = new Value (true);  		}  		break;  	case 8:  		DebugEnterAlt (8);  		// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  		{  			DebugLocation (136' 4);  			Match (input' FALSE' Follow._FALSE_in_filterExpr281);  			DebugLocation (137' 4);  			filterNode = new Value (false);  		}  		break;  	case 9:  		DebugEnterAlt (9);  		// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  		{  			DebugLocation (140' 4);  			Match (input' NULL' Follow._NULL_in_filterExpr291);  			DebugLocation (141' 4);  			filterNode = new Value (null);  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("filterExpr"' 6);  	LeaveRule ("filterExpr"' 6);  	LeaveRule_filterExpr ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  	int alt9 = 9;  	try {  		DebugEnterDecision (9' false);  		switch (input.LA (1)) {  		case CHAIN_OPERATOR:  		case COMPARATOR:  			{  				alt9 = 1;  			}  			break;  		case EXPR:  			{  				int LA9_2 = input.LA (2);  				if ((LA9_2 == DOWN)) {  					int LA9_3 = input.LA (3);  					if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  						alt9 = 2;  					}  					else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  						alt9 = 3;  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				else {  					NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  					DebugRecognitionException (nvae);  					throw nvae;  				}  			}  			break;  		case STRING:  			{  				alt9 = 4;  			}  			break;  		case REGEX:  			{  				alt9 = 5;  			}  			break;  		case NUMBER:  			{  				alt9 = 6;  			}  			break;  		case TRUE:  			{  				alt9 = 7;  			}  			break;  		case FALSE:  			{  				alt9 = 8;  			}  			break;  		case NULL:  			{  				alt9 = 9;  			}  			break;  		default: {  			NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  		}  	}  	finally {  		DebugExitDecision (9);  	}  	switch (alt9) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  		{  			DebugLocation (64' 4);  			DebugLocation (64' 6);  			PushFollow (Follow._comparator_in_filterExpr175);  			comparator6 = comparator ();  			PopFollow ();  			Match (input' TokenTypes.Down' null);  			DebugLocation (64' 18);  			PushFollow (Follow._filterExpr_in_filterExpr179);  			a = filterExpr ();  			PopFollow ();  			DebugLocation (64' 31);  			PushFollow (Follow._filterExpr_in_filterExpr183);  			b = filterExpr ();  			PopFollow ();  			Match (input' TokenTypes.Up' null);  			DebugLocation (65' 4);  			Comparator newComparator;  			switch (comparator6) {  			case "=":  				newComparator = Comparator.Equals;  				break;  			case "!=":  				newComparator = Comparator.NotEquals;  				break;  			case ">":  				newComparator = Comparator.Greater;  				break;  			case "<":  				newComparator = Comparator.Less;  				break;  			case ">=":  				newComparator = Comparator.GreaterOrEqual;  				break;  			case "<=":  				newComparator = Comparator.LessOrEqual;  				break;  			case "&":  				newComparator = Comparator.And;  				break;  			case "|":  				newComparator = Comparator.Or;  				break;  			default:  				newComparator = Comparator.Equals;  				break;  			}  			filterNode = new BoolExpression (a' newComparator' b);  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  		{  			DebugLocation (98' 4);  			DebugLocation (98' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr195);  			Match (input' TokenTypes.Down' null);  			DebugLocation (98' 12);  			PushFollow (Follow._filterExpr_in_filterExpr199);  			f = filterExpr ();  			PopFollow ();  			DebugLocation (98' 31);  			// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  			int alt6 = 2;  			try {  				DebugEnterSubRule (6);  				try {  					DebugEnterDecision (6' false);  					int LA6_1 = input.LA (1);  					if ((LA6_1 == 24)) {  						alt6 = 1;  					}  				}  				finally {  					DebugExitDecision (6);  				}  				switch (alt6) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  					{  						DebugLocation (98' 31);  						inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (6);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (99' 4);  			FilterTreeNode newNode = f;  			if ((inverse != null ? inverse.Text : default(string)) == "!")  				newNode.ToggleInversed ();  			filterNode = newNode;  		}  		break;  	case 3:  		DebugEnterAlt (3);  		// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  		{  			DebugLocation (105' 4);  			DebugLocation (105' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr216);  			Match (input' TokenTypes.Down' null);  			DebugLocation (105' 12);  			PushFollow (Follow._propertyChain_in_filterExpr219);  			propertyChain (propertySegments);  			PopFollow ();  			DebugLocation (105' 51);  			// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  			int alt7 = 2;  			try {  				DebugEnterSubRule (7);  				try {  					DebugEnterDecision (7' false);  					int LA7_1 = input.LA (1);  					if ((LA7_1 == 31)) {  						alt7 = 1;  					}  				}  				finally {  					DebugExitDecision (7);  				}  				switch (alt7) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  					{  						DebugLocation (105' 51);  						inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (7);  			}  			DebugLocation (105' 60);  			// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  			int alt8 = 2;  			try {  				DebugEnterSubRule (8);  				try {  					DebugEnterDecision (8' false);  					int LA8_1 = input.LA (1);  					if ((LA8_1 == 24)) {  						alt8 = 1;  					}  				}  				finally {  					DebugExitDecision (8);  				}  				switch (alt8) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  					{  						DebugLocation (105' 60);  						not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (8);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (106' 4);  			FilterTreeNode newProperty = new Property (propertySegments);  			if ((inverse != null ? inverse.Text : default(string)) == "?")  				filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  			else {  				if ((not != null ? not.Text : default(string)) == "!")  					newProperty.ToggleInversed ();  				filterNode = newProperty;  			}  		}  		break;  	case 4:  		DebugEnterAlt (4);  		// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  		{  			DebugLocation (116' 4);  			STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  			DebugLocation (117' 4);  			string stringText = (STRING7 != null ? STRING7.Text : default(string));  			stringText = stringText.Substring (1' stringText.Length - 2);  			filterNode = new Value (stringText);  		}  		break;  	case 5:  		DebugEnterAlt (5);  		// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  		{  			DebugLocation (122' 4);  			REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  			DebugLocation (123' 4);  			string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  			regexText = regexText.Substring (1' regexText.Length - 2);  			filterNode = new RegExp (regexText);  		}  		break;  	case 6:  		DebugEnterAlt (6);  		// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  		{  			DebugLocation (128' 4);  			NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  			DebugLocation (129' 4);  			filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  		}  		break;  	case 7:  		DebugEnterAlt (7);  		// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  		{  			DebugLocation (132' 4);  			Match (input' TRUE' Follow._TRUE_in_filterExpr271);  			DebugLocation (133' 4);  			filterNode = new Value (true);  		}  		break;  	case 8:  		DebugEnterAlt (8);  		// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  		{  			DebugLocation (136' 4);  			Match (input' FALSE' Follow._FALSE_in_filterExpr281);  			DebugLocation (137' 4);  			filterNode = new Value (false);  		}  		break;  	case 9:  		DebugEnterAlt (9);  		// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  		{  			DebugLocation (140' 4);  			Match (input' NULL' Follow._NULL_in_filterExpr291);  			DebugLocation (141' 4);  			filterNode = new Value (null);  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("filterExpr"' 6);  	LeaveRule ("filterExpr"' 6);  	LeaveRule_filterExpr ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  	int alt9 = 9;  	try {  		DebugEnterDecision (9' false);  		switch (input.LA (1)) {  		case CHAIN_OPERATOR:  		case COMPARATOR:  			{  				alt9 = 1;  			}  			break;  		case EXPR:  			{  				int LA9_2 = input.LA (2);  				if ((LA9_2 == DOWN)) {  					int LA9_3 = input.LA (3);  					if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  						alt9 = 2;  					}  					else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  						alt9 = 3;  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				else {  					NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  					DebugRecognitionException (nvae);  					throw nvae;  				}  			}  			break;  		case STRING:  			{  				alt9 = 4;  			}  			break;  		case REGEX:  			{  				alt9 = 5;  			}  			break;  		case NUMBER:  			{  				alt9 = 6;  			}  			break;  		case TRUE:  			{  				alt9 = 7;  			}  			break;  		case FALSE:  			{  				alt9 = 8;  			}  			break;  		case NULL:  			{  				alt9 = 9;  			}  			break;  		default: {  			NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  		}  	}  	finally {  		DebugExitDecision (9);  	}  	switch (alt9) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  		{  			DebugLocation (64' 4);  			DebugLocation (64' 6);  			PushFollow (Follow._comparator_in_filterExpr175);  			comparator6 = comparator ();  			PopFollow ();  			Match (input' TokenTypes.Down' null);  			DebugLocation (64' 18);  			PushFollow (Follow._filterExpr_in_filterExpr179);  			a = filterExpr ();  			PopFollow ();  			DebugLocation (64' 31);  			PushFollow (Follow._filterExpr_in_filterExpr183);  			b = filterExpr ();  			PopFollow ();  			Match (input' TokenTypes.Up' null);  			DebugLocation (65' 4);  			Comparator newComparator;  			switch (comparator6) {  			case "=":  				newComparator = Comparator.Equals;  				break;  			case "!=":  				newComparator = Comparator.NotEquals;  				break;  			case ">":  				newComparator = Comparator.Greater;  				break;  			case "<":  				newComparator = Comparator.Less;  				break;  			case ">=":  				newComparator = Comparator.GreaterOrEqual;  				break;  			case "<=":  				newComparator = Comparator.LessOrEqual;  				break;  			case "&":  				newComparator = Comparator.And;  				break;  			case "|":  				newComparator = Comparator.Or;  				break;  			default:  				newComparator = Comparator.Equals;  				break;  			}  			filterNode = new BoolExpression (a' newComparator' b);  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  		{  			DebugLocation (98' 4);  			DebugLocation (98' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr195);  			Match (input' TokenTypes.Down' null);  			DebugLocation (98' 12);  			PushFollow (Follow._filterExpr_in_filterExpr199);  			f = filterExpr ();  			PopFollow ();  			DebugLocation (98' 31);  			// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  			int alt6 = 2;  			try {  				DebugEnterSubRule (6);  				try {  					DebugEnterDecision (6' false);  					int LA6_1 = input.LA (1);  					if ((LA6_1 == 24)) {  						alt6 = 1;  					}  				}  				finally {  					DebugExitDecision (6);  				}  				switch (alt6) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  					{  						DebugLocation (98' 31);  						inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (6);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (99' 4);  			FilterTreeNode newNode = f;  			if ((inverse != null ? inverse.Text : default(string)) == "!")  				newNode.ToggleInversed ();  			filterNode = newNode;  		}  		break;  	case 3:  		DebugEnterAlt (3);  		// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  		{  			DebugLocation (105' 4);  			DebugLocation (105' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr216);  			Match (input' TokenTypes.Down' null);  			DebugLocation (105' 12);  			PushFollow (Follow._propertyChain_in_filterExpr219);  			propertyChain (propertySegments);  			PopFollow ();  			DebugLocation (105' 51);  			// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  			int alt7 = 2;  			try {  				DebugEnterSubRule (7);  				try {  					DebugEnterDecision (7' false);  					int LA7_1 = input.LA (1);  					if ((LA7_1 == 31)) {  						alt7 = 1;  					}  				}  				finally {  					DebugExitDecision (7);  				}  				switch (alt7) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  					{  						DebugLocation (105' 51);  						inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (7);  			}  			DebugLocation (105' 60);  			// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  			int alt8 = 2;  			try {  				DebugEnterSubRule (8);  				try {  					DebugEnterDecision (8' false);  					int LA8_1 = input.LA (1);  					if ((LA8_1 == 24)) {  						alt8 = 1;  					}  				}  				finally {  					DebugExitDecision (8);  				}  				switch (alt8) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  					{  						DebugLocation (105' 60);  						not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (8);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (106' 4);  			FilterTreeNode newProperty = new Property (propertySegments);  			if ((inverse != null ? inverse.Text : default(string)) == "?")  				filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  			else {  				if ((not != null ? not.Text : default(string)) == "!")  					newProperty.ToggleInversed ();  				filterNode = newProperty;  			}  		}  		break;  	case 4:  		DebugEnterAlt (4);  		// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  		{  			DebugLocation (116' 4);  			STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  			DebugLocation (117' 4);  			string stringText = (STRING7 != null ? STRING7.Text : default(string));  			stringText = stringText.Substring (1' stringText.Length - 2);  			filterNode = new Value (stringText);  		}  		break;  	case 5:  		DebugEnterAlt (5);  		// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  		{  			DebugLocation (122' 4);  			REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  			DebugLocation (123' 4);  			string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  			regexText = regexText.Substring (1' regexText.Length - 2);  			filterNode = new RegExp (regexText);  		}  		break;  	case 6:  		DebugEnterAlt (6);  		// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  		{  			DebugLocation (128' 4);  			NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  			DebugLocation (129' 4);  			filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  		}  		break;  	case 7:  		DebugEnterAlt (7);  		// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  		{  			DebugLocation (132' 4);  			Match (input' TRUE' Follow._TRUE_in_filterExpr271);  			DebugLocation (133' 4);  			filterNode = new Value (true);  		}  		break;  	case 8:  		DebugEnterAlt (8);  		// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  		{  			DebugLocation (136' 4);  			Match (input' FALSE' Follow._FALSE_in_filterExpr281);  			DebugLocation (137' 4);  			filterNode = new Value (false);  		}  		break;  	case 9:  		DebugEnterAlt (9);  		// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  		{  			DebugLocation (140' 4);  			Match (input' NULL' Follow._NULL_in_filterExpr291);  			DebugLocation (141' 4);  			filterNode = new Value (null);  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("filterExpr"' 6);  	LeaveRule ("filterExpr"' 6);  	LeaveRule_filterExpr ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  	int alt9 = 9;  	try {  		DebugEnterDecision (9' false);  		switch (input.LA (1)) {  		case CHAIN_OPERATOR:  		case COMPARATOR:  			{  				alt9 = 1;  			}  			break;  		case EXPR:  			{  				int LA9_2 = input.LA (2);  				if ((LA9_2 == DOWN)) {  					int LA9_3 = input.LA (3);  					if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  						alt9 = 2;  					}  					else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  						alt9 = 3;  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				else {  					NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  					DebugRecognitionException (nvae);  					throw nvae;  				}  			}  			break;  		case STRING:  			{  				alt9 = 4;  			}  			break;  		case REGEX:  			{  				alt9 = 5;  			}  			break;  		case NUMBER:  			{  				alt9 = 6;  			}  			break;  		case TRUE:  			{  				alt9 = 7;  			}  			break;  		case FALSE:  			{  				alt9 = 8;  			}  			break;  		case NULL:  			{  				alt9 = 9;  			}  			break;  		default: {  			NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  		}  	}  	finally {  		DebugExitDecision (9);  	}  	switch (alt9) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  		{  			DebugLocation (64' 4);  			DebugLocation (64' 6);  			PushFollow (Follow._comparator_in_filterExpr175);  			comparator6 = comparator ();  			PopFollow ();  			Match (input' TokenTypes.Down' null);  			DebugLocation (64' 18);  			PushFollow (Follow._filterExpr_in_filterExpr179);  			a = filterExpr ();  			PopFollow ();  			DebugLocation (64' 31);  			PushFollow (Follow._filterExpr_in_filterExpr183);  			b = filterExpr ();  			PopFollow ();  			Match (input' TokenTypes.Up' null);  			DebugLocation (65' 4);  			Comparator newComparator;  			switch (comparator6) {  			case "=":  				newComparator = Comparator.Equals;  				break;  			case "!=":  				newComparator = Comparator.NotEquals;  				break;  			case ">":  				newComparator = Comparator.Greater;  				break;  			case "<":  				newComparator = Comparator.Less;  				break;  			case ">=":  				newComparator = Comparator.GreaterOrEqual;  				break;  			case "<=":  				newComparator = Comparator.LessOrEqual;  				break;  			case "&":  				newComparator = Comparator.And;  				break;  			case "|":  				newComparator = Comparator.Or;  				break;  			default:  				newComparator = Comparator.Equals;  				break;  			}  			filterNode = new BoolExpression (a' newComparator' b);  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  		{  			DebugLocation (98' 4);  			DebugLocation (98' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr195);  			Match (input' TokenTypes.Down' null);  			DebugLocation (98' 12);  			PushFollow (Follow._filterExpr_in_filterExpr199);  			f = filterExpr ();  			PopFollow ();  			DebugLocation (98' 31);  			// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  			int alt6 = 2;  			try {  				DebugEnterSubRule (6);  				try {  					DebugEnterDecision (6' false);  					int LA6_1 = input.LA (1);  					if ((LA6_1 == 24)) {  						alt6 = 1;  					}  				}  				finally {  					DebugExitDecision (6);  				}  				switch (alt6) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  					{  						DebugLocation (98' 31);  						inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (6);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (99' 4);  			FilterTreeNode newNode = f;  			if ((inverse != null ? inverse.Text : default(string)) == "!")  				newNode.ToggleInversed ();  			filterNode = newNode;  		}  		break;  	case 3:  		DebugEnterAlt (3);  		// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  		{  			DebugLocation (105' 4);  			DebugLocation (105' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr216);  			Match (input' TokenTypes.Down' null);  			DebugLocation (105' 12);  			PushFollow (Follow._propertyChain_in_filterExpr219);  			propertyChain (propertySegments);  			PopFollow ();  			DebugLocation (105' 51);  			// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  			int alt7 = 2;  			try {  				DebugEnterSubRule (7);  				try {  					DebugEnterDecision (7' false);  					int LA7_1 = input.LA (1);  					if ((LA7_1 == 31)) {  						alt7 = 1;  					}  				}  				finally {  					DebugExitDecision (7);  				}  				switch (alt7) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  					{  						DebugLocation (105' 51);  						inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (7);  			}  			DebugLocation (105' 60);  			// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  			int alt8 = 2;  			try {  				DebugEnterSubRule (8);  				try {  					DebugEnterDecision (8' false);  					int LA8_1 = input.LA (1);  					if ((LA8_1 == 24)) {  						alt8 = 1;  					}  				}  				finally {  					DebugExitDecision (8);  				}  				switch (alt8) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  					{  						DebugLocation (105' 60);  						not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (8);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (106' 4);  			FilterTreeNode newProperty = new Property (propertySegments);  			if ((inverse != null ? inverse.Text : default(string)) == "?")  				filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  			else {  				if ((not != null ? not.Text : default(string)) == "!")  					newProperty.ToggleInversed ();  				filterNode = newProperty;  			}  		}  		break;  	case 4:  		DebugEnterAlt (4);  		// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  		{  			DebugLocation (116' 4);  			STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  			DebugLocation (117' 4);  			string stringText = (STRING7 != null ? STRING7.Text : default(string));  			stringText = stringText.Substring (1' stringText.Length - 2);  			filterNode = new Value (stringText);  		}  		break;  	case 5:  		DebugEnterAlt (5);  		// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  		{  			DebugLocation (122' 4);  			REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  			DebugLocation (123' 4);  			string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  			regexText = regexText.Substring (1' regexText.Length - 2);  			filterNode = new RegExp (regexText);  		}  		break;  	case 6:  		DebugEnterAlt (6);  		// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  		{  			DebugLocation (128' 4);  			NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  			DebugLocation (129' 4);  			filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  		}  		break;  	case 7:  		DebugEnterAlt (7);  		// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  		{  			DebugLocation (132' 4);  			Match (input' TRUE' Follow._TRUE_in_filterExpr271);  			DebugLocation (133' 4);  			filterNode = new Value (true);  		}  		break;  	case 8:  		DebugEnterAlt (8);  		// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  		{  			DebugLocation (136' 4);  			Match (input' FALSE' Follow._FALSE_in_filterExpr281);  			DebugLocation (137' 4);  			filterNode = new Value (false);  		}  		break;  	case 9:  		DebugEnterAlt (9);  		// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  		{  			DebugLocation (140' 4);  			Match (input' NULL' Follow._NULL_in_filterExpr291);  			DebugLocation (141' 4);  			filterNode = new Value (null);  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("filterExpr"' 6);  	LeaveRule ("filterExpr"' 6);  	LeaveRule_filterExpr ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  	int alt9 = 9;  	try {  		DebugEnterDecision (9' false);  		switch (input.LA (1)) {  		case CHAIN_OPERATOR:  		case COMPARATOR:  			{  				alt9 = 1;  			}  			break;  		case EXPR:  			{  				int LA9_2 = input.LA (2);  				if ((LA9_2 == DOWN)) {  					int LA9_3 = input.LA (3);  					if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  						alt9 = 2;  					}  					else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  						alt9 = 3;  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				else {  					NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  					DebugRecognitionException (nvae);  					throw nvae;  				}  			}  			break;  		case STRING:  			{  				alt9 = 4;  			}  			break;  		case REGEX:  			{  				alt9 = 5;  			}  			break;  		case NUMBER:  			{  				alt9 = 6;  			}  			break;  		case TRUE:  			{  				alt9 = 7;  			}  			break;  		case FALSE:  			{  				alt9 = 8;  			}  			break;  		case NULL:  			{  				alt9 = 9;  			}  			break;  		default: {  			NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  		}  	}  	finally {  		DebugExitDecision (9);  	}  	switch (alt9) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  		{  			DebugLocation (64' 4);  			DebugLocation (64' 6);  			PushFollow (Follow._comparator_in_filterExpr175);  			comparator6 = comparator ();  			PopFollow ();  			Match (input' TokenTypes.Down' null);  			DebugLocation (64' 18);  			PushFollow (Follow._filterExpr_in_filterExpr179);  			a = filterExpr ();  			PopFollow ();  			DebugLocation (64' 31);  			PushFollow (Follow._filterExpr_in_filterExpr183);  			b = filterExpr ();  			PopFollow ();  			Match (input' TokenTypes.Up' null);  			DebugLocation (65' 4);  			Comparator newComparator;  			switch (comparator6) {  			case "=":  				newComparator = Comparator.Equals;  				break;  			case "!=":  				newComparator = Comparator.NotEquals;  				break;  			case ">":  				newComparator = Comparator.Greater;  				break;  			case "<":  				newComparator = Comparator.Less;  				break;  			case ">=":  				newComparator = Comparator.GreaterOrEqual;  				break;  			case "<=":  				newComparator = Comparator.LessOrEqual;  				break;  			case "&":  				newComparator = Comparator.And;  				break;  			case "|":  				newComparator = Comparator.Or;  				break;  			default:  				newComparator = Comparator.Equals;  				break;  			}  			filterNode = new BoolExpression (a' newComparator' b);  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  		{  			DebugLocation (98' 4);  			DebugLocation (98' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr195);  			Match (input' TokenTypes.Down' null);  			DebugLocation (98' 12);  			PushFollow (Follow._filterExpr_in_filterExpr199);  			f = filterExpr ();  			PopFollow ();  			DebugLocation (98' 31);  			// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  			int alt6 = 2;  			try {  				DebugEnterSubRule (6);  				try {  					DebugEnterDecision (6' false);  					int LA6_1 = input.LA (1);  					if ((LA6_1 == 24)) {  						alt6 = 1;  					}  				}  				finally {  					DebugExitDecision (6);  				}  				switch (alt6) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  					{  						DebugLocation (98' 31);  						inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (6);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (99' 4);  			FilterTreeNode newNode = f;  			if ((inverse != null ? inverse.Text : default(string)) == "!")  				newNode.ToggleInversed ();  			filterNode = newNode;  		}  		break;  	case 3:  		DebugEnterAlt (3);  		// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  		{  			DebugLocation (105' 4);  			DebugLocation (105' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr216);  			Match (input' TokenTypes.Down' null);  			DebugLocation (105' 12);  			PushFollow (Follow._propertyChain_in_filterExpr219);  			propertyChain (propertySegments);  			PopFollow ();  			DebugLocation (105' 51);  			// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  			int alt7 = 2;  			try {  				DebugEnterSubRule (7);  				try {  					DebugEnterDecision (7' false);  					int LA7_1 = input.LA (1);  					if ((LA7_1 == 31)) {  						alt7 = 1;  					}  				}  				finally {  					DebugExitDecision (7);  				}  				switch (alt7) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  					{  						DebugLocation (105' 51);  						inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (7);  			}  			DebugLocation (105' 60);  			// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  			int alt8 = 2;  			try {  				DebugEnterSubRule (8);  				try {  					DebugEnterDecision (8' false);  					int LA8_1 = input.LA (1);  					if ((LA8_1 == 24)) {  						alt8 = 1;  					}  				}  				finally {  					DebugExitDecision (8);  				}  				switch (alt8) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  					{  						DebugLocation (105' 60);  						not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (8);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (106' 4);  			FilterTreeNode newProperty = new Property (propertySegments);  			if ((inverse != null ? inverse.Text : default(string)) == "?")  				filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  			else {  				if ((not != null ? not.Text : default(string)) == "!")  					newProperty.ToggleInversed ();  				filterNode = newProperty;  			}  		}  		break;  	case 4:  		DebugEnterAlt (4);  		// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  		{  			DebugLocation (116' 4);  			STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  			DebugLocation (117' 4);  			string stringText = (STRING7 != null ? STRING7.Text : default(string));  			stringText = stringText.Substring (1' stringText.Length - 2);  			filterNode = new Value (stringText);  		}  		break;  	case 5:  		DebugEnterAlt (5);  		// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  		{  			DebugLocation (122' 4);  			REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  			DebugLocation (123' 4);  			string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  			regexText = regexText.Substring (1' regexText.Length - 2);  			filterNode = new RegExp (regexText);  		}  		break;  	case 6:  		DebugEnterAlt (6);  		// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  		{  			DebugLocation (128' 4);  			NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  			DebugLocation (129' 4);  			filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  		}  		break;  	case 7:  		DebugEnterAlt (7);  		// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  		{  			DebugLocation (132' 4);  			Match (input' TRUE' Follow._TRUE_in_filterExpr271);  			DebugLocation (133' 4);  			filterNode = new Value (true);  		}  		break;  	case 8:  		DebugEnterAlt (8);  		// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  		{  			DebugLocation (136' 4);  			Match (input' FALSE' Follow._FALSE_in_filterExpr281);  			DebugLocation (137' 4);  			filterNode = new Value (false);  		}  		break;  	case 9:  		DebugEnterAlt (9);  		// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  		{  			DebugLocation (140' 4);  			Match (input' NULL' Follow._NULL_in_filterExpr291);  			DebugLocation (141' 4);  			filterNode = new Value (null);  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("filterExpr"' 6);  	LeaveRule ("filterExpr"' 6);  	LeaveRule_filterExpr ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  	int alt9 = 9;  	try {  		DebugEnterDecision (9' false);  		switch (input.LA (1)) {  		case CHAIN_OPERATOR:  		case COMPARATOR:  			{  				alt9 = 1;  			}  			break;  		case EXPR:  			{  				int LA9_2 = input.LA (2);  				if ((LA9_2 == DOWN)) {  					int LA9_3 = input.LA (3);  					if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  						alt9 = 2;  					}  					else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  						alt9 = 3;  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				else {  					NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  					DebugRecognitionException (nvae);  					throw nvae;  				}  			}  			break;  		case STRING:  			{  				alt9 = 4;  			}  			break;  		case REGEX:  			{  				alt9 = 5;  			}  			break;  		case NUMBER:  			{  				alt9 = 6;  			}  			break;  		case TRUE:  			{  				alt9 = 7;  			}  			break;  		case FALSE:  			{  				alt9 = 8;  			}  			break;  		case NULL:  			{  				alt9 = 9;  			}  			break;  		default: {  			NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  		}  	}  	finally {  		DebugExitDecision (9);  	}  	switch (alt9) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  		{  			DebugLocation (64' 4);  			DebugLocation (64' 6);  			PushFollow (Follow._comparator_in_filterExpr175);  			comparator6 = comparator ();  			PopFollow ();  			Match (input' TokenTypes.Down' null);  			DebugLocation (64' 18);  			PushFollow (Follow._filterExpr_in_filterExpr179);  			a = filterExpr ();  			PopFollow ();  			DebugLocation (64' 31);  			PushFollow (Follow._filterExpr_in_filterExpr183);  			b = filterExpr ();  			PopFollow ();  			Match (input' TokenTypes.Up' null);  			DebugLocation (65' 4);  			Comparator newComparator;  			switch (comparator6) {  			case "=":  				newComparator = Comparator.Equals;  				break;  			case "!=":  				newComparator = Comparator.NotEquals;  				break;  			case ">":  				newComparator = Comparator.Greater;  				break;  			case "<":  				newComparator = Comparator.Less;  				break;  			case ">=":  				newComparator = Comparator.GreaterOrEqual;  				break;  			case "<=":  				newComparator = Comparator.LessOrEqual;  				break;  			case "&":  				newComparator = Comparator.And;  				break;  			case "|":  				newComparator = Comparator.Or;  				break;  			default:  				newComparator = Comparator.Equals;  				break;  			}  			filterNode = new BoolExpression (a' newComparator' b);  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  		{  			DebugLocation (98' 4);  			DebugLocation (98' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr195);  			Match (input' TokenTypes.Down' null);  			DebugLocation (98' 12);  			PushFollow (Follow._filterExpr_in_filterExpr199);  			f = filterExpr ();  			PopFollow ();  			DebugLocation (98' 31);  			// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  			int alt6 = 2;  			try {  				DebugEnterSubRule (6);  				try {  					DebugEnterDecision (6' false);  					int LA6_1 = input.LA (1);  					if ((LA6_1 == 24)) {  						alt6 = 1;  					}  				}  				finally {  					DebugExitDecision (6);  				}  				switch (alt6) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  					{  						DebugLocation (98' 31);  						inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (6);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (99' 4);  			FilterTreeNode newNode = f;  			if ((inverse != null ? inverse.Text : default(string)) == "!")  				newNode.ToggleInversed ();  			filterNode = newNode;  		}  		break;  	case 3:  		DebugEnterAlt (3);  		// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  		{  			DebugLocation (105' 4);  			DebugLocation (105' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr216);  			Match (input' TokenTypes.Down' null);  			DebugLocation (105' 12);  			PushFollow (Follow._propertyChain_in_filterExpr219);  			propertyChain (propertySegments);  			PopFollow ();  			DebugLocation (105' 51);  			// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  			int alt7 = 2;  			try {  				DebugEnterSubRule (7);  				try {  					DebugEnterDecision (7' false);  					int LA7_1 = input.LA (1);  					if ((LA7_1 == 31)) {  						alt7 = 1;  					}  				}  				finally {  					DebugExitDecision (7);  				}  				switch (alt7) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  					{  						DebugLocation (105' 51);  						inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (7);  			}  			DebugLocation (105' 60);  			// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  			int alt8 = 2;  			try {  				DebugEnterSubRule (8);  				try {  					DebugEnterDecision (8' false);  					int LA8_1 = input.LA (1);  					if ((LA8_1 == 24)) {  						alt8 = 1;  					}  				}  				finally {  					DebugExitDecision (8);  				}  				switch (alt8) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  					{  						DebugLocation (105' 60);  						not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (8);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (106' 4);  			FilterTreeNode newProperty = new Property (propertySegments);  			if ((inverse != null ? inverse.Text : default(string)) == "?")  				filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  			else {  				if ((not != null ? not.Text : default(string)) == "!")  					newProperty.ToggleInversed ();  				filterNode = newProperty;  			}  		}  		break;  	case 4:  		DebugEnterAlt (4);  		// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  		{  			DebugLocation (116' 4);  			STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  			DebugLocation (117' 4);  			string stringText = (STRING7 != null ? STRING7.Text : default(string));  			stringText = stringText.Substring (1' stringText.Length - 2);  			filterNode = new Value (stringText);  		}  		break;  	case 5:  		DebugEnterAlt (5);  		// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  		{  			DebugLocation (122' 4);  			REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  			DebugLocation (123' 4);  			string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  			regexText = regexText.Substring (1' regexText.Length - 2);  			filterNode = new RegExp (regexText);  		}  		break;  	case 6:  		DebugEnterAlt (6);  		// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  		{  			DebugLocation (128' 4);  			NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  			DebugLocation (129' 4);  			filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  		}  		break;  	case 7:  		DebugEnterAlt (7);  		// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  		{  			DebugLocation (132' 4);  			Match (input' TRUE' Follow._TRUE_in_filterExpr271);  			DebugLocation (133' 4);  			filterNode = new Value (true);  		}  		break;  	case 8:  		DebugEnterAlt (8);  		// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  		{  			DebugLocation (136' 4);  			Match (input' FALSE' Follow._FALSE_in_filterExpr281);  			DebugLocation (137' 4);  			filterNode = new Value (false);  		}  		break;  	case 9:  		DebugEnterAlt (9);  		// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  		{  			DebugLocation (140' 4);  			Match (input' NULL' Follow._NULL_in_filterExpr291);  			DebugLocation (141' 4);  			filterNode = new Value (null);  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("filterExpr"' 6);  	LeaveRule ("filterExpr"' 6);  	LeaveRule_filterExpr ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  	int alt9 = 9;  	try {  		DebugEnterDecision (9' false);  		switch (input.LA (1)) {  		case CHAIN_OPERATOR:  		case COMPARATOR:  			{  				alt9 = 1;  			}  			break;  		case EXPR:  			{  				int LA9_2 = input.LA (2);  				if ((LA9_2 == DOWN)) {  					int LA9_3 = input.LA (3);  					if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  						alt9 = 2;  					}  					else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  						alt9 = 3;  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				else {  					NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  					DebugRecognitionException (nvae);  					throw nvae;  				}  			}  			break;  		case STRING:  			{  				alt9 = 4;  			}  			break;  		case REGEX:  			{  				alt9 = 5;  			}  			break;  		case NUMBER:  			{  				alt9 = 6;  			}  			break;  		case TRUE:  			{  				alt9 = 7;  			}  			break;  		case FALSE:  			{  				alt9 = 8;  			}  			break;  		case NULL:  			{  				alt9 = 9;  			}  			break;  		default: {  			NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  		}  	}  	finally {  		DebugExitDecision (9);  	}  	switch (alt9) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  		{  			DebugLocation (64' 4);  			DebugLocation (64' 6);  			PushFollow (Follow._comparator_in_filterExpr175);  			comparator6 = comparator ();  			PopFollow ();  			Match (input' TokenTypes.Down' null);  			DebugLocation (64' 18);  			PushFollow (Follow._filterExpr_in_filterExpr179);  			a = filterExpr ();  			PopFollow ();  			DebugLocation (64' 31);  			PushFollow (Follow._filterExpr_in_filterExpr183);  			b = filterExpr ();  			PopFollow ();  			Match (input' TokenTypes.Up' null);  			DebugLocation (65' 4);  			Comparator newComparator;  			switch (comparator6) {  			case "=":  				newComparator = Comparator.Equals;  				break;  			case "!=":  				newComparator = Comparator.NotEquals;  				break;  			case ">":  				newComparator = Comparator.Greater;  				break;  			case "<":  				newComparator = Comparator.Less;  				break;  			case ">=":  				newComparator = Comparator.GreaterOrEqual;  				break;  			case "<=":  				newComparator = Comparator.LessOrEqual;  				break;  			case "&":  				newComparator = Comparator.And;  				break;  			case "|":  				newComparator = Comparator.Or;  				break;  			default:  				newComparator = Comparator.Equals;  				break;  			}  			filterNode = new BoolExpression (a' newComparator' b);  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  		{  			DebugLocation (98' 4);  			DebugLocation (98' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr195);  			Match (input' TokenTypes.Down' null);  			DebugLocation (98' 12);  			PushFollow (Follow._filterExpr_in_filterExpr199);  			f = filterExpr ();  			PopFollow ();  			DebugLocation (98' 31);  			// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  			int alt6 = 2;  			try {  				DebugEnterSubRule (6);  				try {  					DebugEnterDecision (6' false);  					int LA6_1 = input.LA (1);  					if ((LA6_1 == 24)) {  						alt6 = 1;  					}  				}  				finally {  					DebugExitDecision (6);  				}  				switch (alt6) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  					{  						DebugLocation (98' 31);  						inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (6);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (99' 4);  			FilterTreeNode newNode = f;  			if ((inverse != null ? inverse.Text : default(string)) == "!")  				newNode.ToggleInversed ();  			filterNode = newNode;  		}  		break;  	case 3:  		DebugEnterAlt (3);  		// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  		{  			DebugLocation (105' 4);  			DebugLocation (105' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr216);  			Match (input' TokenTypes.Down' null);  			DebugLocation (105' 12);  			PushFollow (Follow._propertyChain_in_filterExpr219);  			propertyChain (propertySegments);  			PopFollow ();  			DebugLocation (105' 51);  			// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  			int alt7 = 2;  			try {  				DebugEnterSubRule (7);  				try {  					DebugEnterDecision (7' false);  					int LA7_1 = input.LA (1);  					if ((LA7_1 == 31)) {  						alt7 = 1;  					}  				}  				finally {  					DebugExitDecision (7);  				}  				switch (alt7) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  					{  						DebugLocation (105' 51);  						inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (7);  			}  			DebugLocation (105' 60);  			// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  			int alt8 = 2;  			try {  				DebugEnterSubRule (8);  				try {  					DebugEnterDecision (8' false);  					int LA8_1 = input.LA (1);  					if ((LA8_1 == 24)) {  						alt8 = 1;  					}  				}  				finally {  					DebugExitDecision (8);  				}  				switch (alt8) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  					{  						DebugLocation (105' 60);  						not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (8);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (106' 4);  			FilterTreeNode newProperty = new Property (propertySegments);  			if ((inverse != null ? inverse.Text : default(string)) == "?")  				filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  			else {  				if ((not != null ? not.Text : default(string)) == "!")  					newProperty.ToggleInversed ();  				filterNode = newProperty;  			}  		}  		break;  	case 4:  		DebugEnterAlt (4);  		// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  		{  			DebugLocation (116' 4);  			STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  			DebugLocation (117' 4);  			string stringText = (STRING7 != null ? STRING7.Text : default(string));  			stringText = stringText.Substring (1' stringText.Length - 2);  			filterNode = new Value (stringText);  		}  		break;  	case 5:  		DebugEnterAlt (5);  		// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  		{  			DebugLocation (122' 4);  			REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  			DebugLocation (123' 4);  			string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  			regexText = regexText.Substring (1' regexText.Length - 2);  			filterNode = new RegExp (regexText);  		}  		break;  	case 6:  		DebugEnterAlt (6);  		// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  		{  			DebugLocation (128' 4);  			NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  			DebugLocation (129' 4);  			filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  		}  		break;  	case 7:  		DebugEnterAlt (7);  		// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  		{  			DebugLocation (132' 4);  			Match (input' TRUE' Follow._TRUE_in_filterExpr271);  			DebugLocation (133' 4);  			filterNode = new Value (true);  		}  		break;  	case 8:  		DebugEnterAlt (8);  		// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  		{  			DebugLocation (136' 4);  			Match (input' FALSE' Follow._FALSE_in_filterExpr281);  			DebugLocation (137' 4);  			filterNode = new Value (false);  		}  		break;  	case 9:  		DebugEnterAlt (9);  		// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  		{  			DebugLocation (140' 4);  			Match (input' NULL' Follow._NULL_in_filterExpr291);  			DebugLocation (141' 4);  			filterNode = new Value (null);  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("filterExpr"' 6);  	LeaveRule ("filterExpr"' 6);  	LeaveRule_filterExpr ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  	int alt9 = 9;  	try {  		DebugEnterDecision (9' false);  		switch (input.LA (1)) {  		case CHAIN_OPERATOR:  		case COMPARATOR:  			{  				alt9 = 1;  			}  			break;  		case EXPR:  			{  				int LA9_2 = input.LA (2);  				if ((LA9_2 == DOWN)) {  					int LA9_3 = input.LA (3);  					if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  						alt9 = 2;  					}  					else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  						alt9 = 3;  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				else {  					NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  					DebugRecognitionException (nvae);  					throw nvae;  				}  			}  			break;  		case STRING:  			{  				alt9 = 4;  			}  			break;  		case REGEX:  			{  				alt9 = 5;  			}  			break;  		case NUMBER:  			{  				alt9 = 6;  			}  			break;  		case TRUE:  			{  				alt9 = 7;  			}  			break;  		case FALSE:  			{  				alt9 = 8;  			}  			break;  		case NULL:  			{  				alt9 = 9;  			}  			break;  		default: {  			NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  		}  	}  	finally {  		DebugExitDecision (9);  	}  	switch (alt9) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  		{  			DebugLocation (64' 4);  			DebugLocation (64' 6);  			PushFollow (Follow._comparator_in_filterExpr175);  			comparator6 = comparator ();  			PopFollow ();  			Match (input' TokenTypes.Down' null);  			DebugLocation (64' 18);  			PushFollow (Follow._filterExpr_in_filterExpr179);  			a = filterExpr ();  			PopFollow ();  			DebugLocation (64' 31);  			PushFollow (Follow._filterExpr_in_filterExpr183);  			b = filterExpr ();  			PopFollow ();  			Match (input' TokenTypes.Up' null);  			DebugLocation (65' 4);  			Comparator newComparator;  			switch (comparator6) {  			case "=":  				newComparator = Comparator.Equals;  				break;  			case "!=":  				newComparator = Comparator.NotEquals;  				break;  			case ">":  				newComparator = Comparator.Greater;  				break;  			case "<":  				newComparator = Comparator.Less;  				break;  			case ">=":  				newComparator = Comparator.GreaterOrEqual;  				break;  			case "<=":  				newComparator = Comparator.LessOrEqual;  				break;  			case "&":  				newComparator = Comparator.And;  				break;  			case "|":  				newComparator = Comparator.Or;  				break;  			default:  				newComparator = Comparator.Equals;  				break;  			}  			filterNode = new BoolExpression (a' newComparator' b);  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  		{  			DebugLocation (98' 4);  			DebugLocation (98' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr195);  			Match (input' TokenTypes.Down' null);  			DebugLocation (98' 12);  			PushFollow (Follow._filterExpr_in_filterExpr199);  			f = filterExpr ();  			PopFollow ();  			DebugLocation (98' 31);  			// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  			int alt6 = 2;  			try {  				DebugEnterSubRule (6);  				try {  					DebugEnterDecision (6' false);  					int LA6_1 = input.LA (1);  					if ((LA6_1 == 24)) {  						alt6 = 1;  					}  				}  				finally {  					DebugExitDecision (6);  				}  				switch (alt6) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  					{  						DebugLocation (98' 31);  						inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (6);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (99' 4);  			FilterTreeNode newNode = f;  			if ((inverse != null ? inverse.Text : default(string)) == "!")  				newNode.ToggleInversed ();  			filterNode = newNode;  		}  		break;  	case 3:  		DebugEnterAlt (3);  		// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  		{  			DebugLocation (105' 4);  			DebugLocation (105' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr216);  			Match (input' TokenTypes.Down' null);  			DebugLocation (105' 12);  			PushFollow (Follow._propertyChain_in_filterExpr219);  			propertyChain (propertySegments);  			PopFollow ();  			DebugLocation (105' 51);  			// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  			int alt7 = 2;  			try {  				DebugEnterSubRule (7);  				try {  					DebugEnterDecision (7' false);  					int LA7_1 = input.LA (1);  					if ((LA7_1 == 31)) {  						alt7 = 1;  					}  				}  				finally {  					DebugExitDecision (7);  				}  				switch (alt7) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  					{  						DebugLocation (105' 51);  						inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (7);  			}  			DebugLocation (105' 60);  			// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  			int alt8 = 2;  			try {  				DebugEnterSubRule (8);  				try {  					DebugEnterDecision (8' false);  					int LA8_1 = input.LA (1);  					if ((LA8_1 == 24)) {  						alt8 = 1;  					}  				}  				finally {  					DebugExitDecision (8);  				}  				switch (alt8) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  					{  						DebugLocation (105' 60);  						not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (8);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (106' 4);  			FilterTreeNode newProperty = new Property (propertySegments);  			if ((inverse != null ? inverse.Text : default(string)) == "?")  				filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  			else {  				if ((not != null ? not.Text : default(string)) == "!")  					newProperty.ToggleInversed ();  				filterNode = newProperty;  			}  		}  		break;  	case 4:  		DebugEnterAlt (4);  		// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  		{  			DebugLocation (116' 4);  			STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  			DebugLocation (117' 4);  			string stringText = (STRING7 != null ? STRING7.Text : default(string));  			stringText = stringText.Substring (1' stringText.Length - 2);  			filterNode = new Value (stringText);  		}  		break;  	case 5:  		DebugEnterAlt (5);  		// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  		{  			DebugLocation (122' 4);  			REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  			DebugLocation (123' 4);  			string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  			regexText = regexText.Substring (1' regexText.Length - 2);  			filterNode = new RegExp (regexText);  		}  		break;  	case 6:  		DebugEnterAlt (6);  		// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  		{  			DebugLocation (128' 4);  			NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  			DebugLocation (129' 4);  			filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  		}  		break;  	case 7:  		DebugEnterAlt (7);  		// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  		{  			DebugLocation (132' 4);  			Match (input' TRUE' Follow._TRUE_in_filterExpr271);  			DebugLocation (133' 4);  			filterNode = new Value (true);  		}  		break;  	case 8:  		DebugEnterAlt (8);  		// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  		{  			DebugLocation (136' 4);  			Match (input' FALSE' Follow._FALSE_in_filterExpr281);  			DebugLocation (137' 4);  			filterNode = new Value (false);  		}  		break;  	case 9:  		DebugEnterAlt (9);  		// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  		{  			DebugLocation (140' 4);  			Match (input' NULL' Follow._NULL_in_filterExpr291);  			DebugLocation (141' 4);  			filterNode = new Value (null);  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("filterExpr"' 6);  	LeaveRule ("filterExpr"' 6);  	LeaveRule_filterExpr ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  	int alt9 = 9;  	try {  		DebugEnterDecision (9' false);  		switch (input.LA (1)) {  		case CHAIN_OPERATOR:  		case COMPARATOR:  			{  				alt9 = 1;  			}  			break;  		case EXPR:  			{  				int LA9_2 = input.LA (2);  				if ((LA9_2 == DOWN)) {  					int LA9_3 = input.LA (3);  					if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  						alt9 = 2;  					}  					else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  						alt9 = 3;  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				else {  					NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  					DebugRecognitionException (nvae);  					throw nvae;  				}  			}  			break;  		case STRING:  			{  				alt9 = 4;  			}  			break;  		case REGEX:  			{  				alt9 = 5;  			}  			break;  		case NUMBER:  			{  				alt9 = 6;  			}  			break;  		case TRUE:  			{  				alt9 = 7;  			}  			break;  		case FALSE:  			{  				alt9 = 8;  			}  			break;  		case NULL:  			{  				alt9 = 9;  			}  			break;  		default: {  			NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  		}  	}  	finally {  		DebugExitDecision (9);  	}  	switch (alt9) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  		{  			DebugLocation (64' 4);  			DebugLocation (64' 6);  			PushFollow (Follow._comparator_in_filterExpr175);  			comparator6 = comparator ();  			PopFollow ();  			Match (input' TokenTypes.Down' null);  			DebugLocation (64' 18);  			PushFollow (Follow._filterExpr_in_filterExpr179);  			a = filterExpr ();  			PopFollow ();  			DebugLocation (64' 31);  			PushFollow (Follow._filterExpr_in_filterExpr183);  			b = filterExpr ();  			PopFollow ();  			Match (input' TokenTypes.Up' null);  			DebugLocation (65' 4);  			Comparator newComparator;  			switch (comparator6) {  			case "=":  				newComparator = Comparator.Equals;  				break;  			case "!=":  				newComparator = Comparator.NotEquals;  				break;  			case ">":  				newComparator = Comparator.Greater;  				break;  			case "<":  				newComparator = Comparator.Less;  				break;  			case ">=":  				newComparator = Comparator.GreaterOrEqual;  				break;  			case "<=":  				newComparator = Comparator.LessOrEqual;  				break;  			case "&":  				newComparator = Comparator.And;  				break;  			case "|":  				newComparator = Comparator.Or;  				break;  			default:  				newComparator = Comparator.Equals;  				break;  			}  			filterNode = new BoolExpression (a' newComparator' b);  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  		{  			DebugLocation (98' 4);  			DebugLocation (98' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr195);  			Match (input' TokenTypes.Down' null);  			DebugLocation (98' 12);  			PushFollow (Follow._filterExpr_in_filterExpr199);  			f = filterExpr ();  			PopFollow ();  			DebugLocation (98' 31);  			// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  			int alt6 = 2;  			try {  				DebugEnterSubRule (6);  				try {  					DebugEnterDecision (6' false);  					int LA6_1 = input.LA (1);  					if ((LA6_1 == 24)) {  						alt6 = 1;  					}  				}  				finally {  					DebugExitDecision (6);  				}  				switch (alt6) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  					{  						DebugLocation (98' 31);  						inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (6);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (99' 4);  			FilterTreeNode newNode = f;  			if ((inverse != null ? inverse.Text : default(string)) == "!")  				newNode.ToggleInversed ();  			filterNode = newNode;  		}  		break;  	case 3:  		DebugEnterAlt (3);  		// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  		{  			DebugLocation (105' 4);  			DebugLocation (105' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr216);  			Match (input' TokenTypes.Down' null);  			DebugLocation (105' 12);  			PushFollow (Follow._propertyChain_in_filterExpr219);  			propertyChain (propertySegments);  			PopFollow ();  			DebugLocation (105' 51);  			// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  			int alt7 = 2;  			try {  				DebugEnterSubRule (7);  				try {  					DebugEnterDecision (7' false);  					int LA7_1 = input.LA (1);  					if ((LA7_1 == 31)) {  						alt7 = 1;  					}  				}  				finally {  					DebugExitDecision (7);  				}  				switch (alt7) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  					{  						DebugLocation (105' 51);  						inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (7);  			}  			DebugLocation (105' 60);  			// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  			int alt8 = 2;  			try {  				DebugEnterSubRule (8);  				try {  					DebugEnterDecision (8' false);  					int LA8_1 = input.LA (1);  					if ((LA8_1 == 24)) {  						alt8 = 1;  					}  				}  				finally {  					DebugExitDecision (8);  				}  				switch (alt8) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  					{  						DebugLocation (105' 60);  						not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (8);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (106' 4);  			FilterTreeNode newProperty = new Property (propertySegments);  			if ((inverse != null ? inverse.Text : default(string)) == "?")  				filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  			else {  				if ((not != null ? not.Text : default(string)) == "!")  					newProperty.ToggleInversed ();  				filterNode = newProperty;  			}  		}  		break;  	case 4:  		DebugEnterAlt (4);  		// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  		{  			DebugLocation (116' 4);  			STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  			DebugLocation (117' 4);  			string stringText = (STRING7 != null ? STRING7.Text : default(string));  			stringText = stringText.Substring (1' stringText.Length - 2);  			filterNode = new Value (stringText);  		}  		break;  	case 5:  		DebugEnterAlt (5);  		// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  		{  			DebugLocation (122' 4);  			REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  			DebugLocation (123' 4);  			string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  			regexText = regexText.Substring (1' regexText.Length - 2);  			filterNode = new RegExp (regexText);  		}  		break;  	case 6:  		DebugEnterAlt (6);  		// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  		{  			DebugLocation (128' 4);  			NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  			DebugLocation (129' 4);  			filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  		}  		break;  	case 7:  		DebugEnterAlt (7);  		// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  		{  			DebugLocation (132' 4);  			Match (input' TRUE' Follow._TRUE_in_filterExpr271);  			DebugLocation (133' 4);  			filterNode = new Value (true);  		}  		break;  	case 8:  		DebugEnterAlt (8);  		// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  		{  			DebugLocation (136' 4);  			Match (input' FALSE' Follow._FALSE_in_filterExpr281);  			DebugLocation (137' 4);  			filterNode = new Value (false);  		}  		break;  	case 9:  		DebugEnterAlt (9);  		// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  		{  			DebugLocation (140' 4);  			Match (input' NULL' Follow._NULL_in_filterExpr291);  			DebugLocation (141' 4);  			filterNode = new Value (null);  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("filterExpr"' 6);  	LeaveRule ("filterExpr"' 6);  	LeaveRule_filterExpr ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  	int alt9 = 9;  	try {  		DebugEnterDecision (9' false);  		switch (input.LA (1)) {  		case CHAIN_OPERATOR:  		case COMPARATOR:  			{  				alt9 = 1;  			}  			break;  		case EXPR:  			{  				int LA9_2 = input.LA (2);  				if ((LA9_2 == DOWN)) {  					int LA9_3 = input.LA (3);  					if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  						alt9 = 2;  					}  					else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  						alt9 = 3;  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				else {  					NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  					DebugRecognitionException (nvae);  					throw nvae;  				}  			}  			break;  		case STRING:  			{  				alt9 = 4;  			}  			break;  		case REGEX:  			{  				alt9 = 5;  			}  			break;  		case NUMBER:  			{  				alt9 = 6;  			}  			break;  		case TRUE:  			{  				alt9 = 7;  			}  			break;  		case FALSE:  			{  				alt9 = 8;  			}  			break;  		case NULL:  			{  				alt9 = 9;  			}  			break;  		default: {  			NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  		}  	}  	finally {  		DebugExitDecision (9);  	}  	switch (alt9) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  		{  			DebugLocation (64' 4);  			DebugLocation (64' 6);  			PushFollow (Follow._comparator_in_filterExpr175);  			comparator6 = comparator ();  			PopFollow ();  			Match (input' TokenTypes.Down' null);  			DebugLocation (64' 18);  			PushFollow (Follow._filterExpr_in_filterExpr179);  			a = filterExpr ();  			PopFollow ();  			DebugLocation (64' 31);  			PushFollow (Follow._filterExpr_in_filterExpr183);  			b = filterExpr ();  			PopFollow ();  			Match (input' TokenTypes.Up' null);  			DebugLocation (65' 4);  			Comparator newComparator;  			switch (comparator6) {  			case "=":  				newComparator = Comparator.Equals;  				break;  			case "!=":  				newComparator = Comparator.NotEquals;  				break;  			case ">":  				newComparator = Comparator.Greater;  				break;  			case "<":  				newComparator = Comparator.Less;  				break;  			case ">=":  				newComparator = Comparator.GreaterOrEqual;  				break;  			case "<=":  				newComparator = Comparator.LessOrEqual;  				break;  			case "&":  				newComparator = Comparator.And;  				break;  			case "|":  				newComparator = Comparator.Or;  				break;  			default:  				newComparator = Comparator.Equals;  				break;  			}  			filterNode = new BoolExpression (a' newComparator' b);  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  		{  			DebugLocation (98' 4);  			DebugLocation (98' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr195);  			Match (input' TokenTypes.Down' null);  			DebugLocation (98' 12);  			PushFollow (Follow._filterExpr_in_filterExpr199);  			f = filterExpr ();  			PopFollow ();  			DebugLocation (98' 31);  			// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  			int alt6 = 2;  			try {  				DebugEnterSubRule (6);  				try {  					DebugEnterDecision (6' false);  					int LA6_1 = input.LA (1);  					if ((LA6_1 == 24)) {  						alt6 = 1;  					}  				}  				finally {  					DebugExitDecision (6);  				}  				switch (alt6) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  					{  						DebugLocation (98' 31);  						inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (6);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (99' 4);  			FilterTreeNode newNode = f;  			if ((inverse != null ? inverse.Text : default(string)) == "!")  				newNode.ToggleInversed ();  			filterNode = newNode;  		}  		break;  	case 3:  		DebugEnterAlt (3);  		// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  		{  			DebugLocation (105' 4);  			DebugLocation (105' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr216);  			Match (input' TokenTypes.Down' null);  			DebugLocation (105' 12);  			PushFollow (Follow._propertyChain_in_filterExpr219);  			propertyChain (propertySegments);  			PopFollow ();  			DebugLocation (105' 51);  			// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  			int alt7 = 2;  			try {  				DebugEnterSubRule (7);  				try {  					DebugEnterDecision (7' false);  					int LA7_1 = input.LA (1);  					if ((LA7_1 == 31)) {  						alt7 = 1;  					}  				}  				finally {  					DebugExitDecision (7);  				}  				switch (alt7) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  					{  						DebugLocation (105' 51);  						inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (7);  			}  			DebugLocation (105' 60);  			// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  			int alt8 = 2;  			try {  				DebugEnterSubRule (8);  				try {  					DebugEnterDecision (8' false);  					int LA8_1 = input.LA (1);  					if ((LA8_1 == 24)) {  						alt8 = 1;  					}  				}  				finally {  					DebugExitDecision (8);  				}  				switch (alt8) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  					{  						DebugLocation (105' 60);  						not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (8);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (106' 4);  			FilterTreeNode newProperty = new Property (propertySegments);  			if ((inverse != null ? inverse.Text : default(string)) == "?")  				filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  			else {  				if ((not != null ? not.Text : default(string)) == "!")  					newProperty.ToggleInversed ();  				filterNode = newProperty;  			}  		}  		break;  	case 4:  		DebugEnterAlt (4);  		// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  		{  			DebugLocation (116' 4);  			STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  			DebugLocation (117' 4);  			string stringText = (STRING7 != null ? STRING7.Text : default(string));  			stringText = stringText.Substring (1' stringText.Length - 2);  			filterNode = new Value (stringText);  		}  		break;  	case 5:  		DebugEnterAlt (5);  		// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  		{  			DebugLocation (122' 4);  			REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  			DebugLocation (123' 4);  			string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  			regexText = regexText.Substring (1' regexText.Length - 2);  			filterNode = new RegExp (regexText);  		}  		break;  	case 6:  		DebugEnterAlt (6);  		// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  		{  			DebugLocation (128' 4);  			NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  			DebugLocation (129' 4);  			filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  		}  		break;  	case 7:  		DebugEnterAlt (7);  		// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  		{  			DebugLocation (132' 4);  			Match (input' TRUE' Follow._TRUE_in_filterExpr271);  			DebugLocation (133' 4);  			filterNode = new Value (true);  		}  		break;  	case 8:  		DebugEnterAlt (8);  		// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  		{  			DebugLocation (136' 4);  			Match (input' FALSE' Follow._FALSE_in_filterExpr281);  			DebugLocation (137' 4);  			filterNode = new Value (false);  		}  		break;  	case 9:  		DebugEnterAlt (9);  		// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  		{  			DebugLocation (140' 4);  			Match (input' NULL' Follow._NULL_in_filterExpr291);  			DebugLocation (141' 4);  			filterNode = new Value (null);  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("filterExpr"' 6);  	LeaveRule ("filterExpr"' 6);  	LeaveRule_filterExpr ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  	int alt9 = 9;  	try {  		DebugEnterDecision (9' false);  		switch (input.LA (1)) {  		case CHAIN_OPERATOR:  		case COMPARATOR:  			{  				alt9 = 1;  			}  			break;  		case EXPR:  			{  				int LA9_2 = input.LA (2);  				if ((LA9_2 == DOWN)) {  					int LA9_3 = input.LA (3);  					if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  						alt9 = 2;  					}  					else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  						alt9 = 3;  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				else {  					NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  					DebugRecognitionException (nvae);  					throw nvae;  				}  			}  			break;  		case STRING:  			{  				alt9 = 4;  			}  			break;  		case REGEX:  			{  				alt9 = 5;  			}  			break;  		case NUMBER:  			{  				alt9 = 6;  			}  			break;  		case TRUE:  			{  				alt9 = 7;  			}  			break;  		case FALSE:  			{  				alt9 = 8;  			}  			break;  		case NULL:  			{  				alt9 = 9;  			}  			break;  		default: {  			NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  		}  	}  	finally {  		DebugExitDecision (9);  	}  	switch (alt9) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  		{  			DebugLocation (64' 4);  			DebugLocation (64' 6);  			PushFollow (Follow._comparator_in_filterExpr175);  			comparator6 = comparator ();  			PopFollow ();  			Match (input' TokenTypes.Down' null);  			DebugLocation (64' 18);  			PushFollow (Follow._filterExpr_in_filterExpr179);  			a = filterExpr ();  			PopFollow ();  			DebugLocation (64' 31);  			PushFollow (Follow._filterExpr_in_filterExpr183);  			b = filterExpr ();  			PopFollow ();  			Match (input' TokenTypes.Up' null);  			DebugLocation (65' 4);  			Comparator newComparator;  			switch (comparator6) {  			case "=":  				newComparator = Comparator.Equals;  				break;  			case "!=":  				newComparator = Comparator.NotEquals;  				break;  			case ">":  				newComparator = Comparator.Greater;  				break;  			case "<":  				newComparator = Comparator.Less;  				break;  			case ">=":  				newComparator = Comparator.GreaterOrEqual;  				break;  			case "<=":  				newComparator = Comparator.LessOrEqual;  				break;  			case "&":  				newComparator = Comparator.And;  				break;  			case "|":  				newComparator = Comparator.Or;  				break;  			default:  				newComparator = Comparator.Equals;  				break;  			}  			filterNode = new BoolExpression (a' newComparator' b);  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  		{  			DebugLocation (98' 4);  			DebugLocation (98' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr195);  			Match (input' TokenTypes.Down' null);  			DebugLocation (98' 12);  			PushFollow (Follow._filterExpr_in_filterExpr199);  			f = filterExpr ();  			PopFollow ();  			DebugLocation (98' 31);  			// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  			int alt6 = 2;  			try {  				DebugEnterSubRule (6);  				try {  					DebugEnterDecision (6' false);  					int LA6_1 = input.LA (1);  					if ((LA6_1 == 24)) {  						alt6 = 1;  					}  				}  				finally {  					DebugExitDecision (6);  				}  				switch (alt6) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  					{  						DebugLocation (98' 31);  						inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (6);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (99' 4);  			FilterTreeNode newNode = f;  			if ((inverse != null ? inverse.Text : default(string)) == "!")  				newNode.ToggleInversed ();  			filterNode = newNode;  		}  		break;  	case 3:  		DebugEnterAlt (3);  		// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  		{  			DebugLocation (105' 4);  			DebugLocation (105' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr216);  			Match (input' TokenTypes.Down' null);  			DebugLocation (105' 12);  			PushFollow (Follow._propertyChain_in_filterExpr219);  			propertyChain (propertySegments);  			PopFollow ();  			DebugLocation (105' 51);  			// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  			int alt7 = 2;  			try {  				DebugEnterSubRule (7);  				try {  					DebugEnterDecision (7' false);  					int LA7_1 = input.LA (1);  					if ((LA7_1 == 31)) {  						alt7 = 1;  					}  				}  				finally {  					DebugExitDecision (7);  				}  				switch (alt7) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  					{  						DebugLocation (105' 51);  						inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (7);  			}  			DebugLocation (105' 60);  			// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  			int alt8 = 2;  			try {  				DebugEnterSubRule (8);  				try {  					DebugEnterDecision (8' false);  					int LA8_1 = input.LA (1);  					if ((LA8_1 == 24)) {  						alt8 = 1;  					}  				}  				finally {  					DebugExitDecision (8);  				}  				switch (alt8) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  					{  						DebugLocation (105' 60);  						not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (8);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (106' 4);  			FilterTreeNode newProperty = new Property (propertySegments);  			if ((inverse != null ? inverse.Text : default(string)) == "?")  				filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  			else {  				if ((not != null ? not.Text : default(string)) == "!")  					newProperty.ToggleInversed ();  				filterNode = newProperty;  			}  		}  		break;  	case 4:  		DebugEnterAlt (4);  		// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  		{  			DebugLocation (116' 4);  			STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  			DebugLocation (117' 4);  			string stringText = (STRING7 != null ? STRING7.Text : default(string));  			stringText = stringText.Substring (1' stringText.Length - 2);  			filterNode = new Value (stringText);  		}  		break;  	case 5:  		DebugEnterAlt (5);  		// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  		{  			DebugLocation (122' 4);  			REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  			DebugLocation (123' 4);  			string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  			regexText = regexText.Substring (1' regexText.Length - 2);  			filterNode = new RegExp (regexText);  		}  		break;  	case 6:  		DebugEnterAlt (6);  		// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  		{  			DebugLocation (128' 4);  			NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  			DebugLocation (129' 4);  			filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  		}  		break;  	case 7:  		DebugEnterAlt (7);  		// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  		{  			DebugLocation (132' 4);  			Match (input' TRUE' Follow._TRUE_in_filterExpr271);  			DebugLocation (133' 4);  			filterNode = new Value (true);  		}  		break;  	case 8:  		DebugEnterAlt (8);  		// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  		{  			DebugLocation (136' 4);  			Match (input' FALSE' Follow._FALSE_in_filterExpr281);  			DebugLocation (137' 4);  			filterNode = new Value (false);  		}  		break;  	case 9:  		DebugEnterAlt (9);  		// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  		{  			DebugLocation (140' 4);  			Match (input' NULL' Follow._NULL_in_filterExpr291);  			DebugLocation (141' 4);  			filterNode = new Value (null);  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("filterExpr"' 6);  	LeaveRule ("filterExpr"' 6);  	LeaveRule_filterExpr ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  	int alt9 = 9;  	try {  		DebugEnterDecision (9' false);  		switch (input.LA (1)) {  		case CHAIN_OPERATOR:  		case COMPARATOR:  			{  				alt9 = 1;  			}  			break;  		case EXPR:  			{  				int LA9_2 = input.LA (2);  				if ((LA9_2 == DOWN)) {  					int LA9_3 = input.LA (3);  					if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  						alt9 = 2;  					}  					else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  						alt9 = 3;  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				else {  					NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  					DebugRecognitionException (nvae);  					throw nvae;  				}  			}  			break;  		case STRING:  			{  				alt9 = 4;  			}  			break;  		case REGEX:  			{  				alt9 = 5;  			}  			break;  		case NUMBER:  			{  				alt9 = 6;  			}  			break;  		case TRUE:  			{  				alt9 = 7;  			}  			break;  		case FALSE:  			{  				alt9 = 8;  			}  			break;  		case NULL:  			{  				alt9 = 9;  			}  			break;  		default: {  			NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  		}  	}  	finally {  		DebugExitDecision (9);  	}  	switch (alt9) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  		{  			DebugLocation (64' 4);  			DebugLocation (64' 6);  			PushFollow (Follow._comparator_in_filterExpr175);  			comparator6 = comparator ();  			PopFollow ();  			Match (input' TokenTypes.Down' null);  			DebugLocation (64' 18);  			PushFollow (Follow._filterExpr_in_filterExpr179);  			a = filterExpr ();  			PopFollow ();  			DebugLocation (64' 31);  			PushFollow (Follow._filterExpr_in_filterExpr183);  			b = filterExpr ();  			PopFollow ();  			Match (input' TokenTypes.Up' null);  			DebugLocation (65' 4);  			Comparator newComparator;  			switch (comparator6) {  			case "=":  				newComparator = Comparator.Equals;  				break;  			case "!=":  				newComparator = Comparator.NotEquals;  				break;  			case ">":  				newComparator = Comparator.Greater;  				break;  			case "<":  				newComparator = Comparator.Less;  				break;  			case ">=":  				newComparator = Comparator.GreaterOrEqual;  				break;  			case "<=":  				newComparator = Comparator.LessOrEqual;  				break;  			case "&":  				newComparator = Comparator.And;  				break;  			case "|":  				newComparator = Comparator.Or;  				break;  			default:  				newComparator = Comparator.Equals;  				break;  			}  			filterNode = new BoolExpression (a' newComparator' b);  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  		{  			DebugLocation (98' 4);  			DebugLocation (98' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr195);  			Match (input' TokenTypes.Down' null);  			DebugLocation (98' 12);  			PushFollow (Follow._filterExpr_in_filterExpr199);  			f = filterExpr ();  			PopFollow ();  			DebugLocation (98' 31);  			// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  			int alt6 = 2;  			try {  				DebugEnterSubRule (6);  				try {  					DebugEnterDecision (6' false);  					int LA6_1 = input.LA (1);  					if ((LA6_1 == 24)) {  						alt6 = 1;  					}  				}  				finally {  					DebugExitDecision (6);  				}  				switch (alt6) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  					{  						DebugLocation (98' 31);  						inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (6);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (99' 4);  			FilterTreeNode newNode = f;  			if ((inverse != null ? inverse.Text : default(string)) == "!")  				newNode.ToggleInversed ();  			filterNode = newNode;  		}  		break;  	case 3:  		DebugEnterAlt (3);  		// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  		{  			DebugLocation (105' 4);  			DebugLocation (105' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr216);  			Match (input' TokenTypes.Down' null);  			DebugLocation (105' 12);  			PushFollow (Follow._propertyChain_in_filterExpr219);  			propertyChain (propertySegments);  			PopFollow ();  			DebugLocation (105' 51);  			// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  			int alt7 = 2;  			try {  				DebugEnterSubRule (7);  				try {  					DebugEnterDecision (7' false);  					int LA7_1 = input.LA (1);  					if ((LA7_1 == 31)) {  						alt7 = 1;  					}  				}  				finally {  					DebugExitDecision (7);  				}  				switch (alt7) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  					{  						DebugLocation (105' 51);  						inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (7);  			}  			DebugLocation (105' 60);  			// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  			int alt8 = 2;  			try {  				DebugEnterSubRule (8);  				try {  					DebugEnterDecision (8' false);  					int LA8_1 = input.LA (1);  					if ((LA8_1 == 24)) {  						alt8 = 1;  					}  				}  				finally {  					DebugExitDecision (8);  				}  				switch (alt8) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  					{  						DebugLocation (105' 60);  						not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (8);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (106' 4);  			FilterTreeNode newProperty = new Property (propertySegments);  			if ((inverse != null ? inverse.Text : default(string)) == "?")  				filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  			else {  				if ((not != null ? not.Text : default(string)) == "!")  					newProperty.ToggleInversed ();  				filterNode = newProperty;  			}  		}  		break;  	case 4:  		DebugEnterAlt (4);  		// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  		{  			DebugLocation (116' 4);  			STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  			DebugLocation (117' 4);  			string stringText = (STRING7 != null ? STRING7.Text : default(string));  			stringText = stringText.Substring (1' stringText.Length - 2);  			filterNode = new Value (stringText);  		}  		break;  	case 5:  		DebugEnterAlt (5);  		// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  		{  			DebugLocation (122' 4);  			REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  			DebugLocation (123' 4);  			string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  			regexText = regexText.Substring (1' regexText.Length - 2);  			filterNode = new RegExp (regexText);  		}  		break;  	case 6:  		DebugEnterAlt (6);  		// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  		{  			DebugLocation (128' 4);  			NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  			DebugLocation (129' 4);  			filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  		}  		break;  	case 7:  		DebugEnterAlt (7);  		// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  		{  			DebugLocation (132' 4);  			Match (input' TRUE' Follow._TRUE_in_filterExpr271);  			DebugLocation (133' 4);  			filterNode = new Value (true);  		}  		break;  	case 8:  		DebugEnterAlt (8);  		// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  		{  			DebugLocation (136' 4);  			Match (input' FALSE' Follow._FALSE_in_filterExpr281);  			DebugLocation (137' 4);  			filterNode = new Value (false);  		}  		break;  	case 9:  		DebugEnterAlt (9);  		// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  		{  			DebugLocation (140' 4);  			Match (input' NULL' Follow._NULL_in_filterExpr291);  			DebugLocation (141' 4);  			filterNode = new Value (null);  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("filterExpr"' 6);  	LeaveRule ("filterExpr"' 6);  	LeaveRule_filterExpr ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  	int alt9 = 9;  	try {  		DebugEnterDecision (9' false);  		switch (input.LA (1)) {  		case CHAIN_OPERATOR:  		case COMPARATOR:  			{  				alt9 = 1;  			}  			break;  		case EXPR:  			{  				int LA9_2 = input.LA (2);  				if ((LA9_2 == DOWN)) {  					int LA9_3 = input.LA (3);  					if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  						alt9 = 2;  					}  					else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  						alt9 = 3;  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				else {  					NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  					DebugRecognitionException (nvae);  					throw nvae;  				}  			}  			break;  		case STRING:  			{  				alt9 = 4;  			}  			break;  		case REGEX:  			{  				alt9 = 5;  			}  			break;  		case NUMBER:  			{  				alt9 = 6;  			}  			break;  		case TRUE:  			{  				alt9 = 7;  			}  			break;  		case FALSE:  			{  				alt9 = 8;  			}  			break;  		case NULL:  			{  				alt9 = 9;  			}  			break;  		default: {  			NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  		}  	}  	finally {  		DebugExitDecision (9);  	}  	switch (alt9) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  		{  			DebugLocation (64' 4);  			DebugLocation (64' 6);  			PushFollow (Follow._comparator_in_filterExpr175);  			comparator6 = comparator ();  			PopFollow ();  			Match (input' TokenTypes.Down' null);  			DebugLocation (64' 18);  			PushFollow (Follow._filterExpr_in_filterExpr179);  			a = filterExpr ();  			PopFollow ();  			DebugLocation (64' 31);  			PushFollow (Follow._filterExpr_in_filterExpr183);  			b = filterExpr ();  			PopFollow ();  			Match (input' TokenTypes.Up' null);  			DebugLocation (65' 4);  			Comparator newComparator;  			switch (comparator6) {  			case "=":  				newComparator = Comparator.Equals;  				break;  			case "!=":  				newComparator = Comparator.NotEquals;  				break;  			case ">":  				newComparator = Comparator.Greater;  				break;  			case "<":  				newComparator = Comparator.Less;  				break;  			case ">=":  				newComparator = Comparator.GreaterOrEqual;  				break;  			case "<=":  				newComparator = Comparator.LessOrEqual;  				break;  			case "&":  				newComparator = Comparator.And;  				break;  			case "|":  				newComparator = Comparator.Or;  				break;  			default:  				newComparator = Comparator.Equals;  				break;  			}  			filterNode = new BoolExpression (a' newComparator' b);  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  		{  			DebugLocation (98' 4);  			DebugLocation (98' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr195);  			Match (input' TokenTypes.Down' null);  			DebugLocation (98' 12);  			PushFollow (Follow._filterExpr_in_filterExpr199);  			f = filterExpr ();  			PopFollow ();  			DebugLocation (98' 31);  			// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  			int alt6 = 2;  			try {  				DebugEnterSubRule (6);  				try {  					DebugEnterDecision (6' false);  					int LA6_1 = input.LA (1);  					if ((LA6_1 == 24)) {  						alt6 = 1;  					}  				}  				finally {  					DebugExitDecision (6);  				}  				switch (alt6) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  					{  						DebugLocation (98' 31);  						inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (6);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (99' 4);  			FilterTreeNode newNode = f;  			if ((inverse != null ? inverse.Text : default(string)) == "!")  				newNode.ToggleInversed ();  			filterNode = newNode;  		}  		break;  	case 3:  		DebugEnterAlt (3);  		// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  		{  			DebugLocation (105' 4);  			DebugLocation (105' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr216);  			Match (input' TokenTypes.Down' null);  			DebugLocation (105' 12);  			PushFollow (Follow._propertyChain_in_filterExpr219);  			propertyChain (propertySegments);  			PopFollow ();  			DebugLocation (105' 51);  			// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  			int alt7 = 2;  			try {  				DebugEnterSubRule (7);  				try {  					DebugEnterDecision (7' false);  					int LA7_1 = input.LA (1);  					if ((LA7_1 == 31)) {  						alt7 = 1;  					}  				}  				finally {  					DebugExitDecision (7);  				}  				switch (alt7) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  					{  						DebugLocation (105' 51);  						inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (7);  			}  			DebugLocation (105' 60);  			// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  			int alt8 = 2;  			try {  				DebugEnterSubRule (8);  				try {  					DebugEnterDecision (8' false);  					int LA8_1 = input.LA (1);  					if ((LA8_1 == 24)) {  						alt8 = 1;  					}  				}  				finally {  					DebugExitDecision (8);  				}  				switch (alt8) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  					{  						DebugLocation (105' 60);  						not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (8);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (106' 4);  			FilterTreeNode newProperty = new Property (propertySegments);  			if ((inverse != null ? inverse.Text : default(string)) == "?")  				filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  			else {  				if ((not != null ? not.Text : default(string)) == "!")  					newProperty.ToggleInversed ();  				filterNode = newProperty;  			}  		}  		break;  	case 4:  		DebugEnterAlt (4);  		// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  		{  			DebugLocation (116' 4);  			STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  			DebugLocation (117' 4);  			string stringText = (STRING7 != null ? STRING7.Text : default(string));  			stringText = stringText.Substring (1' stringText.Length - 2);  			filterNode = new Value (stringText);  		}  		break;  	case 5:  		DebugEnterAlt (5);  		// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  		{  			DebugLocation (122' 4);  			REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  			DebugLocation (123' 4);  			string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  			regexText = regexText.Substring (1' regexText.Length - 2);  			filterNode = new RegExp (regexText);  		}  		break;  	case 6:  		DebugEnterAlt (6);  		// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  		{  			DebugLocation (128' 4);  			NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  			DebugLocation (129' 4);  			filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  		}  		break;  	case 7:  		DebugEnterAlt (7);  		// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  		{  			DebugLocation (132' 4);  			Match (input' TRUE' Follow._TRUE_in_filterExpr271);  			DebugLocation (133' 4);  			filterNode = new Value (true);  		}  		break;  	case 8:  		DebugEnterAlt (8);  		// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  		{  			DebugLocation (136' 4);  			Match (input' FALSE' Follow._FALSE_in_filterExpr281);  			DebugLocation (137' 4);  			filterNode = new Value (false);  		}  		break;  	case 9:  		DebugEnterAlt (9);  		// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  		{  			DebugLocation (140' 4);  			Match (input' NULL' Follow._NULL_in_filterExpr291);  			DebugLocation (141' 4);  			filterNode = new Value (null);  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("filterExpr"' 6);  	LeaveRule ("filterExpr"' 6);  	LeaveRule_filterExpr ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  	int alt9 = 9;  	try {  		DebugEnterDecision (9' false);  		switch (input.LA (1)) {  		case CHAIN_OPERATOR:  		case COMPARATOR:  			{  				alt9 = 1;  			}  			break;  		case EXPR:  			{  				int LA9_2 = input.LA (2);  				if ((LA9_2 == DOWN)) {  					int LA9_3 = input.LA (3);  					if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  						alt9 = 2;  					}  					else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  						alt9 = 3;  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				else {  					NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  					DebugRecognitionException (nvae);  					throw nvae;  				}  			}  			break;  		case STRING:  			{  				alt9 = 4;  			}  			break;  		case REGEX:  			{  				alt9 = 5;  			}  			break;  		case NUMBER:  			{  				alt9 = 6;  			}  			break;  		case TRUE:  			{  				alt9 = 7;  			}  			break;  		case FALSE:  			{  				alt9 = 8;  			}  			break;  		case NULL:  			{  				alt9 = 9;  			}  			break;  		default: {  			NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  		}  	}  	finally {  		DebugExitDecision (9);  	}  	switch (alt9) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  		{  			DebugLocation (64' 4);  			DebugLocation (64' 6);  			PushFollow (Follow._comparator_in_filterExpr175);  			comparator6 = comparator ();  			PopFollow ();  			Match (input' TokenTypes.Down' null);  			DebugLocation (64' 18);  			PushFollow (Follow._filterExpr_in_filterExpr179);  			a = filterExpr ();  			PopFollow ();  			DebugLocation (64' 31);  			PushFollow (Follow._filterExpr_in_filterExpr183);  			b = filterExpr ();  			PopFollow ();  			Match (input' TokenTypes.Up' null);  			DebugLocation (65' 4);  			Comparator newComparator;  			switch (comparator6) {  			case "=":  				newComparator = Comparator.Equals;  				break;  			case "!=":  				newComparator = Comparator.NotEquals;  				break;  			case ">":  				newComparator = Comparator.Greater;  				break;  			case "<":  				newComparator = Comparator.Less;  				break;  			case ">=":  				newComparator = Comparator.GreaterOrEqual;  				break;  			case "<=":  				newComparator = Comparator.LessOrEqual;  				break;  			case "&":  				newComparator = Comparator.And;  				break;  			case "|":  				newComparator = Comparator.Or;  				break;  			default:  				newComparator = Comparator.Equals;  				break;  			}  			filterNode = new BoolExpression (a' newComparator' b);  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  		{  			DebugLocation (98' 4);  			DebugLocation (98' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr195);  			Match (input' TokenTypes.Down' null);  			DebugLocation (98' 12);  			PushFollow (Follow._filterExpr_in_filterExpr199);  			f = filterExpr ();  			PopFollow ();  			DebugLocation (98' 31);  			// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  			int alt6 = 2;  			try {  				DebugEnterSubRule (6);  				try {  					DebugEnterDecision (6' false);  					int LA6_1 = input.LA (1);  					if ((LA6_1 == 24)) {  						alt6 = 1;  					}  				}  				finally {  					DebugExitDecision (6);  				}  				switch (alt6) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  					{  						DebugLocation (98' 31);  						inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (6);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (99' 4);  			FilterTreeNode newNode = f;  			if ((inverse != null ? inverse.Text : default(string)) == "!")  				newNode.ToggleInversed ();  			filterNode = newNode;  		}  		break;  	case 3:  		DebugEnterAlt (3);  		// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  		{  			DebugLocation (105' 4);  			DebugLocation (105' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr216);  			Match (input' TokenTypes.Down' null);  			DebugLocation (105' 12);  			PushFollow (Follow._propertyChain_in_filterExpr219);  			propertyChain (propertySegments);  			PopFollow ();  			DebugLocation (105' 51);  			// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  			int alt7 = 2;  			try {  				DebugEnterSubRule (7);  				try {  					DebugEnterDecision (7' false);  					int LA7_1 = input.LA (1);  					if ((LA7_1 == 31)) {  						alt7 = 1;  					}  				}  				finally {  					DebugExitDecision (7);  				}  				switch (alt7) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  					{  						DebugLocation (105' 51);  						inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (7);  			}  			DebugLocation (105' 60);  			// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  			int alt8 = 2;  			try {  				DebugEnterSubRule (8);  				try {  					DebugEnterDecision (8' false);  					int LA8_1 = input.LA (1);  					if ((LA8_1 == 24)) {  						alt8 = 1;  					}  				}  				finally {  					DebugExitDecision (8);  				}  				switch (alt8) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  					{  						DebugLocation (105' 60);  						not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (8);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (106' 4);  			FilterTreeNode newProperty = new Property (propertySegments);  			if ((inverse != null ? inverse.Text : default(string)) == "?")  				filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  			else {  				if ((not != null ? not.Text : default(string)) == "!")  					newProperty.ToggleInversed ();  				filterNode = newProperty;  			}  		}  		break;  	case 4:  		DebugEnterAlt (4);  		// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  		{  			DebugLocation (116' 4);  			STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  			DebugLocation (117' 4);  			string stringText = (STRING7 != null ? STRING7.Text : default(string));  			stringText = stringText.Substring (1' stringText.Length - 2);  			filterNode = new Value (stringText);  		}  		break;  	case 5:  		DebugEnterAlt (5);  		// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  		{  			DebugLocation (122' 4);  			REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  			DebugLocation (123' 4);  			string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  			regexText = regexText.Substring (1' regexText.Length - 2);  			filterNode = new RegExp (regexText);  		}  		break;  	case 6:  		DebugEnterAlt (6);  		// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  		{  			DebugLocation (128' 4);  			NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  			DebugLocation (129' 4);  			filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  		}  		break;  	case 7:  		DebugEnterAlt (7);  		// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  		{  			DebugLocation (132' 4);  			Match (input' TRUE' Follow._TRUE_in_filterExpr271);  			DebugLocation (133' 4);  			filterNode = new Value (true);  		}  		break;  	case 8:  		DebugEnterAlt (8);  		// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  		{  			DebugLocation (136' 4);  			Match (input' FALSE' Follow._FALSE_in_filterExpr281);  			DebugLocation (137' 4);  			filterNode = new Value (false);  		}  		break;  	case 9:  		DebugEnterAlt (9);  		// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  		{  			DebugLocation (140' 4);  			Match (input' NULL' Follow._NULL_in_filterExpr291);  			DebugLocation (141' 4);  			filterNode = new Value (null);  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("filterExpr"' 6);  	LeaveRule ("filterExpr"' 6);  	LeaveRule_filterExpr ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  	int alt9 = 9;  	try {  		DebugEnterDecision (9' false);  		switch (input.LA (1)) {  		case CHAIN_OPERATOR:  		case COMPARATOR:  			{  				alt9 = 1;  			}  			break;  		case EXPR:  			{  				int LA9_2 = input.LA (2);  				if ((LA9_2 == DOWN)) {  					int LA9_3 = input.LA (3);  					if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  						alt9 = 2;  					}  					else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  						alt9 = 3;  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				else {  					NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  					DebugRecognitionException (nvae);  					throw nvae;  				}  			}  			break;  		case STRING:  			{  				alt9 = 4;  			}  			break;  		case REGEX:  			{  				alt9 = 5;  			}  			break;  		case NUMBER:  			{  				alt9 = 6;  			}  			break;  		case TRUE:  			{  				alt9 = 7;  			}  			break;  		case FALSE:  			{  				alt9 = 8;  			}  			break;  		case NULL:  			{  				alt9 = 9;  			}  			break;  		default: {  			NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  		}  	}  	finally {  		DebugExitDecision (9);  	}  	switch (alt9) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  		{  			DebugLocation (64' 4);  			DebugLocation (64' 6);  			PushFollow (Follow._comparator_in_filterExpr175);  			comparator6 = comparator ();  			PopFollow ();  			Match (input' TokenTypes.Down' null);  			DebugLocation (64' 18);  			PushFollow (Follow._filterExpr_in_filterExpr179);  			a = filterExpr ();  			PopFollow ();  			DebugLocation (64' 31);  			PushFollow (Follow._filterExpr_in_filterExpr183);  			b = filterExpr ();  			PopFollow ();  			Match (input' TokenTypes.Up' null);  			DebugLocation (65' 4);  			Comparator newComparator;  			switch (comparator6) {  			case "=":  				newComparator = Comparator.Equals;  				break;  			case "!=":  				newComparator = Comparator.NotEquals;  				break;  			case ">":  				newComparator = Comparator.Greater;  				break;  			case "<":  				newComparator = Comparator.Less;  				break;  			case ">=":  				newComparator = Comparator.GreaterOrEqual;  				break;  			case "<=":  				newComparator = Comparator.LessOrEqual;  				break;  			case "&":  				newComparator = Comparator.And;  				break;  			case "|":  				newComparator = Comparator.Or;  				break;  			default:  				newComparator = Comparator.Equals;  				break;  			}  			filterNode = new BoolExpression (a' newComparator' b);  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  		{  			DebugLocation (98' 4);  			DebugLocation (98' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr195);  			Match (input' TokenTypes.Down' null);  			DebugLocation (98' 12);  			PushFollow (Follow._filterExpr_in_filterExpr199);  			f = filterExpr ();  			PopFollow ();  			DebugLocation (98' 31);  			// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  			int alt6 = 2;  			try {  				DebugEnterSubRule (6);  				try {  					DebugEnterDecision (6' false);  					int LA6_1 = input.LA (1);  					if ((LA6_1 == 24)) {  						alt6 = 1;  					}  				}  				finally {  					DebugExitDecision (6);  				}  				switch (alt6) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  					{  						DebugLocation (98' 31);  						inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (6);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (99' 4);  			FilterTreeNode newNode = f;  			if ((inverse != null ? inverse.Text : default(string)) == "!")  				newNode.ToggleInversed ();  			filterNode = newNode;  		}  		break;  	case 3:  		DebugEnterAlt (3);  		// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  		{  			DebugLocation (105' 4);  			DebugLocation (105' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr216);  			Match (input' TokenTypes.Down' null);  			DebugLocation (105' 12);  			PushFollow (Follow._propertyChain_in_filterExpr219);  			propertyChain (propertySegments);  			PopFollow ();  			DebugLocation (105' 51);  			// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  			int alt7 = 2;  			try {  				DebugEnterSubRule (7);  				try {  					DebugEnterDecision (7' false);  					int LA7_1 = input.LA (1);  					if ((LA7_1 == 31)) {  						alt7 = 1;  					}  				}  				finally {  					DebugExitDecision (7);  				}  				switch (alt7) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  					{  						DebugLocation (105' 51);  						inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (7);  			}  			DebugLocation (105' 60);  			// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  			int alt8 = 2;  			try {  				DebugEnterSubRule (8);  				try {  					DebugEnterDecision (8' false);  					int LA8_1 = input.LA (1);  					if ((LA8_1 == 24)) {  						alt8 = 1;  					}  				}  				finally {  					DebugExitDecision (8);  				}  				switch (alt8) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  					{  						DebugLocation (105' 60);  						not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (8);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (106' 4);  			FilterTreeNode newProperty = new Property (propertySegments);  			if ((inverse != null ? inverse.Text : default(string)) == "?")  				filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  			else {  				if ((not != null ? not.Text : default(string)) == "!")  					newProperty.ToggleInversed ();  				filterNode = newProperty;  			}  		}  		break;  	case 4:  		DebugEnterAlt (4);  		// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  		{  			DebugLocation (116' 4);  			STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  			DebugLocation (117' 4);  			string stringText = (STRING7 != null ? STRING7.Text : default(string));  			stringText = stringText.Substring (1' stringText.Length - 2);  			filterNode = new Value (stringText);  		}  		break;  	case 5:  		DebugEnterAlt (5);  		// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  		{  			DebugLocation (122' 4);  			REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  			DebugLocation (123' 4);  			string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  			regexText = regexText.Substring (1' regexText.Length - 2);  			filterNode = new RegExp (regexText);  		}  		break;  	case 6:  		DebugEnterAlt (6);  		// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  		{  			DebugLocation (128' 4);  			NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  			DebugLocation (129' 4);  			filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  		}  		break;  	case 7:  		DebugEnterAlt (7);  		// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  		{  			DebugLocation (132' 4);  			Match (input' TRUE' Follow._TRUE_in_filterExpr271);  			DebugLocation (133' 4);  			filterNode = new Value (true);  		}  		break;  	case 8:  		DebugEnterAlt (8);  		// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  		{  			DebugLocation (136' 4);  			Match (input' FALSE' Follow._FALSE_in_filterExpr281);  			DebugLocation (137' 4);  			filterNode = new Value (false);  		}  		break;  	case 9:  		DebugEnterAlt (9);  		// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  		{  			DebugLocation (140' 4);  			Match (input' NULL' Follow._NULL_in_filterExpr291);  			DebugLocation (141' 4);  			filterNode = new Value (null);  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("filterExpr"' 6);  	LeaveRule ("filterExpr"' 6);  	LeaveRule_filterExpr ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  	int alt9 = 9;  	try {  		DebugEnterDecision (9' false);  		switch (input.LA (1)) {  		case CHAIN_OPERATOR:  		case COMPARATOR:  			{  				alt9 = 1;  			}  			break;  		case EXPR:  			{  				int LA9_2 = input.LA (2);  				if ((LA9_2 == DOWN)) {  					int LA9_3 = input.LA (3);  					if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  						alt9 = 2;  					}  					else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  						alt9 = 3;  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				else {  					NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  					DebugRecognitionException (nvae);  					throw nvae;  				}  			}  			break;  		case STRING:  			{  				alt9 = 4;  			}  			break;  		case REGEX:  			{  				alt9 = 5;  			}  			break;  		case NUMBER:  			{  				alt9 = 6;  			}  			break;  		case TRUE:  			{  				alt9 = 7;  			}  			break;  		case FALSE:  			{  				alt9 = 8;  			}  			break;  		case NULL:  			{  				alt9 = 9;  			}  			break;  		default: {  			NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  		}  	}  	finally {  		DebugExitDecision (9);  	}  	switch (alt9) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  		{  			DebugLocation (64' 4);  			DebugLocation (64' 6);  			PushFollow (Follow._comparator_in_filterExpr175);  			comparator6 = comparator ();  			PopFollow ();  			Match (input' TokenTypes.Down' null);  			DebugLocation (64' 18);  			PushFollow (Follow._filterExpr_in_filterExpr179);  			a = filterExpr ();  			PopFollow ();  			DebugLocation (64' 31);  			PushFollow (Follow._filterExpr_in_filterExpr183);  			b = filterExpr ();  			PopFollow ();  			Match (input' TokenTypes.Up' null);  			DebugLocation (65' 4);  			Comparator newComparator;  			switch (comparator6) {  			case "=":  				newComparator = Comparator.Equals;  				break;  			case "!=":  				newComparator = Comparator.NotEquals;  				break;  			case ">":  				newComparator = Comparator.Greater;  				break;  			case "<":  				newComparator = Comparator.Less;  				break;  			case ">=":  				newComparator = Comparator.GreaterOrEqual;  				break;  			case "<=":  				newComparator = Comparator.LessOrEqual;  				break;  			case "&":  				newComparator = Comparator.And;  				break;  			case "|":  				newComparator = Comparator.Or;  				break;  			default:  				newComparator = Comparator.Equals;  				break;  			}  			filterNode = new BoolExpression (a' newComparator' b);  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  		{  			DebugLocation (98' 4);  			DebugLocation (98' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr195);  			Match (input' TokenTypes.Down' null);  			DebugLocation (98' 12);  			PushFollow (Follow._filterExpr_in_filterExpr199);  			f = filterExpr ();  			PopFollow ();  			DebugLocation (98' 31);  			// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  			int alt6 = 2;  			try {  				DebugEnterSubRule (6);  				try {  					DebugEnterDecision (6' false);  					int LA6_1 = input.LA (1);  					if ((LA6_1 == 24)) {  						alt6 = 1;  					}  				}  				finally {  					DebugExitDecision (6);  				}  				switch (alt6) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  					{  						DebugLocation (98' 31);  						inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (6);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (99' 4);  			FilterTreeNode newNode = f;  			if ((inverse != null ? inverse.Text : default(string)) == "!")  				newNode.ToggleInversed ();  			filterNode = newNode;  		}  		break;  	case 3:  		DebugEnterAlt (3);  		// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  		{  			DebugLocation (105' 4);  			DebugLocation (105' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr216);  			Match (input' TokenTypes.Down' null);  			DebugLocation (105' 12);  			PushFollow (Follow._propertyChain_in_filterExpr219);  			propertyChain (propertySegments);  			PopFollow ();  			DebugLocation (105' 51);  			// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  			int alt7 = 2;  			try {  				DebugEnterSubRule (7);  				try {  					DebugEnterDecision (7' false);  					int LA7_1 = input.LA (1);  					if ((LA7_1 == 31)) {  						alt7 = 1;  					}  				}  				finally {  					DebugExitDecision (7);  				}  				switch (alt7) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  					{  						DebugLocation (105' 51);  						inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (7);  			}  			DebugLocation (105' 60);  			// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  			int alt8 = 2;  			try {  				DebugEnterSubRule (8);  				try {  					DebugEnterDecision (8' false);  					int LA8_1 = input.LA (1);  					if ((LA8_1 == 24)) {  						alt8 = 1;  					}  				}  				finally {  					DebugExitDecision (8);  				}  				switch (alt8) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  					{  						DebugLocation (105' 60);  						not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (8);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (106' 4);  			FilterTreeNode newProperty = new Property (propertySegments);  			if ((inverse != null ? inverse.Text : default(string)) == "?")  				filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  			else {  				if ((not != null ? not.Text : default(string)) == "!")  					newProperty.ToggleInversed ();  				filterNode = newProperty;  			}  		}  		break;  	case 4:  		DebugEnterAlt (4);  		// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  		{  			DebugLocation (116' 4);  			STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  			DebugLocation (117' 4);  			string stringText = (STRING7 != null ? STRING7.Text : default(string));  			stringText = stringText.Substring (1' stringText.Length - 2);  			filterNode = new Value (stringText);  		}  		break;  	case 5:  		DebugEnterAlt (5);  		// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  		{  			DebugLocation (122' 4);  			REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  			DebugLocation (123' 4);  			string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  			regexText = regexText.Substring (1' regexText.Length - 2);  			filterNode = new RegExp (regexText);  		}  		break;  	case 6:  		DebugEnterAlt (6);  		// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  		{  			DebugLocation (128' 4);  			NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  			DebugLocation (129' 4);  			filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  		}  		break;  	case 7:  		DebugEnterAlt (7);  		// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  		{  			DebugLocation (132' 4);  			Match (input' TRUE' Follow._TRUE_in_filterExpr271);  			DebugLocation (133' 4);  			filterNode = new Value (true);  		}  		break;  	case 8:  		DebugEnterAlt (8);  		// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  		{  			DebugLocation (136' 4);  			Match (input' FALSE' Follow._FALSE_in_filterExpr281);  			DebugLocation (137' 4);  			filterNode = new Value (false);  		}  		break;  	case 9:  		DebugEnterAlt (9);  		// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  		{  			DebugLocation (140' 4);  			Match (input' NULL' Follow._NULL_in_filterExpr291);  			DebugLocation (141' 4);  			filterNode = new Value (null);  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("filterExpr"' 6);  	LeaveRule ("filterExpr"' 6);  	LeaveRule_filterExpr ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  	int alt9 = 9;  	try {  		DebugEnterDecision (9' false);  		switch (input.LA (1)) {  		case CHAIN_OPERATOR:  		case COMPARATOR:  			{  				alt9 = 1;  			}  			break;  		case EXPR:  			{  				int LA9_2 = input.LA (2);  				if ((LA9_2 == DOWN)) {  					int LA9_3 = input.LA (3);  					if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  						alt9 = 2;  					}  					else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  						alt9 = 3;  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				else {  					NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  					DebugRecognitionException (nvae);  					throw nvae;  				}  			}  			break;  		case STRING:  			{  				alt9 = 4;  			}  			break;  		case REGEX:  			{  				alt9 = 5;  			}  			break;  		case NUMBER:  			{  				alt9 = 6;  			}  			break;  		case TRUE:  			{  				alt9 = 7;  			}  			break;  		case FALSE:  			{  				alt9 = 8;  			}  			break;  		case NULL:  			{  				alt9 = 9;  			}  			break;  		default: {  			NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  		}  	}  	finally {  		DebugExitDecision (9);  	}  	switch (alt9) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  		{  			DebugLocation (64' 4);  			DebugLocation (64' 6);  			PushFollow (Follow._comparator_in_filterExpr175);  			comparator6 = comparator ();  			PopFollow ();  			Match (input' TokenTypes.Down' null);  			DebugLocation (64' 18);  			PushFollow (Follow._filterExpr_in_filterExpr179);  			a = filterExpr ();  			PopFollow ();  			DebugLocation (64' 31);  			PushFollow (Follow._filterExpr_in_filterExpr183);  			b = filterExpr ();  			PopFollow ();  			Match (input' TokenTypes.Up' null);  			DebugLocation (65' 4);  			Comparator newComparator;  			switch (comparator6) {  			case "=":  				newComparator = Comparator.Equals;  				break;  			case "!=":  				newComparator = Comparator.NotEquals;  				break;  			case ">":  				newComparator = Comparator.Greater;  				break;  			case "<":  				newComparator = Comparator.Less;  				break;  			case ">=":  				newComparator = Comparator.GreaterOrEqual;  				break;  			case "<=":  				newComparator = Comparator.LessOrEqual;  				break;  			case "&":  				newComparator = Comparator.And;  				break;  			case "|":  				newComparator = Comparator.Or;  				break;  			default:  				newComparator = Comparator.Equals;  				break;  			}  			filterNode = new BoolExpression (a' newComparator' b);  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  		{  			DebugLocation (98' 4);  			DebugLocation (98' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr195);  			Match (input' TokenTypes.Down' null);  			DebugLocation (98' 12);  			PushFollow (Follow._filterExpr_in_filterExpr199);  			f = filterExpr ();  			PopFollow ();  			DebugLocation (98' 31);  			// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  			int alt6 = 2;  			try {  				DebugEnterSubRule (6);  				try {  					DebugEnterDecision (6' false);  					int LA6_1 = input.LA (1);  					if ((LA6_1 == 24)) {  						alt6 = 1;  					}  				}  				finally {  					DebugExitDecision (6);  				}  				switch (alt6) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  					{  						DebugLocation (98' 31);  						inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (6);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (99' 4);  			FilterTreeNode newNode = f;  			if ((inverse != null ? inverse.Text : default(string)) == "!")  				newNode.ToggleInversed ();  			filterNode = newNode;  		}  		break;  	case 3:  		DebugEnterAlt (3);  		// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  		{  			DebugLocation (105' 4);  			DebugLocation (105' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr216);  			Match (input' TokenTypes.Down' null);  			DebugLocation (105' 12);  			PushFollow (Follow._propertyChain_in_filterExpr219);  			propertyChain (propertySegments);  			PopFollow ();  			DebugLocation (105' 51);  			// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  			int alt7 = 2;  			try {  				DebugEnterSubRule (7);  				try {  					DebugEnterDecision (7' false);  					int LA7_1 = input.LA (1);  					if ((LA7_1 == 31)) {  						alt7 = 1;  					}  				}  				finally {  					DebugExitDecision (7);  				}  				switch (alt7) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  					{  						DebugLocation (105' 51);  						inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (7);  			}  			DebugLocation (105' 60);  			// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  			int alt8 = 2;  			try {  				DebugEnterSubRule (8);  				try {  					DebugEnterDecision (8' false);  					int LA8_1 = input.LA (1);  					if ((LA8_1 == 24)) {  						alt8 = 1;  					}  				}  				finally {  					DebugExitDecision (8);  				}  				switch (alt8) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  					{  						DebugLocation (105' 60);  						not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (8);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (106' 4);  			FilterTreeNode newProperty = new Property (propertySegments);  			if ((inverse != null ? inverse.Text : default(string)) == "?")  				filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  			else {  				if ((not != null ? not.Text : default(string)) == "!")  					newProperty.ToggleInversed ();  				filterNode = newProperty;  			}  		}  		break;  	case 4:  		DebugEnterAlt (4);  		// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  		{  			DebugLocation (116' 4);  			STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  			DebugLocation (117' 4);  			string stringText = (STRING7 != null ? STRING7.Text : default(string));  			stringText = stringText.Substring (1' stringText.Length - 2);  			filterNode = new Value (stringText);  		}  		break;  	case 5:  		DebugEnterAlt (5);  		// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  		{  			DebugLocation (122' 4);  			REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  			DebugLocation (123' 4);  			string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  			regexText = regexText.Substring (1' regexText.Length - 2);  			filterNode = new RegExp (regexText);  		}  		break;  	case 6:  		DebugEnterAlt (6);  		// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  		{  			DebugLocation (128' 4);  			NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  			DebugLocation (129' 4);  			filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  		}  		break;  	case 7:  		DebugEnterAlt (7);  		// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  		{  			DebugLocation (132' 4);  			Match (input' TRUE' Follow._TRUE_in_filterExpr271);  			DebugLocation (133' 4);  			filterNode = new Value (true);  		}  		break;  	case 8:  		DebugEnterAlt (8);  		// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  		{  			DebugLocation (136' 4);  			Match (input' FALSE' Follow._FALSE_in_filterExpr281);  			DebugLocation (137' 4);  			filterNode = new Value (false);  		}  		break;  	case 9:  		DebugEnterAlt (9);  		// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  		{  			DebugLocation (140' 4);  			Match (input' NULL' Follow._NULL_in_filterExpr291);  			DebugLocation (141' 4);  			filterNode = new Value (null);  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("filterExpr"' 6);  	LeaveRule ("filterExpr"' 6);  	LeaveRule_filterExpr ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  	int alt9 = 9;  	try {  		DebugEnterDecision (9' false);  		switch (input.LA (1)) {  		case CHAIN_OPERATOR:  		case COMPARATOR:  			{  				alt9 = 1;  			}  			break;  		case EXPR:  			{  				int LA9_2 = input.LA (2);  				if ((LA9_2 == DOWN)) {  					int LA9_3 = input.LA (3);  					if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  						alt9 = 2;  					}  					else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  						alt9 = 3;  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				else {  					NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  					DebugRecognitionException (nvae);  					throw nvae;  				}  			}  			break;  		case STRING:  			{  				alt9 = 4;  			}  			break;  		case REGEX:  			{  				alt9 = 5;  			}  			break;  		case NUMBER:  			{  				alt9 = 6;  			}  			break;  		case TRUE:  			{  				alt9 = 7;  			}  			break;  		case FALSE:  			{  				alt9 = 8;  			}  			break;  		case NULL:  			{  				alt9 = 9;  			}  			break;  		default: {  			NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  		}  	}  	finally {  		DebugExitDecision (9);  	}  	switch (alt9) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  		{  			DebugLocation (64' 4);  			DebugLocation (64' 6);  			PushFollow (Follow._comparator_in_filterExpr175);  			comparator6 = comparator ();  			PopFollow ();  			Match (input' TokenTypes.Down' null);  			DebugLocation (64' 18);  			PushFollow (Follow._filterExpr_in_filterExpr179);  			a = filterExpr ();  			PopFollow ();  			DebugLocation (64' 31);  			PushFollow (Follow._filterExpr_in_filterExpr183);  			b = filterExpr ();  			PopFollow ();  			Match (input' TokenTypes.Up' null);  			DebugLocation (65' 4);  			Comparator newComparator;  			switch (comparator6) {  			case "=":  				newComparator = Comparator.Equals;  				break;  			case "!=":  				newComparator = Comparator.NotEquals;  				break;  			case ">":  				newComparator = Comparator.Greater;  				break;  			case "<":  				newComparator = Comparator.Less;  				break;  			case ">=":  				newComparator = Comparator.GreaterOrEqual;  				break;  			case "<=":  				newComparator = Comparator.LessOrEqual;  				break;  			case "&":  				newComparator = Comparator.And;  				break;  			case "|":  				newComparator = Comparator.Or;  				break;  			default:  				newComparator = Comparator.Equals;  				break;  			}  			filterNode = new BoolExpression (a' newComparator' b);  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  		{  			DebugLocation (98' 4);  			DebugLocation (98' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr195);  			Match (input' TokenTypes.Down' null);  			DebugLocation (98' 12);  			PushFollow (Follow._filterExpr_in_filterExpr199);  			f = filterExpr ();  			PopFollow ();  			DebugLocation (98' 31);  			// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  			int alt6 = 2;  			try {  				DebugEnterSubRule (6);  				try {  					DebugEnterDecision (6' false);  					int LA6_1 = input.LA (1);  					if ((LA6_1 == 24)) {  						alt6 = 1;  					}  				}  				finally {  					DebugExitDecision (6);  				}  				switch (alt6) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  					{  						DebugLocation (98' 31);  						inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (6);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (99' 4);  			FilterTreeNode newNode = f;  			if ((inverse != null ? inverse.Text : default(string)) == "!")  				newNode.ToggleInversed ();  			filterNode = newNode;  		}  		break;  	case 3:  		DebugEnterAlt (3);  		// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  		{  			DebugLocation (105' 4);  			DebugLocation (105' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr216);  			Match (input' TokenTypes.Down' null);  			DebugLocation (105' 12);  			PushFollow (Follow._propertyChain_in_filterExpr219);  			propertyChain (propertySegments);  			PopFollow ();  			DebugLocation (105' 51);  			// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  			int alt7 = 2;  			try {  				DebugEnterSubRule (7);  				try {  					DebugEnterDecision (7' false);  					int LA7_1 = input.LA (1);  					if ((LA7_1 == 31)) {  						alt7 = 1;  					}  				}  				finally {  					DebugExitDecision (7);  				}  				switch (alt7) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  					{  						DebugLocation (105' 51);  						inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (7);  			}  			DebugLocation (105' 60);  			// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  			int alt8 = 2;  			try {  				DebugEnterSubRule (8);  				try {  					DebugEnterDecision (8' false);  					int LA8_1 = input.LA (1);  					if ((LA8_1 == 24)) {  						alt8 = 1;  					}  				}  				finally {  					DebugExitDecision (8);  				}  				switch (alt8) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  					{  						DebugLocation (105' 60);  						not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (8);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (106' 4);  			FilterTreeNode newProperty = new Property (propertySegments);  			if ((inverse != null ? inverse.Text : default(string)) == "?")  				filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  			else {  				if ((not != null ? not.Text : default(string)) == "!")  					newProperty.ToggleInversed ();  				filterNode = newProperty;  			}  		}  		break;  	case 4:  		DebugEnterAlt (4);  		// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  		{  			DebugLocation (116' 4);  			STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  			DebugLocation (117' 4);  			string stringText = (STRING7 != null ? STRING7.Text : default(string));  			stringText = stringText.Substring (1' stringText.Length - 2);  			filterNode = new Value (stringText);  		}  		break;  	case 5:  		DebugEnterAlt (5);  		// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  		{  			DebugLocation (122' 4);  			REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  			DebugLocation (123' 4);  			string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  			regexText = regexText.Substring (1' regexText.Length - 2);  			filterNode = new RegExp (regexText);  		}  		break;  	case 6:  		DebugEnterAlt (6);  		// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  		{  			DebugLocation (128' 4);  			NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  			DebugLocation (129' 4);  			filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  		}  		break;  	case 7:  		DebugEnterAlt (7);  		// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  		{  			DebugLocation (132' 4);  			Match (input' TRUE' Follow._TRUE_in_filterExpr271);  			DebugLocation (133' 4);  			filterNode = new Value (true);  		}  		break;  	case 8:  		DebugEnterAlt (8);  		// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  		{  			DebugLocation (136' 4);  			Match (input' FALSE' Follow._FALSE_in_filterExpr281);  			DebugLocation (137' 4);  			filterNode = new Value (false);  		}  		break;  	case 9:  		DebugEnterAlt (9);  		// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  		{  			DebugLocation (140' 4);  			Match (input' NULL' Follow._NULL_in_filterExpr291);  			DebugLocation (141' 4);  			filterNode = new Value (null);  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("filterExpr"' 6);  	LeaveRule ("filterExpr"' 6);  	LeaveRule_filterExpr ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  	int alt9 = 9;  	try {  		DebugEnterDecision (9' false);  		switch (input.LA (1)) {  		case CHAIN_OPERATOR:  		case COMPARATOR:  			{  				alt9 = 1;  			}  			break;  		case EXPR:  			{  				int LA9_2 = input.LA (2);  				if ((LA9_2 == DOWN)) {  					int LA9_3 = input.LA (3);  					if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  						alt9 = 2;  					}  					else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  						alt9 = 3;  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				else {  					NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  					DebugRecognitionException (nvae);  					throw nvae;  				}  			}  			break;  		case STRING:  			{  				alt9 = 4;  			}  			break;  		case REGEX:  			{  				alt9 = 5;  			}  			break;  		case NUMBER:  			{  				alt9 = 6;  			}  			break;  		case TRUE:  			{  				alt9 = 7;  			}  			break;  		case FALSE:  			{  				alt9 = 8;  			}  			break;  		case NULL:  			{  				alt9 = 9;  			}  			break;  		default: {  			NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  		}  	}  	finally {  		DebugExitDecision (9);  	}  	switch (alt9) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  		{  			DebugLocation (64' 4);  			DebugLocation (64' 6);  			PushFollow (Follow._comparator_in_filterExpr175);  			comparator6 = comparator ();  			PopFollow ();  			Match (input' TokenTypes.Down' null);  			DebugLocation (64' 18);  			PushFollow (Follow._filterExpr_in_filterExpr179);  			a = filterExpr ();  			PopFollow ();  			DebugLocation (64' 31);  			PushFollow (Follow._filterExpr_in_filterExpr183);  			b = filterExpr ();  			PopFollow ();  			Match (input' TokenTypes.Up' null);  			DebugLocation (65' 4);  			Comparator newComparator;  			switch (comparator6) {  			case "=":  				newComparator = Comparator.Equals;  				break;  			case "!=":  				newComparator = Comparator.NotEquals;  				break;  			case ">":  				newComparator = Comparator.Greater;  				break;  			case "<":  				newComparator = Comparator.Less;  				break;  			case ">=":  				newComparator = Comparator.GreaterOrEqual;  				break;  			case "<=":  				newComparator = Comparator.LessOrEqual;  				break;  			case "&":  				newComparator = Comparator.And;  				break;  			case "|":  				newComparator = Comparator.Or;  				break;  			default:  				newComparator = Comparator.Equals;  				break;  			}  			filterNode = new BoolExpression (a' newComparator' b);  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  		{  			DebugLocation (98' 4);  			DebugLocation (98' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr195);  			Match (input' TokenTypes.Down' null);  			DebugLocation (98' 12);  			PushFollow (Follow._filterExpr_in_filterExpr199);  			f = filterExpr ();  			PopFollow ();  			DebugLocation (98' 31);  			// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  			int alt6 = 2;  			try {  				DebugEnterSubRule (6);  				try {  					DebugEnterDecision (6' false);  					int LA6_1 = input.LA (1);  					if ((LA6_1 == 24)) {  						alt6 = 1;  					}  				}  				finally {  					DebugExitDecision (6);  				}  				switch (alt6) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  					{  						DebugLocation (98' 31);  						inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (6);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (99' 4);  			FilterTreeNode newNode = f;  			if ((inverse != null ? inverse.Text : default(string)) == "!")  				newNode.ToggleInversed ();  			filterNode = newNode;  		}  		break;  	case 3:  		DebugEnterAlt (3);  		// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  		{  			DebugLocation (105' 4);  			DebugLocation (105' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr216);  			Match (input' TokenTypes.Down' null);  			DebugLocation (105' 12);  			PushFollow (Follow._propertyChain_in_filterExpr219);  			propertyChain (propertySegments);  			PopFollow ();  			DebugLocation (105' 51);  			// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  			int alt7 = 2;  			try {  				DebugEnterSubRule (7);  				try {  					DebugEnterDecision (7' false);  					int LA7_1 = input.LA (1);  					if ((LA7_1 == 31)) {  						alt7 = 1;  					}  				}  				finally {  					DebugExitDecision (7);  				}  				switch (alt7) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  					{  						DebugLocation (105' 51);  						inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (7);  			}  			DebugLocation (105' 60);  			// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  			int alt8 = 2;  			try {  				DebugEnterSubRule (8);  				try {  					DebugEnterDecision (8' false);  					int LA8_1 = input.LA (1);  					if ((LA8_1 == 24)) {  						alt8 = 1;  					}  				}  				finally {  					DebugExitDecision (8);  				}  				switch (alt8) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  					{  						DebugLocation (105' 60);  						not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (8);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (106' 4);  			FilterTreeNode newProperty = new Property (propertySegments);  			if ((inverse != null ? inverse.Text : default(string)) == "?")  				filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  			else {  				if ((not != null ? not.Text : default(string)) == "!")  					newProperty.ToggleInversed ();  				filterNode = newProperty;  			}  		}  		break;  	case 4:  		DebugEnterAlt (4);  		// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  		{  			DebugLocation (116' 4);  			STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  			DebugLocation (117' 4);  			string stringText = (STRING7 != null ? STRING7.Text : default(string));  			stringText = stringText.Substring (1' stringText.Length - 2);  			filterNode = new Value (stringText);  		}  		break;  	case 5:  		DebugEnterAlt (5);  		// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  		{  			DebugLocation (122' 4);  			REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  			DebugLocation (123' 4);  			string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  			regexText = regexText.Substring (1' regexText.Length - 2);  			filterNode = new RegExp (regexText);  		}  		break;  	case 6:  		DebugEnterAlt (6);  		// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  		{  			DebugLocation (128' 4);  			NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  			DebugLocation (129' 4);  			filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  		}  		break;  	case 7:  		DebugEnterAlt (7);  		// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  		{  			DebugLocation (132' 4);  			Match (input' TRUE' Follow._TRUE_in_filterExpr271);  			DebugLocation (133' 4);  			filterNode = new Value (true);  		}  		break;  	case 8:  		DebugEnterAlt (8);  		// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  		{  			DebugLocation (136' 4);  			Match (input' FALSE' Follow._FALSE_in_filterExpr281);  			DebugLocation (137' 4);  			filterNode = new Value (false);  		}  		break;  	case 9:  		DebugEnterAlt (9);  		// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  		{  			DebugLocation (140' 4);  			Match (input' NULL' Follow._NULL_in_filterExpr291);  			DebugLocation (141' 4);  			filterNode = new Value (null);  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("filterExpr"' 6);  	LeaveRule ("filterExpr"' 6);  	LeaveRule_filterExpr ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  	int alt9 = 9;  	try {  		DebugEnterDecision (9' false);  		switch (input.LA (1)) {  		case CHAIN_OPERATOR:  		case COMPARATOR:  			{  				alt9 = 1;  			}  			break;  		case EXPR:  			{  				int LA9_2 = input.LA (2);  				if ((LA9_2 == DOWN)) {  					int LA9_3 = input.LA (3);  					if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  						alt9 = 2;  					}  					else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  						alt9 = 3;  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				else {  					NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  					DebugRecognitionException (nvae);  					throw nvae;  				}  			}  			break;  		case STRING:  			{  				alt9 = 4;  			}  			break;  		case REGEX:  			{  				alt9 = 5;  			}  			break;  		case NUMBER:  			{  				alt9 = 6;  			}  			break;  		case TRUE:  			{  				alt9 = 7;  			}  			break;  		case FALSE:  			{  				alt9 = 8;  			}  			break;  		case NULL:  			{  				alt9 = 9;  			}  			break;  		default: {  			NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  		}  	}  	finally {  		DebugExitDecision (9);  	}  	switch (alt9) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  		{  			DebugLocation (64' 4);  			DebugLocation (64' 6);  			PushFollow (Follow._comparator_in_filterExpr175);  			comparator6 = comparator ();  			PopFollow ();  			Match (input' TokenTypes.Down' null);  			DebugLocation (64' 18);  			PushFollow (Follow._filterExpr_in_filterExpr179);  			a = filterExpr ();  			PopFollow ();  			DebugLocation (64' 31);  			PushFollow (Follow._filterExpr_in_filterExpr183);  			b = filterExpr ();  			PopFollow ();  			Match (input' TokenTypes.Up' null);  			DebugLocation (65' 4);  			Comparator newComparator;  			switch (comparator6) {  			case "=":  				newComparator = Comparator.Equals;  				break;  			case "!=":  				newComparator = Comparator.NotEquals;  				break;  			case ">":  				newComparator = Comparator.Greater;  				break;  			case "<":  				newComparator = Comparator.Less;  				break;  			case ">=":  				newComparator = Comparator.GreaterOrEqual;  				break;  			case "<=":  				newComparator = Comparator.LessOrEqual;  				break;  			case "&":  				newComparator = Comparator.And;  				break;  			case "|":  				newComparator = Comparator.Or;  				break;  			default:  				newComparator = Comparator.Equals;  				break;  			}  			filterNode = new BoolExpression (a' newComparator' b);  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  		{  			DebugLocation (98' 4);  			DebugLocation (98' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr195);  			Match (input' TokenTypes.Down' null);  			DebugLocation (98' 12);  			PushFollow (Follow._filterExpr_in_filterExpr199);  			f = filterExpr ();  			PopFollow ();  			DebugLocation (98' 31);  			// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  			int alt6 = 2;  			try {  				DebugEnterSubRule (6);  				try {  					DebugEnterDecision (6' false);  					int LA6_1 = input.LA (1);  					if ((LA6_1 == 24)) {  						alt6 = 1;  					}  				}  				finally {  					DebugExitDecision (6);  				}  				switch (alt6) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  					{  						DebugLocation (98' 31);  						inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (6);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (99' 4);  			FilterTreeNode newNode = f;  			if ((inverse != null ? inverse.Text : default(string)) == "!")  				newNode.ToggleInversed ();  			filterNode = newNode;  		}  		break;  	case 3:  		DebugEnterAlt (3);  		// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  		{  			DebugLocation (105' 4);  			DebugLocation (105' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr216);  			Match (input' TokenTypes.Down' null);  			DebugLocation (105' 12);  			PushFollow (Follow._propertyChain_in_filterExpr219);  			propertyChain (propertySegments);  			PopFollow ();  			DebugLocation (105' 51);  			// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  			int alt7 = 2;  			try {  				DebugEnterSubRule (7);  				try {  					DebugEnterDecision (7' false);  					int LA7_1 = input.LA (1);  					if ((LA7_1 == 31)) {  						alt7 = 1;  					}  				}  				finally {  					DebugExitDecision (7);  				}  				switch (alt7) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  					{  						DebugLocation (105' 51);  						inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (7);  			}  			DebugLocation (105' 60);  			// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  			int alt8 = 2;  			try {  				DebugEnterSubRule (8);  				try {  					DebugEnterDecision (8' false);  					int LA8_1 = input.LA (1);  					if ((LA8_1 == 24)) {  						alt8 = 1;  					}  				}  				finally {  					DebugExitDecision (8);  				}  				switch (alt8) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  					{  						DebugLocation (105' 60);  						not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (8);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (106' 4);  			FilterTreeNode newProperty = new Property (propertySegments);  			if ((inverse != null ? inverse.Text : default(string)) == "?")  				filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  			else {  				if ((not != null ? not.Text : default(string)) == "!")  					newProperty.ToggleInversed ();  				filterNode = newProperty;  			}  		}  		break;  	case 4:  		DebugEnterAlt (4);  		// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  		{  			DebugLocation (116' 4);  			STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  			DebugLocation (117' 4);  			string stringText = (STRING7 != null ? STRING7.Text : default(string));  			stringText = stringText.Substring (1' stringText.Length - 2);  			filterNode = new Value (stringText);  		}  		break;  	case 5:  		DebugEnterAlt (5);  		// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  		{  			DebugLocation (122' 4);  			REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  			DebugLocation (123' 4);  			string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  			regexText = regexText.Substring (1' regexText.Length - 2);  			filterNode = new RegExp (regexText);  		}  		break;  	case 6:  		DebugEnterAlt (6);  		// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  		{  			DebugLocation (128' 4);  			NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  			DebugLocation (129' 4);  			filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  		}  		break;  	case 7:  		DebugEnterAlt (7);  		// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  		{  			DebugLocation (132' 4);  			Match (input' TRUE' Follow._TRUE_in_filterExpr271);  			DebugLocation (133' 4);  			filterNode = new Value (true);  		}  		break;  	case 8:  		DebugEnterAlt (8);  		// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  		{  			DebugLocation (136' 4);  			Match (input' FALSE' Follow._FALSE_in_filterExpr281);  			DebugLocation (137' 4);  			filterNode = new Value (false);  		}  		break;  	case 9:  		DebugEnterAlt (9);  		// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  		{  			DebugLocation (140' 4);  			Match (input' NULL' Follow._NULL_in_filterExpr291);  			DebugLocation (141' 4);  			filterNode = new Value (null);  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("filterExpr"' 6);  	LeaveRule ("filterExpr"' 6);  	LeaveRule_filterExpr ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  	int alt9 = 9;  	try {  		DebugEnterDecision (9' false);  		switch (input.LA (1)) {  		case CHAIN_OPERATOR:  		case COMPARATOR:  			{  				alt9 = 1;  			}  			break;  		case EXPR:  			{  				int LA9_2 = input.LA (2);  				if ((LA9_2 == DOWN)) {  					int LA9_3 = input.LA (3);  					if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  						alt9 = 2;  					}  					else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  						alt9 = 3;  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				else {  					NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  					DebugRecognitionException (nvae);  					throw nvae;  				}  			}  			break;  		case STRING:  			{  				alt9 = 4;  			}  			break;  		case REGEX:  			{  				alt9 = 5;  			}  			break;  		case NUMBER:  			{  				alt9 = 6;  			}  			break;  		case TRUE:  			{  				alt9 = 7;  			}  			break;  		case FALSE:  			{  				alt9 = 8;  			}  			break;  		case NULL:  			{  				alt9 = 9;  			}  			break;  		default: {  			NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  		}  	}  	finally {  		DebugExitDecision (9);  	}  	switch (alt9) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  		{  			DebugLocation (64' 4);  			DebugLocation (64' 6);  			PushFollow (Follow._comparator_in_filterExpr175);  			comparator6 = comparator ();  			PopFollow ();  			Match (input' TokenTypes.Down' null);  			DebugLocation (64' 18);  			PushFollow (Follow._filterExpr_in_filterExpr179);  			a = filterExpr ();  			PopFollow ();  			DebugLocation (64' 31);  			PushFollow (Follow._filterExpr_in_filterExpr183);  			b = filterExpr ();  			PopFollow ();  			Match (input' TokenTypes.Up' null);  			DebugLocation (65' 4);  			Comparator newComparator;  			switch (comparator6) {  			case "=":  				newComparator = Comparator.Equals;  				break;  			case "!=":  				newComparator = Comparator.NotEquals;  				break;  			case ">":  				newComparator = Comparator.Greater;  				break;  			case "<":  				newComparator = Comparator.Less;  				break;  			case ">=":  				newComparator = Comparator.GreaterOrEqual;  				break;  			case "<=":  				newComparator = Comparator.LessOrEqual;  				break;  			case "&":  				newComparator = Comparator.And;  				break;  			case "|":  				newComparator = Comparator.Or;  				break;  			default:  				newComparator = Comparator.Equals;  				break;  			}  			filterNode = new BoolExpression (a' newComparator' b);  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  		{  			DebugLocation (98' 4);  			DebugLocation (98' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr195);  			Match (input' TokenTypes.Down' null);  			DebugLocation (98' 12);  			PushFollow (Follow._filterExpr_in_filterExpr199);  			f = filterExpr ();  			PopFollow ();  			DebugLocation (98' 31);  			// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  			int alt6 = 2;  			try {  				DebugEnterSubRule (6);  				try {  					DebugEnterDecision (6' false);  					int LA6_1 = input.LA (1);  					if ((LA6_1 == 24)) {  						alt6 = 1;  					}  				}  				finally {  					DebugExitDecision (6);  				}  				switch (alt6) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  					{  						DebugLocation (98' 31);  						inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (6);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (99' 4);  			FilterTreeNode newNode = f;  			if ((inverse != null ? inverse.Text : default(string)) == "!")  				newNode.ToggleInversed ();  			filterNode = newNode;  		}  		break;  	case 3:  		DebugEnterAlt (3);  		// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  		{  			DebugLocation (105' 4);  			DebugLocation (105' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr216);  			Match (input' TokenTypes.Down' null);  			DebugLocation (105' 12);  			PushFollow (Follow._propertyChain_in_filterExpr219);  			propertyChain (propertySegments);  			PopFollow ();  			DebugLocation (105' 51);  			// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  			int alt7 = 2;  			try {  				DebugEnterSubRule (7);  				try {  					DebugEnterDecision (7' false);  					int LA7_1 = input.LA (1);  					if ((LA7_1 == 31)) {  						alt7 = 1;  					}  				}  				finally {  					DebugExitDecision (7);  				}  				switch (alt7) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  					{  						DebugLocation (105' 51);  						inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (7);  			}  			DebugLocation (105' 60);  			// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  			int alt8 = 2;  			try {  				DebugEnterSubRule (8);  				try {  					DebugEnterDecision (8' false);  					int LA8_1 = input.LA (1);  					if ((LA8_1 == 24)) {  						alt8 = 1;  					}  				}  				finally {  					DebugExitDecision (8);  				}  				switch (alt8) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  					{  						DebugLocation (105' 60);  						not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (8);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (106' 4);  			FilterTreeNode newProperty = new Property (propertySegments);  			if ((inverse != null ? inverse.Text : default(string)) == "?")  				filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  			else {  				if ((not != null ? not.Text : default(string)) == "!")  					newProperty.ToggleInversed ();  				filterNode = newProperty;  			}  		}  		break;  	case 4:  		DebugEnterAlt (4);  		// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  		{  			DebugLocation (116' 4);  			STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  			DebugLocation (117' 4);  			string stringText = (STRING7 != null ? STRING7.Text : default(string));  			stringText = stringText.Substring (1' stringText.Length - 2);  			filterNode = new Value (stringText);  		}  		break;  	case 5:  		DebugEnterAlt (5);  		// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  		{  			DebugLocation (122' 4);  			REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  			DebugLocation (123' 4);  			string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  			regexText = regexText.Substring (1' regexText.Length - 2);  			filterNode = new RegExp (regexText);  		}  		break;  	case 6:  		DebugEnterAlt (6);  		// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  		{  			DebugLocation (128' 4);  			NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  			DebugLocation (129' 4);  			filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  		}  		break;  	case 7:  		DebugEnterAlt (7);  		// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  		{  			DebugLocation (132' 4);  			Match (input' TRUE' Follow._TRUE_in_filterExpr271);  			DebugLocation (133' 4);  			filterNode = new Value (true);  		}  		break;  	case 8:  		DebugEnterAlt (8);  		// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  		{  			DebugLocation (136' 4);  			Match (input' FALSE' Follow._FALSE_in_filterExpr281);  			DebugLocation (137' 4);  			filterNode = new Value (false);  		}  		break;  	case 9:  		DebugEnterAlt (9);  		// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  		{  			DebugLocation (140' 4);  			Match (input' NULL' Follow._NULL_in_filterExpr291);  			DebugLocation (141' 4);  			filterNode = new Value (null);  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("filterExpr"' 6);  	LeaveRule ("filterExpr"' 6);  	LeaveRule_filterExpr ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  	int alt9 = 9;  	try {  		DebugEnterDecision (9' false);  		switch (input.LA (1)) {  		case CHAIN_OPERATOR:  		case COMPARATOR:  			{  				alt9 = 1;  			}  			break;  		case EXPR:  			{  				int LA9_2 = input.LA (2);  				if ((LA9_2 == DOWN)) {  					int LA9_3 = input.LA (3);  					if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  						alt9 = 2;  					}  					else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  						alt9 = 3;  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				else {  					NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  					DebugRecognitionException (nvae);  					throw nvae;  				}  			}  			break;  		case STRING:  			{  				alt9 = 4;  			}  			break;  		case REGEX:  			{  				alt9 = 5;  			}  			break;  		case NUMBER:  			{  				alt9 = 6;  			}  			break;  		case TRUE:  			{  				alt9 = 7;  			}  			break;  		case FALSE:  			{  				alt9 = 8;  			}  			break;  		case NULL:  			{  				alt9 = 9;  			}  			break;  		default: {  			NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  		}  	}  	finally {  		DebugExitDecision (9);  	}  	switch (alt9) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  		{  			DebugLocation (64' 4);  			DebugLocation (64' 6);  			PushFollow (Follow._comparator_in_filterExpr175);  			comparator6 = comparator ();  			PopFollow ();  			Match (input' TokenTypes.Down' null);  			DebugLocation (64' 18);  			PushFollow (Follow._filterExpr_in_filterExpr179);  			a = filterExpr ();  			PopFollow ();  			DebugLocation (64' 31);  			PushFollow (Follow._filterExpr_in_filterExpr183);  			b = filterExpr ();  			PopFollow ();  			Match (input' TokenTypes.Up' null);  			DebugLocation (65' 4);  			Comparator newComparator;  			switch (comparator6) {  			case "=":  				newComparator = Comparator.Equals;  				break;  			case "!=":  				newComparator = Comparator.NotEquals;  				break;  			case ">":  				newComparator = Comparator.Greater;  				break;  			case "<":  				newComparator = Comparator.Less;  				break;  			case ">=":  				newComparator = Comparator.GreaterOrEqual;  				break;  			case "<=":  				newComparator = Comparator.LessOrEqual;  				break;  			case "&":  				newComparator = Comparator.And;  				break;  			case "|":  				newComparator = Comparator.Or;  				break;  			default:  				newComparator = Comparator.Equals;  				break;  			}  			filterNode = new BoolExpression (a' newComparator' b);  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  		{  			DebugLocation (98' 4);  			DebugLocation (98' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr195);  			Match (input' TokenTypes.Down' null);  			DebugLocation (98' 12);  			PushFollow (Follow._filterExpr_in_filterExpr199);  			f = filterExpr ();  			PopFollow ();  			DebugLocation (98' 31);  			// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  			int alt6 = 2;  			try {  				DebugEnterSubRule (6);  				try {  					DebugEnterDecision (6' false);  					int LA6_1 = input.LA (1);  					if ((LA6_1 == 24)) {  						alt6 = 1;  					}  				}  				finally {  					DebugExitDecision (6);  				}  				switch (alt6) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  					{  						DebugLocation (98' 31);  						inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (6);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (99' 4);  			FilterTreeNode newNode = f;  			if ((inverse != null ? inverse.Text : default(string)) == "!")  				newNode.ToggleInversed ();  			filterNode = newNode;  		}  		break;  	case 3:  		DebugEnterAlt (3);  		// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  		{  			DebugLocation (105' 4);  			DebugLocation (105' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr216);  			Match (input' TokenTypes.Down' null);  			DebugLocation (105' 12);  			PushFollow (Follow._propertyChain_in_filterExpr219);  			propertyChain (propertySegments);  			PopFollow ();  			DebugLocation (105' 51);  			// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  			int alt7 = 2;  			try {  				DebugEnterSubRule (7);  				try {  					DebugEnterDecision (7' false);  					int LA7_1 = input.LA (1);  					if ((LA7_1 == 31)) {  						alt7 = 1;  					}  				}  				finally {  					DebugExitDecision (7);  				}  				switch (alt7) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  					{  						DebugLocation (105' 51);  						inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (7);  			}  			DebugLocation (105' 60);  			// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  			int alt8 = 2;  			try {  				DebugEnterSubRule (8);  				try {  					DebugEnterDecision (8' false);  					int LA8_1 = input.LA (1);  					if ((LA8_1 == 24)) {  						alt8 = 1;  					}  				}  				finally {  					DebugExitDecision (8);  				}  				switch (alt8) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  					{  						DebugLocation (105' 60);  						not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (8);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (106' 4);  			FilterTreeNode newProperty = new Property (propertySegments);  			if ((inverse != null ? inverse.Text : default(string)) == "?")  				filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  			else {  				if ((not != null ? not.Text : default(string)) == "!")  					newProperty.ToggleInversed ();  				filterNode = newProperty;  			}  		}  		break;  	case 4:  		DebugEnterAlt (4);  		// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  		{  			DebugLocation (116' 4);  			STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  			DebugLocation (117' 4);  			string stringText = (STRING7 != null ? STRING7.Text : default(string));  			stringText = stringText.Substring (1' stringText.Length - 2);  			filterNode = new Value (stringText);  		}  		break;  	case 5:  		DebugEnterAlt (5);  		// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  		{  			DebugLocation (122' 4);  			REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  			DebugLocation (123' 4);  			string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  			regexText = regexText.Substring (1' regexText.Length - 2);  			filterNode = new RegExp (regexText);  		}  		break;  	case 6:  		DebugEnterAlt (6);  		// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  		{  			DebugLocation (128' 4);  			NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  			DebugLocation (129' 4);  			filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  		}  		break;  	case 7:  		DebugEnterAlt (7);  		// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  		{  			DebugLocation (132' 4);  			Match (input' TRUE' Follow._TRUE_in_filterExpr271);  			DebugLocation (133' 4);  			filterNode = new Value (true);  		}  		break;  	case 8:  		DebugEnterAlt (8);  		// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  		{  			DebugLocation (136' 4);  			Match (input' FALSE' Follow._FALSE_in_filterExpr281);  			DebugLocation (137' 4);  			filterNode = new Value (false);  		}  		break;  	case 9:  		DebugEnterAlt (9);  		// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  		{  			DebugLocation (140' 4);  			Match (input' NULL' Follow._NULL_in_filterExpr291);  			DebugLocation (141' 4);  			filterNode = new Value (null);  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("filterExpr"' 6);  	LeaveRule ("filterExpr"' 6);  	LeaveRule_filterExpr ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  	int alt9 = 9;  	try {  		DebugEnterDecision (9' false);  		switch (input.LA (1)) {  		case CHAIN_OPERATOR:  		case COMPARATOR:  			{  				alt9 = 1;  			}  			break;  		case EXPR:  			{  				int LA9_2 = input.LA (2);  				if ((LA9_2 == DOWN)) {  					int LA9_3 = input.LA (3);  					if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  						alt9 = 2;  					}  					else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  						alt9 = 3;  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				else {  					NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  					DebugRecognitionException (nvae);  					throw nvae;  				}  			}  			break;  		case STRING:  			{  				alt9 = 4;  			}  			break;  		case REGEX:  			{  				alt9 = 5;  			}  			break;  		case NUMBER:  			{  				alt9 = 6;  			}  			break;  		case TRUE:  			{  				alt9 = 7;  			}  			break;  		case FALSE:  			{  				alt9 = 8;  			}  			break;  		case NULL:  			{  				alt9 = 9;  			}  			break;  		default: {  			NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  		}  	}  	finally {  		DebugExitDecision (9);  	}  	switch (alt9) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  		{  			DebugLocation (64' 4);  			DebugLocation (64' 6);  			PushFollow (Follow._comparator_in_filterExpr175);  			comparator6 = comparator ();  			PopFollow ();  			Match (input' TokenTypes.Down' null);  			DebugLocation (64' 18);  			PushFollow (Follow._filterExpr_in_filterExpr179);  			a = filterExpr ();  			PopFollow ();  			DebugLocation (64' 31);  			PushFollow (Follow._filterExpr_in_filterExpr183);  			b = filterExpr ();  			PopFollow ();  			Match (input' TokenTypes.Up' null);  			DebugLocation (65' 4);  			Comparator newComparator;  			switch (comparator6) {  			case "=":  				newComparator = Comparator.Equals;  				break;  			case "!=":  				newComparator = Comparator.NotEquals;  				break;  			case ">":  				newComparator = Comparator.Greater;  				break;  			case "<":  				newComparator = Comparator.Less;  				break;  			case ">=":  				newComparator = Comparator.GreaterOrEqual;  				break;  			case "<=":  				newComparator = Comparator.LessOrEqual;  				break;  			case "&":  				newComparator = Comparator.And;  				break;  			case "|":  				newComparator = Comparator.Or;  				break;  			default:  				newComparator = Comparator.Equals;  				break;  			}  			filterNode = new BoolExpression (a' newComparator' b);  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  		{  			DebugLocation (98' 4);  			DebugLocation (98' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr195);  			Match (input' TokenTypes.Down' null);  			DebugLocation (98' 12);  			PushFollow (Follow._filterExpr_in_filterExpr199);  			f = filterExpr ();  			PopFollow ();  			DebugLocation (98' 31);  			// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  			int alt6 = 2;  			try {  				DebugEnterSubRule (6);  				try {  					DebugEnterDecision (6' false);  					int LA6_1 = input.LA (1);  					if ((LA6_1 == 24)) {  						alt6 = 1;  					}  				}  				finally {  					DebugExitDecision (6);  				}  				switch (alt6) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  					{  						DebugLocation (98' 31);  						inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (6);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (99' 4);  			FilterTreeNode newNode = f;  			if ((inverse != null ? inverse.Text : default(string)) == "!")  				newNode.ToggleInversed ();  			filterNode = newNode;  		}  		break;  	case 3:  		DebugEnterAlt (3);  		// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  		{  			DebugLocation (105' 4);  			DebugLocation (105' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr216);  			Match (input' TokenTypes.Down' null);  			DebugLocation (105' 12);  			PushFollow (Follow._propertyChain_in_filterExpr219);  			propertyChain (propertySegments);  			PopFollow ();  			DebugLocation (105' 51);  			// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  			int alt7 = 2;  			try {  				DebugEnterSubRule (7);  				try {  					DebugEnterDecision (7' false);  					int LA7_1 = input.LA (1);  					if ((LA7_1 == 31)) {  						alt7 = 1;  					}  				}  				finally {  					DebugExitDecision (7);  				}  				switch (alt7) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  					{  						DebugLocation (105' 51);  						inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (7);  			}  			DebugLocation (105' 60);  			// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  			int alt8 = 2;  			try {  				DebugEnterSubRule (8);  				try {  					DebugEnterDecision (8' false);  					int LA8_1 = input.LA (1);  					if ((LA8_1 == 24)) {  						alt8 = 1;  					}  				}  				finally {  					DebugExitDecision (8);  				}  				switch (alt8) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  					{  						DebugLocation (105' 60);  						not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (8);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (106' 4);  			FilterTreeNode newProperty = new Property (propertySegments);  			if ((inverse != null ? inverse.Text : default(string)) == "?")  				filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  			else {  				if ((not != null ? not.Text : default(string)) == "!")  					newProperty.ToggleInversed ();  				filterNode = newProperty;  			}  		}  		break;  	case 4:  		DebugEnterAlt (4);  		// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  		{  			DebugLocation (116' 4);  			STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  			DebugLocation (117' 4);  			string stringText = (STRING7 != null ? STRING7.Text : default(string));  			stringText = stringText.Substring (1' stringText.Length - 2);  			filterNode = new Value (stringText);  		}  		break;  	case 5:  		DebugEnterAlt (5);  		// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  		{  			DebugLocation (122' 4);  			REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  			DebugLocation (123' 4);  			string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  			regexText = regexText.Substring (1' regexText.Length - 2);  			filterNode = new RegExp (regexText);  		}  		break;  	case 6:  		DebugEnterAlt (6);  		// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  		{  			DebugLocation (128' 4);  			NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  			DebugLocation (129' 4);  			filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  		}  		break;  	case 7:  		DebugEnterAlt (7);  		// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  		{  			DebugLocation (132' 4);  			Match (input' TRUE' Follow._TRUE_in_filterExpr271);  			DebugLocation (133' 4);  			filterNode = new Value (true);  		}  		break;  	case 8:  		DebugEnterAlt (8);  		// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  		{  			DebugLocation (136' 4);  			Match (input' FALSE' Follow._FALSE_in_filterExpr281);  			DebugLocation (137' 4);  			filterNode = new Value (false);  		}  		break;  	case 9:  		DebugEnterAlt (9);  		// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  		{  			DebugLocation (140' 4);  			Match (input' NULL' Follow._NULL_in_filterExpr291);  			DebugLocation (141' 4);  			filterNode = new Value (null);  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("filterExpr"' 6);  	LeaveRule ("filterExpr"' 6);  	LeaveRule_filterExpr ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  	int alt9 = 9;  	try {  		DebugEnterDecision (9' false);  		switch (input.LA (1)) {  		case CHAIN_OPERATOR:  		case COMPARATOR:  			{  				alt9 = 1;  			}  			break;  		case EXPR:  			{  				int LA9_2 = input.LA (2);  				if ((LA9_2 == DOWN)) {  					int LA9_3 = input.LA (3);  					if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  						alt9 = 2;  					}  					else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  						alt9 = 3;  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				else {  					NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  					DebugRecognitionException (nvae);  					throw nvae;  				}  			}  			break;  		case STRING:  			{  				alt9 = 4;  			}  			break;  		case REGEX:  			{  				alt9 = 5;  			}  			break;  		case NUMBER:  			{  				alt9 = 6;  			}  			break;  		case TRUE:  			{  				alt9 = 7;  			}  			break;  		case FALSE:  			{  				alt9 = 8;  			}  			break;  		case NULL:  			{  				alt9 = 9;  			}  			break;  		default: {  			NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  		}  	}  	finally {  		DebugExitDecision (9);  	}  	switch (alt9) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  		{  			DebugLocation (64' 4);  			DebugLocation (64' 6);  			PushFollow (Follow._comparator_in_filterExpr175);  			comparator6 = comparator ();  			PopFollow ();  			Match (input' TokenTypes.Down' null);  			DebugLocation (64' 18);  			PushFollow (Follow._filterExpr_in_filterExpr179);  			a = filterExpr ();  			PopFollow ();  			DebugLocation (64' 31);  			PushFollow (Follow._filterExpr_in_filterExpr183);  			b = filterExpr ();  			PopFollow ();  			Match (input' TokenTypes.Up' null);  			DebugLocation (65' 4);  			Comparator newComparator;  			switch (comparator6) {  			case "=":  				newComparator = Comparator.Equals;  				break;  			case "!=":  				newComparator = Comparator.NotEquals;  				break;  			case ">":  				newComparator = Comparator.Greater;  				break;  			case "<":  				newComparator = Comparator.Less;  				break;  			case ">=":  				newComparator = Comparator.GreaterOrEqual;  				break;  			case "<=":  				newComparator = Comparator.LessOrEqual;  				break;  			case "&":  				newComparator = Comparator.And;  				break;  			case "|":  				newComparator = Comparator.Or;  				break;  			default:  				newComparator = Comparator.Equals;  				break;  			}  			filterNode = new BoolExpression (a' newComparator' b);  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  		{  			DebugLocation (98' 4);  			DebugLocation (98' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr195);  			Match (input' TokenTypes.Down' null);  			DebugLocation (98' 12);  			PushFollow (Follow._filterExpr_in_filterExpr199);  			f = filterExpr ();  			PopFollow ();  			DebugLocation (98' 31);  			// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  			int alt6 = 2;  			try {  				DebugEnterSubRule (6);  				try {  					DebugEnterDecision (6' false);  					int LA6_1 = input.LA (1);  					if ((LA6_1 == 24)) {  						alt6 = 1;  					}  				}  				finally {  					DebugExitDecision (6);  				}  				switch (alt6) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  					{  						DebugLocation (98' 31);  						inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (6);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (99' 4);  			FilterTreeNode newNode = f;  			if ((inverse != null ? inverse.Text : default(string)) == "!")  				newNode.ToggleInversed ();  			filterNode = newNode;  		}  		break;  	case 3:  		DebugEnterAlt (3);  		// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  		{  			DebugLocation (105' 4);  			DebugLocation (105' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr216);  			Match (input' TokenTypes.Down' null);  			DebugLocation (105' 12);  			PushFollow (Follow._propertyChain_in_filterExpr219);  			propertyChain (propertySegments);  			PopFollow ();  			DebugLocation (105' 51);  			// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  			int alt7 = 2;  			try {  				DebugEnterSubRule (7);  				try {  					DebugEnterDecision (7' false);  					int LA7_1 = input.LA (1);  					if ((LA7_1 == 31)) {  						alt7 = 1;  					}  				}  				finally {  					DebugExitDecision (7);  				}  				switch (alt7) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  					{  						DebugLocation (105' 51);  						inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (7);  			}  			DebugLocation (105' 60);  			// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  			int alt8 = 2;  			try {  				DebugEnterSubRule (8);  				try {  					DebugEnterDecision (8' false);  					int LA8_1 = input.LA (1);  					if ((LA8_1 == 24)) {  						alt8 = 1;  					}  				}  				finally {  					DebugExitDecision (8);  				}  				switch (alt8) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  					{  						DebugLocation (105' 60);  						not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (8);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (106' 4);  			FilterTreeNode newProperty = new Property (propertySegments);  			if ((inverse != null ? inverse.Text : default(string)) == "?")  				filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  			else {  				if ((not != null ? not.Text : default(string)) == "!")  					newProperty.ToggleInversed ();  				filterNode = newProperty;  			}  		}  		break;  	case 4:  		DebugEnterAlt (4);  		// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  		{  			DebugLocation (116' 4);  			STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  			DebugLocation (117' 4);  			string stringText = (STRING7 != null ? STRING7.Text : default(string));  			stringText = stringText.Substring (1' stringText.Length - 2);  			filterNode = new Value (stringText);  		}  		break;  	case 5:  		DebugEnterAlt (5);  		// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  		{  			DebugLocation (122' 4);  			REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  			DebugLocation (123' 4);  			string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  			regexText = regexText.Substring (1' regexText.Length - 2);  			filterNode = new RegExp (regexText);  		}  		break;  	case 6:  		DebugEnterAlt (6);  		// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  		{  			DebugLocation (128' 4);  			NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  			DebugLocation (129' 4);  			filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  		}  		break;  	case 7:  		DebugEnterAlt (7);  		// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  		{  			DebugLocation (132' 4);  			Match (input' TRUE' Follow._TRUE_in_filterExpr271);  			DebugLocation (133' 4);  			filterNode = new Value (true);  		}  		break;  	case 8:  		DebugEnterAlt (8);  		// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  		{  			DebugLocation (136' 4);  			Match (input' FALSE' Follow._FALSE_in_filterExpr281);  			DebugLocation (137' 4);  			filterNode = new Value (false);  		}  		break;  	case 9:  		DebugEnterAlt (9);  		// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  		{  			DebugLocation (140' 4);  			Match (input' NULL' Follow._NULL_in_filterExpr291);  			DebugLocation (141' 4);  			filterNode = new Value (null);  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("filterExpr"' 6);  	LeaveRule ("filterExpr"' 6);  	LeaveRule_filterExpr ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  	int alt9 = 9;  	try {  		DebugEnterDecision (9' false);  		switch (input.LA (1)) {  		case CHAIN_OPERATOR:  		case COMPARATOR:  			{  				alt9 = 1;  			}  			break;  		case EXPR:  			{  				int LA9_2 = input.LA (2);  				if ((LA9_2 == DOWN)) {  					int LA9_3 = input.LA (3);  					if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  						alt9 = 2;  					}  					else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  						alt9 = 3;  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				else {  					NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  					DebugRecognitionException (nvae);  					throw nvae;  				}  			}  			break;  		case STRING:  			{  				alt9 = 4;  			}  			break;  		case REGEX:  			{  				alt9 = 5;  			}  			break;  		case NUMBER:  			{  				alt9 = 6;  			}  			break;  		case TRUE:  			{  				alt9 = 7;  			}  			break;  		case FALSE:  			{  				alt9 = 8;  			}  			break;  		case NULL:  			{  				alt9 = 9;  			}  			break;  		default: {  			NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  		}  	}  	finally {  		DebugExitDecision (9);  	}  	switch (alt9) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  		{  			DebugLocation (64' 4);  			DebugLocation (64' 6);  			PushFollow (Follow._comparator_in_filterExpr175);  			comparator6 = comparator ();  			PopFollow ();  			Match (input' TokenTypes.Down' null);  			DebugLocation (64' 18);  			PushFollow (Follow._filterExpr_in_filterExpr179);  			a = filterExpr ();  			PopFollow ();  			DebugLocation (64' 31);  			PushFollow (Follow._filterExpr_in_filterExpr183);  			b = filterExpr ();  			PopFollow ();  			Match (input' TokenTypes.Up' null);  			DebugLocation (65' 4);  			Comparator newComparator;  			switch (comparator6) {  			case "=":  				newComparator = Comparator.Equals;  				break;  			case "!=":  				newComparator = Comparator.NotEquals;  				break;  			case ">":  				newComparator = Comparator.Greater;  				break;  			case "<":  				newComparator = Comparator.Less;  				break;  			case ">=":  				newComparator = Comparator.GreaterOrEqual;  				break;  			case "<=":  				newComparator = Comparator.LessOrEqual;  				break;  			case "&":  				newComparator = Comparator.And;  				break;  			case "|":  				newComparator = Comparator.Or;  				break;  			default:  				newComparator = Comparator.Equals;  				break;  			}  			filterNode = new BoolExpression (a' newComparator' b);  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  		{  			DebugLocation (98' 4);  			DebugLocation (98' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr195);  			Match (input' TokenTypes.Down' null);  			DebugLocation (98' 12);  			PushFollow (Follow._filterExpr_in_filterExpr199);  			f = filterExpr ();  			PopFollow ();  			DebugLocation (98' 31);  			// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  			int alt6 = 2;  			try {  				DebugEnterSubRule (6);  				try {  					DebugEnterDecision (6' false);  					int LA6_1 = input.LA (1);  					if ((LA6_1 == 24)) {  						alt6 = 1;  					}  				}  				finally {  					DebugExitDecision (6);  				}  				switch (alt6) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  					{  						DebugLocation (98' 31);  						inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (6);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (99' 4);  			FilterTreeNode newNode = f;  			if ((inverse != null ? inverse.Text : default(string)) == "!")  				newNode.ToggleInversed ();  			filterNode = newNode;  		}  		break;  	case 3:  		DebugEnterAlt (3);  		// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  		{  			DebugLocation (105' 4);  			DebugLocation (105' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr216);  			Match (input' TokenTypes.Down' null);  			DebugLocation (105' 12);  			PushFollow (Follow._propertyChain_in_filterExpr219);  			propertyChain (propertySegments);  			PopFollow ();  			DebugLocation (105' 51);  			// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  			int alt7 = 2;  			try {  				DebugEnterSubRule (7);  				try {  					DebugEnterDecision (7' false);  					int LA7_1 = input.LA (1);  					if ((LA7_1 == 31)) {  						alt7 = 1;  					}  				}  				finally {  					DebugExitDecision (7);  				}  				switch (alt7) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  					{  						DebugLocation (105' 51);  						inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (7);  			}  			DebugLocation (105' 60);  			// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  			int alt8 = 2;  			try {  				DebugEnterSubRule (8);  				try {  					DebugEnterDecision (8' false);  					int LA8_1 = input.LA (1);  					if ((LA8_1 == 24)) {  						alt8 = 1;  					}  				}  				finally {  					DebugExitDecision (8);  				}  				switch (alt8) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  					{  						DebugLocation (105' 60);  						not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (8);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (106' 4);  			FilterTreeNode newProperty = new Property (propertySegments);  			if ((inverse != null ? inverse.Text : default(string)) == "?")  				filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  			else {  				if ((not != null ? not.Text : default(string)) == "!")  					newProperty.ToggleInversed ();  				filterNode = newProperty;  			}  		}  		break;  	case 4:  		DebugEnterAlt (4);  		// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  		{  			DebugLocation (116' 4);  			STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  			DebugLocation (117' 4);  			string stringText = (STRING7 != null ? STRING7.Text : default(string));  			stringText = stringText.Substring (1' stringText.Length - 2);  			filterNode = new Value (stringText);  		}  		break;  	case 5:  		DebugEnterAlt (5);  		// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  		{  			DebugLocation (122' 4);  			REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  			DebugLocation (123' 4);  			string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  			regexText = regexText.Substring (1' regexText.Length - 2);  			filterNode = new RegExp (regexText);  		}  		break;  	case 6:  		DebugEnterAlt (6);  		// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  		{  			DebugLocation (128' 4);  			NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  			DebugLocation (129' 4);  			filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  		}  		break;  	case 7:  		DebugEnterAlt (7);  		// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  		{  			DebugLocation (132' 4);  			Match (input' TRUE' Follow._TRUE_in_filterExpr271);  			DebugLocation (133' 4);  			filterNode = new Value (true);  		}  		break;  	case 8:  		DebugEnterAlt (8);  		// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  		{  			DebugLocation (136' 4);  			Match (input' FALSE' Follow._FALSE_in_filterExpr281);  			DebugLocation (137' 4);  			filterNode = new Value (false);  		}  		break;  	case 9:  		DebugEnterAlt (9);  		// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  		{  			DebugLocation (140' 4);  			Match (input' NULL' Follow._NULL_in_filterExpr291);  			DebugLocation (141' 4);  			filterNode = new Value (null);  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("filterExpr"' 6);  	LeaveRule ("filterExpr"' 6);  	LeaveRule_filterExpr ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  	int alt9 = 9;  	try {  		DebugEnterDecision (9' false);  		switch (input.LA (1)) {  		case CHAIN_OPERATOR:  		case COMPARATOR:  			{  				alt9 = 1;  			}  			break;  		case EXPR:  			{  				int LA9_2 = input.LA (2);  				if ((LA9_2 == DOWN)) {  					int LA9_3 = input.LA (3);  					if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  						alt9 = 2;  					}  					else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  						alt9 = 3;  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				else {  					NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  					DebugRecognitionException (nvae);  					throw nvae;  				}  			}  			break;  		case STRING:  			{  				alt9 = 4;  			}  			break;  		case REGEX:  			{  				alt9 = 5;  			}  			break;  		case NUMBER:  			{  				alt9 = 6;  			}  			break;  		case TRUE:  			{  				alt9 = 7;  			}  			break;  		case FALSE:  			{  				alt9 = 8;  			}  			break;  		case NULL:  			{  				alt9 = 9;  			}  			break;  		default: {  			NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  		}  	}  	finally {  		DebugExitDecision (9);  	}  	switch (alt9) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  		{  			DebugLocation (64' 4);  			DebugLocation (64' 6);  			PushFollow (Follow._comparator_in_filterExpr175);  			comparator6 = comparator ();  			PopFollow ();  			Match (input' TokenTypes.Down' null);  			DebugLocation (64' 18);  			PushFollow (Follow._filterExpr_in_filterExpr179);  			a = filterExpr ();  			PopFollow ();  			DebugLocation (64' 31);  			PushFollow (Follow._filterExpr_in_filterExpr183);  			b = filterExpr ();  			PopFollow ();  			Match (input' TokenTypes.Up' null);  			DebugLocation (65' 4);  			Comparator newComparator;  			switch (comparator6) {  			case "=":  				newComparator = Comparator.Equals;  				break;  			case "!=":  				newComparator = Comparator.NotEquals;  				break;  			case ">":  				newComparator = Comparator.Greater;  				break;  			case "<":  				newComparator = Comparator.Less;  				break;  			case ">=":  				newComparator = Comparator.GreaterOrEqual;  				break;  			case "<=":  				newComparator = Comparator.LessOrEqual;  				break;  			case "&":  				newComparator = Comparator.And;  				break;  			case "|":  				newComparator = Comparator.Or;  				break;  			default:  				newComparator = Comparator.Equals;  				break;  			}  			filterNode = new BoolExpression (a' newComparator' b);  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  		{  			DebugLocation (98' 4);  			DebugLocation (98' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr195);  			Match (input' TokenTypes.Down' null);  			DebugLocation (98' 12);  			PushFollow (Follow._filterExpr_in_filterExpr199);  			f = filterExpr ();  			PopFollow ();  			DebugLocation (98' 31);  			// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  			int alt6 = 2;  			try {  				DebugEnterSubRule (6);  				try {  					DebugEnterDecision (6' false);  					int LA6_1 = input.LA (1);  					if ((LA6_1 == 24)) {  						alt6 = 1;  					}  				}  				finally {  					DebugExitDecision (6);  				}  				switch (alt6) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  					{  						DebugLocation (98' 31);  						inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (6);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (99' 4);  			FilterTreeNode newNode = f;  			if ((inverse != null ? inverse.Text : default(string)) == "!")  				newNode.ToggleInversed ();  			filterNode = newNode;  		}  		break;  	case 3:  		DebugEnterAlt (3);  		// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  		{  			DebugLocation (105' 4);  			DebugLocation (105' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr216);  			Match (input' TokenTypes.Down' null);  			DebugLocation (105' 12);  			PushFollow (Follow._propertyChain_in_filterExpr219);  			propertyChain (propertySegments);  			PopFollow ();  			DebugLocation (105' 51);  			// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  			int alt7 = 2;  			try {  				DebugEnterSubRule (7);  				try {  					DebugEnterDecision (7' false);  					int LA7_1 = input.LA (1);  					if ((LA7_1 == 31)) {  						alt7 = 1;  					}  				}  				finally {  					DebugExitDecision (7);  				}  				switch (alt7) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  					{  						DebugLocation (105' 51);  						inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (7);  			}  			DebugLocation (105' 60);  			// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  			int alt8 = 2;  			try {  				DebugEnterSubRule (8);  				try {  					DebugEnterDecision (8' false);  					int LA8_1 = input.LA (1);  					if ((LA8_1 == 24)) {  						alt8 = 1;  					}  				}  				finally {  					DebugExitDecision (8);  				}  				switch (alt8) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  					{  						DebugLocation (105' 60);  						not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (8);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (106' 4);  			FilterTreeNode newProperty = new Property (propertySegments);  			if ((inverse != null ? inverse.Text : default(string)) == "?")  				filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  			else {  				if ((not != null ? not.Text : default(string)) == "!")  					newProperty.ToggleInversed ();  				filterNode = newProperty;  			}  		}  		break;  	case 4:  		DebugEnterAlt (4);  		// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  		{  			DebugLocation (116' 4);  			STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  			DebugLocation (117' 4);  			string stringText = (STRING7 != null ? STRING7.Text : default(string));  			stringText = stringText.Substring (1' stringText.Length - 2);  			filterNode = new Value (stringText);  		}  		break;  	case 5:  		DebugEnterAlt (5);  		// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  		{  			DebugLocation (122' 4);  			REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  			DebugLocation (123' 4);  			string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  			regexText = regexText.Substring (1' regexText.Length - 2);  			filterNode = new RegExp (regexText);  		}  		break;  	case 6:  		DebugEnterAlt (6);  		// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  		{  			DebugLocation (128' 4);  			NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  			DebugLocation (129' 4);  			filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  		}  		break;  	case 7:  		DebugEnterAlt (7);  		// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  		{  			DebugLocation (132' 4);  			Match (input' TRUE' Follow._TRUE_in_filterExpr271);  			DebugLocation (133' 4);  			filterNode = new Value (true);  		}  		break;  	case 8:  		DebugEnterAlt (8);  		// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  		{  			DebugLocation (136' 4);  			Match (input' FALSE' Follow._FALSE_in_filterExpr281);  			DebugLocation (137' 4);  			filterNode = new Value (false);  		}  		break;  	case 9:  		DebugEnterAlt (9);  		// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  		{  			DebugLocation (140' 4);  			Match (input' NULL' Follow._NULL_in_filterExpr291);  			DebugLocation (141' 4);  			filterNode = new Value (null);  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("filterExpr"' 6);  	LeaveRule ("filterExpr"' 6);  	LeaveRule_filterExpr ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  	int alt9 = 9;  	try {  		DebugEnterDecision (9' false);  		switch (input.LA (1)) {  		case CHAIN_OPERATOR:  		case COMPARATOR:  			{  				alt9 = 1;  			}  			break;  		case EXPR:  			{  				int LA9_2 = input.LA (2);  				if ((LA9_2 == DOWN)) {  					int LA9_3 = input.LA (3);  					if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  						alt9 = 2;  					}  					else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  						alt9 = 3;  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				else {  					NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  					DebugRecognitionException (nvae);  					throw nvae;  				}  			}  			break;  		case STRING:  			{  				alt9 = 4;  			}  			break;  		case REGEX:  			{  				alt9 = 5;  			}  			break;  		case NUMBER:  			{  				alt9 = 6;  			}  			break;  		case TRUE:  			{  				alt9 = 7;  			}  			break;  		case FALSE:  			{  				alt9 = 8;  			}  			break;  		case NULL:  			{  				alt9 = 9;  			}  			break;  		default: {  			NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  		}  	}  	finally {  		DebugExitDecision (9);  	}  	switch (alt9) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  		{  			DebugLocation (64' 4);  			DebugLocation (64' 6);  			PushFollow (Follow._comparator_in_filterExpr175);  			comparator6 = comparator ();  			PopFollow ();  			Match (input' TokenTypes.Down' null);  			DebugLocation (64' 18);  			PushFollow (Follow._filterExpr_in_filterExpr179);  			a = filterExpr ();  			PopFollow ();  			DebugLocation (64' 31);  			PushFollow (Follow._filterExpr_in_filterExpr183);  			b = filterExpr ();  			PopFollow ();  			Match (input' TokenTypes.Up' null);  			DebugLocation (65' 4);  			Comparator newComparator;  			switch (comparator6) {  			case "=":  				newComparator = Comparator.Equals;  				break;  			case "!=":  				newComparator = Comparator.NotEquals;  				break;  			case ">":  				newComparator = Comparator.Greater;  				break;  			case "<":  				newComparator = Comparator.Less;  				break;  			case ">=":  				newComparator = Comparator.GreaterOrEqual;  				break;  			case "<=":  				newComparator = Comparator.LessOrEqual;  				break;  			case "&":  				newComparator = Comparator.And;  				break;  			case "|":  				newComparator = Comparator.Or;  				break;  			default:  				newComparator = Comparator.Equals;  				break;  			}  			filterNode = new BoolExpression (a' newComparator' b);  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  		{  			DebugLocation (98' 4);  			DebugLocation (98' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr195);  			Match (input' TokenTypes.Down' null);  			DebugLocation (98' 12);  			PushFollow (Follow._filterExpr_in_filterExpr199);  			f = filterExpr ();  			PopFollow ();  			DebugLocation (98' 31);  			// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  			int alt6 = 2;  			try {  				DebugEnterSubRule (6);  				try {  					DebugEnterDecision (6' false);  					int LA6_1 = input.LA (1);  					if ((LA6_1 == 24)) {  						alt6 = 1;  					}  				}  				finally {  					DebugExitDecision (6);  				}  				switch (alt6) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  					{  						DebugLocation (98' 31);  						inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (6);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (99' 4);  			FilterTreeNode newNode = f;  			if ((inverse != null ? inverse.Text : default(string)) == "!")  				newNode.ToggleInversed ();  			filterNode = newNode;  		}  		break;  	case 3:  		DebugEnterAlt (3);  		// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  		{  			DebugLocation (105' 4);  			DebugLocation (105' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr216);  			Match (input' TokenTypes.Down' null);  			DebugLocation (105' 12);  			PushFollow (Follow._propertyChain_in_filterExpr219);  			propertyChain (propertySegments);  			PopFollow ();  			DebugLocation (105' 51);  			// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  			int alt7 = 2;  			try {  				DebugEnterSubRule (7);  				try {  					DebugEnterDecision (7' false);  					int LA7_1 = input.LA (1);  					if ((LA7_1 == 31)) {  						alt7 = 1;  					}  				}  				finally {  					DebugExitDecision (7);  				}  				switch (alt7) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  					{  						DebugLocation (105' 51);  						inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (7);  			}  			DebugLocation (105' 60);  			// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  			int alt8 = 2;  			try {  				DebugEnterSubRule (8);  				try {  					DebugEnterDecision (8' false);  					int LA8_1 = input.LA (1);  					if ((LA8_1 == 24)) {  						alt8 = 1;  					}  				}  				finally {  					DebugExitDecision (8);  				}  				switch (alt8) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  					{  						DebugLocation (105' 60);  						not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (8);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (106' 4);  			FilterTreeNode newProperty = new Property (propertySegments);  			if ((inverse != null ? inverse.Text : default(string)) == "?")  				filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  			else {  				if ((not != null ? not.Text : default(string)) == "!")  					newProperty.ToggleInversed ();  				filterNode = newProperty;  			}  		}  		break;  	case 4:  		DebugEnterAlt (4);  		// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  		{  			DebugLocation (116' 4);  			STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  			DebugLocation (117' 4);  			string stringText = (STRING7 != null ? STRING7.Text : default(string));  			stringText = stringText.Substring (1' stringText.Length - 2);  			filterNode = new Value (stringText);  		}  		break;  	case 5:  		DebugEnterAlt (5);  		// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  		{  			DebugLocation (122' 4);  			REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  			DebugLocation (123' 4);  			string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  			regexText = regexText.Substring (1' regexText.Length - 2);  			filterNode = new RegExp (regexText);  		}  		break;  	case 6:  		DebugEnterAlt (6);  		// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  		{  			DebugLocation (128' 4);  			NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  			DebugLocation (129' 4);  			filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  		}  		break;  	case 7:  		DebugEnterAlt (7);  		// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  		{  			DebugLocation (132' 4);  			Match (input' TRUE' Follow._TRUE_in_filterExpr271);  			DebugLocation (133' 4);  			filterNode = new Value (true);  		}  		break;  	case 8:  		DebugEnterAlt (8);  		// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  		{  			DebugLocation (136' 4);  			Match (input' FALSE' Follow._FALSE_in_filterExpr281);  			DebugLocation (137' 4);  			filterNode = new Value (false);  		}  		break;  	case 9:  		DebugEnterAlt (9);  		// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  		{  			DebugLocation (140' 4);  			Match (input' NULL' Follow._NULL_in_filterExpr291);  			DebugLocation (141' 4);  			filterNode = new Value (null);  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("filterExpr"' 6);  	LeaveRule ("filterExpr"' 6);  	LeaveRule_filterExpr ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  	int alt9 = 9;  	try {  		DebugEnterDecision (9' false);  		switch (input.LA (1)) {  		case CHAIN_OPERATOR:  		case COMPARATOR:  			{  				alt9 = 1;  			}  			break;  		case EXPR:  			{  				int LA9_2 = input.LA (2);  				if ((LA9_2 == DOWN)) {  					int LA9_3 = input.LA (3);  					if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  						alt9 = 2;  					}  					else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  						alt9 = 3;  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				else {  					NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  					DebugRecognitionException (nvae);  					throw nvae;  				}  			}  			break;  		case STRING:  			{  				alt9 = 4;  			}  			break;  		case REGEX:  			{  				alt9 = 5;  			}  			break;  		case NUMBER:  			{  				alt9 = 6;  			}  			break;  		case TRUE:  			{  				alt9 = 7;  			}  			break;  		case FALSE:  			{  				alt9 = 8;  			}  			break;  		case NULL:  			{  				alt9 = 9;  			}  			break;  		default: {  			NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  		}  	}  	finally {  		DebugExitDecision (9);  	}  	switch (alt9) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  		{  			DebugLocation (64' 4);  			DebugLocation (64' 6);  			PushFollow (Follow._comparator_in_filterExpr175);  			comparator6 = comparator ();  			PopFollow ();  			Match (input' TokenTypes.Down' null);  			DebugLocation (64' 18);  			PushFollow (Follow._filterExpr_in_filterExpr179);  			a = filterExpr ();  			PopFollow ();  			DebugLocation (64' 31);  			PushFollow (Follow._filterExpr_in_filterExpr183);  			b = filterExpr ();  			PopFollow ();  			Match (input' TokenTypes.Up' null);  			DebugLocation (65' 4);  			Comparator newComparator;  			switch (comparator6) {  			case "=":  				newComparator = Comparator.Equals;  				break;  			case "!=":  				newComparator = Comparator.NotEquals;  				break;  			case ">":  				newComparator = Comparator.Greater;  				break;  			case "<":  				newComparator = Comparator.Less;  				break;  			case ">=":  				newComparator = Comparator.GreaterOrEqual;  				break;  			case "<=":  				newComparator = Comparator.LessOrEqual;  				break;  			case "&":  				newComparator = Comparator.And;  				break;  			case "|":  				newComparator = Comparator.Or;  				break;  			default:  				newComparator = Comparator.Equals;  				break;  			}  			filterNode = new BoolExpression (a' newComparator' b);  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  		{  			DebugLocation (98' 4);  			DebugLocation (98' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr195);  			Match (input' TokenTypes.Down' null);  			DebugLocation (98' 12);  			PushFollow (Follow._filterExpr_in_filterExpr199);  			f = filterExpr ();  			PopFollow ();  			DebugLocation (98' 31);  			// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  			int alt6 = 2;  			try {  				DebugEnterSubRule (6);  				try {  					DebugEnterDecision (6' false);  					int LA6_1 = input.LA (1);  					if ((LA6_1 == 24)) {  						alt6 = 1;  					}  				}  				finally {  					DebugExitDecision (6);  				}  				switch (alt6) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  					{  						DebugLocation (98' 31);  						inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (6);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (99' 4);  			FilterTreeNode newNode = f;  			if ((inverse != null ? inverse.Text : default(string)) == "!")  				newNode.ToggleInversed ();  			filterNode = newNode;  		}  		break;  	case 3:  		DebugEnterAlt (3);  		// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  		{  			DebugLocation (105' 4);  			DebugLocation (105' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr216);  			Match (input' TokenTypes.Down' null);  			DebugLocation (105' 12);  			PushFollow (Follow._propertyChain_in_filterExpr219);  			propertyChain (propertySegments);  			PopFollow ();  			DebugLocation (105' 51);  			// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  			int alt7 = 2;  			try {  				DebugEnterSubRule (7);  				try {  					DebugEnterDecision (7' false);  					int LA7_1 = input.LA (1);  					if ((LA7_1 == 31)) {  						alt7 = 1;  					}  				}  				finally {  					DebugExitDecision (7);  				}  				switch (alt7) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  					{  						DebugLocation (105' 51);  						inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (7);  			}  			DebugLocation (105' 60);  			// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  			int alt8 = 2;  			try {  				DebugEnterSubRule (8);  				try {  					DebugEnterDecision (8' false);  					int LA8_1 = input.LA (1);  					if ((LA8_1 == 24)) {  						alt8 = 1;  					}  				}  				finally {  					DebugExitDecision (8);  				}  				switch (alt8) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  					{  						DebugLocation (105' 60);  						not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (8);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (106' 4);  			FilterTreeNode newProperty = new Property (propertySegments);  			if ((inverse != null ? inverse.Text : default(string)) == "?")  				filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  			else {  				if ((not != null ? not.Text : default(string)) == "!")  					newProperty.ToggleInversed ();  				filterNode = newProperty;  			}  		}  		break;  	case 4:  		DebugEnterAlt (4);  		// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  		{  			DebugLocation (116' 4);  			STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  			DebugLocation (117' 4);  			string stringText = (STRING7 != null ? STRING7.Text : default(string));  			stringText = stringText.Substring (1' stringText.Length - 2);  			filterNode = new Value (stringText);  		}  		break;  	case 5:  		DebugEnterAlt (5);  		// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  		{  			DebugLocation (122' 4);  			REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  			DebugLocation (123' 4);  			string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  			regexText = regexText.Substring (1' regexText.Length - 2);  			filterNode = new RegExp (regexText);  		}  		break;  	case 6:  		DebugEnterAlt (6);  		// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  		{  			DebugLocation (128' 4);  			NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  			DebugLocation (129' 4);  			filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  		}  		break;  	case 7:  		DebugEnterAlt (7);  		// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  		{  			DebugLocation (132' 4);  			Match (input' TRUE' Follow._TRUE_in_filterExpr271);  			DebugLocation (133' 4);  			filterNode = new Value (true);  		}  		break;  	case 8:  		DebugEnterAlt (8);  		// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  		{  			DebugLocation (136' 4);  			Match (input' FALSE' Follow._FALSE_in_filterExpr281);  			DebugLocation (137' 4);  			filterNode = new Value (false);  		}  		break;  	case 9:  		DebugEnterAlt (9);  		// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  		{  			DebugLocation (140' 4);  			Match (input' NULL' Follow._NULL_in_filterExpr291);  			DebugLocation (141' 4);  			filterNode = new Value (null);  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("filterExpr"' 6);  	LeaveRule ("filterExpr"' 6);  	LeaveRule_filterExpr ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  	int alt9 = 9;  	try {  		DebugEnterDecision (9' false);  		switch (input.LA (1)) {  		case CHAIN_OPERATOR:  		case COMPARATOR:  			{  				alt9 = 1;  			}  			break;  		case EXPR:  			{  				int LA9_2 = input.LA (2);  				if ((LA9_2 == DOWN)) {  					int LA9_3 = input.LA (3);  					if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  						alt9 = 2;  					}  					else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  						alt9 = 3;  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				else {  					NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  					DebugRecognitionException (nvae);  					throw nvae;  				}  			}  			break;  		case STRING:  			{  				alt9 = 4;  			}  			break;  		case REGEX:  			{  				alt9 = 5;  			}  			break;  		case NUMBER:  			{  				alt9 = 6;  			}  			break;  		case TRUE:  			{  				alt9 = 7;  			}  			break;  		case FALSE:  			{  				alt9 = 8;  			}  			break;  		case NULL:  			{  				alt9 = 9;  			}  			break;  		default: {  			NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  		}  	}  	finally {  		DebugExitDecision (9);  	}  	switch (alt9) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  		{  			DebugLocation (64' 4);  			DebugLocation (64' 6);  			PushFollow (Follow._comparator_in_filterExpr175);  			comparator6 = comparator ();  			PopFollow ();  			Match (input' TokenTypes.Down' null);  			DebugLocation (64' 18);  			PushFollow (Follow._filterExpr_in_filterExpr179);  			a = filterExpr ();  			PopFollow ();  			DebugLocation (64' 31);  			PushFollow (Follow._filterExpr_in_filterExpr183);  			b = filterExpr ();  			PopFollow ();  			Match (input' TokenTypes.Up' null);  			DebugLocation (65' 4);  			Comparator newComparator;  			switch (comparator6) {  			case "=":  				newComparator = Comparator.Equals;  				break;  			case "!=":  				newComparator = Comparator.NotEquals;  				break;  			case ">":  				newComparator = Comparator.Greater;  				break;  			case "<":  				newComparator = Comparator.Less;  				break;  			case ">=":  				newComparator = Comparator.GreaterOrEqual;  				break;  			case "<=":  				newComparator = Comparator.LessOrEqual;  				break;  			case "&":  				newComparator = Comparator.And;  				break;  			case "|":  				newComparator = Comparator.Or;  				break;  			default:  				newComparator = Comparator.Equals;  				break;  			}  			filterNode = new BoolExpression (a' newComparator' b);  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  		{  			DebugLocation (98' 4);  			DebugLocation (98' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr195);  			Match (input' TokenTypes.Down' null);  			DebugLocation (98' 12);  			PushFollow (Follow._filterExpr_in_filterExpr199);  			f = filterExpr ();  			PopFollow ();  			DebugLocation (98' 31);  			// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  			int alt6 = 2;  			try {  				DebugEnterSubRule (6);  				try {  					DebugEnterDecision (6' false);  					int LA6_1 = input.LA (1);  					if ((LA6_1 == 24)) {  						alt6 = 1;  					}  				}  				finally {  					DebugExitDecision (6);  				}  				switch (alt6) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  					{  						DebugLocation (98' 31);  						inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (6);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (99' 4);  			FilterTreeNode newNode = f;  			if ((inverse != null ? inverse.Text : default(string)) == "!")  				newNode.ToggleInversed ();  			filterNode = newNode;  		}  		break;  	case 3:  		DebugEnterAlt (3);  		// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  		{  			DebugLocation (105' 4);  			DebugLocation (105' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr216);  			Match (input' TokenTypes.Down' null);  			DebugLocation (105' 12);  			PushFollow (Follow._propertyChain_in_filterExpr219);  			propertyChain (propertySegments);  			PopFollow ();  			DebugLocation (105' 51);  			// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  			int alt7 = 2;  			try {  				DebugEnterSubRule (7);  				try {  					DebugEnterDecision (7' false);  					int LA7_1 = input.LA (1);  					if ((LA7_1 == 31)) {  						alt7 = 1;  					}  				}  				finally {  					DebugExitDecision (7);  				}  				switch (alt7) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  					{  						DebugLocation (105' 51);  						inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (7);  			}  			DebugLocation (105' 60);  			// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  			int alt8 = 2;  			try {  				DebugEnterSubRule (8);  				try {  					DebugEnterDecision (8' false);  					int LA8_1 = input.LA (1);  					if ((LA8_1 == 24)) {  						alt8 = 1;  					}  				}  				finally {  					DebugExitDecision (8);  				}  				switch (alt8) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  					{  						DebugLocation (105' 60);  						not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (8);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (106' 4);  			FilterTreeNode newProperty = new Property (propertySegments);  			if ((inverse != null ? inverse.Text : default(string)) == "?")  				filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  			else {  				if ((not != null ? not.Text : default(string)) == "!")  					newProperty.ToggleInversed ();  				filterNode = newProperty;  			}  		}  		break;  	case 4:  		DebugEnterAlt (4);  		// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  		{  			DebugLocation (116' 4);  			STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  			DebugLocation (117' 4);  			string stringText = (STRING7 != null ? STRING7.Text : default(string));  			stringText = stringText.Substring (1' stringText.Length - 2);  			filterNode = new Value (stringText);  		}  		break;  	case 5:  		DebugEnterAlt (5);  		// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  		{  			DebugLocation (122' 4);  			REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  			DebugLocation (123' 4);  			string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  			regexText = regexText.Substring (1' regexText.Length - 2);  			filterNode = new RegExp (regexText);  		}  		break;  	case 6:  		DebugEnterAlt (6);  		// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  		{  			DebugLocation (128' 4);  			NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  			DebugLocation (129' 4);  			filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  		}  		break;  	case 7:  		DebugEnterAlt (7);  		// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  		{  			DebugLocation (132' 4);  			Match (input' TRUE' Follow._TRUE_in_filterExpr271);  			DebugLocation (133' 4);  			filterNode = new Value (true);  		}  		break;  	case 8:  		DebugEnterAlt (8);  		// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  		{  			DebugLocation (136' 4);  			Match (input' FALSE' Follow._FALSE_in_filterExpr281);  			DebugLocation (137' 4);  			filterNode = new Value (false);  		}  		break;  	case 9:  		DebugEnterAlt (9);  		// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  		{  			DebugLocation (140' 4);  			Match (input' NULL' Follow._NULL_in_filterExpr291);  			DebugLocation (141' 4);  			filterNode = new Value (null);  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("filterExpr"' 6);  	LeaveRule ("filterExpr"' 6);  	LeaveRule_filterExpr ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  	int alt9 = 9;  	try {  		DebugEnterDecision (9' false);  		switch (input.LA (1)) {  		case CHAIN_OPERATOR:  		case COMPARATOR:  			{  				alt9 = 1;  			}  			break;  		case EXPR:  			{  				int LA9_2 = input.LA (2);  				if ((LA9_2 == DOWN)) {  					int LA9_3 = input.LA (3);  					if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  						alt9 = 2;  					}  					else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  						alt9 = 3;  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				else {  					NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  					DebugRecognitionException (nvae);  					throw nvae;  				}  			}  			break;  		case STRING:  			{  				alt9 = 4;  			}  			break;  		case REGEX:  			{  				alt9 = 5;  			}  			break;  		case NUMBER:  			{  				alt9 = 6;  			}  			break;  		case TRUE:  			{  				alt9 = 7;  			}  			break;  		case FALSE:  			{  				alt9 = 8;  			}  			break;  		case NULL:  			{  				alt9 = 9;  			}  			break;  		default: {  			NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  		}  	}  	finally {  		DebugExitDecision (9);  	}  	switch (alt9) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  		{  			DebugLocation (64' 4);  			DebugLocation (64' 6);  			PushFollow (Follow._comparator_in_filterExpr175);  			comparator6 = comparator ();  			PopFollow ();  			Match (input' TokenTypes.Down' null);  			DebugLocation (64' 18);  			PushFollow (Follow._filterExpr_in_filterExpr179);  			a = filterExpr ();  			PopFollow ();  			DebugLocation (64' 31);  			PushFollow (Follow._filterExpr_in_filterExpr183);  			b = filterExpr ();  			PopFollow ();  			Match (input' TokenTypes.Up' null);  			DebugLocation (65' 4);  			Comparator newComparator;  			switch (comparator6) {  			case "=":  				newComparator = Comparator.Equals;  				break;  			case "!=":  				newComparator = Comparator.NotEquals;  				break;  			case ">":  				newComparator = Comparator.Greater;  				break;  			case "<":  				newComparator = Comparator.Less;  				break;  			case ">=":  				newComparator = Comparator.GreaterOrEqual;  				break;  			case "<=":  				newComparator = Comparator.LessOrEqual;  				break;  			case "&":  				newComparator = Comparator.And;  				break;  			case "|":  				newComparator = Comparator.Or;  				break;  			default:  				newComparator = Comparator.Equals;  				break;  			}  			filterNode = new BoolExpression (a' newComparator' b);  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  		{  			DebugLocation (98' 4);  			DebugLocation (98' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr195);  			Match (input' TokenTypes.Down' null);  			DebugLocation (98' 12);  			PushFollow (Follow._filterExpr_in_filterExpr199);  			f = filterExpr ();  			PopFollow ();  			DebugLocation (98' 31);  			// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  			int alt6 = 2;  			try {  				DebugEnterSubRule (6);  				try {  					DebugEnterDecision (6' false);  					int LA6_1 = input.LA (1);  					if ((LA6_1 == 24)) {  						alt6 = 1;  					}  				}  				finally {  					DebugExitDecision (6);  				}  				switch (alt6) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  					{  						DebugLocation (98' 31);  						inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (6);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (99' 4);  			FilterTreeNode newNode = f;  			if ((inverse != null ? inverse.Text : default(string)) == "!")  				newNode.ToggleInversed ();  			filterNode = newNode;  		}  		break;  	case 3:  		DebugEnterAlt (3);  		// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  		{  			DebugLocation (105' 4);  			DebugLocation (105' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr216);  			Match (input' TokenTypes.Down' null);  			DebugLocation (105' 12);  			PushFollow (Follow._propertyChain_in_filterExpr219);  			propertyChain (propertySegments);  			PopFollow ();  			DebugLocation (105' 51);  			// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  			int alt7 = 2;  			try {  				DebugEnterSubRule (7);  				try {  					DebugEnterDecision (7' false);  					int LA7_1 = input.LA (1);  					if ((LA7_1 == 31)) {  						alt7 = 1;  					}  				}  				finally {  					DebugExitDecision (7);  				}  				switch (alt7) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  					{  						DebugLocation (105' 51);  						inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (7);  			}  			DebugLocation (105' 60);  			// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  			int alt8 = 2;  			try {  				DebugEnterSubRule (8);  				try {  					DebugEnterDecision (8' false);  					int LA8_1 = input.LA (1);  					if ((LA8_1 == 24)) {  						alt8 = 1;  					}  				}  				finally {  					DebugExitDecision (8);  				}  				switch (alt8) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  					{  						DebugLocation (105' 60);  						not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (8);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (106' 4);  			FilterTreeNode newProperty = new Property (propertySegments);  			if ((inverse != null ? inverse.Text : default(string)) == "?")  				filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  			else {  				if ((not != null ? not.Text : default(string)) == "!")  					newProperty.ToggleInversed ();  				filterNode = newProperty;  			}  		}  		break;  	case 4:  		DebugEnterAlt (4);  		// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  		{  			DebugLocation (116' 4);  			STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  			DebugLocation (117' 4);  			string stringText = (STRING7 != null ? STRING7.Text : default(string));  			stringText = stringText.Substring (1' stringText.Length - 2);  			filterNode = new Value (stringText);  		}  		break;  	case 5:  		DebugEnterAlt (5);  		// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  		{  			DebugLocation (122' 4);  			REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  			DebugLocation (123' 4);  			string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  			regexText = regexText.Substring (1' regexText.Length - 2);  			filterNode = new RegExp (regexText);  		}  		break;  	case 6:  		DebugEnterAlt (6);  		// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  		{  			DebugLocation (128' 4);  			NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  			DebugLocation (129' 4);  			filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  		}  		break;  	case 7:  		DebugEnterAlt (7);  		// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  		{  			DebugLocation (132' 4);  			Match (input' TRUE' Follow._TRUE_in_filterExpr271);  			DebugLocation (133' 4);  			filterNode = new Value (true);  		}  		break;  	case 8:  		DebugEnterAlt (8);  		// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  		{  			DebugLocation (136' 4);  			Match (input' FALSE' Follow._FALSE_in_filterExpr281);  			DebugLocation (137' 4);  			filterNode = new Value (false);  		}  		break;  	case 9:  		DebugEnterAlt (9);  		// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  		{  			DebugLocation (140' 4);  			Match (input' NULL' Follow._NULL_in_filterExpr291);  			DebugLocation (141' 4);  			filterNode = new Value (null);  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("filterExpr"' 6);  	LeaveRule ("filterExpr"' 6);  	LeaveRule_filterExpr ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  	int alt9 = 9;  	try {  		DebugEnterDecision (9' false);  		switch (input.LA (1)) {  		case CHAIN_OPERATOR:  		case COMPARATOR:  			{  				alt9 = 1;  			}  			break;  		case EXPR:  			{  				int LA9_2 = input.LA (2);  				if ((LA9_2 == DOWN)) {  					int LA9_3 = input.LA (3);  					if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  						alt9 = 2;  					}  					else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  						alt9 = 3;  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				else {  					NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  					DebugRecognitionException (nvae);  					throw nvae;  				}  			}  			break;  		case STRING:  			{  				alt9 = 4;  			}  			break;  		case REGEX:  			{  				alt9 = 5;  			}  			break;  		case NUMBER:  			{  				alt9 = 6;  			}  			break;  		case TRUE:  			{  				alt9 = 7;  			}  			break;  		case FALSE:  			{  				alt9 = 8;  			}  			break;  		case NULL:  			{  				alt9 = 9;  			}  			break;  		default: {  			NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  		}  	}  	finally {  		DebugExitDecision (9);  	}  	switch (alt9) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  		{  			DebugLocation (64' 4);  			DebugLocation (64' 6);  			PushFollow (Follow._comparator_in_filterExpr175);  			comparator6 = comparator ();  			PopFollow ();  			Match (input' TokenTypes.Down' null);  			DebugLocation (64' 18);  			PushFollow (Follow._filterExpr_in_filterExpr179);  			a = filterExpr ();  			PopFollow ();  			DebugLocation (64' 31);  			PushFollow (Follow._filterExpr_in_filterExpr183);  			b = filterExpr ();  			PopFollow ();  			Match (input' TokenTypes.Up' null);  			DebugLocation (65' 4);  			Comparator newComparator;  			switch (comparator6) {  			case "=":  				newComparator = Comparator.Equals;  				break;  			case "!=":  				newComparator = Comparator.NotEquals;  				break;  			case ">":  				newComparator = Comparator.Greater;  				break;  			case "<":  				newComparator = Comparator.Less;  				break;  			case ">=":  				newComparator = Comparator.GreaterOrEqual;  				break;  			case "<=":  				newComparator = Comparator.LessOrEqual;  				break;  			case "&":  				newComparator = Comparator.And;  				break;  			case "|":  				newComparator = Comparator.Or;  				break;  			default:  				newComparator = Comparator.Equals;  				break;  			}  			filterNode = new BoolExpression (a' newComparator' b);  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  		{  			DebugLocation (98' 4);  			DebugLocation (98' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr195);  			Match (input' TokenTypes.Down' null);  			DebugLocation (98' 12);  			PushFollow (Follow._filterExpr_in_filterExpr199);  			f = filterExpr ();  			PopFollow ();  			DebugLocation (98' 31);  			// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  			int alt6 = 2;  			try {  				DebugEnterSubRule (6);  				try {  					DebugEnterDecision (6' false);  					int LA6_1 = input.LA (1);  					if ((LA6_1 == 24)) {  						alt6 = 1;  					}  				}  				finally {  					DebugExitDecision (6);  				}  				switch (alt6) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  					{  						DebugLocation (98' 31);  						inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (6);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (99' 4);  			FilterTreeNode newNode = f;  			if ((inverse != null ? inverse.Text : default(string)) == "!")  				newNode.ToggleInversed ();  			filterNode = newNode;  		}  		break;  	case 3:  		DebugEnterAlt (3);  		// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  		{  			DebugLocation (105' 4);  			DebugLocation (105' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr216);  			Match (input' TokenTypes.Down' null);  			DebugLocation (105' 12);  			PushFollow (Follow._propertyChain_in_filterExpr219);  			propertyChain (propertySegments);  			PopFollow ();  			DebugLocation (105' 51);  			// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  			int alt7 = 2;  			try {  				DebugEnterSubRule (7);  				try {  					DebugEnterDecision (7' false);  					int LA7_1 = input.LA (1);  					if ((LA7_1 == 31)) {  						alt7 = 1;  					}  				}  				finally {  					DebugExitDecision (7);  				}  				switch (alt7) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  					{  						DebugLocation (105' 51);  						inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (7);  			}  			DebugLocation (105' 60);  			// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  			int alt8 = 2;  			try {  				DebugEnterSubRule (8);  				try {  					DebugEnterDecision (8' false);  					int LA8_1 = input.LA (1);  					if ((LA8_1 == 24)) {  						alt8 = 1;  					}  				}  				finally {  					DebugExitDecision (8);  				}  				switch (alt8) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  					{  						DebugLocation (105' 60);  						not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (8);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (106' 4);  			FilterTreeNode newProperty = new Property (propertySegments);  			if ((inverse != null ? inverse.Text : default(string)) == "?")  				filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  			else {  				if ((not != null ? not.Text : default(string)) == "!")  					newProperty.ToggleInversed ();  				filterNode = newProperty;  			}  		}  		break;  	case 4:  		DebugEnterAlt (4);  		// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  		{  			DebugLocation (116' 4);  			STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  			DebugLocation (117' 4);  			string stringText = (STRING7 != null ? STRING7.Text : default(string));  			stringText = stringText.Substring (1' stringText.Length - 2);  			filterNode = new Value (stringText);  		}  		break;  	case 5:  		DebugEnterAlt (5);  		// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  		{  			DebugLocation (122' 4);  			REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  			DebugLocation (123' 4);  			string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  			regexText = regexText.Substring (1' regexText.Length - 2);  			filterNode = new RegExp (regexText);  		}  		break;  	case 6:  		DebugEnterAlt (6);  		// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  		{  			DebugLocation (128' 4);  			NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  			DebugLocation (129' 4);  			filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  		}  		break;  	case 7:  		DebugEnterAlt (7);  		// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  		{  			DebugLocation (132' 4);  			Match (input' TRUE' Follow._TRUE_in_filterExpr271);  			DebugLocation (133' 4);  			filterNode = new Value (true);  		}  		break;  	case 8:  		DebugEnterAlt (8);  		// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  		{  			DebugLocation (136' 4);  			Match (input' FALSE' Follow._FALSE_in_filterExpr281);  			DebugLocation (137' 4);  			filterNode = new Value (false);  		}  		break;  	case 9:  		DebugEnterAlt (9);  		// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  		{  			DebugLocation (140' 4);  			Match (input' NULL' Follow._NULL_in_filterExpr291);  			DebugLocation (141' 4);  			filterNode = new Value (null);  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("filterExpr"' 6);  	LeaveRule ("filterExpr"' 6);  	LeaveRule_filterExpr ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  	int alt9 = 9;  	try {  		DebugEnterDecision (9' false);  		switch (input.LA (1)) {  		case CHAIN_OPERATOR:  		case COMPARATOR:  			{  				alt9 = 1;  			}  			break;  		case EXPR:  			{  				int LA9_2 = input.LA (2);  				if ((LA9_2 == DOWN)) {  					int LA9_3 = input.LA (3);  					if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  						alt9 = 2;  					}  					else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  						alt9 = 3;  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				else {  					NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  					DebugRecognitionException (nvae);  					throw nvae;  				}  			}  			break;  		case STRING:  			{  				alt9 = 4;  			}  			break;  		case REGEX:  			{  				alt9 = 5;  			}  			break;  		case NUMBER:  			{  				alt9 = 6;  			}  			break;  		case TRUE:  			{  				alt9 = 7;  			}  			break;  		case FALSE:  			{  				alt9 = 8;  			}  			break;  		case NULL:  			{  				alt9 = 9;  			}  			break;  		default: {  			NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  		}  	}  	finally {  		DebugExitDecision (9);  	}  	switch (alt9) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  		{  			DebugLocation (64' 4);  			DebugLocation (64' 6);  			PushFollow (Follow._comparator_in_filterExpr175);  			comparator6 = comparator ();  			PopFollow ();  			Match (input' TokenTypes.Down' null);  			DebugLocation (64' 18);  			PushFollow (Follow._filterExpr_in_filterExpr179);  			a = filterExpr ();  			PopFollow ();  			DebugLocation (64' 31);  			PushFollow (Follow._filterExpr_in_filterExpr183);  			b = filterExpr ();  			PopFollow ();  			Match (input' TokenTypes.Up' null);  			DebugLocation (65' 4);  			Comparator newComparator;  			switch (comparator6) {  			case "=":  				newComparator = Comparator.Equals;  				break;  			case "!=":  				newComparator = Comparator.NotEquals;  				break;  			case ">":  				newComparator = Comparator.Greater;  				break;  			case "<":  				newComparator = Comparator.Less;  				break;  			case ">=":  				newComparator = Comparator.GreaterOrEqual;  				break;  			case "<=":  				newComparator = Comparator.LessOrEqual;  				break;  			case "&":  				newComparator = Comparator.And;  				break;  			case "|":  				newComparator = Comparator.Or;  				break;  			default:  				newComparator = Comparator.Equals;  				break;  			}  			filterNode = new BoolExpression (a' newComparator' b);  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  		{  			DebugLocation (98' 4);  			DebugLocation (98' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr195);  			Match (input' TokenTypes.Down' null);  			DebugLocation (98' 12);  			PushFollow (Follow._filterExpr_in_filterExpr199);  			f = filterExpr ();  			PopFollow ();  			DebugLocation (98' 31);  			// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  			int alt6 = 2;  			try {  				DebugEnterSubRule (6);  				try {  					DebugEnterDecision (6' false);  					int LA6_1 = input.LA (1);  					if ((LA6_1 == 24)) {  						alt6 = 1;  					}  				}  				finally {  					DebugExitDecision (6);  				}  				switch (alt6) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  					{  						DebugLocation (98' 31);  						inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (6);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (99' 4);  			FilterTreeNode newNode = f;  			if ((inverse != null ? inverse.Text : default(string)) == "!")  				newNode.ToggleInversed ();  			filterNode = newNode;  		}  		break;  	case 3:  		DebugEnterAlt (3);  		// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  		{  			DebugLocation (105' 4);  			DebugLocation (105' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr216);  			Match (input' TokenTypes.Down' null);  			DebugLocation (105' 12);  			PushFollow (Follow._propertyChain_in_filterExpr219);  			propertyChain (propertySegments);  			PopFollow ();  			DebugLocation (105' 51);  			// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  			int alt7 = 2;  			try {  				DebugEnterSubRule (7);  				try {  					DebugEnterDecision (7' false);  					int LA7_1 = input.LA (1);  					if ((LA7_1 == 31)) {  						alt7 = 1;  					}  				}  				finally {  					DebugExitDecision (7);  				}  				switch (alt7) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  					{  						DebugLocation (105' 51);  						inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (7);  			}  			DebugLocation (105' 60);  			// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  			int alt8 = 2;  			try {  				DebugEnterSubRule (8);  				try {  					DebugEnterDecision (8' false);  					int LA8_1 = input.LA (1);  					if ((LA8_1 == 24)) {  						alt8 = 1;  					}  				}  				finally {  					DebugExitDecision (8);  				}  				switch (alt8) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  					{  						DebugLocation (105' 60);  						not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (8);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (106' 4);  			FilterTreeNode newProperty = new Property (propertySegments);  			if ((inverse != null ? inverse.Text : default(string)) == "?")  				filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  			else {  				if ((not != null ? not.Text : default(string)) == "!")  					newProperty.ToggleInversed ();  				filterNode = newProperty;  			}  		}  		break;  	case 4:  		DebugEnterAlt (4);  		// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  		{  			DebugLocation (116' 4);  			STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  			DebugLocation (117' 4);  			string stringText = (STRING7 != null ? STRING7.Text : default(string));  			stringText = stringText.Substring (1' stringText.Length - 2);  			filterNode = new Value (stringText);  		}  		break;  	case 5:  		DebugEnterAlt (5);  		// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  		{  			DebugLocation (122' 4);  			REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  			DebugLocation (123' 4);  			string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  			regexText = regexText.Substring (1' regexText.Length - 2);  			filterNode = new RegExp (regexText);  		}  		break;  	case 6:  		DebugEnterAlt (6);  		// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  		{  			DebugLocation (128' 4);  			NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  			DebugLocation (129' 4);  			filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  		}  		break;  	case 7:  		DebugEnterAlt (7);  		// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  		{  			DebugLocation (132' 4);  			Match (input' TRUE' Follow._TRUE_in_filterExpr271);  			DebugLocation (133' 4);  			filterNode = new Value (true);  		}  		break;  	case 8:  		DebugEnterAlt (8);  		// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  		{  			DebugLocation (136' 4);  			Match (input' FALSE' Follow._FALSE_in_filterExpr281);  			DebugLocation (137' 4);  			filterNode = new Value (false);  		}  		break;  	case 9:  		DebugEnterAlt (9);  		// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  		{  			DebugLocation (140' 4);  			Match (input' NULL' Follow._NULL_in_filterExpr291);  			DebugLocation (141' 4);  			filterNode = new Value (null);  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("filterExpr"' 6);  	LeaveRule ("filterExpr"' 6);  	LeaveRule_filterExpr ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  	int alt9 = 9;  	try {  		DebugEnterDecision (9' false);  		switch (input.LA (1)) {  		case CHAIN_OPERATOR:  		case COMPARATOR:  			{  				alt9 = 1;  			}  			break;  		case EXPR:  			{  				int LA9_2 = input.LA (2);  				if ((LA9_2 == DOWN)) {  					int LA9_3 = input.LA (3);  					if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  						alt9 = 2;  					}  					else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  						alt9 = 3;  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				else {  					NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  					DebugRecognitionException (nvae);  					throw nvae;  				}  			}  			break;  		case STRING:  			{  				alt9 = 4;  			}  			break;  		case REGEX:  			{  				alt9 = 5;  			}  			break;  		case NUMBER:  			{  				alt9 = 6;  			}  			break;  		case TRUE:  			{  				alt9 = 7;  			}  			break;  		case FALSE:  			{  				alt9 = 8;  			}  			break;  		case NULL:  			{  				alt9 = 9;  			}  			break;  		default: {  			NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  		}  	}  	finally {  		DebugExitDecision (9);  	}  	switch (alt9) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  		{  			DebugLocation (64' 4);  			DebugLocation (64' 6);  			PushFollow (Follow._comparator_in_filterExpr175);  			comparator6 = comparator ();  			PopFollow ();  			Match (input' TokenTypes.Down' null);  			DebugLocation (64' 18);  			PushFollow (Follow._filterExpr_in_filterExpr179);  			a = filterExpr ();  			PopFollow ();  			DebugLocation (64' 31);  			PushFollow (Follow._filterExpr_in_filterExpr183);  			b = filterExpr ();  			PopFollow ();  			Match (input' TokenTypes.Up' null);  			DebugLocation (65' 4);  			Comparator newComparator;  			switch (comparator6) {  			case "=":  				newComparator = Comparator.Equals;  				break;  			case "!=":  				newComparator = Comparator.NotEquals;  				break;  			case ">":  				newComparator = Comparator.Greater;  				break;  			case "<":  				newComparator = Comparator.Less;  				break;  			case ">=":  				newComparator = Comparator.GreaterOrEqual;  				break;  			case "<=":  				newComparator = Comparator.LessOrEqual;  				break;  			case "&":  				newComparator = Comparator.And;  				break;  			case "|":  				newComparator = Comparator.Or;  				break;  			default:  				newComparator = Comparator.Equals;  				break;  			}  			filterNode = new BoolExpression (a' newComparator' b);  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  		{  			DebugLocation (98' 4);  			DebugLocation (98' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr195);  			Match (input' TokenTypes.Down' null);  			DebugLocation (98' 12);  			PushFollow (Follow._filterExpr_in_filterExpr199);  			f = filterExpr ();  			PopFollow ();  			DebugLocation (98' 31);  			// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  			int alt6 = 2;  			try {  				DebugEnterSubRule (6);  				try {  					DebugEnterDecision (6' false);  					int LA6_1 = input.LA (1);  					if ((LA6_1 == 24)) {  						alt6 = 1;  					}  				}  				finally {  					DebugExitDecision (6);  				}  				switch (alt6) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  					{  						DebugLocation (98' 31);  						inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (6);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (99' 4);  			FilterTreeNode newNode = f;  			if ((inverse != null ? inverse.Text : default(string)) == "!")  				newNode.ToggleInversed ();  			filterNode = newNode;  		}  		break;  	case 3:  		DebugEnterAlt (3);  		// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  		{  			DebugLocation (105' 4);  			DebugLocation (105' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr216);  			Match (input' TokenTypes.Down' null);  			DebugLocation (105' 12);  			PushFollow (Follow._propertyChain_in_filterExpr219);  			propertyChain (propertySegments);  			PopFollow ();  			DebugLocation (105' 51);  			// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  			int alt7 = 2;  			try {  				DebugEnterSubRule (7);  				try {  					DebugEnterDecision (7' false);  					int LA7_1 = input.LA (1);  					if ((LA7_1 == 31)) {  						alt7 = 1;  					}  				}  				finally {  					DebugExitDecision (7);  				}  				switch (alt7) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  					{  						DebugLocation (105' 51);  						inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (7);  			}  			DebugLocation (105' 60);  			// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  			int alt8 = 2;  			try {  				DebugEnterSubRule (8);  				try {  					DebugEnterDecision (8' false);  					int LA8_1 = input.LA (1);  					if ((LA8_1 == 24)) {  						alt8 = 1;  					}  				}  				finally {  					DebugExitDecision (8);  				}  				switch (alt8) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  					{  						DebugLocation (105' 60);  						not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (8);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (106' 4);  			FilterTreeNode newProperty = new Property (propertySegments);  			if ((inverse != null ? inverse.Text : default(string)) == "?")  				filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  			else {  				if ((not != null ? not.Text : default(string)) == "!")  					newProperty.ToggleInversed ();  				filterNode = newProperty;  			}  		}  		break;  	case 4:  		DebugEnterAlt (4);  		// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  		{  			DebugLocation (116' 4);  			STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  			DebugLocation (117' 4);  			string stringText = (STRING7 != null ? STRING7.Text : default(string));  			stringText = stringText.Substring (1' stringText.Length - 2);  			filterNode = new Value (stringText);  		}  		break;  	case 5:  		DebugEnterAlt (5);  		// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  		{  			DebugLocation (122' 4);  			REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  			DebugLocation (123' 4);  			string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  			regexText = regexText.Substring (1' regexText.Length - 2);  			filterNode = new RegExp (regexText);  		}  		break;  	case 6:  		DebugEnterAlt (6);  		// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  		{  			DebugLocation (128' 4);  			NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  			DebugLocation (129' 4);  			filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  		}  		break;  	case 7:  		DebugEnterAlt (7);  		// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  		{  			DebugLocation (132' 4);  			Match (input' TRUE' Follow._TRUE_in_filterExpr271);  			DebugLocation (133' 4);  			filterNode = new Value (true);  		}  		break;  	case 8:  		DebugEnterAlt (8);  		// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  		{  			DebugLocation (136' 4);  			Match (input' FALSE' Follow._FALSE_in_filterExpr281);  			DebugLocation (137' 4);  			filterNode = new Value (false);  		}  		break;  	case 9:  		DebugEnterAlt (9);  		// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  		{  			DebugLocation (140' 4);  			Match (input' NULL' Follow._NULL_in_filterExpr291);  			DebugLocation (141' 4);  			filterNode = new Value (null);  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("filterExpr"' 6);  	LeaveRule ("filterExpr"' 6);  	LeaveRule_filterExpr ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  	int alt9 = 9;  	try {  		DebugEnterDecision (9' false);  		switch (input.LA (1)) {  		case CHAIN_OPERATOR:  		case COMPARATOR:  			{  				alt9 = 1;  			}  			break;  		case EXPR:  			{  				int LA9_2 = input.LA (2);  				if ((LA9_2 == DOWN)) {  					int LA9_3 = input.LA (3);  					if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  						alt9 = 2;  					}  					else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  						alt9 = 3;  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				else {  					NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  					DebugRecognitionException (nvae);  					throw nvae;  				}  			}  			break;  		case STRING:  			{  				alt9 = 4;  			}  			break;  		case REGEX:  			{  				alt9 = 5;  			}  			break;  		case NUMBER:  			{  				alt9 = 6;  			}  			break;  		case TRUE:  			{  				alt9 = 7;  			}  			break;  		case FALSE:  			{  				alt9 = 8;  			}  			break;  		case NULL:  			{  				alt9 = 9;  			}  			break;  		default: {  			NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  		}  	}  	finally {  		DebugExitDecision (9);  	}  	switch (alt9) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  		{  			DebugLocation (64' 4);  			DebugLocation (64' 6);  			PushFollow (Follow._comparator_in_filterExpr175);  			comparator6 = comparator ();  			PopFollow ();  			Match (input' TokenTypes.Down' null);  			DebugLocation (64' 18);  			PushFollow (Follow._filterExpr_in_filterExpr179);  			a = filterExpr ();  			PopFollow ();  			DebugLocation (64' 31);  			PushFollow (Follow._filterExpr_in_filterExpr183);  			b = filterExpr ();  			PopFollow ();  			Match (input' TokenTypes.Up' null);  			DebugLocation (65' 4);  			Comparator newComparator;  			switch (comparator6) {  			case "=":  				newComparator = Comparator.Equals;  				break;  			case "!=":  				newComparator = Comparator.NotEquals;  				break;  			case ">":  				newComparator = Comparator.Greater;  				break;  			case "<":  				newComparator = Comparator.Less;  				break;  			case ">=":  				newComparator = Comparator.GreaterOrEqual;  				break;  			case "<=":  				newComparator = Comparator.LessOrEqual;  				break;  			case "&":  				newComparator = Comparator.And;  				break;  			case "|":  				newComparator = Comparator.Or;  				break;  			default:  				newComparator = Comparator.Equals;  				break;  			}  			filterNode = new BoolExpression (a' newComparator' b);  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  		{  			DebugLocation (98' 4);  			DebugLocation (98' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr195);  			Match (input' TokenTypes.Down' null);  			DebugLocation (98' 12);  			PushFollow (Follow._filterExpr_in_filterExpr199);  			f = filterExpr ();  			PopFollow ();  			DebugLocation (98' 31);  			// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  			int alt6 = 2;  			try {  				DebugEnterSubRule (6);  				try {  					DebugEnterDecision (6' false);  					int LA6_1 = input.LA (1);  					if ((LA6_1 == 24)) {  						alt6 = 1;  					}  				}  				finally {  					DebugExitDecision (6);  				}  				switch (alt6) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  					{  						DebugLocation (98' 31);  						inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (6);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (99' 4);  			FilterTreeNode newNode = f;  			if ((inverse != null ? inverse.Text : default(string)) == "!")  				newNode.ToggleInversed ();  			filterNode = newNode;  		}  		break;  	case 3:  		DebugEnterAlt (3);  		// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  		{  			DebugLocation (105' 4);  			DebugLocation (105' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr216);  			Match (input' TokenTypes.Down' null);  			DebugLocation (105' 12);  			PushFollow (Follow._propertyChain_in_filterExpr219);  			propertyChain (propertySegments);  			PopFollow ();  			DebugLocation (105' 51);  			// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  			int alt7 = 2;  			try {  				DebugEnterSubRule (7);  				try {  					DebugEnterDecision (7' false);  					int LA7_1 = input.LA (1);  					if ((LA7_1 == 31)) {  						alt7 = 1;  					}  				}  				finally {  					DebugExitDecision (7);  				}  				switch (alt7) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  					{  						DebugLocation (105' 51);  						inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (7);  			}  			DebugLocation (105' 60);  			// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  			int alt8 = 2;  			try {  				DebugEnterSubRule (8);  				try {  					DebugEnterDecision (8' false);  					int LA8_1 = input.LA (1);  					if ((LA8_1 == 24)) {  						alt8 = 1;  					}  				}  				finally {  					DebugExitDecision (8);  				}  				switch (alt8) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  					{  						DebugLocation (105' 60);  						not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (8);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (106' 4);  			FilterTreeNode newProperty = new Property (propertySegments);  			if ((inverse != null ? inverse.Text : default(string)) == "?")  				filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  			else {  				if ((not != null ? not.Text : default(string)) == "!")  					newProperty.ToggleInversed ();  				filterNode = newProperty;  			}  		}  		break;  	case 4:  		DebugEnterAlt (4);  		// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  		{  			DebugLocation (116' 4);  			STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  			DebugLocation (117' 4);  			string stringText = (STRING7 != null ? STRING7.Text : default(string));  			stringText = stringText.Substring (1' stringText.Length - 2);  			filterNode = new Value (stringText);  		}  		break;  	case 5:  		DebugEnterAlt (5);  		// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  		{  			DebugLocation (122' 4);  			REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  			DebugLocation (123' 4);  			string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  			regexText = regexText.Substring (1' regexText.Length - 2);  			filterNode = new RegExp (regexText);  		}  		break;  	case 6:  		DebugEnterAlt (6);  		// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  		{  			DebugLocation (128' 4);  			NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  			DebugLocation (129' 4);  			filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  		}  		break;  	case 7:  		DebugEnterAlt (7);  		// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  		{  			DebugLocation (132' 4);  			Match (input' TRUE' Follow._TRUE_in_filterExpr271);  			DebugLocation (133' 4);  			filterNode = new Value (true);  		}  		break;  	case 8:  		DebugEnterAlt (8);  		// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  		{  			DebugLocation (136' 4);  			Match (input' FALSE' Follow._FALSE_in_filterExpr281);  			DebugLocation (137' 4);  			filterNode = new Value (false);  		}  		break;  	case 9:  		DebugEnterAlt (9);  		// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  		{  			DebugLocation (140' 4);  			Match (input' NULL' Follow._NULL_in_filterExpr291);  			DebugLocation (141' 4);  			filterNode = new Value (null);  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("filterExpr"' 6);  	LeaveRule ("filterExpr"' 6);  	LeaveRule_filterExpr ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  	int alt9 = 9;  	try {  		DebugEnterDecision (9' false);  		switch (input.LA (1)) {  		case CHAIN_OPERATOR:  		case COMPARATOR:  			{  				alt9 = 1;  			}  			break;  		case EXPR:  			{  				int LA9_2 = input.LA (2);  				if ((LA9_2 == DOWN)) {  					int LA9_3 = input.LA (3);  					if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  						alt9 = 2;  					}  					else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  						alt9 = 3;  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				else {  					NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  					DebugRecognitionException (nvae);  					throw nvae;  				}  			}  			break;  		case STRING:  			{  				alt9 = 4;  			}  			break;  		case REGEX:  			{  				alt9 = 5;  			}  			break;  		case NUMBER:  			{  				alt9 = 6;  			}  			break;  		case TRUE:  			{  				alt9 = 7;  			}  			break;  		case FALSE:  			{  				alt9 = 8;  			}  			break;  		case NULL:  			{  				alt9 = 9;  			}  			break;  		default: {  			NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  		}  	}  	finally {  		DebugExitDecision (9);  	}  	switch (alt9) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  		{  			DebugLocation (64' 4);  			DebugLocation (64' 6);  			PushFollow (Follow._comparator_in_filterExpr175);  			comparator6 = comparator ();  			PopFollow ();  			Match (input' TokenTypes.Down' null);  			DebugLocation (64' 18);  			PushFollow (Follow._filterExpr_in_filterExpr179);  			a = filterExpr ();  			PopFollow ();  			DebugLocation (64' 31);  			PushFollow (Follow._filterExpr_in_filterExpr183);  			b = filterExpr ();  			PopFollow ();  			Match (input' TokenTypes.Up' null);  			DebugLocation (65' 4);  			Comparator newComparator;  			switch (comparator6) {  			case "=":  				newComparator = Comparator.Equals;  				break;  			case "!=":  				newComparator = Comparator.NotEquals;  				break;  			case ">":  				newComparator = Comparator.Greater;  				break;  			case "<":  				newComparator = Comparator.Less;  				break;  			case ">=":  				newComparator = Comparator.GreaterOrEqual;  				break;  			case "<=":  				newComparator = Comparator.LessOrEqual;  				break;  			case "&":  				newComparator = Comparator.And;  				break;  			case "|":  				newComparator = Comparator.Or;  				break;  			default:  				newComparator = Comparator.Equals;  				break;  			}  			filterNode = new BoolExpression (a' newComparator' b);  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  		{  			DebugLocation (98' 4);  			DebugLocation (98' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr195);  			Match (input' TokenTypes.Down' null);  			DebugLocation (98' 12);  			PushFollow (Follow._filterExpr_in_filterExpr199);  			f = filterExpr ();  			PopFollow ();  			DebugLocation (98' 31);  			// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  			int alt6 = 2;  			try {  				DebugEnterSubRule (6);  				try {  					DebugEnterDecision (6' false);  					int LA6_1 = input.LA (1);  					if ((LA6_1 == 24)) {  						alt6 = 1;  					}  				}  				finally {  					DebugExitDecision (6);  				}  				switch (alt6) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  					{  						DebugLocation (98' 31);  						inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (6);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (99' 4);  			FilterTreeNode newNode = f;  			if ((inverse != null ? inverse.Text : default(string)) == "!")  				newNode.ToggleInversed ();  			filterNode = newNode;  		}  		break;  	case 3:  		DebugEnterAlt (3);  		// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  		{  			DebugLocation (105' 4);  			DebugLocation (105' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr216);  			Match (input' TokenTypes.Down' null);  			DebugLocation (105' 12);  			PushFollow (Follow._propertyChain_in_filterExpr219);  			propertyChain (propertySegments);  			PopFollow ();  			DebugLocation (105' 51);  			// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  			int alt7 = 2;  			try {  				DebugEnterSubRule (7);  				try {  					DebugEnterDecision (7' false);  					int LA7_1 = input.LA (1);  					if ((LA7_1 == 31)) {  						alt7 = 1;  					}  				}  				finally {  					DebugExitDecision (7);  				}  				switch (alt7) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  					{  						DebugLocation (105' 51);  						inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (7);  			}  			DebugLocation (105' 60);  			// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  			int alt8 = 2;  			try {  				DebugEnterSubRule (8);  				try {  					DebugEnterDecision (8' false);  					int LA8_1 = input.LA (1);  					if ((LA8_1 == 24)) {  						alt8 = 1;  					}  				}  				finally {  					DebugExitDecision (8);  				}  				switch (alt8) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  					{  						DebugLocation (105' 60);  						not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (8);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (106' 4);  			FilterTreeNode newProperty = new Property (propertySegments);  			if ((inverse != null ? inverse.Text : default(string)) == "?")  				filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  			else {  				if ((not != null ? not.Text : default(string)) == "!")  					newProperty.ToggleInversed ();  				filterNode = newProperty;  			}  		}  		break;  	case 4:  		DebugEnterAlt (4);  		// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  		{  			DebugLocation (116' 4);  			STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  			DebugLocation (117' 4);  			string stringText = (STRING7 != null ? STRING7.Text : default(string));  			stringText = stringText.Substring (1' stringText.Length - 2);  			filterNode = new Value (stringText);  		}  		break;  	case 5:  		DebugEnterAlt (5);  		// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  		{  			DebugLocation (122' 4);  			REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  			DebugLocation (123' 4);  			string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  			regexText = regexText.Substring (1' regexText.Length - 2);  			filterNode = new RegExp (regexText);  		}  		break;  	case 6:  		DebugEnterAlt (6);  		// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  		{  			DebugLocation (128' 4);  			NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  			DebugLocation (129' 4);  			filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  		}  		break;  	case 7:  		DebugEnterAlt (7);  		// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  		{  			DebugLocation (132' 4);  			Match (input' TRUE' Follow._TRUE_in_filterExpr271);  			DebugLocation (133' 4);  			filterNode = new Value (true);  		}  		break;  	case 8:  		DebugEnterAlt (8);  		// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  		{  			DebugLocation (136' 4);  			Match (input' FALSE' Follow._FALSE_in_filterExpr281);  			DebugLocation (137' 4);  			filterNode = new Value (false);  		}  		break;  	case 9:  		DebugEnterAlt (9);  		// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  		{  			DebugLocation (140' 4);  			Match (input' NULL' Follow._NULL_in_filterExpr291);  			DebugLocation (141' 4);  			filterNode = new Value (null);  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("filterExpr"' 6);  	LeaveRule ("filterExpr"' 6);  	LeaveRule_filterExpr ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  	int alt9 = 9;  	try {  		DebugEnterDecision (9' false);  		switch (input.LA (1)) {  		case CHAIN_OPERATOR:  		case COMPARATOR:  			{  				alt9 = 1;  			}  			break;  		case EXPR:  			{  				int LA9_2 = input.LA (2);  				if ((LA9_2 == DOWN)) {  					int LA9_3 = input.LA (3);  					if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  						alt9 = 2;  					}  					else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  						alt9 = 3;  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				else {  					NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  					DebugRecognitionException (nvae);  					throw nvae;  				}  			}  			break;  		case STRING:  			{  				alt9 = 4;  			}  			break;  		case REGEX:  			{  				alt9 = 5;  			}  			break;  		case NUMBER:  			{  				alt9 = 6;  			}  			break;  		case TRUE:  			{  				alt9 = 7;  			}  			break;  		case FALSE:  			{  				alt9 = 8;  			}  			break;  		case NULL:  			{  				alt9 = 9;  			}  			break;  		default: {  			NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  		}  	}  	finally {  		DebugExitDecision (9);  	}  	switch (alt9) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  		{  			DebugLocation (64' 4);  			DebugLocation (64' 6);  			PushFollow (Follow._comparator_in_filterExpr175);  			comparator6 = comparator ();  			PopFollow ();  			Match (input' TokenTypes.Down' null);  			DebugLocation (64' 18);  			PushFollow (Follow._filterExpr_in_filterExpr179);  			a = filterExpr ();  			PopFollow ();  			DebugLocation (64' 31);  			PushFollow (Follow._filterExpr_in_filterExpr183);  			b = filterExpr ();  			PopFollow ();  			Match (input' TokenTypes.Up' null);  			DebugLocation (65' 4);  			Comparator newComparator;  			switch (comparator6) {  			case "=":  				newComparator = Comparator.Equals;  				break;  			case "!=":  				newComparator = Comparator.NotEquals;  				break;  			case ">":  				newComparator = Comparator.Greater;  				break;  			case "<":  				newComparator = Comparator.Less;  				break;  			case ">=":  				newComparator = Comparator.GreaterOrEqual;  				break;  			case "<=":  				newComparator = Comparator.LessOrEqual;  				break;  			case "&":  				newComparator = Comparator.And;  				break;  			case "|":  				newComparator = Comparator.Or;  				break;  			default:  				newComparator = Comparator.Equals;  				break;  			}  			filterNode = new BoolExpression (a' newComparator' b);  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  		{  			DebugLocation (98' 4);  			DebugLocation (98' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr195);  			Match (input' TokenTypes.Down' null);  			DebugLocation (98' 12);  			PushFollow (Follow._filterExpr_in_filterExpr199);  			f = filterExpr ();  			PopFollow ();  			DebugLocation (98' 31);  			// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  			int alt6 = 2;  			try {  				DebugEnterSubRule (6);  				try {  					DebugEnterDecision (6' false);  					int LA6_1 = input.LA (1);  					if ((LA6_1 == 24)) {  						alt6 = 1;  					}  				}  				finally {  					DebugExitDecision (6);  				}  				switch (alt6) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  					{  						DebugLocation (98' 31);  						inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (6);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (99' 4);  			FilterTreeNode newNode = f;  			if ((inverse != null ? inverse.Text : default(string)) == "!")  				newNode.ToggleInversed ();  			filterNode = newNode;  		}  		break;  	case 3:  		DebugEnterAlt (3);  		// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  		{  			DebugLocation (105' 4);  			DebugLocation (105' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr216);  			Match (input' TokenTypes.Down' null);  			DebugLocation (105' 12);  			PushFollow (Follow._propertyChain_in_filterExpr219);  			propertyChain (propertySegments);  			PopFollow ();  			DebugLocation (105' 51);  			// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  			int alt7 = 2;  			try {  				DebugEnterSubRule (7);  				try {  					DebugEnterDecision (7' false);  					int LA7_1 = input.LA (1);  					if ((LA7_1 == 31)) {  						alt7 = 1;  					}  				}  				finally {  					DebugExitDecision (7);  				}  				switch (alt7) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  					{  						DebugLocation (105' 51);  						inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (7);  			}  			DebugLocation (105' 60);  			// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  			int alt8 = 2;  			try {  				DebugEnterSubRule (8);  				try {  					DebugEnterDecision (8' false);  					int LA8_1 = input.LA (1);  					if ((LA8_1 == 24)) {  						alt8 = 1;  					}  				}  				finally {  					DebugExitDecision (8);  				}  				switch (alt8) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  					{  						DebugLocation (105' 60);  						not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (8);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (106' 4);  			FilterTreeNode newProperty = new Property (propertySegments);  			if ((inverse != null ? inverse.Text : default(string)) == "?")  				filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  			else {  				if ((not != null ? not.Text : default(string)) == "!")  					newProperty.ToggleInversed ();  				filterNode = newProperty;  			}  		}  		break;  	case 4:  		DebugEnterAlt (4);  		// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  		{  			DebugLocation (116' 4);  			STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  			DebugLocation (117' 4);  			string stringText = (STRING7 != null ? STRING7.Text : default(string));  			stringText = stringText.Substring (1' stringText.Length - 2);  			filterNode = new Value (stringText);  		}  		break;  	case 5:  		DebugEnterAlt (5);  		// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  		{  			DebugLocation (122' 4);  			REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  			DebugLocation (123' 4);  			string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  			regexText = regexText.Substring (1' regexText.Length - 2);  			filterNode = new RegExp (regexText);  		}  		break;  	case 6:  		DebugEnterAlt (6);  		// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  		{  			DebugLocation (128' 4);  			NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  			DebugLocation (129' 4);  			filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  		}  		break;  	case 7:  		DebugEnterAlt (7);  		// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  		{  			DebugLocation (132' 4);  			Match (input' TRUE' Follow._TRUE_in_filterExpr271);  			DebugLocation (133' 4);  			filterNode = new Value (true);  		}  		break;  	case 8:  		DebugEnterAlt (8);  		// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  		{  			DebugLocation (136' 4);  			Match (input' FALSE' Follow._FALSE_in_filterExpr281);  			DebugLocation (137' 4);  			filterNode = new Value (false);  		}  		break;  	case 9:  		DebugEnterAlt (9);  		// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  		{  			DebugLocation (140' 4);  			Match (input' NULL' Follow._NULL_in_filterExpr291);  			DebugLocation (141' 4);  			filterNode = new Value (null);  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("filterExpr"' 6);  	LeaveRule ("filterExpr"' 6);  	LeaveRule_filterExpr ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  	int alt9 = 9;  	try {  		DebugEnterDecision (9' false);  		switch (input.LA (1)) {  		case CHAIN_OPERATOR:  		case COMPARATOR:  			{  				alt9 = 1;  			}  			break;  		case EXPR:  			{  				int LA9_2 = input.LA (2);  				if ((LA9_2 == DOWN)) {  					int LA9_3 = input.LA (3);  					if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  						alt9 = 2;  					}  					else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  						alt9 = 3;  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				else {  					NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  					DebugRecognitionException (nvae);  					throw nvae;  				}  			}  			break;  		case STRING:  			{  				alt9 = 4;  			}  			break;  		case REGEX:  			{  				alt9 = 5;  			}  			break;  		case NUMBER:  			{  				alt9 = 6;  			}  			break;  		case TRUE:  			{  				alt9 = 7;  			}  			break;  		case FALSE:  			{  				alt9 = 8;  			}  			break;  		case NULL:  			{  				alt9 = 9;  			}  			break;  		default: {  			NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  		}  	}  	finally {  		DebugExitDecision (9);  	}  	switch (alt9) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  		{  			DebugLocation (64' 4);  			DebugLocation (64' 6);  			PushFollow (Follow._comparator_in_filterExpr175);  			comparator6 = comparator ();  			PopFollow ();  			Match (input' TokenTypes.Down' null);  			DebugLocation (64' 18);  			PushFollow (Follow._filterExpr_in_filterExpr179);  			a = filterExpr ();  			PopFollow ();  			DebugLocation (64' 31);  			PushFollow (Follow._filterExpr_in_filterExpr183);  			b = filterExpr ();  			PopFollow ();  			Match (input' TokenTypes.Up' null);  			DebugLocation (65' 4);  			Comparator newComparator;  			switch (comparator6) {  			case "=":  				newComparator = Comparator.Equals;  				break;  			case "!=":  				newComparator = Comparator.NotEquals;  				break;  			case ">":  				newComparator = Comparator.Greater;  				break;  			case "<":  				newComparator = Comparator.Less;  				break;  			case ">=":  				newComparator = Comparator.GreaterOrEqual;  				break;  			case "<=":  				newComparator = Comparator.LessOrEqual;  				break;  			case "&":  				newComparator = Comparator.And;  				break;  			case "|":  				newComparator = Comparator.Or;  				break;  			default:  				newComparator = Comparator.Equals;  				break;  			}  			filterNode = new BoolExpression (a' newComparator' b);  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  		{  			DebugLocation (98' 4);  			DebugLocation (98' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr195);  			Match (input' TokenTypes.Down' null);  			DebugLocation (98' 12);  			PushFollow (Follow._filterExpr_in_filterExpr199);  			f = filterExpr ();  			PopFollow ();  			DebugLocation (98' 31);  			// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  			int alt6 = 2;  			try {  				DebugEnterSubRule (6);  				try {  					DebugEnterDecision (6' false);  					int LA6_1 = input.LA (1);  					if ((LA6_1 == 24)) {  						alt6 = 1;  					}  				}  				finally {  					DebugExitDecision (6);  				}  				switch (alt6) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  					{  						DebugLocation (98' 31);  						inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (6);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (99' 4);  			FilterTreeNode newNode = f;  			if ((inverse != null ? inverse.Text : default(string)) == "!")  				newNode.ToggleInversed ();  			filterNode = newNode;  		}  		break;  	case 3:  		DebugEnterAlt (3);  		// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  		{  			DebugLocation (105' 4);  			DebugLocation (105' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr216);  			Match (input' TokenTypes.Down' null);  			DebugLocation (105' 12);  			PushFollow (Follow._propertyChain_in_filterExpr219);  			propertyChain (propertySegments);  			PopFollow ();  			DebugLocation (105' 51);  			// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  			int alt7 = 2;  			try {  				DebugEnterSubRule (7);  				try {  					DebugEnterDecision (7' false);  					int LA7_1 = input.LA (1);  					if ((LA7_1 == 31)) {  						alt7 = 1;  					}  				}  				finally {  					DebugExitDecision (7);  				}  				switch (alt7) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  					{  						DebugLocation (105' 51);  						inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (7);  			}  			DebugLocation (105' 60);  			// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  			int alt8 = 2;  			try {  				DebugEnterSubRule (8);  				try {  					DebugEnterDecision (8' false);  					int LA8_1 = input.LA (1);  					if ((LA8_1 == 24)) {  						alt8 = 1;  					}  				}  				finally {  					DebugExitDecision (8);  				}  				switch (alt8) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  					{  						DebugLocation (105' 60);  						not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (8);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (106' 4);  			FilterTreeNode newProperty = new Property (propertySegments);  			if ((inverse != null ? inverse.Text : default(string)) == "?")  				filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  			else {  				if ((not != null ? not.Text : default(string)) == "!")  					newProperty.ToggleInversed ();  				filterNode = newProperty;  			}  		}  		break;  	case 4:  		DebugEnterAlt (4);  		// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  		{  			DebugLocation (116' 4);  			STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  			DebugLocation (117' 4);  			string stringText = (STRING7 != null ? STRING7.Text : default(string));  			stringText = stringText.Substring (1' stringText.Length - 2);  			filterNode = new Value (stringText);  		}  		break;  	case 5:  		DebugEnterAlt (5);  		// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  		{  			DebugLocation (122' 4);  			REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  			DebugLocation (123' 4);  			string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  			regexText = regexText.Substring (1' regexText.Length - 2);  			filterNode = new RegExp (regexText);  		}  		break;  	case 6:  		DebugEnterAlt (6);  		// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  		{  			DebugLocation (128' 4);  			NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  			DebugLocation (129' 4);  			filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  		}  		break;  	case 7:  		DebugEnterAlt (7);  		// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  		{  			DebugLocation (132' 4);  			Match (input' TRUE' Follow._TRUE_in_filterExpr271);  			DebugLocation (133' 4);  			filterNode = new Value (true);  		}  		break;  	case 8:  		DebugEnterAlt (8);  		// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  		{  			DebugLocation (136' 4);  			Match (input' FALSE' Follow._FALSE_in_filterExpr281);  			DebugLocation (137' 4);  			filterNode = new Value (false);  		}  		break;  	case 9:  		DebugEnterAlt (9);  		// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  		{  			DebugLocation (140' 4);  			Match (input' NULL' Follow._NULL_in_filterExpr291);  			DebugLocation (141' 4);  			filterNode = new Value (null);  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("filterExpr"' 6);  	LeaveRule ("filterExpr"' 6);  	LeaveRule_filterExpr ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  	int alt9 = 9;  	try {  		DebugEnterDecision (9' false);  		switch (input.LA (1)) {  		case CHAIN_OPERATOR:  		case COMPARATOR:  			{  				alt9 = 1;  			}  			break;  		case EXPR:  			{  				int LA9_2 = input.LA (2);  				if ((LA9_2 == DOWN)) {  					int LA9_3 = input.LA (3);  					if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  						alt9 = 2;  					}  					else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  						alt9 = 3;  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				else {  					NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  					DebugRecognitionException (nvae);  					throw nvae;  				}  			}  			break;  		case STRING:  			{  				alt9 = 4;  			}  			break;  		case REGEX:  			{  				alt9 = 5;  			}  			break;  		case NUMBER:  			{  				alt9 = 6;  			}  			break;  		case TRUE:  			{  				alt9 = 7;  			}  			break;  		case FALSE:  			{  				alt9 = 8;  			}  			break;  		case NULL:  			{  				alt9 = 9;  			}  			break;  		default: {  			NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  		}  	}  	finally {  		DebugExitDecision (9);  	}  	switch (alt9) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  		{  			DebugLocation (64' 4);  			DebugLocation (64' 6);  			PushFollow (Follow._comparator_in_filterExpr175);  			comparator6 = comparator ();  			PopFollow ();  			Match (input' TokenTypes.Down' null);  			DebugLocation (64' 18);  			PushFollow (Follow._filterExpr_in_filterExpr179);  			a = filterExpr ();  			PopFollow ();  			DebugLocation (64' 31);  			PushFollow (Follow._filterExpr_in_filterExpr183);  			b = filterExpr ();  			PopFollow ();  			Match (input' TokenTypes.Up' null);  			DebugLocation (65' 4);  			Comparator newComparator;  			switch (comparator6) {  			case "=":  				newComparator = Comparator.Equals;  				break;  			case "!=":  				newComparator = Comparator.NotEquals;  				break;  			case ">":  				newComparator = Comparator.Greater;  				break;  			case "<":  				newComparator = Comparator.Less;  				break;  			case ">=":  				newComparator = Comparator.GreaterOrEqual;  				break;  			case "<=":  				newComparator = Comparator.LessOrEqual;  				break;  			case "&":  				newComparator = Comparator.And;  				break;  			case "|":  				newComparator = Comparator.Or;  				break;  			default:  				newComparator = Comparator.Equals;  				break;  			}  			filterNode = new BoolExpression (a' newComparator' b);  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  		{  			DebugLocation (98' 4);  			DebugLocation (98' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr195);  			Match (input' TokenTypes.Down' null);  			DebugLocation (98' 12);  			PushFollow (Follow._filterExpr_in_filterExpr199);  			f = filterExpr ();  			PopFollow ();  			DebugLocation (98' 31);  			// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  			int alt6 = 2;  			try {  				DebugEnterSubRule (6);  				try {  					DebugEnterDecision (6' false);  					int LA6_1 = input.LA (1);  					if ((LA6_1 == 24)) {  						alt6 = 1;  					}  				}  				finally {  					DebugExitDecision (6);  				}  				switch (alt6) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  					{  						DebugLocation (98' 31);  						inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (6);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (99' 4);  			FilterTreeNode newNode = f;  			if ((inverse != null ? inverse.Text : default(string)) == "!")  				newNode.ToggleInversed ();  			filterNode = newNode;  		}  		break;  	case 3:  		DebugEnterAlt (3);  		// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  		{  			DebugLocation (105' 4);  			DebugLocation (105' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr216);  			Match (input' TokenTypes.Down' null);  			DebugLocation (105' 12);  			PushFollow (Follow._propertyChain_in_filterExpr219);  			propertyChain (propertySegments);  			PopFollow ();  			DebugLocation (105' 51);  			// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  			int alt7 = 2;  			try {  				DebugEnterSubRule (7);  				try {  					DebugEnterDecision (7' false);  					int LA7_1 = input.LA (1);  					if ((LA7_1 == 31)) {  						alt7 = 1;  					}  				}  				finally {  					DebugExitDecision (7);  				}  				switch (alt7) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  					{  						DebugLocation (105' 51);  						inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (7);  			}  			DebugLocation (105' 60);  			// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  			int alt8 = 2;  			try {  				DebugEnterSubRule (8);  				try {  					DebugEnterDecision (8' false);  					int LA8_1 = input.LA (1);  					if ((LA8_1 == 24)) {  						alt8 = 1;  					}  				}  				finally {  					DebugExitDecision (8);  				}  				switch (alt8) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  					{  						DebugLocation (105' 60);  						not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (8);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (106' 4);  			FilterTreeNode newProperty = new Property (propertySegments);  			if ((inverse != null ? inverse.Text : default(string)) == "?")  				filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  			else {  				if ((not != null ? not.Text : default(string)) == "!")  					newProperty.ToggleInversed ();  				filterNode = newProperty;  			}  		}  		break;  	case 4:  		DebugEnterAlt (4);  		// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  		{  			DebugLocation (116' 4);  			STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  			DebugLocation (117' 4);  			string stringText = (STRING7 != null ? STRING7.Text : default(string));  			stringText = stringText.Substring (1' stringText.Length - 2);  			filterNode = new Value (stringText);  		}  		break;  	case 5:  		DebugEnterAlt (5);  		// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  		{  			DebugLocation (122' 4);  			REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  			DebugLocation (123' 4);  			string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  			regexText = regexText.Substring (1' regexText.Length - 2);  			filterNode = new RegExp (regexText);  		}  		break;  	case 6:  		DebugEnterAlt (6);  		// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  		{  			DebugLocation (128' 4);  			NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  			DebugLocation (129' 4);  			filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  		}  		break;  	case 7:  		DebugEnterAlt (7);  		// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  		{  			DebugLocation (132' 4);  			Match (input' TRUE' Follow._TRUE_in_filterExpr271);  			DebugLocation (133' 4);  			filterNode = new Value (true);  		}  		break;  	case 8:  		DebugEnterAlt (8);  		// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  		{  			DebugLocation (136' 4);  			Match (input' FALSE' Follow._FALSE_in_filterExpr281);  			DebugLocation (137' 4);  			filterNode = new Value (false);  		}  		break;  	case 9:  		DebugEnterAlt (9);  		// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  		{  			DebugLocation (140' 4);  			Match (input' NULL' Follow._NULL_in_filterExpr291);  			DebugLocation (141' 4);  			filterNode = new Value (null);  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("filterExpr"' 6);  	LeaveRule ("filterExpr"' 6);  	LeaveRule_filterExpr ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  	int alt9 = 9;  	try {  		DebugEnterDecision (9' false);  		switch (input.LA (1)) {  		case CHAIN_OPERATOR:  		case COMPARATOR:  			{  				alt9 = 1;  			}  			break;  		case EXPR:  			{  				int LA9_2 = input.LA (2);  				if ((LA9_2 == DOWN)) {  					int LA9_3 = input.LA (3);  					if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  						alt9 = 2;  					}  					else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  						alt9 = 3;  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				else {  					NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  					DebugRecognitionException (nvae);  					throw nvae;  				}  			}  			break;  		case STRING:  			{  				alt9 = 4;  			}  			break;  		case REGEX:  			{  				alt9 = 5;  			}  			break;  		case NUMBER:  			{  				alt9 = 6;  			}  			break;  		case TRUE:  			{  				alt9 = 7;  			}  			break;  		case FALSE:  			{  				alt9 = 8;  			}  			break;  		case NULL:  			{  				alt9 = 9;  			}  			break;  		default: {  			NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  		}  	}  	finally {  		DebugExitDecision (9);  	}  	switch (alt9) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  		{  			DebugLocation (64' 4);  			DebugLocation (64' 6);  			PushFollow (Follow._comparator_in_filterExpr175);  			comparator6 = comparator ();  			PopFollow ();  			Match (input' TokenTypes.Down' null);  			DebugLocation (64' 18);  			PushFollow (Follow._filterExpr_in_filterExpr179);  			a = filterExpr ();  			PopFollow ();  			DebugLocation (64' 31);  			PushFollow (Follow._filterExpr_in_filterExpr183);  			b = filterExpr ();  			PopFollow ();  			Match (input' TokenTypes.Up' null);  			DebugLocation (65' 4);  			Comparator newComparator;  			switch (comparator6) {  			case "=":  				newComparator = Comparator.Equals;  				break;  			case "!=":  				newComparator = Comparator.NotEquals;  				break;  			case ">":  				newComparator = Comparator.Greater;  				break;  			case "<":  				newComparator = Comparator.Less;  				break;  			case ">=":  				newComparator = Comparator.GreaterOrEqual;  				break;  			case "<=":  				newComparator = Comparator.LessOrEqual;  				break;  			case "&":  				newComparator = Comparator.And;  				break;  			case "|":  				newComparator = Comparator.Or;  				break;  			default:  				newComparator = Comparator.Equals;  				break;  			}  			filterNode = new BoolExpression (a' newComparator' b);  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  		{  			DebugLocation (98' 4);  			DebugLocation (98' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr195);  			Match (input' TokenTypes.Down' null);  			DebugLocation (98' 12);  			PushFollow (Follow._filterExpr_in_filterExpr199);  			f = filterExpr ();  			PopFollow ();  			DebugLocation (98' 31);  			// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  			int alt6 = 2;  			try {  				DebugEnterSubRule (6);  				try {  					DebugEnterDecision (6' false);  					int LA6_1 = input.LA (1);  					if ((LA6_1 == 24)) {  						alt6 = 1;  					}  				}  				finally {  					DebugExitDecision (6);  				}  				switch (alt6) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  					{  						DebugLocation (98' 31);  						inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (6);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (99' 4);  			FilterTreeNode newNode = f;  			if ((inverse != null ? inverse.Text : default(string)) == "!")  				newNode.ToggleInversed ();  			filterNode = newNode;  		}  		break;  	case 3:  		DebugEnterAlt (3);  		// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  		{  			DebugLocation (105' 4);  			DebugLocation (105' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr216);  			Match (input' TokenTypes.Down' null);  			DebugLocation (105' 12);  			PushFollow (Follow._propertyChain_in_filterExpr219);  			propertyChain (propertySegments);  			PopFollow ();  			DebugLocation (105' 51);  			// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  			int alt7 = 2;  			try {  				DebugEnterSubRule (7);  				try {  					DebugEnterDecision (7' false);  					int LA7_1 = input.LA (1);  					if ((LA7_1 == 31)) {  						alt7 = 1;  					}  				}  				finally {  					DebugExitDecision (7);  				}  				switch (alt7) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  					{  						DebugLocation (105' 51);  						inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (7);  			}  			DebugLocation (105' 60);  			// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  			int alt8 = 2;  			try {  				DebugEnterSubRule (8);  				try {  					DebugEnterDecision (8' false);  					int LA8_1 = input.LA (1);  					if ((LA8_1 == 24)) {  						alt8 = 1;  					}  				}  				finally {  					DebugExitDecision (8);  				}  				switch (alt8) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  					{  						DebugLocation (105' 60);  						not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (8);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (106' 4);  			FilterTreeNode newProperty = new Property (propertySegments);  			if ((inverse != null ? inverse.Text : default(string)) == "?")  				filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  			else {  				if ((not != null ? not.Text : default(string)) == "!")  					newProperty.ToggleInversed ();  				filterNode = newProperty;  			}  		}  		break;  	case 4:  		DebugEnterAlt (4);  		// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  		{  			DebugLocation (116' 4);  			STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  			DebugLocation (117' 4);  			string stringText = (STRING7 != null ? STRING7.Text : default(string));  			stringText = stringText.Substring (1' stringText.Length - 2);  			filterNode = new Value (stringText);  		}  		break;  	case 5:  		DebugEnterAlt (5);  		// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  		{  			DebugLocation (122' 4);  			REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  			DebugLocation (123' 4);  			string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  			regexText = regexText.Substring (1' regexText.Length - 2);  			filterNode = new RegExp (regexText);  		}  		break;  	case 6:  		DebugEnterAlt (6);  		// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  		{  			DebugLocation (128' 4);  			NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  			DebugLocation (129' 4);  			filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  		}  		break;  	case 7:  		DebugEnterAlt (7);  		// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  		{  			DebugLocation (132' 4);  			Match (input' TRUE' Follow._TRUE_in_filterExpr271);  			DebugLocation (133' 4);  			filterNode = new Value (true);  		}  		break;  	case 8:  		DebugEnterAlt (8);  		// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  		{  			DebugLocation (136' 4);  			Match (input' FALSE' Follow._FALSE_in_filterExpr281);  			DebugLocation (137' 4);  			filterNode = new Value (false);  		}  		break;  	case 9:  		DebugEnterAlt (9);  		// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  		{  			DebugLocation (140' 4);  			Match (input' NULL' Follow._NULL_in_filterExpr291);  			DebugLocation (141' 4);  			filterNode = new Value (null);  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("filterExpr"' 6);  	LeaveRule ("filterExpr"' 6);  	LeaveRule_filterExpr ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  	int alt9 = 9;  	try {  		DebugEnterDecision (9' false);  		switch (input.LA (1)) {  		case CHAIN_OPERATOR:  		case COMPARATOR:  			{  				alt9 = 1;  			}  			break;  		case EXPR:  			{  				int LA9_2 = input.LA (2);  				if ((LA9_2 == DOWN)) {  					int LA9_3 = input.LA (3);  					if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  						alt9 = 2;  					}  					else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  						alt9 = 3;  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				else {  					NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  					DebugRecognitionException (nvae);  					throw nvae;  				}  			}  			break;  		case STRING:  			{  				alt9 = 4;  			}  			break;  		case REGEX:  			{  				alt9 = 5;  			}  			break;  		case NUMBER:  			{  				alt9 = 6;  			}  			break;  		case TRUE:  			{  				alt9 = 7;  			}  			break;  		case FALSE:  			{  				alt9 = 8;  			}  			break;  		case NULL:  			{  				alt9 = 9;  			}  			break;  		default: {  			NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  		}  	}  	finally {  		DebugExitDecision (9);  	}  	switch (alt9) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  		{  			DebugLocation (64' 4);  			DebugLocation (64' 6);  			PushFollow (Follow._comparator_in_filterExpr175);  			comparator6 = comparator ();  			PopFollow ();  			Match (input' TokenTypes.Down' null);  			DebugLocation (64' 18);  			PushFollow (Follow._filterExpr_in_filterExpr179);  			a = filterExpr ();  			PopFollow ();  			DebugLocation (64' 31);  			PushFollow (Follow._filterExpr_in_filterExpr183);  			b = filterExpr ();  			PopFollow ();  			Match (input' TokenTypes.Up' null);  			DebugLocation (65' 4);  			Comparator newComparator;  			switch (comparator6) {  			case "=":  				newComparator = Comparator.Equals;  				break;  			case "!=":  				newComparator = Comparator.NotEquals;  				break;  			case ">":  				newComparator = Comparator.Greater;  				break;  			case "<":  				newComparator = Comparator.Less;  				break;  			case ">=":  				newComparator = Comparator.GreaterOrEqual;  				break;  			case "<=":  				newComparator = Comparator.LessOrEqual;  				break;  			case "&":  				newComparator = Comparator.And;  				break;  			case "|":  				newComparator = Comparator.Or;  				break;  			default:  				newComparator = Comparator.Equals;  				break;  			}  			filterNode = new BoolExpression (a' newComparator' b);  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  		{  			DebugLocation (98' 4);  			DebugLocation (98' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr195);  			Match (input' TokenTypes.Down' null);  			DebugLocation (98' 12);  			PushFollow (Follow._filterExpr_in_filterExpr199);  			f = filterExpr ();  			PopFollow ();  			DebugLocation (98' 31);  			// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  			int alt6 = 2;  			try {  				DebugEnterSubRule (6);  				try {  					DebugEnterDecision (6' false);  					int LA6_1 = input.LA (1);  					if ((LA6_1 == 24)) {  						alt6 = 1;  					}  				}  				finally {  					DebugExitDecision (6);  				}  				switch (alt6) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  					{  						DebugLocation (98' 31);  						inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (6);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (99' 4);  			FilterTreeNode newNode = f;  			if ((inverse != null ? inverse.Text : default(string)) == "!")  				newNode.ToggleInversed ();  			filterNode = newNode;  		}  		break;  	case 3:  		DebugEnterAlt (3);  		// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  		{  			DebugLocation (105' 4);  			DebugLocation (105' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr216);  			Match (input' TokenTypes.Down' null);  			DebugLocation (105' 12);  			PushFollow (Follow._propertyChain_in_filterExpr219);  			propertyChain (propertySegments);  			PopFollow ();  			DebugLocation (105' 51);  			// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  			int alt7 = 2;  			try {  				DebugEnterSubRule (7);  				try {  					DebugEnterDecision (7' false);  					int LA7_1 = input.LA (1);  					if ((LA7_1 == 31)) {  						alt7 = 1;  					}  				}  				finally {  					DebugExitDecision (7);  				}  				switch (alt7) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  					{  						DebugLocation (105' 51);  						inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (7);  			}  			DebugLocation (105' 60);  			// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  			int alt8 = 2;  			try {  				DebugEnterSubRule (8);  				try {  					DebugEnterDecision (8' false);  					int LA8_1 = input.LA (1);  					if ((LA8_1 == 24)) {  						alt8 = 1;  					}  				}  				finally {  					DebugExitDecision (8);  				}  				switch (alt8) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  					{  						DebugLocation (105' 60);  						not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (8);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (106' 4);  			FilterTreeNode newProperty = new Property (propertySegments);  			if ((inverse != null ? inverse.Text : default(string)) == "?")  				filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  			else {  				if ((not != null ? not.Text : default(string)) == "!")  					newProperty.ToggleInversed ();  				filterNode = newProperty;  			}  		}  		break;  	case 4:  		DebugEnterAlt (4);  		// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  		{  			DebugLocation (116' 4);  			STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  			DebugLocation (117' 4);  			string stringText = (STRING7 != null ? STRING7.Text : default(string));  			stringText = stringText.Substring (1' stringText.Length - 2);  			filterNode = new Value (stringText);  		}  		break;  	case 5:  		DebugEnterAlt (5);  		// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  		{  			DebugLocation (122' 4);  			REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  			DebugLocation (123' 4);  			string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  			regexText = regexText.Substring (1' regexText.Length - 2);  			filterNode = new RegExp (regexText);  		}  		break;  	case 6:  		DebugEnterAlt (6);  		// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  		{  			DebugLocation (128' 4);  			NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  			DebugLocation (129' 4);  			filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  		}  		break;  	case 7:  		DebugEnterAlt (7);  		// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  		{  			DebugLocation (132' 4);  			Match (input' TRUE' Follow._TRUE_in_filterExpr271);  			DebugLocation (133' 4);  			filterNode = new Value (true);  		}  		break;  	case 8:  		DebugEnterAlt (8);  		// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  		{  			DebugLocation (136' 4);  			Match (input' FALSE' Follow._FALSE_in_filterExpr281);  			DebugLocation (137' 4);  			filterNode = new Value (false);  		}  		break;  	case 9:  		DebugEnterAlt (9);  		// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  		{  			DebugLocation (140' 4);  			Match (input' NULL' Follow._NULL_in_filterExpr291);  			DebugLocation (141' 4);  			filterNode = new Value (null);  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("filterExpr"' 6);  	LeaveRule ("filterExpr"' 6);  	LeaveRule_filterExpr ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  	int alt9 = 9;  	try {  		DebugEnterDecision (9' false);  		switch (input.LA (1)) {  		case CHAIN_OPERATOR:  		case COMPARATOR:  			{  				alt9 = 1;  			}  			break;  		case EXPR:  			{  				int LA9_2 = input.LA (2);  				if ((LA9_2 == DOWN)) {  					int LA9_3 = input.LA (3);  					if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  						alt9 = 2;  					}  					else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  						alt9 = 3;  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				else {  					NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  					DebugRecognitionException (nvae);  					throw nvae;  				}  			}  			break;  		case STRING:  			{  				alt9 = 4;  			}  			break;  		case REGEX:  			{  				alt9 = 5;  			}  			break;  		case NUMBER:  			{  				alt9 = 6;  			}  			break;  		case TRUE:  			{  				alt9 = 7;  			}  			break;  		case FALSE:  			{  				alt9 = 8;  			}  			break;  		case NULL:  			{  				alt9 = 9;  			}  			break;  		default: {  			NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  		}  	}  	finally {  		DebugExitDecision (9);  	}  	switch (alt9) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  		{  			DebugLocation (64' 4);  			DebugLocation (64' 6);  			PushFollow (Follow._comparator_in_filterExpr175);  			comparator6 = comparator ();  			PopFollow ();  			Match (input' TokenTypes.Down' null);  			DebugLocation (64' 18);  			PushFollow (Follow._filterExpr_in_filterExpr179);  			a = filterExpr ();  			PopFollow ();  			DebugLocation (64' 31);  			PushFollow (Follow._filterExpr_in_filterExpr183);  			b = filterExpr ();  			PopFollow ();  			Match (input' TokenTypes.Up' null);  			DebugLocation (65' 4);  			Comparator newComparator;  			switch (comparator6) {  			case "=":  				newComparator = Comparator.Equals;  				break;  			case "!=":  				newComparator = Comparator.NotEquals;  				break;  			case ">":  				newComparator = Comparator.Greater;  				break;  			case "<":  				newComparator = Comparator.Less;  				break;  			case ">=":  				newComparator = Comparator.GreaterOrEqual;  				break;  			case "<=":  				newComparator = Comparator.LessOrEqual;  				break;  			case "&":  				newComparator = Comparator.And;  				break;  			case "|":  				newComparator = Comparator.Or;  				break;  			default:  				newComparator = Comparator.Equals;  				break;  			}  			filterNode = new BoolExpression (a' newComparator' b);  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  		{  			DebugLocation (98' 4);  			DebugLocation (98' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr195);  			Match (input' TokenTypes.Down' null);  			DebugLocation (98' 12);  			PushFollow (Follow._filterExpr_in_filterExpr199);  			f = filterExpr ();  			PopFollow ();  			DebugLocation (98' 31);  			// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  			int alt6 = 2;  			try {  				DebugEnterSubRule (6);  				try {  					DebugEnterDecision (6' false);  					int LA6_1 = input.LA (1);  					if ((LA6_1 == 24)) {  						alt6 = 1;  					}  				}  				finally {  					DebugExitDecision (6);  				}  				switch (alt6) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  					{  						DebugLocation (98' 31);  						inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (6);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (99' 4);  			FilterTreeNode newNode = f;  			if ((inverse != null ? inverse.Text : default(string)) == "!")  				newNode.ToggleInversed ();  			filterNode = newNode;  		}  		break;  	case 3:  		DebugEnterAlt (3);  		// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  		{  			DebugLocation (105' 4);  			DebugLocation (105' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr216);  			Match (input' TokenTypes.Down' null);  			DebugLocation (105' 12);  			PushFollow (Follow._propertyChain_in_filterExpr219);  			propertyChain (propertySegments);  			PopFollow ();  			DebugLocation (105' 51);  			// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  			int alt7 = 2;  			try {  				DebugEnterSubRule (7);  				try {  					DebugEnterDecision (7' false);  					int LA7_1 = input.LA (1);  					if ((LA7_1 == 31)) {  						alt7 = 1;  					}  				}  				finally {  					DebugExitDecision (7);  				}  				switch (alt7) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  					{  						DebugLocation (105' 51);  						inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (7);  			}  			DebugLocation (105' 60);  			// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  			int alt8 = 2;  			try {  				DebugEnterSubRule (8);  				try {  					DebugEnterDecision (8' false);  					int LA8_1 = input.LA (1);  					if ((LA8_1 == 24)) {  						alt8 = 1;  					}  				}  				finally {  					DebugExitDecision (8);  				}  				switch (alt8) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  					{  						DebugLocation (105' 60);  						not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (8);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (106' 4);  			FilterTreeNode newProperty = new Property (propertySegments);  			if ((inverse != null ? inverse.Text : default(string)) == "?")  				filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  			else {  				if ((not != null ? not.Text : default(string)) == "!")  					newProperty.ToggleInversed ();  				filterNode = newProperty;  			}  		}  		break;  	case 4:  		DebugEnterAlt (4);  		// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  		{  			DebugLocation (116' 4);  			STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  			DebugLocation (117' 4);  			string stringText = (STRING7 != null ? STRING7.Text : default(string));  			stringText = stringText.Substring (1' stringText.Length - 2);  			filterNode = new Value (stringText);  		}  		break;  	case 5:  		DebugEnterAlt (5);  		// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  		{  			DebugLocation (122' 4);  			REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  			DebugLocation (123' 4);  			string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  			regexText = regexText.Substring (1' regexText.Length - 2);  			filterNode = new RegExp (regexText);  		}  		break;  	case 6:  		DebugEnterAlt (6);  		// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  		{  			DebugLocation (128' 4);  			NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  			DebugLocation (129' 4);  			filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  		}  		break;  	case 7:  		DebugEnterAlt (7);  		// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  		{  			DebugLocation (132' 4);  			Match (input' TRUE' Follow._TRUE_in_filterExpr271);  			DebugLocation (133' 4);  			filterNode = new Value (true);  		}  		break;  	case 8:  		DebugEnterAlt (8);  		// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  		{  			DebugLocation (136' 4);  			Match (input' FALSE' Follow._FALSE_in_filterExpr281);  			DebugLocation (137' 4);  			filterNode = new Value (false);  		}  		break;  	case 9:  		DebugEnterAlt (9);  		// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  		{  			DebugLocation (140' 4);  			Match (input' NULL' Follow._NULL_in_filterExpr291);  			DebugLocation (141' 4);  			filterNode = new Value (null);  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("filterExpr"' 6);  	LeaveRule ("filterExpr"' 6);  	LeaveRule_filterExpr ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  	int alt9 = 9;  	try {  		DebugEnterDecision (9' false);  		switch (input.LA (1)) {  		case CHAIN_OPERATOR:  		case COMPARATOR:  			{  				alt9 = 1;  			}  			break;  		case EXPR:  			{  				int LA9_2 = input.LA (2);  				if ((LA9_2 == DOWN)) {  					int LA9_3 = input.LA (3);  					if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  						alt9 = 2;  					}  					else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  						alt9 = 3;  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				else {  					NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  					DebugRecognitionException (nvae);  					throw nvae;  				}  			}  			break;  		case STRING:  			{  				alt9 = 4;  			}  			break;  		case REGEX:  			{  				alt9 = 5;  			}  			break;  		case NUMBER:  			{  				alt9 = 6;  			}  			break;  		case TRUE:  			{  				alt9 = 7;  			}  			break;  		case FALSE:  			{  				alt9 = 8;  			}  			break;  		case NULL:  			{  				alt9 = 9;  			}  			break;  		default: {  			NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  		}  	}  	finally {  		DebugExitDecision (9);  	}  	switch (alt9) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  		{  			DebugLocation (64' 4);  			DebugLocation (64' 6);  			PushFollow (Follow._comparator_in_filterExpr175);  			comparator6 = comparator ();  			PopFollow ();  			Match (input' TokenTypes.Down' null);  			DebugLocation (64' 18);  			PushFollow (Follow._filterExpr_in_filterExpr179);  			a = filterExpr ();  			PopFollow ();  			DebugLocation (64' 31);  			PushFollow (Follow._filterExpr_in_filterExpr183);  			b = filterExpr ();  			PopFollow ();  			Match (input' TokenTypes.Up' null);  			DebugLocation (65' 4);  			Comparator newComparator;  			switch (comparator6) {  			case "=":  				newComparator = Comparator.Equals;  				break;  			case "!=":  				newComparator = Comparator.NotEquals;  				break;  			case ">":  				newComparator = Comparator.Greater;  				break;  			case "<":  				newComparator = Comparator.Less;  				break;  			case ">=":  				newComparator = Comparator.GreaterOrEqual;  				break;  			case "<=":  				newComparator = Comparator.LessOrEqual;  				break;  			case "&":  				newComparator = Comparator.And;  				break;  			case "|":  				newComparator = Comparator.Or;  				break;  			default:  				newComparator = Comparator.Equals;  				break;  			}  			filterNode = new BoolExpression (a' newComparator' b);  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  		{  			DebugLocation (98' 4);  			DebugLocation (98' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr195);  			Match (input' TokenTypes.Down' null);  			DebugLocation (98' 12);  			PushFollow (Follow._filterExpr_in_filterExpr199);  			f = filterExpr ();  			PopFollow ();  			DebugLocation (98' 31);  			// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  			int alt6 = 2;  			try {  				DebugEnterSubRule (6);  				try {  					DebugEnterDecision (6' false);  					int LA6_1 = input.LA (1);  					if ((LA6_1 == 24)) {  						alt6 = 1;  					}  				}  				finally {  					DebugExitDecision (6);  				}  				switch (alt6) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  					{  						DebugLocation (98' 31);  						inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (6);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (99' 4);  			FilterTreeNode newNode = f;  			if ((inverse != null ? inverse.Text : default(string)) == "!")  				newNode.ToggleInversed ();  			filterNode = newNode;  		}  		break;  	case 3:  		DebugEnterAlt (3);  		// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  		{  			DebugLocation (105' 4);  			DebugLocation (105' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr216);  			Match (input' TokenTypes.Down' null);  			DebugLocation (105' 12);  			PushFollow (Follow._propertyChain_in_filterExpr219);  			propertyChain (propertySegments);  			PopFollow ();  			DebugLocation (105' 51);  			// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  			int alt7 = 2;  			try {  				DebugEnterSubRule (7);  				try {  					DebugEnterDecision (7' false);  					int LA7_1 = input.LA (1);  					if ((LA7_1 == 31)) {  						alt7 = 1;  					}  				}  				finally {  					DebugExitDecision (7);  				}  				switch (alt7) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  					{  						DebugLocation (105' 51);  						inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (7);  			}  			DebugLocation (105' 60);  			// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  			int alt8 = 2;  			try {  				DebugEnterSubRule (8);  				try {  					DebugEnterDecision (8' false);  					int LA8_1 = input.LA (1);  					if ((LA8_1 == 24)) {  						alt8 = 1;  					}  				}  				finally {  					DebugExitDecision (8);  				}  				switch (alt8) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  					{  						DebugLocation (105' 60);  						not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (8);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (106' 4);  			FilterTreeNode newProperty = new Property (propertySegments);  			if ((inverse != null ? inverse.Text : default(string)) == "?")  				filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  			else {  				if ((not != null ? not.Text : default(string)) == "!")  					newProperty.ToggleInversed ();  				filterNode = newProperty;  			}  		}  		break;  	case 4:  		DebugEnterAlt (4);  		// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  		{  			DebugLocation (116' 4);  			STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  			DebugLocation (117' 4);  			string stringText = (STRING7 != null ? STRING7.Text : default(string));  			stringText = stringText.Substring (1' stringText.Length - 2);  			filterNode = new Value (stringText);  		}  		break;  	case 5:  		DebugEnterAlt (5);  		// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  		{  			DebugLocation (122' 4);  			REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  			DebugLocation (123' 4);  			string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  			regexText = regexText.Substring (1' regexText.Length - 2);  			filterNode = new RegExp (regexText);  		}  		break;  	case 6:  		DebugEnterAlt (6);  		// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  		{  			DebugLocation (128' 4);  			NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  			DebugLocation (129' 4);  			filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  		}  		break;  	case 7:  		DebugEnterAlt (7);  		// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  		{  			DebugLocation (132' 4);  			Match (input' TRUE' Follow._TRUE_in_filterExpr271);  			DebugLocation (133' 4);  			filterNode = new Value (true);  		}  		break;  	case 8:  		DebugEnterAlt (8);  		// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  		{  			DebugLocation (136' 4);  			Match (input' FALSE' Follow._FALSE_in_filterExpr281);  			DebugLocation (137' 4);  			filterNode = new Value (false);  		}  		break;  	case 9:  		DebugEnterAlt (9);  		// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  		{  			DebugLocation (140' 4);  			Match (input' NULL' Follow._NULL_in_filterExpr291);  			DebugLocation (141' 4);  			filterNode = new Value (null);  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("filterExpr"' 6);  	LeaveRule ("filterExpr"' 6);  	LeaveRule_filterExpr ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  	int alt9 = 9;  	try {  		DebugEnterDecision (9' false);  		switch (input.LA (1)) {  		case CHAIN_OPERATOR:  		case COMPARATOR:  			{  				alt9 = 1;  			}  			break;  		case EXPR:  			{  				int LA9_2 = input.LA (2);  				if ((LA9_2 == DOWN)) {  					int LA9_3 = input.LA (3);  					if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  						alt9 = 2;  					}  					else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  						alt9 = 3;  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				else {  					NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  					DebugRecognitionException (nvae);  					throw nvae;  				}  			}  			break;  		case STRING:  			{  				alt9 = 4;  			}  			break;  		case REGEX:  			{  				alt9 = 5;  			}  			break;  		case NUMBER:  			{  				alt9 = 6;  			}  			break;  		case TRUE:  			{  				alt9 = 7;  			}  			break;  		case FALSE:  			{  				alt9 = 8;  			}  			break;  		case NULL:  			{  				alt9 = 9;  			}  			break;  		default: {  			NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  		}  	}  	finally {  		DebugExitDecision (9);  	}  	switch (alt9) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  		{  			DebugLocation (64' 4);  			DebugLocation (64' 6);  			PushFollow (Follow._comparator_in_filterExpr175);  			comparator6 = comparator ();  			PopFollow ();  			Match (input' TokenTypes.Down' null);  			DebugLocation (64' 18);  			PushFollow (Follow._filterExpr_in_filterExpr179);  			a = filterExpr ();  			PopFollow ();  			DebugLocation (64' 31);  			PushFollow (Follow._filterExpr_in_filterExpr183);  			b = filterExpr ();  			PopFollow ();  			Match (input' TokenTypes.Up' null);  			DebugLocation (65' 4);  			Comparator newComparator;  			switch (comparator6) {  			case "=":  				newComparator = Comparator.Equals;  				break;  			case "!=":  				newComparator = Comparator.NotEquals;  				break;  			case ">":  				newComparator = Comparator.Greater;  				break;  			case "<":  				newComparator = Comparator.Less;  				break;  			case ">=":  				newComparator = Comparator.GreaterOrEqual;  				break;  			case "<=":  				newComparator = Comparator.LessOrEqual;  				break;  			case "&":  				newComparator = Comparator.And;  				break;  			case "|":  				newComparator = Comparator.Or;  				break;  			default:  				newComparator = Comparator.Equals;  				break;  			}  			filterNode = new BoolExpression (a' newComparator' b);  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  		{  			DebugLocation (98' 4);  			DebugLocation (98' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr195);  			Match (input' TokenTypes.Down' null);  			DebugLocation (98' 12);  			PushFollow (Follow._filterExpr_in_filterExpr199);  			f = filterExpr ();  			PopFollow ();  			DebugLocation (98' 31);  			// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  			int alt6 = 2;  			try {  				DebugEnterSubRule (6);  				try {  					DebugEnterDecision (6' false);  					int LA6_1 = input.LA (1);  					if ((LA6_1 == 24)) {  						alt6 = 1;  					}  				}  				finally {  					DebugExitDecision (6);  				}  				switch (alt6) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  					{  						DebugLocation (98' 31);  						inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (6);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (99' 4);  			FilterTreeNode newNode = f;  			if ((inverse != null ? inverse.Text : default(string)) == "!")  				newNode.ToggleInversed ();  			filterNode = newNode;  		}  		break;  	case 3:  		DebugEnterAlt (3);  		// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  		{  			DebugLocation (105' 4);  			DebugLocation (105' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr216);  			Match (input' TokenTypes.Down' null);  			DebugLocation (105' 12);  			PushFollow (Follow._propertyChain_in_filterExpr219);  			propertyChain (propertySegments);  			PopFollow ();  			DebugLocation (105' 51);  			// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  			int alt7 = 2;  			try {  				DebugEnterSubRule (7);  				try {  					DebugEnterDecision (7' false);  					int LA7_1 = input.LA (1);  					if ((LA7_1 == 31)) {  						alt7 = 1;  					}  				}  				finally {  					DebugExitDecision (7);  				}  				switch (alt7) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  					{  						DebugLocation (105' 51);  						inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (7);  			}  			DebugLocation (105' 60);  			// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  			int alt8 = 2;  			try {  				DebugEnterSubRule (8);  				try {  					DebugEnterDecision (8' false);  					int LA8_1 = input.LA (1);  					if ((LA8_1 == 24)) {  						alt8 = 1;  					}  				}  				finally {  					DebugExitDecision (8);  				}  				switch (alt8) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  					{  						DebugLocation (105' 60);  						not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (8);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (106' 4);  			FilterTreeNode newProperty = new Property (propertySegments);  			if ((inverse != null ? inverse.Text : default(string)) == "?")  				filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  			else {  				if ((not != null ? not.Text : default(string)) == "!")  					newProperty.ToggleInversed ();  				filterNode = newProperty;  			}  		}  		break;  	case 4:  		DebugEnterAlt (4);  		// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  		{  			DebugLocation (116' 4);  			STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  			DebugLocation (117' 4);  			string stringText = (STRING7 != null ? STRING7.Text : default(string));  			stringText = stringText.Substring (1' stringText.Length - 2);  			filterNode = new Value (stringText);  		}  		break;  	case 5:  		DebugEnterAlt (5);  		// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  		{  			DebugLocation (122' 4);  			REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  			DebugLocation (123' 4);  			string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  			regexText = regexText.Substring (1' regexText.Length - 2);  			filterNode = new RegExp (regexText);  		}  		break;  	case 6:  		DebugEnterAlt (6);  		// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  		{  			DebugLocation (128' 4);  			NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  			DebugLocation (129' 4);  			filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  		}  		break;  	case 7:  		DebugEnterAlt (7);  		// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  		{  			DebugLocation (132' 4);  			Match (input' TRUE' Follow._TRUE_in_filterExpr271);  			DebugLocation (133' 4);  			filterNode = new Value (true);  		}  		break;  	case 8:  		DebugEnterAlt (8);  		// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  		{  			DebugLocation (136' 4);  			Match (input' FALSE' Follow._FALSE_in_filterExpr281);  			DebugLocation (137' 4);  			filterNode = new Value (false);  		}  		break;  	case 9:  		DebugEnterAlt (9);  		// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  		{  			DebugLocation (140' 4);  			Match (input' NULL' Follow._NULL_in_filterExpr291);  			DebugLocation (141' 4);  			filterNode = new Value (null);  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("filterExpr"' 6);  	LeaveRule ("filterExpr"' 6);  	LeaveRule_filterExpr ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  	int alt9 = 9;  	try {  		DebugEnterDecision (9' false);  		switch (input.LA (1)) {  		case CHAIN_OPERATOR:  		case COMPARATOR:  			{  				alt9 = 1;  			}  			break;  		case EXPR:  			{  				int LA9_2 = input.LA (2);  				if ((LA9_2 == DOWN)) {  					int LA9_3 = input.LA (3);  					if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  						alt9 = 2;  					}  					else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  						alt9 = 3;  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				else {  					NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  					DebugRecognitionException (nvae);  					throw nvae;  				}  			}  			break;  		case STRING:  			{  				alt9 = 4;  			}  			break;  		case REGEX:  			{  				alt9 = 5;  			}  			break;  		case NUMBER:  			{  				alt9 = 6;  			}  			break;  		case TRUE:  			{  				alt9 = 7;  			}  			break;  		case FALSE:  			{  				alt9 = 8;  			}  			break;  		case NULL:  			{  				alt9 = 9;  			}  			break;  		default: {  			NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  		}  	}  	finally {  		DebugExitDecision (9);  	}  	switch (alt9) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  		{  			DebugLocation (64' 4);  			DebugLocation (64' 6);  			PushFollow (Follow._comparator_in_filterExpr175);  			comparator6 = comparator ();  			PopFollow ();  			Match (input' TokenTypes.Down' null);  			DebugLocation (64' 18);  			PushFollow (Follow._filterExpr_in_filterExpr179);  			a = filterExpr ();  			PopFollow ();  			DebugLocation (64' 31);  			PushFollow (Follow._filterExpr_in_filterExpr183);  			b = filterExpr ();  			PopFollow ();  			Match (input' TokenTypes.Up' null);  			DebugLocation (65' 4);  			Comparator newComparator;  			switch (comparator6) {  			case "=":  				newComparator = Comparator.Equals;  				break;  			case "!=":  				newComparator = Comparator.NotEquals;  				break;  			case ">":  				newComparator = Comparator.Greater;  				break;  			case "<":  				newComparator = Comparator.Less;  				break;  			case ">=":  				newComparator = Comparator.GreaterOrEqual;  				break;  			case "<=":  				newComparator = Comparator.LessOrEqual;  				break;  			case "&":  				newComparator = Comparator.And;  				break;  			case "|":  				newComparator = Comparator.Or;  				break;  			default:  				newComparator = Comparator.Equals;  				break;  			}  			filterNode = new BoolExpression (a' newComparator' b);  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  		{  			DebugLocation (98' 4);  			DebugLocation (98' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr195);  			Match (input' TokenTypes.Down' null);  			DebugLocation (98' 12);  			PushFollow (Follow._filterExpr_in_filterExpr199);  			f = filterExpr ();  			PopFollow ();  			DebugLocation (98' 31);  			// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  			int alt6 = 2;  			try {  				DebugEnterSubRule (6);  				try {  					DebugEnterDecision (6' false);  					int LA6_1 = input.LA (1);  					if ((LA6_1 == 24)) {  						alt6 = 1;  					}  				}  				finally {  					DebugExitDecision (6);  				}  				switch (alt6) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  					{  						DebugLocation (98' 31);  						inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (6);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (99' 4);  			FilterTreeNode newNode = f;  			if ((inverse != null ? inverse.Text : default(string)) == "!")  				newNode.ToggleInversed ();  			filterNode = newNode;  		}  		break;  	case 3:  		DebugEnterAlt (3);  		// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  		{  			DebugLocation (105' 4);  			DebugLocation (105' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr216);  			Match (input' TokenTypes.Down' null);  			DebugLocation (105' 12);  			PushFollow (Follow._propertyChain_in_filterExpr219);  			propertyChain (propertySegments);  			PopFollow ();  			DebugLocation (105' 51);  			// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  			int alt7 = 2;  			try {  				DebugEnterSubRule (7);  				try {  					DebugEnterDecision (7' false);  					int LA7_1 = input.LA (1);  					if ((LA7_1 == 31)) {  						alt7 = 1;  					}  				}  				finally {  					DebugExitDecision (7);  				}  				switch (alt7) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  					{  						DebugLocation (105' 51);  						inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (7);  			}  			DebugLocation (105' 60);  			// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  			int alt8 = 2;  			try {  				DebugEnterSubRule (8);  				try {  					DebugEnterDecision (8' false);  					int LA8_1 = input.LA (1);  					if ((LA8_1 == 24)) {  						alt8 = 1;  					}  				}  				finally {  					DebugExitDecision (8);  				}  				switch (alt8) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  					{  						DebugLocation (105' 60);  						not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (8);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (106' 4);  			FilterTreeNode newProperty = new Property (propertySegments);  			if ((inverse != null ? inverse.Text : default(string)) == "?")  				filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  			else {  				if ((not != null ? not.Text : default(string)) == "!")  					newProperty.ToggleInversed ();  				filterNode = newProperty;  			}  		}  		break;  	case 4:  		DebugEnterAlt (4);  		// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  		{  			DebugLocation (116' 4);  			STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  			DebugLocation (117' 4);  			string stringText = (STRING7 != null ? STRING7.Text : default(string));  			stringText = stringText.Substring (1' stringText.Length - 2);  			filterNode = new Value (stringText);  		}  		break;  	case 5:  		DebugEnterAlt (5);  		// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  		{  			DebugLocation (122' 4);  			REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  			DebugLocation (123' 4);  			string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  			regexText = regexText.Substring (1' regexText.Length - 2);  			filterNode = new RegExp (regexText);  		}  		break;  	case 6:  		DebugEnterAlt (6);  		// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  		{  			DebugLocation (128' 4);  			NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  			DebugLocation (129' 4);  			filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  		}  		break;  	case 7:  		DebugEnterAlt (7);  		// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  		{  			DebugLocation (132' 4);  			Match (input' TRUE' Follow._TRUE_in_filterExpr271);  			DebugLocation (133' 4);  			filterNode = new Value (true);  		}  		break;  	case 8:  		DebugEnterAlt (8);  		// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  		{  			DebugLocation (136' 4);  			Match (input' FALSE' Follow._FALSE_in_filterExpr281);  			DebugLocation (137' 4);  			filterNode = new Value (false);  		}  		break;  	case 9:  		DebugEnterAlt (9);  		// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  		{  			DebugLocation (140' 4);  			Match (input' NULL' Follow._NULL_in_filterExpr291);  			DebugLocation (141' 4);  			filterNode = new Value (null);  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("filterExpr"' 6);  	LeaveRule ("filterExpr"' 6);  	LeaveRule_filterExpr ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  	int alt9 = 9;  	try {  		DebugEnterDecision (9' false);  		switch (input.LA (1)) {  		case CHAIN_OPERATOR:  		case COMPARATOR:  			{  				alt9 = 1;  			}  			break;  		case EXPR:  			{  				int LA9_2 = input.LA (2);  				if ((LA9_2 == DOWN)) {  					int LA9_3 = input.LA (3);  					if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  						alt9 = 2;  					}  					else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  						alt9 = 3;  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				else {  					NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  					DebugRecognitionException (nvae);  					throw nvae;  				}  			}  			break;  		case STRING:  			{  				alt9 = 4;  			}  			break;  		case REGEX:  			{  				alt9 = 5;  			}  			break;  		case NUMBER:  			{  				alt9 = 6;  			}  			break;  		case TRUE:  			{  				alt9 = 7;  			}  			break;  		case FALSE:  			{  				alt9 = 8;  			}  			break;  		case NULL:  			{  				alt9 = 9;  			}  			break;  		default: {  			NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  		}  	}  	finally {  		DebugExitDecision (9);  	}  	switch (alt9) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  		{  			DebugLocation (64' 4);  			DebugLocation (64' 6);  			PushFollow (Follow._comparator_in_filterExpr175);  			comparator6 = comparator ();  			PopFollow ();  			Match (input' TokenTypes.Down' null);  			DebugLocation (64' 18);  			PushFollow (Follow._filterExpr_in_filterExpr179);  			a = filterExpr ();  			PopFollow ();  			DebugLocation (64' 31);  			PushFollow (Follow._filterExpr_in_filterExpr183);  			b = filterExpr ();  			PopFollow ();  			Match (input' TokenTypes.Up' null);  			DebugLocation (65' 4);  			Comparator newComparator;  			switch (comparator6) {  			case "=":  				newComparator = Comparator.Equals;  				break;  			case "!=":  				newComparator = Comparator.NotEquals;  				break;  			case ">":  				newComparator = Comparator.Greater;  				break;  			case "<":  				newComparator = Comparator.Less;  				break;  			case ">=":  				newComparator = Comparator.GreaterOrEqual;  				break;  			case "<=":  				newComparator = Comparator.LessOrEqual;  				break;  			case "&":  				newComparator = Comparator.And;  				break;  			case "|":  				newComparator = Comparator.Or;  				break;  			default:  				newComparator = Comparator.Equals;  				break;  			}  			filterNode = new BoolExpression (a' newComparator' b);  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  		{  			DebugLocation (98' 4);  			DebugLocation (98' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr195);  			Match (input' TokenTypes.Down' null);  			DebugLocation (98' 12);  			PushFollow (Follow._filterExpr_in_filterExpr199);  			f = filterExpr ();  			PopFollow ();  			DebugLocation (98' 31);  			// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  			int alt6 = 2;  			try {  				DebugEnterSubRule (6);  				try {  					DebugEnterDecision (6' false);  					int LA6_1 = input.LA (1);  					if ((LA6_1 == 24)) {  						alt6 = 1;  					}  				}  				finally {  					DebugExitDecision (6);  				}  				switch (alt6) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  					{  						DebugLocation (98' 31);  						inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (6);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (99' 4);  			FilterTreeNode newNode = f;  			if ((inverse != null ? inverse.Text : default(string)) == "!")  				newNode.ToggleInversed ();  			filterNode = newNode;  		}  		break;  	case 3:  		DebugEnterAlt (3);  		// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  		{  			DebugLocation (105' 4);  			DebugLocation (105' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr216);  			Match (input' TokenTypes.Down' null);  			DebugLocation (105' 12);  			PushFollow (Follow._propertyChain_in_filterExpr219);  			propertyChain (propertySegments);  			PopFollow ();  			DebugLocation (105' 51);  			// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  			int alt7 = 2;  			try {  				DebugEnterSubRule (7);  				try {  					DebugEnterDecision (7' false);  					int LA7_1 = input.LA (1);  					if ((LA7_1 == 31)) {  						alt7 = 1;  					}  				}  				finally {  					DebugExitDecision (7);  				}  				switch (alt7) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  					{  						DebugLocation (105' 51);  						inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (7);  			}  			DebugLocation (105' 60);  			// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  			int alt8 = 2;  			try {  				DebugEnterSubRule (8);  				try {  					DebugEnterDecision (8' false);  					int LA8_1 = input.LA (1);  					if ((LA8_1 == 24)) {  						alt8 = 1;  					}  				}  				finally {  					DebugExitDecision (8);  				}  				switch (alt8) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  					{  						DebugLocation (105' 60);  						not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (8);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (106' 4);  			FilterTreeNode newProperty = new Property (propertySegments);  			if ((inverse != null ? inverse.Text : default(string)) == "?")  				filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  			else {  				if ((not != null ? not.Text : default(string)) == "!")  					newProperty.ToggleInversed ();  				filterNode = newProperty;  			}  		}  		break;  	case 4:  		DebugEnterAlt (4);  		// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  		{  			DebugLocation (116' 4);  			STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  			DebugLocation (117' 4);  			string stringText = (STRING7 != null ? STRING7.Text : default(string));  			stringText = stringText.Substring (1' stringText.Length - 2);  			filterNode = new Value (stringText);  		}  		break;  	case 5:  		DebugEnterAlt (5);  		// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  		{  			DebugLocation (122' 4);  			REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  			DebugLocation (123' 4);  			string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  			regexText = regexText.Substring (1' regexText.Length - 2);  			filterNode = new RegExp (regexText);  		}  		break;  	case 6:  		DebugEnterAlt (6);  		// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  		{  			DebugLocation (128' 4);  			NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  			DebugLocation (129' 4);  			filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  		}  		break;  	case 7:  		DebugEnterAlt (7);  		// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  		{  			DebugLocation (132' 4);  			Match (input' TRUE' Follow._TRUE_in_filterExpr271);  			DebugLocation (133' 4);  			filterNode = new Value (true);  		}  		break;  	case 8:  		DebugEnterAlt (8);  		// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  		{  			DebugLocation (136' 4);  			Match (input' FALSE' Follow._FALSE_in_filterExpr281);  			DebugLocation (137' 4);  			filterNode = new Value (false);  		}  		break;  	case 9:  		DebugEnterAlt (9);  		// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  		{  			DebugLocation (140' 4);  			Match (input' NULL' Follow._NULL_in_filterExpr291);  			DebugLocation (141' 4);  			filterNode = new Value (null);  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("filterExpr"' 6);  	LeaveRule ("filterExpr"' 6);  	LeaveRule_filterExpr ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  	int alt9 = 9;  	try {  		DebugEnterDecision (9' false);  		switch (input.LA (1)) {  		case CHAIN_OPERATOR:  		case COMPARATOR:  			{  				alt9 = 1;  			}  			break;  		case EXPR:  			{  				int LA9_2 = input.LA (2);  				if ((LA9_2 == DOWN)) {  					int LA9_3 = input.LA (3);  					if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  						alt9 = 2;  					}  					else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  						alt9 = 3;  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				else {  					NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  					DebugRecognitionException (nvae);  					throw nvae;  				}  			}  			break;  		case STRING:  			{  				alt9 = 4;  			}  			break;  		case REGEX:  			{  				alt9 = 5;  			}  			break;  		case NUMBER:  			{  				alt9 = 6;  			}  			break;  		case TRUE:  			{  				alt9 = 7;  			}  			break;  		case FALSE:  			{  				alt9 = 8;  			}  			break;  		case NULL:  			{  				alt9 = 9;  			}  			break;  		default: {  			NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  		}  	}  	finally {  		DebugExitDecision (9);  	}  	switch (alt9) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  		{  			DebugLocation (64' 4);  			DebugLocation (64' 6);  			PushFollow (Follow._comparator_in_filterExpr175);  			comparator6 = comparator ();  			PopFollow ();  			Match (input' TokenTypes.Down' null);  			DebugLocation (64' 18);  			PushFollow (Follow._filterExpr_in_filterExpr179);  			a = filterExpr ();  			PopFollow ();  			DebugLocation (64' 31);  			PushFollow (Follow._filterExpr_in_filterExpr183);  			b = filterExpr ();  			PopFollow ();  			Match (input' TokenTypes.Up' null);  			DebugLocation (65' 4);  			Comparator newComparator;  			switch (comparator6) {  			case "=":  				newComparator = Comparator.Equals;  				break;  			case "!=":  				newComparator = Comparator.NotEquals;  				break;  			case ">":  				newComparator = Comparator.Greater;  				break;  			case "<":  				newComparator = Comparator.Less;  				break;  			case ">=":  				newComparator = Comparator.GreaterOrEqual;  				break;  			case "<=":  				newComparator = Comparator.LessOrEqual;  				break;  			case "&":  				newComparator = Comparator.And;  				break;  			case "|":  				newComparator = Comparator.Or;  				break;  			default:  				newComparator = Comparator.Equals;  				break;  			}  			filterNode = new BoolExpression (a' newComparator' b);  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  		{  			DebugLocation (98' 4);  			DebugLocation (98' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr195);  			Match (input' TokenTypes.Down' null);  			DebugLocation (98' 12);  			PushFollow (Follow._filterExpr_in_filterExpr199);  			f = filterExpr ();  			PopFollow ();  			DebugLocation (98' 31);  			// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  			int alt6 = 2;  			try {  				DebugEnterSubRule (6);  				try {  					DebugEnterDecision (6' false);  					int LA6_1 = input.LA (1);  					if ((LA6_1 == 24)) {  						alt6 = 1;  					}  				}  				finally {  					DebugExitDecision (6);  				}  				switch (alt6) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  					{  						DebugLocation (98' 31);  						inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (6);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (99' 4);  			FilterTreeNode newNode = f;  			if ((inverse != null ? inverse.Text : default(string)) == "!")  				newNode.ToggleInversed ();  			filterNode = newNode;  		}  		break;  	case 3:  		DebugEnterAlt (3);  		// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  		{  			DebugLocation (105' 4);  			DebugLocation (105' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr216);  			Match (input' TokenTypes.Down' null);  			DebugLocation (105' 12);  			PushFollow (Follow._propertyChain_in_filterExpr219);  			propertyChain (propertySegments);  			PopFollow ();  			DebugLocation (105' 51);  			// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  			int alt7 = 2;  			try {  				DebugEnterSubRule (7);  				try {  					DebugEnterDecision (7' false);  					int LA7_1 = input.LA (1);  					if ((LA7_1 == 31)) {  						alt7 = 1;  					}  				}  				finally {  					DebugExitDecision (7);  				}  				switch (alt7) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  					{  						DebugLocation (105' 51);  						inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (7);  			}  			DebugLocation (105' 60);  			// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  			int alt8 = 2;  			try {  				DebugEnterSubRule (8);  				try {  					DebugEnterDecision (8' false);  					int LA8_1 = input.LA (1);  					if ((LA8_1 == 24)) {  						alt8 = 1;  					}  				}  				finally {  					DebugExitDecision (8);  				}  				switch (alt8) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  					{  						DebugLocation (105' 60);  						not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (8);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (106' 4);  			FilterTreeNode newProperty = new Property (propertySegments);  			if ((inverse != null ? inverse.Text : default(string)) == "?")  				filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  			else {  				if ((not != null ? not.Text : default(string)) == "!")  					newProperty.ToggleInversed ();  				filterNode = newProperty;  			}  		}  		break;  	case 4:  		DebugEnterAlt (4);  		// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  		{  			DebugLocation (116' 4);  			STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  			DebugLocation (117' 4);  			string stringText = (STRING7 != null ? STRING7.Text : default(string));  			stringText = stringText.Substring (1' stringText.Length - 2);  			filterNode = new Value (stringText);  		}  		break;  	case 5:  		DebugEnterAlt (5);  		// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  		{  			DebugLocation (122' 4);  			REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  			DebugLocation (123' 4);  			string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  			regexText = regexText.Substring (1' regexText.Length - 2);  			filterNode = new RegExp (regexText);  		}  		break;  	case 6:  		DebugEnterAlt (6);  		// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  		{  			DebugLocation (128' 4);  			NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  			DebugLocation (129' 4);  			filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  		}  		break;  	case 7:  		DebugEnterAlt (7);  		// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  		{  			DebugLocation (132' 4);  			Match (input' TRUE' Follow._TRUE_in_filterExpr271);  			DebugLocation (133' 4);  			filterNode = new Value (true);  		}  		break;  	case 8:  		DebugEnterAlt (8);  		// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  		{  			DebugLocation (136' 4);  			Match (input' FALSE' Follow._FALSE_in_filterExpr281);  			DebugLocation (137' 4);  			filterNode = new Value (false);  		}  		break;  	case 9:  		DebugEnterAlt (9);  		// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  		{  			DebugLocation (140' 4);  			Match (input' NULL' Follow._NULL_in_filterExpr291);  			DebugLocation (141' 4);  			filterNode = new Value (null);  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("filterExpr"' 6);  	LeaveRule ("filterExpr"' 6);  	LeaveRule_filterExpr ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  	int alt9 = 9;  	try {  		DebugEnterDecision (9' false);  		switch (input.LA (1)) {  		case CHAIN_OPERATOR:  		case COMPARATOR:  			{  				alt9 = 1;  			}  			break;  		case EXPR:  			{  				int LA9_2 = input.LA (2);  				if ((LA9_2 == DOWN)) {  					int LA9_3 = input.LA (3);  					if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  						alt9 = 2;  					}  					else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  						alt9 = 3;  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				else {  					NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  					DebugRecognitionException (nvae);  					throw nvae;  				}  			}  			break;  		case STRING:  			{  				alt9 = 4;  			}  			break;  		case REGEX:  			{  				alt9 = 5;  			}  			break;  		case NUMBER:  			{  				alt9 = 6;  			}  			break;  		case TRUE:  			{  				alt9 = 7;  			}  			break;  		case FALSE:  			{  				alt9 = 8;  			}  			break;  		case NULL:  			{  				alt9 = 9;  			}  			break;  		default: {  			NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  		}  	}  	finally {  		DebugExitDecision (9);  	}  	switch (alt9) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  		{  			DebugLocation (64' 4);  			DebugLocation (64' 6);  			PushFollow (Follow._comparator_in_filterExpr175);  			comparator6 = comparator ();  			PopFollow ();  			Match (input' TokenTypes.Down' null);  			DebugLocation (64' 18);  			PushFollow (Follow._filterExpr_in_filterExpr179);  			a = filterExpr ();  			PopFollow ();  			DebugLocation (64' 31);  			PushFollow (Follow._filterExpr_in_filterExpr183);  			b = filterExpr ();  			PopFollow ();  			Match (input' TokenTypes.Up' null);  			DebugLocation (65' 4);  			Comparator newComparator;  			switch (comparator6) {  			case "=":  				newComparator = Comparator.Equals;  				break;  			case "!=":  				newComparator = Comparator.NotEquals;  				break;  			case ">":  				newComparator = Comparator.Greater;  				break;  			case "<":  				newComparator = Comparator.Less;  				break;  			case ">=":  				newComparator = Comparator.GreaterOrEqual;  				break;  			case "<=":  				newComparator = Comparator.LessOrEqual;  				break;  			case "&":  				newComparator = Comparator.And;  				break;  			case "|":  				newComparator = Comparator.Or;  				break;  			default:  				newComparator = Comparator.Equals;  				break;  			}  			filterNode = new BoolExpression (a' newComparator' b);  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  		{  			DebugLocation (98' 4);  			DebugLocation (98' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr195);  			Match (input' TokenTypes.Down' null);  			DebugLocation (98' 12);  			PushFollow (Follow._filterExpr_in_filterExpr199);  			f = filterExpr ();  			PopFollow ();  			DebugLocation (98' 31);  			// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  			int alt6 = 2;  			try {  				DebugEnterSubRule (6);  				try {  					DebugEnterDecision (6' false);  					int LA6_1 = input.LA (1);  					if ((LA6_1 == 24)) {  						alt6 = 1;  					}  				}  				finally {  					DebugExitDecision (6);  				}  				switch (alt6) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  					{  						DebugLocation (98' 31);  						inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (6);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (99' 4);  			FilterTreeNode newNode = f;  			if ((inverse != null ? inverse.Text : default(string)) == "!")  				newNode.ToggleInversed ();  			filterNode = newNode;  		}  		break;  	case 3:  		DebugEnterAlt (3);  		// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  		{  			DebugLocation (105' 4);  			DebugLocation (105' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr216);  			Match (input' TokenTypes.Down' null);  			DebugLocation (105' 12);  			PushFollow (Follow._propertyChain_in_filterExpr219);  			propertyChain (propertySegments);  			PopFollow ();  			DebugLocation (105' 51);  			// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  			int alt7 = 2;  			try {  				DebugEnterSubRule (7);  				try {  					DebugEnterDecision (7' false);  					int LA7_1 = input.LA (1);  					if ((LA7_1 == 31)) {  						alt7 = 1;  					}  				}  				finally {  					DebugExitDecision (7);  				}  				switch (alt7) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  					{  						DebugLocation (105' 51);  						inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (7);  			}  			DebugLocation (105' 60);  			// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  			int alt8 = 2;  			try {  				DebugEnterSubRule (8);  				try {  					DebugEnterDecision (8' false);  					int LA8_1 = input.LA (1);  					if ((LA8_1 == 24)) {  						alt8 = 1;  					}  				}  				finally {  					DebugExitDecision (8);  				}  				switch (alt8) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  					{  						DebugLocation (105' 60);  						not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (8);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (106' 4);  			FilterTreeNode newProperty = new Property (propertySegments);  			if ((inverse != null ? inverse.Text : default(string)) == "?")  				filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  			else {  				if ((not != null ? not.Text : default(string)) == "!")  					newProperty.ToggleInversed ();  				filterNode = newProperty;  			}  		}  		break;  	case 4:  		DebugEnterAlt (4);  		// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  		{  			DebugLocation (116' 4);  			STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  			DebugLocation (117' 4);  			string stringText = (STRING7 != null ? STRING7.Text : default(string));  			stringText = stringText.Substring (1' stringText.Length - 2);  			filterNode = new Value (stringText);  		}  		break;  	case 5:  		DebugEnterAlt (5);  		// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  		{  			DebugLocation (122' 4);  			REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  			DebugLocation (123' 4);  			string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  			regexText = regexText.Substring (1' regexText.Length - 2);  			filterNode = new RegExp (regexText);  		}  		break;  	case 6:  		DebugEnterAlt (6);  		// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  		{  			DebugLocation (128' 4);  			NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  			DebugLocation (129' 4);  			filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  		}  		break;  	case 7:  		DebugEnterAlt (7);  		// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  		{  			DebugLocation (132' 4);  			Match (input' TRUE' Follow._TRUE_in_filterExpr271);  			DebugLocation (133' 4);  			filterNode = new Value (true);  		}  		break;  	case 8:  		DebugEnterAlt (8);  		// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  		{  			DebugLocation (136' 4);  			Match (input' FALSE' Follow._FALSE_in_filterExpr281);  			DebugLocation (137' 4);  			filterNode = new Value (false);  		}  		break;  	case 9:  		DebugEnterAlt (9);  		// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  		{  			DebugLocation (140' 4);  			Match (input' NULL' Follow._NULL_in_filterExpr291);  			DebugLocation (141' 4);  			filterNode = new Value (null);  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("filterExpr"' 6);  	LeaveRule ("filterExpr"' 6);  	LeaveRule_filterExpr ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  	int alt9 = 9;  	try {  		DebugEnterDecision (9' false);  		switch (input.LA (1)) {  		case CHAIN_OPERATOR:  		case COMPARATOR:  			{  				alt9 = 1;  			}  			break;  		case EXPR:  			{  				int LA9_2 = input.LA (2);  				if ((LA9_2 == DOWN)) {  					int LA9_3 = input.LA (3);  					if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  						alt9 = 2;  					}  					else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  						alt9 = 3;  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				else {  					NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  					DebugRecognitionException (nvae);  					throw nvae;  				}  			}  			break;  		case STRING:  			{  				alt9 = 4;  			}  			break;  		case REGEX:  			{  				alt9 = 5;  			}  			break;  		case NUMBER:  			{  				alt9 = 6;  			}  			break;  		case TRUE:  			{  				alt9 = 7;  			}  			break;  		case FALSE:  			{  				alt9 = 8;  			}  			break;  		case NULL:  			{  				alt9 = 9;  			}  			break;  		default: {  			NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  		}  	}  	finally {  		DebugExitDecision (9);  	}  	switch (alt9) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  		{  			DebugLocation (64' 4);  			DebugLocation (64' 6);  			PushFollow (Follow._comparator_in_filterExpr175);  			comparator6 = comparator ();  			PopFollow ();  			Match (input' TokenTypes.Down' null);  			DebugLocation (64' 18);  			PushFollow (Follow._filterExpr_in_filterExpr179);  			a = filterExpr ();  			PopFollow ();  			DebugLocation (64' 31);  			PushFollow (Follow._filterExpr_in_filterExpr183);  			b = filterExpr ();  			PopFollow ();  			Match (input' TokenTypes.Up' null);  			DebugLocation (65' 4);  			Comparator newComparator;  			switch (comparator6) {  			case "=":  				newComparator = Comparator.Equals;  				break;  			case "!=":  				newComparator = Comparator.NotEquals;  				break;  			case ">":  				newComparator = Comparator.Greater;  				break;  			case "<":  				newComparator = Comparator.Less;  				break;  			case ">=":  				newComparator = Comparator.GreaterOrEqual;  				break;  			case "<=":  				newComparator = Comparator.LessOrEqual;  				break;  			case "&":  				newComparator = Comparator.And;  				break;  			case "|":  				newComparator = Comparator.Or;  				break;  			default:  				newComparator = Comparator.Equals;  				break;  			}  			filterNode = new BoolExpression (a' newComparator' b);  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  		{  			DebugLocation (98' 4);  			DebugLocation (98' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr195);  			Match (input' TokenTypes.Down' null);  			DebugLocation (98' 12);  			PushFollow (Follow._filterExpr_in_filterExpr199);  			f = filterExpr ();  			PopFollow ();  			DebugLocation (98' 31);  			// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  			int alt6 = 2;  			try {  				DebugEnterSubRule (6);  				try {  					DebugEnterDecision (6' false);  					int LA6_1 = input.LA (1);  					if ((LA6_1 == 24)) {  						alt6 = 1;  					}  				}  				finally {  					DebugExitDecision (6);  				}  				switch (alt6) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  					{  						DebugLocation (98' 31);  						inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (6);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (99' 4);  			FilterTreeNode newNode = f;  			if ((inverse != null ? inverse.Text : default(string)) == "!")  				newNode.ToggleInversed ();  			filterNode = newNode;  		}  		break;  	case 3:  		DebugEnterAlt (3);  		// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  		{  			DebugLocation (105' 4);  			DebugLocation (105' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr216);  			Match (input' TokenTypes.Down' null);  			DebugLocation (105' 12);  			PushFollow (Follow._propertyChain_in_filterExpr219);  			propertyChain (propertySegments);  			PopFollow ();  			DebugLocation (105' 51);  			// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  			int alt7 = 2;  			try {  				DebugEnterSubRule (7);  				try {  					DebugEnterDecision (7' false);  					int LA7_1 = input.LA (1);  					if ((LA7_1 == 31)) {  						alt7 = 1;  					}  				}  				finally {  					DebugExitDecision (7);  				}  				switch (alt7) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  					{  						DebugLocation (105' 51);  						inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (7);  			}  			DebugLocation (105' 60);  			// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  			int alt8 = 2;  			try {  				DebugEnterSubRule (8);  				try {  					DebugEnterDecision (8' false);  					int LA8_1 = input.LA (1);  					if ((LA8_1 == 24)) {  						alt8 = 1;  					}  				}  				finally {  					DebugExitDecision (8);  				}  				switch (alt8) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  					{  						DebugLocation (105' 60);  						not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (8);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (106' 4);  			FilterTreeNode newProperty = new Property (propertySegments);  			if ((inverse != null ? inverse.Text : default(string)) == "?")  				filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  			else {  				if ((not != null ? not.Text : default(string)) == "!")  					newProperty.ToggleInversed ();  				filterNode = newProperty;  			}  		}  		break;  	case 4:  		DebugEnterAlt (4);  		// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  		{  			DebugLocation (116' 4);  			STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  			DebugLocation (117' 4);  			string stringText = (STRING7 != null ? STRING7.Text : default(string));  			stringText = stringText.Substring (1' stringText.Length - 2);  			filterNode = new Value (stringText);  		}  		break;  	case 5:  		DebugEnterAlt (5);  		// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  		{  			DebugLocation (122' 4);  			REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  			DebugLocation (123' 4);  			string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  			regexText = regexText.Substring (1' regexText.Length - 2);  			filterNode = new RegExp (regexText);  		}  		break;  	case 6:  		DebugEnterAlt (6);  		// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  		{  			DebugLocation (128' 4);  			NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  			DebugLocation (129' 4);  			filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  		}  		break;  	case 7:  		DebugEnterAlt (7);  		// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  		{  			DebugLocation (132' 4);  			Match (input' TRUE' Follow._TRUE_in_filterExpr271);  			DebugLocation (133' 4);  			filterNode = new Value (true);  		}  		break;  	case 8:  		DebugEnterAlt (8);  		// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  		{  			DebugLocation (136' 4);  			Match (input' FALSE' Follow._FALSE_in_filterExpr281);  			DebugLocation (137' 4);  			filterNode = new Value (false);  		}  		break;  	case 9:  		DebugEnterAlt (9);  		// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  		{  			DebugLocation (140' 4);  			Match (input' NULL' Follow._NULL_in_filterExpr291);  			DebugLocation (141' 4);  			filterNode = new Value (null);  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("filterExpr"' 6);  	LeaveRule ("filterExpr"' 6);  	LeaveRule_filterExpr ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  	int alt9 = 9;  	try {  		DebugEnterDecision (9' false);  		switch (input.LA (1)) {  		case CHAIN_OPERATOR:  		case COMPARATOR:  			{  				alt9 = 1;  			}  			break;  		case EXPR:  			{  				int LA9_2 = input.LA (2);  				if ((LA9_2 == DOWN)) {  					int LA9_3 = input.LA (3);  					if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  						alt9 = 2;  					}  					else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  						alt9 = 3;  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				else {  					NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  					DebugRecognitionException (nvae);  					throw nvae;  				}  			}  			break;  		case STRING:  			{  				alt9 = 4;  			}  			break;  		case REGEX:  			{  				alt9 = 5;  			}  			break;  		case NUMBER:  			{  				alt9 = 6;  			}  			break;  		case TRUE:  			{  				alt9 = 7;  			}  			break;  		case FALSE:  			{  				alt9 = 8;  			}  			break;  		case NULL:  			{  				alt9 = 9;  			}  			break;  		default: {  			NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  		}  	}  	finally {  		DebugExitDecision (9);  	}  	switch (alt9) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  		{  			DebugLocation (64' 4);  			DebugLocation (64' 6);  			PushFollow (Follow._comparator_in_filterExpr175);  			comparator6 = comparator ();  			PopFollow ();  			Match (input' TokenTypes.Down' null);  			DebugLocation (64' 18);  			PushFollow (Follow._filterExpr_in_filterExpr179);  			a = filterExpr ();  			PopFollow ();  			DebugLocation (64' 31);  			PushFollow (Follow._filterExpr_in_filterExpr183);  			b = filterExpr ();  			PopFollow ();  			Match (input' TokenTypes.Up' null);  			DebugLocation (65' 4);  			Comparator newComparator;  			switch (comparator6) {  			case "=":  				newComparator = Comparator.Equals;  				break;  			case "!=":  				newComparator = Comparator.NotEquals;  				break;  			case ">":  				newComparator = Comparator.Greater;  				break;  			case "<":  				newComparator = Comparator.Less;  				break;  			case ">=":  				newComparator = Comparator.GreaterOrEqual;  				break;  			case "<=":  				newComparator = Comparator.LessOrEqual;  				break;  			case "&":  				newComparator = Comparator.And;  				break;  			case "|":  				newComparator = Comparator.Or;  				break;  			default:  				newComparator = Comparator.Equals;  				break;  			}  			filterNode = new BoolExpression (a' newComparator' b);  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  		{  			DebugLocation (98' 4);  			DebugLocation (98' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr195);  			Match (input' TokenTypes.Down' null);  			DebugLocation (98' 12);  			PushFollow (Follow._filterExpr_in_filterExpr199);  			f = filterExpr ();  			PopFollow ();  			DebugLocation (98' 31);  			// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  			int alt6 = 2;  			try {  				DebugEnterSubRule (6);  				try {  					DebugEnterDecision (6' false);  					int LA6_1 = input.LA (1);  					if ((LA6_1 == 24)) {  						alt6 = 1;  					}  				}  				finally {  					DebugExitDecision (6);  				}  				switch (alt6) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  					{  						DebugLocation (98' 31);  						inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (6);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (99' 4);  			FilterTreeNode newNode = f;  			if ((inverse != null ? inverse.Text : default(string)) == "!")  				newNode.ToggleInversed ();  			filterNode = newNode;  		}  		break;  	case 3:  		DebugEnterAlt (3);  		// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  		{  			DebugLocation (105' 4);  			DebugLocation (105' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr216);  			Match (input' TokenTypes.Down' null);  			DebugLocation (105' 12);  			PushFollow (Follow._propertyChain_in_filterExpr219);  			propertyChain (propertySegments);  			PopFollow ();  			DebugLocation (105' 51);  			// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  			int alt7 = 2;  			try {  				DebugEnterSubRule (7);  				try {  					DebugEnterDecision (7' false);  					int LA7_1 = input.LA (1);  					if ((LA7_1 == 31)) {  						alt7 = 1;  					}  				}  				finally {  					DebugExitDecision (7);  				}  				switch (alt7) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  					{  						DebugLocation (105' 51);  						inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (7);  			}  			DebugLocation (105' 60);  			// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  			int alt8 = 2;  			try {  				DebugEnterSubRule (8);  				try {  					DebugEnterDecision (8' false);  					int LA8_1 = input.LA (1);  					if ((LA8_1 == 24)) {  						alt8 = 1;  					}  				}  				finally {  					DebugExitDecision (8);  				}  				switch (alt8) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  					{  						DebugLocation (105' 60);  						not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (8);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (106' 4);  			FilterTreeNode newProperty = new Property (propertySegments);  			if ((inverse != null ? inverse.Text : default(string)) == "?")  				filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  			else {  				if ((not != null ? not.Text : default(string)) == "!")  					newProperty.ToggleInversed ();  				filterNode = newProperty;  			}  		}  		break;  	case 4:  		DebugEnterAlt (4);  		// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  		{  			DebugLocation (116' 4);  			STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  			DebugLocation (117' 4);  			string stringText = (STRING7 != null ? STRING7.Text : default(string));  			stringText = stringText.Substring (1' stringText.Length - 2);  			filterNode = new Value (stringText);  		}  		break;  	case 5:  		DebugEnterAlt (5);  		// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  		{  			DebugLocation (122' 4);  			REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  			DebugLocation (123' 4);  			string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  			regexText = regexText.Substring (1' regexText.Length - 2);  			filterNode = new RegExp (regexText);  		}  		break;  	case 6:  		DebugEnterAlt (6);  		// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  		{  			DebugLocation (128' 4);  			NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  			DebugLocation (129' 4);  			filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  		}  		break;  	case 7:  		DebugEnterAlt (7);  		// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  		{  			DebugLocation (132' 4);  			Match (input' TRUE' Follow._TRUE_in_filterExpr271);  			DebugLocation (133' 4);  			filterNode = new Value (true);  		}  		break;  	case 8:  		DebugEnterAlt (8);  		// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  		{  			DebugLocation (136' 4);  			Match (input' FALSE' Follow._FALSE_in_filterExpr281);  			DebugLocation (137' 4);  			filterNode = new Value (false);  		}  		break;  	case 9:  		DebugEnterAlt (9);  		// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  		{  			DebugLocation (140' 4);  			Match (input' NULL' Follow._NULL_in_filterExpr291);  			DebugLocation (141' 4);  			filterNode = new Value (null);  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("filterExpr"' 6);  	LeaveRule ("filterExpr"' 6);  	LeaveRule_filterExpr ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  	int alt9 = 9;  	try {  		DebugEnterDecision (9' false);  		switch (input.LA (1)) {  		case CHAIN_OPERATOR:  		case COMPARATOR:  			{  				alt9 = 1;  			}  			break;  		case EXPR:  			{  				int LA9_2 = input.LA (2);  				if ((LA9_2 == DOWN)) {  					int LA9_3 = input.LA (3);  					if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  						alt9 = 2;  					}  					else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  						alt9 = 3;  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				else {  					NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  					DebugRecognitionException (nvae);  					throw nvae;  				}  			}  			break;  		case STRING:  			{  				alt9 = 4;  			}  			break;  		case REGEX:  			{  				alt9 = 5;  			}  			break;  		case NUMBER:  			{  				alt9 = 6;  			}  			break;  		case TRUE:  			{  				alt9 = 7;  			}  			break;  		case FALSE:  			{  				alt9 = 8;  			}  			break;  		case NULL:  			{  				alt9 = 9;  			}  			break;  		default: {  			NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  		}  	}  	finally {  		DebugExitDecision (9);  	}  	switch (alt9) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  		{  			DebugLocation (64' 4);  			DebugLocation (64' 6);  			PushFollow (Follow._comparator_in_filterExpr175);  			comparator6 = comparator ();  			PopFollow ();  			Match (input' TokenTypes.Down' null);  			DebugLocation (64' 18);  			PushFollow (Follow._filterExpr_in_filterExpr179);  			a = filterExpr ();  			PopFollow ();  			DebugLocation (64' 31);  			PushFollow (Follow._filterExpr_in_filterExpr183);  			b = filterExpr ();  			PopFollow ();  			Match (input' TokenTypes.Up' null);  			DebugLocation (65' 4);  			Comparator newComparator;  			switch (comparator6) {  			case "=":  				newComparator = Comparator.Equals;  				break;  			case "!=":  				newComparator = Comparator.NotEquals;  				break;  			case ">":  				newComparator = Comparator.Greater;  				break;  			case "<":  				newComparator = Comparator.Less;  				break;  			case ">=":  				newComparator = Comparator.GreaterOrEqual;  				break;  			case "<=":  				newComparator = Comparator.LessOrEqual;  				break;  			case "&":  				newComparator = Comparator.And;  				break;  			case "|":  				newComparator = Comparator.Or;  				break;  			default:  				newComparator = Comparator.Equals;  				break;  			}  			filterNode = new BoolExpression (a' newComparator' b);  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  		{  			DebugLocation (98' 4);  			DebugLocation (98' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr195);  			Match (input' TokenTypes.Down' null);  			DebugLocation (98' 12);  			PushFollow (Follow._filterExpr_in_filterExpr199);  			f = filterExpr ();  			PopFollow ();  			DebugLocation (98' 31);  			// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  			int alt6 = 2;  			try {  				DebugEnterSubRule (6);  				try {  					DebugEnterDecision (6' false);  					int LA6_1 = input.LA (1);  					if ((LA6_1 == 24)) {  						alt6 = 1;  					}  				}  				finally {  					DebugExitDecision (6);  				}  				switch (alt6) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  					{  						DebugLocation (98' 31);  						inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (6);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (99' 4);  			FilterTreeNode newNode = f;  			if ((inverse != null ? inverse.Text : default(string)) == "!")  				newNode.ToggleInversed ();  			filterNode = newNode;  		}  		break;  	case 3:  		DebugEnterAlt (3);  		// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  		{  			DebugLocation (105' 4);  			DebugLocation (105' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr216);  			Match (input' TokenTypes.Down' null);  			DebugLocation (105' 12);  			PushFollow (Follow._propertyChain_in_filterExpr219);  			propertyChain (propertySegments);  			PopFollow ();  			DebugLocation (105' 51);  			// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  			int alt7 = 2;  			try {  				DebugEnterSubRule (7);  				try {  					DebugEnterDecision (7' false);  					int LA7_1 = input.LA (1);  					if ((LA7_1 == 31)) {  						alt7 = 1;  					}  				}  				finally {  					DebugExitDecision (7);  				}  				switch (alt7) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  					{  						DebugLocation (105' 51);  						inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (7);  			}  			DebugLocation (105' 60);  			// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  			int alt8 = 2;  			try {  				DebugEnterSubRule (8);  				try {  					DebugEnterDecision (8' false);  					int LA8_1 = input.LA (1);  					if ((LA8_1 == 24)) {  						alt8 = 1;  					}  				}  				finally {  					DebugExitDecision (8);  				}  				switch (alt8) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  					{  						DebugLocation (105' 60);  						not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (8);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (106' 4);  			FilterTreeNode newProperty = new Property (propertySegments);  			if ((inverse != null ? inverse.Text : default(string)) == "?")  				filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  			else {  				if ((not != null ? not.Text : default(string)) == "!")  					newProperty.ToggleInversed ();  				filterNode = newProperty;  			}  		}  		break;  	case 4:  		DebugEnterAlt (4);  		// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  		{  			DebugLocation (116' 4);  			STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  			DebugLocation (117' 4);  			string stringText = (STRING7 != null ? STRING7.Text : default(string));  			stringText = stringText.Substring (1' stringText.Length - 2);  			filterNode = new Value (stringText);  		}  		break;  	case 5:  		DebugEnterAlt (5);  		// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  		{  			DebugLocation (122' 4);  			REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  			DebugLocation (123' 4);  			string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  			regexText = regexText.Substring (1' regexText.Length - 2);  			filterNode = new RegExp (regexText);  		}  		break;  	case 6:  		DebugEnterAlt (6);  		// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  		{  			DebugLocation (128' 4);  			NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  			DebugLocation (129' 4);  			filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  		}  		break;  	case 7:  		DebugEnterAlt (7);  		// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  		{  			DebugLocation (132' 4);  			Match (input' TRUE' Follow._TRUE_in_filterExpr271);  			DebugLocation (133' 4);  			filterNode = new Value (true);  		}  		break;  	case 8:  		DebugEnterAlt (8);  		// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  		{  			DebugLocation (136' 4);  			Match (input' FALSE' Follow._FALSE_in_filterExpr281);  			DebugLocation (137' 4);  			filterNode = new Value (false);  		}  		break;  	case 9:  		DebugEnterAlt (9);  		// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  		{  			DebugLocation (140' 4);  			Match (input' NULL' Follow._NULL_in_filterExpr291);  			DebugLocation (141' 4);  			filterNode = new Value (null);  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("filterExpr"' 6);  	LeaveRule ("filterExpr"' 6);  	LeaveRule_filterExpr ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  	int alt9 = 9;  	try {  		DebugEnterDecision (9' false);  		switch (input.LA (1)) {  		case CHAIN_OPERATOR:  		case COMPARATOR:  			{  				alt9 = 1;  			}  			break;  		case EXPR:  			{  				int LA9_2 = input.LA (2);  				if ((LA9_2 == DOWN)) {  					int LA9_3 = input.LA (3);  					if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  						alt9 = 2;  					}  					else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  						alt9 = 3;  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				else {  					NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  					DebugRecognitionException (nvae);  					throw nvae;  				}  			}  			break;  		case STRING:  			{  				alt9 = 4;  			}  			break;  		case REGEX:  			{  				alt9 = 5;  			}  			break;  		case NUMBER:  			{  				alt9 = 6;  			}  			break;  		case TRUE:  			{  				alt9 = 7;  			}  			break;  		case FALSE:  			{  				alt9 = 8;  			}  			break;  		case NULL:  			{  				alt9 = 9;  			}  			break;  		default: {  			NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  		}  	}  	finally {  		DebugExitDecision (9);  	}  	switch (alt9) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  		{  			DebugLocation (64' 4);  			DebugLocation (64' 6);  			PushFollow (Follow._comparator_in_filterExpr175);  			comparator6 = comparator ();  			PopFollow ();  			Match (input' TokenTypes.Down' null);  			DebugLocation (64' 18);  			PushFollow (Follow._filterExpr_in_filterExpr179);  			a = filterExpr ();  			PopFollow ();  			DebugLocation (64' 31);  			PushFollow (Follow._filterExpr_in_filterExpr183);  			b = filterExpr ();  			PopFollow ();  			Match (input' TokenTypes.Up' null);  			DebugLocation (65' 4);  			Comparator newComparator;  			switch (comparator6) {  			case "=":  				newComparator = Comparator.Equals;  				break;  			case "!=":  				newComparator = Comparator.NotEquals;  				break;  			case ">":  				newComparator = Comparator.Greater;  				break;  			case "<":  				newComparator = Comparator.Less;  				break;  			case ">=":  				newComparator = Comparator.GreaterOrEqual;  				break;  			case "<=":  				newComparator = Comparator.LessOrEqual;  				break;  			case "&":  				newComparator = Comparator.And;  				break;  			case "|":  				newComparator = Comparator.Or;  				break;  			default:  				newComparator = Comparator.Equals;  				break;  			}  			filterNode = new BoolExpression (a' newComparator' b);  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  		{  			DebugLocation (98' 4);  			DebugLocation (98' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr195);  			Match (input' TokenTypes.Down' null);  			DebugLocation (98' 12);  			PushFollow (Follow._filterExpr_in_filterExpr199);  			f = filterExpr ();  			PopFollow ();  			DebugLocation (98' 31);  			// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  			int alt6 = 2;  			try {  				DebugEnterSubRule (6);  				try {  					DebugEnterDecision (6' false);  					int LA6_1 = input.LA (1);  					if ((LA6_1 == 24)) {  						alt6 = 1;  					}  				}  				finally {  					DebugExitDecision (6);  				}  				switch (alt6) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  					{  						DebugLocation (98' 31);  						inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (6);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (99' 4);  			FilterTreeNode newNode = f;  			if ((inverse != null ? inverse.Text : default(string)) == "!")  				newNode.ToggleInversed ();  			filterNode = newNode;  		}  		break;  	case 3:  		DebugEnterAlt (3);  		// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  		{  			DebugLocation (105' 4);  			DebugLocation (105' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr216);  			Match (input' TokenTypes.Down' null);  			DebugLocation (105' 12);  			PushFollow (Follow._propertyChain_in_filterExpr219);  			propertyChain (propertySegments);  			PopFollow ();  			DebugLocation (105' 51);  			// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  			int alt7 = 2;  			try {  				DebugEnterSubRule (7);  				try {  					DebugEnterDecision (7' false);  					int LA7_1 = input.LA (1);  					if ((LA7_1 == 31)) {  						alt7 = 1;  					}  				}  				finally {  					DebugExitDecision (7);  				}  				switch (alt7) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  					{  						DebugLocation (105' 51);  						inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (7);  			}  			DebugLocation (105' 60);  			// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  			int alt8 = 2;  			try {  				DebugEnterSubRule (8);  				try {  					DebugEnterDecision (8' false);  					int LA8_1 = input.LA (1);  					if ((LA8_1 == 24)) {  						alt8 = 1;  					}  				}  				finally {  					DebugExitDecision (8);  				}  				switch (alt8) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  					{  						DebugLocation (105' 60);  						not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (8);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (106' 4);  			FilterTreeNode newProperty = new Property (propertySegments);  			if ((inverse != null ? inverse.Text : default(string)) == "?")  				filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  			else {  				if ((not != null ? not.Text : default(string)) == "!")  					newProperty.ToggleInversed ();  				filterNode = newProperty;  			}  		}  		break;  	case 4:  		DebugEnterAlt (4);  		// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  		{  			DebugLocation (116' 4);  			STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  			DebugLocation (117' 4);  			string stringText = (STRING7 != null ? STRING7.Text : default(string));  			stringText = stringText.Substring (1' stringText.Length - 2);  			filterNode = new Value (stringText);  		}  		break;  	case 5:  		DebugEnterAlt (5);  		// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  		{  			DebugLocation (122' 4);  			REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  			DebugLocation (123' 4);  			string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  			regexText = regexText.Substring (1' regexText.Length - 2);  			filterNode = new RegExp (regexText);  		}  		break;  	case 6:  		DebugEnterAlt (6);  		// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  		{  			DebugLocation (128' 4);  			NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  			DebugLocation (129' 4);  			filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  		}  		break;  	case 7:  		DebugEnterAlt (7);  		// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  		{  			DebugLocation (132' 4);  			Match (input' TRUE' Follow._TRUE_in_filterExpr271);  			DebugLocation (133' 4);  			filterNode = new Value (true);  		}  		break;  	case 8:  		DebugEnterAlt (8);  		// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  		{  			DebugLocation (136' 4);  			Match (input' FALSE' Follow._FALSE_in_filterExpr281);  			DebugLocation (137' 4);  			filterNode = new Value (false);  		}  		break;  	case 9:  		DebugEnterAlt (9);  		// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  		{  			DebugLocation (140' 4);  			Match (input' NULL' Follow._NULL_in_filterExpr291);  			DebugLocation (141' 4);  			filterNode = new Value (null);  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("filterExpr"' 6);  	LeaveRule ("filterExpr"' 6);  	LeaveRule_filterExpr ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  	int alt9 = 9;  	try {  		DebugEnterDecision (9' false);  		switch (input.LA (1)) {  		case CHAIN_OPERATOR:  		case COMPARATOR:  			{  				alt9 = 1;  			}  			break;  		case EXPR:  			{  				int LA9_2 = input.LA (2);  				if ((LA9_2 == DOWN)) {  					int LA9_3 = input.LA (3);  					if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  						alt9 = 2;  					}  					else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  						alt9 = 3;  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				else {  					NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  					DebugRecognitionException (nvae);  					throw nvae;  				}  			}  			break;  		case STRING:  			{  				alt9 = 4;  			}  			break;  		case REGEX:  			{  				alt9 = 5;  			}  			break;  		case NUMBER:  			{  				alt9 = 6;  			}  			break;  		case TRUE:  			{  				alt9 = 7;  			}  			break;  		case FALSE:  			{  				alt9 = 8;  			}  			break;  		case NULL:  			{  				alt9 = 9;  			}  			break;  		default: {  			NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  		}  	}  	finally {  		DebugExitDecision (9);  	}  	switch (alt9) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  		{  			DebugLocation (64' 4);  			DebugLocation (64' 6);  			PushFollow (Follow._comparator_in_filterExpr175);  			comparator6 = comparator ();  			PopFollow ();  			Match (input' TokenTypes.Down' null);  			DebugLocation (64' 18);  			PushFollow (Follow._filterExpr_in_filterExpr179);  			a = filterExpr ();  			PopFollow ();  			DebugLocation (64' 31);  			PushFollow (Follow._filterExpr_in_filterExpr183);  			b = filterExpr ();  			PopFollow ();  			Match (input' TokenTypes.Up' null);  			DebugLocation (65' 4);  			Comparator newComparator;  			switch (comparator6) {  			case "=":  				newComparator = Comparator.Equals;  				break;  			case "!=":  				newComparator = Comparator.NotEquals;  				break;  			case ">":  				newComparator = Comparator.Greater;  				break;  			case "<":  				newComparator = Comparator.Less;  				break;  			case ">=":  				newComparator = Comparator.GreaterOrEqual;  				break;  			case "<=":  				newComparator = Comparator.LessOrEqual;  				break;  			case "&":  				newComparator = Comparator.And;  				break;  			case "|":  				newComparator = Comparator.Or;  				break;  			default:  				newComparator = Comparator.Equals;  				break;  			}  			filterNode = new BoolExpression (a' newComparator' b);  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  		{  			DebugLocation (98' 4);  			DebugLocation (98' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr195);  			Match (input' TokenTypes.Down' null);  			DebugLocation (98' 12);  			PushFollow (Follow._filterExpr_in_filterExpr199);  			f = filterExpr ();  			PopFollow ();  			DebugLocation (98' 31);  			// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  			int alt6 = 2;  			try {  				DebugEnterSubRule (6);  				try {  					DebugEnterDecision (6' false);  					int LA6_1 = input.LA (1);  					if ((LA6_1 == 24)) {  						alt6 = 1;  					}  				}  				finally {  					DebugExitDecision (6);  				}  				switch (alt6) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  					{  						DebugLocation (98' 31);  						inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (6);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (99' 4);  			FilterTreeNode newNode = f;  			if ((inverse != null ? inverse.Text : default(string)) == "!")  				newNode.ToggleInversed ();  			filterNode = newNode;  		}  		break;  	case 3:  		DebugEnterAlt (3);  		// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  		{  			DebugLocation (105' 4);  			DebugLocation (105' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr216);  			Match (input' TokenTypes.Down' null);  			DebugLocation (105' 12);  			PushFollow (Follow._propertyChain_in_filterExpr219);  			propertyChain (propertySegments);  			PopFollow ();  			DebugLocation (105' 51);  			// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  			int alt7 = 2;  			try {  				DebugEnterSubRule (7);  				try {  					DebugEnterDecision (7' false);  					int LA7_1 = input.LA (1);  					if ((LA7_1 == 31)) {  						alt7 = 1;  					}  				}  				finally {  					DebugExitDecision (7);  				}  				switch (alt7) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  					{  						DebugLocation (105' 51);  						inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (7);  			}  			DebugLocation (105' 60);  			// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  			int alt8 = 2;  			try {  				DebugEnterSubRule (8);  				try {  					DebugEnterDecision (8' false);  					int LA8_1 = input.LA (1);  					if ((LA8_1 == 24)) {  						alt8 = 1;  					}  				}  				finally {  					DebugExitDecision (8);  				}  				switch (alt8) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  					{  						DebugLocation (105' 60);  						not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (8);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (106' 4);  			FilterTreeNode newProperty = new Property (propertySegments);  			if ((inverse != null ? inverse.Text : default(string)) == "?")  				filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  			else {  				if ((not != null ? not.Text : default(string)) == "!")  					newProperty.ToggleInversed ();  				filterNode = newProperty;  			}  		}  		break;  	case 4:  		DebugEnterAlt (4);  		// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  		{  			DebugLocation (116' 4);  			STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  			DebugLocation (117' 4);  			string stringText = (STRING7 != null ? STRING7.Text : default(string));  			stringText = stringText.Substring (1' stringText.Length - 2);  			filterNode = new Value (stringText);  		}  		break;  	case 5:  		DebugEnterAlt (5);  		// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  		{  			DebugLocation (122' 4);  			REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  			DebugLocation (123' 4);  			string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  			regexText = regexText.Substring (1' regexText.Length - 2);  			filterNode = new RegExp (regexText);  		}  		break;  	case 6:  		DebugEnterAlt (6);  		// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  		{  			DebugLocation (128' 4);  			NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  			DebugLocation (129' 4);  			filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  		}  		break;  	case 7:  		DebugEnterAlt (7);  		// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  		{  			DebugLocation (132' 4);  			Match (input' TRUE' Follow._TRUE_in_filterExpr271);  			DebugLocation (133' 4);  			filterNode = new Value (true);  		}  		break;  	case 8:  		DebugEnterAlt (8);  		// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  		{  			DebugLocation (136' 4);  			Match (input' FALSE' Follow._FALSE_in_filterExpr281);  			DebugLocation (137' 4);  			filterNode = new Value (false);  		}  		break;  	case 9:  		DebugEnterAlt (9);  		// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  		{  			DebugLocation (140' 4);  			Match (input' NULL' Follow._NULL_in_filterExpr291);  			DebugLocation (141' 4);  			filterNode = new Value (null);  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("filterExpr"' 6);  	LeaveRule ("filterExpr"' 6);  	LeaveRule_filterExpr ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  	int alt9 = 9;  	try {  		DebugEnterDecision (9' false);  		switch (input.LA (1)) {  		case CHAIN_OPERATOR:  		case COMPARATOR:  			{  				alt9 = 1;  			}  			break;  		case EXPR:  			{  				int LA9_2 = input.LA (2);  				if ((LA9_2 == DOWN)) {  					int LA9_3 = input.LA (3);  					if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  						alt9 = 2;  					}  					else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  						alt9 = 3;  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				else {  					NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  					DebugRecognitionException (nvae);  					throw nvae;  				}  			}  			break;  		case STRING:  			{  				alt9 = 4;  			}  			break;  		case REGEX:  			{  				alt9 = 5;  			}  			break;  		case NUMBER:  			{  				alt9 = 6;  			}  			break;  		case TRUE:  			{  				alt9 = 7;  			}  			break;  		case FALSE:  			{  				alt9 = 8;  			}  			break;  		case NULL:  			{  				alt9 = 9;  			}  			break;  		default: {  			NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  		}  	}  	finally {  		DebugExitDecision (9);  	}  	switch (alt9) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  		{  			DebugLocation (64' 4);  			DebugLocation (64' 6);  			PushFollow (Follow._comparator_in_filterExpr175);  			comparator6 = comparator ();  			PopFollow ();  			Match (input' TokenTypes.Down' null);  			DebugLocation (64' 18);  			PushFollow (Follow._filterExpr_in_filterExpr179);  			a = filterExpr ();  			PopFollow ();  			DebugLocation (64' 31);  			PushFollow (Follow._filterExpr_in_filterExpr183);  			b = filterExpr ();  			PopFollow ();  			Match (input' TokenTypes.Up' null);  			DebugLocation (65' 4);  			Comparator newComparator;  			switch (comparator6) {  			case "=":  				newComparator = Comparator.Equals;  				break;  			case "!=":  				newComparator = Comparator.NotEquals;  				break;  			case ">":  				newComparator = Comparator.Greater;  				break;  			case "<":  				newComparator = Comparator.Less;  				break;  			case ">=":  				newComparator = Comparator.GreaterOrEqual;  				break;  			case "<=":  				newComparator = Comparator.LessOrEqual;  				break;  			case "&":  				newComparator = Comparator.And;  				break;  			case "|":  				newComparator = Comparator.Or;  				break;  			default:  				newComparator = Comparator.Equals;  				break;  			}  			filterNode = new BoolExpression (a' newComparator' b);  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  		{  			DebugLocation (98' 4);  			DebugLocation (98' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr195);  			Match (input' TokenTypes.Down' null);  			DebugLocation (98' 12);  			PushFollow (Follow._filterExpr_in_filterExpr199);  			f = filterExpr ();  			PopFollow ();  			DebugLocation (98' 31);  			// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  			int alt6 = 2;  			try {  				DebugEnterSubRule (6);  				try {  					DebugEnterDecision (6' false);  					int LA6_1 = input.LA (1);  					if ((LA6_1 == 24)) {  						alt6 = 1;  					}  				}  				finally {  					DebugExitDecision (6);  				}  				switch (alt6) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  					{  						DebugLocation (98' 31);  						inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (6);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (99' 4);  			FilterTreeNode newNode = f;  			if ((inverse != null ? inverse.Text : default(string)) == "!")  				newNode.ToggleInversed ();  			filterNode = newNode;  		}  		break;  	case 3:  		DebugEnterAlt (3);  		// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  		{  			DebugLocation (105' 4);  			DebugLocation (105' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr216);  			Match (input' TokenTypes.Down' null);  			DebugLocation (105' 12);  			PushFollow (Follow._propertyChain_in_filterExpr219);  			propertyChain (propertySegments);  			PopFollow ();  			DebugLocation (105' 51);  			// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  			int alt7 = 2;  			try {  				DebugEnterSubRule (7);  				try {  					DebugEnterDecision (7' false);  					int LA7_1 = input.LA (1);  					if ((LA7_1 == 31)) {  						alt7 = 1;  					}  				}  				finally {  					DebugExitDecision (7);  				}  				switch (alt7) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  					{  						DebugLocation (105' 51);  						inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (7);  			}  			DebugLocation (105' 60);  			// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  			int alt8 = 2;  			try {  				DebugEnterSubRule (8);  				try {  					DebugEnterDecision (8' false);  					int LA8_1 = input.LA (1);  					if ((LA8_1 == 24)) {  						alt8 = 1;  					}  				}  				finally {  					DebugExitDecision (8);  				}  				switch (alt8) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  					{  						DebugLocation (105' 60);  						not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (8);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (106' 4);  			FilterTreeNode newProperty = new Property (propertySegments);  			if ((inverse != null ? inverse.Text : default(string)) == "?")  				filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  			else {  				if ((not != null ? not.Text : default(string)) == "!")  					newProperty.ToggleInversed ();  				filterNode = newProperty;  			}  		}  		break;  	case 4:  		DebugEnterAlt (4);  		// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  		{  			DebugLocation (116' 4);  			STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  			DebugLocation (117' 4);  			string stringText = (STRING7 != null ? STRING7.Text : default(string));  			stringText = stringText.Substring (1' stringText.Length - 2);  			filterNode = new Value (stringText);  		}  		break;  	case 5:  		DebugEnterAlt (5);  		// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  		{  			DebugLocation (122' 4);  			REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  			DebugLocation (123' 4);  			string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  			regexText = regexText.Substring (1' regexText.Length - 2);  			filterNode = new RegExp (regexText);  		}  		break;  	case 6:  		DebugEnterAlt (6);  		// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  		{  			DebugLocation (128' 4);  			NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  			DebugLocation (129' 4);  			filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  		}  		break;  	case 7:  		DebugEnterAlt (7);  		// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  		{  			DebugLocation (132' 4);  			Match (input' TRUE' Follow._TRUE_in_filterExpr271);  			DebugLocation (133' 4);  			filterNode = new Value (true);  		}  		break;  	case 8:  		DebugEnterAlt (8);  		// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  		{  			DebugLocation (136' 4);  			Match (input' FALSE' Follow._FALSE_in_filterExpr281);  			DebugLocation (137' 4);  			filterNode = new Value (false);  		}  		break;  	case 9:  		DebugEnterAlt (9);  		// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  		{  			DebugLocation (140' 4);  			Match (input' NULL' Follow._NULL_in_filterExpr291);  			DebugLocation (141' 4);  			filterNode = new Value (null);  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("filterExpr"' 6);  	LeaveRule ("filterExpr"' 6);  	LeaveRule_filterExpr ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  	int alt9 = 9;  	try {  		DebugEnterDecision (9' false);  		switch (input.LA (1)) {  		case CHAIN_OPERATOR:  		case COMPARATOR:  			{  				alt9 = 1;  			}  			break;  		case EXPR:  			{  				int LA9_2 = input.LA (2);  				if ((LA9_2 == DOWN)) {  					int LA9_3 = input.LA (3);  					if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  						alt9 = 2;  					}  					else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  						alt9 = 3;  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				else {  					NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  					DebugRecognitionException (nvae);  					throw nvae;  				}  			}  			break;  		case STRING:  			{  				alt9 = 4;  			}  			break;  		case REGEX:  			{  				alt9 = 5;  			}  			break;  		case NUMBER:  			{  				alt9 = 6;  			}  			break;  		case TRUE:  			{  				alt9 = 7;  			}  			break;  		case FALSE:  			{  				alt9 = 8;  			}  			break;  		case NULL:  			{  				alt9 = 9;  			}  			break;  		default: {  			NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  		}  	}  	finally {  		DebugExitDecision (9);  	}  	switch (alt9) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  		{  			DebugLocation (64' 4);  			DebugLocation (64' 6);  			PushFollow (Follow._comparator_in_filterExpr175);  			comparator6 = comparator ();  			PopFollow ();  			Match (input' TokenTypes.Down' null);  			DebugLocation (64' 18);  			PushFollow (Follow._filterExpr_in_filterExpr179);  			a = filterExpr ();  			PopFollow ();  			DebugLocation (64' 31);  			PushFollow (Follow._filterExpr_in_filterExpr183);  			b = filterExpr ();  			PopFollow ();  			Match (input' TokenTypes.Up' null);  			DebugLocation (65' 4);  			Comparator newComparator;  			switch (comparator6) {  			case "=":  				newComparator = Comparator.Equals;  				break;  			case "!=":  				newComparator = Comparator.NotEquals;  				break;  			case ">":  				newComparator = Comparator.Greater;  				break;  			case "<":  				newComparator = Comparator.Less;  				break;  			case ">=":  				newComparator = Comparator.GreaterOrEqual;  				break;  			case "<=":  				newComparator = Comparator.LessOrEqual;  				break;  			case "&":  				newComparator = Comparator.And;  				break;  			case "|":  				newComparator = Comparator.Or;  				break;  			default:  				newComparator = Comparator.Equals;  				break;  			}  			filterNode = new BoolExpression (a' newComparator' b);  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  		{  			DebugLocation (98' 4);  			DebugLocation (98' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr195);  			Match (input' TokenTypes.Down' null);  			DebugLocation (98' 12);  			PushFollow (Follow._filterExpr_in_filterExpr199);  			f = filterExpr ();  			PopFollow ();  			DebugLocation (98' 31);  			// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  			int alt6 = 2;  			try {  				DebugEnterSubRule (6);  				try {  					DebugEnterDecision (6' false);  					int LA6_1 = input.LA (1);  					if ((LA6_1 == 24)) {  						alt6 = 1;  					}  				}  				finally {  					DebugExitDecision (6);  				}  				switch (alt6) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  					{  						DebugLocation (98' 31);  						inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (6);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (99' 4);  			FilterTreeNode newNode = f;  			if ((inverse != null ? inverse.Text : default(string)) == "!")  				newNode.ToggleInversed ();  			filterNode = newNode;  		}  		break;  	case 3:  		DebugEnterAlt (3);  		// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  		{  			DebugLocation (105' 4);  			DebugLocation (105' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr216);  			Match (input' TokenTypes.Down' null);  			DebugLocation (105' 12);  			PushFollow (Follow._propertyChain_in_filterExpr219);  			propertyChain (propertySegments);  			PopFollow ();  			DebugLocation (105' 51);  			// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  			int alt7 = 2;  			try {  				DebugEnterSubRule (7);  				try {  					DebugEnterDecision (7' false);  					int LA7_1 = input.LA (1);  					if ((LA7_1 == 31)) {  						alt7 = 1;  					}  				}  				finally {  					DebugExitDecision (7);  				}  				switch (alt7) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  					{  						DebugLocation (105' 51);  						inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (7);  			}  			DebugLocation (105' 60);  			// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  			int alt8 = 2;  			try {  				DebugEnterSubRule (8);  				try {  					DebugEnterDecision (8' false);  					int LA8_1 = input.LA (1);  					if ((LA8_1 == 24)) {  						alt8 = 1;  					}  				}  				finally {  					DebugExitDecision (8);  				}  				switch (alt8) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  					{  						DebugLocation (105' 60);  						not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (8);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (106' 4);  			FilterTreeNode newProperty = new Property (propertySegments);  			if ((inverse != null ? inverse.Text : default(string)) == "?")  				filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  			else {  				if ((not != null ? not.Text : default(string)) == "!")  					newProperty.ToggleInversed ();  				filterNode = newProperty;  			}  		}  		break;  	case 4:  		DebugEnterAlt (4);  		// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  		{  			DebugLocation (116' 4);  			STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  			DebugLocation (117' 4);  			string stringText = (STRING7 != null ? STRING7.Text : default(string));  			stringText = stringText.Substring (1' stringText.Length - 2);  			filterNode = new Value (stringText);  		}  		break;  	case 5:  		DebugEnterAlt (5);  		// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  		{  			DebugLocation (122' 4);  			REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  			DebugLocation (123' 4);  			string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  			regexText = regexText.Substring (1' regexText.Length - 2);  			filterNode = new RegExp (regexText);  		}  		break;  	case 6:  		DebugEnterAlt (6);  		// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  		{  			DebugLocation (128' 4);  			NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  			DebugLocation (129' 4);  			filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  		}  		break;  	case 7:  		DebugEnterAlt (7);  		// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  		{  			DebugLocation (132' 4);  			Match (input' TRUE' Follow._TRUE_in_filterExpr271);  			DebugLocation (133' 4);  			filterNode = new Value (true);  		}  		break;  	case 8:  		DebugEnterAlt (8);  		// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  		{  			DebugLocation (136' 4);  			Match (input' FALSE' Follow._FALSE_in_filterExpr281);  			DebugLocation (137' 4);  			filterNode = new Value (false);  		}  		break;  	case 9:  		DebugEnterAlt (9);  		// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  		{  			DebugLocation (140' 4);  			Match (input' NULL' Follow._NULL_in_filterExpr291);  			DebugLocation (141' 4);  			filterNode = new Value (null);  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("filterExpr"' 6);  	LeaveRule ("filterExpr"' 6);  	LeaveRule_filterExpr ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  	int alt9 = 9;  	try {  		DebugEnterDecision (9' false);  		switch (input.LA (1)) {  		case CHAIN_OPERATOR:  		case COMPARATOR:  			{  				alt9 = 1;  			}  			break;  		case EXPR:  			{  				int LA9_2 = input.LA (2);  				if ((LA9_2 == DOWN)) {  					int LA9_3 = input.LA (3);  					if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  						alt9 = 2;  					}  					else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  						alt9 = 3;  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				else {  					NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  					DebugRecognitionException (nvae);  					throw nvae;  				}  			}  			break;  		case STRING:  			{  				alt9 = 4;  			}  			break;  		case REGEX:  			{  				alt9 = 5;  			}  			break;  		case NUMBER:  			{  				alt9 = 6;  			}  			break;  		case TRUE:  			{  				alt9 = 7;  			}  			break;  		case FALSE:  			{  				alt9 = 8;  			}  			break;  		case NULL:  			{  				alt9 = 9;  			}  			break;  		default: {  			NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  		}  	}  	finally {  		DebugExitDecision (9);  	}  	switch (alt9) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  		{  			DebugLocation (64' 4);  			DebugLocation (64' 6);  			PushFollow (Follow._comparator_in_filterExpr175);  			comparator6 = comparator ();  			PopFollow ();  			Match (input' TokenTypes.Down' null);  			DebugLocation (64' 18);  			PushFollow (Follow._filterExpr_in_filterExpr179);  			a = filterExpr ();  			PopFollow ();  			DebugLocation (64' 31);  			PushFollow (Follow._filterExpr_in_filterExpr183);  			b = filterExpr ();  			PopFollow ();  			Match (input' TokenTypes.Up' null);  			DebugLocation (65' 4);  			Comparator newComparator;  			switch (comparator6) {  			case "=":  				newComparator = Comparator.Equals;  				break;  			case "!=":  				newComparator = Comparator.NotEquals;  				break;  			case ">":  				newComparator = Comparator.Greater;  				break;  			case "<":  				newComparator = Comparator.Less;  				break;  			case ">=":  				newComparator = Comparator.GreaterOrEqual;  				break;  			case "<=":  				newComparator = Comparator.LessOrEqual;  				break;  			case "&":  				newComparator = Comparator.And;  				break;  			case "|":  				newComparator = Comparator.Or;  				break;  			default:  				newComparator = Comparator.Equals;  				break;  			}  			filterNode = new BoolExpression (a' newComparator' b);  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  		{  			DebugLocation (98' 4);  			DebugLocation (98' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr195);  			Match (input' TokenTypes.Down' null);  			DebugLocation (98' 12);  			PushFollow (Follow._filterExpr_in_filterExpr199);  			f = filterExpr ();  			PopFollow ();  			DebugLocation (98' 31);  			// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  			int alt6 = 2;  			try {  				DebugEnterSubRule (6);  				try {  					DebugEnterDecision (6' false);  					int LA6_1 = input.LA (1);  					if ((LA6_1 == 24)) {  						alt6 = 1;  					}  				}  				finally {  					DebugExitDecision (6);  				}  				switch (alt6) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  					{  						DebugLocation (98' 31);  						inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (6);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (99' 4);  			FilterTreeNode newNode = f;  			if ((inverse != null ? inverse.Text : default(string)) == "!")  				newNode.ToggleInversed ();  			filterNode = newNode;  		}  		break;  	case 3:  		DebugEnterAlt (3);  		// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  		{  			DebugLocation (105' 4);  			DebugLocation (105' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr216);  			Match (input' TokenTypes.Down' null);  			DebugLocation (105' 12);  			PushFollow (Follow._propertyChain_in_filterExpr219);  			propertyChain (propertySegments);  			PopFollow ();  			DebugLocation (105' 51);  			// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  			int alt7 = 2;  			try {  				DebugEnterSubRule (7);  				try {  					DebugEnterDecision (7' false);  					int LA7_1 = input.LA (1);  					if ((LA7_1 == 31)) {  						alt7 = 1;  					}  				}  				finally {  					DebugExitDecision (7);  				}  				switch (alt7) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  					{  						DebugLocation (105' 51);  						inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (7);  			}  			DebugLocation (105' 60);  			// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  			int alt8 = 2;  			try {  				DebugEnterSubRule (8);  				try {  					DebugEnterDecision (8' false);  					int LA8_1 = input.LA (1);  					if ((LA8_1 == 24)) {  						alt8 = 1;  					}  				}  				finally {  					DebugExitDecision (8);  				}  				switch (alt8) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  					{  						DebugLocation (105' 60);  						not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (8);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (106' 4);  			FilterTreeNode newProperty = new Property (propertySegments);  			if ((inverse != null ? inverse.Text : default(string)) == "?")  				filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  			else {  				if ((not != null ? not.Text : default(string)) == "!")  					newProperty.ToggleInversed ();  				filterNode = newProperty;  			}  		}  		break;  	case 4:  		DebugEnterAlt (4);  		// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  		{  			DebugLocation (116' 4);  			STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  			DebugLocation (117' 4);  			string stringText = (STRING7 != null ? STRING7.Text : default(string));  			stringText = stringText.Substring (1' stringText.Length - 2);  			filterNode = new Value (stringText);  		}  		break;  	case 5:  		DebugEnterAlt (5);  		// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  		{  			DebugLocation (122' 4);  			REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  			DebugLocation (123' 4);  			string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  			regexText = regexText.Substring (1' regexText.Length - 2);  			filterNode = new RegExp (regexText);  		}  		break;  	case 6:  		DebugEnterAlt (6);  		// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  		{  			DebugLocation (128' 4);  			NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  			DebugLocation (129' 4);  			filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  		}  		break;  	case 7:  		DebugEnterAlt (7);  		// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  		{  			DebugLocation (132' 4);  			Match (input' TRUE' Follow._TRUE_in_filterExpr271);  			DebugLocation (133' 4);  			filterNode = new Value (true);  		}  		break;  	case 8:  		DebugEnterAlt (8);  		// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  		{  			DebugLocation (136' 4);  			Match (input' FALSE' Follow._FALSE_in_filterExpr281);  			DebugLocation (137' 4);  			filterNode = new Value (false);  		}  		break;  	case 9:  		DebugEnterAlt (9);  		// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  		{  			DebugLocation (140' 4);  			Match (input' NULL' Follow._NULL_in_filterExpr291);  			DebugLocation (141' 4);  			filterNode = new Value (null);  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("filterExpr"' 6);  	LeaveRule ("filterExpr"' 6);  	LeaveRule_filterExpr ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  	int alt9 = 9;  	try {  		DebugEnterDecision (9' false);  		switch (input.LA (1)) {  		case CHAIN_OPERATOR:  		case COMPARATOR:  			{  				alt9 = 1;  			}  			break;  		case EXPR:  			{  				int LA9_2 = input.LA (2);  				if ((LA9_2 == DOWN)) {  					int LA9_3 = input.LA (3);  					if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  						alt9 = 2;  					}  					else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  						alt9 = 3;  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				else {  					NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  					DebugRecognitionException (nvae);  					throw nvae;  				}  			}  			break;  		case STRING:  			{  				alt9 = 4;  			}  			break;  		case REGEX:  			{  				alt9 = 5;  			}  			break;  		case NUMBER:  			{  				alt9 = 6;  			}  			break;  		case TRUE:  			{  				alt9 = 7;  			}  			break;  		case FALSE:  			{  				alt9 = 8;  			}  			break;  		case NULL:  			{  				alt9 = 9;  			}  			break;  		default: {  			NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  		}  	}  	finally {  		DebugExitDecision (9);  	}  	switch (alt9) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  		{  			DebugLocation (64' 4);  			DebugLocation (64' 6);  			PushFollow (Follow._comparator_in_filterExpr175);  			comparator6 = comparator ();  			PopFollow ();  			Match (input' TokenTypes.Down' null);  			DebugLocation (64' 18);  			PushFollow (Follow._filterExpr_in_filterExpr179);  			a = filterExpr ();  			PopFollow ();  			DebugLocation (64' 31);  			PushFollow (Follow._filterExpr_in_filterExpr183);  			b = filterExpr ();  			PopFollow ();  			Match (input' TokenTypes.Up' null);  			DebugLocation (65' 4);  			Comparator newComparator;  			switch (comparator6) {  			case "=":  				newComparator = Comparator.Equals;  				break;  			case "!=":  				newComparator = Comparator.NotEquals;  				break;  			case ">":  				newComparator = Comparator.Greater;  				break;  			case "<":  				newComparator = Comparator.Less;  				break;  			case ">=":  				newComparator = Comparator.GreaterOrEqual;  				break;  			case "<=":  				newComparator = Comparator.LessOrEqual;  				break;  			case "&":  				newComparator = Comparator.And;  				break;  			case "|":  				newComparator = Comparator.Or;  				break;  			default:  				newComparator = Comparator.Equals;  				break;  			}  			filterNode = new BoolExpression (a' newComparator' b);  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  		{  			DebugLocation (98' 4);  			DebugLocation (98' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr195);  			Match (input' TokenTypes.Down' null);  			DebugLocation (98' 12);  			PushFollow (Follow._filterExpr_in_filterExpr199);  			f = filterExpr ();  			PopFollow ();  			DebugLocation (98' 31);  			// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  			int alt6 = 2;  			try {  				DebugEnterSubRule (6);  				try {  					DebugEnterDecision (6' false);  					int LA6_1 = input.LA (1);  					if ((LA6_1 == 24)) {  						alt6 = 1;  					}  				}  				finally {  					DebugExitDecision (6);  				}  				switch (alt6) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  					{  						DebugLocation (98' 31);  						inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (6);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (99' 4);  			FilterTreeNode newNode = f;  			if ((inverse != null ? inverse.Text : default(string)) == "!")  				newNode.ToggleInversed ();  			filterNode = newNode;  		}  		break;  	case 3:  		DebugEnterAlt (3);  		// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  		{  			DebugLocation (105' 4);  			DebugLocation (105' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr216);  			Match (input' TokenTypes.Down' null);  			DebugLocation (105' 12);  			PushFollow (Follow._propertyChain_in_filterExpr219);  			propertyChain (propertySegments);  			PopFollow ();  			DebugLocation (105' 51);  			// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  			int alt7 = 2;  			try {  				DebugEnterSubRule (7);  				try {  					DebugEnterDecision (7' false);  					int LA7_1 = input.LA (1);  					if ((LA7_1 == 31)) {  						alt7 = 1;  					}  				}  				finally {  					DebugExitDecision (7);  				}  				switch (alt7) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  					{  						DebugLocation (105' 51);  						inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (7);  			}  			DebugLocation (105' 60);  			// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  			int alt8 = 2;  			try {  				DebugEnterSubRule (8);  				try {  					DebugEnterDecision (8' false);  					int LA8_1 = input.LA (1);  					if ((LA8_1 == 24)) {  						alt8 = 1;  					}  				}  				finally {  					DebugExitDecision (8);  				}  				switch (alt8) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  					{  						DebugLocation (105' 60);  						not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (8);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (106' 4);  			FilterTreeNode newProperty = new Property (propertySegments);  			if ((inverse != null ? inverse.Text : default(string)) == "?")  				filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  			else {  				if ((not != null ? not.Text : default(string)) == "!")  					newProperty.ToggleInversed ();  				filterNode = newProperty;  			}  		}  		break;  	case 4:  		DebugEnterAlt (4);  		// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  		{  			DebugLocation (116' 4);  			STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  			DebugLocation (117' 4);  			string stringText = (STRING7 != null ? STRING7.Text : default(string));  			stringText = stringText.Substring (1' stringText.Length - 2);  			filterNode = new Value (stringText);  		}  		break;  	case 5:  		DebugEnterAlt (5);  		// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  		{  			DebugLocation (122' 4);  			REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  			DebugLocation (123' 4);  			string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  			regexText = regexText.Substring (1' regexText.Length - 2);  			filterNode = new RegExp (regexText);  		}  		break;  	case 6:  		DebugEnterAlt (6);  		// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  		{  			DebugLocation (128' 4);  			NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  			DebugLocation (129' 4);  			filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  		}  		break;  	case 7:  		DebugEnterAlt (7);  		// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  		{  			DebugLocation (132' 4);  			Match (input' TRUE' Follow._TRUE_in_filterExpr271);  			DebugLocation (133' 4);  			filterNode = new Value (true);  		}  		break;  	case 8:  		DebugEnterAlt (8);  		// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  		{  			DebugLocation (136' 4);  			Match (input' FALSE' Follow._FALSE_in_filterExpr281);  			DebugLocation (137' 4);  			filterNode = new Value (false);  		}  		break;  	case 9:  		DebugEnterAlt (9);  		// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  		{  			DebugLocation (140' 4);  			Match (input' NULL' Follow._NULL_in_filterExpr291);  			DebugLocation (141' 4);  			filterNode = new Value (null);  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("filterExpr"' 6);  	LeaveRule ("filterExpr"' 6);  	LeaveRule_filterExpr ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  	int alt9 = 9;  	try {  		DebugEnterDecision (9' false);  		switch (input.LA (1)) {  		case CHAIN_OPERATOR:  		case COMPARATOR:  			{  				alt9 = 1;  			}  			break;  		case EXPR:  			{  				int LA9_2 = input.LA (2);  				if ((LA9_2 == DOWN)) {  					int LA9_3 = input.LA (3);  					if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  						alt9 = 2;  					}  					else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  						alt9 = 3;  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				else {  					NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  					DebugRecognitionException (nvae);  					throw nvae;  				}  			}  			break;  		case STRING:  			{  				alt9 = 4;  			}  			break;  		case REGEX:  			{  				alt9 = 5;  			}  			break;  		case NUMBER:  			{  				alt9 = 6;  			}  			break;  		case TRUE:  			{  				alt9 = 7;  			}  			break;  		case FALSE:  			{  				alt9 = 8;  			}  			break;  		case NULL:  			{  				alt9 = 9;  			}  			break;  		default: {  			NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  		}  	}  	finally {  		DebugExitDecision (9);  	}  	switch (alt9) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  		{  			DebugLocation (64' 4);  			DebugLocation (64' 6);  			PushFollow (Follow._comparator_in_filterExpr175);  			comparator6 = comparator ();  			PopFollow ();  			Match (input' TokenTypes.Down' null);  			DebugLocation (64' 18);  			PushFollow (Follow._filterExpr_in_filterExpr179);  			a = filterExpr ();  			PopFollow ();  			DebugLocation (64' 31);  			PushFollow (Follow._filterExpr_in_filterExpr183);  			b = filterExpr ();  			PopFollow ();  			Match (input' TokenTypes.Up' null);  			DebugLocation (65' 4);  			Comparator newComparator;  			switch (comparator6) {  			case "=":  				newComparator = Comparator.Equals;  				break;  			case "!=":  				newComparator = Comparator.NotEquals;  				break;  			case ">":  				newComparator = Comparator.Greater;  				break;  			case "<":  				newComparator = Comparator.Less;  				break;  			case ">=":  				newComparator = Comparator.GreaterOrEqual;  				break;  			case "<=":  				newComparator = Comparator.LessOrEqual;  				break;  			case "&":  				newComparator = Comparator.And;  				break;  			case "|":  				newComparator = Comparator.Or;  				break;  			default:  				newComparator = Comparator.Equals;  				break;  			}  			filterNode = new BoolExpression (a' newComparator' b);  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  		{  			DebugLocation (98' 4);  			DebugLocation (98' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr195);  			Match (input' TokenTypes.Down' null);  			DebugLocation (98' 12);  			PushFollow (Follow._filterExpr_in_filterExpr199);  			f = filterExpr ();  			PopFollow ();  			DebugLocation (98' 31);  			// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  			int alt6 = 2;  			try {  				DebugEnterSubRule (6);  				try {  					DebugEnterDecision (6' false);  					int LA6_1 = input.LA (1);  					if ((LA6_1 == 24)) {  						alt6 = 1;  					}  				}  				finally {  					DebugExitDecision (6);  				}  				switch (alt6) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  					{  						DebugLocation (98' 31);  						inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (6);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (99' 4);  			FilterTreeNode newNode = f;  			if ((inverse != null ? inverse.Text : default(string)) == "!")  				newNode.ToggleInversed ();  			filterNode = newNode;  		}  		break;  	case 3:  		DebugEnterAlt (3);  		// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  		{  			DebugLocation (105' 4);  			DebugLocation (105' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr216);  			Match (input' TokenTypes.Down' null);  			DebugLocation (105' 12);  			PushFollow (Follow._propertyChain_in_filterExpr219);  			propertyChain (propertySegments);  			PopFollow ();  			DebugLocation (105' 51);  			// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  			int alt7 = 2;  			try {  				DebugEnterSubRule (7);  				try {  					DebugEnterDecision (7' false);  					int LA7_1 = input.LA (1);  					if ((LA7_1 == 31)) {  						alt7 = 1;  					}  				}  				finally {  					DebugExitDecision (7);  				}  				switch (alt7) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  					{  						DebugLocation (105' 51);  						inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (7);  			}  			DebugLocation (105' 60);  			// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  			int alt8 = 2;  			try {  				DebugEnterSubRule (8);  				try {  					DebugEnterDecision (8' false);  					int LA8_1 = input.LA (1);  					if ((LA8_1 == 24)) {  						alt8 = 1;  					}  				}  				finally {  					DebugExitDecision (8);  				}  				switch (alt8) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  					{  						DebugLocation (105' 60);  						not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (8);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (106' 4);  			FilterTreeNode newProperty = new Property (propertySegments);  			if ((inverse != null ? inverse.Text : default(string)) == "?")  				filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  			else {  				if ((not != null ? not.Text : default(string)) == "!")  					newProperty.ToggleInversed ();  				filterNode = newProperty;  			}  		}  		break;  	case 4:  		DebugEnterAlt (4);  		// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  		{  			DebugLocation (116' 4);  			STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  			DebugLocation (117' 4);  			string stringText = (STRING7 != null ? STRING7.Text : default(string));  			stringText = stringText.Substring (1' stringText.Length - 2);  			filterNode = new Value (stringText);  		}  		break;  	case 5:  		DebugEnterAlt (5);  		// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  		{  			DebugLocation (122' 4);  			REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  			DebugLocation (123' 4);  			string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  			regexText = regexText.Substring (1' regexText.Length - 2);  			filterNode = new RegExp (regexText);  		}  		break;  	case 6:  		DebugEnterAlt (6);  		// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  		{  			DebugLocation (128' 4);  			NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  			DebugLocation (129' 4);  			filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  		}  		break;  	case 7:  		DebugEnterAlt (7);  		// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  		{  			DebugLocation (132' 4);  			Match (input' TRUE' Follow._TRUE_in_filterExpr271);  			DebugLocation (133' 4);  			filterNode = new Value (true);  		}  		break;  	case 8:  		DebugEnterAlt (8);  		// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  		{  			DebugLocation (136' 4);  			Match (input' FALSE' Follow._FALSE_in_filterExpr281);  			DebugLocation (137' 4);  			filterNode = new Value (false);  		}  		break;  	case 9:  		DebugEnterAlt (9);  		// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  		{  			DebugLocation (140' 4);  			Match (input' NULL' Follow._NULL_in_filterExpr291);  			DebugLocation (141' 4);  			filterNode = new Value (null);  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("filterExpr"' 6);  	LeaveRule ("filterExpr"' 6);  	LeaveRule_filterExpr ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  	int alt9 = 9;  	try {  		DebugEnterDecision (9' false);  		switch (input.LA (1)) {  		case CHAIN_OPERATOR:  		case COMPARATOR:  			{  				alt9 = 1;  			}  			break;  		case EXPR:  			{  				int LA9_2 = input.LA (2);  				if ((LA9_2 == DOWN)) {  					int LA9_3 = input.LA (3);  					if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  						alt9 = 2;  					}  					else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  						alt9 = 3;  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				else {  					NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  					DebugRecognitionException (nvae);  					throw nvae;  				}  			}  			break;  		case STRING:  			{  				alt9 = 4;  			}  			break;  		case REGEX:  			{  				alt9 = 5;  			}  			break;  		case NUMBER:  			{  				alt9 = 6;  			}  			break;  		case TRUE:  			{  				alt9 = 7;  			}  			break;  		case FALSE:  			{  				alt9 = 8;  			}  			break;  		case NULL:  			{  				alt9 = 9;  			}  			break;  		default: {  			NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  		}  	}  	finally {  		DebugExitDecision (9);  	}  	switch (alt9) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  		{  			DebugLocation (64' 4);  			DebugLocation (64' 6);  			PushFollow (Follow._comparator_in_filterExpr175);  			comparator6 = comparator ();  			PopFollow ();  			Match (input' TokenTypes.Down' null);  			DebugLocation (64' 18);  			PushFollow (Follow._filterExpr_in_filterExpr179);  			a = filterExpr ();  			PopFollow ();  			DebugLocation (64' 31);  			PushFollow (Follow._filterExpr_in_filterExpr183);  			b = filterExpr ();  			PopFollow ();  			Match (input' TokenTypes.Up' null);  			DebugLocation (65' 4);  			Comparator newComparator;  			switch (comparator6) {  			case "=":  				newComparator = Comparator.Equals;  				break;  			case "!=":  				newComparator = Comparator.NotEquals;  				break;  			case ">":  				newComparator = Comparator.Greater;  				break;  			case "<":  				newComparator = Comparator.Less;  				break;  			case ">=":  				newComparator = Comparator.GreaterOrEqual;  				break;  			case "<=":  				newComparator = Comparator.LessOrEqual;  				break;  			case "&":  				newComparator = Comparator.And;  				break;  			case "|":  				newComparator = Comparator.Or;  				break;  			default:  				newComparator = Comparator.Equals;  				break;  			}  			filterNode = new BoolExpression (a' newComparator' b);  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  		{  			DebugLocation (98' 4);  			DebugLocation (98' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr195);  			Match (input' TokenTypes.Down' null);  			DebugLocation (98' 12);  			PushFollow (Follow._filterExpr_in_filterExpr199);  			f = filterExpr ();  			PopFollow ();  			DebugLocation (98' 31);  			// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  			int alt6 = 2;  			try {  				DebugEnterSubRule (6);  				try {  					DebugEnterDecision (6' false);  					int LA6_1 = input.LA (1);  					if ((LA6_1 == 24)) {  						alt6 = 1;  					}  				}  				finally {  					DebugExitDecision (6);  				}  				switch (alt6) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  					{  						DebugLocation (98' 31);  						inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (6);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (99' 4);  			FilterTreeNode newNode = f;  			if ((inverse != null ? inverse.Text : default(string)) == "!")  				newNode.ToggleInversed ();  			filterNode = newNode;  		}  		break;  	case 3:  		DebugEnterAlt (3);  		// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  		{  			DebugLocation (105' 4);  			DebugLocation (105' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr216);  			Match (input' TokenTypes.Down' null);  			DebugLocation (105' 12);  			PushFollow (Follow._propertyChain_in_filterExpr219);  			propertyChain (propertySegments);  			PopFollow ();  			DebugLocation (105' 51);  			// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  			int alt7 = 2;  			try {  				DebugEnterSubRule (7);  				try {  					DebugEnterDecision (7' false);  					int LA7_1 = input.LA (1);  					if ((LA7_1 == 31)) {  						alt7 = 1;  					}  				}  				finally {  					DebugExitDecision (7);  				}  				switch (alt7) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  					{  						DebugLocation (105' 51);  						inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (7);  			}  			DebugLocation (105' 60);  			// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  			int alt8 = 2;  			try {  				DebugEnterSubRule (8);  				try {  					DebugEnterDecision (8' false);  					int LA8_1 = input.LA (1);  					if ((LA8_1 == 24)) {  						alt8 = 1;  					}  				}  				finally {  					DebugExitDecision (8);  				}  				switch (alt8) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  					{  						DebugLocation (105' 60);  						not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (8);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (106' 4);  			FilterTreeNode newProperty = new Property (propertySegments);  			if ((inverse != null ? inverse.Text : default(string)) == "?")  				filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  			else {  				if ((not != null ? not.Text : default(string)) == "!")  					newProperty.ToggleInversed ();  				filterNode = newProperty;  			}  		}  		break;  	case 4:  		DebugEnterAlt (4);  		// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  		{  			DebugLocation (116' 4);  			STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  			DebugLocation (117' 4);  			string stringText = (STRING7 != null ? STRING7.Text : default(string));  			stringText = stringText.Substring (1' stringText.Length - 2);  			filterNode = new Value (stringText);  		}  		break;  	case 5:  		DebugEnterAlt (5);  		// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  		{  			DebugLocation (122' 4);  			REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  			DebugLocation (123' 4);  			string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  			regexText = regexText.Substring (1' regexText.Length - 2);  			filterNode = new RegExp (regexText);  		}  		break;  	case 6:  		DebugEnterAlt (6);  		// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  		{  			DebugLocation (128' 4);  			NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  			DebugLocation (129' 4);  			filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  		}  		break;  	case 7:  		DebugEnterAlt (7);  		// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  		{  			DebugLocation (132' 4);  			Match (input' TRUE' Follow._TRUE_in_filterExpr271);  			DebugLocation (133' 4);  			filterNode = new Value (true);  		}  		break;  	case 8:  		DebugEnterAlt (8);  		// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  		{  			DebugLocation (136' 4);  			Match (input' FALSE' Follow._FALSE_in_filterExpr281);  			DebugLocation (137' 4);  			filterNode = new Value (false);  		}  		break;  	case 9:  		DebugEnterAlt (9);  		// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  		{  			DebugLocation (140' 4);  			Match (input' NULL' Follow._NULL_in_filterExpr291);  			DebugLocation (141' 4);  			filterNode = new Value (null);  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("filterExpr"' 6);  	LeaveRule ("filterExpr"' 6);  	LeaveRule_filterExpr ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  	int alt9 = 9;  	try {  		DebugEnterDecision (9' false);  		switch (input.LA (1)) {  		case CHAIN_OPERATOR:  		case COMPARATOR:  			{  				alt9 = 1;  			}  			break;  		case EXPR:  			{  				int LA9_2 = input.LA (2);  				if ((LA9_2 == DOWN)) {  					int LA9_3 = input.LA (3);  					if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  						alt9 = 2;  					}  					else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  						alt9 = 3;  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				else {  					NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  					DebugRecognitionException (nvae);  					throw nvae;  				}  			}  			break;  		case STRING:  			{  				alt9 = 4;  			}  			break;  		case REGEX:  			{  				alt9 = 5;  			}  			break;  		case NUMBER:  			{  				alt9 = 6;  			}  			break;  		case TRUE:  			{  				alt9 = 7;  			}  			break;  		case FALSE:  			{  				alt9 = 8;  			}  			break;  		case NULL:  			{  				alt9 = 9;  			}  			break;  		default: {  			NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  		}  	}  	finally {  		DebugExitDecision (9);  	}  	switch (alt9) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  		{  			DebugLocation (64' 4);  			DebugLocation (64' 6);  			PushFollow (Follow._comparator_in_filterExpr175);  			comparator6 = comparator ();  			PopFollow ();  			Match (input' TokenTypes.Down' null);  			DebugLocation (64' 18);  			PushFollow (Follow._filterExpr_in_filterExpr179);  			a = filterExpr ();  			PopFollow ();  			DebugLocation (64' 31);  			PushFollow (Follow._filterExpr_in_filterExpr183);  			b = filterExpr ();  			PopFollow ();  			Match (input' TokenTypes.Up' null);  			DebugLocation (65' 4);  			Comparator newComparator;  			switch (comparator6) {  			case "=":  				newComparator = Comparator.Equals;  				break;  			case "!=":  				newComparator = Comparator.NotEquals;  				break;  			case ">":  				newComparator = Comparator.Greater;  				break;  			case "<":  				newComparator = Comparator.Less;  				break;  			case ">=":  				newComparator = Comparator.GreaterOrEqual;  				break;  			case "<=":  				newComparator = Comparator.LessOrEqual;  				break;  			case "&":  				newComparator = Comparator.And;  				break;  			case "|":  				newComparator = Comparator.Or;  				break;  			default:  				newComparator = Comparator.Equals;  				break;  			}  			filterNode = new BoolExpression (a' newComparator' b);  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  		{  			DebugLocation (98' 4);  			DebugLocation (98' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr195);  			Match (input' TokenTypes.Down' null);  			DebugLocation (98' 12);  			PushFollow (Follow._filterExpr_in_filterExpr199);  			f = filterExpr ();  			PopFollow ();  			DebugLocation (98' 31);  			// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  			int alt6 = 2;  			try {  				DebugEnterSubRule (6);  				try {  					DebugEnterDecision (6' false);  					int LA6_1 = input.LA (1);  					if ((LA6_1 == 24)) {  						alt6 = 1;  					}  				}  				finally {  					DebugExitDecision (6);  				}  				switch (alt6) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  					{  						DebugLocation (98' 31);  						inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (6);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (99' 4);  			FilterTreeNode newNode = f;  			if ((inverse != null ? inverse.Text : default(string)) == "!")  				newNode.ToggleInversed ();  			filterNode = newNode;  		}  		break;  	case 3:  		DebugEnterAlt (3);  		// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  		{  			DebugLocation (105' 4);  			DebugLocation (105' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr216);  			Match (input' TokenTypes.Down' null);  			DebugLocation (105' 12);  			PushFollow (Follow._propertyChain_in_filterExpr219);  			propertyChain (propertySegments);  			PopFollow ();  			DebugLocation (105' 51);  			// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  			int alt7 = 2;  			try {  				DebugEnterSubRule (7);  				try {  					DebugEnterDecision (7' false);  					int LA7_1 = input.LA (1);  					if ((LA7_1 == 31)) {  						alt7 = 1;  					}  				}  				finally {  					DebugExitDecision (7);  				}  				switch (alt7) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  					{  						DebugLocation (105' 51);  						inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (7);  			}  			DebugLocation (105' 60);  			// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  			int alt8 = 2;  			try {  				DebugEnterSubRule (8);  				try {  					DebugEnterDecision (8' false);  					int LA8_1 = input.LA (1);  					if ((LA8_1 == 24)) {  						alt8 = 1;  					}  				}  				finally {  					DebugExitDecision (8);  				}  				switch (alt8) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  					{  						DebugLocation (105' 60);  						not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (8);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (106' 4);  			FilterTreeNode newProperty = new Property (propertySegments);  			if ((inverse != null ? inverse.Text : default(string)) == "?")  				filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  			else {  				if ((not != null ? not.Text : default(string)) == "!")  					newProperty.ToggleInversed ();  				filterNode = newProperty;  			}  		}  		break;  	case 4:  		DebugEnterAlt (4);  		// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  		{  			DebugLocation (116' 4);  			STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  			DebugLocation (117' 4);  			string stringText = (STRING7 != null ? STRING7.Text : default(string));  			stringText = stringText.Substring (1' stringText.Length - 2);  			filterNode = new Value (stringText);  		}  		break;  	case 5:  		DebugEnterAlt (5);  		// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  		{  			DebugLocation (122' 4);  			REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  			DebugLocation (123' 4);  			string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  			regexText = regexText.Substring (1' regexText.Length - 2);  			filterNode = new RegExp (regexText);  		}  		break;  	case 6:  		DebugEnterAlt (6);  		// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  		{  			DebugLocation (128' 4);  			NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  			DebugLocation (129' 4);  			filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  		}  		break;  	case 7:  		DebugEnterAlt (7);  		// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  		{  			DebugLocation (132' 4);  			Match (input' TRUE' Follow._TRUE_in_filterExpr271);  			DebugLocation (133' 4);  			filterNode = new Value (true);  		}  		break;  	case 8:  		DebugEnterAlt (8);  		// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  		{  			DebugLocation (136' 4);  			Match (input' FALSE' Follow._FALSE_in_filterExpr281);  			DebugLocation (137' 4);  			filterNode = new Value (false);  		}  		break;  	case 9:  		DebugEnterAlt (9);  		// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  		{  			DebugLocation (140' 4);  			Match (input' NULL' Follow._NULL_in_filterExpr291);  			DebugLocation (141' 4);  			filterNode = new Value (null);  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("filterExpr"' 6);  	LeaveRule ("filterExpr"' 6);  	LeaveRule_filterExpr ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  	int alt9 = 9;  	try {  		DebugEnterDecision (9' false);  		switch (input.LA (1)) {  		case CHAIN_OPERATOR:  		case COMPARATOR:  			{  				alt9 = 1;  			}  			break;  		case EXPR:  			{  				int LA9_2 = input.LA (2);  				if ((LA9_2 == DOWN)) {  					int LA9_3 = input.LA (3);  					if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  						alt9 = 2;  					}  					else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  						alt9 = 3;  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				else {  					NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  					DebugRecognitionException (nvae);  					throw nvae;  				}  			}  			break;  		case STRING:  			{  				alt9 = 4;  			}  			break;  		case REGEX:  			{  				alt9 = 5;  			}  			break;  		case NUMBER:  			{  				alt9 = 6;  			}  			break;  		case TRUE:  			{  				alt9 = 7;  			}  			break;  		case FALSE:  			{  				alt9 = 8;  			}  			break;  		case NULL:  			{  				alt9 = 9;  			}  			break;  		default: {  			NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  		}  	}  	finally {  		DebugExitDecision (9);  	}  	switch (alt9) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  		{  			DebugLocation (64' 4);  			DebugLocation (64' 6);  			PushFollow (Follow._comparator_in_filterExpr175);  			comparator6 = comparator ();  			PopFollow ();  			Match (input' TokenTypes.Down' null);  			DebugLocation (64' 18);  			PushFollow (Follow._filterExpr_in_filterExpr179);  			a = filterExpr ();  			PopFollow ();  			DebugLocation (64' 31);  			PushFollow (Follow._filterExpr_in_filterExpr183);  			b = filterExpr ();  			PopFollow ();  			Match (input' TokenTypes.Up' null);  			DebugLocation (65' 4);  			Comparator newComparator;  			switch (comparator6) {  			case "=":  				newComparator = Comparator.Equals;  				break;  			case "!=":  				newComparator = Comparator.NotEquals;  				break;  			case ">":  				newComparator = Comparator.Greater;  				break;  			case "<":  				newComparator = Comparator.Less;  				break;  			case ">=":  				newComparator = Comparator.GreaterOrEqual;  				break;  			case "<=":  				newComparator = Comparator.LessOrEqual;  				break;  			case "&":  				newComparator = Comparator.And;  				break;  			case "|":  				newComparator = Comparator.Or;  				break;  			default:  				newComparator = Comparator.Equals;  				break;  			}  			filterNode = new BoolExpression (a' newComparator' b);  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  		{  			DebugLocation (98' 4);  			DebugLocation (98' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr195);  			Match (input' TokenTypes.Down' null);  			DebugLocation (98' 12);  			PushFollow (Follow._filterExpr_in_filterExpr199);  			f = filterExpr ();  			PopFollow ();  			DebugLocation (98' 31);  			// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  			int alt6 = 2;  			try {  				DebugEnterSubRule (6);  				try {  					DebugEnterDecision (6' false);  					int LA6_1 = input.LA (1);  					if ((LA6_1 == 24)) {  						alt6 = 1;  					}  				}  				finally {  					DebugExitDecision (6);  				}  				switch (alt6) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  					{  						DebugLocation (98' 31);  						inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (6);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (99' 4);  			FilterTreeNode newNode = f;  			if ((inverse != null ? inverse.Text : default(string)) == "!")  				newNode.ToggleInversed ();  			filterNode = newNode;  		}  		break;  	case 3:  		DebugEnterAlt (3);  		// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  		{  			DebugLocation (105' 4);  			DebugLocation (105' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr216);  			Match (input' TokenTypes.Down' null);  			DebugLocation (105' 12);  			PushFollow (Follow._propertyChain_in_filterExpr219);  			propertyChain (propertySegments);  			PopFollow ();  			DebugLocation (105' 51);  			// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  			int alt7 = 2;  			try {  				DebugEnterSubRule (7);  				try {  					DebugEnterDecision (7' false);  					int LA7_1 = input.LA (1);  					if ((LA7_1 == 31)) {  						alt7 = 1;  					}  				}  				finally {  					DebugExitDecision (7);  				}  				switch (alt7) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  					{  						DebugLocation (105' 51);  						inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (7);  			}  			DebugLocation (105' 60);  			// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  			int alt8 = 2;  			try {  				DebugEnterSubRule (8);  				try {  					DebugEnterDecision (8' false);  					int LA8_1 = input.LA (1);  					if ((LA8_1 == 24)) {  						alt8 = 1;  					}  				}  				finally {  					DebugExitDecision (8);  				}  				switch (alt8) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  					{  						DebugLocation (105' 60);  						not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (8);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (106' 4);  			FilterTreeNode newProperty = new Property (propertySegments);  			if ((inverse != null ? inverse.Text : default(string)) == "?")  				filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  			else {  				if ((not != null ? not.Text : default(string)) == "!")  					newProperty.ToggleInversed ();  				filterNode = newProperty;  			}  		}  		break;  	case 4:  		DebugEnterAlt (4);  		// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  		{  			DebugLocation (116' 4);  			STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  			DebugLocation (117' 4);  			string stringText = (STRING7 != null ? STRING7.Text : default(string));  			stringText = stringText.Substring (1' stringText.Length - 2);  			filterNode = new Value (stringText);  		}  		break;  	case 5:  		DebugEnterAlt (5);  		// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  		{  			DebugLocation (122' 4);  			REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  			DebugLocation (123' 4);  			string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  			regexText = regexText.Substring (1' regexText.Length - 2);  			filterNode = new RegExp (regexText);  		}  		break;  	case 6:  		DebugEnterAlt (6);  		// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  		{  			DebugLocation (128' 4);  			NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  			DebugLocation (129' 4);  			filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  		}  		break;  	case 7:  		DebugEnterAlt (7);  		// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  		{  			DebugLocation (132' 4);  			Match (input' TRUE' Follow._TRUE_in_filterExpr271);  			DebugLocation (133' 4);  			filterNode = new Value (true);  		}  		break;  	case 8:  		DebugEnterAlt (8);  		// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  		{  			DebugLocation (136' 4);  			Match (input' FALSE' Follow._FALSE_in_filterExpr281);  			DebugLocation (137' 4);  			filterNode = new Value (false);  		}  		break;  	case 9:  		DebugEnterAlt (9);  		// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  		{  			DebugLocation (140' 4);  			Match (input' NULL' Follow._NULL_in_filterExpr291);  			DebugLocation (141' 4);  			filterNode = new Value (null);  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("filterExpr"' 6);  	LeaveRule ("filterExpr"' 6);  	LeaveRule_filterExpr ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  	int alt9 = 9;  	try {  		DebugEnterDecision (9' false);  		switch (input.LA (1)) {  		case CHAIN_OPERATOR:  		case COMPARATOR:  			{  				alt9 = 1;  			}  			break;  		case EXPR:  			{  				int LA9_2 = input.LA (2);  				if ((LA9_2 == DOWN)) {  					int LA9_3 = input.LA (3);  					if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  						alt9 = 2;  					}  					else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  						alt9 = 3;  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				else {  					NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  					DebugRecognitionException (nvae);  					throw nvae;  				}  			}  			break;  		case STRING:  			{  				alt9 = 4;  			}  			break;  		case REGEX:  			{  				alt9 = 5;  			}  			break;  		case NUMBER:  			{  				alt9 = 6;  			}  			break;  		case TRUE:  			{  				alt9 = 7;  			}  			break;  		case FALSE:  			{  				alt9 = 8;  			}  			break;  		case NULL:  			{  				alt9 = 9;  			}  			break;  		default: {  			NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  		}  	}  	finally {  		DebugExitDecision (9);  	}  	switch (alt9) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  		{  			DebugLocation (64' 4);  			DebugLocation (64' 6);  			PushFollow (Follow._comparator_in_filterExpr175);  			comparator6 = comparator ();  			PopFollow ();  			Match (input' TokenTypes.Down' null);  			DebugLocation (64' 18);  			PushFollow (Follow._filterExpr_in_filterExpr179);  			a = filterExpr ();  			PopFollow ();  			DebugLocation (64' 31);  			PushFollow (Follow._filterExpr_in_filterExpr183);  			b = filterExpr ();  			PopFollow ();  			Match (input' TokenTypes.Up' null);  			DebugLocation (65' 4);  			Comparator newComparator;  			switch (comparator6) {  			case "=":  				newComparator = Comparator.Equals;  				break;  			case "!=":  				newComparator = Comparator.NotEquals;  				break;  			case ">":  				newComparator = Comparator.Greater;  				break;  			case "<":  				newComparator = Comparator.Less;  				break;  			case ">=":  				newComparator = Comparator.GreaterOrEqual;  				break;  			case "<=":  				newComparator = Comparator.LessOrEqual;  				break;  			case "&":  				newComparator = Comparator.And;  				break;  			case "|":  				newComparator = Comparator.Or;  				break;  			default:  				newComparator = Comparator.Equals;  				break;  			}  			filterNode = new BoolExpression (a' newComparator' b);  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  		{  			DebugLocation (98' 4);  			DebugLocation (98' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr195);  			Match (input' TokenTypes.Down' null);  			DebugLocation (98' 12);  			PushFollow (Follow._filterExpr_in_filterExpr199);  			f = filterExpr ();  			PopFollow ();  			DebugLocation (98' 31);  			// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  			int alt6 = 2;  			try {  				DebugEnterSubRule (6);  				try {  					DebugEnterDecision (6' false);  					int LA6_1 = input.LA (1);  					if ((LA6_1 == 24)) {  						alt6 = 1;  					}  				}  				finally {  					DebugExitDecision (6);  				}  				switch (alt6) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  					{  						DebugLocation (98' 31);  						inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (6);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (99' 4);  			FilterTreeNode newNode = f;  			if ((inverse != null ? inverse.Text : default(string)) == "!")  				newNode.ToggleInversed ();  			filterNode = newNode;  		}  		break;  	case 3:  		DebugEnterAlt (3);  		// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  		{  			DebugLocation (105' 4);  			DebugLocation (105' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr216);  			Match (input' TokenTypes.Down' null);  			DebugLocation (105' 12);  			PushFollow (Follow._propertyChain_in_filterExpr219);  			propertyChain (propertySegments);  			PopFollow ();  			DebugLocation (105' 51);  			// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  			int alt7 = 2;  			try {  				DebugEnterSubRule (7);  				try {  					DebugEnterDecision (7' false);  					int LA7_1 = input.LA (1);  					if ((LA7_1 == 31)) {  						alt7 = 1;  					}  				}  				finally {  					DebugExitDecision (7);  				}  				switch (alt7) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  					{  						DebugLocation (105' 51);  						inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (7);  			}  			DebugLocation (105' 60);  			// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  			int alt8 = 2;  			try {  				DebugEnterSubRule (8);  				try {  					DebugEnterDecision (8' false);  					int LA8_1 = input.LA (1);  					if ((LA8_1 == 24)) {  						alt8 = 1;  					}  				}  				finally {  					DebugExitDecision (8);  				}  				switch (alt8) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  					{  						DebugLocation (105' 60);  						not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (8);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (106' 4);  			FilterTreeNode newProperty = new Property (propertySegments);  			if ((inverse != null ? inverse.Text : default(string)) == "?")  				filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  			else {  				if ((not != null ? not.Text : default(string)) == "!")  					newProperty.ToggleInversed ();  				filterNode = newProperty;  			}  		}  		break;  	case 4:  		DebugEnterAlt (4);  		// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  		{  			DebugLocation (116' 4);  			STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  			DebugLocation (117' 4);  			string stringText = (STRING7 != null ? STRING7.Text : default(string));  			stringText = stringText.Substring (1' stringText.Length - 2);  			filterNode = new Value (stringText);  		}  		break;  	case 5:  		DebugEnterAlt (5);  		// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  		{  			DebugLocation (122' 4);  			REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  			DebugLocation (123' 4);  			string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  			regexText = regexText.Substring (1' regexText.Length - 2);  			filterNode = new RegExp (regexText);  		}  		break;  	case 6:  		DebugEnterAlt (6);  		// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  		{  			DebugLocation (128' 4);  			NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  			DebugLocation (129' 4);  			filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  		}  		break;  	case 7:  		DebugEnterAlt (7);  		// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  		{  			DebugLocation (132' 4);  			Match (input' TRUE' Follow._TRUE_in_filterExpr271);  			DebugLocation (133' 4);  			filterNode = new Value (true);  		}  		break;  	case 8:  		DebugEnterAlt (8);  		// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  		{  			DebugLocation (136' 4);  			Match (input' FALSE' Follow._FALSE_in_filterExpr281);  			DebugLocation (137' 4);  			filterNode = new Value (false);  		}  		break;  	case 9:  		DebugEnterAlt (9);  		// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  		{  			DebugLocation (140' 4);  			Match (input' NULL' Follow._NULL_in_filterExpr291);  			DebugLocation (141' 4);  			filterNode = new Value (null);  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("filterExpr"' 6);  	LeaveRule ("filterExpr"' 6);  	LeaveRule_filterExpr ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  	int alt9 = 9;  	try {  		DebugEnterDecision (9' false);  		switch (input.LA (1)) {  		case CHAIN_OPERATOR:  		case COMPARATOR:  			{  				alt9 = 1;  			}  			break;  		case EXPR:  			{  				int LA9_2 = input.LA (2);  				if ((LA9_2 == DOWN)) {  					int LA9_3 = input.LA (3);  					if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  						alt9 = 2;  					}  					else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  						alt9 = 3;  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				else {  					NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  					DebugRecognitionException (nvae);  					throw nvae;  				}  			}  			break;  		case STRING:  			{  				alt9 = 4;  			}  			break;  		case REGEX:  			{  				alt9 = 5;  			}  			break;  		case NUMBER:  			{  				alt9 = 6;  			}  			break;  		case TRUE:  			{  				alt9 = 7;  			}  			break;  		case FALSE:  			{  				alt9 = 8;  			}  			break;  		case NULL:  			{  				alt9 = 9;  			}  			break;  		default: {  			NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  		}  	}  	finally {  		DebugExitDecision (9);  	}  	switch (alt9) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  		{  			DebugLocation (64' 4);  			DebugLocation (64' 6);  			PushFollow (Follow._comparator_in_filterExpr175);  			comparator6 = comparator ();  			PopFollow ();  			Match (input' TokenTypes.Down' null);  			DebugLocation (64' 18);  			PushFollow (Follow._filterExpr_in_filterExpr179);  			a = filterExpr ();  			PopFollow ();  			DebugLocation (64' 31);  			PushFollow (Follow._filterExpr_in_filterExpr183);  			b = filterExpr ();  			PopFollow ();  			Match (input' TokenTypes.Up' null);  			DebugLocation (65' 4);  			Comparator newComparator;  			switch (comparator6) {  			case "=":  				newComparator = Comparator.Equals;  				break;  			case "!=":  				newComparator = Comparator.NotEquals;  				break;  			case ">":  				newComparator = Comparator.Greater;  				break;  			case "<":  				newComparator = Comparator.Less;  				break;  			case ">=":  				newComparator = Comparator.GreaterOrEqual;  				break;  			case "<=":  				newComparator = Comparator.LessOrEqual;  				break;  			case "&":  				newComparator = Comparator.And;  				break;  			case "|":  				newComparator = Comparator.Or;  				break;  			default:  				newComparator = Comparator.Equals;  				break;  			}  			filterNode = new BoolExpression (a' newComparator' b);  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  		{  			DebugLocation (98' 4);  			DebugLocation (98' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr195);  			Match (input' TokenTypes.Down' null);  			DebugLocation (98' 12);  			PushFollow (Follow._filterExpr_in_filterExpr199);  			f = filterExpr ();  			PopFollow ();  			DebugLocation (98' 31);  			// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  			int alt6 = 2;  			try {  				DebugEnterSubRule (6);  				try {  					DebugEnterDecision (6' false);  					int LA6_1 = input.LA (1);  					if ((LA6_1 == 24)) {  						alt6 = 1;  					}  				}  				finally {  					DebugExitDecision (6);  				}  				switch (alt6) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  					{  						DebugLocation (98' 31);  						inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (6);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (99' 4);  			FilterTreeNode newNode = f;  			if ((inverse != null ? inverse.Text : default(string)) == "!")  				newNode.ToggleInversed ();  			filterNode = newNode;  		}  		break;  	case 3:  		DebugEnterAlt (3);  		// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  		{  			DebugLocation (105' 4);  			DebugLocation (105' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr216);  			Match (input' TokenTypes.Down' null);  			DebugLocation (105' 12);  			PushFollow (Follow._propertyChain_in_filterExpr219);  			propertyChain (propertySegments);  			PopFollow ();  			DebugLocation (105' 51);  			// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  			int alt7 = 2;  			try {  				DebugEnterSubRule (7);  				try {  					DebugEnterDecision (7' false);  					int LA7_1 = input.LA (1);  					if ((LA7_1 == 31)) {  						alt7 = 1;  					}  				}  				finally {  					DebugExitDecision (7);  				}  				switch (alt7) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  					{  						DebugLocation (105' 51);  						inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (7);  			}  			DebugLocation (105' 60);  			// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  			int alt8 = 2;  			try {  				DebugEnterSubRule (8);  				try {  					DebugEnterDecision (8' false);  					int LA8_1 = input.LA (1);  					if ((LA8_1 == 24)) {  						alt8 = 1;  					}  				}  				finally {  					DebugExitDecision (8);  				}  				switch (alt8) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  					{  						DebugLocation (105' 60);  						not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (8);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (106' 4);  			FilterTreeNode newProperty = new Property (propertySegments);  			if ((inverse != null ? inverse.Text : default(string)) == "?")  				filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  			else {  				if ((not != null ? not.Text : default(string)) == "!")  					newProperty.ToggleInversed ();  				filterNode = newProperty;  			}  		}  		break;  	case 4:  		DebugEnterAlt (4);  		// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  		{  			DebugLocation (116' 4);  			STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  			DebugLocation (117' 4);  			string stringText = (STRING7 != null ? STRING7.Text : default(string));  			stringText = stringText.Substring (1' stringText.Length - 2);  			filterNode = new Value (stringText);  		}  		break;  	case 5:  		DebugEnterAlt (5);  		// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  		{  			DebugLocation (122' 4);  			REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  			DebugLocation (123' 4);  			string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  			regexText = regexText.Substring (1' regexText.Length - 2);  			filterNode = new RegExp (regexText);  		}  		break;  	case 6:  		DebugEnterAlt (6);  		// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  		{  			DebugLocation (128' 4);  			NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  			DebugLocation (129' 4);  			filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  		}  		break;  	case 7:  		DebugEnterAlt (7);  		// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  		{  			DebugLocation (132' 4);  			Match (input' TRUE' Follow._TRUE_in_filterExpr271);  			DebugLocation (133' 4);  			filterNode = new Value (true);  		}  		break;  	case 8:  		DebugEnterAlt (8);  		// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  		{  			DebugLocation (136' 4);  			Match (input' FALSE' Follow._FALSE_in_filterExpr281);  			DebugLocation (137' 4);  			filterNode = new Value (false);  		}  		break;  	case 9:  		DebugEnterAlt (9);  		// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  		{  			DebugLocation (140' 4);  			Match (input' NULL' Follow._NULL_in_filterExpr291);  			DebugLocation (141' 4);  			filterNode = new Value (null);  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("filterExpr"' 6);  	LeaveRule ("filterExpr"' 6);  	LeaveRule_filterExpr ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  	int alt9 = 9;  	try {  		DebugEnterDecision (9' false);  		switch (input.LA (1)) {  		case CHAIN_OPERATOR:  		case COMPARATOR:  			{  				alt9 = 1;  			}  			break;  		case EXPR:  			{  				int LA9_2 = input.LA (2);  				if ((LA9_2 == DOWN)) {  					int LA9_3 = input.LA (3);  					if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  						alt9 = 2;  					}  					else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  						alt9 = 3;  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				else {  					NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  					DebugRecognitionException (nvae);  					throw nvae;  				}  			}  			break;  		case STRING:  			{  				alt9 = 4;  			}  			break;  		case REGEX:  			{  				alt9 = 5;  			}  			break;  		case NUMBER:  			{  				alt9 = 6;  			}  			break;  		case TRUE:  			{  				alt9 = 7;  			}  			break;  		case FALSE:  			{  				alt9 = 8;  			}  			break;  		case NULL:  			{  				alt9 = 9;  			}  			break;  		default: {  			NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  		}  	}  	finally {  		DebugExitDecision (9);  	}  	switch (alt9) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  		{  			DebugLocation (64' 4);  			DebugLocation (64' 6);  			PushFollow (Follow._comparator_in_filterExpr175);  			comparator6 = comparator ();  			PopFollow ();  			Match (input' TokenTypes.Down' null);  			DebugLocation (64' 18);  			PushFollow (Follow._filterExpr_in_filterExpr179);  			a = filterExpr ();  			PopFollow ();  			DebugLocation (64' 31);  			PushFollow (Follow._filterExpr_in_filterExpr183);  			b = filterExpr ();  			PopFollow ();  			Match (input' TokenTypes.Up' null);  			DebugLocation (65' 4);  			Comparator newComparator;  			switch (comparator6) {  			case "=":  				newComparator = Comparator.Equals;  				break;  			case "!=":  				newComparator = Comparator.NotEquals;  				break;  			case ">":  				newComparator = Comparator.Greater;  				break;  			case "<":  				newComparator = Comparator.Less;  				break;  			case ">=":  				newComparator = Comparator.GreaterOrEqual;  				break;  			case "<=":  				newComparator = Comparator.LessOrEqual;  				break;  			case "&":  				newComparator = Comparator.And;  				break;  			case "|":  				newComparator = Comparator.Or;  				break;  			default:  				newComparator = Comparator.Equals;  				break;  			}  			filterNode = new BoolExpression (a' newComparator' b);  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  		{  			DebugLocation (98' 4);  			DebugLocation (98' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr195);  			Match (input' TokenTypes.Down' null);  			DebugLocation (98' 12);  			PushFollow (Follow._filterExpr_in_filterExpr199);  			f = filterExpr ();  			PopFollow ();  			DebugLocation (98' 31);  			// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  			int alt6 = 2;  			try {  				DebugEnterSubRule (6);  				try {  					DebugEnterDecision (6' false);  					int LA6_1 = input.LA (1);  					if ((LA6_1 == 24)) {  						alt6 = 1;  					}  				}  				finally {  					DebugExitDecision (6);  				}  				switch (alt6) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  					{  						DebugLocation (98' 31);  						inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (6);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (99' 4);  			FilterTreeNode newNode = f;  			if ((inverse != null ? inverse.Text : default(string)) == "!")  				newNode.ToggleInversed ();  			filterNode = newNode;  		}  		break;  	case 3:  		DebugEnterAlt (3);  		// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  		{  			DebugLocation (105' 4);  			DebugLocation (105' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr216);  			Match (input' TokenTypes.Down' null);  			DebugLocation (105' 12);  			PushFollow (Follow._propertyChain_in_filterExpr219);  			propertyChain (propertySegments);  			PopFollow ();  			DebugLocation (105' 51);  			// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  			int alt7 = 2;  			try {  				DebugEnterSubRule (7);  				try {  					DebugEnterDecision (7' false);  					int LA7_1 = input.LA (1);  					if ((LA7_1 == 31)) {  						alt7 = 1;  					}  				}  				finally {  					DebugExitDecision (7);  				}  				switch (alt7) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  					{  						DebugLocation (105' 51);  						inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (7);  			}  			DebugLocation (105' 60);  			// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  			int alt8 = 2;  			try {  				DebugEnterSubRule (8);  				try {  					DebugEnterDecision (8' false);  					int LA8_1 = input.LA (1);  					if ((LA8_1 == 24)) {  						alt8 = 1;  					}  				}  				finally {  					DebugExitDecision (8);  				}  				switch (alt8) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  					{  						DebugLocation (105' 60);  						not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (8);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (106' 4);  			FilterTreeNode newProperty = new Property (propertySegments);  			if ((inverse != null ? inverse.Text : default(string)) == "?")  				filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  			else {  				if ((not != null ? not.Text : default(string)) == "!")  					newProperty.ToggleInversed ();  				filterNode = newProperty;  			}  		}  		break;  	case 4:  		DebugEnterAlt (4);  		// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  		{  			DebugLocation (116' 4);  			STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  			DebugLocation (117' 4);  			string stringText = (STRING7 != null ? STRING7.Text : default(string));  			stringText = stringText.Substring (1' stringText.Length - 2);  			filterNode = new Value (stringText);  		}  		break;  	case 5:  		DebugEnterAlt (5);  		// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  		{  			DebugLocation (122' 4);  			REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  			DebugLocation (123' 4);  			string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  			regexText = regexText.Substring (1' regexText.Length - 2);  			filterNode = new RegExp (regexText);  		}  		break;  	case 6:  		DebugEnterAlt (6);  		// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  		{  			DebugLocation (128' 4);  			NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  			DebugLocation (129' 4);  			filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  		}  		break;  	case 7:  		DebugEnterAlt (7);  		// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  		{  			DebugLocation (132' 4);  			Match (input' TRUE' Follow._TRUE_in_filterExpr271);  			DebugLocation (133' 4);  			filterNode = new Value (true);  		}  		break;  	case 8:  		DebugEnterAlt (8);  		// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  		{  			DebugLocation (136' 4);  			Match (input' FALSE' Follow._FALSE_in_filterExpr281);  			DebugLocation (137' 4);  			filterNode = new Value (false);  		}  		break;  	case 9:  		DebugEnterAlt (9);  		// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  		{  			DebugLocation (140' 4);  			Match (input' NULL' Follow._NULL_in_filterExpr291);  			DebugLocation (141' 4);  			filterNode = new Value (null);  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("filterExpr"' 6);  	LeaveRule ("filterExpr"' 6);  	LeaveRule_filterExpr ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  	int alt9 = 9;  	try {  		DebugEnterDecision (9' false);  		switch (input.LA (1)) {  		case CHAIN_OPERATOR:  		case COMPARATOR:  			{  				alt9 = 1;  			}  			break;  		case EXPR:  			{  				int LA9_2 = input.LA (2);  				if ((LA9_2 == DOWN)) {  					int LA9_3 = input.LA (3);  					if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  						alt9 = 2;  					}  					else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  						alt9 = 3;  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				else {  					NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  					DebugRecognitionException (nvae);  					throw nvae;  				}  			}  			break;  		case STRING:  			{  				alt9 = 4;  			}  			break;  		case REGEX:  			{  				alt9 = 5;  			}  			break;  		case NUMBER:  			{  				alt9 = 6;  			}  			break;  		case TRUE:  			{  				alt9 = 7;  			}  			break;  		case FALSE:  			{  				alt9 = 8;  			}  			break;  		case NULL:  			{  				alt9 = 9;  			}  			break;  		default: {  			NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  		}  	}  	finally {  		DebugExitDecision (9);  	}  	switch (alt9) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  		{  			DebugLocation (64' 4);  			DebugLocation (64' 6);  			PushFollow (Follow._comparator_in_filterExpr175);  			comparator6 = comparator ();  			PopFollow ();  			Match (input' TokenTypes.Down' null);  			DebugLocation (64' 18);  			PushFollow (Follow._filterExpr_in_filterExpr179);  			a = filterExpr ();  			PopFollow ();  			DebugLocation (64' 31);  			PushFollow (Follow._filterExpr_in_filterExpr183);  			b = filterExpr ();  			PopFollow ();  			Match (input' TokenTypes.Up' null);  			DebugLocation (65' 4);  			Comparator newComparator;  			switch (comparator6) {  			case "=":  				newComparator = Comparator.Equals;  				break;  			case "!=":  				newComparator = Comparator.NotEquals;  				break;  			case ">":  				newComparator = Comparator.Greater;  				break;  			case "<":  				newComparator = Comparator.Less;  				break;  			case ">=":  				newComparator = Comparator.GreaterOrEqual;  				break;  			case "<=":  				newComparator = Comparator.LessOrEqual;  				break;  			case "&":  				newComparator = Comparator.And;  				break;  			case "|":  				newComparator = Comparator.Or;  				break;  			default:  				newComparator = Comparator.Equals;  				break;  			}  			filterNode = new BoolExpression (a' newComparator' b);  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  		{  			DebugLocation (98' 4);  			DebugLocation (98' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr195);  			Match (input' TokenTypes.Down' null);  			DebugLocation (98' 12);  			PushFollow (Follow._filterExpr_in_filterExpr199);  			f = filterExpr ();  			PopFollow ();  			DebugLocation (98' 31);  			// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  			int alt6 = 2;  			try {  				DebugEnterSubRule (6);  				try {  					DebugEnterDecision (6' false);  					int LA6_1 = input.LA (1);  					if ((LA6_1 == 24)) {  						alt6 = 1;  					}  				}  				finally {  					DebugExitDecision (6);  				}  				switch (alt6) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  					{  						DebugLocation (98' 31);  						inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (6);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (99' 4);  			FilterTreeNode newNode = f;  			if ((inverse != null ? inverse.Text : default(string)) == "!")  				newNode.ToggleInversed ();  			filterNode = newNode;  		}  		break;  	case 3:  		DebugEnterAlt (3);  		// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  		{  			DebugLocation (105' 4);  			DebugLocation (105' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr216);  			Match (input' TokenTypes.Down' null);  			DebugLocation (105' 12);  			PushFollow (Follow._propertyChain_in_filterExpr219);  			propertyChain (propertySegments);  			PopFollow ();  			DebugLocation (105' 51);  			// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  			int alt7 = 2;  			try {  				DebugEnterSubRule (7);  				try {  					DebugEnterDecision (7' false);  					int LA7_1 = input.LA (1);  					if ((LA7_1 == 31)) {  						alt7 = 1;  					}  				}  				finally {  					DebugExitDecision (7);  				}  				switch (alt7) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  					{  						DebugLocation (105' 51);  						inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (7);  			}  			DebugLocation (105' 60);  			// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  			int alt8 = 2;  			try {  				DebugEnterSubRule (8);  				try {  					DebugEnterDecision (8' false);  					int LA8_1 = input.LA (1);  					if ((LA8_1 == 24)) {  						alt8 = 1;  					}  				}  				finally {  					DebugExitDecision (8);  				}  				switch (alt8) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  					{  						DebugLocation (105' 60);  						not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (8);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (106' 4);  			FilterTreeNode newProperty = new Property (propertySegments);  			if ((inverse != null ? inverse.Text : default(string)) == "?")  				filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  			else {  				if ((not != null ? not.Text : default(string)) == "!")  					newProperty.ToggleInversed ();  				filterNode = newProperty;  			}  		}  		break;  	case 4:  		DebugEnterAlt (4);  		// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  		{  			DebugLocation (116' 4);  			STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  			DebugLocation (117' 4);  			string stringText = (STRING7 != null ? STRING7.Text : default(string));  			stringText = stringText.Substring (1' stringText.Length - 2);  			filterNode = new Value (stringText);  		}  		break;  	case 5:  		DebugEnterAlt (5);  		// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  		{  			DebugLocation (122' 4);  			REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  			DebugLocation (123' 4);  			string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  			regexText = regexText.Substring (1' regexText.Length - 2);  			filterNode = new RegExp (regexText);  		}  		break;  	case 6:  		DebugEnterAlt (6);  		// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  		{  			DebugLocation (128' 4);  			NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  			DebugLocation (129' 4);  			filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  		}  		break;  	case 7:  		DebugEnterAlt (7);  		// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  		{  			DebugLocation (132' 4);  			Match (input' TRUE' Follow._TRUE_in_filterExpr271);  			DebugLocation (133' 4);  			filterNode = new Value (true);  		}  		break;  	case 8:  		DebugEnterAlt (8);  		// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  		{  			DebugLocation (136' 4);  			Match (input' FALSE' Follow._FALSE_in_filterExpr281);  			DebugLocation (137' 4);  			filterNode = new Value (false);  		}  		break;  	case 9:  		DebugEnterAlt (9);  		// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  		{  			DebugLocation (140' 4);  			Match (input' NULL' Follow._NULL_in_filterExpr291);  			DebugLocation (141' 4);  			filterNode = new Value (null);  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("filterExpr"' 6);  	LeaveRule ("filterExpr"' 6);  	LeaveRule_filterExpr ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  	int alt9 = 9;  	try {  		DebugEnterDecision (9' false);  		switch (input.LA (1)) {  		case CHAIN_OPERATOR:  		case COMPARATOR:  			{  				alt9 = 1;  			}  			break;  		case EXPR:  			{  				int LA9_2 = input.LA (2);  				if ((LA9_2 == DOWN)) {  					int LA9_3 = input.LA (3);  					if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  						alt9 = 2;  					}  					else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  						alt9 = 3;  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				else {  					NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  					DebugRecognitionException (nvae);  					throw nvae;  				}  			}  			break;  		case STRING:  			{  				alt9 = 4;  			}  			break;  		case REGEX:  			{  				alt9 = 5;  			}  			break;  		case NUMBER:  			{  				alt9 = 6;  			}  			break;  		case TRUE:  			{  				alt9 = 7;  			}  			break;  		case FALSE:  			{  				alt9 = 8;  			}  			break;  		case NULL:  			{  				alt9 = 9;  			}  			break;  		default: {  			NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  		}  	}  	finally {  		DebugExitDecision (9);  	}  	switch (alt9) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  		{  			DebugLocation (64' 4);  			DebugLocation (64' 6);  			PushFollow (Follow._comparator_in_filterExpr175);  			comparator6 = comparator ();  			PopFollow ();  			Match (input' TokenTypes.Down' null);  			DebugLocation (64' 18);  			PushFollow (Follow._filterExpr_in_filterExpr179);  			a = filterExpr ();  			PopFollow ();  			DebugLocation (64' 31);  			PushFollow (Follow._filterExpr_in_filterExpr183);  			b = filterExpr ();  			PopFollow ();  			Match (input' TokenTypes.Up' null);  			DebugLocation (65' 4);  			Comparator newComparator;  			switch (comparator6) {  			case "=":  				newComparator = Comparator.Equals;  				break;  			case "!=":  				newComparator = Comparator.NotEquals;  				break;  			case ">":  				newComparator = Comparator.Greater;  				break;  			case "<":  				newComparator = Comparator.Less;  				break;  			case ">=":  				newComparator = Comparator.GreaterOrEqual;  				break;  			case "<=":  				newComparator = Comparator.LessOrEqual;  				break;  			case "&":  				newComparator = Comparator.And;  				break;  			case "|":  				newComparator = Comparator.Or;  				break;  			default:  				newComparator = Comparator.Equals;  				break;  			}  			filterNode = new BoolExpression (a' newComparator' b);  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  		{  			DebugLocation (98' 4);  			DebugLocation (98' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr195);  			Match (input' TokenTypes.Down' null);  			DebugLocation (98' 12);  			PushFollow (Follow._filterExpr_in_filterExpr199);  			f = filterExpr ();  			PopFollow ();  			DebugLocation (98' 31);  			// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  			int alt6 = 2;  			try {  				DebugEnterSubRule (6);  				try {  					DebugEnterDecision (6' false);  					int LA6_1 = input.LA (1);  					if ((LA6_1 == 24)) {  						alt6 = 1;  					}  				}  				finally {  					DebugExitDecision (6);  				}  				switch (alt6) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  					{  						DebugLocation (98' 31);  						inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (6);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (99' 4);  			FilterTreeNode newNode = f;  			if ((inverse != null ? inverse.Text : default(string)) == "!")  				newNode.ToggleInversed ();  			filterNode = newNode;  		}  		break;  	case 3:  		DebugEnterAlt (3);  		// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  		{  			DebugLocation (105' 4);  			DebugLocation (105' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr216);  			Match (input' TokenTypes.Down' null);  			DebugLocation (105' 12);  			PushFollow (Follow._propertyChain_in_filterExpr219);  			propertyChain (propertySegments);  			PopFollow ();  			DebugLocation (105' 51);  			// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  			int alt7 = 2;  			try {  				DebugEnterSubRule (7);  				try {  					DebugEnterDecision (7' false);  					int LA7_1 = input.LA (1);  					if ((LA7_1 == 31)) {  						alt7 = 1;  					}  				}  				finally {  					DebugExitDecision (7);  				}  				switch (alt7) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  					{  						DebugLocation (105' 51);  						inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (7);  			}  			DebugLocation (105' 60);  			// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  			int alt8 = 2;  			try {  				DebugEnterSubRule (8);  				try {  					DebugEnterDecision (8' false);  					int LA8_1 = input.LA (1);  					if ((LA8_1 == 24)) {  						alt8 = 1;  					}  				}  				finally {  					DebugExitDecision (8);  				}  				switch (alt8) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  					{  						DebugLocation (105' 60);  						not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (8);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (106' 4);  			FilterTreeNode newProperty = new Property (propertySegments);  			if ((inverse != null ? inverse.Text : default(string)) == "?")  				filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  			else {  				if ((not != null ? not.Text : default(string)) == "!")  					newProperty.ToggleInversed ();  				filterNode = newProperty;  			}  		}  		break;  	case 4:  		DebugEnterAlt (4);  		// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  		{  			DebugLocation (116' 4);  			STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  			DebugLocation (117' 4);  			string stringText = (STRING7 != null ? STRING7.Text : default(string));  			stringText = stringText.Substring (1' stringText.Length - 2);  			filterNode = new Value (stringText);  		}  		break;  	case 5:  		DebugEnterAlt (5);  		// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  		{  			DebugLocation (122' 4);  			REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  			DebugLocation (123' 4);  			string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  			regexText = regexText.Substring (1' regexText.Length - 2);  			filterNode = new RegExp (regexText);  		}  		break;  	case 6:  		DebugEnterAlt (6);  		// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  		{  			DebugLocation (128' 4);  			NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  			DebugLocation (129' 4);  			filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  		}  		break;  	case 7:  		DebugEnterAlt (7);  		// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  		{  			DebugLocation (132' 4);  			Match (input' TRUE' Follow._TRUE_in_filterExpr271);  			DebugLocation (133' 4);  			filterNode = new Value (true);  		}  		break;  	case 8:  		DebugEnterAlt (8);  		// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  		{  			DebugLocation (136' 4);  			Match (input' FALSE' Follow._FALSE_in_filterExpr281);  			DebugLocation (137' 4);  			filterNode = new Value (false);  		}  		break;  	case 9:  		DebugEnterAlt (9);  		// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  		{  			DebugLocation (140' 4);  			Match (input' NULL' Follow._NULL_in_filterExpr291);  			DebugLocation (141' 4);  			filterNode = new Value (null);  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("filterExpr"' 6);  	LeaveRule ("filterExpr"' 6);  	LeaveRule_filterExpr ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  	int alt9 = 9;  	try {  		DebugEnterDecision (9' false);  		switch (input.LA (1)) {  		case CHAIN_OPERATOR:  		case COMPARATOR:  			{  				alt9 = 1;  			}  			break;  		case EXPR:  			{  				int LA9_2 = input.LA (2);  				if ((LA9_2 == DOWN)) {  					int LA9_3 = input.LA (3);  					if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  						alt9 = 2;  					}  					else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  						alt9 = 3;  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				else {  					NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  					DebugRecognitionException (nvae);  					throw nvae;  				}  			}  			break;  		case STRING:  			{  				alt9 = 4;  			}  			break;  		case REGEX:  			{  				alt9 = 5;  			}  			break;  		case NUMBER:  			{  				alt9 = 6;  			}  			break;  		case TRUE:  			{  				alt9 = 7;  			}  			break;  		case FALSE:  			{  				alt9 = 8;  			}  			break;  		case NULL:  			{  				alt9 = 9;  			}  			break;  		default: {  			NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  		}  	}  	finally {  		DebugExitDecision (9);  	}  	switch (alt9) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  		{  			DebugLocation (64' 4);  			DebugLocation (64' 6);  			PushFollow (Follow._comparator_in_filterExpr175);  			comparator6 = comparator ();  			PopFollow ();  			Match (input' TokenTypes.Down' null);  			DebugLocation (64' 18);  			PushFollow (Follow._filterExpr_in_filterExpr179);  			a = filterExpr ();  			PopFollow ();  			DebugLocation (64' 31);  			PushFollow (Follow._filterExpr_in_filterExpr183);  			b = filterExpr ();  			PopFollow ();  			Match (input' TokenTypes.Up' null);  			DebugLocation (65' 4);  			Comparator newComparator;  			switch (comparator6) {  			case "=":  				newComparator = Comparator.Equals;  				break;  			case "!=":  				newComparator = Comparator.NotEquals;  				break;  			case ">":  				newComparator = Comparator.Greater;  				break;  			case "<":  				newComparator = Comparator.Less;  				break;  			case ">=":  				newComparator = Comparator.GreaterOrEqual;  				break;  			case "<=":  				newComparator = Comparator.LessOrEqual;  				break;  			case "&":  				newComparator = Comparator.And;  				break;  			case "|":  				newComparator = Comparator.Or;  				break;  			default:  				newComparator = Comparator.Equals;  				break;  			}  			filterNode = new BoolExpression (a' newComparator' b);  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  		{  			DebugLocation (98' 4);  			DebugLocation (98' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr195);  			Match (input' TokenTypes.Down' null);  			DebugLocation (98' 12);  			PushFollow (Follow._filterExpr_in_filterExpr199);  			f = filterExpr ();  			PopFollow ();  			DebugLocation (98' 31);  			// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  			int alt6 = 2;  			try {  				DebugEnterSubRule (6);  				try {  					DebugEnterDecision (6' false);  					int LA6_1 = input.LA (1);  					if ((LA6_1 == 24)) {  						alt6 = 1;  					}  				}  				finally {  					DebugExitDecision (6);  				}  				switch (alt6) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  					{  						DebugLocation (98' 31);  						inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (6);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (99' 4);  			FilterTreeNode newNode = f;  			if ((inverse != null ? inverse.Text : default(string)) == "!")  				newNode.ToggleInversed ();  			filterNode = newNode;  		}  		break;  	case 3:  		DebugEnterAlt (3);  		// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  		{  			DebugLocation (105' 4);  			DebugLocation (105' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr216);  			Match (input' TokenTypes.Down' null);  			DebugLocation (105' 12);  			PushFollow (Follow._propertyChain_in_filterExpr219);  			propertyChain (propertySegments);  			PopFollow ();  			DebugLocation (105' 51);  			// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  			int alt7 = 2;  			try {  				DebugEnterSubRule (7);  				try {  					DebugEnterDecision (7' false);  					int LA7_1 = input.LA (1);  					if ((LA7_1 == 31)) {  						alt7 = 1;  					}  				}  				finally {  					DebugExitDecision (7);  				}  				switch (alt7) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  					{  						DebugLocation (105' 51);  						inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (7);  			}  			DebugLocation (105' 60);  			// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  			int alt8 = 2;  			try {  				DebugEnterSubRule (8);  				try {  					DebugEnterDecision (8' false);  					int LA8_1 = input.LA (1);  					if ((LA8_1 == 24)) {  						alt8 = 1;  					}  				}  				finally {  					DebugExitDecision (8);  				}  				switch (alt8) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  					{  						DebugLocation (105' 60);  						not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (8);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (106' 4);  			FilterTreeNode newProperty = new Property (propertySegments);  			if ((inverse != null ? inverse.Text : default(string)) == "?")  				filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  			else {  				if ((not != null ? not.Text : default(string)) == "!")  					newProperty.ToggleInversed ();  				filterNode = newProperty;  			}  		}  		break;  	case 4:  		DebugEnterAlt (4);  		// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  		{  			DebugLocation (116' 4);  			STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  			DebugLocation (117' 4);  			string stringText = (STRING7 != null ? STRING7.Text : default(string));  			stringText = stringText.Substring (1' stringText.Length - 2);  			filterNode = new Value (stringText);  		}  		break;  	case 5:  		DebugEnterAlt (5);  		// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  		{  			DebugLocation (122' 4);  			REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  			DebugLocation (123' 4);  			string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  			regexText = regexText.Substring (1' regexText.Length - 2);  			filterNode = new RegExp (regexText);  		}  		break;  	case 6:  		DebugEnterAlt (6);  		// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  		{  			DebugLocation (128' 4);  			NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  			DebugLocation (129' 4);  			filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  		}  		break;  	case 7:  		DebugEnterAlt (7);  		// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  		{  			DebugLocation (132' 4);  			Match (input' TRUE' Follow._TRUE_in_filterExpr271);  			DebugLocation (133' 4);  			filterNode = new Value (true);  		}  		break;  	case 8:  		DebugEnterAlt (8);  		// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  		{  			DebugLocation (136' 4);  			Match (input' FALSE' Follow._FALSE_in_filterExpr281);  			DebugLocation (137' 4);  			filterNode = new Value (false);  		}  		break;  	case 9:  		DebugEnterAlt (9);  		// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  		{  			DebugLocation (140' 4);  			Match (input' NULL' Follow._NULL_in_filterExpr291);  			DebugLocation (141' 4);  			filterNode = new Value (null);  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("filterExpr"' 6);  	LeaveRule ("filterExpr"' 6);  	LeaveRule_filterExpr ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  	int alt9 = 9;  	try {  		DebugEnterDecision (9' false);  		switch (input.LA (1)) {  		case CHAIN_OPERATOR:  		case COMPARATOR:  			{  				alt9 = 1;  			}  			break;  		case EXPR:  			{  				int LA9_2 = input.LA (2);  				if ((LA9_2 == DOWN)) {  					int LA9_3 = input.LA (3);  					if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  						alt9 = 2;  					}  					else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  						alt9 = 3;  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				else {  					NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  					DebugRecognitionException (nvae);  					throw nvae;  				}  			}  			break;  		case STRING:  			{  				alt9 = 4;  			}  			break;  		case REGEX:  			{  				alt9 = 5;  			}  			break;  		case NUMBER:  			{  				alt9 = 6;  			}  			break;  		case TRUE:  			{  				alt9 = 7;  			}  			break;  		case FALSE:  			{  				alt9 = 8;  			}  			break;  		case NULL:  			{  				alt9 = 9;  			}  			break;  		default: {  			NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  		}  	}  	finally {  		DebugExitDecision (9);  	}  	switch (alt9) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  		{  			DebugLocation (64' 4);  			DebugLocation (64' 6);  			PushFollow (Follow._comparator_in_filterExpr175);  			comparator6 = comparator ();  			PopFollow ();  			Match (input' TokenTypes.Down' null);  			DebugLocation (64' 18);  			PushFollow (Follow._filterExpr_in_filterExpr179);  			a = filterExpr ();  			PopFollow ();  			DebugLocation (64' 31);  			PushFollow (Follow._filterExpr_in_filterExpr183);  			b = filterExpr ();  			PopFollow ();  			Match (input' TokenTypes.Up' null);  			DebugLocation (65' 4);  			Comparator newComparator;  			switch (comparator6) {  			case "=":  				newComparator = Comparator.Equals;  				break;  			case "!=":  				newComparator = Comparator.NotEquals;  				break;  			case ">":  				newComparator = Comparator.Greater;  				break;  			case "<":  				newComparator = Comparator.Less;  				break;  			case ">=":  				newComparator = Comparator.GreaterOrEqual;  				break;  			case "<=":  				newComparator = Comparator.LessOrEqual;  				break;  			case "&":  				newComparator = Comparator.And;  				break;  			case "|":  				newComparator = Comparator.Or;  				break;  			default:  				newComparator = Comparator.Equals;  				break;  			}  			filterNode = new BoolExpression (a' newComparator' b);  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  		{  			DebugLocation (98' 4);  			DebugLocation (98' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr195);  			Match (input' TokenTypes.Down' null);  			DebugLocation (98' 12);  			PushFollow (Follow._filterExpr_in_filterExpr199);  			f = filterExpr ();  			PopFollow ();  			DebugLocation (98' 31);  			// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  			int alt6 = 2;  			try {  				DebugEnterSubRule (6);  				try {  					DebugEnterDecision (6' false);  					int LA6_1 = input.LA (1);  					if ((LA6_1 == 24)) {  						alt6 = 1;  					}  				}  				finally {  					DebugExitDecision (6);  				}  				switch (alt6) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  					{  						DebugLocation (98' 31);  						inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (6);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (99' 4);  			FilterTreeNode newNode = f;  			if ((inverse != null ? inverse.Text : default(string)) == "!")  				newNode.ToggleInversed ();  			filterNode = newNode;  		}  		break;  	case 3:  		DebugEnterAlt (3);  		// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  		{  			DebugLocation (105' 4);  			DebugLocation (105' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr216);  			Match (input' TokenTypes.Down' null);  			DebugLocation (105' 12);  			PushFollow (Follow._propertyChain_in_filterExpr219);  			propertyChain (propertySegments);  			PopFollow ();  			DebugLocation (105' 51);  			// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  			int alt7 = 2;  			try {  				DebugEnterSubRule (7);  				try {  					DebugEnterDecision (7' false);  					int LA7_1 = input.LA (1);  					if ((LA7_1 == 31)) {  						alt7 = 1;  					}  				}  				finally {  					DebugExitDecision (7);  				}  				switch (alt7) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  					{  						DebugLocation (105' 51);  						inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (7);  			}  			DebugLocation (105' 60);  			// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  			int alt8 = 2;  			try {  				DebugEnterSubRule (8);  				try {  					DebugEnterDecision (8' false);  					int LA8_1 = input.LA (1);  					if ((LA8_1 == 24)) {  						alt8 = 1;  					}  				}  				finally {  					DebugExitDecision (8);  				}  				switch (alt8) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  					{  						DebugLocation (105' 60);  						not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (8);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (106' 4);  			FilterTreeNode newProperty = new Property (propertySegments);  			if ((inverse != null ? inverse.Text : default(string)) == "?")  				filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  			else {  				if ((not != null ? not.Text : default(string)) == "!")  					newProperty.ToggleInversed ();  				filterNode = newProperty;  			}  		}  		break;  	case 4:  		DebugEnterAlt (4);  		// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  		{  			DebugLocation (116' 4);  			STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  			DebugLocation (117' 4);  			string stringText = (STRING7 != null ? STRING7.Text : default(string));  			stringText = stringText.Substring (1' stringText.Length - 2);  			filterNode = new Value (stringText);  		}  		break;  	case 5:  		DebugEnterAlt (5);  		// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  		{  			DebugLocation (122' 4);  			REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  			DebugLocation (123' 4);  			string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  			regexText = regexText.Substring (1' regexText.Length - 2);  			filterNode = new RegExp (regexText);  		}  		break;  	case 6:  		DebugEnterAlt (6);  		// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  		{  			DebugLocation (128' 4);  			NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  			DebugLocation (129' 4);  			filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  		}  		break;  	case 7:  		DebugEnterAlt (7);  		// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  		{  			DebugLocation (132' 4);  			Match (input' TRUE' Follow._TRUE_in_filterExpr271);  			DebugLocation (133' 4);  			filterNode = new Value (true);  		}  		break;  	case 8:  		DebugEnterAlt (8);  		// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  		{  			DebugLocation (136' 4);  			Match (input' FALSE' Follow._FALSE_in_filterExpr281);  			DebugLocation (137' 4);  			filterNode = new Value (false);  		}  		break;  	case 9:  		DebugEnterAlt (9);  		// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  		{  			DebugLocation (140' 4);  			Match (input' NULL' Follow._NULL_in_filterExpr291);  			DebugLocation (141' 4);  			filterNode = new Value (null);  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("filterExpr"' 6);  	LeaveRule ("filterExpr"' 6);  	LeaveRule_filterExpr ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:64:2: ( ^( comparator a= filterExpr b= filterExpr ) | ^( EXPR f= filterExpr (inverse= '!' )? ) | ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? ) | STRING | REGEX | NUMBER | TRUE | FALSE | NULL )  	int alt9 = 9;  	try {  		DebugEnterDecision (9' false);  		switch (input.LA (1)) {  		case CHAIN_OPERATOR:  		case COMPARATOR:  			{  				alt9 = 1;  			}  			break;  		case EXPR:  			{  				int LA9_2 = input.LA (2);  				if ((LA9_2 == DOWN)) {  					int LA9_3 = input.LA (3);  					if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  						alt9 = 2;  					}  					else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  						alt9 = 3;  					}  					else {  						NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  						DebugRecognitionException (nvae);  						throw nvae;  					}  				}  				else {  					NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  					DebugRecognitionException (nvae);  					throw nvae;  				}  			}  			break;  		case STRING:  			{  				alt9 = 4;  			}  			break;  		case REGEX:  			{  				alt9 = 5;  			}  			break;  		case NUMBER:  			{  				alt9 = 6;  			}  			break;  		case TRUE:  			{  				alt9 = 7;  			}  			break;  		case FALSE:  			{  				alt9 = 8;  			}  			break;  		case NULL:  			{  				alt9 = 9;  			}  			break;  		default: {  			NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  		}  	}  	finally {  		DebugExitDecision (9);  	}  	switch (alt9) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  		{  			DebugLocation (64' 4);  			DebugLocation (64' 6);  			PushFollow (Follow._comparator_in_filterExpr175);  			comparator6 = comparator ();  			PopFollow ();  			Match (input' TokenTypes.Down' null);  			DebugLocation (64' 18);  			PushFollow (Follow._filterExpr_in_filterExpr179);  			a = filterExpr ();  			PopFollow ();  			DebugLocation (64' 31);  			PushFollow (Follow._filterExpr_in_filterExpr183);  			b = filterExpr ();  			PopFollow ();  			Match (input' TokenTypes.Up' null);  			DebugLocation (65' 4);  			Comparator newComparator;  			switch (comparator6) {  			case "=":  				newComparator = Comparator.Equals;  				break;  			case "!=":  				newComparator = Comparator.NotEquals;  				break;  			case ">":  				newComparator = Comparator.Greater;  				break;  			case "<":  				newComparator = Comparator.Less;  				break;  			case ">=":  				newComparator = Comparator.GreaterOrEqual;  				break;  			case "<=":  				newComparator = Comparator.LessOrEqual;  				break;  			case "&":  				newComparator = Comparator.And;  				break;  			case "|":  				newComparator = Comparator.Or;  				break;  			default:  				newComparator = Comparator.Equals;  				break;  			}  			filterNode = new BoolExpression (a' newComparator' b);  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  		{  			DebugLocation (98' 4);  			DebugLocation (98' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr195);  			Match (input' TokenTypes.Down' null);  			DebugLocation (98' 12);  			PushFollow (Follow._filterExpr_in_filterExpr199);  			f = filterExpr ();  			PopFollow ();  			DebugLocation (98' 31);  			// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  			int alt6 = 2;  			try {  				DebugEnterSubRule (6);  				try {  					DebugEnterDecision (6' false);  					int LA6_1 = input.LA (1);  					if ((LA6_1 == 24)) {  						alt6 = 1;  					}  				}  				finally {  					DebugExitDecision (6);  				}  				switch (alt6) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  					{  						DebugLocation (98' 31);  						inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (6);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (99' 4);  			FilterTreeNode newNode = f;  			if ((inverse != null ? inverse.Text : default(string)) == "!")  				newNode.ToggleInversed ();  			filterNode = newNode;  		}  		break;  	case 3:  		DebugEnterAlt (3);  		// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  		{  			DebugLocation (105' 4);  			DebugLocation (105' 6);  			Match (input' EXPR' Follow._EXPR_in_filterExpr216);  			Match (input' TokenTypes.Down' null);  			DebugLocation (105' 12);  			PushFollow (Follow._propertyChain_in_filterExpr219);  			propertyChain (propertySegments);  			PopFollow ();  			DebugLocation (105' 51);  			// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  			int alt7 = 2;  			try {  				DebugEnterSubRule (7);  				try {  					DebugEnterDecision (7' false);  					int LA7_1 = input.LA (1);  					if ((LA7_1 == 31)) {  						alt7 = 1;  					}  				}  				finally {  					DebugExitDecision (7);  				}  				switch (alt7) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  					{  						DebugLocation (105' 51);  						inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (7);  			}  			DebugLocation (105' 60);  			// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  			int alt8 = 2;  			try {  				DebugEnterSubRule (8);  				try {  					DebugEnterDecision (8' false);  					int LA8_1 = input.LA (1);  					if ((LA8_1 == 24)) {  						alt8 = 1;  					}  				}  				finally {  					DebugExitDecision (8);  				}  				switch (alt8) {  				case 1:  					DebugEnterAlt (1);  					// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  					{  						DebugLocation (105' 60);  						not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  					}  					break;  				}  			}  			finally {  				DebugExitSubRule (8);  			}  			Match (input' TokenTypes.Up' null);  			DebugLocation (106' 4);  			FilterTreeNode newProperty = new Property (propertySegments);  			if ((inverse != null ? inverse.Text : default(string)) == "?")  				filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  			else {  				if ((not != null ? not.Text : default(string)) == "!")  					newProperty.ToggleInversed ();  				filterNode = newProperty;  			}  		}  		break;  	case 4:  		DebugEnterAlt (4);  		// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  		{  			DebugLocation (116' 4);  			STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  			DebugLocation (117' 4);  			string stringText = (STRING7 != null ? STRING7.Text : default(string));  			stringText = stringText.Substring (1' stringText.Length - 2);  			filterNode = new Value (stringText);  		}  		break;  	case 5:  		DebugEnterAlt (5);  		// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  		{  			DebugLocation (122' 4);  			REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  			DebugLocation (123' 4);  			string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  			regexText = regexText.Substring (1' regexText.Length - 2);  			filterNode = new RegExp (regexText);  		}  		break;  	case 6:  		DebugEnterAlt (6);  		// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  		{  			DebugLocation (128' 4);  			NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  			DebugLocation (129' 4);  			filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  		}  		break;  	case 7:  		DebugEnterAlt (7);  		// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  		{  			DebugLocation (132' 4);  			Match (input' TRUE' Follow._TRUE_in_filterExpr271);  			DebugLocation (133' 4);  			filterNode = new Value (true);  		}  		break;  	case 8:  		DebugEnterAlt (8);  		// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  		{  			DebugLocation (136' 4);  			Match (input' FALSE' Follow._FALSE_in_filterExpr281);  			DebugLocation (137' 4);  			filterNode = new Value (false);  		}  		break;  	case 9:  		DebugEnterAlt (9);  		// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  		{  			DebugLocation (140' 4);  			Match (input' NULL' Follow._NULL_in_filterExpr291);  			DebugLocation (141' 4);  			filterNode = new Value (null);  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("filterExpr"' 6);  	LeaveRule ("filterExpr"' 6);  	LeaveRule_filterExpr ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	DebugEnterDecision (9' false);  	switch (input.LA (1)) {  	case CHAIN_OPERATOR:  	case COMPARATOR:  		{  			alt9 = 1;  		}  		break;  	case EXPR:  		{  			int LA9_2 = input.LA (2);  			if ((LA9_2 == DOWN)) {  				int LA9_3 = input.LA (3);  				if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  					alt9 = 2;  				}  				else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  					alt9 = 3;  				}  				else {  					NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  					DebugRecognitionException (nvae);  					throw nvae;  				}  			}  			else {  				NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  				DebugRecognitionException (nvae);  				throw nvae;  			}  		}  		break;  	case STRING:  		{  			alt9 = 4;  		}  		break;  	case REGEX:  		{  			alt9 = 5;  		}  		break;  	case NUMBER:  		{  			alt9 = 6;  		}  		break;  	case TRUE:  		{  			alt9 = 7;  		}  		break;  	case FALSE:  		{  			alt9 = 8;  		}  		break;  	case NULL:  		{  			alt9 = 9;  		}  		break;  	default: {  		NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  		DebugRecognitionException (nvae);  		throw nvae;  	}  	}  }  finally {  	DebugExitDecision (9);  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	DebugEnterDecision (9' false);  	switch (input.LA (1)) {  	case CHAIN_OPERATOR:  	case COMPARATOR:  		{  			alt9 = 1;  		}  		break;  	case EXPR:  		{  			int LA9_2 = input.LA (2);  			if ((LA9_2 == DOWN)) {  				int LA9_3 = input.LA (3);  				if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  					alt9 = 2;  				}  				else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  					alt9 = 3;  				}  				else {  					NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  					DebugRecognitionException (nvae);  					throw nvae;  				}  			}  			else {  				NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  				DebugRecognitionException (nvae);  				throw nvae;  			}  		}  		break;  	case STRING:  		{  			alt9 = 4;  		}  		break;  	case REGEX:  		{  			alt9 = 5;  		}  		break;  	case NUMBER:  		{  			alt9 = 6;  		}  		break;  	case TRUE:  		{  			alt9 = 7;  		}  		break;  	case FALSE:  		{  			alt9 = 8;  		}  		break;  	case NULL:  		{  			alt9 = 9;  		}  		break;  	default: {  		NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  		DebugRecognitionException (nvae);  		throw nvae;  	}  	}  }  finally {  	DebugExitDecision (9);  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	DebugEnterDecision (9' false);  	switch (input.LA (1)) {  	case CHAIN_OPERATOR:  	case COMPARATOR:  		{  			alt9 = 1;  		}  		break;  	case EXPR:  		{  			int LA9_2 = input.LA (2);  			if ((LA9_2 == DOWN)) {  				int LA9_3 = input.LA (3);  				if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  					alt9 = 2;  				}  				else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  					alt9 = 3;  				}  				else {  					NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  					DebugRecognitionException (nvae);  					throw nvae;  				}  			}  			else {  				NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  				DebugRecognitionException (nvae);  				throw nvae;  			}  		}  		break;  	case STRING:  		{  			alt9 = 4;  		}  		break;  	case REGEX:  		{  			alt9 = 5;  		}  		break;  	case NUMBER:  		{  			alt9 = 6;  		}  		break;  	case TRUE:  		{  			alt9 = 7;  		}  		break;  	case FALSE:  		{  			alt9 = 8;  		}  		break;  	case NULL:  		{  			alt9 = 9;  		}  		break;  	default: {  		NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  		DebugRecognitionException (nvae);  		throw nvae;  	}  	}  }  finally {  	DebugExitDecision (9);  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	DebugEnterDecision (9' false);  	switch (input.LA (1)) {  	case CHAIN_OPERATOR:  	case COMPARATOR:  		{  			alt9 = 1;  		}  		break;  	case EXPR:  		{  			int LA9_2 = input.LA (2);  			if ((LA9_2 == DOWN)) {  				int LA9_3 = input.LA (3);  				if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  					alt9 = 2;  				}  				else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  					alt9 = 3;  				}  				else {  					NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  					DebugRecognitionException (nvae);  					throw nvae;  				}  			}  			else {  				NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  				DebugRecognitionException (nvae);  				throw nvae;  			}  		}  		break;  	case STRING:  		{  			alt9 = 4;  		}  		break;  	case REGEX:  		{  			alt9 = 5;  		}  		break;  	case NUMBER:  		{  			alt9 = 6;  		}  		break;  	case TRUE:  		{  			alt9 = 7;  		}  		break;  	case FALSE:  		{  			alt9 = 8;  		}  		break;  	case NULL:  		{  			alt9 = 9;  		}  		break;  	default: {  		NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  		DebugRecognitionException (nvae);  		throw nvae;  	}  	}  }  finally {  	DebugExitDecision (9);  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	DebugEnterDecision (9' false);  	switch (input.LA (1)) {  	case CHAIN_OPERATOR:  	case COMPARATOR:  		{  			alt9 = 1;  		}  		break;  	case EXPR:  		{  			int LA9_2 = input.LA (2);  			if ((LA9_2 == DOWN)) {  				int LA9_3 = input.LA (3);  				if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  					alt9 = 2;  				}  				else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  					alt9 = 3;  				}  				else {  					NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  					DebugRecognitionException (nvae);  					throw nvae;  				}  			}  			else {  				NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  				DebugRecognitionException (nvae);  				throw nvae;  			}  		}  		break;  	case STRING:  		{  			alt9 = 4;  		}  		break;  	case REGEX:  		{  			alt9 = 5;  		}  		break;  	case NUMBER:  		{  			alt9 = 6;  		}  		break;  	case TRUE:  		{  			alt9 = 7;  		}  		break;  	case FALSE:  		{  			alt9 = 8;  		}  		break;  	case NULL:  		{  			alt9 = 9;  		}  		break;  	default: {  		NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  		DebugRecognitionException (nvae);  		throw nvae;  	}  	}  }  finally {  	DebugExitDecision (9);  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	DebugEnterDecision (9' false);  	switch (input.LA (1)) {  	case CHAIN_OPERATOR:  	case COMPARATOR:  		{  			alt9 = 1;  		}  		break;  	case EXPR:  		{  			int LA9_2 = input.LA (2);  			if ((LA9_2 == DOWN)) {  				int LA9_3 = input.LA (3);  				if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  					alt9 = 2;  				}  				else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  					alt9 = 3;  				}  				else {  					NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  					DebugRecognitionException (nvae);  					throw nvae;  				}  			}  			else {  				NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  				DebugRecognitionException (nvae);  				throw nvae;  			}  		}  		break;  	case STRING:  		{  			alt9 = 4;  		}  		break;  	case REGEX:  		{  			alt9 = 5;  		}  		break;  	case NUMBER:  		{  			alt9 = 6;  		}  		break;  	case TRUE:  		{  			alt9 = 7;  		}  		break;  	case FALSE:  		{  			alt9 = 8;  		}  		break;  	case NULL:  		{  			alt9 = 9;  		}  		break;  	default: {  		NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  		DebugRecognitionException (nvae);  		throw nvae;  	}  	}  }  finally {  	DebugExitDecision (9);  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	DebugEnterDecision (9' false);  	switch (input.LA (1)) {  	case CHAIN_OPERATOR:  	case COMPARATOR:  		{  			alt9 = 1;  		}  		break;  	case EXPR:  		{  			int LA9_2 = input.LA (2);  			if ((LA9_2 == DOWN)) {  				int LA9_3 = input.LA (3);  				if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  					alt9 = 2;  				}  				else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  					alt9 = 3;  				}  				else {  					NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  					DebugRecognitionException (nvae);  					throw nvae;  				}  			}  			else {  				NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  				DebugRecognitionException (nvae);  				throw nvae;  			}  		}  		break;  	case STRING:  		{  			alt9 = 4;  		}  		break;  	case REGEX:  		{  			alt9 = 5;  		}  		break;  	case NUMBER:  		{  			alt9 = 6;  		}  		break;  	case TRUE:  		{  			alt9 = 7;  		}  		break;  	case FALSE:  		{  			alt9 = 8;  		}  		break;  	case NULL:  		{  			alt9 = 9;  		}  		break;  	default: {  		NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  		DebugRecognitionException (nvae);  		throw nvae;  	}  	}  }  finally {  	DebugExitDecision (9);  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	DebugEnterDecision (9' false);  	switch (input.LA (1)) {  	case CHAIN_OPERATOR:  	case COMPARATOR:  		{  			alt9 = 1;  		}  		break;  	case EXPR:  		{  			int LA9_2 = input.LA (2);  			if ((LA9_2 == DOWN)) {  				int LA9_3 = input.LA (3);  				if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  					alt9 = 2;  				}  				else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  					alt9 = 3;  				}  				else {  					NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  					DebugRecognitionException (nvae);  					throw nvae;  				}  			}  			else {  				NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  				DebugRecognitionException (nvae);  				throw nvae;  			}  		}  		break;  	case STRING:  		{  			alt9 = 4;  		}  		break;  	case REGEX:  		{  			alt9 = 5;  		}  		break;  	case NUMBER:  		{  			alt9 = 6;  		}  		break;  	case TRUE:  		{  			alt9 = 7;  		}  		break;  	case FALSE:  		{  			alt9 = 8;  		}  		break;  	case NULL:  		{  			alt9 = 9;  		}  		break;  	default: {  		NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  		DebugRecognitionException (nvae);  		throw nvae;  	}  	}  }  finally {  	DebugExitDecision (9);  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	DebugEnterDecision (9' false);  	switch (input.LA (1)) {  	case CHAIN_OPERATOR:  	case COMPARATOR:  		{  			alt9 = 1;  		}  		break;  	case EXPR:  		{  			int LA9_2 = input.LA (2);  			if ((LA9_2 == DOWN)) {  				int LA9_3 = input.LA (3);  				if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  					alt9 = 2;  				}  				else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  					alt9 = 3;  				}  				else {  					NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  					DebugRecognitionException (nvae);  					throw nvae;  				}  			}  			else {  				NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  				DebugRecognitionException (nvae);  				throw nvae;  			}  		}  		break;  	case STRING:  		{  			alt9 = 4;  		}  		break;  	case REGEX:  		{  			alt9 = 5;  		}  		break;  	case NUMBER:  		{  			alt9 = 6;  		}  		break;  	case TRUE:  		{  			alt9 = 7;  		}  		break;  	case FALSE:  		{  			alt9 = 8;  		}  		break;  	case NULL:  		{  			alt9 = 9;  		}  		break;  	default: {  		NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  		DebugRecognitionException (nvae);  		throw nvae;  	}  	}  }  finally {  	DebugExitDecision (9);  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	DebugEnterDecision (9' false);  	switch (input.LA (1)) {  	case CHAIN_OPERATOR:  	case COMPARATOR:  		{  			alt9 = 1;  		}  		break;  	case EXPR:  		{  			int LA9_2 = input.LA (2);  			if ((LA9_2 == DOWN)) {  				int LA9_3 = input.LA (3);  				if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  					alt9 = 2;  				}  				else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  					alt9 = 3;  				}  				else {  					NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  					DebugRecognitionException (nvae);  					throw nvae;  				}  			}  			else {  				NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  				DebugRecognitionException (nvae);  				throw nvae;  			}  		}  		break;  	case STRING:  		{  			alt9 = 4;  		}  		break;  	case REGEX:  		{  			alt9 = 5;  		}  		break;  	case NUMBER:  		{  			alt9 = 6;  		}  		break;  	case TRUE:  		{  			alt9 = 7;  		}  		break;  	case FALSE:  		{  			alt9 = 8;  		}  		break;  	case NULL:  		{  			alt9 = 9;  		}  		break;  	default: {  		NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  		DebugRecognitionException (nvae);  		throw nvae;  	}  	}  }  finally {  	DebugExitDecision (9);  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	DebugEnterDecision (9' false);  	switch (input.LA (1)) {  	case CHAIN_OPERATOR:  	case COMPARATOR:  		{  			alt9 = 1;  		}  		break;  	case EXPR:  		{  			int LA9_2 = input.LA (2);  			if ((LA9_2 == DOWN)) {  				int LA9_3 = input.LA (3);  				if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  					alt9 = 2;  				}  				else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  					alt9 = 3;  				}  				else {  					NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  					DebugRecognitionException (nvae);  					throw nvae;  				}  			}  			else {  				NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  				DebugRecognitionException (nvae);  				throw nvae;  			}  		}  		break;  	case STRING:  		{  			alt9 = 4;  		}  		break;  	case REGEX:  		{  			alt9 = 5;  		}  		break;  	case NUMBER:  		{  			alt9 = 6;  		}  		break;  	case TRUE:  		{  			alt9 = 7;  		}  		break;  	case FALSE:  		{  			alt9 = 8;  		}  		break;  	case NULL:  		{  			alt9 = 9;  		}  		break;  	default: {  		NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  		DebugRecognitionException (nvae);  		throw nvae;  	}  	}  }  finally {  	DebugExitDecision (9);  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	DebugEnterDecision (9' false);  	switch (input.LA (1)) {  	case CHAIN_OPERATOR:  	case COMPARATOR:  		{  			alt9 = 1;  		}  		break;  	case EXPR:  		{  			int LA9_2 = input.LA (2);  			if ((LA9_2 == DOWN)) {  				int LA9_3 = input.LA (3);  				if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  					alt9 = 2;  				}  				else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  					alt9 = 3;  				}  				else {  					NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  					DebugRecognitionException (nvae);  					throw nvae;  				}  			}  			else {  				NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  				DebugRecognitionException (nvae);  				throw nvae;  			}  		}  		break;  	case STRING:  		{  			alt9 = 4;  		}  		break;  	case REGEX:  		{  			alt9 = 5;  		}  		break;  	case NUMBER:  		{  			alt9 = 6;  		}  		break;  	case TRUE:  		{  			alt9 = 7;  		}  		break;  	case FALSE:  		{  			alt9 = 8;  		}  		break;  	case NULL:  		{  			alt9 = 9;  		}  		break;  	default: {  		NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  		DebugRecognitionException (nvae);  		throw nvae;  	}  	}  }  finally {  	DebugExitDecision (9);  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	DebugEnterDecision (9' false);  	switch (input.LA (1)) {  	case CHAIN_OPERATOR:  	case COMPARATOR:  		{  			alt9 = 1;  		}  		break;  	case EXPR:  		{  			int LA9_2 = input.LA (2);  			if ((LA9_2 == DOWN)) {  				int LA9_3 = input.LA (3);  				if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  					alt9 = 2;  				}  				else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  					alt9 = 3;  				}  				else {  					NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  					DebugRecognitionException (nvae);  					throw nvae;  				}  			}  			else {  				NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  				DebugRecognitionException (nvae);  				throw nvae;  			}  		}  		break;  	case STRING:  		{  			alt9 = 4;  		}  		break;  	case REGEX:  		{  			alt9 = 5;  		}  		break;  	case NUMBER:  		{  			alt9 = 6;  		}  		break;  	case TRUE:  		{  			alt9 = 7;  		}  		break;  	case FALSE:  		{  			alt9 = 8;  		}  		break;  	case NULL:  		{  			alt9 = 9;  		}  		break;  	default: {  		NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  		DebugRecognitionException (nvae);  		throw nvae;  	}  	}  }  finally {  	DebugExitDecision (9);  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	DebugEnterDecision (9' false);  	switch (input.LA (1)) {  	case CHAIN_OPERATOR:  	case COMPARATOR:  		{  			alt9 = 1;  		}  		break;  	case EXPR:  		{  			int LA9_2 = input.LA (2);  			if ((LA9_2 == DOWN)) {  				int LA9_3 = input.LA (3);  				if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  					alt9 = 2;  				}  				else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  					alt9 = 3;  				}  				else {  					NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  					DebugRecognitionException (nvae);  					throw nvae;  				}  			}  			else {  				NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  				DebugRecognitionException (nvae);  				throw nvae;  			}  		}  		break;  	case STRING:  		{  			alt9 = 4;  		}  		break;  	case REGEX:  		{  			alt9 = 5;  		}  		break;  	case NUMBER:  		{  			alt9 = 6;  		}  		break;  	case TRUE:  		{  			alt9 = 7;  		}  		break;  	case FALSE:  		{  			alt9 = 8;  		}  		break;  	case NULL:  		{  			alt9 = 9;  		}  		break;  	default: {  		NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  		DebugRecognitionException (nvae);  		throw nvae;  	}  	}  }  finally {  	DebugExitDecision (9);  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	DebugEnterDecision (9' false);  	switch (input.LA (1)) {  	case CHAIN_OPERATOR:  	case COMPARATOR:  		{  			alt9 = 1;  		}  		break;  	case EXPR:  		{  			int LA9_2 = input.LA (2);  			if ((LA9_2 == DOWN)) {  				int LA9_3 = input.LA (3);  				if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  					alt9 = 2;  				}  				else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  					alt9 = 3;  				}  				else {  					NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  					DebugRecognitionException (nvae);  					throw nvae;  				}  			}  			else {  				NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  				DebugRecognitionException (nvae);  				throw nvae;  			}  		}  		break;  	case STRING:  		{  			alt9 = 4;  		}  		break;  	case REGEX:  		{  			alt9 = 5;  		}  		break;  	case NUMBER:  		{  			alt9 = 6;  		}  		break;  	case TRUE:  		{  			alt9 = 7;  		}  		break;  	case FALSE:  		{  			alt9 = 8;  		}  		break;  	case NULL:  		{  			alt9 = 9;  		}  		break;  	default: {  		NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  		DebugRecognitionException (nvae);  		throw nvae;  	}  	}  }  finally {  	DebugExitDecision (9);  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	DebugEnterDecision (9' false);  	switch (input.LA (1)) {  	case CHAIN_OPERATOR:  	case COMPARATOR:  		{  			alt9 = 1;  		}  		break;  	case EXPR:  		{  			int LA9_2 = input.LA (2);  			if ((LA9_2 == DOWN)) {  				int LA9_3 = input.LA (3);  				if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  					alt9 = 2;  				}  				else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  					alt9 = 3;  				}  				else {  					NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  					DebugRecognitionException (nvae);  					throw nvae;  				}  			}  			else {  				NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  				DebugRecognitionException (nvae);  				throw nvae;  			}  		}  		break;  	case STRING:  		{  			alt9 = 4;  		}  		break;  	case REGEX:  		{  			alt9 = 5;  		}  		break;  	case NUMBER:  		{  			alt9 = 6;  		}  		break;  	case TRUE:  		{  			alt9 = 7;  		}  		break;  	case FALSE:  		{  			alt9 = 8;  		}  		break;  	case NULL:  		{  			alt9 = 9;  		}  		break;  	default: {  		NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  		DebugRecognitionException (nvae);  		throw nvae;  	}  	}  }  finally {  	DebugExitDecision (9);  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	DebugEnterDecision (9' false);  	switch (input.LA (1)) {  	case CHAIN_OPERATOR:  	case COMPARATOR:  		{  			alt9 = 1;  		}  		break;  	case EXPR:  		{  			int LA9_2 = input.LA (2);  			if ((LA9_2 == DOWN)) {  				int LA9_3 = input.LA (3);  				if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  					alt9 = 2;  				}  				else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  					alt9 = 3;  				}  				else {  					NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  					DebugRecognitionException (nvae);  					throw nvae;  				}  			}  			else {  				NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  				DebugRecognitionException (nvae);  				throw nvae;  			}  		}  		break;  	case STRING:  		{  			alt9 = 4;  		}  		break;  	case REGEX:  		{  			alt9 = 5;  		}  		break;  	case NUMBER:  		{  			alt9 = 6;  		}  		break;  	case TRUE:  		{  			alt9 = 7;  		}  		break;  	case FALSE:  		{  			alt9 = 8;  		}  		break;  	case NULL:  		{  			alt9 = 9;  		}  		break;  	default: {  		NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  		DebugRecognitionException (nvae);  		throw nvae;  	}  	}  }  finally {  	DebugExitDecision (9);  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	DebugEnterDecision (9' false);  	switch (input.LA (1)) {  	case CHAIN_OPERATOR:  	case COMPARATOR:  		{  			alt9 = 1;  		}  		break;  	case EXPR:  		{  			int LA9_2 = input.LA (2);  			if ((LA9_2 == DOWN)) {  				int LA9_3 = input.LA (3);  				if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  					alt9 = 2;  				}  				else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  					alt9 = 3;  				}  				else {  					NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  					DebugRecognitionException (nvae);  					throw nvae;  				}  			}  			else {  				NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  				DebugRecognitionException (nvae);  				throw nvae;  			}  		}  		break;  	case STRING:  		{  			alt9 = 4;  		}  		break;  	case REGEX:  		{  			alt9 = 5;  		}  		break;  	case NUMBER:  		{  			alt9 = 6;  		}  		break;  	case TRUE:  		{  			alt9 = 7;  		}  		break;  	case FALSE:  		{  			alt9 = 8;  		}  		break;  	case NULL:  		{  			alt9 = 9;  		}  		break;  	default: {  		NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  		DebugRecognitionException (nvae);  		throw nvae;  	}  	}  }  finally {  	DebugExitDecision (9);  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	DebugEnterDecision (9' false);  	switch (input.LA (1)) {  	case CHAIN_OPERATOR:  	case COMPARATOR:  		{  			alt9 = 1;  		}  		break;  	case EXPR:  		{  			int LA9_2 = input.LA (2);  			if ((LA9_2 == DOWN)) {  				int LA9_3 = input.LA (3);  				if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  					alt9 = 2;  				}  				else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  					alt9 = 3;  				}  				else {  					NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  					DebugRecognitionException (nvae);  					throw nvae;  				}  			}  			else {  				NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  				DebugRecognitionException (nvae);  				throw nvae;  			}  		}  		break;  	case STRING:  		{  			alt9 = 4;  		}  		break;  	case REGEX:  		{  			alt9 = 5;  		}  		break;  	case NUMBER:  		{  			alt9 = 6;  		}  		break;  	case TRUE:  		{  			alt9 = 7;  		}  		break;  	case FALSE:  		{  			alt9 = 8;  		}  		break;  	case NULL:  		{  			alt9 = 9;  		}  		break;  	default: {  		NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  		DebugRecognitionException (nvae);  		throw nvae;  	}  	}  }  finally {  	DebugExitDecision (9);  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: DebugEnterDecision (9' false);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: switch (input.LA (1)) {  case CHAIN_OPERATOR:  case COMPARATOR:  	{  		alt9 = 1;  	}  	break;  case EXPR:  	{  		int LA9_2 = input.LA (2);  		if ((LA9_2 == DOWN)) {  			int LA9_3 = input.LA (3);  			if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  				alt9 = 2;  			}  			else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  				alt9 = 3;  			}  			else {  				NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  				DebugRecognitionException (nvae);  				throw nvae;  			}  		}  		else {  			NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  			DebugRecognitionException (nvae);  			throw nvae;  		}  	}  	break;  case STRING:  	{  		alt9 = 4;  	}  	break;  case REGEX:  	{  		alt9 = 5;  	}  	break;  case NUMBER:  	{  		alt9 = 6;  	}  	break;  case TRUE:  	{  		alt9 = 7;  	}  	break;  case FALSE:  	{  		alt9 = 8;  	}  	break;  case NULL:  	{  		alt9 = 9;  	}  	break;  default: {  	NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  	DebugRecognitionException (nvae);  	throw nvae;  }  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: switch (input.LA (1)) {  case CHAIN_OPERATOR:  case COMPARATOR:  	{  		alt9 = 1;  	}  	break;  case EXPR:  	{  		int LA9_2 = input.LA (2);  		if ((LA9_2 == DOWN)) {  			int LA9_3 = input.LA (3);  			if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  				alt9 = 2;  			}  			else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  				alt9 = 3;  			}  			else {  				NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  				DebugRecognitionException (nvae);  				throw nvae;  			}  		}  		else {  			NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  			DebugRecognitionException (nvae);  			throw nvae;  		}  	}  	break;  case STRING:  	{  		alt9 = 4;  	}  	break;  case REGEX:  	{  		alt9 = 5;  	}  	break;  case NUMBER:  	{  		alt9 = 6;  	}  	break;  case TRUE:  	{  		alt9 = 7;  	}  	break;  case FALSE:  	{  		alt9 = 8;  	}  	break;  case NULL:  	{  		alt9 = 9;  	}  	break;  default: {  	NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  	DebugRecognitionException (nvae);  	throw nvae;  }  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: switch (input.LA (1)) {  case CHAIN_OPERATOR:  case COMPARATOR:  	{  		alt9 = 1;  	}  	break;  case EXPR:  	{  		int LA9_2 = input.LA (2);  		if ((LA9_2 == DOWN)) {  			int LA9_3 = input.LA (3);  			if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  				alt9 = 2;  			}  			else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  				alt9 = 3;  			}  			else {  				NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  				DebugRecognitionException (nvae);  				throw nvae;  			}  		}  		else {  			NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  			DebugRecognitionException (nvae);  			throw nvae;  		}  	}  	break;  case STRING:  	{  		alt9 = 4;  	}  	break;  case REGEX:  	{  		alt9 = 5;  	}  	break;  case NUMBER:  	{  		alt9 = 6;  	}  	break;  case TRUE:  	{  		alt9 = 7;  	}  	break;  case FALSE:  	{  		alt9 = 8;  	}  	break;  case NULL:  	{  		alt9 = 9;  	}  	break;  default: {  	NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  	DebugRecognitionException (nvae);  	throw nvae;  }  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: switch (input.LA (1)) {  case CHAIN_OPERATOR:  case COMPARATOR:  	{  		alt9 = 1;  	}  	break;  case EXPR:  	{  		int LA9_2 = input.LA (2);  		if ((LA9_2 == DOWN)) {  			int LA9_3 = input.LA (3);  			if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  				alt9 = 2;  			}  			else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  				alt9 = 3;  			}  			else {  				NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  				DebugRecognitionException (nvae);  				throw nvae;  			}  		}  		else {  			NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  			DebugRecognitionException (nvae);  			throw nvae;  		}  	}  	break;  case STRING:  	{  		alt9 = 4;  	}  	break;  case REGEX:  	{  		alt9 = 5;  	}  	break;  case NUMBER:  	{  		alt9 = 6;  	}  	break;  case TRUE:  	{  		alt9 = 7;  	}  	break;  case FALSE:  	{  		alt9 = 8;  	}  	break;  case NULL:  	{  		alt9 = 9;  	}  	break;  default: {  	NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  	DebugRecognitionException (nvae);  	throw nvae;  }  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: switch (input.LA (1)) {  case CHAIN_OPERATOR:  case COMPARATOR:  	{  		alt9 = 1;  	}  	break;  case EXPR:  	{  		int LA9_2 = input.LA (2);  		if ((LA9_2 == DOWN)) {  			int LA9_3 = input.LA (3);  			if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  				alt9 = 2;  			}  			else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  				alt9 = 3;  			}  			else {  				NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  				DebugRecognitionException (nvae);  				throw nvae;  			}  		}  		else {  			NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  			DebugRecognitionException (nvae);  			throw nvae;  		}  	}  	break;  case STRING:  	{  		alt9 = 4;  	}  	break;  case REGEX:  	{  		alt9 = 5;  	}  	break;  case NUMBER:  	{  		alt9 = 6;  	}  	break;  case TRUE:  	{  		alt9 = 7;  	}  	break;  case FALSE:  	{  		alt9 = 8;  	}  	break;  case NULL:  	{  		alt9 = 9;  	}  	break;  default: {  	NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  	DebugRecognitionException (nvae);  	throw nvae;  }  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: switch (input.LA (1)) {  case CHAIN_OPERATOR:  case COMPARATOR:  	{  		alt9 = 1;  	}  	break;  case EXPR:  	{  		int LA9_2 = input.LA (2);  		if ((LA9_2 == DOWN)) {  			int LA9_3 = input.LA (3);  			if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  				alt9 = 2;  			}  			else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  				alt9 = 3;  			}  			else {  				NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  				DebugRecognitionException (nvae);  				throw nvae;  			}  		}  		else {  			NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  			DebugRecognitionException (nvae);  			throw nvae;  		}  	}  	break;  case STRING:  	{  		alt9 = 4;  	}  	break;  case REGEX:  	{  		alt9 = 5;  	}  	break;  case NUMBER:  	{  		alt9 = 6;  	}  	break;  case TRUE:  	{  		alt9 = 7;  	}  	break;  case FALSE:  	{  		alt9 = 8;  	}  	break;  case NULL:  	{  		alt9 = 9;  	}  	break;  default: {  	NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  	DebugRecognitionException (nvae);  	throw nvae;  }  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: switch (input.LA (1)) {  case CHAIN_OPERATOR:  case COMPARATOR:  	{  		alt9 = 1;  	}  	break;  case EXPR:  	{  		int LA9_2 = input.LA (2);  		if ((LA9_2 == DOWN)) {  			int LA9_3 = input.LA (3);  			if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  				alt9 = 2;  			}  			else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  				alt9 = 3;  			}  			else {  				NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  				DebugRecognitionException (nvae);  				throw nvae;  			}  		}  		else {  			NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  			DebugRecognitionException (nvae);  			throw nvae;  		}  	}  	break;  case STRING:  	{  		alt9 = 4;  	}  	break;  case REGEX:  	{  		alt9 = 5;  	}  	break;  case NUMBER:  	{  		alt9 = 6;  	}  	break;  case TRUE:  	{  		alt9 = 7;  	}  	break;  case FALSE:  	{  		alt9 = 8;  	}  	break;  case NULL:  	{  		alt9 = 9;  	}  	break;  default: {  	NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  	DebugRecognitionException (nvae);  	throw nvae;  }  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: switch (input.LA (1)) {  case CHAIN_OPERATOR:  case COMPARATOR:  	{  		alt9 = 1;  	}  	break;  case EXPR:  	{  		int LA9_2 = input.LA (2);  		if ((LA9_2 == DOWN)) {  			int LA9_3 = input.LA (3);  			if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  				alt9 = 2;  			}  			else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  				alt9 = 3;  			}  			else {  				NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  				DebugRecognitionException (nvae);  				throw nvae;  			}  		}  		else {  			NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  			DebugRecognitionException (nvae);  			throw nvae;  		}  	}  	break;  case STRING:  	{  		alt9 = 4;  	}  	break;  case REGEX:  	{  		alt9 = 5;  	}  	break;  case NUMBER:  	{  		alt9 = 6;  	}  	break;  case TRUE:  	{  		alt9 = 7;  	}  	break;  case FALSE:  	{  		alt9 = 8;  	}  	break;  case NULL:  	{  		alt9 = 9;  	}  	break;  default: {  	NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  	DebugRecognitionException (nvae);  	throw nvae;  }  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: switch (input.LA (1)) {  case CHAIN_OPERATOR:  case COMPARATOR:  	{  		alt9 = 1;  	}  	break;  case EXPR:  	{  		int LA9_2 = input.LA (2);  		if ((LA9_2 == DOWN)) {  			int LA9_3 = input.LA (3);  			if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  				alt9 = 2;  			}  			else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  				alt9 = 3;  			}  			else {  				NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  				DebugRecognitionException (nvae);  				throw nvae;  			}  		}  		else {  			NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  			DebugRecognitionException (nvae);  			throw nvae;  		}  	}  	break;  case STRING:  	{  		alt9 = 4;  	}  	break;  case REGEX:  	{  		alt9 = 5;  	}  	break;  case NUMBER:  	{  		alt9 = 6;  	}  	break;  case TRUE:  	{  		alt9 = 7;  	}  	break;  case FALSE:  	{  		alt9 = 8;  	}  	break;  case NULL:  	{  		alt9 = 9;  	}  	break;  default: {  	NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  	DebugRecognitionException (nvae);  	throw nvae;  }  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: switch (input.LA (1)) {  case CHAIN_OPERATOR:  case COMPARATOR:  	{  		alt9 = 1;  	}  	break;  case EXPR:  	{  		int LA9_2 = input.LA (2);  		if ((LA9_2 == DOWN)) {  			int LA9_3 = input.LA (3);  			if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  				alt9 = 2;  			}  			else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  				alt9 = 3;  			}  			else {  				NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  				DebugRecognitionException (nvae);  				throw nvae;  			}  		}  		else {  			NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  			DebugRecognitionException (nvae);  			throw nvae;  		}  	}  	break;  case STRING:  	{  		alt9 = 4;  	}  	break;  case REGEX:  	{  		alt9 = 5;  	}  	break;  case NUMBER:  	{  		alt9 = 6;  	}  	break;  case TRUE:  	{  		alt9 = 7;  	}  	break;  case FALSE:  	{  		alt9 = 8;  	}  	break;  case NULL:  	{  		alt9 = 9;  	}  	break;  default: {  	NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  	DebugRecognitionException (nvae);  	throw nvae;  }  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: switch (input.LA (1)) {  case CHAIN_OPERATOR:  case COMPARATOR:  	{  		alt9 = 1;  	}  	break;  case EXPR:  	{  		int LA9_2 = input.LA (2);  		if ((LA9_2 == DOWN)) {  			int LA9_3 = input.LA (3);  			if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  				alt9 = 2;  			}  			else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  				alt9 = 3;  			}  			else {  				NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  				DebugRecognitionException (nvae);  				throw nvae;  			}  		}  		else {  			NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  			DebugRecognitionException (nvae);  			throw nvae;  		}  	}  	break;  case STRING:  	{  		alt9 = 4;  	}  	break;  case REGEX:  	{  		alt9 = 5;  	}  	break;  case NUMBER:  	{  		alt9 = 6;  	}  	break;  case TRUE:  	{  		alt9 = 7;  	}  	break;  case FALSE:  	{  		alt9 = 8;  	}  	break;  case NULL:  	{  		alt9 = 9;  	}  	break;  default: {  	NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  	DebugRecognitionException (nvae);  	throw nvae;  }  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: switch (input.LA (1)) {  case CHAIN_OPERATOR:  case COMPARATOR:  	{  		alt9 = 1;  	}  	break;  case EXPR:  	{  		int LA9_2 = input.LA (2);  		if ((LA9_2 == DOWN)) {  			int LA9_3 = input.LA (3);  			if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  				alt9 = 2;  			}  			else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  				alt9 = 3;  			}  			else {  				NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  				DebugRecognitionException (nvae);  				throw nvae;  			}  		}  		else {  			NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  			DebugRecognitionException (nvae);  			throw nvae;  		}  	}  	break;  case STRING:  	{  		alt9 = 4;  	}  	break;  case REGEX:  	{  		alt9 = 5;  	}  	break;  case NUMBER:  	{  		alt9 = 6;  	}  	break;  case TRUE:  	{  		alt9 = 7;  	}  	break;  case FALSE:  	{  		alt9 = 8;  	}  	break;  case NULL:  	{  		alt9 = 9;  	}  	break;  default: {  	NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  	DebugRecognitionException (nvae);  	throw nvae;  }  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: switch (input.LA (1)) {  case CHAIN_OPERATOR:  case COMPARATOR:  	{  		alt9 = 1;  	}  	break;  case EXPR:  	{  		int LA9_2 = input.LA (2);  		if ((LA9_2 == DOWN)) {  			int LA9_3 = input.LA (3);  			if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  				alt9 = 2;  			}  			else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  				alt9 = 3;  			}  			else {  				NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  				DebugRecognitionException (nvae);  				throw nvae;  			}  		}  		else {  			NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  			DebugRecognitionException (nvae);  			throw nvae;  		}  	}  	break;  case STRING:  	{  		alt9 = 4;  	}  	break;  case REGEX:  	{  		alt9 = 5;  	}  	break;  case NUMBER:  	{  		alt9 = 6;  	}  	break;  case TRUE:  	{  		alt9 = 7;  	}  	break;  case FALSE:  	{  		alt9 = 8;  	}  	break;  case NULL:  	{  		alt9 = 9;  	}  	break;  default: {  	NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  	DebugRecognitionException (nvae);  	throw nvae;  }  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: switch (input.LA (1)) {  case CHAIN_OPERATOR:  case COMPARATOR:  	{  		alt9 = 1;  	}  	break;  case EXPR:  	{  		int LA9_2 = input.LA (2);  		if ((LA9_2 == DOWN)) {  			int LA9_3 = input.LA (3);  			if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  				alt9 = 2;  			}  			else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  				alt9 = 3;  			}  			else {  				NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  				DebugRecognitionException (nvae);  				throw nvae;  			}  		}  		else {  			NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  			DebugRecognitionException (nvae);  			throw nvae;  		}  	}  	break;  case STRING:  	{  		alt9 = 4;  	}  	break;  case REGEX:  	{  		alt9 = 5;  	}  	break;  case NUMBER:  	{  		alt9 = 6;  	}  	break;  case TRUE:  	{  		alt9 = 7;  	}  	break;  case FALSE:  	{  		alt9 = 8;  	}  	break;  case NULL:  	{  		alt9 = 9;  	}  	break;  default: {  	NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  	DebugRecognitionException (nvae);  	throw nvae;  }  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: switch (input.LA (1)) {  case CHAIN_OPERATOR:  case COMPARATOR:  	{  		alt9 = 1;  	}  	break;  case EXPR:  	{  		int LA9_2 = input.LA (2);  		if ((LA9_2 == DOWN)) {  			int LA9_3 = input.LA (3);  			if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  				alt9 = 2;  			}  			else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  				alt9 = 3;  			}  			else {  				NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  				DebugRecognitionException (nvae);  				throw nvae;  			}  		}  		else {  			NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  			DebugRecognitionException (nvae);  			throw nvae;  		}  	}  	break;  case STRING:  	{  		alt9 = 4;  	}  	break;  case REGEX:  	{  		alt9 = 5;  	}  	break;  case NUMBER:  	{  		alt9 = 6;  	}  	break;  case TRUE:  	{  		alt9 = 7;  	}  	break;  case FALSE:  	{  		alt9 = 8;  	}  	break;  case NULL:  	{  		alt9 = 9;  	}  	break;  default: {  	NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  	DebugRecognitionException (nvae);  	throw nvae;  }  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: switch (input.LA (1)) {  case CHAIN_OPERATOR:  case COMPARATOR:  	{  		alt9 = 1;  	}  	break;  case EXPR:  	{  		int LA9_2 = input.LA (2);  		if ((LA9_2 == DOWN)) {  			int LA9_3 = input.LA (3);  			if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  				alt9 = 2;  			}  			else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  				alt9 = 3;  			}  			else {  				NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  				DebugRecognitionException (nvae);  				throw nvae;  			}  		}  		else {  			NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  			DebugRecognitionException (nvae);  			throw nvae;  		}  	}  	break;  case STRING:  	{  		alt9 = 4;  	}  	break;  case REGEX:  	{  		alt9 = 5;  	}  	break;  case NUMBER:  	{  		alt9 = 6;  	}  	break;  case TRUE:  	{  		alt9 = 7;  	}  	break;  case FALSE:  	{  		alt9 = 8;  	}  	break;  case NULL:  	{  		alt9 = 9;  	}  	break;  default: {  	NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  	DebugRecognitionException (nvae);  	throw nvae;  }  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: switch (input.LA (1)) {  case CHAIN_OPERATOR:  case COMPARATOR:  	{  		alt9 = 1;  	}  	break;  case EXPR:  	{  		int LA9_2 = input.LA (2);  		if ((LA9_2 == DOWN)) {  			int LA9_3 = input.LA (3);  			if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  				alt9 = 2;  			}  			else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  				alt9 = 3;  			}  			else {  				NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  				DebugRecognitionException (nvae);  				throw nvae;  			}  		}  		else {  			NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  			DebugRecognitionException (nvae);  			throw nvae;  		}  	}  	break;  case STRING:  	{  		alt9 = 4;  	}  	break;  case REGEX:  	{  		alt9 = 5;  	}  	break;  case NUMBER:  	{  		alt9 = 6;  	}  	break;  case TRUE:  	{  		alt9 = 7;  	}  	break;  case FALSE:  	{  		alt9 = 8;  	}  	break;  case NULL:  	{  		alt9 = 9;  	}  	break;  default: {  	NoViableAltException nvae = new NoViableAltException (""' 9' 0' input' 1);  	DebugRecognitionException (nvae);  	throw nvae;  }  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: if ((LA9_2 == DOWN)) {  	int LA9_3 = input.LA (3);  	if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  		alt9 = 2;  	}  	else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  		alt9 = 3;  	}  	else {  		NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  		DebugRecognitionException (nvae);  		throw nvae;  	}  }  else {  	NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  	DebugRecognitionException (nvae);  	throw nvae;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: if ((LA9_2 == DOWN)) {  	int LA9_3 = input.LA (3);  	if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  		alt9 = 2;  	}  	else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  		alt9 = 3;  	}  	else {  		NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  		DebugRecognitionException (nvae);  		throw nvae;  	}  }  else {  	NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  	DebugRecognitionException (nvae);  	throw nvae;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: if ((LA9_2 == DOWN)) {  	int LA9_3 = input.LA (3);  	if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  		alt9 = 2;  	}  	else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  		alt9 = 3;  	}  	else {  		NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  		DebugRecognitionException (nvae);  		throw nvae;  	}  }  else {  	NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  	DebugRecognitionException (nvae);  	throw nvae;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: if ((LA9_2 == DOWN)) {  	int LA9_3 = input.LA (3);  	if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  		alt9 = 2;  	}  	else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  		alt9 = 3;  	}  	else {  		NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  		DebugRecognitionException (nvae);  		throw nvae;  	}  }  else {  	NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  	DebugRecognitionException (nvae);  	throw nvae;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: if ((LA9_2 == DOWN)) {  	int LA9_3 = input.LA (3);  	if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  		alt9 = 2;  	}  	else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  		alt9 = 3;  	}  	else {  		NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  		DebugRecognitionException (nvae);  		throw nvae;  	}  }  else {  	NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  	DebugRecognitionException (nvae);  	throw nvae;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: if ((LA9_2 == DOWN)) {  	int LA9_3 = input.LA (3);  	if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  		alt9 = 2;  	}  	else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  		alt9 = 3;  	}  	else {  		NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  		DebugRecognitionException (nvae);  		throw nvae;  	}  }  else {  	NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  	DebugRecognitionException (nvae);  	throw nvae;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: if ((LA9_2 == DOWN)) {  	int LA9_3 = input.LA (3);  	if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  		alt9 = 2;  	}  	else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  		alt9 = 3;  	}  	else {  		NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  		DebugRecognitionException (nvae);  		throw nvae;  	}  }  else {  	NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  	DebugRecognitionException (nvae);  	throw nvae;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: if ((LA9_2 == DOWN)) {  	int LA9_3 = input.LA (3);  	if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  		alt9 = 2;  	}  	else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  		alt9 = 3;  	}  	else {  		NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  		DebugRecognitionException (nvae);  		throw nvae;  	}  }  else {  	NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  	DebugRecognitionException (nvae);  	throw nvae;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: if ((LA9_2 == DOWN)) {  	int LA9_3 = input.LA (3);  	if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  		alt9 = 2;  	}  	else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  		alt9 = 3;  	}  	else {  		NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  		DebugRecognitionException (nvae);  		throw nvae;  	}  }  else {  	NoViableAltException nvae = new NoViableAltException (""' 9' 2' input' 2);  	DebugRecognitionException (nvae);  	throw nvae;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  	alt9 = 2;  }  else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  	alt9 = 3;  }  else {  	NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  	DebugRecognitionException (nvae);  	throw nvae;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  	alt9 = 2;  }  else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  	alt9 = 3;  }  else {  	NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  	DebugRecognitionException (nvae);  	throw nvae;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  	alt9 = 2;  }  else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  	alt9 = 3;  }  else {  	NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  	DebugRecognitionException (nvae);  	throw nvae;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  	alt9 = 2;  }  else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  	alt9 = 3;  }  else {  	NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  	DebugRecognitionException (nvae);  	throw nvae;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: if (((LA9_3 >= CHAIN_OPERATOR && LA9_3 <= COMPARATOR) || (LA9_3 >= EXPR && LA9_3 <= FALSE) || (LA9_3 >= NULL && LA9_3 <= TRUE))) {  	alt9 = 2;  }  else if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  	alt9 = 3;  }  else {  	NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  	DebugRecognitionException (nvae);  	throw nvae;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: alt9 = 2;  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  	alt9 = 3;  }  else {  	NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  	DebugRecognitionException (nvae);  	throw nvae;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  	alt9 = 3;  }  else {  	NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  	DebugRecognitionException (nvae);  	throw nvae;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  	alt9 = 3;  }  else {  	NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  	DebugRecognitionException (nvae);  	throw nvae;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: if ((LA9_3 == ESC_ID || LA9_3 == ID)) {  	alt9 = 3;  }  else {  	NoViableAltException nvae = new NoViableAltException (""' 9' 9' input' 3);  	DebugRecognitionException (nvae);  	throw nvae;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: alt9 = 3;  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: alt9 = 4;  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: alt9 = 5;  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: alt9 = 6;  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: alt9 = 7;  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: alt9 = 8;  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: alt9 = 9;  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: DebugExitDecision (9);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: switch (alt9) {  case 1:  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  	{  		DebugLocation (64' 4);  		DebugLocation (64' 6);  		PushFollow (Follow._comparator_in_filterExpr175);  		comparator6 = comparator ();  		PopFollow ();  		Match (input' TokenTypes.Down' null);  		DebugLocation (64' 18);  		PushFollow (Follow._filterExpr_in_filterExpr179);  		a = filterExpr ();  		PopFollow ();  		DebugLocation (64' 31);  		PushFollow (Follow._filterExpr_in_filterExpr183);  		b = filterExpr ();  		PopFollow ();  		Match (input' TokenTypes.Up' null);  		DebugLocation (65' 4);  		Comparator newComparator;  		switch (comparator6) {  		case "=":  			newComparator = Comparator.Equals;  			break;  		case "!=":  			newComparator = Comparator.NotEquals;  			break;  		case ">":  			newComparator = Comparator.Greater;  			break;  		case "<":  			newComparator = Comparator.Less;  			break;  		case ">=":  			newComparator = Comparator.GreaterOrEqual;  			break;  		case "<=":  			newComparator = Comparator.LessOrEqual;  			break;  		case "&":  			newComparator = Comparator.And;  			break;  		case "|":  			newComparator = Comparator.Or;  			break;  		default:  			newComparator = Comparator.Equals;  			break;  		}  		filterNode = new BoolExpression (a' newComparator' b);  	}  	break;  case 2:  	DebugEnterAlt (2);  	// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  	{  		DebugLocation (98' 4);  		DebugLocation (98' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr195);  		Match (input' TokenTypes.Down' null);  		DebugLocation (98' 12);  		PushFollow (Follow._filterExpr_in_filterExpr199);  		f = filterExpr ();  		PopFollow ();  		DebugLocation (98' 31);  		// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  		int alt6 = 2;  		try {  			DebugEnterSubRule (6);  			try {  				DebugEnterDecision (6' false);  				int LA6_1 = input.LA (1);  				if ((LA6_1 == 24)) {  					alt6 = 1;  				}  			}  			finally {  				DebugExitDecision (6);  			}  			switch (alt6) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  				{  					DebugLocation (98' 31);  					inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (6);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (99' 4);  		FilterTreeNode newNode = f;  		if ((inverse != null ? inverse.Text : default(string)) == "!")  			newNode.ToggleInversed ();  		filterNode = newNode;  	}  	break;  case 3:  	DebugEnterAlt (3);  	// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  	{  		DebugLocation (105' 4);  		DebugLocation (105' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr216);  		Match (input' TokenTypes.Down' null);  		DebugLocation (105' 12);  		PushFollow (Follow._propertyChain_in_filterExpr219);  		propertyChain (propertySegments);  		PopFollow ();  		DebugLocation (105' 51);  		// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  		int alt7 = 2;  		try {  			DebugEnterSubRule (7);  			try {  				DebugEnterDecision (7' false);  				int LA7_1 = input.LA (1);  				if ((LA7_1 == 31)) {  					alt7 = 1;  				}  			}  			finally {  				DebugExitDecision (7);  			}  			switch (alt7) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  				{  					DebugLocation (105' 51);  					inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (7);  		}  		DebugLocation (105' 60);  		// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  		int alt8 = 2;  		try {  			DebugEnterSubRule (8);  			try {  				DebugEnterDecision (8' false);  				int LA8_1 = input.LA (1);  				if ((LA8_1 == 24)) {  					alt8 = 1;  				}  			}  			finally {  				DebugExitDecision (8);  			}  			switch (alt8) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  				{  					DebugLocation (105' 60);  					not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (8);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (106' 4);  		FilterTreeNode newProperty = new Property (propertySegments);  		if ((inverse != null ? inverse.Text : default(string)) == "?")  			filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  		else {  			if ((not != null ? not.Text : default(string)) == "!")  				newProperty.ToggleInversed ();  			filterNode = newProperty;  		}  	}  	break;  case 4:  	DebugEnterAlt (4);  	// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  	{  		DebugLocation (116' 4);  		STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  		DebugLocation (117' 4);  		string stringText = (STRING7 != null ? STRING7.Text : default(string));  		stringText = stringText.Substring (1' stringText.Length - 2);  		filterNode = new Value (stringText);  	}  	break;  case 5:  	DebugEnterAlt (5);  	// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  	{  		DebugLocation (122' 4);  		REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  		DebugLocation (123' 4);  		string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  		regexText = regexText.Substring (1' regexText.Length - 2);  		filterNode = new RegExp (regexText);  	}  	break;  case 6:  	DebugEnterAlt (6);  	// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  	{  		DebugLocation (128' 4);  		NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  		DebugLocation (129' 4);  		filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  	}  	break;  case 7:  	DebugEnterAlt (7);  	// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  	{  		DebugLocation (132' 4);  		Match (input' TRUE' Follow._TRUE_in_filterExpr271);  		DebugLocation (133' 4);  		filterNode = new Value (true);  	}  	break;  case 8:  	DebugEnterAlt (8);  	// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  	{  		DebugLocation (136' 4);  		Match (input' FALSE' Follow._FALSE_in_filterExpr281);  		DebugLocation (137' 4);  		filterNode = new Value (false);  	}  	break;  case 9:  	DebugEnterAlt (9);  	// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  	{  		DebugLocation (140' 4);  		Match (input' NULL' Follow._NULL_in_filterExpr291);  		DebugLocation (141' 4);  		filterNode = new Value (null);  	}  	break;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: switch (alt9) {  case 1:  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  	{  		DebugLocation (64' 4);  		DebugLocation (64' 6);  		PushFollow (Follow._comparator_in_filterExpr175);  		comparator6 = comparator ();  		PopFollow ();  		Match (input' TokenTypes.Down' null);  		DebugLocation (64' 18);  		PushFollow (Follow._filterExpr_in_filterExpr179);  		a = filterExpr ();  		PopFollow ();  		DebugLocation (64' 31);  		PushFollow (Follow._filterExpr_in_filterExpr183);  		b = filterExpr ();  		PopFollow ();  		Match (input' TokenTypes.Up' null);  		DebugLocation (65' 4);  		Comparator newComparator;  		switch (comparator6) {  		case "=":  			newComparator = Comparator.Equals;  			break;  		case "!=":  			newComparator = Comparator.NotEquals;  			break;  		case ">":  			newComparator = Comparator.Greater;  			break;  		case "<":  			newComparator = Comparator.Less;  			break;  		case ">=":  			newComparator = Comparator.GreaterOrEqual;  			break;  		case "<=":  			newComparator = Comparator.LessOrEqual;  			break;  		case "&":  			newComparator = Comparator.And;  			break;  		case "|":  			newComparator = Comparator.Or;  			break;  		default:  			newComparator = Comparator.Equals;  			break;  		}  		filterNode = new BoolExpression (a' newComparator' b);  	}  	break;  case 2:  	DebugEnterAlt (2);  	// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  	{  		DebugLocation (98' 4);  		DebugLocation (98' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr195);  		Match (input' TokenTypes.Down' null);  		DebugLocation (98' 12);  		PushFollow (Follow._filterExpr_in_filterExpr199);  		f = filterExpr ();  		PopFollow ();  		DebugLocation (98' 31);  		// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  		int alt6 = 2;  		try {  			DebugEnterSubRule (6);  			try {  				DebugEnterDecision (6' false);  				int LA6_1 = input.LA (1);  				if ((LA6_1 == 24)) {  					alt6 = 1;  				}  			}  			finally {  				DebugExitDecision (6);  			}  			switch (alt6) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  				{  					DebugLocation (98' 31);  					inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (6);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (99' 4);  		FilterTreeNode newNode = f;  		if ((inverse != null ? inverse.Text : default(string)) == "!")  			newNode.ToggleInversed ();  		filterNode = newNode;  	}  	break;  case 3:  	DebugEnterAlt (3);  	// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  	{  		DebugLocation (105' 4);  		DebugLocation (105' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr216);  		Match (input' TokenTypes.Down' null);  		DebugLocation (105' 12);  		PushFollow (Follow._propertyChain_in_filterExpr219);  		propertyChain (propertySegments);  		PopFollow ();  		DebugLocation (105' 51);  		// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  		int alt7 = 2;  		try {  			DebugEnterSubRule (7);  			try {  				DebugEnterDecision (7' false);  				int LA7_1 = input.LA (1);  				if ((LA7_1 == 31)) {  					alt7 = 1;  				}  			}  			finally {  				DebugExitDecision (7);  			}  			switch (alt7) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  				{  					DebugLocation (105' 51);  					inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (7);  		}  		DebugLocation (105' 60);  		// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  		int alt8 = 2;  		try {  			DebugEnterSubRule (8);  			try {  				DebugEnterDecision (8' false);  				int LA8_1 = input.LA (1);  				if ((LA8_1 == 24)) {  					alt8 = 1;  				}  			}  			finally {  				DebugExitDecision (8);  			}  			switch (alt8) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  				{  					DebugLocation (105' 60);  					not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (8);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (106' 4);  		FilterTreeNode newProperty = new Property (propertySegments);  		if ((inverse != null ? inverse.Text : default(string)) == "?")  			filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  		else {  			if ((not != null ? not.Text : default(string)) == "!")  				newProperty.ToggleInversed ();  			filterNode = newProperty;  		}  	}  	break;  case 4:  	DebugEnterAlt (4);  	// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  	{  		DebugLocation (116' 4);  		STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  		DebugLocation (117' 4);  		string stringText = (STRING7 != null ? STRING7.Text : default(string));  		stringText = stringText.Substring (1' stringText.Length - 2);  		filterNode = new Value (stringText);  	}  	break;  case 5:  	DebugEnterAlt (5);  	// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  	{  		DebugLocation (122' 4);  		REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  		DebugLocation (123' 4);  		string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  		regexText = regexText.Substring (1' regexText.Length - 2);  		filterNode = new RegExp (regexText);  	}  	break;  case 6:  	DebugEnterAlt (6);  	// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  	{  		DebugLocation (128' 4);  		NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  		DebugLocation (129' 4);  		filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  	}  	break;  case 7:  	DebugEnterAlt (7);  	// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  	{  		DebugLocation (132' 4);  		Match (input' TRUE' Follow._TRUE_in_filterExpr271);  		DebugLocation (133' 4);  		filterNode = new Value (true);  	}  	break;  case 8:  	DebugEnterAlt (8);  	// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  	{  		DebugLocation (136' 4);  		Match (input' FALSE' Follow._FALSE_in_filterExpr281);  		DebugLocation (137' 4);  		filterNode = new Value (false);  	}  	break;  case 9:  	DebugEnterAlt (9);  	// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  	{  		DebugLocation (140' 4);  		Match (input' NULL' Follow._NULL_in_filterExpr291);  		DebugLocation (141' 4);  		filterNode = new Value (null);  	}  	break;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: switch (alt9) {  case 1:  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  	{  		DebugLocation (64' 4);  		DebugLocation (64' 6);  		PushFollow (Follow._comparator_in_filterExpr175);  		comparator6 = comparator ();  		PopFollow ();  		Match (input' TokenTypes.Down' null);  		DebugLocation (64' 18);  		PushFollow (Follow._filterExpr_in_filterExpr179);  		a = filterExpr ();  		PopFollow ();  		DebugLocation (64' 31);  		PushFollow (Follow._filterExpr_in_filterExpr183);  		b = filterExpr ();  		PopFollow ();  		Match (input' TokenTypes.Up' null);  		DebugLocation (65' 4);  		Comparator newComparator;  		switch (comparator6) {  		case "=":  			newComparator = Comparator.Equals;  			break;  		case "!=":  			newComparator = Comparator.NotEquals;  			break;  		case ">":  			newComparator = Comparator.Greater;  			break;  		case "<":  			newComparator = Comparator.Less;  			break;  		case ">=":  			newComparator = Comparator.GreaterOrEqual;  			break;  		case "<=":  			newComparator = Comparator.LessOrEqual;  			break;  		case "&":  			newComparator = Comparator.And;  			break;  		case "|":  			newComparator = Comparator.Or;  			break;  		default:  			newComparator = Comparator.Equals;  			break;  		}  		filterNode = new BoolExpression (a' newComparator' b);  	}  	break;  case 2:  	DebugEnterAlt (2);  	// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  	{  		DebugLocation (98' 4);  		DebugLocation (98' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr195);  		Match (input' TokenTypes.Down' null);  		DebugLocation (98' 12);  		PushFollow (Follow._filterExpr_in_filterExpr199);  		f = filterExpr ();  		PopFollow ();  		DebugLocation (98' 31);  		// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  		int alt6 = 2;  		try {  			DebugEnterSubRule (6);  			try {  				DebugEnterDecision (6' false);  				int LA6_1 = input.LA (1);  				if ((LA6_1 == 24)) {  					alt6 = 1;  				}  			}  			finally {  				DebugExitDecision (6);  			}  			switch (alt6) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  				{  					DebugLocation (98' 31);  					inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (6);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (99' 4);  		FilterTreeNode newNode = f;  		if ((inverse != null ? inverse.Text : default(string)) == "!")  			newNode.ToggleInversed ();  		filterNode = newNode;  	}  	break;  case 3:  	DebugEnterAlt (3);  	// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  	{  		DebugLocation (105' 4);  		DebugLocation (105' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr216);  		Match (input' TokenTypes.Down' null);  		DebugLocation (105' 12);  		PushFollow (Follow._propertyChain_in_filterExpr219);  		propertyChain (propertySegments);  		PopFollow ();  		DebugLocation (105' 51);  		// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  		int alt7 = 2;  		try {  			DebugEnterSubRule (7);  			try {  				DebugEnterDecision (7' false);  				int LA7_1 = input.LA (1);  				if ((LA7_1 == 31)) {  					alt7 = 1;  				}  			}  			finally {  				DebugExitDecision (7);  			}  			switch (alt7) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  				{  					DebugLocation (105' 51);  					inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (7);  		}  		DebugLocation (105' 60);  		// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  		int alt8 = 2;  		try {  			DebugEnterSubRule (8);  			try {  				DebugEnterDecision (8' false);  				int LA8_1 = input.LA (1);  				if ((LA8_1 == 24)) {  					alt8 = 1;  				}  			}  			finally {  				DebugExitDecision (8);  			}  			switch (alt8) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  				{  					DebugLocation (105' 60);  					not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (8);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (106' 4);  		FilterTreeNode newProperty = new Property (propertySegments);  		if ((inverse != null ? inverse.Text : default(string)) == "?")  			filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  		else {  			if ((not != null ? not.Text : default(string)) == "!")  				newProperty.ToggleInversed ();  			filterNode = newProperty;  		}  	}  	break;  case 4:  	DebugEnterAlt (4);  	// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  	{  		DebugLocation (116' 4);  		STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  		DebugLocation (117' 4);  		string stringText = (STRING7 != null ? STRING7.Text : default(string));  		stringText = stringText.Substring (1' stringText.Length - 2);  		filterNode = new Value (stringText);  	}  	break;  case 5:  	DebugEnterAlt (5);  	// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  	{  		DebugLocation (122' 4);  		REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  		DebugLocation (123' 4);  		string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  		regexText = regexText.Substring (1' regexText.Length - 2);  		filterNode = new RegExp (regexText);  	}  	break;  case 6:  	DebugEnterAlt (6);  	// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  	{  		DebugLocation (128' 4);  		NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  		DebugLocation (129' 4);  		filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  	}  	break;  case 7:  	DebugEnterAlt (7);  	// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  	{  		DebugLocation (132' 4);  		Match (input' TRUE' Follow._TRUE_in_filterExpr271);  		DebugLocation (133' 4);  		filterNode = new Value (true);  	}  	break;  case 8:  	DebugEnterAlt (8);  	// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  	{  		DebugLocation (136' 4);  		Match (input' FALSE' Follow._FALSE_in_filterExpr281);  		DebugLocation (137' 4);  		filterNode = new Value (false);  	}  	break;  case 9:  	DebugEnterAlt (9);  	// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  	{  		DebugLocation (140' 4);  		Match (input' NULL' Follow._NULL_in_filterExpr291);  		DebugLocation (141' 4);  		filterNode = new Value (null);  	}  	break;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: switch (alt9) {  case 1:  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  	{  		DebugLocation (64' 4);  		DebugLocation (64' 6);  		PushFollow (Follow._comparator_in_filterExpr175);  		comparator6 = comparator ();  		PopFollow ();  		Match (input' TokenTypes.Down' null);  		DebugLocation (64' 18);  		PushFollow (Follow._filterExpr_in_filterExpr179);  		a = filterExpr ();  		PopFollow ();  		DebugLocation (64' 31);  		PushFollow (Follow._filterExpr_in_filterExpr183);  		b = filterExpr ();  		PopFollow ();  		Match (input' TokenTypes.Up' null);  		DebugLocation (65' 4);  		Comparator newComparator;  		switch (comparator6) {  		case "=":  			newComparator = Comparator.Equals;  			break;  		case "!=":  			newComparator = Comparator.NotEquals;  			break;  		case ">":  			newComparator = Comparator.Greater;  			break;  		case "<":  			newComparator = Comparator.Less;  			break;  		case ">=":  			newComparator = Comparator.GreaterOrEqual;  			break;  		case "<=":  			newComparator = Comparator.LessOrEqual;  			break;  		case "&":  			newComparator = Comparator.And;  			break;  		case "|":  			newComparator = Comparator.Or;  			break;  		default:  			newComparator = Comparator.Equals;  			break;  		}  		filterNode = new BoolExpression (a' newComparator' b);  	}  	break;  case 2:  	DebugEnterAlt (2);  	// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  	{  		DebugLocation (98' 4);  		DebugLocation (98' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr195);  		Match (input' TokenTypes.Down' null);  		DebugLocation (98' 12);  		PushFollow (Follow._filterExpr_in_filterExpr199);  		f = filterExpr ();  		PopFollow ();  		DebugLocation (98' 31);  		// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  		int alt6 = 2;  		try {  			DebugEnterSubRule (6);  			try {  				DebugEnterDecision (6' false);  				int LA6_1 = input.LA (1);  				if ((LA6_1 == 24)) {  					alt6 = 1;  				}  			}  			finally {  				DebugExitDecision (6);  			}  			switch (alt6) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  				{  					DebugLocation (98' 31);  					inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (6);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (99' 4);  		FilterTreeNode newNode = f;  		if ((inverse != null ? inverse.Text : default(string)) == "!")  			newNode.ToggleInversed ();  		filterNode = newNode;  	}  	break;  case 3:  	DebugEnterAlt (3);  	// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  	{  		DebugLocation (105' 4);  		DebugLocation (105' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr216);  		Match (input' TokenTypes.Down' null);  		DebugLocation (105' 12);  		PushFollow (Follow._propertyChain_in_filterExpr219);  		propertyChain (propertySegments);  		PopFollow ();  		DebugLocation (105' 51);  		// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  		int alt7 = 2;  		try {  			DebugEnterSubRule (7);  			try {  				DebugEnterDecision (7' false);  				int LA7_1 = input.LA (1);  				if ((LA7_1 == 31)) {  					alt7 = 1;  				}  			}  			finally {  				DebugExitDecision (7);  			}  			switch (alt7) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  				{  					DebugLocation (105' 51);  					inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (7);  		}  		DebugLocation (105' 60);  		// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  		int alt8 = 2;  		try {  			DebugEnterSubRule (8);  			try {  				DebugEnterDecision (8' false);  				int LA8_1 = input.LA (1);  				if ((LA8_1 == 24)) {  					alt8 = 1;  				}  			}  			finally {  				DebugExitDecision (8);  			}  			switch (alt8) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  				{  					DebugLocation (105' 60);  					not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (8);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (106' 4);  		FilterTreeNode newProperty = new Property (propertySegments);  		if ((inverse != null ? inverse.Text : default(string)) == "?")  			filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  		else {  			if ((not != null ? not.Text : default(string)) == "!")  				newProperty.ToggleInversed ();  			filterNode = newProperty;  		}  	}  	break;  case 4:  	DebugEnterAlt (4);  	// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  	{  		DebugLocation (116' 4);  		STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  		DebugLocation (117' 4);  		string stringText = (STRING7 != null ? STRING7.Text : default(string));  		stringText = stringText.Substring (1' stringText.Length - 2);  		filterNode = new Value (stringText);  	}  	break;  case 5:  	DebugEnterAlt (5);  	// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  	{  		DebugLocation (122' 4);  		REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  		DebugLocation (123' 4);  		string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  		regexText = regexText.Substring (1' regexText.Length - 2);  		filterNode = new RegExp (regexText);  	}  	break;  case 6:  	DebugEnterAlt (6);  	// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  	{  		DebugLocation (128' 4);  		NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  		DebugLocation (129' 4);  		filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  	}  	break;  case 7:  	DebugEnterAlt (7);  	// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  	{  		DebugLocation (132' 4);  		Match (input' TRUE' Follow._TRUE_in_filterExpr271);  		DebugLocation (133' 4);  		filterNode = new Value (true);  	}  	break;  case 8:  	DebugEnterAlt (8);  	// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  	{  		DebugLocation (136' 4);  		Match (input' FALSE' Follow._FALSE_in_filterExpr281);  		DebugLocation (137' 4);  		filterNode = new Value (false);  	}  	break;  case 9:  	DebugEnterAlt (9);  	// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  	{  		DebugLocation (140' 4);  		Match (input' NULL' Follow._NULL_in_filterExpr291);  		DebugLocation (141' 4);  		filterNode = new Value (null);  	}  	break;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: switch (alt9) {  case 1:  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  	{  		DebugLocation (64' 4);  		DebugLocation (64' 6);  		PushFollow (Follow._comparator_in_filterExpr175);  		comparator6 = comparator ();  		PopFollow ();  		Match (input' TokenTypes.Down' null);  		DebugLocation (64' 18);  		PushFollow (Follow._filterExpr_in_filterExpr179);  		a = filterExpr ();  		PopFollow ();  		DebugLocation (64' 31);  		PushFollow (Follow._filterExpr_in_filterExpr183);  		b = filterExpr ();  		PopFollow ();  		Match (input' TokenTypes.Up' null);  		DebugLocation (65' 4);  		Comparator newComparator;  		switch (comparator6) {  		case "=":  			newComparator = Comparator.Equals;  			break;  		case "!=":  			newComparator = Comparator.NotEquals;  			break;  		case ">":  			newComparator = Comparator.Greater;  			break;  		case "<":  			newComparator = Comparator.Less;  			break;  		case ">=":  			newComparator = Comparator.GreaterOrEqual;  			break;  		case "<=":  			newComparator = Comparator.LessOrEqual;  			break;  		case "&":  			newComparator = Comparator.And;  			break;  		case "|":  			newComparator = Comparator.Or;  			break;  		default:  			newComparator = Comparator.Equals;  			break;  		}  		filterNode = new BoolExpression (a' newComparator' b);  	}  	break;  case 2:  	DebugEnterAlt (2);  	// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  	{  		DebugLocation (98' 4);  		DebugLocation (98' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr195);  		Match (input' TokenTypes.Down' null);  		DebugLocation (98' 12);  		PushFollow (Follow._filterExpr_in_filterExpr199);  		f = filterExpr ();  		PopFollow ();  		DebugLocation (98' 31);  		// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  		int alt6 = 2;  		try {  			DebugEnterSubRule (6);  			try {  				DebugEnterDecision (6' false);  				int LA6_1 = input.LA (1);  				if ((LA6_1 == 24)) {  					alt6 = 1;  				}  			}  			finally {  				DebugExitDecision (6);  			}  			switch (alt6) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  				{  					DebugLocation (98' 31);  					inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (6);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (99' 4);  		FilterTreeNode newNode = f;  		if ((inverse != null ? inverse.Text : default(string)) == "!")  			newNode.ToggleInversed ();  		filterNode = newNode;  	}  	break;  case 3:  	DebugEnterAlt (3);  	// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  	{  		DebugLocation (105' 4);  		DebugLocation (105' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr216);  		Match (input' TokenTypes.Down' null);  		DebugLocation (105' 12);  		PushFollow (Follow._propertyChain_in_filterExpr219);  		propertyChain (propertySegments);  		PopFollow ();  		DebugLocation (105' 51);  		// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  		int alt7 = 2;  		try {  			DebugEnterSubRule (7);  			try {  				DebugEnterDecision (7' false);  				int LA7_1 = input.LA (1);  				if ((LA7_1 == 31)) {  					alt7 = 1;  				}  			}  			finally {  				DebugExitDecision (7);  			}  			switch (alt7) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  				{  					DebugLocation (105' 51);  					inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (7);  		}  		DebugLocation (105' 60);  		// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  		int alt8 = 2;  		try {  			DebugEnterSubRule (8);  			try {  				DebugEnterDecision (8' false);  				int LA8_1 = input.LA (1);  				if ((LA8_1 == 24)) {  					alt8 = 1;  				}  			}  			finally {  				DebugExitDecision (8);  			}  			switch (alt8) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  				{  					DebugLocation (105' 60);  					not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (8);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (106' 4);  		FilterTreeNode newProperty = new Property (propertySegments);  		if ((inverse != null ? inverse.Text : default(string)) == "?")  			filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  		else {  			if ((not != null ? not.Text : default(string)) == "!")  				newProperty.ToggleInversed ();  			filterNode = newProperty;  		}  	}  	break;  case 4:  	DebugEnterAlt (4);  	// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  	{  		DebugLocation (116' 4);  		STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  		DebugLocation (117' 4);  		string stringText = (STRING7 != null ? STRING7.Text : default(string));  		stringText = stringText.Substring (1' stringText.Length - 2);  		filterNode = new Value (stringText);  	}  	break;  case 5:  	DebugEnterAlt (5);  	// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  	{  		DebugLocation (122' 4);  		REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  		DebugLocation (123' 4);  		string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  		regexText = regexText.Substring (1' regexText.Length - 2);  		filterNode = new RegExp (regexText);  	}  	break;  case 6:  	DebugEnterAlt (6);  	// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  	{  		DebugLocation (128' 4);  		NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  		DebugLocation (129' 4);  		filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  	}  	break;  case 7:  	DebugEnterAlt (7);  	// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  	{  		DebugLocation (132' 4);  		Match (input' TRUE' Follow._TRUE_in_filterExpr271);  		DebugLocation (133' 4);  		filterNode = new Value (true);  	}  	break;  case 8:  	DebugEnterAlt (8);  	// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  	{  		DebugLocation (136' 4);  		Match (input' FALSE' Follow._FALSE_in_filterExpr281);  		DebugLocation (137' 4);  		filterNode = new Value (false);  	}  	break;  case 9:  	DebugEnterAlt (9);  	// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  	{  		DebugLocation (140' 4);  		Match (input' NULL' Follow._NULL_in_filterExpr291);  		DebugLocation (141' 4);  		filterNode = new Value (null);  	}  	break;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: switch (alt9) {  case 1:  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  	{  		DebugLocation (64' 4);  		DebugLocation (64' 6);  		PushFollow (Follow._comparator_in_filterExpr175);  		comparator6 = comparator ();  		PopFollow ();  		Match (input' TokenTypes.Down' null);  		DebugLocation (64' 18);  		PushFollow (Follow._filterExpr_in_filterExpr179);  		a = filterExpr ();  		PopFollow ();  		DebugLocation (64' 31);  		PushFollow (Follow._filterExpr_in_filterExpr183);  		b = filterExpr ();  		PopFollow ();  		Match (input' TokenTypes.Up' null);  		DebugLocation (65' 4);  		Comparator newComparator;  		switch (comparator6) {  		case "=":  			newComparator = Comparator.Equals;  			break;  		case "!=":  			newComparator = Comparator.NotEquals;  			break;  		case ">":  			newComparator = Comparator.Greater;  			break;  		case "<":  			newComparator = Comparator.Less;  			break;  		case ">=":  			newComparator = Comparator.GreaterOrEqual;  			break;  		case "<=":  			newComparator = Comparator.LessOrEqual;  			break;  		case "&":  			newComparator = Comparator.And;  			break;  		case "|":  			newComparator = Comparator.Or;  			break;  		default:  			newComparator = Comparator.Equals;  			break;  		}  		filterNode = new BoolExpression (a' newComparator' b);  	}  	break;  case 2:  	DebugEnterAlt (2);  	// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  	{  		DebugLocation (98' 4);  		DebugLocation (98' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr195);  		Match (input' TokenTypes.Down' null);  		DebugLocation (98' 12);  		PushFollow (Follow._filterExpr_in_filterExpr199);  		f = filterExpr ();  		PopFollow ();  		DebugLocation (98' 31);  		// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  		int alt6 = 2;  		try {  			DebugEnterSubRule (6);  			try {  				DebugEnterDecision (6' false);  				int LA6_1 = input.LA (1);  				if ((LA6_1 == 24)) {  					alt6 = 1;  				}  			}  			finally {  				DebugExitDecision (6);  			}  			switch (alt6) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  				{  					DebugLocation (98' 31);  					inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (6);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (99' 4);  		FilterTreeNode newNode = f;  		if ((inverse != null ? inverse.Text : default(string)) == "!")  			newNode.ToggleInversed ();  		filterNode = newNode;  	}  	break;  case 3:  	DebugEnterAlt (3);  	// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  	{  		DebugLocation (105' 4);  		DebugLocation (105' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr216);  		Match (input' TokenTypes.Down' null);  		DebugLocation (105' 12);  		PushFollow (Follow._propertyChain_in_filterExpr219);  		propertyChain (propertySegments);  		PopFollow ();  		DebugLocation (105' 51);  		// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  		int alt7 = 2;  		try {  			DebugEnterSubRule (7);  			try {  				DebugEnterDecision (7' false);  				int LA7_1 = input.LA (1);  				if ((LA7_1 == 31)) {  					alt7 = 1;  				}  			}  			finally {  				DebugExitDecision (7);  			}  			switch (alt7) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  				{  					DebugLocation (105' 51);  					inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (7);  		}  		DebugLocation (105' 60);  		// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  		int alt8 = 2;  		try {  			DebugEnterSubRule (8);  			try {  				DebugEnterDecision (8' false);  				int LA8_1 = input.LA (1);  				if ((LA8_1 == 24)) {  					alt8 = 1;  				}  			}  			finally {  				DebugExitDecision (8);  			}  			switch (alt8) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  				{  					DebugLocation (105' 60);  					not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (8);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (106' 4);  		FilterTreeNode newProperty = new Property (propertySegments);  		if ((inverse != null ? inverse.Text : default(string)) == "?")  			filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  		else {  			if ((not != null ? not.Text : default(string)) == "!")  				newProperty.ToggleInversed ();  			filterNode = newProperty;  		}  	}  	break;  case 4:  	DebugEnterAlt (4);  	// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  	{  		DebugLocation (116' 4);  		STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  		DebugLocation (117' 4);  		string stringText = (STRING7 != null ? STRING7.Text : default(string));  		stringText = stringText.Substring (1' stringText.Length - 2);  		filterNode = new Value (stringText);  	}  	break;  case 5:  	DebugEnterAlt (5);  	// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  	{  		DebugLocation (122' 4);  		REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  		DebugLocation (123' 4);  		string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  		regexText = regexText.Substring (1' regexText.Length - 2);  		filterNode = new RegExp (regexText);  	}  	break;  case 6:  	DebugEnterAlt (6);  	// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  	{  		DebugLocation (128' 4);  		NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  		DebugLocation (129' 4);  		filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  	}  	break;  case 7:  	DebugEnterAlt (7);  	// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  	{  		DebugLocation (132' 4);  		Match (input' TRUE' Follow._TRUE_in_filterExpr271);  		DebugLocation (133' 4);  		filterNode = new Value (true);  	}  	break;  case 8:  	DebugEnterAlt (8);  	// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  	{  		DebugLocation (136' 4);  		Match (input' FALSE' Follow._FALSE_in_filterExpr281);  		DebugLocation (137' 4);  		filterNode = new Value (false);  	}  	break;  case 9:  	DebugEnterAlt (9);  	// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  	{  		DebugLocation (140' 4);  		Match (input' NULL' Follow._NULL_in_filterExpr291);  		DebugLocation (141' 4);  		filterNode = new Value (null);  	}  	break;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: switch (alt9) {  case 1:  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  	{  		DebugLocation (64' 4);  		DebugLocation (64' 6);  		PushFollow (Follow._comparator_in_filterExpr175);  		comparator6 = comparator ();  		PopFollow ();  		Match (input' TokenTypes.Down' null);  		DebugLocation (64' 18);  		PushFollow (Follow._filterExpr_in_filterExpr179);  		a = filterExpr ();  		PopFollow ();  		DebugLocation (64' 31);  		PushFollow (Follow._filterExpr_in_filterExpr183);  		b = filterExpr ();  		PopFollow ();  		Match (input' TokenTypes.Up' null);  		DebugLocation (65' 4);  		Comparator newComparator;  		switch (comparator6) {  		case "=":  			newComparator = Comparator.Equals;  			break;  		case "!=":  			newComparator = Comparator.NotEquals;  			break;  		case ">":  			newComparator = Comparator.Greater;  			break;  		case "<":  			newComparator = Comparator.Less;  			break;  		case ">=":  			newComparator = Comparator.GreaterOrEqual;  			break;  		case "<=":  			newComparator = Comparator.LessOrEqual;  			break;  		case "&":  			newComparator = Comparator.And;  			break;  		case "|":  			newComparator = Comparator.Or;  			break;  		default:  			newComparator = Comparator.Equals;  			break;  		}  		filterNode = new BoolExpression (a' newComparator' b);  	}  	break;  case 2:  	DebugEnterAlt (2);  	// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  	{  		DebugLocation (98' 4);  		DebugLocation (98' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr195);  		Match (input' TokenTypes.Down' null);  		DebugLocation (98' 12);  		PushFollow (Follow._filterExpr_in_filterExpr199);  		f = filterExpr ();  		PopFollow ();  		DebugLocation (98' 31);  		// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  		int alt6 = 2;  		try {  			DebugEnterSubRule (6);  			try {  				DebugEnterDecision (6' false);  				int LA6_1 = input.LA (1);  				if ((LA6_1 == 24)) {  					alt6 = 1;  				}  			}  			finally {  				DebugExitDecision (6);  			}  			switch (alt6) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  				{  					DebugLocation (98' 31);  					inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (6);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (99' 4);  		FilterTreeNode newNode = f;  		if ((inverse != null ? inverse.Text : default(string)) == "!")  			newNode.ToggleInversed ();  		filterNode = newNode;  	}  	break;  case 3:  	DebugEnterAlt (3);  	// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  	{  		DebugLocation (105' 4);  		DebugLocation (105' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr216);  		Match (input' TokenTypes.Down' null);  		DebugLocation (105' 12);  		PushFollow (Follow._propertyChain_in_filterExpr219);  		propertyChain (propertySegments);  		PopFollow ();  		DebugLocation (105' 51);  		// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  		int alt7 = 2;  		try {  			DebugEnterSubRule (7);  			try {  				DebugEnterDecision (7' false);  				int LA7_1 = input.LA (1);  				if ((LA7_1 == 31)) {  					alt7 = 1;  				}  			}  			finally {  				DebugExitDecision (7);  			}  			switch (alt7) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  				{  					DebugLocation (105' 51);  					inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (7);  		}  		DebugLocation (105' 60);  		// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  		int alt8 = 2;  		try {  			DebugEnterSubRule (8);  			try {  				DebugEnterDecision (8' false);  				int LA8_1 = input.LA (1);  				if ((LA8_1 == 24)) {  					alt8 = 1;  				}  			}  			finally {  				DebugExitDecision (8);  			}  			switch (alt8) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  				{  					DebugLocation (105' 60);  					not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (8);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (106' 4);  		FilterTreeNode newProperty = new Property (propertySegments);  		if ((inverse != null ? inverse.Text : default(string)) == "?")  			filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  		else {  			if ((not != null ? not.Text : default(string)) == "!")  				newProperty.ToggleInversed ();  			filterNode = newProperty;  		}  	}  	break;  case 4:  	DebugEnterAlt (4);  	// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  	{  		DebugLocation (116' 4);  		STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  		DebugLocation (117' 4);  		string stringText = (STRING7 != null ? STRING7.Text : default(string));  		stringText = stringText.Substring (1' stringText.Length - 2);  		filterNode = new Value (stringText);  	}  	break;  case 5:  	DebugEnterAlt (5);  	// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  	{  		DebugLocation (122' 4);  		REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  		DebugLocation (123' 4);  		string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  		regexText = regexText.Substring (1' regexText.Length - 2);  		filterNode = new RegExp (regexText);  	}  	break;  case 6:  	DebugEnterAlt (6);  	// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  	{  		DebugLocation (128' 4);  		NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  		DebugLocation (129' 4);  		filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  	}  	break;  case 7:  	DebugEnterAlt (7);  	// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  	{  		DebugLocation (132' 4);  		Match (input' TRUE' Follow._TRUE_in_filterExpr271);  		DebugLocation (133' 4);  		filterNode = new Value (true);  	}  	break;  case 8:  	DebugEnterAlt (8);  	// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  	{  		DebugLocation (136' 4);  		Match (input' FALSE' Follow._FALSE_in_filterExpr281);  		DebugLocation (137' 4);  		filterNode = new Value (false);  	}  	break;  case 9:  	DebugEnterAlt (9);  	// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  	{  		DebugLocation (140' 4);  		Match (input' NULL' Follow._NULL_in_filterExpr291);  		DebugLocation (141' 4);  		filterNode = new Value (null);  	}  	break;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: switch (alt9) {  case 1:  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  	{  		DebugLocation (64' 4);  		DebugLocation (64' 6);  		PushFollow (Follow._comparator_in_filterExpr175);  		comparator6 = comparator ();  		PopFollow ();  		Match (input' TokenTypes.Down' null);  		DebugLocation (64' 18);  		PushFollow (Follow._filterExpr_in_filterExpr179);  		a = filterExpr ();  		PopFollow ();  		DebugLocation (64' 31);  		PushFollow (Follow._filterExpr_in_filterExpr183);  		b = filterExpr ();  		PopFollow ();  		Match (input' TokenTypes.Up' null);  		DebugLocation (65' 4);  		Comparator newComparator;  		switch (comparator6) {  		case "=":  			newComparator = Comparator.Equals;  			break;  		case "!=":  			newComparator = Comparator.NotEquals;  			break;  		case ">":  			newComparator = Comparator.Greater;  			break;  		case "<":  			newComparator = Comparator.Less;  			break;  		case ">=":  			newComparator = Comparator.GreaterOrEqual;  			break;  		case "<=":  			newComparator = Comparator.LessOrEqual;  			break;  		case "&":  			newComparator = Comparator.And;  			break;  		case "|":  			newComparator = Comparator.Or;  			break;  		default:  			newComparator = Comparator.Equals;  			break;  		}  		filterNode = new BoolExpression (a' newComparator' b);  	}  	break;  case 2:  	DebugEnterAlt (2);  	// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  	{  		DebugLocation (98' 4);  		DebugLocation (98' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr195);  		Match (input' TokenTypes.Down' null);  		DebugLocation (98' 12);  		PushFollow (Follow._filterExpr_in_filterExpr199);  		f = filterExpr ();  		PopFollow ();  		DebugLocation (98' 31);  		// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  		int alt6 = 2;  		try {  			DebugEnterSubRule (6);  			try {  				DebugEnterDecision (6' false);  				int LA6_1 = input.LA (1);  				if ((LA6_1 == 24)) {  					alt6 = 1;  				}  			}  			finally {  				DebugExitDecision (6);  			}  			switch (alt6) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  				{  					DebugLocation (98' 31);  					inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (6);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (99' 4);  		FilterTreeNode newNode = f;  		if ((inverse != null ? inverse.Text : default(string)) == "!")  			newNode.ToggleInversed ();  		filterNode = newNode;  	}  	break;  case 3:  	DebugEnterAlt (3);  	// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  	{  		DebugLocation (105' 4);  		DebugLocation (105' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr216);  		Match (input' TokenTypes.Down' null);  		DebugLocation (105' 12);  		PushFollow (Follow._propertyChain_in_filterExpr219);  		propertyChain (propertySegments);  		PopFollow ();  		DebugLocation (105' 51);  		// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  		int alt7 = 2;  		try {  			DebugEnterSubRule (7);  			try {  				DebugEnterDecision (7' false);  				int LA7_1 = input.LA (1);  				if ((LA7_1 == 31)) {  					alt7 = 1;  				}  			}  			finally {  				DebugExitDecision (7);  			}  			switch (alt7) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  				{  					DebugLocation (105' 51);  					inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (7);  		}  		DebugLocation (105' 60);  		// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  		int alt8 = 2;  		try {  			DebugEnterSubRule (8);  			try {  				DebugEnterDecision (8' false);  				int LA8_1 = input.LA (1);  				if ((LA8_1 == 24)) {  					alt8 = 1;  				}  			}  			finally {  				DebugExitDecision (8);  			}  			switch (alt8) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  				{  					DebugLocation (105' 60);  					not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (8);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (106' 4);  		FilterTreeNode newProperty = new Property (propertySegments);  		if ((inverse != null ? inverse.Text : default(string)) == "?")  			filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  		else {  			if ((not != null ? not.Text : default(string)) == "!")  				newProperty.ToggleInversed ();  			filterNode = newProperty;  		}  	}  	break;  case 4:  	DebugEnterAlt (4);  	// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  	{  		DebugLocation (116' 4);  		STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  		DebugLocation (117' 4);  		string stringText = (STRING7 != null ? STRING7.Text : default(string));  		stringText = stringText.Substring (1' stringText.Length - 2);  		filterNode = new Value (stringText);  	}  	break;  case 5:  	DebugEnterAlt (5);  	// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  	{  		DebugLocation (122' 4);  		REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  		DebugLocation (123' 4);  		string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  		regexText = regexText.Substring (1' regexText.Length - 2);  		filterNode = new RegExp (regexText);  	}  	break;  case 6:  	DebugEnterAlt (6);  	// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  	{  		DebugLocation (128' 4);  		NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  		DebugLocation (129' 4);  		filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  	}  	break;  case 7:  	DebugEnterAlt (7);  	// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  	{  		DebugLocation (132' 4);  		Match (input' TRUE' Follow._TRUE_in_filterExpr271);  		DebugLocation (133' 4);  		filterNode = new Value (true);  	}  	break;  case 8:  	DebugEnterAlt (8);  	// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  	{  		DebugLocation (136' 4);  		Match (input' FALSE' Follow._FALSE_in_filterExpr281);  		DebugLocation (137' 4);  		filterNode = new Value (false);  	}  	break;  case 9:  	DebugEnterAlt (9);  	// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  	{  		DebugLocation (140' 4);  		Match (input' NULL' Follow._NULL_in_filterExpr291);  		DebugLocation (141' 4);  		filterNode = new Value (null);  	}  	break;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: switch (alt9) {  case 1:  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  	{  		DebugLocation (64' 4);  		DebugLocation (64' 6);  		PushFollow (Follow._comparator_in_filterExpr175);  		comparator6 = comparator ();  		PopFollow ();  		Match (input' TokenTypes.Down' null);  		DebugLocation (64' 18);  		PushFollow (Follow._filterExpr_in_filterExpr179);  		a = filterExpr ();  		PopFollow ();  		DebugLocation (64' 31);  		PushFollow (Follow._filterExpr_in_filterExpr183);  		b = filterExpr ();  		PopFollow ();  		Match (input' TokenTypes.Up' null);  		DebugLocation (65' 4);  		Comparator newComparator;  		switch (comparator6) {  		case "=":  			newComparator = Comparator.Equals;  			break;  		case "!=":  			newComparator = Comparator.NotEquals;  			break;  		case ">":  			newComparator = Comparator.Greater;  			break;  		case "<":  			newComparator = Comparator.Less;  			break;  		case ">=":  			newComparator = Comparator.GreaterOrEqual;  			break;  		case "<=":  			newComparator = Comparator.LessOrEqual;  			break;  		case "&":  			newComparator = Comparator.And;  			break;  		case "|":  			newComparator = Comparator.Or;  			break;  		default:  			newComparator = Comparator.Equals;  			break;  		}  		filterNode = new BoolExpression (a' newComparator' b);  	}  	break;  case 2:  	DebugEnterAlt (2);  	// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  	{  		DebugLocation (98' 4);  		DebugLocation (98' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr195);  		Match (input' TokenTypes.Down' null);  		DebugLocation (98' 12);  		PushFollow (Follow._filterExpr_in_filterExpr199);  		f = filterExpr ();  		PopFollow ();  		DebugLocation (98' 31);  		// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  		int alt6 = 2;  		try {  			DebugEnterSubRule (6);  			try {  				DebugEnterDecision (6' false);  				int LA6_1 = input.LA (1);  				if ((LA6_1 == 24)) {  					alt6 = 1;  				}  			}  			finally {  				DebugExitDecision (6);  			}  			switch (alt6) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  				{  					DebugLocation (98' 31);  					inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (6);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (99' 4);  		FilterTreeNode newNode = f;  		if ((inverse != null ? inverse.Text : default(string)) == "!")  			newNode.ToggleInversed ();  		filterNode = newNode;  	}  	break;  case 3:  	DebugEnterAlt (3);  	// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  	{  		DebugLocation (105' 4);  		DebugLocation (105' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr216);  		Match (input' TokenTypes.Down' null);  		DebugLocation (105' 12);  		PushFollow (Follow._propertyChain_in_filterExpr219);  		propertyChain (propertySegments);  		PopFollow ();  		DebugLocation (105' 51);  		// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  		int alt7 = 2;  		try {  			DebugEnterSubRule (7);  			try {  				DebugEnterDecision (7' false);  				int LA7_1 = input.LA (1);  				if ((LA7_1 == 31)) {  					alt7 = 1;  				}  			}  			finally {  				DebugExitDecision (7);  			}  			switch (alt7) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  				{  					DebugLocation (105' 51);  					inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (7);  		}  		DebugLocation (105' 60);  		// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  		int alt8 = 2;  		try {  			DebugEnterSubRule (8);  			try {  				DebugEnterDecision (8' false);  				int LA8_1 = input.LA (1);  				if ((LA8_1 == 24)) {  					alt8 = 1;  				}  			}  			finally {  				DebugExitDecision (8);  			}  			switch (alt8) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  				{  					DebugLocation (105' 60);  					not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (8);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (106' 4);  		FilterTreeNode newProperty = new Property (propertySegments);  		if ((inverse != null ? inverse.Text : default(string)) == "?")  			filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  		else {  			if ((not != null ? not.Text : default(string)) == "!")  				newProperty.ToggleInversed ();  			filterNode = newProperty;  		}  	}  	break;  case 4:  	DebugEnterAlt (4);  	// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  	{  		DebugLocation (116' 4);  		STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  		DebugLocation (117' 4);  		string stringText = (STRING7 != null ? STRING7.Text : default(string));  		stringText = stringText.Substring (1' stringText.Length - 2);  		filterNode = new Value (stringText);  	}  	break;  case 5:  	DebugEnterAlt (5);  	// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  	{  		DebugLocation (122' 4);  		REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  		DebugLocation (123' 4);  		string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  		regexText = regexText.Substring (1' regexText.Length - 2);  		filterNode = new RegExp (regexText);  	}  	break;  case 6:  	DebugEnterAlt (6);  	// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  	{  		DebugLocation (128' 4);  		NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  		DebugLocation (129' 4);  		filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  	}  	break;  case 7:  	DebugEnterAlt (7);  	// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  	{  		DebugLocation (132' 4);  		Match (input' TRUE' Follow._TRUE_in_filterExpr271);  		DebugLocation (133' 4);  		filterNode = new Value (true);  	}  	break;  case 8:  	DebugEnterAlt (8);  	// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  	{  		DebugLocation (136' 4);  		Match (input' FALSE' Follow._FALSE_in_filterExpr281);  		DebugLocation (137' 4);  		filterNode = new Value (false);  	}  	break;  case 9:  	DebugEnterAlt (9);  	// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  	{  		DebugLocation (140' 4);  		Match (input' NULL' Follow._NULL_in_filterExpr291);  		DebugLocation (141' 4);  		filterNode = new Value (null);  	}  	break;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: switch (alt9) {  case 1:  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  	{  		DebugLocation (64' 4);  		DebugLocation (64' 6);  		PushFollow (Follow._comparator_in_filterExpr175);  		comparator6 = comparator ();  		PopFollow ();  		Match (input' TokenTypes.Down' null);  		DebugLocation (64' 18);  		PushFollow (Follow._filterExpr_in_filterExpr179);  		a = filterExpr ();  		PopFollow ();  		DebugLocation (64' 31);  		PushFollow (Follow._filterExpr_in_filterExpr183);  		b = filterExpr ();  		PopFollow ();  		Match (input' TokenTypes.Up' null);  		DebugLocation (65' 4);  		Comparator newComparator;  		switch (comparator6) {  		case "=":  			newComparator = Comparator.Equals;  			break;  		case "!=":  			newComparator = Comparator.NotEquals;  			break;  		case ">":  			newComparator = Comparator.Greater;  			break;  		case "<":  			newComparator = Comparator.Less;  			break;  		case ">=":  			newComparator = Comparator.GreaterOrEqual;  			break;  		case "<=":  			newComparator = Comparator.LessOrEqual;  			break;  		case "&":  			newComparator = Comparator.And;  			break;  		case "|":  			newComparator = Comparator.Or;  			break;  		default:  			newComparator = Comparator.Equals;  			break;  		}  		filterNode = new BoolExpression (a' newComparator' b);  	}  	break;  case 2:  	DebugEnterAlt (2);  	// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  	{  		DebugLocation (98' 4);  		DebugLocation (98' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr195);  		Match (input' TokenTypes.Down' null);  		DebugLocation (98' 12);  		PushFollow (Follow._filterExpr_in_filterExpr199);  		f = filterExpr ();  		PopFollow ();  		DebugLocation (98' 31);  		// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  		int alt6 = 2;  		try {  			DebugEnterSubRule (6);  			try {  				DebugEnterDecision (6' false);  				int LA6_1 = input.LA (1);  				if ((LA6_1 == 24)) {  					alt6 = 1;  				}  			}  			finally {  				DebugExitDecision (6);  			}  			switch (alt6) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  				{  					DebugLocation (98' 31);  					inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (6);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (99' 4);  		FilterTreeNode newNode = f;  		if ((inverse != null ? inverse.Text : default(string)) == "!")  			newNode.ToggleInversed ();  		filterNode = newNode;  	}  	break;  case 3:  	DebugEnterAlt (3);  	// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  	{  		DebugLocation (105' 4);  		DebugLocation (105' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr216);  		Match (input' TokenTypes.Down' null);  		DebugLocation (105' 12);  		PushFollow (Follow._propertyChain_in_filterExpr219);  		propertyChain (propertySegments);  		PopFollow ();  		DebugLocation (105' 51);  		// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  		int alt7 = 2;  		try {  			DebugEnterSubRule (7);  			try {  				DebugEnterDecision (7' false);  				int LA7_1 = input.LA (1);  				if ((LA7_1 == 31)) {  					alt7 = 1;  				}  			}  			finally {  				DebugExitDecision (7);  			}  			switch (alt7) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  				{  					DebugLocation (105' 51);  					inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (7);  		}  		DebugLocation (105' 60);  		// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  		int alt8 = 2;  		try {  			DebugEnterSubRule (8);  			try {  				DebugEnterDecision (8' false);  				int LA8_1 = input.LA (1);  				if ((LA8_1 == 24)) {  					alt8 = 1;  				}  			}  			finally {  				DebugExitDecision (8);  			}  			switch (alt8) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  				{  					DebugLocation (105' 60);  					not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (8);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (106' 4);  		FilterTreeNode newProperty = new Property (propertySegments);  		if ((inverse != null ? inverse.Text : default(string)) == "?")  			filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  		else {  			if ((not != null ? not.Text : default(string)) == "!")  				newProperty.ToggleInversed ();  			filterNode = newProperty;  		}  	}  	break;  case 4:  	DebugEnterAlt (4);  	// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  	{  		DebugLocation (116' 4);  		STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  		DebugLocation (117' 4);  		string stringText = (STRING7 != null ? STRING7.Text : default(string));  		stringText = stringText.Substring (1' stringText.Length - 2);  		filterNode = new Value (stringText);  	}  	break;  case 5:  	DebugEnterAlt (5);  	// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  	{  		DebugLocation (122' 4);  		REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  		DebugLocation (123' 4);  		string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  		regexText = regexText.Substring (1' regexText.Length - 2);  		filterNode = new RegExp (regexText);  	}  	break;  case 6:  	DebugEnterAlt (6);  	// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  	{  		DebugLocation (128' 4);  		NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  		DebugLocation (129' 4);  		filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  	}  	break;  case 7:  	DebugEnterAlt (7);  	// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  	{  		DebugLocation (132' 4);  		Match (input' TRUE' Follow._TRUE_in_filterExpr271);  		DebugLocation (133' 4);  		filterNode = new Value (true);  	}  	break;  case 8:  	DebugEnterAlt (8);  	// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  	{  		DebugLocation (136' 4);  		Match (input' FALSE' Follow._FALSE_in_filterExpr281);  		DebugLocation (137' 4);  		filterNode = new Value (false);  	}  	break;  case 9:  	DebugEnterAlt (9);  	// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  	{  		DebugLocation (140' 4);  		Match (input' NULL' Follow._NULL_in_filterExpr291);  		DebugLocation (141' 4);  		filterNode = new Value (null);  	}  	break;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: switch (alt9) {  case 1:  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  	{  		DebugLocation (64' 4);  		DebugLocation (64' 6);  		PushFollow (Follow._comparator_in_filterExpr175);  		comparator6 = comparator ();  		PopFollow ();  		Match (input' TokenTypes.Down' null);  		DebugLocation (64' 18);  		PushFollow (Follow._filterExpr_in_filterExpr179);  		a = filterExpr ();  		PopFollow ();  		DebugLocation (64' 31);  		PushFollow (Follow._filterExpr_in_filterExpr183);  		b = filterExpr ();  		PopFollow ();  		Match (input' TokenTypes.Up' null);  		DebugLocation (65' 4);  		Comparator newComparator;  		switch (comparator6) {  		case "=":  			newComparator = Comparator.Equals;  			break;  		case "!=":  			newComparator = Comparator.NotEquals;  			break;  		case ">":  			newComparator = Comparator.Greater;  			break;  		case "<":  			newComparator = Comparator.Less;  			break;  		case ">=":  			newComparator = Comparator.GreaterOrEqual;  			break;  		case "<=":  			newComparator = Comparator.LessOrEqual;  			break;  		case "&":  			newComparator = Comparator.And;  			break;  		case "|":  			newComparator = Comparator.Or;  			break;  		default:  			newComparator = Comparator.Equals;  			break;  		}  		filterNode = new BoolExpression (a' newComparator' b);  	}  	break;  case 2:  	DebugEnterAlt (2);  	// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  	{  		DebugLocation (98' 4);  		DebugLocation (98' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr195);  		Match (input' TokenTypes.Down' null);  		DebugLocation (98' 12);  		PushFollow (Follow._filterExpr_in_filterExpr199);  		f = filterExpr ();  		PopFollow ();  		DebugLocation (98' 31);  		// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  		int alt6 = 2;  		try {  			DebugEnterSubRule (6);  			try {  				DebugEnterDecision (6' false);  				int LA6_1 = input.LA (1);  				if ((LA6_1 == 24)) {  					alt6 = 1;  				}  			}  			finally {  				DebugExitDecision (6);  			}  			switch (alt6) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  				{  					DebugLocation (98' 31);  					inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (6);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (99' 4);  		FilterTreeNode newNode = f;  		if ((inverse != null ? inverse.Text : default(string)) == "!")  			newNode.ToggleInversed ();  		filterNode = newNode;  	}  	break;  case 3:  	DebugEnterAlt (3);  	// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  	{  		DebugLocation (105' 4);  		DebugLocation (105' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr216);  		Match (input' TokenTypes.Down' null);  		DebugLocation (105' 12);  		PushFollow (Follow._propertyChain_in_filterExpr219);  		propertyChain (propertySegments);  		PopFollow ();  		DebugLocation (105' 51);  		// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  		int alt7 = 2;  		try {  			DebugEnterSubRule (7);  			try {  				DebugEnterDecision (7' false);  				int LA7_1 = input.LA (1);  				if ((LA7_1 == 31)) {  					alt7 = 1;  				}  			}  			finally {  				DebugExitDecision (7);  			}  			switch (alt7) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  				{  					DebugLocation (105' 51);  					inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (7);  		}  		DebugLocation (105' 60);  		// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  		int alt8 = 2;  		try {  			DebugEnterSubRule (8);  			try {  				DebugEnterDecision (8' false);  				int LA8_1 = input.LA (1);  				if ((LA8_1 == 24)) {  					alt8 = 1;  				}  			}  			finally {  				DebugExitDecision (8);  			}  			switch (alt8) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  				{  					DebugLocation (105' 60);  					not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (8);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (106' 4);  		FilterTreeNode newProperty = new Property (propertySegments);  		if ((inverse != null ? inverse.Text : default(string)) == "?")  			filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  		else {  			if ((not != null ? not.Text : default(string)) == "!")  				newProperty.ToggleInversed ();  			filterNode = newProperty;  		}  	}  	break;  case 4:  	DebugEnterAlt (4);  	// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  	{  		DebugLocation (116' 4);  		STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  		DebugLocation (117' 4);  		string stringText = (STRING7 != null ? STRING7.Text : default(string));  		stringText = stringText.Substring (1' stringText.Length - 2);  		filterNode = new Value (stringText);  	}  	break;  case 5:  	DebugEnterAlt (5);  	// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  	{  		DebugLocation (122' 4);  		REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  		DebugLocation (123' 4);  		string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  		regexText = regexText.Substring (1' regexText.Length - 2);  		filterNode = new RegExp (regexText);  	}  	break;  case 6:  	DebugEnterAlt (6);  	// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  	{  		DebugLocation (128' 4);  		NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  		DebugLocation (129' 4);  		filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  	}  	break;  case 7:  	DebugEnterAlt (7);  	// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  	{  		DebugLocation (132' 4);  		Match (input' TRUE' Follow._TRUE_in_filterExpr271);  		DebugLocation (133' 4);  		filterNode = new Value (true);  	}  	break;  case 8:  	DebugEnterAlt (8);  	// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  	{  		DebugLocation (136' 4);  		Match (input' FALSE' Follow._FALSE_in_filterExpr281);  		DebugLocation (137' 4);  		filterNode = new Value (false);  	}  	break;  case 9:  	DebugEnterAlt (9);  	// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  	{  		DebugLocation (140' 4);  		Match (input' NULL' Follow._NULL_in_filterExpr291);  		DebugLocation (141' 4);  		filterNode = new Value (null);  	}  	break;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: switch (alt9) {  case 1:  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  	{  		DebugLocation (64' 4);  		DebugLocation (64' 6);  		PushFollow (Follow._comparator_in_filterExpr175);  		comparator6 = comparator ();  		PopFollow ();  		Match (input' TokenTypes.Down' null);  		DebugLocation (64' 18);  		PushFollow (Follow._filterExpr_in_filterExpr179);  		a = filterExpr ();  		PopFollow ();  		DebugLocation (64' 31);  		PushFollow (Follow._filterExpr_in_filterExpr183);  		b = filterExpr ();  		PopFollow ();  		Match (input' TokenTypes.Up' null);  		DebugLocation (65' 4);  		Comparator newComparator;  		switch (comparator6) {  		case "=":  			newComparator = Comparator.Equals;  			break;  		case "!=":  			newComparator = Comparator.NotEquals;  			break;  		case ">":  			newComparator = Comparator.Greater;  			break;  		case "<":  			newComparator = Comparator.Less;  			break;  		case ">=":  			newComparator = Comparator.GreaterOrEqual;  			break;  		case "<=":  			newComparator = Comparator.LessOrEqual;  			break;  		case "&":  			newComparator = Comparator.And;  			break;  		case "|":  			newComparator = Comparator.Or;  			break;  		default:  			newComparator = Comparator.Equals;  			break;  		}  		filterNode = new BoolExpression (a' newComparator' b);  	}  	break;  case 2:  	DebugEnterAlt (2);  	// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  	{  		DebugLocation (98' 4);  		DebugLocation (98' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr195);  		Match (input' TokenTypes.Down' null);  		DebugLocation (98' 12);  		PushFollow (Follow._filterExpr_in_filterExpr199);  		f = filterExpr ();  		PopFollow ();  		DebugLocation (98' 31);  		// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  		int alt6 = 2;  		try {  			DebugEnterSubRule (6);  			try {  				DebugEnterDecision (6' false);  				int LA6_1 = input.LA (1);  				if ((LA6_1 == 24)) {  					alt6 = 1;  				}  			}  			finally {  				DebugExitDecision (6);  			}  			switch (alt6) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  				{  					DebugLocation (98' 31);  					inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (6);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (99' 4);  		FilterTreeNode newNode = f;  		if ((inverse != null ? inverse.Text : default(string)) == "!")  			newNode.ToggleInversed ();  		filterNode = newNode;  	}  	break;  case 3:  	DebugEnterAlt (3);  	// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  	{  		DebugLocation (105' 4);  		DebugLocation (105' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr216);  		Match (input' TokenTypes.Down' null);  		DebugLocation (105' 12);  		PushFollow (Follow._propertyChain_in_filterExpr219);  		propertyChain (propertySegments);  		PopFollow ();  		DebugLocation (105' 51);  		// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  		int alt7 = 2;  		try {  			DebugEnterSubRule (7);  			try {  				DebugEnterDecision (7' false);  				int LA7_1 = input.LA (1);  				if ((LA7_1 == 31)) {  					alt7 = 1;  				}  			}  			finally {  				DebugExitDecision (7);  			}  			switch (alt7) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  				{  					DebugLocation (105' 51);  					inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (7);  		}  		DebugLocation (105' 60);  		// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  		int alt8 = 2;  		try {  			DebugEnterSubRule (8);  			try {  				DebugEnterDecision (8' false);  				int LA8_1 = input.LA (1);  				if ((LA8_1 == 24)) {  					alt8 = 1;  				}  			}  			finally {  				DebugExitDecision (8);  			}  			switch (alt8) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  				{  					DebugLocation (105' 60);  					not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (8);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (106' 4);  		FilterTreeNode newProperty = new Property (propertySegments);  		if ((inverse != null ? inverse.Text : default(string)) == "?")  			filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  		else {  			if ((not != null ? not.Text : default(string)) == "!")  				newProperty.ToggleInversed ();  			filterNode = newProperty;  		}  	}  	break;  case 4:  	DebugEnterAlt (4);  	// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  	{  		DebugLocation (116' 4);  		STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  		DebugLocation (117' 4);  		string stringText = (STRING7 != null ? STRING7.Text : default(string));  		stringText = stringText.Substring (1' stringText.Length - 2);  		filterNode = new Value (stringText);  	}  	break;  case 5:  	DebugEnterAlt (5);  	// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  	{  		DebugLocation (122' 4);  		REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  		DebugLocation (123' 4);  		string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  		regexText = regexText.Substring (1' regexText.Length - 2);  		filterNode = new RegExp (regexText);  	}  	break;  case 6:  	DebugEnterAlt (6);  	// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  	{  		DebugLocation (128' 4);  		NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  		DebugLocation (129' 4);  		filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  	}  	break;  case 7:  	DebugEnterAlt (7);  	// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  	{  		DebugLocation (132' 4);  		Match (input' TRUE' Follow._TRUE_in_filterExpr271);  		DebugLocation (133' 4);  		filterNode = new Value (true);  	}  	break;  case 8:  	DebugEnterAlt (8);  	// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  	{  		DebugLocation (136' 4);  		Match (input' FALSE' Follow._FALSE_in_filterExpr281);  		DebugLocation (137' 4);  		filterNode = new Value (false);  	}  	break;  case 9:  	DebugEnterAlt (9);  	// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  	{  		DebugLocation (140' 4);  		Match (input' NULL' Follow._NULL_in_filterExpr291);  		DebugLocation (141' 4);  		filterNode = new Value (null);  	}  	break;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: switch (alt9) {  case 1:  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  	{  		DebugLocation (64' 4);  		DebugLocation (64' 6);  		PushFollow (Follow._comparator_in_filterExpr175);  		comparator6 = comparator ();  		PopFollow ();  		Match (input' TokenTypes.Down' null);  		DebugLocation (64' 18);  		PushFollow (Follow._filterExpr_in_filterExpr179);  		a = filterExpr ();  		PopFollow ();  		DebugLocation (64' 31);  		PushFollow (Follow._filterExpr_in_filterExpr183);  		b = filterExpr ();  		PopFollow ();  		Match (input' TokenTypes.Up' null);  		DebugLocation (65' 4);  		Comparator newComparator;  		switch (comparator6) {  		case "=":  			newComparator = Comparator.Equals;  			break;  		case "!=":  			newComparator = Comparator.NotEquals;  			break;  		case ">":  			newComparator = Comparator.Greater;  			break;  		case "<":  			newComparator = Comparator.Less;  			break;  		case ">=":  			newComparator = Comparator.GreaterOrEqual;  			break;  		case "<=":  			newComparator = Comparator.LessOrEqual;  			break;  		case "&":  			newComparator = Comparator.And;  			break;  		case "|":  			newComparator = Comparator.Or;  			break;  		default:  			newComparator = Comparator.Equals;  			break;  		}  		filterNode = new BoolExpression (a' newComparator' b);  	}  	break;  case 2:  	DebugEnterAlt (2);  	// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  	{  		DebugLocation (98' 4);  		DebugLocation (98' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr195);  		Match (input' TokenTypes.Down' null);  		DebugLocation (98' 12);  		PushFollow (Follow._filterExpr_in_filterExpr199);  		f = filterExpr ();  		PopFollow ();  		DebugLocation (98' 31);  		// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  		int alt6 = 2;  		try {  			DebugEnterSubRule (6);  			try {  				DebugEnterDecision (6' false);  				int LA6_1 = input.LA (1);  				if ((LA6_1 == 24)) {  					alt6 = 1;  				}  			}  			finally {  				DebugExitDecision (6);  			}  			switch (alt6) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  				{  					DebugLocation (98' 31);  					inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (6);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (99' 4);  		FilterTreeNode newNode = f;  		if ((inverse != null ? inverse.Text : default(string)) == "!")  			newNode.ToggleInversed ();  		filterNode = newNode;  	}  	break;  case 3:  	DebugEnterAlt (3);  	// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  	{  		DebugLocation (105' 4);  		DebugLocation (105' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr216);  		Match (input' TokenTypes.Down' null);  		DebugLocation (105' 12);  		PushFollow (Follow._propertyChain_in_filterExpr219);  		propertyChain (propertySegments);  		PopFollow ();  		DebugLocation (105' 51);  		// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  		int alt7 = 2;  		try {  			DebugEnterSubRule (7);  			try {  				DebugEnterDecision (7' false);  				int LA7_1 = input.LA (1);  				if ((LA7_1 == 31)) {  					alt7 = 1;  				}  			}  			finally {  				DebugExitDecision (7);  			}  			switch (alt7) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  				{  					DebugLocation (105' 51);  					inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (7);  		}  		DebugLocation (105' 60);  		// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  		int alt8 = 2;  		try {  			DebugEnterSubRule (8);  			try {  				DebugEnterDecision (8' false);  				int LA8_1 = input.LA (1);  				if ((LA8_1 == 24)) {  					alt8 = 1;  				}  			}  			finally {  				DebugExitDecision (8);  			}  			switch (alt8) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  				{  					DebugLocation (105' 60);  					not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (8);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (106' 4);  		FilterTreeNode newProperty = new Property (propertySegments);  		if ((inverse != null ? inverse.Text : default(string)) == "?")  			filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  		else {  			if ((not != null ? not.Text : default(string)) == "!")  				newProperty.ToggleInversed ();  			filterNode = newProperty;  		}  	}  	break;  case 4:  	DebugEnterAlt (4);  	// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  	{  		DebugLocation (116' 4);  		STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  		DebugLocation (117' 4);  		string stringText = (STRING7 != null ? STRING7.Text : default(string));  		stringText = stringText.Substring (1' stringText.Length - 2);  		filterNode = new Value (stringText);  	}  	break;  case 5:  	DebugEnterAlt (5);  	// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  	{  		DebugLocation (122' 4);  		REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  		DebugLocation (123' 4);  		string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  		regexText = regexText.Substring (1' regexText.Length - 2);  		filterNode = new RegExp (regexText);  	}  	break;  case 6:  	DebugEnterAlt (6);  	// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  	{  		DebugLocation (128' 4);  		NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  		DebugLocation (129' 4);  		filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  	}  	break;  case 7:  	DebugEnterAlt (7);  	// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  	{  		DebugLocation (132' 4);  		Match (input' TRUE' Follow._TRUE_in_filterExpr271);  		DebugLocation (133' 4);  		filterNode = new Value (true);  	}  	break;  case 8:  	DebugEnterAlt (8);  	// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  	{  		DebugLocation (136' 4);  		Match (input' FALSE' Follow._FALSE_in_filterExpr281);  		DebugLocation (137' 4);  		filterNode = new Value (false);  	}  	break;  case 9:  	DebugEnterAlt (9);  	// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  	{  		DebugLocation (140' 4);  		Match (input' NULL' Follow._NULL_in_filterExpr291);  		DebugLocation (141' 4);  		filterNode = new Value (null);  	}  	break;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: switch (alt9) {  case 1:  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  	{  		DebugLocation (64' 4);  		DebugLocation (64' 6);  		PushFollow (Follow._comparator_in_filterExpr175);  		comparator6 = comparator ();  		PopFollow ();  		Match (input' TokenTypes.Down' null);  		DebugLocation (64' 18);  		PushFollow (Follow._filterExpr_in_filterExpr179);  		a = filterExpr ();  		PopFollow ();  		DebugLocation (64' 31);  		PushFollow (Follow._filterExpr_in_filterExpr183);  		b = filterExpr ();  		PopFollow ();  		Match (input' TokenTypes.Up' null);  		DebugLocation (65' 4);  		Comparator newComparator;  		switch (comparator6) {  		case "=":  			newComparator = Comparator.Equals;  			break;  		case "!=":  			newComparator = Comparator.NotEquals;  			break;  		case ">":  			newComparator = Comparator.Greater;  			break;  		case "<":  			newComparator = Comparator.Less;  			break;  		case ">=":  			newComparator = Comparator.GreaterOrEqual;  			break;  		case "<=":  			newComparator = Comparator.LessOrEqual;  			break;  		case "&":  			newComparator = Comparator.And;  			break;  		case "|":  			newComparator = Comparator.Or;  			break;  		default:  			newComparator = Comparator.Equals;  			break;  		}  		filterNode = new BoolExpression (a' newComparator' b);  	}  	break;  case 2:  	DebugEnterAlt (2);  	// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  	{  		DebugLocation (98' 4);  		DebugLocation (98' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr195);  		Match (input' TokenTypes.Down' null);  		DebugLocation (98' 12);  		PushFollow (Follow._filterExpr_in_filterExpr199);  		f = filterExpr ();  		PopFollow ();  		DebugLocation (98' 31);  		// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  		int alt6 = 2;  		try {  			DebugEnterSubRule (6);  			try {  				DebugEnterDecision (6' false);  				int LA6_1 = input.LA (1);  				if ((LA6_1 == 24)) {  					alt6 = 1;  				}  			}  			finally {  				DebugExitDecision (6);  			}  			switch (alt6) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  				{  					DebugLocation (98' 31);  					inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (6);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (99' 4);  		FilterTreeNode newNode = f;  		if ((inverse != null ? inverse.Text : default(string)) == "!")  			newNode.ToggleInversed ();  		filterNode = newNode;  	}  	break;  case 3:  	DebugEnterAlt (3);  	// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  	{  		DebugLocation (105' 4);  		DebugLocation (105' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr216);  		Match (input' TokenTypes.Down' null);  		DebugLocation (105' 12);  		PushFollow (Follow._propertyChain_in_filterExpr219);  		propertyChain (propertySegments);  		PopFollow ();  		DebugLocation (105' 51);  		// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  		int alt7 = 2;  		try {  			DebugEnterSubRule (7);  			try {  				DebugEnterDecision (7' false);  				int LA7_1 = input.LA (1);  				if ((LA7_1 == 31)) {  					alt7 = 1;  				}  			}  			finally {  				DebugExitDecision (7);  			}  			switch (alt7) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  				{  					DebugLocation (105' 51);  					inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (7);  		}  		DebugLocation (105' 60);  		// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  		int alt8 = 2;  		try {  			DebugEnterSubRule (8);  			try {  				DebugEnterDecision (8' false);  				int LA8_1 = input.LA (1);  				if ((LA8_1 == 24)) {  					alt8 = 1;  				}  			}  			finally {  				DebugExitDecision (8);  			}  			switch (alt8) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  				{  					DebugLocation (105' 60);  					not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (8);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (106' 4);  		FilterTreeNode newProperty = new Property (propertySegments);  		if ((inverse != null ? inverse.Text : default(string)) == "?")  			filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  		else {  			if ((not != null ? not.Text : default(string)) == "!")  				newProperty.ToggleInversed ();  			filterNode = newProperty;  		}  	}  	break;  case 4:  	DebugEnterAlt (4);  	// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  	{  		DebugLocation (116' 4);  		STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  		DebugLocation (117' 4);  		string stringText = (STRING7 != null ? STRING7.Text : default(string));  		stringText = stringText.Substring (1' stringText.Length - 2);  		filterNode = new Value (stringText);  	}  	break;  case 5:  	DebugEnterAlt (5);  	// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  	{  		DebugLocation (122' 4);  		REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  		DebugLocation (123' 4);  		string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  		regexText = regexText.Substring (1' regexText.Length - 2);  		filterNode = new RegExp (regexText);  	}  	break;  case 6:  	DebugEnterAlt (6);  	// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  	{  		DebugLocation (128' 4);  		NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  		DebugLocation (129' 4);  		filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  	}  	break;  case 7:  	DebugEnterAlt (7);  	// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  	{  		DebugLocation (132' 4);  		Match (input' TRUE' Follow._TRUE_in_filterExpr271);  		DebugLocation (133' 4);  		filterNode = new Value (true);  	}  	break;  case 8:  	DebugEnterAlt (8);  	// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  	{  		DebugLocation (136' 4);  		Match (input' FALSE' Follow._FALSE_in_filterExpr281);  		DebugLocation (137' 4);  		filterNode = new Value (false);  	}  	break;  case 9:  	DebugEnterAlt (9);  	// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  	{  		DebugLocation (140' 4);  		Match (input' NULL' Follow._NULL_in_filterExpr291);  		DebugLocation (141' 4);  		filterNode = new Value (null);  	}  	break;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: switch (alt9) {  case 1:  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  	{  		DebugLocation (64' 4);  		DebugLocation (64' 6);  		PushFollow (Follow._comparator_in_filterExpr175);  		comparator6 = comparator ();  		PopFollow ();  		Match (input' TokenTypes.Down' null);  		DebugLocation (64' 18);  		PushFollow (Follow._filterExpr_in_filterExpr179);  		a = filterExpr ();  		PopFollow ();  		DebugLocation (64' 31);  		PushFollow (Follow._filterExpr_in_filterExpr183);  		b = filterExpr ();  		PopFollow ();  		Match (input' TokenTypes.Up' null);  		DebugLocation (65' 4);  		Comparator newComparator;  		switch (comparator6) {  		case "=":  			newComparator = Comparator.Equals;  			break;  		case "!=":  			newComparator = Comparator.NotEquals;  			break;  		case ">":  			newComparator = Comparator.Greater;  			break;  		case "<":  			newComparator = Comparator.Less;  			break;  		case ">=":  			newComparator = Comparator.GreaterOrEqual;  			break;  		case "<=":  			newComparator = Comparator.LessOrEqual;  			break;  		case "&":  			newComparator = Comparator.And;  			break;  		case "|":  			newComparator = Comparator.Or;  			break;  		default:  			newComparator = Comparator.Equals;  			break;  		}  		filterNode = new BoolExpression (a' newComparator' b);  	}  	break;  case 2:  	DebugEnterAlt (2);  	// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  	{  		DebugLocation (98' 4);  		DebugLocation (98' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr195);  		Match (input' TokenTypes.Down' null);  		DebugLocation (98' 12);  		PushFollow (Follow._filterExpr_in_filterExpr199);  		f = filterExpr ();  		PopFollow ();  		DebugLocation (98' 31);  		// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  		int alt6 = 2;  		try {  			DebugEnterSubRule (6);  			try {  				DebugEnterDecision (6' false);  				int LA6_1 = input.LA (1);  				if ((LA6_1 == 24)) {  					alt6 = 1;  				}  			}  			finally {  				DebugExitDecision (6);  			}  			switch (alt6) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  				{  					DebugLocation (98' 31);  					inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (6);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (99' 4);  		FilterTreeNode newNode = f;  		if ((inverse != null ? inverse.Text : default(string)) == "!")  			newNode.ToggleInversed ();  		filterNode = newNode;  	}  	break;  case 3:  	DebugEnterAlt (3);  	// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  	{  		DebugLocation (105' 4);  		DebugLocation (105' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr216);  		Match (input' TokenTypes.Down' null);  		DebugLocation (105' 12);  		PushFollow (Follow._propertyChain_in_filterExpr219);  		propertyChain (propertySegments);  		PopFollow ();  		DebugLocation (105' 51);  		// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  		int alt7 = 2;  		try {  			DebugEnterSubRule (7);  			try {  				DebugEnterDecision (7' false);  				int LA7_1 = input.LA (1);  				if ((LA7_1 == 31)) {  					alt7 = 1;  				}  			}  			finally {  				DebugExitDecision (7);  			}  			switch (alt7) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  				{  					DebugLocation (105' 51);  					inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (7);  		}  		DebugLocation (105' 60);  		// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  		int alt8 = 2;  		try {  			DebugEnterSubRule (8);  			try {  				DebugEnterDecision (8' false);  				int LA8_1 = input.LA (1);  				if ((LA8_1 == 24)) {  					alt8 = 1;  				}  			}  			finally {  				DebugExitDecision (8);  			}  			switch (alt8) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  				{  					DebugLocation (105' 60);  					not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (8);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (106' 4);  		FilterTreeNode newProperty = new Property (propertySegments);  		if ((inverse != null ? inverse.Text : default(string)) == "?")  			filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  		else {  			if ((not != null ? not.Text : default(string)) == "!")  				newProperty.ToggleInversed ();  			filterNode = newProperty;  		}  	}  	break;  case 4:  	DebugEnterAlt (4);  	// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  	{  		DebugLocation (116' 4);  		STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  		DebugLocation (117' 4);  		string stringText = (STRING7 != null ? STRING7.Text : default(string));  		stringText = stringText.Substring (1' stringText.Length - 2);  		filterNode = new Value (stringText);  	}  	break;  case 5:  	DebugEnterAlt (5);  	// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  	{  		DebugLocation (122' 4);  		REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  		DebugLocation (123' 4);  		string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  		regexText = regexText.Substring (1' regexText.Length - 2);  		filterNode = new RegExp (regexText);  	}  	break;  case 6:  	DebugEnterAlt (6);  	// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  	{  		DebugLocation (128' 4);  		NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  		DebugLocation (129' 4);  		filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  	}  	break;  case 7:  	DebugEnterAlt (7);  	// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  	{  		DebugLocation (132' 4);  		Match (input' TRUE' Follow._TRUE_in_filterExpr271);  		DebugLocation (133' 4);  		filterNode = new Value (true);  	}  	break;  case 8:  	DebugEnterAlt (8);  	// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  	{  		DebugLocation (136' 4);  		Match (input' FALSE' Follow._FALSE_in_filterExpr281);  		DebugLocation (137' 4);  		filterNode = new Value (false);  	}  	break;  case 9:  	DebugEnterAlt (9);  	// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  	{  		DebugLocation (140' 4);  		Match (input' NULL' Follow._NULL_in_filterExpr291);  		DebugLocation (141' 4);  		filterNode = new Value (null);  	}  	break;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: switch (alt9) {  case 1:  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  	{  		DebugLocation (64' 4);  		DebugLocation (64' 6);  		PushFollow (Follow._comparator_in_filterExpr175);  		comparator6 = comparator ();  		PopFollow ();  		Match (input' TokenTypes.Down' null);  		DebugLocation (64' 18);  		PushFollow (Follow._filterExpr_in_filterExpr179);  		a = filterExpr ();  		PopFollow ();  		DebugLocation (64' 31);  		PushFollow (Follow._filterExpr_in_filterExpr183);  		b = filterExpr ();  		PopFollow ();  		Match (input' TokenTypes.Up' null);  		DebugLocation (65' 4);  		Comparator newComparator;  		switch (comparator6) {  		case "=":  			newComparator = Comparator.Equals;  			break;  		case "!=":  			newComparator = Comparator.NotEquals;  			break;  		case ">":  			newComparator = Comparator.Greater;  			break;  		case "<":  			newComparator = Comparator.Less;  			break;  		case ">=":  			newComparator = Comparator.GreaterOrEqual;  			break;  		case "<=":  			newComparator = Comparator.LessOrEqual;  			break;  		case "&":  			newComparator = Comparator.And;  			break;  		case "|":  			newComparator = Comparator.Or;  			break;  		default:  			newComparator = Comparator.Equals;  			break;  		}  		filterNode = new BoolExpression (a' newComparator' b);  	}  	break;  case 2:  	DebugEnterAlt (2);  	// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  	{  		DebugLocation (98' 4);  		DebugLocation (98' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr195);  		Match (input' TokenTypes.Down' null);  		DebugLocation (98' 12);  		PushFollow (Follow._filterExpr_in_filterExpr199);  		f = filterExpr ();  		PopFollow ();  		DebugLocation (98' 31);  		// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  		int alt6 = 2;  		try {  			DebugEnterSubRule (6);  			try {  				DebugEnterDecision (6' false);  				int LA6_1 = input.LA (1);  				if ((LA6_1 == 24)) {  					alt6 = 1;  				}  			}  			finally {  				DebugExitDecision (6);  			}  			switch (alt6) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  				{  					DebugLocation (98' 31);  					inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (6);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (99' 4);  		FilterTreeNode newNode = f;  		if ((inverse != null ? inverse.Text : default(string)) == "!")  			newNode.ToggleInversed ();  		filterNode = newNode;  	}  	break;  case 3:  	DebugEnterAlt (3);  	// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  	{  		DebugLocation (105' 4);  		DebugLocation (105' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr216);  		Match (input' TokenTypes.Down' null);  		DebugLocation (105' 12);  		PushFollow (Follow._propertyChain_in_filterExpr219);  		propertyChain (propertySegments);  		PopFollow ();  		DebugLocation (105' 51);  		// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  		int alt7 = 2;  		try {  			DebugEnterSubRule (7);  			try {  				DebugEnterDecision (7' false);  				int LA7_1 = input.LA (1);  				if ((LA7_1 == 31)) {  					alt7 = 1;  				}  			}  			finally {  				DebugExitDecision (7);  			}  			switch (alt7) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  				{  					DebugLocation (105' 51);  					inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (7);  		}  		DebugLocation (105' 60);  		// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  		int alt8 = 2;  		try {  			DebugEnterSubRule (8);  			try {  				DebugEnterDecision (8' false);  				int LA8_1 = input.LA (1);  				if ((LA8_1 == 24)) {  					alt8 = 1;  				}  			}  			finally {  				DebugExitDecision (8);  			}  			switch (alt8) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  				{  					DebugLocation (105' 60);  					not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (8);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (106' 4);  		FilterTreeNode newProperty = new Property (propertySegments);  		if ((inverse != null ? inverse.Text : default(string)) == "?")  			filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  		else {  			if ((not != null ? not.Text : default(string)) == "!")  				newProperty.ToggleInversed ();  			filterNode = newProperty;  		}  	}  	break;  case 4:  	DebugEnterAlt (4);  	// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  	{  		DebugLocation (116' 4);  		STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  		DebugLocation (117' 4);  		string stringText = (STRING7 != null ? STRING7.Text : default(string));  		stringText = stringText.Substring (1' stringText.Length - 2);  		filterNode = new Value (stringText);  	}  	break;  case 5:  	DebugEnterAlt (5);  	// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  	{  		DebugLocation (122' 4);  		REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  		DebugLocation (123' 4);  		string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  		regexText = regexText.Substring (1' regexText.Length - 2);  		filterNode = new RegExp (regexText);  	}  	break;  case 6:  	DebugEnterAlt (6);  	// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  	{  		DebugLocation (128' 4);  		NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  		DebugLocation (129' 4);  		filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  	}  	break;  case 7:  	DebugEnterAlt (7);  	// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  	{  		DebugLocation (132' 4);  		Match (input' TRUE' Follow._TRUE_in_filterExpr271);  		DebugLocation (133' 4);  		filterNode = new Value (true);  	}  	break;  case 8:  	DebugEnterAlt (8);  	// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  	{  		DebugLocation (136' 4);  		Match (input' FALSE' Follow._FALSE_in_filterExpr281);  		DebugLocation (137' 4);  		filterNode = new Value (false);  	}  	break;  case 9:  	DebugEnterAlt (9);  	// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  	{  		DebugLocation (140' 4);  		Match (input' NULL' Follow._NULL_in_filterExpr291);  		DebugLocation (141' 4);  		filterNode = new Value (null);  	}  	break;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: switch (alt9) {  case 1:  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  	{  		DebugLocation (64' 4);  		DebugLocation (64' 6);  		PushFollow (Follow._comparator_in_filterExpr175);  		comparator6 = comparator ();  		PopFollow ();  		Match (input' TokenTypes.Down' null);  		DebugLocation (64' 18);  		PushFollow (Follow._filterExpr_in_filterExpr179);  		a = filterExpr ();  		PopFollow ();  		DebugLocation (64' 31);  		PushFollow (Follow._filterExpr_in_filterExpr183);  		b = filterExpr ();  		PopFollow ();  		Match (input' TokenTypes.Up' null);  		DebugLocation (65' 4);  		Comparator newComparator;  		switch (comparator6) {  		case "=":  			newComparator = Comparator.Equals;  			break;  		case "!=":  			newComparator = Comparator.NotEquals;  			break;  		case ">":  			newComparator = Comparator.Greater;  			break;  		case "<":  			newComparator = Comparator.Less;  			break;  		case ">=":  			newComparator = Comparator.GreaterOrEqual;  			break;  		case "<=":  			newComparator = Comparator.LessOrEqual;  			break;  		case "&":  			newComparator = Comparator.And;  			break;  		case "|":  			newComparator = Comparator.Or;  			break;  		default:  			newComparator = Comparator.Equals;  			break;  		}  		filterNode = new BoolExpression (a' newComparator' b);  	}  	break;  case 2:  	DebugEnterAlt (2);  	// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  	{  		DebugLocation (98' 4);  		DebugLocation (98' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr195);  		Match (input' TokenTypes.Down' null);  		DebugLocation (98' 12);  		PushFollow (Follow._filterExpr_in_filterExpr199);  		f = filterExpr ();  		PopFollow ();  		DebugLocation (98' 31);  		// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  		int alt6 = 2;  		try {  			DebugEnterSubRule (6);  			try {  				DebugEnterDecision (6' false);  				int LA6_1 = input.LA (1);  				if ((LA6_1 == 24)) {  					alt6 = 1;  				}  			}  			finally {  				DebugExitDecision (6);  			}  			switch (alt6) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  				{  					DebugLocation (98' 31);  					inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (6);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (99' 4);  		FilterTreeNode newNode = f;  		if ((inverse != null ? inverse.Text : default(string)) == "!")  			newNode.ToggleInversed ();  		filterNode = newNode;  	}  	break;  case 3:  	DebugEnterAlt (3);  	// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  	{  		DebugLocation (105' 4);  		DebugLocation (105' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr216);  		Match (input' TokenTypes.Down' null);  		DebugLocation (105' 12);  		PushFollow (Follow._propertyChain_in_filterExpr219);  		propertyChain (propertySegments);  		PopFollow ();  		DebugLocation (105' 51);  		// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  		int alt7 = 2;  		try {  			DebugEnterSubRule (7);  			try {  				DebugEnterDecision (7' false);  				int LA7_1 = input.LA (1);  				if ((LA7_1 == 31)) {  					alt7 = 1;  				}  			}  			finally {  				DebugExitDecision (7);  			}  			switch (alt7) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  				{  					DebugLocation (105' 51);  					inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (7);  		}  		DebugLocation (105' 60);  		// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  		int alt8 = 2;  		try {  			DebugEnterSubRule (8);  			try {  				DebugEnterDecision (8' false);  				int LA8_1 = input.LA (1);  				if ((LA8_1 == 24)) {  					alt8 = 1;  				}  			}  			finally {  				DebugExitDecision (8);  			}  			switch (alt8) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  				{  					DebugLocation (105' 60);  					not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (8);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (106' 4);  		FilterTreeNode newProperty = new Property (propertySegments);  		if ((inverse != null ? inverse.Text : default(string)) == "?")  			filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  		else {  			if ((not != null ? not.Text : default(string)) == "!")  				newProperty.ToggleInversed ();  			filterNode = newProperty;  		}  	}  	break;  case 4:  	DebugEnterAlt (4);  	// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  	{  		DebugLocation (116' 4);  		STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  		DebugLocation (117' 4);  		string stringText = (STRING7 != null ? STRING7.Text : default(string));  		stringText = stringText.Substring (1' stringText.Length - 2);  		filterNode = new Value (stringText);  	}  	break;  case 5:  	DebugEnterAlt (5);  	// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  	{  		DebugLocation (122' 4);  		REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  		DebugLocation (123' 4);  		string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  		regexText = regexText.Substring (1' regexText.Length - 2);  		filterNode = new RegExp (regexText);  	}  	break;  case 6:  	DebugEnterAlt (6);  	// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  	{  		DebugLocation (128' 4);  		NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  		DebugLocation (129' 4);  		filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  	}  	break;  case 7:  	DebugEnterAlt (7);  	// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  	{  		DebugLocation (132' 4);  		Match (input' TRUE' Follow._TRUE_in_filterExpr271);  		DebugLocation (133' 4);  		filterNode = new Value (true);  	}  	break;  case 8:  	DebugEnterAlt (8);  	// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  	{  		DebugLocation (136' 4);  		Match (input' FALSE' Follow._FALSE_in_filterExpr281);  		DebugLocation (137' 4);  		filterNode = new Value (false);  	}  	break;  case 9:  	DebugEnterAlt (9);  	// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  	{  		DebugLocation (140' 4);  		Match (input' NULL' Follow._NULL_in_filterExpr291);  		DebugLocation (141' 4);  		filterNode = new Value (null);  	}  	break;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: switch (alt9) {  case 1:  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  	{  		DebugLocation (64' 4);  		DebugLocation (64' 6);  		PushFollow (Follow._comparator_in_filterExpr175);  		comparator6 = comparator ();  		PopFollow ();  		Match (input' TokenTypes.Down' null);  		DebugLocation (64' 18);  		PushFollow (Follow._filterExpr_in_filterExpr179);  		a = filterExpr ();  		PopFollow ();  		DebugLocation (64' 31);  		PushFollow (Follow._filterExpr_in_filterExpr183);  		b = filterExpr ();  		PopFollow ();  		Match (input' TokenTypes.Up' null);  		DebugLocation (65' 4);  		Comparator newComparator;  		switch (comparator6) {  		case "=":  			newComparator = Comparator.Equals;  			break;  		case "!=":  			newComparator = Comparator.NotEquals;  			break;  		case ">":  			newComparator = Comparator.Greater;  			break;  		case "<":  			newComparator = Comparator.Less;  			break;  		case ">=":  			newComparator = Comparator.GreaterOrEqual;  			break;  		case "<=":  			newComparator = Comparator.LessOrEqual;  			break;  		case "&":  			newComparator = Comparator.And;  			break;  		case "|":  			newComparator = Comparator.Or;  			break;  		default:  			newComparator = Comparator.Equals;  			break;  		}  		filterNode = new BoolExpression (a' newComparator' b);  	}  	break;  case 2:  	DebugEnterAlt (2);  	// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  	{  		DebugLocation (98' 4);  		DebugLocation (98' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr195);  		Match (input' TokenTypes.Down' null);  		DebugLocation (98' 12);  		PushFollow (Follow._filterExpr_in_filterExpr199);  		f = filterExpr ();  		PopFollow ();  		DebugLocation (98' 31);  		// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  		int alt6 = 2;  		try {  			DebugEnterSubRule (6);  			try {  				DebugEnterDecision (6' false);  				int LA6_1 = input.LA (1);  				if ((LA6_1 == 24)) {  					alt6 = 1;  				}  			}  			finally {  				DebugExitDecision (6);  			}  			switch (alt6) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  				{  					DebugLocation (98' 31);  					inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (6);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (99' 4);  		FilterTreeNode newNode = f;  		if ((inverse != null ? inverse.Text : default(string)) == "!")  			newNode.ToggleInversed ();  		filterNode = newNode;  	}  	break;  case 3:  	DebugEnterAlt (3);  	// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  	{  		DebugLocation (105' 4);  		DebugLocation (105' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr216);  		Match (input' TokenTypes.Down' null);  		DebugLocation (105' 12);  		PushFollow (Follow._propertyChain_in_filterExpr219);  		propertyChain (propertySegments);  		PopFollow ();  		DebugLocation (105' 51);  		// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  		int alt7 = 2;  		try {  			DebugEnterSubRule (7);  			try {  				DebugEnterDecision (7' false);  				int LA7_1 = input.LA (1);  				if ((LA7_1 == 31)) {  					alt7 = 1;  				}  			}  			finally {  				DebugExitDecision (7);  			}  			switch (alt7) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  				{  					DebugLocation (105' 51);  					inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (7);  		}  		DebugLocation (105' 60);  		// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  		int alt8 = 2;  		try {  			DebugEnterSubRule (8);  			try {  				DebugEnterDecision (8' false);  				int LA8_1 = input.LA (1);  				if ((LA8_1 == 24)) {  					alt8 = 1;  				}  			}  			finally {  				DebugExitDecision (8);  			}  			switch (alt8) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  				{  					DebugLocation (105' 60);  					not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (8);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (106' 4);  		FilterTreeNode newProperty = new Property (propertySegments);  		if ((inverse != null ? inverse.Text : default(string)) == "?")  			filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  		else {  			if ((not != null ? not.Text : default(string)) == "!")  				newProperty.ToggleInversed ();  			filterNode = newProperty;  		}  	}  	break;  case 4:  	DebugEnterAlt (4);  	// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  	{  		DebugLocation (116' 4);  		STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  		DebugLocation (117' 4);  		string stringText = (STRING7 != null ? STRING7.Text : default(string));  		stringText = stringText.Substring (1' stringText.Length - 2);  		filterNode = new Value (stringText);  	}  	break;  case 5:  	DebugEnterAlt (5);  	// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  	{  		DebugLocation (122' 4);  		REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  		DebugLocation (123' 4);  		string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  		regexText = regexText.Substring (1' regexText.Length - 2);  		filterNode = new RegExp (regexText);  	}  	break;  case 6:  	DebugEnterAlt (6);  	// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  	{  		DebugLocation (128' 4);  		NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  		DebugLocation (129' 4);  		filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  	}  	break;  case 7:  	DebugEnterAlt (7);  	// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  	{  		DebugLocation (132' 4);  		Match (input' TRUE' Follow._TRUE_in_filterExpr271);  		DebugLocation (133' 4);  		filterNode = new Value (true);  	}  	break;  case 8:  	DebugEnterAlt (8);  	// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  	{  		DebugLocation (136' 4);  		Match (input' FALSE' Follow._FALSE_in_filterExpr281);  		DebugLocation (137' 4);  		filterNode = new Value (false);  	}  	break;  case 9:  	DebugEnterAlt (9);  	// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  	{  		DebugLocation (140' 4);  		Match (input' NULL' Follow._NULL_in_filterExpr291);  		DebugLocation (141' 4);  		filterNode = new Value (null);  	}  	break;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: switch (alt9) {  case 1:  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  	{  		DebugLocation (64' 4);  		DebugLocation (64' 6);  		PushFollow (Follow._comparator_in_filterExpr175);  		comparator6 = comparator ();  		PopFollow ();  		Match (input' TokenTypes.Down' null);  		DebugLocation (64' 18);  		PushFollow (Follow._filterExpr_in_filterExpr179);  		a = filterExpr ();  		PopFollow ();  		DebugLocation (64' 31);  		PushFollow (Follow._filterExpr_in_filterExpr183);  		b = filterExpr ();  		PopFollow ();  		Match (input' TokenTypes.Up' null);  		DebugLocation (65' 4);  		Comparator newComparator;  		switch (comparator6) {  		case "=":  			newComparator = Comparator.Equals;  			break;  		case "!=":  			newComparator = Comparator.NotEquals;  			break;  		case ">":  			newComparator = Comparator.Greater;  			break;  		case "<":  			newComparator = Comparator.Less;  			break;  		case ">=":  			newComparator = Comparator.GreaterOrEqual;  			break;  		case "<=":  			newComparator = Comparator.LessOrEqual;  			break;  		case "&":  			newComparator = Comparator.And;  			break;  		case "|":  			newComparator = Comparator.Or;  			break;  		default:  			newComparator = Comparator.Equals;  			break;  		}  		filterNode = new BoolExpression (a' newComparator' b);  	}  	break;  case 2:  	DebugEnterAlt (2);  	// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  	{  		DebugLocation (98' 4);  		DebugLocation (98' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr195);  		Match (input' TokenTypes.Down' null);  		DebugLocation (98' 12);  		PushFollow (Follow._filterExpr_in_filterExpr199);  		f = filterExpr ();  		PopFollow ();  		DebugLocation (98' 31);  		// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  		int alt6 = 2;  		try {  			DebugEnterSubRule (6);  			try {  				DebugEnterDecision (6' false);  				int LA6_1 = input.LA (1);  				if ((LA6_1 == 24)) {  					alt6 = 1;  				}  			}  			finally {  				DebugExitDecision (6);  			}  			switch (alt6) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  				{  					DebugLocation (98' 31);  					inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (6);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (99' 4);  		FilterTreeNode newNode = f;  		if ((inverse != null ? inverse.Text : default(string)) == "!")  			newNode.ToggleInversed ();  		filterNode = newNode;  	}  	break;  case 3:  	DebugEnterAlt (3);  	// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  	{  		DebugLocation (105' 4);  		DebugLocation (105' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr216);  		Match (input' TokenTypes.Down' null);  		DebugLocation (105' 12);  		PushFollow (Follow._propertyChain_in_filterExpr219);  		propertyChain (propertySegments);  		PopFollow ();  		DebugLocation (105' 51);  		// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  		int alt7 = 2;  		try {  			DebugEnterSubRule (7);  			try {  				DebugEnterDecision (7' false);  				int LA7_1 = input.LA (1);  				if ((LA7_1 == 31)) {  					alt7 = 1;  				}  			}  			finally {  				DebugExitDecision (7);  			}  			switch (alt7) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  				{  					DebugLocation (105' 51);  					inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (7);  		}  		DebugLocation (105' 60);  		// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  		int alt8 = 2;  		try {  			DebugEnterSubRule (8);  			try {  				DebugEnterDecision (8' false);  				int LA8_1 = input.LA (1);  				if ((LA8_1 == 24)) {  					alt8 = 1;  				}  			}  			finally {  				DebugExitDecision (8);  			}  			switch (alt8) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  				{  					DebugLocation (105' 60);  					not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (8);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (106' 4);  		FilterTreeNode newProperty = new Property (propertySegments);  		if ((inverse != null ? inverse.Text : default(string)) == "?")  			filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  		else {  			if ((not != null ? not.Text : default(string)) == "!")  				newProperty.ToggleInversed ();  			filterNode = newProperty;  		}  	}  	break;  case 4:  	DebugEnterAlt (4);  	// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  	{  		DebugLocation (116' 4);  		STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  		DebugLocation (117' 4);  		string stringText = (STRING7 != null ? STRING7.Text : default(string));  		stringText = stringText.Substring (1' stringText.Length - 2);  		filterNode = new Value (stringText);  	}  	break;  case 5:  	DebugEnterAlt (5);  	// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  	{  		DebugLocation (122' 4);  		REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  		DebugLocation (123' 4);  		string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  		regexText = regexText.Substring (1' regexText.Length - 2);  		filterNode = new RegExp (regexText);  	}  	break;  case 6:  	DebugEnterAlt (6);  	// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  	{  		DebugLocation (128' 4);  		NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  		DebugLocation (129' 4);  		filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  	}  	break;  case 7:  	DebugEnterAlt (7);  	// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  	{  		DebugLocation (132' 4);  		Match (input' TRUE' Follow._TRUE_in_filterExpr271);  		DebugLocation (133' 4);  		filterNode = new Value (true);  	}  	break;  case 8:  	DebugEnterAlt (8);  	// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  	{  		DebugLocation (136' 4);  		Match (input' FALSE' Follow._FALSE_in_filterExpr281);  		DebugLocation (137' 4);  		filterNode = new Value (false);  	}  	break;  case 9:  	DebugEnterAlt (9);  	// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  	{  		DebugLocation (140' 4);  		Match (input' NULL' Follow._NULL_in_filterExpr291);  		DebugLocation (141' 4);  		filterNode = new Value (null);  	}  	break;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: switch (alt9) {  case 1:  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  	{  		DebugLocation (64' 4);  		DebugLocation (64' 6);  		PushFollow (Follow._comparator_in_filterExpr175);  		comparator6 = comparator ();  		PopFollow ();  		Match (input' TokenTypes.Down' null);  		DebugLocation (64' 18);  		PushFollow (Follow._filterExpr_in_filterExpr179);  		a = filterExpr ();  		PopFollow ();  		DebugLocation (64' 31);  		PushFollow (Follow._filterExpr_in_filterExpr183);  		b = filterExpr ();  		PopFollow ();  		Match (input' TokenTypes.Up' null);  		DebugLocation (65' 4);  		Comparator newComparator;  		switch (comparator6) {  		case "=":  			newComparator = Comparator.Equals;  			break;  		case "!=":  			newComparator = Comparator.NotEquals;  			break;  		case ">":  			newComparator = Comparator.Greater;  			break;  		case "<":  			newComparator = Comparator.Less;  			break;  		case ">=":  			newComparator = Comparator.GreaterOrEqual;  			break;  		case "<=":  			newComparator = Comparator.LessOrEqual;  			break;  		case "&":  			newComparator = Comparator.And;  			break;  		case "|":  			newComparator = Comparator.Or;  			break;  		default:  			newComparator = Comparator.Equals;  			break;  		}  		filterNode = new BoolExpression (a' newComparator' b);  	}  	break;  case 2:  	DebugEnterAlt (2);  	// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  	{  		DebugLocation (98' 4);  		DebugLocation (98' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr195);  		Match (input' TokenTypes.Down' null);  		DebugLocation (98' 12);  		PushFollow (Follow._filterExpr_in_filterExpr199);  		f = filterExpr ();  		PopFollow ();  		DebugLocation (98' 31);  		// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  		int alt6 = 2;  		try {  			DebugEnterSubRule (6);  			try {  				DebugEnterDecision (6' false);  				int LA6_1 = input.LA (1);  				if ((LA6_1 == 24)) {  					alt6 = 1;  				}  			}  			finally {  				DebugExitDecision (6);  			}  			switch (alt6) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  				{  					DebugLocation (98' 31);  					inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (6);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (99' 4);  		FilterTreeNode newNode = f;  		if ((inverse != null ? inverse.Text : default(string)) == "!")  			newNode.ToggleInversed ();  		filterNode = newNode;  	}  	break;  case 3:  	DebugEnterAlt (3);  	// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  	{  		DebugLocation (105' 4);  		DebugLocation (105' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr216);  		Match (input' TokenTypes.Down' null);  		DebugLocation (105' 12);  		PushFollow (Follow._propertyChain_in_filterExpr219);  		propertyChain (propertySegments);  		PopFollow ();  		DebugLocation (105' 51);  		// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  		int alt7 = 2;  		try {  			DebugEnterSubRule (7);  			try {  				DebugEnterDecision (7' false);  				int LA7_1 = input.LA (1);  				if ((LA7_1 == 31)) {  					alt7 = 1;  				}  			}  			finally {  				DebugExitDecision (7);  			}  			switch (alt7) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  				{  					DebugLocation (105' 51);  					inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (7);  		}  		DebugLocation (105' 60);  		// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  		int alt8 = 2;  		try {  			DebugEnterSubRule (8);  			try {  				DebugEnterDecision (8' false);  				int LA8_1 = input.LA (1);  				if ((LA8_1 == 24)) {  					alt8 = 1;  				}  			}  			finally {  				DebugExitDecision (8);  			}  			switch (alt8) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  				{  					DebugLocation (105' 60);  					not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (8);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (106' 4);  		FilterTreeNode newProperty = new Property (propertySegments);  		if ((inverse != null ? inverse.Text : default(string)) == "?")  			filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  		else {  			if ((not != null ? not.Text : default(string)) == "!")  				newProperty.ToggleInversed ();  			filterNode = newProperty;  		}  	}  	break;  case 4:  	DebugEnterAlt (4);  	// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  	{  		DebugLocation (116' 4);  		STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  		DebugLocation (117' 4);  		string stringText = (STRING7 != null ? STRING7.Text : default(string));  		stringText = stringText.Substring (1' stringText.Length - 2);  		filterNode = new Value (stringText);  	}  	break;  case 5:  	DebugEnterAlt (5);  	// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  	{  		DebugLocation (122' 4);  		REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  		DebugLocation (123' 4);  		string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  		regexText = regexText.Substring (1' regexText.Length - 2);  		filterNode = new RegExp (regexText);  	}  	break;  case 6:  	DebugEnterAlt (6);  	// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  	{  		DebugLocation (128' 4);  		NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  		DebugLocation (129' 4);  		filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  	}  	break;  case 7:  	DebugEnterAlt (7);  	// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  	{  		DebugLocation (132' 4);  		Match (input' TRUE' Follow._TRUE_in_filterExpr271);  		DebugLocation (133' 4);  		filterNode = new Value (true);  	}  	break;  case 8:  	DebugEnterAlt (8);  	// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  	{  		DebugLocation (136' 4);  		Match (input' FALSE' Follow._FALSE_in_filterExpr281);  		DebugLocation (137' 4);  		filterNode = new Value (false);  	}  	break;  case 9:  	DebugEnterAlt (9);  	// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  	{  		DebugLocation (140' 4);  		Match (input' NULL' Follow._NULL_in_filterExpr291);  		DebugLocation (141' 4);  		filterNode = new Value (null);  	}  	break;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: switch (alt9) {  case 1:  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  	{  		DebugLocation (64' 4);  		DebugLocation (64' 6);  		PushFollow (Follow._comparator_in_filterExpr175);  		comparator6 = comparator ();  		PopFollow ();  		Match (input' TokenTypes.Down' null);  		DebugLocation (64' 18);  		PushFollow (Follow._filterExpr_in_filterExpr179);  		a = filterExpr ();  		PopFollow ();  		DebugLocation (64' 31);  		PushFollow (Follow._filterExpr_in_filterExpr183);  		b = filterExpr ();  		PopFollow ();  		Match (input' TokenTypes.Up' null);  		DebugLocation (65' 4);  		Comparator newComparator;  		switch (comparator6) {  		case "=":  			newComparator = Comparator.Equals;  			break;  		case "!=":  			newComparator = Comparator.NotEquals;  			break;  		case ">":  			newComparator = Comparator.Greater;  			break;  		case "<":  			newComparator = Comparator.Less;  			break;  		case ">=":  			newComparator = Comparator.GreaterOrEqual;  			break;  		case "<=":  			newComparator = Comparator.LessOrEqual;  			break;  		case "&":  			newComparator = Comparator.And;  			break;  		case "|":  			newComparator = Comparator.Or;  			break;  		default:  			newComparator = Comparator.Equals;  			break;  		}  		filterNode = new BoolExpression (a' newComparator' b);  	}  	break;  case 2:  	DebugEnterAlt (2);  	// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  	{  		DebugLocation (98' 4);  		DebugLocation (98' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr195);  		Match (input' TokenTypes.Down' null);  		DebugLocation (98' 12);  		PushFollow (Follow._filterExpr_in_filterExpr199);  		f = filterExpr ();  		PopFollow ();  		DebugLocation (98' 31);  		// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  		int alt6 = 2;  		try {  			DebugEnterSubRule (6);  			try {  				DebugEnterDecision (6' false);  				int LA6_1 = input.LA (1);  				if ((LA6_1 == 24)) {  					alt6 = 1;  				}  			}  			finally {  				DebugExitDecision (6);  			}  			switch (alt6) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  				{  					DebugLocation (98' 31);  					inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (6);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (99' 4);  		FilterTreeNode newNode = f;  		if ((inverse != null ? inverse.Text : default(string)) == "!")  			newNode.ToggleInversed ();  		filterNode = newNode;  	}  	break;  case 3:  	DebugEnterAlt (3);  	// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  	{  		DebugLocation (105' 4);  		DebugLocation (105' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr216);  		Match (input' TokenTypes.Down' null);  		DebugLocation (105' 12);  		PushFollow (Follow._propertyChain_in_filterExpr219);  		propertyChain (propertySegments);  		PopFollow ();  		DebugLocation (105' 51);  		// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  		int alt7 = 2;  		try {  			DebugEnterSubRule (7);  			try {  				DebugEnterDecision (7' false);  				int LA7_1 = input.LA (1);  				if ((LA7_1 == 31)) {  					alt7 = 1;  				}  			}  			finally {  				DebugExitDecision (7);  			}  			switch (alt7) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  				{  					DebugLocation (105' 51);  					inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (7);  		}  		DebugLocation (105' 60);  		// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  		int alt8 = 2;  		try {  			DebugEnterSubRule (8);  			try {  				DebugEnterDecision (8' false);  				int LA8_1 = input.LA (1);  				if ((LA8_1 == 24)) {  					alt8 = 1;  				}  			}  			finally {  				DebugExitDecision (8);  			}  			switch (alt8) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  				{  					DebugLocation (105' 60);  					not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (8);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (106' 4);  		FilterTreeNode newProperty = new Property (propertySegments);  		if ((inverse != null ? inverse.Text : default(string)) == "?")  			filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  		else {  			if ((not != null ? not.Text : default(string)) == "!")  				newProperty.ToggleInversed ();  			filterNode = newProperty;  		}  	}  	break;  case 4:  	DebugEnterAlt (4);  	// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  	{  		DebugLocation (116' 4);  		STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  		DebugLocation (117' 4);  		string stringText = (STRING7 != null ? STRING7.Text : default(string));  		stringText = stringText.Substring (1' stringText.Length - 2);  		filterNode = new Value (stringText);  	}  	break;  case 5:  	DebugEnterAlt (5);  	// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  	{  		DebugLocation (122' 4);  		REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  		DebugLocation (123' 4);  		string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  		regexText = regexText.Substring (1' regexText.Length - 2);  		filterNode = new RegExp (regexText);  	}  	break;  case 6:  	DebugEnterAlt (6);  	// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  	{  		DebugLocation (128' 4);  		NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  		DebugLocation (129' 4);  		filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  	}  	break;  case 7:  	DebugEnterAlt (7);  	// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  	{  		DebugLocation (132' 4);  		Match (input' TRUE' Follow._TRUE_in_filterExpr271);  		DebugLocation (133' 4);  		filterNode = new Value (true);  	}  	break;  case 8:  	DebugEnterAlt (8);  	// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  	{  		DebugLocation (136' 4);  		Match (input' FALSE' Follow._FALSE_in_filterExpr281);  		DebugLocation (137' 4);  		filterNode = new Value (false);  	}  	break;  case 9:  	DebugEnterAlt (9);  	// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  	{  		DebugLocation (140' 4);  		Match (input' NULL' Follow._NULL_in_filterExpr291);  		DebugLocation (141' 4);  		filterNode = new Value (null);  	}  	break;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: switch (alt9) {  case 1:  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  	{  		DebugLocation (64' 4);  		DebugLocation (64' 6);  		PushFollow (Follow._comparator_in_filterExpr175);  		comparator6 = comparator ();  		PopFollow ();  		Match (input' TokenTypes.Down' null);  		DebugLocation (64' 18);  		PushFollow (Follow._filterExpr_in_filterExpr179);  		a = filterExpr ();  		PopFollow ();  		DebugLocation (64' 31);  		PushFollow (Follow._filterExpr_in_filterExpr183);  		b = filterExpr ();  		PopFollow ();  		Match (input' TokenTypes.Up' null);  		DebugLocation (65' 4);  		Comparator newComparator;  		switch (comparator6) {  		case "=":  			newComparator = Comparator.Equals;  			break;  		case "!=":  			newComparator = Comparator.NotEquals;  			break;  		case ">":  			newComparator = Comparator.Greater;  			break;  		case "<":  			newComparator = Comparator.Less;  			break;  		case ">=":  			newComparator = Comparator.GreaterOrEqual;  			break;  		case "<=":  			newComparator = Comparator.LessOrEqual;  			break;  		case "&":  			newComparator = Comparator.And;  			break;  		case "|":  			newComparator = Comparator.Or;  			break;  		default:  			newComparator = Comparator.Equals;  			break;  		}  		filterNode = new BoolExpression (a' newComparator' b);  	}  	break;  case 2:  	DebugEnterAlt (2);  	// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  	{  		DebugLocation (98' 4);  		DebugLocation (98' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr195);  		Match (input' TokenTypes.Down' null);  		DebugLocation (98' 12);  		PushFollow (Follow._filterExpr_in_filterExpr199);  		f = filterExpr ();  		PopFollow ();  		DebugLocation (98' 31);  		// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  		int alt6 = 2;  		try {  			DebugEnterSubRule (6);  			try {  				DebugEnterDecision (6' false);  				int LA6_1 = input.LA (1);  				if ((LA6_1 == 24)) {  					alt6 = 1;  				}  			}  			finally {  				DebugExitDecision (6);  			}  			switch (alt6) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  				{  					DebugLocation (98' 31);  					inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (6);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (99' 4);  		FilterTreeNode newNode = f;  		if ((inverse != null ? inverse.Text : default(string)) == "!")  			newNode.ToggleInversed ();  		filterNode = newNode;  	}  	break;  case 3:  	DebugEnterAlt (3);  	// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  	{  		DebugLocation (105' 4);  		DebugLocation (105' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr216);  		Match (input' TokenTypes.Down' null);  		DebugLocation (105' 12);  		PushFollow (Follow._propertyChain_in_filterExpr219);  		propertyChain (propertySegments);  		PopFollow ();  		DebugLocation (105' 51);  		// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  		int alt7 = 2;  		try {  			DebugEnterSubRule (7);  			try {  				DebugEnterDecision (7' false);  				int LA7_1 = input.LA (1);  				if ((LA7_1 == 31)) {  					alt7 = 1;  				}  			}  			finally {  				DebugExitDecision (7);  			}  			switch (alt7) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  				{  					DebugLocation (105' 51);  					inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (7);  		}  		DebugLocation (105' 60);  		// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  		int alt8 = 2;  		try {  			DebugEnterSubRule (8);  			try {  				DebugEnterDecision (8' false);  				int LA8_1 = input.LA (1);  				if ((LA8_1 == 24)) {  					alt8 = 1;  				}  			}  			finally {  				DebugExitDecision (8);  			}  			switch (alt8) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  				{  					DebugLocation (105' 60);  					not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (8);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (106' 4);  		FilterTreeNode newProperty = new Property (propertySegments);  		if ((inverse != null ? inverse.Text : default(string)) == "?")  			filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  		else {  			if ((not != null ? not.Text : default(string)) == "!")  				newProperty.ToggleInversed ();  			filterNode = newProperty;  		}  	}  	break;  case 4:  	DebugEnterAlt (4);  	// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  	{  		DebugLocation (116' 4);  		STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  		DebugLocation (117' 4);  		string stringText = (STRING7 != null ? STRING7.Text : default(string));  		stringText = stringText.Substring (1' stringText.Length - 2);  		filterNode = new Value (stringText);  	}  	break;  case 5:  	DebugEnterAlt (5);  	// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  	{  		DebugLocation (122' 4);  		REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  		DebugLocation (123' 4);  		string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  		regexText = regexText.Substring (1' regexText.Length - 2);  		filterNode = new RegExp (regexText);  	}  	break;  case 6:  	DebugEnterAlt (6);  	// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  	{  		DebugLocation (128' 4);  		NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  		DebugLocation (129' 4);  		filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  	}  	break;  case 7:  	DebugEnterAlt (7);  	// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  	{  		DebugLocation (132' 4);  		Match (input' TRUE' Follow._TRUE_in_filterExpr271);  		DebugLocation (133' 4);  		filterNode = new Value (true);  	}  	break;  case 8:  	DebugEnterAlt (8);  	// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  	{  		DebugLocation (136' 4);  		Match (input' FALSE' Follow._FALSE_in_filterExpr281);  		DebugLocation (137' 4);  		filterNode = new Value (false);  	}  	break;  case 9:  	DebugEnterAlt (9);  	// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  	{  		DebugLocation (140' 4);  		Match (input' NULL' Follow._NULL_in_filterExpr291);  		DebugLocation (141' 4);  		filterNode = new Value (null);  	}  	break;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: switch (alt9) {  case 1:  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  	{  		DebugLocation (64' 4);  		DebugLocation (64' 6);  		PushFollow (Follow._comparator_in_filterExpr175);  		comparator6 = comparator ();  		PopFollow ();  		Match (input' TokenTypes.Down' null);  		DebugLocation (64' 18);  		PushFollow (Follow._filterExpr_in_filterExpr179);  		a = filterExpr ();  		PopFollow ();  		DebugLocation (64' 31);  		PushFollow (Follow._filterExpr_in_filterExpr183);  		b = filterExpr ();  		PopFollow ();  		Match (input' TokenTypes.Up' null);  		DebugLocation (65' 4);  		Comparator newComparator;  		switch (comparator6) {  		case "=":  			newComparator = Comparator.Equals;  			break;  		case "!=":  			newComparator = Comparator.NotEquals;  			break;  		case ">":  			newComparator = Comparator.Greater;  			break;  		case "<":  			newComparator = Comparator.Less;  			break;  		case ">=":  			newComparator = Comparator.GreaterOrEqual;  			break;  		case "<=":  			newComparator = Comparator.LessOrEqual;  			break;  		case "&":  			newComparator = Comparator.And;  			break;  		case "|":  			newComparator = Comparator.Or;  			break;  		default:  			newComparator = Comparator.Equals;  			break;  		}  		filterNode = new BoolExpression (a' newComparator' b);  	}  	break;  case 2:  	DebugEnterAlt (2);  	// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  	{  		DebugLocation (98' 4);  		DebugLocation (98' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr195);  		Match (input' TokenTypes.Down' null);  		DebugLocation (98' 12);  		PushFollow (Follow._filterExpr_in_filterExpr199);  		f = filterExpr ();  		PopFollow ();  		DebugLocation (98' 31);  		// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  		int alt6 = 2;  		try {  			DebugEnterSubRule (6);  			try {  				DebugEnterDecision (6' false);  				int LA6_1 = input.LA (1);  				if ((LA6_1 == 24)) {  					alt6 = 1;  				}  			}  			finally {  				DebugExitDecision (6);  			}  			switch (alt6) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  				{  					DebugLocation (98' 31);  					inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (6);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (99' 4);  		FilterTreeNode newNode = f;  		if ((inverse != null ? inverse.Text : default(string)) == "!")  			newNode.ToggleInversed ();  		filterNode = newNode;  	}  	break;  case 3:  	DebugEnterAlt (3);  	// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  	{  		DebugLocation (105' 4);  		DebugLocation (105' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr216);  		Match (input' TokenTypes.Down' null);  		DebugLocation (105' 12);  		PushFollow (Follow._propertyChain_in_filterExpr219);  		propertyChain (propertySegments);  		PopFollow ();  		DebugLocation (105' 51);  		// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  		int alt7 = 2;  		try {  			DebugEnterSubRule (7);  			try {  				DebugEnterDecision (7' false);  				int LA7_1 = input.LA (1);  				if ((LA7_1 == 31)) {  					alt7 = 1;  				}  			}  			finally {  				DebugExitDecision (7);  			}  			switch (alt7) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  				{  					DebugLocation (105' 51);  					inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (7);  		}  		DebugLocation (105' 60);  		// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  		int alt8 = 2;  		try {  			DebugEnterSubRule (8);  			try {  				DebugEnterDecision (8' false);  				int LA8_1 = input.LA (1);  				if ((LA8_1 == 24)) {  					alt8 = 1;  				}  			}  			finally {  				DebugExitDecision (8);  			}  			switch (alt8) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  				{  					DebugLocation (105' 60);  					not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (8);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (106' 4);  		FilterTreeNode newProperty = new Property (propertySegments);  		if ((inverse != null ? inverse.Text : default(string)) == "?")  			filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  		else {  			if ((not != null ? not.Text : default(string)) == "!")  				newProperty.ToggleInversed ();  			filterNode = newProperty;  		}  	}  	break;  case 4:  	DebugEnterAlt (4);  	// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  	{  		DebugLocation (116' 4);  		STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  		DebugLocation (117' 4);  		string stringText = (STRING7 != null ? STRING7.Text : default(string));  		stringText = stringText.Substring (1' stringText.Length - 2);  		filterNode = new Value (stringText);  	}  	break;  case 5:  	DebugEnterAlt (5);  	// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  	{  		DebugLocation (122' 4);  		REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  		DebugLocation (123' 4);  		string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  		regexText = regexText.Substring (1' regexText.Length - 2);  		filterNode = new RegExp (regexText);  	}  	break;  case 6:  	DebugEnterAlt (6);  	// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  	{  		DebugLocation (128' 4);  		NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  		DebugLocation (129' 4);  		filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  	}  	break;  case 7:  	DebugEnterAlt (7);  	// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  	{  		DebugLocation (132' 4);  		Match (input' TRUE' Follow._TRUE_in_filterExpr271);  		DebugLocation (133' 4);  		filterNode = new Value (true);  	}  	break;  case 8:  	DebugEnterAlt (8);  	// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  	{  		DebugLocation (136' 4);  		Match (input' FALSE' Follow._FALSE_in_filterExpr281);  		DebugLocation (137' 4);  		filterNode = new Value (false);  	}  	break;  case 9:  	DebugEnterAlt (9);  	// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  	{  		DebugLocation (140' 4);  		Match (input' NULL' Follow._NULL_in_filterExpr291);  		DebugLocation (141' 4);  		filterNode = new Value (null);  	}  	break;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: switch (alt9) {  case 1:  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  	{  		DebugLocation (64' 4);  		DebugLocation (64' 6);  		PushFollow (Follow._comparator_in_filterExpr175);  		comparator6 = comparator ();  		PopFollow ();  		Match (input' TokenTypes.Down' null);  		DebugLocation (64' 18);  		PushFollow (Follow._filterExpr_in_filterExpr179);  		a = filterExpr ();  		PopFollow ();  		DebugLocation (64' 31);  		PushFollow (Follow._filterExpr_in_filterExpr183);  		b = filterExpr ();  		PopFollow ();  		Match (input' TokenTypes.Up' null);  		DebugLocation (65' 4);  		Comparator newComparator;  		switch (comparator6) {  		case "=":  			newComparator = Comparator.Equals;  			break;  		case "!=":  			newComparator = Comparator.NotEquals;  			break;  		case ">":  			newComparator = Comparator.Greater;  			break;  		case "<":  			newComparator = Comparator.Less;  			break;  		case ">=":  			newComparator = Comparator.GreaterOrEqual;  			break;  		case "<=":  			newComparator = Comparator.LessOrEqual;  			break;  		case "&":  			newComparator = Comparator.And;  			break;  		case "|":  			newComparator = Comparator.Or;  			break;  		default:  			newComparator = Comparator.Equals;  			break;  		}  		filterNode = new BoolExpression (a' newComparator' b);  	}  	break;  case 2:  	DebugEnterAlt (2);  	// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  	{  		DebugLocation (98' 4);  		DebugLocation (98' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr195);  		Match (input' TokenTypes.Down' null);  		DebugLocation (98' 12);  		PushFollow (Follow._filterExpr_in_filterExpr199);  		f = filterExpr ();  		PopFollow ();  		DebugLocation (98' 31);  		// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  		int alt6 = 2;  		try {  			DebugEnterSubRule (6);  			try {  				DebugEnterDecision (6' false);  				int LA6_1 = input.LA (1);  				if ((LA6_1 == 24)) {  					alt6 = 1;  				}  			}  			finally {  				DebugExitDecision (6);  			}  			switch (alt6) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  				{  					DebugLocation (98' 31);  					inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (6);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (99' 4);  		FilterTreeNode newNode = f;  		if ((inverse != null ? inverse.Text : default(string)) == "!")  			newNode.ToggleInversed ();  		filterNode = newNode;  	}  	break;  case 3:  	DebugEnterAlt (3);  	// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  	{  		DebugLocation (105' 4);  		DebugLocation (105' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr216);  		Match (input' TokenTypes.Down' null);  		DebugLocation (105' 12);  		PushFollow (Follow._propertyChain_in_filterExpr219);  		propertyChain (propertySegments);  		PopFollow ();  		DebugLocation (105' 51);  		// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  		int alt7 = 2;  		try {  			DebugEnterSubRule (7);  			try {  				DebugEnterDecision (7' false);  				int LA7_1 = input.LA (1);  				if ((LA7_1 == 31)) {  					alt7 = 1;  				}  			}  			finally {  				DebugExitDecision (7);  			}  			switch (alt7) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  				{  					DebugLocation (105' 51);  					inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (7);  		}  		DebugLocation (105' 60);  		// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  		int alt8 = 2;  		try {  			DebugEnterSubRule (8);  			try {  				DebugEnterDecision (8' false);  				int LA8_1 = input.LA (1);  				if ((LA8_1 == 24)) {  					alt8 = 1;  				}  			}  			finally {  				DebugExitDecision (8);  			}  			switch (alt8) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  				{  					DebugLocation (105' 60);  					not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (8);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (106' 4);  		FilterTreeNode newProperty = new Property (propertySegments);  		if ((inverse != null ? inverse.Text : default(string)) == "?")  			filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  		else {  			if ((not != null ? not.Text : default(string)) == "!")  				newProperty.ToggleInversed ();  			filterNode = newProperty;  		}  	}  	break;  case 4:  	DebugEnterAlt (4);  	// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  	{  		DebugLocation (116' 4);  		STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  		DebugLocation (117' 4);  		string stringText = (STRING7 != null ? STRING7.Text : default(string));  		stringText = stringText.Substring (1' stringText.Length - 2);  		filterNode = new Value (stringText);  	}  	break;  case 5:  	DebugEnterAlt (5);  	// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  	{  		DebugLocation (122' 4);  		REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  		DebugLocation (123' 4);  		string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  		regexText = regexText.Substring (1' regexText.Length - 2);  		filterNode = new RegExp (regexText);  	}  	break;  case 6:  	DebugEnterAlt (6);  	// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  	{  		DebugLocation (128' 4);  		NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  		DebugLocation (129' 4);  		filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  	}  	break;  case 7:  	DebugEnterAlt (7);  	// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  	{  		DebugLocation (132' 4);  		Match (input' TRUE' Follow._TRUE_in_filterExpr271);  		DebugLocation (133' 4);  		filterNode = new Value (true);  	}  	break;  case 8:  	DebugEnterAlt (8);  	// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  	{  		DebugLocation (136' 4);  		Match (input' FALSE' Follow._FALSE_in_filterExpr281);  		DebugLocation (137' 4);  		filterNode = new Value (false);  	}  	break;  case 9:  	DebugEnterAlt (9);  	// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  	{  		DebugLocation (140' 4);  		Match (input' NULL' Follow._NULL_in_filterExpr291);  		DebugLocation (141' 4);  		filterNode = new Value (null);  	}  	break;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: switch (alt9) {  case 1:  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  	{  		DebugLocation (64' 4);  		DebugLocation (64' 6);  		PushFollow (Follow._comparator_in_filterExpr175);  		comparator6 = comparator ();  		PopFollow ();  		Match (input' TokenTypes.Down' null);  		DebugLocation (64' 18);  		PushFollow (Follow._filterExpr_in_filterExpr179);  		a = filterExpr ();  		PopFollow ();  		DebugLocation (64' 31);  		PushFollow (Follow._filterExpr_in_filterExpr183);  		b = filterExpr ();  		PopFollow ();  		Match (input' TokenTypes.Up' null);  		DebugLocation (65' 4);  		Comparator newComparator;  		switch (comparator6) {  		case "=":  			newComparator = Comparator.Equals;  			break;  		case "!=":  			newComparator = Comparator.NotEquals;  			break;  		case ">":  			newComparator = Comparator.Greater;  			break;  		case "<":  			newComparator = Comparator.Less;  			break;  		case ">=":  			newComparator = Comparator.GreaterOrEqual;  			break;  		case "<=":  			newComparator = Comparator.LessOrEqual;  			break;  		case "&":  			newComparator = Comparator.And;  			break;  		case "|":  			newComparator = Comparator.Or;  			break;  		default:  			newComparator = Comparator.Equals;  			break;  		}  		filterNode = new BoolExpression (a' newComparator' b);  	}  	break;  case 2:  	DebugEnterAlt (2);  	// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  	{  		DebugLocation (98' 4);  		DebugLocation (98' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr195);  		Match (input' TokenTypes.Down' null);  		DebugLocation (98' 12);  		PushFollow (Follow._filterExpr_in_filterExpr199);  		f = filterExpr ();  		PopFollow ();  		DebugLocation (98' 31);  		// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  		int alt6 = 2;  		try {  			DebugEnterSubRule (6);  			try {  				DebugEnterDecision (6' false);  				int LA6_1 = input.LA (1);  				if ((LA6_1 == 24)) {  					alt6 = 1;  				}  			}  			finally {  				DebugExitDecision (6);  			}  			switch (alt6) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  				{  					DebugLocation (98' 31);  					inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (6);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (99' 4);  		FilterTreeNode newNode = f;  		if ((inverse != null ? inverse.Text : default(string)) == "!")  			newNode.ToggleInversed ();  		filterNode = newNode;  	}  	break;  case 3:  	DebugEnterAlt (3);  	// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  	{  		DebugLocation (105' 4);  		DebugLocation (105' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr216);  		Match (input' TokenTypes.Down' null);  		DebugLocation (105' 12);  		PushFollow (Follow._propertyChain_in_filterExpr219);  		propertyChain (propertySegments);  		PopFollow ();  		DebugLocation (105' 51);  		// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  		int alt7 = 2;  		try {  			DebugEnterSubRule (7);  			try {  				DebugEnterDecision (7' false);  				int LA7_1 = input.LA (1);  				if ((LA7_1 == 31)) {  					alt7 = 1;  				}  			}  			finally {  				DebugExitDecision (7);  			}  			switch (alt7) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  				{  					DebugLocation (105' 51);  					inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (7);  		}  		DebugLocation (105' 60);  		// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  		int alt8 = 2;  		try {  			DebugEnterSubRule (8);  			try {  				DebugEnterDecision (8' false);  				int LA8_1 = input.LA (1);  				if ((LA8_1 == 24)) {  					alt8 = 1;  				}  			}  			finally {  				DebugExitDecision (8);  			}  			switch (alt8) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  				{  					DebugLocation (105' 60);  					not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (8);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (106' 4);  		FilterTreeNode newProperty = new Property (propertySegments);  		if ((inverse != null ? inverse.Text : default(string)) == "?")  			filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  		else {  			if ((not != null ? not.Text : default(string)) == "!")  				newProperty.ToggleInversed ();  			filterNode = newProperty;  		}  	}  	break;  case 4:  	DebugEnterAlt (4);  	// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  	{  		DebugLocation (116' 4);  		STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  		DebugLocation (117' 4);  		string stringText = (STRING7 != null ? STRING7.Text : default(string));  		stringText = stringText.Substring (1' stringText.Length - 2);  		filterNode = new Value (stringText);  	}  	break;  case 5:  	DebugEnterAlt (5);  	// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  	{  		DebugLocation (122' 4);  		REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  		DebugLocation (123' 4);  		string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  		regexText = regexText.Substring (1' regexText.Length - 2);  		filterNode = new RegExp (regexText);  	}  	break;  case 6:  	DebugEnterAlt (6);  	// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  	{  		DebugLocation (128' 4);  		NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  		DebugLocation (129' 4);  		filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  	}  	break;  case 7:  	DebugEnterAlt (7);  	// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  	{  		DebugLocation (132' 4);  		Match (input' TRUE' Follow._TRUE_in_filterExpr271);  		DebugLocation (133' 4);  		filterNode = new Value (true);  	}  	break;  case 8:  	DebugEnterAlt (8);  	// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  	{  		DebugLocation (136' 4);  		Match (input' FALSE' Follow._FALSE_in_filterExpr281);  		DebugLocation (137' 4);  		filterNode = new Value (false);  	}  	break;  case 9:  	DebugEnterAlt (9);  	// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  	{  		DebugLocation (140' 4);  		Match (input' NULL' Follow._NULL_in_filterExpr291);  		DebugLocation (141' 4);  		filterNode = new Value (null);  	}  	break;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: switch (alt9) {  case 1:  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  	{  		DebugLocation (64' 4);  		DebugLocation (64' 6);  		PushFollow (Follow._comparator_in_filterExpr175);  		comparator6 = comparator ();  		PopFollow ();  		Match (input' TokenTypes.Down' null);  		DebugLocation (64' 18);  		PushFollow (Follow._filterExpr_in_filterExpr179);  		a = filterExpr ();  		PopFollow ();  		DebugLocation (64' 31);  		PushFollow (Follow._filterExpr_in_filterExpr183);  		b = filterExpr ();  		PopFollow ();  		Match (input' TokenTypes.Up' null);  		DebugLocation (65' 4);  		Comparator newComparator;  		switch (comparator6) {  		case "=":  			newComparator = Comparator.Equals;  			break;  		case "!=":  			newComparator = Comparator.NotEquals;  			break;  		case ">":  			newComparator = Comparator.Greater;  			break;  		case "<":  			newComparator = Comparator.Less;  			break;  		case ">=":  			newComparator = Comparator.GreaterOrEqual;  			break;  		case "<=":  			newComparator = Comparator.LessOrEqual;  			break;  		case "&":  			newComparator = Comparator.And;  			break;  		case "|":  			newComparator = Comparator.Or;  			break;  		default:  			newComparator = Comparator.Equals;  			break;  		}  		filterNode = new BoolExpression (a' newComparator' b);  	}  	break;  case 2:  	DebugEnterAlt (2);  	// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  	{  		DebugLocation (98' 4);  		DebugLocation (98' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr195);  		Match (input' TokenTypes.Down' null);  		DebugLocation (98' 12);  		PushFollow (Follow._filterExpr_in_filterExpr199);  		f = filterExpr ();  		PopFollow ();  		DebugLocation (98' 31);  		// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  		int alt6 = 2;  		try {  			DebugEnterSubRule (6);  			try {  				DebugEnterDecision (6' false);  				int LA6_1 = input.LA (1);  				if ((LA6_1 == 24)) {  					alt6 = 1;  				}  			}  			finally {  				DebugExitDecision (6);  			}  			switch (alt6) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  				{  					DebugLocation (98' 31);  					inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (6);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (99' 4);  		FilterTreeNode newNode = f;  		if ((inverse != null ? inverse.Text : default(string)) == "!")  			newNode.ToggleInversed ();  		filterNode = newNode;  	}  	break;  case 3:  	DebugEnterAlt (3);  	// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  	{  		DebugLocation (105' 4);  		DebugLocation (105' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr216);  		Match (input' TokenTypes.Down' null);  		DebugLocation (105' 12);  		PushFollow (Follow._propertyChain_in_filterExpr219);  		propertyChain (propertySegments);  		PopFollow ();  		DebugLocation (105' 51);  		// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  		int alt7 = 2;  		try {  			DebugEnterSubRule (7);  			try {  				DebugEnterDecision (7' false);  				int LA7_1 = input.LA (1);  				if ((LA7_1 == 31)) {  					alt7 = 1;  				}  			}  			finally {  				DebugExitDecision (7);  			}  			switch (alt7) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  				{  					DebugLocation (105' 51);  					inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (7);  		}  		DebugLocation (105' 60);  		// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  		int alt8 = 2;  		try {  			DebugEnterSubRule (8);  			try {  				DebugEnterDecision (8' false);  				int LA8_1 = input.LA (1);  				if ((LA8_1 == 24)) {  					alt8 = 1;  				}  			}  			finally {  				DebugExitDecision (8);  			}  			switch (alt8) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  				{  					DebugLocation (105' 60);  					not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (8);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (106' 4);  		FilterTreeNode newProperty = new Property (propertySegments);  		if ((inverse != null ? inverse.Text : default(string)) == "?")  			filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  		else {  			if ((not != null ? not.Text : default(string)) == "!")  				newProperty.ToggleInversed ();  			filterNode = newProperty;  		}  	}  	break;  case 4:  	DebugEnterAlt (4);  	// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  	{  		DebugLocation (116' 4);  		STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  		DebugLocation (117' 4);  		string stringText = (STRING7 != null ? STRING7.Text : default(string));  		stringText = stringText.Substring (1' stringText.Length - 2);  		filterNode = new Value (stringText);  	}  	break;  case 5:  	DebugEnterAlt (5);  	// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  	{  		DebugLocation (122' 4);  		REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  		DebugLocation (123' 4);  		string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  		regexText = regexText.Substring (1' regexText.Length - 2);  		filterNode = new RegExp (regexText);  	}  	break;  case 6:  	DebugEnterAlt (6);  	// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  	{  		DebugLocation (128' 4);  		NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  		DebugLocation (129' 4);  		filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  	}  	break;  case 7:  	DebugEnterAlt (7);  	// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  	{  		DebugLocation (132' 4);  		Match (input' TRUE' Follow._TRUE_in_filterExpr271);  		DebugLocation (133' 4);  		filterNode = new Value (true);  	}  	break;  case 8:  	DebugEnterAlt (8);  	// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  	{  		DebugLocation (136' 4);  		Match (input' FALSE' Follow._FALSE_in_filterExpr281);  		DebugLocation (137' 4);  		filterNode = new Value (false);  	}  	break;  case 9:  	DebugEnterAlt (9);  	// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  	{  		DebugLocation (140' 4);  		Match (input' NULL' Follow._NULL_in_filterExpr291);  		DebugLocation (141' 4);  		filterNode = new Value (null);  	}  	break;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: switch (alt9) {  case 1:  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  	{  		DebugLocation (64' 4);  		DebugLocation (64' 6);  		PushFollow (Follow._comparator_in_filterExpr175);  		comparator6 = comparator ();  		PopFollow ();  		Match (input' TokenTypes.Down' null);  		DebugLocation (64' 18);  		PushFollow (Follow._filterExpr_in_filterExpr179);  		a = filterExpr ();  		PopFollow ();  		DebugLocation (64' 31);  		PushFollow (Follow._filterExpr_in_filterExpr183);  		b = filterExpr ();  		PopFollow ();  		Match (input' TokenTypes.Up' null);  		DebugLocation (65' 4);  		Comparator newComparator;  		switch (comparator6) {  		case "=":  			newComparator = Comparator.Equals;  			break;  		case "!=":  			newComparator = Comparator.NotEquals;  			break;  		case ">":  			newComparator = Comparator.Greater;  			break;  		case "<":  			newComparator = Comparator.Less;  			break;  		case ">=":  			newComparator = Comparator.GreaterOrEqual;  			break;  		case "<=":  			newComparator = Comparator.LessOrEqual;  			break;  		case "&":  			newComparator = Comparator.And;  			break;  		case "|":  			newComparator = Comparator.Or;  			break;  		default:  			newComparator = Comparator.Equals;  			break;  		}  		filterNode = new BoolExpression (a' newComparator' b);  	}  	break;  case 2:  	DebugEnterAlt (2);  	// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  	{  		DebugLocation (98' 4);  		DebugLocation (98' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr195);  		Match (input' TokenTypes.Down' null);  		DebugLocation (98' 12);  		PushFollow (Follow._filterExpr_in_filterExpr199);  		f = filterExpr ();  		PopFollow ();  		DebugLocation (98' 31);  		// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  		int alt6 = 2;  		try {  			DebugEnterSubRule (6);  			try {  				DebugEnterDecision (6' false);  				int LA6_1 = input.LA (1);  				if ((LA6_1 == 24)) {  					alt6 = 1;  				}  			}  			finally {  				DebugExitDecision (6);  			}  			switch (alt6) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  				{  					DebugLocation (98' 31);  					inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (6);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (99' 4);  		FilterTreeNode newNode = f;  		if ((inverse != null ? inverse.Text : default(string)) == "!")  			newNode.ToggleInversed ();  		filterNode = newNode;  	}  	break;  case 3:  	DebugEnterAlt (3);  	// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  	{  		DebugLocation (105' 4);  		DebugLocation (105' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr216);  		Match (input' TokenTypes.Down' null);  		DebugLocation (105' 12);  		PushFollow (Follow._propertyChain_in_filterExpr219);  		propertyChain (propertySegments);  		PopFollow ();  		DebugLocation (105' 51);  		// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  		int alt7 = 2;  		try {  			DebugEnterSubRule (7);  			try {  				DebugEnterDecision (7' false);  				int LA7_1 = input.LA (1);  				if ((LA7_1 == 31)) {  					alt7 = 1;  				}  			}  			finally {  				DebugExitDecision (7);  			}  			switch (alt7) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  				{  					DebugLocation (105' 51);  					inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (7);  		}  		DebugLocation (105' 60);  		// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  		int alt8 = 2;  		try {  			DebugEnterSubRule (8);  			try {  				DebugEnterDecision (8' false);  				int LA8_1 = input.LA (1);  				if ((LA8_1 == 24)) {  					alt8 = 1;  				}  			}  			finally {  				DebugExitDecision (8);  			}  			switch (alt8) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  				{  					DebugLocation (105' 60);  					not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (8);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (106' 4);  		FilterTreeNode newProperty = new Property (propertySegments);  		if ((inverse != null ? inverse.Text : default(string)) == "?")  			filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  		else {  			if ((not != null ? not.Text : default(string)) == "!")  				newProperty.ToggleInversed ();  			filterNode = newProperty;  		}  	}  	break;  case 4:  	DebugEnterAlt (4);  	// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  	{  		DebugLocation (116' 4);  		STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  		DebugLocation (117' 4);  		string stringText = (STRING7 != null ? STRING7.Text : default(string));  		stringText = stringText.Substring (1' stringText.Length - 2);  		filterNode = new Value (stringText);  	}  	break;  case 5:  	DebugEnterAlt (5);  	// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  	{  		DebugLocation (122' 4);  		REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  		DebugLocation (123' 4);  		string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  		regexText = regexText.Substring (1' regexText.Length - 2);  		filterNode = new RegExp (regexText);  	}  	break;  case 6:  	DebugEnterAlt (6);  	// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  	{  		DebugLocation (128' 4);  		NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  		DebugLocation (129' 4);  		filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  	}  	break;  case 7:  	DebugEnterAlt (7);  	// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  	{  		DebugLocation (132' 4);  		Match (input' TRUE' Follow._TRUE_in_filterExpr271);  		DebugLocation (133' 4);  		filterNode = new Value (true);  	}  	break;  case 8:  	DebugEnterAlt (8);  	// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  	{  		DebugLocation (136' 4);  		Match (input' FALSE' Follow._FALSE_in_filterExpr281);  		DebugLocation (137' 4);  		filterNode = new Value (false);  	}  	break;  case 9:  	DebugEnterAlt (9);  	// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  	{  		DebugLocation (140' 4);  		Match (input' NULL' Follow._NULL_in_filterExpr291);  		DebugLocation (141' 4);  		filterNode = new Value (null);  	}  	break;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: switch (alt9) {  case 1:  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  	{  		DebugLocation (64' 4);  		DebugLocation (64' 6);  		PushFollow (Follow._comparator_in_filterExpr175);  		comparator6 = comparator ();  		PopFollow ();  		Match (input' TokenTypes.Down' null);  		DebugLocation (64' 18);  		PushFollow (Follow._filterExpr_in_filterExpr179);  		a = filterExpr ();  		PopFollow ();  		DebugLocation (64' 31);  		PushFollow (Follow._filterExpr_in_filterExpr183);  		b = filterExpr ();  		PopFollow ();  		Match (input' TokenTypes.Up' null);  		DebugLocation (65' 4);  		Comparator newComparator;  		switch (comparator6) {  		case "=":  			newComparator = Comparator.Equals;  			break;  		case "!=":  			newComparator = Comparator.NotEquals;  			break;  		case ">":  			newComparator = Comparator.Greater;  			break;  		case "<":  			newComparator = Comparator.Less;  			break;  		case ">=":  			newComparator = Comparator.GreaterOrEqual;  			break;  		case "<=":  			newComparator = Comparator.LessOrEqual;  			break;  		case "&":  			newComparator = Comparator.And;  			break;  		case "|":  			newComparator = Comparator.Or;  			break;  		default:  			newComparator = Comparator.Equals;  			break;  		}  		filterNode = new BoolExpression (a' newComparator' b);  	}  	break;  case 2:  	DebugEnterAlt (2);  	// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  	{  		DebugLocation (98' 4);  		DebugLocation (98' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr195);  		Match (input' TokenTypes.Down' null);  		DebugLocation (98' 12);  		PushFollow (Follow._filterExpr_in_filterExpr199);  		f = filterExpr ();  		PopFollow ();  		DebugLocation (98' 31);  		// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  		int alt6 = 2;  		try {  			DebugEnterSubRule (6);  			try {  				DebugEnterDecision (6' false);  				int LA6_1 = input.LA (1);  				if ((LA6_1 == 24)) {  					alt6 = 1;  				}  			}  			finally {  				DebugExitDecision (6);  			}  			switch (alt6) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  				{  					DebugLocation (98' 31);  					inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (6);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (99' 4);  		FilterTreeNode newNode = f;  		if ((inverse != null ? inverse.Text : default(string)) == "!")  			newNode.ToggleInversed ();  		filterNode = newNode;  	}  	break;  case 3:  	DebugEnterAlt (3);  	// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  	{  		DebugLocation (105' 4);  		DebugLocation (105' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr216);  		Match (input' TokenTypes.Down' null);  		DebugLocation (105' 12);  		PushFollow (Follow._propertyChain_in_filterExpr219);  		propertyChain (propertySegments);  		PopFollow ();  		DebugLocation (105' 51);  		// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  		int alt7 = 2;  		try {  			DebugEnterSubRule (7);  			try {  				DebugEnterDecision (7' false);  				int LA7_1 = input.LA (1);  				if ((LA7_1 == 31)) {  					alt7 = 1;  				}  			}  			finally {  				DebugExitDecision (7);  			}  			switch (alt7) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  				{  					DebugLocation (105' 51);  					inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (7);  		}  		DebugLocation (105' 60);  		// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  		int alt8 = 2;  		try {  			DebugEnterSubRule (8);  			try {  				DebugEnterDecision (8' false);  				int LA8_1 = input.LA (1);  				if ((LA8_1 == 24)) {  					alt8 = 1;  				}  			}  			finally {  				DebugExitDecision (8);  			}  			switch (alt8) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  				{  					DebugLocation (105' 60);  					not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (8);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (106' 4);  		FilterTreeNode newProperty = new Property (propertySegments);  		if ((inverse != null ? inverse.Text : default(string)) == "?")  			filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  		else {  			if ((not != null ? not.Text : default(string)) == "!")  				newProperty.ToggleInversed ();  			filterNode = newProperty;  		}  	}  	break;  case 4:  	DebugEnterAlt (4);  	// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  	{  		DebugLocation (116' 4);  		STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  		DebugLocation (117' 4);  		string stringText = (STRING7 != null ? STRING7.Text : default(string));  		stringText = stringText.Substring (1' stringText.Length - 2);  		filterNode = new Value (stringText);  	}  	break;  case 5:  	DebugEnterAlt (5);  	// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  	{  		DebugLocation (122' 4);  		REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  		DebugLocation (123' 4);  		string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  		regexText = regexText.Substring (1' regexText.Length - 2);  		filterNode = new RegExp (regexText);  	}  	break;  case 6:  	DebugEnterAlt (6);  	// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  	{  		DebugLocation (128' 4);  		NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  		DebugLocation (129' 4);  		filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  	}  	break;  case 7:  	DebugEnterAlt (7);  	// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  	{  		DebugLocation (132' 4);  		Match (input' TRUE' Follow._TRUE_in_filterExpr271);  		DebugLocation (133' 4);  		filterNode = new Value (true);  	}  	break;  case 8:  	DebugEnterAlt (8);  	// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  	{  		DebugLocation (136' 4);  		Match (input' FALSE' Follow._FALSE_in_filterExpr281);  		DebugLocation (137' 4);  		filterNode = new Value (false);  	}  	break;  case 9:  	DebugEnterAlt (9);  	// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  	{  		DebugLocation (140' 4);  		Match (input' NULL' Follow._NULL_in_filterExpr291);  		DebugLocation (141' 4);  		filterNode = new Value (null);  	}  	break;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: switch (alt9) {  case 1:  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  	{  		DebugLocation (64' 4);  		DebugLocation (64' 6);  		PushFollow (Follow._comparator_in_filterExpr175);  		comparator6 = comparator ();  		PopFollow ();  		Match (input' TokenTypes.Down' null);  		DebugLocation (64' 18);  		PushFollow (Follow._filterExpr_in_filterExpr179);  		a = filterExpr ();  		PopFollow ();  		DebugLocation (64' 31);  		PushFollow (Follow._filterExpr_in_filterExpr183);  		b = filterExpr ();  		PopFollow ();  		Match (input' TokenTypes.Up' null);  		DebugLocation (65' 4);  		Comparator newComparator;  		switch (comparator6) {  		case "=":  			newComparator = Comparator.Equals;  			break;  		case "!=":  			newComparator = Comparator.NotEquals;  			break;  		case ">":  			newComparator = Comparator.Greater;  			break;  		case "<":  			newComparator = Comparator.Less;  			break;  		case ">=":  			newComparator = Comparator.GreaterOrEqual;  			break;  		case "<=":  			newComparator = Comparator.LessOrEqual;  			break;  		case "&":  			newComparator = Comparator.And;  			break;  		case "|":  			newComparator = Comparator.Or;  			break;  		default:  			newComparator = Comparator.Equals;  			break;  		}  		filterNode = new BoolExpression (a' newComparator' b);  	}  	break;  case 2:  	DebugEnterAlt (2);  	// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  	{  		DebugLocation (98' 4);  		DebugLocation (98' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr195);  		Match (input' TokenTypes.Down' null);  		DebugLocation (98' 12);  		PushFollow (Follow._filterExpr_in_filterExpr199);  		f = filterExpr ();  		PopFollow ();  		DebugLocation (98' 31);  		// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  		int alt6 = 2;  		try {  			DebugEnterSubRule (6);  			try {  				DebugEnterDecision (6' false);  				int LA6_1 = input.LA (1);  				if ((LA6_1 == 24)) {  					alt6 = 1;  				}  			}  			finally {  				DebugExitDecision (6);  			}  			switch (alt6) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  				{  					DebugLocation (98' 31);  					inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (6);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (99' 4);  		FilterTreeNode newNode = f;  		if ((inverse != null ? inverse.Text : default(string)) == "!")  			newNode.ToggleInversed ();  		filterNode = newNode;  	}  	break;  case 3:  	DebugEnterAlt (3);  	// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  	{  		DebugLocation (105' 4);  		DebugLocation (105' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr216);  		Match (input' TokenTypes.Down' null);  		DebugLocation (105' 12);  		PushFollow (Follow._propertyChain_in_filterExpr219);  		propertyChain (propertySegments);  		PopFollow ();  		DebugLocation (105' 51);  		// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  		int alt7 = 2;  		try {  			DebugEnterSubRule (7);  			try {  				DebugEnterDecision (7' false);  				int LA7_1 = input.LA (1);  				if ((LA7_1 == 31)) {  					alt7 = 1;  				}  			}  			finally {  				DebugExitDecision (7);  			}  			switch (alt7) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  				{  					DebugLocation (105' 51);  					inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (7);  		}  		DebugLocation (105' 60);  		// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  		int alt8 = 2;  		try {  			DebugEnterSubRule (8);  			try {  				DebugEnterDecision (8' false);  				int LA8_1 = input.LA (1);  				if ((LA8_1 == 24)) {  					alt8 = 1;  				}  			}  			finally {  				DebugExitDecision (8);  			}  			switch (alt8) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  				{  					DebugLocation (105' 60);  					not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (8);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (106' 4);  		FilterTreeNode newProperty = new Property (propertySegments);  		if ((inverse != null ? inverse.Text : default(string)) == "?")  			filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  		else {  			if ((not != null ? not.Text : default(string)) == "!")  				newProperty.ToggleInversed ();  			filterNode = newProperty;  		}  	}  	break;  case 4:  	DebugEnterAlt (4);  	// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  	{  		DebugLocation (116' 4);  		STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  		DebugLocation (117' 4);  		string stringText = (STRING7 != null ? STRING7.Text : default(string));  		stringText = stringText.Substring (1' stringText.Length - 2);  		filterNode = new Value (stringText);  	}  	break;  case 5:  	DebugEnterAlt (5);  	// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  	{  		DebugLocation (122' 4);  		REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  		DebugLocation (123' 4);  		string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  		regexText = regexText.Substring (1' regexText.Length - 2);  		filterNode = new RegExp (regexText);  	}  	break;  case 6:  	DebugEnterAlt (6);  	// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  	{  		DebugLocation (128' 4);  		NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  		DebugLocation (129' 4);  		filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  	}  	break;  case 7:  	DebugEnterAlt (7);  	// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  	{  		DebugLocation (132' 4);  		Match (input' TRUE' Follow._TRUE_in_filterExpr271);  		DebugLocation (133' 4);  		filterNode = new Value (true);  	}  	break;  case 8:  	DebugEnterAlt (8);  	// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  	{  		DebugLocation (136' 4);  		Match (input' FALSE' Follow._FALSE_in_filterExpr281);  		DebugLocation (137' 4);  		filterNode = new Value (false);  	}  	break;  case 9:  	DebugEnterAlt (9);  	// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  	{  		DebugLocation (140' 4);  		Match (input' NULL' Follow._NULL_in_filterExpr291);  		DebugLocation (141' 4);  		filterNode = new Value (null);  	}  	break;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: switch (alt9) {  case 1:  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  	{  		DebugLocation (64' 4);  		DebugLocation (64' 6);  		PushFollow (Follow._comparator_in_filterExpr175);  		comparator6 = comparator ();  		PopFollow ();  		Match (input' TokenTypes.Down' null);  		DebugLocation (64' 18);  		PushFollow (Follow._filterExpr_in_filterExpr179);  		a = filterExpr ();  		PopFollow ();  		DebugLocation (64' 31);  		PushFollow (Follow._filterExpr_in_filterExpr183);  		b = filterExpr ();  		PopFollow ();  		Match (input' TokenTypes.Up' null);  		DebugLocation (65' 4);  		Comparator newComparator;  		switch (comparator6) {  		case "=":  			newComparator = Comparator.Equals;  			break;  		case "!=":  			newComparator = Comparator.NotEquals;  			break;  		case ">":  			newComparator = Comparator.Greater;  			break;  		case "<":  			newComparator = Comparator.Less;  			break;  		case ">=":  			newComparator = Comparator.GreaterOrEqual;  			break;  		case "<=":  			newComparator = Comparator.LessOrEqual;  			break;  		case "&":  			newComparator = Comparator.And;  			break;  		case "|":  			newComparator = Comparator.Or;  			break;  		default:  			newComparator = Comparator.Equals;  			break;  		}  		filterNode = new BoolExpression (a' newComparator' b);  	}  	break;  case 2:  	DebugEnterAlt (2);  	// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  	{  		DebugLocation (98' 4);  		DebugLocation (98' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr195);  		Match (input' TokenTypes.Down' null);  		DebugLocation (98' 12);  		PushFollow (Follow._filterExpr_in_filterExpr199);  		f = filterExpr ();  		PopFollow ();  		DebugLocation (98' 31);  		// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  		int alt6 = 2;  		try {  			DebugEnterSubRule (6);  			try {  				DebugEnterDecision (6' false);  				int LA6_1 = input.LA (1);  				if ((LA6_1 == 24)) {  					alt6 = 1;  				}  			}  			finally {  				DebugExitDecision (6);  			}  			switch (alt6) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  				{  					DebugLocation (98' 31);  					inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (6);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (99' 4);  		FilterTreeNode newNode = f;  		if ((inverse != null ? inverse.Text : default(string)) == "!")  			newNode.ToggleInversed ();  		filterNode = newNode;  	}  	break;  case 3:  	DebugEnterAlt (3);  	// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  	{  		DebugLocation (105' 4);  		DebugLocation (105' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr216);  		Match (input' TokenTypes.Down' null);  		DebugLocation (105' 12);  		PushFollow (Follow._propertyChain_in_filterExpr219);  		propertyChain (propertySegments);  		PopFollow ();  		DebugLocation (105' 51);  		// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  		int alt7 = 2;  		try {  			DebugEnterSubRule (7);  			try {  				DebugEnterDecision (7' false);  				int LA7_1 = input.LA (1);  				if ((LA7_1 == 31)) {  					alt7 = 1;  				}  			}  			finally {  				DebugExitDecision (7);  			}  			switch (alt7) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  				{  					DebugLocation (105' 51);  					inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (7);  		}  		DebugLocation (105' 60);  		// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  		int alt8 = 2;  		try {  			DebugEnterSubRule (8);  			try {  				DebugEnterDecision (8' false);  				int LA8_1 = input.LA (1);  				if ((LA8_1 == 24)) {  					alt8 = 1;  				}  			}  			finally {  				DebugExitDecision (8);  			}  			switch (alt8) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  				{  					DebugLocation (105' 60);  					not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (8);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (106' 4);  		FilterTreeNode newProperty = new Property (propertySegments);  		if ((inverse != null ? inverse.Text : default(string)) == "?")  			filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  		else {  			if ((not != null ? not.Text : default(string)) == "!")  				newProperty.ToggleInversed ();  			filterNode = newProperty;  		}  	}  	break;  case 4:  	DebugEnterAlt (4);  	// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  	{  		DebugLocation (116' 4);  		STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  		DebugLocation (117' 4);  		string stringText = (STRING7 != null ? STRING7.Text : default(string));  		stringText = stringText.Substring (1' stringText.Length - 2);  		filterNode = new Value (stringText);  	}  	break;  case 5:  	DebugEnterAlt (5);  	// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  	{  		DebugLocation (122' 4);  		REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  		DebugLocation (123' 4);  		string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  		regexText = regexText.Substring (1' regexText.Length - 2);  		filterNode = new RegExp (regexText);  	}  	break;  case 6:  	DebugEnterAlt (6);  	// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  	{  		DebugLocation (128' 4);  		NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  		DebugLocation (129' 4);  		filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  	}  	break;  case 7:  	DebugEnterAlt (7);  	// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  	{  		DebugLocation (132' 4);  		Match (input' TRUE' Follow._TRUE_in_filterExpr271);  		DebugLocation (133' 4);  		filterNode = new Value (true);  	}  	break;  case 8:  	DebugEnterAlt (8);  	// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  	{  		DebugLocation (136' 4);  		Match (input' FALSE' Follow._FALSE_in_filterExpr281);  		DebugLocation (137' 4);  		filterNode = new Value (false);  	}  	break;  case 9:  	DebugEnterAlt (9);  	// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  	{  		DebugLocation (140' 4);  		Match (input' NULL' Follow._NULL_in_filterExpr291);  		DebugLocation (141' 4);  		filterNode = new Value (null);  	}  	break;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: switch (alt9) {  case 1:  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  	{  		DebugLocation (64' 4);  		DebugLocation (64' 6);  		PushFollow (Follow._comparator_in_filterExpr175);  		comparator6 = comparator ();  		PopFollow ();  		Match (input' TokenTypes.Down' null);  		DebugLocation (64' 18);  		PushFollow (Follow._filterExpr_in_filterExpr179);  		a = filterExpr ();  		PopFollow ();  		DebugLocation (64' 31);  		PushFollow (Follow._filterExpr_in_filterExpr183);  		b = filterExpr ();  		PopFollow ();  		Match (input' TokenTypes.Up' null);  		DebugLocation (65' 4);  		Comparator newComparator;  		switch (comparator6) {  		case "=":  			newComparator = Comparator.Equals;  			break;  		case "!=":  			newComparator = Comparator.NotEquals;  			break;  		case ">":  			newComparator = Comparator.Greater;  			break;  		case "<":  			newComparator = Comparator.Less;  			break;  		case ">=":  			newComparator = Comparator.GreaterOrEqual;  			break;  		case "<=":  			newComparator = Comparator.LessOrEqual;  			break;  		case "&":  			newComparator = Comparator.And;  			break;  		case "|":  			newComparator = Comparator.Or;  			break;  		default:  			newComparator = Comparator.Equals;  			break;  		}  		filterNode = new BoolExpression (a' newComparator' b);  	}  	break;  case 2:  	DebugEnterAlt (2);  	// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  	{  		DebugLocation (98' 4);  		DebugLocation (98' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr195);  		Match (input' TokenTypes.Down' null);  		DebugLocation (98' 12);  		PushFollow (Follow._filterExpr_in_filterExpr199);  		f = filterExpr ();  		PopFollow ();  		DebugLocation (98' 31);  		// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  		int alt6 = 2;  		try {  			DebugEnterSubRule (6);  			try {  				DebugEnterDecision (6' false);  				int LA6_1 = input.LA (1);  				if ((LA6_1 == 24)) {  					alt6 = 1;  				}  			}  			finally {  				DebugExitDecision (6);  			}  			switch (alt6) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  				{  					DebugLocation (98' 31);  					inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (6);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (99' 4);  		FilterTreeNode newNode = f;  		if ((inverse != null ? inverse.Text : default(string)) == "!")  			newNode.ToggleInversed ();  		filterNode = newNode;  	}  	break;  case 3:  	DebugEnterAlt (3);  	// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  	{  		DebugLocation (105' 4);  		DebugLocation (105' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr216);  		Match (input' TokenTypes.Down' null);  		DebugLocation (105' 12);  		PushFollow (Follow._propertyChain_in_filterExpr219);  		propertyChain (propertySegments);  		PopFollow ();  		DebugLocation (105' 51);  		// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  		int alt7 = 2;  		try {  			DebugEnterSubRule (7);  			try {  				DebugEnterDecision (7' false);  				int LA7_1 = input.LA (1);  				if ((LA7_1 == 31)) {  					alt7 = 1;  				}  			}  			finally {  				DebugExitDecision (7);  			}  			switch (alt7) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  				{  					DebugLocation (105' 51);  					inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (7);  		}  		DebugLocation (105' 60);  		// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  		int alt8 = 2;  		try {  			DebugEnterSubRule (8);  			try {  				DebugEnterDecision (8' false);  				int LA8_1 = input.LA (1);  				if ((LA8_1 == 24)) {  					alt8 = 1;  				}  			}  			finally {  				DebugExitDecision (8);  			}  			switch (alt8) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  				{  					DebugLocation (105' 60);  					not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (8);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (106' 4);  		FilterTreeNode newProperty = new Property (propertySegments);  		if ((inverse != null ? inverse.Text : default(string)) == "?")  			filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  		else {  			if ((not != null ? not.Text : default(string)) == "!")  				newProperty.ToggleInversed ();  			filterNode = newProperty;  		}  	}  	break;  case 4:  	DebugEnterAlt (4);  	// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  	{  		DebugLocation (116' 4);  		STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  		DebugLocation (117' 4);  		string stringText = (STRING7 != null ? STRING7.Text : default(string));  		stringText = stringText.Substring (1' stringText.Length - 2);  		filterNode = new Value (stringText);  	}  	break;  case 5:  	DebugEnterAlt (5);  	// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  	{  		DebugLocation (122' 4);  		REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  		DebugLocation (123' 4);  		string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  		regexText = regexText.Substring (1' regexText.Length - 2);  		filterNode = new RegExp (regexText);  	}  	break;  case 6:  	DebugEnterAlt (6);  	// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  	{  		DebugLocation (128' 4);  		NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  		DebugLocation (129' 4);  		filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  	}  	break;  case 7:  	DebugEnterAlt (7);  	// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  	{  		DebugLocation (132' 4);  		Match (input' TRUE' Follow._TRUE_in_filterExpr271);  		DebugLocation (133' 4);  		filterNode = new Value (true);  	}  	break;  case 8:  	DebugEnterAlt (8);  	// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  	{  		DebugLocation (136' 4);  		Match (input' FALSE' Follow._FALSE_in_filterExpr281);  		DebugLocation (137' 4);  		filterNode = new Value (false);  	}  	break;  case 9:  	DebugEnterAlt (9);  	// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  	{  		DebugLocation (140' 4);  		Match (input' NULL' Follow._NULL_in_filterExpr291);  		DebugLocation (141' 4);  		filterNode = new Value (null);  	}  	break;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: switch (alt9) {  case 1:  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  	{  		DebugLocation (64' 4);  		DebugLocation (64' 6);  		PushFollow (Follow._comparator_in_filterExpr175);  		comparator6 = comparator ();  		PopFollow ();  		Match (input' TokenTypes.Down' null);  		DebugLocation (64' 18);  		PushFollow (Follow._filterExpr_in_filterExpr179);  		a = filterExpr ();  		PopFollow ();  		DebugLocation (64' 31);  		PushFollow (Follow._filterExpr_in_filterExpr183);  		b = filterExpr ();  		PopFollow ();  		Match (input' TokenTypes.Up' null);  		DebugLocation (65' 4);  		Comparator newComparator;  		switch (comparator6) {  		case "=":  			newComparator = Comparator.Equals;  			break;  		case "!=":  			newComparator = Comparator.NotEquals;  			break;  		case ">":  			newComparator = Comparator.Greater;  			break;  		case "<":  			newComparator = Comparator.Less;  			break;  		case ">=":  			newComparator = Comparator.GreaterOrEqual;  			break;  		case "<=":  			newComparator = Comparator.LessOrEqual;  			break;  		case "&":  			newComparator = Comparator.And;  			break;  		case "|":  			newComparator = Comparator.Or;  			break;  		default:  			newComparator = Comparator.Equals;  			break;  		}  		filterNode = new BoolExpression (a' newComparator' b);  	}  	break;  case 2:  	DebugEnterAlt (2);  	// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  	{  		DebugLocation (98' 4);  		DebugLocation (98' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr195);  		Match (input' TokenTypes.Down' null);  		DebugLocation (98' 12);  		PushFollow (Follow._filterExpr_in_filterExpr199);  		f = filterExpr ();  		PopFollow ();  		DebugLocation (98' 31);  		// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  		int alt6 = 2;  		try {  			DebugEnterSubRule (6);  			try {  				DebugEnterDecision (6' false);  				int LA6_1 = input.LA (1);  				if ((LA6_1 == 24)) {  					alt6 = 1;  				}  			}  			finally {  				DebugExitDecision (6);  			}  			switch (alt6) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  				{  					DebugLocation (98' 31);  					inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (6);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (99' 4);  		FilterTreeNode newNode = f;  		if ((inverse != null ? inverse.Text : default(string)) == "!")  			newNode.ToggleInversed ();  		filterNode = newNode;  	}  	break;  case 3:  	DebugEnterAlt (3);  	// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  	{  		DebugLocation (105' 4);  		DebugLocation (105' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr216);  		Match (input' TokenTypes.Down' null);  		DebugLocation (105' 12);  		PushFollow (Follow._propertyChain_in_filterExpr219);  		propertyChain (propertySegments);  		PopFollow ();  		DebugLocation (105' 51);  		// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  		int alt7 = 2;  		try {  			DebugEnterSubRule (7);  			try {  				DebugEnterDecision (7' false);  				int LA7_1 = input.LA (1);  				if ((LA7_1 == 31)) {  					alt7 = 1;  				}  			}  			finally {  				DebugExitDecision (7);  			}  			switch (alt7) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  				{  					DebugLocation (105' 51);  					inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (7);  		}  		DebugLocation (105' 60);  		// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  		int alt8 = 2;  		try {  			DebugEnterSubRule (8);  			try {  				DebugEnterDecision (8' false);  				int LA8_1 = input.LA (1);  				if ((LA8_1 == 24)) {  					alt8 = 1;  				}  			}  			finally {  				DebugExitDecision (8);  			}  			switch (alt8) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  				{  					DebugLocation (105' 60);  					not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (8);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (106' 4);  		FilterTreeNode newProperty = new Property (propertySegments);  		if ((inverse != null ? inverse.Text : default(string)) == "?")  			filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  		else {  			if ((not != null ? not.Text : default(string)) == "!")  				newProperty.ToggleInversed ();  			filterNode = newProperty;  		}  	}  	break;  case 4:  	DebugEnterAlt (4);  	// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  	{  		DebugLocation (116' 4);  		STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  		DebugLocation (117' 4);  		string stringText = (STRING7 != null ? STRING7.Text : default(string));  		stringText = stringText.Substring (1' stringText.Length - 2);  		filterNode = new Value (stringText);  	}  	break;  case 5:  	DebugEnterAlt (5);  	// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  	{  		DebugLocation (122' 4);  		REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  		DebugLocation (123' 4);  		string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  		regexText = regexText.Substring (1' regexText.Length - 2);  		filterNode = new RegExp (regexText);  	}  	break;  case 6:  	DebugEnterAlt (6);  	// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  	{  		DebugLocation (128' 4);  		NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  		DebugLocation (129' 4);  		filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  	}  	break;  case 7:  	DebugEnterAlt (7);  	// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  	{  		DebugLocation (132' 4);  		Match (input' TRUE' Follow._TRUE_in_filterExpr271);  		DebugLocation (133' 4);  		filterNode = new Value (true);  	}  	break;  case 8:  	DebugEnterAlt (8);  	// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  	{  		DebugLocation (136' 4);  		Match (input' FALSE' Follow._FALSE_in_filterExpr281);  		DebugLocation (137' 4);  		filterNode = new Value (false);  	}  	break;  case 9:  	DebugEnterAlt (9);  	// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  	{  		DebugLocation (140' 4);  		Match (input' NULL' Follow._NULL_in_filterExpr291);  		DebugLocation (141' 4);  		filterNode = new Value (null);  	}  	break;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: switch (alt9) {  case 1:  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  	{  		DebugLocation (64' 4);  		DebugLocation (64' 6);  		PushFollow (Follow._comparator_in_filterExpr175);  		comparator6 = comparator ();  		PopFollow ();  		Match (input' TokenTypes.Down' null);  		DebugLocation (64' 18);  		PushFollow (Follow._filterExpr_in_filterExpr179);  		a = filterExpr ();  		PopFollow ();  		DebugLocation (64' 31);  		PushFollow (Follow._filterExpr_in_filterExpr183);  		b = filterExpr ();  		PopFollow ();  		Match (input' TokenTypes.Up' null);  		DebugLocation (65' 4);  		Comparator newComparator;  		switch (comparator6) {  		case "=":  			newComparator = Comparator.Equals;  			break;  		case "!=":  			newComparator = Comparator.NotEquals;  			break;  		case ">":  			newComparator = Comparator.Greater;  			break;  		case "<":  			newComparator = Comparator.Less;  			break;  		case ">=":  			newComparator = Comparator.GreaterOrEqual;  			break;  		case "<=":  			newComparator = Comparator.LessOrEqual;  			break;  		case "&":  			newComparator = Comparator.And;  			break;  		case "|":  			newComparator = Comparator.Or;  			break;  		default:  			newComparator = Comparator.Equals;  			break;  		}  		filterNode = new BoolExpression (a' newComparator' b);  	}  	break;  case 2:  	DebugEnterAlt (2);  	// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  	{  		DebugLocation (98' 4);  		DebugLocation (98' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr195);  		Match (input' TokenTypes.Down' null);  		DebugLocation (98' 12);  		PushFollow (Follow._filterExpr_in_filterExpr199);  		f = filterExpr ();  		PopFollow ();  		DebugLocation (98' 31);  		// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  		int alt6 = 2;  		try {  			DebugEnterSubRule (6);  			try {  				DebugEnterDecision (6' false);  				int LA6_1 = input.LA (1);  				if ((LA6_1 == 24)) {  					alt6 = 1;  				}  			}  			finally {  				DebugExitDecision (6);  			}  			switch (alt6) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  				{  					DebugLocation (98' 31);  					inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (6);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (99' 4);  		FilterTreeNode newNode = f;  		if ((inverse != null ? inverse.Text : default(string)) == "!")  			newNode.ToggleInversed ();  		filterNode = newNode;  	}  	break;  case 3:  	DebugEnterAlt (3);  	// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  	{  		DebugLocation (105' 4);  		DebugLocation (105' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr216);  		Match (input' TokenTypes.Down' null);  		DebugLocation (105' 12);  		PushFollow (Follow._propertyChain_in_filterExpr219);  		propertyChain (propertySegments);  		PopFollow ();  		DebugLocation (105' 51);  		// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  		int alt7 = 2;  		try {  			DebugEnterSubRule (7);  			try {  				DebugEnterDecision (7' false);  				int LA7_1 = input.LA (1);  				if ((LA7_1 == 31)) {  					alt7 = 1;  				}  			}  			finally {  				DebugExitDecision (7);  			}  			switch (alt7) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  				{  					DebugLocation (105' 51);  					inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (7);  		}  		DebugLocation (105' 60);  		// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  		int alt8 = 2;  		try {  			DebugEnterSubRule (8);  			try {  				DebugEnterDecision (8' false);  				int LA8_1 = input.LA (1);  				if ((LA8_1 == 24)) {  					alt8 = 1;  				}  			}  			finally {  				DebugExitDecision (8);  			}  			switch (alt8) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  				{  					DebugLocation (105' 60);  					not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (8);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (106' 4);  		FilterTreeNode newProperty = new Property (propertySegments);  		if ((inverse != null ? inverse.Text : default(string)) == "?")  			filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  		else {  			if ((not != null ? not.Text : default(string)) == "!")  				newProperty.ToggleInversed ();  			filterNode = newProperty;  		}  	}  	break;  case 4:  	DebugEnterAlt (4);  	// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  	{  		DebugLocation (116' 4);  		STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  		DebugLocation (117' 4);  		string stringText = (STRING7 != null ? STRING7.Text : default(string));  		stringText = stringText.Substring (1' stringText.Length - 2);  		filterNode = new Value (stringText);  	}  	break;  case 5:  	DebugEnterAlt (5);  	// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  	{  		DebugLocation (122' 4);  		REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  		DebugLocation (123' 4);  		string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  		regexText = regexText.Substring (1' regexText.Length - 2);  		filterNode = new RegExp (regexText);  	}  	break;  case 6:  	DebugEnterAlt (6);  	// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  	{  		DebugLocation (128' 4);  		NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  		DebugLocation (129' 4);  		filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  	}  	break;  case 7:  	DebugEnterAlt (7);  	// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  	{  		DebugLocation (132' 4);  		Match (input' TRUE' Follow._TRUE_in_filterExpr271);  		DebugLocation (133' 4);  		filterNode = new Value (true);  	}  	break;  case 8:  	DebugEnterAlt (8);  	// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  	{  		DebugLocation (136' 4);  		Match (input' FALSE' Follow._FALSE_in_filterExpr281);  		DebugLocation (137' 4);  		filterNode = new Value (false);  	}  	break;  case 9:  	DebugEnterAlt (9);  	// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  	{  		DebugLocation (140' 4);  		Match (input' NULL' Follow._NULL_in_filterExpr291);  		DebugLocation (141' 4);  		filterNode = new Value (null);  	}  	break;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: switch (alt9) {  case 1:  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  	{  		DebugLocation (64' 4);  		DebugLocation (64' 6);  		PushFollow (Follow._comparator_in_filterExpr175);  		comparator6 = comparator ();  		PopFollow ();  		Match (input' TokenTypes.Down' null);  		DebugLocation (64' 18);  		PushFollow (Follow._filterExpr_in_filterExpr179);  		a = filterExpr ();  		PopFollow ();  		DebugLocation (64' 31);  		PushFollow (Follow._filterExpr_in_filterExpr183);  		b = filterExpr ();  		PopFollow ();  		Match (input' TokenTypes.Up' null);  		DebugLocation (65' 4);  		Comparator newComparator;  		switch (comparator6) {  		case "=":  			newComparator = Comparator.Equals;  			break;  		case "!=":  			newComparator = Comparator.NotEquals;  			break;  		case ">":  			newComparator = Comparator.Greater;  			break;  		case "<":  			newComparator = Comparator.Less;  			break;  		case ">=":  			newComparator = Comparator.GreaterOrEqual;  			break;  		case "<=":  			newComparator = Comparator.LessOrEqual;  			break;  		case "&":  			newComparator = Comparator.And;  			break;  		case "|":  			newComparator = Comparator.Or;  			break;  		default:  			newComparator = Comparator.Equals;  			break;  		}  		filterNode = new BoolExpression (a' newComparator' b);  	}  	break;  case 2:  	DebugEnterAlt (2);  	// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  	{  		DebugLocation (98' 4);  		DebugLocation (98' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr195);  		Match (input' TokenTypes.Down' null);  		DebugLocation (98' 12);  		PushFollow (Follow._filterExpr_in_filterExpr199);  		f = filterExpr ();  		PopFollow ();  		DebugLocation (98' 31);  		// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  		int alt6 = 2;  		try {  			DebugEnterSubRule (6);  			try {  				DebugEnterDecision (6' false);  				int LA6_1 = input.LA (1);  				if ((LA6_1 == 24)) {  					alt6 = 1;  				}  			}  			finally {  				DebugExitDecision (6);  			}  			switch (alt6) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  				{  					DebugLocation (98' 31);  					inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (6);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (99' 4);  		FilterTreeNode newNode = f;  		if ((inverse != null ? inverse.Text : default(string)) == "!")  			newNode.ToggleInversed ();  		filterNode = newNode;  	}  	break;  case 3:  	DebugEnterAlt (3);  	// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  	{  		DebugLocation (105' 4);  		DebugLocation (105' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr216);  		Match (input' TokenTypes.Down' null);  		DebugLocation (105' 12);  		PushFollow (Follow._propertyChain_in_filterExpr219);  		propertyChain (propertySegments);  		PopFollow ();  		DebugLocation (105' 51);  		// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  		int alt7 = 2;  		try {  			DebugEnterSubRule (7);  			try {  				DebugEnterDecision (7' false);  				int LA7_1 = input.LA (1);  				if ((LA7_1 == 31)) {  					alt7 = 1;  				}  			}  			finally {  				DebugExitDecision (7);  			}  			switch (alt7) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  				{  					DebugLocation (105' 51);  					inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (7);  		}  		DebugLocation (105' 60);  		// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  		int alt8 = 2;  		try {  			DebugEnterSubRule (8);  			try {  				DebugEnterDecision (8' false);  				int LA8_1 = input.LA (1);  				if ((LA8_1 == 24)) {  					alt8 = 1;  				}  			}  			finally {  				DebugExitDecision (8);  			}  			switch (alt8) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  				{  					DebugLocation (105' 60);  					not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (8);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (106' 4);  		FilterTreeNode newProperty = new Property (propertySegments);  		if ((inverse != null ? inverse.Text : default(string)) == "?")  			filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  		else {  			if ((not != null ? not.Text : default(string)) == "!")  				newProperty.ToggleInversed ();  			filterNode = newProperty;  		}  	}  	break;  case 4:  	DebugEnterAlt (4);  	// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  	{  		DebugLocation (116' 4);  		STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  		DebugLocation (117' 4);  		string stringText = (STRING7 != null ? STRING7.Text : default(string));  		stringText = stringText.Substring (1' stringText.Length - 2);  		filterNode = new Value (stringText);  	}  	break;  case 5:  	DebugEnterAlt (5);  	// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  	{  		DebugLocation (122' 4);  		REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  		DebugLocation (123' 4);  		string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  		regexText = regexText.Substring (1' regexText.Length - 2);  		filterNode = new RegExp (regexText);  	}  	break;  case 6:  	DebugEnterAlt (6);  	// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  	{  		DebugLocation (128' 4);  		NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  		DebugLocation (129' 4);  		filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  	}  	break;  case 7:  	DebugEnterAlt (7);  	// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  	{  		DebugLocation (132' 4);  		Match (input' TRUE' Follow._TRUE_in_filterExpr271);  		DebugLocation (133' 4);  		filterNode = new Value (true);  	}  	break;  case 8:  	DebugEnterAlt (8);  	// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  	{  		DebugLocation (136' 4);  		Match (input' FALSE' Follow._FALSE_in_filterExpr281);  		DebugLocation (137' 4);  		filterNode = new Value (false);  	}  	break;  case 9:  	DebugEnterAlt (9);  	// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  	{  		DebugLocation (140' 4);  		Match (input' NULL' Follow._NULL_in_filterExpr291);  		DebugLocation (141' 4);  		filterNode = new Value (null);  	}  	break;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: switch (alt9) {  case 1:  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  	{  		DebugLocation (64' 4);  		DebugLocation (64' 6);  		PushFollow (Follow._comparator_in_filterExpr175);  		comparator6 = comparator ();  		PopFollow ();  		Match (input' TokenTypes.Down' null);  		DebugLocation (64' 18);  		PushFollow (Follow._filterExpr_in_filterExpr179);  		a = filterExpr ();  		PopFollow ();  		DebugLocation (64' 31);  		PushFollow (Follow._filterExpr_in_filterExpr183);  		b = filterExpr ();  		PopFollow ();  		Match (input' TokenTypes.Up' null);  		DebugLocation (65' 4);  		Comparator newComparator;  		switch (comparator6) {  		case "=":  			newComparator = Comparator.Equals;  			break;  		case "!=":  			newComparator = Comparator.NotEquals;  			break;  		case ">":  			newComparator = Comparator.Greater;  			break;  		case "<":  			newComparator = Comparator.Less;  			break;  		case ">=":  			newComparator = Comparator.GreaterOrEqual;  			break;  		case "<=":  			newComparator = Comparator.LessOrEqual;  			break;  		case "&":  			newComparator = Comparator.And;  			break;  		case "|":  			newComparator = Comparator.Or;  			break;  		default:  			newComparator = Comparator.Equals;  			break;  		}  		filterNode = new BoolExpression (a' newComparator' b);  	}  	break;  case 2:  	DebugEnterAlt (2);  	// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  	{  		DebugLocation (98' 4);  		DebugLocation (98' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr195);  		Match (input' TokenTypes.Down' null);  		DebugLocation (98' 12);  		PushFollow (Follow._filterExpr_in_filterExpr199);  		f = filterExpr ();  		PopFollow ();  		DebugLocation (98' 31);  		// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  		int alt6 = 2;  		try {  			DebugEnterSubRule (6);  			try {  				DebugEnterDecision (6' false);  				int LA6_1 = input.LA (1);  				if ((LA6_1 == 24)) {  					alt6 = 1;  				}  			}  			finally {  				DebugExitDecision (6);  			}  			switch (alt6) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  				{  					DebugLocation (98' 31);  					inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (6);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (99' 4);  		FilterTreeNode newNode = f;  		if ((inverse != null ? inverse.Text : default(string)) == "!")  			newNode.ToggleInversed ();  		filterNode = newNode;  	}  	break;  case 3:  	DebugEnterAlt (3);  	// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  	{  		DebugLocation (105' 4);  		DebugLocation (105' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr216);  		Match (input' TokenTypes.Down' null);  		DebugLocation (105' 12);  		PushFollow (Follow._propertyChain_in_filterExpr219);  		propertyChain (propertySegments);  		PopFollow ();  		DebugLocation (105' 51);  		// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  		int alt7 = 2;  		try {  			DebugEnterSubRule (7);  			try {  				DebugEnterDecision (7' false);  				int LA7_1 = input.LA (1);  				if ((LA7_1 == 31)) {  					alt7 = 1;  				}  			}  			finally {  				DebugExitDecision (7);  			}  			switch (alt7) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  				{  					DebugLocation (105' 51);  					inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (7);  		}  		DebugLocation (105' 60);  		// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  		int alt8 = 2;  		try {  			DebugEnterSubRule (8);  			try {  				DebugEnterDecision (8' false);  				int LA8_1 = input.LA (1);  				if ((LA8_1 == 24)) {  					alt8 = 1;  				}  			}  			finally {  				DebugExitDecision (8);  			}  			switch (alt8) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  				{  					DebugLocation (105' 60);  					not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (8);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (106' 4);  		FilterTreeNode newProperty = new Property (propertySegments);  		if ((inverse != null ? inverse.Text : default(string)) == "?")  			filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  		else {  			if ((not != null ? not.Text : default(string)) == "!")  				newProperty.ToggleInversed ();  			filterNode = newProperty;  		}  	}  	break;  case 4:  	DebugEnterAlt (4);  	// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  	{  		DebugLocation (116' 4);  		STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  		DebugLocation (117' 4);  		string stringText = (STRING7 != null ? STRING7.Text : default(string));  		stringText = stringText.Substring (1' stringText.Length - 2);  		filterNode = new Value (stringText);  	}  	break;  case 5:  	DebugEnterAlt (5);  	// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  	{  		DebugLocation (122' 4);  		REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  		DebugLocation (123' 4);  		string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  		regexText = regexText.Substring (1' regexText.Length - 2);  		filterNode = new RegExp (regexText);  	}  	break;  case 6:  	DebugEnterAlt (6);  	// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  	{  		DebugLocation (128' 4);  		NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  		DebugLocation (129' 4);  		filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  	}  	break;  case 7:  	DebugEnterAlt (7);  	// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  	{  		DebugLocation (132' 4);  		Match (input' TRUE' Follow._TRUE_in_filterExpr271);  		DebugLocation (133' 4);  		filterNode = new Value (true);  	}  	break;  case 8:  	DebugEnterAlt (8);  	// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  	{  		DebugLocation (136' 4);  		Match (input' FALSE' Follow._FALSE_in_filterExpr281);  		DebugLocation (137' 4);  		filterNode = new Value (false);  	}  	break;  case 9:  	DebugEnterAlt (9);  	// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  	{  		DebugLocation (140' 4);  		Match (input' NULL' Follow._NULL_in_filterExpr291);  		DebugLocation (141' 4);  		filterNode = new Value (null);  	}  	break;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: switch (alt9) {  case 1:  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  	{  		DebugLocation (64' 4);  		DebugLocation (64' 6);  		PushFollow (Follow._comparator_in_filterExpr175);  		comparator6 = comparator ();  		PopFollow ();  		Match (input' TokenTypes.Down' null);  		DebugLocation (64' 18);  		PushFollow (Follow._filterExpr_in_filterExpr179);  		a = filterExpr ();  		PopFollow ();  		DebugLocation (64' 31);  		PushFollow (Follow._filterExpr_in_filterExpr183);  		b = filterExpr ();  		PopFollow ();  		Match (input' TokenTypes.Up' null);  		DebugLocation (65' 4);  		Comparator newComparator;  		switch (comparator6) {  		case "=":  			newComparator = Comparator.Equals;  			break;  		case "!=":  			newComparator = Comparator.NotEquals;  			break;  		case ">":  			newComparator = Comparator.Greater;  			break;  		case "<":  			newComparator = Comparator.Less;  			break;  		case ">=":  			newComparator = Comparator.GreaterOrEqual;  			break;  		case "<=":  			newComparator = Comparator.LessOrEqual;  			break;  		case "&":  			newComparator = Comparator.And;  			break;  		case "|":  			newComparator = Comparator.Or;  			break;  		default:  			newComparator = Comparator.Equals;  			break;  		}  		filterNode = new BoolExpression (a' newComparator' b);  	}  	break;  case 2:  	DebugEnterAlt (2);  	// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  	{  		DebugLocation (98' 4);  		DebugLocation (98' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr195);  		Match (input' TokenTypes.Down' null);  		DebugLocation (98' 12);  		PushFollow (Follow._filterExpr_in_filterExpr199);  		f = filterExpr ();  		PopFollow ();  		DebugLocation (98' 31);  		// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  		int alt6 = 2;  		try {  			DebugEnterSubRule (6);  			try {  				DebugEnterDecision (6' false);  				int LA6_1 = input.LA (1);  				if ((LA6_1 == 24)) {  					alt6 = 1;  				}  			}  			finally {  				DebugExitDecision (6);  			}  			switch (alt6) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  				{  					DebugLocation (98' 31);  					inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (6);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (99' 4);  		FilterTreeNode newNode = f;  		if ((inverse != null ? inverse.Text : default(string)) == "!")  			newNode.ToggleInversed ();  		filterNode = newNode;  	}  	break;  case 3:  	DebugEnterAlt (3);  	// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  	{  		DebugLocation (105' 4);  		DebugLocation (105' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr216);  		Match (input' TokenTypes.Down' null);  		DebugLocation (105' 12);  		PushFollow (Follow._propertyChain_in_filterExpr219);  		propertyChain (propertySegments);  		PopFollow ();  		DebugLocation (105' 51);  		// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  		int alt7 = 2;  		try {  			DebugEnterSubRule (7);  			try {  				DebugEnterDecision (7' false);  				int LA7_1 = input.LA (1);  				if ((LA7_1 == 31)) {  					alt7 = 1;  				}  			}  			finally {  				DebugExitDecision (7);  			}  			switch (alt7) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  				{  					DebugLocation (105' 51);  					inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (7);  		}  		DebugLocation (105' 60);  		// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  		int alt8 = 2;  		try {  			DebugEnterSubRule (8);  			try {  				DebugEnterDecision (8' false);  				int LA8_1 = input.LA (1);  				if ((LA8_1 == 24)) {  					alt8 = 1;  				}  			}  			finally {  				DebugExitDecision (8);  			}  			switch (alt8) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  				{  					DebugLocation (105' 60);  					not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (8);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (106' 4);  		FilterTreeNode newProperty = new Property (propertySegments);  		if ((inverse != null ? inverse.Text : default(string)) == "?")  			filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  		else {  			if ((not != null ? not.Text : default(string)) == "!")  				newProperty.ToggleInversed ();  			filterNode = newProperty;  		}  	}  	break;  case 4:  	DebugEnterAlt (4);  	// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  	{  		DebugLocation (116' 4);  		STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  		DebugLocation (117' 4);  		string stringText = (STRING7 != null ? STRING7.Text : default(string));  		stringText = stringText.Substring (1' stringText.Length - 2);  		filterNode = new Value (stringText);  	}  	break;  case 5:  	DebugEnterAlt (5);  	// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  	{  		DebugLocation (122' 4);  		REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  		DebugLocation (123' 4);  		string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  		regexText = regexText.Substring (1' regexText.Length - 2);  		filterNode = new RegExp (regexText);  	}  	break;  case 6:  	DebugEnterAlt (6);  	// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  	{  		DebugLocation (128' 4);  		NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  		DebugLocation (129' 4);  		filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  	}  	break;  case 7:  	DebugEnterAlt (7);  	// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  	{  		DebugLocation (132' 4);  		Match (input' TRUE' Follow._TRUE_in_filterExpr271);  		DebugLocation (133' 4);  		filterNode = new Value (true);  	}  	break;  case 8:  	DebugEnterAlt (8);  	// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  	{  		DebugLocation (136' 4);  		Match (input' FALSE' Follow._FALSE_in_filterExpr281);  		DebugLocation (137' 4);  		filterNode = new Value (false);  	}  	break;  case 9:  	DebugEnterAlt (9);  	// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  	{  		DebugLocation (140' 4);  		Match (input' NULL' Follow._NULL_in_filterExpr291);  		DebugLocation (141' 4);  		filterNode = new Value (null);  	}  	break;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: switch (alt9) {  case 1:  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  	{  		DebugLocation (64' 4);  		DebugLocation (64' 6);  		PushFollow (Follow._comparator_in_filterExpr175);  		comparator6 = comparator ();  		PopFollow ();  		Match (input' TokenTypes.Down' null);  		DebugLocation (64' 18);  		PushFollow (Follow._filterExpr_in_filterExpr179);  		a = filterExpr ();  		PopFollow ();  		DebugLocation (64' 31);  		PushFollow (Follow._filterExpr_in_filterExpr183);  		b = filterExpr ();  		PopFollow ();  		Match (input' TokenTypes.Up' null);  		DebugLocation (65' 4);  		Comparator newComparator;  		switch (comparator6) {  		case "=":  			newComparator = Comparator.Equals;  			break;  		case "!=":  			newComparator = Comparator.NotEquals;  			break;  		case ">":  			newComparator = Comparator.Greater;  			break;  		case "<":  			newComparator = Comparator.Less;  			break;  		case ">=":  			newComparator = Comparator.GreaterOrEqual;  			break;  		case "<=":  			newComparator = Comparator.LessOrEqual;  			break;  		case "&":  			newComparator = Comparator.And;  			break;  		case "|":  			newComparator = Comparator.Or;  			break;  		default:  			newComparator = Comparator.Equals;  			break;  		}  		filterNode = new BoolExpression (a' newComparator' b);  	}  	break;  case 2:  	DebugEnterAlt (2);  	// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  	{  		DebugLocation (98' 4);  		DebugLocation (98' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr195);  		Match (input' TokenTypes.Down' null);  		DebugLocation (98' 12);  		PushFollow (Follow._filterExpr_in_filterExpr199);  		f = filterExpr ();  		PopFollow ();  		DebugLocation (98' 31);  		// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  		int alt6 = 2;  		try {  			DebugEnterSubRule (6);  			try {  				DebugEnterDecision (6' false);  				int LA6_1 = input.LA (1);  				if ((LA6_1 == 24)) {  					alt6 = 1;  				}  			}  			finally {  				DebugExitDecision (6);  			}  			switch (alt6) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  				{  					DebugLocation (98' 31);  					inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (6);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (99' 4);  		FilterTreeNode newNode = f;  		if ((inverse != null ? inverse.Text : default(string)) == "!")  			newNode.ToggleInversed ();  		filterNode = newNode;  	}  	break;  case 3:  	DebugEnterAlt (3);  	// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  	{  		DebugLocation (105' 4);  		DebugLocation (105' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr216);  		Match (input' TokenTypes.Down' null);  		DebugLocation (105' 12);  		PushFollow (Follow._propertyChain_in_filterExpr219);  		propertyChain (propertySegments);  		PopFollow ();  		DebugLocation (105' 51);  		// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  		int alt7 = 2;  		try {  			DebugEnterSubRule (7);  			try {  				DebugEnterDecision (7' false);  				int LA7_1 = input.LA (1);  				if ((LA7_1 == 31)) {  					alt7 = 1;  				}  			}  			finally {  				DebugExitDecision (7);  			}  			switch (alt7) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  				{  					DebugLocation (105' 51);  					inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (7);  		}  		DebugLocation (105' 60);  		// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  		int alt8 = 2;  		try {  			DebugEnterSubRule (8);  			try {  				DebugEnterDecision (8' false);  				int LA8_1 = input.LA (1);  				if ((LA8_1 == 24)) {  					alt8 = 1;  				}  			}  			finally {  				DebugExitDecision (8);  			}  			switch (alt8) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  				{  					DebugLocation (105' 60);  					not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (8);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (106' 4);  		FilterTreeNode newProperty = new Property (propertySegments);  		if ((inverse != null ? inverse.Text : default(string)) == "?")  			filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  		else {  			if ((not != null ? not.Text : default(string)) == "!")  				newProperty.ToggleInversed ();  			filterNode = newProperty;  		}  	}  	break;  case 4:  	DebugEnterAlt (4);  	// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  	{  		DebugLocation (116' 4);  		STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  		DebugLocation (117' 4);  		string stringText = (STRING7 != null ? STRING7.Text : default(string));  		stringText = stringText.Substring (1' stringText.Length - 2);  		filterNode = new Value (stringText);  	}  	break;  case 5:  	DebugEnterAlt (5);  	// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  	{  		DebugLocation (122' 4);  		REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  		DebugLocation (123' 4);  		string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  		regexText = regexText.Substring (1' regexText.Length - 2);  		filterNode = new RegExp (regexText);  	}  	break;  case 6:  	DebugEnterAlt (6);  	// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  	{  		DebugLocation (128' 4);  		NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  		DebugLocation (129' 4);  		filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  	}  	break;  case 7:  	DebugEnterAlt (7);  	// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  	{  		DebugLocation (132' 4);  		Match (input' TRUE' Follow._TRUE_in_filterExpr271);  		DebugLocation (133' 4);  		filterNode = new Value (true);  	}  	break;  case 8:  	DebugEnterAlt (8);  	// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  	{  		DebugLocation (136' 4);  		Match (input' FALSE' Follow._FALSE_in_filterExpr281);  		DebugLocation (137' 4);  		filterNode = new Value (false);  	}  	break;  case 9:  	DebugEnterAlt (9);  	// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  	{  		DebugLocation (140' 4);  		Match (input' NULL' Follow._NULL_in_filterExpr291);  		DebugLocation (141' 4);  		filterNode = new Value (null);  	}  	break;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: switch (alt9) {  case 1:  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  	{  		DebugLocation (64' 4);  		DebugLocation (64' 6);  		PushFollow (Follow._comparator_in_filterExpr175);  		comparator6 = comparator ();  		PopFollow ();  		Match (input' TokenTypes.Down' null);  		DebugLocation (64' 18);  		PushFollow (Follow._filterExpr_in_filterExpr179);  		a = filterExpr ();  		PopFollow ();  		DebugLocation (64' 31);  		PushFollow (Follow._filterExpr_in_filterExpr183);  		b = filterExpr ();  		PopFollow ();  		Match (input' TokenTypes.Up' null);  		DebugLocation (65' 4);  		Comparator newComparator;  		switch (comparator6) {  		case "=":  			newComparator = Comparator.Equals;  			break;  		case "!=":  			newComparator = Comparator.NotEquals;  			break;  		case ">":  			newComparator = Comparator.Greater;  			break;  		case "<":  			newComparator = Comparator.Less;  			break;  		case ">=":  			newComparator = Comparator.GreaterOrEqual;  			break;  		case "<=":  			newComparator = Comparator.LessOrEqual;  			break;  		case "&":  			newComparator = Comparator.And;  			break;  		case "|":  			newComparator = Comparator.Or;  			break;  		default:  			newComparator = Comparator.Equals;  			break;  		}  		filterNode = new BoolExpression (a' newComparator' b);  	}  	break;  case 2:  	DebugEnterAlt (2);  	// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  	{  		DebugLocation (98' 4);  		DebugLocation (98' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr195);  		Match (input' TokenTypes.Down' null);  		DebugLocation (98' 12);  		PushFollow (Follow._filterExpr_in_filterExpr199);  		f = filterExpr ();  		PopFollow ();  		DebugLocation (98' 31);  		// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  		int alt6 = 2;  		try {  			DebugEnterSubRule (6);  			try {  				DebugEnterDecision (6' false);  				int LA6_1 = input.LA (1);  				if ((LA6_1 == 24)) {  					alt6 = 1;  				}  			}  			finally {  				DebugExitDecision (6);  			}  			switch (alt6) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  				{  					DebugLocation (98' 31);  					inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (6);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (99' 4);  		FilterTreeNode newNode = f;  		if ((inverse != null ? inverse.Text : default(string)) == "!")  			newNode.ToggleInversed ();  		filterNode = newNode;  	}  	break;  case 3:  	DebugEnterAlt (3);  	// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  	{  		DebugLocation (105' 4);  		DebugLocation (105' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr216);  		Match (input' TokenTypes.Down' null);  		DebugLocation (105' 12);  		PushFollow (Follow._propertyChain_in_filterExpr219);  		propertyChain (propertySegments);  		PopFollow ();  		DebugLocation (105' 51);  		// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  		int alt7 = 2;  		try {  			DebugEnterSubRule (7);  			try {  				DebugEnterDecision (7' false);  				int LA7_1 = input.LA (1);  				if ((LA7_1 == 31)) {  					alt7 = 1;  				}  			}  			finally {  				DebugExitDecision (7);  			}  			switch (alt7) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  				{  					DebugLocation (105' 51);  					inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (7);  		}  		DebugLocation (105' 60);  		// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  		int alt8 = 2;  		try {  			DebugEnterSubRule (8);  			try {  				DebugEnterDecision (8' false);  				int LA8_1 = input.LA (1);  				if ((LA8_1 == 24)) {  					alt8 = 1;  				}  			}  			finally {  				DebugExitDecision (8);  			}  			switch (alt8) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  				{  					DebugLocation (105' 60);  					not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (8);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (106' 4);  		FilterTreeNode newProperty = new Property (propertySegments);  		if ((inverse != null ? inverse.Text : default(string)) == "?")  			filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  		else {  			if ((not != null ? not.Text : default(string)) == "!")  				newProperty.ToggleInversed ();  			filterNode = newProperty;  		}  	}  	break;  case 4:  	DebugEnterAlt (4);  	// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  	{  		DebugLocation (116' 4);  		STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  		DebugLocation (117' 4);  		string stringText = (STRING7 != null ? STRING7.Text : default(string));  		stringText = stringText.Substring (1' stringText.Length - 2);  		filterNode = new Value (stringText);  	}  	break;  case 5:  	DebugEnterAlt (5);  	// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  	{  		DebugLocation (122' 4);  		REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  		DebugLocation (123' 4);  		string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  		regexText = regexText.Substring (1' regexText.Length - 2);  		filterNode = new RegExp (regexText);  	}  	break;  case 6:  	DebugEnterAlt (6);  	// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  	{  		DebugLocation (128' 4);  		NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  		DebugLocation (129' 4);  		filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  	}  	break;  case 7:  	DebugEnterAlt (7);  	// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  	{  		DebugLocation (132' 4);  		Match (input' TRUE' Follow._TRUE_in_filterExpr271);  		DebugLocation (133' 4);  		filterNode = new Value (true);  	}  	break;  case 8:  	DebugEnterAlt (8);  	// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  	{  		DebugLocation (136' 4);  		Match (input' FALSE' Follow._FALSE_in_filterExpr281);  		DebugLocation (137' 4);  		filterNode = new Value (false);  	}  	break;  case 9:  	DebugEnterAlt (9);  	// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  	{  		DebugLocation (140' 4);  		Match (input' NULL' Follow._NULL_in_filterExpr291);  		DebugLocation (141' 4);  		filterNode = new Value (null);  	}  	break;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: switch (alt9) {  case 1:  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  	{  		DebugLocation (64' 4);  		DebugLocation (64' 6);  		PushFollow (Follow._comparator_in_filterExpr175);  		comparator6 = comparator ();  		PopFollow ();  		Match (input' TokenTypes.Down' null);  		DebugLocation (64' 18);  		PushFollow (Follow._filterExpr_in_filterExpr179);  		a = filterExpr ();  		PopFollow ();  		DebugLocation (64' 31);  		PushFollow (Follow._filterExpr_in_filterExpr183);  		b = filterExpr ();  		PopFollow ();  		Match (input' TokenTypes.Up' null);  		DebugLocation (65' 4);  		Comparator newComparator;  		switch (comparator6) {  		case "=":  			newComparator = Comparator.Equals;  			break;  		case "!=":  			newComparator = Comparator.NotEquals;  			break;  		case ">":  			newComparator = Comparator.Greater;  			break;  		case "<":  			newComparator = Comparator.Less;  			break;  		case ">=":  			newComparator = Comparator.GreaterOrEqual;  			break;  		case "<=":  			newComparator = Comparator.LessOrEqual;  			break;  		case "&":  			newComparator = Comparator.And;  			break;  		case "|":  			newComparator = Comparator.Or;  			break;  		default:  			newComparator = Comparator.Equals;  			break;  		}  		filterNode = new BoolExpression (a' newComparator' b);  	}  	break;  case 2:  	DebugEnterAlt (2);  	// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  	{  		DebugLocation (98' 4);  		DebugLocation (98' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr195);  		Match (input' TokenTypes.Down' null);  		DebugLocation (98' 12);  		PushFollow (Follow._filterExpr_in_filterExpr199);  		f = filterExpr ();  		PopFollow ();  		DebugLocation (98' 31);  		// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  		int alt6 = 2;  		try {  			DebugEnterSubRule (6);  			try {  				DebugEnterDecision (6' false);  				int LA6_1 = input.LA (1);  				if ((LA6_1 == 24)) {  					alt6 = 1;  				}  			}  			finally {  				DebugExitDecision (6);  			}  			switch (alt6) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  				{  					DebugLocation (98' 31);  					inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (6);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (99' 4);  		FilterTreeNode newNode = f;  		if ((inverse != null ? inverse.Text : default(string)) == "!")  			newNode.ToggleInversed ();  		filterNode = newNode;  	}  	break;  case 3:  	DebugEnterAlt (3);  	// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  	{  		DebugLocation (105' 4);  		DebugLocation (105' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr216);  		Match (input' TokenTypes.Down' null);  		DebugLocation (105' 12);  		PushFollow (Follow._propertyChain_in_filterExpr219);  		propertyChain (propertySegments);  		PopFollow ();  		DebugLocation (105' 51);  		// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  		int alt7 = 2;  		try {  			DebugEnterSubRule (7);  			try {  				DebugEnterDecision (7' false);  				int LA7_1 = input.LA (1);  				if ((LA7_1 == 31)) {  					alt7 = 1;  				}  			}  			finally {  				DebugExitDecision (7);  			}  			switch (alt7) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  				{  					DebugLocation (105' 51);  					inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (7);  		}  		DebugLocation (105' 60);  		// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  		int alt8 = 2;  		try {  			DebugEnterSubRule (8);  			try {  				DebugEnterDecision (8' false);  				int LA8_1 = input.LA (1);  				if ((LA8_1 == 24)) {  					alt8 = 1;  				}  			}  			finally {  				DebugExitDecision (8);  			}  			switch (alt8) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  				{  					DebugLocation (105' 60);  					not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (8);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (106' 4);  		FilterTreeNode newProperty = new Property (propertySegments);  		if ((inverse != null ? inverse.Text : default(string)) == "?")  			filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  		else {  			if ((not != null ? not.Text : default(string)) == "!")  				newProperty.ToggleInversed ();  			filterNode = newProperty;  		}  	}  	break;  case 4:  	DebugEnterAlt (4);  	// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  	{  		DebugLocation (116' 4);  		STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  		DebugLocation (117' 4);  		string stringText = (STRING7 != null ? STRING7.Text : default(string));  		stringText = stringText.Substring (1' stringText.Length - 2);  		filterNode = new Value (stringText);  	}  	break;  case 5:  	DebugEnterAlt (5);  	// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  	{  		DebugLocation (122' 4);  		REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  		DebugLocation (123' 4);  		string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  		regexText = regexText.Substring (1' regexText.Length - 2);  		filterNode = new RegExp (regexText);  	}  	break;  case 6:  	DebugEnterAlt (6);  	// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  	{  		DebugLocation (128' 4);  		NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  		DebugLocation (129' 4);  		filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  	}  	break;  case 7:  	DebugEnterAlt (7);  	// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  	{  		DebugLocation (132' 4);  		Match (input' TRUE' Follow._TRUE_in_filterExpr271);  		DebugLocation (133' 4);  		filterNode = new Value (true);  	}  	break;  case 8:  	DebugEnterAlt (8);  	// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  	{  		DebugLocation (136' 4);  		Match (input' FALSE' Follow._FALSE_in_filterExpr281);  		DebugLocation (137' 4);  		filterNode = new Value (false);  	}  	break;  case 9:  	DebugEnterAlt (9);  	// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  	{  		DebugLocation (140' 4);  		Match (input' NULL' Follow._NULL_in_filterExpr291);  		DebugLocation (141' 4);  		filterNode = new Value (null);  	}  	break;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: switch (alt9) {  case 1:  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  	{  		DebugLocation (64' 4);  		DebugLocation (64' 6);  		PushFollow (Follow._comparator_in_filterExpr175);  		comparator6 = comparator ();  		PopFollow ();  		Match (input' TokenTypes.Down' null);  		DebugLocation (64' 18);  		PushFollow (Follow._filterExpr_in_filterExpr179);  		a = filterExpr ();  		PopFollow ();  		DebugLocation (64' 31);  		PushFollow (Follow._filterExpr_in_filterExpr183);  		b = filterExpr ();  		PopFollow ();  		Match (input' TokenTypes.Up' null);  		DebugLocation (65' 4);  		Comparator newComparator;  		switch (comparator6) {  		case "=":  			newComparator = Comparator.Equals;  			break;  		case "!=":  			newComparator = Comparator.NotEquals;  			break;  		case ">":  			newComparator = Comparator.Greater;  			break;  		case "<":  			newComparator = Comparator.Less;  			break;  		case ">=":  			newComparator = Comparator.GreaterOrEqual;  			break;  		case "<=":  			newComparator = Comparator.LessOrEqual;  			break;  		case "&":  			newComparator = Comparator.And;  			break;  		case "|":  			newComparator = Comparator.Or;  			break;  		default:  			newComparator = Comparator.Equals;  			break;  		}  		filterNode = new BoolExpression (a' newComparator' b);  	}  	break;  case 2:  	DebugEnterAlt (2);  	// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  	{  		DebugLocation (98' 4);  		DebugLocation (98' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr195);  		Match (input' TokenTypes.Down' null);  		DebugLocation (98' 12);  		PushFollow (Follow._filterExpr_in_filterExpr199);  		f = filterExpr ();  		PopFollow ();  		DebugLocation (98' 31);  		// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  		int alt6 = 2;  		try {  			DebugEnterSubRule (6);  			try {  				DebugEnterDecision (6' false);  				int LA6_1 = input.LA (1);  				if ((LA6_1 == 24)) {  					alt6 = 1;  				}  			}  			finally {  				DebugExitDecision (6);  			}  			switch (alt6) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  				{  					DebugLocation (98' 31);  					inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (6);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (99' 4);  		FilterTreeNode newNode = f;  		if ((inverse != null ? inverse.Text : default(string)) == "!")  			newNode.ToggleInversed ();  		filterNode = newNode;  	}  	break;  case 3:  	DebugEnterAlt (3);  	// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  	{  		DebugLocation (105' 4);  		DebugLocation (105' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr216);  		Match (input' TokenTypes.Down' null);  		DebugLocation (105' 12);  		PushFollow (Follow._propertyChain_in_filterExpr219);  		propertyChain (propertySegments);  		PopFollow ();  		DebugLocation (105' 51);  		// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  		int alt7 = 2;  		try {  			DebugEnterSubRule (7);  			try {  				DebugEnterDecision (7' false);  				int LA7_1 = input.LA (1);  				if ((LA7_1 == 31)) {  					alt7 = 1;  				}  			}  			finally {  				DebugExitDecision (7);  			}  			switch (alt7) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  				{  					DebugLocation (105' 51);  					inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (7);  		}  		DebugLocation (105' 60);  		// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  		int alt8 = 2;  		try {  			DebugEnterSubRule (8);  			try {  				DebugEnterDecision (8' false);  				int LA8_1 = input.LA (1);  				if ((LA8_1 == 24)) {  					alt8 = 1;  				}  			}  			finally {  				DebugExitDecision (8);  			}  			switch (alt8) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  				{  					DebugLocation (105' 60);  					not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (8);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (106' 4);  		FilterTreeNode newProperty = new Property (propertySegments);  		if ((inverse != null ? inverse.Text : default(string)) == "?")  			filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  		else {  			if ((not != null ? not.Text : default(string)) == "!")  				newProperty.ToggleInversed ();  			filterNode = newProperty;  		}  	}  	break;  case 4:  	DebugEnterAlt (4);  	// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  	{  		DebugLocation (116' 4);  		STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  		DebugLocation (117' 4);  		string stringText = (STRING7 != null ? STRING7.Text : default(string));  		stringText = stringText.Substring (1' stringText.Length - 2);  		filterNode = new Value (stringText);  	}  	break;  case 5:  	DebugEnterAlt (5);  	// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  	{  		DebugLocation (122' 4);  		REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  		DebugLocation (123' 4);  		string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  		regexText = regexText.Substring (1' regexText.Length - 2);  		filterNode = new RegExp (regexText);  	}  	break;  case 6:  	DebugEnterAlt (6);  	// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  	{  		DebugLocation (128' 4);  		NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  		DebugLocation (129' 4);  		filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  	}  	break;  case 7:  	DebugEnterAlt (7);  	// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  	{  		DebugLocation (132' 4);  		Match (input' TRUE' Follow._TRUE_in_filterExpr271);  		DebugLocation (133' 4);  		filterNode = new Value (true);  	}  	break;  case 8:  	DebugEnterAlt (8);  	// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  	{  		DebugLocation (136' 4);  		Match (input' FALSE' Follow._FALSE_in_filterExpr281);  		DebugLocation (137' 4);  		filterNode = new Value (false);  	}  	break;  case 9:  	DebugEnterAlt (9);  	// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  	{  		DebugLocation (140' 4);  		Match (input' NULL' Follow._NULL_in_filterExpr291);  		DebugLocation (141' 4);  		filterNode = new Value (null);  	}  	break;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: switch (alt9) {  case 1:  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  	{  		DebugLocation (64' 4);  		DebugLocation (64' 6);  		PushFollow (Follow._comparator_in_filterExpr175);  		comparator6 = comparator ();  		PopFollow ();  		Match (input' TokenTypes.Down' null);  		DebugLocation (64' 18);  		PushFollow (Follow._filterExpr_in_filterExpr179);  		a = filterExpr ();  		PopFollow ();  		DebugLocation (64' 31);  		PushFollow (Follow._filterExpr_in_filterExpr183);  		b = filterExpr ();  		PopFollow ();  		Match (input' TokenTypes.Up' null);  		DebugLocation (65' 4);  		Comparator newComparator;  		switch (comparator6) {  		case "=":  			newComparator = Comparator.Equals;  			break;  		case "!=":  			newComparator = Comparator.NotEquals;  			break;  		case ">":  			newComparator = Comparator.Greater;  			break;  		case "<":  			newComparator = Comparator.Less;  			break;  		case ">=":  			newComparator = Comparator.GreaterOrEqual;  			break;  		case "<=":  			newComparator = Comparator.LessOrEqual;  			break;  		case "&":  			newComparator = Comparator.And;  			break;  		case "|":  			newComparator = Comparator.Or;  			break;  		default:  			newComparator = Comparator.Equals;  			break;  		}  		filterNode = new BoolExpression (a' newComparator' b);  	}  	break;  case 2:  	DebugEnterAlt (2);  	// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  	{  		DebugLocation (98' 4);  		DebugLocation (98' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr195);  		Match (input' TokenTypes.Down' null);  		DebugLocation (98' 12);  		PushFollow (Follow._filterExpr_in_filterExpr199);  		f = filterExpr ();  		PopFollow ();  		DebugLocation (98' 31);  		// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  		int alt6 = 2;  		try {  			DebugEnterSubRule (6);  			try {  				DebugEnterDecision (6' false);  				int LA6_1 = input.LA (1);  				if ((LA6_1 == 24)) {  					alt6 = 1;  				}  			}  			finally {  				DebugExitDecision (6);  			}  			switch (alt6) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  				{  					DebugLocation (98' 31);  					inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (6);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (99' 4);  		FilterTreeNode newNode = f;  		if ((inverse != null ? inverse.Text : default(string)) == "!")  			newNode.ToggleInversed ();  		filterNode = newNode;  	}  	break;  case 3:  	DebugEnterAlt (3);  	// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  	{  		DebugLocation (105' 4);  		DebugLocation (105' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr216);  		Match (input' TokenTypes.Down' null);  		DebugLocation (105' 12);  		PushFollow (Follow._propertyChain_in_filterExpr219);  		propertyChain (propertySegments);  		PopFollow ();  		DebugLocation (105' 51);  		// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  		int alt7 = 2;  		try {  			DebugEnterSubRule (7);  			try {  				DebugEnterDecision (7' false);  				int LA7_1 = input.LA (1);  				if ((LA7_1 == 31)) {  					alt7 = 1;  				}  			}  			finally {  				DebugExitDecision (7);  			}  			switch (alt7) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  				{  					DebugLocation (105' 51);  					inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (7);  		}  		DebugLocation (105' 60);  		// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  		int alt8 = 2;  		try {  			DebugEnterSubRule (8);  			try {  				DebugEnterDecision (8' false);  				int LA8_1 = input.LA (1);  				if ((LA8_1 == 24)) {  					alt8 = 1;  				}  			}  			finally {  				DebugExitDecision (8);  			}  			switch (alt8) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  				{  					DebugLocation (105' 60);  					not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (8);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (106' 4);  		FilterTreeNode newProperty = new Property (propertySegments);  		if ((inverse != null ? inverse.Text : default(string)) == "?")  			filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  		else {  			if ((not != null ? not.Text : default(string)) == "!")  				newProperty.ToggleInversed ();  			filterNode = newProperty;  		}  	}  	break;  case 4:  	DebugEnterAlt (4);  	// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  	{  		DebugLocation (116' 4);  		STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  		DebugLocation (117' 4);  		string stringText = (STRING7 != null ? STRING7.Text : default(string));  		stringText = stringText.Substring (1' stringText.Length - 2);  		filterNode = new Value (stringText);  	}  	break;  case 5:  	DebugEnterAlt (5);  	// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  	{  		DebugLocation (122' 4);  		REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  		DebugLocation (123' 4);  		string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  		regexText = regexText.Substring (1' regexText.Length - 2);  		filterNode = new RegExp (regexText);  	}  	break;  case 6:  	DebugEnterAlt (6);  	// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  	{  		DebugLocation (128' 4);  		NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  		DebugLocation (129' 4);  		filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  	}  	break;  case 7:  	DebugEnterAlt (7);  	// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  	{  		DebugLocation (132' 4);  		Match (input' TRUE' Follow._TRUE_in_filterExpr271);  		DebugLocation (133' 4);  		filterNode = new Value (true);  	}  	break;  case 8:  	DebugEnterAlt (8);  	// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  	{  		DebugLocation (136' 4);  		Match (input' FALSE' Follow._FALSE_in_filterExpr281);  		DebugLocation (137' 4);  		filterNode = new Value (false);  	}  	break;  case 9:  	DebugEnterAlt (9);  	// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  	{  		DebugLocation (140' 4);  		Match (input' NULL' Follow._NULL_in_filterExpr291);  		DebugLocation (141' 4);  		filterNode = new Value (null);  	}  	break;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: switch (alt9) {  case 1:  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  	{  		DebugLocation (64' 4);  		DebugLocation (64' 6);  		PushFollow (Follow._comparator_in_filterExpr175);  		comparator6 = comparator ();  		PopFollow ();  		Match (input' TokenTypes.Down' null);  		DebugLocation (64' 18);  		PushFollow (Follow._filterExpr_in_filterExpr179);  		a = filterExpr ();  		PopFollow ();  		DebugLocation (64' 31);  		PushFollow (Follow._filterExpr_in_filterExpr183);  		b = filterExpr ();  		PopFollow ();  		Match (input' TokenTypes.Up' null);  		DebugLocation (65' 4);  		Comparator newComparator;  		switch (comparator6) {  		case "=":  			newComparator = Comparator.Equals;  			break;  		case "!=":  			newComparator = Comparator.NotEquals;  			break;  		case ">":  			newComparator = Comparator.Greater;  			break;  		case "<":  			newComparator = Comparator.Less;  			break;  		case ">=":  			newComparator = Comparator.GreaterOrEqual;  			break;  		case "<=":  			newComparator = Comparator.LessOrEqual;  			break;  		case "&":  			newComparator = Comparator.And;  			break;  		case "|":  			newComparator = Comparator.Or;  			break;  		default:  			newComparator = Comparator.Equals;  			break;  		}  		filterNode = new BoolExpression (a' newComparator' b);  	}  	break;  case 2:  	DebugEnterAlt (2);  	// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  	{  		DebugLocation (98' 4);  		DebugLocation (98' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr195);  		Match (input' TokenTypes.Down' null);  		DebugLocation (98' 12);  		PushFollow (Follow._filterExpr_in_filterExpr199);  		f = filterExpr ();  		PopFollow ();  		DebugLocation (98' 31);  		// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  		int alt6 = 2;  		try {  			DebugEnterSubRule (6);  			try {  				DebugEnterDecision (6' false);  				int LA6_1 = input.LA (1);  				if ((LA6_1 == 24)) {  					alt6 = 1;  				}  			}  			finally {  				DebugExitDecision (6);  			}  			switch (alt6) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  				{  					DebugLocation (98' 31);  					inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (6);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (99' 4);  		FilterTreeNode newNode = f;  		if ((inverse != null ? inverse.Text : default(string)) == "!")  			newNode.ToggleInversed ();  		filterNode = newNode;  	}  	break;  case 3:  	DebugEnterAlt (3);  	// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  	{  		DebugLocation (105' 4);  		DebugLocation (105' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr216);  		Match (input' TokenTypes.Down' null);  		DebugLocation (105' 12);  		PushFollow (Follow._propertyChain_in_filterExpr219);  		propertyChain (propertySegments);  		PopFollow ();  		DebugLocation (105' 51);  		// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  		int alt7 = 2;  		try {  			DebugEnterSubRule (7);  			try {  				DebugEnterDecision (7' false);  				int LA7_1 = input.LA (1);  				if ((LA7_1 == 31)) {  					alt7 = 1;  				}  			}  			finally {  				DebugExitDecision (7);  			}  			switch (alt7) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  				{  					DebugLocation (105' 51);  					inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (7);  		}  		DebugLocation (105' 60);  		// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  		int alt8 = 2;  		try {  			DebugEnterSubRule (8);  			try {  				DebugEnterDecision (8' false);  				int LA8_1 = input.LA (1);  				if ((LA8_1 == 24)) {  					alt8 = 1;  				}  			}  			finally {  				DebugExitDecision (8);  			}  			switch (alt8) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  				{  					DebugLocation (105' 60);  					not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (8);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (106' 4);  		FilterTreeNode newProperty = new Property (propertySegments);  		if ((inverse != null ? inverse.Text : default(string)) == "?")  			filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  		else {  			if ((not != null ? not.Text : default(string)) == "!")  				newProperty.ToggleInversed ();  			filterNode = newProperty;  		}  	}  	break;  case 4:  	DebugEnterAlt (4);  	// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  	{  		DebugLocation (116' 4);  		STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  		DebugLocation (117' 4);  		string stringText = (STRING7 != null ? STRING7.Text : default(string));  		stringText = stringText.Substring (1' stringText.Length - 2);  		filterNode = new Value (stringText);  	}  	break;  case 5:  	DebugEnterAlt (5);  	// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  	{  		DebugLocation (122' 4);  		REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  		DebugLocation (123' 4);  		string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  		regexText = regexText.Substring (1' regexText.Length - 2);  		filterNode = new RegExp (regexText);  	}  	break;  case 6:  	DebugEnterAlt (6);  	// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  	{  		DebugLocation (128' 4);  		NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  		DebugLocation (129' 4);  		filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  	}  	break;  case 7:  	DebugEnterAlt (7);  	// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  	{  		DebugLocation (132' 4);  		Match (input' TRUE' Follow._TRUE_in_filterExpr271);  		DebugLocation (133' 4);  		filterNode = new Value (true);  	}  	break;  case 8:  	DebugEnterAlt (8);  	// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  	{  		DebugLocation (136' 4);  		Match (input' FALSE' Follow._FALSE_in_filterExpr281);  		DebugLocation (137' 4);  		filterNode = new Value (false);  	}  	break;  case 9:  	DebugEnterAlt (9);  	// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  	{  		DebugLocation (140' 4);  		Match (input' NULL' Follow._NULL_in_filterExpr291);  		DebugLocation (141' 4);  		filterNode = new Value (null);  	}  	break;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: switch (alt9) {  case 1:  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  	{  		DebugLocation (64' 4);  		DebugLocation (64' 6);  		PushFollow (Follow._comparator_in_filterExpr175);  		comparator6 = comparator ();  		PopFollow ();  		Match (input' TokenTypes.Down' null);  		DebugLocation (64' 18);  		PushFollow (Follow._filterExpr_in_filterExpr179);  		a = filterExpr ();  		PopFollow ();  		DebugLocation (64' 31);  		PushFollow (Follow._filterExpr_in_filterExpr183);  		b = filterExpr ();  		PopFollow ();  		Match (input' TokenTypes.Up' null);  		DebugLocation (65' 4);  		Comparator newComparator;  		switch (comparator6) {  		case "=":  			newComparator = Comparator.Equals;  			break;  		case "!=":  			newComparator = Comparator.NotEquals;  			break;  		case ">":  			newComparator = Comparator.Greater;  			break;  		case "<":  			newComparator = Comparator.Less;  			break;  		case ">=":  			newComparator = Comparator.GreaterOrEqual;  			break;  		case "<=":  			newComparator = Comparator.LessOrEqual;  			break;  		case "&":  			newComparator = Comparator.And;  			break;  		case "|":  			newComparator = Comparator.Or;  			break;  		default:  			newComparator = Comparator.Equals;  			break;  		}  		filterNode = new BoolExpression (a' newComparator' b);  	}  	break;  case 2:  	DebugEnterAlt (2);  	// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  	{  		DebugLocation (98' 4);  		DebugLocation (98' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr195);  		Match (input' TokenTypes.Down' null);  		DebugLocation (98' 12);  		PushFollow (Follow._filterExpr_in_filterExpr199);  		f = filterExpr ();  		PopFollow ();  		DebugLocation (98' 31);  		// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  		int alt6 = 2;  		try {  			DebugEnterSubRule (6);  			try {  				DebugEnterDecision (6' false);  				int LA6_1 = input.LA (1);  				if ((LA6_1 == 24)) {  					alt6 = 1;  				}  			}  			finally {  				DebugExitDecision (6);  			}  			switch (alt6) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  				{  					DebugLocation (98' 31);  					inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (6);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (99' 4);  		FilterTreeNode newNode = f;  		if ((inverse != null ? inverse.Text : default(string)) == "!")  			newNode.ToggleInversed ();  		filterNode = newNode;  	}  	break;  case 3:  	DebugEnterAlt (3);  	// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  	{  		DebugLocation (105' 4);  		DebugLocation (105' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr216);  		Match (input' TokenTypes.Down' null);  		DebugLocation (105' 12);  		PushFollow (Follow._propertyChain_in_filterExpr219);  		propertyChain (propertySegments);  		PopFollow ();  		DebugLocation (105' 51);  		// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  		int alt7 = 2;  		try {  			DebugEnterSubRule (7);  			try {  				DebugEnterDecision (7' false);  				int LA7_1 = input.LA (1);  				if ((LA7_1 == 31)) {  					alt7 = 1;  				}  			}  			finally {  				DebugExitDecision (7);  			}  			switch (alt7) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  				{  					DebugLocation (105' 51);  					inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (7);  		}  		DebugLocation (105' 60);  		// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  		int alt8 = 2;  		try {  			DebugEnterSubRule (8);  			try {  				DebugEnterDecision (8' false);  				int LA8_1 = input.LA (1);  				if ((LA8_1 == 24)) {  					alt8 = 1;  				}  			}  			finally {  				DebugExitDecision (8);  			}  			switch (alt8) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  				{  					DebugLocation (105' 60);  					not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (8);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (106' 4);  		FilterTreeNode newProperty = new Property (propertySegments);  		if ((inverse != null ? inverse.Text : default(string)) == "?")  			filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  		else {  			if ((not != null ? not.Text : default(string)) == "!")  				newProperty.ToggleInversed ();  			filterNode = newProperty;  		}  	}  	break;  case 4:  	DebugEnterAlt (4);  	// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  	{  		DebugLocation (116' 4);  		STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  		DebugLocation (117' 4);  		string stringText = (STRING7 != null ? STRING7.Text : default(string));  		stringText = stringText.Substring (1' stringText.Length - 2);  		filterNode = new Value (stringText);  	}  	break;  case 5:  	DebugEnterAlt (5);  	// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  	{  		DebugLocation (122' 4);  		REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  		DebugLocation (123' 4);  		string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  		regexText = regexText.Substring (1' regexText.Length - 2);  		filterNode = new RegExp (regexText);  	}  	break;  case 6:  	DebugEnterAlt (6);  	// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  	{  		DebugLocation (128' 4);  		NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  		DebugLocation (129' 4);  		filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  	}  	break;  case 7:  	DebugEnterAlt (7);  	// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  	{  		DebugLocation (132' 4);  		Match (input' TRUE' Follow._TRUE_in_filterExpr271);  		DebugLocation (133' 4);  		filterNode = new Value (true);  	}  	break;  case 8:  	DebugEnterAlt (8);  	// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  	{  		DebugLocation (136' 4);  		Match (input' FALSE' Follow._FALSE_in_filterExpr281);  		DebugLocation (137' 4);  		filterNode = new Value (false);  	}  	break;  case 9:  	DebugEnterAlt (9);  	// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  	{  		DebugLocation (140' 4);  		Match (input' NULL' Follow._NULL_in_filterExpr291);  		DebugLocation (141' 4);  		filterNode = new Value (null);  	}  	break;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: switch (alt9) {  case 1:  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  	{  		DebugLocation (64' 4);  		DebugLocation (64' 6);  		PushFollow (Follow._comparator_in_filterExpr175);  		comparator6 = comparator ();  		PopFollow ();  		Match (input' TokenTypes.Down' null);  		DebugLocation (64' 18);  		PushFollow (Follow._filterExpr_in_filterExpr179);  		a = filterExpr ();  		PopFollow ();  		DebugLocation (64' 31);  		PushFollow (Follow._filterExpr_in_filterExpr183);  		b = filterExpr ();  		PopFollow ();  		Match (input' TokenTypes.Up' null);  		DebugLocation (65' 4);  		Comparator newComparator;  		switch (comparator6) {  		case "=":  			newComparator = Comparator.Equals;  			break;  		case "!=":  			newComparator = Comparator.NotEquals;  			break;  		case ">":  			newComparator = Comparator.Greater;  			break;  		case "<":  			newComparator = Comparator.Less;  			break;  		case ">=":  			newComparator = Comparator.GreaterOrEqual;  			break;  		case "<=":  			newComparator = Comparator.LessOrEqual;  			break;  		case "&":  			newComparator = Comparator.And;  			break;  		case "|":  			newComparator = Comparator.Or;  			break;  		default:  			newComparator = Comparator.Equals;  			break;  		}  		filterNode = new BoolExpression (a' newComparator' b);  	}  	break;  case 2:  	DebugEnterAlt (2);  	// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  	{  		DebugLocation (98' 4);  		DebugLocation (98' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr195);  		Match (input' TokenTypes.Down' null);  		DebugLocation (98' 12);  		PushFollow (Follow._filterExpr_in_filterExpr199);  		f = filterExpr ();  		PopFollow ();  		DebugLocation (98' 31);  		// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  		int alt6 = 2;  		try {  			DebugEnterSubRule (6);  			try {  				DebugEnterDecision (6' false);  				int LA6_1 = input.LA (1);  				if ((LA6_1 == 24)) {  					alt6 = 1;  				}  			}  			finally {  				DebugExitDecision (6);  			}  			switch (alt6) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  				{  					DebugLocation (98' 31);  					inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (6);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (99' 4);  		FilterTreeNode newNode = f;  		if ((inverse != null ? inverse.Text : default(string)) == "!")  			newNode.ToggleInversed ();  		filterNode = newNode;  	}  	break;  case 3:  	DebugEnterAlt (3);  	// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  	{  		DebugLocation (105' 4);  		DebugLocation (105' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr216);  		Match (input' TokenTypes.Down' null);  		DebugLocation (105' 12);  		PushFollow (Follow._propertyChain_in_filterExpr219);  		propertyChain (propertySegments);  		PopFollow ();  		DebugLocation (105' 51);  		// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  		int alt7 = 2;  		try {  			DebugEnterSubRule (7);  			try {  				DebugEnterDecision (7' false);  				int LA7_1 = input.LA (1);  				if ((LA7_1 == 31)) {  					alt7 = 1;  				}  			}  			finally {  				DebugExitDecision (7);  			}  			switch (alt7) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  				{  					DebugLocation (105' 51);  					inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (7);  		}  		DebugLocation (105' 60);  		// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  		int alt8 = 2;  		try {  			DebugEnterSubRule (8);  			try {  				DebugEnterDecision (8' false);  				int LA8_1 = input.LA (1);  				if ((LA8_1 == 24)) {  					alt8 = 1;  				}  			}  			finally {  				DebugExitDecision (8);  			}  			switch (alt8) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  				{  					DebugLocation (105' 60);  					not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (8);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (106' 4);  		FilterTreeNode newProperty = new Property (propertySegments);  		if ((inverse != null ? inverse.Text : default(string)) == "?")  			filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  		else {  			if ((not != null ? not.Text : default(string)) == "!")  				newProperty.ToggleInversed ();  			filterNode = newProperty;  		}  	}  	break;  case 4:  	DebugEnterAlt (4);  	// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  	{  		DebugLocation (116' 4);  		STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  		DebugLocation (117' 4);  		string stringText = (STRING7 != null ? STRING7.Text : default(string));  		stringText = stringText.Substring (1' stringText.Length - 2);  		filterNode = new Value (stringText);  	}  	break;  case 5:  	DebugEnterAlt (5);  	// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  	{  		DebugLocation (122' 4);  		REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  		DebugLocation (123' 4);  		string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  		regexText = regexText.Substring (1' regexText.Length - 2);  		filterNode = new RegExp (regexText);  	}  	break;  case 6:  	DebugEnterAlt (6);  	// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  	{  		DebugLocation (128' 4);  		NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  		DebugLocation (129' 4);  		filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  	}  	break;  case 7:  	DebugEnterAlt (7);  	// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  	{  		DebugLocation (132' 4);  		Match (input' TRUE' Follow._TRUE_in_filterExpr271);  		DebugLocation (133' 4);  		filterNode = new Value (true);  	}  	break;  case 8:  	DebugEnterAlt (8);  	// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  	{  		DebugLocation (136' 4);  		Match (input' FALSE' Follow._FALSE_in_filterExpr281);  		DebugLocation (137' 4);  		filterNode = new Value (false);  	}  	break;  case 9:  	DebugEnterAlt (9);  	// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  	{  		DebugLocation (140' 4);  		Match (input' NULL' Follow._NULL_in_filterExpr291);  		DebugLocation (141' 4);  		filterNode = new Value (null);  	}  	break;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: switch (alt9) {  case 1:  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  	{  		DebugLocation (64' 4);  		DebugLocation (64' 6);  		PushFollow (Follow._comparator_in_filterExpr175);  		comparator6 = comparator ();  		PopFollow ();  		Match (input' TokenTypes.Down' null);  		DebugLocation (64' 18);  		PushFollow (Follow._filterExpr_in_filterExpr179);  		a = filterExpr ();  		PopFollow ();  		DebugLocation (64' 31);  		PushFollow (Follow._filterExpr_in_filterExpr183);  		b = filterExpr ();  		PopFollow ();  		Match (input' TokenTypes.Up' null);  		DebugLocation (65' 4);  		Comparator newComparator;  		switch (comparator6) {  		case "=":  			newComparator = Comparator.Equals;  			break;  		case "!=":  			newComparator = Comparator.NotEquals;  			break;  		case ">":  			newComparator = Comparator.Greater;  			break;  		case "<":  			newComparator = Comparator.Less;  			break;  		case ">=":  			newComparator = Comparator.GreaterOrEqual;  			break;  		case "<=":  			newComparator = Comparator.LessOrEqual;  			break;  		case "&":  			newComparator = Comparator.And;  			break;  		case "|":  			newComparator = Comparator.Or;  			break;  		default:  			newComparator = Comparator.Equals;  			break;  		}  		filterNode = new BoolExpression (a' newComparator' b);  	}  	break;  case 2:  	DebugEnterAlt (2);  	// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  	{  		DebugLocation (98' 4);  		DebugLocation (98' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr195);  		Match (input' TokenTypes.Down' null);  		DebugLocation (98' 12);  		PushFollow (Follow._filterExpr_in_filterExpr199);  		f = filterExpr ();  		PopFollow ();  		DebugLocation (98' 31);  		// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  		int alt6 = 2;  		try {  			DebugEnterSubRule (6);  			try {  				DebugEnterDecision (6' false);  				int LA6_1 = input.LA (1);  				if ((LA6_1 == 24)) {  					alt6 = 1;  				}  			}  			finally {  				DebugExitDecision (6);  			}  			switch (alt6) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  				{  					DebugLocation (98' 31);  					inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (6);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (99' 4);  		FilterTreeNode newNode = f;  		if ((inverse != null ? inverse.Text : default(string)) == "!")  			newNode.ToggleInversed ();  		filterNode = newNode;  	}  	break;  case 3:  	DebugEnterAlt (3);  	// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  	{  		DebugLocation (105' 4);  		DebugLocation (105' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr216);  		Match (input' TokenTypes.Down' null);  		DebugLocation (105' 12);  		PushFollow (Follow._propertyChain_in_filterExpr219);  		propertyChain (propertySegments);  		PopFollow ();  		DebugLocation (105' 51);  		// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  		int alt7 = 2;  		try {  			DebugEnterSubRule (7);  			try {  				DebugEnterDecision (7' false);  				int LA7_1 = input.LA (1);  				if ((LA7_1 == 31)) {  					alt7 = 1;  				}  			}  			finally {  				DebugExitDecision (7);  			}  			switch (alt7) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  				{  					DebugLocation (105' 51);  					inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (7);  		}  		DebugLocation (105' 60);  		// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  		int alt8 = 2;  		try {  			DebugEnterSubRule (8);  			try {  				DebugEnterDecision (8' false);  				int LA8_1 = input.LA (1);  				if ((LA8_1 == 24)) {  					alt8 = 1;  				}  			}  			finally {  				DebugExitDecision (8);  			}  			switch (alt8) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  				{  					DebugLocation (105' 60);  					not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (8);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (106' 4);  		FilterTreeNode newProperty = new Property (propertySegments);  		if ((inverse != null ? inverse.Text : default(string)) == "?")  			filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  		else {  			if ((not != null ? not.Text : default(string)) == "!")  				newProperty.ToggleInversed ();  			filterNode = newProperty;  		}  	}  	break;  case 4:  	DebugEnterAlt (4);  	// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  	{  		DebugLocation (116' 4);  		STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  		DebugLocation (117' 4);  		string stringText = (STRING7 != null ? STRING7.Text : default(string));  		stringText = stringText.Substring (1' stringText.Length - 2);  		filterNode = new Value (stringText);  	}  	break;  case 5:  	DebugEnterAlt (5);  	// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  	{  		DebugLocation (122' 4);  		REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  		DebugLocation (123' 4);  		string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  		regexText = regexText.Substring (1' regexText.Length - 2);  		filterNode = new RegExp (regexText);  	}  	break;  case 6:  	DebugEnterAlt (6);  	// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  	{  		DebugLocation (128' 4);  		NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  		DebugLocation (129' 4);  		filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  	}  	break;  case 7:  	DebugEnterAlt (7);  	// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  	{  		DebugLocation (132' 4);  		Match (input' TRUE' Follow._TRUE_in_filterExpr271);  		DebugLocation (133' 4);  		filterNode = new Value (true);  	}  	break;  case 8:  	DebugEnterAlt (8);  	// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  	{  		DebugLocation (136' 4);  		Match (input' FALSE' Follow._FALSE_in_filterExpr281);  		DebugLocation (137' 4);  		filterNode = new Value (false);  	}  	break;  case 9:  	DebugEnterAlt (9);  	// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  	{  		DebugLocation (140' 4);  		Match (input' NULL' Follow._NULL_in_filterExpr291);  		DebugLocation (141' 4);  		filterNode = new Value (null);  	}  	break;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: switch (alt9) {  case 1:  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  	{  		DebugLocation (64' 4);  		DebugLocation (64' 6);  		PushFollow (Follow._comparator_in_filterExpr175);  		comparator6 = comparator ();  		PopFollow ();  		Match (input' TokenTypes.Down' null);  		DebugLocation (64' 18);  		PushFollow (Follow._filterExpr_in_filterExpr179);  		a = filterExpr ();  		PopFollow ();  		DebugLocation (64' 31);  		PushFollow (Follow._filterExpr_in_filterExpr183);  		b = filterExpr ();  		PopFollow ();  		Match (input' TokenTypes.Up' null);  		DebugLocation (65' 4);  		Comparator newComparator;  		switch (comparator6) {  		case "=":  			newComparator = Comparator.Equals;  			break;  		case "!=":  			newComparator = Comparator.NotEquals;  			break;  		case ">":  			newComparator = Comparator.Greater;  			break;  		case "<":  			newComparator = Comparator.Less;  			break;  		case ">=":  			newComparator = Comparator.GreaterOrEqual;  			break;  		case "<=":  			newComparator = Comparator.LessOrEqual;  			break;  		case "&":  			newComparator = Comparator.And;  			break;  		case "|":  			newComparator = Comparator.Or;  			break;  		default:  			newComparator = Comparator.Equals;  			break;  		}  		filterNode = new BoolExpression (a' newComparator' b);  	}  	break;  case 2:  	DebugEnterAlt (2);  	// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  	{  		DebugLocation (98' 4);  		DebugLocation (98' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr195);  		Match (input' TokenTypes.Down' null);  		DebugLocation (98' 12);  		PushFollow (Follow._filterExpr_in_filterExpr199);  		f = filterExpr ();  		PopFollow ();  		DebugLocation (98' 31);  		// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  		int alt6 = 2;  		try {  			DebugEnterSubRule (6);  			try {  				DebugEnterDecision (6' false);  				int LA6_1 = input.LA (1);  				if ((LA6_1 == 24)) {  					alt6 = 1;  				}  			}  			finally {  				DebugExitDecision (6);  			}  			switch (alt6) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  				{  					DebugLocation (98' 31);  					inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (6);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (99' 4);  		FilterTreeNode newNode = f;  		if ((inverse != null ? inverse.Text : default(string)) == "!")  			newNode.ToggleInversed ();  		filterNode = newNode;  	}  	break;  case 3:  	DebugEnterAlt (3);  	// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  	{  		DebugLocation (105' 4);  		DebugLocation (105' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr216);  		Match (input' TokenTypes.Down' null);  		DebugLocation (105' 12);  		PushFollow (Follow._propertyChain_in_filterExpr219);  		propertyChain (propertySegments);  		PopFollow ();  		DebugLocation (105' 51);  		// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  		int alt7 = 2;  		try {  			DebugEnterSubRule (7);  			try {  				DebugEnterDecision (7' false);  				int LA7_1 = input.LA (1);  				if ((LA7_1 == 31)) {  					alt7 = 1;  				}  			}  			finally {  				DebugExitDecision (7);  			}  			switch (alt7) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  				{  					DebugLocation (105' 51);  					inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (7);  		}  		DebugLocation (105' 60);  		// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  		int alt8 = 2;  		try {  			DebugEnterSubRule (8);  			try {  				DebugEnterDecision (8' false);  				int LA8_1 = input.LA (1);  				if ((LA8_1 == 24)) {  					alt8 = 1;  				}  			}  			finally {  				DebugExitDecision (8);  			}  			switch (alt8) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  				{  					DebugLocation (105' 60);  					not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (8);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (106' 4);  		FilterTreeNode newProperty = new Property (propertySegments);  		if ((inverse != null ? inverse.Text : default(string)) == "?")  			filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  		else {  			if ((not != null ? not.Text : default(string)) == "!")  				newProperty.ToggleInversed ();  			filterNode = newProperty;  		}  	}  	break;  case 4:  	DebugEnterAlt (4);  	// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  	{  		DebugLocation (116' 4);  		STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  		DebugLocation (117' 4);  		string stringText = (STRING7 != null ? STRING7.Text : default(string));  		stringText = stringText.Substring (1' stringText.Length - 2);  		filterNode = new Value (stringText);  	}  	break;  case 5:  	DebugEnterAlt (5);  	// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  	{  		DebugLocation (122' 4);  		REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  		DebugLocation (123' 4);  		string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  		regexText = regexText.Substring (1' regexText.Length - 2);  		filterNode = new RegExp (regexText);  	}  	break;  case 6:  	DebugEnterAlt (6);  	// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  	{  		DebugLocation (128' 4);  		NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  		DebugLocation (129' 4);  		filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  	}  	break;  case 7:  	DebugEnterAlt (7);  	// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  	{  		DebugLocation (132' 4);  		Match (input' TRUE' Follow._TRUE_in_filterExpr271);  		DebugLocation (133' 4);  		filterNode = new Value (true);  	}  	break;  case 8:  	DebugEnterAlt (8);  	// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  	{  		DebugLocation (136' 4);  		Match (input' FALSE' Follow._FALSE_in_filterExpr281);  		DebugLocation (137' 4);  		filterNode = new Value (false);  	}  	break;  case 9:  	DebugEnterAlt (9);  	// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  	{  		DebugLocation (140' 4);  		Match (input' NULL' Follow._NULL_in_filterExpr291);  		DebugLocation (141' 4);  		filterNode = new Value (null);  	}  	break;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: switch (alt9) {  case 1:  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  	{  		DebugLocation (64' 4);  		DebugLocation (64' 6);  		PushFollow (Follow._comparator_in_filterExpr175);  		comparator6 = comparator ();  		PopFollow ();  		Match (input' TokenTypes.Down' null);  		DebugLocation (64' 18);  		PushFollow (Follow._filterExpr_in_filterExpr179);  		a = filterExpr ();  		PopFollow ();  		DebugLocation (64' 31);  		PushFollow (Follow._filterExpr_in_filterExpr183);  		b = filterExpr ();  		PopFollow ();  		Match (input' TokenTypes.Up' null);  		DebugLocation (65' 4);  		Comparator newComparator;  		switch (comparator6) {  		case "=":  			newComparator = Comparator.Equals;  			break;  		case "!=":  			newComparator = Comparator.NotEquals;  			break;  		case ">":  			newComparator = Comparator.Greater;  			break;  		case "<":  			newComparator = Comparator.Less;  			break;  		case ">=":  			newComparator = Comparator.GreaterOrEqual;  			break;  		case "<=":  			newComparator = Comparator.LessOrEqual;  			break;  		case "&":  			newComparator = Comparator.And;  			break;  		case "|":  			newComparator = Comparator.Or;  			break;  		default:  			newComparator = Comparator.Equals;  			break;  		}  		filterNode = new BoolExpression (a' newComparator' b);  	}  	break;  case 2:  	DebugEnterAlt (2);  	// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  	{  		DebugLocation (98' 4);  		DebugLocation (98' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr195);  		Match (input' TokenTypes.Down' null);  		DebugLocation (98' 12);  		PushFollow (Follow._filterExpr_in_filterExpr199);  		f = filterExpr ();  		PopFollow ();  		DebugLocation (98' 31);  		// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  		int alt6 = 2;  		try {  			DebugEnterSubRule (6);  			try {  				DebugEnterDecision (6' false);  				int LA6_1 = input.LA (1);  				if ((LA6_1 == 24)) {  					alt6 = 1;  				}  			}  			finally {  				DebugExitDecision (6);  			}  			switch (alt6) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  				{  					DebugLocation (98' 31);  					inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (6);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (99' 4);  		FilterTreeNode newNode = f;  		if ((inverse != null ? inverse.Text : default(string)) == "!")  			newNode.ToggleInversed ();  		filterNode = newNode;  	}  	break;  case 3:  	DebugEnterAlt (3);  	// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  	{  		DebugLocation (105' 4);  		DebugLocation (105' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr216);  		Match (input' TokenTypes.Down' null);  		DebugLocation (105' 12);  		PushFollow (Follow._propertyChain_in_filterExpr219);  		propertyChain (propertySegments);  		PopFollow ();  		DebugLocation (105' 51);  		// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  		int alt7 = 2;  		try {  			DebugEnterSubRule (7);  			try {  				DebugEnterDecision (7' false);  				int LA7_1 = input.LA (1);  				if ((LA7_1 == 31)) {  					alt7 = 1;  				}  			}  			finally {  				DebugExitDecision (7);  			}  			switch (alt7) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  				{  					DebugLocation (105' 51);  					inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (7);  		}  		DebugLocation (105' 60);  		// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  		int alt8 = 2;  		try {  			DebugEnterSubRule (8);  			try {  				DebugEnterDecision (8' false);  				int LA8_1 = input.LA (1);  				if ((LA8_1 == 24)) {  					alt8 = 1;  				}  			}  			finally {  				DebugExitDecision (8);  			}  			switch (alt8) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  				{  					DebugLocation (105' 60);  					not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (8);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (106' 4);  		FilterTreeNode newProperty = new Property (propertySegments);  		if ((inverse != null ? inverse.Text : default(string)) == "?")  			filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  		else {  			if ((not != null ? not.Text : default(string)) == "!")  				newProperty.ToggleInversed ();  			filterNode = newProperty;  		}  	}  	break;  case 4:  	DebugEnterAlt (4);  	// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  	{  		DebugLocation (116' 4);  		STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  		DebugLocation (117' 4);  		string stringText = (STRING7 != null ? STRING7.Text : default(string));  		stringText = stringText.Substring (1' stringText.Length - 2);  		filterNode = new Value (stringText);  	}  	break;  case 5:  	DebugEnterAlt (5);  	// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  	{  		DebugLocation (122' 4);  		REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  		DebugLocation (123' 4);  		string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  		regexText = regexText.Substring (1' regexText.Length - 2);  		filterNode = new RegExp (regexText);  	}  	break;  case 6:  	DebugEnterAlt (6);  	// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  	{  		DebugLocation (128' 4);  		NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  		DebugLocation (129' 4);  		filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  	}  	break;  case 7:  	DebugEnterAlt (7);  	// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  	{  		DebugLocation (132' 4);  		Match (input' TRUE' Follow._TRUE_in_filterExpr271);  		DebugLocation (133' 4);  		filterNode = new Value (true);  	}  	break;  case 8:  	DebugEnterAlt (8);  	// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  	{  		DebugLocation (136' 4);  		Match (input' FALSE' Follow._FALSE_in_filterExpr281);  		DebugLocation (137' 4);  		filterNode = new Value (false);  	}  	break;  case 9:  	DebugEnterAlt (9);  	// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  	{  		DebugLocation (140' 4);  		Match (input' NULL' Follow._NULL_in_filterExpr291);  		DebugLocation (141' 4);  		filterNode = new Value (null);  	}  	break;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: switch (alt9) {  case 1:  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  	{  		DebugLocation (64' 4);  		DebugLocation (64' 6);  		PushFollow (Follow._comparator_in_filterExpr175);  		comparator6 = comparator ();  		PopFollow ();  		Match (input' TokenTypes.Down' null);  		DebugLocation (64' 18);  		PushFollow (Follow._filterExpr_in_filterExpr179);  		a = filterExpr ();  		PopFollow ();  		DebugLocation (64' 31);  		PushFollow (Follow._filterExpr_in_filterExpr183);  		b = filterExpr ();  		PopFollow ();  		Match (input' TokenTypes.Up' null);  		DebugLocation (65' 4);  		Comparator newComparator;  		switch (comparator6) {  		case "=":  			newComparator = Comparator.Equals;  			break;  		case "!=":  			newComparator = Comparator.NotEquals;  			break;  		case ">":  			newComparator = Comparator.Greater;  			break;  		case "<":  			newComparator = Comparator.Less;  			break;  		case ">=":  			newComparator = Comparator.GreaterOrEqual;  			break;  		case "<=":  			newComparator = Comparator.LessOrEqual;  			break;  		case "&":  			newComparator = Comparator.And;  			break;  		case "|":  			newComparator = Comparator.Or;  			break;  		default:  			newComparator = Comparator.Equals;  			break;  		}  		filterNode = new BoolExpression (a' newComparator' b);  	}  	break;  case 2:  	DebugEnterAlt (2);  	// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  	{  		DebugLocation (98' 4);  		DebugLocation (98' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr195);  		Match (input' TokenTypes.Down' null);  		DebugLocation (98' 12);  		PushFollow (Follow._filterExpr_in_filterExpr199);  		f = filterExpr ();  		PopFollow ();  		DebugLocation (98' 31);  		// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  		int alt6 = 2;  		try {  			DebugEnterSubRule (6);  			try {  				DebugEnterDecision (6' false);  				int LA6_1 = input.LA (1);  				if ((LA6_1 == 24)) {  					alt6 = 1;  				}  			}  			finally {  				DebugExitDecision (6);  			}  			switch (alt6) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  				{  					DebugLocation (98' 31);  					inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (6);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (99' 4);  		FilterTreeNode newNode = f;  		if ((inverse != null ? inverse.Text : default(string)) == "!")  			newNode.ToggleInversed ();  		filterNode = newNode;  	}  	break;  case 3:  	DebugEnterAlt (3);  	// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  	{  		DebugLocation (105' 4);  		DebugLocation (105' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr216);  		Match (input' TokenTypes.Down' null);  		DebugLocation (105' 12);  		PushFollow (Follow._propertyChain_in_filterExpr219);  		propertyChain (propertySegments);  		PopFollow ();  		DebugLocation (105' 51);  		// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  		int alt7 = 2;  		try {  			DebugEnterSubRule (7);  			try {  				DebugEnterDecision (7' false);  				int LA7_1 = input.LA (1);  				if ((LA7_1 == 31)) {  					alt7 = 1;  				}  			}  			finally {  				DebugExitDecision (7);  			}  			switch (alt7) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  				{  					DebugLocation (105' 51);  					inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (7);  		}  		DebugLocation (105' 60);  		// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  		int alt8 = 2;  		try {  			DebugEnterSubRule (8);  			try {  				DebugEnterDecision (8' false);  				int LA8_1 = input.LA (1);  				if ((LA8_1 == 24)) {  					alt8 = 1;  				}  			}  			finally {  				DebugExitDecision (8);  			}  			switch (alt8) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  				{  					DebugLocation (105' 60);  					not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (8);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (106' 4);  		FilterTreeNode newProperty = new Property (propertySegments);  		if ((inverse != null ? inverse.Text : default(string)) == "?")  			filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  		else {  			if ((not != null ? not.Text : default(string)) == "!")  				newProperty.ToggleInversed ();  			filterNode = newProperty;  		}  	}  	break;  case 4:  	DebugEnterAlt (4);  	// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  	{  		DebugLocation (116' 4);  		STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  		DebugLocation (117' 4);  		string stringText = (STRING7 != null ? STRING7.Text : default(string));  		stringText = stringText.Substring (1' stringText.Length - 2);  		filterNode = new Value (stringText);  	}  	break;  case 5:  	DebugEnterAlt (5);  	// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  	{  		DebugLocation (122' 4);  		REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  		DebugLocation (123' 4);  		string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  		regexText = regexText.Substring (1' regexText.Length - 2);  		filterNode = new RegExp (regexText);  	}  	break;  case 6:  	DebugEnterAlt (6);  	// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  	{  		DebugLocation (128' 4);  		NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  		DebugLocation (129' 4);  		filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  	}  	break;  case 7:  	DebugEnterAlt (7);  	// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  	{  		DebugLocation (132' 4);  		Match (input' TRUE' Follow._TRUE_in_filterExpr271);  		DebugLocation (133' 4);  		filterNode = new Value (true);  	}  	break;  case 8:  	DebugEnterAlt (8);  	// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  	{  		DebugLocation (136' 4);  		Match (input' FALSE' Follow._FALSE_in_filterExpr281);  		DebugLocation (137' 4);  		filterNode = new Value (false);  	}  	break;  case 9:  	DebugEnterAlt (9);  	// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  	{  		DebugLocation (140' 4);  		Match (input' NULL' Follow._NULL_in_filterExpr291);  		DebugLocation (141' 4);  		filterNode = new Value (null);  	}  	break;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: switch (alt9) {  case 1:  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  	{  		DebugLocation (64' 4);  		DebugLocation (64' 6);  		PushFollow (Follow._comparator_in_filterExpr175);  		comparator6 = comparator ();  		PopFollow ();  		Match (input' TokenTypes.Down' null);  		DebugLocation (64' 18);  		PushFollow (Follow._filterExpr_in_filterExpr179);  		a = filterExpr ();  		PopFollow ();  		DebugLocation (64' 31);  		PushFollow (Follow._filterExpr_in_filterExpr183);  		b = filterExpr ();  		PopFollow ();  		Match (input' TokenTypes.Up' null);  		DebugLocation (65' 4);  		Comparator newComparator;  		switch (comparator6) {  		case "=":  			newComparator = Comparator.Equals;  			break;  		case "!=":  			newComparator = Comparator.NotEquals;  			break;  		case ">":  			newComparator = Comparator.Greater;  			break;  		case "<":  			newComparator = Comparator.Less;  			break;  		case ">=":  			newComparator = Comparator.GreaterOrEqual;  			break;  		case "<=":  			newComparator = Comparator.LessOrEqual;  			break;  		case "&":  			newComparator = Comparator.And;  			break;  		case "|":  			newComparator = Comparator.Or;  			break;  		default:  			newComparator = Comparator.Equals;  			break;  		}  		filterNode = new BoolExpression (a' newComparator' b);  	}  	break;  case 2:  	DebugEnterAlt (2);  	// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  	{  		DebugLocation (98' 4);  		DebugLocation (98' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr195);  		Match (input' TokenTypes.Down' null);  		DebugLocation (98' 12);  		PushFollow (Follow._filterExpr_in_filterExpr199);  		f = filterExpr ();  		PopFollow ();  		DebugLocation (98' 31);  		// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  		int alt6 = 2;  		try {  			DebugEnterSubRule (6);  			try {  				DebugEnterDecision (6' false);  				int LA6_1 = input.LA (1);  				if ((LA6_1 == 24)) {  					alt6 = 1;  				}  			}  			finally {  				DebugExitDecision (6);  			}  			switch (alt6) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  				{  					DebugLocation (98' 31);  					inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (6);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (99' 4);  		FilterTreeNode newNode = f;  		if ((inverse != null ? inverse.Text : default(string)) == "!")  			newNode.ToggleInversed ();  		filterNode = newNode;  	}  	break;  case 3:  	DebugEnterAlt (3);  	// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  	{  		DebugLocation (105' 4);  		DebugLocation (105' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr216);  		Match (input' TokenTypes.Down' null);  		DebugLocation (105' 12);  		PushFollow (Follow._propertyChain_in_filterExpr219);  		propertyChain (propertySegments);  		PopFollow ();  		DebugLocation (105' 51);  		// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  		int alt7 = 2;  		try {  			DebugEnterSubRule (7);  			try {  				DebugEnterDecision (7' false);  				int LA7_1 = input.LA (1);  				if ((LA7_1 == 31)) {  					alt7 = 1;  				}  			}  			finally {  				DebugExitDecision (7);  			}  			switch (alt7) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  				{  					DebugLocation (105' 51);  					inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (7);  		}  		DebugLocation (105' 60);  		// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  		int alt8 = 2;  		try {  			DebugEnterSubRule (8);  			try {  				DebugEnterDecision (8' false);  				int LA8_1 = input.LA (1);  				if ((LA8_1 == 24)) {  					alt8 = 1;  				}  			}  			finally {  				DebugExitDecision (8);  			}  			switch (alt8) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  				{  					DebugLocation (105' 60);  					not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (8);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (106' 4);  		FilterTreeNode newProperty = new Property (propertySegments);  		if ((inverse != null ? inverse.Text : default(string)) == "?")  			filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  		else {  			if ((not != null ? not.Text : default(string)) == "!")  				newProperty.ToggleInversed ();  			filterNode = newProperty;  		}  	}  	break;  case 4:  	DebugEnterAlt (4);  	// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  	{  		DebugLocation (116' 4);  		STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  		DebugLocation (117' 4);  		string stringText = (STRING7 != null ? STRING7.Text : default(string));  		stringText = stringText.Substring (1' stringText.Length - 2);  		filterNode = new Value (stringText);  	}  	break;  case 5:  	DebugEnterAlt (5);  	// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  	{  		DebugLocation (122' 4);  		REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  		DebugLocation (123' 4);  		string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  		regexText = regexText.Substring (1' regexText.Length - 2);  		filterNode = new RegExp (regexText);  	}  	break;  case 6:  	DebugEnterAlt (6);  	// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  	{  		DebugLocation (128' 4);  		NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  		DebugLocation (129' 4);  		filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  	}  	break;  case 7:  	DebugEnterAlt (7);  	// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  	{  		DebugLocation (132' 4);  		Match (input' TRUE' Follow._TRUE_in_filterExpr271);  		DebugLocation (133' 4);  		filterNode = new Value (true);  	}  	break;  case 8:  	DebugEnterAlt (8);  	// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  	{  		DebugLocation (136' 4);  		Match (input' FALSE' Follow._FALSE_in_filterExpr281);  		DebugLocation (137' 4);  		filterNode = new Value (false);  	}  	break;  case 9:  	DebugEnterAlt (9);  	// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  	{  		DebugLocation (140' 4);  		Match (input' NULL' Follow._NULL_in_filterExpr291);  		DebugLocation (141' 4);  		filterNode = new Value (null);  	}  	break;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: switch (alt9) {  case 1:  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  	{  		DebugLocation (64' 4);  		DebugLocation (64' 6);  		PushFollow (Follow._comparator_in_filterExpr175);  		comparator6 = comparator ();  		PopFollow ();  		Match (input' TokenTypes.Down' null);  		DebugLocation (64' 18);  		PushFollow (Follow._filterExpr_in_filterExpr179);  		a = filterExpr ();  		PopFollow ();  		DebugLocation (64' 31);  		PushFollow (Follow._filterExpr_in_filterExpr183);  		b = filterExpr ();  		PopFollow ();  		Match (input' TokenTypes.Up' null);  		DebugLocation (65' 4);  		Comparator newComparator;  		switch (comparator6) {  		case "=":  			newComparator = Comparator.Equals;  			break;  		case "!=":  			newComparator = Comparator.NotEquals;  			break;  		case ">":  			newComparator = Comparator.Greater;  			break;  		case "<":  			newComparator = Comparator.Less;  			break;  		case ">=":  			newComparator = Comparator.GreaterOrEqual;  			break;  		case "<=":  			newComparator = Comparator.LessOrEqual;  			break;  		case "&":  			newComparator = Comparator.And;  			break;  		case "|":  			newComparator = Comparator.Or;  			break;  		default:  			newComparator = Comparator.Equals;  			break;  		}  		filterNode = new BoolExpression (a' newComparator' b);  	}  	break;  case 2:  	DebugEnterAlt (2);  	// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  	{  		DebugLocation (98' 4);  		DebugLocation (98' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr195);  		Match (input' TokenTypes.Down' null);  		DebugLocation (98' 12);  		PushFollow (Follow._filterExpr_in_filterExpr199);  		f = filterExpr ();  		PopFollow ();  		DebugLocation (98' 31);  		// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  		int alt6 = 2;  		try {  			DebugEnterSubRule (6);  			try {  				DebugEnterDecision (6' false);  				int LA6_1 = input.LA (1);  				if ((LA6_1 == 24)) {  					alt6 = 1;  				}  			}  			finally {  				DebugExitDecision (6);  			}  			switch (alt6) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  				{  					DebugLocation (98' 31);  					inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (6);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (99' 4);  		FilterTreeNode newNode = f;  		if ((inverse != null ? inverse.Text : default(string)) == "!")  			newNode.ToggleInversed ();  		filterNode = newNode;  	}  	break;  case 3:  	DebugEnterAlt (3);  	// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  	{  		DebugLocation (105' 4);  		DebugLocation (105' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr216);  		Match (input' TokenTypes.Down' null);  		DebugLocation (105' 12);  		PushFollow (Follow._propertyChain_in_filterExpr219);  		propertyChain (propertySegments);  		PopFollow ();  		DebugLocation (105' 51);  		// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  		int alt7 = 2;  		try {  			DebugEnterSubRule (7);  			try {  				DebugEnterDecision (7' false);  				int LA7_1 = input.LA (1);  				if ((LA7_1 == 31)) {  					alt7 = 1;  				}  			}  			finally {  				DebugExitDecision (7);  			}  			switch (alt7) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  				{  					DebugLocation (105' 51);  					inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (7);  		}  		DebugLocation (105' 60);  		// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  		int alt8 = 2;  		try {  			DebugEnterSubRule (8);  			try {  				DebugEnterDecision (8' false);  				int LA8_1 = input.LA (1);  				if ((LA8_1 == 24)) {  					alt8 = 1;  				}  			}  			finally {  				DebugExitDecision (8);  			}  			switch (alt8) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  				{  					DebugLocation (105' 60);  					not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (8);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (106' 4);  		FilterTreeNode newProperty = new Property (propertySegments);  		if ((inverse != null ? inverse.Text : default(string)) == "?")  			filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  		else {  			if ((not != null ? not.Text : default(string)) == "!")  				newProperty.ToggleInversed ();  			filterNode = newProperty;  		}  	}  	break;  case 4:  	DebugEnterAlt (4);  	// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  	{  		DebugLocation (116' 4);  		STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  		DebugLocation (117' 4);  		string stringText = (STRING7 != null ? STRING7.Text : default(string));  		stringText = stringText.Substring (1' stringText.Length - 2);  		filterNode = new Value (stringText);  	}  	break;  case 5:  	DebugEnterAlt (5);  	// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  	{  		DebugLocation (122' 4);  		REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  		DebugLocation (123' 4);  		string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  		regexText = regexText.Substring (1' regexText.Length - 2);  		filterNode = new RegExp (regexText);  	}  	break;  case 6:  	DebugEnterAlt (6);  	// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  	{  		DebugLocation (128' 4);  		NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  		DebugLocation (129' 4);  		filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  	}  	break;  case 7:  	DebugEnterAlt (7);  	// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  	{  		DebugLocation (132' 4);  		Match (input' TRUE' Follow._TRUE_in_filterExpr271);  		DebugLocation (133' 4);  		filterNode = new Value (true);  	}  	break;  case 8:  	DebugEnterAlt (8);  	// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  	{  		DebugLocation (136' 4);  		Match (input' FALSE' Follow._FALSE_in_filterExpr281);  		DebugLocation (137' 4);  		filterNode = new Value (false);  	}  	break;  case 9:  	DebugEnterAlt (9);  	// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  	{  		DebugLocation (140' 4);  		Match (input' NULL' Follow._NULL_in_filterExpr291);  		DebugLocation (141' 4);  		filterNode = new Value (null);  	}  	break;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: switch (alt9) {  case 1:  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  	{  		DebugLocation (64' 4);  		DebugLocation (64' 6);  		PushFollow (Follow._comparator_in_filterExpr175);  		comparator6 = comparator ();  		PopFollow ();  		Match (input' TokenTypes.Down' null);  		DebugLocation (64' 18);  		PushFollow (Follow._filterExpr_in_filterExpr179);  		a = filterExpr ();  		PopFollow ();  		DebugLocation (64' 31);  		PushFollow (Follow._filterExpr_in_filterExpr183);  		b = filterExpr ();  		PopFollow ();  		Match (input' TokenTypes.Up' null);  		DebugLocation (65' 4);  		Comparator newComparator;  		switch (comparator6) {  		case "=":  			newComparator = Comparator.Equals;  			break;  		case "!=":  			newComparator = Comparator.NotEquals;  			break;  		case ">":  			newComparator = Comparator.Greater;  			break;  		case "<":  			newComparator = Comparator.Less;  			break;  		case ">=":  			newComparator = Comparator.GreaterOrEqual;  			break;  		case "<=":  			newComparator = Comparator.LessOrEqual;  			break;  		case "&":  			newComparator = Comparator.And;  			break;  		case "|":  			newComparator = Comparator.Or;  			break;  		default:  			newComparator = Comparator.Equals;  			break;  		}  		filterNode = new BoolExpression (a' newComparator' b);  	}  	break;  case 2:  	DebugEnterAlt (2);  	// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  	{  		DebugLocation (98' 4);  		DebugLocation (98' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr195);  		Match (input' TokenTypes.Down' null);  		DebugLocation (98' 12);  		PushFollow (Follow._filterExpr_in_filterExpr199);  		f = filterExpr ();  		PopFollow ();  		DebugLocation (98' 31);  		// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  		int alt6 = 2;  		try {  			DebugEnterSubRule (6);  			try {  				DebugEnterDecision (6' false);  				int LA6_1 = input.LA (1);  				if ((LA6_1 == 24)) {  					alt6 = 1;  				}  			}  			finally {  				DebugExitDecision (6);  			}  			switch (alt6) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  				{  					DebugLocation (98' 31);  					inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (6);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (99' 4);  		FilterTreeNode newNode = f;  		if ((inverse != null ? inverse.Text : default(string)) == "!")  			newNode.ToggleInversed ();  		filterNode = newNode;  	}  	break;  case 3:  	DebugEnterAlt (3);  	// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  	{  		DebugLocation (105' 4);  		DebugLocation (105' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr216);  		Match (input' TokenTypes.Down' null);  		DebugLocation (105' 12);  		PushFollow (Follow._propertyChain_in_filterExpr219);  		propertyChain (propertySegments);  		PopFollow ();  		DebugLocation (105' 51);  		// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  		int alt7 = 2;  		try {  			DebugEnterSubRule (7);  			try {  				DebugEnterDecision (7' false);  				int LA7_1 = input.LA (1);  				if ((LA7_1 == 31)) {  					alt7 = 1;  				}  			}  			finally {  				DebugExitDecision (7);  			}  			switch (alt7) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  				{  					DebugLocation (105' 51);  					inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (7);  		}  		DebugLocation (105' 60);  		// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  		int alt8 = 2;  		try {  			DebugEnterSubRule (8);  			try {  				DebugEnterDecision (8' false);  				int LA8_1 = input.LA (1);  				if ((LA8_1 == 24)) {  					alt8 = 1;  				}  			}  			finally {  				DebugExitDecision (8);  			}  			switch (alt8) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  				{  					DebugLocation (105' 60);  					not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (8);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (106' 4);  		FilterTreeNode newProperty = new Property (propertySegments);  		if ((inverse != null ? inverse.Text : default(string)) == "?")  			filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  		else {  			if ((not != null ? not.Text : default(string)) == "!")  				newProperty.ToggleInversed ();  			filterNode = newProperty;  		}  	}  	break;  case 4:  	DebugEnterAlt (4);  	// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  	{  		DebugLocation (116' 4);  		STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  		DebugLocation (117' 4);  		string stringText = (STRING7 != null ? STRING7.Text : default(string));  		stringText = stringText.Substring (1' stringText.Length - 2);  		filterNode = new Value (stringText);  	}  	break;  case 5:  	DebugEnterAlt (5);  	// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  	{  		DebugLocation (122' 4);  		REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  		DebugLocation (123' 4);  		string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  		regexText = regexText.Substring (1' regexText.Length - 2);  		filterNode = new RegExp (regexText);  	}  	break;  case 6:  	DebugEnterAlt (6);  	// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  	{  		DebugLocation (128' 4);  		NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  		DebugLocation (129' 4);  		filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  	}  	break;  case 7:  	DebugEnterAlt (7);  	// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  	{  		DebugLocation (132' 4);  		Match (input' TRUE' Follow._TRUE_in_filterExpr271);  		DebugLocation (133' 4);  		filterNode = new Value (true);  	}  	break;  case 8:  	DebugEnterAlt (8);  	// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  	{  		DebugLocation (136' 4);  		Match (input' FALSE' Follow._FALSE_in_filterExpr281);  		DebugLocation (137' 4);  		filterNode = new Value (false);  	}  	break;  case 9:  	DebugEnterAlt (9);  	// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  	{  		DebugLocation (140' 4);  		Match (input' NULL' Follow._NULL_in_filterExpr291);  		DebugLocation (141' 4);  		filterNode = new Value (null);  	}  	break;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: switch (alt9) {  case 1:  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  	{  		DebugLocation (64' 4);  		DebugLocation (64' 6);  		PushFollow (Follow._comparator_in_filterExpr175);  		comparator6 = comparator ();  		PopFollow ();  		Match (input' TokenTypes.Down' null);  		DebugLocation (64' 18);  		PushFollow (Follow._filterExpr_in_filterExpr179);  		a = filterExpr ();  		PopFollow ();  		DebugLocation (64' 31);  		PushFollow (Follow._filterExpr_in_filterExpr183);  		b = filterExpr ();  		PopFollow ();  		Match (input' TokenTypes.Up' null);  		DebugLocation (65' 4);  		Comparator newComparator;  		switch (comparator6) {  		case "=":  			newComparator = Comparator.Equals;  			break;  		case "!=":  			newComparator = Comparator.NotEquals;  			break;  		case ">":  			newComparator = Comparator.Greater;  			break;  		case "<":  			newComparator = Comparator.Less;  			break;  		case ">=":  			newComparator = Comparator.GreaterOrEqual;  			break;  		case "<=":  			newComparator = Comparator.LessOrEqual;  			break;  		case "&":  			newComparator = Comparator.And;  			break;  		case "|":  			newComparator = Comparator.Or;  			break;  		default:  			newComparator = Comparator.Equals;  			break;  		}  		filterNode = new BoolExpression (a' newComparator' b);  	}  	break;  case 2:  	DebugEnterAlt (2);  	// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  	{  		DebugLocation (98' 4);  		DebugLocation (98' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr195);  		Match (input' TokenTypes.Down' null);  		DebugLocation (98' 12);  		PushFollow (Follow._filterExpr_in_filterExpr199);  		f = filterExpr ();  		PopFollow ();  		DebugLocation (98' 31);  		// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  		int alt6 = 2;  		try {  			DebugEnterSubRule (6);  			try {  				DebugEnterDecision (6' false);  				int LA6_1 = input.LA (1);  				if ((LA6_1 == 24)) {  					alt6 = 1;  				}  			}  			finally {  				DebugExitDecision (6);  			}  			switch (alt6) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  				{  					DebugLocation (98' 31);  					inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (6);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (99' 4);  		FilterTreeNode newNode = f;  		if ((inverse != null ? inverse.Text : default(string)) == "!")  			newNode.ToggleInversed ();  		filterNode = newNode;  	}  	break;  case 3:  	DebugEnterAlt (3);  	// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  	{  		DebugLocation (105' 4);  		DebugLocation (105' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr216);  		Match (input' TokenTypes.Down' null);  		DebugLocation (105' 12);  		PushFollow (Follow._propertyChain_in_filterExpr219);  		propertyChain (propertySegments);  		PopFollow ();  		DebugLocation (105' 51);  		// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  		int alt7 = 2;  		try {  			DebugEnterSubRule (7);  			try {  				DebugEnterDecision (7' false);  				int LA7_1 = input.LA (1);  				if ((LA7_1 == 31)) {  					alt7 = 1;  				}  			}  			finally {  				DebugExitDecision (7);  			}  			switch (alt7) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  				{  					DebugLocation (105' 51);  					inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (7);  		}  		DebugLocation (105' 60);  		// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  		int alt8 = 2;  		try {  			DebugEnterSubRule (8);  			try {  				DebugEnterDecision (8' false);  				int LA8_1 = input.LA (1);  				if ((LA8_1 == 24)) {  					alt8 = 1;  				}  			}  			finally {  				DebugExitDecision (8);  			}  			switch (alt8) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  				{  					DebugLocation (105' 60);  					not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (8);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (106' 4);  		FilterTreeNode newProperty = new Property (propertySegments);  		if ((inverse != null ? inverse.Text : default(string)) == "?")  			filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  		else {  			if ((not != null ? not.Text : default(string)) == "!")  				newProperty.ToggleInversed ();  			filterNode = newProperty;  		}  	}  	break;  case 4:  	DebugEnterAlt (4);  	// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  	{  		DebugLocation (116' 4);  		STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  		DebugLocation (117' 4);  		string stringText = (STRING7 != null ? STRING7.Text : default(string));  		stringText = stringText.Substring (1' stringText.Length - 2);  		filterNode = new Value (stringText);  	}  	break;  case 5:  	DebugEnterAlt (5);  	// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  	{  		DebugLocation (122' 4);  		REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  		DebugLocation (123' 4);  		string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  		regexText = regexText.Substring (1' regexText.Length - 2);  		filterNode = new RegExp (regexText);  	}  	break;  case 6:  	DebugEnterAlt (6);  	// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  	{  		DebugLocation (128' 4);  		NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  		DebugLocation (129' 4);  		filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  	}  	break;  case 7:  	DebugEnterAlt (7);  	// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  	{  		DebugLocation (132' 4);  		Match (input' TRUE' Follow._TRUE_in_filterExpr271);  		DebugLocation (133' 4);  		filterNode = new Value (true);  	}  	break;  case 8:  	DebugEnterAlt (8);  	// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  	{  		DebugLocation (136' 4);  		Match (input' FALSE' Follow._FALSE_in_filterExpr281);  		DebugLocation (137' 4);  		filterNode = new Value (false);  	}  	break;  case 9:  	DebugEnterAlt (9);  	// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  	{  		DebugLocation (140' 4);  		Match (input' NULL' Follow._NULL_in_filterExpr291);  		DebugLocation (141' 4);  		filterNode = new Value (null);  	}  	break;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: switch (alt9) {  case 1:  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  	{  		DebugLocation (64' 4);  		DebugLocation (64' 6);  		PushFollow (Follow._comparator_in_filterExpr175);  		comparator6 = comparator ();  		PopFollow ();  		Match (input' TokenTypes.Down' null);  		DebugLocation (64' 18);  		PushFollow (Follow._filterExpr_in_filterExpr179);  		a = filterExpr ();  		PopFollow ();  		DebugLocation (64' 31);  		PushFollow (Follow._filterExpr_in_filterExpr183);  		b = filterExpr ();  		PopFollow ();  		Match (input' TokenTypes.Up' null);  		DebugLocation (65' 4);  		Comparator newComparator;  		switch (comparator6) {  		case "=":  			newComparator = Comparator.Equals;  			break;  		case "!=":  			newComparator = Comparator.NotEquals;  			break;  		case ">":  			newComparator = Comparator.Greater;  			break;  		case "<":  			newComparator = Comparator.Less;  			break;  		case ">=":  			newComparator = Comparator.GreaterOrEqual;  			break;  		case "<=":  			newComparator = Comparator.LessOrEqual;  			break;  		case "&":  			newComparator = Comparator.And;  			break;  		case "|":  			newComparator = Comparator.Or;  			break;  		default:  			newComparator = Comparator.Equals;  			break;  		}  		filterNode = new BoolExpression (a' newComparator' b);  	}  	break;  case 2:  	DebugEnterAlt (2);  	// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  	{  		DebugLocation (98' 4);  		DebugLocation (98' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr195);  		Match (input' TokenTypes.Down' null);  		DebugLocation (98' 12);  		PushFollow (Follow._filterExpr_in_filterExpr199);  		f = filterExpr ();  		PopFollow ();  		DebugLocation (98' 31);  		// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  		int alt6 = 2;  		try {  			DebugEnterSubRule (6);  			try {  				DebugEnterDecision (6' false);  				int LA6_1 = input.LA (1);  				if ((LA6_1 == 24)) {  					alt6 = 1;  				}  			}  			finally {  				DebugExitDecision (6);  			}  			switch (alt6) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  				{  					DebugLocation (98' 31);  					inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (6);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (99' 4);  		FilterTreeNode newNode = f;  		if ((inverse != null ? inverse.Text : default(string)) == "!")  			newNode.ToggleInversed ();  		filterNode = newNode;  	}  	break;  case 3:  	DebugEnterAlt (3);  	// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  	{  		DebugLocation (105' 4);  		DebugLocation (105' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr216);  		Match (input' TokenTypes.Down' null);  		DebugLocation (105' 12);  		PushFollow (Follow._propertyChain_in_filterExpr219);  		propertyChain (propertySegments);  		PopFollow ();  		DebugLocation (105' 51);  		// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  		int alt7 = 2;  		try {  			DebugEnterSubRule (7);  			try {  				DebugEnterDecision (7' false);  				int LA7_1 = input.LA (1);  				if ((LA7_1 == 31)) {  					alt7 = 1;  				}  			}  			finally {  				DebugExitDecision (7);  			}  			switch (alt7) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  				{  					DebugLocation (105' 51);  					inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (7);  		}  		DebugLocation (105' 60);  		// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  		int alt8 = 2;  		try {  			DebugEnterSubRule (8);  			try {  				DebugEnterDecision (8' false);  				int LA8_1 = input.LA (1);  				if ((LA8_1 == 24)) {  					alt8 = 1;  				}  			}  			finally {  				DebugExitDecision (8);  			}  			switch (alt8) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  				{  					DebugLocation (105' 60);  					not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (8);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (106' 4);  		FilterTreeNode newProperty = new Property (propertySegments);  		if ((inverse != null ? inverse.Text : default(string)) == "?")  			filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  		else {  			if ((not != null ? not.Text : default(string)) == "!")  				newProperty.ToggleInversed ();  			filterNode = newProperty;  		}  	}  	break;  case 4:  	DebugEnterAlt (4);  	// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  	{  		DebugLocation (116' 4);  		STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  		DebugLocation (117' 4);  		string stringText = (STRING7 != null ? STRING7.Text : default(string));  		stringText = stringText.Substring (1' stringText.Length - 2);  		filterNode = new Value (stringText);  	}  	break;  case 5:  	DebugEnterAlt (5);  	// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  	{  		DebugLocation (122' 4);  		REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  		DebugLocation (123' 4);  		string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  		regexText = regexText.Substring (1' regexText.Length - 2);  		filterNode = new RegExp (regexText);  	}  	break;  case 6:  	DebugEnterAlt (6);  	// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  	{  		DebugLocation (128' 4);  		NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  		DebugLocation (129' 4);  		filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  	}  	break;  case 7:  	DebugEnterAlt (7);  	// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  	{  		DebugLocation (132' 4);  		Match (input' TRUE' Follow._TRUE_in_filterExpr271);  		DebugLocation (133' 4);  		filterNode = new Value (true);  	}  	break;  case 8:  	DebugEnterAlt (8);  	// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  	{  		DebugLocation (136' 4);  		Match (input' FALSE' Follow._FALSE_in_filterExpr281);  		DebugLocation (137' 4);  		filterNode = new Value (false);  	}  	break;  case 9:  	DebugEnterAlt (9);  	// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  	{  		DebugLocation (140' 4);  		Match (input' NULL' Follow._NULL_in_filterExpr291);  		DebugLocation (141' 4);  		filterNode = new Value (null);  	}  	break;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: switch (alt9) {  case 1:  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  	{  		DebugLocation (64' 4);  		DebugLocation (64' 6);  		PushFollow (Follow._comparator_in_filterExpr175);  		comparator6 = comparator ();  		PopFollow ();  		Match (input' TokenTypes.Down' null);  		DebugLocation (64' 18);  		PushFollow (Follow._filterExpr_in_filterExpr179);  		a = filterExpr ();  		PopFollow ();  		DebugLocation (64' 31);  		PushFollow (Follow._filterExpr_in_filterExpr183);  		b = filterExpr ();  		PopFollow ();  		Match (input' TokenTypes.Up' null);  		DebugLocation (65' 4);  		Comparator newComparator;  		switch (comparator6) {  		case "=":  			newComparator = Comparator.Equals;  			break;  		case "!=":  			newComparator = Comparator.NotEquals;  			break;  		case ">":  			newComparator = Comparator.Greater;  			break;  		case "<":  			newComparator = Comparator.Less;  			break;  		case ">=":  			newComparator = Comparator.GreaterOrEqual;  			break;  		case "<=":  			newComparator = Comparator.LessOrEqual;  			break;  		case "&":  			newComparator = Comparator.And;  			break;  		case "|":  			newComparator = Comparator.Or;  			break;  		default:  			newComparator = Comparator.Equals;  			break;  		}  		filterNode = new BoolExpression (a' newComparator' b);  	}  	break;  case 2:  	DebugEnterAlt (2);  	// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  	{  		DebugLocation (98' 4);  		DebugLocation (98' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr195);  		Match (input' TokenTypes.Down' null);  		DebugLocation (98' 12);  		PushFollow (Follow._filterExpr_in_filterExpr199);  		f = filterExpr ();  		PopFollow ();  		DebugLocation (98' 31);  		// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  		int alt6 = 2;  		try {  			DebugEnterSubRule (6);  			try {  				DebugEnterDecision (6' false);  				int LA6_1 = input.LA (1);  				if ((LA6_1 == 24)) {  					alt6 = 1;  				}  			}  			finally {  				DebugExitDecision (6);  			}  			switch (alt6) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  				{  					DebugLocation (98' 31);  					inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (6);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (99' 4);  		FilterTreeNode newNode = f;  		if ((inverse != null ? inverse.Text : default(string)) == "!")  			newNode.ToggleInversed ();  		filterNode = newNode;  	}  	break;  case 3:  	DebugEnterAlt (3);  	// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  	{  		DebugLocation (105' 4);  		DebugLocation (105' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr216);  		Match (input' TokenTypes.Down' null);  		DebugLocation (105' 12);  		PushFollow (Follow._propertyChain_in_filterExpr219);  		propertyChain (propertySegments);  		PopFollow ();  		DebugLocation (105' 51);  		// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  		int alt7 = 2;  		try {  			DebugEnterSubRule (7);  			try {  				DebugEnterDecision (7' false);  				int LA7_1 = input.LA (1);  				if ((LA7_1 == 31)) {  					alt7 = 1;  				}  			}  			finally {  				DebugExitDecision (7);  			}  			switch (alt7) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  				{  					DebugLocation (105' 51);  					inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (7);  		}  		DebugLocation (105' 60);  		// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  		int alt8 = 2;  		try {  			DebugEnterSubRule (8);  			try {  				DebugEnterDecision (8' false);  				int LA8_1 = input.LA (1);  				if ((LA8_1 == 24)) {  					alt8 = 1;  				}  			}  			finally {  				DebugExitDecision (8);  			}  			switch (alt8) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  				{  					DebugLocation (105' 60);  					not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (8);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (106' 4);  		FilterTreeNode newProperty = new Property (propertySegments);  		if ((inverse != null ? inverse.Text : default(string)) == "?")  			filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  		else {  			if ((not != null ? not.Text : default(string)) == "!")  				newProperty.ToggleInversed ();  			filterNode = newProperty;  		}  	}  	break;  case 4:  	DebugEnterAlt (4);  	// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  	{  		DebugLocation (116' 4);  		STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  		DebugLocation (117' 4);  		string stringText = (STRING7 != null ? STRING7.Text : default(string));  		stringText = stringText.Substring (1' stringText.Length - 2);  		filterNode = new Value (stringText);  	}  	break;  case 5:  	DebugEnterAlt (5);  	// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  	{  		DebugLocation (122' 4);  		REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  		DebugLocation (123' 4);  		string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  		regexText = regexText.Substring (1' regexText.Length - 2);  		filterNode = new RegExp (regexText);  	}  	break;  case 6:  	DebugEnterAlt (6);  	// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  	{  		DebugLocation (128' 4);  		NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  		DebugLocation (129' 4);  		filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  	}  	break;  case 7:  	DebugEnterAlt (7);  	// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  	{  		DebugLocation (132' 4);  		Match (input' TRUE' Follow._TRUE_in_filterExpr271);  		DebugLocation (133' 4);  		filterNode = new Value (true);  	}  	break;  case 8:  	DebugEnterAlt (8);  	// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  	{  		DebugLocation (136' 4);  		Match (input' FALSE' Follow._FALSE_in_filterExpr281);  		DebugLocation (137' 4);  		filterNode = new Value (false);  	}  	break;  case 9:  	DebugEnterAlt (9);  	// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  	{  		DebugLocation (140' 4);  		Match (input' NULL' Follow._NULL_in_filterExpr291);  		DebugLocation (141' 4);  		filterNode = new Value (null);  	}  	break;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: switch (alt9) {  case 1:  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  	{  		DebugLocation (64' 4);  		DebugLocation (64' 6);  		PushFollow (Follow._comparator_in_filterExpr175);  		comparator6 = comparator ();  		PopFollow ();  		Match (input' TokenTypes.Down' null);  		DebugLocation (64' 18);  		PushFollow (Follow._filterExpr_in_filterExpr179);  		a = filterExpr ();  		PopFollow ();  		DebugLocation (64' 31);  		PushFollow (Follow._filterExpr_in_filterExpr183);  		b = filterExpr ();  		PopFollow ();  		Match (input' TokenTypes.Up' null);  		DebugLocation (65' 4);  		Comparator newComparator;  		switch (comparator6) {  		case "=":  			newComparator = Comparator.Equals;  			break;  		case "!=":  			newComparator = Comparator.NotEquals;  			break;  		case ">":  			newComparator = Comparator.Greater;  			break;  		case "<":  			newComparator = Comparator.Less;  			break;  		case ">=":  			newComparator = Comparator.GreaterOrEqual;  			break;  		case "<=":  			newComparator = Comparator.LessOrEqual;  			break;  		case "&":  			newComparator = Comparator.And;  			break;  		case "|":  			newComparator = Comparator.Or;  			break;  		default:  			newComparator = Comparator.Equals;  			break;  		}  		filterNode = new BoolExpression (a' newComparator' b);  	}  	break;  case 2:  	DebugEnterAlt (2);  	// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  	{  		DebugLocation (98' 4);  		DebugLocation (98' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr195);  		Match (input' TokenTypes.Down' null);  		DebugLocation (98' 12);  		PushFollow (Follow._filterExpr_in_filterExpr199);  		f = filterExpr ();  		PopFollow ();  		DebugLocation (98' 31);  		// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  		int alt6 = 2;  		try {  			DebugEnterSubRule (6);  			try {  				DebugEnterDecision (6' false);  				int LA6_1 = input.LA (1);  				if ((LA6_1 == 24)) {  					alt6 = 1;  				}  			}  			finally {  				DebugExitDecision (6);  			}  			switch (alt6) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  				{  					DebugLocation (98' 31);  					inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (6);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (99' 4);  		FilterTreeNode newNode = f;  		if ((inverse != null ? inverse.Text : default(string)) == "!")  			newNode.ToggleInversed ();  		filterNode = newNode;  	}  	break;  case 3:  	DebugEnterAlt (3);  	// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  	{  		DebugLocation (105' 4);  		DebugLocation (105' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr216);  		Match (input' TokenTypes.Down' null);  		DebugLocation (105' 12);  		PushFollow (Follow._propertyChain_in_filterExpr219);  		propertyChain (propertySegments);  		PopFollow ();  		DebugLocation (105' 51);  		// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  		int alt7 = 2;  		try {  			DebugEnterSubRule (7);  			try {  				DebugEnterDecision (7' false);  				int LA7_1 = input.LA (1);  				if ((LA7_1 == 31)) {  					alt7 = 1;  				}  			}  			finally {  				DebugExitDecision (7);  			}  			switch (alt7) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  				{  					DebugLocation (105' 51);  					inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (7);  		}  		DebugLocation (105' 60);  		// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  		int alt8 = 2;  		try {  			DebugEnterSubRule (8);  			try {  				DebugEnterDecision (8' false);  				int LA8_1 = input.LA (1);  				if ((LA8_1 == 24)) {  					alt8 = 1;  				}  			}  			finally {  				DebugExitDecision (8);  			}  			switch (alt8) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  				{  					DebugLocation (105' 60);  					not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (8);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (106' 4);  		FilterTreeNode newProperty = new Property (propertySegments);  		if ((inverse != null ? inverse.Text : default(string)) == "?")  			filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  		else {  			if ((not != null ? not.Text : default(string)) == "!")  				newProperty.ToggleInversed ();  			filterNode = newProperty;  		}  	}  	break;  case 4:  	DebugEnterAlt (4);  	// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  	{  		DebugLocation (116' 4);  		STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  		DebugLocation (117' 4);  		string stringText = (STRING7 != null ? STRING7.Text : default(string));  		stringText = stringText.Substring (1' stringText.Length - 2);  		filterNode = new Value (stringText);  	}  	break;  case 5:  	DebugEnterAlt (5);  	// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  	{  		DebugLocation (122' 4);  		REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  		DebugLocation (123' 4);  		string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  		regexText = regexText.Substring (1' regexText.Length - 2);  		filterNode = new RegExp (regexText);  	}  	break;  case 6:  	DebugEnterAlt (6);  	// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  	{  		DebugLocation (128' 4);  		NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  		DebugLocation (129' 4);  		filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  	}  	break;  case 7:  	DebugEnterAlt (7);  	// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  	{  		DebugLocation (132' 4);  		Match (input' TRUE' Follow._TRUE_in_filterExpr271);  		DebugLocation (133' 4);  		filterNode = new Value (true);  	}  	break;  case 8:  	DebugEnterAlt (8);  	// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  	{  		DebugLocation (136' 4);  		Match (input' FALSE' Follow._FALSE_in_filterExpr281);  		DebugLocation (137' 4);  		filterNode = new Value (false);  	}  	break;  case 9:  	DebugEnterAlt (9);  	// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  	{  		DebugLocation (140' 4);  		Match (input' NULL' Follow._NULL_in_filterExpr291);  		DebugLocation (141' 4);  		filterNode = new Value (null);  	}  	break;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: switch (alt9) {  case 1:  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  	{  		DebugLocation (64' 4);  		DebugLocation (64' 6);  		PushFollow (Follow._comparator_in_filterExpr175);  		comparator6 = comparator ();  		PopFollow ();  		Match (input' TokenTypes.Down' null);  		DebugLocation (64' 18);  		PushFollow (Follow._filterExpr_in_filterExpr179);  		a = filterExpr ();  		PopFollow ();  		DebugLocation (64' 31);  		PushFollow (Follow._filterExpr_in_filterExpr183);  		b = filterExpr ();  		PopFollow ();  		Match (input' TokenTypes.Up' null);  		DebugLocation (65' 4);  		Comparator newComparator;  		switch (comparator6) {  		case "=":  			newComparator = Comparator.Equals;  			break;  		case "!=":  			newComparator = Comparator.NotEquals;  			break;  		case ">":  			newComparator = Comparator.Greater;  			break;  		case "<":  			newComparator = Comparator.Less;  			break;  		case ">=":  			newComparator = Comparator.GreaterOrEqual;  			break;  		case "<=":  			newComparator = Comparator.LessOrEqual;  			break;  		case "&":  			newComparator = Comparator.And;  			break;  		case "|":  			newComparator = Comparator.Or;  			break;  		default:  			newComparator = Comparator.Equals;  			break;  		}  		filterNode = new BoolExpression (a' newComparator' b);  	}  	break;  case 2:  	DebugEnterAlt (2);  	// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  	{  		DebugLocation (98' 4);  		DebugLocation (98' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr195);  		Match (input' TokenTypes.Down' null);  		DebugLocation (98' 12);  		PushFollow (Follow._filterExpr_in_filterExpr199);  		f = filterExpr ();  		PopFollow ();  		DebugLocation (98' 31);  		// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  		int alt6 = 2;  		try {  			DebugEnterSubRule (6);  			try {  				DebugEnterDecision (6' false);  				int LA6_1 = input.LA (1);  				if ((LA6_1 == 24)) {  					alt6 = 1;  				}  			}  			finally {  				DebugExitDecision (6);  			}  			switch (alt6) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  				{  					DebugLocation (98' 31);  					inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (6);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (99' 4);  		FilterTreeNode newNode = f;  		if ((inverse != null ? inverse.Text : default(string)) == "!")  			newNode.ToggleInversed ();  		filterNode = newNode;  	}  	break;  case 3:  	DebugEnterAlt (3);  	// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  	{  		DebugLocation (105' 4);  		DebugLocation (105' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr216);  		Match (input' TokenTypes.Down' null);  		DebugLocation (105' 12);  		PushFollow (Follow._propertyChain_in_filterExpr219);  		propertyChain (propertySegments);  		PopFollow ();  		DebugLocation (105' 51);  		// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  		int alt7 = 2;  		try {  			DebugEnterSubRule (7);  			try {  				DebugEnterDecision (7' false);  				int LA7_1 = input.LA (1);  				if ((LA7_1 == 31)) {  					alt7 = 1;  				}  			}  			finally {  				DebugExitDecision (7);  			}  			switch (alt7) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  				{  					DebugLocation (105' 51);  					inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (7);  		}  		DebugLocation (105' 60);  		// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  		int alt8 = 2;  		try {  			DebugEnterSubRule (8);  			try {  				DebugEnterDecision (8' false);  				int LA8_1 = input.LA (1);  				if ((LA8_1 == 24)) {  					alt8 = 1;  				}  			}  			finally {  				DebugExitDecision (8);  			}  			switch (alt8) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  				{  					DebugLocation (105' 60);  					not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (8);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (106' 4);  		FilterTreeNode newProperty = new Property (propertySegments);  		if ((inverse != null ? inverse.Text : default(string)) == "?")  			filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  		else {  			if ((not != null ? not.Text : default(string)) == "!")  				newProperty.ToggleInversed ();  			filterNode = newProperty;  		}  	}  	break;  case 4:  	DebugEnterAlt (4);  	// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  	{  		DebugLocation (116' 4);  		STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  		DebugLocation (117' 4);  		string stringText = (STRING7 != null ? STRING7.Text : default(string));  		stringText = stringText.Substring (1' stringText.Length - 2);  		filterNode = new Value (stringText);  	}  	break;  case 5:  	DebugEnterAlt (5);  	// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  	{  		DebugLocation (122' 4);  		REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  		DebugLocation (123' 4);  		string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  		regexText = regexText.Substring (1' regexText.Length - 2);  		filterNode = new RegExp (regexText);  	}  	break;  case 6:  	DebugEnterAlt (6);  	// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  	{  		DebugLocation (128' 4);  		NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  		DebugLocation (129' 4);  		filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  	}  	break;  case 7:  	DebugEnterAlt (7);  	// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  	{  		DebugLocation (132' 4);  		Match (input' TRUE' Follow._TRUE_in_filterExpr271);  		DebugLocation (133' 4);  		filterNode = new Value (true);  	}  	break;  case 8:  	DebugEnterAlt (8);  	// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  	{  		DebugLocation (136' 4);  		Match (input' FALSE' Follow._FALSE_in_filterExpr281);  		DebugLocation (137' 4);  		filterNode = new Value (false);  	}  	break;  case 9:  	DebugEnterAlt (9);  	// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  	{  		DebugLocation (140' 4);  		Match (input' NULL' Follow._NULL_in_filterExpr291);  		DebugLocation (141' 4);  		filterNode = new Value (null);  	}  	break;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: switch (alt9) {  case 1:  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  	{  		DebugLocation (64' 4);  		DebugLocation (64' 6);  		PushFollow (Follow._comparator_in_filterExpr175);  		comparator6 = comparator ();  		PopFollow ();  		Match (input' TokenTypes.Down' null);  		DebugLocation (64' 18);  		PushFollow (Follow._filterExpr_in_filterExpr179);  		a = filterExpr ();  		PopFollow ();  		DebugLocation (64' 31);  		PushFollow (Follow._filterExpr_in_filterExpr183);  		b = filterExpr ();  		PopFollow ();  		Match (input' TokenTypes.Up' null);  		DebugLocation (65' 4);  		Comparator newComparator;  		switch (comparator6) {  		case "=":  			newComparator = Comparator.Equals;  			break;  		case "!=":  			newComparator = Comparator.NotEquals;  			break;  		case ">":  			newComparator = Comparator.Greater;  			break;  		case "<":  			newComparator = Comparator.Less;  			break;  		case ">=":  			newComparator = Comparator.GreaterOrEqual;  			break;  		case "<=":  			newComparator = Comparator.LessOrEqual;  			break;  		case "&":  			newComparator = Comparator.And;  			break;  		case "|":  			newComparator = Comparator.Or;  			break;  		default:  			newComparator = Comparator.Equals;  			break;  		}  		filterNode = new BoolExpression (a' newComparator' b);  	}  	break;  case 2:  	DebugEnterAlt (2);  	// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  	{  		DebugLocation (98' 4);  		DebugLocation (98' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr195);  		Match (input' TokenTypes.Down' null);  		DebugLocation (98' 12);  		PushFollow (Follow._filterExpr_in_filterExpr199);  		f = filterExpr ();  		PopFollow ();  		DebugLocation (98' 31);  		// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  		int alt6 = 2;  		try {  			DebugEnterSubRule (6);  			try {  				DebugEnterDecision (6' false);  				int LA6_1 = input.LA (1);  				if ((LA6_1 == 24)) {  					alt6 = 1;  				}  			}  			finally {  				DebugExitDecision (6);  			}  			switch (alt6) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  				{  					DebugLocation (98' 31);  					inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (6);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (99' 4);  		FilterTreeNode newNode = f;  		if ((inverse != null ? inverse.Text : default(string)) == "!")  			newNode.ToggleInversed ();  		filterNode = newNode;  	}  	break;  case 3:  	DebugEnterAlt (3);  	// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  	{  		DebugLocation (105' 4);  		DebugLocation (105' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr216);  		Match (input' TokenTypes.Down' null);  		DebugLocation (105' 12);  		PushFollow (Follow._propertyChain_in_filterExpr219);  		propertyChain (propertySegments);  		PopFollow ();  		DebugLocation (105' 51);  		// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  		int alt7 = 2;  		try {  			DebugEnterSubRule (7);  			try {  				DebugEnterDecision (7' false);  				int LA7_1 = input.LA (1);  				if ((LA7_1 == 31)) {  					alt7 = 1;  				}  			}  			finally {  				DebugExitDecision (7);  			}  			switch (alt7) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  				{  					DebugLocation (105' 51);  					inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (7);  		}  		DebugLocation (105' 60);  		// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  		int alt8 = 2;  		try {  			DebugEnterSubRule (8);  			try {  				DebugEnterDecision (8' false);  				int LA8_1 = input.LA (1);  				if ((LA8_1 == 24)) {  					alt8 = 1;  				}  			}  			finally {  				DebugExitDecision (8);  			}  			switch (alt8) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  				{  					DebugLocation (105' 60);  					not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (8);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (106' 4);  		FilterTreeNode newProperty = new Property (propertySegments);  		if ((inverse != null ? inverse.Text : default(string)) == "?")  			filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  		else {  			if ((not != null ? not.Text : default(string)) == "!")  				newProperty.ToggleInversed ();  			filterNode = newProperty;  		}  	}  	break;  case 4:  	DebugEnterAlt (4);  	// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  	{  		DebugLocation (116' 4);  		STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  		DebugLocation (117' 4);  		string stringText = (STRING7 != null ? STRING7.Text : default(string));  		stringText = stringText.Substring (1' stringText.Length - 2);  		filterNode = new Value (stringText);  	}  	break;  case 5:  	DebugEnterAlt (5);  	// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  	{  		DebugLocation (122' 4);  		REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  		DebugLocation (123' 4);  		string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  		regexText = regexText.Substring (1' regexText.Length - 2);  		filterNode = new RegExp (regexText);  	}  	break;  case 6:  	DebugEnterAlt (6);  	// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  	{  		DebugLocation (128' 4);  		NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  		DebugLocation (129' 4);  		filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  	}  	break;  case 7:  	DebugEnterAlt (7);  	// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  	{  		DebugLocation (132' 4);  		Match (input' TRUE' Follow._TRUE_in_filterExpr271);  		DebugLocation (133' 4);  		filterNode = new Value (true);  	}  	break;  case 8:  	DebugEnterAlt (8);  	// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  	{  		DebugLocation (136' 4);  		Match (input' FALSE' Follow._FALSE_in_filterExpr281);  		DebugLocation (137' 4);  		filterNode = new Value (false);  	}  	break;  case 9:  	DebugEnterAlt (9);  	// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  	{  		DebugLocation (140' 4);  		Match (input' NULL' Follow._NULL_in_filterExpr291);  		DebugLocation (141' 4);  		filterNode = new Value (null);  	}  	break;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: switch (alt9) {  case 1:  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  	{  		DebugLocation (64' 4);  		DebugLocation (64' 6);  		PushFollow (Follow._comparator_in_filterExpr175);  		comparator6 = comparator ();  		PopFollow ();  		Match (input' TokenTypes.Down' null);  		DebugLocation (64' 18);  		PushFollow (Follow._filterExpr_in_filterExpr179);  		a = filterExpr ();  		PopFollow ();  		DebugLocation (64' 31);  		PushFollow (Follow._filterExpr_in_filterExpr183);  		b = filterExpr ();  		PopFollow ();  		Match (input' TokenTypes.Up' null);  		DebugLocation (65' 4);  		Comparator newComparator;  		switch (comparator6) {  		case "=":  			newComparator = Comparator.Equals;  			break;  		case "!=":  			newComparator = Comparator.NotEquals;  			break;  		case ">":  			newComparator = Comparator.Greater;  			break;  		case "<":  			newComparator = Comparator.Less;  			break;  		case ">=":  			newComparator = Comparator.GreaterOrEqual;  			break;  		case "<=":  			newComparator = Comparator.LessOrEqual;  			break;  		case "&":  			newComparator = Comparator.And;  			break;  		case "|":  			newComparator = Comparator.Or;  			break;  		default:  			newComparator = Comparator.Equals;  			break;  		}  		filterNode = new BoolExpression (a' newComparator' b);  	}  	break;  case 2:  	DebugEnterAlt (2);  	// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  	{  		DebugLocation (98' 4);  		DebugLocation (98' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr195);  		Match (input' TokenTypes.Down' null);  		DebugLocation (98' 12);  		PushFollow (Follow._filterExpr_in_filterExpr199);  		f = filterExpr ();  		PopFollow ();  		DebugLocation (98' 31);  		// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  		int alt6 = 2;  		try {  			DebugEnterSubRule (6);  			try {  				DebugEnterDecision (6' false);  				int LA6_1 = input.LA (1);  				if ((LA6_1 == 24)) {  					alt6 = 1;  				}  			}  			finally {  				DebugExitDecision (6);  			}  			switch (alt6) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  				{  					DebugLocation (98' 31);  					inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (6);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (99' 4);  		FilterTreeNode newNode = f;  		if ((inverse != null ? inverse.Text : default(string)) == "!")  			newNode.ToggleInversed ();  		filterNode = newNode;  	}  	break;  case 3:  	DebugEnterAlt (3);  	// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  	{  		DebugLocation (105' 4);  		DebugLocation (105' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr216);  		Match (input' TokenTypes.Down' null);  		DebugLocation (105' 12);  		PushFollow (Follow._propertyChain_in_filterExpr219);  		propertyChain (propertySegments);  		PopFollow ();  		DebugLocation (105' 51);  		// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  		int alt7 = 2;  		try {  			DebugEnterSubRule (7);  			try {  				DebugEnterDecision (7' false);  				int LA7_1 = input.LA (1);  				if ((LA7_1 == 31)) {  					alt7 = 1;  				}  			}  			finally {  				DebugExitDecision (7);  			}  			switch (alt7) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  				{  					DebugLocation (105' 51);  					inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (7);  		}  		DebugLocation (105' 60);  		// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  		int alt8 = 2;  		try {  			DebugEnterSubRule (8);  			try {  				DebugEnterDecision (8' false);  				int LA8_1 = input.LA (1);  				if ((LA8_1 == 24)) {  					alt8 = 1;  				}  			}  			finally {  				DebugExitDecision (8);  			}  			switch (alt8) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  				{  					DebugLocation (105' 60);  					not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (8);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (106' 4);  		FilterTreeNode newProperty = new Property (propertySegments);  		if ((inverse != null ? inverse.Text : default(string)) == "?")  			filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  		else {  			if ((not != null ? not.Text : default(string)) == "!")  				newProperty.ToggleInversed ();  			filterNode = newProperty;  		}  	}  	break;  case 4:  	DebugEnterAlt (4);  	// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  	{  		DebugLocation (116' 4);  		STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  		DebugLocation (117' 4);  		string stringText = (STRING7 != null ? STRING7.Text : default(string));  		stringText = stringText.Substring (1' stringText.Length - 2);  		filterNode = new Value (stringText);  	}  	break;  case 5:  	DebugEnterAlt (5);  	// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  	{  		DebugLocation (122' 4);  		REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  		DebugLocation (123' 4);  		string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  		regexText = regexText.Substring (1' regexText.Length - 2);  		filterNode = new RegExp (regexText);  	}  	break;  case 6:  	DebugEnterAlt (6);  	// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  	{  		DebugLocation (128' 4);  		NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  		DebugLocation (129' 4);  		filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  	}  	break;  case 7:  	DebugEnterAlt (7);  	// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  	{  		DebugLocation (132' 4);  		Match (input' TRUE' Follow._TRUE_in_filterExpr271);  		DebugLocation (133' 4);  		filterNode = new Value (true);  	}  	break;  case 8:  	DebugEnterAlt (8);  	// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  	{  		DebugLocation (136' 4);  		Match (input' FALSE' Follow._FALSE_in_filterExpr281);  		DebugLocation (137' 4);  		filterNode = new Value (false);  	}  	break;  case 9:  	DebugEnterAlt (9);  	// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  	{  		DebugLocation (140' 4);  		Match (input' NULL' Follow._NULL_in_filterExpr291);  		DebugLocation (141' 4);  		filterNode = new Value (null);  	}  	break;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: switch (alt9) {  case 1:  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  	{  		DebugLocation (64' 4);  		DebugLocation (64' 6);  		PushFollow (Follow._comparator_in_filterExpr175);  		comparator6 = comparator ();  		PopFollow ();  		Match (input' TokenTypes.Down' null);  		DebugLocation (64' 18);  		PushFollow (Follow._filterExpr_in_filterExpr179);  		a = filterExpr ();  		PopFollow ();  		DebugLocation (64' 31);  		PushFollow (Follow._filterExpr_in_filterExpr183);  		b = filterExpr ();  		PopFollow ();  		Match (input' TokenTypes.Up' null);  		DebugLocation (65' 4);  		Comparator newComparator;  		switch (comparator6) {  		case "=":  			newComparator = Comparator.Equals;  			break;  		case "!=":  			newComparator = Comparator.NotEquals;  			break;  		case ">":  			newComparator = Comparator.Greater;  			break;  		case "<":  			newComparator = Comparator.Less;  			break;  		case ">=":  			newComparator = Comparator.GreaterOrEqual;  			break;  		case "<=":  			newComparator = Comparator.LessOrEqual;  			break;  		case "&":  			newComparator = Comparator.And;  			break;  		case "|":  			newComparator = Comparator.Or;  			break;  		default:  			newComparator = Comparator.Equals;  			break;  		}  		filterNode = new BoolExpression (a' newComparator' b);  	}  	break;  case 2:  	DebugEnterAlt (2);  	// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  	{  		DebugLocation (98' 4);  		DebugLocation (98' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr195);  		Match (input' TokenTypes.Down' null);  		DebugLocation (98' 12);  		PushFollow (Follow._filterExpr_in_filterExpr199);  		f = filterExpr ();  		PopFollow ();  		DebugLocation (98' 31);  		// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  		int alt6 = 2;  		try {  			DebugEnterSubRule (6);  			try {  				DebugEnterDecision (6' false);  				int LA6_1 = input.LA (1);  				if ((LA6_1 == 24)) {  					alt6 = 1;  				}  			}  			finally {  				DebugExitDecision (6);  			}  			switch (alt6) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  				{  					DebugLocation (98' 31);  					inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (6);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (99' 4);  		FilterTreeNode newNode = f;  		if ((inverse != null ? inverse.Text : default(string)) == "!")  			newNode.ToggleInversed ();  		filterNode = newNode;  	}  	break;  case 3:  	DebugEnterAlt (3);  	// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  	{  		DebugLocation (105' 4);  		DebugLocation (105' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr216);  		Match (input' TokenTypes.Down' null);  		DebugLocation (105' 12);  		PushFollow (Follow._propertyChain_in_filterExpr219);  		propertyChain (propertySegments);  		PopFollow ();  		DebugLocation (105' 51);  		// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  		int alt7 = 2;  		try {  			DebugEnterSubRule (7);  			try {  				DebugEnterDecision (7' false);  				int LA7_1 = input.LA (1);  				if ((LA7_1 == 31)) {  					alt7 = 1;  				}  			}  			finally {  				DebugExitDecision (7);  			}  			switch (alt7) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  				{  					DebugLocation (105' 51);  					inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (7);  		}  		DebugLocation (105' 60);  		// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  		int alt8 = 2;  		try {  			DebugEnterSubRule (8);  			try {  				DebugEnterDecision (8' false);  				int LA8_1 = input.LA (1);  				if ((LA8_1 == 24)) {  					alt8 = 1;  				}  			}  			finally {  				DebugExitDecision (8);  			}  			switch (alt8) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  				{  					DebugLocation (105' 60);  					not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (8);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (106' 4);  		FilterTreeNode newProperty = new Property (propertySegments);  		if ((inverse != null ? inverse.Text : default(string)) == "?")  			filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  		else {  			if ((not != null ? not.Text : default(string)) == "!")  				newProperty.ToggleInversed ();  			filterNode = newProperty;  		}  	}  	break;  case 4:  	DebugEnterAlt (4);  	// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  	{  		DebugLocation (116' 4);  		STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  		DebugLocation (117' 4);  		string stringText = (STRING7 != null ? STRING7.Text : default(string));  		stringText = stringText.Substring (1' stringText.Length - 2);  		filterNode = new Value (stringText);  	}  	break;  case 5:  	DebugEnterAlt (5);  	// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  	{  		DebugLocation (122' 4);  		REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  		DebugLocation (123' 4);  		string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  		regexText = regexText.Substring (1' regexText.Length - 2);  		filterNode = new RegExp (regexText);  	}  	break;  case 6:  	DebugEnterAlt (6);  	// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  	{  		DebugLocation (128' 4);  		NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  		DebugLocation (129' 4);  		filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  	}  	break;  case 7:  	DebugEnterAlt (7);  	// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  	{  		DebugLocation (132' 4);  		Match (input' TRUE' Follow._TRUE_in_filterExpr271);  		DebugLocation (133' 4);  		filterNode = new Value (true);  	}  	break;  case 8:  	DebugEnterAlt (8);  	// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  	{  		DebugLocation (136' 4);  		Match (input' FALSE' Follow._FALSE_in_filterExpr281);  		DebugLocation (137' 4);  		filterNode = new Value (false);  	}  	break;  case 9:  	DebugEnterAlt (9);  	// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  	{  		DebugLocation (140' 4);  		Match (input' NULL' Follow._NULL_in_filterExpr291);  		DebugLocation (141' 4);  		filterNode = new Value (null);  	}  	break;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: switch (alt9) {  case 1:  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  	{  		DebugLocation (64' 4);  		DebugLocation (64' 6);  		PushFollow (Follow._comparator_in_filterExpr175);  		comparator6 = comparator ();  		PopFollow ();  		Match (input' TokenTypes.Down' null);  		DebugLocation (64' 18);  		PushFollow (Follow._filterExpr_in_filterExpr179);  		a = filterExpr ();  		PopFollow ();  		DebugLocation (64' 31);  		PushFollow (Follow._filterExpr_in_filterExpr183);  		b = filterExpr ();  		PopFollow ();  		Match (input' TokenTypes.Up' null);  		DebugLocation (65' 4);  		Comparator newComparator;  		switch (comparator6) {  		case "=":  			newComparator = Comparator.Equals;  			break;  		case "!=":  			newComparator = Comparator.NotEquals;  			break;  		case ">":  			newComparator = Comparator.Greater;  			break;  		case "<":  			newComparator = Comparator.Less;  			break;  		case ">=":  			newComparator = Comparator.GreaterOrEqual;  			break;  		case "<=":  			newComparator = Comparator.LessOrEqual;  			break;  		case "&":  			newComparator = Comparator.And;  			break;  		case "|":  			newComparator = Comparator.Or;  			break;  		default:  			newComparator = Comparator.Equals;  			break;  		}  		filterNode = new BoolExpression (a' newComparator' b);  	}  	break;  case 2:  	DebugEnterAlt (2);  	// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  	{  		DebugLocation (98' 4);  		DebugLocation (98' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr195);  		Match (input' TokenTypes.Down' null);  		DebugLocation (98' 12);  		PushFollow (Follow._filterExpr_in_filterExpr199);  		f = filterExpr ();  		PopFollow ();  		DebugLocation (98' 31);  		// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  		int alt6 = 2;  		try {  			DebugEnterSubRule (6);  			try {  				DebugEnterDecision (6' false);  				int LA6_1 = input.LA (1);  				if ((LA6_1 == 24)) {  					alt6 = 1;  				}  			}  			finally {  				DebugExitDecision (6);  			}  			switch (alt6) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  				{  					DebugLocation (98' 31);  					inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (6);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (99' 4);  		FilterTreeNode newNode = f;  		if ((inverse != null ? inverse.Text : default(string)) == "!")  			newNode.ToggleInversed ();  		filterNode = newNode;  	}  	break;  case 3:  	DebugEnterAlt (3);  	// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  	{  		DebugLocation (105' 4);  		DebugLocation (105' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr216);  		Match (input' TokenTypes.Down' null);  		DebugLocation (105' 12);  		PushFollow (Follow._propertyChain_in_filterExpr219);  		propertyChain (propertySegments);  		PopFollow ();  		DebugLocation (105' 51);  		// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  		int alt7 = 2;  		try {  			DebugEnterSubRule (7);  			try {  				DebugEnterDecision (7' false);  				int LA7_1 = input.LA (1);  				if ((LA7_1 == 31)) {  					alt7 = 1;  				}  			}  			finally {  				DebugExitDecision (7);  			}  			switch (alt7) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  				{  					DebugLocation (105' 51);  					inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (7);  		}  		DebugLocation (105' 60);  		// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  		int alt8 = 2;  		try {  			DebugEnterSubRule (8);  			try {  				DebugEnterDecision (8' false);  				int LA8_1 = input.LA (1);  				if ((LA8_1 == 24)) {  					alt8 = 1;  				}  			}  			finally {  				DebugExitDecision (8);  			}  			switch (alt8) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  				{  					DebugLocation (105' 60);  					not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (8);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (106' 4);  		FilterTreeNode newProperty = new Property (propertySegments);  		if ((inverse != null ? inverse.Text : default(string)) == "?")  			filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  		else {  			if ((not != null ? not.Text : default(string)) == "!")  				newProperty.ToggleInversed ();  			filterNode = newProperty;  		}  	}  	break;  case 4:  	DebugEnterAlt (4);  	// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  	{  		DebugLocation (116' 4);  		STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  		DebugLocation (117' 4);  		string stringText = (STRING7 != null ? STRING7.Text : default(string));  		stringText = stringText.Substring (1' stringText.Length - 2);  		filterNode = new Value (stringText);  	}  	break;  case 5:  	DebugEnterAlt (5);  	// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  	{  		DebugLocation (122' 4);  		REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  		DebugLocation (123' 4);  		string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  		regexText = regexText.Substring (1' regexText.Length - 2);  		filterNode = new RegExp (regexText);  	}  	break;  case 6:  	DebugEnterAlt (6);  	// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  	{  		DebugLocation (128' 4);  		NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  		DebugLocation (129' 4);  		filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  	}  	break;  case 7:  	DebugEnterAlt (7);  	// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  	{  		DebugLocation (132' 4);  		Match (input' TRUE' Follow._TRUE_in_filterExpr271);  		DebugLocation (133' 4);  		filterNode = new Value (true);  	}  	break;  case 8:  	DebugEnterAlt (8);  	// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  	{  		DebugLocation (136' 4);  		Match (input' FALSE' Follow._FALSE_in_filterExpr281);  		DebugLocation (137' 4);  		filterNode = new Value (false);  	}  	break;  case 9:  	DebugEnterAlt (9);  	// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  	{  		DebugLocation (140' 4);  		Match (input' NULL' Follow._NULL_in_filterExpr291);  		DebugLocation (141' 4);  		filterNode = new Value (null);  	}  	break;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: switch (alt9) {  case 1:  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  	{  		DebugLocation (64' 4);  		DebugLocation (64' 6);  		PushFollow (Follow._comparator_in_filterExpr175);  		comparator6 = comparator ();  		PopFollow ();  		Match (input' TokenTypes.Down' null);  		DebugLocation (64' 18);  		PushFollow (Follow._filterExpr_in_filterExpr179);  		a = filterExpr ();  		PopFollow ();  		DebugLocation (64' 31);  		PushFollow (Follow._filterExpr_in_filterExpr183);  		b = filterExpr ();  		PopFollow ();  		Match (input' TokenTypes.Up' null);  		DebugLocation (65' 4);  		Comparator newComparator;  		switch (comparator6) {  		case "=":  			newComparator = Comparator.Equals;  			break;  		case "!=":  			newComparator = Comparator.NotEquals;  			break;  		case ">":  			newComparator = Comparator.Greater;  			break;  		case "<":  			newComparator = Comparator.Less;  			break;  		case ">=":  			newComparator = Comparator.GreaterOrEqual;  			break;  		case "<=":  			newComparator = Comparator.LessOrEqual;  			break;  		case "&":  			newComparator = Comparator.And;  			break;  		case "|":  			newComparator = Comparator.Or;  			break;  		default:  			newComparator = Comparator.Equals;  			break;  		}  		filterNode = new BoolExpression (a' newComparator' b);  	}  	break;  case 2:  	DebugEnterAlt (2);  	// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  	{  		DebugLocation (98' 4);  		DebugLocation (98' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr195);  		Match (input' TokenTypes.Down' null);  		DebugLocation (98' 12);  		PushFollow (Follow._filterExpr_in_filterExpr199);  		f = filterExpr ();  		PopFollow ();  		DebugLocation (98' 31);  		// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  		int alt6 = 2;  		try {  			DebugEnterSubRule (6);  			try {  				DebugEnterDecision (6' false);  				int LA6_1 = input.LA (1);  				if ((LA6_1 == 24)) {  					alt6 = 1;  				}  			}  			finally {  				DebugExitDecision (6);  			}  			switch (alt6) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  				{  					DebugLocation (98' 31);  					inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (6);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (99' 4);  		FilterTreeNode newNode = f;  		if ((inverse != null ? inverse.Text : default(string)) == "!")  			newNode.ToggleInversed ();  		filterNode = newNode;  	}  	break;  case 3:  	DebugEnterAlt (3);  	// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  	{  		DebugLocation (105' 4);  		DebugLocation (105' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr216);  		Match (input' TokenTypes.Down' null);  		DebugLocation (105' 12);  		PushFollow (Follow._propertyChain_in_filterExpr219);  		propertyChain (propertySegments);  		PopFollow ();  		DebugLocation (105' 51);  		// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  		int alt7 = 2;  		try {  			DebugEnterSubRule (7);  			try {  				DebugEnterDecision (7' false);  				int LA7_1 = input.LA (1);  				if ((LA7_1 == 31)) {  					alt7 = 1;  				}  			}  			finally {  				DebugExitDecision (7);  			}  			switch (alt7) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  				{  					DebugLocation (105' 51);  					inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (7);  		}  		DebugLocation (105' 60);  		// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  		int alt8 = 2;  		try {  			DebugEnterSubRule (8);  			try {  				DebugEnterDecision (8' false);  				int LA8_1 = input.LA (1);  				if ((LA8_1 == 24)) {  					alt8 = 1;  				}  			}  			finally {  				DebugExitDecision (8);  			}  			switch (alt8) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  				{  					DebugLocation (105' 60);  					not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (8);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (106' 4);  		FilterTreeNode newProperty = new Property (propertySegments);  		if ((inverse != null ? inverse.Text : default(string)) == "?")  			filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  		else {  			if ((not != null ? not.Text : default(string)) == "!")  				newProperty.ToggleInversed ();  			filterNode = newProperty;  		}  	}  	break;  case 4:  	DebugEnterAlt (4);  	// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  	{  		DebugLocation (116' 4);  		STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  		DebugLocation (117' 4);  		string stringText = (STRING7 != null ? STRING7.Text : default(string));  		stringText = stringText.Substring (1' stringText.Length - 2);  		filterNode = new Value (stringText);  	}  	break;  case 5:  	DebugEnterAlt (5);  	// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  	{  		DebugLocation (122' 4);  		REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  		DebugLocation (123' 4);  		string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  		regexText = regexText.Substring (1' regexText.Length - 2);  		filterNode = new RegExp (regexText);  	}  	break;  case 6:  	DebugEnterAlt (6);  	// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  	{  		DebugLocation (128' 4);  		NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  		DebugLocation (129' 4);  		filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  	}  	break;  case 7:  	DebugEnterAlt (7);  	// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  	{  		DebugLocation (132' 4);  		Match (input' TRUE' Follow._TRUE_in_filterExpr271);  		DebugLocation (133' 4);  		filterNode = new Value (true);  	}  	break;  case 8:  	DebugEnterAlt (8);  	// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  	{  		DebugLocation (136' 4);  		Match (input' FALSE' Follow._FALSE_in_filterExpr281);  		DebugLocation (137' 4);  		filterNode = new Value (false);  	}  	break;  case 9:  	DebugEnterAlt (9);  	// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  	{  		DebugLocation (140' 4);  		Match (input' NULL' Follow._NULL_in_filterExpr291);  		DebugLocation (141' 4);  		filterNode = new Value (null);  	}  	break;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: switch (alt9) {  case 1:  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  	{  		DebugLocation (64' 4);  		DebugLocation (64' 6);  		PushFollow (Follow._comparator_in_filterExpr175);  		comparator6 = comparator ();  		PopFollow ();  		Match (input' TokenTypes.Down' null);  		DebugLocation (64' 18);  		PushFollow (Follow._filterExpr_in_filterExpr179);  		a = filterExpr ();  		PopFollow ();  		DebugLocation (64' 31);  		PushFollow (Follow._filterExpr_in_filterExpr183);  		b = filterExpr ();  		PopFollow ();  		Match (input' TokenTypes.Up' null);  		DebugLocation (65' 4);  		Comparator newComparator;  		switch (comparator6) {  		case "=":  			newComparator = Comparator.Equals;  			break;  		case "!=":  			newComparator = Comparator.NotEquals;  			break;  		case ">":  			newComparator = Comparator.Greater;  			break;  		case "<":  			newComparator = Comparator.Less;  			break;  		case ">=":  			newComparator = Comparator.GreaterOrEqual;  			break;  		case "<=":  			newComparator = Comparator.LessOrEqual;  			break;  		case "&":  			newComparator = Comparator.And;  			break;  		case "|":  			newComparator = Comparator.Or;  			break;  		default:  			newComparator = Comparator.Equals;  			break;  		}  		filterNode = new BoolExpression (a' newComparator' b);  	}  	break;  case 2:  	DebugEnterAlt (2);  	// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  	{  		DebugLocation (98' 4);  		DebugLocation (98' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr195);  		Match (input' TokenTypes.Down' null);  		DebugLocation (98' 12);  		PushFollow (Follow._filterExpr_in_filterExpr199);  		f = filterExpr ();  		PopFollow ();  		DebugLocation (98' 31);  		// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  		int alt6 = 2;  		try {  			DebugEnterSubRule (6);  			try {  				DebugEnterDecision (6' false);  				int LA6_1 = input.LA (1);  				if ((LA6_1 == 24)) {  					alt6 = 1;  				}  			}  			finally {  				DebugExitDecision (6);  			}  			switch (alt6) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  				{  					DebugLocation (98' 31);  					inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (6);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (99' 4);  		FilterTreeNode newNode = f;  		if ((inverse != null ? inverse.Text : default(string)) == "!")  			newNode.ToggleInversed ();  		filterNode = newNode;  	}  	break;  case 3:  	DebugEnterAlt (3);  	// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  	{  		DebugLocation (105' 4);  		DebugLocation (105' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr216);  		Match (input' TokenTypes.Down' null);  		DebugLocation (105' 12);  		PushFollow (Follow._propertyChain_in_filterExpr219);  		propertyChain (propertySegments);  		PopFollow ();  		DebugLocation (105' 51);  		// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  		int alt7 = 2;  		try {  			DebugEnterSubRule (7);  			try {  				DebugEnterDecision (7' false);  				int LA7_1 = input.LA (1);  				if ((LA7_1 == 31)) {  					alt7 = 1;  				}  			}  			finally {  				DebugExitDecision (7);  			}  			switch (alt7) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  				{  					DebugLocation (105' 51);  					inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (7);  		}  		DebugLocation (105' 60);  		// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  		int alt8 = 2;  		try {  			DebugEnterSubRule (8);  			try {  				DebugEnterDecision (8' false);  				int LA8_1 = input.LA (1);  				if ((LA8_1 == 24)) {  					alt8 = 1;  				}  			}  			finally {  				DebugExitDecision (8);  			}  			switch (alt8) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  				{  					DebugLocation (105' 60);  					not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (8);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (106' 4);  		FilterTreeNode newProperty = new Property (propertySegments);  		if ((inverse != null ? inverse.Text : default(string)) == "?")  			filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  		else {  			if ((not != null ? not.Text : default(string)) == "!")  				newProperty.ToggleInversed ();  			filterNode = newProperty;  		}  	}  	break;  case 4:  	DebugEnterAlt (4);  	// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  	{  		DebugLocation (116' 4);  		STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  		DebugLocation (117' 4);  		string stringText = (STRING7 != null ? STRING7.Text : default(string));  		stringText = stringText.Substring (1' stringText.Length - 2);  		filterNode = new Value (stringText);  	}  	break;  case 5:  	DebugEnterAlt (5);  	// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  	{  		DebugLocation (122' 4);  		REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  		DebugLocation (123' 4);  		string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  		regexText = regexText.Substring (1' regexText.Length - 2);  		filterNode = new RegExp (regexText);  	}  	break;  case 6:  	DebugEnterAlt (6);  	// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  	{  		DebugLocation (128' 4);  		NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  		DebugLocation (129' 4);  		filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  	}  	break;  case 7:  	DebugEnterAlt (7);  	// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  	{  		DebugLocation (132' 4);  		Match (input' TRUE' Follow._TRUE_in_filterExpr271);  		DebugLocation (133' 4);  		filterNode = new Value (true);  	}  	break;  case 8:  	DebugEnterAlt (8);  	// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  	{  		DebugLocation (136' 4);  		Match (input' FALSE' Follow._FALSE_in_filterExpr281);  		DebugLocation (137' 4);  		filterNode = new Value (false);  	}  	break;  case 9:  	DebugEnterAlt (9);  	// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  	{  		DebugLocation (140' 4);  		Match (input' NULL' Follow._NULL_in_filterExpr291);  		DebugLocation (141' 4);  		filterNode = new Value (null);  	}  	break;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: switch (alt9) {  case 1:  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  	{  		DebugLocation (64' 4);  		DebugLocation (64' 6);  		PushFollow (Follow._comparator_in_filterExpr175);  		comparator6 = comparator ();  		PopFollow ();  		Match (input' TokenTypes.Down' null);  		DebugLocation (64' 18);  		PushFollow (Follow._filterExpr_in_filterExpr179);  		a = filterExpr ();  		PopFollow ();  		DebugLocation (64' 31);  		PushFollow (Follow._filterExpr_in_filterExpr183);  		b = filterExpr ();  		PopFollow ();  		Match (input' TokenTypes.Up' null);  		DebugLocation (65' 4);  		Comparator newComparator;  		switch (comparator6) {  		case "=":  			newComparator = Comparator.Equals;  			break;  		case "!=":  			newComparator = Comparator.NotEquals;  			break;  		case ">":  			newComparator = Comparator.Greater;  			break;  		case "<":  			newComparator = Comparator.Less;  			break;  		case ">=":  			newComparator = Comparator.GreaterOrEqual;  			break;  		case "<=":  			newComparator = Comparator.LessOrEqual;  			break;  		case "&":  			newComparator = Comparator.And;  			break;  		case "|":  			newComparator = Comparator.Or;  			break;  		default:  			newComparator = Comparator.Equals;  			break;  		}  		filterNode = new BoolExpression (a' newComparator' b);  	}  	break;  case 2:  	DebugEnterAlt (2);  	// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  	{  		DebugLocation (98' 4);  		DebugLocation (98' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr195);  		Match (input' TokenTypes.Down' null);  		DebugLocation (98' 12);  		PushFollow (Follow._filterExpr_in_filterExpr199);  		f = filterExpr ();  		PopFollow ();  		DebugLocation (98' 31);  		// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  		int alt6 = 2;  		try {  			DebugEnterSubRule (6);  			try {  				DebugEnterDecision (6' false);  				int LA6_1 = input.LA (1);  				if ((LA6_1 == 24)) {  					alt6 = 1;  				}  			}  			finally {  				DebugExitDecision (6);  			}  			switch (alt6) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  				{  					DebugLocation (98' 31);  					inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (6);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (99' 4);  		FilterTreeNode newNode = f;  		if ((inverse != null ? inverse.Text : default(string)) == "!")  			newNode.ToggleInversed ();  		filterNode = newNode;  	}  	break;  case 3:  	DebugEnterAlt (3);  	// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  	{  		DebugLocation (105' 4);  		DebugLocation (105' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr216);  		Match (input' TokenTypes.Down' null);  		DebugLocation (105' 12);  		PushFollow (Follow._propertyChain_in_filterExpr219);  		propertyChain (propertySegments);  		PopFollow ();  		DebugLocation (105' 51);  		// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  		int alt7 = 2;  		try {  			DebugEnterSubRule (7);  			try {  				DebugEnterDecision (7' false);  				int LA7_1 = input.LA (1);  				if ((LA7_1 == 31)) {  					alt7 = 1;  				}  			}  			finally {  				DebugExitDecision (7);  			}  			switch (alt7) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  				{  					DebugLocation (105' 51);  					inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (7);  		}  		DebugLocation (105' 60);  		// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  		int alt8 = 2;  		try {  			DebugEnterSubRule (8);  			try {  				DebugEnterDecision (8' false);  				int LA8_1 = input.LA (1);  				if ((LA8_1 == 24)) {  					alt8 = 1;  				}  			}  			finally {  				DebugExitDecision (8);  			}  			switch (alt8) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  				{  					DebugLocation (105' 60);  					not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (8);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (106' 4);  		FilterTreeNode newProperty = new Property (propertySegments);  		if ((inverse != null ? inverse.Text : default(string)) == "?")  			filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  		else {  			if ((not != null ? not.Text : default(string)) == "!")  				newProperty.ToggleInversed ();  			filterNode = newProperty;  		}  	}  	break;  case 4:  	DebugEnterAlt (4);  	// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  	{  		DebugLocation (116' 4);  		STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  		DebugLocation (117' 4);  		string stringText = (STRING7 != null ? STRING7.Text : default(string));  		stringText = stringText.Substring (1' stringText.Length - 2);  		filterNode = new Value (stringText);  	}  	break;  case 5:  	DebugEnterAlt (5);  	// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  	{  		DebugLocation (122' 4);  		REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  		DebugLocation (123' 4);  		string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  		regexText = regexText.Substring (1' regexText.Length - 2);  		filterNode = new RegExp (regexText);  	}  	break;  case 6:  	DebugEnterAlt (6);  	// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  	{  		DebugLocation (128' 4);  		NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  		DebugLocation (129' 4);  		filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  	}  	break;  case 7:  	DebugEnterAlt (7);  	// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  	{  		DebugLocation (132' 4);  		Match (input' TRUE' Follow._TRUE_in_filterExpr271);  		DebugLocation (133' 4);  		filterNode = new Value (true);  	}  	break;  case 8:  	DebugEnterAlt (8);  	// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  	{  		DebugLocation (136' 4);  		Match (input' FALSE' Follow._FALSE_in_filterExpr281);  		DebugLocation (137' 4);  		filterNode = new Value (false);  	}  	break;  case 9:  	DebugEnterAlt (9);  	// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  	{  		DebugLocation (140' 4);  		Match (input' NULL' Follow._NULL_in_filterExpr291);  		DebugLocation (141' 4);  		filterNode = new Value (null);  	}  	break;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: switch (alt9) {  case 1:  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  	{  		DebugLocation (64' 4);  		DebugLocation (64' 6);  		PushFollow (Follow._comparator_in_filterExpr175);  		comparator6 = comparator ();  		PopFollow ();  		Match (input' TokenTypes.Down' null);  		DebugLocation (64' 18);  		PushFollow (Follow._filterExpr_in_filterExpr179);  		a = filterExpr ();  		PopFollow ();  		DebugLocation (64' 31);  		PushFollow (Follow._filterExpr_in_filterExpr183);  		b = filterExpr ();  		PopFollow ();  		Match (input' TokenTypes.Up' null);  		DebugLocation (65' 4);  		Comparator newComparator;  		switch (comparator6) {  		case "=":  			newComparator = Comparator.Equals;  			break;  		case "!=":  			newComparator = Comparator.NotEquals;  			break;  		case ">":  			newComparator = Comparator.Greater;  			break;  		case "<":  			newComparator = Comparator.Less;  			break;  		case ">=":  			newComparator = Comparator.GreaterOrEqual;  			break;  		case "<=":  			newComparator = Comparator.LessOrEqual;  			break;  		case "&":  			newComparator = Comparator.And;  			break;  		case "|":  			newComparator = Comparator.Or;  			break;  		default:  			newComparator = Comparator.Equals;  			break;  		}  		filterNode = new BoolExpression (a' newComparator' b);  	}  	break;  case 2:  	DebugEnterAlt (2);  	// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  	{  		DebugLocation (98' 4);  		DebugLocation (98' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr195);  		Match (input' TokenTypes.Down' null);  		DebugLocation (98' 12);  		PushFollow (Follow._filterExpr_in_filterExpr199);  		f = filterExpr ();  		PopFollow ();  		DebugLocation (98' 31);  		// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  		int alt6 = 2;  		try {  			DebugEnterSubRule (6);  			try {  				DebugEnterDecision (6' false);  				int LA6_1 = input.LA (1);  				if ((LA6_1 == 24)) {  					alt6 = 1;  				}  			}  			finally {  				DebugExitDecision (6);  			}  			switch (alt6) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  				{  					DebugLocation (98' 31);  					inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (6);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (99' 4);  		FilterTreeNode newNode = f;  		if ((inverse != null ? inverse.Text : default(string)) == "!")  			newNode.ToggleInversed ();  		filterNode = newNode;  	}  	break;  case 3:  	DebugEnterAlt (3);  	// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  	{  		DebugLocation (105' 4);  		DebugLocation (105' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr216);  		Match (input' TokenTypes.Down' null);  		DebugLocation (105' 12);  		PushFollow (Follow._propertyChain_in_filterExpr219);  		propertyChain (propertySegments);  		PopFollow ();  		DebugLocation (105' 51);  		// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  		int alt7 = 2;  		try {  			DebugEnterSubRule (7);  			try {  				DebugEnterDecision (7' false);  				int LA7_1 = input.LA (1);  				if ((LA7_1 == 31)) {  					alt7 = 1;  				}  			}  			finally {  				DebugExitDecision (7);  			}  			switch (alt7) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  				{  					DebugLocation (105' 51);  					inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (7);  		}  		DebugLocation (105' 60);  		// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  		int alt8 = 2;  		try {  			DebugEnterSubRule (8);  			try {  				DebugEnterDecision (8' false);  				int LA8_1 = input.LA (1);  				if ((LA8_1 == 24)) {  					alt8 = 1;  				}  			}  			finally {  				DebugExitDecision (8);  			}  			switch (alt8) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  				{  					DebugLocation (105' 60);  					not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (8);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (106' 4);  		FilterTreeNode newProperty = new Property (propertySegments);  		if ((inverse != null ? inverse.Text : default(string)) == "?")  			filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  		else {  			if ((not != null ? not.Text : default(string)) == "!")  				newProperty.ToggleInversed ();  			filterNode = newProperty;  		}  	}  	break;  case 4:  	DebugEnterAlt (4);  	// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  	{  		DebugLocation (116' 4);  		STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  		DebugLocation (117' 4);  		string stringText = (STRING7 != null ? STRING7.Text : default(string));  		stringText = stringText.Substring (1' stringText.Length - 2);  		filterNode = new Value (stringText);  	}  	break;  case 5:  	DebugEnterAlt (5);  	// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  	{  		DebugLocation (122' 4);  		REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  		DebugLocation (123' 4);  		string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  		regexText = regexText.Substring (1' regexText.Length - 2);  		filterNode = new RegExp (regexText);  	}  	break;  case 6:  	DebugEnterAlt (6);  	// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  	{  		DebugLocation (128' 4);  		NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  		DebugLocation (129' 4);  		filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  	}  	break;  case 7:  	DebugEnterAlt (7);  	// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  	{  		DebugLocation (132' 4);  		Match (input' TRUE' Follow._TRUE_in_filterExpr271);  		DebugLocation (133' 4);  		filterNode = new Value (true);  	}  	break;  case 8:  	DebugEnterAlt (8);  	// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  	{  		DebugLocation (136' 4);  		Match (input' FALSE' Follow._FALSE_in_filterExpr281);  		DebugLocation (137' 4);  		filterNode = new Value (false);  	}  	break;  case 9:  	DebugEnterAlt (9);  	// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  	{  		DebugLocation (140' 4);  		Match (input' NULL' Follow._NULL_in_filterExpr291);  		DebugLocation (141' 4);  		filterNode = new Value (null);  	}  	break;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: switch (alt9) {  case 1:  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  	{  		DebugLocation (64' 4);  		DebugLocation (64' 6);  		PushFollow (Follow._comparator_in_filterExpr175);  		comparator6 = comparator ();  		PopFollow ();  		Match (input' TokenTypes.Down' null);  		DebugLocation (64' 18);  		PushFollow (Follow._filterExpr_in_filterExpr179);  		a = filterExpr ();  		PopFollow ();  		DebugLocation (64' 31);  		PushFollow (Follow._filterExpr_in_filterExpr183);  		b = filterExpr ();  		PopFollow ();  		Match (input' TokenTypes.Up' null);  		DebugLocation (65' 4);  		Comparator newComparator;  		switch (comparator6) {  		case "=":  			newComparator = Comparator.Equals;  			break;  		case "!=":  			newComparator = Comparator.NotEquals;  			break;  		case ">":  			newComparator = Comparator.Greater;  			break;  		case "<":  			newComparator = Comparator.Less;  			break;  		case ">=":  			newComparator = Comparator.GreaterOrEqual;  			break;  		case "<=":  			newComparator = Comparator.LessOrEqual;  			break;  		case "&":  			newComparator = Comparator.And;  			break;  		case "|":  			newComparator = Comparator.Or;  			break;  		default:  			newComparator = Comparator.Equals;  			break;  		}  		filterNode = new BoolExpression (a' newComparator' b);  	}  	break;  case 2:  	DebugEnterAlt (2);  	// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  	{  		DebugLocation (98' 4);  		DebugLocation (98' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr195);  		Match (input' TokenTypes.Down' null);  		DebugLocation (98' 12);  		PushFollow (Follow._filterExpr_in_filterExpr199);  		f = filterExpr ();  		PopFollow ();  		DebugLocation (98' 31);  		// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  		int alt6 = 2;  		try {  			DebugEnterSubRule (6);  			try {  				DebugEnterDecision (6' false);  				int LA6_1 = input.LA (1);  				if ((LA6_1 == 24)) {  					alt6 = 1;  				}  			}  			finally {  				DebugExitDecision (6);  			}  			switch (alt6) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  				{  					DebugLocation (98' 31);  					inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (6);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (99' 4);  		FilterTreeNode newNode = f;  		if ((inverse != null ? inverse.Text : default(string)) == "!")  			newNode.ToggleInversed ();  		filterNode = newNode;  	}  	break;  case 3:  	DebugEnterAlt (3);  	// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  	{  		DebugLocation (105' 4);  		DebugLocation (105' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr216);  		Match (input' TokenTypes.Down' null);  		DebugLocation (105' 12);  		PushFollow (Follow._propertyChain_in_filterExpr219);  		propertyChain (propertySegments);  		PopFollow ();  		DebugLocation (105' 51);  		// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  		int alt7 = 2;  		try {  			DebugEnterSubRule (7);  			try {  				DebugEnterDecision (7' false);  				int LA7_1 = input.LA (1);  				if ((LA7_1 == 31)) {  					alt7 = 1;  				}  			}  			finally {  				DebugExitDecision (7);  			}  			switch (alt7) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  				{  					DebugLocation (105' 51);  					inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (7);  		}  		DebugLocation (105' 60);  		// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  		int alt8 = 2;  		try {  			DebugEnterSubRule (8);  			try {  				DebugEnterDecision (8' false);  				int LA8_1 = input.LA (1);  				if ((LA8_1 == 24)) {  					alt8 = 1;  				}  			}  			finally {  				DebugExitDecision (8);  			}  			switch (alt8) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  				{  					DebugLocation (105' 60);  					not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (8);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (106' 4);  		FilterTreeNode newProperty = new Property (propertySegments);  		if ((inverse != null ? inverse.Text : default(string)) == "?")  			filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  		else {  			if ((not != null ? not.Text : default(string)) == "!")  				newProperty.ToggleInversed ();  			filterNode = newProperty;  		}  	}  	break;  case 4:  	DebugEnterAlt (4);  	// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  	{  		DebugLocation (116' 4);  		STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  		DebugLocation (117' 4);  		string stringText = (STRING7 != null ? STRING7.Text : default(string));  		stringText = stringText.Substring (1' stringText.Length - 2);  		filterNode = new Value (stringText);  	}  	break;  case 5:  	DebugEnterAlt (5);  	// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  	{  		DebugLocation (122' 4);  		REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  		DebugLocation (123' 4);  		string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  		regexText = regexText.Substring (1' regexText.Length - 2);  		filterNode = new RegExp (regexText);  	}  	break;  case 6:  	DebugEnterAlt (6);  	// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  	{  		DebugLocation (128' 4);  		NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  		DebugLocation (129' 4);  		filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  	}  	break;  case 7:  	DebugEnterAlt (7);  	// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  	{  		DebugLocation (132' 4);  		Match (input' TRUE' Follow._TRUE_in_filterExpr271);  		DebugLocation (133' 4);  		filterNode = new Value (true);  	}  	break;  case 8:  	DebugEnterAlt (8);  	// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  	{  		DebugLocation (136' 4);  		Match (input' FALSE' Follow._FALSE_in_filterExpr281);  		DebugLocation (137' 4);  		filterNode = new Value (false);  	}  	break;  case 9:  	DebugEnterAlt (9);  	// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  	{  		DebugLocation (140' 4);  		Match (input' NULL' Follow._NULL_in_filterExpr291);  		DebugLocation (141' 4);  		filterNode = new Value (null);  	}  	break;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: switch (alt9) {  case 1:  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  	{  		DebugLocation (64' 4);  		DebugLocation (64' 6);  		PushFollow (Follow._comparator_in_filterExpr175);  		comparator6 = comparator ();  		PopFollow ();  		Match (input' TokenTypes.Down' null);  		DebugLocation (64' 18);  		PushFollow (Follow._filterExpr_in_filterExpr179);  		a = filterExpr ();  		PopFollow ();  		DebugLocation (64' 31);  		PushFollow (Follow._filterExpr_in_filterExpr183);  		b = filterExpr ();  		PopFollow ();  		Match (input' TokenTypes.Up' null);  		DebugLocation (65' 4);  		Comparator newComparator;  		switch (comparator6) {  		case "=":  			newComparator = Comparator.Equals;  			break;  		case "!=":  			newComparator = Comparator.NotEquals;  			break;  		case ">":  			newComparator = Comparator.Greater;  			break;  		case "<":  			newComparator = Comparator.Less;  			break;  		case ">=":  			newComparator = Comparator.GreaterOrEqual;  			break;  		case "<=":  			newComparator = Comparator.LessOrEqual;  			break;  		case "&":  			newComparator = Comparator.And;  			break;  		case "|":  			newComparator = Comparator.Or;  			break;  		default:  			newComparator = Comparator.Equals;  			break;  		}  		filterNode = new BoolExpression (a' newComparator' b);  	}  	break;  case 2:  	DebugEnterAlt (2);  	// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  	{  		DebugLocation (98' 4);  		DebugLocation (98' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr195);  		Match (input' TokenTypes.Down' null);  		DebugLocation (98' 12);  		PushFollow (Follow._filterExpr_in_filterExpr199);  		f = filterExpr ();  		PopFollow ();  		DebugLocation (98' 31);  		// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  		int alt6 = 2;  		try {  			DebugEnterSubRule (6);  			try {  				DebugEnterDecision (6' false);  				int LA6_1 = input.LA (1);  				if ((LA6_1 == 24)) {  					alt6 = 1;  				}  			}  			finally {  				DebugExitDecision (6);  			}  			switch (alt6) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  				{  					DebugLocation (98' 31);  					inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (6);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (99' 4);  		FilterTreeNode newNode = f;  		if ((inverse != null ? inverse.Text : default(string)) == "!")  			newNode.ToggleInversed ();  		filterNode = newNode;  	}  	break;  case 3:  	DebugEnterAlt (3);  	// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  	{  		DebugLocation (105' 4);  		DebugLocation (105' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr216);  		Match (input' TokenTypes.Down' null);  		DebugLocation (105' 12);  		PushFollow (Follow._propertyChain_in_filterExpr219);  		propertyChain (propertySegments);  		PopFollow ();  		DebugLocation (105' 51);  		// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  		int alt7 = 2;  		try {  			DebugEnterSubRule (7);  			try {  				DebugEnterDecision (7' false);  				int LA7_1 = input.LA (1);  				if ((LA7_1 == 31)) {  					alt7 = 1;  				}  			}  			finally {  				DebugExitDecision (7);  			}  			switch (alt7) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  				{  					DebugLocation (105' 51);  					inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (7);  		}  		DebugLocation (105' 60);  		// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  		int alt8 = 2;  		try {  			DebugEnterSubRule (8);  			try {  				DebugEnterDecision (8' false);  				int LA8_1 = input.LA (1);  				if ((LA8_1 == 24)) {  					alt8 = 1;  				}  			}  			finally {  				DebugExitDecision (8);  			}  			switch (alt8) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  				{  					DebugLocation (105' 60);  					not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (8);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (106' 4);  		FilterTreeNode newProperty = new Property (propertySegments);  		if ((inverse != null ? inverse.Text : default(string)) == "?")  			filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  		else {  			if ((not != null ? not.Text : default(string)) == "!")  				newProperty.ToggleInversed ();  			filterNode = newProperty;  		}  	}  	break;  case 4:  	DebugEnterAlt (4);  	// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  	{  		DebugLocation (116' 4);  		STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  		DebugLocation (117' 4);  		string stringText = (STRING7 != null ? STRING7.Text : default(string));  		stringText = stringText.Substring (1' stringText.Length - 2);  		filterNode = new Value (stringText);  	}  	break;  case 5:  	DebugEnterAlt (5);  	// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  	{  		DebugLocation (122' 4);  		REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  		DebugLocation (123' 4);  		string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  		regexText = regexText.Substring (1' regexText.Length - 2);  		filterNode = new RegExp (regexText);  	}  	break;  case 6:  	DebugEnterAlt (6);  	// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  	{  		DebugLocation (128' 4);  		NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  		DebugLocation (129' 4);  		filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  	}  	break;  case 7:  	DebugEnterAlt (7);  	// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  	{  		DebugLocation (132' 4);  		Match (input' TRUE' Follow._TRUE_in_filterExpr271);  		DebugLocation (133' 4);  		filterNode = new Value (true);  	}  	break;  case 8:  	DebugEnterAlt (8);  	// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  	{  		DebugLocation (136' 4);  		Match (input' FALSE' Follow._FALSE_in_filterExpr281);  		DebugLocation (137' 4);  		filterNode = new Value (false);  	}  	break;  case 9:  	DebugEnterAlt (9);  	// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  	{  		DebugLocation (140' 4);  		Match (input' NULL' Follow._NULL_in_filterExpr291);  		DebugLocation (141' 4);  		filterNode = new Value (null);  	}  	break;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: switch (alt9) {  case 1:  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  	{  		DebugLocation (64' 4);  		DebugLocation (64' 6);  		PushFollow (Follow._comparator_in_filterExpr175);  		comparator6 = comparator ();  		PopFollow ();  		Match (input' TokenTypes.Down' null);  		DebugLocation (64' 18);  		PushFollow (Follow._filterExpr_in_filterExpr179);  		a = filterExpr ();  		PopFollow ();  		DebugLocation (64' 31);  		PushFollow (Follow._filterExpr_in_filterExpr183);  		b = filterExpr ();  		PopFollow ();  		Match (input' TokenTypes.Up' null);  		DebugLocation (65' 4);  		Comparator newComparator;  		switch (comparator6) {  		case "=":  			newComparator = Comparator.Equals;  			break;  		case "!=":  			newComparator = Comparator.NotEquals;  			break;  		case ">":  			newComparator = Comparator.Greater;  			break;  		case "<":  			newComparator = Comparator.Less;  			break;  		case ">=":  			newComparator = Comparator.GreaterOrEqual;  			break;  		case "<=":  			newComparator = Comparator.LessOrEqual;  			break;  		case "&":  			newComparator = Comparator.And;  			break;  		case "|":  			newComparator = Comparator.Or;  			break;  		default:  			newComparator = Comparator.Equals;  			break;  		}  		filterNode = new BoolExpression (a' newComparator' b);  	}  	break;  case 2:  	DebugEnterAlt (2);  	// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  	{  		DebugLocation (98' 4);  		DebugLocation (98' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr195);  		Match (input' TokenTypes.Down' null);  		DebugLocation (98' 12);  		PushFollow (Follow._filterExpr_in_filterExpr199);  		f = filterExpr ();  		PopFollow ();  		DebugLocation (98' 31);  		// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  		int alt6 = 2;  		try {  			DebugEnterSubRule (6);  			try {  				DebugEnterDecision (6' false);  				int LA6_1 = input.LA (1);  				if ((LA6_1 == 24)) {  					alt6 = 1;  				}  			}  			finally {  				DebugExitDecision (6);  			}  			switch (alt6) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  				{  					DebugLocation (98' 31);  					inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (6);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (99' 4);  		FilterTreeNode newNode = f;  		if ((inverse != null ? inverse.Text : default(string)) == "!")  			newNode.ToggleInversed ();  		filterNode = newNode;  	}  	break;  case 3:  	DebugEnterAlt (3);  	// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  	{  		DebugLocation (105' 4);  		DebugLocation (105' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr216);  		Match (input' TokenTypes.Down' null);  		DebugLocation (105' 12);  		PushFollow (Follow._propertyChain_in_filterExpr219);  		propertyChain (propertySegments);  		PopFollow ();  		DebugLocation (105' 51);  		// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  		int alt7 = 2;  		try {  			DebugEnterSubRule (7);  			try {  				DebugEnterDecision (7' false);  				int LA7_1 = input.LA (1);  				if ((LA7_1 == 31)) {  					alt7 = 1;  				}  			}  			finally {  				DebugExitDecision (7);  			}  			switch (alt7) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  				{  					DebugLocation (105' 51);  					inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (7);  		}  		DebugLocation (105' 60);  		// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  		int alt8 = 2;  		try {  			DebugEnterSubRule (8);  			try {  				DebugEnterDecision (8' false);  				int LA8_1 = input.LA (1);  				if ((LA8_1 == 24)) {  					alt8 = 1;  				}  			}  			finally {  				DebugExitDecision (8);  			}  			switch (alt8) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  				{  					DebugLocation (105' 60);  					not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (8);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (106' 4);  		FilterTreeNode newProperty = new Property (propertySegments);  		if ((inverse != null ? inverse.Text : default(string)) == "?")  			filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  		else {  			if ((not != null ? not.Text : default(string)) == "!")  				newProperty.ToggleInversed ();  			filterNode = newProperty;  		}  	}  	break;  case 4:  	DebugEnterAlt (4);  	// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  	{  		DebugLocation (116' 4);  		STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  		DebugLocation (117' 4);  		string stringText = (STRING7 != null ? STRING7.Text : default(string));  		stringText = stringText.Substring (1' stringText.Length - 2);  		filterNode = new Value (stringText);  	}  	break;  case 5:  	DebugEnterAlt (5);  	// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  	{  		DebugLocation (122' 4);  		REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  		DebugLocation (123' 4);  		string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  		regexText = regexText.Substring (1' regexText.Length - 2);  		filterNode = new RegExp (regexText);  	}  	break;  case 6:  	DebugEnterAlt (6);  	// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  	{  		DebugLocation (128' 4);  		NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  		DebugLocation (129' 4);  		filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  	}  	break;  case 7:  	DebugEnterAlt (7);  	// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  	{  		DebugLocation (132' 4);  		Match (input' TRUE' Follow._TRUE_in_filterExpr271);  		DebugLocation (133' 4);  		filterNode = new Value (true);  	}  	break;  case 8:  	DebugEnterAlt (8);  	// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  	{  		DebugLocation (136' 4);  		Match (input' FALSE' Follow._FALSE_in_filterExpr281);  		DebugLocation (137' 4);  		filterNode = new Value (false);  	}  	break;  case 9:  	DebugEnterAlt (9);  	// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  	{  		DebugLocation (140' 4);  		Match (input' NULL' Follow._NULL_in_filterExpr291);  		DebugLocation (141' 4);  		filterNode = new Value (null);  	}  	break;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: switch (alt9) {  case 1:  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  	{  		DebugLocation (64' 4);  		DebugLocation (64' 6);  		PushFollow (Follow._comparator_in_filterExpr175);  		comparator6 = comparator ();  		PopFollow ();  		Match (input' TokenTypes.Down' null);  		DebugLocation (64' 18);  		PushFollow (Follow._filterExpr_in_filterExpr179);  		a = filterExpr ();  		PopFollow ();  		DebugLocation (64' 31);  		PushFollow (Follow._filterExpr_in_filterExpr183);  		b = filterExpr ();  		PopFollow ();  		Match (input' TokenTypes.Up' null);  		DebugLocation (65' 4);  		Comparator newComparator;  		switch (comparator6) {  		case "=":  			newComparator = Comparator.Equals;  			break;  		case "!=":  			newComparator = Comparator.NotEquals;  			break;  		case ">":  			newComparator = Comparator.Greater;  			break;  		case "<":  			newComparator = Comparator.Less;  			break;  		case ">=":  			newComparator = Comparator.GreaterOrEqual;  			break;  		case "<=":  			newComparator = Comparator.LessOrEqual;  			break;  		case "&":  			newComparator = Comparator.And;  			break;  		case "|":  			newComparator = Comparator.Or;  			break;  		default:  			newComparator = Comparator.Equals;  			break;  		}  		filterNode = new BoolExpression (a' newComparator' b);  	}  	break;  case 2:  	DebugEnterAlt (2);  	// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  	{  		DebugLocation (98' 4);  		DebugLocation (98' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr195);  		Match (input' TokenTypes.Down' null);  		DebugLocation (98' 12);  		PushFollow (Follow._filterExpr_in_filterExpr199);  		f = filterExpr ();  		PopFollow ();  		DebugLocation (98' 31);  		// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  		int alt6 = 2;  		try {  			DebugEnterSubRule (6);  			try {  				DebugEnterDecision (6' false);  				int LA6_1 = input.LA (1);  				if ((LA6_1 == 24)) {  					alt6 = 1;  				}  			}  			finally {  				DebugExitDecision (6);  			}  			switch (alt6) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  				{  					DebugLocation (98' 31);  					inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (6);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (99' 4);  		FilterTreeNode newNode = f;  		if ((inverse != null ? inverse.Text : default(string)) == "!")  			newNode.ToggleInversed ();  		filterNode = newNode;  	}  	break;  case 3:  	DebugEnterAlt (3);  	// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  	{  		DebugLocation (105' 4);  		DebugLocation (105' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr216);  		Match (input' TokenTypes.Down' null);  		DebugLocation (105' 12);  		PushFollow (Follow._propertyChain_in_filterExpr219);  		propertyChain (propertySegments);  		PopFollow ();  		DebugLocation (105' 51);  		// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  		int alt7 = 2;  		try {  			DebugEnterSubRule (7);  			try {  				DebugEnterDecision (7' false);  				int LA7_1 = input.LA (1);  				if ((LA7_1 == 31)) {  					alt7 = 1;  				}  			}  			finally {  				DebugExitDecision (7);  			}  			switch (alt7) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  				{  					DebugLocation (105' 51);  					inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (7);  		}  		DebugLocation (105' 60);  		// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  		int alt8 = 2;  		try {  			DebugEnterSubRule (8);  			try {  				DebugEnterDecision (8' false);  				int LA8_1 = input.LA (1);  				if ((LA8_1 == 24)) {  					alt8 = 1;  				}  			}  			finally {  				DebugExitDecision (8);  			}  			switch (alt8) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  				{  					DebugLocation (105' 60);  					not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (8);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (106' 4);  		FilterTreeNode newProperty = new Property (propertySegments);  		if ((inverse != null ? inverse.Text : default(string)) == "?")  			filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  		else {  			if ((not != null ? not.Text : default(string)) == "!")  				newProperty.ToggleInversed ();  			filterNode = newProperty;  		}  	}  	break;  case 4:  	DebugEnterAlt (4);  	// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  	{  		DebugLocation (116' 4);  		STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  		DebugLocation (117' 4);  		string stringText = (STRING7 != null ? STRING7.Text : default(string));  		stringText = stringText.Substring (1' stringText.Length - 2);  		filterNode = new Value (stringText);  	}  	break;  case 5:  	DebugEnterAlt (5);  	// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  	{  		DebugLocation (122' 4);  		REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  		DebugLocation (123' 4);  		string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  		regexText = regexText.Substring (1' regexText.Length - 2);  		filterNode = new RegExp (regexText);  	}  	break;  case 6:  	DebugEnterAlt (6);  	// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  	{  		DebugLocation (128' 4);  		NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  		DebugLocation (129' 4);  		filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  	}  	break;  case 7:  	DebugEnterAlt (7);  	// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  	{  		DebugLocation (132' 4);  		Match (input' TRUE' Follow._TRUE_in_filterExpr271);  		DebugLocation (133' 4);  		filterNode = new Value (true);  	}  	break;  case 8:  	DebugEnterAlt (8);  	// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  	{  		DebugLocation (136' 4);  		Match (input' FALSE' Follow._FALSE_in_filterExpr281);  		DebugLocation (137' 4);  		filterNode = new Value (false);  	}  	break;  case 9:  	DebugEnterAlt (9);  	// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  	{  		DebugLocation (140' 4);  		Match (input' NULL' Follow._NULL_in_filterExpr291);  		DebugLocation (141' 4);  		filterNode = new Value (null);  	}  	break;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: switch (alt9) {  case 1:  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  	{  		DebugLocation (64' 4);  		DebugLocation (64' 6);  		PushFollow (Follow._comparator_in_filterExpr175);  		comparator6 = comparator ();  		PopFollow ();  		Match (input' TokenTypes.Down' null);  		DebugLocation (64' 18);  		PushFollow (Follow._filterExpr_in_filterExpr179);  		a = filterExpr ();  		PopFollow ();  		DebugLocation (64' 31);  		PushFollow (Follow._filterExpr_in_filterExpr183);  		b = filterExpr ();  		PopFollow ();  		Match (input' TokenTypes.Up' null);  		DebugLocation (65' 4);  		Comparator newComparator;  		switch (comparator6) {  		case "=":  			newComparator = Comparator.Equals;  			break;  		case "!=":  			newComparator = Comparator.NotEquals;  			break;  		case ">":  			newComparator = Comparator.Greater;  			break;  		case "<":  			newComparator = Comparator.Less;  			break;  		case ">=":  			newComparator = Comparator.GreaterOrEqual;  			break;  		case "<=":  			newComparator = Comparator.LessOrEqual;  			break;  		case "&":  			newComparator = Comparator.And;  			break;  		case "|":  			newComparator = Comparator.Or;  			break;  		default:  			newComparator = Comparator.Equals;  			break;  		}  		filterNode = new BoolExpression (a' newComparator' b);  	}  	break;  case 2:  	DebugEnterAlt (2);  	// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  	{  		DebugLocation (98' 4);  		DebugLocation (98' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr195);  		Match (input' TokenTypes.Down' null);  		DebugLocation (98' 12);  		PushFollow (Follow._filterExpr_in_filterExpr199);  		f = filterExpr ();  		PopFollow ();  		DebugLocation (98' 31);  		// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  		int alt6 = 2;  		try {  			DebugEnterSubRule (6);  			try {  				DebugEnterDecision (6' false);  				int LA6_1 = input.LA (1);  				if ((LA6_1 == 24)) {  					alt6 = 1;  				}  			}  			finally {  				DebugExitDecision (6);  			}  			switch (alt6) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  				{  					DebugLocation (98' 31);  					inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (6);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (99' 4);  		FilterTreeNode newNode = f;  		if ((inverse != null ? inverse.Text : default(string)) == "!")  			newNode.ToggleInversed ();  		filterNode = newNode;  	}  	break;  case 3:  	DebugEnterAlt (3);  	// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  	{  		DebugLocation (105' 4);  		DebugLocation (105' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr216);  		Match (input' TokenTypes.Down' null);  		DebugLocation (105' 12);  		PushFollow (Follow._propertyChain_in_filterExpr219);  		propertyChain (propertySegments);  		PopFollow ();  		DebugLocation (105' 51);  		// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  		int alt7 = 2;  		try {  			DebugEnterSubRule (7);  			try {  				DebugEnterDecision (7' false);  				int LA7_1 = input.LA (1);  				if ((LA7_1 == 31)) {  					alt7 = 1;  				}  			}  			finally {  				DebugExitDecision (7);  			}  			switch (alt7) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  				{  					DebugLocation (105' 51);  					inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (7);  		}  		DebugLocation (105' 60);  		// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  		int alt8 = 2;  		try {  			DebugEnterSubRule (8);  			try {  				DebugEnterDecision (8' false);  				int LA8_1 = input.LA (1);  				if ((LA8_1 == 24)) {  					alt8 = 1;  				}  			}  			finally {  				DebugExitDecision (8);  			}  			switch (alt8) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  				{  					DebugLocation (105' 60);  					not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (8);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (106' 4);  		FilterTreeNode newProperty = new Property (propertySegments);  		if ((inverse != null ? inverse.Text : default(string)) == "?")  			filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  		else {  			if ((not != null ? not.Text : default(string)) == "!")  				newProperty.ToggleInversed ();  			filterNode = newProperty;  		}  	}  	break;  case 4:  	DebugEnterAlt (4);  	// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  	{  		DebugLocation (116' 4);  		STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  		DebugLocation (117' 4);  		string stringText = (STRING7 != null ? STRING7.Text : default(string));  		stringText = stringText.Substring (1' stringText.Length - 2);  		filterNode = new Value (stringText);  	}  	break;  case 5:  	DebugEnterAlt (5);  	// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  	{  		DebugLocation (122' 4);  		REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  		DebugLocation (123' 4);  		string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  		regexText = regexText.Substring (1' regexText.Length - 2);  		filterNode = new RegExp (regexText);  	}  	break;  case 6:  	DebugEnterAlt (6);  	// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  	{  		DebugLocation (128' 4);  		NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  		DebugLocation (129' 4);  		filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  	}  	break;  case 7:  	DebugEnterAlt (7);  	// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  	{  		DebugLocation (132' 4);  		Match (input' TRUE' Follow._TRUE_in_filterExpr271);  		DebugLocation (133' 4);  		filterNode = new Value (true);  	}  	break;  case 8:  	DebugEnterAlt (8);  	// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  	{  		DebugLocation (136' 4);  		Match (input' FALSE' Follow._FALSE_in_filterExpr281);  		DebugLocation (137' 4);  		filterNode = new Value (false);  	}  	break;  case 9:  	DebugEnterAlt (9);  	// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  	{  		DebugLocation (140' 4);  		Match (input' NULL' Follow._NULL_in_filterExpr291);  		DebugLocation (141' 4);  		filterNode = new Value (null);  	}  	break;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: switch (alt9) {  case 1:  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  	{  		DebugLocation (64' 4);  		DebugLocation (64' 6);  		PushFollow (Follow._comparator_in_filterExpr175);  		comparator6 = comparator ();  		PopFollow ();  		Match (input' TokenTypes.Down' null);  		DebugLocation (64' 18);  		PushFollow (Follow._filterExpr_in_filterExpr179);  		a = filterExpr ();  		PopFollow ();  		DebugLocation (64' 31);  		PushFollow (Follow._filterExpr_in_filterExpr183);  		b = filterExpr ();  		PopFollow ();  		Match (input' TokenTypes.Up' null);  		DebugLocation (65' 4);  		Comparator newComparator;  		switch (comparator6) {  		case "=":  			newComparator = Comparator.Equals;  			break;  		case "!=":  			newComparator = Comparator.NotEquals;  			break;  		case ">":  			newComparator = Comparator.Greater;  			break;  		case "<":  			newComparator = Comparator.Less;  			break;  		case ">=":  			newComparator = Comparator.GreaterOrEqual;  			break;  		case "<=":  			newComparator = Comparator.LessOrEqual;  			break;  		case "&":  			newComparator = Comparator.And;  			break;  		case "|":  			newComparator = Comparator.Or;  			break;  		default:  			newComparator = Comparator.Equals;  			break;  		}  		filterNode = new BoolExpression (a' newComparator' b);  	}  	break;  case 2:  	DebugEnterAlt (2);  	// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  	{  		DebugLocation (98' 4);  		DebugLocation (98' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr195);  		Match (input' TokenTypes.Down' null);  		DebugLocation (98' 12);  		PushFollow (Follow._filterExpr_in_filterExpr199);  		f = filterExpr ();  		PopFollow ();  		DebugLocation (98' 31);  		// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  		int alt6 = 2;  		try {  			DebugEnterSubRule (6);  			try {  				DebugEnterDecision (6' false);  				int LA6_1 = input.LA (1);  				if ((LA6_1 == 24)) {  					alt6 = 1;  				}  			}  			finally {  				DebugExitDecision (6);  			}  			switch (alt6) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  				{  					DebugLocation (98' 31);  					inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (6);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (99' 4);  		FilterTreeNode newNode = f;  		if ((inverse != null ? inverse.Text : default(string)) == "!")  			newNode.ToggleInversed ();  		filterNode = newNode;  	}  	break;  case 3:  	DebugEnterAlt (3);  	// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  	{  		DebugLocation (105' 4);  		DebugLocation (105' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr216);  		Match (input' TokenTypes.Down' null);  		DebugLocation (105' 12);  		PushFollow (Follow._propertyChain_in_filterExpr219);  		propertyChain (propertySegments);  		PopFollow ();  		DebugLocation (105' 51);  		// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  		int alt7 = 2;  		try {  			DebugEnterSubRule (7);  			try {  				DebugEnterDecision (7' false);  				int LA7_1 = input.LA (1);  				if ((LA7_1 == 31)) {  					alt7 = 1;  				}  			}  			finally {  				DebugExitDecision (7);  			}  			switch (alt7) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  				{  					DebugLocation (105' 51);  					inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (7);  		}  		DebugLocation (105' 60);  		// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  		int alt8 = 2;  		try {  			DebugEnterSubRule (8);  			try {  				DebugEnterDecision (8' false);  				int LA8_1 = input.LA (1);  				if ((LA8_1 == 24)) {  					alt8 = 1;  				}  			}  			finally {  				DebugExitDecision (8);  			}  			switch (alt8) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  				{  					DebugLocation (105' 60);  					not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (8);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (106' 4);  		FilterTreeNode newProperty = new Property (propertySegments);  		if ((inverse != null ? inverse.Text : default(string)) == "?")  			filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  		else {  			if ((not != null ? not.Text : default(string)) == "!")  				newProperty.ToggleInversed ();  			filterNode = newProperty;  		}  	}  	break;  case 4:  	DebugEnterAlt (4);  	// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  	{  		DebugLocation (116' 4);  		STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  		DebugLocation (117' 4);  		string stringText = (STRING7 != null ? STRING7.Text : default(string));  		stringText = stringText.Substring (1' stringText.Length - 2);  		filterNode = new Value (stringText);  	}  	break;  case 5:  	DebugEnterAlt (5);  	// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  	{  		DebugLocation (122' 4);  		REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  		DebugLocation (123' 4);  		string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  		regexText = regexText.Substring (1' regexText.Length - 2);  		filterNode = new RegExp (regexText);  	}  	break;  case 6:  	DebugEnterAlt (6);  	// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  	{  		DebugLocation (128' 4);  		NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  		DebugLocation (129' 4);  		filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  	}  	break;  case 7:  	DebugEnterAlt (7);  	// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  	{  		DebugLocation (132' 4);  		Match (input' TRUE' Follow._TRUE_in_filterExpr271);  		DebugLocation (133' 4);  		filterNode = new Value (true);  	}  	break;  case 8:  	DebugEnterAlt (8);  	// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  	{  		DebugLocation (136' 4);  		Match (input' FALSE' Follow._FALSE_in_filterExpr281);  		DebugLocation (137' 4);  		filterNode = new Value (false);  	}  	break;  case 9:  	DebugEnterAlt (9);  	// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  	{  		DebugLocation (140' 4);  		Match (input' NULL' Follow._NULL_in_filterExpr291);  		DebugLocation (141' 4);  		filterNode = new Value (null);  	}  	break;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: switch (alt9) {  case 1:  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  	{  		DebugLocation (64' 4);  		DebugLocation (64' 6);  		PushFollow (Follow._comparator_in_filterExpr175);  		comparator6 = comparator ();  		PopFollow ();  		Match (input' TokenTypes.Down' null);  		DebugLocation (64' 18);  		PushFollow (Follow._filterExpr_in_filterExpr179);  		a = filterExpr ();  		PopFollow ();  		DebugLocation (64' 31);  		PushFollow (Follow._filterExpr_in_filterExpr183);  		b = filterExpr ();  		PopFollow ();  		Match (input' TokenTypes.Up' null);  		DebugLocation (65' 4);  		Comparator newComparator;  		switch (comparator6) {  		case "=":  			newComparator = Comparator.Equals;  			break;  		case "!=":  			newComparator = Comparator.NotEquals;  			break;  		case ">":  			newComparator = Comparator.Greater;  			break;  		case "<":  			newComparator = Comparator.Less;  			break;  		case ">=":  			newComparator = Comparator.GreaterOrEqual;  			break;  		case "<=":  			newComparator = Comparator.LessOrEqual;  			break;  		case "&":  			newComparator = Comparator.And;  			break;  		case "|":  			newComparator = Comparator.Or;  			break;  		default:  			newComparator = Comparator.Equals;  			break;  		}  		filterNode = new BoolExpression (a' newComparator' b);  	}  	break;  case 2:  	DebugEnterAlt (2);  	// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  	{  		DebugLocation (98' 4);  		DebugLocation (98' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr195);  		Match (input' TokenTypes.Down' null);  		DebugLocation (98' 12);  		PushFollow (Follow._filterExpr_in_filterExpr199);  		f = filterExpr ();  		PopFollow ();  		DebugLocation (98' 31);  		// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  		int alt6 = 2;  		try {  			DebugEnterSubRule (6);  			try {  				DebugEnterDecision (6' false);  				int LA6_1 = input.LA (1);  				if ((LA6_1 == 24)) {  					alt6 = 1;  				}  			}  			finally {  				DebugExitDecision (6);  			}  			switch (alt6) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  				{  					DebugLocation (98' 31);  					inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (6);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (99' 4);  		FilterTreeNode newNode = f;  		if ((inverse != null ? inverse.Text : default(string)) == "!")  			newNode.ToggleInversed ();  		filterNode = newNode;  	}  	break;  case 3:  	DebugEnterAlt (3);  	// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  	{  		DebugLocation (105' 4);  		DebugLocation (105' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr216);  		Match (input' TokenTypes.Down' null);  		DebugLocation (105' 12);  		PushFollow (Follow._propertyChain_in_filterExpr219);  		propertyChain (propertySegments);  		PopFollow ();  		DebugLocation (105' 51);  		// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  		int alt7 = 2;  		try {  			DebugEnterSubRule (7);  			try {  				DebugEnterDecision (7' false);  				int LA7_1 = input.LA (1);  				if ((LA7_1 == 31)) {  					alt7 = 1;  				}  			}  			finally {  				DebugExitDecision (7);  			}  			switch (alt7) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  				{  					DebugLocation (105' 51);  					inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (7);  		}  		DebugLocation (105' 60);  		// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  		int alt8 = 2;  		try {  			DebugEnterSubRule (8);  			try {  				DebugEnterDecision (8' false);  				int LA8_1 = input.LA (1);  				if ((LA8_1 == 24)) {  					alt8 = 1;  				}  			}  			finally {  				DebugExitDecision (8);  			}  			switch (alt8) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  				{  					DebugLocation (105' 60);  					not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (8);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (106' 4);  		FilterTreeNode newProperty = new Property (propertySegments);  		if ((inverse != null ? inverse.Text : default(string)) == "?")  			filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  		else {  			if ((not != null ? not.Text : default(string)) == "!")  				newProperty.ToggleInversed ();  			filterNode = newProperty;  		}  	}  	break;  case 4:  	DebugEnterAlt (4);  	// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  	{  		DebugLocation (116' 4);  		STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  		DebugLocation (117' 4);  		string stringText = (STRING7 != null ? STRING7.Text : default(string));  		stringText = stringText.Substring (1' stringText.Length - 2);  		filterNode = new Value (stringText);  	}  	break;  case 5:  	DebugEnterAlt (5);  	// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  	{  		DebugLocation (122' 4);  		REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  		DebugLocation (123' 4);  		string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  		regexText = regexText.Substring (1' regexText.Length - 2);  		filterNode = new RegExp (regexText);  	}  	break;  case 6:  	DebugEnterAlt (6);  	// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  	{  		DebugLocation (128' 4);  		NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  		DebugLocation (129' 4);  		filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  	}  	break;  case 7:  	DebugEnterAlt (7);  	// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  	{  		DebugLocation (132' 4);  		Match (input' TRUE' Follow._TRUE_in_filterExpr271);  		DebugLocation (133' 4);  		filterNode = new Value (true);  	}  	break;  case 8:  	DebugEnterAlt (8);  	// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  	{  		DebugLocation (136' 4);  		Match (input' FALSE' Follow._FALSE_in_filterExpr281);  		DebugLocation (137' 4);  		filterNode = new Value (false);  	}  	break;  case 9:  	DebugEnterAlt (9);  	// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  	{  		DebugLocation (140' 4);  		Match (input' NULL' Follow._NULL_in_filterExpr291);  		DebugLocation (141' 4);  		filterNode = new Value (null);  	}  	break;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: switch (alt9) {  case 1:  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  	{  		DebugLocation (64' 4);  		DebugLocation (64' 6);  		PushFollow (Follow._comparator_in_filterExpr175);  		comparator6 = comparator ();  		PopFollow ();  		Match (input' TokenTypes.Down' null);  		DebugLocation (64' 18);  		PushFollow (Follow._filterExpr_in_filterExpr179);  		a = filterExpr ();  		PopFollow ();  		DebugLocation (64' 31);  		PushFollow (Follow._filterExpr_in_filterExpr183);  		b = filterExpr ();  		PopFollow ();  		Match (input' TokenTypes.Up' null);  		DebugLocation (65' 4);  		Comparator newComparator;  		switch (comparator6) {  		case "=":  			newComparator = Comparator.Equals;  			break;  		case "!=":  			newComparator = Comparator.NotEquals;  			break;  		case ">":  			newComparator = Comparator.Greater;  			break;  		case "<":  			newComparator = Comparator.Less;  			break;  		case ">=":  			newComparator = Comparator.GreaterOrEqual;  			break;  		case "<=":  			newComparator = Comparator.LessOrEqual;  			break;  		case "&":  			newComparator = Comparator.And;  			break;  		case "|":  			newComparator = Comparator.Or;  			break;  		default:  			newComparator = Comparator.Equals;  			break;  		}  		filterNode = new BoolExpression (a' newComparator' b);  	}  	break;  case 2:  	DebugEnterAlt (2);  	// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  	{  		DebugLocation (98' 4);  		DebugLocation (98' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr195);  		Match (input' TokenTypes.Down' null);  		DebugLocation (98' 12);  		PushFollow (Follow._filterExpr_in_filterExpr199);  		f = filterExpr ();  		PopFollow ();  		DebugLocation (98' 31);  		// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  		int alt6 = 2;  		try {  			DebugEnterSubRule (6);  			try {  				DebugEnterDecision (6' false);  				int LA6_1 = input.LA (1);  				if ((LA6_1 == 24)) {  					alt6 = 1;  				}  			}  			finally {  				DebugExitDecision (6);  			}  			switch (alt6) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  				{  					DebugLocation (98' 31);  					inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (6);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (99' 4);  		FilterTreeNode newNode = f;  		if ((inverse != null ? inverse.Text : default(string)) == "!")  			newNode.ToggleInversed ();  		filterNode = newNode;  	}  	break;  case 3:  	DebugEnterAlt (3);  	// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  	{  		DebugLocation (105' 4);  		DebugLocation (105' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr216);  		Match (input' TokenTypes.Down' null);  		DebugLocation (105' 12);  		PushFollow (Follow._propertyChain_in_filterExpr219);  		propertyChain (propertySegments);  		PopFollow ();  		DebugLocation (105' 51);  		// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  		int alt7 = 2;  		try {  			DebugEnterSubRule (7);  			try {  				DebugEnterDecision (7' false);  				int LA7_1 = input.LA (1);  				if ((LA7_1 == 31)) {  					alt7 = 1;  				}  			}  			finally {  				DebugExitDecision (7);  			}  			switch (alt7) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  				{  					DebugLocation (105' 51);  					inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (7);  		}  		DebugLocation (105' 60);  		// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  		int alt8 = 2;  		try {  			DebugEnterSubRule (8);  			try {  				DebugEnterDecision (8' false);  				int LA8_1 = input.LA (1);  				if ((LA8_1 == 24)) {  					alt8 = 1;  				}  			}  			finally {  				DebugExitDecision (8);  			}  			switch (alt8) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  				{  					DebugLocation (105' 60);  					not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (8);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (106' 4);  		FilterTreeNode newProperty = new Property (propertySegments);  		if ((inverse != null ? inverse.Text : default(string)) == "?")  			filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  		else {  			if ((not != null ? not.Text : default(string)) == "!")  				newProperty.ToggleInversed ();  			filterNode = newProperty;  		}  	}  	break;  case 4:  	DebugEnterAlt (4);  	// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  	{  		DebugLocation (116' 4);  		STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  		DebugLocation (117' 4);  		string stringText = (STRING7 != null ? STRING7.Text : default(string));  		stringText = stringText.Substring (1' stringText.Length - 2);  		filterNode = new Value (stringText);  	}  	break;  case 5:  	DebugEnterAlt (5);  	// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  	{  		DebugLocation (122' 4);  		REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  		DebugLocation (123' 4);  		string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  		regexText = regexText.Substring (1' regexText.Length - 2);  		filterNode = new RegExp (regexText);  	}  	break;  case 6:  	DebugEnterAlt (6);  	// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  	{  		DebugLocation (128' 4);  		NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  		DebugLocation (129' 4);  		filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  	}  	break;  case 7:  	DebugEnterAlt (7);  	// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  	{  		DebugLocation (132' 4);  		Match (input' TRUE' Follow._TRUE_in_filterExpr271);  		DebugLocation (133' 4);  		filterNode = new Value (true);  	}  	break;  case 8:  	DebugEnterAlt (8);  	// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  	{  		DebugLocation (136' 4);  		Match (input' FALSE' Follow._FALSE_in_filterExpr281);  		DebugLocation (137' 4);  		filterNode = new Value (false);  	}  	break;  case 9:  	DebugEnterAlt (9);  	// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  	{  		DebugLocation (140' 4);  		Match (input' NULL' Follow._NULL_in_filterExpr291);  		DebugLocation (141' 4);  		filterNode = new Value (null);  	}  	break;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: switch (alt9) {  case 1:  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  	{  		DebugLocation (64' 4);  		DebugLocation (64' 6);  		PushFollow (Follow._comparator_in_filterExpr175);  		comparator6 = comparator ();  		PopFollow ();  		Match (input' TokenTypes.Down' null);  		DebugLocation (64' 18);  		PushFollow (Follow._filterExpr_in_filterExpr179);  		a = filterExpr ();  		PopFollow ();  		DebugLocation (64' 31);  		PushFollow (Follow._filterExpr_in_filterExpr183);  		b = filterExpr ();  		PopFollow ();  		Match (input' TokenTypes.Up' null);  		DebugLocation (65' 4);  		Comparator newComparator;  		switch (comparator6) {  		case "=":  			newComparator = Comparator.Equals;  			break;  		case "!=":  			newComparator = Comparator.NotEquals;  			break;  		case ">":  			newComparator = Comparator.Greater;  			break;  		case "<":  			newComparator = Comparator.Less;  			break;  		case ">=":  			newComparator = Comparator.GreaterOrEqual;  			break;  		case "<=":  			newComparator = Comparator.LessOrEqual;  			break;  		case "&":  			newComparator = Comparator.And;  			break;  		case "|":  			newComparator = Comparator.Or;  			break;  		default:  			newComparator = Comparator.Equals;  			break;  		}  		filterNode = new BoolExpression (a' newComparator' b);  	}  	break;  case 2:  	DebugEnterAlt (2);  	// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  	{  		DebugLocation (98' 4);  		DebugLocation (98' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr195);  		Match (input' TokenTypes.Down' null);  		DebugLocation (98' 12);  		PushFollow (Follow._filterExpr_in_filterExpr199);  		f = filterExpr ();  		PopFollow ();  		DebugLocation (98' 31);  		// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  		int alt6 = 2;  		try {  			DebugEnterSubRule (6);  			try {  				DebugEnterDecision (6' false);  				int LA6_1 = input.LA (1);  				if ((LA6_1 == 24)) {  					alt6 = 1;  				}  			}  			finally {  				DebugExitDecision (6);  			}  			switch (alt6) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  				{  					DebugLocation (98' 31);  					inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (6);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (99' 4);  		FilterTreeNode newNode = f;  		if ((inverse != null ? inverse.Text : default(string)) == "!")  			newNode.ToggleInversed ();  		filterNode = newNode;  	}  	break;  case 3:  	DebugEnterAlt (3);  	// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  	{  		DebugLocation (105' 4);  		DebugLocation (105' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr216);  		Match (input' TokenTypes.Down' null);  		DebugLocation (105' 12);  		PushFollow (Follow._propertyChain_in_filterExpr219);  		propertyChain (propertySegments);  		PopFollow ();  		DebugLocation (105' 51);  		// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  		int alt7 = 2;  		try {  			DebugEnterSubRule (7);  			try {  				DebugEnterDecision (7' false);  				int LA7_1 = input.LA (1);  				if ((LA7_1 == 31)) {  					alt7 = 1;  				}  			}  			finally {  				DebugExitDecision (7);  			}  			switch (alt7) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  				{  					DebugLocation (105' 51);  					inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (7);  		}  		DebugLocation (105' 60);  		// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  		int alt8 = 2;  		try {  			DebugEnterSubRule (8);  			try {  				DebugEnterDecision (8' false);  				int LA8_1 = input.LA (1);  				if ((LA8_1 == 24)) {  					alt8 = 1;  				}  			}  			finally {  				DebugExitDecision (8);  			}  			switch (alt8) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  				{  					DebugLocation (105' 60);  					not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (8);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (106' 4);  		FilterTreeNode newProperty = new Property (propertySegments);  		if ((inverse != null ? inverse.Text : default(string)) == "?")  			filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  		else {  			if ((not != null ? not.Text : default(string)) == "!")  				newProperty.ToggleInversed ();  			filterNode = newProperty;  		}  	}  	break;  case 4:  	DebugEnterAlt (4);  	// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  	{  		DebugLocation (116' 4);  		STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  		DebugLocation (117' 4);  		string stringText = (STRING7 != null ? STRING7.Text : default(string));  		stringText = stringText.Substring (1' stringText.Length - 2);  		filterNode = new Value (stringText);  	}  	break;  case 5:  	DebugEnterAlt (5);  	// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  	{  		DebugLocation (122' 4);  		REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  		DebugLocation (123' 4);  		string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  		regexText = regexText.Substring (1' regexText.Length - 2);  		filterNode = new RegExp (regexText);  	}  	break;  case 6:  	DebugEnterAlt (6);  	// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  	{  		DebugLocation (128' 4);  		NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  		DebugLocation (129' 4);  		filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  	}  	break;  case 7:  	DebugEnterAlt (7);  	// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  	{  		DebugLocation (132' 4);  		Match (input' TRUE' Follow._TRUE_in_filterExpr271);  		DebugLocation (133' 4);  		filterNode = new Value (true);  	}  	break;  case 8:  	DebugEnterAlt (8);  	// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  	{  		DebugLocation (136' 4);  		Match (input' FALSE' Follow._FALSE_in_filterExpr281);  		DebugLocation (137' 4);  		filterNode = new Value (false);  	}  	break;  case 9:  	DebugEnterAlt (9);  	// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  	{  		DebugLocation (140' 4);  		Match (input' NULL' Follow._NULL_in_filterExpr291);  		DebugLocation (141' 4);  		filterNode = new Value (null);  	}  	break;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: switch (alt9) {  case 1:  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  	{  		DebugLocation (64' 4);  		DebugLocation (64' 6);  		PushFollow (Follow._comparator_in_filterExpr175);  		comparator6 = comparator ();  		PopFollow ();  		Match (input' TokenTypes.Down' null);  		DebugLocation (64' 18);  		PushFollow (Follow._filterExpr_in_filterExpr179);  		a = filterExpr ();  		PopFollow ();  		DebugLocation (64' 31);  		PushFollow (Follow._filterExpr_in_filterExpr183);  		b = filterExpr ();  		PopFollow ();  		Match (input' TokenTypes.Up' null);  		DebugLocation (65' 4);  		Comparator newComparator;  		switch (comparator6) {  		case "=":  			newComparator = Comparator.Equals;  			break;  		case "!=":  			newComparator = Comparator.NotEquals;  			break;  		case ">":  			newComparator = Comparator.Greater;  			break;  		case "<":  			newComparator = Comparator.Less;  			break;  		case ">=":  			newComparator = Comparator.GreaterOrEqual;  			break;  		case "<=":  			newComparator = Comparator.LessOrEqual;  			break;  		case "&":  			newComparator = Comparator.And;  			break;  		case "|":  			newComparator = Comparator.Or;  			break;  		default:  			newComparator = Comparator.Equals;  			break;  		}  		filterNode = new BoolExpression (a' newComparator' b);  	}  	break;  case 2:  	DebugEnterAlt (2);  	// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  	{  		DebugLocation (98' 4);  		DebugLocation (98' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr195);  		Match (input' TokenTypes.Down' null);  		DebugLocation (98' 12);  		PushFollow (Follow._filterExpr_in_filterExpr199);  		f = filterExpr ();  		PopFollow ();  		DebugLocation (98' 31);  		// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  		int alt6 = 2;  		try {  			DebugEnterSubRule (6);  			try {  				DebugEnterDecision (6' false);  				int LA6_1 = input.LA (1);  				if ((LA6_1 == 24)) {  					alt6 = 1;  				}  			}  			finally {  				DebugExitDecision (6);  			}  			switch (alt6) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  				{  					DebugLocation (98' 31);  					inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (6);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (99' 4);  		FilterTreeNode newNode = f;  		if ((inverse != null ? inverse.Text : default(string)) == "!")  			newNode.ToggleInversed ();  		filterNode = newNode;  	}  	break;  case 3:  	DebugEnterAlt (3);  	// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  	{  		DebugLocation (105' 4);  		DebugLocation (105' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr216);  		Match (input' TokenTypes.Down' null);  		DebugLocation (105' 12);  		PushFollow (Follow._propertyChain_in_filterExpr219);  		propertyChain (propertySegments);  		PopFollow ();  		DebugLocation (105' 51);  		// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  		int alt7 = 2;  		try {  			DebugEnterSubRule (7);  			try {  				DebugEnterDecision (7' false);  				int LA7_1 = input.LA (1);  				if ((LA7_1 == 31)) {  					alt7 = 1;  				}  			}  			finally {  				DebugExitDecision (7);  			}  			switch (alt7) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  				{  					DebugLocation (105' 51);  					inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (7);  		}  		DebugLocation (105' 60);  		// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  		int alt8 = 2;  		try {  			DebugEnterSubRule (8);  			try {  				DebugEnterDecision (8' false);  				int LA8_1 = input.LA (1);  				if ((LA8_1 == 24)) {  					alt8 = 1;  				}  			}  			finally {  				DebugExitDecision (8);  			}  			switch (alt8) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  				{  					DebugLocation (105' 60);  					not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (8);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (106' 4);  		FilterTreeNode newProperty = new Property (propertySegments);  		if ((inverse != null ? inverse.Text : default(string)) == "?")  			filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  		else {  			if ((not != null ? not.Text : default(string)) == "!")  				newProperty.ToggleInversed ();  			filterNode = newProperty;  		}  	}  	break;  case 4:  	DebugEnterAlt (4);  	// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  	{  		DebugLocation (116' 4);  		STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  		DebugLocation (117' 4);  		string stringText = (STRING7 != null ? STRING7.Text : default(string));  		stringText = stringText.Substring (1' stringText.Length - 2);  		filterNode = new Value (stringText);  	}  	break;  case 5:  	DebugEnterAlt (5);  	// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  	{  		DebugLocation (122' 4);  		REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  		DebugLocation (123' 4);  		string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  		regexText = regexText.Substring (1' regexText.Length - 2);  		filterNode = new RegExp (regexText);  	}  	break;  case 6:  	DebugEnterAlt (6);  	// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  	{  		DebugLocation (128' 4);  		NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  		DebugLocation (129' 4);  		filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  	}  	break;  case 7:  	DebugEnterAlt (7);  	// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  	{  		DebugLocation (132' 4);  		Match (input' TRUE' Follow._TRUE_in_filterExpr271);  		DebugLocation (133' 4);  		filterNode = new Value (true);  	}  	break;  case 8:  	DebugEnterAlt (8);  	// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  	{  		DebugLocation (136' 4);  		Match (input' FALSE' Follow._FALSE_in_filterExpr281);  		DebugLocation (137' 4);  		filterNode = new Value (false);  	}  	break;  case 9:  	DebugEnterAlt (9);  	// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  	{  		DebugLocation (140' 4);  		Match (input' NULL' Follow._NULL_in_filterExpr291);  		DebugLocation (141' 4);  		filterNode = new Value (null);  	}  	break;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: switch (alt9) {  case 1:  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  	{  		DebugLocation (64' 4);  		DebugLocation (64' 6);  		PushFollow (Follow._comparator_in_filterExpr175);  		comparator6 = comparator ();  		PopFollow ();  		Match (input' TokenTypes.Down' null);  		DebugLocation (64' 18);  		PushFollow (Follow._filterExpr_in_filterExpr179);  		a = filterExpr ();  		PopFollow ();  		DebugLocation (64' 31);  		PushFollow (Follow._filterExpr_in_filterExpr183);  		b = filterExpr ();  		PopFollow ();  		Match (input' TokenTypes.Up' null);  		DebugLocation (65' 4);  		Comparator newComparator;  		switch (comparator6) {  		case "=":  			newComparator = Comparator.Equals;  			break;  		case "!=":  			newComparator = Comparator.NotEquals;  			break;  		case ">":  			newComparator = Comparator.Greater;  			break;  		case "<":  			newComparator = Comparator.Less;  			break;  		case ">=":  			newComparator = Comparator.GreaterOrEqual;  			break;  		case "<=":  			newComparator = Comparator.LessOrEqual;  			break;  		case "&":  			newComparator = Comparator.And;  			break;  		case "|":  			newComparator = Comparator.Or;  			break;  		default:  			newComparator = Comparator.Equals;  			break;  		}  		filterNode = new BoolExpression (a' newComparator' b);  	}  	break;  case 2:  	DebugEnterAlt (2);  	// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  	{  		DebugLocation (98' 4);  		DebugLocation (98' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr195);  		Match (input' TokenTypes.Down' null);  		DebugLocation (98' 12);  		PushFollow (Follow._filterExpr_in_filterExpr199);  		f = filterExpr ();  		PopFollow ();  		DebugLocation (98' 31);  		// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  		int alt6 = 2;  		try {  			DebugEnterSubRule (6);  			try {  				DebugEnterDecision (6' false);  				int LA6_1 = input.LA (1);  				if ((LA6_1 == 24)) {  					alt6 = 1;  				}  			}  			finally {  				DebugExitDecision (6);  			}  			switch (alt6) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  				{  					DebugLocation (98' 31);  					inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (6);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (99' 4);  		FilterTreeNode newNode = f;  		if ((inverse != null ? inverse.Text : default(string)) == "!")  			newNode.ToggleInversed ();  		filterNode = newNode;  	}  	break;  case 3:  	DebugEnterAlt (3);  	// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  	{  		DebugLocation (105' 4);  		DebugLocation (105' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr216);  		Match (input' TokenTypes.Down' null);  		DebugLocation (105' 12);  		PushFollow (Follow._propertyChain_in_filterExpr219);  		propertyChain (propertySegments);  		PopFollow ();  		DebugLocation (105' 51);  		// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  		int alt7 = 2;  		try {  			DebugEnterSubRule (7);  			try {  				DebugEnterDecision (7' false);  				int LA7_1 = input.LA (1);  				if ((LA7_1 == 31)) {  					alt7 = 1;  				}  			}  			finally {  				DebugExitDecision (7);  			}  			switch (alt7) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  				{  					DebugLocation (105' 51);  					inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (7);  		}  		DebugLocation (105' 60);  		// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  		int alt8 = 2;  		try {  			DebugEnterSubRule (8);  			try {  				DebugEnterDecision (8' false);  				int LA8_1 = input.LA (1);  				if ((LA8_1 == 24)) {  					alt8 = 1;  				}  			}  			finally {  				DebugExitDecision (8);  			}  			switch (alt8) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  				{  					DebugLocation (105' 60);  					not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (8);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (106' 4);  		FilterTreeNode newProperty = new Property (propertySegments);  		if ((inverse != null ? inverse.Text : default(string)) == "?")  			filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  		else {  			if ((not != null ? not.Text : default(string)) == "!")  				newProperty.ToggleInversed ();  			filterNode = newProperty;  		}  	}  	break;  case 4:  	DebugEnterAlt (4);  	// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  	{  		DebugLocation (116' 4);  		STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  		DebugLocation (117' 4);  		string stringText = (STRING7 != null ? STRING7.Text : default(string));  		stringText = stringText.Substring (1' stringText.Length - 2);  		filterNode = new Value (stringText);  	}  	break;  case 5:  	DebugEnterAlt (5);  	// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  	{  		DebugLocation (122' 4);  		REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  		DebugLocation (123' 4);  		string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  		regexText = regexText.Substring (1' regexText.Length - 2);  		filterNode = new RegExp (regexText);  	}  	break;  case 6:  	DebugEnterAlt (6);  	// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  	{  		DebugLocation (128' 4);  		NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  		DebugLocation (129' 4);  		filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  	}  	break;  case 7:  	DebugEnterAlt (7);  	// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  	{  		DebugLocation (132' 4);  		Match (input' TRUE' Follow._TRUE_in_filterExpr271);  		DebugLocation (133' 4);  		filterNode = new Value (true);  	}  	break;  case 8:  	DebugEnterAlt (8);  	// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  	{  		DebugLocation (136' 4);  		Match (input' FALSE' Follow._FALSE_in_filterExpr281);  		DebugLocation (137' 4);  		filterNode = new Value (false);  	}  	break;  case 9:  	DebugEnterAlt (9);  	// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  	{  		DebugLocation (140' 4);  		Match (input' NULL' Follow._NULL_in_filterExpr291);  		DebugLocation (141' 4);  		filterNode = new Value (null);  	}  	break;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: switch (alt9) {  case 1:  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  	{  		DebugLocation (64' 4);  		DebugLocation (64' 6);  		PushFollow (Follow._comparator_in_filterExpr175);  		comparator6 = comparator ();  		PopFollow ();  		Match (input' TokenTypes.Down' null);  		DebugLocation (64' 18);  		PushFollow (Follow._filterExpr_in_filterExpr179);  		a = filterExpr ();  		PopFollow ();  		DebugLocation (64' 31);  		PushFollow (Follow._filterExpr_in_filterExpr183);  		b = filterExpr ();  		PopFollow ();  		Match (input' TokenTypes.Up' null);  		DebugLocation (65' 4);  		Comparator newComparator;  		switch (comparator6) {  		case "=":  			newComparator = Comparator.Equals;  			break;  		case "!=":  			newComparator = Comparator.NotEquals;  			break;  		case ">":  			newComparator = Comparator.Greater;  			break;  		case "<":  			newComparator = Comparator.Less;  			break;  		case ">=":  			newComparator = Comparator.GreaterOrEqual;  			break;  		case "<=":  			newComparator = Comparator.LessOrEqual;  			break;  		case "&":  			newComparator = Comparator.And;  			break;  		case "|":  			newComparator = Comparator.Or;  			break;  		default:  			newComparator = Comparator.Equals;  			break;  		}  		filterNode = new BoolExpression (a' newComparator' b);  	}  	break;  case 2:  	DebugEnterAlt (2);  	// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  	{  		DebugLocation (98' 4);  		DebugLocation (98' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr195);  		Match (input' TokenTypes.Down' null);  		DebugLocation (98' 12);  		PushFollow (Follow._filterExpr_in_filterExpr199);  		f = filterExpr ();  		PopFollow ();  		DebugLocation (98' 31);  		// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  		int alt6 = 2;  		try {  			DebugEnterSubRule (6);  			try {  				DebugEnterDecision (6' false);  				int LA6_1 = input.LA (1);  				if ((LA6_1 == 24)) {  					alt6 = 1;  				}  			}  			finally {  				DebugExitDecision (6);  			}  			switch (alt6) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  				{  					DebugLocation (98' 31);  					inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (6);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (99' 4);  		FilterTreeNode newNode = f;  		if ((inverse != null ? inverse.Text : default(string)) == "!")  			newNode.ToggleInversed ();  		filterNode = newNode;  	}  	break;  case 3:  	DebugEnterAlt (3);  	// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  	{  		DebugLocation (105' 4);  		DebugLocation (105' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr216);  		Match (input' TokenTypes.Down' null);  		DebugLocation (105' 12);  		PushFollow (Follow._propertyChain_in_filterExpr219);  		propertyChain (propertySegments);  		PopFollow ();  		DebugLocation (105' 51);  		// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  		int alt7 = 2;  		try {  			DebugEnterSubRule (7);  			try {  				DebugEnterDecision (7' false);  				int LA7_1 = input.LA (1);  				if ((LA7_1 == 31)) {  					alt7 = 1;  				}  			}  			finally {  				DebugExitDecision (7);  			}  			switch (alt7) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  				{  					DebugLocation (105' 51);  					inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (7);  		}  		DebugLocation (105' 60);  		// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  		int alt8 = 2;  		try {  			DebugEnterSubRule (8);  			try {  				DebugEnterDecision (8' false);  				int LA8_1 = input.LA (1);  				if ((LA8_1 == 24)) {  					alt8 = 1;  				}  			}  			finally {  				DebugExitDecision (8);  			}  			switch (alt8) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  				{  					DebugLocation (105' 60);  					not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (8);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (106' 4);  		FilterTreeNode newProperty = new Property (propertySegments);  		if ((inverse != null ? inverse.Text : default(string)) == "?")  			filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  		else {  			if ((not != null ? not.Text : default(string)) == "!")  				newProperty.ToggleInversed ();  			filterNode = newProperty;  		}  	}  	break;  case 4:  	DebugEnterAlt (4);  	// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  	{  		DebugLocation (116' 4);  		STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  		DebugLocation (117' 4);  		string stringText = (STRING7 != null ? STRING7.Text : default(string));  		stringText = stringText.Substring (1' stringText.Length - 2);  		filterNode = new Value (stringText);  	}  	break;  case 5:  	DebugEnterAlt (5);  	// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  	{  		DebugLocation (122' 4);  		REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  		DebugLocation (123' 4);  		string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  		regexText = regexText.Substring (1' regexText.Length - 2);  		filterNode = new RegExp (regexText);  	}  	break;  case 6:  	DebugEnterAlt (6);  	// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  	{  		DebugLocation (128' 4);  		NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  		DebugLocation (129' 4);  		filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  	}  	break;  case 7:  	DebugEnterAlt (7);  	// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  	{  		DebugLocation (132' 4);  		Match (input' TRUE' Follow._TRUE_in_filterExpr271);  		DebugLocation (133' 4);  		filterNode = new Value (true);  	}  	break;  case 8:  	DebugEnterAlt (8);  	// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  	{  		DebugLocation (136' 4);  		Match (input' FALSE' Follow._FALSE_in_filterExpr281);  		DebugLocation (137' 4);  		filterNode = new Value (false);  	}  	break;  case 9:  	DebugEnterAlt (9);  	// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  	{  		DebugLocation (140' 4);  		Match (input' NULL' Follow._NULL_in_filterExpr291);  		DebugLocation (141' 4);  		filterNode = new Value (null);  	}  	break;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: switch (alt9) {  case 1:  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  	{  		DebugLocation (64' 4);  		DebugLocation (64' 6);  		PushFollow (Follow._comparator_in_filterExpr175);  		comparator6 = comparator ();  		PopFollow ();  		Match (input' TokenTypes.Down' null);  		DebugLocation (64' 18);  		PushFollow (Follow._filterExpr_in_filterExpr179);  		a = filterExpr ();  		PopFollow ();  		DebugLocation (64' 31);  		PushFollow (Follow._filterExpr_in_filterExpr183);  		b = filterExpr ();  		PopFollow ();  		Match (input' TokenTypes.Up' null);  		DebugLocation (65' 4);  		Comparator newComparator;  		switch (comparator6) {  		case "=":  			newComparator = Comparator.Equals;  			break;  		case "!=":  			newComparator = Comparator.NotEquals;  			break;  		case ">":  			newComparator = Comparator.Greater;  			break;  		case "<":  			newComparator = Comparator.Less;  			break;  		case ">=":  			newComparator = Comparator.GreaterOrEqual;  			break;  		case "<=":  			newComparator = Comparator.LessOrEqual;  			break;  		case "&":  			newComparator = Comparator.And;  			break;  		case "|":  			newComparator = Comparator.Or;  			break;  		default:  			newComparator = Comparator.Equals;  			break;  		}  		filterNode = new BoolExpression (a' newComparator' b);  	}  	break;  case 2:  	DebugEnterAlt (2);  	// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  	{  		DebugLocation (98' 4);  		DebugLocation (98' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr195);  		Match (input' TokenTypes.Down' null);  		DebugLocation (98' 12);  		PushFollow (Follow._filterExpr_in_filterExpr199);  		f = filterExpr ();  		PopFollow ();  		DebugLocation (98' 31);  		// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  		int alt6 = 2;  		try {  			DebugEnterSubRule (6);  			try {  				DebugEnterDecision (6' false);  				int LA6_1 = input.LA (1);  				if ((LA6_1 == 24)) {  					alt6 = 1;  				}  			}  			finally {  				DebugExitDecision (6);  			}  			switch (alt6) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  				{  					DebugLocation (98' 31);  					inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (6);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (99' 4);  		FilterTreeNode newNode = f;  		if ((inverse != null ? inverse.Text : default(string)) == "!")  			newNode.ToggleInversed ();  		filterNode = newNode;  	}  	break;  case 3:  	DebugEnterAlt (3);  	// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  	{  		DebugLocation (105' 4);  		DebugLocation (105' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr216);  		Match (input' TokenTypes.Down' null);  		DebugLocation (105' 12);  		PushFollow (Follow._propertyChain_in_filterExpr219);  		propertyChain (propertySegments);  		PopFollow ();  		DebugLocation (105' 51);  		// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  		int alt7 = 2;  		try {  			DebugEnterSubRule (7);  			try {  				DebugEnterDecision (7' false);  				int LA7_1 = input.LA (1);  				if ((LA7_1 == 31)) {  					alt7 = 1;  				}  			}  			finally {  				DebugExitDecision (7);  			}  			switch (alt7) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  				{  					DebugLocation (105' 51);  					inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (7);  		}  		DebugLocation (105' 60);  		// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  		int alt8 = 2;  		try {  			DebugEnterSubRule (8);  			try {  				DebugEnterDecision (8' false);  				int LA8_1 = input.LA (1);  				if ((LA8_1 == 24)) {  					alt8 = 1;  				}  			}  			finally {  				DebugExitDecision (8);  			}  			switch (alt8) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  				{  					DebugLocation (105' 60);  					not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (8);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (106' 4);  		FilterTreeNode newProperty = new Property (propertySegments);  		if ((inverse != null ? inverse.Text : default(string)) == "?")  			filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  		else {  			if ((not != null ? not.Text : default(string)) == "!")  				newProperty.ToggleInversed ();  			filterNode = newProperty;  		}  	}  	break;  case 4:  	DebugEnterAlt (4);  	// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  	{  		DebugLocation (116' 4);  		STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  		DebugLocation (117' 4);  		string stringText = (STRING7 != null ? STRING7.Text : default(string));  		stringText = stringText.Substring (1' stringText.Length - 2);  		filterNode = new Value (stringText);  	}  	break;  case 5:  	DebugEnterAlt (5);  	// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  	{  		DebugLocation (122' 4);  		REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  		DebugLocation (123' 4);  		string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  		regexText = regexText.Substring (1' regexText.Length - 2);  		filterNode = new RegExp (regexText);  	}  	break;  case 6:  	DebugEnterAlt (6);  	// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  	{  		DebugLocation (128' 4);  		NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  		DebugLocation (129' 4);  		filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  	}  	break;  case 7:  	DebugEnterAlt (7);  	// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  	{  		DebugLocation (132' 4);  		Match (input' TRUE' Follow._TRUE_in_filterExpr271);  		DebugLocation (133' 4);  		filterNode = new Value (true);  	}  	break;  case 8:  	DebugEnterAlt (8);  	// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  	{  		DebugLocation (136' 4);  		Match (input' FALSE' Follow._FALSE_in_filterExpr281);  		DebugLocation (137' 4);  		filterNode = new Value (false);  	}  	break;  case 9:  	DebugEnterAlt (9);  	// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  	{  		DebugLocation (140' 4);  		Match (input' NULL' Follow._NULL_in_filterExpr291);  		DebugLocation (141' 4);  		filterNode = new Value (null);  	}  	break;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: switch (alt9) {  case 1:  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  	{  		DebugLocation (64' 4);  		DebugLocation (64' 6);  		PushFollow (Follow._comparator_in_filterExpr175);  		comparator6 = comparator ();  		PopFollow ();  		Match (input' TokenTypes.Down' null);  		DebugLocation (64' 18);  		PushFollow (Follow._filterExpr_in_filterExpr179);  		a = filterExpr ();  		PopFollow ();  		DebugLocation (64' 31);  		PushFollow (Follow._filterExpr_in_filterExpr183);  		b = filterExpr ();  		PopFollow ();  		Match (input' TokenTypes.Up' null);  		DebugLocation (65' 4);  		Comparator newComparator;  		switch (comparator6) {  		case "=":  			newComparator = Comparator.Equals;  			break;  		case "!=":  			newComparator = Comparator.NotEquals;  			break;  		case ">":  			newComparator = Comparator.Greater;  			break;  		case "<":  			newComparator = Comparator.Less;  			break;  		case ">=":  			newComparator = Comparator.GreaterOrEqual;  			break;  		case "<=":  			newComparator = Comparator.LessOrEqual;  			break;  		case "&":  			newComparator = Comparator.And;  			break;  		case "|":  			newComparator = Comparator.Or;  			break;  		default:  			newComparator = Comparator.Equals;  			break;  		}  		filterNode = new BoolExpression (a' newComparator' b);  	}  	break;  case 2:  	DebugEnterAlt (2);  	// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  	{  		DebugLocation (98' 4);  		DebugLocation (98' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr195);  		Match (input' TokenTypes.Down' null);  		DebugLocation (98' 12);  		PushFollow (Follow._filterExpr_in_filterExpr199);  		f = filterExpr ();  		PopFollow ();  		DebugLocation (98' 31);  		// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  		int alt6 = 2;  		try {  			DebugEnterSubRule (6);  			try {  				DebugEnterDecision (6' false);  				int LA6_1 = input.LA (1);  				if ((LA6_1 == 24)) {  					alt6 = 1;  				}  			}  			finally {  				DebugExitDecision (6);  			}  			switch (alt6) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  				{  					DebugLocation (98' 31);  					inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (6);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (99' 4);  		FilterTreeNode newNode = f;  		if ((inverse != null ? inverse.Text : default(string)) == "!")  			newNode.ToggleInversed ();  		filterNode = newNode;  	}  	break;  case 3:  	DebugEnterAlt (3);  	// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  	{  		DebugLocation (105' 4);  		DebugLocation (105' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr216);  		Match (input' TokenTypes.Down' null);  		DebugLocation (105' 12);  		PushFollow (Follow._propertyChain_in_filterExpr219);  		propertyChain (propertySegments);  		PopFollow ();  		DebugLocation (105' 51);  		// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  		int alt7 = 2;  		try {  			DebugEnterSubRule (7);  			try {  				DebugEnterDecision (7' false);  				int LA7_1 = input.LA (1);  				if ((LA7_1 == 31)) {  					alt7 = 1;  				}  			}  			finally {  				DebugExitDecision (7);  			}  			switch (alt7) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  				{  					DebugLocation (105' 51);  					inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (7);  		}  		DebugLocation (105' 60);  		// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  		int alt8 = 2;  		try {  			DebugEnterSubRule (8);  			try {  				DebugEnterDecision (8' false);  				int LA8_1 = input.LA (1);  				if ((LA8_1 == 24)) {  					alt8 = 1;  				}  			}  			finally {  				DebugExitDecision (8);  			}  			switch (alt8) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  				{  					DebugLocation (105' 60);  					not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (8);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (106' 4);  		FilterTreeNode newProperty = new Property (propertySegments);  		if ((inverse != null ? inverse.Text : default(string)) == "?")  			filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  		else {  			if ((not != null ? not.Text : default(string)) == "!")  				newProperty.ToggleInversed ();  			filterNode = newProperty;  		}  	}  	break;  case 4:  	DebugEnterAlt (4);  	// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  	{  		DebugLocation (116' 4);  		STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  		DebugLocation (117' 4);  		string stringText = (STRING7 != null ? STRING7.Text : default(string));  		stringText = stringText.Substring (1' stringText.Length - 2);  		filterNode = new Value (stringText);  	}  	break;  case 5:  	DebugEnterAlt (5);  	// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  	{  		DebugLocation (122' 4);  		REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  		DebugLocation (123' 4);  		string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  		regexText = regexText.Substring (1' regexText.Length - 2);  		filterNode = new RegExp (regexText);  	}  	break;  case 6:  	DebugEnterAlt (6);  	// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  	{  		DebugLocation (128' 4);  		NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  		DebugLocation (129' 4);  		filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  	}  	break;  case 7:  	DebugEnterAlt (7);  	// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  	{  		DebugLocation (132' 4);  		Match (input' TRUE' Follow._TRUE_in_filterExpr271);  		DebugLocation (133' 4);  		filterNode = new Value (true);  	}  	break;  case 8:  	DebugEnterAlt (8);  	// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  	{  		DebugLocation (136' 4);  		Match (input' FALSE' Follow._FALSE_in_filterExpr281);  		DebugLocation (137' 4);  		filterNode = new Value (false);  	}  	break;  case 9:  	DebugEnterAlt (9);  	// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  	{  		DebugLocation (140' 4);  		Match (input' NULL' Follow._NULL_in_filterExpr291);  		DebugLocation (141' 4);  		filterNode = new Value (null);  	}  	break;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: switch (alt9) {  case 1:  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  	{  		DebugLocation (64' 4);  		DebugLocation (64' 6);  		PushFollow (Follow._comparator_in_filterExpr175);  		comparator6 = comparator ();  		PopFollow ();  		Match (input' TokenTypes.Down' null);  		DebugLocation (64' 18);  		PushFollow (Follow._filterExpr_in_filterExpr179);  		a = filterExpr ();  		PopFollow ();  		DebugLocation (64' 31);  		PushFollow (Follow._filterExpr_in_filterExpr183);  		b = filterExpr ();  		PopFollow ();  		Match (input' TokenTypes.Up' null);  		DebugLocation (65' 4);  		Comparator newComparator;  		switch (comparator6) {  		case "=":  			newComparator = Comparator.Equals;  			break;  		case "!=":  			newComparator = Comparator.NotEquals;  			break;  		case ">":  			newComparator = Comparator.Greater;  			break;  		case "<":  			newComparator = Comparator.Less;  			break;  		case ">=":  			newComparator = Comparator.GreaterOrEqual;  			break;  		case "<=":  			newComparator = Comparator.LessOrEqual;  			break;  		case "&":  			newComparator = Comparator.And;  			break;  		case "|":  			newComparator = Comparator.Or;  			break;  		default:  			newComparator = Comparator.Equals;  			break;  		}  		filterNode = new BoolExpression (a' newComparator' b);  	}  	break;  case 2:  	DebugEnterAlt (2);  	// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  	{  		DebugLocation (98' 4);  		DebugLocation (98' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr195);  		Match (input' TokenTypes.Down' null);  		DebugLocation (98' 12);  		PushFollow (Follow._filterExpr_in_filterExpr199);  		f = filterExpr ();  		PopFollow ();  		DebugLocation (98' 31);  		// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  		int alt6 = 2;  		try {  			DebugEnterSubRule (6);  			try {  				DebugEnterDecision (6' false);  				int LA6_1 = input.LA (1);  				if ((LA6_1 == 24)) {  					alt6 = 1;  				}  			}  			finally {  				DebugExitDecision (6);  			}  			switch (alt6) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  				{  					DebugLocation (98' 31);  					inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (6);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (99' 4);  		FilterTreeNode newNode = f;  		if ((inverse != null ? inverse.Text : default(string)) == "!")  			newNode.ToggleInversed ();  		filterNode = newNode;  	}  	break;  case 3:  	DebugEnterAlt (3);  	// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  	{  		DebugLocation (105' 4);  		DebugLocation (105' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr216);  		Match (input' TokenTypes.Down' null);  		DebugLocation (105' 12);  		PushFollow (Follow._propertyChain_in_filterExpr219);  		propertyChain (propertySegments);  		PopFollow ();  		DebugLocation (105' 51);  		// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  		int alt7 = 2;  		try {  			DebugEnterSubRule (7);  			try {  				DebugEnterDecision (7' false);  				int LA7_1 = input.LA (1);  				if ((LA7_1 == 31)) {  					alt7 = 1;  				}  			}  			finally {  				DebugExitDecision (7);  			}  			switch (alt7) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  				{  					DebugLocation (105' 51);  					inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (7);  		}  		DebugLocation (105' 60);  		// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  		int alt8 = 2;  		try {  			DebugEnterSubRule (8);  			try {  				DebugEnterDecision (8' false);  				int LA8_1 = input.LA (1);  				if ((LA8_1 == 24)) {  					alt8 = 1;  				}  			}  			finally {  				DebugExitDecision (8);  			}  			switch (alt8) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  				{  					DebugLocation (105' 60);  					not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (8);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (106' 4);  		FilterTreeNode newProperty = new Property (propertySegments);  		if ((inverse != null ? inverse.Text : default(string)) == "?")  			filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  		else {  			if ((not != null ? not.Text : default(string)) == "!")  				newProperty.ToggleInversed ();  			filterNode = newProperty;  		}  	}  	break;  case 4:  	DebugEnterAlt (4);  	// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  	{  		DebugLocation (116' 4);  		STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  		DebugLocation (117' 4);  		string stringText = (STRING7 != null ? STRING7.Text : default(string));  		stringText = stringText.Substring (1' stringText.Length - 2);  		filterNode = new Value (stringText);  	}  	break;  case 5:  	DebugEnterAlt (5);  	// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  	{  		DebugLocation (122' 4);  		REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  		DebugLocation (123' 4);  		string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  		regexText = regexText.Substring (1' regexText.Length - 2);  		filterNode = new RegExp (regexText);  	}  	break;  case 6:  	DebugEnterAlt (6);  	// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  	{  		DebugLocation (128' 4);  		NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  		DebugLocation (129' 4);  		filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  	}  	break;  case 7:  	DebugEnterAlt (7);  	// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  	{  		DebugLocation (132' 4);  		Match (input' TRUE' Follow._TRUE_in_filterExpr271);  		DebugLocation (133' 4);  		filterNode = new Value (true);  	}  	break;  case 8:  	DebugEnterAlt (8);  	// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  	{  		DebugLocation (136' 4);  		Match (input' FALSE' Follow._FALSE_in_filterExpr281);  		DebugLocation (137' 4);  		filterNode = new Value (false);  	}  	break;  case 9:  	DebugEnterAlt (9);  	// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  	{  		DebugLocation (140' 4);  		Match (input' NULL' Follow._NULL_in_filterExpr291);  		DebugLocation (141' 4);  		filterNode = new Value (null);  	}  	break;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: switch (alt9) {  case 1:  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  	{  		DebugLocation (64' 4);  		DebugLocation (64' 6);  		PushFollow (Follow._comparator_in_filterExpr175);  		comparator6 = comparator ();  		PopFollow ();  		Match (input' TokenTypes.Down' null);  		DebugLocation (64' 18);  		PushFollow (Follow._filterExpr_in_filterExpr179);  		a = filterExpr ();  		PopFollow ();  		DebugLocation (64' 31);  		PushFollow (Follow._filterExpr_in_filterExpr183);  		b = filterExpr ();  		PopFollow ();  		Match (input' TokenTypes.Up' null);  		DebugLocation (65' 4);  		Comparator newComparator;  		switch (comparator6) {  		case "=":  			newComparator = Comparator.Equals;  			break;  		case "!=":  			newComparator = Comparator.NotEquals;  			break;  		case ">":  			newComparator = Comparator.Greater;  			break;  		case "<":  			newComparator = Comparator.Less;  			break;  		case ">=":  			newComparator = Comparator.GreaterOrEqual;  			break;  		case "<=":  			newComparator = Comparator.LessOrEqual;  			break;  		case "&":  			newComparator = Comparator.And;  			break;  		case "|":  			newComparator = Comparator.Or;  			break;  		default:  			newComparator = Comparator.Equals;  			break;  		}  		filterNode = new BoolExpression (a' newComparator' b);  	}  	break;  case 2:  	DebugEnterAlt (2);  	// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  	{  		DebugLocation (98' 4);  		DebugLocation (98' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr195);  		Match (input' TokenTypes.Down' null);  		DebugLocation (98' 12);  		PushFollow (Follow._filterExpr_in_filterExpr199);  		f = filterExpr ();  		PopFollow ();  		DebugLocation (98' 31);  		// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  		int alt6 = 2;  		try {  			DebugEnterSubRule (6);  			try {  				DebugEnterDecision (6' false);  				int LA6_1 = input.LA (1);  				if ((LA6_1 == 24)) {  					alt6 = 1;  				}  			}  			finally {  				DebugExitDecision (6);  			}  			switch (alt6) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  				{  					DebugLocation (98' 31);  					inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (6);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (99' 4);  		FilterTreeNode newNode = f;  		if ((inverse != null ? inverse.Text : default(string)) == "!")  			newNode.ToggleInversed ();  		filterNode = newNode;  	}  	break;  case 3:  	DebugEnterAlt (3);  	// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  	{  		DebugLocation (105' 4);  		DebugLocation (105' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr216);  		Match (input' TokenTypes.Down' null);  		DebugLocation (105' 12);  		PushFollow (Follow._propertyChain_in_filterExpr219);  		propertyChain (propertySegments);  		PopFollow ();  		DebugLocation (105' 51);  		// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  		int alt7 = 2;  		try {  			DebugEnterSubRule (7);  			try {  				DebugEnterDecision (7' false);  				int LA7_1 = input.LA (1);  				if ((LA7_1 == 31)) {  					alt7 = 1;  				}  			}  			finally {  				DebugExitDecision (7);  			}  			switch (alt7) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  				{  					DebugLocation (105' 51);  					inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (7);  		}  		DebugLocation (105' 60);  		// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  		int alt8 = 2;  		try {  			DebugEnterSubRule (8);  			try {  				DebugEnterDecision (8' false);  				int LA8_1 = input.LA (1);  				if ((LA8_1 == 24)) {  					alt8 = 1;  				}  			}  			finally {  				DebugExitDecision (8);  			}  			switch (alt8) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  				{  					DebugLocation (105' 60);  					not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (8);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (106' 4);  		FilterTreeNode newProperty = new Property (propertySegments);  		if ((inverse != null ? inverse.Text : default(string)) == "?")  			filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  		else {  			if ((not != null ? not.Text : default(string)) == "!")  				newProperty.ToggleInversed ();  			filterNode = newProperty;  		}  	}  	break;  case 4:  	DebugEnterAlt (4);  	// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  	{  		DebugLocation (116' 4);  		STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  		DebugLocation (117' 4);  		string stringText = (STRING7 != null ? STRING7.Text : default(string));  		stringText = stringText.Substring (1' stringText.Length - 2);  		filterNode = new Value (stringText);  	}  	break;  case 5:  	DebugEnterAlt (5);  	// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  	{  		DebugLocation (122' 4);  		REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  		DebugLocation (123' 4);  		string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  		regexText = regexText.Substring (1' regexText.Length - 2);  		filterNode = new RegExp (regexText);  	}  	break;  case 6:  	DebugEnterAlt (6);  	// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  	{  		DebugLocation (128' 4);  		NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  		DebugLocation (129' 4);  		filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  	}  	break;  case 7:  	DebugEnterAlt (7);  	// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  	{  		DebugLocation (132' 4);  		Match (input' TRUE' Follow._TRUE_in_filterExpr271);  		DebugLocation (133' 4);  		filterNode = new Value (true);  	}  	break;  case 8:  	DebugEnterAlt (8);  	// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  	{  		DebugLocation (136' 4);  		Match (input' FALSE' Follow._FALSE_in_filterExpr281);  		DebugLocation (137' 4);  		filterNode = new Value (false);  	}  	break;  case 9:  	DebugEnterAlt (9);  	// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  	{  		DebugLocation (140' 4);  		Match (input' NULL' Follow._NULL_in_filterExpr291);  		DebugLocation (141' 4);  		filterNode = new Value (null);  	}  	break;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: switch (alt9) {  case 1:  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  	{  		DebugLocation (64' 4);  		DebugLocation (64' 6);  		PushFollow (Follow._comparator_in_filterExpr175);  		comparator6 = comparator ();  		PopFollow ();  		Match (input' TokenTypes.Down' null);  		DebugLocation (64' 18);  		PushFollow (Follow._filterExpr_in_filterExpr179);  		a = filterExpr ();  		PopFollow ();  		DebugLocation (64' 31);  		PushFollow (Follow._filterExpr_in_filterExpr183);  		b = filterExpr ();  		PopFollow ();  		Match (input' TokenTypes.Up' null);  		DebugLocation (65' 4);  		Comparator newComparator;  		switch (comparator6) {  		case "=":  			newComparator = Comparator.Equals;  			break;  		case "!=":  			newComparator = Comparator.NotEquals;  			break;  		case ">":  			newComparator = Comparator.Greater;  			break;  		case "<":  			newComparator = Comparator.Less;  			break;  		case ">=":  			newComparator = Comparator.GreaterOrEqual;  			break;  		case "<=":  			newComparator = Comparator.LessOrEqual;  			break;  		case "&":  			newComparator = Comparator.And;  			break;  		case "|":  			newComparator = Comparator.Or;  			break;  		default:  			newComparator = Comparator.Equals;  			break;  		}  		filterNode = new BoolExpression (a' newComparator' b);  	}  	break;  case 2:  	DebugEnterAlt (2);  	// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  	{  		DebugLocation (98' 4);  		DebugLocation (98' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr195);  		Match (input' TokenTypes.Down' null);  		DebugLocation (98' 12);  		PushFollow (Follow._filterExpr_in_filterExpr199);  		f = filterExpr ();  		PopFollow ();  		DebugLocation (98' 31);  		// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  		int alt6 = 2;  		try {  			DebugEnterSubRule (6);  			try {  				DebugEnterDecision (6' false);  				int LA6_1 = input.LA (1);  				if ((LA6_1 == 24)) {  					alt6 = 1;  				}  			}  			finally {  				DebugExitDecision (6);  			}  			switch (alt6) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  				{  					DebugLocation (98' 31);  					inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (6);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (99' 4);  		FilterTreeNode newNode = f;  		if ((inverse != null ? inverse.Text : default(string)) == "!")  			newNode.ToggleInversed ();  		filterNode = newNode;  	}  	break;  case 3:  	DebugEnterAlt (3);  	// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  	{  		DebugLocation (105' 4);  		DebugLocation (105' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr216);  		Match (input' TokenTypes.Down' null);  		DebugLocation (105' 12);  		PushFollow (Follow._propertyChain_in_filterExpr219);  		propertyChain (propertySegments);  		PopFollow ();  		DebugLocation (105' 51);  		// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  		int alt7 = 2;  		try {  			DebugEnterSubRule (7);  			try {  				DebugEnterDecision (7' false);  				int LA7_1 = input.LA (1);  				if ((LA7_1 == 31)) {  					alt7 = 1;  				}  			}  			finally {  				DebugExitDecision (7);  			}  			switch (alt7) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  				{  					DebugLocation (105' 51);  					inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (7);  		}  		DebugLocation (105' 60);  		// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  		int alt8 = 2;  		try {  			DebugEnterSubRule (8);  			try {  				DebugEnterDecision (8' false);  				int LA8_1 = input.LA (1);  				if ((LA8_1 == 24)) {  					alt8 = 1;  				}  			}  			finally {  				DebugExitDecision (8);  			}  			switch (alt8) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  				{  					DebugLocation (105' 60);  					not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (8);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (106' 4);  		FilterTreeNode newProperty = new Property (propertySegments);  		if ((inverse != null ? inverse.Text : default(string)) == "?")  			filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  		else {  			if ((not != null ? not.Text : default(string)) == "!")  				newProperty.ToggleInversed ();  			filterNode = newProperty;  		}  	}  	break;  case 4:  	DebugEnterAlt (4);  	// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  	{  		DebugLocation (116' 4);  		STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  		DebugLocation (117' 4);  		string stringText = (STRING7 != null ? STRING7.Text : default(string));  		stringText = stringText.Substring (1' stringText.Length - 2);  		filterNode = new Value (stringText);  	}  	break;  case 5:  	DebugEnterAlt (5);  	// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  	{  		DebugLocation (122' 4);  		REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  		DebugLocation (123' 4);  		string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  		regexText = regexText.Substring (1' regexText.Length - 2);  		filterNode = new RegExp (regexText);  	}  	break;  case 6:  	DebugEnterAlt (6);  	// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  	{  		DebugLocation (128' 4);  		NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  		DebugLocation (129' 4);  		filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  	}  	break;  case 7:  	DebugEnterAlt (7);  	// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  	{  		DebugLocation (132' 4);  		Match (input' TRUE' Follow._TRUE_in_filterExpr271);  		DebugLocation (133' 4);  		filterNode = new Value (true);  	}  	break;  case 8:  	DebugEnterAlt (8);  	// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  	{  		DebugLocation (136' 4);  		Match (input' FALSE' Follow._FALSE_in_filterExpr281);  		DebugLocation (137' 4);  		filterNode = new Value (false);  	}  	break;  case 9:  	DebugEnterAlt (9);  	// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  	{  		DebugLocation (140' 4);  		Match (input' NULL' Follow._NULL_in_filterExpr291);  		DebugLocation (141' 4);  		filterNode = new Value (null);  	}  	break;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: switch (alt9) {  case 1:  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  	{  		DebugLocation (64' 4);  		DebugLocation (64' 6);  		PushFollow (Follow._comparator_in_filterExpr175);  		comparator6 = comparator ();  		PopFollow ();  		Match (input' TokenTypes.Down' null);  		DebugLocation (64' 18);  		PushFollow (Follow._filterExpr_in_filterExpr179);  		a = filterExpr ();  		PopFollow ();  		DebugLocation (64' 31);  		PushFollow (Follow._filterExpr_in_filterExpr183);  		b = filterExpr ();  		PopFollow ();  		Match (input' TokenTypes.Up' null);  		DebugLocation (65' 4);  		Comparator newComparator;  		switch (comparator6) {  		case "=":  			newComparator = Comparator.Equals;  			break;  		case "!=":  			newComparator = Comparator.NotEquals;  			break;  		case ">":  			newComparator = Comparator.Greater;  			break;  		case "<":  			newComparator = Comparator.Less;  			break;  		case ">=":  			newComparator = Comparator.GreaterOrEqual;  			break;  		case "<=":  			newComparator = Comparator.LessOrEqual;  			break;  		case "&":  			newComparator = Comparator.And;  			break;  		case "|":  			newComparator = Comparator.Or;  			break;  		default:  			newComparator = Comparator.Equals;  			break;  		}  		filterNode = new BoolExpression (a' newComparator' b);  	}  	break;  case 2:  	DebugEnterAlt (2);  	// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  	{  		DebugLocation (98' 4);  		DebugLocation (98' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr195);  		Match (input' TokenTypes.Down' null);  		DebugLocation (98' 12);  		PushFollow (Follow._filterExpr_in_filterExpr199);  		f = filterExpr ();  		PopFollow ();  		DebugLocation (98' 31);  		// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  		int alt6 = 2;  		try {  			DebugEnterSubRule (6);  			try {  				DebugEnterDecision (6' false);  				int LA6_1 = input.LA (1);  				if ((LA6_1 == 24)) {  					alt6 = 1;  				}  			}  			finally {  				DebugExitDecision (6);  			}  			switch (alt6) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  				{  					DebugLocation (98' 31);  					inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (6);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (99' 4);  		FilterTreeNode newNode = f;  		if ((inverse != null ? inverse.Text : default(string)) == "!")  			newNode.ToggleInversed ();  		filterNode = newNode;  	}  	break;  case 3:  	DebugEnterAlt (3);  	// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  	{  		DebugLocation (105' 4);  		DebugLocation (105' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr216);  		Match (input' TokenTypes.Down' null);  		DebugLocation (105' 12);  		PushFollow (Follow._propertyChain_in_filterExpr219);  		propertyChain (propertySegments);  		PopFollow ();  		DebugLocation (105' 51);  		// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  		int alt7 = 2;  		try {  			DebugEnterSubRule (7);  			try {  				DebugEnterDecision (7' false);  				int LA7_1 = input.LA (1);  				if ((LA7_1 == 31)) {  					alt7 = 1;  				}  			}  			finally {  				DebugExitDecision (7);  			}  			switch (alt7) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  				{  					DebugLocation (105' 51);  					inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (7);  		}  		DebugLocation (105' 60);  		// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  		int alt8 = 2;  		try {  			DebugEnterSubRule (8);  			try {  				DebugEnterDecision (8' false);  				int LA8_1 = input.LA (1);  				if ((LA8_1 == 24)) {  					alt8 = 1;  				}  			}  			finally {  				DebugExitDecision (8);  			}  			switch (alt8) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  				{  					DebugLocation (105' 60);  					not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (8);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (106' 4);  		FilterTreeNode newProperty = new Property (propertySegments);  		if ((inverse != null ? inverse.Text : default(string)) == "?")  			filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  		else {  			if ((not != null ? not.Text : default(string)) == "!")  				newProperty.ToggleInversed ();  			filterNode = newProperty;  		}  	}  	break;  case 4:  	DebugEnterAlt (4);  	// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  	{  		DebugLocation (116' 4);  		STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  		DebugLocation (117' 4);  		string stringText = (STRING7 != null ? STRING7.Text : default(string));  		stringText = stringText.Substring (1' stringText.Length - 2);  		filterNode = new Value (stringText);  	}  	break;  case 5:  	DebugEnterAlt (5);  	// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  	{  		DebugLocation (122' 4);  		REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  		DebugLocation (123' 4);  		string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  		regexText = regexText.Substring (1' regexText.Length - 2);  		filterNode = new RegExp (regexText);  	}  	break;  case 6:  	DebugEnterAlt (6);  	// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  	{  		DebugLocation (128' 4);  		NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  		DebugLocation (129' 4);  		filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  	}  	break;  case 7:  	DebugEnterAlt (7);  	// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  	{  		DebugLocation (132' 4);  		Match (input' TRUE' Follow._TRUE_in_filterExpr271);  		DebugLocation (133' 4);  		filterNode = new Value (true);  	}  	break;  case 8:  	DebugEnterAlt (8);  	// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  	{  		DebugLocation (136' 4);  		Match (input' FALSE' Follow._FALSE_in_filterExpr281);  		DebugLocation (137' 4);  		filterNode = new Value (false);  	}  	break;  case 9:  	DebugEnterAlt (9);  	// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  	{  		DebugLocation (140' 4);  		Match (input' NULL' Follow._NULL_in_filterExpr291);  		DebugLocation (141' 4);  		filterNode = new Value (null);  	}  	break;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: switch (alt9) {  case 1:  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  	{  		DebugLocation (64' 4);  		DebugLocation (64' 6);  		PushFollow (Follow._comparator_in_filterExpr175);  		comparator6 = comparator ();  		PopFollow ();  		Match (input' TokenTypes.Down' null);  		DebugLocation (64' 18);  		PushFollow (Follow._filterExpr_in_filterExpr179);  		a = filterExpr ();  		PopFollow ();  		DebugLocation (64' 31);  		PushFollow (Follow._filterExpr_in_filterExpr183);  		b = filterExpr ();  		PopFollow ();  		Match (input' TokenTypes.Up' null);  		DebugLocation (65' 4);  		Comparator newComparator;  		switch (comparator6) {  		case "=":  			newComparator = Comparator.Equals;  			break;  		case "!=":  			newComparator = Comparator.NotEquals;  			break;  		case ">":  			newComparator = Comparator.Greater;  			break;  		case "<":  			newComparator = Comparator.Less;  			break;  		case ">=":  			newComparator = Comparator.GreaterOrEqual;  			break;  		case "<=":  			newComparator = Comparator.LessOrEqual;  			break;  		case "&":  			newComparator = Comparator.And;  			break;  		case "|":  			newComparator = Comparator.Or;  			break;  		default:  			newComparator = Comparator.Equals;  			break;  		}  		filterNode = new BoolExpression (a' newComparator' b);  	}  	break;  case 2:  	DebugEnterAlt (2);  	// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  	{  		DebugLocation (98' 4);  		DebugLocation (98' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr195);  		Match (input' TokenTypes.Down' null);  		DebugLocation (98' 12);  		PushFollow (Follow._filterExpr_in_filterExpr199);  		f = filterExpr ();  		PopFollow ();  		DebugLocation (98' 31);  		// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  		int alt6 = 2;  		try {  			DebugEnterSubRule (6);  			try {  				DebugEnterDecision (6' false);  				int LA6_1 = input.LA (1);  				if ((LA6_1 == 24)) {  					alt6 = 1;  				}  			}  			finally {  				DebugExitDecision (6);  			}  			switch (alt6) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  				{  					DebugLocation (98' 31);  					inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (6);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (99' 4);  		FilterTreeNode newNode = f;  		if ((inverse != null ? inverse.Text : default(string)) == "!")  			newNode.ToggleInversed ();  		filterNode = newNode;  	}  	break;  case 3:  	DebugEnterAlt (3);  	// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  	{  		DebugLocation (105' 4);  		DebugLocation (105' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr216);  		Match (input' TokenTypes.Down' null);  		DebugLocation (105' 12);  		PushFollow (Follow._propertyChain_in_filterExpr219);  		propertyChain (propertySegments);  		PopFollow ();  		DebugLocation (105' 51);  		// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  		int alt7 = 2;  		try {  			DebugEnterSubRule (7);  			try {  				DebugEnterDecision (7' false);  				int LA7_1 = input.LA (1);  				if ((LA7_1 == 31)) {  					alt7 = 1;  				}  			}  			finally {  				DebugExitDecision (7);  			}  			switch (alt7) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  				{  					DebugLocation (105' 51);  					inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (7);  		}  		DebugLocation (105' 60);  		// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  		int alt8 = 2;  		try {  			DebugEnterSubRule (8);  			try {  				DebugEnterDecision (8' false);  				int LA8_1 = input.LA (1);  				if ((LA8_1 == 24)) {  					alt8 = 1;  				}  			}  			finally {  				DebugExitDecision (8);  			}  			switch (alt8) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  				{  					DebugLocation (105' 60);  					not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (8);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (106' 4);  		FilterTreeNode newProperty = new Property (propertySegments);  		if ((inverse != null ? inverse.Text : default(string)) == "?")  			filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  		else {  			if ((not != null ? not.Text : default(string)) == "!")  				newProperty.ToggleInversed ();  			filterNode = newProperty;  		}  	}  	break;  case 4:  	DebugEnterAlt (4);  	// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  	{  		DebugLocation (116' 4);  		STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  		DebugLocation (117' 4);  		string stringText = (STRING7 != null ? STRING7.Text : default(string));  		stringText = stringText.Substring (1' stringText.Length - 2);  		filterNode = new Value (stringText);  	}  	break;  case 5:  	DebugEnterAlt (5);  	// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  	{  		DebugLocation (122' 4);  		REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  		DebugLocation (123' 4);  		string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  		regexText = regexText.Substring (1' regexText.Length - 2);  		filterNode = new RegExp (regexText);  	}  	break;  case 6:  	DebugEnterAlt (6);  	// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  	{  		DebugLocation (128' 4);  		NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  		DebugLocation (129' 4);  		filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  	}  	break;  case 7:  	DebugEnterAlt (7);  	// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  	{  		DebugLocation (132' 4);  		Match (input' TRUE' Follow._TRUE_in_filterExpr271);  		DebugLocation (133' 4);  		filterNode = new Value (true);  	}  	break;  case 8:  	DebugEnterAlt (8);  	// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  	{  		DebugLocation (136' 4);  		Match (input' FALSE' Follow._FALSE_in_filterExpr281);  		DebugLocation (137' 4);  		filterNode = new Value (false);  	}  	break;  case 9:  	DebugEnterAlt (9);  	// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  	{  		DebugLocation (140' 4);  		Match (input' NULL' Follow._NULL_in_filterExpr291);  		DebugLocation (141' 4);  		filterNode = new Value (null);  	}  	break;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: switch (alt9) {  case 1:  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  	{  		DebugLocation (64' 4);  		DebugLocation (64' 6);  		PushFollow (Follow._comparator_in_filterExpr175);  		comparator6 = comparator ();  		PopFollow ();  		Match (input' TokenTypes.Down' null);  		DebugLocation (64' 18);  		PushFollow (Follow._filterExpr_in_filterExpr179);  		a = filterExpr ();  		PopFollow ();  		DebugLocation (64' 31);  		PushFollow (Follow._filterExpr_in_filterExpr183);  		b = filterExpr ();  		PopFollow ();  		Match (input' TokenTypes.Up' null);  		DebugLocation (65' 4);  		Comparator newComparator;  		switch (comparator6) {  		case "=":  			newComparator = Comparator.Equals;  			break;  		case "!=":  			newComparator = Comparator.NotEquals;  			break;  		case ">":  			newComparator = Comparator.Greater;  			break;  		case "<":  			newComparator = Comparator.Less;  			break;  		case ">=":  			newComparator = Comparator.GreaterOrEqual;  			break;  		case "<=":  			newComparator = Comparator.LessOrEqual;  			break;  		case "&":  			newComparator = Comparator.And;  			break;  		case "|":  			newComparator = Comparator.Or;  			break;  		default:  			newComparator = Comparator.Equals;  			break;  		}  		filterNode = new BoolExpression (a' newComparator' b);  	}  	break;  case 2:  	DebugEnterAlt (2);  	// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  	{  		DebugLocation (98' 4);  		DebugLocation (98' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr195);  		Match (input' TokenTypes.Down' null);  		DebugLocation (98' 12);  		PushFollow (Follow._filterExpr_in_filterExpr199);  		f = filterExpr ();  		PopFollow ();  		DebugLocation (98' 31);  		// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  		int alt6 = 2;  		try {  			DebugEnterSubRule (6);  			try {  				DebugEnterDecision (6' false);  				int LA6_1 = input.LA (1);  				if ((LA6_1 == 24)) {  					alt6 = 1;  				}  			}  			finally {  				DebugExitDecision (6);  			}  			switch (alt6) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  				{  					DebugLocation (98' 31);  					inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (6);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (99' 4);  		FilterTreeNode newNode = f;  		if ((inverse != null ? inverse.Text : default(string)) == "!")  			newNode.ToggleInversed ();  		filterNode = newNode;  	}  	break;  case 3:  	DebugEnterAlt (3);  	// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  	{  		DebugLocation (105' 4);  		DebugLocation (105' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr216);  		Match (input' TokenTypes.Down' null);  		DebugLocation (105' 12);  		PushFollow (Follow._propertyChain_in_filterExpr219);  		propertyChain (propertySegments);  		PopFollow ();  		DebugLocation (105' 51);  		// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  		int alt7 = 2;  		try {  			DebugEnterSubRule (7);  			try {  				DebugEnterDecision (7' false);  				int LA7_1 = input.LA (1);  				if ((LA7_1 == 31)) {  					alt7 = 1;  				}  			}  			finally {  				DebugExitDecision (7);  			}  			switch (alt7) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  				{  					DebugLocation (105' 51);  					inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (7);  		}  		DebugLocation (105' 60);  		// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  		int alt8 = 2;  		try {  			DebugEnterSubRule (8);  			try {  				DebugEnterDecision (8' false);  				int LA8_1 = input.LA (1);  				if ((LA8_1 == 24)) {  					alt8 = 1;  				}  			}  			finally {  				DebugExitDecision (8);  			}  			switch (alt8) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  				{  					DebugLocation (105' 60);  					not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (8);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (106' 4);  		FilterTreeNode newProperty = new Property (propertySegments);  		if ((inverse != null ? inverse.Text : default(string)) == "?")  			filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  		else {  			if ((not != null ? not.Text : default(string)) == "!")  				newProperty.ToggleInversed ();  			filterNode = newProperty;  		}  	}  	break;  case 4:  	DebugEnterAlt (4);  	// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  	{  		DebugLocation (116' 4);  		STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  		DebugLocation (117' 4);  		string stringText = (STRING7 != null ? STRING7.Text : default(string));  		stringText = stringText.Substring (1' stringText.Length - 2);  		filterNode = new Value (stringText);  	}  	break;  case 5:  	DebugEnterAlt (5);  	// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  	{  		DebugLocation (122' 4);  		REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  		DebugLocation (123' 4);  		string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  		regexText = regexText.Substring (1' regexText.Length - 2);  		filterNode = new RegExp (regexText);  	}  	break;  case 6:  	DebugEnterAlt (6);  	// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  	{  		DebugLocation (128' 4);  		NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  		DebugLocation (129' 4);  		filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  	}  	break;  case 7:  	DebugEnterAlt (7);  	// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  	{  		DebugLocation (132' 4);  		Match (input' TRUE' Follow._TRUE_in_filterExpr271);  		DebugLocation (133' 4);  		filterNode = new Value (true);  	}  	break;  case 8:  	DebugEnterAlt (8);  	// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  	{  		DebugLocation (136' 4);  		Match (input' FALSE' Follow._FALSE_in_filterExpr281);  		DebugLocation (137' 4);  		filterNode = new Value (false);  	}  	break;  case 9:  	DebugEnterAlt (9);  	// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  	{  		DebugLocation (140' 4);  		Match (input' NULL' Follow._NULL_in_filterExpr291);  		DebugLocation (141' 4);  		filterNode = new Value (null);  	}  	break;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: switch (alt9) {  case 1:  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  	{  		DebugLocation (64' 4);  		DebugLocation (64' 6);  		PushFollow (Follow._comparator_in_filterExpr175);  		comparator6 = comparator ();  		PopFollow ();  		Match (input' TokenTypes.Down' null);  		DebugLocation (64' 18);  		PushFollow (Follow._filterExpr_in_filterExpr179);  		a = filterExpr ();  		PopFollow ();  		DebugLocation (64' 31);  		PushFollow (Follow._filterExpr_in_filterExpr183);  		b = filterExpr ();  		PopFollow ();  		Match (input' TokenTypes.Up' null);  		DebugLocation (65' 4);  		Comparator newComparator;  		switch (comparator6) {  		case "=":  			newComparator = Comparator.Equals;  			break;  		case "!=":  			newComparator = Comparator.NotEquals;  			break;  		case ">":  			newComparator = Comparator.Greater;  			break;  		case "<":  			newComparator = Comparator.Less;  			break;  		case ">=":  			newComparator = Comparator.GreaterOrEqual;  			break;  		case "<=":  			newComparator = Comparator.LessOrEqual;  			break;  		case "&":  			newComparator = Comparator.And;  			break;  		case "|":  			newComparator = Comparator.Or;  			break;  		default:  			newComparator = Comparator.Equals;  			break;  		}  		filterNode = new BoolExpression (a' newComparator' b);  	}  	break;  case 2:  	DebugEnterAlt (2);  	// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  	{  		DebugLocation (98' 4);  		DebugLocation (98' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr195);  		Match (input' TokenTypes.Down' null);  		DebugLocation (98' 12);  		PushFollow (Follow._filterExpr_in_filterExpr199);  		f = filterExpr ();  		PopFollow ();  		DebugLocation (98' 31);  		// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  		int alt6 = 2;  		try {  			DebugEnterSubRule (6);  			try {  				DebugEnterDecision (6' false);  				int LA6_1 = input.LA (1);  				if ((LA6_1 == 24)) {  					alt6 = 1;  				}  			}  			finally {  				DebugExitDecision (6);  			}  			switch (alt6) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  				{  					DebugLocation (98' 31);  					inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (6);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (99' 4);  		FilterTreeNode newNode = f;  		if ((inverse != null ? inverse.Text : default(string)) == "!")  			newNode.ToggleInversed ();  		filterNode = newNode;  	}  	break;  case 3:  	DebugEnterAlt (3);  	// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  	{  		DebugLocation (105' 4);  		DebugLocation (105' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr216);  		Match (input' TokenTypes.Down' null);  		DebugLocation (105' 12);  		PushFollow (Follow._propertyChain_in_filterExpr219);  		propertyChain (propertySegments);  		PopFollow ();  		DebugLocation (105' 51);  		// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  		int alt7 = 2;  		try {  			DebugEnterSubRule (7);  			try {  				DebugEnterDecision (7' false);  				int LA7_1 = input.LA (1);  				if ((LA7_1 == 31)) {  					alt7 = 1;  				}  			}  			finally {  				DebugExitDecision (7);  			}  			switch (alt7) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  				{  					DebugLocation (105' 51);  					inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (7);  		}  		DebugLocation (105' 60);  		// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  		int alt8 = 2;  		try {  			DebugEnterSubRule (8);  			try {  				DebugEnterDecision (8' false);  				int LA8_1 = input.LA (1);  				if ((LA8_1 == 24)) {  					alt8 = 1;  				}  			}  			finally {  				DebugExitDecision (8);  			}  			switch (alt8) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  				{  					DebugLocation (105' 60);  					not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (8);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (106' 4);  		FilterTreeNode newProperty = new Property (propertySegments);  		if ((inverse != null ? inverse.Text : default(string)) == "?")  			filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  		else {  			if ((not != null ? not.Text : default(string)) == "!")  				newProperty.ToggleInversed ();  			filterNode = newProperty;  		}  	}  	break;  case 4:  	DebugEnterAlt (4);  	// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  	{  		DebugLocation (116' 4);  		STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  		DebugLocation (117' 4);  		string stringText = (STRING7 != null ? STRING7.Text : default(string));  		stringText = stringText.Substring (1' stringText.Length - 2);  		filterNode = new Value (stringText);  	}  	break;  case 5:  	DebugEnterAlt (5);  	// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  	{  		DebugLocation (122' 4);  		REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  		DebugLocation (123' 4);  		string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  		regexText = regexText.Substring (1' regexText.Length - 2);  		filterNode = new RegExp (regexText);  	}  	break;  case 6:  	DebugEnterAlt (6);  	// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  	{  		DebugLocation (128' 4);  		NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  		DebugLocation (129' 4);  		filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  	}  	break;  case 7:  	DebugEnterAlt (7);  	// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  	{  		DebugLocation (132' 4);  		Match (input' TRUE' Follow._TRUE_in_filterExpr271);  		DebugLocation (133' 4);  		filterNode = new Value (true);  	}  	break;  case 8:  	DebugEnterAlt (8);  	// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  	{  		DebugLocation (136' 4);  		Match (input' FALSE' Follow._FALSE_in_filterExpr281);  		DebugLocation (137' 4);  		filterNode = new Value (false);  	}  	break;  case 9:  	DebugEnterAlt (9);  	// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  	{  		DebugLocation (140' 4);  		Match (input' NULL' Follow._NULL_in_filterExpr291);  		DebugLocation (141' 4);  		filterNode = new Value (null);  	}  	break;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: switch (alt9) {  case 1:  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  	{  		DebugLocation (64' 4);  		DebugLocation (64' 6);  		PushFollow (Follow._comparator_in_filterExpr175);  		comparator6 = comparator ();  		PopFollow ();  		Match (input' TokenTypes.Down' null);  		DebugLocation (64' 18);  		PushFollow (Follow._filterExpr_in_filterExpr179);  		a = filterExpr ();  		PopFollow ();  		DebugLocation (64' 31);  		PushFollow (Follow._filterExpr_in_filterExpr183);  		b = filterExpr ();  		PopFollow ();  		Match (input' TokenTypes.Up' null);  		DebugLocation (65' 4);  		Comparator newComparator;  		switch (comparator6) {  		case "=":  			newComparator = Comparator.Equals;  			break;  		case "!=":  			newComparator = Comparator.NotEquals;  			break;  		case ">":  			newComparator = Comparator.Greater;  			break;  		case "<":  			newComparator = Comparator.Less;  			break;  		case ">=":  			newComparator = Comparator.GreaterOrEqual;  			break;  		case "<=":  			newComparator = Comparator.LessOrEqual;  			break;  		case "&":  			newComparator = Comparator.And;  			break;  		case "|":  			newComparator = Comparator.Or;  			break;  		default:  			newComparator = Comparator.Equals;  			break;  		}  		filterNode = new BoolExpression (a' newComparator' b);  	}  	break;  case 2:  	DebugEnterAlt (2);  	// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  	{  		DebugLocation (98' 4);  		DebugLocation (98' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr195);  		Match (input' TokenTypes.Down' null);  		DebugLocation (98' 12);  		PushFollow (Follow._filterExpr_in_filterExpr199);  		f = filterExpr ();  		PopFollow ();  		DebugLocation (98' 31);  		// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  		int alt6 = 2;  		try {  			DebugEnterSubRule (6);  			try {  				DebugEnterDecision (6' false);  				int LA6_1 = input.LA (1);  				if ((LA6_1 == 24)) {  					alt6 = 1;  				}  			}  			finally {  				DebugExitDecision (6);  			}  			switch (alt6) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  				{  					DebugLocation (98' 31);  					inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (6);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (99' 4);  		FilterTreeNode newNode = f;  		if ((inverse != null ? inverse.Text : default(string)) == "!")  			newNode.ToggleInversed ();  		filterNode = newNode;  	}  	break;  case 3:  	DebugEnterAlt (3);  	// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  	{  		DebugLocation (105' 4);  		DebugLocation (105' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr216);  		Match (input' TokenTypes.Down' null);  		DebugLocation (105' 12);  		PushFollow (Follow._propertyChain_in_filterExpr219);  		propertyChain (propertySegments);  		PopFollow ();  		DebugLocation (105' 51);  		// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  		int alt7 = 2;  		try {  			DebugEnterSubRule (7);  			try {  				DebugEnterDecision (7' false);  				int LA7_1 = input.LA (1);  				if ((LA7_1 == 31)) {  					alt7 = 1;  				}  			}  			finally {  				DebugExitDecision (7);  			}  			switch (alt7) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  				{  					DebugLocation (105' 51);  					inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (7);  		}  		DebugLocation (105' 60);  		// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  		int alt8 = 2;  		try {  			DebugEnterSubRule (8);  			try {  				DebugEnterDecision (8' false);  				int LA8_1 = input.LA (1);  				if ((LA8_1 == 24)) {  					alt8 = 1;  				}  			}  			finally {  				DebugExitDecision (8);  			}  			switch (alt8) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  				{  					DebugLocation (105' 60);  					not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (8);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (106' 4);  		FilterTreeNode newProperty = new Property (propertySegments);  		if ((inverse != null ? inverse.Text : default(string)) == "?")  			filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  		else {  			if ((not != null ? not.Text : default(string)) == "!")  				newProperty.ToggleInversed ();  			filterNode = newProperty;  		}  	}  	break;  case 4:  	DebugEnterAlt (4);  	// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  	{  		DebugLocation (116' 4);  		STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  		DebugLocation (117' 4);  		string stringText = (STRING7 != null ? STRING7.Text : default(string));  		stringText = stringText.Substring (1' stringText.Length - 2);  		filterNode = new Value (stringText);  	}  	break;  case 5:  	DebugEnterAlt (5);  	// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  	{  		DebugLocation (122' 4);  		REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  		DebugLocation (123' 4);  		string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  		regexText = regexText.Substring (1' regexText.Length - 2);  		filterNode = new RegExp (regexText);  	}  	break;  case 6:  	DebugEnterAlt (6);  	// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  	{  		DebugLocation (128' 4);  		NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  		DebugLocation (129' 4);  		filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  	}  	break;  case 7:  	DebugEnterAlt (7);  	// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  	{  		DebugLocation (132' 4);  		Match (input' TRUE' Follow._TRUE_in_filterExpr271);  		DebugLocation (133' 4);  		filterNode = new Value (true);  	}  	break;  case 8:  	DebugEnterAlt (8);  	// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  	{  		DebugLocation (136' 4);  		Match (input' FALSE' Follow._FALSE_in_filterExpr281);  		DebugLocation (137' 4);  		filterNode = new Value (false);  	}  	break;  case 9:  	DebugEnterAlt (9);  	// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  	{  		DebugLocation (140' 4);  		Match (input' NULL' Follow._NULL_in_filterExpr291);  		DebugLocation (141' 4);  		filterNode = new Value (null);  	}  	break;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: switch (alt9) {  case 1:  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  	{  		DebugLocation (64' 4);  		DebugLocation (64' 6);  		PushFollow (Follow._comparator_in_filterExpr175);  		comparator6 = comparator ();  		PopFollow ();  		Match (input' TokenTypes.Down' null);  		DebugLocation (64' 18);  		PushFollow (Follow._filterExpr_in_filterExpr179);  		a = filterExpr ();  		PopFollow ();  		DebugLocation (64' 31);  		PushFollow (Follow._filterExpr_in_filterExpr183);  		b = filterExpr ();  		PopFollow ();  		Match (input' TokenTypes.Up' null);  		DebugLocation (65' 4);  		Comparator newComparator;  		switch (comparator6) {  		case "=":  			newComparator = Comparator.Equals;  			break;  		case "!=":  			newComparator = Comparator.NotEquals;  			break;  		case ">":  			newComparator = Comparator.Greater;  			break;  		case "<":  			newComparator = Comparator.Less;  			break;  		case ">=":  			newComparator = Comparator.GreaterOrEqual;  			break;  		case "<=":  			newComparator = Comparator.LessOrEqual;  			break;  		case "&":  			newComparator = Comparator.And;  			break;  		case "|":  			newComparator = Comparator.Or;  			break;  		default:  			newComparator = Comparator.Equals;  			break;  		}  		filterNode = new BoolExpression (a' newComparator' b);  	}  	break;  case 2:  	DebugEnterAlt (2);  	// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  	{  		DebugLocation (98' 4);  		DebugLocation (98' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr195);  		Match (input' TokenTypes.Down' null);  		DebugLocation (98' 12);  		PushFollow (Follow._filterExpr_in_filterExpr199);  		f = filterExpr ();  		PopFollow ();  		DebugLocation (98' 31);  		// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  		int alt6 = 2;  		try {  			DebugEnterSubRule (6);  			try {  				DebugEnterDecision (6' false);  				int LA6_1 = input.LA (1);  				if ((LA6_1 == 24)) {  					alt6 = 1;  				}  			}  			finally {  				DebugExitDecision (6);  			}  			switch (alt6) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  				{  					DebugLocation (98' 31);  					inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (6);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (99' 4);  		FilterTreeNode newNode = f;  		if ((inverse != null ? inverse.Text : default(string)) == "!")  			newNode.ToggleInversed ();  		filterNode = newNode;  	}  	break;  case 3:  	DebugEnterAlt (3);  	// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  	{  		DebugLocation (105' 4);  		DebugLocation (105' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr216);  		Match (input' TokenTypes.Down' null);  		DebugLocation (105' 12);  		PushFollow (Follow._propertyChain_in_filterExpr219);  		propertyChain (propertySegments);  		PopFollow ();  		DebugLocation (105' 51);  		// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  		int alt7 = 2;  		try {  			DebugEnterSubRule (7);  			try {  				DebugEnterDecision (7' false);  				int LA7_1 = input.LA (1);  				if ((LA7_1 == 31)) {  					alt7 = 1;  				}  			}  			finally {  				DebugExitDecision (7);  			}  			switch (alt7) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  				{  					DebugLocation (105' 51);  					inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (7);  		}  		DebugLocation (105' 60);  		// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  		int alt8 = 2;  		try {  			DebugEnterSubRule (8);  			try {  				DebugEnterDecision (8' false);  				int LA8_1 = input.LA (1);  				if ((LA8_1 == 24)) {  					alt8 = 1;  				}  			}  			finally {  				DebugExitDecision (8);  			}  			switch (alt8) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  				{  					DebugLocation (105' 60);  					not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (8);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (106' 4);  		FilterTreeNode newProperty = new Property (propertySegments);  		if ((inverse != null ? inverse.Text : default(string)) == "?")  			filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  		else {  			if ((not != null ? not.Text : default(string)) == "!")  				newProperty.ToggleInversed ();  			filterNode = newProperty;  		}  	}  	break;  case 4:  	DebugEnterAlt (4);  	// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  	{  		DebugLocation (116' 4);  		STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  		DebugLocation (117' 4);  		string stringText = (STRING7 != null ? STRING7.Text : default(string));  		stringText = stringText.Substring (1' stringText.Length - 2);  		filterNode = new Value (stringText);  	}  	break;  case 5:  	DebugEnterAlt (5);  	// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  	{  		DebugLocation (122' 4);  		REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  		DebugLocation (123' 4);  		string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  		regexText = regexText.Substring (1' regexText.Length - 2);  		filterNode = new RegExp (regexText);  	}  	break;  case 6:  	DebugEnterAlt (6);  	// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  	{  		DebugLocation (128' 4);  		NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  		DebugLocation (129' 4);  		filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  	}  	break;  case 7:  	DebugEnterAlt (7);  	// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  	{  		DebugLocation (132' 4);  		Match (input' TRUE' Follow._TRUE_in_filterExpr271);  		DebugLocation (133' 4);  		filterNode = new Value (true);  	}  	break;  case 8:  	DebugEnterAlt (8);  	// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  	{  		DebugLocation (136' 4);  		Match (input' FALSE' Follow._FALSE_in_filterExpr281);  		DebugLocation (137' 4);  		filterNode = new Value (false);  	}  	break;  case 9:  	DebugEnterAlt (9);  	// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  	{  		DebugLocation (140' 4);  		Match (input' NULL' Follow._NULL_in_filterExpr291);  		DebugLocation (141' 4);  		filterNode = new Value (null);  	}  	break;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: switch (alt9) {  case 1:  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  	{  		DebugLocation (64' 4);  		DebugLocation (64' 6);  		PushFollow (Follow._comparator_in_filterExpr175);  		comparator6 = comparator ();  		PopFollow ();  		Match (input' TokenTypes.Down' null);  		DebugLocation (64' 18);  		PushFollow (Follow._filterExpr_in_filterExpr179);  		a = filterExpr ();  		PopFollow ();  		DebugLocation (64' 31);  		PushFollow (Follow._filterExpr_in_filterExpr183);  		b = filterExpr ();  		PopFollow ();  		Match (input' TokenTypes.Up' null);  		DebugLocation (65' 4);  		Comparator newComparator;  		switch (comparator6) {  		case "=":  			newComparator = Comparator.Equals;  			break;  		case "!=":  			newComparator = Comparator.NotEquals;  			break;  		case ">":  			newComparator = Comparator.Greater;  			break;  		case "<":  			newComparator = Comparator.Less;  			break;  		case ">=":  			newComparator = Comparator.GreaterOrEqual;  			break;  		case "<=":  			newComparator = Comparator.LessOrEqual;  			break;  		case "&":  			newComparator = Comparator.And;  			break;  		case "|":  			newComparator = Comparator.Or;  			break;  		default:  			newComparator = Comparator.Equals;  			break;  		}  		filterNode = new BoolExpression (a' newComparator' b);  	}  	break;  case 2:  	DebugEnterAlt (2);  	// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  	{  		DebugLocation (98' 4);  		DebugLocation (98' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr195);  		Match (input' TokenTypes.Down' null);  		DebugLocation (98' 12);  		PushFollow (Follow._filterExpr_in_filterExpr199);  		f = filterExpr ();  		PopFollow ();  		DebugLocation (98' 31);  		// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  		int alt6 = 2;  		try {  			DebugEnterSubRule (6);  			try {  				DebugEnterDecision (6' false);  				int LA6_1 = input.LA (1);  				if ((LA6_1 == 24)) {  					alt6 = 1;  				}  			}  			finally {  				DebugExitDecision (6);  			}  			switch (alt6) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  				{  					DebugLocation (98' 31);  					inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (6);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (99' 4);  		FilterTreeNode newNode = f;  		if ((inverse != null ? inverse.Text : default(string)) == "!")  			newNode.ToggleInversed ();  		filterNode = newNode;  	}  	break;  case 3:  	DebugEnterAlt (3);  	// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  	{  		DebugLocation (105' 4);  		DebugLocation (105' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr216);  		Match (input' TokenTypes.Down' null);  		DebugLocation (105' 12);  		PushFollow (Follow._propertyChain_in_filterExpr219);  		propertyChain (propertySegments);  		PopFollow ();  		DebugLocation (105' 51);  		// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  		int alt7 = 2;  		try {  			DebugEnterSubRule (7);  			try {  				DebugEnterDecision (7' false);  				int LA7_1 = input.LA (1);  				if ((LA7_1 == 31)) {  					alt7 = 1;  				}  			}  			finally {  				DebugExitDecision (7);  			}  			switch (alt7) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  				{  					DebugLocation (105' 51);  					inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (7);  		}  		DebugLocation (105' 60);  		// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  		int alt8 = 2;  		try {  			DebugEnterSubRule (8);  			try {  				DebugEnterDecision (8' false);  				int LA8_1 = input.LA (1);  				if ((LA8_1 == 24)) {  					alt8 = 1;  				}  			}  			finally {  				DebugExitDecision (8);  			}  			switch (alt8) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  				{  					DebugLocation (105' 60);  					not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (8);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (106' 4);  		FilterTreeNode newProperty = new Property (propertySegments);  		if ((inverse != null ? inverse.Text : default(string)) == "?")  			filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  		else {  			if ((not != null ? not.Text : default(string)) == "!")  				newProperty.ToggleInversed ();  			filterNode = newProperty;  		}  	}  	break;  case 4:  	DebugEnterAlt (4);  	// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  	{  		DebugLocation (116' 4);  		STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  		DebugLocation (117' 4);  		string stringText = (STRING7 != null ? STRING7.Text : default(string));  		stringText = stringText.Substring (1' stringText.Length - 2);  		filterNode = new Value (stringText);  	}  	break;  case 5:  	DebugEnterAlt (5);  	// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  	{  		DebugLocation (122' 4);  		REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  		DebugLocation (123' 4);  		string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  		regexText = regexText.Substring (1' regexText.Length - 2);  		filterNode = new RegExp (regexText);  	}  	break;  case 6:  	DebugEnterAlt (6);  	// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  	{  		DebugLocation (128' 4);  		NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  		DebugLocation (129' 4);  		filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  	}  	break;  case 7:  	DebugEnterAlt (7);  	// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  	{  		DebugLocation (132' 4);  		Match (input' TRUE' Follow._TRUE_in_filterExpr271);  		DebugLocation (133' 4);  		filterNode = new Value (true);  	}  	break;  case 8:  	DebugEnterAlt (8);  	// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  	{  		DebugLocation (136' 4);  		Match (input' FALSE' Follow._FALSE_in_filterExpr281);  		DebugLocation (137' 4);  		filterNode = new Value (false);  	}  	break;  case 9:  	DebugEnterAlt (9);  	// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  	{  		DebugLocation (140' 4);  		Match (input' NULL' Follow._NULL_in_filterExpr291);  		DebugLocation (141' 4);  		filterNode = new Value (null);  	}  	break;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: switch (alt9) {  case 1:  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  	{  		DebugLocation (64' 4);  		DebugLocation (64' 6);  		PushFollow (Follow._comparator_in_filterExpr175);  		comparator6 = comparator ();  		PopFollow ();  		Match (input' TokenTypes.Down' null);  		DebugLocation (64' 18);  		PushFollow (Follow._filterExpr_in_filterExpr179);  		a = filterExpr ();  		PopFollow ();  		DebugLocation (64' 31);  		PushFollow (Follow._filterExpr_in_filterExpr183);  		b = filterExpr ();  		PopFollow ();  		Match (input' TokenTypes.Up' null);  		DebugLocation (65' 4);  		Comparator newComparator;  		switch (comparator6) {  		case "=":  			newComparator = Comparator.Equals;  			break;  		case "!=":  			newComparator = Comparator.NotEquals;  			break;  		case ">":  			newComparator = Comparator.Greater;  			break;  		case "<":  			newComparator = Comparator.Less;  			break;  		case ">=":  			newComparator = Comparator.GreaterOrEqual;  			break;  		case "<=":  			newComparator = Comparator.LessOrEqual;  			break;  		case "&":  			newComparator = Comparator.And;  			break;  		case "|":  			newComparator = Comparator.Or;  			break;  		default:  			newComparator = Comparator.Equals;  			break;  		}  		filterNode = new BoolExpression (a' newComparator' b);  	}  	break;  case 2:  	DebugEnterAlt (2);  	// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  	{  		DebugLocation (98' 4);  		DebugLocation (98' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr195);  		Match (input' TokenTypes.Down' null);  		DebugLocation (98' 12);  		PushFollow (Follow._filterExpr_in_filterExpr199);  		f = filterExpr ();  		PopFollow ();  		DebugLocation (98' 31);  		// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  		int alt6 = 2;  		try {  			DebugEnterSubRule (6);  			try {  				DebugEnterDecision (6' false);  				int LA6_1 = input.LA (1);  				if ((LA6_1 == 24)) {  					alt6 = 1;  				}  			}  			finally {  				DebugExitDecision (6);  			}  			switch (alt6) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  				{  					DebugLocation (98' 31);  					inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (6);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (99' 4);  		FilterTreeNode newNode = f;  		if ((inverse != null ? inverse.Text : default(string)) == "!")  			newNode.ToggleInversed ();  		filterNode = newNode;  	}  	break;  case 3:  	DebugEnterAlt (3);  	// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  	{  		DebugLocation (105' 4);  		DebugLocation (105' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr216);  		Match (input' TokenTypes.Down' null);  		DebugLocation (105' 12);  		PushFollow (Follow._propertyChain_in_filterExpr219);  		propertyChain (propertySegments);  		PopFollow ();  		DebugLocation (105' 51);  		// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  		int alt7 = 2;  		try {  			DebugEnterSubRule (7);  			try {  				DebugEnterDecision (7' false);  				int LA7_1 = input.LA (1);  				if ((LA7_1 == 31)) {  					alt7 = 1;  				}  			}  			finally {  				DebugExitDecision (7);  			}  			switch (alt7) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  				{  					DebugLocation (105' 51);  					inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (7);  		}  		DebugLocation (105' 60);  		// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  		int alt8 = 2;  		try {  			DebugEnterSubRule (8);  			try {  				DebugEnterDecision (8' false);  				int LA8_1 = input.LA (1);  				if ((LA8_1 == 24)) {  					alt8 = 1;  				}  			}  			finally {  				DebugExitDecision (8);  			}  			switch (alt8) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  				{  					DebugLocation (105' 60);  					not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (8);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (106' 4);  		FilterTreeNode newProperty = new Property (propertySegments);  		if ((inverse != null ? inverse.Text : default(string)) == "?")  			filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  		else {  			if ((not != null ? not.Text : default(string)) == "!")  				newProperty.ToggleInversed ();  			filterNode = newProperty;  		}  	}  	break;  case 4:  	DebugEnterAlt (4);  	// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  	{  		DebugLocation (116' 4);  		STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  		DebugLocation (117' 4);  		string stringText = (STRING7 != null ? STRING7.Text : default(string));  		stringText = stringText.Substring (1' stringText.Length - 2);  		filterNode = new Value (stringText);  	}  	break;  case 5:  	DebugEnterAlt (5);  	// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  	{  		DebugLocation (122' 4);  		REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  		DebugLocation (123' 4);  		string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  		regexText = regexText.Substring (1' regexText.Length - 2);  		filterNode = new RegExp (regexText);  	}  	break;  case 6:  	DebugEnterAlt (6);  	// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  	{  		DebugLocation (128' 4);  		NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  		DebugLocation (129' 4);  		filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  	}  	break;  case 7:  	DebugEnterAlt (7);  	// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  	{  		DebugLocation (132' 4);  		Match (input' TRUE' Follow._TRUE_in_filterExpr271);  		DebugLocation (133' 4);  		filterNode = new Value (true);  	}  	break;  case 8:  	DebugEnterAlt (8);  	// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  	{  		DebugLocation (136' 4);  		Match (input' FALSE' Follow._FALSE_in_filterExpr281);  		DebugLocation (137' 4);  		filterNode = new Value (false);  	}  	break;  case 9:  	DebugEnterAlt (9);  	// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  	{  		DebugLocation (140' 4);  		Match (input' NULL' Follow._NULL_in_filterExpr291);  		DebugLocation (141' 4);  		filterNode = new Value (null);  	}  	break;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: switch (alt9) {  case 1:  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  	{  		DebugLocation (64' 4);  		DebugLocation (64' 6);  		PushFollow (Follow._comparator_in_filterExpr175);  		comparator6 = comparator ();  		PopFollow ();  		Match (input' TokenTypes.Down' null);  		DebugLocation (64' 18);  		PushFollow (Follow._filterExpr_in_filterExpr179);  		a = filterExpr ();  		PopFollow ();  		DebugLocation (64' 31);  		PushFollow (Follow._filterExpr_in_filterExpr183);  		b = filterExpr ();  		PopFollow ();  		Match (input' TokenTypes.Up' null);  		DebugLocation (65' 4);  		Comparator newComparator;  		switch (comparator6) {  		case "=":  			newComparator = Comparator.Equals;  			break;  		case "!=":  			newComparator = Comparator.NotEquals;  			break;  		case ">":  			newComparator = Comparator.Greater;  			break;  		case "<":  			newComparator = Comparator.Less;  			break;  		case ">=":  			newComparator = Comparator.GreaterOrEqual;  			break;  		case "<=":  			newComparator = Comparator.LessOrEqual;  			break;  		case "&":  			newComparator = Comparator.And;  			break;  		case "|":  			newComparator = Comparator.Or;  			break;  		default:  			newComparator = Comparator.Equals;  			break;  		}  		filterNode = new BoolExpression (a' newComparator' b);  	}  	break;  case 2:  	DebugEnterAlt (2);  	// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  	{  		DebugLocation (98' 4);  		DebugLocation (98' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr195);  		Match (input' TokenTypes.Down' null);  		DebugLocation (98' 12);  		PushFollow (Follow._filterExpr_in_filterExpr199);  		f = filterExpr ();  		PopFollow ();  		DebugLocation (98' 31);  		// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  		int alt6 = 2;  		try {  			DebugEnterSubRule (6);  			try {  				DebugEnterDecision (6' false);  				int LA6_1 = input.LA (1);  				if ((LA6_1 == 24)) {  					alt6 = 1;  				}  			}  			finally {  				DebugExitDecision (6);  			}  			switch (alt6) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  				{  					DebugLocation (98' 31);  					inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (6);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (99' 4);  		FilterTreeNode newNode = f;  		if ((inverse != null ? inverse.Text : default(string)) == "!")  			newNode.ToggleInversed ();  		filterNode = newNode;  	}  	break;  case 3:  	DebugEnterAlt (3);  	// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  	{  		DebugLocation (105' 4);  		DebugLocation (105' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr216);  		Match (input' TokenTypes.Down' null);  		DebugLocation (105' 12);  		PushFollow (Follow._propertyChain_in_filterExpr219);  		propertyChain (propertySegments);  		PopFollow ();  		DebugLocation (105' 51);  		// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  		int alt7 = 2;  		try {  			DebugEnterSubRule (7);  			try {  				DebugEnterDecision (7' false);  				int LA7_1 = input.LA (1);  				if ((LA7_1 == 31)) {  					alt7 = 1;  				}  			}  			finally {  				DebugExitDecision (7);  			}  			switch (alt7) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  				{  					DebugLocation (105' 51);  					inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (7);  		}  		DebugLocation (105' 60);  		// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  		int alt8 = 2;  		try {  			DebugEnterSubRule (8);  			try {  				DebugEnterDecision (8' false);  				int LA8_1 = input.LA (1);  				if ((LA8_1 == 24)) {  					alt8 = 1;  				}  			}  			finally {  				DebugExitDecision (8);  			}  			switch (alt8) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  				{  					DebugLocation (105' 60);  					not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (8);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (106' 4);  		FilterTreeNode newProperty = new Property (propertySegments);  		if ((inverse != null ? inverse.Text : default(string)) == "?")  			filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  		else {  			if ((not != null ? not.Text : default(string)) == "!")  				newProperty.ToggleInversed ();  			filterNode = newProperty;  		}  	}  	break;  case 4:  	DebugEnterAlt (4);  	// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  	{  		DebugLocation (116' 4);  		STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  		DebugLocation (117' 4);  		string stringText = (STRING7 != null ? STRING7.Text : default(string));  		stringText = stringText.Substring (1' stringText.Length - 2);  		filterNode = new Value (stringText);  	}  	break;  case 5:  	DebugEnterAlt (5);  	// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  	{  		DebugLocation (122' 4);  		REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  		DebugLocation (123' 4);  		string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  		regexText = regexText.Substring (1' regexText.Length - 2);  		filterNode = new RegExp (regexText);  	}  	break;  case 6:  	DebugEnterAlt (6);  	// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  	{  		DebugLocation (128' 4);  		NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  		DebugLocation (129' 4);  		filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  	}  	break;  case 7:  	DebugEnterAlt (7);  	// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  	{  		DebugLocation (132' 4);  		Match (input' TRUE' Follow._TRUE_in_filterExpr271);  		DebugLocation (133' 4);  		filterNode = new Value (true);  	}  	break;  case 8:  	DebugEnterAlt (8);  	// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  	{  		DebugLocation (136' 4);  		Match (input' FALSE' Follow._FALSE_in_filterExpr281);  		DebugLocation (137' 4);  		filterNode = new Value (false);  	}  	break;  case 9:  	DebugEnterAlt (9);  	// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  	{  		DebugLocation (140' 4);  		Match (input' NULL' Follow._NULL_in_filterExpr291);  		DebugLocation (141' 4);  		filterNode = new Value (null);  	}  	break;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: switch (alt9) {  case 1:  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  	{  		DebugLocation (64' 4);  		DebugLocation (64' 6);  		PushFollow (Follow._comparator_in_filterExpr175);  		comparator6 = comparator ();  		PopFollow ();  		Match (input' TokenTypes.Down' null);  		DebugLocation (64' 18);  		PushFollow (Follow._filterExpr_in_filterExpr179);  		a = filterExpr ();  		PopFollow ();  		DebugLocation (64' 31);  		PushFollow (Follow._filterExpr_in_filterExpr183);  		b = filterExpr ();  		PopFollow ();  		Match (input' TokenTypes.Up' null);  		DebugLocation (65' 4);  		Comparator newComparator;  		switch (comparator6) {  		case "=":  			newComparator = Comparator.Equals;  			break;  		case "!=":  			newComparator = Comparator.NotEquals;  			break;  		case ">":  			newComparator = Comparator.Greater;  			break;  		case "<":  			newComparator = Comparator.Less;  			break;  		case ">=":  			newComparator = Comparator.GreaterOrEqual;  			break;  		case "<=":  			newComparator = Comparator.LessOrEqual;  			break;  		case "&":  			newComparator = Comparator.And;  			break;  		case "|":  			newComparator = Comparator.Or;  			break;  		default:  			newComparator = Comparator.Equals;  			break;  		}  		filterNode = new BoolExpression (a' newComparator' b);  	}  	break;  case 2:  	DebugEnterAlt (2);  	// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  	{  		DebugLocation (98' 4);  		DebugLocation (98' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr195);  		Match (input' TokenTypes.Down' null);  		DebugLocation (98' 12);  		PushFollow (Follow._filterExpr_in_filterExpr199);  		f = filterExpr ();  		PopFollow ();  		DebugLocation (98' 31);  		// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  		int alt6 = 2;  		try {  			DebugEnterSubRule (6);  			try {  				DebugEnterDecision (6' false);  				int LA6_1 = input.LA (1);  				if ((LA6_1 == 24)) {  					alt6 = 1;  				}  			}  			finally {  				DebugExitDecision (6);  			}  			switch (alt6) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  				{  					DebugLocation (98' 31);  					inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (6);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (99' 4);  		FilterTreeNode newNode = f;  		if ((inverse != null ? inverse.Text : default(string)) == "!")  			newNode.ToggleInversed ();  		filterNode = newNode;  	}  	break;  case 3:  	DebugEnterAlt (3);  	// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  	{  		DebugLocation (105' 4);  		DebugLocation (105' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr216);  		Match (input' TokenTypes.Down' null);  		DebugLocation (105' 12);  		PushFollow (Follow._propertyChain_in_filterExpr219);  		propertyChain (propertySegments);  		PopFollow ();  		DebugLocation (105' 51);  		// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  		int alt7 = 2;  		try {  			DebugEnterSubRule (7);  			try {  				DebugEnterDecision (7' false);  				int LA7_1 = input.LA (1);  				if ((LA7_1 == 31)) {  					alt7 = 1;  				}  			}  			finally {  				DebugExitDecision (7);  			}  			switch (alt7) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  				{  					DebugLocation (105' 51);  					inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (7);  		}  		DebugLocation (105' 60);  		// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  		int alt8 = 2;  		try {  			DebugEnterSubRule (8);  			try {  				DebugEnterDecision (8' false);  				int LA8_1 = input.LA (1);  				if ((LA8_1 == 24)) {  					alt8 = 1;  				}  			}  			finally {  				DebugExitDecision (8);  			}  			switch (alt8) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  				{  					DebugLocation (105' 60);  					not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (8);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (106' 4);  		FilterTreeNode newProperty = new Property (propertySegments);  		if ((inverse != null ? inverse.Text : default(string)) == "?")  			filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  		else {  			if ((not != null ? not.Text : default(string)) == "!")  				newProperty.ToggleInversed ();  			filterNode = newProperty;  		}  	}  	break;  case 4:  	DebugEnterAlt (4);  	// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  	{  		DebugLocation (116' 4);  		STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  		DebugLocation (117' 4);  		string stringText = (STRING7 != null ? STRING7.Text : default(string));  		stringText = stringText.Substring (1' stringText.Length - 2);  		filterNode = new Value (stringText);  	}  	break;  case 5:  	DebugEnterAlt (5);  	// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  	{  		DebugLocation (122' 4);  		REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  		DebugLocation (123' 4);  		string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  		regexText = regexText.Substring (1' regexText.Length - 2);  		filterNode = new RegExp (regexText);  	}  	break;  case 6:  	DebugEnterAlt (6);  	// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  	{  		DebugLocation (128' 4);  		NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  		DebugLocation (129' 4);  		filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  	}  	break;  case 7:  	DebugEnterAlt (7);  	// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  	{  		DebugLocation (132' 4);  		Match (input' TRUE' Follow._TRUE_in_filterExpr271);  		DebugLocation (133' 4);  		filterNode = new Value (true);  	}  	break;  case 8:  	DebugEnterAlt (8);  	// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  	{  		DebugLocation (136' 4);  		Match (input' FALSE' Follow._FALSE_in_filterExpr281);  		DebugLocation (137' 4);  		filterNode = new Value (false);  	}  	break;  case 9:  	DebugEnterAlt (9);  	// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  	{  		DebugLocation (140' 4);  		Match (input' NULL' Follow._NULL_in_filterExpr291);  		DebugLocation (141' 4);  		filterNode = new Value (null);  	}  	break;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: switch (alt9) {  case 1:  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  	{  		DebugLocation (64' 4);  		DebugLocation (64' 6);  		PushFollow (Follow._comparator_in_filterExpr175);  		comparator6 = comparator ();  		PopFollow ();  		Match (input' TokenTypes.Down' null);  		DebugLocation (64' 18);  		PushFollow (Follow._filterExpr_in_filterExpr179);  		a = filterExpr ();  		PopFollow ();  		DebugLocation (64' 31);  		PushFollow (Follow._filterExpr_in_filterExpr183);  		b = filterExpr ();  		PopFollow ();  		Match (input' TokenTypes.Up' null);  		DebugLocation (65' 4);  		Comparator newComparator;  		switch (comparator6) {  		case "=":  			newComparator = Comparator.Equals;  			break;  		case "!=":  			newComparator = Comparator.NotEquals;  			break;  		case ">":  			newComparator = Comparator.Greater;  			break;  		case "<":  			newComparator = Comparator.Less;  			break;  		case ">=":  			newComparator = Comparator.GreaterOrEqual;  			break;  		case "<=":  			newComparator = Comparator.LessOrEqual;  			break;  		case "&":  			newComparator = Comparator.And;  			break;  		case "|":  			newComparator = Comparator.Or;  			break;  		default:  			newComparator = Comparator.Equals;  			break;  		}  		filterNode = new BoolExpression (a' newComparator' b);  	}  	break;  case 2:  	DebugEnterAlt (2);  	// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  	{  		DebugLocation (98' 4);  		DebugLocation (98' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr195);  		Match (input' TokenTypes.Down' null);  		DebugLocation (98' 12);  		PushFollow (Follow._filterExpr_in_filterExpr199);  		f = filterExpr ();  		PopFollow ();  		DebugLocation (98' 31);  		// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  		int alt6 = 2;  		try {  			DebugEnterSubRule (6);  			try {  				DebugEnterDecision (6' false);  				int LA6_1 = input.LA (1);  				if ((LA6_1 == 24)) {  					alt6 = 1;  				}  			}  			finally {  				DebugExitDecision (6);  			}  			switch (alt6) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  				{  					DebugLocation (98' 31);  					inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (6);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (99' 4);  		FilterTreeNode newNode = f;  		if ((inverse != null ? inverse.Text : default(string)) == "!")  			newNode.ToggleInversed ();  		filterNode = newNode;  	}  	break;  case 3:  	DebugEnterAlt (3);  	// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  	{  		DebugLocation (105' 4);  		DebugLocation (105' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr216);  		Match (input' TokenTypes.Down' null);  		DebugLocation (105' 12);  		PushFollow (Follow._propertyChain_in_filterExpr219);  		propertyChain (propertySegments);  		PopFollow ();  		DebugLocation (105' 51);  		// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  		int alt7 = 2;  		try {  			DebugEnterSubRule (7);  			try {  				DebugEnterDecision (7' false);  				int LA7_1 = input.LA (1);  				if ((LA7_1 == 31)) {  					alt7 = 1;  				}  			}  			finally {  				DebugExitDecision (7);  			}  			switch (alt7) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  				{  					DebugLocation (105' 51);  					inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (7);  		}  		DebugLocation (105' 60);  		// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  		int alt8 = 2;  		try {  			DebugEnterSubRule (8);  			try {  				DebugEnterDecision (8' false);  				int LA8_1 = input.LA (1);  				if ((LA8_1 == 24)) {  					alt8 = 1;  				}  			}  			finally {  				DebugExitDecision (8);  			}  			switch (alt8) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  				{  					DebugLocation (105' 60);  					not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (8);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (106' 4);  		FilterTreeNode newProperty = new Property (propertySegments);  		if ((inverse != null ? inverse.Text : default(string)) == "?")  			filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  		else {  			if ((not != null ? not.Text : default(string)) == "!")  				newProperty.ToggleInversed ();  			filterNode = newProperty;  		}  	}  	break;  case 4:  	DebugEnterAlt (4);  	// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  	{  		DebugLocation (116' 4);  		STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  		DebugLocation (117' 4);  		string stringText = (STRING7 != null ? STRING7.Text : default(string));  		stringText = stringText.Substring (1' stringText.Length - 2);  		filterNode = new Value (stringText);  	}  	break;  case 5:  	DebugEnterAlt (5);  	// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  	{  		DebugLocation (122' 4);  		REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  		DebugLocation (123' 4);  		string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  		regexText = regexText.Substring (1' regexText.Length - 2);  		filterNode = new RegExp (regexText);  	}  	break;  case 6:  	DebugEnterAlt (6);  	// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  	{  		DebugLocation (128' 4);  		NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  		DebugLocation (129' 4);  		filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  	}  	break;  case 7:  	DebugEnterAlt (7);  	// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  	{  		DebugLocation (132' 4);  		Match (input' TRUE' Follow._TRUE_in_filterExpr271);  		DebugLocation (133' 4);  		filterNode = new Value (true);  	}  	break;  case 8:  	DebugEnterAlt (8);  	// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  	{  		DebugLocation (136' 4);  		Match (input' FALSE' Follow._FALSE_in_filterExpr281);  		DebugLocation (137' 4);  		filterNode = new Value (false);  	}  	break;  case 9:  	DebugEnterAlt (9);  	// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  	{  		DebugLocation (140' 4);  		Match (input' NULL' Follow._NULL_in_filterExpr291);  		DebugLocation (141' 4);  		filterNode = new Value (null);  	}  	break;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: switch (alt9) {  case 1:  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  	{  		DebugLocation (64' 4);  		DebugLocation (64' 6);  		PushFollow (Follow._comparator_in_filterExpr175);  		comparator6 = comparator ();  		PopFollow ();  		Match (input' TokenTypes.Down' null);  		DebugLocation (64' 18);  		PushFollow (Follow._filterExpr_in_filterExpr179);  		a = filterExpr ();  		PopFollow ();  		DebugLocation (64' 31);  		PushFollow (Follow._filterExpr_in_filterExpr183);  		b = filterExpr ();  		PopFollow ();  		Match (input' TokenTypes.Up' null);  		DebugLocation (65' 4);  		Comparator newComparator;  		switch (comparator6) {  		case "=":  			newComparator = Comparator.Equals;  			break;  		case "!=":  			newComparator = Comparator.NotEquals;  			break;  		case ">":  			newComparator = Comparator.Greater;  			break;  		case "<":  			newComparator = Comparator.Less;  			break;  		case ">=":  			newComparator = Comparator.GreaterOrEqual;  			break;  		case "<=":  			newComparator = Comparator.LessOrEqual;  			break;  		case "&":  			newComparator = Comparator.And;  			break;  		case "|":  			newComparator = Comparator.Or;  			break;  		default:  			newComparator = Comparator.Equals;  			break;  		}  		filterNode = new BoolExpression (a' newComparator' b);  	}  	break;  case 2:  	DebugEnterAlt (2);  	// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  	{  		DebugLocation (98' 4);  		DebugLocation (98' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr195);  		Match (input' TokenTypes.Down' null);  		DebugLocation (98' 12);  		PushFollow (Follow._filterExpr_in_filterExpr199);  		f = filterExpr ();  		PopFollow ();  		DebugLocation (98' 31);  		// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  		int alt6 = 2;  		try {  			DebugEnterSubRule (6);  			try {  				DebugEnterDecision (6' false);  				int LA6_1 = input.LA (1);  				if ((LA6_1 == 24)) {  					alt6 = 1;  				}  			}  			finally {  				DebugExitDecision (6);  			}  			switch (alt6) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  				{  					DebugLocation (98' 31);  					inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (6);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (99' 4);  		FilterTreeNode newNode = f;  		if ((inverse != null ? inverse.Text : default(string)) == "!")  			newNode.ToggleInversed ();  		filterNode = newNode;  	}  	break;  case 3:  	DebugEnterAlt (3);  	// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  	{  		DebugLocation (105' 4);  		DebugLocation (105' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr216);  		Match (input' TokenTypes.Down' null);  		DebugLocation (105' 12);  		PushFollow (Follow._propertyChain_in_filterExpr219);  		propertyChain (propertySegments);  		PopFollow ();  		DebugLocation (105' 51);  		// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  		int alt7 = 2;  		try {  			DebugEnterSubRule (7);  			try {  				DebugEnterDecision (7' false);  				int LA7_1 = input.LA (1);  				if ((LA7_1 == 31)) {  					alt7 = 1;  				}  			}  			finally {  				DebugExitDecision (7);  			}  			switch (alt7) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  				{  					DebugLocation (105' 51);  					inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (7);  		}  		DebugLocation (105' 60);  		// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  		int alt8 = 2;  		try {  			DebugEnterSubRule (8);  			try {  				DebugEnterDecision (8' false);  				int LA8_1 = input.LA (1);  				if ((LA8_1 == 24)) {  					alt8 = 1;  				}  			}  			finally {  				DebugExitDecision (8);  			}  			switch (alt8) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  				{  					DebugLocation (105' 60);  					not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (8);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (106' 4);  		FilterTreeNode newProperty = new Property (propertySegments);  		if ((inverse != null ? inverse.Text : default(string)) == "?")  			filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  		else {  			if ((not != null ? not.Text : default(string)) == "!")  				newProperty.ToggleInversed ();  			filterNode = newProperty;  		}  	}  	break;  case 4:  	DebugEnterAlt (4);  	// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  	{  		DebugLocation (116' 4);  		STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  		DebugLocation (117' 4);  		string stringText = (STRING7 != null ? STRING7.Text : default(string));  		stringText = stringText.Substring (1' stringText.Length - 2);  		filterNode = new Value (stringText);  	}  	break;  case 5:  	DebugEnterAlt (5);  	// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  	{  		DebugLocation (122' 4);  		REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  		DebugLocation (123' 4);  		string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  		regexText = regexText.Substring (1' regexText.Length - 2);  		filterNode = new RegExp (regexText);  	}  	break;  case 6:  	DebugEnterAlt (6);  	// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  	{  		DebugLocation (128' 4);  		NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  		DebugLocation (129' 4);  		filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  	}  	break;  case 7:  	DebugEnterAlt (7);  	// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  	{  		DebugLocation (132' 4);  		Match (input' TRUE' Follow._TRUE_in_filterExpr271);  		DebugLocation (133' 4);  		filterNode = new Value (true);  	}  	break;  case 8:  	DebugEnterAlt (8);  	// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  	{  		DebugLocation (136' 4);  		Match (input' FALSE' Follow._FALSE_in_filterExpr281);  		DebugLocation (137' 4);  		filterNode = new Value (false);  	}  	break;  case 9:  	DebugEnterAlt (9);  	// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  	{  		DebugLocation (140' 4);  		Match (input' NULL' Follow._NULL_in_filterExpr291);  		DebugLocation (141' 4);  		filterNode = new Value (null);  	}  	break;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: switch (alt9) {  case 1:  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  	{  		DebugLocation (64' 4);  		DebugLocation (64' 6);  		PushFollow (Follow._comparator_in_filterExpr175);  		comparator6 = comparator ();  		PopFollow ();  		Match (input' TokenTypes.Down' null);  		DebugLocation (64' 18);  		PushFollow (Follow._filterExpr_in_filterExpr179);  		a = filterExpr ();  		PopFollow ();  		DebugLocation (64' 31);  		PushFollow (Follow._filterExpr_in_filterExpr183);  		b = filterExpr ();  		PopFollow ();  		Match (input' TokenTypes.Up' null);  		DebugLocation (65' 4);  		Comparator newComparator;  		switch (comparator6) {  		case "=":  			newComparator = Comparator.Equals;  			break;  		case "!=":  			newComparator = Comparator.NotEquals;  			break;  		case ">":  			newComparator = Comparator.Greater;  			break;  		case "<":  			newComparator = Comparator.Less;  			break;  		case ">=":  			newComparator = Comparator.GreaterOrEqual;  			break;  		case "<=":  			newComparator = Comparator.LessOrEqual;  			break;  		case "&":  			newComparator = Comparator.And;  			break;  		case "|":  			newComparator = Comparator.Or;  			break;  		default:  			newComparator = Comparator.Equals;  			break;  		}  		filterNode = new BoolExpression (a' newComparator' b);  	}  	break;  case 2:  	DebugEnterAlt (2);  	// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  	{  		DebugLocation (98' 4);  		DebugLocation (98' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr195);  		Match (input' TokenTypes.Down' null);  		DebugLocation (98' 12);  		PushFollow (Follow._filterExpr_in_filterExpr199);  		f = filterExpr ();  		PopFollow ();  		DebugLocation (98' 31);  		// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  		int alt6 = 2;  		try {  			DebugEnterSubRule (6);  			try {  				DebugEnterDecision (6' false);  				int LA6_1 = input.LA (1);  				if ((LA6_1 == 24)) {  					alt6 = 1;  				}  			}  			finally {  				DebugExitDecision (6);  			}  			switch (alt6) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  				{  					DebugLocation (98' 31);  					inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (6);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (99' 4);  		FilterTreeNode newNode = f;  		if ((inverse != null ? inverse.Text : default(string)) == "!")  			newNode.ToggleInversed ();  		filterNode = newNode;  	}  	break;  case 3:  	DebugEnterAlt (3);  	// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  	{  		DebugLocation (105' 4);  		DebugLocation (105' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr216);  		Match (input' TokenTypes.Down' null);  		DebugLocation (105' 12);  		PushFollow (Follow._propertyChain_in_filterExpr219);  		propertyChain (propertySegments);  		PopFollow ();  		DebugLocation (105' 51);  		// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  		int alt7 = 2;  		try {  			DebugEnterSubRule (7);  			try {  				DebugEnterDecision (7' false);  				int LA7_1 = input.LA (1);  				if ((LA7_1 == 31)) {  					alt7 = 1;  				}  			}  			finally {  				DebugExitDecision (7);  			}  			switch (alt7) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  				{  					DebugLocation (105' 51);  					inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (7);  		}  		DebugLocation (105' 60);  		// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  		int alt8 = 2;  		try {  			DebugEnterSubRule (8);  			try {  				DebugEnterDecision (8' false);  				int LA8_1 = input.LA (1);  				if ((LA8_1 == 24)) {  					alt8 = 1;  				}  			}  			finally {  				DebugExitDecision (8);  			}  			switch (alt8) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  				{  					DebugLocation (105' 60);  					not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (8);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (106' 4);  		FilterTreeNode newProperty = new Property (propertySegments);  		if ((inverse != null ? inverse.Text : default(string)) == "?")  			filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  		else {  			if ((not != null ? not.Text : default(string)) == "!")  				newProperty.ToggleInversed ();  			filterNode = newProperty;  		}  	}  	break;  case 4:  	DebugEnterAlt (4);  	// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  	{  		DebugLocation (116' 4);  		STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  		DebugLocation (117' 4);  		string stringText = (STRING7 != null ? STRING7.Text : default(string));  		stringText = stringText.Substring (1' stringText.Length - 2);  		filterNode = new Value (stringText);  	}  	break;  case 5:  	DebugEnterAlt (5);  	// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  	{  		DebugLocation (122' 4);  		REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  		DebugLocation (123' 4);  		string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  		regexText = regexText.Substring (1' regexText.Length - 2);  		filterNode = new RegExp (regexText);  	}  	break;  case 6:  	DebugEnterAlt (6);  	// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  	{  		DebugLocation (128' 4);  		NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  		DebugLocation (129' 4);  		filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  	}  	break;  case 7:  	DebugEnterAlt (7);  	// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  	{  		DebugLocation (132' 4);  		Match (input' TRUE' Follow._TRUE_in_filterExpr271);  		DebugLocation (133' 4);  		filterNode = new Value (true);  	}  	break;  case 8:  	DebugEnterAlt (8);  	// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  	{  		DebugLocation (136' 4);  		Match (input' FALSE' Follow._FALSE_in_filterExpr281);  		DebugLocation (137' 4);  		filterNode = new Value (false);  	}  	break;  case 9:  	DebugEnterAlt (9);  	// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  	{  		DebugLocation (140' 4);  		Match (input' NULL' Follow._NULL_in_filterExpr291);  		DebugLocation (141' 4);  		filterNode = new Value (null);  	}  	break;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: switch (alt9) {  case 1:  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  	{  		DebugLocation (64' 4);  		DebugLocation (64' 6);  		PushFollow (Follow._comparator_in_filterExpr175);  		comparator6 = comparator ();  		PopFollow ();  		Match (input' TokenTypes.Down' null);  		DebugLocation (64' 18);  		PushFollow (Follow._filterExpr_in_filterExpr179);  		a = filterExpr ();  		PopFollow ();  		DebugLocation (64' 31);  		PushFollow (Follow._filterExpr_in_filterExpr183);  		b = filterExpr ();  		PopFollow ();  		Match (input' TokenTypes.Up' null);  		DebugLocation (65' 4);  		Comparator newComparator;  		switch (comparator6) {  		case "=":  			newComparator = Comparator.Equals;  			break;  		case "!=":  			newComparator = Comparator.NotEquals;  			break;  		case ">":  			newComparator = Comparator.Greater;  			break;  		case "<":  			newComparator = Comparator.Less;  			break;  		case ">=":  			newComparator = Comparator.GreaterOrEqual;  			break;  		case "<=":  			newComparator = Comparator.LessOrEqual;  			break;  		case "&":  			newComparator = Comparator.And;  			break;  		case "|":  			newComparator = Comparator.Or;  			break;  		default:  			newComparator = Comparator.Equals;  			break;  		}  		filterNode = new BoolExpression (a' newComparator' b);  	}  	break;  case 2:  	DebugEnterAlt (2);  	// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  	{  		DebugLocation (98' 4);  		DebugLocation (98' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr195);  		Match (input' TokenTypes.Down' null);  		DebugLocation (98' 12);  		PushFollow (Follow._filterExpr_in_filterExpr199);  		f = filterExpr ();  		PopFollow ();  		DebugLocation (98' 31);  		// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  		int alt6 = 2;  		try {  			DebugEnterSubRule (6);  			try {  				DebugEnterDecision (6' false);  				int LA6_1 = input.LA (1);  				if ((LA6_1 == 24)) {  					alt6 = 1;  				}  			}  			finally {  				DebugExitDecision (6);  			}  			switch (alt6) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  				{  					DebugLocation (98' 31);  					inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (6);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (99' 4);  		FilterTreeNode newNode = f;  		if ((inverse != null ? inverse.Text : default(string)) == "!")  			newNode.ToggleInversed ();  		filterNode = newNode;  	}  	break;  case 3:  	DebugEnterAlt (3);  	// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  	{  		DebugLocation (105' 4);  		DebugLocation (105' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr216);  		Match (input' TokenTypes.Down' null);  		DebugLocation (105' 12);  		PushFollow (Follow._propertyChain_in_filterExpr219);  		propertyChain (propertySegments);  		PopFollow ();  		DebugLocation (105' 51);  		// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  		int alt7 = 2;  		try {  			DebugEnterSubRule (7);  			try {  				DebugEnterDecision (7' false);  				int LA7_1 = input.LA (1);  				if ((LA7_1 == 31)) {  					alt7 = 1;  				}  			}  			finally {  				DebugExitDecision (7);  			}  			switch (alt7) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  				{  					DebugLocation (105' 51);  					inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (7);  		}  		DebugLocation (105' 60);  		// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  		int alt8 = 2;  		try {  			DebugEnterSubRule (8);  			try {  				DebugEnterDecision (8' false);  				int LA8_1 = input.LA (1);  				if ((LA8_1 == 24)) {  					alt8 = 1;  				}  			}  			finally {  				DebugExitDecision (8);  			}  			switch (alt8) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  				{  					DebugLocation (105' 60);  					not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (8);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (106' 4);  		FilterTreeNode newProperty = new Property (propertySegments);  		if ((inverse != null ? inverse.Text : default(string)) == "?")  			filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  		else {  			if ((not != null ? not.Text : default(string)) == "!")  				newProperty.ToggleInversed ();  			filterNode = newProperty;  		}  	}  	break;  case 4:  	DebugEnterAlt (4);  	// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  	{  		DebugLocation (116' 4);  		STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  		DebugLocation (117' 4);  		string stringText = (STRING7 != null ? STRING7.Text : default(string));  		stringText = stringText.Substring (1' stringText.Length - 2);  		filterNode = new Value (stringText);  	}  	break;  case 5:  	DebugEnterAlt (5);  	// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  	{  		DebugLocation (122' 4);  		REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  		DebugLocation (123' 4);  		string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  		regexText = regexText.Substring (1' regexText.Length - 2);  		filterNode = new RegExp (regexText);  	}  	break;  case 6:  	DebugEnterAlt (6);  	// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  	{  		DebugLocation (128' 4);  		NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  		DebugLocation (129' 4);  		filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  	}  	break;  case 7:  	DebugEnterAlt (7);  	// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  	{  		DebugLocation (132' 4);  		Match (input' TRUE' Follow._TRUE_in_filterExpr271);  		DebugLocation (133' 4);  		filterNode = new Value (true);  	}  	break;  case 8:  	DebugEnterAlt (8);  	// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  	{  		DebugLocation (136' 4);  		Match (input' FALSE' Follow._FALSE_in_filterExpr281);  		DebugLocation (137' 4);  		filterNode = new Value (false);  	}  	break;  case 9:  	DebugEnterAlt (9);  	// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  	{  		DebugLocation (140' 4);  		Match (input' NULL' Follow._NULL_in_filterExpr291);  		DebugLocation (141' 4);  		filterNode = new Value (null);  	}  	break;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: switch (alt9) {  case 1:  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  	{  		DebugLocation (64' 4);  		DebugLocation (64' 6);  		PushFollow (Follow._comparator_in_filterExpr175);  		comparator6 = comparator ();  		PopFollow ();  		Match (input' TokenTypes.Down' null);  		DebugLocation (64' 18);  		PushFollow (Follow._filterExpr_in_filterExpr179);  		a = filterExpr ();  		PopFollow ();  		DebugLocation (64' 31);  		PushFollow (Follow._filterExpr_in_filterExpr183);  		b = filterExpr ();  		PopFollow ();  		Match (input' TokenTypes.Up' null);  		DebugLocation (65' 4);  		Comparator newComparator;  		switch (comparator6) {  		case "=":  			newComparator = Comparator.Equals;  			break;  		case "!=":  			newComparator = Comparator.NotEquals;  			break;  		case ">":  			newComparator = Comparator.Greater;  			break;  		case "<":  			newComparator = Comparator.Less;  			break;  		case ">=":  			newComparator = Comparator.GreaterOrEqual;  			break;  		case "<=":  			newComparator = Comparator.LessOrEqual;  			break;  		case "&":  			newComparator = Comparator.And;  			break;  		case "|":  			newComparator = Comparator.Or;  			break;  		default:  			newComparator = Comparator.Equals;  			break;  		}  		filterNode = new BoolExpression (a' newComparator' b);  	}  	break;  case 2:  	DebugEnterAlt (2);  	// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  	{  		DebugLocation (98' 4);  		DebugLocation (98' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr195);  		Match (input' TokenTypes.Down' null);  		DebugLocation (98' 12);  		PushFollow (Follow._filterExpr_in_filterExpr199);  		f = filterExpr ();  		PopFollow ();  		DebugLocation (98' 31);  		// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  		int alt6 = 2;  		try {  			DebugEnterSubRule (6);  			try {  				DebugEnterDecision (6' false);  				int LA6_1 = input.LA (1);  				if ((LA6_1 == 24)) {  					alt6 = 1;  				}  			}  			finally {  				DebugExitDecision (6);  			}  			switch (alt6) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  				{  					DebugLocation (98' 31);  					inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (6);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (99' 4);  		FilterTreeNode newNode = f;  		if ((inverse != null ? inverse.Text : default(string)) == "!")  			newNode.ToggleInversed ();  		filterNode = newNode;  	}  	break;  case 3:  	DebugEnterAlt (3);  	// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  	{  		DebugLocation (105' 4);  		DebugLocation (105' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr216);  		Match (input' TokenTypes.Down' null);  		DebugLocation (105' 12);  		PushFollow (Follow._propertyChain_in_filterExpr219);  		propertyChain (propertySegments);  		PopFollow ();  		DebugLocation (105' 51);  		// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  		int alt7 = 2;  		try {  			DebugEnterSubRule (7);  			try {  				DebugEnterDecision (7' false);  				int LA7_1 = input.LA (1);  				if ((LA7_1 == 31)) {  					alt7 = 1;  				}  			}  			finally {  				DebugExitDecision (7);  			}  			switch (alt7) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  				{  					DebugLocation (105' 51);  					inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (7);  		}  		DebugLocation (105' 60);  		// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  		int alt8 = 2;  		try {  			DebugEnterSubRule (8);  			try {  				DebugEnterDecision (8' false);  				int LA8_1 = input.LA (1);  				if ((LA8_1 == 24)) {  					alt8 = 1;  				}  			}  			finally {  				DebugExitDecision (8);  			}  			switch (alt8) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  				{  					DebugLocation (105' 60);  					not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (8);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (106' 4);  		FilterTreeNode newProperty = new Property (propertySegments);  		if ((inverse != null ? inverse.Text : default(string)) == "?")  			filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  		else {  			if ((not != null ? not.Text : default(string)) == "!")  				newProperty.ToggleInversed ();  			filterNode = newProperty;  		}  	}  	break;  case 4:  	DebugEnterAlt (4);  	// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  	{  		DebugLocation (116' 4);  		STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  		DebugLocation (117' 4);  		string stringText = (STRING7 != null ? STRING7.Text : default(string));  		stringText = stringText.Substring (1' stringText.Length - 2);  		filterNode = new Value (stringText);  	}  	break;  case 5:  	DebugEnterAlt (5);  	// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  	{  		DebugLocation (122' 4);  		REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  		DebugLocation (123' 4);  		string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  		regexText = regexText.Substring (1' regexText.Length - 2);  		filterNode = new RegExp (regexText);  	}  	break;  case 6:  	DebugEnterAlt (6);  	// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  	{  		DebugLocation (128' 4);  		NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  		DebugLocation (129' 4);  		filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  	}  	break;  case 7:  	DebugEnterAlt (7);  	// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  	{  		DebugLocation (132' 4);  		Match (input' TRUE' Follow._TRUE_in_filterExpr271);  		DebugLocation (133' 4);  		filterNode = new Value (true);  	}  	break;  case 8:  	DebugEnterAlt (8);  	// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  	{  		DebugLocation (136' 4);  		Match (input' FALSE' Follow._FALSE_in_filterExpr281);  		DebugLocation (137' 4);  		filterNode = new Value (false);  	}  	break;  case 9:  	DebugEnterAlt (9);  	// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  	{  		DebugLocation (140' 4);  		Match (input' NULL' Follow._NULL_in_filterExpr291);  		DebugLocation (141' 4);  		filterNode = new Value (null);  	}  	break;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: switch (alt9) {  case 1:  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  	{  		DebugLocation (64' 4);  		DebugLocation (64' 6);  		PushFollow (Follow._comparator_in_filterExpr175);  		comparator6 = comparator ();  		PopFollow ();  		Match (input' TokenTypes.Down' null);  		DebugLocation (64' 18);  		PushFollow (Follow._filterExpr_in_filterExpr179);  		a = filterExpr ();  		PopFollow ();  		DebugLocation (64' 31);  		PushFollow (Follow._filterExpr_in_filterExpr183);  		b = filterExpr ();  		PopFollow ();  		Match (input' TokenTypes.Up' null);  		DebugLocation (65' 4);  		Comparator newComparator;  		switch (comparator6) {  		case "=":  			newComparator = Comparator.Equals;  			break;  		case "!=":  			newComparator = Comparator.NotEquals;  			break;  		case ">":  			newComparator = Comparator.Greater;  			break;  		case "<":  			newComparator = Comparator.Less;  			break;  		case ">=":  			newComparator = Comparator.GreaterOrEqual;  			break;  		case "<=":  			newComparator = Comparator.LessOrEqual;  			break;  		case "&":  			newComparator = Comparator.And;  			break;  		case "|":  			newComparator = Comparator.Or;  			break;  		default:  			newComparator = Comparator.Equals;  			break;  		}  		filterNode = new BoolExpression (a' newComparator' b);  	}  	break;  case 2:  	DebugEnterAlt (2);  	// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  	{  		DebugLocation (98' 4);  		DebugLocation (98' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr195);  		Match (input' TokenTypes.Down' null);  		DebugLocation (98' 12);  		PushFollow (Follow._filterExpr_in_filterExpr199);  		f = filterExpr ();  		PopFollow ();  		DebugLocation (98' 31);  		// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  		int alt6 = 2;  		try {  			DebugEnterSubRule (6);  			try {  				DebugEnterDecision (6' false);  				int LA6_1 = input.LA (1);  				if ((LA6_1 == 24)) {  					alt6 = 1;  				}  			}  			finally {  				DebugExitDecision (6);  			}  			switch (alt6) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  				{  					DebugLocation (98' 31);  					inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (6);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (99' 4);  		FilterTreeNode newNode = f;  		if ((inverse != null ? inverse.Text : default(string)) == "!")  			newNode.ToggleInversed ();  		filterNode = newNode;  	}  	break;  case 3:  	DebugEnterAlt (3);  	// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  	{  		DebugLocation (105' 4);  		DebugLocation (105' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr216);  		Match (input' TokenTypes.Down' null);  		DebugLocation (105' 12);  		PushFollow (Follow._propertyChain_in_filterExpr219);  		propertyChain (propertySegments);  		PopFollow ();  		DebugLocation (105' 51);  		// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  		int alt7 = 2;  		try {  			DebugEnterSubRule (7);  			try {  				DebugEnterDecision (7' false);  				int LA7_1 = input.LA (1);  				if ((LA7_1 == 31)) {  					alt7 = 1;  				}  			}  			finally {  				DebugExitDecision (7);  			}  			switch (alt7) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  				{  					DebugLocation (105' 51);  					inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (7);  		}  		DebugLocation (105' 60);  		// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  		int alt8 = 2;  		try {  			DebugEnterSubRule (8);  			try {  				DebugEnterDecision (8' false);  				int LA8_1 = input.LA (1);  				if ((LA8_1 == 24)) {  					alt8 = 1;  				}  			}  			finally {  				DebugExitDecision (8);  			}  			switch (alt8) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  				{  					DebugLocation (105' 60);  					not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (8);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (106' 4);  		FilterTreeNode newProperty = new Property (propertySegments);  		if ((inverse != null ? inverse.Text : default(string)) == "?")  			filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  		else {  			if ((not != null ? not.Text : default(string)) == "!")  				newProperty.ToggleInversed ();  			filterNode = newProperty;  		}  	}  	break;  case 4:  	DebugEnterAlt (4);  	// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  	{  		DebugLocation (116' 4);  		STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  		DebugLocation (117' 4);  		string stringText = (STRING7 != null ? STRING7.Text : default(string));  		stringText = stringText.Substring (1' stringText.Length - 2);  		filterNode = new Value (stringText);  	}  	break;  case 5:  	DebugEnterAlt (5);  	// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  	{  		DebugLocation (122' 4);  		REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  		DebugLocation (123' 4);  		string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  		regexText = regexText.Substring (1' regexText.Length - 2);  		filterNode = new RegExp (regexText);  	}  	break;  case 6:  	DebugEnterAlt (6);  	// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  	{  		DebugLocation (128' 4);  		NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  		DebugLocation (129' 4);  		filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  	}  	break;  case 7:  	DebugEnterAlt (7);  	// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  	{  		DebugLocation (132' 4);  		Match (input' TRUE' Follow._TRUE_in_filterExpr271);  		DebugLocation (133' 4);  		filterNode = new Value (true);  	}  	break;  case 8:  	DebugEnterAlt (8);  	// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  	{  		DebugLocation (136' 4);  		Match (input' FALSE' Follow._FALSE_in_filterExpr281);  		DebugLocation (137' 4);  		filterNode = new Value (false);  	}  	break;  case 9:  	DebugEnterAlt (9);  	// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  	{  		DebugLocation (140' 4);  		Match (input' NULL' Follow._NULL_in_filterExpr291);  		DebugLocation (141' 4);  		filterNode = new Value (null);  	}  	break;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: switch (alt9) {  case 1:  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  	{  		DebugLocation (64' 4);  		DebugLocation (64' 6);  		PushFollow (Follow._comparator_in_filterExpr175);  		comparator6 = comparator ();  		PopFollow ();  		Match (input' TokenTypes.Down' null);  		DebugLocation (64' 18);  		PushFollow (Follow._filterExpr_in_filterExpr179);  		a = filterExpr ();  		PopFollow ();  		DebugLocation (64' 31);  		PushFollow (Follow._filterExpr_in_filterExpr183);  		b = filterExpr ();  		PopFollow ();  		Match (input' TokenTypes.Up' null);  		DebugLocation (65' 4);  		Comparator newComparator;  		switch (comparator6) {  		case "=":  			newComparator = Comparator.Equals;  			break;  		case "!=":  			newComparator = Comparator.NotEquals;  			break;  		case ">":  			newComparator = Comparator.Greater;  			break;  		case "<":  			newComparator = Comparator.Less;  			break;  		case ">=":  			newComparator = Comparator.GreaterOrEqual;  			break;  		case "<=":  			newComparator = Comparator.LessOrEqual;  			break;  		case "&":  			newComparator = Comparator.And;  			break;  		case "|":  			newComparator = Comparator.Or;  			break;  		default:  			newComparator = Comparator.Equals;  			break;  		}  		filterNode = new BoolExpression (a' newComparator' b);  	}  	break;  case 2:  	DebugEnterAlt (2);  	// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  	{  		DebugLocation (98' 4);  		DebugLocation (98' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr195);  		Match (input' TokenTypes.Down' null);  		DebugLocation (98' 12);  		PushFollow (Follow._filterExpr_in_filterExpr199);  		f = filterExpr ();  		PopFollow ();  		DebugLocation (98' 31);  		// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  		int alt6 = 2;  		try {  			DebugEnterSubRule (6);  			try {  				DebugEnterDecision (6' false);  				int LA6_1 = input.LA (1);  				if ((LA6_1 == 24)) {  					alt6 = 1;  				}  			}  			finally {  				DebugExitDecision (6);  			}  			switch (alt6) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  				{  					DebugLocation (98' 31);  					inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (6);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (99' 4);  		FilterTreeNode newNode = f;  		if ((inverse != null ? inverse.Text : default(string)) == "!")  			newNode.ToggleInversed ();  		filterNode = newNode;  	}  	break;  case 3:  	DebugEnterAlt (3);  	// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  	{  		DebugLocation (105' 4);  		DebugLocation (105' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr216);  		Match (input' TokenTypes.Down' null);  		DebugLocation (105' 12);  		PushFollow (Follow._propertyChain_in_filterExpr219);  		propertyChain (propertySegments);  		PopFollow ();  		DebugLocation (105' 51);  		// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  		int alt7 = 2;  		try {  			DebugEnterSubRule (7);  			try {  				DebugEnterDecision (7' false);  				int LA7_1 = input.LA (1);  				if ((LA7_1 == 31)) {  					alt7 = 1;  				}  			}  			finally {  				DebugExitDecision (7);  			}  			switch (alt7) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  				{  					DebugLocation (105' 51);  					inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (7);  		}  		DebugLocation (105' 60);  		// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  		int alt8 = 2;  		try {  			DebugEnterSubRule (8);  			try {  				DebugEnterDecision (8' false);  				int LA8_1 = input.LA (1);  				if ((LA8_1 == 24)) {  					alt8 = 1;  				}  			}  			finally {  				DebugExitDecision (8);  			}  			switch (alt8) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  				{  					DebugLocation (105' 60);  					not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (8);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (106' 4);  		FilterTreeNode newProperty = new Property (propertySegments);  		if ((inverse != null ? inverse.Text : default(string)) == "?")  			filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  		else {  			if ((not != null ? not.Text : default(string)) == "!")  				newProperty.ToggleInversed ();  			filterNode = newProperty;  		}  	}  	break;  case 4:  	DebugEnterAlt (4);  	// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  	{  		DebugLocation (116' 4);  		STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  		DebugLocation (117' 4);  		string stringText = (STRING7 != null ? STRING7.Text : default(string));  		stringText = stringText.Substring (1' stringText.Length - 2);  		filterNode = new Value (stringText);  	}  	break;  case 5:  	DebugEnterAlt (5);  	// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  	{  		DebugLocation (122' 4);  		REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  		DebugLocation (123' 4);  		string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  		regexText = regexText.Substring (1' regexText.Length - 2);  		filterNode = new RegExp (regexText);  	}  	break;  case 6:  	DebugEnterAlt (6);  	// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  	{  		DebugLocation (128' 4);  		NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  		DebugLocation (129' 4);  		filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  	}  	break;  case 7:  	DebugEnterAlt (7);  	// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  	{  		DebugLocation (132' 4);  		Match (input' TRUE' Follow._TRUE_in_filterExpr271);  		DebugLocation (133' 4);  		filterNode = new Value (true);  	}  	break;  case 8:  	DebugEnterAlt (8);  	// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  	{  		DebugLocation (136' 4);  		Match (input' FALSE' Follow._FALSE_in_filterExpr281);  		DebugLocation (137' 4);  		filterNode = new Value (false);  	}  	break;  case 9:  	DebugEnterAlt (9);  	// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  	{  		DebugLocation (140' 4);  		Match (input' NULL' Follow._NULL_in_filterExpr291);  		DebugLocation (141' 4);  		filterNode = new Value (null);  	}  	break;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: switch (alt9) {  case 1:  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  	{  		DebugLocation (64' 4);  		DebugLocation (64' 6);  		PushFollow (Follow._comparator_in_filterExpr175);  		comparator6 = comparator ();  		PopFollow ();  		Match (input' TokenTypes.Down' null);  		DebugLocation (64' 18);  		PushFollow (Follow._filterExpr_in_filterExpr179);  		a = filterExpr ();  		PopFollow ();  		DebugLocation (64' 31);  		PushFollow (Follow._filterExpr_in_filterExpr183);  		b = filterExpr ();  		PopFollow ();  		Match (input' TokenTypes.Up' null);  		DebugLocation (65' 4);  		Comparator newComparator;  		switch (comparator6) {  		case "=":  			newComparator = Comparator.Equals;  			break;  		case "!=":  			newComparator = Comparator.NotEquals;  			break;  		case ">":  			newComparator = Comparator.Greater;  			break;  		case "<":  			newComparator = Comparator.Less;  			break;  		case ">=":  			newComparator = Comparator.GreaterOrEqual;  			break;  		case "<=":  			newComparator = Comparator.LessOrEqual;  			break;  		case "&":  			newComparator = Comparator.And;  			break;  		case "|":  			newComparator = Comparator.Or;  			break;  		default:  			newComparator = Comparator.Equals;  			break;  		}  		filterNode = new BoolExpression (a' newComparator' b);  	}  	break;  case 2:  	DebugEnterAlt (2);  	// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  	{  		DebugLocation (98' 4);  		DebugLocation (98' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr195);  		Match (input' TokenTypes.Down' null);  		DebugLocation (98' 12);  		PushFollow (Follow._filterExpr_in_filterExpr199);  		f = filterExpr ();  		PopFollow ();  		DebugLocation (98' 31);  		// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  		int alt6 = 2;  		try {  			DebugEnterSubRule (6);  			try {  				DebugEnterDecision (6' false);  				int LA6_1 = input.LA (1);  				if ((LA6_1 == 24)) {  					alt6 = 1;  				}  			}  			finally {  				DebugExitDecision (6);  			}  			switch (alt6) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  				{  					DebugLocation (98' 31);  					inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (6);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (99' 4);  		FilterTreeNode newNode = f;  		if ((inverse != null ? inverse.Text : default(string)) == "!")  			newNode.ToggleInversed ();  		filterNode = newNode;  	}  	break;  case 3:  	DebugEnterAlt (3);  	// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  	{  		DebugLocation (105' 4);  		DebugLocation (105' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr216);  		Match (input' TokenTypes.Down' null);  		DebugLocation (105' 12);  		PushFollow (Follow._propertyChain_in_filterExpr219);  		propertyChain (propertySegments);  		PopFollow ();  		DebugLocation (105' 51);  		// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  		int alt7 = 2;  		try {  			DebugEnterSubRule (7);  			try {  				DebugEnterDecision (7' false);  				int LA7_1 = input.LA (1);  				if ((LA7_1 == 31)) {  					alt7 = 1;  				}  			}  			finally {  				DebugExitDecision (7);  			}  			switch (alt7) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  				{  					DebugLocation (105' 51);  					inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (7);  		}  		DebugLocation (105' 60);  		// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  		int alt8 = 2;  		try {  			DebugEnterSubRule (8);  			try {  				DebugEnterDecision (8' false);  				int LA8_1 = input.LA (1);  				if ((LA8_1 == 24)) {  					alt8 = 1;  				}  			}  			finally {  				DebugExitDecision (8);  			}  			switch (alt8) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  				{  					DebugLocation (105' 60);  					not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (8);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (106' 4);  		FilterTreeNode newProperty = new Property (propertySegments);  		if ((inverse != null ? inverse.Text : default(string)) == "?")  			filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  		else {  			if ((not != null ? not.Text : default(string)) == "!")  				newProperty.ToggleInversed ();  			filterNode = newProperty;  		}  	}  	break;  case 4:  	DebugEnterAlt (4);  	// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  	{  		DebugLocation (116' 4);  		STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  		DebugLocation (117' 4);  		string stringText = (STRING7 != null ? STRING7.Text : default(string));  		stringText = stringText.Substring (1' stringText.Length - 2);  		filterNode = new Value (stringText);  	}  	break;  case 5:  	DebugEnterAlt (5);  	// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  	{  		DebugLocation (122' 4);  		REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  		DebugLocation (123' 4);  		string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  		regexText = regexText.Substring (1' regexText.Length - 2);  		filterNode = new RegExp (regexText);  	}  	break;  case 6:  	DebugEnterAlt (6);  	// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  	{  		DebugLocation (128' 4);  		NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  		DebugLocation (129' 4);  		filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  	}  	break;  case 7:  	DebugEnterAlt (7);  	// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  	{  		DebugLocation (132' 4);  		Match (input' TRUE' Follow._TRUE_in_filterExpr271);  		DebugLocation (133' 4);  		filterNode = new Value (true);  	}  	break;  case 8:  	DebugEnterAlt (8);  	// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  	{  		DebugLocation (136' 4);  		Match (input' FALSE' Follow._FALSE_in_filterExpr281);  		DebugLocation (137' 4);  		filterNode = new Value (false);  	}  	break;  case 9:  	DebugEnterAlt (9);  	// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  	{  		DebugLocation (140' 4);  		Match (input' NULL' Follow._NULL_in_filterExpr291);  		DebugLocation (141' 4);  		filterNode = new Value (null);  	}  	break;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: switch (alt9) {  case 1:  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  	{  		DebugLocation (64' 4);  		DebugLocation (64' 6);  		PushFollow (Follow._comparator_in_filterExpr175);  		comparator6 = comparator ();  		PopFollow ();  		Match (input' TokenTypes.Down' null);  		DebugLocation (64' 18);  		PushFollow (Follow._filterExpr_in_filterExpr179);  		a = filterExpr ();  		PopFollow ();  		DebugLocation (64' 31);  		PushFollow (Follow._filterExpr_in_filterExpr183);  		b = filterExpr ();  		PopFollow ();  		Match (input' TokenTypes.Up' null);  		DebugLocation (65' 4);  		Comparator newComparator;  		switch (comparator6) {  		case "=":  			newComparator = Comparator.Equals;  			break;  		case "!=":  			newComparator = Comparator.NotEquals;  			break;  		case ">":  			newComparator = Comparator.Greater;  			break;  		case "<":  			newComparator = Comparator.Less;  			break;  		case ">=":  			newComparator = Comparator.GreaterOrEqual;  			break;  		case "<=":  			newComparator = Comparator.LessOrEqual;  			break;  		case "&":  			newComparator = Comparator.And;  			break;  		case "|":  			newComparator = Comparator.Or;  			break;  		default:  			newComparator = Comparator.Equals;  			break;  		}  		filterNode = new BoolExpression (a' newComparator' b);  	}  	break;  case 2:  	DebugEnterAlt (2);  	// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  	{  		DebugLocation (98' 4);  		DebugLocation (98' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr195);  		Match (input' TokenTypes.Down' null);  		DebugLocation (98' 12);  		PushFollow (Follow._filterExpr_in_filterExpr199);  		f = filterExpr ();  		PopFollow ();  		DebugLocation (98' 31);  		// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  		int alt6 = 2;  		try {  			DebugEnterSubRule (6);  			try {  				DebugEnterDecision (6' false);  				int LA6_1 = input.LA (1);  				if ((LA6_1 == 24)) {  					alt6 = 1;  				}  			}  			finally {  				DebugExitDecision (6);  			}  			switch (alt6) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  				{  					DebugLocation (98' 31);  					inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (6);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (99' 4);  		FilterTreeNode newNode = f;  		if ((inverse != null ? inverse.Text : default(string)) == "!")  			newNode.ToggleInversed ();  		filterNode = newNode;  	}  	break;  case 3:  	DebugEnterAlt (3);  	// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  	{  		DebugLocation (105' 4);  		DebugLocation (105' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr216);  		Match (input' TokenTypes.Down' null);  		DebugLocation (105' 12);  		PushFollow (Follow._propertyChain_in_filterExpr219);  		propertyChain (propertySegments);  		PopFollow ();  		DebugLocation (105' 51);  		// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  		int alt7 = 2;  		try {  			DebugEnterSubRule (7);  			try {  				DebugEnterDecision (7' false);  				int LA7_1 = input.LA (1);  				if ((LA7_1 == 31)) {  					alt7 = 1;  				}  			}  			finally {  				DebugExitDecision (7);  			}  			switch (alt7) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  				{  					DebugLocation (105' 51);  					inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (7);  		}  		DebugLocation (105' 60);  		// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  		int alt8 = 2;  		try {  			DebugEnterSubRule (8);  			try {  				DebugEnterDecision (8' false);  				int LA8_1 = input.LA (1);  				if ((LA8_1 == 24)) {  					alt8 = 1;  				}  			}  			finally {  				DebugExitDecision (8);  			}  			switch (alt8) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  				{  					DebugLocation (105' 60);  					not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (8);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (106' 4);  		FilterTreeNode newProperty = new Property (propertySegments);  		if ((inverse != null ? inverse.Text : default(string)) == "?")  			filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  		else {  			if ((not != null ? not.Text : default(string)) == "!")  				newProperty.ToggleInversed ();  			filterNode = newProperty;  		}  	}  	break;  case 4:  	DebugEnterAlt (4);  	// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  	{  		DebugLocation (116' 4);  		STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  		DebugLocation (117' 4);  		string stringText = (STRING7 != null ? STRING7.Text : default(string));  		stringText = stringText.Substring (1' stringText.Length - 2);  		filterNode = new Value (stringText);  	}  	break;  case 5:  	DebugEnterAlt (5);  	// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  	{  		DebugLocation (122' 4);  		REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  		DebugLocation (123' 4);  		string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  		regexText = regexText.Substring (1' regexText.Length - 2);  		filterNode = new RegExp (regexText);  	}  	break;  case 6:  	DebugEnterAlt (6);  	// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  	{  		DebugLocation (128' 4);  		NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  		DebugLocation (129' 4);  		filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  	}  	break;  case 7:  	DebugEnterAlt (7);  	// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  	{  		DebugLocation (132' 4);  		Match (input' TRUE' Follow._TRUE_in_filterExpr271);  		DebugLocation (133' 4);  		filterNode = new Value (true);  	}  	break;  case 8:  	DebugEnterAlt (8);  	// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  	{  		DebugLocation (136' 4);  		Match (input' FALSE' Follow._FALSE_in_filterExpr281);  		DebugLocation (137' 4);  		filterNode = new Value (false);  	}  	break;  case 9:  	DebugEnterAlt (9);  	// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  	{  		DebugLocation (140' 4);  		Match (input' NULL' Follow._NULL_in_filterExpr291);  		DebugLocation (141' 4);  		filterNode = new Value (null);  	}  	break;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: switch (alt9) {  case 1:  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:64:4: ^( comparator a= filterExpr b= filterExpr )  	{  		DebugLocation (64' 4);  		DebugLocation (64' 6);  		PushFollow (Follow._comparator_in_filterExpr175);  		comparator6 = comparator ();  		PopFollow ();  		Match (input' TokenTypes.Down' null);  		DebugLocation (64' 18);  		PushFollow (Follow._filterExpr_in_filterExpr179);  		a = filterExpr ();  		PopFollow ();  		DebugLocation (64' 31);  		PushFollow (Follow._filterExpr_in_filterExpr183);  		b = filterExpr ();  		PopFollow ();  		Match (input' TokenTypes.Up' null);  		DebugLocation (65' 4);  		Comparator newComparator;  		switch (comparator6) {  		case "=":  			newComparator = Comparator.Equals;  			break;  		case "!=":  			newComparator = Comparator.NotEquals;  			break;  		case ">":  			newComparator = Comparator.Greater;  			break;  		case "<":  			newComparator = Comparator.Less;  			break;  		case ">=":  			newComparator = Comparator.GreaterOrEqual;  			break;  		case "<=":  			newComparator = Comparator.LessOrEqual;  			break;  		case "&":  			newComparator = Comparator.And;  			break;  		case "|":  			newComparator = Comparator.Or;  			break;  		default:  			newComparator = Comparator.Equals;  			break;  		}  		filterNode = new BoolExpression (a' newComparator' b);  	}  	break;  case 2:  	DebugEnterAlt (2);  	// ./src/Parser/Grammar/JFLWalker.g:98:4: ^( EXPR f= filterExpr (inverse= '!' )? )  	{  		DebugLocation (98' 4);  		DebugLocation (98' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr195);  		Match (input' TokenTypes.Down' null);  		DebugLocation (98' 12);  		PushFollow (Follow._filterExpr_in_filterExpr199);  		f = filterExpr ();  		PopFollow ();  		DebugLocation (98' 31);  		// ./src/Parser/Grammar/JFLWalker.g:98:31: (inverse= '!' )?  		int alt6 = 2;  		try {  			DebugEnterSubRule (6);  			try {  				DebugEnterDecision (6' false);  				int LA6_1 = input.LA (1);  				if ((LA6_1 == 24)) {  					alt6 = 1;  				}  			}  			finally {  				DebugExitDecision (6);  			}  			switch (alt6) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  				{  					DebugLocation (98' 31);  					inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (6);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (99' 4);  		FilterTreeNode newNode = f;  		if ((inverse != null ? inverse.Text : default(string)) == "!")  			newNode.ToggleInversed ();  		filterNode = newNode;  	}  	break;  case 3:  	DebugEnterAlt (3);  	// ./src/Parser/Grammar/JFLWalker.g:105:4: ^( EXPR propertyChain[propertySegments] (inverse= '?' )? (not= '!' )? )  	{  		DebugLocation (105' 4);  		DebugLocation (105' 6);  		Match (input' EXPR' Follow._EXPR_in_filterExpr216);  		Match (input' TokenTypes.Down' null);  		DebugLocation (105' 12);  		PushFollow (Follow._propertyChain_in_filterExpr219);  		propertyChain (propertySegments);  		PopFollow ();  		DebugLocation (105' 51);  		// ./src/Parser/Grammar/JFLWalker.g:105:51: (inverse= '?' )?  		int alt7 = 2;  		try {  			DebugEnterSubRule (7);  			try {  				DebugEnterDecision (7' false);  				int LA7_1 = input.LA (1);  				if ((LA7_1 == 31)) {  					alt7 = 1;  				}  			}  			finally {  				DebugExitDecision (7);  			}  			switch (alt7) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  				{  					DebugLocation (105' 51);  					inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (7);  		}  		DebugLocation (105' 60);  		// ./src/Parser/Grammar/JFLWalker.g:105:60: (not= '!' )?  		int alt8 = 2;  		try {  			DebugEnterSubRule (8);  			try {  				DebugEnterDecision (8' false);  				int LA8_1 = input.LA (1);  				if ((LA8_1 == 24)) {  					alt8 = 1;  				}  			}  			finally {  				DebugExitDecision (8);  			}  			switch (alt8) {  			case 1:  				DebugEnterAlt (1);  				// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  				{  					DebugLocation (105' 60);  					not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  				}  				break;  			}  		}  		finally {  			DebugExitSubRule (8);  		}  		Match (input' TokenTypes.Up' null);  		DebugLocation (106' 4);  		FilterTreeNode newProperty = new Property (propertySegments);  		if ((inverse != null ? inverse.Text : default(string)) == "?")  			filterNode = new BoolExpression (newProperty' Comparator.Equals' new Existence ());  		else {  			if ((not != null ? not.Text : default(string)) == "!")  				newProperty.ToggleInversed ();  			filterNode = newProperty;  		}  	}  	break;  case 4:  	DebugEnterAlt (4);  	// ./src/Parser/Grammar/JFLWalker.g:116:4: STRING  	{  		DebugLocation (116' 4);  		STRING7 = (CommonTree)Match (input' STRING' Follow._STRING_in_filterExpr241);  		DebugLocation (117' 4);  		string stringText = (STRING7 != null ? STRING7.Text : default(string));  		stringText = stringText.Substring (1' stringText.Length - 2);  		filterNode = new Value (stringText);  	}  	break;  case 5:  	DebugEnterAlt (5);  	// ./src/Parser/Grammar/JFLWalker.g:122:4: REGEX  	{  		DebugLocation (122' 4);  		REGEX8 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_filterExpr251);  		DebugLocation (123' 4);  		string regexText = (REGEX8 != null ? REGEX8.Text : default(string));  		regexText = regexText.Substring (1' regexText.Length - 2);  		filterNode = new RegExp (regexText);  	}  	break;  case 6:  	DebugEnterAlt (6);  	// ./src/Parser/Grammar/JFLWalker.g:128:4: NUMBER  	{  		DebugLocation (128' 4);  		NUMBER9 = (CommonTree)Match (input' NUMBER' Follow._NUMBER_in_filterExpr261);  		DebugLocation (129' 4);  		filterNode = new Value (System.Double.Parse ((NUMBER9 != null ? NUMBER9.Text : default(string))));  	}  	break;  case 7:  	DebugEnterAlt (7);  	// ./src/Parser/Grammar/JFLWalker.g:132:4: TRUE  	{  		DebugLocation (132' 4);  		Match (input' TRUE' Follow._TRUE_in_filterExpr271);  		DebugLocation (133' 4);  		filterNode = new Value (true);  	}  	break;  case 8:  	DebugEnterAlt (8);  	// ./src/Parser/Grammar/JFLWalker.g:136:4: FALSE  	{  		DebugLocation (136' 4);  		Match (input' FALSE' Follow._FALSE_in_filterExpr281);  		DebugLocation (137' 4);  		filterNode = new Value (false);  	}  	break;  case 9:  	DebugEnterAlt (9);  	// ./src/Parser/Grammar/JFLWalker.g:140:4: NULL  	{  		DebugLocation (140' 4);  		Match (input' NULL' Follow._NULL_in_filterExpr291);  		DebugLocation (141' 4);  		filterNode = new Value (null);  	}  	break;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: DebugLocation (64' 4);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: DebugLocation (64' 4);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: DebugLocation (64' 6);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: DebugLocation (64' 6);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: DebugLocation (64' 18);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: DebugLocation (64' 18);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: DebugLocation (64' 31);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: DebugLocation (64' 31);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: DebugLocation (65' 4);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: DebugLocation (65' 4);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: DebugEnterAlt (2);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: DebugLocation (98' 4);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: DebugLocation (98' 4);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: DebugLocation (98' 6);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: DebugLocation (98' 6);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: DebugLocation (98' 12);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: DebugLocation (98' 12);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: DebugLocation (98' 31);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: DebugLocation (98' 31);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	DebugEnterSubRule (6);  	try {  		DebugEnterDecision (6' false);  		int LA6_1 = input.LA (1);  		if ((LA6_1 == 24)) {  			alt6 = 1;  		}  	}  	finally {  		DebugExitDecision (6);  	}  	switch (alt6) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  		{  			DebugLocation (98' 31);  			inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  		}  		break;  	}  }  finally {  	DebugExitSubRule (6);  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	DebugEnterSubRule (6);  	try {  		DebugEnterDecision (6' false);  		int LA6_1 = input.LA (1);  		if ((LA6_1 == 24)) {  			alt6 = 1;  		}  	}  	finally {  		DebugExitDecision (6);  	}  	switch (alt6) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  		{  			DebugLocation (98' 31);  			inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  		}  		break;  	}  }  finally {  	DebugExitSubRule (6);  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	DebugEnterSubRule (6);  	try {  		DebugEnterDecision (6' false);  		int LA6_1 = input.LA (1);  		if ((LA6_1 == 24)) {  			alt6 = 1;  		}  	}  	finally {  		DebugExitDecision (6);  	}  	switch (alt6) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  		{  			DebugLocation (98' 31);  			inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  		}  		break;  	}  }  finally {  	DebugExitSubRule (6);  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	DebugEnterSubRule (6);  	try {  		DebugEnterDecision (6' false);  		int LA6_1 = input.LA (1);  		if ((LA6_1 == 24)) {  			alt6 = 1;  		}  	}  	finally {  		DebugExitDecision (6);  	}  	switch (alt6) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  		{  			DebugLocation (98' 31);  			inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  		}  		break;  	}  }  finally {  	DebugExitSubRule (6);  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	DebugEnterSubRule (6);  	try {  		DebugEnterDecision (6' false);  		int LA6_1 = input.LA (1);  		if ((LA6_1 == 24)) {  			alt6 = 1;  		}  	}  	finally {  		DebugExitDecision (6);  	}  	switch (alt6) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  		{  			DebugLocation (98' 31);  			inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  		}  		break;  	}  }  finally {  	DebugExitSubRule (6);  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	DebugEnterSubRule (6);  	try {  		DebugEnterDecision (6' false);  		int LA6_1 = input.LA (1);  		if ((LA6_1 == 24)) {  			alt6 = 1;  		}  	}  	finally {  		DebugExitDecision (6);  	}  	switch (alt6) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  		{  			DebugLocation (98' 31);  			inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  		}  		break;  	}  }  finally {  	DebugExitSubRule (6);  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	DebugEnterSubRule (6);  	try {  		DebugEnterDecision (6' false);  		int LA6_1 = input.LA (1);  		if ((LA6_1 == 24)) {  			alt6 = 1;  		}  	}  	finally {  		DebugExitDecision (6);  	}  	switch (alt6) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  		{  			DebugLocation (98' 31);  			inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  		}  		break;  	}  }  finally {  	DebugExitSubRule (6);  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	DebugEnterSubRule (6);  	try {  		DebugEnterDecision (6' false);  		int LA6_1 = input.LA (1);  		if ((LA6_1 == 24)) {  			alt6 = 1;  		}  	}  	finally {  		DebugExitDecision (6);  	}  	switch (alt6) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  		{  			DebugLocation (98' 31);  			inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  		}  		break;  	}  }  finally {  	DebugExitSubRule (6);  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: DebugEnterSubRule (6);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	DebugEnterDecision (6' false);  	int LA6_1 = input.LA (1);  	if ((LA6_1 == 24)) {  		alt6 = 1;  	}  }  finally {  	DebugExitDecision (6);  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	DebugEnterDecision (6' false);  	int LA6_1 = input.LA (1);  	if ((LA6_1 == 24)) {  		alt6 = 1;  	}  }  finally {  	DebugExitDecision (6);  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	DebugEnterDecision (6' false);  	int LA6_1 = input.LA (1);  	if ((LA6_1 == 24)) {  		alt6 = 1;  	}  }  finally {  	DebugExitDecision (6);  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: DebugEnterDecision (6' false);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: if ((LA6_1 == 24)) {  	alt6 = 1;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: DebugExitDecision (6);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: switch (alt6) {  case 1:  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  	{  		DebugLocation (98' 31);  		inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  	}  	break;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: switch (alt6) {  case 1:  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  	{  		DebugLocation (98' 31);  		inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  	}  	break;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: switch (alt6) {  case 1:  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  	{  		DebugLocation (98' 31);  		inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  	}  	break;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: DebugLocation (98' 31);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: DebugLocation (98' 31);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: DebugExitSubRule (6);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: DebugLocation (99' 4);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: DebugLocation (99' 4);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: DebugEnterAlt (3);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: DebugLocation (105' 4);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: DebugLocation (105' 4);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: DebugLocation (105' 6);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: DebugLocation (105' 6);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: DebugLocation (105' 12);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: DebugLocation (105' 12);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: DebugLocation (105' 51);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: DebugLocation (105' 51);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	DebugEnterSubRule (7);  	try {  		DebugEnterDecision (7' false);  		int LA7_1 = input.LA (1);  		if ((LA7_1 == 31)) {  			alt7 = 1;  		}  	}  	finally {  		DebugExitDecision (7);  	}  	switch (alt7) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  		{  			DebugLocation (105' 51);  			inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  		}  		break;  	}  }  finally {  	DebugExitSubRule (7);  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	DebugEnterSubRule (7);  	try {  		DebugEnterDecision (7' false);  		int LA7_1 = input.LA (1);  		if ((LA7_1 == 31)) {  			alt7 = 1;  		}  	}  	finally {  		DebugExitDecision (7);  	}  	switch (alt7) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  		{  			DebugLocation (105' 51);  			inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  		}  		break;  	}  }  finally {  	DebugExitSubRule (7);  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	DebugEnterSubRule (7);  	try {  		DebugEnterDecision (7' false);  		int LA7_1 = input.LA (1);  		if ((LA7_1 == 31)) {  			alt7 = 1;  		}  	}  	finally {  		DebugExitDecision (7);  	}  	switch (alt7) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  		{  			DebugLocation (105' 51);  			inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  		}  		break;  	}  }  finally {  	DebugExitSubRule (7);  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	DebugEnterSubRule (7);  	try {  		DebugEnterDecision (7' false);  		int LA7_1 = input.LA (1);  		if ((LA7_1 == 31)) {  			alt7 = 1;  		}  	}  	finally {  		DebugExitDecision (7);  	}  	switch (alt7) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  		{  			DebugLocation (105' 51);  			inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  		}  		break;  	}  }  finally {  	DebugExitSubRule (7);  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	DebugEnterSubRule (7);  	try {  		DebugEnterDecision (7' false);  		int LA7_1 = input.LA (1);  		if ((LA7_1 == 31)) {  			alt7 = 1;  		}  	}  	finally {  		DebugExitDecision (7);  	}  	switch (alt7) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  		{  			DebugLocation (105' 51);  			inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  		}  		break;  	}  }  finally {  	DebugExitSubRule (7);  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	DebugEnterSubRule (7);  	try {  		DebugEnterDecision (7' false);  		int LA7_1 = input.LA (1);  		if ((LA7_1 == 31)) {  			alt7 = 1;  		}  	}  	finally {  		DebugExitDecision (7);  	}  	switch (alt7) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  		{  			DebugLocation (105' 51);  			inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  		}  		break;  	}  }  finally {  	DebugExitSubRule (7);  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	DebugEnterSubRule (7);  	try {  		DebugEnterDecision (7' false);  		int LA7_1 = input.LA (1);  		if ((LA7_1 == 31)) {  			alt7 = 1;  		}  	}  	finally {  		DebugExitDecision (7);  	}  	switch (alt7) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  		{  			DebugLocation (105' 51);  			inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  		}  		break;  	}  }  finally {  	DebugExitSubRule (7);  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	DebugEnterSubRule (7);  	try {  		DebugEnterDecision (7' false);  		int LA7_1 = input.LA (1);  		if ((LA7_1 == 31)) {  			alt7 = 1;  		}  	}  	finally {  		DebugExitDecision (7);  	}  	switch (alt7) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  		{  			DebugLocation (105' 51);  			inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  		}  		break;  	}  }  finally {  	DebugExitSubRule (7);  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: DebugEnterSubRule (7);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	DebugEnterDecision (7' false);  	int LA7_1 = input.LA (1);  	if ((LA7_1 == 31)) {  		alt7 = 1;  	}  }  finally {  	DebugExitDecision (7);  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	DebugEnterDecision (7' false);  	int LA7_1 = input.LA (1);  	if ((LA7_1 == 31)) {  		alt7 = 1;  	}  }  finally {  	DebugExitDecision (7);  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	DebugEnterDecision (7' false);  	int LA7_1 = input.LA (1);  	if ((LA7_1 == 31)) {  		alt7 = 1;  	}  }  finally {  	DebugExitDecision (7);  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: DebugEnterDecision (7' false);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: if ((LA7_1 == 31)) {  	alt7 = 1;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: DebugExitDecision (7);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: switch (alt7) {  case 1:  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  	{  		DebugLocation (105' 51);  		inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  	}  	break;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: switch (alt7) {  case 1:  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  	{  		DebugLocation (105' 51);  		inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  	}  	break;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: switch (alt7) {  case 1:  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  	{  		DebugLocation (105' 51);  		inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  	}  	break;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: DebugLocation (105' 51);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: DebugLocation (105' 51);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: DebugExitSubRule (7);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: DebugLocation (105' 60);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: DebugLocation (105' 60);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	DebugEnterSubRule (8);  	try {  		DebugEnterDecision (8' false);  		int LA8_1 = input.LA (1);  		if ((LA8_1 == 24)) {  			alt8 = 1;  		}  	}  	finally {  		DebugExitDecision (8);  	}  	switch (alt8) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  		{  			DebugLocation (105' 60);  			not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  		}  		break;  	}  }  finally {  	DebugExitSubRule (8);  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	DebugEnterSubRule (8);  	try {  		DebugEnterDecision (8' false);  		int LA8_1 = input.LA (1);  		if ((LA8_1 == 24)) {  			alt8 = 1;  		}  	}  	finally {  		DebugExitDecision (8);  	}  	switch (alt8) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  		{  			DebugLocation (105' 60);  			not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  		}  		break;  	}  }  finally {  	DebugExitSubRule (8);  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	DebugEnterSubRule (8);  	try {  		DebugEnterDecision (8' false);  		int LA8_1 = input.LA (1);  		if ((LA8_1 == 24)) {  			alt8 = 1;  		}  	}  	finally {  		DebugExitDecision (8);  	}  	switch (alt8) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  		{  			DebugLocation (105' 60);  			not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  		}  		break;  	}  }  finally {  	DebugExitSubRule (8);  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	DebugEnterSubRule (8);  	try {  		DebugEnterDecision (8' false);  		int LA8_1 = input.LA (1);  		if ((LA8_1 == 24)) {  			alt8 = 1;  		}  	}  	finally {  		DebugExitDecision (8);  	}  	switch (alt8) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  		{  			DebugLocation (105' 60);  			not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  		}  		break;  	}  }  finally {  	DebugExitSubRule (8);  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	DebugEnterSubRule (8);  	try {  		DebugEnterDecision (8' false);  		int LA8_1 = input.LA (1);  		if ((LA8_1 == 24)) {  			alt8 = 1;  		}  	}  	finally {  		DebugExitDecision (8);  	}  	switch (alt8) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  		{  			DebugLocation (105' 60);  			not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  		}  		break;  	}  }  finally {  	DebugExitSubRule (8);  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	DebugEnterSubRule (8);  	try {  		DebugEnterDecision (8' false);  		int LA8_1 = input.LA (1);  		if ((LA8_1 == 24)) {  			alt8 = 1;  		}  	}  	finally {  		DebugExitDecision (8);  	}  	switch (alt8) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  		{  			DebugLocation (105' 60);  			not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  		}  		break;  	}  }  finally {  	DebugExitSubRule (8);  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	DebugEnterSubRule (8);  	try {  		DebugEnterDecision (8' false);  		int LA8_1 = input.LA (1);  		if ((LA8_1 == 24)) {  			alt8 = 1;  		}  	}  	finally {  		DebugExitDecision (8);  	}  	switch (alt8) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  		{  			DebugLocation (105' 60);  			not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  		}  		break;  	}  }  finally {  	DebugExitSubRule (8);  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	DebugEnterSubRule (8);  	try {  		DebugEnterDecision (8' false);  		int LA8_1 = input.LA (1);  		if ((LA8_1 == 24)) {  			alt8 = 1;  		}  	}  	finally {  		DebugExitDecision (8);  	}  	switch (alt8) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  		{  			DebugLocation (105' 60);  			not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  		}  		break;  	}  }  finally {  	DebugExitSubRule (8);  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: DebugEnterSubRule (8);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	DebugEnterDecision (8' false);  	int LA8_1 = input.LA (1);  	if ((LA8_1 == 24)) {  		alt8 = 1;  	}  }  finally {  	DebugExitDecision (8);  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	DebugEnterDecision (8' false);  	int LA8_1 = input.LA (1);  	if ((LA8_1 == 24)) {  		alt8 = 1;  	}  }  finally {  	DebugExitDecision (8);  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: try {  	DebugEnterDecision (8' false);  	int LA8_1 = input.LA (1);  	if ((LA8_1 == 24)) {  		alt8 = 1;  	}  }  finally {  	DebugExitDecision (8);  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: DebugEnterDecision (8' false);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: if ((LA8_1 == 24)) {  	alt8 = 1;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: DebugExitDecision (8);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: switch (alt8) {  case 1:  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  	{  		DebugLocation (105' 60);  		not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  	}  	break;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: switch (alt8) {  case 1:  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  	{  		DebugLocation (105' 60);  		not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  	}  	break;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: switch (alt8) {  case 1:  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  	{  		DebugLocation (105' 60);  		not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  	}  	break;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: DebugLocation (105' 60);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: DebugLocation (105' 60);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: DebugExitSubRule (8);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: DebugLocation (106' 4);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: DebugLocation (106' 4);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: DebugEnterAlt (4);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: DebugLocation (116' 4);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: DebugLocation (116' 4);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: DebugLocation (117' 4);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: DebugLocation (117' 4);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: stringText = stringText.Substring (1' stringText.Length - 2);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: DebugEnterAlt (5);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: DebugLocation (122' 4);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: DebugLocation (122' 4);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: DebugLocation (123' 4);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: DebugLocation (123' 4);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: regexText = regexText.Substring (1' regexText.Length - 2);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: DebugEnterAlt (6);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: DebugLocation (128' 4);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: DebugLocation (128' 4);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: DebugLocation (129' 4);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: DebugLocation (129' 4);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: DebugEnterAlt (7);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: DebugLocation (132' 4);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: DebugLocation (132' 4);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: DebugLocation (133' 4);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: DebugLocation (133' 4);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: DebugEnterAlt (8);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: DebugLocation (136' 4);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: DebugLocation (136' 4);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: DebugLocation (137' 4);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: DebugLocation (137' 4);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: DebugEnterAlt (9);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: DebugLocation (140' 4);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: DebugLocation (140' 4);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: DebugLocation (141' 4);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: DebugLocation (141' 4);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: TraceOut ("filterExpr"' 6);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: LeaveRule ("filterExpr"' 6);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following statement contains a magic number: DebugLocation (144' 1);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyChain,The following statement contains a magic number: EnterRule ("propertyChain"' 7);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyChain,The following statement contains a magic number: TraceIn ("propertyChain"' 7);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyChain,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "propertyChain");  	DebugLocation (146' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:147:2: ( ^( ID propertyChain[propertySegments] ) | ^( ESC_ID propertyChain[propertySegments] ) )  		int alt10 = 2;  		try {  			DebugEnterDecision (10' false);  			int LA10_1 = input.LA (1);  			if ((LA10_1 == ID)) {  				alt10 = 1;  			}  			else if ((LA10_1 == ESC_ID)) {  				alt10 = 2;  			}  			else {  				NoViableAltException nvae = new NoViableAltException (""' 10' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  		}  		finally {  			DebugExitDecision (10);  		}  		switch (alt10) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:147:4: ^( ID propertyChain[propertySegments] )  			{  				DebugLocation (147' 4);  				DebugLocation (147' 6);  				ID10 = (CommonTree)Match (input' ID' Follow._ID_in_propertyChain310);  				DebugLocation (148' 3);  				propertySegments.Add ((ID10 != null ? ID10.Text : default(string)));  				Match (input' TokenTypes.Down' null);  				DebugLocation (149' 3);  				PushFollow (Follow._propertyChain_in_propertyChain318);  				propertyChain (propertySegments);  				PopFollow ();  				Match (input' TokenTypes.Up' null);  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:150:4: ^( ESC_ID propertyChain[propertySegments] )  			{  				DebugLocation (150' 4);  				DebugLocation (150' 6);  				ESC_ID11 = (CommonTree)Match (input' ESC_ID' Follow._ESC_ID_in_propertyChain326);  				DebugLocation (151' 3);  				propertySegments.Add ((ESC_ID11 != null ? ESC_ID11.Text : default(string)));  				Match (input' TokenTypes.Down' null);  				DebugLocation (152' 3);  				PushFollow (Follow._propertyChain_in_propertyChain334);  				propertyChain (propertySegments);  				PopFollow ();  				Match (input' TokenTypes.Up' null);  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("propertyChain"' 7);  		LeaveRule ("propertyChain"' 7);  		LeaveRule_propertyChain ();  	}  	DebugLocation (153' 1);  }  finally {  	DebugExitRule (GrammarFileName' "propertyChain");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyChain,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "propertyChain");  	DebugLocation (146' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:147:2: ( ^( ID propertyChain[propertySegments] ) | ^( ESC_ID propertyChain[propertySegments] ) )  		int alt10 = 2;  		try {  			DebugEnterDecision (10' false);  			int LA10_1 = input.LA (1);  			if ((LA10_1 == ID)) {  				alt10 = 1;  			}  			else if ((LA10_1 == ESC_ID)) {  				alt10 = 2;  			}  			else {  				NoViableAltException nvae = new NoViableAltException (""' 10' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  		}  		finally {  			DebugExitDecision (10);  		}  		switch (alt10) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:147:4: ^( ID propertyChain[propertySegments] )  			{  				DebugLocation (147' 4);  				DebugLocation (147' 6);  				ID10 = (CommonTree)Match (input' ID' Follow._ID_in_propertyChain310);  				DebugLocation (148' 3);  				propertySegments.Add ((ID10 != null ? ID10.Text : default(string)));  				Match (input' TokenTypes.Down' null);  				DebugLocation (149' 3);  				PushFollow (Follow._propertyChain_in_propertyChain318);  				propertyChain (propertySegments);  				PopFollow ();  				Match (input' TokenTypes.Up' null);  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:150:4: ^( ESC_ID propertyChain[propertySegments] )  			{  				DebugLocation (150' 4);  				DebugLocation (150' 6);  				ESC_ID11 = (CommonTree)Match (input' ESC_ID' Follow._ESC_ID_in_propertyChain326);  				DebugLocation (151' 3);  				propertySegments.Add ((ESC_ID11 != null ? ESC_ID11.Text : default(string)));  				Match (input' TokenTypes.Down' null);  				DebugLocation (152' 3);  				PushFollow (Follow._propertyChain_in_propertyChain334);  				propertyChain (propertySegments);  				PopFollow ();  				Match (input' TokenTypes.Up' null);  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("propertyChain"' 7);  		LeaveRule ("propertyChain"' 7);  		LeaveRule_propertyChain ();  	}  	DebugLocation (153' 1);  }  finally {  	DebugExitRule (GrammarFileName' "propertyChain");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyChain,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "propertyChain");  	DebugLocation (146' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:147:2: ( ^( ID propertyChain[propertySegments] ) | ^( ESC_ID propertyChain[propertySegments] ) )  		int alt10 = 2;  		try {  			DebugEnterDecision (10' false);  			int LA10_1 = input.LA (1);  			if ((LA10_1 == ID)) {  				alt10 = 1;  			}  			else if ((LA10_1 == ESC_ID)) {  				alt10 = 2;  			}  			else {  				NoViableAltException nvae = new NoViableAltException (""' 10' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  		}  		finally {  			DebugExitDecision (10);  		}  		switch (alt10) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:147:4: ^( ID propertyChain[propertySegments] )  			{  				DebugLocation (147' 4);  				DebugLocation (147' 6);  				ID10 = (CommonTree)Match (input' ID' Follow._ID_in_propertyChain310);  				DebugLocation (148' 3);  				propertySegments.Add ((ID10 != null ? ID10.Text : default(string)));  				Match (input' TokenTypes.Down' null);  				DebugLocation (149' 3);  				PushFollow (Follow._propertyChain_in_propertyChain318);  				propertyChain (propertySegments);  				PopFollow ();  				Match (input' TokenTypes.Up' null);  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:150:4: ^( ESC_ID propertyChain[propertySegments] )  			{  				DebugLocation (150' 4);  				DebugLocation (150' 6);  				ESC_ID11 = (CommonTree)Match (input' ESC_ID' Follow._ESC_ID_in_propertyChain326);  				DebugLocation (151' 3);  				propertySegments.Add ((ESC_ID11 != null ? ESC_ID11.Text : default(string)));  				Match (input' TokenTypes.Down' null);  				DebugLocation (152' 3);  				PushFollow (Follow._propertyChain_in_propertyChain334);  				propertyChain (propertySegments);  				PopFollow ();  				Match (input' TokenTypes.Up' null);  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("propertyChain"' 7);  		LeaveRule ("propertyChain"' 7);  		LeaveRule_propertyChain ();  	}  	DebugLocation (153' 1);  }  finally {  	DebugExitRule (GrammarFileName' "propertyChain");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyChain,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "propertyChain");  	DebugLocation (146' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:147:2: ( ^( ID propertyChain[propertySegments] ) | ^( ESC_ID propertyChain[propertySegments] ) )  		int alt10 = 2;  		try {  			DebugEnterDecision (10' false);  			int LA10_1 = input.LA (1);  			if ((LA10_1 == ID)) {  				alt10 = 1;  			}  			else if ((LA10_1 == ESC_ID)) {  				alt10 = 2;  			}  			else {  				NoViableAltException nvae = new NoViableAltException (""' 10' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  		}  		finally {  			DebugExitDecision (10);  		}  		switch (alt10) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:147:4: ^( ID propertyChain[propertySegments] )  			{  				DebugLocation (147' 4);  				DebugLocation (147' 6);  				ID10 = (CommonTree)Match (input' ID' Follow._ID_in_propertyChain310);  				DebugLocation (148' 3);  				propertySegments.Add ((ID10 != null ? ID10.Text : default(string)));  				Match (input' TokenTypes.Down' null);  				DebugLocation (149' 3);  				PushFollow (Follow._propertyChain_in_propertyChain318);  				propertyChain (propertySegments);  				PopFollow ();  				Match (input' TokenTypes.Up' null);  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:150:4: ^( ESC_ID propertyChain[propertySegments] )  			{  				DebugLocation (150' 4);  				DebugLocation (150' 6);  				ESC_ID11 = (CommonTree)Match (input' ESC_ID' Follow._ESC_ID_in_propertyChain326);  				DebugLocation (151' 3);  				propertySegments.Add ((ESC_ID11 != null ? ESC_ID11.Text : default(string)));  				Match (input' TokenTypes.Down' null);  				DebugLocation (152' 3);  				PushFollow (Follow._propertyChain_in_propertyChain334);  				propertyChain (propertySegments);  				PopFollow ();  				Match (input' TokenTypes.Up' null);  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("propertyChain"' 7);  		LeaveRule ("propertyChain"' 7);  		LeaveRule_propertyChain ();  	}  	DebugLocation (153' 1);  }  finally {  	DebugExitRule (GrammarFileName' "propertyChain");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyChain,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "propertyChain");  	DebugLocation (146' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:147:2: ( ^( ID propertyChain[propertySegments] ) | ^( ESC_ID propertyChain[propertySegments] ) )  		int alt10 = 2;  		try {  			DebugEnterDecision (10' false);  			int LA10_1 = input.LA (1);  			if ((LA10_1 == ID)) {  				alt10 = 1;  			}  			else if ((LA10_1 == ESC_ID)) {  				alt10 = 2;  			}  			else {  				NoViableAltException nvae = new NoViableAltException (""' 10' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  		}  		finally {  			DebugExitDecision (10);  		}  		switch (alt10) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:147:4: ^( ID propertyChain[propertySegments] )  			{  				DebugLocation (147' 4);  				DebugLocation (147' 6);  				ID10 = (CommonTree)Match (input' ID' Follow._ID_in_propertyChain310);  				DebugLocation (148' 3);  				propertySegments.Add ((ID10 != null ? ID10.Text : default(string)));  				Match (input' TokenTypes.Down' null);  				DebugLocation (149' 3);  				PushFollow (Follow._propertyChain_in_propertyChain318);  				propertyChain (propertySegments);  				PopFollow ();  				Match (input' TokenTypes.Up' null);  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:150:4: ^( ESC_ID propertyChain[propertySegments] )  			{  				DebugLocation (150' 4);  				DebugLocation (150' 6);  				ESC_ID11 = (CommonTree)Match (input' ESC_ID' Follow._ESC_ID_in_propertyChain326);  				DebugLocation (151' 3);  				propertySegments.Add ((ESC_ID11 != null ? ESC_ID11.Text : default(string)));  				Match (input' TokenTypes.Down' null);  				DebugLocation (152' 3);  				PushFollow (Follow._propertyChain_in_propertyChain334);  				propertyChain (propertySegments);  				PopFollow ();  				Match (input' TokenTypes.Up' null);  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("propertyChain"' 7);  		LeaveRule ("propertyChain"' 7);  		LeaveRule_propertyChain ();  	}  	DebugLocation (153' 1);  }  finally {  	DebugExitRule (GrammarFileName' "propertyChain");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyChain,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "propertyChain");  	DebugLocation (146' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:147:2: ( ^( ID propertyChain[propertySegments] ) | ^( ESC_ID propertyChain[propertySegments] ) )  		int alt10 = 2;  		try {  			DebugEnterDecision (10' false);  			int LA10_1 = input.LA (1);  			if ((LA10_1 == ID)) {  				alt10 = 1;  			}  			else if ((LA10_1 == ESC_ID)) {  				alt10 = 2;  			}  			else {  				NoViableAltException nvae = new NoViableAltException (""' 10' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  		}  		finally {  			DebugExitDecision (10);  		}  		switch (alt10) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:147:4: ^( ID propertyChain[propertySegments] )  			{  				DebugLocation (147' 4);  				DebugLocation (147' 6);  				ID10 = (CommonTree)Match (input' ID' Follow._ID_in_propertyChain310);  				DebugLocation (148' 3);  				propertySegments.Add ((ID10 != null ? ID10.Text : default(string)));  				Match (input' TokenTypes.Down' null);  				DebugLocation (149' 3);  				PushFollow (Follow._propertyChain_in_propertyChain318);  				propertyChain (propertySegments);  				PopFollow ();  				Match (input' TokenTypes.Up' null);  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:150:4: ^( ESC_ID propertyChain[propertySegments] )  			{  				DebugLocation (150' 4);  				DebugLocation (150' 6);  				ESC_ID11 = (CommonTree)Match (input' ESC_ID' Follow._ESC_ID_in_propertyChain326);  				DebugLocation (151' 3);  				propertySegments.Add ((ESC_ID11 != null ? ESC_ID11.Text : default(string)));  				Match (input' TokenTypes.Down' null);  				DebugLocation (152' 3);  				PushFollow (Follow._propertyChain_in_propertyChain334);  				propertyChain (propertySegments);  				PopFollow ();  				Match (input' TokenTypes.Up' null);  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("propertyChain"' 7);  		LeaveRule ("propertyChain"' 7);  		LeaveRule_propertyChain ();  	}  	DebugLocation (153' 1);  }  finally {  	DebugExitRule (GrammarFileName' "propertyChain");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyChain,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "propertyChain");  	DebugLocation (146' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:147:2: ( ^( ID propertyChain[propertySegments] ) | ^( ESC_ID propertyChain[propertySegments] ) )  		int alt10 = 2;  		try {  			DebugEnterDecision (10' false);  			int LA10_1 = input.LA (1);  			if ((LA10_1 == ID)) {  				alt10 = 1;  			}  			else if ((LA10_1 == ESC_ID)) {  				alt10 = 2;  			}  			else {  				NoViableAltException nvae = new NoViableAltException (""' 10' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  		}  		finally {  			DebugExitDecision (10);  		}  		switch (alt10) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:147:4: ^( ID propertyChain[propertySegments] )  			{  				DebugLocation (147' 4);  				DebugLocation (147' 6);  				ID10 = (CommonTree)Match (input' ID' Follow._ID_in_propertyChain310);  				DebugLocation (148' 3);  				propertySegments.Add ((ID10 != null ? ID10.Text : default(string)));  				Match (input' TokenTypes.Down' null);  				DebugLocation (149' 3);  				PushFollow (Follow._propertyChain_in_propertyChain318);  				propertyChain (propertySegments);  				PopFollow ();  				Match (input' TokenTypes.Up' null);  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:150:4: ^( ESC_ID propertyChain[propertySegments] )  			{  				DebugLocation (150' 4);  				DebugLocation (150' 6);  				ESC_ID11 = (CommonTree)Match (input' ESC_ID' Follow._ESC_ID_in_propertyChain326);  				DebugLocation (151' 3);  				propertySegments.Add ((ESC_ID11 != null ? ESC_ID11.Text : default(string)));  				Match (input' TokenTypes.Down' null);  				DebugLocation (152' 3);  				PushFollow (Follow._propertyChain_in_propertyChain334);  				propertyChain (propertySegments);  				PopFollow ();  				Match (input' TokenTypes.Up' null);  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("propertyChain"' 7);  		LeaveRule ("propertyChain"' 7);  		LeaveRule_propertyChain ();  	}  	DebugLocation (153' 1);  }  finally {  	DebugExitRule (GrammarFileName' "propertyChain");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyChain,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "propertyChain");  	DebugLocation (146' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:147:2: ( ^( ID propertyChain[propertySegments] ) | ^( ESC_ID propertyChain[propertySegments] ) )  		int alt10 = 2;  		try {  			DebugEnterDecision (10' false);  			int LA10_1 = input.LA (1);  			if ((LA10_1 == ID)) {  				alt10 = 1;  			}  			else if ((LA10_1 == ESC_ID)) {  				alt10 = 2;  			}  			else {  				NoViableAltException nvae = new NoViableAltException (""' 10' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  		}  		finally {  			DebugExitDecision (10);  		}  		switch (alt10) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:147:4: ^( ID propertyChain[propertySegments] )  			{  				DebugLocation (147' 4);  				DebugLocation (147' 6);  				ID10 = (CommonTree)Match (input' ID' Follow._ID_in_propertyChain310);  				DebugLocation (148' 3);  				propertySegments.Add ((ID10 != null ? ID10.Text : default(string)));  				Match (input' TokenTypes.Down' null);  				DebugLocation (149' 3);  				PushFollow (Follow._propertyChain_in_propertyChain318);  				propertyChain (propertySegments);  				PopFollow ();  				Match (input' TokenTypes.Up' null);  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:150:4: ^( ESC_ID propertyChain[propertySegments] )  			{  				DebugLocation (150' 4);  				DebugLocation (150' 6);  				ESC_ID11 = (CommonTree)Match (input' ESC_ID' Follow._ESC_ID_in_propertyChain326);  				DebugLocation (151' 3);  				propertySegments.Add ((ESC_ID11 != null ? ESC_ID11.Text : default(string)));  				Match (input' TokenTypes.Down' null);  				DebugLocation (152' 3);  				PushFollow (Follow._propertyChain_in_propertyChain334);  				propertyChain (propertySegments);  				PopFollow ();  				Match (input' TokenTypes.Up' null);  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("propertyChain"' 7);  		LeaveRule ("propertyChain"' 7);  		LeaveRule_propertyChain ();  	}  	DebugLocation (153' 1);  }  finally {  	DebugExitRule (GrammarFileName' "propertyChain");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyChain,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "propertyChain");  	DebugLocation (146' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:147:2: ( ^( ID propertyChain[propertySegments] ) | ^( ESC_ID propertyChain[propertySegments] ) )  		int alt10 = 2;  		try {  			DebugEnterDecision (10' false);  			int LA10_1 = input.LA (1);  			if ((LA10_1 == ID)) {  				alt10 = 1;  			}  			else if ((LA10_1 == ESC_ID)) {  				alt10 = 2;  			}  			else {  				NoViableAltException nvae = new NoViableAltException (""' 10' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  		}  		finally {  			DebugExitDecision (10);  		}  		switch (alt10) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:147:4: ^( ID propertyChain[propertySegments] )  			{  				DebugLocation (147' 4);  				DebugLocation (147' 6);  				ID10 = (CommonTree)Match (input' ID' Follow._ID_in_propertyChain310);  				DebugLocation (148' 3);  				propertySegments.Add ((ID10 != null ? ID10.Text : default(string)));  				Match (input' TokenTypes.Down' null);  				DebugLocation (149' 3);  				PushFollow (Follow._propertyChain_in_propertyChain318);  				propertyChain (propertySegments);  				PopFollow ();  				Match (input' TokenTypes.Up' null);  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:150:4: ^( ESC_ID propertyChain[propertySegments] )  			{  				DebugLocation (150' 4);  				DebugLocation (150' 6);  				ESC_ID11 = (CommonTree)Match (input' ESC_ID' Follow._ESC_ID_in_propertyChain326);  				DebugLocation (151' 3);  				propertySegments.Add ((ESC_ID11 != null ? ESC_ID11.Text : default(string)));  				Match (input' TokenTypes.Down' null);  				DebugLocation (152' 3);  				PushFollow (Follow._propertyChain_in_propertyChain334);  				propertyChain (propertySegments);  				PopFollow ();  				Match (input' TokenTypes.Up' null);  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("propertyChain"' 7);  		LeaveRule ("propertyChain"' 7);  		LeaveRule_propertyChain ();  	}  	DebugLocation (153' 1);  }  finally {  	DebugExitRule (GrammarFileName' "propertyChain");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyChain,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "propertyChain");  	DebugLocation (146' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:147:2: ( ^( ID propertyChain[propertySegments] ) | ^( ESC_ID propertyChain[propertySegments] ) )  		int alt10 = 2;  		try {  			DebugEnterDecision (10' false);  			int LA10_1 = input.LA (1);  			if ((LA10_1 == ID)) {  				alt10 = 1;  			}  			else if ((LA10_1 == ESC_ID)) {  				alt10 = 2;  			}  			else {  				NoViableAltException nvae = new NoViableAltException (""' 10' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  		}  		finally {  			DebugExitDecision (10);  		}  		switch (alt10) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:147:4: ^( ID propertyChain[propertySegments] )  			{  				DebugLocation (147' 4);  				DebugLocation (147' 6);  				ID10 = (CommonTree)Match (input' ID' Follow._ID_in_propertyChain310);  				DebugLocation (148' 3);  				propertySegments.Add ((ID10 != null ? ID10.Text : default(string)));  				Match (input' TokenTypes.Down' null);  				DebugLocation (149' 3);  				PushFollow (Follow._propertyChain_in_propertyChain318);  				propertyChain (propertySegments);  				PopFollow ();  				Match (input' TokenTypes.Up' null);  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:150:4: ^( ESC_ID propertyChain[propertySegments] )  			{  				DebugLocation (150' 4);  				DebugLocation (150' 6);  				ESC_ID11 = (CommonTree)Match (input' ESC_ID' Follow._ESC_ID_in_propertyChain326);  				DebugLocation (151' 3);  				propertySegments.Add ((ESC_ID11 != null ? ESC_ID11.Text : default(string)));  				Match (input' TokenTypes.Down' null);  				DebugLocation (152' 3);  				PushFollow (Follow._propertyChain_in_propertyChain334);  				propertyChain (propertySegments);  				PopFollow ();  				Match (input' TokenTypes.Up' null);  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("propertyChain"' 7);  		LeaveRule ("propertyChain"' 7);  		LeaveRule_propertyChain ();  	}  	DebugLocation (153' 1);  }  finally {  	DebugExitRule (GrammarFileName' "propertyChain");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyChain,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "propertyChain");  	DebugLocation (146' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:147:2: ( ^( ID propertyChain[propertySegments] ) | ^( ESC_ID propertyChain[propertySegments] ) )  		int alt10 = 2;  		try {  			DebugEnterDecision (10' false);  			int LA10_1 = input.LA (1);  			if ((LA10_1 == ID)) {  				alt10 = 1;  			}  			else if ((LA10_1 == ESC_ID)) {  				alt10 = 2;  			}  			else {  				NoViableAltException nvae = new NoViableAltException (""' 10' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  		}  		finally {  			DebugExitDecision (10);  		}  		switch (alt10) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:147:4: ^( ID propertyChain[propertySegments] )  			{  				DebugLocation (147' 4);  				DebugLocation (147' 6);  				ID10 = (CommonTree)Match (input' ID' Follow._ID_in_propertyChain310);  				DebugLocation (148' 3);  				propertySegments.Add ((ID10 != null ? ID10.Text : default(string)));  				Match (input' TokenTypes.Down' null);  				DebugLocation (149' 3);  				PushFollow (Follow._propertyChain_in_propertyChain318);  				propertyChain (propertySegments);  				PopFollow ();  				Match (input' TokenTypes.Up' null);  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:150:4: ^( ESC_ID propertyChain[propertySegments] )  			{  				DebugLocation (150' 4);  				DebugLocation (150' 6);  				ESC_ID11 = (CommonTree)Match (input' ESC_ID' Follow._ESC_ID_in_propertyChain326);  				DebugLocation (151' 3);  				propertySegments.Add ((ESC_ID11 != null ? ESC_ID11.Text : default(string)));  				Match (input' TokenTypes.Down' null);  				DebugLocation (152' 3);  				PushFollow (Follow._propertyChain_in_propertyChain334);  				propertyChain (propertySegments);  				PopFollow ();  				Match (input' TokenTypes.Up' null);  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("propertyChain"' 7);  		LeaveRule ("propertyChain"' 7);  		LeaveRule_propertyChain ();  	}  	DebugLocation (153' 1);  }  finally {  	DebugExitRule (GrammarFileName' "propertyChain");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyChain,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "propertyChain");  	DebugLocation (146' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:147:2: ( ^( ID propertyChain[propertySegments] ) | ^( ESC_ID propertyChain[propertySegments] ) )  		int alt10 = 2;  		try {  			DebugEnterDecision (10' false);  			int LA10_1 = input.LA (1);  			if ((LA10_1 == ID)) {  				alt10 = 1;  			}  			else if ((LA10_1 == ESC_ID)) {  				alt10 = 2;  			}  			else {  				NoViableAltException nvae = new NoViableAltException (""' 10' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  		}  		finally {  			DebugExitDecision (10);  		}  		switch (alt10) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:147:4: ^( ID propertyChain[propertySegments] )  			{  				DebugLocation (147' 4);  				DebugLocation (147' 6);  				ID10 = (CommonTree)Match (input' ID' Follow._ID_in_propertyChain310);  				DebugLocation (148' 3);  				propertySegments.Add ((ID10 != null ? ID10.Text : default(string)));  				Match (input' TokenTypes.Down' null);  				DebugLocation (149' 3);  				PushFollow (Follow._propertyChain_in_propertyChain318);  				propertyChain (propertySegments);  				PopFollow ();  				Match (input' TokenTypes.Up' null);  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:150:4: ^( ESC_ID propertyChain[propertySegments] )  			{  				DebugLocation (150' 4);  				DebugLocation (150' 6);  				ESC_ID11 = (CommonTree)Match (input' ESC_ID' Follow._ESC_ID_in_propertyChain326);  				DebugLocation (151' 3);  				propertySegments.Add ((ESC_ID11 != null ? ESC_ID11.Text : default(string)));  				Match (input' TokenTypes.Down' null);  				DebugLocation (152' 3);  				PushFollow (Follow._propertyChain_in_propertyChain334);  				propertyChain (propertySegments);  				PopFollow ();  				Match (input' TokenTypes.Up' null);  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("propertyChain"' 7);  		LeaveRule ("propertyChain"' 7);  		LeaveRule_propertyChain ();  	}  	DebugLocation (153' 1);  }  finally {  	DebugExitRule (GrammarFileName' "propertyChain");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyChain,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "propertyChain");  	DebugLocation (146' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:147:2: ( ^( ID propertyChain[propertySegments] ) | ^( ESC_ID propertyChain[propertySegments] ) )  		int alt10 = 2;  		try {  			DebugEnterDecision (10' false);  			int LA10_1 = input.LA (1);  			if ((LA10_1 == ID)) {  				alt10 = 1;  			}  			else if ((LA10_1 == ESC_ID)) {  				alt10 = 2;  			}  			else {  				NoViableAltException nvae = new NoViableAltException (""' 10' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  		}  		finally {  			DebugExitDecision (10);  		}  		switch (alt10) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:147:4: ^( ID propertyChain[propertySegments] )  			{  				DebugLocation (147' 4);  				DebugLocation (147' 6);  				ID10 = (CommonTree)Match (input' ID' Follow._ID_in_propertyChain310);  				DebugLocation (148' 3);  				propertySegments.Add ((ID10 != null ? ID10.Text : default(string)));  				Match (input' TokenTypes.Down' null);  				DebugLocation (149' 3);  				PushFollow (Follow._propertyChain_in_propertyChain318);  				propertyChain (propertySegments);  				PopFollow ();  				Match (input' TokenTypes.Up' null);  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:150:4: ^( ESC_ID propertyChain[propertySegments] )  			{  				DebugLocation (150' 4);  				DebugLocation (150' 6);  				ESC_ID11 = (CommonTree)Match (input' ESC_ID' Follow._ESC_ID_in_propertyChain326);  				DebugLocation (151' 3);  				propertySegments.Add ((ESC_ID11 != null ? ESC_ID11.Text : default(string)));  				Match (input' TokenTypes.Down' null);  				DebugLocation (152' 3);  				PushFollow (Follow._propertyChain_in_propertyChain334);  				propertyChain (propertySegments);  				PopFollow ();  				Match (input' TokenTypes.Up' null);  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("propertyChain"' 7);  		LeaveRule ("propertyChain"' 7);  		LeaveRule_propertyChain ();  	}  	DebugLocation (153' 1);  }  finally {  	DebugExitRule (GrammarFileName' "propertyChain");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyChain,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "propertyChain");  	DebugLocation (146' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:147:2: ( ^( ID propertyChain[propertySegments] ) | ^( ESC_ID propertyChain[propertySegments] ) )  		int alt10 = 2;  		try {  			DebugEnterDecision (10' false);  			int LA10_1 = input.LA (1);  			if ((LA10_1 == ID)) {  				alt10 = 1;  			}  			else if ((LA10_1 == ESC_ID)) {  				alt10 = 2;  			}  			else {  				NoViableAltException nvae = new NoViableAltException (""' 10' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  		}  		finally {  			DebugExitDecision (10);  		}  		switch (alt10) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:147:4: ^( ID propertyChain[propertySegments] )  			{  				DebugLocation (147' 4);  				DebugLocation (147' 6);  				ID10 = (CommonTree)Match (input' ID' Follow._ID_in_propertyChain310);  				DebugLocation (148' 3);  				propertySegments.Add ((ID10 != null ? ID10.Text : default(string)));  				Match (input' TokenTypes.Down' null);  				DebugLocation (149' 3);  				PushFollow (Follow._propertyChain_in_propertyChain318);  				propertyChain (propertySegments);  				PopFollow ();  				Match (input' TokenTypes.Up' null);  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:150:4: ^( ESC_ID propertyChain[propertySegments] )  			{  				DebugLocation (150' 4);  				DebugLocation (150' 6);  				ESC_ID11 = (CommonTree)Match (input' ESC_ID' Follow._ESC_ID_in_propertyChain326);  				DebugLocation (151' 3);  				propertySegments.Add ((ESC_ID11 != null ? ESC_ID11.Text : default(string)));  				Match (input' TokenTypes.Down' null);  				DebugLocation (152' 3);  				PushFollow (Follow._propertyChain_in_propertyChain334);  				propertyChain (propertySegments);  				PopFollow ();  				Match (input' TokenTypes.Up' null);  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("propertyChain"' 7);  		LeaveRule ("propertyChain"' 7);  		LeaveRule_propertyChain ();  	}  	DebugLocation (153' 1);  }  finally {  	DebugExitRule (GrammarFileName' "propertyChain");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyChain,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "propertyChain");  	DebugLocation (146' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:147:2: ( ^( ID propertyChain[propertySegments] ) | ^( ESC_ID propertyChain[propertySegments] ) )  		int alt10 = 2;  		try {  			DebugEnterDecision (10' false);  			int LA10_1 = input.LA (1);  			if ((LA10_1 == ID)) {  				alt10 = 1;  			}  			else if ((LA10_1 == ESC_ID)) {  				alt10 = 2;  			}  			else {  				NoViableAltException nvae = new NoViableAltException (""' 10' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  		}  		finally {  			DebugExitDecision (10);  		}  		switch (alt10) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:147:4: ^( ID propertyChain[propertySegments] )  			{  				DebugLocation (147' 4);  				DebugLocation (147' 6);  				ID10 = (CommonTree)Match (input' ID' Follow._ID_in_propertyChain310);  				DebugLocation (148' 3);  				propertySegments.Add ((ID10 != null ? ID10.Text : default(string)));  				Match (input' TokenTypes.Down' null);  				DebugLocation (149' 3);  				PushFollow (Follow._propertyChain_in_propertyChain318);  				propertyChain (propertySegments);  				PopFollow ();  				Match (input' TokenTypes.Up' null);  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:150:4: ^( ESC_ID propertyChain[propertySegments] )  			{  				DebugLocation (150' 4);  				DebugLocation (150' 6);  				ESC_ID11 = (CommonTree)Match (input' ESC_ID' Follow._ESC_ID_in_propertyChain326);  				DebugLocation (151' 3);  				propertySegments.Add ((ESC_ID11 != null ? ESC_ID11.Text : default(string)));  				Match (input' TokenTypes.Down' null);  				DebugLocation (152' 3);  				PushFollow (Follow._propertyChain_in_propertyChain334);  				propertyChain (propertySegments);  				PopFollow ();  				Match (input' TokenTypes.Up' null);  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("propertyChain"' 7);  		LeaveRule ("propertyChain"' 7);  		LeaveRule_propertyChain ();  	}  	DebugLocation (153' 1);  }  finally {  	DebugExitRule (GrammarFileName' "propertyChain");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyChain,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "propertyChain");  	DebugLocation (146' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:147:2: ( ^( ID propertyChain[propertySegments] ) | ^( ESC_ID propertyChain[propertySegments] ) )  		int alt10 = 2;  		try {  			DebugEnterDecision (10' false);  			int LA10_1 = input.LA (1);  			if ((LA10_1 == ID)) {  				alt10 = 1;  			}  			else if ((LA10_1 == ESC_ID)) {  				alt10 = 2;  			}  			else {  				NoViableAltException nvae = new NoViableAltException (""' 10' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  		}  		finally {  			DebugExitDecision (10);  		}  		switch (alt10) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:147:4: ^( ID propertyChain[propertySegments] )  			{  				DebugLocation (147' 4);  				DebugLocation (147' 6);  				ID10 = (CommonTree)Match (input' ID' Follow._ID_in_propertyChain310);  				DebugLocation (148' 3);  				propertySegments.Add ((ID10 != null ? ID10.Text : default(string)));  				Match (input' TokenTypes.Down' null);  				DebugLocation (149' 3);  				PushFollow (Follow._propertyChain_in_propertyChain318);  				propertyChain (propertySegments);  				PopFollow ();  				Match (input' TokenTypes.Up' null);  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:150:4: ^( ESC_ID propertyChain[propertySegments] )  			{  				DebugLocation (150' 4);  				DebugLocation (150' 6);  				ESC_ID11 = (CommonTree)Match (input' ESC_ID' Follow._ESC_ID_in_propertyChain326);  				DebugLocation (151' 3);  				propertySegments.Add ((ESC_ID11 != null ? ESC_ID11.Text : default(string)));  				Match (input' TokenTypes.Down' null);  				DebugLocation (152' 3);  				PushFollow (Follow._propertyChain_in_propertyChain334);  				propertyChain (propertySegments);  				PopFollow ();  				Match (input' TokenTypes.Up' null);  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("propertyChain"' 7);  		LeaveRule ("propertyChain"' 7);  		LeaveRule_propertyChain ();  	}  	DebugLocation (153' 1);  }  finally {  	DebugExitRule (GrammarFileName' "propertyChain");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyChain,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "propertyChain");  	DebugLocation (146' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:147:2: ( ^( ID propertyChain[propertySegments] ) | ^( ESC_ID propertyChain[propertySegments] ) )  		int alt10 = 2;  		try {  			DebugEnterDecision (10' false);  			int LA10_1 = input.LA (1);  			if ((LA10_1 == ID)) {  				alt10 = 1;  			}  			else if ((LA10_1 == ESC_ID)) {  				alt10 = 2;  			}  			else {  				NoViableAltException nvae = new NoViableAltException (""' 10' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  		}  		finally {  			DebugExitDecision (10);  		}  		switch (alt10) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:147:4: ^( ID propertyChain[propertySegments] )  			{  				DebugLocation (147' 4);  				DebugLocation (147' 6);  				ID10 = (CommonTree)Match (input' ID' Follow._ID_in_propertyChain310);  				DebugLocation (148' 3);  				propertySegments.Add ((ID10 != null ? ID10.Text : default(string)));  				Match (input' TokenTypes.Down' null);  				DebugLocation (149' 3);  				PushFollow (Follow._propertyChain_in_propertyChain318);  				propertyChain (propertySegments);  				PopFollow ();  				Match (input' TokenTypes.Up' null);  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:150:4: ^( ESC_ID propertyChain[propertySegments] )  			{  				DebugLocation (150' 4);  				DebugLocation (150' 6);  				ESC_ID11 = (CommonTree)Match (input' ESC_ID' Follow._ESC_ID_in_propertyChain326);  				DebugLocation (151' 3);  				propertySegments.Add ((ESC_ID11 != null ? ESC_ID11.Text : default(string)));  				Match (input' TokenTypes.Down' null);  				DebugLocation (152' 3);  				PushFollow (Follow._propertyChain_in_propertyChain334);  				propertyChain (propertySegments);  				PopFollow ();  				Match (input' TokenTypes.Up' null);  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("propertyChain"' 7);  		LeaveRule ("propertyChain"' 7);  		LeaveRule_propertyChain ();  	}  	DebugLocation (153' 1);  }  finally {  	DebugExitRule (GrammarFileName' "propertyChain");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyChain,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "propertyChain");  	DebugLocation (146' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:147:2: ( ^( ID propertyChain[propertySegments] ) | ^( ESC_ID propertyChain[propertySegments] ) )  		int alt10 = 2;  		try {  			DebugEnterDecision (10' false);  			int LA10_1 = input.LA (1);  			if ((LA10_1 == ID)) {  				alt10 = 1;  			}  			else if ((LA10_1 == ESC_ID)) {  				alt10 = 2;  			}  			else {  				NoViableAltException nvae = new NoViableAltException (""' 10' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  		}  		finally {  			DebugExitDecision (10);  		}  		switch (alt10) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:147:4: ^( ID propertyChain[propertySegments] )  			{  				DebugLocation (147' 4);  				DebugLocation (147' 6);  				ID10 = (CommonTree)Match (input' ID' Follow._ID_in_propertyChain310);  				DebugLocation (148' 3);  				propertySegments.Add ((ID10 != null ? ID10.Text : default(string)));  				Match (input' TokenTypes.Down' null);  				DebugLocation (149' 3);  				PushFollow (Follow._propertyChain_in_propertyChain318);  				propertyChain (propertySegments);  				PopFollow ();  				Match (input' TokenTypes.Up' null);  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:150:4: ^( ESC_ID propertyChain[propertySegments] )  			{  				DebugLocation (150' 4);  				DebugLocation (150' 6);  				ESC_ID11 = (CommonTree)Match (input' ESC_ID' Follow._ESC_ID_in_propertyChain326);  				DebugLocation (151' 3);  				propertySegments.Add ((ESC_ID11 != null ? ESC_ID11.Text : default(string)));  				Match (input' TokenTypes.Down' null);  				DebugLocation (152' 3);  				PushFollow (Follow._propertyChain_in_propertyChain334);  				propertyChain (propertySegments);  				PopFollow ();  				Match (input' TokenTypes.Up' null);  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("propertyChain"' 7);  		LeaveRule ("propertyChain"' 7);  		LeaveRule_propertyChain ();  	}  	DebugLocation (153' 1);  }  finally {  	DebugExitRule (GrammarFileName' "propertyChain");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyChain,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "propertyChain");  	DebugLocation (146' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:147:2: ( ^( ID propertyChain[propertySegments] ) | ^( ESC_ID propertyChain[propertySegments] ) )  		int alt10 = 2;  		try {  			DebugEnterDecision (10' false);  			int LA10_1 = input.LA (1);  			if ((LA10_1 == ID)) {  				alt10 = 1;  			}  			else if ((LA10_1 == ESC_ID)) {  				alt10 = 2;  			}  			else {  				NoViableAltException nvae = new NoViableAltException (""' 10' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  		}  		finally {  			DebugExitDecision (10);  		}  		switch (alt10) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:147:4: ^( ID propertyChain[propertySegments] )  			{  				DebugLocation (147' 4);  				DebugLocation (147' 6);  				ID10 = (CommonTree)Match (input' ID' Follow._ID_in_propertyChain310);  				DebugLocation (148' 3);  				propertySegments.Add ((ID10 != null ? ID10.Text : default(string)));  				Match (input' TokenTypes.Down' null);  				DebugLocation (149' 3);  				PushFollow (Follow._propertyChain_in_propertyChain318);  				propertyChain (propertySegments);  				PopFollow ();  				Match (input' TokenTypes.Up' null);  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:150:4: ^( ESC_ID propertyChain[propertySegments] )  			{  				DebugLocation (150' 4);  				DebugLocation (150' 6);  				ESC_ID11 = (CommonTree)Match (input' ESC_ID' Follow._ESC_ID_in_propertyChain326);  				DebugLocation (151' 3);  				propertySegments.Add ((ESC_ID11 != null ? ESC_ID11.Text : default(string)));  				Match (input' TokenTypes.Down' null);  				DebugLocation (152' 3);  				PushFollow (Follow._propertyChain_in_propertyChain334);  				propertyChain (propertySegments);  				PopFollow ();  				Match (input' TokenTypes.Up' null);  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("propertyChain"' 7);  		LeaveRule ("propertyChain"' 7);  		LeaveRule_propertyChain ();  	}  	DebugLocation (153' 1);  }  finally {  	DebugExitRule (GrammarFileName' "propertyChain");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyChain,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "propertyChain");  	DebugLocation (146' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:147:2: ( ^( ID propertyChain[propertySegments] ) | ^( ESC_ID propertyChain[propertySegments] ) )  		int alt10 = 2;  		try {  			DebugEnterDecision (10' false);  			int LA10_1 = input.LA (1);  			if ((LA10_1 == ID)) {  				alt10 = 1;  			}  			else if ((LA10_1 == ESC_ID)) {  				alt10 = 2;  			}  			else {  				NoViableAltException nvae = new NoViableAltException (""' 10' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  		}  		finally {  			DebugExitDecision (10);  		}  		switch (alt10) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:147:4: ^( ID propertyChain[propertySegments] )  			{  				DebugLocation (147' 4);  				DebugLocation (147' 6);  				ID10 = (CommonTree)Match (input' ID' Follow._ID_in_propertyChain310);  				DebugLocation (148' 3);  				propertySegments.Add ((ID10 != null ? ID10.Text : default(string)));  				Match (input' TokenTypes.Down' null);  				DebugLocation (149' 3);  				PushFollow (Follow._propertyChain_in_propertyChain318);  				propertyChain (propertySegments);  				PopFollow ();  				Match (input' TokenTypes.Up' null);  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:150:4: ^( ESC_ID propertyChain[propertySegments] )  			{  				DebugLocation (150' 4);  				DebugLocation (150' 6);  				ESC_ID11 = (CommonTree)Match (input' ESC_ID' Follow._ESC_ID_in_propertyChain326);  				DebugLocation (151' 3);  				propertySegments.Add ((ESC_ID11 != null ? ESC_ID11.Text : default(string)));  				Match (input' TokenTypes.Down' null);  				DebugLocation (152' 3);  				PushFollow (Follow._propertyChain_in_propertyChain334);  				propertyChain (propertySegments);  				PopFollow ();  				Match (input' TokenTypes.Up' null);  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("propertyChain"' 7);  		LeaveRule ("propertyChain"' 7);  		LeaveRule_propertyChain ();  	}  	DebugLocation (153' 1);  }  finally {  	DebugExitRule (GrammarFileName' "propertyChain");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyChain,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "propertyChain");  	DebugLocation (146' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:147:2: ( ^( ID propertyChain[propertySegments] ) | ^( ESC_ID propertyChain[propertySegments] ) )  		int alt10 = 2;  		try {  			DebugEnterDecision (10' false);  			int LA10_1 = input.LA (1);  			if ((LA10_1 == ID)) {  				alt10 = 1;  			}  			else if ((LA10_1 == ESC_ID)) {  				alt10 = 2;  			}  			else {  				NoViableAltException nvae = new NoViableAltException (""' 10' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  		}  		finally {  			DebugExitDecision (10);  		}  		switch (alt10) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:147:4: ^( ID propertyChain[propertySegments] )  			{  				DebugLocation (147' 4);  				DebugLocation (147' 6);  				ID10 = (CommonTree)Match (input' ID' Follow._ID_in_propertyChain310);  				DebugLocation (148' 3);  				propertySegments.Add ((ID10 != null ? ID10.Text : default(string)));  				Match (input' TokenTypes.Down' null);  				DebugLocation (149' 3);  				PushFollow (Follow._propertyChain_in_propertyChain318);  				propertyChain (propertySegments);  				PopFollow ();  				Match (input' TokenTypes.Up' null);  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:150:4: ^( ESC_ID propertyChain[propertySegments] )  			{  				DebugLocation (150' 4);  				DebugLocation (150' 6);  				ESC_ID11 = (CommonTree)Match (input' ESC_ID' Follow._ESC_ID_in_propertyChain326);  				DebugLocation (151' 3);  				propertySegments.Add ((ESC_ID11 != null ? ESC_ID11.Text : default(string)));  				Match (input' TokenTypes.Down' null);  				DebugLocation (152' 3);  				PushFollow (Follow._propertyChain_in_propertyChain334);  				propertyChain (propertySegments);  				PopFollow ();  				Match (input' TokenTypes.Up' null);  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("propertyChain"' 7);  		LeaveRule ("propertyChain"' 7);  		LeaveRule_propertyChain ();  	}  	DebugLocation (153' 1);  }  finally {  	DebugExitRule (GrammarFileName' "propertyChain");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyChain,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "propertyChain");  	DebugLocation (146' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:147:2: ( ^( ID propertyChain[propertySegments] ) | ^( ESC_ID propertyChain[propertySegments] ) )  		int alt10 = 2;  		try {  			DebugEnterDecision (10' false);  			int LA10_1 = input.LA (1);  			if ((LA10_1 == ID)) {  				alt10 = 1;  			}  			else if ((LA10_1 == ESC_ID)) {  				alt10 = 2;  			}  			else {  				NoViableAltException nvae = new NoViableAltException (""' 10' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  		}  		finally {  			DebugExitDecision (10);  		}  		switch (alt10) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:147:4: ^( ID propertyChain[propertySegments] )  			{  				DebugLocation (147' 4);  				DebugLocation (147' 6);  				ID10 = (CommonTree)Match (input' ID' Follow._ID_in_propertyChain310);  				DebugLocation (148' 3);  				propertySegments.Add ((ID10 != null ? ID10.Text : default(string)));  				Match (input' TokenTypes.Down' null);  				DebugLocation (149' 3);  				PushFollow (Follow._propertyChain_in_propertyChain318);  				propertyChain (propertySegments);  				PopFollow ();  				Match (input' TokenTypes.Up' null);  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:150:4: ^( ESC_ID propertyChain[propertySegments] )  			{  				DebugLocation (150' 4);  				DebugLocation (150' 6);  				ESC_ID11 = (CommonTree)Match (input' ESC_ID' Follow._ESC_ID_in_propertyChain326);  				DebugLocation (151' 3);  				propertySegments.Add ((ESC_ID11 != null ? ESC_ID11.Text : default(string)));  				Match (input' TokenTypes.Down' null);  				DebugLocation (152' 3);  				PushFollow (Follow._propertyChain_in_propertyChain334);  				propertyChain (propertySegments);  				PopFollow ();  				Match (input' TokenTypes.Up' null);  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("propertyChain"' 7);  		LeaveRule ("propertyChain"' 7);  		LeaveRule_propertyChain ();  	}  	DebugLocation (153' 1);  }  finally {  	DebugExitRule (GrammarFileName' "propertyChain");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyChain,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "propertyChain");  	DebugLocation (146' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:147:2: ( ^( ID propertyChain[propertySegments] ) | ^( ESC_ID propertyChain[propertySegments] ) )  		int alt10 = 2;  		try {  			DebugEnterDecision (10' false);  			int LA10_1 = input.LA (1);  			if ((LA10_1 == ID)) {  				alt10 = 1;  			}  			else if ((LA10_1 == ESC_ID)) {  				alt10 = 2;  			}  			else {  				NoViableAltException nvae = new NoViableAltException (""' 10' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  		}  		finally {  			DebugExitDecision (10);  		}  		switch (alt10) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:147:4: ^( ID propertyChain[propertySegments] )  			{  				DebugLocation (147' 4);  				DebugLocation (147' 6);  				ID10 = (CommonTree)Match (input' ID' Follow._ID_in_propertyChain310);  				DebugLocation (148' 3);  				propertySegments.Add ((ID10 != null ? ID10.Text : default(string)));  				Match (input' TokenTypes.Down' null);  				DebugLocation (149' 3);  				PushFollow (Follow._propertyChain_in_propertyChain318);  				propertyChain (propertySegments);  				PopFollow ();  				Match (input' TokenTypes.Up' null);  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:150:4: ^( ESC_ID propertyChain[propertySegments] )  			{  				DebugLocation (150' 4);  				DebugLocation (150' 6);  				ESC_ID11 = (CommonTree)Match (input' ESC_ID' Follow._ESC_ID_in_propertyChain326);  				DebugLocation (151' 3);  				propertySegments.Add ((ESC_ID11 != null ? ESC_ID11.Text : default(string)));  				Match (input' TokenTypes.Down' null);  				DebugLocation (152' 3);  				PushFollow (Follow._propertyChain_in_propertyChain334);  				propertyChain (propertySegments);  				PopFollow ();  				Match (input' TokenTypes.Up' null);  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("propertyChain"' 7);  		LeaveRule ("propertyChain"' 7);  		LeaveRule_propertyChain ();  	}  	DebugLocation (153' 1);  }  finally {  	DebugExitRule (GrammarFileName' "propertyChain");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyChain,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "propertyChain");  	DebugLocation (146' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:147:2: ( ^( ID propertyChain[propertySegments] ) | ^( ESC_ID propertyChain[propertySegments] ) )  		int alt10 = 2;  		try {  			DebugEnterDecision (10' false);  			int LA10_1 = input.LA (1);  			if ((LA10_1 == ID)) {  				alt10 = 1;  			}  			else if ((LA10_1 == ESC_ID)) {  				alt10 = 2;  			}  			else {  				NoViableAltException nvae = new NoViableAltException (""' 10' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  		}  		finally {  			DebugExitDecision (10);  		}  		switch (alt10) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:147:4: ^( ID propertyChain[propertySegments] )  			{  				DebugLocation (147' 4);  				DebugLocation (147' 6);  				ID10 = (CommonTree)Match (input' ID' Follow._ID_in_propertyChain310);  				DebugLocation (148' 3);  				propertySegments.Add ((ID10 != null ? ID10.Text : default(string)));  				Match (input' TokenTypes.Down' null);  				DebugLocation (149' 3);  				PushFollow (Follow._propertyChain_in_propertyChain318);  				propertyChain (propertySegments);  				PopFollow ();  				Match (input' TokenTypes.Up' null);  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:150:4: ^( ESC_ID propertyChain[propertySegments] )  			{  				DebugLocation (150' 4);  				DebugLocation (150' 6);  				ESC_ID11 = (CommonTree)Match (input' ESC_ID' Follow._ESC_ID_in_propertyChain326);  				DebugLocation (151' 3);  				propertySegments.Add ((ESC_ID11 != null ? ESC_ID11.Text : default(string)));  				Match (input' TokenTypes.Down' null);  				DebugLocation (152' 3);  				PushFollow (Follow._propertyChain_in_propertyChain334);  				propertyChain (propertySegments);  				PopFollow ();  				Match (input' TokenTypes.Up' null);  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("propertyChain"' 7);  		LeaveRule ("propertyChain"' 7);  		LeaveRule_propertyChain ();  	}  	DebugLocation (153' 1);  }  finally {  	DebugExitRule (GrammarFileName' "propertyChain");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyChain,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "propertyChain");  	DebugLocation (146' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:147:2: ( ^( ID propertyChain[propertySegments] ) | ^( ESC_ID propertyChain[propertySegments] ) )  		int alt10 = 2;  		try {  			DebugEnterDecision (10' false);  			int LA10_1 = input.LA (1);  			if ((LA10_1 == ID)) {  				alt10 = 1;  			}  			else if ((LA10_1 == ESC_ID)) {  				alt10 = 2;  			}  			else {  				NoViableAltException nvae = new NoViableAltException (""' 10' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  		}  		finally {  			DebugExitDecision (10);  		}  		switch (alt10) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:147:4: ^( ID propertyChain[propertySegments] )  			{  				DebugLocation (147' 4);  				DebugLocation (147' 6);  				ID10 = (CommonTree)Match (input' ID' Follow._ID_in_propertyChain310);  				DebugLocation (148' 3);  				propertySegments.Add ((ID10 != null ? ID10.Text : default(string)));  				Match (input' TokenTypes.Down' null);  				DebugLocation (149' 3);  				PushFollow (Follow._propertyChain_in_propertyChain318);  				propertyChain (propertySegments);  				PopFollow ();  				Match (input' TokenTypes.Up' null);  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:150:4: ^( ESC_ID propertyChain[propertySegments] )  			{  				DebugLocation (150' 4);  				DebugLocation (150' 6);  				ESC_ID11 = (CommonTree)Match (input' ESC_ID' Follow._ESC_ID_in_propertyChain326);  				DebugLocation (151' 3);  				propertySegments.Add ((ESC_ID11 != null ? ESC_ID11.Text : default(string)));  				Match (input' TokenTypes.Down' null);  				DebugLocation (152' 3);  				PushFollow (Follow._propertyChain_in_propertyChain334);  				propertyChain (propertySegments);  				PopFollow ();  				Match (input' TokenTypes.Up' null);  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("propertyChain"' 7);  		LeaveRule ("propertyChain"' 7);  		LeaveRule_propertyChain ();  	}  	DebugLocation (153' 1);  }  finally {  	DebugExitRule (GrammarFileName' "propertyChain");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyChain,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "propertyChain");  	DebugLocation (146' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:147:2: ( ^( ID propertyChain[propertySegments] ) | ^( ESC_ID propertyChain[propertySegments] ) )  		int alt10 = 2;  		try {  			DebugEnterDecision (10' false);  			int LA10_1 = input.LA (1);  			if ((LA10_1 == ID)) {  				alt10 = 1;  			}  			else if ((LA10_1 == ESC_ID)) {  				alt10 = 2;  			}  			else {  				NoViableAltException nvae = new NoViableAltException (""' 10' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  		}  		finally {  			DebugExitDecision (10);  		}  		switch (alt10) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:147:4: ^( ID propertyChain[propertySegments] )  			{  				DebugLocation (147' 4);  				DebugLocation (147' 6);  				ID10 = (CommonTree)Match (input' ID' Follow._ID_in_propertyChain310);  				DebugLocation (148' 3);  				propertySegments.Add ((ID10 != null ? ID10.Text : default(string)));  				Match (input' TokenTypes.Down' null);  				DebugLocation (149' 3);  				PushFollow (Follow._propertyChain_in_propertyChain318);  				propertyChain (propertySegments);  				PopFollow ();  				Match (input' TokenTypes.Up' null);  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:150:4: ^( ESC_ID propertyChain[propertySegments] )  			{  				DebugLocation (150' 4);  				DebugLocation (150' 6);  				ESC_ID11 = (CommonTree)Match (input' ESC_ID' Follow._ESC_ID_in_propertyChain326);  				DebugLocation (151' 3);  				propertySegments.Add ((ESC_ID11 != null ? ESC_ID11.Text : default(string)));  				Match (input' TokenTypes.Down' null);  				DebugLocation (152' 3);  				PushFollow (Follow._propertyChain_in_propertyChain334);  				propertyChain (propertySegments);  				PopFollow ();  				Match (input' TokenTypes.Up' null);  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("propertyChain"' 7);  		LeaveRule ("propertyChain"' 7);  		LeaveRule_propertyChain ();  	}  	DebugLocation (153' 1);  }  finally {  	DebugExitRule (GrammarFileName' "propertyChain");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyChain,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "propertyChain");  	DebugLocation (146' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:147:2: ( ^( ID propertyChain[propertySegments] ) | ^( ESC_ID propertyChain[propertySegments] ) )  		int alt10 = 2;  		try {  			DebugEnterDecision (10' false);  			int LA10_1 = input.LA (1);  			if ((LA10_1 == ID)) {  				alt10 = 1;  			}  			else if ((LA10_1 == ESC_ID)) {  				alt10 = 2;  			}  			else {  				NoViableAltException nvae = new NoViableAltException (""' 10' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  		}  		finally {  			DebugExitDecision (10);  		}  		switch (alt10) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:147:4: ^( ID propertyChain[propertySegments] )  			{  				DebugLocation (147' 4);  				DebugLocation (147' 6);  				ID10 = (CommonTree)Match (input' ID' Follow._ID_in_propertyChain310);  				DebugLocation (148' 3);  				propertySegments.Add ((ID10 != null ? ID10.Text : default(string)));  				Match (input' TokenTypes.Down' null);  				DebugLocation (149' 3);  				PushFollow (Follow._propertyChain_in_propertyChain318);  				propertyChain (propertySegments);  				PopFollow ();  				Match (input' TokenTypes.Up' null);  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:150:4: ^( ESC_ID propertyChain[propertySegments] )  			{  				DebugLocation (150' 4);  				DebugLocation (150' 6);  				ESC_ID11 = (CommonTree)Match (input' ESC_ID' Follow._ESC_ID_in_propertyChain326);  				DebugLocation (151' 3);  				propertySegments.Add ((ESC_ID11 != null ? ESC_ID11.Text : default(string)));  				Match (input' TokenTypes.Down' null);  				DebugLocation (152' 3);  				PushFollow (Follow._propertyChain_in_propertyChain334);  				propertyChain (propertySegments);  				PopFollow ();  				Match (input' TokenTypes.Up' null);  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("propertyChain"' 7);  		LeaveRule ("propertyChain"' 7);  		LeaveRule_propertyChain ();  	}  	DebugLocation (153' 1);  }  finally {  	DebugExitRule (GrammarFileName' "propertyChain");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyChain,The following statement contains a magic number: DebugLocation (146' 1);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyChain,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:147:2: ( ^( ID propertyChain[propertySegments] ) | ^( ESC_ID propertyChain[propertySegments] ) )  	int alt10 = 2;  	try {  		DebugEnterDecision (10' false);  		int LA10_1 = input.LA (1);  		if ((LA10_1 == ID)) {  			alt10 = 1;  		}  		else if ((LA10_1 == ESC_ID)) {  			alt10 = 2;  		}  		else {  			NoViableAltException nvae = new NoViableAltException (""' 10' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  	}  	finally {  		DebugExitDecision (10);  	}  	switch (alt10) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:147:4: ^( ID propertyChain[propertySegments] )  		{  			DebugLocation (147' 4);  			DebugLocation (147' 6);  			ID10 = (CommonTree)Match (input' ID' Follow._ID_in_propertyChain310);  			DebugLocation (148' 3);  			propertySegments.Add ((ID10 != null ? ID10.Text : default(string)));  			Match (input' TokenTypes.Down' null);  			DebugLocation (149' 3);  			PushFollow (Follow._propertyChain_in_propertyChain318);  			propertyChain (propertySegments);  			PopFollow ();  			Match (input' TokenTypes.Up' null);  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:150:4: ^( ESC_ID propertyChain[propertySegments] )  		{  			DebugLocation (150' 4);  			DebugLocation (150' 6);  			ESC_ID11 = (CommonTree)Match (input' ESC_ID' Follow._ESC_ID_in_propertyChain326);  			DebugLocation (151' 3);  			propertySegments.Add ((ESC_ID11 != null ? ESC_ID11.Text : default(string)));  			Match (input' TokenTypes.Down' null);  			DebugLocation (152' 3);  			PushFollow (Follow._propertyChain_in_propertyChain334);  			propertyChain (propertySegments);  			PopFollow ();  			Match (input' TokenTypes.Up' null);  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("propertyChain"' 7);  	LeaveRule ("propertyChain"' 7);  	LeaveRule_propertyChain ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyChain,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:147:2: ( ^( ID propertyChain[propertySegments] ) | ^( ESC_ID propertyChain[propertySegments] ) )  	int alt10 = 2;  	try {  		DebugEnterDecision (10' false);  		int LA10_1 = input.LA (1);  		if ((LA10_1 == ID)) {  			alt10 = 1;  		}  		else if ((LA10_1 == ESC_ID)) {  			alt10 = 2;  		}  		else {  			NoViableAltException nvae = new NoViableAltException (""' 10' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  	}  	finally {  		DebugExitDecision (10);  	}  	switch (alt10) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:147:4: ^( ID propertyChain[propertySegments] )  		{  			DebugLocation (147' 4);  			DebugLocation (147' 6);  			ID10 = (CommonTree)Match (input' ID' Follow._ID_in_propertyChain310);  			DebugLocation (148' 3);  			propertySegments.Add ((ID10 != null ? ID10.Text : default(string)));  			Match (input' TokenTypes.Down' null);  			DebugLocation (149' 3);  			PushFollow (Follow._propertyChain_in_propertyChain318);  			propertyChain (propertySegments);  			PopFollow ();  			Match (input' TokenTypes.Up' null);  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:150:4: ^( ESC_ID propertyChain[propertySegments] )  		{  			DebugLocation (150' 4);  			DebugLocation (150' 6);  			ESC_ID11 = (CommonTree)Match (input' ESC_ID' Follow._ESC_ID_in_propertyChain326);  			DebugLocation (151' 3);  			propertySegments.Add ((ESC_ID11 != null ? ESC_ID11.Text : default(string)));  			Match (input' TokenTypes.Down' null);  			DebugLocation (152' 3);  			PushFollow (Follow._propertyChain_in_propertyChain334);  			propertyChain (propertySegments);  			PopFollow ();  			Match (input' TokenTypes.Up' null);  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("propertyChain"' 7);  	LeaveRule ("propertyChain"' 7);  	LeaveRule_propertyChain ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyChain,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:147:2: ( ^( ID propertyChain[propertySegments] ) | ^( ESC_ID propertyChain[propertySegments] ) )  	int alt10 = 2;  	try {  		DebugEnterDecision (10' false);  		int LA10_1 = input.LA (1);  		if ((LA10_1 == ID)) {  			alt10 = 1;  		}  		else if ((LA10_1 == ESC_ID)) {  			alt10 = 2;  		}  		else {  			NoViableAltException nvae = new NoViableAltException (""' 10' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  	}  	finally {  		DebugExitDecision (10);  	}  	switch (alt10) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:147:4: ^( ID propertyChain[propertySegments] )  		{  			DebugLocation (147' 4);  			DebugLocation (147' 6);  			ID10 = (CommonTree)Match (input' ID' Follow._ID_in_propertyChain310);  			DebugLocation (148' 3);  			propertySegments.Add ((ID10 != null ? ID10.Text : default(string)));  			Match (input' TokenTypes.Down' null);  			DebugLocation (149' 3);  			PushFollow (Follow._propertyChain_in_propertyChain318);  			propertyChain (propertySegments);  			PopFollow ();  			Match (input' TokenTypes.Up' null);  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:150:4: ^( ESC_ID propertyChain[propertySegments] )  		{  			DebugLocation (150' 4);  			DebugLocation (150' 6);  			ESC_ID11 = (CommonTree)Match (input' ESC_ID' Follow._ESC_ID_in_propertyChain326);  			DebugLocation (151' 3);  			propertySegments.Add ((ESC_ID11 != null ? ESC_ID11.Text : default(string)));  			Match (input' TokenTypes.Down' null);  			DebugLocation (152' 3);  			PushFollow (Follow._propertyChain_in_propertyChain334);  			propertyChain (propertySegments);  			PopFollow ();  			Match (input' TokenTypes.Up' null);  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("propertyChain"' 7);  	LeaveRule ("propertyChain"' 7);  	LeaveRule_propertyChain ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyChain,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:147:2: ( ^( ID propertyChain[propertySegments] ) | ^( ESC_ID propertyChain[propertySegments] ) )  	int alt10 = 2;  	try {  		DebugEnterDecision (10' false);  		int LA10_1 = input.LA (1);  		if ((LA10_1 == ID)) {  			alt10 = 1;  		}  		else if ((LA10_1 == ESC_ID)) {  			alt10 = 2;  		}  		else {  			NoViableAltException nvae = new NoViableAltException (""' 10' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  	}  	finally {  		DebugExitDecision (10);  	}  	switch (alt10) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:147:4: ^( ID propertyChain[propertySegments] )  		{  			DebugLocation (147' 4);  			DebugLocation (147' 6);  			ID10 = (CommonTree)Match (input' ID' Follow._ID_in_propertyChain310);  			DebugLocation (148' 3);  			propertySegments.Add ((ID10 != null ? ID10.Text : default(string)));  			Match (input' TokenTypes.Down' null);  			DebugLocation (149' 3);  			PushFollow (Follow._propertyChain_in_propertyChain318);  			propertyChain (propertySegments);  			PopFollow ();  			Match (input' TokenTypes.Up' null);  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:150:4: ^( ESC_ID propertyChain[propertySegments] )  		{  			DebugLocation (150' 4);  			DebugLocation (150' 6);  			ESC_ID11 = (CommonTree)Match (input' ESC_ID' Follow._ESC_ID_in_propertyChain326);  			DebugLocation (151' 3);  			propertySegments.Add ((ESC_ID11 != null ? ESC_ID11.Text : default(string)));  			Match (input' TokenTypes.Down' null);  			DebugLocation (152' 3);  			PushFollow (Follow._propertyChain_in_propertyChain334);  			propertyChain (propertySegments);  			PopFollow ();  			Match (input' TokenTypes.Up' null);  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("propertyChain"' 7);  	LeaveRule ("propertyChain"' 7);  	LeaveRule_propertyChain ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyChain,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:147:2: ( ^( ID propertyChain[propertySegments] ) | ^( ESC_ID propertyChain[propertySegments] ) )  	int alt10 = 2;  	try {  		DebugEnterDecision (10' false);  		int LA10_1 = input.LA (1);  		if ((LA10_1 == ID)) {  			alt10 = 1;  		}  		else if ((LA10_1 == ESC_ID)) {  			alt10 = 2;  		}  		else {  			NoViableAltException nvae = new NoViableAltException (""' 10' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  	}  	finally {  		DebugExitDecision (10);  	}  	switch (alt10) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:147:4: ^( ID propertyChain[propertySegments] )  		{  			DebugLocation (147' 4);  			DebugLocation (147' 6);  			ID10 = (CommonTree)Match (input' ID' Follow._ID_in_propertyChain310);  			DebugLocation (148' 3);  			propertySegments.Add ((ID10 != null ? ID10.Text : default(string)));  			Match (input' TokenTypes.Down' null);  			DebugLocation (149' 3);  			PushFollow (Follow._propertyChain_in_propertyChain318);  			propertyChain (propertySegments);  			PopFollow ();  			Match (input' TokenTypes.Up' null);  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:150:4: ^( ESC_ID propertyChain[propertySegments] )  		{  			DebugLocation (150' 4);  			DebugLocation (150' 6);  			ESC_ID11 = (CommonTree)Match (input' ESC_ID' Follow._ESC_ID_in_propertyChain326);  			DebugLocation (151' 3);  			propertySegments.Add ((ESC_ID11 != null ? ESC_ID11.Text : default(string)));  			Match (input' TokenTypes.Down' null);  			DebugLocation (152' 3);  			PushFollow (Follow._propertyChain_in_propertyChain334);  			propertyChain (propertySegments);  			PopFollow ();  			Match (input' TokenTypes.Up' null);  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("propertyChain"' 7);  	LeaveRule ("propertyChain"' 7);  	LeaveRule_propertyChain ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyChain,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:147:2: ( ^( ID propertyChain[propertySegments] ) | ^( ESC_ID propertyChain[propertySegments] ) )  	int alt10 = 2;  	try {  		DebugEnterDecision (10' false);  		int LA10_1 = input.LA (1);  		if ((LA10_1 == ID)) {  			alt10 = 1;  		}  		else if ((LA10_1 == ESC_ID)) {  			alt10 = 2;  		}  		else {  			NoViableAltException nvae = new NoViableAltException (""' 10' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  	}  	finally {  		DebugExitDecision (10);  	}  	switch (alt10) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:147:4: ^( ID propertyChain[propertySegments] )  		{  			DebugLocation (147' 4);  			DebugLocation (147' 6);  			ID10 = (CommonTree)Match (input' ID' Follow._ID_in_propertyChain310);  			DebugLocation (148' 3);  			propertySegments.Add ((ID10 != null ? ID10.Text : default(string)));  			Match (input' TokenTypes.Down' null);  			DebugLocation (149' 3);  			PushFollow (Follow._propertyChain_in_propertyChain318);  			propertyChain (propertySegments);  			PopFollow ();  			Match (input' TokenTypes.Up' null);  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:150:4: ^( ESC_ID propertyChain[propertySegments] )  		{  			DebugLocation (150' 4);  			DebugLocation (150' 6);  			ESC_ID11 = (CommonTree)Match (input' ESC_ID' Follow._ESC_ID_in_propertyChain326);  			DebugLocation (151' 3);  			propertySegments.Add ((ESC_ID11 != null ? ESC_ID11.Text : default(string)));  			Match (input' TokenTypes.Down' null);  			DebugLocation (152' 3);  			PushFollow (Follow._propertyChain_in_propertyChain334);  			propertyChain (propertySegments);  			PopFollow ();  			Match (input' TokenTypes.Up' null);  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("propertyChain"' 7);  	LeaveRule ("propertyChain"' 7);  	LeaveRule_propertyChain ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyChain,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:147:2: ( ^( ID propertyChain[propertySegments] ) | ^( ESC_ID propertyChain[propertySegments] ) )  	int alt10 = 2;  	try {  		DebugEnterDecision (10' false);  		int LA10_1 = input.LA (1);  		if ((LA10_1 == ID)) {  			alt10 = 1;  		}  		else if ((LA10_1 == ESC_ID)) {  			alt10 = 2;  		}  		else {  			NoViableAltException nvae = new NoViableAltException (""' 10' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  	}  	finally {  		DebugExitDecision (10);  	}  	switch (alt10) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:147:4: ^( ID propertyChain[propertySegments] )  		{  			DebugLocation (147' 4);  			DebugLocation (147' 6);  			ID10 = (CommonTree)Match (input' ID' Follow._ID_in_propertyChain310);  			DebugLocation (148' 3);  			propertySegments.Add ((ID10 != null ? ID10.Text : default(string)));  			Match (input' TokenTypes.Down' null);  			DebugLocation (149' 3);  			PushFollow (Follow._propertyChain_in_propertyChain318);  			propertyChain (propertySegments);  			PopFollow ();  			Match (input' TokenTypes.Up' null);  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:150:4: ^( ESC_ID propertyChain[propertySegments] )  		{  			DebugLocation (150' 4);  			DebugLocation (150' 6);  			ESC_ID11 = (CommonTree)Match (input' ESC_ID' Follow._ESC_ID_in_propertyChain326);  			DebugLocation (151' 3);  			propertySegments.Add ((ESC_ID11 != null ? ESC_ID11.Text : default(string)));  			Match (input' TokenTypes.Down' null);  			DebugLocation (152' 3);  			PushFollow (Follow._propertyChain_in_propertyChain334);  			propertyChain (propertySegments);  			PopFollow ();  			Match (input' TokenTypes.Up' null);  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("propertyChain"' 7);  	LeaveRule ("propertyChain"' 7);  	LeaveRule_propertyChain ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyChain,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:147:2: ( ^( ID propertyChain[propertySegments] ) | ^( ESC_ID propertyChain[propertySegments] ) )  	int alt10 = 2;  	try {  		DebugEnterDecision (10' false);  		int LA10_1 = input.LA (1);  		if ((LA10_1 == ID)) {  			alt10 = 1;  		}  		else if ((LA10_1 == ESC_ID)) {  			alt10 = 2;  		}  		else {  			NoViableAltException nvae = new NoViableAltException (""' 10' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  	}  	finally {  		DebugExitDecision (10);  	}  	switch (alt10) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:147:4: ^( ID propertyChain[propertySegments] )  		{  			DebugLocation (147' 4);  			DebugLocation (147' 6);  			ID10 = (CommonTree)Match (input' ID' Follow._ID_in_propertyChain310);  			DebugLocation (148' 3);  			propertySegments.Add ((ID10 != null ? ID10.Text : default(string)));  			Match (input' TokenTypes.Down' null);  			DebugLocation (149' 3);  			PushFollow (Follow._propertyChain_in_propertyChain318);  			propertyChain (propertySegments);  			PopFollow ();  			Match (input' TokenTypes.Up' null);  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:150:4: ^( ESC_ID propertyChain[propertySegments] )  		{  			DebugLocation (150' 4);  			DebugLocation (150' 6);  			ESC_ID11 = (CommonTree)Match (input' ESC_ID' Follow._ESC_ID_in_propertyChain326);  			DebugLocation (151' 3);  			propertySegments.Add ((ESC_ID11 != null ? ESC_ID11.Text : default(string)));  			Match (input' TokenTypes.Down' null);  			DebugLocation (152' 3);  			PushFollow (Follow._propertyChain_in_propertyChain334);  			propertyChain (propertySegments);  			PopFollow ();  			Match (input' TokenTypes.Up' null);  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("propertyChain"' 7);  	LeaveRule ("propertyChain"' 7);  	LeaveRule_propertyChain ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyChain,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:147:2: ( ^( ID propertyChain[propertySegments] ) | ^( ESC_ID propertyChain[propertySegments] ) )  	int alt10 = 2;  	try {  		DebugEnterDecision (10' false);  		int LA10_1 = input.LA (1);  		if ((LA10_1 == ID)) {  			alt10 = 1;  		}  		else if ((LA10_1 == ESC_ID)) {  			alt10 = 2;  		}  		else {  			NoViableAltException nvae = new NoViableAltException (""' 10' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  	}  	finally {  		DebugExitDecision (10);  	}  	switch (alt10) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:147:4: ^( ID propertyChain[propertySegments] )  		{  			DebugLocation (147' 4);  			DebugLocation (147' 6);  			ID10 = (CommonTree)Match (input' ID' Follow._ID_in_propertyChain310);  			DebugLocation (148' 3);  			propertySegments.Add ((ID10 != null ? ID10.Text : default(string)));  			Match (input' TokenTypes.Down' null);  			DebugLocation (149' 3);  			PushFollow (Follow._propertyChain_in_propertyChain318);  			propertyChain (propertySegments);  			PopFollow ();  			Match (input' TokenTypes.Up' null);  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:150:4: ^( ESC_ID propertyChain[propertySegments] )  		{  			DebugLocation (150' 4);  			DebugLocation (150' 6);  			ESC_ID11 = (CommonTree)Match (input' ESC_ID' Follow._ESC_ID_in_propertyChain326);  			DebugLocation (151' 3);  			propertySegments.Add ((ESC_ID11 != null ? ESC_ID11.Text : default(string)));  			Match (input' TokenTypes.Down' null);  			DebugLocation (152' 3);  			PushFollow (Follow._propertyChain_in_propertyChain334);  			propertyChain (propertySegments);  			PopFollow ();  			Match (input' TokenTypes.Up' null);  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("propertyChain"' 7);  	LeaveRule ("propertyChain"' 7);  	LeaveRule_propertyChain ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyChain,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:147:2: ( ^( ID propertyChain[propertySegments] ) | ^( ESC_ID propertyChain[propertySegments] ) )  	int alt10 = 2;  	try {  		DebugEnterDecision (10' false);  		int LA10_1 = input.LA (1);  		if ((LA10_1 == ID)) {  			alt10 = 1;  		}  		else if ((LA10_1 == ESC_ID)) {  			alt10 = 2;  		}  		else {  			NoViableAltException nvae = new NoViableAltException (""' 10' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  	}  	finally {  		DebugExitDecision (10);  	}  	switch (alt10) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:147:4: ^( ID propertyChain[propertySegments] )  		{  			DebugLocation (147' 4);  			DebugLocation (147' 6);  			ID10 = (CommonTree)Match (input' ID' Follow._ID_in_propertyChain310);  			DebugLocation (148' 3);  			propertySegments.Add ((ID10 != null ? ID10.Text : default(string)));  			Match (input' TokenTypes.Down' null);  			DebugLocation (149' 3);  			PushFollow (Follow._propertyChain_in_propertyChain318);  			propertyChain (propertySegments);  			PopFollow ();  			Match (input' TokenTypes.Up' null);  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:150:4: ^( ESC_ID propertyChain[propertySegments] )  		{  			DebugLocation (150' 4);  			DebugLocation (150' 6);  			ESC_ID11 = (CommonTree)Match (input' ESC_ID' Follow._ESC_ID_in_propertyChain326);  			DebugLocation (151' 3);  			propertySegments.Add ((ESC_ID11 != null ? ESC_ID11.Text : default(string)));  			Match (input' TokenTypes.Down' null);  			DebugLocation (152' 3);  			PushFollow (Follow._propertyChain_in_propertyChain334);  			propertyChain (propertySegments);  			PopFollow ();  			Match (input' TokenTypes.Up' null);  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("propertyChain"' 7);  	LeaveRule ("propertyChain"' 7);  	LeaveRule_propertyChain ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyChain,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:147:2: ( ^( ID propertyChain[propertySegments] ) | ^( ESC_ID propertyChain[propertySegments] ) )  	int alt10 = 2;  	try {  		DebugEnterDecision (10' false);  		int LA10_1 = input.LA (1);  		if ((LA10_1 == ID)) {  			alt10 = 1;  		}  		else if ((LA10_1 == ESC_ID)) {  			alt10 = 2;  		}  		else {  			NoViableAltException nvae = new NoViableAltException (""' 10' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  	}  	finally {  		DebugExitDecision (10);  	}  	switch (alt10) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:147:4: ^( ID propertyChain[propertySegments] )  		{  			DebugLocation (147' 4);  			DebugLocation (147' 6);  			ID10 = (CommonTree)Match (input' ID' Follow._ID_in_propertyChain310);  			DebugLocation (148' 3);  			propertySegments.Add ((ID10 != null ? ID10.Text : default(string)));  			Match (input' TokenTypes.Down' null);  			DebugLocation (149' 3);  			PushFollow (Follow._propertyChain_in_propertyChain318);  			propertyChain (propertySegments);  			PopFollow ();  			Match (input' TokenTypes.Up' null);  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:150:4: ^( ESC_ID propertyChain[propertySegments] )  		{  			DebugLocation (150' 4);  			DebugLocation (150' 6);  			ESC_ID11 = (CommonTree)Match (input' ESC_ID' Follow._ESC_ID_in_propertyChain326);  			DebugLocation (151' 3);  			propertySegments.Add ((ESC_ID11 != null ? ESC_ID11.Text : default(string)));  			Match (input' TokenTypes.Down' null);  			DebugLocation (152' 3);  			PushFollow (Follow._propertyChain_in_propertyChain334);  			propertyChain (propertySegments);  			PopFollow ();  			Match (input' TokenTypes.Up' null);  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("propertyChain"' 7);  	LeaveRule ("propertyChain"' 7);  	LeaveRule_propertyChain ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyChain,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:147:2: ( ^( ID propertyChain[propertySegments] ) | ^( ESC_ID propertyChain[propertySegments] ) )  	int alt10 = 2;  	try {  		DebugEnterDecision (10' false);  		int LA10_1 = input.LA (1);  		if ((LA10_1 == ID)) {  			alt10 = 1;  		}  		else if ((LA10_1 == ESC_ID)) {  			alt10 = 2;  		}  		else {  			NoViableAltException nvae = new NoViableAltException (""' 10' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  	}  	finally {  		DebugExitDecision (10);  	}  	switch (alt10) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:147:4: ^( ID propertyChain[propertySegments] )  		{  			DebugLocation (147' 4);  			DebugLocation (147' 6);  			ID10 = (CommonTree)Match (input' ID' Follow._ID_in_propertyChain310);  			DebugLocation (148' 3);  			propertySegments.Add ((ID10 != null ? ID10.Text : default(string)));  			Match (input' TokenTypes.Down' null);  			DebugLocation (149' 3);  			PushFollow (Follow._propertyChain_in_propertyChain318);  			propertyChain (propertySegments);  			PopFollow ();  			Match (input' TokenTypes.Up' null);  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:150:4: ^( ESC_ID propertyChain[propertySegments] )  		{  			DebugLocation (150' 4);  			DebugLocation (150' 6);  			ESC_ID11 = (CommonTree)Match (input' ESC_ID' Follow._ESC_ID_in_propertyChain326);  			DebugLocation (151' 3);  			propertySegments.Add ((ESC_ID11 != null ? ESC_ID11.Text : default(string)));  			Match (input' TokenTypes.Down' null);  			DebugLocation (152' 3);  			PushFollow (Follow._propertyChain_in_propertyChain334);  			propertyChain (propertySegments);  			PopFollow ();  			Match (input' TokenTypes.Up' null);  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("propertyChain"' 7);  	LeaveRule ("propertyChain"' 7);  	LeaveRule_propertyChain ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyChain,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:147:2: ( ^( ID propertyChain[propertySegments] ) | ^( ESC_ID propertyChain[propertySegments] ) )  	int alt10 = 2;  	try {  		DebugEnterDecision (10' false);  		int LA10_1 = input.LA (1);  		if ((LA10_1 == ID)) {  			alt10 = 1;  		}  		else if ((LA10_1 == ESC_ID)) {  			alt10 = 2;  		}  		else {  			NoViableAltException nvae = new NoViableAltException (""' 10' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  	}  	finally {  		DebugExitDecision (10);  	}  	switch (alt10) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:147:4: ^( ID propertyChain[propertySegments] )  		{  			DebugLocation (147' 4);  			DebugLocation (147' 6);  			ID10 = (CommonTree)Match (input' ID' Follow._ID_in_propertyChain310);  			DebugLocation (148' 3);  			propertySegments.Add ((ID10 != null ? ID10.Text : default(string)));  			Match (input' TokenTypes.Down' null);  			DebugLocation (149' 3);  			PushFollow (Follow._propertyChain_in_propertyChain318);  			propertyChain (propertySegments);  			PopFollow ();  			Match (input' TokenTypes.Up' null);  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:150:4: ^( ESC_ID propertyChain[propertySegments] )  		{  			DebugLocation (150' 4);  			DebugLocation (150' 6);  			ESC_ID11 = (CommonTree)Match (input' ESC_ID' Follow._ESC_ID_in_propertyChain326);  			DebugLocation (151' 3);  			propertySegments.Add ((ESC_ID11 != null ? ESC_ID11.Text : default(string)));  			Match (input' TokenTypes.Down' null);  			DebugLocation (152' 3);  			PushFollow (Follow._propertyChain_in_propertyChain334);  			propertyChain (propertySegments);  			PopFollow ();  			Match (input' TokenTypes.Up' null);  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("propertyChain"' 7);  	LeaveRule ("propertyChain"' 7);  	LeaveRule_propertyChain ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyChain,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:147:2: ( ^( ID propertyChain[propertySegments] ) | ^( ESC_ID propertyChain[propertySegments] ) )  	int alt10 = 2;  	try {  		DebugEnterDecision (10' false);  		int LA10_1 = input.LA (1);  		if ((LA10_1 == ID)) {  			alt10 = 1;  		}  		else if ((LA10_1 == ESC_ID)) {  			alt10 = 2;  		}  		else {  			NoViableAltException nvae = new NoViableAltException (""' 10' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  	}  	finally {  		DebugExitDecision (10);  	}  	switch (alt10) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:147:4: ^( ID propertyChain[propertySegments] )  		{  			DebugLocation (147' 4);  			DebugLocation (147' 6);  			ID10 = (CommonTree)Match (input' ID' Follow._ID_in_propertyChain310);  			DebugLocation (148' 3);  			propertySegments.Add ((ID10 != null ? ID10.Text : default(string)));  			Match (input' TokenTypes.Down' null);  			DebugLocation (149' 3);  			PushFollow (Follow._propertyChain_in_propertyChain318);  			propertyChain (propertySegments);  			PopFollow ();  			Match (input' TokenTypes.Up' null);  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:150:4: ^( ESC_ID propertyChain[propertySegments] )  		{  			DebugLocation (150' 4);  			DebugLocation (150' 6);  			ESC_ID11 = (CommonTree)Match (input' ESC_ID' Follow._ESC_ID_in_propertyChain326);  			DebugLocation (151' 3);  			propertySegments.Add ((ESC_ID11 != null ? ESC_ID11.Text : default(string)));  			Match (input' TokenTypes.Down' null);  			DebugLocation (152' 3);  			PushFollow (Follow._propertyChain_in_propertyChain334);  			propertyChain (propertySegments);  			PopFollow ();  			Match (input' TokenTypes.Up' null);  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("propertyChain"' 7);  	LeaveRule ("propertyChain"' 7);  	LeaveRule_propertyChain ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyChain,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:147:2: ( ^( ID propertyChain[propertySegments] ) | ^( ESC_ID propertyChain[propertySegments] ) )  	int alt10 = 2;  	try {  		DebugEnterDecision (10' false);  		int LA10_1 = input.LA (1);  		if ((LA10_1 == ID)) {  			alt10 = 1;  		}  		else if ((LA10_1 == ESC_ID)) {  			alt10 = 2;  		}  		else {  			NoViableAltException nvae = new NoViableAltException (""' 10' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  	}  	finally {  		DebugExitDecision (10);  	}  	switch (alt10) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:147:4: ^( ID propertyChain[propertySegments] )  		{  			DebugLocation (147' 4);  			DebugLocation (147' 6);  			ID10 = (CommonTree)Match (input' ID' Follow._ID_in_propertyChain310);  			DebugLocation (148' 3);  			propertySegments.Add ((ID10 != null ? ID10.Text : default(string)));  			Match (input' TokenTypes.Down' null);  			DebugLocation (149' 3);  			PushFollow (Follow._propertyChain_in_propertyChain318);  			propertyChain (propertySegments);  			PopFollow ();  			Match (input' TokenTypes.Up' null);  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:150:4: ^( ESC_ID propertyChain[propertySegments] )  		{  			DebugLocation (150' 4);  			DebugLocation (150' 6);  			ESC_ID11 = (CommonTree)Match (input' ESC_ID' Follow._ESC_ID_in_propertyChain326);  			DebugLocation (151' 3);  			propertySegments.Add ((ESC_ID11 != null ? ESC_ID11.Text : default(string)));  			Match (input' TokenTypes.Down' null);  			DebugLocation (152' 3);  			PushFollow (Follow._propertyChain_in_propertyChain334);  			propertyChain (propertySegments);  			PopFollow ();  			Match (input' TokenTypes.Up' null);  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("propertyChain"' 7);  	LeaveRule ("propertyChain"' 7);  	LeaveRule_propertyChain ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyChain,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:147:2: ( ^( ID propertyChain[propertySegments] ) | ^( ESC_ID propertyChain[propertySegments] ) )  	int alt10 = 2;  	try {  		DebugEnterDecision (10' false);  		int LA10_1 = input.LA (1);  		if ((LA10_1 == ID)) {  			alt10 = 1;  		}  		else if ((LA10_1 == ESC_ID)) {  			alt10 = 2;  		}  		else {  			NoViableAltException nvae = new NoViableAltException (""' 10' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  	}  	finally {  		DebugExitDecision (10);  	}  	switch (alt10) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:147:4: ^( ID propertyChain[propertySegments] )  		{  			DebugLocation (147' 4);  			DebugLocation (147' 6);  			ID10 = (CommonTree)Match (input' ID' Follow._ID_in_propertyChain310);  			DebugLocation (148' 3);  			propertySegments.Add ((ID10 != null ? ID10.Text : default(string)));  			Match (input' TokenTypes.Down' null);  			DebugLocation (149' 3);  			PushFollow (Follow._propertyChain_in_propertyChain318);  			propertyChain (propertySegments);  			PopFollow ();  			Match (input' TokenTypes.Up' null);  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:150:4: ^( ESC_ID propertyChain[propertySegments] )  		{  			DebugLocation (150' 4);  			DebugLocation (150' 6);  			ESC_ID11 = (CommonTree)Match (input' ESC_ID' Follow._ESC_ID_in_propertyChain326);  			DebugLocation (151' 3);  			propertySegments.Add ((ESC_ID11 != null ? ESC_ID11.Text : default(string)));  			Match (input' TokenTypes.Down' null);  			DebugLocation (152' 3);  			PushFollow (Follow._propertyChain_in_propertyChain334);  			propertyChain (propertySegments);  			PopFollow ();  			Match (input' TokenTypes.Up' null);  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("propertyChain"' 7);  	LeaveRule ("propertyChain"' 7);  	LeaveRule_propertyChain ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyChain,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:147:2: ( ^( ID propertyChain[propertySegments] ) | ^( ESC_ID propertyChain[propertySegments] ) )  	int alt10 = 2;  	try {  		DebugEnterDecision (10' false);  		int LA10_1 = input.LA (1);  		if ((LA10_1 == ID)) {  			alt10 = 1;  		}  		else if ((LA10_1 == ESC_ID)) {  			alt10 = 2;  		}  		else {  			NoViableAltException nvae = new NoViableAltException (""' 10' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  	}  	finally {  		DebugExitDecision (10);  	}  	switch (alt10) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:147:4: ^( ID propertyChain[propertySegments] )  		{  			DebugLocation (147' 4);  			DebugLocation (147' 6);  			ID10 = (CommonTree)Match (input' ID' Follow._ID_in_propertyChain310);  			DebugLocation (148' 3);  			propertySegments.Add ((ID10 != null ? ID10.Text : default(string)));  			Match (input' TokenTypes.Down' null);  			DebugLocation (149' 3);  			PushFollow (Follow._propertyChain_in_propertyChain318);  			propertyChain (propertySegments);  			PopFollow ();  			Match (input' TokenTypes.Up' null);  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:150:4: ^( ESC_ID propertyChain[propertySegments] )  		{  			DebugLocation (150' 4);  			DebugLocation (150' 6);  			ESC_ID11 = (CommonTree)Match (input' ESC_ID' Follow._ESC_ID_in_propertyChain326);  			DebugLocation (151' 3);  			propertySegments.Add ((ESC_ID11 != null ? ESC_ID11.Text : default(string)));  			Match (input' TokenTypes.Down' null);  			DebugLocation (152' 3);  			PushFollow (Follow._propertyChain_in_propertyChain334);  			propertyChain (propertySegments);  			PopFollow ();  			Match (input' TokenTypes.Up' null);  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("propertyChain"' 7);  	LeaveRule ("propertyChain"' 7);  	LeaveRule_propertyChain ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyChain,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:147:2: ( ^( ID propertyChain[propertySegments] ) | ^( ESC_ID propertyChain[propertySegments] ) )  	int alt10 = 2;  	try {  		DebugEnterDecision (10' false);  		int LA10_1 = input.LA (1);  		if ((LA10_1 == ID)) {  			alt10 = 1;  		}  		else if ((LA10_1 == ESC_ID)) {  			alt10 = 2;  		}  		else {  			NoViableAltException nvae = new NoViableAltException (""' 10' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  	}  	finally {  		DebugExitDecision (10);  	}  	switch (alt10) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:147:4: ^( ID propertyChain[propertySegments] )  		{  			DebugLocation (147' 4);  			DebugLocation (147' 6);  			ID10 = (CommonTree)Match (input' ID' Follow._ID_in_propertyChain310);  			DebugLocation (148' 3);  			propertySegments.Add ((ID10 != null ? ID10.Text : default(string)));  			Match (input' TokenTypes.Down' null);  			DebugLocation (149' 3);  			PushFollow (Follow._propertyChain_in_propertyChain318);  			propertyChain (propertySegments);  			PopFollow ();  			Match (input' TokenTypes.Up' null);  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:150:4: ^( ESC_ID propertyChain[propertySegments] )  		{  			DebugLocation (150' 4);  			DebugLocation (150' 6);  			ESC_ID11 = (CommonTree)Match (input' ESC_ID' Follow._ESC_ID_in_propertyChain326);  			DebugLocation (151' 3);  			propertySegments.Add ((ESC_ID11 != null ? ESC_ID11.Text : default(string)));  			Match (input' TokenTypes.Down' null);  			DebugLocation (152' 3);  			PushFollow (Follow._propertyChain_in_propertyChain334);  			propertyChain (propertySegments);  			PopFollow ();  			Match (input' TokenTypes.Up' null);  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("propertyChain"' 7);  	LeaveRule ("propertyChain"' 7);  	LeaveRule_propertyChain ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyChain,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:147:2: ( ^( ID propertyChain[propertySegments] ) | ^( ESC_ID propertyChain[propertySegments] ) )  	int alt10 = 2;  	try {  		DebugEnterDecision (10' false);  		int LA10_1 = input.LA (1);  		if ((LA10_1 == ID)) {  			alt10 = 1;  		}  		else if ((LA10_1 == ESC_ID)) {  			alt10 = 2;  		}  		else {  			NoViableAltException nvae = new NoViableAltException (""' 10' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  	}  	finally {  		DebugExitDecision (10);  	}  	switch (alt10) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:147:4: ^( ID propertyChain[propertySegments] )  		{  			DebugLocation (147' 4);  			DebugLocation (147' 6);  			ID10 = (CommonTree)Match (input' ID' Follow._ID_in_propertyChain310);  			DebugLocation (148' 3);  			propertySegments.Add ((ID10 != null ? ID10.Text : default(string)));  			Match (input' TokenTypes.Down' null);  			DebugLocation (149' 3);  			PushFollow (Follow._propertyChain_in_propertyChain318);  			propertyChain (propertySegments);  			PopFollow ();  			Match (input' TokenTypes.Up' null);  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:150:4: ^( ESC_ID propertyChain[propertySegments] )  		{  			DebugLocation (150' 4);  			DebugLocation (150' 6);  			ESC_ID11 = (CommonTree)Match (input' ESC_ID' Follow._ESC_ID_in_propertyChain326);  			DebugLocation (151' 3);  			propertySegments.Add ((ESC_ID11 != null ? ESC_ID11.Text : default(string)));  			Match (input' TokenTypes.Down' null);  			DebugLocation (152' 3);  			PushFollow (Follow._propertyChain_in_propertyChain334);  			propertyChain (propertySegments);  			PopFollow ();  			Match (input' TokenTypes.Up' null);  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("propertyChain"' 7);  	LeaveRule ("propertyChain"' 7);  	LeaveRule_propertyChain ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyChain,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:147:2: ( ^( ID propertyChain[propertySegments] ) | ^( ESC_ID propertyChain[propertySegments] ) )  	int alt10 = 2;  	try {  		DebugEnterDecision (10' false);  		int LA10_1 = input.LA (1);  		if ((LA10_1 == ID)) {  			alt10 = 1;  		}  		else if ((LA10_1 == ESC_ID)) {  			alt10 = 2;  		}  		else {  			NoViableAltException nvae = new NoViableAltException (""' 10' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  	}  	finally {  		DebugExitDecision (10);  	}  	switch (alt10) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:147:4: ^( ID propertyChain[propertySegments] )  		{  			DebugLocation (147' 4);  			DebugLocation (147' 6);  			ID10 = (CommonTree)Match (input' ID' Follow._ID_in_propertyChain310);  			DebugLocation (148' 3);  			propertySegments.Add ((ID10 != null ? ID10.Text : default(string)));  			Match (input' TokenTypes.Down' null);  			DebugLocation (149' 3);  			PushFollow (Follow._propertyChain_in_propertyChain318);  			propertyChain (propertySegments);  			PopFollow ();  			Match (input' TokenTypes.Up' null);  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:150:4: ^( ESC_ID propertyChain[propertySegments] )  		{  			DebugLocation (150' 4);  			DebugLocation (150' 6);  			ESC_ID11 = (CommonTree)Match (input' ESC_ID' Follow._ESC_ID_in_propertyChain326);  			DebugLocation (151' 3);  			propertySegments.Add ((ESC_ID11 != null ? ESC_ID11.Text : default(string)));  			Match (input' TokenTypes.Down' null);  			DebugLocation (152' 3);  			PushFollow (Follow._propertyChain_in_propertyChain334);  			propertyChain (propertySegments);  			PopFollow ();  			Match (input' TokenTypes.Up' null);  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("propertyChain"' 7);  	LeaveRule ("propertyChain"' 7);  	LeaveRule_propertyChain ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyChain,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:147:2: ( ^( ID propertyChain[propertySegments] ) | ^( ESC_ID propertyChain[propertySegments] ) )  	int alt10 = 2;  	try {  		DebugEnterDecision (10' false);  		int LA10_1 = input.LA (1);  		if ((LA10_1 == ID)) {  			alt10 = 1;  		}  		else if ((LA10_1 == ESC_ID)) {  			alt10 = 2;  		}  		else {  			NoViableAltException nvae = new NoViableAltException (""' 10' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  	}  	finally {  		DebugExitDecision (10);  	}  	switch (alt10) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:147:4: ^( ID propertyChain[propertySegments] )  		{  			DebugLocation (147' 4);  			DebugLocation (147' 6);  			ID10 = (CommonTree)Match (input' ID' Follow._ID_in_propertyChain310);  			DebugLocation (148' 3);  			propertySegments.Add ((ID10 != null ? ID10.Text : default(string)));  			Match (input' TokenTypes.Down' null);  			DebugLocation (149' 3);  			PushFollow (Follow._propertyChain_in_propertyChain318);  			propertyChain (propertySegments);  			PopFollow ();  			Match (input' TokenTypes.Up' null);  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:150:4: ^( ESC_ID propertyChain[propertySegments] )  		{  			DebugLocation (150' 4);  			DebugLocation (150' 6);  			ESC_ID11 = (CommonTree)Match (input' ESC_ID' Follow._ESC_ID_in_propertyChain326);  			DebugLocation (151' 3);  			propertySegments.Add ((ESC_ID11 != null ? ESC_ID11.Text : default(string)));  			Match (input' TokenTypes.Down' null);  			DebugLocation (152' 3);  			PushFollow (Follow._propertyChain_in_propertyChain334);  			propertyChain (propertySegments);  			PopFollow ();  			Match (input' TokenTypes.Up' null);  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("propertyChain"' 7);  	LeaveRule ("propertyChain"' 7);  	LeaveRule_propertyChain ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyChain,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:147:2: ( ^( ID propertyChain[propertySegments] ) | ^( ESC_ID propertyChain[propertySegments] ) )  	int alt10 = 2;  	try {  		DebugEnterDecision (10' false);  		int LA10_1 = input.LA (1);  		if ((LA10_1 == ID)) {  			alt10 = 1;  		}  		else if ((LA10_1 == ESC_ID)) {  			alt10 = 2;  		}  		else {  			NoViableAltException nvae = new NoViableAltException (""' 10' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  	}  	finally {  		DebugExitDecision (10);  	}  	switch (alt10) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:147:4: ^( ID propertyChain[propertySegments] )  		{  			DebugLocation (147' 4);  			DebugLocation (147' 6);  			ID10 = (CommonTree)Match (input' ID' Follow._ID_in_propertyChain310);  			DebugLocation (148' 3);  			propertySegments.Add ((ID10 != null ? ID10.Text : default(string)));  			Match (input' TokenTypes.Down' null);  			DebugLocation (149' 3);  			PushFollow (Follow._propertyChain_in_propertyChain318);  			propertyChain (propertySegments);  			PopFollow ();  			Match (input' TokenTypes.Up' null);  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:150:4: ^( ESC_ID propertyChain[propertySegments] )  		{  			DebugLocation (150' 4);  			DebugLocation (150' 6);  			ESC_ID11 = (CommonTree)Match (input' ESC_ID' Follow._ESC_ID_in_propertyChain326);  			DebugLocation (151' 3);  			propertySegments.Add ((ESC_ID11 != null ? ESC_ID11.Text : default(string)));  			Match (input' TokenTypes.Down' null);  			DebugLocation (152' 3);  			PushFollow (Follow._propertyChain_in_propertyChain334);  			propertyChain (propertySegments);  			PopFollow ();  			Match (input' TokenTypes.Up' null);  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("propertyChain"' 7);  	LeaveRule ("propertyChain"' 7);  	LeaveRule_propertyChain ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyChain,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:147:2: ( ^( ID propertyChain[propertySegments] ) | ^( ESC_ID propertyChain[propertySegments] ) )  	int alt10 = 2;  	try {  		DebugEnterDecision (10' false);  		int LA10_1 = input.LA (1);  		if ((LA10_1 == ID)) {  			alt10 = 1;  		}  		else if ((LA10_1 == ESC_ID)) {  			alt10 = 2;  		}  		else {  			NoViableAltException nvae = new NoViableAltException (""' 10' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  	}  	finally {  		DebugExitDecision (10);  	}  	switch (alt10) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:147:4: ^( ID propertyChain[propertySegments] )  		{  			DebugLocation (147' 4);  			DebugLocation (147' 6);  			ID10 = (CommonTree)Match (input' ID' Follow._ID_in_propertyChain310);  			DebugLocation (148' 3);  			propertySegments.Add ((ID10 != null ? ID10.Text : default(string)));  			Match (input' TokenTypes.Down' null);  			DebugLocation (149' 3);  			PushFollow (Follow._propertyChain_in_propertyChain318);  			propertyChain (propertySegments);  			PopFollow ();  			Match (input' TokenTypes.Up' null);  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:150:4: ^( ESC_ID propertyChain[propertySegments] )  		{  			DebugLocation (150' 4);  			DebugLocation (150' 6);  			ESC_ID11 = (CommonTree)Match (input' ESC_ID' Follow._ESC_ID_in_propertyChain326);  			DebugLocation (151' 3);  			propertySegments.Add ((ESC_ID11 != null ? ESC_ID11.Text : default(string)));  			Match (input' TokenTypes.Down' null);  			DebugLocation (152' 3);  			PushFollow (Follow._propertyChain_in_propertyChain334);  			propertyChain (propertySegments);  			PopFollow ();  			Match (input' TokenTypes.Up' null);  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("propertyChain"' 7);  	LeaveRule ("propertyChain"' 7);  	LeaveRule_propertyChain ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyChain,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:147:2: ( ^( ID propertyChain[propertySegments] ) | ^( ESC_ID propertyChain[propertySegments] ) )  	int alt10 = 2;  	try {  		DebugEnterDecision (10' false);  		int LA10_1 = input.LA (1);  		if ((LA10_1 == ID)) {  			alt10 = 1;  		}  		else if ((LA10_1 == ESC_ID)) {  			alt10 = 2;  		}  		else {  			NoViableAltException nvae = new NoViableAltException (""' 10' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  	}  	finally {  		DebugExitDecision (10);  	}  	switch (alt10) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:147:4: ^( ID propertyChain[propertySegments] )  		{  			DebugLocation (147' 4);  			DebugLocation (147' 6);  			ID10 = (CommonTree)Match (input' ID' Follow._ID_in_propertyChain310);  			DebugLocation (148' 3);  			propertySegments.Add ((ID10 != null ? ID10.Text : default(string)));  			Match (input' TokenTypes.Down' null);  			DebugLocation (149' 3);  			PushFollow (Follow._propertyChain_in_propertyChain318);  			propertyChain (propertySegments);  			PopFollow ();  			Match (input' TokenTypes.Up' null);  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:150:4: ^( ESC_ID propertyChain[propertySegments] )  		{  			DebugLocation (150' 4);  			DebugLocation (150' 6);  			ESC_ID11 = (CommonTree)Match (input' ESC_ID' Follow._ESC_ID_in_propertyChain326);  			DebugLocation (151' 3);  			propertySegments.Add ((ESC_ID11 != null ? ESC_ID11.Text : default(string)));  			Match (input' TokenTypes.Down' null);  			DebugLocation (152' 3);  			PushFollow (Follow._propertyChain_in_propertyChain334);  			propertyChain (propertySegments);  			PopFollow ();  			Match (input' TokenTypes.Up' null);  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("propertyChain"' 7);  	LeaveRule ("propertyChain"' 7);  	LeaveRule_propertyChain ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyChain,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:147:2: ( ^( ID propertyChain[propertySegments] ) | ^( ESC_ID propertyChain[propertySegments] ) )  	int alt10 = 2;  	try {  		DebugEnterDecision (10' false);  		int LA10_1 = input.LA (1);  		if ((LA10_1 == ID)) {  			alt10 = 1;  		}  		else if ((LA10_1 == ESC_ID)) {  			alt10 = 2;  		}  		else {  			NoViableAltException nvae = new NoViableAltException (""' 10' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  	}  	finally {  		DebugExitDecision (10);  	}  	switch (alt10) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:147:4: ^( ID propertyChain[propertySegments] )  		{  			DebugLocation (147' 4);  			DebugLocation (147' 6);  			ID10 = (CommonTree)Match (input' ID' Follow._ID_in_propertyChain310);  			DebugLocation (148' 3);  			propertySegments.Add ((ID10 != null ? ID10.Text : default(string)));  			Match (input' TokenTypes.Down' null);  			DebugLocation (149' 3);  			PushFollow (Follow._propertyChain_in_propertyChain318);  			propertyChain (propertySegments);  			PopFollow ();  			Match (input' TokenTypes.Up' null);  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:150:4: ^( ESC_ID propertyChain[propertySegments] )  		{  			DebugLocation (150' 4);  			DebugLocation (150' 6);  			ESC_ID11 = (CommonTree)Match (input' ESC_ID' Follow._ESC_ID_in_propertyChain326);  			DebugLocation (151' 3);  			propertySegments.Add ((ESC_ID11 != null ? ESC_ID11.Text : default(string)));  			Match (input' TokenTypes.Down' null);  			DebugLocation (152' 3);  			PushFollow (Follow._propertyChain_in_propertyChain334);  			propertyChain (propertySegments);  			PopFollow ();  			Match (input' TokenTypes.Up' null);  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("propertyChain"' 7);  	LeaveRule ("propertyChain"' 7);  	LeaveRule_propertyChain ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyChain,The following statement contains a magic number: try {  	DebugEnterDecision (10' false);  	int LA10_1 = input.LA (1);  	if ((LA10_1 == ID)) {  		alt10 = 1;  	}  	else if ((LA10_1 == ESC_ID)) {  		alt10 = 2;  	}  	else {  		NoViableAltException nvae = new NoViableAltException (""' 10' 0' input' 1);  		DebugRecognitionException (nvae);  		throw nvae;  	}  }  finally {  	DebugExitDecision (10);  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyChain,The following statement contains a magic number: try {  	DebugEnterDecision (10' false);  	int LA10_1 = input.LA (1);  	if ((LA10_1 == ID)) {  		alt10 = 1;  	}  	else if ((LA10_1 == ESC_ID)) {  		alt10 = 2;  	}  	else {  		NoViableAltException nvae = new NoViableAltException (""' 10' 0' input' 1);  		DebugRecognitionException (nvae);  		throw nvae;  	}  }  finally {  	DebugExitDecision (10);  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyChain,The following statement contains a magic number: try {  	DebugEnterDecision (10' false);  	int LA10_1 = input.LA (1);  	if ((LA10_1 == ID)) {  		alt10 = 1;  	}  	else if ((LA10_1 == ESC_ID)) {  		alt10 = 2;  	}  	else {  		NoViableAltException nvae = new NoViableAltException (""' 10' 0' input' 1);  		DebugRecognitionException (nvae);  		throw nvae;  	}  }  finally {  	DebugExitDecision (10);  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyChain,The following statement contains a magic number: try {  	DebugEnterDecision (10' false);  	int LA10_1 = input.LA (1);  	if ((LA10_1 == ID)) {  		alt10 = 1;  	}  	else if ((LA10_1 == ESC_ID)) {  		alt10 = 2;  	}  	else {  		NoViableAltException nvae = new NoViableAltException (""' 10' 0' input' 1);  		DebugRecognitionException (nvae);  		throw nvae;  	}  }  finally {  	DebugExitDecision (10);  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyChain,The following statement contains a magic number: DebugEnterDecision (10' false);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyChain,The following statement contains a magic number: if ((LA10_1 == ID)) {  	alt10 = 1;  }  else if ((LA10_1 == ESC_ID)) {  	alt10 = 2;  }  else {  	NoViableAltException nvae = new NoViableAltException (""' 10' 0' input' 1);  	DebugRecognitionException (nvae);  	throw nvae;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyChain,The following statement contains a magic number: if ((LA10_1 == ID)) {  	alt10 = 1;  }  else if ((LA10_1 == ESC_ID)) {  	alt10 = 2;  }  else {  	NoViableAltException nvae = new NoViableAltException (""' 10' 0' input' 1);  	DebugRecognitionException (nvae);  	throw nvae;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyChain,The following statement contains a magic number: if ((LA10_1 == ESC_ID)) {  	alt10 = 2;  }  else {  	NoViableAltException nvae = new NoViableAltException (""' 10' 0' input' 1);  	DebugRecognitionException (nvae);  	throw nvae;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyChain,The following statement contains a magic number: if ((LA10_1 == ESC_ID)) {  	alt10 = 2;  }  else {  	NoViableAltException nvae = new NoViableAltException (""' 10' 0' input' 1);  	DebugRecognitionException (nvae);  	throw nvae;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyChain,The following statement contains a magic number: alt10 = 2;  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyChain,The following statement contains a magic number: DebugExitDecision (10);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyChain,The following statement contains a magic number: switch (alt10) {  case 1:  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:147:4: ^( ID propertyChain[propertySegments] )  	{  		DebugLocation (147' 4);  		DebugLocation (147' 6);  		ID10 = (CommonTree)Match (input' ID' Follow._ID_in_propertyChain310);  		DebugLocation (148' 3);  		propertySegments.Add ((ID10 != null ? ID10.Text : default(string)));  		Match (input' TokenTypes.Down' null);  		DebugLocation (149' 3);  		PushFollow (Follow._propertyChain_in_propertyChain318);  		propertyChain (propertySegments);  		PopFollow ();  		Match (input' TokenTypes.Up' null);  	}  	break;  case 2:  	DebugEnterAlt (2);  	// ./src/Parser/Grammar/JFLWalker.g:150:4: ^( ESC_ID propertyChain[propertySegments] )  	{  		DebugLocation (150' 4);  		DebugLocation (150' 6);  		ESC_ID11 = (CommonTree)Match (input' ESC_ID' Follow._ESC_ID_in_propertyChain326);  		DebugLocation (151' 3);  		propertySegments.Add ((ESC_ID11 != null ? ESC_ID11.Text : default(string)));  		Match (input' TokenTypes.Down' null);  		DebugLocation (152' 3);  		PushFollow (Follow._propertyChain_in_propertyChain334);  		propertyChain (propertySegments);  		PopFollow ();  		Match (input' TokenTypes.Up' null);  	}  	break;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyChain,The following statement contains a magic number: switch (alt10) {  case 1:  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:147:4: ^( ID propertyChain[propertySegments] )  	{  		DebugLocation (147' 4);  		DebugLocation (147' 6);  		ID10 = (CommonTree)Match (input' ID' Follow._ID_in_propertyChain310);  		DebugLocation (148' 3);  		propertySegments.Add ((ID10 != null ? ID10.Text : default(string)));  		Match (input' TokenTypes.Down' null);  		DebugLocation (149' 3);  		PushFollow (Follow._propertyChain_in_propertyChain318);  		propertyChain (propertySegments);  		PopFollow ();  		Match (input' TokenTypes.Up' null);  	}  	break;  case 2:  	DebugEnterAlt (2);  	// ./src/Parser/Grammar/JFLWalker.g:150:4: ^( ESC_ID propertyChain[propertySegments] )  	{  		DebugLocation (150' 4);  		DebugLocation (150' 6);  		ESC_ID11 = (CommonTree)Match (input' ESC_ID' Follow._ESC_ID_in_propertyChain326);  		DebugLocation (151' 3);  		propertySegments.Add ((ESC_ID11 != null ? ESC_ID11.Text : default(string)));  		Match (input' TokenTypes.Down' null);  		DebugLocation (152' 3);  		PushFollow (Follow._propertyChain_in_propertyChain334);  		propertyChain (propertySegments);  		PopFollow ();  		Match (input' TokenTypes.Up' null);  	}  	break;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyChain,The following statement contains a magic number: switch (alt10) {  case 1:  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:147:4: ^( ID propertyChain[propertySegments] )  	{  		DebugLocation (147' 4);  		DebugLocation (147' 6);  		ID10 = (CommonTree)Match (input' ID' Follow._ID_in_propertyChain310);  		DebugLocation (148' 3);  		propertySegments.Add ((ID10 != null ? ID10.Text : default(string)));  		Match (input' TokenTypes.Down' null);  		DebugLocation (149' 3);  		PushFollow (Follow._propertyChain_in_propertyChain318);  		propertyChain (propertySegments);  		PopFollow ();  		Match (input' TokenTypes.Up' null);  	}  	break;  case 2:  	DebugEnterAlt (2);  	// ./src/Parser/Grammar/JFLWalker.g:150:4: ^( ESC_ID propertyChain[propertySegments] )  	{  		DebugLocation (150' 4);  		DebugLocation (150' 6);  		ESC_ID11 = (CommonTree)Match (input' ESC_ID' Follow._ESC_ID_in_propertyChain326);  		DebugLocation (151' 3);  		propertySegments.Add ((ESC_ID11 != null ? ESC_ID11.Text : default(string)));  		Match (input' TokenTypes.Down' null);  		DebugLocation (152' 3);  		PushFollow (Follow._propertyChain_in_propertyChain334);  		propertyChain (propertySegments);  		PopFollow ();  		Match (input' TokenTypes.Up' null);  	}  	break;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyChain,The following statement contains a magic number: switch (alt10) {  case 1:  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:147:4: ^( ID propertyChain[propertySegments] )  	{  		DebugLocation (147' 4);  		DebugLocation (147' 6);  		ID10 = (CommonTree)Match (input' ID' Follow._ID_in_propertyChain310);  		DebugLocation (148' 3);  		propertySegments.Add ((ID10 != null ? ID10.Text : default(string)));  		Match (input' TokenTypes.Down' null);  		DebugLocation (149' 3);  		PushFollow (Follow._propertyChain_in_propertyChain318);  		propertyChain (propertySegments);  		PopFollow ();  		Match (input' TokenTypes.Up' null);  	}  	break;  case 2:  	DebugEnterAlt (2);  	// ./src/Parser/Grammar/JFLWalker.g:150:4: ^( ESC_ID propertyChain[propertySegments] )  	{  		DebugLocation (150' 4);  		DebugLocation (150' 6);  		ESC_ID11 = (CommonTree)Match (input' ESC_ID' Follow._ESC_ID_in_propertyChain326);  		DebugLocation (151' 3);  		propertySegments.Add ((ESC_ID11 != null ? ESC_ID11.Text : default(string)));  		Match (input' TokenTypes.Down' null);  		DebugLocation (152' 3);  		PushFollow (Follow._propertyChain_in_propertyChain334);  		propertyChain (propertySegments);  		PopFollow ();  		Match (input' TokenTypes.Up' null);  	}  	break;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyChain,The following statement contains a magic number: switch (alt10) {  case 1:  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:147:4: ^( ID propertyChain[propertySegments] )  	{  		DebugLocation (147' 4);  		DebugLocation (147' 6);  		ID10 = (CommonTree)Match (input' ID' Follow._ID_in_propertyChain310);  		DebugLocation (148' 3);  		propertySegments.Add ((ID10 != null ? ID10.Text : default(string)));  		Match (input' TokenTypes.Down' null);  		DebugLocation (149' 3);  		PushFollow (Follow._propertyChain_in_propertyChain318);  		propertyChain (propertySegments);  		PopFollow ();  		Match (input' TokenTypes.Up' null);  	}  	break;  case 2:  	DebugEnterAlt (2);  	// ./src/Parser/Grammar/JFLWalker.g:150:4: ^( ESC_ID propertyChain[propertySegments] )  	{  		DebugLocation (150' 4);  		DebugLocation (150' 6);  		ESC_ID11 = (CommonTree)Match (input' ESC_ID' Follow._ESC_ID_in_propertyChain326);  		DebugLocation (151' 3);  		propertySegments.Add ((ESC_ID11 != null ? ESC_ID11.Text : default(string)));  		Match (input' TokenTypes.Down' null);  		DebugLocation (152' 3);  		PushFollow (Follow._propertyChain_in_propertyChain334);  		propertyChain (propertySegments);  		PopFollow ();  		Match (input' TokenTypes.Up' null);  	}  	break;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyChain,The following statement contains a magic number: switch (alt10) {  case 1:  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:147:4: ^( ID propertyChain[propertySegments] )  	{  		DebugLocation (147' 4);  		DebugLocation (147' 6);  		ID10 = (CommonTree)Match (input' ID' Follow._ID_in_propertyChain310);  		DebugLocation (148' 3);  		propertySegments.Add ((ID10 != null ? ID10.Text : default(string)));  		Match (input' TokenTypes.Down' null);  		DebugLocation (149' 3);  		PushFollow (Follow._propertyChain_in_propertyChain318);  		propertyChain (propertySegments);  		PopFollow ();  		Match (input' TokenTypes.Up' null);  	}  	break;  case 2:  	DebugEnterAlt (2);  	// ./src/Parser/Grammar/JFLWalker.g:150:4: ^( ESC_ID propertyChain[propertySegments] )  	{  		DebugLocation (150' 4);  		DebugLocation (150' 6);  		ESC_ID11 = (CommonTree)Match (input' ESC_ID' Follow._ESC_ID_in_propertyChain326);  		DebugLocation (151' 3);  		propertySegments.Add ((ESC_ID11 != null ? ESC_ID11.Text : default(string)));  		Match (input' TokenTypes.Down' null);  		DebugLocation (152' 3);  		PushFollow (Follow._propertyChain_in_propertyChain334);  		propertyChain (propertySegments);  		PopFollow ();  		Match (input' TokenTypes.Up' null);  	}  	break;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyChain,The following statement contains a magic number: switch (alt10) {  case 1:  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:147:4: ^( ID propertyChain[propertySegments] )  	{  		DebugLocation (147' 4);  		DebugLocation (147' 6);  		ID10 = (CommonTree)Match (input' ID' Follow._ID_in_propertyChain310);  		DebugLocation (148' 3);  		propertySegments.Add ((ID10 != null ? ID10.Text : default(string)));  		Match (input' TokenTypes.Down' null);  		DebugLocation (149' 3);  		PushFollow (Follow._propertyChain_in_propertyChain318);  		propertyChain (propertySegments);  		PopFollow ();  		Match (input' TokenTypes.Up' null);  	}  	break;  case 2:  	DebugEnterAlt (2);  	// ./src/Parser/Grammar/JFLWalker.g:150:4: ^( ESC_ID propertyChain[propertySegments] )  	{  		DebugLocation (150' 4);  		DebugLocation (150' 6);  		ESC_ID11 = (CommonTree)Match (input' ESC_ID' Follow._ESC_ID_in_propertyChain326);  		DebugLocation (151' 3);  		propertySegments.Add ((ESC_ID11 != null ? ESC_ID11.Text : default(string)));  		Match (input' TokenTypes.Down' null);  		DebugLocation (152' 3);  		PushFollow (Follow._propertyChain_in_propertyChain334);  		propertyChain (propertySegments);  		PopFollow ();  		Match (input' TokenTypes.Up' null);  	}  	break;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyChain,The following statement contains a magic number: switch (alt10) {  case 1:  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:147:4: ^( ID propertyChain[propertySegments] )  	{  		DebugLocation (147' 4);  		DebugLocation (147' 6);  		ID10 = (CommonTree)Match (input' ID' Follow._ID_in_propertyChain310);  		DebugLocation (148' 3);  		propertySegments.Add ((ID10 != null ? ID10.Text : default(string)));  		Match (input' TokenTypes.Down' null);  		DebugLocation (149' 3);  		PushFollow (Follow._propertyChain_in_propertyChain318);  		propertyChain (propertySegments);  		PopFollow ();  		Match (input' TokenTypes.Up' null);  	}  	break;  case 2:  	DebugEnterAlt (2);  	// ./src/Parser/Grammar/JFLWalker.g:150:4: ^( ESC_ID propertyChain[propertySegments] )  	{  		DebugLocation (150' 4);  		DebugLocation (150' 6);  		ESC_ID11 = (CommonTree)Match (input' ESC_ID' Follow._ESC_ID_in_propertyChain326);  		DebugLocation (151' 3);  		propertySegments.Add ((ESC_ID11 != null ? ESC_ID11.Text : default(string)));  		Match (input' TokenTypes.Down' null);  		DebugLocation (152' 3);  		PushFollow (Follow._propertyChain_in_propertyChain334);  		propertyChain (propertySegments);  		PopFollow ();  		Match (input' TokenTypes.Up' null);  	}  	break;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyChain,The following statement contains a magic number: switch (alt10) {  case 1:  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:147:4: ^( ID propertyChain[propertySegments] )  	{  		DebugLocation (147' 4);  		DebugLocation (147' 6);  		ID10 = (CommonTree)Match (input' ID' Follow._ID_in_propertyChain310);  		DebugLocation (148' 3);  		propertySegments.Add ((ID10 != null ? ID10.Text : default(string)));  		Match (input' TokenTypes.Down' null);  		DebugLocation (149' 3);  		PushFollow (Follow._propertyChain_in_propertyChain318);  		propertyChain (propertySegments);  		PopFollow ();  		Match (input' TokenTypes.Up' null);  	}  	break;  case 2:  	DebugEnterAlt (2);  	// ./src/Parser/Grammar/JFLWalker.g:150:4: ^( ESC_ID propertyChain[propertySegments] )  	{  		DebugLocation (150' 4);  		DebugLocation (150' 6);  		ESC_ID11 = (CommonTree)Match (input' ESC_ID' Follow._ESC_ID_in_propertyChain326);  		DebugLocation (151' 3);  		propertySegments.Add ((ESC_ID11 != null ? ESC_ID11.Text : default(string)));  		Match (input' TokenTypes.Down' null);  		DebugLocation (152' 3);  		PushFollow (Follow._propertyChain_in_propertyChain334);  		propertyChain (propertySegments);  		PopFollow ();  		Match (input' TokenTypes.Up' null);  	}  	break;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyChain,The following statement contains a magic number: switch (alt10) {  case 1:  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:147:4: ^( ID propertyChain[propertySegments] )  	{  		DebugLocation (147' 4);  		DebugLocation (147' 6);  		ID10 = (CommonTree)Match (input' ID' Follow._ID_in_propertyChain310);  		DebugLocation (148' 3);  		propertySegments.Add ((ID10 != null ? ID10.Text : default(string)));  		Match (input' TokenTypes.Down' null);  		DebugLocation (149' 3);  		PushFollow (Follow._propertyChain_in_propertyChain318);  		propertyChain (propertySegments);  		PopFollow ();  		Match (input' TokenTypes.Up' null);  	}  	break;  case 2:  	DebugEnterAlt (2);  	// ./src/Parser/Grammar/JFLWalker.g:150:4: ^( ESC_ID propertyChain[propertySegments] )  	{  		DebugLocation (150' 4);  		DebugLocation (150' 6);  		ESC_ID11 = (CommonTree)Match (input' ESC_ID' Follow._ESC_ID_in_propertyChain326);  		DebugLocation (151' 3);  		propertySegments.Add ((ESC_ID11 != null ? ESC_ID11.Text : default(string)));  		Match (input' TokenTypes.Down' null);  		DebugLocation (152' 3);  		PushFollow (Follow._propertyChain_in_propertyChain334);  		propertyChain (propertySegments);  		PopFollow ();  		Match (input' TokenTypes.Up' null);  	}  	break;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyChain,The following statement contains a magic number: switch (alt10) {  case 1:  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:147:4: ^( ID propertyChain[propertySegments] )  	{  		DebugLocation (147' 4);  		DebugLocation (147' 6);  		ID10 = (CommonTree)Match (input' ID' Follow._ID_in_propertyChain310);  		DebugLocation (148' 3);  		propertySegments.Add ((ID10 != null ? ID10.Text : default(string)));  		Match (input' TokenTypes.Down' null);  		DebugLocation (149' 3);  		PushFollow (Follow._propertyChain_in_propertyChain318);  		propertyChain (propertySegments);  		PopFollow ();  		Match (input' TokenTypes.Up' null);  	}  	break;  case 2:  	DebugEnterAlt (2);  	// ./src/Parser/Grammar/JFLWalker.g:150:4: ^( ESC_ID propertyChain[propertySegments] )  	{  		DebugLocation (150' 4);  		DebugLocation (150' 6);  		ESC_ID11 = (CommonTree)Match (input' ESC_ID' Follow._ESC_ID_in_propertyChain326);  		DebugLocation (151' 3);  		propertySegments.Add ((ESC_ID11 != null ? ESC_ID11.Text : default(string)));  		Match (input' TokenTypes.Down' null);  		DebugLocation (152' 3);  		PushFollow (Follow._propertyChain_in_propertyChain334);  		propertyChain (propertySegments);  		PopFollow ();  		Match (input' TokenTypes.Up' null);  	}  	break;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyChain,The following statement contains a magic number: switch (alt10) {  case 1:  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:147:4: ^( ID propertyChain[propertySegments] )  	{  		DebugLocation (147' 4);  		DebugLocation (147' 6);  		ID10 = (CommonTree)Match (input' ID' Follow._ID_in_propertyChain310);  		DebugLocation (148' 3);  		propertySegments.Add ((ID10 != null ? ID10.Text : default(string)));  		Match (input' TokenTypes.Down' null);  		DebugLocation (149' 3);  		PushFollow (Follow._propertyChain_in_propertyChain318);  		propertyChain (propertySegments);  		PopFollow ();  		Match (input' TokenTypes.Up' null);  	}  	break;  case 2:  	DebugEnterAlt (2);  	// ./src/Parser/Grammar/JFLWalker.g:150:4: ^( ESC_ID propertyChain[propertySegments] )  	{  		DebugLocation (150' 4);  		DebugLocation (150' 6);  		ESC_ID11 = (CommonTree)Match (input' ESC_ID' Follow._ESC_ID_in_propertyChain326);  		DebugLocation (151' 3);  		propertySegments.Add ((ESC_ID11 != null ? ESC_ID11.Text : default(string)));  		Match (input' TokenTypes.Down' null);  		DebugLocation (152' 3);  		PushFollow (Follow._propertyChain_in_propertyChain334);  		propertyChain (propertySegments);  		PopFollow ();  		Match (input' TokenTypes.Up' null);  	}  	break;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyChain,The following statement contains a magic number: switch (alt10) {  case 1:  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:147:4: ^( ID propertyChain[propertySegments] )  	{  		DebugLocation (147' 4);  		DebugLocation (147' 6);  		ID10 = (CommonTree)Match (input' ID' Follow._ID_in_propertyChain310);  		DebugLocation (148' 3);  		propertySegments.Add ((ID10 != null ? ID10.Text : default(string)));  		Match (input' TokenTypes.Down' null);  		DebugLocation (149' 3);  		PushFollow (Follow._propertyChain_in_propertyChain318);  		propertyChain (propertySegments);  		PopFollow ();  		Match (input' TokenTypes.Up' null);  	}  	break;  case 2:  	DebugEnterAlt (2);  	// ./src/Parser/Grammar/JFLWalker.g:150:4: ^( ESC_ID propertyChain[propertySegments] )  	{  		DebugLocation (150' 4);  		DebugLocation (150' 6);  		ESC_ID11 = (CommonTree)Match (input' ESC_ID' Follow._ESC_ID_in_propertyChain326);  		DebugLocation (151' 3);  		propertySegments.Add ((ESC_ID11 != null ? ESC_ID11.Text : default(string)));  		Match (input' TokenTypes.Down' null);  		DebugLocation (152' 3);  		PushFollow (Follow._propertyChain_in_propertyChain334);  		propertyChain (propertySegments);  		PopFollow ();  		Match (input' TokenTypes.Up' null);  	}  	break;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyChain,The following statement contains a magic number: switch (alt10) {  case 1:  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:147:4: ^( ID propertyChain[propertySegments] )  	{  		DebugLocation (147' 4);  		DebugLocation (147' 6);  		ID10 = (CommonTree)Match (input' ID' Follow._ID_in_propertyChain310);  		DebugLocation (148' 3);  		propertySegments.Add ((ID10 != null ? ID10.Text : default(string)));  		Match (input' TokenTypes.Down' null);  		DebugLocation (149' 3);  		PushFollow (Follow._propertyChain_in_propertyChain318);  		propertyChain (propertySegments);  		PopFollow ();  		Match (input' TokenTypes.Up' null);  	}  	break;  case 2:  	DebugEnterAlt (2);  	// ./src/Parser/Grammar/JFLWalker.g:150:4: ^( ESC_ID propertyChain[propertySegments] )  	{  		DebugLocation (150' 4);  		DebugLocation (150' 6);  		ESC_ID11 = (CommonTree)Match (input' ESC_ID' Follow._ESC_ID_in_propertyChain326);  		DebugLocation (151' 3);  		propertySegments.Add ((ESC_ID11 != null ? ESC_ID11.Text : default(string)));  		Match (input' TokenTypes.Down' null);  		DebugLocation (152' 3);  		PushFollow (Follow._propertyChain_in_propertyChain334);  		propertyChain (propertySegments);  		PopFollow ();  		Match (input' TokenTypes.Up' null);  	}  	break;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyChain,The following statement contains a magic number: switch (alt10) {  case 1:  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:147:4: ^( ID propertyChain[propertySegments] )  	{  		DebugLocation (147' 4);  		DebugLocation (147' 6);  		ID10 = (CommonTree)Match (input' ID' Follow._ID_in_propertyChain310);  		DebugLocation (148' 3);  		propertySegments.Add ((ID10 != null ? ID10.Text : default(string)));  		Match (input' TokenTypes.Down' null);  		DebugLocation (149' 3);  		PushFollow (Follow._propertyChain_in_propertyChain318);  		propertyChain (propertySegments);  		PopFollow ();  		Match (input' TokenTypes.Up' null);  	}  	break;  case 2:  	DebugEnterAlt (2);  	// ./src/Parser/Grammar/JFLWalker.g:150:4: ^( ESC_ID propertyChain[propertySegments] )  	{  		DebugLocation (150' 4);  		DebugLocation (150' 6);  		ESC_ID11 = (CommonTree)Match (input' ESC_ID' Follow._ESC_ID_in_propertyChain326);  		DebugLocation (151' 3);  		propertySegments.Add ((ESC_ID11 != null ? ESC_ID11.Text : default(string)));  		Match (input' TokenTypes.Down' null);  		DebugLocation (152' 3);  		PushFollow (Follow._propertyChain_in_propertyChain334);  		propertyChain (propertySegments);  		PopFollow ();  		Match (input' TokenTypes.Up' null);  	}  	break;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyChain,The following statement contains a magic number: switch (alt10) {  case 1:  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:147:4: ^( ID propertyChain[propertySegments] )  	{  		DebugLocation (147' 4);  		DebugLocation (147' 6);  		ID10 = (CommonTree)Match (input' ID' Follow._ID_in_propertyChain310);  		DebugLocation (148' 3);  		propertySegments.Add ((ID10 != null ? ID10.Text : default(string)));  		Match (input' TokenTypes.Down' null);  		DebugLocation (149' 3);  		PushFollow (Follow._propertyChain_in_propertyChain318);  		propertyChain (propertySegments);  		PopFollow ();  		Match (input' TokenTypes.Up' null);  	}  	break;  case 2:  	DebugEnterAlt (2);  	// ./src/Parser/Grammar/JFLWalker.g:150:4: ^( ESC_ID propertyChain[propertySegments] )  	{  		DebugLocation (150' 4);  		DebugLocation (150' 6);  		ESC_ID11 = (CommonTree)Match (input' ESC_ID' Follow._ESC_ID_in_propertyChain326);  		DebugLocation (151' 3);  		propertySegments.Add ((ESC_ID11 != null ? ESC_ID11.Text : default(string)));  		Match (input' TokenTypes.Down' null);  		DebugLocation (152' 3);  		PushFollow (Follow._propertyChain_in_propertyChain334);  		propertyChain (propertySegments);  		PopFollow ();  		Match (input' TokenTypes.Up' null);  	}  	break;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyChain,The following statement contains a magic number: switch (alt10) {  case 1:  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:147:4: ^( ID propertyChain[propertySegments] )  	{  		DebugLocation (147' 4);  		DebugLocation (147' 6);  		ID10 = (CommonTree)Match (input' ID' Follow._ID_in_propertyChain310);  		DebugLocation (148' 3);  		propertySegments.Add ((ID10 != null ? ID10.Text : default(string)));  		Match (input' TokenTypes.Down' null);  		DebugLocation (149' 3);  		PushFollow (Follow._propertyChain_in_propertyChain318);  		propertyChain (propertySegments);  		PopFollow ();  		Match (input' TokenTypes.Up' null);  	}  	break;  case 2:  	DebugEnterAlt (2);  	// ./src/Parser/Grammar/JFLWalker.g:150:4: ^( ESC_ID propertyChain[propertySegments] )  	{  		DebugLocation (150' 4);  		DebugLocation (150' 6);  		ESC_ID11 = (CommonTree)Match (input' ESC_ID' Follow._ESC_ID_in_propertyChain326);  		DebugLocation (151' 3);  		propertySegments.Add ((ESC_ID11 != null ? ESC_ID11.Text : default(string)));  		Match (input' TokenTypes.Down' null);  		DebugLocation (152' 3);  		PushFollow (Follow._propertyChain_in_propertyChain334);  		propertyChain (propertySegments);  		PopFollow ();  		Match (input' TokenTypes.Up' null);  	}  	break;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyChain,The following statement contains a magic number: switch (alt10) {  case 1:  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:147:4: ^( ID propertyChain[propertySegments] )  	{  		DebugLocation (147' 4);  		DebugLocation (147' 6);  		ID10 = (CommonTree)Match (input' ID' Follow._ID_in_propertyChain310);  		DebugLocation (148' 3);  		propertySegments.Add ((ID10 != null ? ID10.Text : default(string)));  		Match (input' TokenTypes.Down' null);  		DebugLocation (149' 3);  		PushFollow (Follow._propertyChain_in_propertyChain318);  		propertyChain (propertySegments);  		PopFollow ();  		Match (input' TokenTypes.Up' null);  	}  	break;  case 2:  	DebugEnterAlt (2);  	// ./src/Parser/Grammar/JFLWalker.g:150:4: ^( ESC_ID propertyChain[propertySegments] )  	{  		DebugLocation (150' 4);  		DebugLocation (150' 6);  		ESC_ID11 = (CommonTree)Match (input' ESC_ID' Follow._ESC_ID_in_propertyChain326);  		DebugLocation (151' 3);  		propertySegments.Add ((ESC_ID11 != null ? ESC_ID11.Text : default(string)));  		Match (input' TokenTypes.Down' null);  		DebugLocation (152' 3);  		PushFollow (Follow._propertyChain_in_propertyChain334);  		propertyChain (propertySegments);  		PopFollow ();  		Match (input' TokenTypes.Up' null);  	}  	break;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyChain,The following statement contains a magic number: DebugLocation (147' 4);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyChain,The following statement contains a magic number: DebugLocation (147' 4);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyChain,The following statement contains a magic number: DebugLocation (147' 6);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyChain,The following statement contains a magic number: DebugLocation (147' 6);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyChain,The following statement contains a magic number: DebugLocation (148' 3);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyChain,The following statement contains a magic number: DebugLocation (148' 3);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyChain,The following statement contains a magic number: DebugLocation (149' 3);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyChain,The following statement contains a magic number: DebugLocation (149' 3);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyChain,The following statement contains a magic number: DebugEnterAlt (2);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyChain,The following statement contains a magic number: DebugLocation (150' 4);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyChain,The following statement contains a magic number: DebugLocation (150' 4);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyChain,The following statement contains a magic number: DebugLocation (150' 6);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyChain,The following statement contains a magic number: DebugLocation (150' 6);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyChain,The following statement contains a magic number: DebugLocation (151' 3);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyChain,The following statement contains a magic number: DebugLocation (151' 3);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyChain,The following statement contains a magic number: DebugLocation (152' 3);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyChain,The following statement contains a magic number: DebugLocation (152' 3);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyChain,The following statement contains a magic number: TraceOut ("propertyChain"' 7);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyChain,The following statement contains a magic number: LeaveRule ("propertyChain"' 7);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyChain,The following statement contains a magic number: DebugLocation (153' 1);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,comparator,The following statement contains a magic number: EnterRule ("comparator"' 8);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,comparator,The following statement contains a magic number: TraceIn ("comparator"' 8);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,comparator,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "comparator");  	DebugLocation (155' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:156:2: ( CHAIN_OPERATOR | COMPARATOR )  		int alt11 = 2;  		try {  			DebugEnterDecision (11' false);  			int LA11_1 = input.LA (1);  			if ((LA11_1 == CHAIN_OPERATOR)) {  				alt11 = 1;  			}  			else if ((LA11_1 == COMPARATOR)) {  				alt11 = 2;  			}  			else {  				NoViableAltException nvae = new NoViableAltException (""' 11' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  		}  		finally {  			DebugExitDecision (11);  		}  		switch (alt11) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:156:4: CHAIN_OPERATOR  			{  				DebugLocation (156' 4);  				CHAIN_OPERATOR12 = (CommonTree)Match (input' CHAIN_OPERATOR' Follow._CHAIN_OPERATOR_in_comparator352);  				DebugLocation (156' 19);  				returnValue = (CHAIN_OPERATOR12 != null ? CHAIN_OPERATOR12.Text : default(string));  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:157:4: COMPARATOR  			{  				DebugLocation (157' 4);  				COMPARATOR13 = (CommonTree)Match (input' COMPARATOR' Follow._COMPARATOR_in_comparator359);  				DebugLocation (157' 15);  				returnValue = (COMPARATOR13 != null ? COMPARATOR13.Text : default(string));  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("comparator"' 8);  		LeaveRule ("comparator"' 8);  		LeaveRule_comparator ();  	}  	DebugLocation (158' 1);  }  finally {  	DebugExitRule (GrammarFileName' "comparator");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,comparator,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "comparator");  	DebugLocation (155' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:156:2: ( CHAIN_OPERATOR | COMPARATOR )  		int alt11 = 2;  		try {  			DebugEnterDecision (11' false);  			int LA11_1 = input.LA (1);  			if ((LA11_1 == CHAIN_OPERATOR)) {  				alt11 = 1;  			}  			else if ((LA11_1 == COMPARATOR)) {  				alt11 = 2;  			}  			else {  				NoViableAltException nvae = new NoViableAltException (""' 11' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  		}  		finally {  			DebugExitDecision (11);  		}  		switch (alt11) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:156:4: CHAIN_OPERATOR  			{  				DebugLocation (156' 4);  				CHAIN_OPERATOR12 = (CommonTree)Match (input' CHAIN_OPERATOR' Follow._CHAIN_OPERATOR_in_comparator352);  				DebugLocation (156' 19);  				returnValue = (CHAIN_OPERATOR12 != null ? CHAIN_OPERATOR12.Text : default(string));  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:157:4: COMPARATOR  			{  				DebugLocation (157' 4);  				COMPARATOR13 = (CommonTree)Match (input' COMPARATOR' Follow._COMPARATOR_in_comparator359);  				DebugLocation (157' 15);  				returnValue = (COMPARATOR13 != null ? COMPARATOR13.Text : default(string));  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("comparator"' 8);  		LeaveRule ("comparator"' 8);  		LeaveRule_comparator ();  	}  	DebugLocation (158' 1);  }  finally {  	DebugExitRule (GrammarFileName' "comparator");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,comparator,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "comparator");  	DebugLocation (155' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:156:2: ( CHAIN_OPERATOR | COMPARATOR )  		int alt11 = 2;  		try {  			DebugEnterDecision (11' false);  			int LA11_1 = input.LA (1);  			if ((LA11_1 == CHAIN_OPERATOR)) {  				alt11 = 1;  			}  			else if ((LA11_1 == COMPARATOR)) {  				alt11 = 2;  			}  			else {  				NoViableAltException nvae = new NoViableAltException (""' 11' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  		}  		finally {  			DebugExitDecision (11);  		}  		switch (alt11) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:156:4: CHAIN_OPERATOR  			{  				DebugLocation (156' 4);  				CHAIN_OPERATOR12 = (CommonTree)Match (input' CHAIN_OPERATOR' Follow._CHAIN_OPERATOR_in_comparator352);  				DebugLocation (156' 19);  				returnValue = (CHAIN_OPERATOR12 != null ? CHAIN_OPERATOR12.Text : default(string));  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:157:4: COMPARATOR  			{  				DebugLocation (157' 4);  				COMPARATOR13 = (CommonTree)Match (input' COMPARATOR' Follow._COMPARATOR_in_comparator359);  				DebugLocation (157' 15);  				returnValue = (COMPARATOR13 != null ? COMPARATOR13.Text : default(string));  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("comparator"' 8);  		LeaveRule ("comparator"' 8);  		LeaveRule_comparator ();  	}  	DebugLocation (158' 1);  }  finally {  	DebugExitRule (GrammarFileName' "comparator");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,comparator,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "comparator");  	DebugLocation (155' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:156:2: ( CHAIN_OPERATOR | COMPARATOR )  		int alt11 = 2;  		try {  			DebugEnterDecision (11' false);  			int LA11_1 = input.LA (1);  			if ((LA11_1 == CHAIN_OPERATOR)) {  				alt11 = 1;  			}  			else if ((LA11_1 == COMPARATOR)) {  				alt11 = 2;  			}  			else {  				NoViableAltException nvae = new NoViableAltException (""' 11' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  		}  		finally {  			DebugExitDecision (11);  		}  		switch (alt11) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:156:4: CHAIN_OPERATOR  			{  				DebugLocation (156' 4);  				CHAIN_OPERATOR12 = (CommonTree)Match (input' CHAIN_OPERATOR' Follow._CHAIN_OPERATOR_in_comparator352);  				DebugLocation (156' 19);  				returnValue = (CHAIN_OPERATOR12 != null ? CHAIN_OPERATOR12.Text : default(string));  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:157:4: COMPARATOR  			{  				DebugLocation (157' 4);  				COMPARATOR13 = (CommonTree)Match (input' COMPARATOR' Follow._COMPARATOR_in_comparator359);  				DebugLocation (157' 15);  				returnValue = (COMPARATOR13 != null ? COMPARATOR13.Text : default(string));  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("comparator"' 8);  		LeaveRule ("comparator"' 8);  		LeaveRule_comparator ();  	}  	DebugLocation (158' 1);  }  finally {  	DebugExitRule (GrammarFileName' "comparator");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,comparator,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "comparator");  	DebugLocation (155' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:156:2: ( CHAIN_OPERATOR | COMPARATOR )  		int alt11 = 2;  		try {  			DebugEnterDecision (11' false);  			int LA11_1 = input.LA (1);  			if ((LA11_1 == CHAIN_OPERATOR)) {  				alt11 = 1;  			}  			else if ((LA11_1 == COMPARATOR)) {  				alt11 = 2;  			}  			else {  				NoViableAltException nvae = new NoViableAltException (""' 11' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  		}  		finally {  			DebugExitDecision (11);  		}  		switch (alt11) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:156:4: CHAIN_OPERATOR  			{  				DebugLocation (156' 4);  				CHAIN_OPERATOR12 = (CommonTree)Match (input' CHAIN_OPERATOR' Follow._CHAIN_OPERATOR_in_comparator352);  				DebugLocation (156' 19);  				returnValue = (CHAIN_OPERATOR12 != null ? CHAIN_OPERATOR12.Text : default(string));  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:157:4: COMPARATOR  			{  				DebugLocation (157' 4);  				COMPARATOR13 = (CommonTree)Match (input' COMPARATOR' Follow._COMPARATOR_in_comparator359);  				DebugLocation (157' 15);  				returnValue = (COMPARATOR13 != null ? COMPARATOR13.Text : default(string));  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("comparator"' 8);  		LeaveRule ("comparator"' 8);  		LeaveRule_comparator ();  	}  	DebugLocation (158' 1);  }  finally {  	DebugExitRule (GrammarFileName' "comparator");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,comparator,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "comparator");  	DebugLocation (155' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:156:2: ( CHAIN_OPERATOR | COMPARATOR )  		int alt11 = 2;  		try {  			DebugEnterDecision (11' false);  			int LA11_1 = input.LA (1);  			if ((LA11_1 == CHAIN_OPERATOR)) {  				alt11 = 1;  			}  			else if ((LA11_1 == COMPARATOR)) {  				alt11 = 2;  			}  			else {  				NoViableAltException nvae = new NoViableAltException (""' 11' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  		}  		finally {  			DebugExitDecision (11);  		}  		switch (alt11) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:156:4: CHAIN_OPERATOR  			{  				DebugLocation (156' 4);  				CHAIN_OPERATOR12 = (CommonTree)Match (input' CHAIN_OPERATOR' Follow._CHAIN_OPERATOR_in_comparator352);  				DebugLocation (156' 19);  				returnValue = (CHAIN_OPERATOR12 != null ? CHAIN_OPERATOR12.Text : default(string));  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:157:4: COMPARATOR  			{  				DebugLocation (157' 4);  				COMPARATOR13 = (CommonTree)Match (input' COMPARATOR' Follow._COMPARATOR_in_comparator359);  				DebugLocation (157' 15);  				returnValue = (COMPARATOR13 != null ? COMPARATOR13.Text : default(string));  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("comparator"' 8);  		LeaveRule ("comparator"' 8);  		LeaveRule_comparator ();  	}  	DebugLocation (158' 1);  }  finally {  	DebugExitRule (GrammarFileName' "comparator");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,comparator,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "comparator");  	DebugLocation (155' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:156:2: ( CHAIN_OPERATOR | COMPARATOR )  		int alt11 = 2;  		try {  			DebugEnterDecision (11' false);  			int LA11_1 = input.LA (1);  			if ((LA11_1 == CHAIN_OPERATOR)) {  				alt11 = 1;  			}  			else if ((LA11_1 == COMPARATOR)) {  				alt11 = 2;  			}  			else {  				NoViableAltException nvae = new NoViableAltException (""' 11' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  		}  		finally {  			DebugExitDecision (11);  		}  		switch (alt11) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:156:4: CHAIN_OPERATOR  			{  				DebugLocation (156' 4);  				CHAIN_OPERATOR12 = (CommonTree)Match (input' CHAIN_OPERATOR' Follow._CHAIN_OPERATOR_in_comparator352);  				DebugLocation (156' 19);  				returnValue = (CHAIN_OPERATOR12 != null ? CHAIN_OPERATOR12.Text : default(string));  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:157:4: COMPARATOR  			{  				DebugLocation (157' 4);  				COMPARATOR13 = (CommonTree)Match (input' COMPARATOR' Follow._COMPARATOR_in_comparator359);  				DebugLocation (157' 15);  				returnValue = (COMPARATOR13 != null ? COMPARATOR13.Text : default(string));  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("comparator"' 8);  		LeaveRule ("comparator"' 8);  		LeaveRule_comparator ();  	}  	DebugLocation (158' 1);  }  finally {  	DebugExitRule (GrammarFileName' "comparator");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,comparator,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "comparator");  	DebugLocation (155' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:156:2: ( CHAIN_OPERATOR | COMPARATOR )  		int alt11 = 2;  		try {  			DebugEnterDecision (11' false);  			int LA11_1 = input.LA (1);  			if ((LA11_1 == CHAIN_OPERATOR)) {  				alt11 = 1;  			}  			else if ((LA11_1 == COMPARATOR)) {  				alt11 = 2;  			}  			else {  				NoViableAltException nvae = new NoViableAltException (""' 11' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  		}  		finally {  			DebugExitDecision (11);  		}  		switch (alt11) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:156:4: CHAIN_OPERATOR  			{  				DebugLocation (156' 4);  				CHAIN_OPERATOR12 = (CommonTree)Match (input' CHAIN_OPERATOR' Follow._CHAIN_OPERATOR_in_comparator352);  				DebugLocation (156' 19);  				returnValue = (CHAIN_OPERATOR12 != null ? CHAIN_OPERATOR12.Text : default(string));  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:157:4: COMPARATOR  			{  				DebugLocation (157' 4);  				COMPARATOR13 = (CommonTree)Match (input' COMPARATOR' Follow._COMPARATOR_in_comparator359);  				DebugLocation (157' 15);  				returnValue = (COMPARATOR13 != null ? COMPARATOR13.Text : default(string));  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("comparator"' 8);  		LeaveRule ("comparator"' 8);  		LeaveRule_comparator ();  	}  	DebugLocation (158' 1);  }  finally {  	DebugExitRule (GrammarFileName' "comparator");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,comparator,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "comparator");  	DebugLocation (155' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:156:2: ( CHAIN_OPERATOR | COMPARATOR )  		int alt11 = 2;  		try {  			DebugEnterDecision (11' false);  			int LA11_1 = input.LA (1);  			if ((LA11_1 == CHAIN_OPERATOR)) {  				alt11 = 1;  			}  			else if ((LA11_1 == COMPARATOR)) {  				alt11 = 2;  			}  			else {  				NoViableAltException nvae = new NoViableAltException (""' 11' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  		}  		finally {  			DebugExitDecision (11);  		}  		switch (alt11) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:156:4: CHAIN_OPERATOR  			{  				DebugLocation (156' 4);  				CHAIN_OPERATOR12 = (CommonTree)Match (input' CHAIN_OPERATOR' Follow._CHAIN_OPERATOR_in_comparator352);  				DebugLocation (156' 19);  				returnValue = (CHAIN_OPERATOR12 != null ? CHAIN_OPERATOR12.Text : default(string));  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:157:4: COMPARATOR  			{  				DebugLocation (157' 4);  				COMPARATOR13 = (CommonTree)Match (input' COMPARATOR' Follow._COMPARATOR_in_comparator359);  				DebugLocation (157' 15);  				returnValue = (COMPARATOR13 != null ? COMPARATOR13.Text : default(string));  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("comparator"' 8);  		LeaveRule ("comparator"' 8);  		LeaveRule_comparator ();  	}  	DebugLocation (158' 1);  }  finally {  	DebugExitRule (GrammarFileName' "comparator");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,comparator,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "comparator");  	DebugLocation (155' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:156:2: ( CHAIN_OPERATOR | COMPARATOR )  		int alt11 = 2;  		try {  			DebugEnterDecision (11' false);  			int LA11_1 = input.LA (1);  			if ((LA11_1 == CHAIN_OPERATOR)) {  				alt11 = 1;  			}  			else if ((LA11_1 == COMPARATOR)) {  				alt11 = 2;  			}  			else {  				NoViableAltException nvae = new NoViableAltException (""' 11' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  		}  		finally {  			DebugExitDecision (11);  		}  		switch (alt11) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:156:4: CHAIN_OPERATOR  			{  				DebugLocation (156' 4);  				CHAIN_OPERATOR12 = (CommonTree)Match (input' CHAIN_OPERATOR' Follow._CHAIN_OPERATOR_in_comparator352);  				DebugLocation (156' 19);  				returnValue = (CHAIN_OPERATOR12 != null ? CHAIN_OPERATOR12.Text : default(string));  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:157:4: COMPARATOR  			{  				DebugLocation (157' 4);  				COMPARATOR13 = (CommonTree)Match (input' COMPARATOR' Follow._COMPARATOR_in_comparator359);  				DebugLocation (157' 15);  				returnValue = (COMPARATOR13 != null ? COMPARATOR13.Text : default(string));  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("comparator"' 8);  		LeaveRule ("comparator"' 8);  		LeaveRule_comparator ();  	}  	DebugLocation (158' 1);  }  finally {  	DebugExitRule (GrammarFileName' "comparator");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,comparator,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "comparator");  	DebugLocation (155' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:156:2: ( CHAIN_OPERATOR | COMPARATOR )  		int alt11 = 2;  		try {  			DebugEnterDecision (11' false);  			int LA11_1 = input.LA (1);  			if ((LA11_1 == CHAIN_OPERATOR)) {  				alt11 = 1;  			}  			else if ((LA11_1 == COMPARATOR)) {  				alt11 = 2;  			}  			else {  				NoViableAltException nvae = new NoViableAltException (""' 11' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  		}  		finally {  			DebugExitDecision (11);  		}  		switch (alt11) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:156:4: CHAIN_OPERATOR  			{  				DebugLocation (156' 4);  				CHAIN_OPERATOR12 = (CommonTree)Match (input' CHAIN_OPERATOR' Follow._CHAIN_OPERATOR_in_comparator352);  				DebugLocation (156' 19);  				returnValue = (CHAIN_OPERATOR12 != null ? CHAIN_OPERATOR12.Text : default(string));  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:157:4: COMPARATOR  			{  				DebugLocation (157' 4);  				COMPARATOR13 = (CommonTree)Match (input' COMPARATOR' Follow._COMPARATOR_in_comparator359);  				DebugLocation (157' 15);  				returnValue = (COMPARATOR13 != null ? COMPARATOR13.Text : default(string));  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("comparator"' 8);  		LeaveRule ("comparator"' 8);  		LeaveRule_comparator ();  	}  	DebugLocation (158' 1);  }  finally {  	DebugExitRule (GrammarFileName' "comparator");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,comparator,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "comparator");  	DebugLocation (155' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:156:2: ( CHAIN_OPERATOR | COMPARATOR )  		int alt11 = 2;  		try {  			DebugEnterDecision (11' false);  			int LA11_1 = input.LA (1);  			if ((LA11_1 == CHAIN_OPERATOR)) {  				alt11 = 1;  			}  			else if ((LA11_1 == COMPARATOR)) {  				alt11 = 2;  			}  			else {  				NoViableAltException nvae = new NoViableAltException (""' 11' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  		}  		finally {  			DebugExitDecision (11);  		}  		switch (alt11) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:156:4: CHAIN_OPERATOR  			{  				DebugLocation (156' 4);  				CHAIN_OPERATOR12 = (CommonTree)Match (input' CHAIN_OPERATOR' Follow._CHAIN_OPERATOR_in_comparator352);  				DebugLocation (156' 19);  				returnValue = (CHAIN_OPERATOR12 != null ? CHAIN_OPERATOR12.Text : default(string));  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:157:4: COMPARATOR  			{  				DebugLocation (157' 4);  				COMPARATOR13 = (CommonTree)Match (input' COMPARATOR' Follow._COMPARATOR_in_comparator359);  				DebugLocation (157' 15);  				returnValue = (COMPARATOR13 != null ? COMPARATOR13.Text : default(string));  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("comparator"' 8);  		LeaveRule ("comparator"' 8);  		LeaveRule_comparator ();  	}  	DebugLocation (158' 1);  }  finally {  	DebugExitRule (GrammarFileName' "comparator");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,comparator,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "comparator");  	DebugLocation (155' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:156:2: ( CHAIN_OPERATOR | COMPARATOR )  		int alt11 = 2;  		try {  			DebugEnterDecision (11' false);  			int LA11_1 = input.LA (1);  			if ((LA11_1 == CHAIN_OPERATOR)) {  				alt11 = 1;  			}  			else if ((LA11_1 == COMPARATOR)) {  				alt11 = 2;  			}  			else {  				NoViableAltException nvae = new NoViableAltException (""' 11' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  		}  		finally {  			DebugExitDecision (11);  		}  		switch (alt11) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:156:4: CHAIN_OPERATOR  			{  				DebugLocation (156' 4);  				CHAIN_OPERATOR12 = (CommonTree)Match (input' CHAIN_OPERATOR' Follow._CHAIN_OPERATOR_in_comparator352);  				DebugLocation (156' 19);  				returnValue = (CHAIN_OPERATOR12 != null ? CHAIN_OPERATOR12.Text : default(string));  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:157:4: COMPARATOR  			{  				DebugLocation (157' 4);  				COMPARATOR13 = (CommonTree)Match (input' COMPARATOR' Follow._COMPARATOR_in_comparator359);  				DebugLocation (157' 15);  				returnValue = (COMPARATOR13 != null ? COMPARATOR13.Text : default(string));  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("comparator"' 8);  		LeaveRule ("comparator"' 8);  		LeaveRule_comparator ();  	}  	DebugLocation (158' 1);  }  finally {  	DebugExitRule (GrammarFileName' "comparator");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,comparator,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "comparator");  	DebugLocation (155' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:156:2: ( CHAIN_OPERATOR | COMPARATOR )  		int alt11 = 2;  		try {  			DebugEnterDecision (11' false);  			int LA11_1 = input.LA (1);  			if ((LA11_1 == CHAIN_OPERATOR)) {  				alt11 = 1;  			}  			else if ((LA11_1 == COMPARATOR)) {  				alt11 = 2;  			}  			else {  				NoViableAltException nvae = new NoViableAltException (""' 11' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  		}  		finally {  			DebugExitDecision (11);  		}  		switch (alt11) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:156:4: CHAIN_OPERATOR  			{  				DebugLocation (156' 4);  				CHAIN_OPERATOR12 = (CommonTree)Match (input' CHAIN_OPERATOR' Follow._CHAIN_OPERATOR_in_comparator352);  				DebugLocation (156' 19);  				returnValue = (CHAIN_OPERATOR12 != null ? CHAIN_OPERATOR12.Text : default(string));  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:157:4: COMPARATOR  			{  				DebugLocation (157' 4);  				COMPARATOR13 = (CommonTree)Match (input' COMPARATOR' Follow._COMPARATOR_in_comparator359);  				DebugLocation (157' 15);  				returnValue = (COMPARATOR13 != null ? COMPARATOR13.Text : default(string));  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("comparator"' 8);  		LeaveRule ("comparator"' 8);  		LeaveRule_comparator ();  	}  	DebugLocation (158' 1);  }  finally {  	DebugExitRule (GrammarFileName' "comparator");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,comparator,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "comparator");  	DebugLocation (155' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:156:2: ( CHAIN_OPERATOR | COMPARATOR )  		int alt11 = 2;  		try {  			DebugEnterDecision (11' false);  			int LA11_1 = input.LA (1);  			if ((LA11_1 == CHAIN_OPERATOR)) {  				alt11 = 1;  			}  			else if ((LA11_1 == COMPARATOR)) {  				alt11 = 2;  			}  			else {  				NoViableAltException nvae = new NoViableAltException (""' 11' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  		}  		finally {  			DebugExitDecision (11);  		}  		switch (alt11) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:156:4: CHAIN_OPERATOR  			{  				DebugLocation (156' 4);  				CHAIN_OPERATOR12 = (CommonTree)Match (input' CHAIN_OPERATOR' Follow._CHAIN_OPERATOR_in_comparator352);  				DebugLocation (156' 19);  				returnValue = (CHAIN_OPERATOR12 != null ? CHAIN_OPERATOR12.Text : default(string));  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:157:4: COMPARATOR  			{  				DebugLocation (157' 4);  				COMPARATOR13 = (CommonTree)Match (input' COMPARATOR' Follow._COMPARATOR_in_comparator359);  				DebugLocation (157' 15);  				returnValue = (COMPARATOR13 != null ? COMPARATOR13.Text : default(string));  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("comparator"' 8);  		LeaveRule ("comparator"' 8);  		LeaveRule_comparator ();  	}  	DebugLocation (158' 1);  }  finally {  	DebugExitRule (GrammarFileName' "comparator");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,comparator,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "comparator");  	DebugLocation (155' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:156:2: ( CHAIN_OPERATOR | COMPARATOR )  		int alt11 = 2;  		try {  			DebugEnterDecision (11' false);  			int LA11_1 = input.LA (1);  			if ((LA11_1 == CHAIN_OPERATOR)) {  				alt11 = 1;  			}  			else if ((LA11_1 == COMPARATOR)) {  				alt11 = 2;  			}  			else {  				NoViableAltException nvae = new NoViableAltException (""' 11' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  		}  		finally {  			DebugExitDecision (11);  		}  		switch (alt11) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:156:4: CHAIN_OPERATOR  			{  				DebugLocation (156' 4);  				CHAIN_OPERATOR12 = (CommonTree)Match (input' CHAIN_OPERATOR' Follow._CHAIN_OPERATOR_in_comparator352);  				DebugLocation (156' 19);  				returnValue = (CHAIN_OPERATOR12 != null ? CHAIN_OPERATOR12.Text : default(string));  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:157:4: COMPARATOR  			{  				DebugLocation (157' 4);  				COMPARATOR13 = (CommonTree)Match (input' COMPARATOR' Follow._COMPARATOR_in_comparator359);  				DebugLocation (157' 15);  				returnValue = (COMPARATOR13 != null ? COMPARATOR13.Text : default(string));  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("comparator"' 8);  		LeaveRule ("comparator"' 8);  		LeaveRule_comparator ();  	}  	DebugLocation (158' 1);  }  finally {  	DebugExitRule (GrammarFileName' "comparator");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,comparator,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "comparator");  	DebugLocation (155' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:156:2: ( CHAIN_OPERATOR | COMPARATOR )  		int alt11 = 2;  		try {  			DebugEnterDecision (11' false);  			int LA11_1 = input.LA (1);  			if ((LA11_1 == CHAIN_OPERATOR)) {  				alt11 = 1;  			}  			else if ((LA11_1 == COMPARATOR)) {  				alt11 = 2;  			}  			else {  				NoViableAltException nvae = new NoViableAltException (""' 11' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  		}  		finally {  			DebugExitDecision (11);  		}  		switch (alt11) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:156:4: CHAIN_OPERATOR  			{  				DebugLocation (156' 4);  				CHAIN_OPERATOR12 = (CommonTree)Match (input' CHAIN_OPERATOR' Follow._CHAIN_OPERATOR_in_comparator352);  				DebugLocation (156' 19);  				returnValue = (CHAIN_OPERATOR12 != null ? CHAIN_OPERATOR12.Text : default(string));  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:157:4: COMPARATOR  			{  				DebugLocation (157' 4);  				COMPARATOR13 = (CommonTree)Match (input' COMPARATOR' Follow._COMPARATOR_in_comparator359);  				DebugLocation (157' 15);  				returnValue = (COMPARATOR13 != null ? COMPARATOR13.Text : default(string));  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("comparator"' 8);  		LeaveRule ("comparator"' 8);  		LeaveRule_comparator ();  	}  	DebugLocation (158' 1);  }  finally {  	DebugExitRule (GrammarFileName' "comparator");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,comparator,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "comparator");  	DebugLocation (155' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:156:2: ( CHAIN_OPERATOR | COMPARATOR )  		int alt11 = 2;  		try {  			DebugEnterDecision (11' false);  			int LA11_1 = input.LA (1);  			if ((LA11_1 == CHAIN_OPERATOR)) {  				alt11 = 1;  			}  			else if ((LA11_1 == COMPARATOR)) {  				alt11 = 2;  			}  			else {  				NoViableAltException nvae = new NoViableAltException (""' 11' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  		}  		finally {  			DebugExitDecision (11);  		}  		switch (alt11) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:156:4: CHAIN_OPERATOR  			{  				DebugLocation (156' 4);  				CHAIN_OPERATOR12 = (CommonTree)Match (input' CHAIN_OPERATOR' Follow._CHAIN_OPERATOR_in_comparator352);  				DebugLocation (156' 19);  				returnValue = (CHAIN_OPERATOR12 != null ? CHAIN_OPERATOR12.Text : default(string));  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:157:4: COMPARATOR  			{  				DebugLocation (157' 4);  				COMPARATOR13 = (CommonTree)Match (input' COMPARATOR' Follow._COMPARATOR_in_comparator359);  				DebugLocation (157' 15);  				returnValue = (COMPARATOR13 != null ? COMPARATOR13.Text : default(string));  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("comparator"' 8);  		LeaveRule ("comparator"' 8);  		LeaveRule_comparator ();  	}  	DebugLocation (158' 1);  }  finally {  	DebugExitRule (GrammarFileName' "comparator");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,comparator,The following statement contains a magic number: try {  	DebugEnterRule (GrammarFileName' "comparator");  	DebugLocation (155' 1);  	try {  		// ./src/Parser/Grammar/JFLWalker.g:156:2: ( CHAIN_OPERATOR | COMPARATOR )  		int alt11 = 2;  		try {  			DebugEnterDecision (11' false);  			int LA11_1 = input.LA (1);  			if ((LA11_1 == CHAIN_OPERATOR)) {  				alt11 = 1;  			}  			else if ((LA11_1 == COMPARATOR)) {  				alt11 = 2;  			}  			else {  				NoViableAltException nvae = new NoViableAltException (""' 11' 0' input' 1);  				DebugRecognitionException (nvae);  				throw nvae;  			}  		}  		finally {  			DebugExitDecision (11);  		}  		switch (alt11) {  		case 1:  			DebugEnterAlt (1);  			// ./src/Parser/Grammar/JFLWalker.g:156:4: CHAIN_OPERATOR  			{  				DebugLocation (156' 4);  				CHAIN_OPERATOR12 = (CommonTree)Match (input' CHAIN_OPERATOR' Follow._CHAIN_OPERATOR_in_comparator352);  				DebugLocation (156' 19);  				returnValue = (CHAIN_OPERATOR12 != null ? CHAIN_OPERATOR12.Text : default(string));  			}  			break;  		case 2:  			DebugEnterAlt (2);  			// ./src/Parser/Grammar/JFLWalker.g:157:4: COMPARATOR  			{  				DebugLocation (157' 4);  				COMPARATOR13 = (CommonTree)Match (input' COMPARATOR' Follow._COMPARATOR_in_comparator359);  				DebugLocation (157' 15);  				returnValue = (COMPARATOR13 != null ? COMPARATOR13.Text : default(string));  			}  			break;  		}  	}  	catch (RecognitionException re) {  		ReportError (re);  		Recover (input' re);  	}  	finally {  		TraceOut ("comparator"' 8);  		LeaveRule ("comparator"' 8);  		LeaveRule_comparator ();  	}  	DebugLocation (158' 1);  }  finally {  	DebugExitRule (GrammarFileName' "comparator");  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,comparator,The following statement contains a magic number: DebugLocation (155' 1);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,comparator,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:156:2: ( CHAIN_OPERATOR | COMPARATOR )  	int alt11 = 2;  	try {  		DebugEnterDecision (11' false);  		int LA11_1 = input.LA (1);  		if ((LA11_1 == CHAIN_OPERATOR)) {  			alt11 = 1;  		}  		else if ((LA11_1 == COMPARATOR)) {  			alt11 = 2;  		}  		else {  			NoViableAltException nvae = new NoViableAltException (""' 11' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  	}  	finally {  		DebugExitDecision (11);  	}  	switch (alt11) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:156:4: CHAIN_OPERATOR  		{  			DebugLocation (156' 4);  			CHAIN_OPERATOR12 = (CommonTree)Match (input' CHAIN_OPERATOR' Follow._CHAIN_OPERATOR_in_comparator352);  			DebugLocation (156' 19);  			returnValue = (CHAIN_OPERATOR12 != null ? CHAIN_OPERATOR12.Text : default(string));  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:157:4: COMPARATOR  		{  			DebugLocation (157' 4);  			COMPARATOR13 = (CommonTree)Match (input' COMPARATOR' Follow._COMPARATOR_in_comparator359);  			DebugLocation (157' 15);  			returnValue = (COMPARATOR13 != null ? COMPARATOR13.Text : default(string));  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("comparator"' 8);  	LeaveRule ("comparator"' 8);  	LeaveRule_comparator ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,comparator,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:156:2: ( CHAIN_OPERATOR | COMPARATOR )  	int alt11 = 2;  	try {  		DebugEnterDecision (11' false);  		int LA11_1 = input.LA (1);  		if ((LA11_1 == CHAIN_OPERATOR)) {  			alt11 = 1;  		}  		else if ((LA11_1 == COMPARATOR)) {  			alt11 = 2;  		}  		else {  			NoViableAltException nvae = new NoViableAltException (""' 11' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  	}  	finally {  		DebugExitDecision (11);  	}  	switch (alt11) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:156:4: CHAIN_OPERATOR  		{  			DebugLocation (156' 4);  			CHAIN_OPERATOR12 = (CommonTree)Match (input' CHAIN_OPERATOR' Follow._CHAIN_OPERATOR_in_comparator352);  			DebugLocation (156' 19);  			returnValue = (CHAIN_OPERATOR12 != null ? CHAIN_OPERATOR12.Text : default(string));  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:157:4: COMPARATOR  		{  			DebugLocation (157' 4);  			COMPARATOR13 = (CommonTree)Match (input' COMPARATOR' Follow._COMPARATOR_in_comparator359);  			DebugLocation (157' 15);  			returnValue = (COMPARATOR13 != null ? COMPARATOR13.Text : default(string));  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("comparator"' 8);  	LeaveRule ("comparator"' 8);  	LeaveRule_comparator ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,comparator,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:156:2: ( CHAIN_OPERATOR | COMPARATOR )  	int alt11 = 2;  	try {  		DebugEnterDecision (11' false);  		int LA11_1 = input.LA (1);  		if ((LA11_1 == CHAIN_OPERATOR)) {  			alt11 = 1;  		}  		else if ((LA11_1 == COMPARATOR)) {  			alt11 = 2;  		}  		else {  			NoViableAltException nvae = new NoViableAltException (""' 11' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  	}  	finally {  		DebugExitDecision (11);  	}  	switch (alt11) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:156:4: CHAIN_OPERATOR  		{  			DebugLocation (156' 4);  			CHAIN_OPERATOR12 = (CommonTree)Match (input' CHAIN_OPERATOR' Follow._CHAIN_OPERATOR_in_comparator352);  			DebugLocation (156' 19);  			returnValue = (CHAIN_OPERATOR12 != null ? CHAIN_OPERATOR12.Text : default(string));  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:157:4: COMPARATOR  		{  			DebugLocation (157' 4);  			COMPARATOR13 = (CommonTree)Match (input' COMPARATOR' Follow._COMPARATOR_in_comparator359);  			DebugLocation (157' 15);  			returnValue = (COMPARATOR13 != null ? COMPARATOR13.Text : default(string));  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("comparator"' 8);  	LeaveRule ("comparator"' 8);  	LeaveRule_comparator ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,comparator,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:156:2: ( CHAIN_OPERATOR | COMPARATOR )  	int alt11 = 2;  	try {  		DebugEnterDecision (11' false);  		int LA11_1 = input.LA (1);  		if ((LA11_1 == CHAIN_OPERATOR)) {  			alt11 = 1;  		}  		else if ((LA11_1 == COMPARATOR)) {  			alt11 = 2;  		}  		else {  			NoViableAltException nvae = new NoViableAltException (""' 11' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  	}  	finally {  		DebugExitDecision (11);  	}  	switch (alt11) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:156:4: CHAIN_OPERATOR  		{  			DebugLocation (156' 4);  			CHAIN_OPERATOR12 = (CommonTree)Match (input' CHAIN_OPERATOR' Follow._CHAIN_OPERATOR_in_comparator352);  			DebugLocation (156' 19);  			returnValue = (CHAIN_OPERATOR12 != null ? CHAIN_OPERATOR12.Text : default(string));  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:157:4: COMPARATOR  		{  			DebugLocation (157' 4);  			COMPARATOR13 = (CommonTree)Match (input' COMPARATOR' Follow._COMPARATOR_in_comparator359);  			DebugLocation (157' 15);  			returnValue = (COMPARATOR13 != null ? COMPARATOR13.Text : default(string));  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("comparator"' 8);  	LeaveRule ("comparator"' 8);  	LeaveRule_comparator ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,comparator,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:156:2: ( CHAIN_OPERATOR | COMPARATOR )  	int alt11 = 2;  	try {  		DebugEnterDecision (11' false);  		int LA11_1 = input.LA (1);  		if ((LA11_1 == CHAIN_OPERATOR)) {  			alt11 = 1;  		}  		else if ((LA11_1 == COMPARATOR)) {  			alt11 = 2;  		}  		else {  			NoViableAltException nvae = new NoViableAltException (""' 11' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  	}  	finally {  		DebugExitDecision (11);  	}  	switch (alt11) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:156:4: CHAIN_OPERATOR  		{  			DebugLocation (156' 4);  			CHAIN_OPERATOR12 = (CommonTree)Match (input' CHAIN_OPERATOR' Follow._CHAIN_OPERATOR_in_comparator352);  			DebugLocation (156' 19);  			returnValue = (CHAIN_OPERATOR12 != null ? CHAIN_OPERATOR12.Text : default(string));  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:157:4: COMPARATOR  		{  			DebugLocation (157' 4);  			COMPARATOR13 = (CommonTree)Match (input' COMPARATOR' Follow._COMPARATOR_in_comparator359);  			DebugLocation (157' 15);  			returnValue = (COMPARATOR13 != null ? COMPARATOR13.Text : default(string));  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("comparator"' 8);  	LeaveRule ("comparator"' 8);  	LeaveRule_comparator ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,comparator,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:156:2: ( CHAIN_OPERATOR | COMPARATOR )  	int alt11 = 2;  	try {  		DebugEnterDecision (11' false);  		int LA11_1 = input.LA (1);  		if ((LA11_1 == CHAIN_OPERATOR)) {  			alt11 = 1;  		}  		else if ((LA11_1 == COMPARATOR)) {  			alt11 = 2;  		}  		else {  			NoViableAltException nvae = new NoViableAltException (""' 11' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  	}  	finally {  		DebugExitDecision (11);  	}  	switch (alt11) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:156:4: CHAIN_OPERATOR  		{  			DebugLocation (156' 4);  			CHAIN_OPERATOR12 = (CommonTree)Match (input' CHAIN_OPERATOR' Follow._CHAIN_OPERATOR_in_comparator352);  			DebugLocation (156' 19);  			returnValue = (CHAIN_OPERATOR12 != null ? CHAIN_OPERATOR12.Text : default(string));  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:157:4: COMPARATOR  		{  			DebugLocation (157' 4);  			COMPARATOR13 = (CommonTree)Match (input' COMPARATOR' Follow._COMPARATOR_in_comparator359);  			DebugLocation (157' 15);  			returnValue = (COMPARATOR13 != null ? COMPARATOR13.Text : default(string));  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("comparator"' 8);  	LeaveRule ("comparator"' 8);  	LeaveRule_comparator ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,comparator,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:156:2: ( CHAIN_OPERATOR | COMPARATOR )  	int alt11 = 2;  	try {  		DebugEnterDecision (11' false);  		int LA11_1 = input.LA (1);  		if ((LA11_1 == CHAIN_OPERATOR)) {  			alt11 = 1;  		}  		else if ((LA11_1 == COMPARATOR)) {  			alt11 = 2;  		}  		else {  			NoViableAltException nvae = new NoViableAltException (""' 11' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  	}  	finally {  		DebugExitDecision (11);  	}  	switch (alt11) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:156:4: CHAIN_OPERATOR  		{  			DebugLocation (156' 4);  			CHAIN_OPERATOR12 = (CommonTree)Match (input' CHAIN_OPERATOR' Follow._CHAIN_OPERATOR_in_comparator352);  			DebugLocation (156' 19);  			returnValue = (CHAIN_OPERATOR12 != null ? CHAIN_OPERATOR12.Text : default(string));  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:157:4: COMPARATOR  		{  			DebugLocation (157' 4);  			COMPARATOR13 = (CommonTree)Match (input' COMPARATOR' Follow._COMPARATOR_in_comparator359);  			DebugLocation (157' 15);  			returnValue = (COMPARATOR13 != null ? COMPARATOR13.Text : default(string));  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("comparator"' 8);  	LeaveRule ("comparator"' 8);  	LeaveRule_comparator ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,comparator,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:156:2: ( CHAIN_OPERATOR | COMPARATOR )  	int alt11 = 2;  	try {  		DebugEnterDecision (11' false);  		int LA11_1 = input.LA (1);  		if ((LA11_1 == CHAIN_OPERATOR)) {  			alt11 = 1;  		}  		else if ((LA11_1 == COMPARATOR)) {  			alt11 = 2;  		}  		else {  			NoViableAltException nvae = new NoViableAltException (""' 11' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  	}  	finally {  		DebugExitDecision (11);  	}  	switch (alt11) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:156:4: CHAIN_OPERATOR  		{  			DebugLocation (156' 4);  			CHAIN_OPERATOR12 = (CommonTree)Match (input' CHAIN_OPERATOR' Follow._CHAIN_OPERATOR_in_comparator352);  			DebugLocation (156' 19);  			returnValue = (CHAIN_OPERATOR12 != null ? CHAIN_OPERATOR12.Text : default(string));  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:157:4: COMPARATOR  		{  			DebugLocation (157' 4);  			COMPARATOR13 = (CommonTree)Match (input' COMPARATOR' Follow._COMPARATOR_in_comparator359);  			DebugLocation (157' 15);  			returnValue = (COMPARATOR13 != null ? COMPARATOR13.Text : default(string));  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("comparator"' 8);  	LeaveRule ("comparator"' 8);  	LeaveRule_comparator ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,comparator,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:156:2: ( CHAIN_OPERATOR | COMPARATOR )  	int alt11 = 2;  	try {  		DebugEnterDecision (11' false);  		int LA11_1 = input.LA (1);  		if ((LA11_1 == CHAIN_OPERATOR)) {  			alt11 = 1;  		}  		else if ((LA11_1 == COMPARATOR)) {  			alt11 = 2;  		}  		else {  			NoViableAltException nvae = new NoViableAltException (""' 11' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  	}  	finally {  		DebugExitDecision (11);  	}  	switch (alt11) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:156:4: CHAIN_OPERATOR  		{  			DebugLocation (156' 4);  			CHAIN_OPERATOR12 = (CommonTree)Match (input' CHAIN_OPERATOR' Follow._CHAIN_OPERATOR_in_comparator352);  			DebugLocation (156' 19);  			returnValue = (CHAIN_OPERATOR12 != null ? CHAIN_OPERATOR12.Text : default(string));  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:157:4: COMPARATOR  		{  			DebugLocation (157' 4);  			COMPARATOR13 = (CommonTree)Match (input' COMPARATOR' Follow._COMPARATOR_in_comparator359);  			DebugLocation (157' 15);  			returnValue = (COMPARATOR13 != null ? COMPARATOR13.Text : default(string));  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("comparator"' 8);  	LeaveRule ("comparator"' 8);  	LeaveRule_comparator ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,comparator,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:156:2: ( CHAIN_OPERATOR | COMPARATOR )  	int alt11 = 2;  	try {  		DebugEnterDecision (11' false);  		int LA11_1 = input.LA (1);  		if ((LA11_1 == CHAIN_OPERATOR)) {  			alt11 = 1;  		}  		else if ((LA11_1 == COMPARATOR)) {  			alt11 = 2;  		}  		else {  			NoViableAltException nvae = new NoViableAltException (""' 11' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  	}  	finally {  		DebugExitDecision (11);  	}  	switch (alt11) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:156:4: CHAIN_OPERATOR  		{  			DebugLocation (156' 4);  			CHAIN_OPERATOR12 = (CommonTree)Match (input' CHAIN_OPERATOR' Follow._CHAIN_OPERATOR_in_comparator352);  			DebugLocation (156' 19);  			returnValue = (CHAIN_OPERATOR12 != null ? CHAIN_OPERATOR12.Text : default(string));  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:157:4: COMPARATOR  		{  			DebugLocation (157' 4);  			COMPARATOR13 = (CommonTree)Match (input' COMPARATOR' Follow._COMPARATOR_in_comparator359);  			DebugLocation (157' 15);  			returnValue = (COMPARATOR13 != null ? COMPARATOR13.Text : default(string));  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("comparator"' 8);  	LeaveRule ("comparator"' 8);  	LeaveRule_comparator ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,comparator,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:156:2: ( CHAIN_OPERATOR | COMPARATOR )  	int alt11 = 2;  	try {  		DebugEnterDecision (11' false);  		int LA11_1 = input.LA (1);  		if ((LA11_1 == CHAIN_OPERATOR)) {  			alt11 = 1;  		}  		else if ((LA11_1 == COMPARATOR)) {  			alt11 = 2;  		}  		else {  			NoViableAltException nvae = new NoViableAltException (""' 11' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  	}  	finally {  		DebugExitDecision (11);  	}  	switch (alt11) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:156:4: CHAIN_OPERATOR  		{  			DebugLocation (156' 4);  			CHAIN_OPERATOR12 = (CommonTree)Match (input' CHAIN_OPERATOR' Follow._CHAIN_OPERATOR_in_comparator352);  			DebugLocation (156' 19);  			returnValue = (CHAIN_OPERATOR12 != null ? CHAIN_OPERATOR12.Text : default(string));  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:157:4: COMPARATOR  		{  			DebugLocation (157' 4);  			COMPARATOR13 = (CommonTree)Match (input' COMPARATOR' Follow._COMPARATOR_in_comparator359);  			DebugLocation (157' 15);  			returnValue = (COMPARATOR13 != null ? COMPARATOR13.Text : default(string));  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("comparator"' 8);  	LeaveRule ("comparator"' 8);  	LeaveRule_comparator ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,comparator,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:156:2: ( CHAIN_OPERATOR | COMPARATOR )  	int alt11 = 2;  	try {  		DebugEnterDecision (11' false);  		int LA11_1 = input.LA (1);  		if ((LA11_1 == CHAIN_OPERATOR)) {  			alt11 = 1;  		}  		else if ((LA11_1 == COMPARATOR)) {  			alt11 = 2;  		}  		else {  			NoViableAltException nvae = new NoViableAltException (""' 11' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  	}  	finally {  		DebugExitDecision (11);  	}  	switch (alt11) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:156:4: CHAIN_OPERATOR  		{  			DebugLocation (156' 4);  			CHAIN_OPERATOR12 = (CommonTree)Match (input' CHAIN_OPERATOR' Follow._CHAIN_OPERATOR_in_comparator352);  			DebugLocation (156' 19);  			returnValue = (CHAIN_OPERATOR12 != null ? CHAIN_OPERATOR12.Text : default(string));  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:157:4: COMPARATOR  		{  			DebugLocation (157' 4);  			COMPARATOR13 = (CommonTree)Match (input' COMPARATOR' Follow._COMPARATOR_in_comparator359);  			DebugLocation (157' 15);  			returnValue = (COMPARATOR13 != null ? COMPARATOR13.Text : default(string));  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("comparator"' 8);  	LeaveRule ("comparator"' 8);  	LeaveRule_comparator ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,comparator,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:156:2: ( CHAIN_OPERATOR | COMPARATOR )  	int alt11 = 2;  	try {  		DebugEnterDecision (11' false);  		int LA11_1 = input.LA (1);  		if ((LA11_1 == CHAIN_OPERATOR)) {  			alt11 = 1;  		}  		else if ((LA11_1 == COMPARATOR)) {  			alt11 = 2;  		}  		else {  			NoViableAltException nvae = new NoViableAltException (""' 11' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  	}  	finally {  		DebugExitDecision (11);  	}  	switch (alt11) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:156:4: CHAIN_OPERATOR  		{  			DebugLocation (156' 4);  			CHAIN_OPERATOR12 = (CommonTree)Match (input' CHAIN_OPERATOR' Follow._CHAIN_OPERATOR_in_comparator352);  			DebugLocation (156' 19);  			returnValue = (CHAIN_OPERATOR12 != null ? CHAIN_OPERATOR12.Text : default(string));  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:157:4: COMPARATOR  		{  			DebugLocation (157' 4);  			COMPARATOR13 = (CommonTree)Match (input' COMPARATOR' Follow._COMPARATOR_in_comparator359);  			DebugLocation (157' 15);  			returnValue = (COMPARATOR13 != null ? COMPARATOR13.Text : default(string));  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("comparator"' 8);  	LeaveRule ("comparator"' 8);  	LeaveRule_comparator ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,comparator,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:156:2: ( CHAIN_OPERATOR | COMPARATOR )  	int alt11 = 2;  	try {  		DebugEnterDecision (11' false);  		int LA11_1 = input.LA (1);  		if ((LA11_1 == CHAIN_OPERATOR)) {  			alt11 = 1;  		}  		else if ((LA11_1 == COMPARATOR)) {  			alt11 = 2;  		}  		else {  			NoViableAltException nvae = new NoViableAltException (""' 11' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  	}  	finally {  		DebugExitDecision (11);  	}  	switch (alt11) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:156:4: CHAIN_OPERATOR  		{  			DebugLocation (156' 4);  			CHAIN_OPERATOR12 = (CommonTree)Match (input' CHAIN_OPERATOR' Follow._CHAIN_OPERATOR_in_comparator352);  			DebugLocation (156' 19);  			returnValue = (CHAIN_OPERATOR12 != null ? CHAIN_OPERATOR12.Text : default(string));  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:157:4: COMPARATOR  		{  			DebugLocation (157' 4);  			COMPARATOR13 = (CommonTree)Match (input' COMPARATOR' Follow._COMPARATOR_in_comparator359);  			DebugLocation (157' 15);  			returnValue = (COMPARATOR13 != null ? COMPARATOR13.Text : default(string));  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("comparator"' 8);  	LeaveRule ("comparator"' 8);  	LeaveRule_comparator ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,comparator,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:156:2: ( CHAIN_OPERATOR | COMPARATOR )  	int alt11 = 2;  	try {  		DebugEnterDecision (11' false);  		int LA11_1 = input.LA (1);  		if ((LA11_1 == CHAIN_OPERATOR)) {  			alt11 = 1;  		}  		else if ((LA11_1 == COMPARATOR)) {  			alt11 = 2;  		}  		else {  			NoViableAltException nvae = new NoViableAltException (""' 11' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  	}  	finally {  		DebugExitDecision (11);  	}  	switch (alt11) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:156:4: CHAIN_OPERATOR  		{  			DebugLocation (156' 4);  			CHAIN_OPERATOR12 = (CommonTree)Match (input' CHAIN_OPERATOR' Follow._CHAIN_OPERATOR_in_comparator352);  			DebugLocation (156' 19);  			returnValue = (CHAIN_OPERATOR12 != null ? CHAIN_OPERATOR12.Text : default(string));  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:157:4: COMPARATOR  		{  			DebugLocation (157' 4);  			COMPARATOR13 = (CommonTree)Match (input' COMPARATOR' Follow._COMPARATOR_in_comparator359);  			DebugLocation (157' 15);  			returnValue = (COMPARATOR13 != null ? COMPARATOR13.Text : default(string));  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("comparator"' 8);  	LeaveRule ("comparator"' 8);  	LeaveRule_comparator ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,comparator,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:156:2: ( CHAIN_OPERATOR | COMPARATOR )  	int alt11 = 2;  	try {  		DebugEnterDecision (11' false);  		int LA11_1 = input.LA (1);  		if ((LA11_1 == CHAIN_OPERATOR)) {  			alt11 = 1;  		}  		else if ((LA11_1 == COMPARATOR)) {  			alt11 = 2;  		}  		else {  			NoViableAltException nvae = new NoViableAltException (""' 11' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  	}  	finally {  		DebugExitDecision (11);  	}  	switch (alt11) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:156:4: CHAIN_OPERATOR  		{  			DebugLocation (156' 4);  			CHAIN_OPERATOR12 = (CommonTree)Match (input' CHAIN_OPERATOR' Follow._CHAIN_OPERATOR_in_comparator352);  			DebugLocation (156' 19);  			returnValue = (CHAIN_OPERATOR12 != null ? CHAIN_OPERATOR12.Text : default(string));  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:157:4: COMPARATOR  		{  			DebugLocation (157' 4);  			COMPARATOR13 = (CommonTree)Match (input' COMPARATOR' Follow._COMPARATOR_in_comparator359);  			DebugLocation (157' 15);  			returnValue = (COMPARATOR13 != null ? COMPARATOR13.Text : default(string));  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("comparator"' 8);  	LeaveRule ("comparator"' 8);  	LeaveRule_comparator ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,comparator,The following statement contains a magic number: try {  	// ./src/Parser/Grammar/JFLWalker.g:156:2: ( CHAIN_OPERATOR | COMPARATOR )  	int alt11 = 2;  	try {  		DebugEnterDecision (11' false);  		int LA11_1 = input.LA (1);  		if ((LA11_1 == CHAIN_OPERATOR)) {  			alt11 = 1;  		}  		else if ((LA11_1 == COMPARATOR)) {  			alt11 = 2;  		}  		else {  			NoViableAltException nvae = new NoViableAltException (""' 11' 0' input' 1);  			DebugRecognitionException (nvae);  			throw nvae;  		}  	}  	finally {  		DebugExitDecision (11);  	}  	switch (alt11) {  	case 1:  		DebugEnterAlt (1);  		// ./src/Parser/Grammar/JFLWalker.g:156:4: CHAIN_OPERATOR  		{  			DebugLocation (156' 4);  			CHAIN_OPERATOR12 = (CommonTree)Match (input' CHAIN_OPERATOR' Follow._CHAIN_OPERATOR_in_comparator352);  			DebugLocation (156' 19);  			returnValue = (CHAIN_OPERATOR12 != null ? CHAIN_OPERATOR12.Text : default(string));  		}  		break;  	case 2:  		DebugEnterAlt (2);  		// ./src/Parser/Grammar/JFLWalker.g:157:4: COMPARATOR  		{  			DebugLocation (157' 4);  			COMPARATOR13 = (CommonTree)Match (input' COMPARATOR' Follow._COMPARATOR_in_comparator359);  			DebugLocation (157' 15);  			returnValue = (COMPARATOR13 != null ? COMPARATOR13.Text : default(string));  		}  		break;  	}  }  catch (RecognitionException re) {  	ReportError (re);  	Recover (input' re);  }  finally {  	TraceOut ("comparator"' 8);  	LeaveRule ("comparator"' 8);  	LeaveRule_comparator ();  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,comparator,The following statement contains a magic number: try {  	DebugEnterDecision (11' false);  	int LA11_1 = input.LA (1);  	if ((LA11_1 == CHAIN_OPERATOR)) {  		alt11 = 1;  	}  	else if ((LA11_1 == COMPARATOR)) {  		alt11 = 2;  	}  	else {  		NoViableAltException nvae = new NoViableAltException (""' 11' 0' input' 1);  		DebugRecognitionException (nvae);  		throw nvae;  	}  }  finally {  	DebugExitDecision (11);  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,comparator,The following statement contains a magic number: try {  	DebugEnterDecision (11' false);  	int LA11_1 = input.LA (1);  	if ((LA11_1 == CHAIN_OPERATOR)) {  		alt11 = 1;  	}  	else if ((LA11_1 == COMPARATOR)) {  		alt11 = 2;  	}  	else {  		NoViableAltException nvae = new NoViableAltException (""' 11' 0' input' 1);  		DebugRecognitionException (nvae);  		throw nvae;  	}  }  finally {  	DebugExitDecision (11);  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,comparator,The following statement contains a magic number: try {  	DebugEnterDecision (11' false);  	int LA11_1 = input.LA (1);  	if ((LA11_1 == CHAIN_OPERATOR)) {  		alt11 = 1;  	}  	else if ((LA11_1 == COMPARATOR)) {  		alt11 = 2;  	}  	else {  		NoViableAltException nvae = new NoViableAltException (""' 11' 0' input' 1);  		DebugRecognitionException (nvae);  		throw nvae;  	}  }  finally {  	DebugExitDecision (11);  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,comparator,The following statement contains a magic number: try {  	DebugEnterDecision (11' false);  	int LA11_1 = input.LA (1);  	if ((LA11_1 == CHAIN_OPERATOR)) {  		alt11 = 1;  	}  	else if ((LA11_1 == COMPARATOR)) {  		alt11 = 2;  	}  	else {  		NoViableAltException nvae = new NoViableAltException (""' 11' 0' input' 1);  		DebugRecognitionException (nvae);  		throw nvae;  	}  }  finally {  	DebugExitDecision (11);  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,comparator,The following statement contains a magic number: DebugEnterDecision (11' false);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,comparator,The following statement contains a magic number: if ((LA11_1 == CHAIN_OPERATOR)) {  	alt11 = 1;  }  else if ((LA11_1 == COMPARATOR)) {  	alt11 = 2;  }  else {  	NoViableAltException nvae = new NoViableAltException (""' 11' 0' input' 1);  	DebugRecognitionException (nvae);  	throw nvae;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,comparator,The following statement contains a magic number: if ((LA11_1 == CHAIN_OPERATOR)) {  	alt11 = 1;  }  else if ((LA11_1 == COMPARATOR)) {  	alt11 = 2;  }  else {  	NoViableAltException nvae = new NoViableAltException (""' 11' 0' input' 1);  	DebugRecognitionException (nvae);  	throw nvae;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,comparator,The following statement contains a magic number: if ((LA11_1 == COMPARATOR)) {  	alt11 = 2;  }  else {  	NoViableAltException nvae = new NoViableAltException (""' 11' 0' input' 1);  	DebugRecognitionException (nvae);  	throw nvae;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,comparator,The following statement contains a magic number: if ((LA11_1 == COMPARATOR)) {  	alt11 = 2;  }  else {  	NoViableAltException nvae = new NoViableAltException (""' 11' 0' input' 1);  	DebugRecognitionException (nvae);  	throw nvae;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,comparator,The following statement contains a magic number: alt11 = 2;  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,comparator,The following statement contains a magic number: DebugExitDecision (11);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,comparator,The following statement contains a magic number: switch (alt11) {  case 1:  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:156:4: CHAIN_OPERATOR  	{  		DebugLocation (156' 4);  		CHAIN_OPERATOR12 = (CommonTree)Match (input' CHAIN_OPERATOR' Follow._CHAIN_OPERATOR_in_comparator352);  		DebugLocation (156' 19);  		returnValue = (CHAIN_OPERATOR12 != null ? CHAIN_OPERATOR12.Text : default(string));  	}  	break;  case 2:  	DebugEnterAlt (2);  	// ./src/Parser/Grammar/JFLWalker.g:157:4: COMPARATOR  	{  		DebugLocation (157' 4);  		COMPARATOR13 = (CommonTree)Match (input' COMPARATOR' Follow._COMPARATOR_in_comparator359);  		DebugLocation (157' 15);  		returnValue = (COMPARATOR13 != null ? COMPARATOR13.Text : default(string));  	}  	break;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,comparator,The following statement contains a magic number: switch (alt11) {  case 1:  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:156:4: CHAIN_OPERATOR  	{  		DebugLocation (156' 4);  		CHAIN_OPERATOR12 = (CommonTree)Match (input' CHAIN_OPERATOR' Follow._CHAIN_OPERATOR_in_comparator352);  		DebugLocation (156' 19);  		returnValue = (CHAIN_OPERATOR12 != null ? CHAIN_OPERATOR12.Text : default(string));  	}  	break;  case 2:  	DebugEnterAlt (2);  	// ./src/Parser/Grammar/JFLWalker.g:157:4: COMPARATOR  	{  		DebugLocation (157' 4);  		COMPARATOR13 = (CommonTree)Match (input' COMPARATOR' Follow._COMPARATOR_in_comparator359);  		DebugLocation (157' 15);  		returnValue = (COMPARATOR13 != null ? COMPARATOR13.Text : default(string));  	}  	break;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,comparator,The following statement contains a magic number: switch (alt11) {  case 1:  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:156:4: CHAIN_OPERATOR  	{  		DebugLocation (156' 4);  		CHAIN_OPERATOR12 = (CommonTree)Match (input' CHAIN_OPERATOR' Follow._CHAIN_OPERATOR_in_comparator352);  		DebugLocation (156' 19);  		returnValue = (CHAIN_OPERATOR12 != null ? CHAIN_OPERATOR12.Text : default(string));  	}  	break;  case 2:  	DebugEnterAlt (2);  	// ./src/Parser/Grammar/JFLWalker.g:157:4: COMPARATOR  	{  		DebugLocation (157' 4);  		COMPARATOR13 = (CommonTree)Match (input' COMPARATOR' Follow._COMPARATOR_in_comparator359);  		DebugLocation (157' 15);  		returnValue = (COMPARATOR13 != null ? COMPARATOR13.Text : default(string));  	}  	break;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,comparator,The following statement contains a magic number: switch (alt11) {  case 1:  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:156:4: CHAIN_OPERATOR  	{  		DebugLocation (156' 4);  		CHAIN_OPERATOR12 = (CommonTree)Match (input' CHAIN_OPERATOR' Follow._CHAIN_OPERATOR_in_comparator352);  		DebugLocation (156' 19);  		returnValue = (CHAIN_OPERATOR12 != null ? CHAIN_OPERATOR12.Text : default(string));  	}  	break;  case 2:  	DebugEnterAlt (2);  	// ./src/Parser/Grammar/JFLWalker.g:157:4: COMPARATOR  	{  		DebugLocation (157' 4);  		COMPARATOR13 = (CommonTree)Match (input' COMPARATOR' Follow._COMPARATOR_in_comparator359);  		DebugLocation (157' 15);  		returnValue = (COMPARATOR13 != null ? COMPARATOR13.Text : default(string));  	}  	break;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,comparator,The following statement contains a magic number: switch (alt11) {  case 1:  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:156:4: CHAIN_OPERATOR  	{  		DebugLocation (156' 4);  		CHAIN_OPERATOR12 = (CommonTree)Match (input' CHAIN_OPERATOR' Follow._CHAIN_OPERATOR_in_comparator352);  		DebugLocation (156' 19);  		returnValue = (CHAIN_OPERATOR12 != null ? CHAIN_OPERATOR12.Text : default(string));  	}  	break;  case 2:  	DebugEnterAlt (2);  	// ./src/Parser/Grammar/JFLWalker.g:157:4: COMPARATOR  	{  		DebugLocation (157' 4);  		COMPARATOR13 = (CommonTree)Match (input' COMPARATOR' Follow._COMPARATOR_in_comparator359);  		DebugLocation (157' 15);  		returnValue = (COMPARATOR13 != null ? COMPARATOR13.Text : default(string));  	}  	break;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,comparator,The following statement contains a magic number: switch (alt11) {  case 1:  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:156:4: CHAIN_OPERATOR  	{  		DebugLocation (156' 4);  		CHAIN_OPERATOR12 = (CommonTree)Match (input' CHAIN_OPERATOR' Follow._CHAIN_OPERATOR_in_comparator352);  		DebugLocation (156' 19);  		returnValue = (CHAIN_OPERATOR12 != null ? CHAIN_OPERATOR12.Text : default(string));  	}  	break;  case 2:  	DebugEnterAlt (2);  	// ./src/Parser/Grammar/JFLWalker.g:157:4: COMPARATOR  	{  		DebugLocation (157' 4);  		COMPARATOR13 = (CommonTree)Match (input' COMPARATOR' Follow._COMPARATOR_in_comparator359);  		DebugLocation (157' 15);  		returnValue = (COMPARATOR13 != null ? COMPARATOR13.Text : default(string));  	}  	break;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,comparator,The following statement contains a magic number: switch (alt11) {  case 1:  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:156:4: CHAIN_OPERATOR  	{  		DebugLocation (156' 4);  		CHAIN_OPERATOR12 = (CommonTree)Match (input' CHAIN_OPERATOR' Follow._CHAIN_OPERATOR_in_comparator352);  		DebugLocation (156' 19);  		returnValue = (CHAIN_OPERATOR12 != null ? CHAIN_OPERATOR12.Text : default(string));  	}  	break;  case 2:  	DebugEnterAlt (2);  	// ./src/Parser/Grammar/JFLWalker.g:157:4: COMPARATOR  	{  		DebugLocation (157' 4);  		COMPARATOR13 = (CommonTree)Match (input' COMPARATOR' Follow._COMPARATOR_in_comparator359);  		DebugLocation (157' 15);  		returnValue = (COMPARATOR13 != null ? COMPARATOR13.Text : default(string));  	}  	break;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,comparator,The following statement contains a magic number: switch (alt11) {  case 1:  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:156:4: CHAIN_OPERATOR  	{  		DebugLocation (156' 4);  		CHAIN_OPERATOR12 = (CommonTree)Match (input' CHAIN_OPERATOR' Follow._CHAIN_OPERATOR_in_comparator352);  		DebugLocation (156' 19);  		returnValue = (CHAIN_OPERATOR12 != null ? CHAIN_OPERATOR12.Text : default(string));  	}  	break;  case 2:  	DebugEnterAlt (2);  	// ./src/Parser/Grammar/JFLWalker.g:157:4: COMPARATOR  	{  		DebugLocation (157' 4);  		COMPARATOR13 = (CommonTree)Match (input' COMPARATOR' Follow._COMPARATOR_in_comparator359);  		DebugLocation (157' 15);  		returnValue = (COMPARATOR13 != null ? COMPARATOR13.Text : default(string));  	}  	break;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,comparator,The following statement contains a magic number: switch (alt11) {  case 1:  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:156:4: CHAIN_OPERATOR  	{  		DebugLocation (156' 4);  		CHAIN_OPERATOR12 = (CommonTree)Match (input' CHAIN_OPERATOR' Follow._CHAIN_OPERATOR_in_comparator352);  		DebugLocation (156' 19);  		returnValue = (CHAIN_OPERATOR12 != null ? CHAIN_OPERATOR12.Text : default(string));  	}  	break;  case 2:  	DebugEnterAlt (2);  	// ./src/Parser/Grammar/JFLWalker.g:157:4: COMPARATOR  	{  		DebugLocation (157' 4);  		COMPARATOR13 = (CommonTree)Match (input' COMPARATOR' Follow._COMPARATOR_in_comparator359);  		DebugLocation (157' 15);  		returnValue = (COMPARATOR13 != null ? COMPARATOR13.Text : default(string));  	}  	break;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,comparator,The following statement contains a magic number: switch (alt11) {  case 1:  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:156:4: CHAIN_OPERATOR  	{  		DebugLocation (156' 4);  		CHAIN_OPERATOR12 = (CommonTree)Match (input' CHAIN_OPERATOR' Follow._CHAIN_OPERATOR_in_comparator352);  		DebugLocation (156' 19);  		returnValue = (CHAIN_OPERATOR12 != null ? CHAIN_OPERATOR12.Text : default(string));  	}  	break;  case 2:  	DebugEnterAlt (2);  	// ./src/Parser/Grammar/JFLWalker.g:157:4: COMPARATOR  	{  		DebugLocation (157' 4);  		COMPARATOR13 = (CommonTree)Match (input' COMPARATOR' Follow._COMPARATOR_in_comparator359);  		DebugLocation (157' 15);  		returnValue = (COMPARATOR13 != null ? COMPARATOR13.Text : default(string));  	}  	break;  }  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,comparator,The following statement contains a magic number: DebugLocation (156' 4);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,comparator,The following statement contains a magic number: DebugLocation (156' 4);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,comparator,The following statement contains a magic number: DebugLocation (156' 19);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,comparator,The following statement contains a magic number: DebugLocation (156' 19);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,comparator,The following statement contains a magic number: DebugEnterAlt (2);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,comparator,The following statement contains a magic number: DebugLocation (157' 4);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,comparator,The following statement contains a magic number: DebugLocation (157' 4);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,comparator,The following statement contains a magic number: DebugLocation (157' 15);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,comparator,The following statement contains a magic number: DebugLocation (157' 15);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,comparator,The following statement contains a magic number: TraceOut ("comparator"' 8);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,comparator,The following statement contains a magic number: LeaveRule ("comparator"' 8);  
Magic Number,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,comparator,The following statement contains a magic number: DebugLocation (158' 1);  
Missing Default,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,property,The following switch statement is missing a default case: switch (alt2) {  case 1:  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:23:22: not= '!'  	{  		DebugLocation (23' 22);  		not = (CommonTree)Match (input' 24' Follow._24_in_property84);  	}  	break;  }  
Missing Default,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,property,The following switch statement is missing a default case: switch (alt3) {  case 1:  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:23:28: filter[newProperty]  	{  		DebugLocation (23' 28);  		PushFollow (Follow._filter_in_property87);  		filter (newProperty);  		PopFollow ();  	}  	break;  }  
Missing Default,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,property,The following switch statement is missing a default case: switch (alt4) {  case 1:  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:23:49: block[newProperty]  	{  		DebugLocation (23' 49);  		PushFollow (Follow._block_in_property91);  		block (newProperty);  		PopFollow ();  	}  	break;  }  
Missing Default,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyName,The following switch statement is missing a default case: switch (alt5) {  case 1:  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:34:4: ID  	{  		DebugLocation (34' 4);  		ID2 = (CommonTree)Match (input' ID' Follow._ID_in_propertyName112);  		DebugLocation (34' 7);  		retval.isRegex = false;  		retval.name = (ID2 != null ? ID2.Text : default(string));  	}  	break;  case 2:  	DebugEnterAlt (2);  	// ./src/Parser/Grammar/JFLWalker.g:38:4: ESC_ID  	{  		DebugLocation (38' 4);  		ESC_ID3 = (CommonTree)Match (input' ESC_ID' Follow._ESC_ID_in_propertyName119);  		DebugLocation (38' 11);  		retval.isRegex = false;  		string stringText = (ESC_ID3 != null ? ESC_ID3.Text : default(string));  		retval.name = stringText.Substring (1' stringText.Length - 2);  	}  	break;  case 3:  	DebugEnterAlt (3);  	// ./src/Parser/Grammar/JFLWalker.g:43:4: REGEX  	{  		DebugLocation (43' 4);  		REGEX4 = (CommonTree)Match (input' REGEX' Follow._REGEX_in_propertyName126);  		DebugLocation (43' 10);  		retval.isRegex = true;  		string regexText = (REGEX4 != null ? REGEX4.Text : default(string));  		retval.name = regexText.Substring (1' regexText.Length - 2);  	}  	break;  case 4:  	DebugEnterAlt (4);  	// ./src/Parser/Grammar/JFLWalker.g:48:4: '*'  	{  		DebugLocation (48' 4);  		Match (input' 27' Follow._27_in_propertyName133);  		DebugLocation (48' 8);  		retval.isRegex = false;  		retval.name = "*";  	}  	break;  }  
Missing Default,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following switch statement is missing a default case: switch (alt6) {  case 1:  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:98:31: inverse= '!'  	{  		DebugLocation (98' 31);  		inverse = (CommonTree)Match (input' 24' Follow._24_in_filterExpr203);  	}  	break;  }  
Missing Default,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following switch statement is missing a default case: switch (alt7) {  case 1:  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:105:51: inverse= '?'  	{  		DebugLocation (105' 51);  		inverse = (CommonTree)Match (input' 31' Follow._31_in_filterExpr224);  	}  	break;  }  
Missing Default,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,filterExpr,The following switch statement is missing a default case: switch (alt8) {  case 1:  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:105:60: not= '!'  	{  		DebugLocation (105' 60);  		not = (CommonTree)Match (input' 24' Follow._24_in_filterExpr229);  	}  	break;  }  
Missing Default,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,propertyChain,The following switch statement is missing a default case: switch (alt10) {  case 1:  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:147:4: ^( ID propertyChain[propertySegments] )  	{  		DebugLocation (147' 4);  		DebugLocation (147' 6);  		ID10 = (CommonTree)Match (input' ID' Follow._ID_in_propertyChain310);  		DebugLocation (148' 3);  		propertySegments.Add ((ID10 != null ? ID10.Text : default(string)));  		Match (input' TokenTypes.Down' null);  		DebugLocation (149' 3);  		PushFollow (Follow._propertyChain_in_propertyChain318);  		propertyChain (propertySegments);  		PopFollow ();  		Match (input' TokenTypes.Up' null);  	}  	break;  case 2:  	DebugEnterAlt (2);  	// ./src/Parser/Grammar/JFLWalker.g:150:4: ^( ESC_ID propertyChain[propertySegments] )  	{  		DebugLocation (150' 4);  		DebugLocation (150' 6);  		ESC_ID11 = (CommonTree)Match (input' ESC_ID' Follow._ESC_ID_in_propertyChain326);  		DebugLocation (151' 3);  		propertySegments.Add ((ESC_ID11 != null ? ESC_ID11.Text : default(string)));  		Match (input' TokenTypes.Down' null);  		DebugLocation (152' 3);  		PushFollow (Follow._propertyChain_in_propertyChain334);  		propertyChain (propertySegments);  		PopFollow ();  		Match (input' TokenTypes.Up' null);  	}  	break;  }  
Missing Default,JFLCSharp,JFLWalker,C:\repos\brad-ross-35_jfl\src\parser\JFLWalker.cs,comparator,The following switch statement is missing a default case: switch (alt11) {  case 1:  	DebugEnterAlt (1);  	// ./src/Parser/Grammar/JFLWalker.g:156:4: CHAIN_OPERATOR  	{  		DebugLocation (156' 4);  		CHAIN_OPERATOR12 = (CommonTree)Match (input' CHAIN_OPERATOR' Follow._CHAIN_OPERATOR_in_comparator352);  		DebugLocation (156' 19);  		returnValue = (CHAIN_OPERATOR12 != null ? CHAIN_OPERATOR12.Text : default(string));  	}  	break;  case 2:  	DebugEnterAlt (2);  	// ./src/Parser/Grammar/JFLWalker.g:157:4: COMPARATOR  	{  		DebugLocation (157' 4);  		COMPARATOR13 = (CommonTree)Match (input' COMPARATOR' Follow._COMPARATOR_in_comparator359);  		DebugLocation (157' 15);  		returnValue = (COMPARATOR13 != null ? COMPARATOR13.Text : default(string));  	}  	break;  }  
