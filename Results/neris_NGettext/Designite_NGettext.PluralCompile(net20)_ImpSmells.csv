Implementation smell,Namespace,Class,File,Method,Description
Complex Method,NGettext.PluralCompile.Compiler,PluralRuleCompiler,C:\research\architectureSmells\repos\neris_NGettext\src\NGettext.PluralCompile\Compiler\PluralRuleCompiler.cs,CompileNode,Cyclomatic complexity of the method is 17
Long Statement,NGettext.PluralCompile,CompiledPluralRuleGenerator,C:\research\architectureSmells\repos\neris_NGettext\src\NGettext.PluralCompile\CompiledPluralRuleGenerator.cs,CreateRule,The length of the statement  "				var evaulationDelegate = (PluralRuleEvaluatorDelegate)this.Compiler.CompileToDynamicMethod(astRoot' typeof(PluralRuleEvaluatorDelegate)); " is 137.
Magic Number,NGettext.PluralCompile.Compiler,PluralRuleCompiler,C:\research\architectureSmells\repos\neris_NGettext\src\NGettext.PluralCompile\Compiler\PluralRuleCompiler.cs,CompileNode,The following statement contains a magic number: switch (node.Type)  			{  				case TokenType.Number:  					il.Emit(OpCodes.Ldc_I8' node.Value);  					break;    				case TokenType.N:  					il.Emit(OpCodes.Ldarg_0);  					break;    				case TokenType.Plus:  					this.CompileNode(il' node.Children[0]);  					this.CompileNode(il' node.Children[1]);  					il.Emit(OpCodes.Add);  					break;    				case TokenType.Minus:  					this.CompileNode(il' node.Children[0]);  					this.CompileNode(il' node.Children[1]);  					il.Emit(OpCodes.Sub);  					break;    				case TokenType.Divide:  					this.CompileNode(il' node.Children[0]);  					this.CompileNode(il' node.Children[1]);  					il.Emit(OpCodes.Div);  					break;    				case TokenType.Multiply:  					this.CompileNode(il' node.Children[0]);  					this.CompileNode(il' node.Children[1]);  					il.Emit(OpCodes.Mul);  					break;    				case TokenType.Modulo:  					this.CompileNode(il' node.Children[0]);  					this.CompileNode(il' node.Children[1]);  					il.Emit(OpCodes.Rem);  					break;    				case TokenType.GreaterThan:  					this.CompileNode(il' node.Children[0]);  					this.CompileNode(il' node.Children[1]);  					this.EmitConditionalValue(il' OpCodes.Bgt);  					break;    				case TokenType.GreaterOrEquals:  					this.CompileNode(il' node.Children[0]);  					this.CompileNode(il' node.Children[1]);  					this.EmitConditionalValue(il' OpCodes.Bge);  					break;    				case TokenType.LessThan:  					this.CompileNode(il' node.Children[0]);  					this.CompileNode(il' node.Children[1]);  					this.EmitConditionalValue(il' OpCodes.Blt);  					break;    				case TokenType.LessOrEquals:  					this.CompileNode(il' node.Children[0]);  					this.CompileNode(il' node.Children[1]);  					this.EmitConditionalValue(il' OpCodes.Ble);  					break;    				case TokenType.Equals:  					this.CompileNode(il' node.Children[0]);  					this.CompileNode(il' node.Children[1]);  					this.EmitConditionalValue(il' OpCodes.Beq);  					break;    				case TokenType.NotEquals:  					this.CompileNode(il' node.Children[0]);  					this.CompileNode(il' node.Children[1]);  					this.EmitConditionalValue(il' OpCodes.Beq' 0' 1);  					break;    				case TokenType.And:  					this.CompileNode(il' node.Children[0]);  					this.CompileNode(il' node.Children[1]);  					il.Emit(OpCodes.And);  					break;    				case TokenType.Or:  					this.CompileNode(il' node.Children[0]);  					this.CompileNode(il' node.Children[1]);  					il.Emit(OpCodes.Or);  					break;    				case TokenType.Not:  					this.CompileNode(il' node.Children[0]);  					this.EmitConditionalValue(il' OpCodes.Brfalse);  					break;    				case TokenType.TernaryIf:  					this.CompileNode(il' node.Children[0]);  					this.EmitConditionalBranch(il' OpCodes.Brtrue' node.Children[1]' node.Children[2]);  					break;  			}
Missing Default,NGettext.PluralCompile.Compiler,PluralRuleCompiler,C:\research\architectureSmells\repos\neris_NGettext\src\NGettext.PluralCompile\Compiler\PluralRuleCompiler.cs,CompileNode,The following switch statement is missing a default case: switch (node.Type)  			{  				case TokenType.Number:  					il.Emit(OpCodes.Ldc_I8' node.Value);  					break;    				case TokenType.N:  					il.Emit(OpCodes.Ldarg_0);  					break;    				case TokenType.Plus:  					this.CompileNode(il' node.Children[0]);  					this.CompileNode(il' node.Children[1]);  					il.Emit(OpCodes.Add);  					break;    				case TokenType.Minus:  					this.CompileNode(il' node.Children[0]);  					this.CompileNode(il' node.Children[1]);  					il.Emit(OpCodes.Sub);  					break;    				case TokenType.Divide:  					this.CompileNode(il' node.Children[0]);  					this.CompileNode(il' node.Children[1]);  					il.Emit(OpCodes.Div);  					break;    				case TokenType.Multiply:  					this.CompileNode(il' node.Children[0]);  					this.CompileNode(il' node.Children[1]);  					il.Emit(OpCodes.Mul);  					break;    				case TokenType.Modulo:  					this.CompileNode(il' node.Children[0]);  					this.CompileNode(il' node.Children[1]);  					il.Emit(OpCodes.Rem);  					break;    				case TokenType.GreaterThan:  					this.CompileNode(il' node.Children[0]);  					this.CompileNode(il' node.Children[1]);  					this.EmitConditionalValue(il' OpCodes.Bgt);  					break;    				case TokenType.GreaterOrEquals:  					this.CompileNode(il' node.Children[0]);  					this.CompileNode(il' node.Children[1]);  					this.EmitConditionalValue(il' OpCodes.Bge);  					break;    				case TokenType.LessThan:  					this.CompileNode(il' node.Children[0]);  					this.CompileNode(il' node.Children[1]);  					this.EmitConditionalValue(il' OpCodes.Blt);  					break;    				case TokenType.LessOrEquals:  					this.CompileNode(il' node.Children[0]);  					this.CompileNode(il' node.Children[1]);  					this.EmitConditionalValue(il' OpCodes.Ble);  					break;    				case TokenType.Equals:  					this.CompileNode(il' node.Children[0]);  					this.CompileNode(il' node.Children[1]);  					this.EmitConditionalValue(il' OpCodes.Beq);  					break;    				case TokenType.NotEquals:  					this.CompileNode(il' node.Children[0]);  					this.CompileNode(il' node.Children[1]);  					this.EmitConditionalValue(il' OpCodes.Beq' 0' 1);  					break;    				case TokenType.And:  					this.CompileNode(il' node.Children[0]);  					this.CompileNode(il' node.Children[1]);  					il.Emit(OpCodes.And);  					break;    				case TokenType.Or:  					this.CompileNode(il' node.Children[0]);  					this.CompileNode(il' node.Children[1]);  					il.Emit(OpCodes.Or);  					break;    				case TokenType.Not:  					this.CompileNode(il' node.Children[0]);  					this.EmitConditionalValue(il' OpCodes.Brfalse);  					break;    				case TokenType.TernaryIf:  					this.CompileNode(il' node.Children[0]);  					this.EmitConditionalBranch(il' OpCodes.Brtrue' node.Children[1]' node.Children[2]);  					break;  			}
