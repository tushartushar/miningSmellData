Implementation smell,Namespace,Class,File,Method,Description
Long Method,NetTopologySuite.Algorithm,RobustDeterminant,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Algorithm\RobustDeterminant.cs,SignOfDet2x2,The method has 312 lines of code.
Long Method,RTools_NTS.Util,StreamTokenizer,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Utilities\RToolsUtil\StreamTokenizer.cs,NextToken,The method has 376 lines of code.
Complex Method,NetTopologySuite.Algorithm,CGAlgorithms3D,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Algorithm\CGAlgorithms3D.cs,DistanceSegmentSegment,Cyclomatic complexity of the method is 10
Complex Method,NetTopologySuite.Algorithm,ConvexHull,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Algorithm\ConvexHull.cs,IsBetween,Cyclomatic complexity of the method is 8
Complex Method,NetTopologySuite.Algorithm,ConvexHull,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Algorithm\ConvexHull.cs,ComputeOctPts,Cyclomatic complexity of the method is 11
Complex Method,NetTopologySuite.Algorithm,MinimumBoundingCircle,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Algorithm\MinimumBoundingCircle.cs,ComputeCirclePoints,Cyclomatic complexity of the method is 9
Complex Method,NetTopologySuite.Algorithm,MinimumDiameter,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Algorithm\MinimumDiameter.cs,GetMinimumRectangle,Cyclomatic complexity of the method is 8
Complex Method,NetTopologySuite.Algorithm,PointLocator,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Algorithm\PointLocator.cs,ComputeLocation,Cyclomatic complexity of the method is 11
Complex Method,NetTopologySuite.Algorithm,RayCrossingCounter,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Algorithm\RayCrossingCounter.cs,CountSegment,Cyclomatic complexity of the method is 10
Complex Method,NetTopologySuite.Algorithm,RobustDeterminant,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Algorithm\RobustDeterminant.cs,SignOfDet2x2,Cyclomatic complexity of the method is 39
Complex Method,NetTopologySuite.Algorithm,RobustLineIntersector,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Algorithm\RobustLineIntersector.cs,ComputeIntersect,Cyclomatic complexity of the method is 12
Complex Method,NetTopologySuite.GeometriesGraph,DirectedEdgeStar,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\GeometriesGraph\DirectedEdgeStar.cs,LinkResultDirectedEdges,Cyclomatic complexity of the method is 10
Complex Method,NetTopologySuite.GeometriesGraph,DirectedEdgeStar,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\GeometriesGraph\DirectedEdgeStar.cs,LinkMinimalDirectedEdges,Cyclomatic complexity of the method is 8
Complex Method,NetTopologySuite.GeometriesGraph,DirectedEdgeStar,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\GeometriesGraph\DirectedEdgeStar.cs,FindCoveredLineEdges,Cyclomatic complexity of the method is 10
Complex Method,NetTopologySuite.GeometriesGraph,EdgeEndStar,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\GeometriesGraph\EdgeEndStar.cs,ComputeLabelling,Cyclomatic complexity of the method is 8
Complex Method,NetTopologySuite.GeometriesGraph,EdgeEndStar,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\GeometriesGraph\EdgeEndStar.cs,PropagateSideLabels,Cyclomatic complexity of the method is 10
Complex Method,NetTopologySuite.GeometriesGraph,GeometryGraph,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\GeometriesGraph\GeometryGraph.cs,Add,Cyclomatic complexity of the method is 10
Complex Method,NetTopologySuite.GeometriesGraph.Index,MonotoneChainEdge,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\GeometriesGraph\Index\MonotoneChainEdge.cs,ComputeIntersectsForChain,Cyclomatic complexity of the method is 9
Complex Method,NetTopologySuite.GeometriesGraph.Index,SegmentIntersector,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\GeometriesGraph\Index\SegmentIntersector.cs,AddIntersections,Cyclomatic complexity of the method is 9
Complex Method,NetTopologySuite.Geometries,CoordinateSequenceComparator,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Geometries\CoordinateSequenceComparator.cs,Compare,Cyclomatic complexity of the method is 10
Complex Method,NetTopologySuite.Geometries,Envelope,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Geometries\Envelope.cs,Distance,Cyclomatic complexity of the method is 8
Complex Method,NetTopologySuite.Geometries,Envelope,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Geometries\Envelope.cs,CompareTo,Cyclomatic complexity of the method is 12
Complex Method,NetTopologySuite.Geometries,Envelope,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Geometries\Envelope.cs,Parse,Cyclomatic complexity of the method is 9
Complex Method,NetTopologySuite.Geometries,Geometry,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Geometries\Geometry.cs,Intersects,Cyclomatic complexity of the method is 8
Complex Method,NetTopologySuite.Geometries,GeometryCollectionEnumerator,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Geometries\GeometryCollectionEnumerator.cs,MoveNext,Cyclomatic complexity of the method is 8
Complex Method,NetTopologySuite.Geometries,GeometryFactory,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Geometries\GeometryFactory.cs,BuildGeometry,Cyclomatic complexity of the method is 12
Complex Method,NetTopologySuite.Geometries,OctagonalEnvelope,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Geometries\OctogonalEnvelope.cs,ExpandToInclude,Cyclomatic complexity of the method is 11
Complex Method,NetTopologySuite.Geometries,OctagonalEnvelope,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Geometries\OctogonalEnvelope.cs,ExpandToInclude,Cyclomatic complexity of the method is 10
Complex Method,NetTopologySuite.Geometries,OctagonalEnvelope,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Geometries\OctogonalEnvelope.cs,Intersects,Cyclomatic complexity of the method is 10
Complex Method,NetTopologySuite.Geometries,OctagonalEnvelope,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Geometries\OctogonalEnvelope.cs,Intersects,Cyclomatic complexity of the method is 9
Complex Method,NetTopologySuite.Geometries.Implementation,DotSpatialAffineCoordinateSequence,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Geometries\Implementation\DotSpatialAffineCoordinateSequence.cs,DotSpatialAffineCoordinateSequence,Cyclomatic complexity of the method is 8
Complex Method,NetTopologySuite.Geometries.Implementation,DotSpatialAffineCoordinateSequence,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Geometries\Implementation\DotSpatialAffineCoordinateSequence.cs,DotSpatialAffineCoordinateSequence,Cyclomatic complexity of the method is 9
Complex Method,NetTopologySuite.Geometries.Implementation,DotSpatialAffineCoordinateSequence,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Geometries\Implementation\DotSpatialAffineCoordinateSequence.cs,ToCoordinateArray,Cyclomatic complexity of the method is 9
Complex Method,NetTopologySuite.Geometries.Prepared,AbstractPreparedPolygonContains,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Geometries\Prepared\AbstractPreparedPolygonContains.cs,Eval,Cyclomatic complexity of the method is 8
Complex Method,NetTopologySuite.Geometries.Utilities,GeometryTransformer,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Geometries\Utilities\GeometryTransformer.cs,Transform,Cyclomatic complexity of the method is 9
Complex Method,NetTopologySuite.Geometries.Utilities,GeometryTransformer,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Geometries\Utilities\GeometryTransformer.cs,TransformPolygon,Cyclomatic complexity of the method is 8
Complex Method,NetTopologySuite.Geometries.Utilities,Matrix,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Geometries\Utilities\Matrix.cs,Solve,Cyclomatic complexity of the method is 10
Complex Method,NetTopologySuite.Index.Chain,MonotoneChain,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Index\Chain\MonotoneChain.cs,ComputeOverlaps,Cyclomatic complexity of the method is 9
Complex Method,NetTopologySuite.Index.Quadtree,NodeBase<T>,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Index\Quadtree\NodeBase.cs,Remove,Cyclomatic complexity of the method is 8
Complex Method,NetTopologySuite.Index.Strtree,AbstractSTRtree<T;TItem>,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Index\Strtree\AbstractSTRtree.cs,Remove,Cyclomatic complexity of the method is 8
Complex Method,NetTopologySuite.IO,WKBReader,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\IO\WKBReader.cs,Read,Cyclomatic complexity of the method is 8
Complex Method,NetTopologySuite.IO,WKBReader,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\IO\WKBReader.cs,ReadGeometryType,Cyclomatic complexity of the method is 8
Complex Method,NetTopologySuite.IO,WKBReader,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\IO\WKBReader.cs,ReadCoordinateSequence,Cyclomatic complexity of the method is 12
Complex Method,NetTopologySuite.IO,WKBReader,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\IO\WKBReader.cs,ReadGeometryCollection,Cyclomatic complexity of the method is 9
Complex Method,NetTopologySuite.IO,WKBWriter,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\IO\WKBWriter.cs,WriteHeader,Cyclomatic complexity of the method is 14
Complex Method,NetTopologySuite.IO,WKBWriter,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\IO\WKBWriter.cs,Write,Cyclomatic complexity of the method is 8
Complex Method,NetTopologySuite.IO,WKBWriter,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\IO\WKBWriter.cs,GetBytes,Cyclomatic complexity of the method is 8
Complex Method,NetTopologySuite.IO,WKBWriter,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\IO\WKBWriter.cs,SetByteStream,Cyclomatic complexity of the method is 8
Complex Method,NetTopologySuite.IO,WKTReader,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\IO\WKTReader.cs,MergeSequences,Cyclomatic complexity of the method is 9
Complex Method,NetTopologySuite.IO,WKTReader,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\IO\WKTReader.cs,ReadGeometryTaggedText,Cyclomatic complexity of the method is 17
Complex Method,NetTopologySuite.IO,WKTWriter,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\IO\WKTWriter.cs,AppendGeometryTaggedText,Cyclomatic complexity of the method is 9
Complex Method,NetTopologySuite.IO.GML2,GMLReader,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\IO\GML2\GMLReader.cs,Read,Cyclomatic complexity of the method is 9
Complex Method,NetTopologySuite.IO.GML2,GMLReader,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\IO\GML2\GMLReader.cs,ReadLineString,Cyclomatic complexity of the method is 10
Complex Method,NetTopologySuite.IO.GML2,GMLReader,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\IO\GML2\GMLReader.cs,ReadGeometryCollection,Cyclomatic complexity of the method is 11
Complex Method,NetTopologySuite.IO.GML2,GMLWriter,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\IO\GML2\GMLWriter.cs,Write,Cyclomatic complexity of the method is 8
Complex Method,NetTopologySuite.IO.GML2,GMLWriter,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\IO\GML2\GMLWriter.cs,SetByteStreamLength,Cyclomatic complexity of the method is 8
Complex Method,NetTopologySuite.LinearReferencing,LinearLocation,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\LinearReferencing\LinearLocation.cs,CompareTo,Cyclomatic complexity of the method is 8
Complex Method,NetTopologySuite.Mathematics,DD,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Mathematics\DD.cs,ExtractSignificantDigits,Cyclomatic complexity of the method is 11
Complex Method,NetTopologySuite.Mathematics,DD,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Mathematics\DD.cs,Parse,Cyclomatic complexity of the method is 15
Complex Method,NetTopologySuite.Mathematics,Matrix,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Mathematics\Matrix.cs,Solve,Cyclomatic complexity of the method is 10
Complex Method,NetTopologySuite.Noding,Octant,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Noding\Octant.cs,GetOctant,Cyclomatic complexity of the method is 9
Complex Method,NetTopologySuite.Noding,SegmentPointComparator,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Noding\SegmentPointComparator.cs,Compare,Cyclomatic complexity of the method is 9
Complex Method,NetTopologySuite.Noding.Snapround,HotPixel,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Noding\Snapround\HotPixel.cs,IntersectsToleranceSquare,Cyclomatic complexity of the method is 10
Complex Method,NetTopologySuite.Operation.Buffer,OffsetCurveSetBuilder,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Operation\Buffer\OffsetCurveSetBuilder.cs,Add,Cyclomatic complexity of the method is 9
Complex Method,NetTopologySuite.Operation.Buffer,SubgraphDepthLocater,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Operation\Buffer\SubgraphDepthLocater.cs,FindStabbedSegments,Cyclomatic complexity of the method is 8
Complex Method,NetTopologySuite.Operation.Distance3D,Distance3DOp,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Operation\Distance3D\Distance3DOp.cs,ComputeMinDistance,Cyclomatic complexity of the method is 13
Complex Method,NetTopologySuite.Operation.Polygonize,PolygonizeGraph,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Operation\Polygonize\PolygonizeGraph.cs,ComputeNextCCWEdges,Cyclomatic complexity of the method is 10
Complex Method,NetTopologySuite.Operation.Relate,RelateComputer,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Operation\Relate\RelateComputer.cs,ComputeProperIntersectionIM,Cyclomatic complexity of the method is 11
Complex Method,NetTopologySuite.Operation.Union,UnaryUnionOp,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Operation\Union\UnaryUnionOp.cs,Union,Cyclomatic complexity of the method is 8
Complex Method,NetTopologySuite.Operation.Valid,IsValidOp,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Operation\Valid\IsValidOp.cs,CheckValid,Cyclomatic complexity of the method is 9
Complex Method,NetTopologySuite.Operation.Valid,IsValidOp,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Operation\Valid\IsValidOp.cs,CheckValid,Cyclomatic complexity of the method is 9
Complex Method,NetTopologySuite.Operation.Valid,IsValidOp,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Operation\Valid\IsValidOp.cs,CheckValid,Cyclomatic complexity of the method is 13
Complex Method,NetTopologySuite.Simplify,VWLineSimplifier,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Simplify\VWLineSimplifier.cs,Simplify,Cyclomatic complexity of the method is 11
Complex Method,NetTopologySuite.Utilities,HexConverter,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Utilities\HexConverter.cs,ConvertAny2Any,Cyclomatic complexity of the method is 9
Complex Method,RTools_NTS.Util,StreamTokenizerSettings,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Utilities\RToolsUtil\StreamTokenizer.cs,CharTypeToString,Cyclomatic complexity of the method is 8
Complex Method,RTools_NTS.Util,StreamTokenizer,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Utilities\RToolsUtil\StreamTokenizer.cs,PickNextState,Cyclomatic complexity of the method is 10
Complex Method,RTools_NTS.Util,StreamTokenizer,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Utilities\RToolsUtil\StreamTokenizer.cs,NextToken,Cyclomatic complexity of the method is 58
Complex Method,RTools_NTS.Util,StreamTokenizer,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Utilities\RToolsUtil\StreamTokenizer.cs,GrabInt,Cyclomatic complexity of the method is 9
Complex Method,RTools_NTS.Util,IntToken,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Utilities\RToolsUtil\Token.cs,Equals,Cyclomatic complexity of the method is 8
Long Parameter List,NetTopologySuite.Algorithm,RobustLineIntersector,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Algorithm\RobustLineIntersector.cs,CheckDD,The method has 5 parameters. Parameters: p1' p2' q1' q2' intPt
Long Parameter List,NetTopologySuite.Algorithm,RobustLineIntersector,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Algorithm\RobustLineIntersector.cs,NormalizeToEnvCentre,The method has 5 parameters. Parameters: n00' n01' n10' n11' normPt
Long Parameter List,NetTopologySuite.GeometriesGraph.Index,MonotoneChainEdge,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\GeometriesGraph\Index\MonotoneChainEdge.cs,ComputeIntersectsForChain,The method has 6 parameters. Parameters: start0' end0' mce' start1' end1' ei
Long Parameter List,NetTopologySuite.GeometriesGraph.Index,MonotoneChainEdge,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\GeometriesGraph\Index\MonotoneChainEdge.cs,Overlaps,The method has 5 parameters. Parameters: start0' end0' mce' start1' end1
Long Parameter List,NetTopologySuite.Geometries,CoordinateArrays,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Geometries\CoordinateArrays.cs,CopyDeep,The method has 5 parameters. Parameters: src' srcStart' dest' destStart' length
Long Parameter List,NetTopologySuite.Geometries,CoordinateSequences,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Geometries\CoordinateSequences.cs,Copy,The method has 5 parameters. Parameters: src' srcPos' dest' destPos' length
Long Parameter List,NetTopologySuite.Geometries.Utilities,AffineTransformation,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Geometries\Utilities\AffineTransformation.cs,AffineTransformation,The method has 6 parameters. Parameters: m00' m01' m02' m10' m11' m12
Long Parameter List,NetTopologySuite.Geometries.Utilities,AffineTransformation,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Geometries\Utilities\AffineTransformation.cs,AffineTransformation,The method has 6 parameters. Parameters: src0' src1' src2' dest0' dest1' dest2
Long Parameter List,NetTopologySuite.Geometries.Utilities,AffineTransformation,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Geometries\Utilities\AffineTransformation.cs,SetTransformation,The method has 6 parameters. Parameters: m00' m01' m02' m10' m11' m12
Long Parameter List,NetTopologySuite.Geometries.Utilities,AffineTransformationBuilder,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Geometries\Utilities\AffineTransformationBuilder.cs,AffineTransformationBuilder,The method has 6 parameters. Parameters: src0' src1' src2' dest0' dest1' dest2
Long Parameter List,NetTopologySuite.Geometries.Utilities,AffineTransformationFactory,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Geometries\Utilities\AffineTransformationFactory.cs,CreateFromControlVectors,The method has 6 parameters. Parameters: src0' src1' src2' dest0' dest1' dest2
Long Parameter List,NetTopologySuite.Geometries.Utilities,SineStarFactory,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Geometries\Utilities\SineStarFactory.cs,Create,The method has 5 parameters. Parameters: origin' size' nPts' nArms' armLengthRatio
Long Parameter List,NetTopologySuite.Index.Chain,MonotoneChain,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Index\Chain\MonotoneChain.cs,ComputeOverlaps,The method has 6 parameters. Parameters: start0' end0' mc' start1' end1' mco
Long Parameter List,NetTopologySuite.Index.Chain,MonotoneChain,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Index\Chain\MonotoneChain.cs,Overlaps,The method has 5 parameters. Parameters: start0' end0' mc' start1' end1
Long Parameter List,NetTopologySuite.Index.KdTree,KdTreeExtensions,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Index\KdTree\KdTreeExtensions.cs,NearestNeighbor,The method has 5 parameters. Parameters: currentNode' queryCoordinate' closestNode' closestDistanceSq' isOddLevel
Long Parameter List,NetTopologySuite.Index.KdTree,KdTreeExtensions,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Index\KdTree\KdTreeExtensions.cs,NeedsToBeSearched,The method has 5 parameters. Parameters: target' node' closestDistSq' left' isOddLevel
Long Parameter List,NetTopologySuite.Index.Strtree,BoundablePair<TItem>,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Index\Strtree\BoundablePair.cs,Expand,The method has 5 parameters. Parameters: bndComposite' bndOther' isFlipped' priQ' minDistance
Long Parameter List,NetTopologySuite.IO,WKTWriter,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\IO\WKTWriter.cs,AppendGeometryTaggedText,The method has 6 parameters. Parameters: geometry' useFormatting' writer' formatter' format' useMaxPrecision
Long Parameter List,NetTopologySuite.IO,WKTWriter,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\IO\WKTWriter.cs,AppendGeometryTaggedText,The method has 8 parameters. Parameters: geometry' outputOrdinates' useFormatting' level' writer' formatter' format' useMaxPrecision
Long Parameter List,NetTopologySuite.IO,WKTWriter,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\IO\WKTWriter.cs,AppendPointTaggedText,The method has 8 parameters. Parameters: point' outputOrdinates' useFormatting' level' writer' formatter' format' useMaxPrecision
Long Parameter List,NetTopologySuite.IO,WKTWriter,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\IO\WKTWriter.cs,AppendLineStringTaggedText,The method has 8 parameters. Parameters: lineString' outputOrdinates' useFormatting' level' writer' formatter' format' useMaxPrecision
Long Parameter List,NetTopologySuite.IO,WKTWriter,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\IO\WKTWriter.cs,AppendLinearRingTaggedText,The method has 8 parameters. Parameters: linearRing' outputOrdinates' useFormatting' level' writer' formatter' format' useMaxPrecision
Long Parameter List,NetTopologySuite.IO,WKTWriter,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\IO\WKTWriter.cs,AppendPolygonTaggedText,The method has 8 parameters. Parameters: polygon' outputOrdinates' useFormatting' level' writer' formatter' format' useMaxPrecision
Long Parameter List,NetTopologySuite.IO,WKTWriter,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\IO\WKTWriter.cs,AppendMultiPointTaggedText,The method has 8 parameters. Parameters: multipoint' outputOrdinates' useFormatting' level' writer' formatter' format' useMaxPrecision
Long Parameter List,NetTopologySuite.IO,WKTWriter,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\IO\WKTWriter.cs,AppendMultiLineStringTaggedText,The method has 8 parameters. Parameters: multiLineString' outputOrdinates' useFormatting' level' writer' formatter' format' useMaxPrecision
Long Parameter List,NetTopologySuite.IO,WKTWriter,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\IO\WKTWriter.cs,AppendMultiPolygonTaggedText,The method has 8 parameters. Parameters: multiPolygon' outputOrdinates' useFormatting' level' writer' formatter' format' useMaxPrecision
Long Parameter List,NetTopologySuite.IO,WKTWriter,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\IO\WKTWriter.cs,AppendGeometryCollectionTaggedText,The method has 8 parameters. Parameters: geometryCollection' outputOrdinates' useFormatting' level' writer' formatter' format' useMaxPrecision
Long Parameter List,NetTopologySuite.IO,WKTWriter,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\IO\WKTWriter.cs,AppendCoordinate,The method has 7 parameters. Parameters: seq' outputOrdinates' i' writer' formatter' format' useMaxPrecision
Long Parameter List,NetTopologySuite.IO,WKTWriter,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\IO\WKTWriter.cs,AppendSequenceText,The method has 9 parameters. Parameters: seq' outputOrdinates' useFormatting' level' indentFirst' writer' formatter' format' useMaxPrecision
Long Parameter List,NetTopologySuite.IO,WKTWriter,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\IO\WKTWriter.cs,AppendPolygonText,The method has 9 parameters. Parameters: polygon' outputOrdinates' useFormatting' level' indentFirst' writer' formatter' format' useMaxPrecision
Long Parameter List,NetTopologySuite.IO,WKTWriter,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\IO\WKTWriter.cs,AppendMultiPointText,The method has 8 parameters. Parameters: multiPoint' outputOrdinates' useFormatting' level' writer' formatter' format' useMaxPrecision
Long Parameter List,NetTopologySuite.IO,WKTWriter,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\IO\WKTWriter.cs,AppendMultiLineStringText,The method has 8 parameters. Parameters: multiLineString' outputOrdinates' useFormatting' level' writer' formatter' format' useMaxPrecision
Long Parameter List,NetTopologySuite.IO,WKTWriter,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\IO\WKTWriter.cs,AppendMultiPolygonText,The method has 8 parameters. Parameters: multiPolygon' outputOrdinates' useFormatting' level' writer' formatter' format' useMaxPrecision
Long Parameter List,NetTopologySuite.IO,WKTWriter,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\IO\WKTWriter.cs,AppendGeometryCollectionText,The method has 8 parameters. Parameters: geometryCollection' outputOrdinates' useFormatting' level' writer' formatter' format' useMaxPrecision
Long Parameter List,NetTopologySuite.IO.KML,KMLWriter,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\IO\KML\KMLWriter.cs,WriteGeometry,The method has 5 parameters. Parameters: geometry' z' precision' extrude' altitudeMode
Long Parameter List,NetTopologySuite.LinearReferencing,LinearLocation,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\LinearReferencing\LinearLocation.cs,CompareLocationValues,The method has 6 parameters. Parameters: componentIndex0' segmentIndex0' segmentFraction0' componentIndex1' segmentIndex1' segmentFraction1
Long Parameter List,NetTopologySuite.Noding,NodingIntersectionFinder,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Noding\NodingIntersectionFinder.cs,IsInteriorVertexIntersection,The method has 8 parameters. Parameters: p00' p01' p10' p11' isEnd00' isEnd01' isEnd10' isEnd11
Long Parameter List,NetTopologySuite.Operation.Buffer,BufferInputLineSimplifier,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Operation\Buffer\BufferInputLineSimplifier.cs,IsShallowSampled,The method has 5 parameters. Parameters: p0' p2' i0' i2' distanceTol
Long Parameter List,NetTopologySuite.Operation.Buffer,OffsetCurveSetBuilder,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Operation\Buffer\OffsetCurveSetBuilder.cs,AddPolygonRing,The method has 5 parameters. Parameters: coord' offsetDistance' side' cwLeftLoc' cwRightLoc
Long Parameter List,NetTopologySuite.Operation.Buffer,OffsetSegmentGenerator,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Operation\Buffer\OffsetSegmentGenerator.cs,AddCornerFillet,The method has 5 parameters. Parameters: p' p0' p1' direction' radius
Long Parameter List,NetTopologySuite.Operation.Buffer,OffsetSegmentGenerator,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Operation\Buffer\OffsetSegmentGenerator.cs,AddDirectedFillet,The method has 5 parameters. Parameters: p' startAngle' endAngle' direction' radius
Long Parameter List,NetTopologySuite.Operation.Buffer,OldOffsetCurveBuilder,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Operation\Buffer\OldOffsetCurveBuilder.cs,AddFillet,The method has 5 parameters. Parameters: p' p0' p1' direction' radius
Long Parameter List,NetTopologySuite.Operation.Buffer,OldOffsetCurveBuilder,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Operation\Buffer\OldOffsetCurveBuilder.cs,AddFillet,The method has 5 parameters. Parameters: p' startAngle' endAngle' direction' radius
Long Parameter List,NetTopologySuite.Operation.Distance,FacetSequence,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Operation\Distance\FacetSequence.cs,UpdateNearestLocationsLineLine,The method has 8 parameters. Parameters: i' p0' p1' facetSeq' j' q0' q1' locs
Long Parameter List,NetTopologySuite.Operation.Distance,FacetSequence,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Operation\Distance\FacetSequence.cs,UpdateNearestLocationsPointLine,The method has 6 parameters. Parameters: pt' facetSeq' i' q0' q1' locs
Long Parameter List,NetTopologySuite.Shape.Fractal,SierpinskiCarpetBuilder,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Shape\Fractal\SierpinskiCarpetBuilder.cs,AddHoles,The method has 5 parameters. Parameters: n' originX' originY' width' holeList
Long Parameter List,NetTopologySuite.Triangulate,Segment,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Triangulate\Segment.cs,Segment,The method has 6 parameters. Parameters: x1' y1' z1' x2' y2' z2
Long Parameter List,NetTopologySuite.Triangulate,Segment,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Triangulate\Segment.cs,Segment,The method has 7 parameters. Parameters: x1' y1' z1' x2' y2' z2' data
Long Identifier,NetTopologySuite.Algorithm,BoundaryNodeRules,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Algorithm\BoundaryNodeRule.cs,,The length of the parameter MultivalentEndpointBoundaryRule is 31.
Long Identifier,NetTopologySuite.Algorithm,BoundaryNodeRules,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Algorithm\BoundaryNodeRule.cs,,The length of the parameter MonoValentEndpointBoundaryRule is 30.
Long Identifier,NetTopologySuite.Geometries,GeometryFactoryEx,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Geometries\GeometryFactoryEx.cs,,The length of the parameter _defaultCoordinateSequenceFactory is 33.
Long Identifier,NetTopologySuite.Geometries.Prepared,AbstractPreparedPolygonContains,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Geometries\Prepared\AbstractPreparedPolygonContains.cs,Eval,The length of the parameter properIntersectionImpliesNotContained is 37.
Long Identifier,NetTopologySuite.Geometries.Utilities,GeometryTransformer,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Geometries\Utilities\GeometryTransformer.cs,,The length of the parameter preserveGeometryCollectionType is 30.
Long Identifier,NetTopologySuite.IO,WKTReader,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\IO\WKTReader.cs,,The length of the parameter _isAllowOldNtsCoordinateSyntax is 30.
Long Identifier,NetTopologySuite.IO,WKTReader,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\IO\WKTReader.cs,,The length of the parameter _isAllowOldNtsMultipointSyntax is 30.
Long Identifier,NetTopologySuite.IO,WKTWriter,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\IO\WKTWriter.cs,,The length of the parameter _missingOrdinateReplacementText is 31.
Long Identifier,NetTopologySuite.Operation.Buffer,OffsetSegmentGenerator,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Operation\Buffer\OffsetSegmentGenerator.cs,,The length of the parameter InsideTurnVertexSnapDistanceFactor is 34.
Long Identifier,NetTopologySuite.Operation.Buffer,OldOffsetCurveBuilder,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Operation\Buffer\OldOffsetCurveBuilder.cs,,The length of the parameter OFFSET_SEGMENT_SEPARATION_FACTOR is 32.
Long Identifier,NetTopologySuite.Operation.Buffer,OldOffsetCurveBuilder,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Operation\Buffer\OldOffsetCurveBuilder.cs,,The length of the parameter INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR is 39.
Long Identifier,NetTopologySuite.Operation.Overlay.Snap,LineStringSnapper,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Operation\Overlay\Snap\LineStringSnapper.cs,,The length of the parameter _allowSnappingToSourceVertices is 30.
Long Identifier,NetTopologySuite.Operation.Valid,IsValidOp,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Operation\Valid\IsValidOp.cs,,The length of the parameter _isSelfTouchingRingFormingHoleValid is 35.
Long Identifier,NetTopologySuite.Triangulate.QuadEdge,QuadEdgeSubdivision,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Triangulate\QuadEdge\QuadEdgeSubdivision.cs,,The length of the parameter EdgeCoincidenceToleranceFactor is 30.
Long Statement,NetTopologySuite.Algorithm,MinimumBoundingCircle,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Algorithm\MinimumBoundingCircle.cs,GetDiameter,The length of the statement  "            //TODO: handle case of 3 extremal points' by computing a line from one of them through the centre point with len = 2*radius " is 123.
Long Statement,NetTopologySuite.Algorithm.Locate,PointOnGeometryLocatorExtensions,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Algorithm\Locate\IPointOnGeometryLocator.cs,Intersects,The length of the statement  "                    throw new InvalidOperationException("IPointOnGeometryLocator.Locate should never return anything other than Boundary' Interior' or Exterior."); " is 143.
Long Statement,NetTopologySuite.Geometries,CoordinateSequence,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Geometries\CoordinateSequence.cs,Reversed,The length of the statement  "            var copy = Copy() ?? throw new InvalidOperationException("Cannot reverse a coordinate sequence whose Copy() method returns null."); " is 131.
Long Statement,NetTopologySuite.Geometries,CoordinateSequenceFactory,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Geometries\CoordinateSequenceFactory.cs,Create,The length of the statement  "            var result = Create(coordinates?.Length ?? 0' CoordinateArrays.Dimension(coordinates)' CoordinateArrays.Measures(coordinates)); " is 127.
Long Statement,NetTopologySuite.Geometries,Envelope,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Geometries\Envelope.cs,Parse,The length of the statement  "                if (!double.TryParse(ordinates[0].Trim()' NumberStyles.Number' NumberFormatInfo.InvariantInfo' out ordinatesValues[2 * j])) " is 123.
Long Statement,NetTopologySuite.Geometries,Envelope,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Geometries\Envelope.cs,Parse,The length of the statement  "                if (!double.TryParse(ordinates[1].Trim()' NumberStyles.Number' NumberFormatInfo.InvariantInfo' out ordinatesValues[2 * j + 1])) " is 127.
Long Statement,NetTopologySuite.Geometries,IntersectionMatrix,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Geometries\IntersectionMatrix.cs,Matches,The length of the statement  "            if (requiredDimensionSymbol == DimensionUtility.SymTrue && (actualDimensionValue >= Dimension.Point || actualDimensionValue == Dimension.True)) " is 143.
Long Statement,NetTopologySuite.Geometries.Utilities,GeometryEditor,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Geometries\Utilities\GeometryEditor.cs,EditInternal,The length of the statement  "            NetTopologySuite.Utilities.Assert.ShouldNeverReachHere("Unsupported Geometry classes should be caught in the GeometryEditorOperation."); " is 136.
Long Statement,NetTopologySuite.IO,WKTFileReader,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\IO\WKTFileReader.cs,Read,The length of the statement  "                _reader =  new StreamReader(new FileStream(_file.FullName' FileMode.Open' FileAccess.Read' FileShare.Read' MaxLookahead)); " is 122.
Long Statement,NetTopologySuite.IO,WKTReader,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\IO\WKTReader.cs,GetCoordinate,The length of the statement  "            var sequence = _coordinateSequencefactory.Create(1' this.ToDimension(ordinateFlags)' ordinateFlags.HasFlag(Ordinates.M) ? 1 : 0); " is 129.
Long Statement,NetTopologySuite.IO,WKTReader,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\IO\WKTReader.cs,MergeSequences,The length of the statement  "            var sequence = _coordinateSequencefactory.Create(sequences.Count' this.ToDimension(mergeOrdinates)' mergeOrdinates.HasFlag(Ordinates.M) ? 1 : 0); " is 145.
Long Statement,NetTopologySuite.IO,WKTReader,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\IO\WKTReader.cs,GetNextNumber,The length of the statement  "                    if (double.TryParse(wordToken.StringValue' NumberStyles.Float | NumberStyles.AllowThousands' InvariantCulture' out double val)) " is 127.
Long Statement,NetTopologySuite.IO,WKTWriter,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\IO\WKTWriter.cs,ToPoint,The length of the statement  "            return "POINT ( " + p0.X.ToString("G17"' CultureInfo.InvariantCulture) + " " + p0.Y.ToString("G17"' CultureInfo.InvariantCulture) + " )"; " is 137.
Long Statement,NetTopologySuite.IO,WKTWriter,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\IO\WKTWriter.cs,ToLineString,The length of the statement  "                    buf.Append(seq.GetX(i).ToString("G17"' CultureInfo.InvariantCulture) + " " + seq.GetY(i).ToString("G17"' CultureInfo.InvariantCulture)); " is 136.
Long Statement,NetTopologySuite.IO,WKTWriter,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\IO\WKTWriter.cs,ToLineString,The length of the statement  "                    buf.Append(coord[i].X.ToString("G17"' CultureInfo.InvariantCulture) + " " + coord[i].Y.ToString("G17"' CultureInfo.InvariantCulture)); " is 134.
Long Statement,NetTopologySuite.IO,WKTWriter,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\IO\WKTWriter.cs,ToLineString,The length of the statement  "            return "LINESTRING ( " + p0.X.ToString("G17"' CultureInfo.InvariantCulture) + " " + p0.Y.ToString("G17"' CultureInfo.InvariantCulture) + "' " + p1.X.ToString("G17"' CultureInfo.InvariantCulture) + " " + p1.Y.ToString("G17"' CultureInfo.InvariantCulture) + " )"; " is 261.
Long Statement,NetTopologySuite.IO,WKTWriter,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\IO\WKTWriter.cs,AppendGeometryTaggedText,The length of the statement  "                    AppendLinearRingTaggedText(linearRing' outputOrdinates' useFormatting' level' writer' formatter' format' useMaxPrecision); " is 122.
Long Statement,NetTopologySuite.IO,WKTWriter,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\IO\WKTWriter.cs,AppendGeometryTaggedText,The length of the statement  "                    AppendLineStringTaggedText(lineString' outputOrdinates' useFormatting' level' writer' formatter' format' useMaxPrecision); " is 122.
Long Statement,NetTopologySuite.IO,WKTWriter,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\IO\WKTWriter.cs,AppendGeometryTaggedText,The length of the statement  "                    AppendMultiPointTaggedText(multiPoint' outputOrdinates' useFormatting' level' writer' formatter' format' useMaxPrecision); " is 122.
Long Statement,NetTopologySuite.IO,WKTWriter,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\IO\WKTWriter.cs,AppendGeometryTaggedText,The length of the statement  "                    AppendMultiLineStringTaggedText(multiLineString' outputOrdinates' useFormatting' level' writer' formatter' format' useMaxPrecision); " is 132.
Long Statement,NetTopologySuite.IO,WKTWriter,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\IO\WKTWriter.cs,AppendGeometryTaggedText,The length of the statement  "                    AppendMultiPolygonTaggedText(multiPolygon' outputOrdinates' useFormatting' level' writer' formatter' format' useMaxPrecision); " is 126.
Long Statement,NetTopologySuite.IO,WKTWriter,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\IO\WKTWriter.cs,AppendGeometryTaggedText,The length of the statement  "                    AppendGeometryCollectionTaggedText(geometryCollection' outputOrdinates' useFormatting' level' writer' formatter' format' useMaxPrecision); " is 138.
Long Statement,NetTopologySuite.IO,WKTWriter,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\IO\WKTWriter.cs,AppendPointTaggedText,The length of the statement  "            AppendSequenceText(point.CoordinateSequence' outputOrdinates' useFormatting' level' false' writer' formatter' format' useMaxPrecision); " is 135.
Long Statement,NetTopologySuite.IO,WKTWriter,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\IO\WKTWriter.cs,AppendLineStringTaggedText,The length of the statement  "            AppendSequenceText(lineString.CoordinateSequence' outputOrdinates' useFormatting' level' false' writer' formatter' format' useMaxPrecision); " is 140.
Long Statement,NetTopologySuite.IO,WKTWriter,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\IO\WKTWriter.cs,AppendLinearRingTaggedText,The length of the statement  "            AppendSequenceText(linearRing.CoordinateSequence' outputOrdinates' useFormatting' level' false' writer' formatter' format' useMaxPrecision); " is 140.
Long Statement,NetTopologySuite.IO,WKTWriter,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\IO\WKTWriter.cs,AppendMultiLineStringTaggedText,The length of the statement  "            AppendMultiLineStringText(multiLineString' outputOrdinates' useFormatting' level' /*false' */writer' formatter' format' useMaxPrecision); " is 137.
Long Statement,NetTopologySuite.IO,WKTWriter,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\IO\WKTWriter.cs,AppendMultiPolygonTaggedText,The length of the statement  "            AppendMultiPolygonText(multiPolygon' outputOrdinates' useFormatting' level' /*false' */writer' formatter' format' useMaxPrecision); " is 131.
Long Statement,NetTopologySuite.IO,WKTWriter,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\IO\WKTWriter.cs,AppendGeometryCollectionTaggedText,The length of the statement  "            AppendGeometryCollectionText(geometryCollection' outputOrdinates' useFormatting' level' writer' formatter' format' useMaxPrecision); " is 132.
Long Statement,NetTopologySuite.IO,WKTWriter,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\IO\WKTWriter.cs,AppendCoordinate,The length of the statement  "            writer.Write(WriteNumber(seq.GetX(i)' formatter' format' useMaxPrecision) + " " + WriteNumber(seq.GetY(i)' formatter' format' useMaxPrecision)); " is 144.
Long Statement,NetTopologySuite.IO,WKTWriter,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\IO\WKTWriter.cs,AppendMultiPolygonText,The length of the statement  "                    AppendPolygonText((Polygon) multiPolygon.GetGeometryN(i)' outputOrdinates' useFormatting' level2' doIndent' writer' formatter' format' useMaxPrecision); " is 152.
Long Statement,NetTopologySuite.IO,WKTWriter,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\IO\WKTWriter.cs,AppendGeometryCollectionText,The length of the statement  "                    AppendGeometryTaggedText(geometryCollection.GetGeometryN(i)' outputOrdinates' useFormatting' level2' writer' formatter' format' useMaxPrecision); " is 145.
Long Statement,NetTopologySuite.IO.GML2,GMLReader,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\IO\GML2\GMLReader.cs,ReadLineString,The length of the statement  "                            coordinates.AddRange(ReadPosListAsCoordinates(XmlConvert.ToInt32(tmp)' reader.ReadContentAsString().Split(new[] { ' ' }' StringSplitOptions.RemoveEmptyEntries))); " is 162.
Long Statement,NetTopologySuite.Operation.Buffer,BufferInputLineSimplifier,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Operation\Buffer\BufferInputLineSimplifier.cs,CollapseLine,The length of the statement  "            // if (coordList.size() < inputLine.length)      System.out.println("Simplified " + (inputLine.length - coordList.size()) + " pts"); " is 132.
Long Statement,NetTopologySuite.Operation.Overlay,OverlayOp,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Operation\Overlay\OverlayOp.cs,ReplaceCollapsedEdges,The length of the statement  "                // This instruction throws a "System.InvalidOperationException: Collection was modified; enumeration operation may not execute". " is 128.
Long Statement,NetTopologySuite.Triangulate,ConformingDelaunayTriangulator,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Triangulate\ConformingDelaunayTriangulator.cs,EnforceGabriel,The length of the statement  "                    // throw new ConstraintEnforcementException("Split point snapped to existing point (tolerance too large or constraint interior narrow angle?)"' splitPt); " is 153.
Complex Conditional,NetTopologySuite.Algorithm,DistanceComputer,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Algorithm\Distance.cs,SegmentToSegment,The conditional expression  "(r < 0) || (r > 1) || (s < 0) || (s > 1)"  is complex.
Complex Conditional,NetTopologySuite.Algorithm,HCoordinate,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Algorithm\HCoordinate.cs,Intersection,The conditional expression  "(double.IsNaN(xInt)) || (double.IsInfinity(xInt)                                           || double.IsNaN(yInt)) || (double.IsInfinity(yInt))"  is complex.
Complex Conditional,NetTopologySuite.Algorithm,RayCrossingCounter,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Algorithm\RayCrossingCounter.cs,CountSegment,The conditional expression  "((p1.Y > _p.Y) && (p2.Y <= _p.Y))                      || ((p2.Y > _p.Y) && (p1.Y <= _p.Y))"  is complex.
Complex Conditional,NetTopologySuite.Algorithm,RobustLineIntersector,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Algorithm\RobustLineIntersector.cs,ComputeIntersect,The conditional expression  "(Pq1 > 0 && Pq2 > 0) ||                  (Pq1 < 0 && Pq2 < 0)"  is complex.
Complex Conditional,NetTopologySuite.Algorithm,RobustLineIntersector,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Algorithm\RobustLineIntersector.cs,ComputeIntersect,The conditional expression  "(Qp1 > 0 && Qp2 > 0) ||                  (Qp1 < 0 && Qp2 < 0)"  is complex.
Complex Conditional,NetTopologySuite.Algorithm,RobustLineIntersector,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Algorithm\RobustLineIntersector.cs,ComputeIntersect,The conditional expression  "Pq1 == 0 || Pq2 == 0 || Qp1 == 0 || Qp2 == 0"  is complex.
Complex Conditional,NetTopologySuite.EdgeGraph,HalfEdge,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\EdgeGraph\HalfEdge.cs,Init,The conditional expression  "e0.Sym != null || e1.Sym != null ||                  e0.Next != null || e1.Next != null"  is complex.
Complex Conditional,NetTopologySuite.GeometriesGraph.Index,SegmentIntersector,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\GeometriesGraph\Index\SegmentIntersector.cs,IsTrivialIntersection,The conditional expression  "(segIndex0 == 0 && segIndex1 == maxSegIndex) ||                              (segIndex1 == 0 && segIndex0 == maxSegIndex)"  is complex.
Complex Conditional,NetTopologySuite.Geometries,IntersectionMatrix,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Geometries\IntersectionMatrix.cs,IsTouches,The conditional expression  "(dimensionOfGeometryA == Dimension.Surface && dimensionOfGeometryB == Dimension.Surface) ||                  (dimensionOfGeometryA == Dimension.Curve && dimensionOfGeometryB == Dimension.Curve) ||                  (dimensionOfGeometryA == Dimension.Curve && dimensionOfGeometryB == Dimension.Surface) ||                  (dimensionOfGeometryA == Dimension.Point && dimensionOfGeometryB == Dimension.Surface) ||                  (dimensionOfGeometryA == Dimension.Point && dimensionOfGeometryB == Dimension.Curve)"  is complex.
Complex Conditional,NetTopologySuite.Geometries,IntersectionMatrix,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Geometries\IntersectionMatrix.cs,IsCrosses,The conditional expression  "(dimensionOfGeometryA == Dimension.Point && dimensionOfGeometryB == Dimension.Curve) ||                  (dimensionOfGeometryA == Dimension.Point && dimensionOfGeometryB == Dimension.Surface) ||                  (dimensionOfGeometryA == Dimension.Curve && dimensionOfGeometryB == Dimension.Surface)"  is complex.
Complex Conditional,NetTopologySuite.Geometries,IntersectionMatrix,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Geometries\IntersectionMatrix.cs,IsCrosses,The conditional expression  "(dimensionOfGeometryA == Dimension.Curve && dimensionOfGeometryB == Dimension.Point) ||                  (dimensionOfGeometryA == Dimension.Surface && dimensionOfGeometryB == Dimension.Point) ||                  (dimensionOfGeometryA == Dimension.Surface && dimensionOfGeometryB == Dimension.Curve)"  is complex.
Complex Conditional,NetTopologySuite.Geometries,IntersectionMatrix,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Geometries\IntersectionMatrix.cs,IsOverlaps,The conditional expression  "(dimensionOfGeometryA == Dimension.Point && dimensionOfGeometryB == Dimension.Point) ||                  (dimensionOfGeometryA == Dimension.Surface && dimensionOfGeometryB == Dimension.Surface)"  is complex.
Complex Conditional,NetTopologySuite.Index.KdTree,BestMatchVisitor<T>,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Index\KdTree\KdTree.cs,Visit,The conditional expression  "matchNode == null                      || dist < matchDist                      // if distances are the same' record the lesser coordinate                      || (matchNode != null && dist == matchDist                          && node.Coordinate.CompareTo(matchNode.Coordinate) < 1)"  is complex.
Complex Conditional,NetTopologySuite.Noding,IntersectionAdder,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Noding\IntersectionAdder.cs,IsTrivialIntersection,The conditional expression  "(segIndex0 == 0 && segIndex1 == maxSegIndex) ||                               (segIndex1 == 0 && segIndex0 == maxSegIndex)"  is complex.
Complex Conditional,NetTopologySuite.Utilities,HexConverter,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Utilities\HexConverter.cs,ConvertAny2Any,The conditional expression  "(baseIn < 2) || (baseIn > 36) ||                    (baseOut < 2) || (baseOut > 36)"  is complex.
Complex Conditional,RTools_NTS.Util,StreamTokenizer,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Utilities\RToolsUtil\StreamTokenizer.cs,PickNextState,The conditional expression  "(excludeState != NextTokenState.MaybeNumber) && settings.ParseNumbers                  && (settings.IsCharType(ctype' CharTypeBits.Digit) || (c == '-') || (c == '.'))"  is complex.
Complex Conditional,RTools_NTS.Util,StreamTokenizer,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Utilities\RToolsUtil\StreamTokenizer.cs,NextToken,The conditional expression  "(!settings.IsCharType(ctype' CharTypeBits.Digit)                              && (thisChar != 'e') && (thisChar != 'E')                              && (thisChar != '-') && (thisChar != '.'))                              || ((thisChar == '+') && (seenE == 0))"  is complex.
Complex Conditional,RTools_NTS.Util,StreamTokenizer,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Utilities\RToolsUtil\StreamTokenizer.cs,NextToken,The conditional expression  "(nextTokenSb.IndexOf('.') >= 0)                                      || (nextTokenSb.IndexOf('e') >= 0)                                      || (nextTokenSb.IndexOf('E') >= 0)                                      || (nextTokenSb.Length >= 19)"  is complex.
Virtual Method Call from Constructor,NetTopologySuite.GeometriesGraph,EdgeIntersection,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\GeometriesGraph\EdgeIntersection.cs,EdgeIntersection,The constructor "EdgeIntersection" calls a virtual method "Copy".
Virtual Method Call from Constructor,NetTopologySuite.Geometries,LinearRing,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Geometries\LinearRing.cs,LinearRing,The constructor "LinearRing" calls a virtual method "Create".
Virtual Method Call from Constructor,NetTopologySuite.Geometries,LineString,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Geometries\LineString.cs,LineString,The constructor "LineString" calls a virtual method "Create".
Virtual Method Call from Constructor,NetTopologySuite.Geometries,LineString,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Geometries\LineString.cs,LineString,The constructor "LineString" calls a virtual method "Create".
Virtual Method Call from Constructor,NetTopologySuite.Geometries,Point,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Geometries\Point.cs,Point,The constructor "Point" calls a virtual method "Create".
Virtual Method Call from Constructor,NetTopologySuite.Geometries,Point,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Geometries\Point.cs,Point,The constructor "Point" calls a virtual method "Create".
Virtual Method Call from Constructor,NetTopologySuite.Geometries,Point,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Geometries\Point.cs,Point,The constructor "Point" calls a virtual method "Create".
Virtual Method Call from Constructor,NetTopologySuite.Geometries,Point,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Geometries\Point.cs,Point,The constructor "Point" calls a virtual method "Create".
Virtual Method Call from Constructor,NetTopologySuite.Geometries,TopologyException,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Geometries\TopologyException.cs,TopologyException,The constructor "TopologyException" calls a virtual method "Copy".
Virtual Method Call from Constructor,NetTopologySuite.Geometries.Implementation,CoordinateArraySequence,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Geometries\Implementation\CoordinateArraySequence.cs,CoordinateArraySequence,The constructor "CoordinateArraySequence" calls a virtual method "CreateCoordinate".
Virtual Method Call from Constructor,NetTopologySuite.Geometries.Implementation,CoordinateArraySequence,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Geometries\Implementation\CoordinateArraySequence.cs,CoordinateArraySequence,The constructor "CoordinateArraySequence" calls a virtual method "GetCoordinateCopy".
Virtual Method Call from Constructor,NetTopologySuite.Geometries.Implementation,DotSpatialAffineCoordinateSequence,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Geometries\Implementation\DotSpatialAffineCoordinateSequence.cs,DotSpatialAffineCoordinateSequence,The constructor "DotSpatialAffineCoordinateSequence" calls a virtual method "GetX".
Virtual Method Call from Constructor,NetTopologySuite.Geometries.Implementation,DotSpatialAffineCoordinateSequence,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Geometries\Implementation\DotSpatialAffineCoordinateSequence.cs,DotSpatialAffineCoordinateSequence,The constructor "DotSpatialAffineCoordinateSequence" calls a virtual method "GetY".
Virtual Method Call from Constructor,NetTopologySuite.Geometries.Implementation,DotSpatialAffineCoordinateSequence,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Geometries\Implementation\DotSpatialAffineCoordinateSequence.cs,DotSpatialAffineCoordinateSequence,The constructor "DotSpatialAffineCoordinateSequence" calls a virtual method "GetZ".
Virtual Method Call from Constructor,NetTopologySuite.Geometries.Implementation,DotSpatialAffineCoordinateSequence,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Geometries\Implementation\DotSpatialAffineCoordinateSequence.cs,DotSpatialAffineCoordinateSequence,The constructor "DotSpatialAffineCoordinateSequence" calls a virtual method "GetM".
Virtual Method Call from Constructor,NetTopologySuite.Index.KdTree,KdNode<T>,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Index\KdTree\KdNode.cs,KdNode,The constructor "KdNode" calls a virtual method "Copy".
Virtual Method Call from Constructor,NetTopologySuite.Noding,SegmentNode,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Noding\SegmentNode.cs,SegmentNode,The constructor "SegmentNode" calls a virtual method "Copy".
Virtual Method Call from Constructor,NetTopologySuite.Operation.Valid,TopologyValidationError,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Operation\Valid\TopologyValidationError.cs,TopologyValidationError,The constructor "TopologyValidationError" calls a virtual method "Copy".
Virtual Method Call from Constructor,NetTopologySuite.Triangulate,ConstraintEnforcementException,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Triangulate\ConstraintEnforcementException.cs,ConstraintEnforcementException,The constructor "ConstraintEnforcementException" calls a virtual method "Copy".
Virtual Method Call from Constructor,NetTopologySuite.Triangulate.QuadEdge,Vertex,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Triangulate\QuadEdge\Vertex.cs,Vertex,The constructor "Vertex" calls a virtual method "Copy".
Empty Catch Block,NetTopologySuite.Geometries,LineSegment,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Geometries\LineSegment.cs,LineIntersection,The method has an empty catch block.
Empty Catch Block,NetTopologySuite.IO,WKTWriter,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\IO\WKTWriter.cs,WriteNumber,The method has an empty catch block.
Empty Catch Block,RTools_NTS.Util,StreamTokenizer,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Utilities\RToolsUtil\StreamTokenizer.cs,TokenizeFile,The method has an empty catch block.
Empty Catch Block,RTools_NTS.Util,IntToken,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Utilities\RToolsUtil\Token.cs,Parse,The method has an empty catch block.
Magic Number,NetTopologySuite.Algorithm,AngleUtility,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Algorithm\Angle.cs,ToDegrees,The following statement contains a magic number: return (radians * 180) / (System.Math.PI);
Magic Number,NetTopologySuite.Algorithm,AngleUtility,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Algorithm\Angle.cs,ToRadians,The following statement contains a magic number: return (angleDegrees * System.Math.PI) / 180.0;
Magic Number,NetTopologySuite.Algorithm,AngleUtility,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Algorithm\Angle.cs,Diff,The following statement contains a magic number: delAngle = (2 * System.Math.PI) - delAngle;
Magic Number,NetTopologySuite.Algorithm,Area,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Algorithm\Area.cs,OfRingSigned,The following statement contains a magic number: ring.Length < 3
Magic Number,NetTopologySuite.Algorithm,Area,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Algorithm\Area.cs,OfRingSigned,The following statement contains a magic number: return sum / 2.0;
Magic Number,NetTopologySuite.Algorithm,Area,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Algorithm\Area.cs,OfRingSigned,The following statement contains a magic number: n < 3
Magic Number,NetTopologySuite.Algorithm,Area,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Algorithm\Area.cs,OfRingSigned,The following statement contains a magic number: return sum / 2.0;
Magic Number,NetTopologySuite.Algorithm,Mod2BoundaryNodeRule,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Algorithm\BoundaryNodeRule.cs,IsInBoundary,The following statement contains a magic number: return boundaryCount % 2 == 1;
Magic Number,NetTopologySuite.Algorithm,Centroid,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Algorithm\Centroid.cs,GetCentroid,The following statement contains a magic number: cent.X = _cg3.X / 3 / _areasum2;
Magic Number,NetTopologySuite.Algorithm,Centroid,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Algorithm\Centroid.cs,GetCentroid,The following statement contains a magic number: cent.Y = _cg3.Y / 3 / _areasum2;
Magic Number,NetTopologySuite.Algorithm,Centroid,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Algorithm\Centroid.cs,AddLineSegments,The following statement contains a magic number: double midx = (pts[i].X + pts[i + 1].X) / 2;
Magic Number,NetTopologySuite.Algorithm,Centroid,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Algorithm\Centroid.cs,AddLineSegments,The following statement contains a magic number: double midy = (pts[i].Y + pts[i + 1].Y) / 2;
Magic Number,NetTopologySuite.Algorithm,CGAlgorithmsDD,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Algorithm\CGAlgorithmsDD.cs,OrientationIndexFilter,The following statement contains a magic number: return 2;
Magic Number,NetTopologySuite.Algorithm,ConvexHull,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Algorithm\ConvexHull.cs,GetConvexHull,The following statement contains a magic number: _inputPts.Length == 2
Magic Number,NetTopologySuite.Algorithm,ConvexHull,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Algorithm\ConvexHull.cs,GetConvexHull,The following statement contains a magic number: _inputPts.Length > 50
Magic Number,NetTopologySuite.Algorithm,ConvexHull,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Algorithm\ConvexHull.cs,Reduce,The following statement contains a magic number: reducedPts.Length < 3
Magic Number,NetTopologySuite.Algorithm,ConvexHull,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Algorithm\ConvexHull.cs,PadArray3,The following statement contains a magic number: var pad = new Coordinate[3];
Magic Number,NetTopologySuite.Algorithm,ConvexHull,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Algorithm\ConvexHull.cs,GrahamScan,The following statement contains a magic number: ps.Push(c[2]);
Magic Number,NetTopologySuite.Algorithm,ConvexHull,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Algorithm\ConvexHull.cs,ComputeOctRing,The following statement contains a magic number: coordList.Count < 3
Magic Number,NetTopologySuite.Algorithm,ConvexHull,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Algorithm\ConvexHull.cs,ComputeOctPts,The following statement contains a magic number: var pts = new Coordinate[8];
Magic Number,NetTopologySuite.Algorithm,ConvexHull,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Algorithm\ConvexHull.cs,ComputeOctPts,The following statement contains a magic number: pts[2] = inputPts[i];
Magic Number,NetTopologySuite.Algorithm,ConvexHull,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Algorithm\ConvexHull.cs,ComputeOctPts,The following statement contains a magic number: inputPts[i].Y > pts[2].Y
Magic Number,NetTopologySuite.Algorithm,ConvexHull,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Algorithm\ConvexHull.cs,ComputeOctPts,The following statement contains a magic number: pts[3] = inputPts[i];
Magic Number,NetTopologySuite.Algorithm,ConvexHull,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Algorithm\ConvexHull.cs,ComputeOctPts,The following statement contains a magic number: inputPts[i].X + inputPts[i].Y > pts[3].X + pts[3].Y
Magic Number,NetTopologySuite.Algorithm,ConvexHull,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Algorithm\ConvexHull.cs,ComputeOctPts,The following statement contains a magic number: inputPts[i].X + inputPts[i].Y > pts[3].X + pts[3].Y
Magic Number,NetTopologySuite.Algorithm,ConvexHull,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Algorithm\ConvexHull.cs,ComputeOctPts,The following statement contains a magic number: pts[4] = inputPts[i];
Magic Number,NetTopologySuite.Algorithm,ConvexHull,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Algorithm\ConvexHull.cs,ComputeOctPts,The following statement contains a magic number: inputPts[i].X > pts[4].X
Magic Number,NetTopologySuite.Algorithm,ConvexHull,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Algorithm\ConvexHull.cs,ComputeOctPts,The following statement contains a magic number: pts[5] = inputPts[i];
Magic Number,NetTopologySuite.Algorithm,ConvexHull,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Algorithm\ConvexHull.cs,ComputeOctPts,The following statement contains a magic number: inputPts[i].X - inputPts[i].Y > pts[5].X - pts[5].Y
Magic Number,NetTopologySuite.Algorithm,ConvexHull,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Algorithm\ConvexHull.cs,ComputeOctPts,The following statement contains a magic number: inputPts[i].X - inputPts[i].Y > pts[5].X - pts[5].Y
Magic Number,NetTopologySuite.Algorithm,ConvexHull,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Algorithm\ConvexHull.cs,ComputeOctPts,The following statement contains a magic number: pts[6] = inputPts[i];
Magic Number,NetTopologySuite.Algorithm,ConvexHull,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Algorithm\ConvexHull.cs,ComputeOctPts,The following statement contains a magic number: inputPts[i].Y < pts[6].Y
Magic Number,NetTopologySuite.Algorithm,ConvexHull,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Algorithm\ConvexHull.cs,ComputeOctPts,The following statement contains a magic number: pts[7] = inputPts[i];
Magic Number,NetTopologySuite.Algorithm,ConvexHull,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Algorithm\ConvexHull.cs,ComputeOctPts,The following statement contains a magic number: inputPts[i].X + inputPts[i].Y < pts[7].X + pts[7].Y
Magic Number,NetTopologySuite.Algorithm,ConvexHull,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Algorithm\ConvexHull.cs,ComputeOctPts,The following statement contains a magic number: inputPts[i].X + inputPts[i].Y < pts[7].X + pts[7].Y
Magic Number,NetTopologySuite.Algorithm,ConvexHull,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Algorithm\ConvexHull.cs,LineOrPolygon,The following statement contains a magic number: coordinates.Length == 3
Magic Number,NetTopologySuite.Algorithm,ConvexHull,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Algorithm\ConvexHull.cs,CleanRing,The following statement contains a magic number: i <= original.Length - 2
Magic Number,NetTopologySuite.Algorithm,InteriorPointArea,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Algorithm\InteriorPointArea.cs,Avg,The following statement contains a magic number: return (a + b)/2.0;
Magic Number,NetTopologySuite.Algorithm,InteriorPointPolygon,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Algorithm\InteriorPointArea.cs,FindBestMidpoint,The following statement contains a magic number: Assert.IsTrue(0 == crossings.Count % 2' "Interior Point robustness failure: odd number of scanline crossings");
Magic Number,NetTopologySuite.Algorithm,LineIntersector,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Algorithm\LineIntersector.cs,LineIntersector,The following statement contains a magic number: InputLines = new Coordinate[2][];
Magic Number,NetTopologySuite.Algorithm,LineIntersector,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Algorithm\LineIntersector.cs,LineIntersector,The following statement contains a magic number: InputLines[0] = new Coordinate[2];
Magic Number,NetTopologySuite.Algorithm,LineIntersector,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Algorithm\LineIntersector.cs,LineIntersector,The following statement contains a magic number: InputLines[1] = new Coordinate[2];
Magic Number,NetTopologySuite.Algorithm,LineIntersector,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Algorithm\LineIntersector.cs,ToString,The following statement contains a magic number: sb.Append(InputLines[2]).Append("-");
Magic Number,NetTopologySuite.Algorithm,LineIntersector,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Algorithm\LineIntersector.cs,ToString,The following statement contains a magic number: sb.Append(InputLines[3]).Append(" : ");
Magic Number,NetTopologySuite.Algorithm,LineIntersector,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Algorithm\LineIntersector.cs,ComputeIntLineIndex,The following statement contains a magic number: IntersectionLineIndex = new int[4];
Magic Number,NetTopologySuite.Algorithm,LineIntersector,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Algorithm\LineIntersector.cs,GetIntersectionAlongSegment,The following statement contains a magic number: int index = segmentIndex == 0 ? 0 : 2;
Magic Number,NetTopologySuite.Algorithm,LineIntersector,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Algorithm\LineIntersector.cs,GetIndexAlongSegment,The following statement contains a magic number: int index = segmentIndex == 0 ? 0 : 2;
Magic Number,NetTopologySuite.Algorithm,LineIntersector,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Algorithm\LineIntersector.cs,ComputeIntLineIndex,The following statement contains a magic number: int index = segmentIndex == 0 ? 0 : 2;
Magic Number,NetTopologySuite.Algorithm,MinimumBoundingCircle,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Algorithm\MinimumBoundingCircle.cs,ComputeCentre,The following statement contains a magic number: switch (_extremalPts.Length)              {                  case 0:                      _centre = null;                      break;                  case 1:                      _centre = _extremalPts[0];                      break;                  case 2:                      _centre = new Coordinate(                              (_extremalPts[0].X + _extremalPts[1].X) / 2.0'                              (_extremalPts[0].Y + _extremalPts[1].Y) / 2.0                              );                      break;                  case 3:                      _centre = Triangle.Circumcentre(_extremalPts[0]' _extremalPts[1]' _extremalPts[2]);                      break;              }
Magic Number,NetTopologySuite.Algorithm,MinimumBoundingCircle,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Algorithm\MinimumBoundingCircle.cs,ComputeCentre,The following statement contains a magic number: switch (_extremalPts.Length)              {                  case 0:                      _centre = null;                      break;                  case 1:                      _centre = _extremalPts[0];                      break;                  case 2:                      _centre = new Coordinate(                              (_extremalPts[0].X + _extremalPts[1].X) / 2.0'                              (_extremalPts[0].Y + _extremalPts[1].Y) / 2.0                              );                      break;                  case 3:                      _centre = Triangle.Circumcentre(_extremalPts[0]' _extremalPts[1]' _extremalPts[2]);                      break;              }
Magic Number,NetTopologySuite.Algorithm,MinimumBoundingCircle,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Algorithm\MinimumBoundingCircle.cs,ComputeCentre,The following statement contains a magic number: switch (_extremalPts.Length)              {                  case 0:                      _centre = null;                      break;                  case 1:                      _centre = _extremalPts[0];                      break;                  case 2:                      _centre = new Coordinate(                              (_extremalPts[0].X + _extremalPts[1].X) / 2.0'                              (_extremalPts[0].Y + _extremalPts[1].Y) / 2.0                              );                      break;                  case 3:                      _centre = Triangle.Circumcentre(_extremalPts[0]' _extremalPts[1]' _extremalPts[2]);                      break;              }
Magic Number,NetTopologySuite.Algorithm,MinimumBoundingCircle,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Algorithm\MinimumBoundingCircle.cs,ComputeCentre,The following statement contains a magic number: switch (_extremalPts.Length)              {                  case 0:                      _centre = null;                      break;                  case 1:                      _centre = _extremalPts[0];                      break;                  case 2:                      _centre = new Coordinate(                              (_extremalPts[0].X + _extremalPts[1].X) / 2.0'                              (_extremalPts[0].Y + _extremalPts[1].Y) / 2.0                              );                      break;                  case 3:                      _centre = Triangle.Circumcentre(_extremalPts[0]' _extremalPts[1]' _extremalPts[2]);                      break;              }
Magic Number,NetTopologySuite.Algorithm,MinimumBoundingCircle,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Algorithm\MinimumBoundingCircle.cs,ComputeCentre,The following statement contains a magic number: switch (_extremalPts.Length)              {                  case 0:                      _centre = null;                      break;                  case 1:                      _centre = _extremalPts[0];                      break;                  case 2:                      _centre = new Coordinate(                              (_extremalPts[0].X + _extremalPts[1].X) / 2.0'                              (_extremalPts[0].Y + _extremalPts[1].Y) / 2.0                              );                      break;                  case 3:                      _centre = Triangle.Circumcentre(_extremalPts[0]' _extremalPts[1]' _extremalPts[2]);                      break;              }
Magic Number,NetTopologySuite.Algorithm,MinimumBoundingCircle,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Algorithm\MinimumBoundingCircle.cs,ComputeCirclePoints,The following statement contains a magic number: pts.Length <= 2
Magic Number,NetTopologySuite.Algorithm,Orientation,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Algorithm\Orientation.cs,IsCCW,The following statement contains a magic number: nPts < 3
Magic Number,NetTopologySuite.Algorithm,Orientation,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Algorithm\Orientation.cs,IsCCW,The following statement contains a magic number: nPts < 3
Magic Number,NetTopologySuite.Algorithm,RobustLineIntersector,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Algorithm\RobustLineIntersector.cs,CheckDD,The following statement contains a magic number: distance > 0.0001
Magic Number,NetTopologySuite.Algorithm,RobustLineIntersector,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Algorithm\RobustLineIntersector.cs,NormalizeToEnvCentre,The following statement contains a magic number: double intMidX = (intMinX + intMaxX) / 2.0;
Magic Number,NetTopologySuite.Algorithm,RobustLineIntersector,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Algorithm\RobustLineIntersector.cs,NormalizeToEnvCentre,The following statement contains a magic number: double intMidY = (intMinY + intMaxY) / 2.0;
Magic Number,NetTopologySuite.DataStructures,Interval,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\DataStructures\Interval.cs,GetHashCode,The following statement contains a magic number: return 52876 ^ Min.GetHashCode();
Magic Number,NetTopologySuite.Dissolve,LineDissolver,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Dissolve\LineDissolver.cs,BuildLine,The following statement contains a magic number: e.Sym.Degree() == 2
Magic Number,NetTopologySuite.Dissolve,LineDissolver,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Dissolve\LineDissolver.cs,BuildRing,The following statement contains a magic number: e.Sym.Degree() == 2
Magic Number,NetTopologySuite.EdgeGraph,HalfEdge,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\EdgeGraph\HalfEdge.cs,PrevNode,The following statement contains a magic number: e.Degree() == 2
Magic Number,NetTopologySuite.GeometriesGraph,Depth,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\GeometriesGraph\Depth.cs,Depth,The following statement contains a magic number: i < 2
Magic Number,NetTopologySuite.GeometriesGraph,Depth,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\GeometriesGraph\Depth.cs,IsNull,The following statement contains a magic number: j < 3
Magic Number,NetTopologySuite.GeometriesGraph,Depth,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\GeometriesGraph\Depth.cs,IsNull,The following statement contains a magic number: i < 2
Magic Number,NetTopologySuite.GeometriesGraph,Depth,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\GeometriesGraph\Depth.cs,Add,The following statement contains a magic number: j < 3
Magic Number,NetTopologySuite.GeometriesGraph,Depth,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\GeometriesGraph\Depth.cs,Add,The following statement contains a magic number: i < 2
Magic Number,NetTopologySuite.GeometriesGraph,Depth,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\GeometriesGraph\Depth.cs,Normalize,The following statement contains a magic number: minDepth = depth[i'2];
Magic Number,NetTopologySuite.GeometriesGraph,Depth,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\GeometriesGraph\Depth.cs,Normalize,The following statement contains a magic number: depth[i'2] < minDepth
Magic Number,NetTopologySuite.GeometriesGraph,Depth,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\GeometriesGraph\Depth.cs,Normalize,The following statement contains a magic number: j < 3
Magic Number,NetTopologySuite.GeometriesGraph,Depth,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\GeometriesGraph\Depth.cs,Normalize,The following statement contains a magic number: i < 2
Magic Number,NetTopologySuite.GeometriesGraph,Depth,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\GeometriesGraph\Depth.cs,ToString,The following statement contains a magic number: return string.Format("A: {0}'{1} B: {2}'{3}"' this.depth[0'1]' this.depth[0'2]' this.depth[1'1]' this.depth[1'2]);
Magic Number,NetTopologySuite.GeometriesGraph,Depth,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\GeometriesGraph\Depth.cs,ToString,The following statement contains a magic number: return string.Format("A: {0}'{1} B: {2}'{3}"' this.depth[0'1]' this.depth[0'2]' this.depth[1'1]' this.depth[1'2]);
Magic Number,NetTopologySuite.GeometriesGraph,DirectedEdge,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\GeometriesGraph\DirectedEdge.cs,SetDepth,The following statement contains a magic number: _depth[(int)position] != -999
Magic Number,NetTopologySuite.GeometriesGraph,DirectedEdgeStar,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\GeometriesGraph\DirectedEdgeStar.cs,ComputeLabelling,The following statement contains a magic number: i < 2
Magic Number,NetTopologySuite.GeometriesGraph,EdgeEndStar,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\GeometriesGraph\EdgeEndStar.cs,ComputeLabelling,The following statement contains a magic number: geomi < 2
Magic Number,NetTopologySuite.GeometriesGraph,EdgeEndStar,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\GeometriesGraph\EdgeEndStar.cs,ComputeLabelling,The following statement contains a magic number: geomi < 2
Magic Number,NetTopologySuite.GeometriesGraph,EdgeIntersectionList,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\GeometriesGraph\EdgeIntersectionList.cs,CreateSplitEdge,The following statement contains a magic number: int npts = ei1.SegmentIndex - ei0.SegmentIndex + 2;
Magic Number,NetTopologySuite.GeometriesGraph,EdgeRing,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\GeometriesGraph\EdgeRing.cs,ComputeMaxNodeDegree,The following statement contains a magic number: _maxNodeDegree *= 2;
Magic Number,NetTopologySuite.GeometriesGraph,GeometryGraph,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\GeometriesGraph\GeometryGraph.cs,AddPolygonRing,The following statement contains a magic number: coord.Length < 4
Magic Number,NetTopologySuite.GeometriesGraph,GeometryGraph,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\GeometriesGraph\GeometryGraph.cs,AddLineString,The following statement contains a magic number: coord.Length < 2
Magic Number,NetTopologySuite.GeometriesGraph,GeometryGraph,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\GeometriesGraph\GeometryGraph.cs,AddLineString,The following statement contains a magic number: Assert.IsTrue(coord.Length >= 2' "found LineString with single point");
Magic Number,NetTopologySuite.GeometriesGraph,GeometryGraph,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\GeometriesGraph\GeometryGraph.cs,Locate,The following statement contains a magic number: _parentGeom is IPolygonal && _parentGeom.NumGeometries > 50
Magic Number,NetTopologySuite.GeometriesGraph,GraphComponent,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\GeometriesGraph\GraphComponent.cs,UpdateIM,The following statement contains a magic number: Assert.IsTrue(_label.GeometryCount >= 2' "found partial label");
Magic Number,NetTopologySuite.GeometriesGraph,Label,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\GeometriesGraph\Label.cs,ToLineLabel,The following statement contains a magic number: i < 2
Magic Number,NetTopologySuite.GeometriesGraph,Label,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\GeometriesGraph\Label.cs,Merge,The following statement contains a magic number: i < 2
Magic Number,NetTopologySuite.GeometriesGraph,Node,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\GeometriesGraph\Node.cs,MergeLabel,The following statement contains a magic number: i < 2
Magic Number,NetTopologySuite.GeometriesGraph,PlanarGraph,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\GeometriesGraph\PlanarGraph.cs,FindEdgeInSameDirection,The following statement contains a magic number: MatchInSameDirection(p0' p1' eCoord[eCoord.Length - 1]' eCoord[eCoord.Length - 2])
Magic Number,NetTopologySuite.GeometriesGraph,QuadrantOp,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\GeometriesGraph\QuadrantOp.cs,IsOpposite,The following statement contains a magic number: int diff = (quad1 - quad2 + 4) % 4;
Magic Number,NetTopologySuite.GeometriesGraph,QuadrantOp,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\GeometriesGraph\QuadrantOp.cs,IsOpposite,The following statement contains a magic number: int diff = (quad1 - quad2 + 4) % 4;
Magic Number,NetTopologySuite.GeometriesGraph,QuadrantOp,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\GeometriesGraph\QuadrantOp.cs,IsOpposite,The following statement contains a magic number: diff == 2
Magic Number,NetTopologySuite.GeometriesGraph,QuadrantOp,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\GeometriesGraph\QuadrantOp.cs,CommonHalfPlane,The following statement contains a magic number: int diff = (quad1 - quad2 + 4) % 4;
Magic Number,NetTopologySuite.GeometriesGraph,QuadrantOp,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\GeometriesGraph\QuadrantOp.cs,CommonHalfPlane,The following statement contains a magic number: int diff = (quad1 - quad2 + 4) % 4;
Magic Number,NetTopologySuite.GeometriesGraph,QuadrantOp,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\GeometriesGraph\QuadrantOp.cs,CommonHalfPlane,The following statement contains a magic number: diff == 2
Magic Number,NetTopologySuite.GeometriesGraph,QuadrantOp,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\GeometriesGraph\QuadrantOp.cs,CommonHalfPlane,The following statement contains a magic number: return 3;
Magic Number,NetTopologySuite.GeometriesGraph,QuadrantOp,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\GeometriesGraph\QuadrantOp.cs,CommonHalfPlane,The following statement contains a magic number: min == 0 && max == 3
Magic Number,NetTopologySuite.GeometriesGraph,TopologyLocation,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\GeometriesGraph\TopologyLocation.cs,TopologyLocation,The following statement contains a magic number: Init(3);
Magic Number,NetTopologySuite.GeometriesGraph,TopologyLocation,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\GeometriesGraph\TopologyLocation.cs,Merge,The following statement contains a magic number: var newLoc = new Location[3];
Magic Number,NetTopologySuite.GeometriesGraph.Index,MonotoneChainEdge,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\GeometriesGraph\Index\MonotoneChainEdge.cs,ComputeIntersectsForChain,The following statement contains a magic number: int mid0 = (start0 + end0) / 2;
Magic Number,NetTopologySuite.GeometriesGraph.Index,MonotoneChainEdge,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\GeometriesGraph\Index\MonotoneChainEdge.cs,ComputeIntersectsForChain,The following statement contains a magic number: int mid1 = (start1 + end1) / 2;
Magic Number,NetTopologySuite.GeometriesGraph.Index,SegmentIntersector,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\GeometriesGraph\Index\SegmentIntersector.cs,SetBoundaryNodes,The following statement contains a magic number: _bdyNodes = new IList<Node>[2];
Magic Number,NetTopologySuite.Geometries,Coordinate,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Geometries\Coordinate.cs,GetHashCode,The following statement contains a magic number: var result = 17;
Magic Number,NetTopologySuite.Geometries,Coordinate,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Geometries\Coordinate.cs,GetHashCode,The following statement contains a magic number: result = 37 * result + X.GetHashCode();
Magic Number,NetTopologySuite.Geometries,Coordinate,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Geometries\Coordinate.cs,GetHashCode,The following statement contains a magic number: result = 37 * result + Y.GetHashCode();
Magic Number,NetTopologySuite.Geometries,CoordinateArrays,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Geometries\CoordinateArrays.cs,Dimension,The following statement contains a magic number: return 2;
Magic Number,NetTopologySuite.Geometries,CoordinateArrays,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Geometries\CoordinateArrays.cs,IsRing,The following statement contains a magic number: pts.Length < 4
Magic Number,NetTopologySuite.Geometries,CoordinateArrays,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Geometries\CoordinateArrays.cs,IncreasingDirection,The following statement contains a magic number: i < pts.Length / 2
Magic Number,NetTopologySuite.Geometries,Coordinates,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Geometries\Coordinates.cs,Create,The following statement contains a magic number: dimension == 2
Magic Number,NetTopologySuite.Geometries,Coordinates,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Geometries\Coordinates.cs,Dimension,The following statement contains a magic number: return 2;
Magic Number,NetTopologySuite.Geometries,Coordinates,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Geometries\Coordinates.cs,Dimension,The following statement contains a magic number: return 3;
Magic Number,NetTopologySuite.Geometries,Coordinates,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Geometries\Coordinates.cs,Dimension,The following statement contains a magic number: return 3;
Magic Number,NetTopologySuite.Geometries,Coordinates,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Geometries\Coordinates.cs,Dimension,The following statement contains a magic number: return 4;
Magic Number,NetTopologySuite.Geometries,Coordinates,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Geometries\Coordinates.cs,Dimension,The following statement contains a magic number: return 2;
Magic Number,NetTopologySuite.Geometries,CoordinateSequence,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Geometries\CoordinateSequence.cs,CoordinateSequence,The following statement contains a magic number: Spatial < 2
Magic Number,NetTopologySuite.Geometries,CoordinateSequence,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Geometries\CoordinateSequence.cs,CoordinateSequence,The following statement contains a magic number: int spatialFlags = (1 << Math.Min(Spatial' 16)) - 1;
Magic Number,NetTopologySuite.Geometries,CoordinateSequence,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Geometries\CoordinateSequence.cs,CoordinateSequence,The following statement contains a magic number: int measureFlags = (1 << Math.Min(measures' 16)) - 1;
Magic Number,NetTopologySuite.Geometries,CoordinateSequence,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Geometries\CoordinateSequence.cs,CoordinateSequence,The following statement contains a magic number: Ordinates = (Ordinates)(spatialFlags | (measureFlags << 16));
Magic Number,NetTopologySuite.Geometries,CoordinateSequenceFactory,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Geometries\CoordinateSequenceFactory.cs,Create,The following statement contains a magic number: var result = Create(coordSeq?.Count ?? 0' coordSeq?.Dimension ?? 2' coordSeq?.Measures ?? 0);
Magic Number,NetTopologySuite.Geometries,CoordinateSequences,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Geometries\CoordinateSequences.cs,Reverse,The following statement contains a magic number: int mid = last / 2;
Magic Number,NetTopologySuite.Geometries,CoordinateSequences,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Geometries\CoordinateSequences.cs,IsRing,The following statement contains a magic number: n <= 3
Magic Number,NetTopologySuite.Geometries,CoordinateSequences,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Geometries\CoordinateSequences.cs,EnsureValidRing,The following statement contains a magic number: return CreateClosedRing(fact' seq' 4);
Magic Number,NetTopologySuite.Geometries,CoordinateSequences,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Geometries\CoordinateSequences.cs,EnsureValidRing,The following statement contains a magic number: n <= 3
Magic Number,NetTopologySuite.Geometries,Envelope,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Geometries\Envelope.cs,GetHashCode,The following statement contains a magic number: var result = 17;
Magic Number,NetTopologySuite.Geometries,Envelope,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Geometries\Envelope.cs,GetHashCode,The following statement contains a magic number: result = 37 * result + _minX.GetHashCode();
Magic Number,NetTopologySuite.Geometries,Envelope,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Geometries\Envelope.cs,GetHashCode,The following statement contains a magic number: result = 37 * result + _maxX.GetHashCode();
Magic Number,NetTopologySuite.Geometries,Envelope,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Geometries\Envelope.cs,GetHashCode,The following statement contains a magic number: result = 37 * result + _minY.GetHashCode();
Magic Number,NetTopologySuite.Geometries,Envelope,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Geometries\Envelope.cs,GetHashCode,The following statement contains a magic number: result = 37 * result + _maxY.GetHashCode();
Magic Number,NetTopologySuite.Geometries,Envelope,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Geometries\Envelope.cs,Parse,The following statement contains a magic number: envelope = envelope.Substring(4' envelope.Length - 5);
Magic Number,NetTopologySuite.Geometries,Envelope,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Geometries\Envelope.cs,Parse,The following statement contains a magic number: envelope = envelope.Substring(4' envelope.Length - 5);
Magic Number,NetTopologySuite.Geometries,Envelope,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Geometries\Envelope.cs,Parse,The following statement contains a magic number: var ordinatesValues = new double[4];
Magic Number,NetTopologySuite.Geometries,Envelope,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Geometries\Envelope.cs,Parse,The following statement contains a magic number: parts.Length != 2
Magic Number,NetTopologySuite.Geometries,Envelope,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Geometries\Envelope.cs,Parse,The following statement contains a magic number: ordinates.Length != 2
Magic Number,NetTopologySuite.Geometries,Envelope,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Geometries\Envelope.cs,Parse,The following statement contains a magic number: !double.TryParse(ordinates[0].Trim()' NumberStyles.Number' NumberFormatInfo.InvariantInfo' out ordinatesValues[2 * j])
Magic Number,NetTopologySuite.Geometries,Envelope,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Geometries\Envelope.cs,Parse,The following statement contains a magic number: !double.TryParse(ordinates[1].Trim()' NumberStyles.Number' NumberFormatInfo.InvariantInfo' out ordinatesValues[2 * j + 1])
Magic Number,NetTopologySuite.Geometries,Envelope,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Geometries\Envelope.cs,Parse,The following statement contains a magic number: return new Envelope(ordinatesValues[0]' ordinatesValues[1]'                                  ordinatesValues[2]' ordinatesValues[3]);
Magic Number,NetTopologySuite.Geometries,Envelope,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Geometries\Envelope.cs,Parse,The following statement contains a magic number: return new Envelope(ordinatesValues[0]' ordinatesValues[1]'                                  ordinatesValues[2]' ordinatesValues[3]);
Magic Number,NetTopologySuite.Geometries,ExtraDimensionalCoordinate,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Geometries\ExtraDimensionalCoordinate.cs,ExtraDimensionalCoordinate,The following statement contains a magic number: dimension - measures < 2
Magic Number,NetTopologySuite.Geometries,ExtraDimensionalCoordinate,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Geometries\ExtraDimensionalCoordinate.cs,ExtraDimensionalCoordinate,The following statement contains a magic number: _extraValues = new double[dimension - 2];
Magic Number,NetTopologySuite.Geometries,Geometry,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Geometries\Geometry.cs,ToText,The following statement contains a magic number: var writer = new WKTWriter(3);
Magic Number,NetTopologySuite.Geometries,IntersectionMatrix,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Geometries\IntersectionMatrix.cs,IntersectionMatrix,The following statement contains a magic number: _matrix = new Dimension[3' 3];
Magic Number,NetTopologySuite.Geometries,IntersectionMatrix,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Geometries\IntersectionMatrix.cs,IntersectionMatrix,The following statement contains a magic number: _matrix = new Dimension[3' 3];
Magic Number,NetTopologySuite.Geometries,IntersectionMatrix,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Geometries\IntersectionMatrix.cs,Add,The following statement contains a magic number: i < 3
Magic Number,NetTopologySuite.Geometries,IntersectionMatrix,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Geometries\IntersectionMatrix.cs,Set,The following statement contains a magic number: int row = i / 3;
Magic Number,NetTopologySuite.Geometries,IntersectionMatrix,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Geometries\IntersectionMatrix.cs,Set,The following statement contains a magic number: int col = i % 3;
Magic Number,NetTopologySuite.Geometries,IntersectionMatrix,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Geometries\IntersectionMatrix.cs,SetAtLeast,The following statement contains a magic number: int row = i / 3;
Magic Number,NetTopologySuite.Geometries,IntersectionMatrix,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Geometries\IntersectionMatrix.cs,SetAtLeast,The following statement contains a magic number: int col = i % 3;
Magic Number,NetTopologySuite.Geometries,IntersectionMatrix,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Geometries\IntersectionMatrix.cs,SetAll,The following statement contains a magic number: ai < 3
Magic Number,NetTopologySuite.Geometries,IntersectionMatrix,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Geometries\IntersectionMatrix.cs,Matches,The following statement contains a magic number: requiredDimensionSymbols.Length != 9
Magic Number,NetTopologySuite.Geometries,IntersectionMatrix,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Geometries\IntersectionMatrix.cs,Matches,The following statement contains a magic number: !Matches(_matrix[ai' bi]' requiredDimensionSymbols[3 * ai + bi])
Magic Number,NetTopologySuite.Geometries,IntersectionMatrix,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Geometries\IntersectionMatrix.cs,Matches,The following statement contains a magic number: ai < 3
Magic Number,NetTopologySuite.Geometries,IntersectionMatrix,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Geometries\IntersectionMatrix.cs,Transpose,The following statement contains a magic number: temp = _matrix[2' 0];
Magic Number,NetTopologySuite.Geometries,IntersectionMatrix,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Geometries\IntersectionMatrix.cs,Transpose,The following statement contains a magic number: _matrix[2' 0] = _matrix[0' 2];
Magic Number,NetTopologySuite.Geometries,IntersectionMatrix,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Geometries\IntersectionMatrix.cs,Transpose,The following statement contains a magic number: _matrix[2' 0] = _matrix[0' 2];
Magic Number,NetTopologySuite.Geometries,IntersectionMatrix,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Geometries\IntersectionMatrix.cs,Transpose,The following statement contains a magic number: _matrix[0' 2] = temp;
Magic Number,NetTopologySuite.Geometries,IntersectionMatrix,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Geometries\IntersectionMatrix.cs,Transpose,The following statement contains a magic number: temp = _matrix[2' 1];
Magic Number,NetTopologySuite.Geometries,IntersectionMatrix,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Geometries\IntersectionMatrix.cs,Transpose,The following statement contains a magic number: _matrix[2' 1] = _matrix[1' 2];
Magic Number,NetTopologySuite.Geometries,IntersectionMatrix,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Geometries\IntersectionMatrix.cs,Transpose,The following statement contains a magic number: _matrix[2' 1] = _matrix[1' 2];
Magic Number,NetTopologySuite.Geometries,IntersectionMatrix,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Geometries\IntersectionMatrix.cs,Transpose,The following statement contains a magic number: _matrix[1' 2] = temp;
Magic Number,NetTopologySuite.Geometries,IntersectionMatrix,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Geometries\IntersectionMatrix.cs,ToString,The following statement contains a magic number: buf[3 * ai + bi] = DimensionUtility.ToDimensionSymbol(_matrix[ai' bi]);
Magic Number,NetTopologySuite.Geometries,IntersectionMatrix,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Geometries\IntersectionMatrix.cs,ToString,The following statement contains a magic number: ai < 3
Magic Number,NetTopologySuite.Geometries,LineSegment,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Geometries\LineSegment.cs,ClosestPoints,The following statement contains a magic number: var closestPt = new Coordinate[2];
Magic Number,NetTopologySuite.Geometries,LineSegment,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Geometries\LineSegment.cs,GetHashCode,The following statement contains a magic number: bits0 ^= BitConverter.DoubleToInt64Bits(_p0.Y) * 31;
Magic Number,NetTopologySuite.Geometries,LineSegment,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Geometries\LineSegment.cs,GetHashCode,The following statement contains a magic number: int hash0 = (((int)bits0) ^ ((int)(bits0 >> 32)));
Magic Number,NetTopologySuite.Geometries,LineSegment,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Geometries\LineSegment.cs,GetHashCode,The following statement contains a magic number: bits1 ^= BitConverter.DoubleToInt64Bits(_p1.Y) * 31;
Magic Number,NetTopologySuite.Geometries,LineSegment,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Geometries\LineSegment.cs,GetHashCode,The following statement contains a magic number: int hash1 = (((int)bits1) ^ ((int)(bits1 >> 32)));
Magic Number,NetTopologySuite.Geometries,LineString,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Geometries\LineString.cs,Normalize,The following statement contains a magic number: i < _points.Count / 2
Magic Number,NetTopologySuite.Geometries,OctagonalEnvelope,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Geometries\OctogonalEnvelope.cs,ToGeometry,The following statement contains a magic number: coordList.Count == 2
Magic Number,NetTopologySuite.Geometries,OrdinatesUtility,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Geometries\OrdinatesUtility.cs,OrdinatesToDimension,The following statement contains a magic number: v = (v & 0x33333333) + ((v >> 2) & 0x33333333);
Magic Number,NetTopologySuite.Geometries,OrdinatesUtility,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Geometries\OrdinatesUtility.cs,OrdinatesToDimension,The following statement contains a magic number: return (int)(((v + (v >> 4) & 0xF0F0F0F) * 0x1010101) >> 24);
Magic Number,NetTopologySuite.Geometries,OrdinatesUtility,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Geometries\OrdinatesUtility.cs,OrdinatesToDimension,The following statement contains a magic number: return (int)(((v + (v >> 4) & 0xF0F0F0F) * 0x1010101) >> 24);
Magic Number,NetTopologySuite.Geometries,Polygon,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Geometries\Polygon.cs,Normalize,The following statement contains a magic number: int minCoordinateIndex = CoordinateSequences.MinCoordinateIndex(seq' 0' seq.Count - 2);
Magic Number,NetTopologySuite.Geometries,PrecisionModel,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Geometries\PrecisionModel.cs,MakePrecise,The following statement contains a magic number: return Math.Floor(val * _scale + 0.5d) / _scale;
Magic Number,NetTopologySuite.Geometries,Triangle,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Geometries\Triangle.cs,PerpendicularBisector,The following statement contains a magic number: var l1 = new HCoordinate(a.X + dx / 2.0' a.Y + dy / 2.0' 1.0);
Magic Number,NetTopologySuite.Geometries,Triangle,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Geometries\Triangle.cs,PerpendicularBisector,The following statement contains a magic number: var l1 = new HCoordinate(a.X + dx / 2.0' a.Y + dy / 2.0' 1.0);
Magic Number,NetTopologySuite.Geometries,Triangle,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Geometries\Triangle.cs,PerpendicularBisector,The following statement contains a magic number: var l2 = new HCoordinate(a.X - dy + dx / 2.0' a.Y + dx + dy / 2.0' 1.0);
Magic Number,NetTopologySuite.Geometries,Triangle,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Geometries\Triangle.cs,PerpendicularBisector,The following statement contains a magic number: var l2 = new HCoordinate(a.X - dy + dx / 2.0' a.Y + dx + dy / 2.0' 1.0);
Magic Number,NetTopologySuite.Geometries,Triangle,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Geometries\Triangle.cs,Circumcentre,The following statement contains a magic number: double denom = 2 * Det(ax' ay' bx' by);
Magic Number,NetTopologySuite.Geometries,Triangle,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Geometries\Triangle.cs,Centroid,The following statement contains a magic number: double x = (a.X + b.X + c.X) / 3;
Magic Number,NetTopologySuite.Geometries,Triangle,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Geometries\Triangle.cs,Centroid,The following statement contains a magic number: double y = (a.Y + b.Y + c.Y) / 3;
Magic Number,NetTopologySuite.Geometries,Triangle,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Geometries\Triangle.cs,Area,The following statement contains a magic number: return Math.Abs(                    a.X * (c.Y - b.Y)                  + b.X * (a.Y - c.Y)                  + c.X * (b.Y - a.Y))                  / 2.0;
Magic Number,NetTopologySuite.Geometries,Triangle,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Geometries\Triangle.cs,SignedArea,The following statement contains a magic number: return ((c.X - a.X) * (b.Y - a.Y) - (b.X - a.X) * (c.Y - a.Y)) / 2;
Magic Number,NetTopologySuite.Geometries,Triangle,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Geometries\Triangle.cs,Area3D,The following statement contains a magic number: double area3D = Math.Sqrt(absSq) / 2;
Magic Number,NetTopologySuite.Geometries.Implementation,CoordinateArraySequence,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Geometries\Implementation\CoordinateArraySequence.cs,ToString,The following statement contains a magic number: var strBuf = new StringBuilder(17 * Coordinates.Length);
Magic Number,NetTopologySuite.Geometries.Implementation,CoordinateArraySequenceFactory,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Geometries\Implementation\CoordinateArraySequenceFactory.cs,Create,The following statement contains a magic number: spatial = 3;
Magic Number,NetTopologySuite.Geometries.Implementation,CoordinateArraySequenceFactory,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Geometries\Implementation\CoordinateArraySequenceFactory.cs,Create,The following statement contains a magic number: spatial > 3
Magic Number,NetTopologySuite.Geometries.Implementation,CoordinateArraySequenceFactory,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Geometries\Implementation\CoordinateArraySequenceFactory.cs,Create,The following statement contains a magic number: spatial = 2;
Magic Number,NetTopologySuite.Geometries.Implementation,CoordinateArraySequenceFactory,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Geometries\Implementation\CoordinateArraySequenceFactory.cs,Create,The following statement contains a magic number: spatial < 2
Magic Number,NetTopologySuite.Geometries.Implementation,DotSpatialAffineCoordinateSequence,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Geometries\Implementation\DotSpatialAffineCoordinateSequence.cs,DotSpatialAffineCoordinateSequence,The following statement contains a magic number: _xy = new double[2 * coordinates.Count];
Magic Number,NetTopologySuite.Geometries.Implementation,DotSpatialAffineCoordinateSequence,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Geometries\Implementation\DotSpatialAffineCoordinateSequence.cs,DotSpatialAffineCoordinateSequence,The following statement contains a magic number: _xy = new double[2 * size];
Magic Number,NetTopologySuite.Geometries.Implementation,DotSpatialAffineCoordinateSequence,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Geometries\Implementation\DotSpatialAffineCoordinateSequence.cs,DotSpatialAffineCoordinateSequence,The following statement contains a magic number: _xy = new double[2 * size];
Magic Number,NetTopologySuite.Geometries.Implementation,DotSpatialAffineCoordinateSequence,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Geometries\Implementation\DotSpatialAffineCoordinateSequence.cs,GetCoordinateCopy,The following statement contains a magic number: int j = 2 * i;
Magic Number,NetTopologySuite.Geometries.Implementation,DotSpatialAffineCoordinateSequence,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Geometries\Implementation\DotSpatialAffineCoordinateSequence.cs,GetCoordinate,The following statement contains a magic number: coord.X = _xy[2 * index];
Magic Number,NetTopologySuite.Geometries.Implementation,DotSpatialAffineCoordinateSequence,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Geometries\Implementation\DotSpatialAffineCoordinateSequence.cs,GetCoordinate,The following statement contains a magic number: coord.Y = _xy[2 * index + 1];
Magic Number,NetTopologySuite.Geometries.Implementation,DotSpatialAffineCoordinateSequence,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Geometries\Implementation\DotSpatialAffineCoordinateSequence.cs,GetX,The following statement contains a magic number: return _xy[2 * index];
Magic Number,NetTopologySuite.Geometries.Implementation,DotSpatialAffineCoordinateSequence,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Geometries\Implementation\DotSpatialAffineCoordinateSequence.cs,GetY,The following statement contains a magic number: return _xy[2 * index + 1];
Magic Number,NetTopologySuite.Geometries.Implementation,DotSpatialAffineCoordinateSequence,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Geometries\Implementation\DotSpatialAffineCoordinateSequence.cs,SetX,The following statement contains a magic number: _xy[2 * index] = value;
Magic Number,NetTopologySuite.Geometries.Implementation,DotSpatialAffineCoordinateSequence,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Geometries\Implementation\DotSpatialAffineCoordinateSequence.cs,SetY,The following statement contains a magic number: _xy[2 * index + 1] = value;
Magic Number,NetTopologySuite.Geometries.Implementation,DotSpatialAffineCoordinateSequence,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Geometries\Implementation\DotSpatialAffineCoordinateSequence.cs,GetOrdinate,The following statement contains a magic number: return _xy[index * 2 + ordinateIndex];
Magic Number,NetTopologySuite.Geometries.Implementation,DotSpatialAffineCoordinateSequence,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Geometries\Implementation\DotSpatialAffineCoordinateSequence.cs,SetOrdinate,The following statement contains a magic number: _xy[index * 2 + ordinateIndex] = value;
Magic Number,NetTopologySuite.Geometries.Implementation,DotSpatialAffineCoordinateSequence,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Geometries\Implementation\DotSpatialAffineCoordinateSequence.cs,ClipDimension,The following statement contains a magic number: measures < 0 || dimension < 0 || dimension - measures < 2
Magic Number,NetTopologySuite.Geometries.Implementation,DotSpatialAffineCoordinateSequence,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Geometries\Implementation\DotSpatialAffineCoordinateSequence.cs,ClipDimension,The following statement contains a magic number: dimension = 3 + measures;
Magic Number,NetTopologySuite.Geometries.Implementation,DotSpatialAffineCoordinateSequence,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Geometries\Implementation\DotSpatialAffineCoordinateSequence.cs,ClipDimension,The following statement contains a magic number: dimension - measures > 3
Magic Number,NetTopologySuite.Geometries.Implementation,PackedCoordinateSequence,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Geometries\Implementation\PackedCoordinateSequence.cs,GetZ,The following statement contains a magic number: return GetOrdinate(index' 2);
Magic Number,NetTopologySuite.Geometries.Implementation,PackedDoubleCoordinateSequence,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Geometries\Implementation\PackedCoordinateSequence.cs,PackedDoubleCoordinateSequence,The following statement contains a magic number: _coords[offset + 2] = coords[i][2];
Magic Number,NetTopologySuite.Geometries.Implementation,PackedDoubleCoordinateSequence,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Geometries\Implementation\PackedCoordinateSequence.cs,PackedDoubleCoordinateSequence,The following statement contains a magic number: _coords[offset + 2] = coords[i][2];
Magic Number,NetTopologySuite.Geometries.Implementation,PackedDoubleCoordinateSequence,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Geometries\Implementation\PackedCoordinateSequence.cs,PackedDoubleCoordinateSequence,The following statement contains a magic number: Dimension >= 3
Magic Number,NetTopologySuite.Geometries.Implementation,PackedDoubleCoordinateSequence,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Geometries\Implementation\PackedCoordinateSequence.cs,PackedDoubleCoordinateSequence,The following statement contains a magic number: _coords[offset + 3] = coords[i][3];
Magic Number,NetTopologySuite.Geometries.Implementation,PackedDoubleCoordinateSequence,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Geometries\Implementation\PackedCoordinateSequence.cs,PackedDoubleCoordinateSequence,The following statement contains a magic number: _coords[offset + 3] = coords[i][3];
Magic Number,NetTopologySuite.Geometries.Implementation,PackedDoubleCoordinateSequence,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Geometries\Implementation\PackedCoordinateSequence.cs,PackedDoubleCoordinateSequence,The following statement contains a magic number: Dimension >= 4
Magic Number,NetTopologySuite.Geometries.Implementation,PackedDoubleCoordinateSequence,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Geometries\Implementation\PackedCoordinateSequence.cs,GetCoordinateInternal,The following statement contains a magic number: Dimension == 2 && Measures == 0
Magic Number,NetTopologySuite.Geometries.Implementation,PackedFloatCoordinateSequence,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Geometries\Implementation\PackedCoordinateSequence.cs,PackedFloatCoordinateSequence,The following statement contains a magic number: _coords[offset + 2] = (float)coords[i][2];
Magic Number,NetTopologySuite.Geometries.Implementation,PackedFloatCoordinateSequence,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Geometries\Implementation\PackedCoordinateSequence.cs,PackedFloatCoordinateSequence,The following statement contains a magic number: _coords[offset + 2] = (float)coords[i][2];
Magic Number,NetTopologySuite.Geometries.Implementation,PackedFloatCoordinateSequence,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Geometries\Implementation\PackedCoordinateSequence.cs,PackedFloatCoordinateSequence,The following statement contains a magic number: Dimension >= 3
Magic Number,NetTopologySuite.Geometries.Implementation,PackedFloatCoordinateSequence,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Geometries\Implementation\PackedCoordinateSequence.cs,PackedFloatCoordinateSequence,The following statement contains a magic number: _coords[offset + 3] = (float)coords[i][3];
Magic Number,NetTopologySuite.Geometries.Implementation,PackedFloatCoordinateSequence,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Geometries\Implementation\PackedCoordinateSequence.cs,PackedFloatCoordinateSequence,The following statement contains a magic number: _coords[offset + 3] = (float)coords[i][3];
Magic Number,NetTopologySuite.Geometries.Implementation,PackedFloatCoordinateSequence,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Geometries\Implementation\PackedCoordinateSequence.cs,PackedFloatCoordinateSequence,The following statement contains a magic number: Dimension >= 4
Magic Number,NetTopologySuite.Geometries.Implementation,PackedFloatCoordinateSequence,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Geometries\Implementation\PackedCoordinateSequence.cs,GetCoordinateInternal,The following statement contains a magic number: Dimension == 2 && Measures == 0
Magic Number,NetTopologySuite.Geometries.Utilities,AffineTransformation,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Geometries\Utilities\AffineTransformation.cs,AffineTransformation,The following statement contains a magic number: _m02 = matrix[2];
Magic Number,NetTopologySuite.Geometries.Utilities,AffineTransformation,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Geometries\Utilities\AffineTransformation.cs,AffineTransformation,The following statement contains a magic number: _m10 = matrix[3];
Magic Number,NetTopologySuite.Geometries.Utilities,AffineTransformation,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Geometries\Utilities\AffineTransformation.cs,AffineTransformation,The following statement contains a magic number: _m11 = matrix[4];
Magic Number,NetTopologySuite.Geometries.Utilities,AffineTransformation,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Geometries\Utilities\AffineTransformation.cs,AffineTransformation,The following statement contains a magic number: _m12 = matrix[5];
Magic Number,NetTopologySuite.Geometries.Utilities,AffineTransformation,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Geometries\Utilities\AffineTransformation.cs,SetToReflectionBasic,The following statement contains a magic number: double cs2 = 2 * sin * cos;
Magic Number,NetTopologySuite.Geometries.Utilities,AffineTransformationBuilder,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Geometries\Utilities\AffineTransformationBuilder.cs,Compute,The following statement contains a magic number: _m02 = row0[2];
Magic Number,NetTopologySuite.Geometries.Utilities,AffineTransformationBuilder,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Geometries\Utilities\AffineTransformationBuilder.cs,Compute,The following statement contains a magic number: _m12 = row1[2];
Magic Number,NetTopologySuite.Geometries.Utilities,AffineTransformationBuilder,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Geometries\Utilities\AffineTransformationBuilder.cs,Solve,The following statement contains a magic number: double[][] a = new double[3][];
Magic Number,NetTopologySuite.Geometries.Utilities,AffineTransformationBuilder,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Geometries\Utilities\AffineTransformationBuilder.cs,Solve,The following statement contains a magic number: a[2] = new[] { _src2.X' _src2.Y' 1 };
Magic Number,NetTopologySuite.Geometries.Utilities,AffineTransformationFactory,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Geometries\Utilities\AffineTransformationFactory.cs,CreateFromControlVectors,The following statement contains a magic number: src.Length > 3
Magic Number,NetTopologySuite.Geometries.Utilities,AffineTransformationFactory,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Geometries\Utilities\AffineTransformationFactory.cs,CreateFromControlVectors,The following statement contains a magic number: src.Length == 2
Magic Number,NetTopologySuite.Geometries.Utilities,AffineTransformationFactory,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Geometries\Utilities\AffineTransformationFactory.cs,CreateFromControlVectors,The following statement contains a magic number: return CreateFromControlVectors(src[0]' src[1]' src[2]' dest[0]' dest[1]'                      dest[2]);
Magic Number,NetTopologySuite.Geometries.Utilities,AffineTransformationFactory,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Geometries\Utilities\AffineTransformationFactory.cs,CreateFromControlVectors,The following statement contains a magic number: return CreateFromControlVectors(src[0]' src[1]' src[2]' dest[0]' dest[1]'                      dest[2]);
Magic Number,NetTopologySuite.Geometries.Utilities,GeometryTransformer,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Geometries\Utilities\GeometryTransformer.cs,TransformLinearRing,The following statement contains a magic number: seqSize > 0 && seqSize < 4 && !_preserveType
Magic Number,NetTopologySuite.Geometries.Utilities,SineStarFactory,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Geometries\Utilities\SineStarFactory.cs,SineStarFactory,The following statement contains a magic number: NumArms = 8;
Magic Number,NetTopologySuite.Geometries.Utilities,SineStarFactory,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Geometries\Utilities\SineStarFactory.cs,SineStarFactory,The following statement contains a magic number: ArmLengthRatio = 0.5;
Magic Number,NetTopologySuite.Geometries.Utilities,SineStarFactory,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Geometries\Utilities\SineStarFactory.cs,CreateSineStar,The following statement contains a magic number: double radius = env.Width / 2.0;
Magic Number,NetTopologySuite.Geometries.Utilities,SineStarFactory,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Geometries\Utilities\SineStarFactory.cs,CreateSineStar,The following statement contains a magic number: double armAng = 2 * Math.PI * armAngFrac;
Magic Number,NetTopologySuite.Geometries.Utilities,SineStarFactory,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Geometries\Utilities\SineStarFactory.cs,CreateSineStar,The following statement contains a magic number: double armLenFrac = (Math.Cos(armAng) + 1.0) / 2.0;
Magic Number,NetTopologySuite.Geometries.Utilities,SineStarFactory,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Geometries\Utilities\SineStarFactory.cs,CreateSineStar,The following statement contains a magic number: double ang = i * (2 * Math.PI / NumPoints);
Magic Number,NetTopologySuite.Index.Bintree,Bintree<T>,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Index\Bintree\Bintree.cs,EnsureExtent,The following statement contains a magic number: min = min - minExtent / 2.0;
Magic Number,NetTopologySuite.Index.Bintree,Bintree<T>,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Index\Bintree\Bintree.cs,EnsureExtent,The following statement contains a magic number: max = min + minExtent / 2.0;
Magic Number,NetTopologySuite.Index.Bintree,Node<T>,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Index\Bintree\Node.cs,Node,The following statement contains a magic number: _centre = (interval.Min + interval.Max) / 2;
Magic Number,NetTopologySuite.Index.Bintree,NodeBase<T>,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Index\Bintree\NodeBase.cs,AddAllItems,The following statement contains a magic number: i < 2
Magic Number,NetTopologySuite.Index.Bintree,NodeBase<T>,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Index\Bintree\NodeBase.cs,Remove,The following statement contains a magic number: i < 2
Magic Number,NetTopologySuite.Index.Chain,MonotoneChain,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Index\Chain\MonotoneChain.cs,ComputeSelect,The following statement contains a magic number: int mid = (start0 + end0) / 2;
Magic Number,NetTopologySuite.Index.Chain,MonotoneChain,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Index\Chain\MonotoneChain.cs,ComputeOverlaps,The following statement contains a magic number: int mid0 = (start0 + end0) / 2;
Magic Number,NetTopologySuite.Index.Chain,MonotoneChain,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Index\Chain\MonotoneChain.cs,ComputeOverlaps,The following statement contains a magic number: int mid1 = (start1 + end1) / 2;
Magic Number,NetTopologySuite.Index.IntervalRTree,NodeComparator,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Index\IntervalRTree\IntervalRTreeNode.cs,Compare,The following statement contains a magic number: double mid1 = (n1.Min + n1.Max) / 2;
Magic Number,NetTopologySuite.Index.IntervalRTree,NodeComparator,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Index\IntervalRTree\IntervalRTreeNode.cs,Compare,The following statement contains a magic number: double mid2 = (n2.Min + n2.Max) / 2;
Magic Number,NetTopologySuite.Index.KdTree,KdTreeExtensions,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Index\KdTree\KdTreeExtensions.cs,NearestNeighbor,The following statement contains a magic number: double distSq = Math.Pow(currentNode.X - queryCoordinate.X' 2) +                               Math.Pow(currentNode.Y - queryCoordinate.Y' 2);
Magic Number,NetTopologySuite.Index.KdTree,KdTreeExtensions,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Index\KdTree\KdTreeExtensions.cs,NearestNeighbor,The following statement contains a magic number: double distSq = Math.Pow(currentNode.X - queryCoordinate.X' 2) +                               Math.Pow(currentNode.Y - queryCoordinate.Y' 2);
Magic Number,NetTopologySuite.Index.KdTree,KdTreeExtensions,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Index\KdTree\KdTreeExtensions.cs,NeedsToBeSearched,The following statement contains a magic number: return (left ? target.X <= node.X : target.X >= node.X) || Math.Pow(target.X - node.X' 2) < closestDistSq;
Magic Number,NetTopologySuite.Index.KdTree,KdTreeExtensions,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Index\KdTree\KdTreeExtensions.cs,NeedsToBeSearched,The following statement contains a magic number: return (left ? target.Y <= node.Y : target.Y >= node.Y) || Math.Pow(target.Y - node.Y' 2) < closestDistSq;
Magic Number,NetTopologySuite.Index.Quadtree,DoubleBits,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Index\Quadtree\DoubleBits.cs,PowerOf2,The following statement contains a magic number: exp > 1023 || exp < -1022
Magic Number,NetTopologySuite.Index.Quadtree,DoubleBits,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Index\Quadtree\DoubleBits.cs,PowerOf2,The following statement contains a magic number: exp > 1023 || exp < -1022
Magic Number,NetTopologySuite.Index.Quadtree,DoubleBits,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Index\Quadtree\DoubleBits.cs,PowerOf2,The following statement contains a magic number: long bits = expBias << 52;
Magic Number,NetTopologySuite.Index.Quadtree,DoubleBits,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Index\Quadtree\DoubleBits.cs,TruncateToPowerOfTwo,The following statement contains a magic number: db.ZeroLowerBits(52);
Magic Number,NetTopologySuite.Index.Quadtree,DoubleBits,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Index\Quadtree\DoubleBits.cs,MaximumCommonMantissa,The following statement contains a magic number: db1.ZeroLowerBits(64 - (12 + maxCommon));
Magic Number,NetTopologySuite.Index.Quadtree,DoubleBits,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Index\Quadtree\DoubleBits.cs,MaximumCommonMantissa,The following statement contains a magic number: db1.ZeroLowerBits(64 - (12 + maxCommon));
Magic Number,NetTopologySuite.Index.Quadtree,DoubleBits,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Index\Quadtree\DoubleBits.cs,NumCommonMantissaBits,The following statement contains a magic number: i < 52
Magic Number,NetTopologySuite.Index.Quadtree,DoubleBits,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Index\Quadtree\DoubleBits.cs,NumCommonMantissaBits,The following statement contains a magic number: return 52;
Magic Number,NetTopologySuite.Index.Quadtree,DoubleBits,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Index\Quadtree\DoubleBits.cs,ToString,The following statement contains a magic number: string numStr = HexConverter.ConvertAny2Any(_xBits.ToString()' 10' 2);
Magic Number,NetTopologySuite.Index.Quadtree,DoubleBits,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Index\Quadtree\DoubleBits.cs,ToString,The following statement contains a magic number: string numStr = HexConverter.ConvertAny2Any(_xBits.ToString()' 10' 2);
Magic Number,NetTopologySuite.Index.Quadtree,DoubleBits,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Index\Quadtree\DoubleBits.cs,ToString,The following statement contains a magic number: string bitStr = padStr.Substring(padStr.Length - 64);
Magic Number,NetTopologySuite.Index.Quadtree,DoubleBits,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Index\Quadtree\DoubleBits.cs,ToString,The following statement contains a magic number: string str = bitStr.Substring(0' 1) + "  "                  + bitStr.Substring(1' 12) + "(" + Exponent + ") "                  + bitStr.Substring(12)                  + " [ " + x + " ]";
Magic Number,NetTopologySuite.Index.Quadtree,DoubleBits,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Index\Quadtree\DoubleBits.cs,ToString,The following statement contains a magic number: string str = bitStr.Substring(0' 1) + "  "                  + bitStr.Substring(1' 12) + "(" + Exponent + ") "                  + bitStr.Substring(12)                  + " [ " + x + " ]";
Magic Number,NetTopologySuite.Index.Quadtree,Node<T>,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Index\Quadtree\Node.cs,Node,The following statement contains a magic number: _centreX = (env.MinX + env.MaxX) / 2;
Magic Number,NetTopologySuite.Index.Quadtree,Node<T>,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Index\Quadtree\Node.cs,Node,The following statement contains a magic number: _centreY = (env.MinY + env.MaxY) / 2;
Magic Number,NetTopologySuite.Index.Quadtree,Node<T>,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Index\Quadtree\Node.cs,CreateSubnode,The following statement contains a magic number: switch (index)              {                  case 0:                      minx = _env.MinX;                      maxx = _centreX;                      miny = _env.MinY;                      maxy = _centreY;                      break;                    case 1:                      minx = _centreX;                      maxx = _env.MaxX;                      miny = _env.MinY;                      maxy = _centreY;                      break;                    case 2:                      minx = _env.MinX;                      maxx = _centreX;                      miny = _centreY;                      maxy = _env.MaxY;                      break;                    case 3:                      minx = _centreX;                      maxx = _env.MaxX;                      miny = _centreY;                      maxy = _env.MaxY;                      break;                    default:                      break;              }
Magic Number,NetTopologySuite.Index.Quadtree,Node<T>,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Index\Quadtree\Node.cs,CreateSubnode,The following statement contains a magic number: switch (index)              {                  case 0:                      minx = _env.MinX;                      maxx = _centreX;                      miny = _env.MinY;                      maxy = _centreY;                      break;                    case 1:                      minx = _centreX;                      maxx = _env.MaxX;                      miny = _env.MinY;                      maxy = _centreY;                      break;                    case 2:                      minx = _env.MinX;                      maxx = _centreX;                      miny = _centreY;                      maxy = _env.MaxY;                      break;                    case 3:                      minx = _centreX;                      maxx = _env.MaxX;                      miny = _centreY;                      maxy = _env.MaxY;                      break;                    default:                      break;              }
Magic Number,NetTopologySuite.Index.Quadtree,NodeBase<T>,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Index\Quadtree\NodeBase.cs,GetSubnodeIndex,The following statement contains a magic number: subnodeIndex = 3;
Magic Number,NetTopologySuite.Index.Quadtree,NodeBase<T>,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Index\Quadtree\NodeBase.cs,GetSubnodeIndex,The following statement contains a magic number: subnodeIndex = 2;
Magic Number,NetTopologySuite.Index.Quadtree,NodeBase<T>,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Index\Quadtree\NodeBase.cs,Remove,The following statement contains a magic number: i < 4
Magic Number,NetTopologySuite.Index.Quadtree,NodeBase<T>,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Index\Quadtree\NodeBase.cs,AddAllItems,The following statement contains a magic number: i < 4
Magic Number,NetTopologySuite.Index.Quadtree,NodeBase<T>,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Index\Quadtree\NodeBase.cs,AddAllItemsFromOverlapping,The following statement contains a magic number: i < 4
Magic Number,NetTopologySuite.Index.Quadtree,NodeBase<T>,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Index\Quadtree\NodeBase.cs,Visit,The following statement contains a magic number: i < 4
Magic Number,NetTopologySuite.Index.Quadtree,Quadtree<T>,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Index\Quadtree\Quadtree.cs,EnsureExtent,The following statement contains a magic number: minx = minx - minExtent / 2.0;
Magic Number,NetTopologySuite.Index.Quadtree,Quadtree<T>,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Index\Quadtree\Quadtree.cs,EnsureExtent,The following statement contains a magic number: maxx = minx + minExtent / 2.0;
Magic Number,NetTopologySuite.Index.Quadtree,Quadtree<T>,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Index\Quadtree\Quadtree.cs,EnsureExtent,The following statement contains a magic number: miny = miny - minExtent / 2.0;
Magic Number,NetTopologySuite.Index.Quadtree,Quadtree<T>,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Index\Quadtree\Quadtree.cs,EnsureExtent,The following statement contains a magic number: maxy = miny + minExtent / 2.0;
Magic Number,NetTopologySuite.Index.Strtree,AbstractSTRtree<T;TItem>,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Index\Strtree\AbstractSTRtree.cs,BoundablesAtLevel,The following statement contains a magic number: Assert.IsTrue(level > -2);
Magic Number,NetTopologySuite.Index.Strtree,STRtree<TItem>,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Index\Strtree\STRtree.cs,Avg,The following statement contains a magic number: return (a + b)/2d;
Magic Number,NetTopologySuite.IO,WKBReader,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\IO\WKBReader.cs,HexToBytes,The following statement contains a magic number: int byteLen = hex.Length / 2;
Magic Number,NetTopologySuite.IO,WKBReader,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\IO\WKBReader.cs,HexToBytes,The following statement contains a magic number: int i2 = 2 * i;
Magic Number,NetTopologySuite.IO,WKBReader,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\IO\WKBReader.cs,HexToBytes,The following statement contains a magic number: bytes[i] = (byte)((nib1 << 4) + (byte)nib0);
Magic Number,NetTopologySuite.IO,WKBReader,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\IO\WKBReader.cs,HexToBytes,The following statement contains a magic number: i < hex.Length / 2
Magic Number,NetTopologySuite.IO,WKBReader,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\IO\WKBReader.cs,HexToInt,The following statement contains a magic number: switch (hex)              {                  case '0':                  case '1':                  case '2':                  case '3':                  case '4':                  case '5':                  case '6':                  case '7':                  case '8':                  case '9':                      return hex - '0';                  case 'A':                  case 'B':                  case 'C':                  case 'D':                  case 'E':                  case 'F':                      return hex - 'A' + 10;                  case 'a':                  case 'b':                  case 'c':                  case 'd':                  case 'e':                  case 'f':                      return hex - 'a' + 10;              }
Magic Number,NetTopologySuite.IO,WKBReader,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\IO\WKBReader.cs,HexToInt,The following statement contains a magic number: switch (hex)              {                  case '0':                  case '1':                  case '2':                  case '3':                  case '4':                  case '5':                  case '6':                  case '7':                  case '8':                  case '9':                      return hex - '0';                  case 'A':                  case 'B':                  case 'C':                  case 'D':                  case 'E':                  case 'F':                      return hex - 'A' + 10;                  case 'a':                  case 'b':                  case 'c':                  case 'd':                  case 'e':                  case 'f':                      return hex - 'a' + 10;              }
Magic Number,NetTopologySuite.IO,WKBReader,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\IO\WKBReader.cs,ReadGeometryType,The following statement contains a magic number: uint ordinate = (type & 0xffff) / 1000;
Magic Number,NetTopologySuite.IO,WKBReader,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\IO\WKBReader.cs,ReadGeometryType,The following statement contains a magic number: switch (ordinate)              {                  case 1:                      coordinateSystem = CoordinateSystem.XYZ;                      break;                  case 2:                      coordinateSystem = CoordinateSystem.XYM;                      break;                  case 3:                      coordinateSystem = CoordinateSystem.XYZM;                      break;              }
Magic Number,NetTopologySuite.IO,WKBReader,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\IO\WKBReader.cs,ReadGeometryType,The following statement contains a magic number: switch (ordinate)              {                  case 1:                      coordinateSystem = CoordinateSystem.XYZ;                      break;                  case 2:                      coordinateSystem = CoordinateSystem.XYM;                      break;                  case 3:                      coordinateSystem = CoordinateSystem.XYZM;                      break;              }
Magic Number,NetTopologySuite.IO,WKBReader,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\IO\WKBReader.cs,ReadGeometryType,The following statement contains a magic number: return (WKBGeometryTypes)((type & 0xffff) % 1000);
Magic Number,NetTopologySuite.IO,WKBReader,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\IO\WKBReader.cs,ReadCoordinateSequence,The following statement contains a magic number: switch (cs)                  {                      case CoordinateSystem.XY:                          continue;                      case CoordinateSystem.XYZ:                          double z = reader.ReadDouble();                          if (HandleOrdinate(Ordinate.Z))                              sequence.SetOrdinate(i' 2' z);                          break;                      case CoordinateSystem.XYM:                          double m = reader.ReadDouble();                          if (HandleOrdinate(Ordinate.M))                              sequence.SetOrdinate(i' 2' m);                          break;                      case CoordinateSystem.XYZM:                          z = reader.ReadDouble();                          if (HandleOrdinate(Ordinate.Z))                              sequence.SetOrdinate(i' 2' z);                          m = reader.ReadDouble();                          if (HandleOrdinate(Ordinate.M))                              sequence.SetOrdinate(i' 3' m);                          break;                      default:                          throw new ArgumentException(string.Format("Coordinate system not supported: {0}"' cs));                  }
Magic Number,NetTopologySuite.IO,WKBReader,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\IO\WKBReader.cs,ReadCoordinateSequence,The following statement contains a magic number: switch (cs)                  {                      case CoordinateSystem.XY:                          continue;                      case CoordinateSystem.XYZ:                          double z = reader.ReadDouble();                          if (HandleOrdinate(Ordinate.Z))                              sequence.SetOrdinate(i' 2' z);                          break;                      case CoordinateSystem.XYM:                          double m = reader.ReadDouble();                          if (HandleOrdinate(Ordinate.M))                              sequence.SetOrdinate(i' 2' m);                          break;                      case CoordinateSystem.XYZM:                          z = reader.ReadDouble();                          if (HandleOrdinate(Ordinate.Z))                              sequence.SetOrdinate(i' 2' z);                          m = reader.ReadDouble();                          if (HandleOrdinate(Ordinate.M))                              sequence.SetOrdinate(i' 3' m);                          break;                      default:                          throw new ArgumentException(string.Format("Coordinate system not supported: {0}"' cs));                  }
Magic Number,NetTopologySuite.IO,WKBReader,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\IO\WKBReader.cs,ReadCoordinateSequence,The following statement contains a magic number: switch (cs)                  {                      case CoordinateSystem.XY:                          continue;                      case CoordinateSystem.XYZ:                          double z = reader.ReadDouble();                          if (HandleOrdinate(Ordinate.Z))                              sequence.SetOrdinate(i' 2' z);                          break;                      case CoordinateSystem.XYM:                          double m = reader.ReadDouble();                          if (HandleOrdinate(Ordinate.M))                              sequence.SetOrdinate(i' 2' m);                          break;                      case CoordinateSystem.XYZM:                          z = reader.ReadDouble();                          if (HandleOrdinate(Ordinate.Z))                              sequence.SetOrdinate(i' 2' z);                          m = reader.ReadDouble();                          if (HandleOrdinate(Ordinate.M))                              sequence.SetOrdinate(i' 3' m);                          break;                      default:                          throw new ArgumentException(string.Format("Coordinate system not supported: {0}"' cs));                  }
Magic Number,NetTopologySuite.IO,WKBReader,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\IO\WKBReader.cs,ReadCoordinateSequence,The following statement contains a magic number: switch (cs)                  {                      case CoordinateSystem.XY:                          continue;                      case CoordinateSystem.XYZ:                          double z = reader.ReadDouble();                          if (HandleOrdinate(Ordinate.Z))                              sequence.SetOrdinate(i' 2' z);                          break;                      case CoordinateSystem.XYM:                          double m = reader.ReadDouble();                          if (HandleOrdinate(Ordinate.M))                              sequence.SetOrdinate(i' 2' m);                          break;                      case CoordinateSystem.XYZM:                          z = reader.ReadDouble();                          if (HandleOrdinate(Ordinate.Z))                              sequence.SetOrdinate(i' 2' z);                          m = reader.ReadDouble();                          if (HandleOrdinate(Ordinate.M))                              sequence.SetOrdinate(i' 3' m);                          break;                      default:                          throw new ArgumentException(string.Format("Coordinate system not supported: {0}"' cs));                  }
Magic Number,NetTopologySuite.IO,WKBReader,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\IO\WKBReader.cs,ReadCoordinateSequenceLineString,The following statement contains a magic number: seq.Count == 0 || seq.Count >= 2
Magic Number,NetTopologySuite.IO,WKBReader,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\IO\WKBReader.cs,ReadCoordinateSequenceLineString,The following statement contains a magic number: return CoordinateSequences.Extend(_geometryServices.DefaultCoordinateSequenceFactory' seq' 2);
Magic Number,NetTopologySuite.IO,WKBWriter,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\IO\WKBWriter.cs,ToHex,The following statement contains a magic number: var buf = new StringBuilder(bytes.Length * 2);
Magic Number,NetTopologySuite.IO,WKBWriter,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\IO\WKBWriter.cs,ToHex,The following statement contains a magic number: buf.Append(ToHexDigit((b >> 4) & 0x0F));
Magic Number,NetTopologySuite.IO,WKBWriter,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\IO\WKBWriter.cs,ToHexDigit,The following statement contains a magic number: n < 0 || n > 15
Magic Number,NetTopologySuite.IO,WKBWriter,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\IO\WKBWriter.cs,ToHexDigit,The following statement contains a magic number: n <= 9
Magic Number,NetTopologySuite.IO,WKBWriter,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\IO\WKBWriter.cs,ToHexDigit,The following statement contains a magic number: return (char)('A' + (n - 10));
Magic Number,NetTopologySuite.IO,WKBWriter,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\IO\WKBWriter.cs,WriteHeader,The following statement contains a magic number: intGeometryType += 1000;
Magic Number,NetTopologySuite.IO,WKBWriter,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\IO\WKBWriter.cs,WriteHeader,The following statement contains a magic number: intGeometryType += 2000;
Magic Number,NetTopologySuite.IO,WKBWriter,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\IO\WKBWriter.cs,SetByteStream,The following statement contains a magic number: count += 4;
Magic Number,NetTopologySuite.IO,WKBWriter,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\IO\WKBWriter.cs,SetByteStream,The following statement contains a magic number: count += 4;
Magic Number,NetTopologySuite.IO,WKBWriter,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\IO\WKBWriter.cs,SetByteStream,The following statement contains a magic number: count += 4;
Magic Number,NetTopologySuite.IO,WKBWriter,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\IO\WKBWriter.cs,SetByteStream,The following statement contains a magic number: count += 4;
Magic Number,NetTopologySuite.IO,WKBWriter,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\IO\WKBWriter.cs,SetByteStream,The following statement contains a magic number: count += 4 /*+ 4*/;
Magic Number,NetTopologySuite.IO,WKBWriter,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\IO\WKBWriter.cs,SetByteStream,The following statement contains a magic number: count += 4 * (geometry.NumInteriorRings + 1);
Magic Number,NetTopologySuite.IO,WKBWriter,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\IO\WKBWriter.cs,SetByteStream,The following statement contains a magic number: count += 4;
Magic Number,NetTopologySuite.IO,WKBWriter,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\IO\WKBWriter.cs,CalcCoordinateSize,The following statement contains a magic number: _coordinateSize = 16;
Magic Number,NetTopologySuite.IO,WKBWriter,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\IO\WKBWriter.cs,CalcCoordinateSize,The following statement contains a magic number: _coordinateSize += 8;
Magic Number,NetTopologySuite.IO,WKBWriter,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\IO\WKBWriter.cs,CalcCoordinateSize,The following statement contains a magic number: _coordinateSize += 8;
Magic Number,NetTopologySuite.IO,WKTReader,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\IO\WKTReader.cs,GetCoordinate,The following statement contains a magic number: sequence.SetOrdinate(0' 2' GetNextNumber(tokens));
Magic Number,NetTopologySuite.IO,WKTReader,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\IO\WKTReader.cs,GetCoordinate,The following statement contains a magic number: sequence.SetOrdinate(0' 2 + offsetM' GetNextNumber(tokens));
Magic Number,NetTopologySuite.IO,WKTReader,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\IO\WKTReader.cs,GetCoordinate,The following statement contains a magic number: sequence.SetOrdinate(0' 2' GetNextNumber(tokens));
Magic Number,NetTopologySuite.IO,WKTReader,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\IO\WKTReader.cs,ToDimension,The following statement contains a magic number: int dimension = 2;
Magic Number,NetTopologySuite.IO,WKTReader,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\IO\WKTReader.cs,ToDimension,The following statement contains a magic number: dimension == 2 && _isAllowOldNtsCoordinateSyntax
Magic Number,NetTopologySuite.IO,WKTReader,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\IO\WKTReader.cs,MergeSequences,The following statement contains a magic number: int offsetM = 2 + (mergeOrdinates.HasFlag(Ordinates.Z) ? 1 : 0);
Magic Number,NetTopologySuite.IO,WKTReader,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\IO\WKTReader.cs,MergeSequences,The following statement contains a magic number: sequence.SetOrdinate(i' 2' item.GetOrdinate(0' 2));
Magic Number,NetTopologySuite.IO,WKTReader,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\IO\WKTReader.cs,MergeSequences,The following statement contains a magic number: sequence.SetOrdinate(i' 2' item.GetOrdinate(0' 2));
Magic Number,NetTopologySuite.IO,WKTWriter,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\IO\WKTWriter.cs,WKTWriter,The following statement contains a magic number: this.Tab = 2;
Magic Number,NetTopologySuite.IO,WKTWriter,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\IO\WKTWriter.cs,WKTWriter,The following statement contains a magic number: outputDimension < 2 || outputDimension > 4
Magic Number,NetTopologySuite.IO,WKTWriter,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\IO\WKTWriter.cs,WKTWriter,The following statement contains a magic number: outputDimension < 2 || outputDimension > 4
Magic Number,NetTopologySuite.IO,WKTWriter,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\IO\WKTWriter.cs,WKTWriter,The following statement contains a magic number: switch (outputDimension)              {                  case 2:                      _outputOrdinates = Ordinates.XY;                      break;                    case 3:                      _outputOrdinates = Ordinates.XYZ;                      break;                    case 4:                      _outputOrdinates = Ordinates.XYZM;                      break;              }
Magic Number,NetTopologySuite.IO,WKTWriter,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\IO\WKTWriter.cs,WKTWriter,The following statement contains a magic number: switch (outputDimension)              {                  case 2:                      _outputOrdinates = Ordinates.XY;                      break;                    case 3:                      _outputOrdinates = Ordinates.XYZ;                      break;                    case 4:                      _outputOrdinates = Ordinates.XYZM;                      break;              }
Magic Number,NetTopologySuite.IO,WKTWriter,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\IO\WKTWriter.cs,WKTWriter,The following statement contains a magic number: switch (outputDimension)              {                  case 2:                      _outputOrdinates = Ordinates.XY;                      break;                    case 3:                      _outputOrdinates = Ordinates.XYZ;                      break;                    case 4:                      _outputOrdinates = Ordinates.XYZM;                      break;              }
Magic Number,NetTopologySuite.IO.GML2,GMLReader,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\IO\GML2\GMLReader.cs,ReadPosAsCoordinate,The following statement contains a magic number: double[] ordinates = new double[Math.Min(3' value.Length)];
Magic Number,NetTopologySuite.IO.GML2,GMLReader,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\IO\GML2\GMLReader.cs,ReadPosAsCoordinate,The following statement contains a magic number: return ordinates.Length == 2                  ? new Coordinate(ordinates[0]' ordinates[1])                  : new CoordinateZ(ordinates[0]' ordinates[1]' ordinates[2]);
Magic Number,NetTopologySuite.IO.GML2,GMLReader,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\IO\GML2\GMLReader.cs,ReadPosAsCoordinate,The following statement contains a magic number: return ordinates.Length == 2                  ? new Coordinate(ordinates[0]' ordinates[1])                  : new CoordinateZ(ordinates[0]' ordinates[1]' ordinates[2]);
Magic Number,NetTopologySuite.LinearReferencing,LinearGeometryBuilder,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\LinearReferencing\LinearGeometryBuilder.cs,EndLine,The following statement contains a magic number: IgnoreInvalidLines && _coordList.Count < 2
Magic Number,NetTopologySuite.LinearReferencing,LinearGeometryBuilder,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\LinearReferencing\LinearGeometryBuilder.cs,ValidCoordinateSequence,The following statement contains a magic number: pts.Length >= 2
Magic Number,NetTopologySuite.LinearReferencing,LinearLocation,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\LinearReferencing\LinearLocation.cs,GetSegmentLength,The following statement contains a magic number: segIndex = lineComp.NumPoints - 2;
Magic Number,NetTopologySuite.LinearReferencing,LinearLocation,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\LinearReferencing\LinearLocation.cs,GetSegment,The following statement contains a magic number: var prev = lineComp.GetCoordinateN(lineComp.NumPoints - 2);
Magic Number,NetTopologySuite.LinearReferencing,LocationIndexOfLine,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\LinearReferencing\LocationIndexOfLine.cs,IndicesOf,The following statement contains a magic number: var subLineLoc = new LinearLocation[2];
Magic Number,NetTopologySuite.Mathematics,DD,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Mathematics\DD.cs,Rint,The following statement contains a magic number: var plus5 = this + 0.5d;
Magic Number,NetTopologySuite.Mathematics,DD,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Mathematics\DD.cs,Sqrt,The following statement contains a magic number: double d2 = diffSq._hi*(x*0.5);
Magic Number,NetTopologySuite.Mathematics,DD,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Mathematics\DD.cs,Pow,The following statement contains a magic number: n%2 == 1
Magic Number,NetTopologySuite.Mathematics,DD,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Mathematics\DD.cs,Pow,The following statement contains a magic number: n /= 2;
Magic Number,NetTopologySuite.Mathematics,DD,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Mathematics\DD.cs,ToString,The following statement contains a magic number: mag >= -3 && mag <= 20
Magic Number,NetTopologySuite.Mathematics,DD,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Mathematics\DD.cs,ToString,The following statement contains a magic number: mag >= -3 && mag <= 20
Magic Number,NetTopologySuite.Mathematics,DD,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Mathematics\DD.cs,ExtractSignificantDigits,The following statement contains a magic number: digit < 0 || digit > 9
Magic Number,NetTopologySuite.Mathematics,DD,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Mathematics\DD.cs,ExtractSignificantDigits,The following statement contains a magic number: digit > 9
Magic Number,NetTopologySuite.Mathematics,DD,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Mathematics\DD.cs,Magnitude,The following statement contains a magic number: double xLog10 = Math.Log(xAbs)/Math.Log(10);
Magic Number,NetTopologySuite.Mathematics,DD,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Mathematics\DD.cs,Magnitude,The following statement contains a magic number: double xApprox = Math.Pow(10' xMag);
Magic Number,NetTopologySuite.Mathematics,DD,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Mathematics\DD.cs,Magnitude,The following statement contains a magic number: xApprox*10 <= xAbs
Magic Number,NetTopologySuite.Mathematics,DD,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Mathematics\DD.cs,GetHashCode,The following statement contains a magic number: return (_hi.GetHashCode()*397) ^ _lo.GetHashCode();
Magic Number,NetTopologySuite.Mathematics,MathUtil,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Mathematics\MathUtil.cs,Average,The following statement contains a magic number: return (x1 + x2) / 2.0;
Magic Number,NetTopologySuite.Mathematics,Vector2D,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Mathematics\Vector2D.cs,Average,The following statement contains a magic number: return WeightedSum(v' 0.5);
Magic Number,NetTopologySuite.Mathematics,Vector2D,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Mathematics\Vector2D.cs,RotateByQuarterCircle,The following statement contains a magic number: int nQuad = numQuarters % 4;
Magic Number,NetTopologySuite.Mathematics,Vector2D,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Mathematics\Vector2D.cs,RotateByQuarterCircle,The following statement contains a magic number: nQuad = nQuad + 4;
Magic Number,NetTopologySuite.Mathematics,Vector2D,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Mathematics\Vector2D.cs,RotateByQuarterCircle,The following statement contains a magic number: switch (nQuad)              {                  case 0:                      return Create(_x' _y);                  case 1:                      return Create(-_y' _x);                  case 2:                      return Create(-_x' -_y);                  case 3:                      return Create(_y' -_x);              }
Magic Number,NetTopologySuite.Mathematics,Vector2D,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Mathematics\Vector2D.cs,RotateByQuarterCircle,The following statement contains a magic number: switch (nQuad)              {                  case 0:                      return Create(_x' _y);                  case 1:                      return Create(-_y' _x);                  case 2:                      return Create(-_x' -_y);                  case 3:                      return Create(_y' -_x);              }
Magic Number,NetTopologySuite.Mathematics,Vector2D,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Mathematics\Vector2D.cs,GetHashCode,The following statement contains a magic number: int result = 17;
Magic Number,NetTopologySuite.Mathematics,Vector2D,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Mathematics\Vector2D.cs,GetHashCode,The following statement contains a magic number: result = 37 * result + _x.GetHashCode();
Magic Number,NetTopologySuite.Mathematics,Vector2D,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Mathematics\Vector2D.cs,GetHashCode,The following statement contains a magic number: result = 37 * result + _y.GetHashCode();
Magic Number,NetTopologySuite.Noding,FastNodingValidator,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Noding\FastNodingValidator.cs,GetErrorMessage,The following statement contains a magic number: return "found non-noded intersection between "                  + WKTWriter.ToLineString(intSegs[0]' intSegs[1])                  + " and "                  + WKTWriter.ToLineString(intSegs[2]' intSegs[3]);
Magic Number,NetTopologySuite.Noding,FastNodingValidator,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Noding\FastNodingValidator.cs,GetErrorMessage,The following statement contains a magic number: return "found non-noded intersection between "                  + WKTWriter.ToLineString(intSegs[0]' intSegs[1])                  + " and "                  + WKTWriter.ToLineString(intSegs[2]' intSegs[3]);
Magic Number,NetTopologySuite.Noding,NodingIntersectionFinder,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Noding\NodingIntersectionFinder.cs,ProcessIntersections,The following statement contains a magic number: bool isEnd01 = segIndex0 + 2 == e0.Count;
Magic Number,NetTopologySuite.Noding,NodingIntersectionFinder,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Noding\NodingIntersectionFinder.cs,ProcessIntersections,The following statement contains a magic number: bool isEnd11 = segIndex1 + 2 == e1.Count;
Magic Number,NetTopologySuite.Noding,NodingIntersectionFinder,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Noding\NodingIntersectionFinder.cs,ProcessIntersections,The following statement contains a magic number: _intSegments = new Coordinate[4];
Magic Number,NetTopologySuite.Noding,NodingIntersectionFinder,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Noding\NodingIntersectionFinder.cs,ProcessIntersections,The following statement contains a magic number: _intSegments[2] = p10;
Magic Number,NetTopologySuite.Noding,NodingIntersectionFinder,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Noding\NodingIntersectionFinder.cs,ProcessIntersections,The following statement contains a magic number: _intSegments[3] = p11;
Magic Number,NetTopologySuite.Noding,NodingIntersectionFinder,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Noding\NodingIntersectionFinder.cs,IsEndSegment,The following statement contains a magic number: index >= segStr.Count - 2
Magic Number,NetTopologySuite.Noding,NodingValidator,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Noding\NodingValidator.cs,CheckCollapses,The following statement contains a magic number: CheckCollapse(pts[i]' pts[i + 1]' pts[i + 2]);
Magic Number,NetTopologySuite.Noding,NodingValidator,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Noding\NodingValidator.cs,CheckCollapses,The following statement contains a magic number: i < pts.Length - 2
Magic Number,NetTopologySuite.Noding,ScaledNoder,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Noding\ScaledNoder.cs,Rescale,The following statement contains a magic number: pts.Length == 2 && pts[0].Equals2D(pts[1])
Magic Number,NetTopologySuite.Noding,SegmentIntersectionDetector,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Noding\SegmentIntersectionDetector.cs,ProcessIntersections,The following statement contains a magic number: _intSegments = new Coordinate[4];
Magic Number,NetTopologySuite.Noding,SegmentIntersectionDetector,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Noding\SegmentIntersectionDetector.cs,ProcessIntersections,The following statement contains a magic number: _intSegments[2] = p10;
Magic Number,NetTopologySuite.Noding,SegmentIntersectionDetector,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Noding\SegmentIntersectionDetector.cs,ProcessIntersections,The following statement contains a magic number: _intSegments[3] = p11;
Magic Number,NetTopologySuite.Noding,SegmentNodeList,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Noding\SegmentNodeList.cs,FindCollapsesFromExistingVertices,The following statement contains a magic number: var p2 = _edge.GetCoordinate(i + 2);
Magic Number,NetTopologySuite.Noding,SegmentNodeList,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Noding\SegmentNodeList.cs,FindCollapsesFromExistingVertices,The following statement contains a magic number: i < _edge.Count - 2
Magic Number,NetTopologySuite.Noding,SegmentNodeList,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Noding\SegmentNodeList.cs,CreateSplitEdge,The following statement contains a magic number: int npts = ei1.SegmentIndex - ei0.SegmentIndex + 2;
Magic Number,NetTopologySuite.Noding,SegmentNodeList,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Noding\SegmentNodeList.cs,AddEdgeCoordinates,The following statement contains a magic number: int npts = ei1.SegmentIndex - ei0.SegmentIndex + 2;
Magic Number,NetTopologySuite.Noding.Snapround,GeometryNoder,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Noding\Snapround\GeometryNoder.cs,ToLineStrings,The following statement contains a magic number: ss.Count < 2
Magic Number,NetTopologySuite.Noding.Snapround,HotPixel,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Noding\Snapround\HotPixel.cs,InitCorners,The following statement contains a magic number: const double tolerance = 0.5;
Magic Number,NetTopologySuite.Noding.Snapround,HotPixel,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Noding\Snapround\HotPixel.cs,InitCorners,The following statement contains a magic number: _corner[2] = new Coordinate(_minx' _miny);
Magic Number,NetTopologySuite.Noding.Snapround,HotPixel,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Noding\Snapround\HotPixel.cs,InitCorners,The following statement contains a magic number: _corner[3] = new Coordinate(_maxx' _miny);
Magic Number,NetTopologySuite.Noding.Snapround,HotPixel,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Noding\Snapround\HotPixel.cs,IntersectsToleranceSquare,The following statement contains a magic number: _li.ComputeIntersection(p0' p1' _corner[1]' _corner[2]);
Magic Number,NetTopologySuite.Noding.Snapround,HotPixel,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Noding\Snapround\HotPixel.cs,IntersectsToleranceSquare,The following statement contains a magic number: _li.ComputeIntersection(p0' p1' _corner[2]' _corner[3]);
Magic Number,NetTopologySuite.Noding.Snapround,HotPixel,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Noding\Snapround\HotPixel.cs,IntersectsToleranceSquare,The following statement contains a magic number: _li.ComputeIntersection(p0' p1' _corner[2]' _corner[3]);
Magic Number,NetTopologySuite.Noding.Snapround,HotPixel,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Noding\Snapround\HotPixel.cs,IntersectsToleranceSquare,The following statement contains a magic number: _li.ComputeIntersection(p0' p1' _corner[3]' _corner[0]);
Magic Number,NetTopologySuite.Noding.Snapround,HotPixel,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Noding\Snapround\HotPixel.cs,IntersectsPixelClosure,The following statement contains a magic number: _li.ComputeIntersection(p0' p1' _corner[1]' _corner[2]);
Magic Number,NetTopologySuite.Noding.Snapround,HotPixel,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Noding\Snapround\HotPixel.cs,IntersectsPixelClosure,The following statement contains a magic number: _li.ComputeIntersection(p0' p1' _corner[2]' _corner[3]);
Magic Number,NetTopologySuite.Noding.Snapround,HotPixel,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Noding\Snapround\HotPixel.cs,IntersectsPixelClosure,The following statement contains a magic number: _li.ComputeIntersection(p0' p1' _corner[2]' _corner[3]);
Magic Number,NetTopologySuite.Noding.Snapround,HotPixel,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Noding\Snapround\HotPixel.cs,IntersectsPixelClosure,The following statement contains a magic number: _li.ComputeIntersection(p0' p1' _corner[3]' _corner[0]);
Magic Number,NetTopologySuite.Operation,BoundaryOp,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Operation\BoundaryOp.cs,BoundaryLineString,The following statement contains a magic number: bool closedEndpointOnBoundary = _bnRule.IsInBoundary(2);
Magic Number,NetTopologySuite.Operation,GeometryGraphOperation,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Operation\GeometryGraphOperation.cs,GeometryGraphOperation,The following statement contains a magic number: arg = new GeometryGraph[2];
Magic Number,NetTopologySuite.Operation,IsSimpleOp,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Operation\IsSimpleOp.cs,IsSimpleOp,The following statement contains a magic number: _isClosedEndpointsInInterior = !boundaryNodeRule.IsInBoundary(2);
Magic Number,NetTopologySuite.Operation,IsSimpleOp,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Operation\IsSimpleOp.cs,HasClosedEndpointIntersection,The following statement contains a magic number: eiInfo.IsClosed && eiInfo.Degree != 2
Magic Number,NetTopologySuite.Operation.Buffer,BufferBuilder,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Operation\Buffer\BufferBuilder.cs,ComputeNodedEdges,The following statement contains a magic number: pts.Length == 2 && pts[0].Equals2D(pts[1])
Magic Number,NetTopologySuite.Operation.Buffer,BufferOp,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Operation\Buffer\BufferOp.cs,PrecisionScaleFactor,The following statement contains a magic number: double bufEnvMax = envMax + 2 * expandByDistance;
Magic Number,NetTopologySuite.Operation.Buffer,BufferOp,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Operation\Buffer\BufferOp.cs,PrecisionScaleFactor,The following statement contains a magic number: int bufEnvPrecisionDigits = (int)(Math.Log(bufEnvMax) / Math.Log(10) + 1.0);
Magic Number,NetTopologySuite.Operation.Buffer,BufferOp,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Operation\Buffer\BufferOp.cs,PrecisionScaleFactor,The following statement contains a magic number: double scaleFactor = Math.Pow(10.0' minUnitLog10);
Magic Number,NetTopologySuite.Operation.Buffer,BufferParameters,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Operation\Buffer\BufferParameters.cs,BufferDistanceError,The following statement contains a magic number: double alpha = Math.PI / 2.0 / quadSegs;
Magic Number,NetTopologySuite.Operation.Buffer,BufferParameters,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Operation\Buffer\BufferParameters.cs,BufferDistanceError,The following statement contains a magic number: return 1 - Math.Cos(alpha / 2.0);
Magic Number,NetTopologySuite.Operation.Buffer,OffsetCurveBuilder,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Operation\Buffer\OffsetCurveBuilder.cs,GetRingCurve,The following statement contains a magic number: inputPts.Length <= 2
Magic Number,NetTopologySuite.Operation.Buffer,OffsetCurveSetBuilder,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Operation\Buffer\OffsetCurveSetBuilder.cs,AddCurve,The following statement contains a magic number: coord == null || coord.Length < 2
Magic Number,NetTopologySuite.Operation.Buffer,OffsetCurveSetBuilder,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Operation\Buffer\OffsetCurveSetBuilder.cs,AddPolygon,The following statement contains a magic number: _distance <= 0.0 && shellCoord.Length < 3
Magic Number,NetTopologySuite.Operation.Buffer,OffsetCurveSetBuilder,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Operation\Buffer\OffsetCurveSetBuilder.cs,IsErodedCompletely,The following statement contains a magic number: ringCoord.Length < 4
Magic Number,NetTopologySuite.Operation.Buffer,OffsetCurveSetBuilder,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Operation\Buffer\OffsetCurveSetBuilder.cs,IsErodedCompletely,The following statement contains a magic number: ringCoord.Length == 4
Magic Number,NetTopologySuite.Operation.Buffer,OffsetCurveSetBuilder,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Operation\Buffer\OffsetCurveSetBuilder.cs,IsErodedCompletely,The following statement contains a magic number: return minDiam < 2 * Math.Abs(bufferDistance);
Magic Number,NetTopologySuite.Operation.Buffer,OffsetCurveSetBuilder,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Operation\Buffer\OffsetCurveSetBuilder.cs,IsTriangleErodedCompletely,The following statement contains a magic number: var tri = new Triangle(triangleCoord[0]' triangleCoord[1]' triangleCoord[2]);
Magic Number,NetTopologySuite.Operation.Buffer,OffsetSegmentGenerator,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Operation\Buffer\OffsetSegmentGenerator.cs,OffsetSegmentGenerator,The following statement contains a magic number: _filletAngleQuantum = Math.PI / 2.0 / bufParams.QuadrantSegments;
Magic Number,NetTopologySuite.Operation.Buffer,OffsetSegmentGenerator,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Operation\Buffer\OffsetSegmentGenerator.cs,OffsetSegmentGenerator,The following statement contains a magic number: bufParams.QuadrantSegments >= 8                  && bufParams.JoinStyle == JoinStyle.Round
Magic Number,NetTopologySuite.Operation.Buffer,OffsetSegmentGenerator,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Operation\Buffer\OffsetSegmentGenerator.cs,Init,The following statement contains a magic number: _maxCurveSegmentError = distance * (1 - Math.Cos(_filletAngleQuantum / 2.0));
Magic Number,NetTopologySuite.Operation.Buffer,OffsetSegmentGenerator,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Operation\Buffer\OffsetSegmentGenerator.cs,AddCollinear,The following statement contains a magic number: numInt >= 2
Magic Number,NetTopologySuite.Operation.Buffer,OffsetSegmentGenerator,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Operation\Buffer\OffsetSegmentGenerator.cs,AddLineEndCap,The following statement contains a magic number: switch (_bufParams.EndCapStyle)              {                  case EndCapStyle.Round:                      // add offset seg points with a fillet between them                      _segList.AddPt(offsetL.P1);                      AddDirectedFillet(p1' angle + Math.PI / 2' angle - Math.PI / 2' OrientationIndex.Clockwise' _distance);                      _segList.AddPt(offsetR.P1);                      break;                  case EndCapStyle.Flat:                      // only offset segment points are added                      _segList.AddPt(offsetL.P1);                      _segList.AddPt(offsetR.P1);                      break;                  case EndCapStyle.Square:                      // add a square defined by extensions of the offset segment endpoints                      var squareCapSideOffset = new Coordinate();                      squareCapSideOffset.X = Math.Abs(_distance) * Math.Cos(angle);                      squareCapSideOffset.Y = Math.Abs(_distance) * Math.Sin(angle);                        var squareCapLOffset = new Coordinate(                          offsetL.P1.X + squareCapSideOffset.X'                          offsetL.P1.Y + squareCapSideOffset.Y);                      var squareCapROffset = new Coordinate(                          offsetR.P1.X + squareCapSideOffset.X'                          offsetR.P1.Y + squareCapSideOffset.Y);                      _segList.AddPt(squareCapLOffset);                      _segList.AddPt(squareCapROffset);                      break;              }
Magic Number,NetTopologySuite.Operation.Buffer,OffsetSegmentGenerator,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Operation\Buffer\OffsetSegmentGenerator.cs,AddLineEndCap,The following statement contains a magic number: switch (_bufParams.EndCapStyle)              {                  case EndCapStyle.Round:                      // add offset seg points with a fillet between them                      _segList.AddPt(offsetL.P1);                      AddDirectedFillet(p1' angle + Math.PI / 2' angle - Math.PI / 2' OrientationIndex.Clockwise' _distance);                      _segList.AddPt(offsetR.P1);                      break;                  case EndCapStyle.Flat:                      // only offset segment points are added                      _segList.AddPt(offsetL.P1);                      _segList.AddPt(offsetR.P1);                      break;                  case EndCapStyle.Square:                      // add a square defined by extensions of the offset segment endpoints                      var squareCapSideOffset = new Coordinate();                      squareCapSideOffset.X = Math.Abs(_distance) * Math.Cos(angle);                      squareCapSideOffset.Y = Math.Abs(_distance) * Math.Sin(angle);                        var squareCapLOffset = new Coordinate(                          offsetL.P1.X + squareCapSideOffset.X'                          offsetL.P1.Y + squareCapSideOffset.Y);                      var squareCapROffset = new Coordinate(                          offsetR.P1.X + squareCapSideOffset.X'                          offsetR.P1.Y + squareCapSideOffset.Y);                      _segList.AddPt(squareCapLOffset);                      _segList.AddPt(squareCapROffset);                      break;              }
Magic Number,NetTopologySuite.Operation.Buffer,OffsetSegmentGenerator,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Operation\Buffer\OffsetSegmentGenerator.cs,AddLimitedMitreJoin,The following statement contains a magic number: double angDiffHalf = angDiff / 2;
Magic Number,NetTopologySuite.Operation.Buffer,OffsetSegmentGenerator,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Operation\Buffer\OffsetSegmentGenerator.cs,AddCornerFillet,The following statement contains a magic number: startAngle += 2.0 * Math.PI;
Magic Number,NetTopologySuite.Operation.Buffer,OffsetSegmentGenerator,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Operation\Buffer\OffsetSegmentGenerator.cs,AddDirectedFillet,The following statement contains a magic number: int nSegs = (int)(totalAngle / _filletAngleQuantum + 0.5);
Magic Number,NetTopologySuite.Operation.Buffer,OffsetSegmentGenerator,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Operation\Buffer\OffsetSegmentGenerator.cs,CreateCircle,The following statement contains a magic number: AddDirectedFillet(p' 0.0' 2.0 * Math.PI' OrientationIndex.Clockwise' _distance);
Magic Number,NetTopologySuite.Operation.Buffer,OldOffsetCurveBuilder,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Operation\Buffer\OldOffsetCurveBuilder.cs,OldOffsetCurveBuilder,The following statement contains a magic number: _filletAngleQuantum = Math.PI / 2.0 / bufParams.QuadrantSegments;
Magic Number,NetTopologySuite.Operation.Buffer,OldOffsetCurveBuilder,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Operation\Buffer\OldOffsetCurveBuilder.cs,OldOffsetCurveBuilder,The following statement contains a magic number: bufParams.QuadrantSegments >= 8                  && bufParams.JoinStyle == JoinStyle.Round
Magic Number,NetTopologySuite.Operation.Buffer,OldOffsetCurveBuilder,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Operation\Buffer\OldOffsetCurveBuilder.cs,GetRingCurve,The following statement contains a magic number: inputPts.Length <= 2
Magic Number,NetTopologySuite.Operation.Buffer,OldOffsetCurveBuilder,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Operation\Buffer\OldOffsetCurveBuilder.cs,Init,The following statement contains a magic number: _maxCurveSegmentError = distance * (1 - Math.Cos(_filletAngleQuantum / 2.0));
Magic Number,NetTopologySuite.Operation.Buffer,OldOffsetCurveBuilder,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Operation\Buffer\OldOffsetCurveBuilder.cs,AddCollinear,The following statement contains a magic number: numInt >= 2
Magic Number,NetTopologySuite.Operation.Buffer,OldOffsetCurveBuilder,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Operation\Buffer\OldOffsetCurveBuilder.cs,AddLineEndCap,The following statement contains a magic number: switch (_bufParams.EndCapStyle)              {                  case EndCapStyle.Round:                      // add offset seg points with a fillet between them                      _vertexList.AddPt(offsetL.P1);                      AddFillet(p1' angle + Math.PI / 2' angle - Math.PI / 2' OrientationIndex.Clockwise' _distance);                      _vertexList.AddPt(offsetR.P1);                      break;                  case EndCapStyle.Flat:                      // only offset segment points are added                      _vertexList.AddPt(offsetL.P1);                      _vertexList.AddPt(offsetR.P1);                      break;                  case EndCapStyle.Square:                      // add a square defined by extensions of the offset segment endpoints                      var squareCapSideOffset = new Coordinate();                      squareCapSideOffset.X = Math.Abs(_distance) * Math.Cos(angle);                      squareCapSideOffset.Y = Math.Abs(_distance) * Math.Sin(angle);                        var squareCapLOffset = new Coordinate(                          offsetL.P1.X + squareCapSideOffset.X'                          offsetL.P1.Y + squareCapSideOffset.Y);                      var squareCapROffset = new Coordinate(                          offsetR.P1.X + squareCapSideOffset.X'                          offsetR.P1.Y + squareCapSideOffset.Y);                      _vertexList.AddPt(squareCapLOffset);                      _vertexList.AddPt(squareCapROffset);                      break;              }
Magic Number,NetTopologySuite.Operation.Buffer,OldOffsetCurveBuilder,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Operation\Buffer\OldOffsetCurveBuilder.cs,AddLineEndCap,The following statement contains a magic number: switch (_bufParams.EndCapStyle)              {                  case EndCapStyle.Round:                      // add offset seg points with a fillet between them                      _vertexList.AddPt(offsetL.P1);                      AddFillet(p1' angle + Math.PI / 2' angle - Math.PI / 2' OrientationIndex.Clockwise' _distance);                      _vertexList.AddPt(offsetR.P1);                      break;                  case EndCapStyle.Flat:                      // only offset segment points are added                      _vertexList.AddPt(offsetL.P1);                      _vertexList.AddPt(offsetR.P1);                      break;                  case EndCapStyle.Square:                      // add a square defined by extensions of the offset segment endpoints                      var squareCapSideOffset = new Coordinate();                      squareCapSideOffset.X = Math.Abs(_distance) * Math.Cos(angle);                      squareCapSideOffset.Y = Math.Abs(_distance) * Math.Sin(angle);                        var squareCapLOffset = new Coordinate(                          offsetL.P1.X + squareCapSideOffset.X'                          offsetL.P1.Y + squareCapSideOffset.Y);                      var squareCapROffset = new Coordinate(                          offsetR.P1.X + squareCapSideOffset.X'                          offsetR.P1.Y + squareCapSideOffset.Y);                      _vertexList.AddPt(squareCapLOffset);                      _vertexList.AddPt(squareCapROffset);                      break;              }
Magic Number,NetTopologySuite.Operation.Buffer,OldOffsetCurveBuilder,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Operation\Buffer\OldOffsetCurveBuilder.cs,AddLimitedMitreJoin,The following statement contains a magic number: double angDiffHalf = angDiff / 2;
Magic Number,NetTopologySuite.Operation.Buffer,OldOffsetCurveBuilder,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Operation\Buffer\OldOffsetCurveBuilder.cs,AddFillet,The following statement contains a magic number: startAngle += 2.0 * Math.PI;
Magic Number,NetTopologySuite.Operation.Buffer,OldOffsetCurveBuilder,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Operation\Buffer\OldOffsetCurveBuilder.cs,AddFillet,The following statement contains a magic number: int nSegs = (int)(totalAngle / _filletAngleQuantum + 0.5);
Magic Number,NetTopologySuite.Operation.Buffer,OldOffsetCurveBuilder,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Operation\Buffer\OldOffsetCurveBuilder.cs,AddCircle,The following statement contains a magic number: AddFillet(p' 0.0' 2.0 * Math.PI' OrientationIndex.Clockwise' distance);
Magic Number,NetTopologySuite.Operation.Buffer.Validate,MaxMidpointDistanceFilter,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Operation\Buffer\Validate\BufferCurveMaximumDistanceFinder.cs,Filter,The following statement contains a magic number: var midPt = new Coordinate(                          (p0.X + p1.X) / 2'                          (p0.Y + p1.Y) / 2);
Magic Number,NetTopologySuite.Operation.Buffer.Validate,MaxMidpointDistanceFilter,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Operation\Buffer\Validate\BufferCurveMaximumDistanceFinder.cs,Filter,The following statement contains a magic number: var midPt = new Coordinate(                          (p0.X + p1.X) / 2'                          (p0.Y + p1.Y) / 2);
Magic Number,NetTopologySuite.Operation.Buffer.Validate,BufferDistanceValidator,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Operation\Buffer\Validate\BufferDistanceValidator.cs,CheckMaximumDistance,The following statement contains a magic number: haus.DensifyFraction = 0.25;
Magic Number,NetTopologySuite.Operation.Buffer.Validate,BufferResultValidator,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Operation\Buffer\Validate\BufferResultValidator.cs,CheckEnvelope,The following statement contains a magic number: padding = 0.001;
Magic Number,NetTopologySuite.Operation.Distance3D,AxisPlaneCoordinateSequence,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Operation\Distance3D\AxisPlaneCoordinateSequence.cs,GetCoordinate,The following statement contains a magic number: coord.Z = GetOrdinate(index' 2);
Magic Number,NetTopologySuite.Operation.Distance3D,AxisPlaneCoordinateSequence,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Operation\Distance3D\AxisPlaneCoordinateSequence.cs,GetZ,The following statement contains a magic number: return GetOrdinate(index' 2);
Magic Number,NetTopologySuite.Operation.Distance3D,Distance3DOp,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Operation\Distance3D\Distance3DOp.cs,Distance3DOp,The following statement contains a magic number: _geom = new Geometry[2];
Magic Number,NetTopologySuite.Operation.Distance3D,Distance3DOp,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Operation\Distance3D\Distance3DOp.cs,ComputeMinDistance,The following statement contains a magic number: _minDistanceLocation = new GeometryLocation[2];
Magic Number,NetTopologySuite.Operation.Distance3D,PlanarPolygon3D,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Operation\Distance3D\PlanarPolygon3D.cs,AveragePoint,The following statement contains a magic number: a.Z += seq.GetOrdinate(i' 2);
Magic Number,NetTopologySuite.Operation.Distance,DistanceOp,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Operation\Distance\DistanceOp.cs,ComputeMinDistance,The following statement contains a magic number: _minDistanceLocation = new GeometryLocation[2];
Magic Number,NetTopologySuite.Operation.Distance,DistanceOp,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Operation\Distance\DistanceOp.cs,ComputeContainmentDistance,The following statement contains a magic number: var locPtPoly = new GeometryLocation[2];
Magic Number,NetTopologySuite.Operation.Distance,DistanceOp,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Operation\Distance\DistanceOp.cs,ComputeFacetDistance,The following statement contains a magic number: var locGeom = new GeometryLocation[2];
Magic Number,NetTopologySuite.Operation.Distance,FacetSequence,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Operation\Distance\FacetSequence.cs,NearestLocations,The following statement contains a magic number: var locs = new GeometryLocation[2];
Magic Number,NetTopologySuite.Operation.Linemerge,LineMergeGraph,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Operation\Linemerge\LineMergeGraph.cs,AddEdge,The following statement contains a magic number: coordinates.Length < 2
Magic Number,NetTopologySuite.Operation.Linemerge,LineMergeGraph,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Operation\Linemerge\LineMergeGraph.cs,AddEdge,The following statement contains a magic number: var directedEdge1 = new LineMergeDirectedEdge(endNode' startNode'                                                            coordinates[coordinates.Length - 2]' false);
Magic Number,NetTopologySuite.Operation.Linemerge,LineMerger,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Operation\Linemerge\LineMerger.cs,BuildEdgeStringsForUnprocessedNodes,The following statement contains a magic number: Assert.IsTrue(node.Degree == 2);
Magic Number,NetTopologySuite.Operation.Linemerge,LineMerger,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Operation\Linemerge\LineMerger.cs,BuildEdgeStringsForNonDegree2Nodes,The following statement contains a magic number: node.Degree != 2
Magic Number,NetTopologySuite.Operation.Linemerge,LineSequencer,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Operation\Linemerge\LineSequencer.cs,HasSequence,The following statement contains a magic number: node.Degree % 2 == 1
Magic Number,NetTopologySuite.Operation.Linemerge,LineSequencer,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Operation\Linemerge\LineSequencer.cs,HasSequence,The following statement contains a magic number: return oddDegreeCount <= 2;
Magic Number,NetTopologySuite.Operation.Overlay,OverlayOp,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Operation\Overlay\OverlayOp.cs,ComputeLabelsFromDepths,The following statement contains a magic number: i < 2
Magic Number,NetTopologySuite.Operation.Overlay,PolygonBuilder,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Operation\Overlay\PolygonBuilder.cs,BuildMinimalEdgeRings,The following statement contains a magic number: er.MaxNodeDegree > 2
Magic Number,NetTopologySuite.Operation.Overlay.Snap,GeometrySnapper,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Operation\Overlay\Snap\GeometrySnapper.cs,ComputeOverlaySnapTolerance,The following statement contains a magic number: double fixedSnapTol = (1 / pm.Scale) * 2 / 1.415;
Magic Number,NetTopologySuite.Operation.Overlay.Snap,GeometrySnapper,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Operation\Overlay\Snap\GeometrySnapper.cs,ComputeOverlaySnapTolerance,The following statement contains a magic number: double fixedSnapTol = (1 / pm.Scale) * 2 / 1.415;
Magic Number,NetTopologySuite.Operation.Overlay.Snap,GeometrySnapper,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Operation\Overlay\Snap\GeometrySnapper.cs,Snap,The following statement contains a magic number: var snapGeom = new Geometry[2];
Magic Number,NetTopologySuite.Operation.Overlay.Snap,GeometrySnapper,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Operation\Overlay\Snap\GeometrySnapper.cs,ComputeSnapTolerance,The following statement contains a magic number: double snapTol = minSegLen / 10;
Magic Number,NetTopologySuite.Operation.Overlay.Snap,SnapOverlayOp,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Operation\Overlay\Snap\SnapOverlayOp.cs,RemoveCommonBits,The following statement contains a magic number: var remGeom = new Geometry[2];
Magic Number,NetTopologySuite.Operation.Overlay.Validate,OffsetPointGenerator,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Operation\Overlay\Validate\OffsetPointGenerator.cs,ComputeOffsetPoints,The following statement contains a magic number: double midX = (p1.X + p0.X) / 2;
Magic Number,NetTopologySuite.Operation.Overlay.Validate,OffsetPointGenerator,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Operation\Overlay\Validate\OffsetPointGenerator.cs,ComputeOffsetPoints,The following statement contains a magic number: double midY = (p1.Y + p0.Y) / 2;
Magic Number,NetTopologySuite.Operation.Overlay.Validate,OverlayResultValidator,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Operation\Overlay\Validate\OverlayResultValidator.cs,OverlayResultValidator,The following statement contains a magic number: _locFinder = new[]                               {                                   new FuzzyPointLocator(_geom[0]' _boundaryDistanceTolerance)'                                   new FuzzyPointLocator(_geom[1]' _boundaryDistanceTolerance)'                                   new FuzzyPointLocator(_geom[2]' _boundaryDistanceTolerance)                               };
Magic Number,NetTopologySuite.Operation.Overlay.Validate,OverlayResultValidator,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Operation\Overlay\Validate\OverlayResultValidator.cs,AddTestPts,The following statement contains a magic number: _testCoords.AddRange(ptGen.GetPoints(5 * _boundaryDistanceTolerance));
Magic Number,NetTopologySuite.Operation.Overlay.Validate,OverlayResultValidator,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Operation\Overlay\Validate\OverlayResultValidator.cs,CheckValid,The following statement contains a magic number: _location[2] = _locFinder[2].GetLocation(pt);
Magic Number,NetTopologySuite.Operation.Overlay.Validate,OverlayResultValidator,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Operation\Overlay\Validate\OverlayResultValidator.cs,CheckValid,The following statement contains a magic number: _location[2] = _locFinder[2].GetLocation(pt);
Magic Number,NetTopologySuite.Operation.Overlay.Validate,OverlayResultValidator,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Operation\Overlay\Validate\OverlayResultValidator.cs,HasLocation,The following statement contains a magic number: i < 3
Magic Number,NetTopologySuite.Operation.Overlay.Validate,OverlayResultValidator,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Operation\Overlay\Validate\OverlayResultValidator.cs,IsValidResult,The following statement contains a magic number: bool resultInInterior = (location[2] == Location.Interior);
Magic Number,NetTopologySuite.Operation.Overlay.Validate,OverlayResultValidator,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Operation\Overlay\Validate\OverlayResultValidator.cs,ReportResult,The following statement contains a magic number: Debug.WriteLine(string.Format("{0}:" + " A:{1} B:{2} expected:{3} actual:{4}"'                  overlayOp'                  LocationUtility.ToLocationSymbol(location[0])'                  LocationUtility.ToLocationSymbol(location[1])' expectedInterior ? 'i' : 'e''                  LocationUtility.ToLocationSymbol(location[2])));
Magic Number,NetTopologySuite.Operation.Polygonize,PolygonizeGraph,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Operation\Polygonize\PolygonizeGraph.cs,AddEdge,The following statement contains a magic number: linePts.Length < 2
Magic Number,NetTopologySuite.Operation.Polygonize,PolygonizeGraph,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Operation\Polygonize\PolygonizeGraph.cs,AddEdge,The following statement contains a magic number: var de1 = new PolygonizeDirectedEdge(nEnd' nStart' linePts[linePts.Length - 2]' false);
Magic Number,NetTopologySuite.Operation.Predicate,GeometryContainsPointVisitor,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Operation\Predicate\RectangleIntersects.cs,Visit,The following statement contains a magic number: i < 4
Magic Number,NetTopologySuite.Operation.Relate,EdgeEndBundle,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Operation\Relate\EdgeEndBundle.cs,ComputeLabel,The following statement contains a magic number: i < 2
Magic Number,NetTopologySuite.Operation.Union,CascadedPolygonUnion,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Operation\Union\CascadedPolygonUnion.cs,BinaryUnion,The following statement contains a magic number: end - start == 2
Magic Number,NetTopologySuite.Operation.Union,CascadedPolygonUnion,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Operation\Union\CascadedPolygonUnion.cs,BinaryUnion,The following statement contains a magic number: int mid = (end + start) / 2;
Magic Number,NetTopologySuite.Precision,CommonBits,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Precision\CommonBits.cs,SignExpBits,The following statement contains a magic number: return num >> 52;
Magic Number,NetTopologySuite.Precision,CommonBits,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Precision\CommonBits.cs,NumCommonMostSigMantissaBits,The following statement contains a magic number: return 52;
Magic Number,NetTopologySuite.Precision,CommonBits,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Precision\CommonBits.cs,Add,The following statement contains a magic number: _commonBits = ZeroLowerBits(_commonBits' 64 - (12 + _commonMantissaBitsCount));
Magic Number,NetTopologySuite.Precision,CommonBits,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Precision\CommonBits.cs,Add,The following statement contains a magic number: _commonBits = ZeroLowerBits(_commonBits' 64 - (12 + _commonMantissaBitsCount));
Magic Number,NetTopologySuite.Precision,CommonBits,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Precision\CommonBits.cs,ToString,The following statement contains a magic number: string numStr = HexConverter.ConvertAny2Any(bits.ToString()' 10' 2);
Magic Number,NetTopologySuite.Precision,CommonBits,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Precision\CommonBits.cs,ToString,The following statement contains a magic number: string numStr = HexConverter.ConvertAny2Any(bits.ToString()' 10' 2);
Magic Number,NetTopologySuite.Precision,CommonBits,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Precision\CommonBits.cs,ToString,The following statement contains a magic number: string bitStr = padStr.Substring(padStr.Length - 64);
Magic Number,NetTopologySuite.Precision,CommonBits,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Precision\CommonBits.cs,ToString,The following statement contains a magic number: string str = bitStr.Substring(0' 1) + "  " + bitStr.Substring(1' 12) + "(exp) "                           + bitStr.Substring(12) + " [ " + x + " ]";
Magic Number,NetTopologySuite.Precision,CommonBits,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Precision\CommonBits.cs,ToString,The following statement contains a magic number: string str = bitStr.Substring(0' 1) + "  " + bitStr.Substring(1' 12) + "(exp) "                           + bitStr.Substring(12) + " [ " + x + " ]";
Magic Number,NetTopologySuite.Precision,CommonBitsOp,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Precision\CommonBitsOp.cs,RemoveCommonBits,The following statement contains a magic number: var geom = new Geometry[2];
Magic Number,NetTopologySuite.Precision,MinimumClearance,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Precision\MinimumClearance.cs,Compute,The following statement contains a magic number: _minClearancePts = new Coordinate[2];
Magic Number,NetTopologySuite.Precision,PrecisionReducerCoordinateOperation,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Precision\PrecisionReducerCoordinateOperation.cs,Edit,The following statement contains a magic number: minLength = 2;
Magic Number,NetTopologySuite.Precision,SimpleMinimumClearance,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Precision\SimpleMinimumClearance.cs,Compute,The following statement contains a magic number: _minClearancePts = new Coordinate[2];
Magic Number,NetTopologySuite.Shape.Fractal,HilbertCode,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Shape\Fractal\HilbertCode.cs,Size,The following statement contains a magic number: return (int)Math.Pow(2' 2 * level);
Magic Number,NetTopologySuite.Shape.Fractal,HilbertCode,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Shape\Fractal\HilbertCode.cs,Size,The following statement contains a magic number: return (int)Math.Pow(2' 2 * level);
Magic Number,NetTopologySuite.Shape.Fractal,HilbertCode,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Shape\Fractal\HilbertCode.cs,MaxOrdinate,The following statement contains a magic number: return (int)Math.Pow(2' level) - 1;
Magic Number,NetTopologySuite.Shape.Fractal,HilbertCode,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Shape\Fractal\HilbertCode.cs,Level,The following statement contains a magic number: int pow2 = (int)(Math.Log(numPoints) / Math.Log(2));
Magic Number,NetTopologySuite.Shape.Fractal,HilbertCode,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Shape\Fractal\HilbertCode.cs,Level,The following statement contains a magic number: int level = pow2 / 2;
Magic Number,NetTopologySuite.Shape.Fractal,HilbertCode,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Shape\Fractal\HilbertCode.cs,Encode,The following statement contains a magic number: x = x << (16 - lvl);
Magic Number,NetTopologySuite.Shape.Fractal,HilbertCode,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Shape\Fractal\HilbertCode.cs,Encode,The following statement contains a magic number: y = y << (16 - lvl);
Magic Number,NetTopologySuite.Shape.Fractal,HilbertCode,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Shape\Fractal\HilbertCode.cs,Encode,The following statement contains a magic number: A = ((a & (a >> 2)) ^ (b & (b >> 2)));
Magic Number,NetTopologySuite.Shape.Fractal,HilbertCode,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Shape\Fractal\HilbertCode.cs,Encode,The following statement contains a magic number: A = ((a & (a >> 2)) ^ (b & (b >> 2)));
Magic Number,NetTopologySuite.Shape.Fractal,HilbertCode,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Shape\Fractal\HilbertCode.cs,Encode,The following statement contains a magic number: B = ((a & (b >> 2)) ^ (b & ((a ^ b) >> 2)));
Magic Number,NetTopologySuite.Shape.Fractal,HilbertCode,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Shape\Fractal\HilbertCode.cs,Encode,The following statement contains a magic number: B = ((a & (b >> 2)) ^ (b & ((a ^ b) >> 2)));
Magic Number,NetTopologySuite.Shape.Fractal,HilbertCode,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Shape\Fractal\HilbertCode.cs,Encode,The following statement contains a magic number: C ^= ((a & (c >> 2)) ^ (b & (d >> 2)));
Magic Number,NetTopologySuite.Shape.Fractal,HilbertCode,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Shape\Fractal\HilbertCode.cs,Encode,The following statement contains a magic number: C ^= ((a & (c >> 2)) ^ (b & (d >> 2)));
Magic Number,NetTopologySuite.Shape.Fractal,HilbertCode,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Shape\Fractal\HilbertCode.cs,Encode,The following statement contains a magic number: D ^= ((b & (c >> 2)) ^ ((a ^ b) & (d >> 2)));
Magic Number,NetTopologySuite.Shape.Fractal,HilbertCode,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Shape\Fractal\HilbertCode.cs,Encode,The following statement contains a magic number: D ^= ((b & (c >> 2)) ^ ((a ^ b) & (d >> 2)));
Magic Number,NetTopologySuite.Shape.Fractal,HilbertCode,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Shape\Fractal\HilbertCode.cs,Encode,The following statement contains a magic number: A = ((a & (a >> 4)) ^ (b & (b >> 4)));
Magic Number,NetTopologySuite.Shape.Fractal,HilbertCode,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Shape\Fractal\HilbertCode.cs,Encode,The following statement contains a magic number: A = ((a & (a >> 4)) ^ (b & (b >> 4)));
Magic Number,NetTopologySuite.Shape.Fractal,HilbertCode,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Shape\Fractal\HilbertCode.cs,Encode,The following statement contains a magic number: B = ((a & (b >> 4)) ^ (b & ((a ^ b) >> 4)));
Magic Number,NetTopologySuite.Shape.Fractal,HilbertCode,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Shape\Fractal\HilbertCode.cs,Encode,The following statement contains a magic number: B = ((a & (b >> 4)) ^ (b & ((a ^ b) >> 4)));
Magic Number,NetTopologySuite.Shape.Fractal,HilbertCode,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Shape\Fractal\HilbertCode.cs,Encode,The following statement contains a magic number: C ^= ((a & (c >> 4)) ^ (b & (d >> 4)));
Magic Number,NetTopologySuite.Shape.Fractal,HilbertCode,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Shape\Fractal\HilbertCode.cs,Encode,The following statement contains a magic number: C ^= ((a & (c >> 4)) ^ (b & (d >> 4)));
Magic Number,NetTopologySuite.Shape.Fractal,HilbertCode,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Shape\Fractal\HilbertCode.cs,Encode,The following statement contains a magic number: D ^= ((b & (c >> 4)) ^ ((a ^ b) & (d >> 4)));
Magic Number,NetTopologySuite.Shape.Fractal,HilbertCode,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Shape\Fractal\HilbertCode.cs,Encode,The following statement contains a magic number: D ^= ((b & (c >> 4)) ^ ((a ^ b) & (d >> 4)));
Magic Number,NetTopologySuite.Shape.Fractal,HilbertCode,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Shape\Fractal\HilbertCode.cs,Encode,The following statement contains a magic number: C ^= ((a & (c >> 8)) ^ (b & (d >> 8)));
Magic Number,NetTopologySuite.Shape.Fractal,HilbertCode,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Shape\Fractal\HilbertCode.cs,Encode,The following statement contains a magic number: C ^= ((a & (c >> 8)) ^ (b & (d >> 8)));
Magic Number,NetTopologySuite.Shape.Fractal,HilbertCode,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Shape\Fractal\HilbertCode.cs,Encode,The following statement contains a magic number: D ^= ((b & (c >> 8)) ^ ((a ^ b) & (d >> 8)));
Magic Number,NetTopologySuite.Shape.Fractal,HilbertCode,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Shape\Fractal\HilbertCode.cs,Encode,The following statement contains a magic number: D ^= ((b & (c >> 8)) ^ ((a ^ b) & (d >> 8)));
Magic Number,NetTopologySuite.Shape.Fractal,HilbertCode,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Shape\Fractal\HilbertCode.cs,Encode,The following statement contains a magic number: i0 = (i0 | (i0 << 8)) & 0x00FF00FF;
Magic Number,NetTopologySuite.Shape.Fractal,HilbertCode,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Shape\Fractal\HilbertCode.cs,Encode,The following statement contains a magic number: i0 = (i0 | (i0 << 4)) & 0x0F0F0F0F;
Magic Number,NetTopologySuite.Shape.Fractal,HilbertCode,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Shape\Fractal\HilbertCode.cs,Encode,The following statement contains a magic number: i0 = (i0 | (i0 << 2)) & 0x33333333;
Magic Number,NetTopologySuite.Shape.Fractal,HilbertCode,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Shape\Fractal\HilbertCode.cs,Encode,The following statement contains a magic number: i1 = (i1 | (i1 << 8)) & 0x00FF00FF;
Magic Number,NetTopologySuite.Shape.Fractal,HilbertCode,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Shape\Fractal\HilbertCode.cs,Encode,The following statement contains a magic number: i1 = (i1 | (i1 << 4)) & 0x0F0F0F0F;
Magic Number,NetTopologySuite.Shape.Fractal,HilbertCode,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Shape\Fractal\HilbertCode.cs,Encode,The following statement contains a magic number: i1 = (i1 | (i1 << 2)) & 0x33333333;
Magic Number,NetTopologySuite.Shape.Fractal,HilbertCode,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Shape\Fractal\HilbertCode.cs,Encode,The following statement contains a magic number: long index = ((i1 << 1) | i0) >> (32 - 2 * lvl);
Magic Number,NetTopologySuite.Shape.Fractal,HilbertCode,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Shape\Fractal\HilbertCode.cs,Encode,The following statement contains a magic number: long index = ((i1 << 1) | i0) >> (32 - 2 * lvl);
Magic Number,NetTopologySuite.Shape.Fractal,HilbertCode,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Shape\Fractal\HilbertCode.cs,Decode,The following statement contains a magic number: index = index << (32 - 2 * lvl);
Magic Number,NetTopologySuite.Shape.Fractal,HilbertCode,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Shape\Fractal\HilbertCode.cs,Decode,The following statement contains a magic number: index = index << (32 - 2 * lvl);
Magic Number,NetTopologySuite.Shape.Fractal,HilbertCode,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Shape\Fractal\HilbertCode.cs,Decode,The following statement contains a magic number: long x = (a ^ i1) >> (16 - lvl);
Magic Number,NetTopologySuite.Shape.Fractal,HilbertCode,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Shape\Fractal\HilbertCode.cs,Decode,The following statement contains a magic number: long y = (a ^ i0 ^ i1) >> (16 - lvl);
Magic Number,NetTopologySuite.Shape.Fractal,HilbertCode,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Shape\Fractal\HilbertCode.cs,PrefixScan,The following statement contains a magic number: x = (x >> 8) ^ x;
Magic Number,NetTopologySuite.Shape.Fractal,HilbertCode,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Shape\Fractal\HilbertCode.cs,PrefixScan,The following statement contains a magic number: x = (x >> 4) ^ x;
Magic Number,NetTopologySuite.Shape.Fractal,HilbertCode,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Shape\Fractal\HilbertCode.cs,PrefixScan,The following statement contains a magic number: x = (x >> 2) ^ x;
Magic Number,NetTopologySuite.Shape.Fractal,HilbertCode,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Shape\Fractal\HilbertCode.cs,Deinterleave,The following statement contains a magic number: x = (x | (x >> 2)) & 0x0F0F0F0F;
Magic Number,NetTopologySuite.Shape.Fractal,HilbertCode,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Shape\Fractal\HilbertCode.cs,Deinterleave,The following statement contains a magic number: x = (x | (x >> 4)) & 0x00FF00FF;
Magic Number,NetTopologySuite.Shape.Fractal,HilbertCode,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Shape\Fractal\HilbertCode.cs,Deinterleave,The following statement contains a magic number: x = (x | (x >> 8)) & 0x0000FFFF;
Magic Number,NetTopologySuite.Shape.Fractal,KochSnowflakeBuilder,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Shape\Fractal\KochSnowflakeBuilder.cs,RecursionLevelForSize,The following statement contains a magic number: double pow4 = numPts / 3d;
Magic Number,NetTopologySuite.Shape.Fractal,KochSnowflakeBuilder,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Shape\Fractal\KochSnowflakeBuilder.cs,RecursionLevelForSize,The following statement contains a magic number: double exp = Math.Log(pow4) / Math.Log(4);
Magic Number,NetTopologySuite.Shape.Fractal,KochSnowflakeBuilder,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Shape\Fractal\KochSnowflakeBuilder.cs,GetBoundary,The following statement contains a magic number: var p1 = new Coordinate(origin.X + width / 2' y + width * HeightFactor);
Magic Number,NetTopologySuite.Shape.Fractal,MortonCode,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Shape\Fractal\MortonCode.cs,Size,The following statement contains a magic number: return (int)Math.Pow(2' 2 * level);
Magic Number,NetTopologySuite.Shape.Fractal,MortonCode,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Shape\Fractal\MortonCode.cs,Size,The following statement contains a magic number: return (int)Math.Pow(2' 2 * level);
Magic Number,NetTopologySuite.Shape.Fractal,MortonCode,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Shape\Fractal\MortonCode.cs,MaxOrdinate,The following statement contains a magic number: return (int)Math.Pow(2' level) - 1;
Magic Number,NetTopologySuite.Shape.Fractal,MortonCode,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Shape\Fractal\MortonCode.cs,Level,The following statement contains a magic number: int pow2 = (int)(Math.Log(numPoints) / Math.Log(2));
Magic Number,NetTopologySuite.Shape.Fractal,MortonCode,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Shape\Fractal\MortonCode.cs,Level,The following statement contains a magic number: int level = pow2 / 2;
Magic Number,NetTopologySuite.Shape.Fractal,MortonCode,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Shape\Fractal\MortonCode.cs,Interleave,The following statement contains a magic number: x = (x ^ (x << 8)) & 0x00ff00ff;
Magic Number,NetTopologySuite.Shape.Fractal,MortonCode,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Shape\Fractal\MortonCode.cs,Interleave,The following statement contains a magic number: x = (x ^ (x << 4)) & 0x0f0f0f0f;
Magic Number,NetTopologySuite.Shape.Fractal,MortonCode,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Shape\Fractal\MortonCode.cs,Interleave,The following statement contains a magic number: x = (x ^ (x << 2)) & 0x33333333;
Magic Number,NetTopologySuite.Shape.Fractal,MortonCode,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Shape\Fractal\MortonCode.cs,PrefixScan,The following statement contains a magic number: x = (x >> 8) ^ x;
Magic Number,NetTopologySuite.Shape.Fractal,MortonCode,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Shape\Fractal\MortonCode.cs,PrefixScan,The following statement contains a magic number: x = (x >> 4) ^ x;
Magic Number,NetTopologySuite.Shape.Fractal,MortonCode,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Shape\Fractal\MortonCode.cs,PrefixScan,The following statement contains a magic number: x = (x >> 2) ^ x;
Magic Number,NetTopologySuite.Shape.Fractal,MortonCode,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Shape\Fractal\MortonCode.cs,Deinterleave,The following statement contains a magic number: x = (x | (x >> 2)) & 0x0F0F0F0F;
Magic Number,NetTopologySuite.Shape.Fractal,MortonCode,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Shape\Fractal\MortonCode.cs,Deinterleave,The following statement contains a magic number: x = (x | (x >> 4)) & 0x00FF00FF;
Magic Number,NetTopologySuite.Shape.Fractal,MortonCode,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Shape\Fractal\MortonCode.cs,Deinterleave,The following statement contains a magic number: x = (x | (x >> 8)) & 0x0000FFFF;
Magic Number,NetTopologySuite.Shape.Fractal,SierpinskiCarpetBuilder,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Shape\Fractal\SierpinskiCarpetBuilder.cs,RecursionLevelForSize,The following statement contains a magic number: double pow4 = numPts/3d;
Magic Number,NetTopologySuite.Shape.Fractal,SierpinskiCarpetBuilder,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Shape\Fractal\SierpinskiCarpetBuilder.cs,RecursionLevelForSize,The following statement contains a magic number: double exp = Math.Log(pow4)/Math.Log(4);
Magic Number,NetTopologySuite.Shape.Fractal,SierpinskiCarpetBuilder,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Shape\Fractal\SierpinskiCarpetBuilder.cs,AddHoles,The following statement contains a magic number: double widthThird = width/3.0;
Magic Number,NetTopologySuite.Shape.Fractal,SierpinskiCarpetBuilder,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Shape\Fractal\SierpinskiCarpetBuilder.cs,AddHoles,The following statement contains a magic number: AddHoles(n2' originX + 2*widthThird' originY'                widthThird' holeList);
Magic Number,NetTopologySuite.Shape.Fractal,SierpinskiCarpetBuilder,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Shape\Fractal\SierpinskiCarpetBuilder.cs,AddHoles,The following statement contains a magic number: AddHoles(n2' originX + 2*widthThird' originY + widthThird'   widthThird' holeList);
Magic Number,NetTopologySuite.Shape.Fractal,SierpinskiCarpetBuilder,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Shape\Fractal\SierpinskiCarpetBuilder.cs,AddHoles,The following statement contains a magic number: AddHoles(n2' originX'                originY + 2*widthThird' widthThird' holeList);
Magic Number,NetTopologySuite.Shape.Fractal,SierpinskiCarpetBuilder,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Shape\Fractal\SierpinskiCarpetBuilder.cs,AddHoles,The following statement contains a magic number: AddHoles(n2' originX + widthThird'   originY + 2*widthThird' widthThird' holeList);
Magic Number,NetTopologySuite.Shape.Fractal,SierpinskiCarpetBuilder,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Shape\Fractal\SierpinskiCarpetBuilder.cs,AddHoles,The following statement contains a magic number: AddHoles(n2' originX + 2*widthThird' originY + 2*widthThird' widthThird' holeList);
Magic Number,NetTopologySuite.Shape.Fractal,SierpinskiCarpetBuilder,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Shape\Fractal\SierpinskiCarpetBuilder.cs,AddHoles,The following statement contains a magic number: AddHoles(n2' originX + 2*widthThird' originY + 2*widthThird' widthThird' holeList);
Magic Number,NetTopologySuite.Shape.Random,RandomPointsInGridBuilder,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Shape\Random\RandomPointsInGridBuilder.cs,GetGeometry,The following statement contains a magic number: double gutterOffsetX = gridDX * gutterFrac / 2;
Magic Number,NetTopologySuite.Shape.Random,RandomPointsInGridBuilder,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Shape\Random\RandomPointsInGridBuilder.cs,GetGeometry,The following statement contains a magic number: double gutterOffsetY = gridDY * gutterFrac / 2;
Magic Number,NetTopologySuite.Shape.Random,RandomPointsInGridBuilder,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Shape\Random\RandomPointsInGridBuilder.cs,RandomPointInCircle,The following statement contains a magic number: double centreX = orgX + width / 2;
Magic Number,NetTopologySuite.Shape.Random,RandomPointsInGridBuilder,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Shape\Random\RandomPointsInGridBuilder.cs,RandomPointInCircle,The following statement contains a magic number: double centreY = orgY + height / 2;
Magic Number,NetTopologySuite.Shape.Random,RandomPointsInGridBuilder,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Shape\Random\RandomPointsInGridBuilder.cs,RandomPointInCircle,The following statement contains a magic number: double rndAng = 2 * Math.PI * Rnd.NextDouble();
Magic Number,NetTopologySuite.Shape.Random,RandomPointsInGridBuilder,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Shape\Random\RandomPointsInGridBuilder.cs,RandomPointInCircle,The following statement contains a magic number: double rndX = width / 2 * rndRadius2 * Math.Cos(rndAng);
Magic Number,NetTopologySuite.Shape.Random,RandomPointsInGridBuilder,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Shape\Random\RandomPointsInGridBuilder.cs,RandomPointInCircle,The following statement contains a magic number: double rndY = height / 2 * rndRadius2 * Math.Sin(rndAng);
Magic Number,NetTopologySuite.Simplify,OldVWLineSimplifier,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Simplify\OldVWLineSimplifier.cs,Simplify,The following statement contains a magic number: simp.Length >= 2
Magic Number,NetTopologySuite.Simplify,TaggedLineStringSimplifier,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Simplify\TaggedLineStringSimplifier.cs,SimplifySection,The following statement contains a magic number: int[] sectionIndex = new int[2];
Magic Number,NetTopologySuite.Simplify,LineStringMapBuilderFilter,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Simplify\TopologyPreservingSimplifier.cs,Filter,The following statement contains a magic number: int minSize = line.IsClosed ? 4 : 2;
Magic Number,NetTopologySuite.Simplify,LineStringMapBuilderFilter,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Simplify\TopologyPreservingSimplifier.cs,Filter,The following statement contains a magic number: int minSize = line.IsClosed ? 4 : 2;
Magic Number,NetTopologySuite.Triangulate,ConformingDelaunayTriangulator,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Triangulate\ConformingDelaunayTriangulator.cs,ComputeBoundingBox,The following statement contains a magic number: double deltaX = allPointsEnv.Width * 0.2;
Magic Number,NetTopologySuite.Triangulate,ConformingDelaunayTriangulator,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Triangulate\ConformingDelaunayTriangulator.cs,ComputeBoundingBox,The following statement contains a magic number: double deltaY = allPointsEnv.Height * 0.2;
Magic Number,NetTopologySuite.Triangulate,ConformingDelaunayTriangulator,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Triangulate\ConformingDelaunayTriangulator.cs,FindNonGabrielPoint,The following statement contains a magic number: var midPt = new Coordinate((p.X + q.X) / 2.0' (p.Y + q.Y) / 2.0);
Magic Number,NetTopologySuite.Triangulate,ConformingDelaunayTriangulator,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Triangulate\ConformingDelaunayTriangulator.cs,FindNonGabrielPoint,The following statement contains a magic number: var midPt = new Coordinate((p.X + q.X) / 2.0' (p.Y + q.Y) / 2.0);
Magic Number,NetTopologySuite.Triangulate,MidpointSplitPointFinder,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Triangulate\MidpointSplitPointFinder.cs,FindSplitPoint,The following statement contains a magic number: return new Coordinate((p0.X + p1.X) / 2' (p0.Y + p1.Y) / 2);
Magic Number,NetTopologySuite.Triangulate,MidpointSplitPointFinder,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Triangulate\MidpointSplitPointFinder.cs,FindSplitPoint,The following statement contains a magic number: return new Coordinate((p0.X + p1.X) / 2' (p0.Y + p1.Y) / 2);
Magic Number,NetTopologySuite.Triangulate,NonEncroachingSplitPointFinder,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Triangulate\NonEncroachingSplitPointFinder.cs,FindSplitPoint,The following statement contains a magic number: double midPtLen = segLen / 2;
Magic Number,NetTopologySuite.Triangulate,NonEncroachingSplitPointFinder,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Triangulate\NonEncroachingSplitPointFinder.cs,FindSplitPoint,The following statement contains a magic number: double nonEncroachDiam = projPt.Distance(encroachPt) * 2 * 0.8;
Magic Number,NetTopologySuite.Triangulate,NonEncroachingSplitPointFinder,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Triangulate\NonEncroachingSplitPointFinder.cs,FindSplitPoint,The following statement contains a magic number: double nonEncroachDiam = projPt.Distance(encroachPt) * 2 * 0.8;
Magic Number,NetTopologySuite.Triangulate.QuadEdge,EdgeConnectedTriangleTraversal,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Triangulate\QuadEdge\EdgeConnectedTriangleTraversal.cs,Process,The following statement contains a magic number: i < 3
Magic Number,NetTopologySuite.Triangulate.QuadEdge,QuadEdgeSubdivision,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Triangulate\QuadEdge\QuadEdgeSubdivision.cs,GetTriangleEdges,The following statement contains a magic number: triEdge[2] = triEdge[1].LNext;
Magic Number,NetTopologySuite.Triangulate.QuadEdge,QuadEdgeSubdivision,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Triangulate\QuadEdge\QuadEdgeSubdivision.cs,GetTriangleEdges,The following statement contains a magic number: triEdge[2].LNext != triEdge[0]
Magic Number,NetTopologySuite.Triangulate.QuadEdge,QuadEdgeSubdivision,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Triangulate\QuadEdge\QuadEdgeSubdivision.cs,CreateFrame,The following statement contains a magic number: offset = deltaX * 10.0;
Magic Number,NetTopologySuite.Triangulate.QuadEdge,QuadEdgeSubdivision,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Triangulate\QuadEdge\QuadEdgeSubdivision.cs,CreateFrame,The following statement contains a magic number: _frameVertex[0] = new Vertex((env.MaxX + env.MinX) / 2.0' env.MaxY + offset);
Magic Number,NetTopologySuite.Triangulate.QuadEdge,QuadEdgeSubdivision,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Triangulate\QuadEdge\QuadEdgeSubdivision.cs,CreateFrame,The following statement contains a magic number: _frameVertex[2] = new Vertex(env.MaxX + offset' env.MinY - offset);
Magic Number,NetTopologySuite.Triangulate.QuadEdge,QuadEdgeSubdivision,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Triangulate\QuadEdge\QuadEdgeSubdivision.cs,CreateFrame,The following statement contains a magic number: _frameEnv.ExpandToInclude(_frameVertex[2].Coordinate);
Magic Number,NetTopologySuite.Triangulate.QuadEdge,QuadEdgeSubdivision,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Triangulate\QuadEdge\QuadEdgeSubdivision.cs,InitSubdiv,The following statement contains a magic number: var eb = MakeEdge(_frameVertex[1]' _frameVertex[2]);
Magic Number,NetTopologySuite.Triangulate.QuadEdge,QuadEdgeSubdivision,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Triangulate\QuadEdge\QuadEdgeSubdivision.cs,InitSubdiv,The following statement contains a magic number: var ec = MakeEdge(_frameVertex[2]' _frameVertex[0]);
Magic Number,NetTopologySuite.Triangulate.QuadEdge,QuadEdgeSubdivision,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Triangulate\QuadEdge\QuadEdgeSubdivision.cs,IsFrameBorderEdge,The following statement contains a magic number: var leftTri = new QuadEdge[3];
Magic Number,NetTopologySuite.Triangulate.QuadEdge,QuadEdgeSubdivision,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Triangulate\QuadEdge\QuadEdgeSubdivision.cs,IsFrameBorderEdge,The following statement contains a magic number: var rightTri = new QuadEdge[3];
Magic Number,NetTopologySuite.Triangulate.QuadEdge,QuadEdgeSubdivision,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Triangulate\QuadEdge\QuadEdgeSubdivision.cs,IsFrameVertex,The following statement contains a magic number: v.Equals(_frameVertex[2])
Magic Number,NetTopologySuite.Triangulate.QuadEdge,QuadEdgeSubdivision,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Triangulate\QuadEdge\QuadEdgeSubdivision.cs,GetVoronoiCellPolygon,The following statement contains a magic number: coordList.Count < 4
Magic Number,NetTopologySuite.Triangulate.QuadEdge,TriangleCircumcentreVisitor,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Triangulate\QuadEdge\QuadEdgeSubdivision.cs,Visit,The following statement contains a magic number: var c = triEdges[2].Orig.Coordinate;
Magic Number,NetTopologySuite.Triangulate.QuadEdge,TriangleCircumcentreVisitor,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Triangulate\QuadEdge\QuadEdgeSubdivision.cs,Visit,The following statement contains a magic number: i < 3
Magic Number,NetTopologySuite.Triangulate.QuadEdge,TriangleVertexListVisitor,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Triangulate\QuadEdge\QuadEdgeSubdivision.cs,Visit,The following statement contains a magic number: _triList.Add(new[] { triEdges[0].Orig' triEdges[1].Orig'                              triEdges[2].Orig });
Magic Number,NetTopologySuite.Triangulate.QuadEdge,TriangleCoordinatesVisitor,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Triangulate\QuadEdge\QuadEdgeSubdivision.cs,Visit,The following statement contains a magic number: i < 3
Magic Number,NetTopologySuite.Triangulate.QuadEdge,TriangleCoordinatesVisitor,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Triangulate\QuadEdge\QuadEdgeSubdivision.cs,Visit,The following statement contains a magic number: pts.Length != 4
Magic Number,NetTopologySuite.Triangulate.QuadEdge,TriangleCoordinatesVisitor,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Triangulate\QuadEdge\QuadEdgeSubdivision.cs,CheckTriangleSize,The following statement contains a magic number: pts.Length >= 2
Magic Number,NetTopologySuite.Triangulate.QuadEdge,TriangleCoordinatesVisitor,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Triangulate\QuadEdge\QuadEdgeSubdivision.cs,CheckTriangleSize,The following statement contains a magic number: Assert.IsTrue(pts.Length == 4' "Too few points for visited triangle at " + loc);
Magic Number,NetTopologySuite.Triangulate.QuadEdge,QuadEdgeTriangle,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Triangulate\QuadEdge\QuadEdgeTriangle.cs,Contains,The following statement contains a magic number: var ring = new[]                             {                                 tri[0].Coordinate'                                 tri[1].Coordinate'                                 tri[2].Coordinate'                                 tri[0].Coordinate                             };
Magic Number,NetTopologySuite.Triangulate.QuadEdge,QuadEdgeTriangle,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Triangulate\QuadEdge\QuadEdgeTriangle.cs,Contains,The following statement contains a magic number: var ring = new[]                             {                                 tri[0].Orig.Coordinate'                                 tri[1].Orig.Coordinate'                                 tri[2].Orig.Coordinate'                                 tri[0].Orig.Coordinate                             };
Magic Number,NetTopologySuite.Triangulate.QuadEdge,QuadEdgeTriangle,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Triangulate\QuadEdge\QuadEdgeTriangle.cs,ToPolygon,The following statement contains a magic number: var ringPts = new[]                                {                                    v[0].Coordinate'                                    v[1].Coordinate'                                    v[2].Coordinate'                                    v[0].Coordinate                                };
Magic Number,NetTopologySuite.Triangulate.QuadEdge,QuadEdgeTriangle,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Triangulate\QuadEdge\QuadEdgeTriangle.cs,ToPolygon,The following statement contains a magic number: var ringPts = new[]                                {                                    e[0].Orig.Coordinate'                                    e[1].Orig.Coordinate'                                    e[2].Orig.Coordinate'                                    e[0].Orig.Coordinate                                };
Magic Number,NetTopologySuite.Triangulate.QuadEdge,QuadEdgeTriangle,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Triangulate\QuadEdge\QuadEdgeTriangle.cs,QuadEdgeTriangle,The following statement contains a magic number: i < 3
Magic Number,NetTopologySuite.Triangulate.QuadEdge,QuadEdgeTriangle,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Triangulate\QuadEdge\QuadEdgeTriangle.cs,GetVertices,The following statement contains a magic number: var vert = new Vertex[3];
Magic Number,NetTopologySuite.Triangulate.QuadEdge,QuadEdgeTriangle,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Triangulate\QuadEdge\QuadEdgeTriangle.cs,GetVertices,The following statement contains a magic number: i < 3
Magic Number,NetTopologySuite.Triangulate.QuadEdge,QuadEdgeTriangle,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Triangulate\QuadEdge\QuadEdgeTriangle.cs,GetEdgeIndex,The following statement contains a magic number: i < 3
Magic Number,NetTopologySuite.Triangulate.QuadEdge,QuadEdgeTriangle,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Triangulate\QuadEdge\QuadEdgeTriangle.cs,GetEdgeIndex,The following statement contains a magic number: i < 3
Magic Number,NetTopologySuite.Triangulate.QuadEdge,QuadEdgeTriangle,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Triangulate\QuadEdge\QuadEdgeTriangle.cs,GetEdgeSegment,The following statement contains a magic number: int nexti = (i + 1)%3;
Magic Number,NetTopologySuite.Triangulate.QuadEdge,QuadEdgeTriangle,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Triangulate\QuadEdge\QuadEdgeTriangle.cs,GetCoordinates,The following statement contains a magic number: var pts = new Coordinate[4];
Magic Number,NetTopologySuite.Triangulate.QuadEdge,QuadEdgeTriangle,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Triangulate\QuadEdge\QuadEdgeTriangle.cs,GetCoordinates,The following statement contains a magic number: i < 3
Magic Number,NetTopologySuite.Triangulate.QuadEdge,QuadEdgeTriangle,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Triangulate\QuadEdge\QuadEdgeTriangle.cs,GetCoordinates,The following statement contains a magic number: pts[3] = pts[0].Copy();
Magic Number,NetTopologySuite.Triangulate.QuadEdge,QuadEdgeTriangle,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Triangulate\QuadEdge\QuadEdgeTriangle.cs,IsBorder,The following statement contains a magic number: i < 3
Magic Number,NetTopologySuite.Triangulate.QuadEdge,QuadEdgeTriangle,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Triangulate\QuadEdge\QuadEdgeTriangle.cs,GetNeighbours,The following statement contains a magic number: var neigh = new QuadEdgeTriangle[3];
Magic Number,NetTopologySuite.Triangulate.QuadEdge,QuadEdgeTriangle,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Triangulate\QuadEdge\QuadEdgeTriangle.cs,GetNeighbours,The following statement contains a magic number: i < 3
Magic Number,NetTopologySuite.Triangulate.QuadEdge,Vertex,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Triangulate\QuadEdge\Vertex.cs,Bisector,The following statement contains a magic number: var l1 = new HCoordinate(a.X + dx/2.0' a.Y + dy/2.0' 1.0);
Magic Number,NetTopologySuite.Triangulate.QuadEdge,Vertex,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Triangulate\QuadEdge\Vertex.cs,Bisector,The following statement contains a magic number: var l1 = new HCoordinate(a.X + dx/2.0' a.Y + dy/2.0' 1.0);
Magic Number,NetTopologySuite.Triangulate.QuadEdge,Vertex,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Triangulate\QuadEdge\Vertex.cs,Bisector,The following statement contains a magic number: var l2 = new HCoordinate(a.X - dy + dx/2.0' a.Y + dx + dy/2.0' 1.0);
Magic Number,NetTopologySuite.Triangulate.QuadEdge,Vertex,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Triangulate\QuadEdge\Vertex.cs,Bisector,The following statement contains a magic number: var l2 = new HCoordinate(a.X - dy + dx/2.0' a.Y + dx + dy/2.0' 1.0);
Magic Number,NetTopologySuite.Triangulate.QuadEdge,Vertex,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Triangulate\QuadEdge\Vertex.cs,Distance,The following statement contains a magic number: return Math.Sqrt(Math.Pow(v2.X - v1.X' 2.0)                             + Math.Pow(v2.Y - v1.Y' 2.0));
Magic Number,NetTopologySuite.Triangulate.QuadEdge,Vertex,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Triangulate\QuadEdge\Vertex.cs,Distance,The following statement contains a magic number: return Math.Sqrt(Math.Pow(v2.X - v1.X' 2.0)                             + Math.Pow(v2.Y - v1.Y' 2.0));
Magic Number,NetTopologySuite.Triangulate.QuadEdge,Vertex,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Triangulate\QuadEdge\Vertex.cs,MidPoint,The following statement contains a magic number: double xm = (_p.X + a.X)/2.0;
Magic Number,NetTopologySuite.Triangulate.QuadEdge,Vertex,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Triangulate\QuadEdge\Vertex.cs,MidPoint,The following statement contains a magic number: double ym = (_p.Y + a.Y)/2.0;
Magic Number,NetTopologySuite.Triangulate.QuadEdge,Vertex,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Triangulate\QuadEdge\Vertex.cs,MidPoint,The following statement contains a magic number: double zm = (_p.Z + a.Z)/2.0;
Magic Number,NetTopologySuite.Utilities,AlternativePriorityQueue<TPriority;TData>,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Utilities\AlternativePriorityQueue.cs,HeapifyUp,The following statement contains a magic number: int parent = node.QueueIndex / 2;
Magic Number,NetTopologySuite.Utilities,AlternativePriorityQueue<TPriority;TData>,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Utilities\AlternativePriorityQueue.cs,HeapifyUp,The following statement contains a magic number: parent = node.QueueIndex / 2;
Magic Number,NetTopologySuite.Utilities,AlternativePriorityQueue<TPriority;TData>,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Utilities\AlternativePriorityQueue.cs,HeapifyDown,The following statement contains a magic number: int childLeftIndex = 2 * finalQueueIndex;
Magic Number,NetTopologySuite.Utilities,AlternativePriorityQueue<TPriority;TData>,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Utilities\AlternativePriorityQueue.cs,OnNodeUpdated,The following statement contains a magic number: int parentIndex = node.QueueIndex / 2;
Magic Number,NetTopologySuite.Utilities,BitTweaks,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Utilities\BitTweaks.cs,ReverseByteOrder,The following statement contains a magic number: Debug.Assert(bytes.Length == 4);
Magic Number,NetTopologySuite.Utilities,BitTweaks,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Utilities\BitTweaks.cs,ReverseByteOrder,The following statement contains a magic number: Array.Reverse(bytes' 0' 4);
Magic Number,NetTopologySuite.Utilities,BitTweaks,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Utilities\BitTweaks.cs,ReverseByteOrder,The following statement contains a magic number: return (ushort)((value & 0x00FF) << 8 |                                  (value & 0xFF00) >> 8);
Magic Number,NetTopologySuite.Utilities,BitTweaks,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Utilities\BitTweaks.cs,ReverseByteOrder,The following statement contains a magic number: return (ushort)((value & 0x00FF) << 8 |                                  (value & 0xFF00) >> 8);
Magic Number,NetTopologySuite.Utilities,BitTweaks,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Utilities\BitTweaks.cs,ReverseByteOrder,The following statement contains a magic number: return (value & 0x000000FF) << 24 |                     (value & 0x0000FF00) << 8 |                     (value & 0x00FF0000) >> 8 |                     (value & 0xFF000000) >> 24;
Magic Number,NetTopologySuite.Utilities,BitTweaks,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Utilities\BitTweaks.cs,ReverseByteOrder,The following statement contains a magic number: return (value & 0x000000FF) << 24 |                     (value & 0x0000FF00) << 8 |                     (value & 0x00FF0000) >> 8 |                     (value & 0xFF000000) >> 24;
Magic Number,NetTopologySuite.Utilities,BitTweaks,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Utilities\BitTweaks.cs,ReverseByteOrder,The following statement contains a magic number: return (value & 0x000000FF) << 24 |                     (value & 0x0000FF00) << 8 |                     (value & 0x00FF0000) >> 8 |                     (value & 0xFF000000) >> 24;
Magic Number,NetTopologySuite.Utilities,BitTweaks,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Utilities\BitTweaks.cs,ReverseByteOrder,The following statement contains a magic number: return (value & 0x000000FF) << 24 |                     (value & 0x0000FF00) << 8 |                     (value & 0x00FF0000) >> 8 |                     (value & 0xFF000000) >> 24;
Magic Number,NetTopologySuite.Utilities,BitTweaks,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Utilities\BitTweaks.cs,ReverseByteOrder,The following statement contains a magic number: return (value & 0x00000000000000FF) << 56 |                     (value & 0x000000000000FF00) << 40 |                     (value & 0x0000000000FF0000) << 24 |                     (value & 0x00000000FF000000) << 8 |                     (value & 0x000000FF00000000) >> 8 |                     (value & 0x0000FF0000000000) >> 24 |                     (value & 0x00FF000000000000) >> 40 |                     (value & 0xFF00000000000000) >> 56;
Magic Number,NetTopologySuite.Utilities,BitTweaks,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Utilities\BitTweaks.cs,ReverseByteOrder,The following statement contains a magic number: return (value & 0x00000000000000FF) << 56 |                     (value & 0x000000000000FF00) << 40 |                     (value & 0x0000000000FF0000) << 24 |                     (value & 0x00000000FF000000) << 8 |                     (value & 0x000000FF00000000) >> 8 |                     (value & 0x0000FF0000000000) >> 24 |                     (value & 0x00FF000000000000) >> 40 |                     (value & 0xFF00000000000000) >> 56;
Magic Number,NetTopologySuite.Utilities,BitTweaks,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Utilities\BitTweaks.cs,ReverseByteOrder,The following statement contains a magic number: return (value & 0x00000000000000FF) << 56 |                     (value & 0x000000000000FF00) << 40 |                     (value & 0x0000000000FF0000) << 24 |                     (value & 0x00000000FF000000) << 8 |                     (value & 0x000000FF00000000) >> 8 |                     (value & 0x0000FF0000000000) >> 24 |                     (value & 0x00FF000000000000) >> 40 |                     (value & 0xFF00000000000000) >> 56;
Magic Number,NetTopologySuite.Utilities,BitTweaks,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Utilities\BitTweaks.cs,ReverseByteOrder,The following statement contains a magic number: return (value & 0x00000000000000FF) << 56 |                     (value & 0x000000000000FF00) << 40 |                     (value & 0x0000000000FF0000) << 24 |                     (value & 0x00000000FF000000) << 8 |                     (value & 0x000000FF00000000) >> 8 |                     (value & 0x0000FF0000000000) >> 24 |                     (value & 0x00FF000000000000) >> 40 |                     (value & 0xFF00000000000000) >> 56;
Magic Number,NetTopologySuite.Utilities,BitTweaks,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Utilities\BitTweaks.cs,ReverseByteOrder,The following statement contains a magic number: return (value & 0x00000000000000FF) << 56 |                     (value & 0x000000000000FF00) << 40 |                     (value & 0x0000000000FF0000) << 24 |                     (value & 0x00000000FF000000) << 8 |                     (value & 0x000000FF00000000) >> 8 |                     (value & 0x0000FF0000000000) >> 24 |                     (value & 0x00FF000000000000) >> 40 |                     (value & 0xFF00000000000000) >> 56;
Magic Number,NetTopologySuite.Utilities,BitTweaks,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Utilities\BitTweaks.cs,ReverseByteOrder,The following statement contains a magic number: return (value & 0x00000000000000FF) << 56 |                     (value & 0x000000000000FF00) << 40 |                     (value & 0x0000000000FF0000) << 24 |                     (value & 0x00000000FF000000) << 8 |                     (value & 0x000000FF00000000) >> 8 |                     (value & 0x0000FF0000000000) >> 24 |                     (value & 0x00FF000000000000) >> 40 |                     (value & 0xFF00000000000000) >> 56;
Magic Number,NetTopologySuite.Utilities,BitTweaks,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Utilities\BitTweaks.cs,ReverseByteOrder,The following statement contains a magic number: return (value & 0x00000000000000FF) << 56 |                     (value & 0x000000000000FF00) << 40 |                     (value & 0x0000000000FF0000) << 24 |                     (value & 0x00000000FF000000) << 8 |                     (value & 0x000000FF00000000) >> 8 |                     (value & 0x0000FF0000000000) >> 24 |                     (value & 0x00FF000000000000) >> 40 |                     (value & 0xFF00000000000000) >> 56;
Magic Number,NetTopologySuite.Utilities,BitTweaks,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Utilities\BitTweaks.cs,ReverseByteOrder,The following statement contains a magic number: return (value & 0x00000000000000FF) << 56 |                     (value & 0x000000000000FF00) << 40 |                     (value & 0x0000000000FF0000) << 24 |                     (value & 0x00000000FF000000) << 8 |                     (value & 0x000000FF00000000) >> 8 |                     (value & 0x0000FF0000000000) >> 24 |                     (value & 0x00FF000000000000) >> 40 |                     (value & 0xFF00000000000000) >> 56;
Magic Number,NetTopologySuite.Utilities,Degrees,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Utilities\Degrees.cs,ToRadians,The following statement contains a magic number: return degrees * 0.0174532925199432958;
Magic Number,NetTopologySuite.Utilities,GeometricShapeFactory,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Utilities\GeometricShapeFactory.cs,CreateRectangle,The following statement contains a magic number: int nSide = _nPts / 4;
Magic Number,NetTopologySuite.Utilities,GeometricShapeFactory,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Utilities\GeometricShapeFactory.cs,CreateRectangle,The following statement contains a magic number: var pts = new Coordinate[4 * nSide + 1];
Magic Number,NetTopologySuite.Utilities,GeometricShapeFactory,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Utilities\GeometricShapeFactory.cs,CreateCircle,The following statement contains a magic number: double xRadius = env.Width / 2.0;
Magic Number,NetTopologySuite.Utilities,GeometricShapeFactory,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Utilities\GeometricShapeFactory.cs,CreateCircle,The following statement contains a magic number: double yRadius = env.Height / 2.0;
Magic Number,NetTopologySuite.Utilities,GeometricShapeFactory,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Utilities\GeometricShapeFactory.cs,CreateCircle,The following statement contains a magic number: double ang = i * (2 * Math.PI / _nPts);
Magic Number,NetTopologySuite.Utilities,GeometricShapeFactory,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Utilities\GeometricShapeFactory.cs,CreateEllipse,The following statement contains a magic number: double xRadius = env.Width / 2.0;
Magic Number,NetTopologySuite.Utilities,GeometricShapeFactory,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Utilities\GeometricShapeFactory.cs,CreateEllipse,The following statement contains a magic number: double yRadius = env.Height / 2.0;
Magic Number,NetTopologySuite.Utilities,GeometricShapeFactory,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Utilities\GeometricShapeFactory.cs,CreateEllipse,The following statement contains a magic number: double ang = i * (2 * Math.PI / _nPts);
Magic Number,NetTopologySuite.Utilities,GeometricShapeFactory,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Utilities\GeometricShapeFactory.cs,CreateSquircle,The following statement contains a magic number: return CreateSupercircle(4);
Magic Number,NetTopologySuite.Utilities,GeometricShapeFactory,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Utilities\GeometricShapeFactory.cs,CreateSupercircle,The following statement contains a magic number: double radius = _dim.MinSize / 2;
Magic Number,NetTopologySuite.Utilities,GeometricShapeFactory,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Utilities\GeometricShapeFactory.cs,CreateSupercircle,The following statement contains a magic number: double xyInt = Math.Pow(r4 / 2' recipPow);
Magic Number,NetTopologySuite.Utilities,GeometricShapeFactory,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Utilities\GeometricShapeFactory.cs,CreateSupercircle,The following statement contains a magic number: int nSegsInOct = _nPts / 8;
Magic Number,NetTopologySuite.Utilities,GeometricShapeFactory,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Utilities\GeometricShapeFactory.cs,CreateSupercircle,The following statement contains a magic number: int totPts = nSegsInOct * 8 + 1;
Magic Number,NetTopologySuite.Utilities,GeometricShapeFactory,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Utilities\GeometricShapeFactory.cs,CreateSupercircle,The following statement contains a magic number: pts[2 * nSegsInOct - i] = CreateCoordTrans(y' x' centre);
Magic Number,NetTopologySuite.Utilities,GeometricShapeFactory,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Utilities\GeometricShapeFactory.cs,CreateSupercircle,The following statement contains a magic number: pts[2 * nSegsInOct + i] = CreateCoordTrans(y' -x' centre);
Magic Number,NetTopologySuite.Utilities,GeometricShapeFactory,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Utilities\GeometricShapeFactory.cs,CreateSupercircle,The following statement contains a magic number: pts[4 * nSegsInOct - i] = CreateCoordTrans(x' -y' centre);
Magic Number,NetTopologySuite.Utilities,GeometricShapeFactory,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Utilities\GeometricShapeFactory.cs,CreateSupercircle,The following statement contains a magic number: pts[4 * nSegsInOct + i] = CreateCoordTrans(-x' -y' centre);
Magic Number,NetTopologySuite.Utilities,GeometricShapeFactory,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Utilities\GeometricShapeFactory.cs,CreateSupercircle,The following statement contains a magic number: pts[6 * nSegsInOct - i] = CreateCoordTrans(-y' -x' centre);
Magic Number,NetTopologySuite.Utilities,GeometricShapeFactory,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Utilities\GeometricShapeFactory.cs,CreateSupercircle,The following statement contains a magic number: pts[6 * nSegsInOct + i] = CreateCoordTrans(-y' x' centre);
Magic Number,NetTopologySuite.Utilities,GeometricShapeFactory,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Utilities\GeometricShapeFactory.cs,CreateSupercircle,The following statement contains a magic number: pts[8 * nSegsInOct - i] = CreateCoordTrans(-x' y' centre);
Magic Number,NetTopologySuite.Utilities,GeometricShapeFactory,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Utilities\GeometricShapeFactory.cs,CreateArc,The following statement contains a magic number: double xRadius = env.Width / 2.0;
Magic Number,NetTopologySuite.Utilities,GeometricShapeFactory,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Utilities\GeometricShapeFactory.cs,CreateArc,The following statement contains a magic number: double yRadius = env.Height / 2.0;
Magic Number,NetTopologySuite.Utilities,GeometricShapeFactory,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Utilities\GeometricShapeFactory.cs,CreateArc,The following statement contains a magic number: angSize = 2 * Math.PI;
Magic Number,NetTopologySuite.Utilities,GeometricShapeFactory,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Utilities\GeometricShapeFactory.cs,CreateArc,The following statement contains a magic number: angSize <= 0.0 || angSize > 2 * Math.PI
Magic Number,NetTopologySuite.Utilities,GeometricShapeFactory,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Utilities\GeometricShapeFactory.cs,CreateArcPolygon,The following statement contains a magic number: double xRadius = env.Width / 2.0;
Magic Number,NetTopologySuite.Utilities,GeometricShapeFactory,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Utilities\GeometricShapeFactory.cs,CreateArcPolygon,The following statement contains a magic number: double yRadius = env.Height / 2.0;
Magic Number,NetTopologySuite.Utilities,GeometricShapeFactory,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Utilities\GeometricShapeFactory.cs,CreateArcPolygon,The following statement contains a magic number: angSize = 2 * Math.PI;
Magic Number,NetTopologySuite.Utilities,GeometricShapeFactory,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Utilities\GeometricShapeFactory.cs,CreateArcPolygon,The following statement contains a magic number: angSize <= 0.0 || angSize > 2 * Math.PI
Magic Number,NetTopologySuite.Utilities,GeometricShapeFactory,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Utilities\GeometricShapeFactory.cs,CreateArcPolygon,The following statement contains a magic number: var pts = new Coordinate[_nPts + 2];
Magic Number,NetTopologySuite.Utilities,HexConverter,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Utilities\HexConverter.cs,ConvertAny2Any,The following statement contains a magic number: (baseIn < 2) || (baseIn > 36) ||                    (baseOut < 2) || (baseOut > 36)
Magic Number,NetTopologySuite.Utilities,HexConverter,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Utilities\HexConverter.cs,ConvertAny2Any,The following statement contains a magic number: (baseIn < 2) || (baseIn > 36) ||                    (baseOut < 2) || (baseOut > 36)
Magic Number,NetTopologySuite.Utilities,HexConverter,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Utilities\HexConverter.cs,ConvertAny2Any,The following statement contains a magic number: (baseIn < 2) || (baseIn > 36) ||                    (baseOut < 2) || (baseOut > 36)
Magic Number,NetTopologySuite.Utilities,HexConverter,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Utilities\HexConverter.cs,ConvertAny2Any,The following statement contains a magic number: (baseIn < 2) || (baseIn > 36) ||                    (baseOut < 2) || (baseOut > 36)
Magic Number,NetTopologySuite.Utilities,HexConverter,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Utilities\HexConverter.cs,ConvertAny2Any,The following statement contains a magic number: baseIn == 10
Magic Number,NetTopologySuite.Utilities,HexConverter,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Utilities\HexConverter.cs,ConvertAny2Any,The following statement contains a magic number: baseOut == 10
Magic Number,NetTopologySuite.Utilities,Memory,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Utilities\Memory.cs,Format,The following statement contains a magic number: mem < 2 * KB
Magic Number,NetTopologySuite.Utilities,Memory,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Utilities\Memory.cs,Format,The following statement contains a magic number: mem < 2 * MB
Magic Number,NetTopologySuite.Utilities,Memory,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Utilities\Memory.cs,Format,The following statement contains a magic number: mem < 2 * GB
Magic Number,NetTopologySuite.Utilities,Memory,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Utilities\Memory.cs,Round,The following statement contains a magic number: return Math.Ceiling(d * 100) / 100;
Magic Number,NetTopologySuite.Utilities,Memory,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Utilities\Memory.cs,Round,The following statement contains a magic number: return Math.Ceiling(d * 100) / 100;
Magic Number,NetTopologySuite.Utilities,Radians,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Utilities\Radians.cs,ToDegrees,The following statement contains a magic number: return radians * 57.29577951308232;
Magic Number,RTools_NTS.Util,CharBuffer,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Utilities\RToolsUtil\CharBuffer.cs,Grow,The following statement contains a magic number: int newLen = Math.Max(capacity*2' requestedLen);
Magic Number,RTools_NTS.Util,CharBuffer,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Utilities\RToolsUtil\CharBuffer.cs,Grow,The following statement contains a magic number: newLen = Math.Max(newLen' 16);
Magic Number,RTools_NTS.Util,StreamTokenizer,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Utilities\RToolsUtil\StreamTokenizer.cs,Initialize,The following statement contains a magic number: backString = new CharBuffer(32);
Magic Number,RTools_NTS.Util,StreamTokenizer,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Utilities\RToolsUtil\StreamTokenizer.cs,Initialize,The following statement contains a magic number: nextTokenSb = new CharBuffer(1024);
Magic Number,RTools_NTS.Util,StreamTokenizer,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Utilities\RToolsUtil\StreamTokenizer.cs,GetNextChar,The following statement contains a magic number: (c = textReader.Read()) == 13
Magic Number,RTools_NTS.Util,StreamTokenizer,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Utilities\RToolsUtil\StreamTokenizer.cs,GetNextChar,The following statement contains a magic number: c == 10
Magic Number,RTools_NTS.Util,StreamTokenizer,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Utilities\RToolsUtil\StreamTokenizer.cs,NextToken,The following statement contains a magic number: switch(state)                  {                      case NextTokenState.Start:                          // RESET                          state = PickNextState(ctype' thisChar);                          tokenLineNumber = lineNumber;                          break;                        case NextTokenState.Char:                          token = new CharToken((char)prevChar' tokenLineNumber);                          done = true;                          nextTokenSb.Length = 0;                          break;                        case NextTokenState.Word:                          if ((!settings.IsCharType(ctype' CharTypeBits.Word))                              && (!settings.IsCharType(ctype' CharTypeBits.Digit)))                          {                              // end of word' emit                              token = new WordToken(nextTokenSb.ToString()' tokenLineNumber);                              done = true;                              nextTokenSb.Length = 0;                          }                          break;                        case NextTokenState.Whitespace:                          if (!settings.IsCharType(ctype' CharTypeBits.Whitespace)                              || (settings.GrabEol && (thisChar == 10)))                          {                              // end of whitespace' emit                              if (settings.GrabWhitespace)                              {                                  token = new WhitespaceToken(nextTokenSb.ToString()' tokenLineNumber);                                  done = true;                                  nextTokenSb.Length = 0;                              }                              else                              {                                  // RESET                                  nextTokenSb.Length = 0;                                  tokenLineNumber = lineNumber;                                  state = PickNextState(ctype' thisChar);                              }                          }                          break;                        case NextTokenState.EndQuote:                          // we're now 1 char after end of quote                          token = new QuoteToken(nextTokenSb.ToString()' tokenLineNumber);                          done = true;                          nextTokenSb.Length = 0;                          break;                        case NextTokenState.Quote:                          // looking for end quote matching char that started the quote                          if (thisChar == nextTokenSb[0])                          {                              // handle escaped backslashes: count the immediately prior backslashes                              // - even (including 0) means it's not escaped                              // - odd means it is escaped                              int backSlashCount = 0;                              for (int i = nextTokenSb.Length - 1; i >= 0; i--)                              {                                  if (nextTokenSb[ i ] == '\\') backSlashCount++;                                  else break;                              }                                if ((backSlashCount % 2) == 0)                              {                                  state = NextTokenState.EndQuote;                              }                          }                            if ((state != NextTokenState.EndQuote) && (thisChar == Eof))                          {                              if (settings.DoUntermCheck)                              {                                  nextTokenSb.Length = 0;                                  throw new StreamTokenizerUntermQuoteException("Unterminated quote");                              }                                token = new QuoteToken(nextTokenSb.ToString()' tokenLineNumber);                              done = true;                              nextTokenSb.Length = 0;                          }                          break;                        case NextTokenState.MaybeComment:                          if (thisChar == Eof)                          {                              token = new CharToken(nextTokenSb.ToString()' tokenLineNumber);                              done = true;                              nextTokenSb.Length = 0;                          }                          else                          {                              // if we get the right char' we're in a comment                              if (settings.SlashSlashComments && (thisChar == '/'))                                  state = NextTokenState.LineComment;                              else if (settings.SlashStarComments && (thisChar == '*'))                                  state = NextTokenState.BlockComment;                              else                              {                                  token = new CharToken(nextTokenSb.ToString()' tokenLineNumber);                                  done = true;                                  nextTokenSb.Length = 0;                              }                          }                          break;                        case NextTokenState.LineComment:                          if (thisChar == Eof)                          {                              if (settings.GrabComments)                              {                                  token = new CommentToken(nextTokenSb.ToString()' tokenLineNumber);                                  done = true;                                  nextTokenSb.Length = 0;                              }                              else                              {                                  // RESET                                  nextTokenSb.Length = 0;                                  tokenLineNumber = lineNumber;                                  state = PickNextState(ctype' thisChar);                              }                          }                          else                          {                              if (thisChar == '\n')                              {                                  if (settings.GrabComments)                                  {                                      token = new CommentToken(nextTokenSb.ToString()' tokenLineNumber);                                      done = true;                                      nextTokenSb.Length = 0;                                  }                                  else                                  {                                      // RESET                                      nextTokenSb.Length = 0;                                      tokenLineNumber = lineNumber;                                      state = PickNextState(ctype' thisChar);                                  }                              }                          }                          break;                        case NextTokenState.BlockComment:                          if (thisChar == Eof)                          {                              if (settings.DoUntermCheck)                              {                                  nextTokenSb.Length = 0;                                  throw new StreamTokenizerUntermCommentException("Unterminated comment.");                              }                                if (settings.GrabComments)                              {                                  token = new CommentToken(nextTokenSb.ToString()' tokenLineNumber);                                  done = true;                                  nextTokenSb.Length = 0;                              }                              else                              {                                  // RESET                                  nextTokenSb.Length = 0;                                  tokenLineNumber = lineNumber;                                  state = PickNextState(ctype' thisChar);                              }                          }                          else                          {                              if ((thisChar == '/') && (prevChar == '*'))                              {                                  state = NextTokenState.EndBlockComment;                              }                          }                          break;                        // special case for 2-character token termination                      case NextTokenState.EndBlockComment:                          if (settings.GrabComments)                          {                              token = new CommentToken(nextTokenSb.ToString()' tokenLineNumber);                              done = true;                              nextTokenSb.Length = 0;                          }                          else                          {                              // RESET                              nextTokenSb.Length = 0;                              tokenLineNumber = lineNumber;                              state = PickNextState(ctype' thisChar);                          }                          break;                        case NextTokenState.MaybeHex:                          // previous char was 0                          if (thisChar != 'x')                          {                              // back up and try non-hex                              // back up to the 0                              nextTokenSb.Append((char)thisChar);                              backString.Append(nextTokenSb);                              nextTokenSb.Length = 0;                                // reset state and don't choose MaybeNumber state.                              // pull char from backString                              thisChar = backString[0];                              backString.Remove(0' 1);                              state = PickNextState(settings.CharTypes[thisChar]' thisChar'                                  NextTokenState.MaybeHex);                          }                          else state = NextTokenState.HexGot0x;                          break;                        case NextTokenState.HexGot0x:                          if (!settings.IsCharType(ctype' CharTypeBits.HexDigit))                          {                              // got 0x but now a non-hex char                              // back up to the 0                              nextTokenSb.Append((char)thisChar);                              backString.Append(nextTokenSb);                              nextTokenSb.Length = 0;                                // reset state and don't choose MaybeNumber state.                              // pull char from backString                              thisChar = backString[0];                              backString.Remove(0' 1);                              state = PickNextState(settings.CharTypes[thisChar]' thisChar'                                  NextTokenState.MaybeHex);                          }                          else state = NextTokenState.HexNumber;                          break;                        case NextTokenState.HexNumber:                          if (!settings.IsCharType(ctype' CharTypeBits.HexDigit))                          {                              // emit the hex number we've collected                              token = IntToken.ParseHex(nextTokenSb.ToString()' tokenLineNumber);                              done = true;                              nextTokenSb.Length = 0;                          }                          break;                        case NextTokenState.MaybeNumber:                          //                          // Determine whether or not to stop collecting characters for                          // the number parse.  We terminate when it's clear it's not                          // a number or no longer a number.                          //                          bool term = false;                            if (settings.IsCharType(ctype' CharTypeBits.Digit)                              || settings.IsCharType(prevChar' CharTypeBits.Digit)) seenDigit = true;                            // term conditions                          if (thisChar == '.')                          {                              seenDot++;                              if (seenDot > 1) term = true;  // more than one dot' it aint a number                          }                          else if (((thisChar == 'e') || (thisChar == 'E')))                          {                              seenE++;                              if (!seenDigit) term = true;  // e before any digits is bad                              else if (seenE > 1) term = true;  // more than 1 e is bad                              else                              {                                  term = true; // done regardless                                    // scan the exponent' put its characters into                                  // nextTokenSb' if there are any                                  char c;                                  expSb.Clear();                                  expSb.Append((char)thisChar);                                  if (GrabInt(expSb' true' out c))                                  {                                      // we got a good exponent' tack it on                                      nextTokenSb.Append(expSb);                                      thisChar = c; // and continue after the exponent's characters                                  }                              }                          }                          else if (thisChar == Eof) term = true;                              // or a char that can't be in a number                          else if ((!settings.IsCharType(ctype' CharTypeBits.Digit)                              && (thisChar != 'e') && (thisChar != 'E')                              && (thisChar != '-') && (thisChar != '.'))                              || ((thisChar == '+') && (seenE == 0)))                          {                              // it's not a normal number character                              term = true;                          }                          // or a dash not after e                          else if ((thisChar == '-') && (!((prevChar == 'e') || (prevChar == 'E')))) term = true;                            if (term)                          {                              // we are terminating a number' or it wasn't a number                              if (seenDigit)                              {                                  if ((nextTokenSb.IndexOf('.') >= 0)                                      || (nextTokenSb.IndexOf('e') >= 0)                                      || (nextTokenSb.IndexOf('E') >= 0)                                      || (nextTokenSb.Length >= 19) // probably too large for Int64' use float                                      )                                  {                                      token = new FloatToken(nextTokenSb.ToString()' tokenLineNumber);                                  }                                  else                                  {                                      token = new IntToken(nextTokenSb.ToString()' tokenLineNumber);                                  }                                  done = true;                                  nextTokenSb.Length = 0;                              }                              else                              {                                  // -whatever or -.whatever                                  // didn't see any digits' must have gotten here by a leading -                                  // and no digits after it                                  // back up to -' pick next state excluding numbers                                  nextTokenSb.Append((char)thisChar);                                  backString.Append(nextTokenSb);                                  nextTokenSb.Length = 0;                                    // restart on the - and don't choose MaybeNumber state                                  // pull char from backString                                  thisChar = backString[0];                                  backString.Remove(0' 1);                                  state = PickNextState(settings.CharTypes[thisChar]' thisChar'                                      NextTokenState.MaybeNumber);                              }                          }                          break;                        case NextTokenState.Eol:                          // tokenLineNumber - 1 because the newline char is on the previous line                          token = new EolToken(tokenLineNumber - 1);                          done = true;                          nextTokenSb.Length = 0;                          break;                        case NextTokenState.Eof:                          token = new EofToken(tokenLineNumber);                          done = true;                          nextTokenSb.Length = 0;                          return(false);                        case NextTokenState.Invalid:                      default:                          // not a good sign' some unrepresented state?                          return(false);                  }
Magic Number,RTools_NTS.Util,StreamTokenizer,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Utilities\RToolsUtil\StreamTokenizer.cs,NextToken,The following statement contains a magic number: switch(state)                  {                      case NextTokenState.Start:                          // RESET                          state = PickNextState(ctype' thisChar);                          tokenLineNumber = lineNumber;                          break;                        case NextTokenState.Char:                          token = new CharToken((char)prevChar' tokenLineNumber);                          done = true;                          nextTokenSb.Length = 0;                          break;                        case NextTokenState.Word:                          if ((!settings.IsCharType(ctype' CharTypeBits.Word))                              && (!settings.IsCharType(ctype' CharTypeBits.Digit)))                          {                              // end of word' emit                              token = new WordToken(nextTokenSb.ToString()' tokenLineNumber);                              done = true;                              nextTokenSb.Length = 0;                          }                          break;                        case NextTokenState.Whitespace:                          if (!settings.IsCharType(ctype' CharTypeBits.Whitespace)                              || (settings.GrabEol && (thisChar == 10)))                          {                              // end of whitespace' emit                              if (settings.GrabWhitespace)                              {                                  token = new WhitespaceToken(nextTokenSb.ToString()' tokenLineNumber);                                  done = true;                                  nextTokenSb.Length = 0;                              }                              else                              {                                  // RESET                                  nextTokenSb.Length = 0;                                  tokenLineNumber = lineNumber;                                  state = PickNextState(ctype' thisChar);                              }                          }                          break;                        case NextTokenState.EndQuote:                          // we're now 1 char after end of quote                          token = new QuoteToken(nextTokenSb.ToString()' tokenLineNumber);                          done = true;                          nextTokenSb.Length = 0;                          break;                        case NextTokenState.Quote:                          // looking for end quote matching char that started the quote                          if (thisChar == nextTokenSb[0])                          {                              // handle escaped backslashes: count the immediately prior backslashes                              // - even (including 0) means it's not escaped                              // - odd means it is escaped                              int backSlashCount = 0;                              for (int i = nextTokenSb.Length - 1; i >= 0; i--)                              {                                  if (nextTokenSb[ i ] == '\\') backSlashCount++;                                  else break;                              }                                if ((backSlashCount % 2) == 0)                              {                                  state = NextTokenState.EndQuote;                              }                          }                            if ((state != NextTokenState.EndQuote) && (thisChar == Eof))                          {                              if (settings.DoUntermCheck)                              {                                  nextTokenSb.Length = 0;                                  throw new StreamTokenizerUntermQuoteException("Unterminated quote");                              }                                token = new QuoteToken(nextTokenSb.ToString()' tokenLineNumber);                              done = true;                              nextTokenSb.Length = 0;                          }                          break;                        case NextTokenState.MaybeComment:                          if (thisChar == Eof)                          {                              token = new CharToken(nextTokenSb.ToString()' tokenLineNumber);                              done = true;                              nextTokenSb.Length = 0;                          }                          else                          {                              // if we get the right char' we're in a comment                              if (settings.SlashSlashComments && (thisChar == '/'))                                  state = NextTokenState.LineComment;                              else if (settings.SlashStarComments && (thisChar == '*'))                                  state = NextTokenState.BlockComment;                              else                              {                                  token = new CharToken(nextTokenSb.ToString()' tokenLineNumber);                                  done = true;                                  nextTokenSb.Length = 0;                              }                          }                          break;                        case NextTokenState.LineComment:                          if (thisChar == Eof)                          {                              if (settings.GrabComments)                              {                                  token = new CommentToken(nextTokenSb.ToString()' tokenLineNumber);                                  done = true;                                  nextTokenSb.Length = 0;                              }                              else                              {                                  // RESET                                  nextTokenSb.Length = 0;                                  tokenLineNumber = lineNumber;                                  state = PickNextState(ctype' thisChar);                              }                          }                          else                          {                              if (thisChar == '\n')                              {                                  if (settings.GrabComments)                                  {                                      token = new CommentToken(nextTokenSb.ToString()' tokenLineNumber);                                      done = true;                                      nextTokenSb.Length = 0;                                  }                                  else                                  {                                      // RESET                                      nextTokenSb.Length = 0;                                      tokenLineNumber = lineNumber;                                      state = PickNextState(ctype' thisChar);                                  }                              }                          }                          break;                        case NextTokenState.BlockComment:                          if (thisChar == Eof)                          {                              if (settings.DoUntermCheck)                              {                                  nextTokenSb.Length = 0;                                  throw new StreamTokenizerUntermCommentException("Unterminated comment.");                              }                                if (settings.GrabComments)                              {                                  token = new CommentToken(nextTokenSb.ToString()' tokenLineNumber);                                  done = true;                                  nextTokenSb.Length = 0;                              }                              else                              {                                  // RESET                                  nextTokenSb.Length = 0;                                  tokenLineNumber = lineNumber;                                  state = PickNextState(ctype' thisChar);                              }                          }                          else                          {                              if ((thisChar == '/') && (prevChar == '*'))                              {                                  state = NextTokenState.EndBlockComment;                              }                          }                          break;                        // special case for 2-character token termination                      case NextTokenState.EndBlockComment:                          if (settings.GrabComments)                          {                              token = new CommentToken(nextTokenSb.ToString()' tokenLineNumber);                              done = true;                              nextTokenSb.Length = 0;                          }                          else                          {                              // RESET                              nextTokenSb.Length = 0;                              tokenLineNumber = lineNumber;                              state = PickNextState(ctype' thisChar);                          }                          break;                        case NextTokenState.MaybeHex:                          // previous char was 0                          if (thisChar != 'x')                          {                              // back up and try non-hex                              // back up to the 0                              nextTokenSb.Append((char)thisChar);                              backString.Append(nextTokenSb);                              nextTokenSb.Length = 0;                                // reset state and don't choose MaybeNumber state.                              // pull char from backString                              thisChar = backString[0];                              backString.Remove(0' 1);                              state = PickNextState(settings.CharTypes[thisChar]' thisChar'                                  NextTokenState.MaybeHex);                          }                          else state = NextTokenState.HexGot0x;                          break;                        case NextTokenState.HexGot0x:                          if (!settings.IsCharType(ctype' CharTypeBits.HexDigit))                          {                              // got 0x but now a non-hex char                              // back up to the 0                              nextTokenSb.Append((char)thisChar);                              backString.Append(nextTokenSb);                              nextTokenSb.Length = 0;                                // reset state and don't choose MaybeNumber state.                              // pull char from backString                              thisChar = backString[0];                              backString.Remove(0' 1);                              state = PickNextState(settings.CharTypes[thisChar]' thisChar'                                  NextTokenState.MaybeHex);                          }                          else state = NextTokenState.HexNumber;                          break;                        case NextTokenState.HexNumber:                          if (!settings.IsCharType(ctype' CharTypeBits.HexDigit))                          {                              // emit the hex number we've collected                              token = IntToken.ParseHex(nextTokenSb.ToString()' tokenLineNumber);                              done = true;                              nextTokenSb.Length = 0;                          }                          break;                        case NextTokenState.MaybeNumber:                          //                          // Determine whether or not to stop collecting characters for                          // the number parse.  We terminate when it's clear it's not                          // a number or no longer a number.                          //                          bool term = false;                            if (settings.IsCharType(ctype' CharTypeBits.Digit)                              || settings.IsCharType(prevChar' CharTypeBits.Digit)) seenDigit = true;                            // term conditions                          if (thisChar == '.')                          {                              seenDot++;                              if (seenDot > 1) term = true;  // more than one dot' it aint a number                          }                          else if (((thisChar == 'e') || (thisChar == 'E')))                          {                              seenE++;                              if (!seenDigit) term = true;  // e before any digits is bad                              else if (seenE > 1) term = true;  // more than 1 e is bad                              else                              {                                  term = true; // done regardless                                    // scan the exponent' put its characters into                                  // nextTokenSb' if there are any                                  char c;                                  expSb.Clear();                                  expSb.Append((char)thisChar);                                  if (GrabInt(expSb' true' out c))                                  {                                      // we got a good exponent' tack it on                                      nextTokenSb.Append(expSb);                                      thisChar = c; // and continue after the exponent's characters                                  }                              }                          }                          else if (thisChar == Eof) term = true;                              // or a char that can't be in a number                          else if ((!settings.IsCharType(ctype' CharTypeBits.Digit)                              && (thisChar != 'e') && (thisChar != 'E')                              && (thisChar != '-') && (thisChar != '.'))                              || ((thisChar == '+') && (seenE == 0)))                          {                              // it's not a normal number character                              term = true;                          }                          // or a dash not after e                          else if ((thisChar == '-') && (!((prevChar == 'e') || (prevChar == 'E')))) term = true;                            if (term)                          {                              // we are terminating a number' or it wasn't a number                              if (seenDigit)                              {                                  if ((nextTokenSb.IndexOf('.') >= 0)                                      || (nextTokenSb.IndexOf('e') >= 0)                                      || (nextTokenSb.IndexOf('E') >= 0)                                      || (nextTokenSb.Length >= 19) // probably too large for Int64' use float                                      )                                  {                                      token = new FloatToken(nextTokenSb.ToString()' tokenLineNumber);                                  }                                  else                                  {                                      token = new IntToken(nextTokenSb.ToString()' tokenLineNumber);                                  }                                  done = true;                                  nextTokenSb.Length = 0;                              }                              else                              {                                  // -whatever or -.whatever                                  // didn't see any digits' must have gotten here by a leading -                                  // and no digits after it                                  // back up to -' pick next state excluding numbers                                  nextTokenSb.Append((char)thisChar);                                  backString.Append(nextTokenSb);                                  nextTokenSb.Length = 0;                                    // restart on the - and don't choose MaybeNumber state                                  // pull char from backString                                  thisChar = backString[0];                                  backString.Remove(0' 1);                                  state = PickNextState(settings.CharTypes[thisChar]' thisChar'                                      NextTokenState.MaybeNumber);                              }                          }                          break;                        case NextTokenState.Eol:                          // tokenLineNumber - 1 because the newline char is on the previous line                          token = new EolToken(tokenLineNumber - 1);                          done = true;                          nextTokenSb.Length = 0;                          break;                        case NextTokenState.Eof:                          token = new EofToken(tokenLineNumber);                          done = true;                          nextTokenSb.Length = 0;                          return(false);                        case NextTokenState.Invalid:                      default:                          // not a good sign' some unrepresented state?                          return(false);                  }
Magic Number,RTools_NTS.Util,StreamTokenizer,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Utilities\RToolsUtil\StreamTokenizer.cs,NextToken,The following statement contains a magic number: switch(state)                  {                      case NextTokenState.Start:                          // RESET                          state = PickNextState(ctype' thisChar);                          tokenLineNumber = lineNumber;                          break;                        case NextTokenState.Char:                          token = new CharToken((char)prevChar' tokenLineNumber);                          done = true;                          nextTokenSb.Length = 0;                          break;                        case NextTokenState.Word:                          if ((!settings.IsCharType(ctype' CharTypeBits.Word))                              && (!settings.IsCharType(ctype' CharTypeBits.Digit)))                          {                              // end of word' emit                              token = new WordToken(nextTokenSb.ToString()' tokenLineNumber);                              done = true;                              nextTokenSb.Length = 0;                          }                          break;                        case NextTokenState.Whitespace:                          if (!settings.IsCharType(ctype' CharTypeBits.Whitespace)                              || (settings.GrabEol && (thisChar == 10)))                          {                              // end of whitespace' emit                              if (settings.GrabWhitespace)                              {                                  token = new WhitespaceToken(nextTokenSb.ToString()' tokenLineNumber);                                  done = true;                                  nextTokenSb.Length = 0;                              }                              else                              {                                  // RESET                                  nextTokenSb.Length = 0;                                  tokenLineNumber = lineNumber;                                  state = PickNextState(ctype' thisChar);                              }                          }                          break;                        case NextTokenState.EndQuote:                          // we're now 1 char after end of quote                          token = new QuoteToken(nextTokenSb.ToString()' tokenLineNumber);                          done = true;                          nextTokenSb.Length = 0;                          break;                        case NextTokenState.Quote:                          // looking for end quote matching char that started the quote                          if (thisChar == nextTokenSb[0])                          {                              // handle escaped backslashes: count the immediately prior backslashes                              // - even (including 0) means it's not escaped                              // - odd means it is escaped                              int backSlashCount = 0;                              for (int i = nextTokenSb.Length - 1; i >= 0; i--)                              {                                  if (nextTokenSb[ i ] == '\\') backSlashCount++;                                  else break;                              }                                if ((backSlashCount % 2) == 0)                              {                                  state = NextTokenState.EndQuote;                              }                          }                            if ((state != NextTokenState.EndQuote) && (thisChar == Eof))                          {                              if (settings.DoUntermCheck)                              {                                  nextTokenSb.Length = 0;                                  throw new StreamTokenizerUntermQuoteException("Unterminated quote");                              }                                token = new QuoteToken(nextTokenSb.ToString()' tokenLineNumber);                              done = true;                              nextTokenSb.Length = 0;                          }                          break;                        case NextTokenState.MaybeComment:                          if (thisChar == Eof)                          {                              token = new CharToken(nextTokenSb.ToString()' tokenLineNumber);                              done = true;                              nextTokenSb.Length = 0;                          }                          else                          {                              // if we get the right char' we're in a comment                              if (settings.SlashSlashComments && (thisChar == '/'))                                  state = NextTokenState.LineComment;                              else if (settings.SlashStarComments && (thisChar == '*'))                                  state = NextTokenState.BlockComment;                              else                              {                                  token = new CharToken(nextTokenSb.ToString()' tokenLineNumber);                                  done = true;                                  nextTokenSb.Length = 0;                              }                          }                          break;                        case NextTokenState.LineComment:                          if (thisChar == Eof)                          {                              if (settings.GrabComments)                              {                                  token = new CommentToken(nextTokenSb.ToString()' tokenLineNumber);                                  done = true;                                  nextTokenSb.Length = 0;                              }                              else                              {                                  // RESET                                  nextTokenSb.Length = 0;                                  tokenLineNumber = lineNumber;                                  state = PickNextState(ctype' thisChar);                              }                          }                          else                          {                              if (thisChar == '\n')                              {                                  if (settings.GrabComments)                                  {                                      token = new CommentToken(nextTokenSb.ToString()' tokenLineNumber);                                      done = true;                                      nextTokenSb.Length = 0;                                  }                                  else                                  {                                      // RESET                                      nextTokenSb.Length = 0;                                      tokenLineNumber = lineNumber;                                      state = PickNextState(ctype' thisChar);                                  }                              }                          }                          break;                        case NextTokenState.BlockComment:                          if (thisChar == Eof)                          {                              if (settings.DoUntermCheck)                              {                                  nextTokenSb.Length = 0;                                  throw new StreamTokenizerUntermCommentException("Unterminated comment.");                              }                                if (settings.GrabComments)                              {                                  token = new CommentToken(nextTokenSb.ToString()' tokenLineNumber);                                  done = true;                                  nextTokenSb.Length = 0;                              }                              else                              {                                  // RESET                                  nextTokenSb.Length = 0;                                  tokenLineNumber = lineNumber;                                  state = PickNextState(ctype' thisChar);                              }                          }                          else                          {                              if ((thisChar == '/') && (prevChar == '*'))                              {                                  state = NextTokenState.EndBlockComment;                              }                          }                          break;                        // special case for 2-character token termination                      case NextTokenState.EndBlockComment:                          if (settings.GrabComments)                          {                              token = new CommentToken(nextTokenSb.ToString()' tokenLineNumber);                              done = true;                              nextTokenSb.Length = 0;                          }                          else                          {                              // RESET                              nextTokenSb.Length = 0;                              tokenLineNumber = lineNumber;                              state = PickNextState(ctype' thisChar);                          }                          break;                        case NextTokenState.MaybeHex:                          // previous char was 0                          if (thisChar != 'x')                          {                              // back up and try non-hex                              // back up to the 0                              nextTokenSb.Append((char)thisChar);                              backString.Append(nextTokenSb);                              nextTokenSb.Length = 0;                                // reset state and don't choose MaybeNumber state.                              // pull char from backString                              thisChar = backString[0];                              backString.Remove(0' 1);                              state = PickNextState(settings.CharTypes[thisChar]' thisChar'                                  NextTokenState.MaybeHex);                          }                          else state = NextTokenState.HexGot0x;                          break;                        case NextTokenState.HexGot0x:                          if (!settings.IsCharType(ctype' CharTypeBits.HexDigit))                          {                              // got 0x but now a non-hex char                              // back up to the 0                              nextTokenSb.Append((char)thisChar);                              backString.Append(nextTokenSb);                              nextTokenSb.Length = 0;                                // reset state and don't choose MaybeNumber state.                              // pull char from backString                              thisChar = backString[0];                              backString.Remove(0' 1);                              state = PickNextState(settings.CharTypes[thisChar]' thisChar'                                  NextTokenState.MaybeHex);                          }                          else state = NextTokenState.HexNumber;                          break;                        case NextTokenState.HexNumber:                          if (!settings.IsCharType(ctype' CharTypeBits.HexDigit))                          {                              // emit the hex number we've collected                              token = IntToken.ParseHex(nextTokenSb.ToString()' tokenLineNumber);                              done = true;                              nextTokenSb.Length = 0;                          }                          break;                        case NextTokenState.MaybeNumber:                          //                          // Determine whether or not to stop collecting characters for                          // the number parse.  We terminate when it's clear it's not                          // a number or no longer a number.                          //                          bool term = false;                            if (settings.IsCharType(ctype' CharTypeBits.Digit)                              || settings.IsCharType(prevChar' CharTypeBits.Digit)) seenDigit = true;                            // term conditions                          if (thisChar == '.')                          {                              seenDot++;                              if (seenDot > 1) term = true;  // more than one dot' it aint a number                          }                          else if (((thisChar == 'e') || (thisChar == 'E')))                          {                              seenE++;                              if (!seenDigit) term = true;  // e before any digits is bad                              else if (seenE > 1) term = true;  // more than 1 e is bad                              else                              {                                  term = true; // done regardless                                    // scan the exponent' put its characters into                                  // nextTokenSb' if there are any                                  char c;                                  expSb.Clear();                                  expSb.Append((char)thisChar);                                  if (GrabInt(expSb' true' out c))                                  {                                      // we got a good exponent' tack it on                                      nextTokenSb.Append(expSb);                                      thisChar = c; // and continue after the exponent's characters                                  }                              }                          }                          else if (thisChar == Eof) term = true;                              // or a char that can't be in a number                          else if ((!settings.IsCharType(ctype' CharTypeBits.Digit)                              && (thisChar != 'e') && (thisChar != 'E')                              && (thisChar != '-') && (thisChar != '.'))                              || ((thisChar == '+') && (seenE == 0)))                          {                              // it's not a normal number character                              term = true;                          }                          // or a dash not after e                          else if ((thisChar == '-') && (!((prevChar == 'e') || (prevChar == 'E')))) term = true;                            if (term)                          {                              // we are terminating a number' or it wasn't a number                              if (seenDigit)                              {                                  if ((nextTokenSb.IndexOf('.') >= 0)                                      || (nextTokenSb.IndexOf('e') >= 0)                                      || (nextTokenSb.IndexOf('E') >= 0)                                      || (nextTokenSb.Length >= 19) // probably too large for Int64' use float                                      )                                  {                                      token = new FloatToken(nextTokenSb.ToString()' tokenLineNumber);                                  }                                  else                                  {                                      token = new IntToken(nextTokenSb.ToString()' tokenLineNumber);                                  }                                  done = true;                                  nextTokenSb.Length = 0;                              }                              else                              {                                  // -whatever or -.whatever                                  // didn't see any digits' must have gotten here by a leading -                                  // and no digits after it                                  // back up to -' pick next state excluding numbers                                  nextTokenSb.Append((char)thisChar);                                  backString.Append(nextTokenSb);                                  nextTokenSb.Length = 0;                                    // restart on the - and don't choose MaybeNumber state                                  // pull char from backString                                  thisChar = backString[0];                                  backString.Remove(0' 1);                                  state = PickNextState(settings.CharTypes[thisChar]' thisChar'                                      NextTokenState.MaybeNumber);                              }                          }                          break;                        case NextTokenState.Eol:                          // tokenLineNumber - 1 because the newline char is on the previous line                          token = new EolToken(tokenLineNumber - 1);                          done = true;                          nextTokenSb.Length = 0;                          break;                        case NextTokenState.Eof:                          token = new EofToken(tokenLineNumber);                          done = true;                          nextTokenSb.Length = 0;                          return(false);                        case NextTokenState.Invalid:                      default:                          // not a good sign' some unrepresented state?                          return(false);                  }
Magic Number,RTools_NTS.Util,IntToken,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Utilities\RToolsUtil\Token.cs,ParseHex,The following statement contains a magic number: it = new IntToken(Convert.ToInt32(s' 16)' lineNumber);
Magic Number,RTools_NTS.Util,IntToken,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Utilities\RToolsUtil\Token.cs,Parse,The following statement contains a magic number: int[] bases = {16' 2' 8};
Magic Number,RTools_NTS.Util,IntToken,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Utilities\RToolsUtil\Token.cs,Parse,The following statement contains a magic number: int[] bases = {16' 2' 8};
Magic Number,RTools_NTS.Util,IntToken,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Utilities\RToolsUtil\Token.cs,Parse,The following statement contains a magic number: int[] bases = {16' 2' 8};
Missing Default,NetTopologySuite.Algorithm,MinimumBoundingCircle,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Algorithm\MinimumBoundingCircle.cs,GetFarthestPoints,The following switch statement is missing a default case: switch (_extremalPts.Length)              {                  case 0:                      return _input.Factory.CreateLineString();                  case 1:                      return _input.Factory.CreatePoint(_centre);              }
Missing Default,NetTopologySuite.Algorithm,MinimumBoundingCircle,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Algorithm\MinimumBoundingCircle.cs,GetDiameter,The following switch statement is missing a default case: switch (_extremalPts.Length)              {                  case 0:                      return _input.Factory.CreateLineString();                  case 1:                      return _input.Factory.CreatePoint(_centre);              }
Missing Default,NetTopologySuite.Algorithm,MinimumBoundingCircle,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Algorithm\MinimumBoundingCircle.cs,ComputeCentre,The following switch statement is missing a default case: switch (_extremalPts.Length)              {                  case 0:                      _centre = null;                      break;                  case 1:                      _centre = _extremalPts[0];                      break;                  case 2:                      _centre = new Coordinate(                              (_extremalPts[0].X + _extremalPts[1].X) / 2.0'                              (_extremalPts[0].Y + _extremalPts[1].Y) / 2.0                              );                      break;                  case 3:                      _centre = Triangle.Circumcentre(_extremalPts[0]' _extremalPts[1]' _extremalPts[2]);                      break;              }
Missing Default,NetTopologySuite.Geometries,LocationUtility,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Geometries\Location.cs,ToLocationSymbol,The following switch statement is missing a default case: switch (locationValue)              {                  case Location.Exterior:                      return 'e';                  case Location.Boundary:                      return 'b';                  case Location.Interior:                      return 'i';                  case Location.Null:                      return '-';              }
Missing Default,NetTopologySuite.Index.Bintree,Node<T>,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Index\Bintree\Node.cs,CreateSubnode,The following switch statement is missing a default case: switch (index)              {                  case 0:                      min = _interval.Min;                      max = _centre;                      break;                  case 1:                      min = _centre;                      max = _interval.Max;                      break;                      /*                  default:                      break;                       */              }
Missing Default,NetTopologySuite.IO,WKBReader,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\IO\WKBReader.cs,HexToInt,The following switch statement is missing a default case: switch (hex)              {                  case '0':                  case '1':                  case '2':                  case '3':                  case '4':                  case '5':                  case '6':                  case '7':                  case '8':                  case '9':                      return hex - '0';                  case 'A':                  case 'B':                  case 'C':                  case 'D':                  case 'E':                  case 'F':                      return hex - 'A' + 10;                  case 'a':                  case 'b':                  case 'c':                  case 'd':                  case 'e':                  case 'f':                      return hex - 'a' + 10;              }
Missing Default,NetTopologySuite.IO,WKBReader,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\IO\WKBReader.cs,ReadGeometryType,The following switch statement is missing a default case: switch (ordinate)              {                  case 1:                      coordinateSystem = CoordinateSystem.XYZ;                      break;                  case 2:                      coordinateSystem = CoordinateSystem.XYM;                      break;                  case 3:                      coordinateSystem = CoordinateSystem.XYZM;                      break;              }
Missing Default,NetTopologySuite.IO,WKTWriter,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\IO\WKTWriter.cs,WKTWriter,The following switch statement is missing a default case: switch (outputDimension)              {                  case 2:                      _outputOrdinates = Ordinates.XY;                      break;                    case 3:                      _outputOrdinates = Ordinates.XYZ;                      break;                    case 4:                      _outputOrdinates = Ordinates.XYZM;                      break;              }
Missing Default,NetTopologySuite.IO.GML2,GMLReader,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\IO\GML2\GMLReader.cs,ReadCoordinate,The following switch statement is missing a default case: switch (reader.NodeType)                  {                      case XmlNodeType.Element:                          if (IsStartElement(reader' "X"))                          {                              reader.Read(); // Jump to X value                              x = XmlConvert.ToDouble(reader.Value);                          }                          else if (IsStartElement(reader' "Y"))                          {                              reader.Read(); // Jump to Y value                              y = XmlConvert.ToDouble(reader.Value);                          }                          break;                        case XmlNodeType.EndElement:                          if (reader.Name == GMLElements.gmlPrefix + ":coord")                              return new Coordinate(x' y);                          break;                  }
Missing Default,NetTopologySuite.IO.GML2,GMLReader,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\IO\GML2\GMLReader.cs,ReadPoint,The following switch statement is missing a default case: switch (reader.NodeType)                  {                      case XmlNodeType.Element:                          if (IsStartElement(reader' "coord"))                              return Factory.CreatePoint(ReadCoordinate(reader));                          if (IsStartElement(reader' "pos"))                          {                              reader.Read(); // Jump to values                              string[] coords = reader.Value.Split(new[] { ' ' }' StringSplitOptions.RemoveEmptyEntries);                              if (!string.IsNullOrEmpty(numOrdinatesText))                              {                                  int numOrdinates = XmlConvert.ToInt32(numOrdinatesText);                                  Assert.IsTrue(coords.Length == numOrdinates' "srsDimension doen't match number of provided ordinates");                              }                              return Factory.CreatePoint(ReadPosAsCoordinate(coords));                          }                          if (IsStartElement(reader' "coordinates"))                          {                              reader.Read(); // Jump to values                              string[] coords = reader.Value.Split(new[] { ' ' }' StringSplitOptions.RemoveEmptyEntries);                              if (coords.Length != 1)                                  throw new ApplicationException("Should never reach here!");                              var c = ReadCoordinates(coords[0]);                              return Factory.CreatePoint(c);                          }                          break;                  }
Missing Default,NetTopologySuite.IO.GML2,GMLReader,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\IO\GML2\GMLReader.cs,ReadLineString,The following switch statement is missing a default case: switch (reader.NodeType)                  {                      case XmlNodeType.Element:                          if (IsStartElement(reader' "coord"))                          {                              coordinates.Add(ReadCoordinate(reader));                          }                          else if (IsStartElement(reader' "pos"))                          {                              reader.Read();                              string ordinates = reader.ReadContentAsString();                              coordinates.Add(ReadPosAsCoordinate(ordinates.Split(new[] { ' ' }' StringSplitOptions.RemoveEmptyEntries)));                          }                          else if (IsStartElement(reader' "coordinates"))                          {                              reader.Read(); // Jump to values                              string value = reader.Value;                              string cleaned = value.Replace("\n"' " ").Replace("\t"' " ");                              string[] coords = cleaned.Split(new[] { ' ' }' StringSplitOptions.RemoveEmptyEntries);                              foreach (string coord in coords)                              {                                  if (string.IsNullOrEmpty(coord))                                      continue;                                  var c = ReadCoordinates(coord);                                  coordinates.Add(c);                              }                              return Factory.CreateLineString(coordinates.ToArray());                          }                          else if (IsStartElement(reader' "posList"))                          {                              string tmp = reader.GetAttribute("srsDimension");                              if (string.IsNullOrEmpty(tmp)) tmp = "2";                              reader.Read();                              coordinates.AddRange(ReadPosListAsCoordinates(XmlConvert.ToInt32(tmp)' reader.ReadContentAsString().Split(new[] { ' ' }' StringSplitOptions.RemoveEmptyEntries)));                              reader.ReadEndElement();                              return Factory.CreateLineString(coordinates.ToArray());                          }                          break;                        case XmlNodeType.EndElement:                          return Factory.CreateLineString(coordinates.ToArray());                  }
Missing Default,NetTopologySuite.IO.GML2,GMLReader,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\IO\GML2\GMLReader.cs,ReadPolygon,The following switch statement is missing a default case: switch (reader.NodeType)                  {                      case XmlNodeType.Element:                          if (IsStartElement(reader' "outerBoundaryIs") ||                              IsStartElement(reader' "exterior"))                              exterior = ReadLinearRing(reader);// as LinearRing;                          else if (IsStartElement(reader' "innerBoundaryIs") ||                              IsStartElement(reader' "interior"))                              interiors.Add(ReadLinearRing(reader));                          break;                        case XmlNodeType.EndElement:                          string name = reader.Name;                          if (name == "Polygon" ||                              name == GMLElements.gmlPrefix + ":Polygon")                              return Factory.CreatePolygon(exterior' interiors.ToArray());                          break;                  }
Missing Default,NetTopologySuite.IO.GML2,GMLReader,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\IO\GML2\GMLReader.cs,ReadMultiPoint,The following switch statement is missing a default case: switch (reader.NodeType)                  {                      case XmlNodeType.Element:                          if (IsStartElement(reader' "pointMember"))                              points.Add(ReadPoint(reader));                          break;                        case XmlNodeType.EndElement:                          string name = reader.Name;                          if (name == "MultiPoint" ||                              name == GMLElements.gmlPrefix + ":MultiPoint")                              return Factory.CreateMultiPoint(points.ToArray());                          break;                  }
Missing Default,NetTopologySuite.IO.GML2,GMLReader,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\IO\GML2\GMLReader.cs,ReadMultiLineString,The following switch statement is missing a default case: switch (reader.NodeType)                  {                      case XmlNodeType.Element:                          if (IsStartElement(reader' "lineStringMember"))                              lines.Add(ReadLineString(reader));                          break;                        case XmlNodeType.EndElement:                          string name = reader.Name;                          if (name == "MultiLineString" ||                              name == GMLElements.gmlPrefix + ":MultiLineString")                              return Factory.CreateMultiLineString(lines.ToArray());                          break;                  }
Missing Default,NetTopologySuite.IO.GML2,GMLReader,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\IO\GML2\GMLReader.cs,ReadMultiPolygon,The following switch statement is missing a default case: switch (reader.NodeType)                  {                      case XmlNodeType.Element:                          if (IsStartElement(reader' "polygonMember"))                              polygons.Add(ReadPolygon(reader));                          break;                        case XmlNodeType.EndElement:                          string name = reader.Name;                          if (name == "MultiPolygon" ||                              name == GMLElements.gmlPrefix + ":MultiPolygon")                              return Factory.CreateMultiPolygon(polygons.ToArray());                          break;                  }
Missing Default,NetTopologySuite.IO.GML2,GMLReader,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\IO\GML2\GMLReader.cs,ReadGeometryCollection,The following switch statement is missing a default case: switch (reader.NodeType)                  {                      case XmlNodeType.Element:                          if (IsStartElement(reader' "Point"))                              collection.Add(ReadPoint(reader));                          else if (IsStartElement(reader' "LineString"))                              collection.Add(ReadLineString(reader));                          else if (IsStartElement(reader' "Polygon"))                              collection.Add(ReadPolygon(reader));                          else if (IsStartElement(reader' "MultiPoint"))                              collection.Add(ReadMultiPoint(reader));                          else if (IsStartElement(reader' "MultiLineString"))                              collection.Add(ReadMultiLineString(reader));                          else if (IsStartElement(reader' "MultiPolygon"))                              collection.Add(ReadMultiPolygon(reader));                          else if (IsStartElement(reader' "MultiGeometry"))                              collection.Add(ReadGeometryCollection(reader));                          break;                        case XmlNodeType.EndElement:                          string name = reader.Name;                          if (name == "MultiGeometry" ||                              name == GMLElements.gmlPrefix + ":MultiGeometry")                              return Factory.CreateGeometryCollection(collection.ToArray());                          break;                  }
Missing Default,NetTopologySuite.Mathematics,Vector2D,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Mathematics\Vector2D.cs,RotateByQuarterCircle,The following switch statement is missing a default case: switch (nQuad)              {                  case 0:                      return Create(_x' _y);                  case 1:                      return Create(-_y' _x);                  case 2:                      return Create(-_x' -_y);                  case 3:                      return Create(_y' -_x);              }
Missing Default,NetTopologySuite.Noding,SegmentPointComparator,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Noding\SegmentPointComparator.cs,Compare,The following switch statement is missing a default case: switch (octant)              {                  case Octants.Zero:                      return CompareValue(xSign' ySign);                  case Octants.One:                      return CompareValue(ySign' xSign);                  case Octants.Two:                      return CompareValue(ySign' -xSign);                  case Octants.Three:                      return CompareValue(-xSign' ySign);                  case Octants.Four:                      return CompareValue(-xSign' -ySign);                  case Octants.Five:                      return CompareValue(-ySign' -xSign);                  case Octants.Six:                      return CompareValue(-ySign' xSign);                  case Octants.Seven:                      return CompareValue(xSign' -ySign);              }
Missing Default,NetTopologySuite.Operation.Buffer,OffsetCurveBuilder,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Operation\Buffer\OffsetCurveBuilder.cs,ComputePointCurve,The following switch statement is missing a default case: switch (_bufParams.EndCapStyle)              {                  case EndCapStyle.Round:                      segGen.CreateCircle(pt);                      break;                  case EndCapStyle.Square:                      segGen.CreateSquare(pt);                      break;                      // otherwise curve is empty (e.g. for a butt cap);              }
Missing Default,NetTopologySuite.Operation.Buffer,OffsetSegmentGenerator,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Operation\Buffer\OffsetSegmentGenerator.cs,AddLineEndCap,The following switch statement is missing a default case: switch (_bufParams.EndCapStyle)              {                  case EndCapStyle.Round:                      // add offset seg points with a fillet between them                      _segList.AddPt(offsetL.P1);                      AddDirectedFillet(p1' angle + Math.PI / 2' angle - Math.PI / 2' OrientationIndex.Clockwise' _distance);                      _segList.AddPt(offsetR.P1);                      break;                  case EndCapStyle.Flat:                      // only offset segment points are added                      _segList.AddPt(offsetL.P1);                      _segList.AddPt(offsetR.P1);                      break;                  case EndCapStyle.Square:                      // add a square defined by extensions of the offset segment endpoints                      var squareCapSideOffset = new Coordinate();                      squareCapSideOffset.X = Math.Abs(_distance) * Math.Cos(angle);                      squareCapSideOffset.Y = Math.Abs(_distance) * Math.Sin(angle);                        var squareCapLOffset = new Coordinate(                          offsetL.P1.X + squareCapSideOffset.X'                          offsetL.P1.Y + squareCapSideOffset.Y);                      var squareCapROffset = new Coordinate(                          offsetR.P1.X + squareCapSideOffset.X'                          offsetR.P1.Y + squareCapSideOffset.Y);                      _segList.AddPt(squareCapLOffset);                      _segList.AddPt(squareCapROffset);                      break;              }
Missing Default,NetTopologySuite.Operation.Buffer,OldOffsetCurveBuilder,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Operation\Buffer\OldOffsetCurveBuilder.cs,GetLineCurve,The following switch statement is missing a default case: switch (_bufParams.EndCapStyle)                  {                      case EndCapStyle.Round:                          AddCircle(inputPts[0]' distance);                          break;                      case EndCapStyle.Square:                          AddSquare(inputPts[0]' distance);                          break;                      // default is for buffer to be empty (e.g. for a butt line cap);                  }
Missing Default,NetTopologySuite.Operation.Buffer,OldOffsetCurveBuilder,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Operation\Buffer\OldOffsetCurveBuilder.cs,AddLineEndCap,The following switch statement is missing a default case: switch (_bufParams.EndCapStyle)              {                  case EndCapStyle.Round:                      // add offset seg points with a fillet between them                      _vertexList.AddPt(offsetL.P1);                      AddFillet(p1' angle + Math.PI / 2' angle - Math.PI / 2' OrientationIndex.Clockwise' _distance);                      _vertexList.AddPt(offsetR.P1);                      break;                  case EndCapStyle.Flat:                      // only offset segment points are added                      _vertexList.AddPt(offsetL.P1);                      _vertexList.AddPt(offsetR.P1);                      break;                  case EndCapStyle.Square:                      // add a square defined by extensions of the offset segment endpoints                      var squareCapSideOffset = new Coordinate();                      squareCapSideOffset.X = Math.Abs(_distance) * Math.Cos(angle);                      squareCapSideOffset.Y = Math.Abs(_distance) * Math.Sin(angle);                        var squareCapLOffset = new Coordinate(                          offsetL.P1.X + squareCapSideOffset.X'                          offsetL.P1.Y + squareCapSideOffset.Y);                      var squareCapROffset = new Coordinate(                          offsetR.P1.X + squareCapSideOffset.X'                          offsetR.P1.Y + squareCapSideOffset.Y);                      _vertexList.AddPt(squareCapLOffset);                      _vertexList.AddPt(squareCapROffset);                      break;              }
Missing Default,NetTopologySuite.Operation.Overlay,OverlayOp,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Operation\Overlay\OverlayOp.cs,CreateEmptyResult,The following switch statement is missing a default case: switch (ResultDimension(overlayOpCode' a' b))              {                  case Dimension.False:                      result = geomFact.CreateGeometryCollection();                      break;                  case Dimension.Point:                      result = geomFact.CreatePoint();                      break;                  case Dimension.Curve:                      result = geomFact.CreateLineString();                      break;                  case Dimension.Surface:                      result = geomFact.CreatePolygon();                      break;              }
Missing Default,NetTopologySuite.Operation.Overlay,OverlayOp,C:\research\architectureSmells\repos\NetTopologySuite_NetTopologySuite\src\NetTopologySuite\Operation\Overlay\OverlayOp.cs,ResultDimension,The following switch statement is missing a default case: switch (opCode)              {                  case SpatialFunction.Intersection:                      resultDimension = Math.Min(dim0' dim1);                      break;                  case SpatialFunction.Union:                      resultDimension = Math.Max(dim0' dim1);                      break;                  case SpatialFunction.Difference:                      resultDimension = dim0;                      break;                  case SpatialFunction.SymDifference:                      /**                       * This result is chosen because                       * <pre>                       * SymDiff = Union(Diff(A' B)' Diff(B' A)                       * </pre>                       * and Union has the dimension of the highest-dimension argument.                       */                      resultDimension = Math.Max(dim0' dim1);                      break;              }
