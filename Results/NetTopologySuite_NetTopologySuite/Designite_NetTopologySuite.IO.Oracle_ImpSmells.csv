Implementation smell,Namespace,Class,File,Method,Description
Complex Method,NetTopologySuite.IO,OracleGeometryWriter,C:\repos\NetTopologySuite_NetTopologySuite\NetTopologySuite.IO\NetTopologySuite.IO.Oracle\OracleGeometryWriter.cs,IsRectangle,Cyclomatic complexity of the method is 8
Complex Method,NetTopologySuite.IO,OracleGeometryWriter,C:\repos\NetTopologySuite_NetTopologySuite\NetTopologySuite.IO\NetTopologySuite.IO.Oracle\OracleGeometryWriter.cs,Template,Cyclomatic complexity of the method is 9
Long Parameter List,NetTopologySuite.IO,OracleGeometryReader,C:\repos\NetTopologySuite_NetTopologySuite\NetTopologySuite.IO\NetTopologySuite.IO.Oracle\OracleGeometryReader.cs,CreateCollection,The method has 6 parameters. Parameters: dim' lrs' elemInfo' elemIndex' coords' numGeom
Long Parameter List,NetTopologySuite.IO,OracleGeometryReader,C:\repos\NetTopologySuite_NetTopologySuite\NetTopologySuite.IO\NetTopologySuite.IO.Oracle\OracleGeometryReader.cs,CreateMultiPolygon,The method has 6 parameters. Parameters: dim' lrs' elemInfo' elemIndex' coords' numGeom
Long Parameter List,NetTopologySuite.IO,OracleGeometryReader,C:\repos\NetTopologySuite_NetTopologySuite\NetTopologySuite.IO\NetTopologySuite.IO.Oracle\OracleGeometryReader.cs,CreateMultiLine,The method has 6 parameters. Parameters: dim' lrs' elemInfo' elemIndex' coords' numGeom
Long Parameter List,NetTopologySuite.IO,OracleGeometryReader,C:\repos\NetTopologySuite_NetTopologySuite\NetTopologySuite.IO\NetTopologySuite.IO.Oracle\OracleGeometryReader.cs,CreateMultiPoint,The method has 5 parameters. Parameters: dim' lrs' elemInfo' elemIndex' coords
Long Parameter List,NetTopologySuite.IO,OracleGeometryReader,C:\repos\NetTopologySuite_NetTopologySuite\NetTopologySuite.IO\NetTopologySuite.IO.Oracle\OracleGeometryReader.cs,CreatePolygon,The method has 5 parameters. Parameters: dim' lrs' elemInfo' elemIndex' coords
Long Parameter List,NetTopologySuite.IO,OracleGeometryReader,C:\repos\NetTopologySuite_NetTopologySuite\NetTopologySuite.IO\NetTopologySuite.IO.Oracle\OracleGeometryReader.cs,CreateLinearRing,The method has 5 parameters. Parameters: dim' lrs' elemInfo' elemIndex' coords
Long Parameter List,NetTopologySuite.IO,OracleGeometryReader,C:\repos\NetTopologySuite_NetTopologySuite\NetTopologySuite.IO\NetTopologySuite.IO.Oracle\OracleGeometryReader.cs,CreateLine,The method has 5 parameters. Parameters: dim' lrs' elemInfo' elemIndex' coords
Long Parameter List,NetTopologySuite.IO,OracleGeometryReader,C:\repos\NetTopologySuite_NetTopologySuite\NetTopologySuite.IO\NetTopologySuite.IO.Oracle\OracleGeometryReader.cs,CreatePoint,The method has 5 parameters. Parameters: dim' lrs' elemInfo' elemIndex' coords
Complex Conditional,NetTopologySuite.IO,OracleGeometryReader,C:\repos\NetTopologySuite_NetTopologySuite\NetTopologySuite.IO\NetTopologySuite.IO.Oracle\OracleGeometryReader.cs,Create,The conditional expression  "lrs == 0 && geomTemplate == 1 && point != null && elemInfo == null"  is complex.
Complex Conditional,NetTopologySuite.IO,OracleGeometryReader,C:\repos\NetTopologySuite_NetTopologySuite\NetTopologySuite.IO\NetTopologySuite.IO.Oracle\OracleGeometryReader.cs,Coordinates,The conditional expression  "(dim == 2) && (lrs == 0) && (gtemplate == 01) && (ordinates.Length == 3)"  is complex.
Complex Conditional,NetTopologySuite.IO,OracleGeometryReader,C:\repos\NetTopologySuite_NetTopologySuite\NetTopologySuite.IO\NetTopologySuite.IO.Oracle\OracleGeometryReader.cs,Coordinates,The conditional expression  "(len == 0 && ordinates.Length != 0) || (len != 0 && ((ordinates.Length%len) != 0))"  is complex.
Complex Conditional,NetTopologySuite.IO,OracleGeometryWriter,C:\repos\NetTopologySuite_NetTopologySuite\NetTopologySuite.IO\NetTopologySuite.IO.Oracle\OracleGeometryWriter.cs,IsRectangle,The conditional expression  "(coords[0] == null) || (coords[1] == null) || (coords[2] == null)                  || (coords[3] == null)"  is complex.
Complex Conditional,NetTopologySuite.IO,OracleGeometryWriter,C:\repos\NetTopologySuite_NetTopologySuite\NetTopologySuite.IO\NetTopologySuite.IO.Oracle\OracleGeometryWriter.cs,IsRectangle,The conditional expression  "(x1 == x4) && (y1 == y2) && (x3 == x2) && (y3 == y4)"  is complex.
Complex Conditional,NetTopologySuite.IO,OracleGeometryWriter,C:\repos\NetTopologySuite_NetTopologySuite\NetTopologySuite.IO\NetTopologySuite.IO.Oracle\OracleGeometryWriter.cs,IsRectangle,The conditional expression  "(x1 == x2) && (y1 == y4) && (x3 == x4) && (y3 == y2)"  is complex.
Magic Number,NetTopologySuite.IO,OracleGeometryReader,C:\repos\NetTopologySuite_NetTopologySuite\NetTopologySuite.IO\NetTopologySuite.IO.Oracle\OracleGeometryReader.cs,Create,The following statement contains a magic number: int lrs = (gType%1000)/100;
Magic Number,NetTopologySuite.IO,OracleGeometryReader,C:\repos\NetTopologySuite_NetTopologySuite\NetTopologySuite.IO\NetTopologySuite.IO.Oracle\OracleGeometryReader.cs,Create,The following statement contains a magic number: int lrs = (gType%1000)/100;
Magic Number,NetTopologySuite.IO,OracleGeometryReader,C:\repos\NetTopologySuite_NetTopologySuite\NetTopologySuite.IO\NetTopologySuite.IO.Oracle\OracleGeometryReader.cs,Create,The following statement contains a magic number: if (_dimension != NullDimension)              {                  dim = _dimension;              }              else              {                  dim = Math.Min(gType/1000' 3);              }
Magic Number,NetTopologySuite.IO,OracleGeometryReader,C:\repos\NetTopologySuite_NetTopologySuite\NetTopologySuite.IO\NetTopologySuite.IO.Oracle\OracleGeometryReader.cs,Create,The following statement contains a magic number: if (_dimension != NullDimension)              {                  dim = _dimension;              }              else              {                  dim = Math.Min(gType/1000' 3);              }
Magic Number,NetTopologySuite.IO,OracleGeometryReader,C:\repos\NetTopologySuite_NetTopologySuite\NetTopologySuite.IO\NetTopologySuite.IO.Oracle\OracleGeometryReader.cs,Create,The following statement contains a magic number: if (dim < 2)              {                  throw new ArgumentException("Dimension D:" + dim + " is not valid for JTS. " +                                              "Either specify a dimension or use Oracle Locator Version 9i or later");              }
Magic Number,NetTopologySuite.IO,OracleGeometryReader,C:\repos\NetTopologySuite_NetTopologySuite\NetTopologySuite.IO\NetTopologySuite.IO.Oracle\OracleGeometryReader.cs,Create,The following statement contains a magic number: int geomTemplate = gType - (dim*1000) - (lrs*100);
Magic Number,NetTopologySuite.IO,OracleGeometryReader,C:\repos\NetTopologySuite_NetTopologySuite\NetTopologySuite.IO\NetTopologySuite.IO.Oracle\OracleGeometryReader.cs,Create,The following statement contains a magic number: int geomTemplate = gType - (dim*1000) - (lrs*100);
Magic Number,NetTopologySuite.IO,OracleGeometryReader,C:\repos\NetTopologySuite_NetTopologySuite\NetTopologySuite.IO\NetTopologySuite.IO.Oracle\OracleGeometryReader.cs,Create,The following statement contains a magic number: if (lrs == 0 && geomTemplate == 1 && point != null && elemInfo == null)              {                  // Single Coordinate Type Optimization                  Debug.Assert(point.X != null' "point.X != null");                  Debug.Assert(point.Y != null' "point.Y != null");                  if (dim == 2)                  {                      coords = Coordinates(dim' lrs' geomTemplate' new[] { point.X.Value' point.Y.Value });                  }                  else                  {                      Debug.Assert(point.Z != null' "point.Z != null");                      coords = Coordinates(dim' lrs' geomTemplate'                                           new[] {point.X.Value' point.Y.Value' point.Z.Value});                  }                  elemInfo = new Decimal[] {1' (Int32) SdoEType.Coordinate' 1};              }              else              {                  coords = Coordinates(dim' lrs' geomTemplate' ordinates);              }
Magic Number,NetTopologySuite.IO,OracleGeometryReader,C:\repos\NetTopologySuite_NetTopologySuite\NetTopologySuite.IO\NetTopologySuite.IO.Oracle\OracleGeometryReader.cs,Coordinates,The following statement contains a magic number: if ((dim == 2) && (lrs == 0) && (gtemplate == 01) && (ordinates.Length == 3))              {                  var pt = new List<Coordinate>(1)                               {                                   new Coordinate((Double) ordinates[0]' (Double) ordinates[1]'                                                  (Double) ordinates[2])                               };                  return pt;              }
Magic Number,NetTopologySuite.IO,OracleGeometryReader,C:\repos\NetTopologySuite_NetTopologySuite\NetTopologySuite.IO\NetTopologySuite.IO.Oracle\OracleGeometryReader.cs,Coordinates,The following statement contains a magic number: if ((dim == 2) && (lrs == 0) && (gtemplate == 01) && (ordinates.Length == 3))              {                  var pt = new List<Coordinate>(1)                               {                                   new Coordinate((Double) ordinates[0]' (Double) ordinates[1]'                                                  (Double) ordinates[2])                               };                  return pt;              }
Magic Number,NetTopologySuite.IO,OracleGeometryReader,C:\repos\NetTopologySuite_NetTopologySuite\NetTopologySuite.IO\NetTopologySuite.IO.Oracle\OracleGeometryReader.cs,Coordinates,The following statement contains a magic number: if ((dim == 2) && (lrs == 0) && (gtemplate == 01) && (ordinates.Length == 3))              {                  var pt = new List<Coordinate>(1)                               {                                   new Coordinate((Double) ordinates[0]' (Double) ordinates[1]'                                                  (Double) ordinates[2])                               };                  return pt;              }
Magic Number,NetTopologySuite.IO,OracleGeometryReader,C:\repos\NetTopologySuite_NetTopologySuite\NetTopologySuite.IO\NetTopologySuite.IO.Oracle\OracleGeometryReader.cs,Coordinates,The following statement contains a magic number: for (int i = 0; i < length; i++)              {                  int offset = i*len;                  switch (len)                  {                      case 2:                          pts.Add(new Coordinate((Double) ordinates[offset]' (Double) ordinates[offset + 1]' Double.NaN));                          break;                      case 3:                          pts.Add(new Coordinate((Double) ordinates[offset]' (Double) ordinates[offset + 1]'                                                 (Double) ordinates[offset + 2]));                          break;                  }                    //// in the future change this condition to include ignored dimensions from mask array                  //for (; j < actualDim && j < dim; j++)                  //{                  //    cs.setOrdinate(i' j' ordinates[i * len + j]);                  //    // may not always want to inc. j when we have a mask array                  //}                  ////// in the future change this condition to include ignored dimensions from mask array                  ////for (int d = j; j < actualDim && (j - d) < lrs; j++)                  ////{                  ////    cs.setOrdinate(i' j' ordinates[i * len + j]);                  ////    // may not always want to inc. j when we have a mask array                  ////}              }
Magic Number,NetTopologySuite.IO,OracleGeometryReader,C:\repos\NetTopologySuite_NetTopologySuite\NetTopologySuite.IO\NetTopologySuite.IO.Oracle\OracleGeometryReader.cs,Coordinates,The following statement contains a magic number: for (int i = 0; i < length; i++)              {                  int offset = i*len;                  switch (len)                  {                      case 2:                          pts.Add(new Coordinate((Double) ordinates[offset]' (Double) ordinates[offset + 1]' Double.NaN));                          break;                      case 3:                          pts.Add(new Coordinate((Double) ordinates[offset]' (Double) ordinates[offset + 1]'                                                 (Double) ordinates[offset + 2]));                          break;                  }                    //// in the future change this condition to include ignored dimensions from mask array                  //for (; j < actualDim && j < dim; j++)                  //{                  //    cs.setOrdinate(i' j' ordinates[i * len + j]);                  //    // may not always want to inc. j when we have a mask array                  //}                  ////// in the future change this condition to include ignored dimensions from mask array                  ////for (int d = j; j < actualDim && (j - d) < lrs; j++)                  ////{                  ////    cs.setOrdinate(i' j' ordinates[i * len + j]);                  ////    // may not always want to inc. j when we have a mask array                  ////}              }
Magic Number,NetTopologySuite.IO,OracleGeometryReader,C:\repos\NetTopologySuite_NetTopologySuite\NetTopologySuite.IO\NetTopologySuite.IO.Oracle\OracleGeometryReader.cs,Coordinates,The following statement contains a magic number: for (int i = 0; i < length; i++)              {                  int offset = i*len;                  switch (len)                  {                      case 2:                          pts.Add(new Coordinate((Double) ordinates[offset]' (Double) ordinates[offset + 1]' Double.NaN));                          break;                      case 3:                          pts.Add(new Coordinate((Double) ordinates[offset]' (Double) ordinates[offset + 1]'                                                 (Double) ordinates[offset + 2]));                          break;                  }                    //// in the future change this condition to include ignored dimensions from mask array                  //for (; j < actualDim && j < dim; j++)                  //{                  //    cs.setOrdinate(i' j' ordinates[i * len + j]);                  //    // may not always want to inc. j when we have a mask array                  //}                  ////// in the future change this condition to include ignored dimensions from mask array                  ////for (int d = j; j < actualDim && (j - d) < lrs; j++)                  ////{                  ////    cs.setOrdinate(i' j' ordinates[i * len + j]);                  ////    // may not always want to inc. j when we have a mask array                  ////}              }
Magic Number,NetTopologySuite.IO,OracleGeometryReader,C:\repos\NetTopologySuite_NetTopologySuite\NetTopologySuite.IO\NetTopologySuite.IO.Oracle\OracleGeometryReader.cs,CreateCollection,The following statement contains a magic number: int endTriplet = (numGeom != -1) ? elemIndex + numGeom : elemInfo.Length/3 + 1;
Magic Number,NetTopologySuite.IO,OracleGeometryReader,C:\repos\NetTopologySuite_NetTopologySuite\NetTopologySuite.IO\NetTopologySuite.IO.Oracle\OracleGeometryReader.cs,CreateMultiPolygon,The following statement contains a magic number: if (interpretation != 1 && interpretation != 3)              {                  return null;              }
Magic Number,NetTopologySuite.IO,OracleGeometryReader,C:\repos\NetTopologySuite_NetTopologySuite\NetTopologySuite.IO\NetTopologySuite.IO.Oracle\OracleGeometryReader.cs,CreateMultiPolygon,The following statement contains a magic number: int endTriplet = (numGeom != -1) ? elemIndex + numGeom : (elemInfo.Length/3) + 1;
Magic Number,NetTopologySuite.IO,OracleGeometryReader,C:\repos\NetTopologySuite_NetTopologySuite\NetTopologySuite.IO\NetTopologySuite.IO.Oracle\OracleGeometryReader.cs,CreateMultiLine,The following statement contains a magic number: int endTriplet = (numGeom != -1) ? (elemIndex + numGeom) : (elemInfo.Length/3);
Magic Number,NetTopologySuite.IO,OracleGeometryReader,C:\repos\NetTopologySuite_NetTopologySuite\NetTopologySuite.IO\NetTopologySuite.IO.Oracle\OracleGeometryReader.cs,CreatePolygon,The following statement contains a magic number: if (interpretation != 1 && interpretation != 3)              {                  return null;              }
Magic Number,NetTopologySuite.IO,OracleGeometryReader,C:\repos\NetTopologySuite_NetTopologySuite\NetTopologySuite.IO\NetTopologySuite.IO.Oracle\OracleGeometryReader.cs,CreateLinearRing,The following statement contains a magic number: if (interpretation != 1 && interpretation != 3)              {                  return null;              }
Magic Number,NetTopologySuite.IO,OracleGeometryReader,C:\repos\NetTopologySuite_NetTopologySuite\NetTopologySuite.IO\NetTopologySuite.IO.Oracle\OracleGeometryReader.cs,CreateLinearRing,The following statement contains a magic number: if (interpretation == 1)              {                  ring = new LinearRing(ToPointArray(SubList(coords' start' end)));              }              else              {                  // interpretation == 3                  // rectangle does not maintain measures                  List<Coordinate> pts = new List<Coordinate>(5);                  List<Coordinate> ptssrc = SubList(coords' start' end);                  Coordinate min = ptssrc[0];                  Coordinate max = ptssrc[1];                  pts.AddRange(new[]                                   {                                       min' new Coordinate(max.X' min.Y)' max' new Coordinate(min.X' max.Y) ' min                                   });                                ring = _factory.CreateLinearRing(pts.ToArray());              }
Magic Number,NetTopologySuite.IO,OracleGeometryReader,C:\repos\NetTopologySuite_NetTopologySuite\NetTopologySuite.IO\NetTopologySuite.IO.Oracle\OracleGeometryReader.cs,EType,The following statement contains a magic number: if (((tripletIndex*3) + 1) >= elemInfo.Length)              {                  return SdoEType.Unknown;              }
Magic Number,NetTopologySuite.IO,OracleGeometryReader,C:\repos\NetTopologySuite_NetTopologySuite\NetTopologySuite.IO\NetTopologySuite.IO.Oracle\OracleGeometryReader.cs,EType,The following statement contains a magic number: return (SdoEType) elemInfo[(tripletIndex*3) + 1];
Magic Number,NetTopologySuite.IO,OracleGeometryReader,C:\repos\NetTopologySuite_NetTopologySuite\NetTopologySuite.IO\NetTopologySuite.IO.Oracle\OracleGeometryReader.cs,Interpretation,The following statement contains a magic number: if (((tripletIndex*3) + 2) >= elemInfo.Length)              {                  return -1;              }
Magic Number,NetTopologySuite.IO,OracleGeometryReader,C:\repos\NetTopologySuite_NetTopologySuite\NetTopologySuite.IO\NetTopologySuite.IO.Oracle\OracleGeometryReader.cs,Interpretation,The following statement contains a magic number: if (((tripletIndex*3) + 2) >= elemInfo.Length)              {                  return -1;              }
Magic Number,NetTopologySuite.IO,OracleGeometryReader,C:\repos\NetTopologySuite_NetTopologySuite\NetTopologySuite.IO\NetTopologySuite.IO.Oracle\OracleGeometryReader.cs,Interpretation,The following statement contains a magic number: return (Int32) elemInfo[(tripletIndex*3) + 2];
Magic Number,NetTopologySuite.IO,OracleGeometryReader,C:\repos\NetTopologySuite_NetTopologySuite\NetTopologySuite.IO\NetTopologySuite.IO.Oracle\OracleGeometryReader.cs,Interpretation,The following statement contains a magic number: return (Int32) elemInfo[(tripletIndex*3) + 2];
Magic Number,NetTopologySuite.IO,OracleGeometryReader,C:\repos\NetTopologySuite_NetTopologySuite\NetTopologySuite.IO\NetTopologySuite.IO.Oracle\OracleGeometryReader.cs,StartingOffset,The following statement contains a magic number: if (((tripletIndex*3) + 0) >= elemInfo.Length)              {                  return -1;              }
Magic Number,NetTopologySuite.IO,OracleGeometryReader,C:\repos\NetTopologySuite_NetTopologySuite\NetTopologySuite.IO\NetTopologySuite.IO.Oracle\OracleGeometryReader.cs,StartingOffset,The following statement contains a magic number: return (Int32) elemInfo[(tripletIndex*3) + 0];
Magic Number,NetTopologySuite.IO,OracleGeometryWriter,C:\repos\NetTopologySuite_NetTopologySuite\NetTopologySuite.IO\NetTopologySuite.IO.Oracle\OracleGeometryWriter.cs,coordinates,The following statement contains a magic number: switch (Template(geom)) {            case SdoGTemplate.Coordinate:              AddCoordinates(list' ((IPoint)geom).CoordinateSequence);              return;          case SdoGTemplate.Line:              AddCoordinates(list' ((ILineString)geom).CoordinateSequence);              return;          case SdoGTemplate.Polygon:              switch (ElemInfoInterpretation(geom'SdoEType.PolygonExterior)) {              case 3:                  var e = geom.EnvelopeInternal;                  list.Add(new[] { e.MinX' e.MinY });                  list.Add(new[] { e.MaxX' e.MaxY });                  return;              case 1:              	var polygon = (IPolygon) geom;                  int holes = polygon.NumInteriorRings;                                    // check outer ring's direction                  var ring = polygon.ExteriorRing.CoordinateSequence;                  if (!Algorithm.CGAlgorithms.IsCCW(ring.ToCoordinateArray())) {                      ring = reverse(polygon.Factory.CoordinateSequenceFactory' ring);                   }                  AddCoordinates(list'ring);                    for (int i = 0; i < holes; i++) {                  	// check inner ring's direction                  	ring = polygon.InteriorRings[i].CoordinateSequence;                  	if (Algorithm.CGAlgorithms.IsCCW(ring.ToCoordinateArray())) {                          ring = reverse(polygon.Factory.CoordinateSequenceFactory' ring);                       }                                            AddCoordinates(list'ring);                  }                  return;              }              break; // interpretations 2'4 not supported          case SdoGTemplate.MultiPoint:          case SdoGTemplate.MultiLine:          case SdoGTemplate.MultiPolygon:          case SdoGTemplate.Collection:              for (int i = 0; i < geom.NumGeometries; i++) {                  coordinates(list'geom.GetGeometryN(i));              }              return;          }
Magic Number,NetTopologySuite.IO,OracleGeometryWriter,C:\repos\NetTopologySuite_NetTopologySuite\NetTopologySuite.IO\NetTopologySuite.IO.Oracle\OracleGeometryWriter.cs,ElemInfo,The following statement contains a magic number: switch (gtype - ((int)gtype/100) * 100) { // removes right two digits          case SdoGTemplate.Coordinate:              addInt(elemInfoList' sOffSet);              addInt(elemInfoList' (int)SdoEType.Coordinate);              addInt(elemInfoList' 1); // INTERPRETATION single point                return;            case SdoGTemplate.MultiPoint:              var points = (IMultiPoint) geom;                addInt(elemInfoList' sOffSet);              addInt(elemInfoList' (int)SdoEType.Coordinate);              addInt(elemInfoList' ElemInfoInterpretation(points' SdoEType.Coordinate));                return;            case SdoGTemplate.Line:              addInt(elemInfoList' sOffSet);              addInt(elemInfoList' (int)SdoEType.Line);              addInt(elemInfoList' 1); // INTERPRETATION straight edges                    return;            case SdoGTemplate.MultiLine:          	var lines = (IMultiLineString) geom;              ILineString line;              int offset = sOffSet;              int dim = (int)gtype/1000;              int len = dim + ((int)gtype-dim*1000)/100;                for (int i = 0; i < lines.NumGeometries; i++) {                  line = (ILineString) lines.GetGeometryN(i);                  addInt(elemInfoList' offset);                  addInt(elemInfoList' (int)SdoEType.Line);                  addInt(elemInfoList' 1); // INTERPRETATION straight edges                    offset += (line.NumPoints * len);              }                return;            case SdoGTemplate.Polygon:          	var polygon = (IPolygon)geom;              int holes = polygon.NumInteriorRings;                if (holes == 0) {                  addInt(elemInfoList' sOffSet);                  addInt(elemInfoList' (int)ElemInfoEType(polygon));                  addInt(elemInfoList' ElemInfoInterpretation(polygon' SdoEType.PolygonExterior));                  return;              }                dim = (int)gtype/1000;              len = dim + ((int)gtype-dim*1000)/100;              offset = sOffSet;              ILineString ring;                ring = polygon.ExteriorRing;              addInt(elemInfoList' offset);              addInt(elemInfoList' (int)ElemInfoEType(polygon));              addInt(elemInfoList' ElemInfoInterpretation(polygon' SdoEType.PolygonExterior));              offset += (ring.NumPoints * len);                for (int i = 1; i <= holes; i++) {                  ring = polygon.GetInteriorRingN(i - 1);                  addInt(elemInfoList' offset);                  addInt(elemInfoList' (int)SdoEType.PolygonInterior);                  addInt(elemInfoList' ElemInfoInterpretation(ring' SdoEType.PolygonInterior));                  offset += (ring.NumPoints * len);              }                return;            case SdoGTemplate.MultiPolygon:          	var polys = (IMultiPolygon) geom;              IPolygon poly;              offset = sOffSet;                dim = (int)gtype/1000;              len = dim + ((int)gtype-dim*1000)/100;                for (int i = 0; i < polys.NumGeometries; i++) {                  poly = (IPolygon) polys.GetGeometryN(i);                  ElemInfo(elemInfoList' poly' offset' GType(poly));                  if( IsRectangle( poly )){                      offset += (2 * len);                                  }                  else {                      offset += (poly.NumPoints * len);                                  }                          }                return;            case SdoGTemplate.Collection:          	var geoms = (IGeometryCollection) geom;              offset = sOffSet;              dim = (int)gtype/1000;              len = dim + ((int)gtype-dim*1000)/100;                for (int i = 0; i < geoms.NumGeometries; i++) {                  geom = geoms.GetGeometryN(i);                  // MD  20/3/07 modified to provide gType of component geometry                  ElemInfo(elemInfoList' geom' offset' GType(geom));                  if( geom is IPolygon && IsRectangle( (IPolygon) geom )){                      offset += (2 * len);                                  }                  else {                      offset += (geom.NumPoints * len);                                  }                                      }                return;          }
Magic Number,NetTopologySuite.IO,OracleGeometryWriter,C:\repos\NetTopologySuite_NetTopologySuite\NetTopologySuite.IO\NetTopologySuite.IO.Oracle\OracleGeometryWriter.cs,ElemInfo,The following statement contains a magic number: switch (gtype - ((int)gtype/100) * 100) { // removes right two digits          case SdoGTemplate.Coordinate:              addInt(elemInfoList' sOffSet);              addInt(elemInfoList' (int)SdoEType.Coordinate);              addInt(elemInfoList' 1); // INTERPRETATION single point                return;            case SdoGTemplate.MultiPoint:              var points = (IMultiPoint) geom;                addInt(elemInfoList' sOffSet);              addInt(elemInfoList' (int)SdoEType.Coordinate);              addInt(elemInfoList' ElemInfoInterpretation(points' SdoEType.Coordinate));                return;            case SdoGTemplate.Line:              addInt(elemInfoList' sOffSet);              addInt(elemInfoList' (int)SdoEType.Line);              addInt(elemInfoList' 1); // INTERPRETATION straight edges                    return;            case SdoGTemplate.MultiLine:          	var lines = (IMultiLineString) geom;              ILineString line;              int offset = sOffSet;              int dim = (int)gtype/1000;              int len = dim + ((int)gtype-dim*1000)/100;                for (int i = 0; i < lines.NumGeometries; i++) {                  line = (ILineString) lines.GetGeometryN(i);                  addInt(elemInfoList' offset);                  addInt(elemInfoList' (int)SdoEType.Line);                  addInt(elemInfoList' 1); // INTERPRETATION straight edges                    offset += (line.NumPoints * len);              }                return;            case SdoGTemplate.Polygon:          	var polygon = (IPolygon)geom;              int holes = polygon.NumInteriorRings;                if (holes == 0) {                  addInt(elemInfoList' sOffSet);                  addInt(elemInfoList' (int)ElemInfoEType(polygon));                  addInt(elemInfoList' ElemInfoInterpretation(polygon' SdoEType.PolygonExterior));                  return;              }                dim = (int)gtype/1000;              len = dim + ((int)gtype-dim*1000)/100;              offset = sOffSet;              ILineString ring;                ring = polygon.ExteriorRing;              addInt(elemInfoList' offset);              addInt(elemInfoList' (int)ElemInfoEType(polygon));              addInt(elemInfoList' ElemInfoInterpretation(polygon' SdoEType.PolygonExterior));              offset += (ring.NumPoints * len);                for (int i = 1; i <= holes; i++) {                  ring = polygon.GetInteriorRingN(i - 1);                  addInt(elemInfoList' offset);                  addInt(elemInfoList' (int)SdoEType.PolygonInterior);                  addInt(elemInfoList' ElemInfoInterpretation(ring' SdoEType.PolygonInterior));                  offset += (ring.NumPoints * len);              }                return;            case SdoGTemplate.MultiPolygon:          	var polys = (IMultiPolygon) geom;              IPolygon poly;              offset = sOffSet;                dim = (int)gtype/1000;              len = dim + ((int)gtype-dim*1000)/100;                for (int i = 0; i < polys.NumGeometries; i++) {                  poly = (IPolygon) polys.GetGeometryN(i);                  ElemInfo(elemInfoList' poly' offset' GType(poly));                  if( IsRectangle( poly )){                      offset += (2 * len);                                  }                  else {                      offset += (poly.NumPoints * len);                                  }                          }                return;            case SdoGTemplate.Collection:          	var geoms = (IGeometryCollection) geom;              offset = sOffSet;              dim = (int)gtype/1000;              len = dim + ((int)gtype-dim*1000)/100;                for (int i = 0; i < geoms.NumGeometries; i++) {                  geom = geoms.GetGeometryN(i);                  // MD  20/3/07 modified to provide gType of component geometry                  ElemInfo(elemInfoList' geom' offset' GType(geom));                  if( geom is IPolygon && IsRectangle( (IPolygon) geom )){                      offset += (2 * len);                                  }                  else {                      offset += (geom.NumPoints * len);                                  }                                      }                return;          }
Magic Number,NetTopologySuite.IO,OracleGeometryWriter,C:\repos\NetTopologySuite_NetTopologySuite\NetTopologySuite.IO\NetTopologySuite.IO.Oracle\OracleGeometryWriter.cs,ElemInfo,The following statement contains a magic number: switch (gtype - ((int)gtype/100) * 100) { // removes right two digits          case SdoGTemplate.Coordinate:              addInt(elemInfoList' sOffSet);              addInt(elemInfoList' (int)SdoEType.Coordinate);              addInt(elemInfoList' 1); // INTERPRETATION single point                return;            case SdoGTemplate.MultiPoint:              var points = (IMultiPoint) geom;                addInt(elemInfoList' sOffSet);              addInt(elemInfoList' (int)SdoEType.Coordinate);              addInt(elemInfoList' ElemInfoInterpretation(points' SdoEType.Coordinate));                return;            case SdoGTemplate.Line:              addInt(elemInfoList' sOffSet);              addInt(elemInfoList' (int)SdoEType.Line);              addInt(elemInfoList' 1); // INTERPRETATION straight edges                    return;            case SdoGTemplate.MultiLine:          	var lines = (IMultiLineString) geom;              ILineString line;              int offset = sOffSet;              int dim = (int)gtype/1000;              int len = dim + ((int)gtype-dim*1000)/100;                for (int i = 0; i < lines.NumGeometries; i++) {                  line = (ILineString) lines.GetGeometryN(i);                  addInt(elemInfoList' offset);                  addInt(elemInfoList' (int)SdoEType.Line);                  addInt(elemInfoList' 1); // INTERPRETATION straight edges                    offset += (line.NumPoints * len);              }                return;            case SdoGTemplate.Polygon:          	var polygon = (IPolygon)geom;              int holes = polygon.NumInteriorRings;                if (holes == 0) {                  addInt(elemInfoList' sOffSet);                  addInt(elemInfoList' (int)ElemInfoEType(polygon));                  addInt(elemInfoList' ElemInfoInterpretation(polygon' SdoEType.PolygonExterior));                  return;              }                dim = (int)gtype/1000;              len = dim + ((int)gtype-dim*1000)/100;              offset = sOffSet;              ILineString ring;                ring = polygon.ExteriorRing;              addInt(elemInfoList' offset);              addInt(elemInfoList' (int)ElemInfoEType(polygon));              addInt(elemInfoList' ElemInfoInterpretation(polygon' SdoEType.PolygonExterior));              offset += (ring.NumPoints * len);                for (int i = 1; i <= holes; i++) {                  ring = polygon.GetInteriorRingN(i - 1);                  addInt(elemInfoList' offset);                  addInt(elemInfoList' (int)SdoEType.PolygonInterior);                  addInt(elemInfoList' ElemInfoInterpretation(ring' SdoEType.PolygonInterior));                  offset += (ring.NumPoints * len);              }                return;            case SdoGTemplate.MultiPolygon:          	var polys = (IMultiPolygon) geom;              IPolygon poly;              offset = sOffSet;                dim = (int)gtype/1000;              len = dim + ((int)gtype-dim*1000)/100;                for (int i = 0; i < polys.NumGeometries; i++) {                  poly = (IPolygon) polys.GetGeometryN(i);                  ElemInfo(elemInfoList' poly' offset' GType(poly));                  if( IsRectangle( poly )){                      offset += (2 * len);                                  }                  else {                      offset += (poly.NumPoints * len);                                  }                          }                return;            case SdoGTemplate.Collection:          	var geoms = (IGeometryCollection) geom;              offset = sOffSet;              dim = (int)gtype/1000;              len = dim + ((int)gtype-dim*1000)/100;                for (int i = 0; i < geoms.NumGeometries; i++) {                  geom = geoms.GetGeometryN(i);                  // MD  20/3/07 modified to provide gType of component geometry                  ElemInfo(elemInfoList' geom' offset' GType(geom));                  if( geom is IPolygon && IsRectangle( (IPolygon) geom )){                      offset += (2 * len);                                  }                  else {                      offset += (geom.NumPoints * len);                                  }                                      }                return;          }
Magic Number,NetTopologySuite.IO,OracleGeometryWriter,C:\repos\NetTopologySuite_NetTopologySuite\NetTopologySuite.IO\NetTopologySuite.IO.Oracle\OracleGeometryWriter.cs,ElemInfo,The following statement contains a magic number: switch (gtype - ((int)gtype/100) * 100) { // removes right two digits          case SdoGTemplate.Coordinate:              addInt(elemInfoList' sOffSet);              addInt(elemInfoList' (int)SdoEType.Coordinate);              addInt(elemInfoList' 1); // INTERPRETATION single point                return;            case SdoGTemplate.MultiPoint:              var points = (IMultiPoint) geom;                addInt(elemInfoList' sOffSet);              addInt(elemInfoList' (int)SdoEType.Coordinate);              addInt(elemInfoList' ElemInfoInterpretation(points' SdoEType.Coordinate));                return;            case SdoGTemplate.Line:              addInt(elemInfoList' sOffSet);              addInt(elemInfoList' (int)SdoEType.Line);              addInt(elemInfoList' 1); // INTERPRETATION straight edges                    return;            case SdoGTemplate.MultiLine:          	var lines = (IMultiLineString) geom;              ILineString line;              int offset = sOffSet;              int dim = (int)gtype/1000;              int len = dim + ((int)gtype-dim*1000)/100;                for (int i = 0; i < lines.NumGeometries; i++) {                  line = (ILineString) lines.GetGeometryN(i);                  addInt(elemInfoList' offset);                  addInt(elemInfoList' (int)SdoEType.Line);                  addInt(elemInfoList' 1); // INTERPRETATION straight edges                    offset += (line.NumPoints * len);              }                return;            case SdoGTemplate.Polygon:          	var polygon = (IPolygon)geom;              int holes = polygon.NumInteriorRings;                if (holes == 0) {                  addInt(elemInfoList' sOffSet);                  addInt(elemInfoList' (int)ElemInfoEType(polygon));                  addInt(elemInfoList' ElemInfoInterpretation(polygon' SdoEType.PolygonExterior));                  return;              }                dim = (int)gtype/1000;              len = dim + ((int)gtype-dim*1000)/100;              offset = sOffSet;              ILineString ring;                ring = polygon.ExteriorRing;              addInt(elemInfoList' offset);              addInt(elemInfoList' (int)ElemInfoEType(polygon));              addInt(elemInfoList' ElemInfoInterpretation(polygon' SdoEType.PolygonExterior));              offset += (ring.NumPoints * len);                for (int i = 1; i <= holes; i++) {                  ring = polygon.GetInteriorRingN(i - 1);                  addInt(elemInfoList' offset);                  addInt(elemInfoList' (int)SdoEType.PolygonInterior);                  addInt(elemInfoList' ElemInfoInterpretation(ring' SdoEType.PolygonInterior));                  offset += (ring.NumPoints * len);              }                return;            case SdoGTemplate.MultiPolygon:          	var polys = (IMultiPolygon) geom;              IPolygon poly;              offset = sOffSet;                dim = (int)gtype/1000;              len = dim + ((int)gtype-dim*1000)/100;                for (int i = 0; i < polys.NumGeometries; i++) {                  poly = (IPolygon) polys.GetGeometryN(i);                  ElemInfo(elemInfoList' poly' offset' GType(poly));                  if( IsRectangle( poly )){                      offset += (2 * len);                                  }                  else {                      offset += (poly.NumPoints * len);                                  }                          }                return;            case SdoGTemplate.Collection:          	var geoms = (IGeometryCollection) geom;              offset = sOffSet;              dim = (int)gtype/1000;              len = dim + ((int)gtype-dim*1000)/100;                for (int i = 0; i < geoms.NumGeometries; i++) {                  geom = geoms.GetGeometryN(i);                  // MD  20/3/07 modified to provide gType of component geometry                  ElemInfo(elemInfoList' geom' offset' GType(geom));                  if( geom is IPolygon && IsRectangle( (IPolygon) geom )){                      offset += (2 * len);                                  }                  else {                      offset += (geom.NumPoints * len);                                  }                                      }                return;          }
Magic Number,NetTopologySuite.IO,OracleGeometryWriter,C:\repos\NetTopologySuite_NetTopologySuite\NetTopologySuite.IO\NetTopologySuite.IO.Oracle\OracleGeometryWriter.cs,ElemInfo,The following statement contains a magic number: switch (gtype - ((int)gtype/100) * 100) { // removes right two digits          case SdoGTemplate.Coordinate:              addInt(elemInfoList' sOffSet);              addInt(elemInfoList' (int)SdoEType.Coordinate);              addInt(elemInfoList' 1); // INTERPRETATION single point                return;            case SdoGTemplate.MultiPoint:              var points = (IMultiPoint) geom;                addInt(elemInfoList' sOffSet);              addInt(elemInfoList' (int)SdoEType.Coordinate);              addInt(elemInfoList' ElemInfoInterpretation(points' SdoEType.Coordinate));                return;            case SdoGTemplate.Line:              addInt(elemInfoList' sOffSet);              addInt(elemInfoList' (int)SdoEType.Line);              addInt(elemInfoList' 1); // INTERPRETATION straight edges                    return;            case SdoGTemplate.MultiLine:          	var lines = (IMultiLineString) geom;              ILineString line;              int offset = sOffSet;              int dim = (int)gtype/1000;              int len = dim + ((int)gtype-dim*1000)/100;                for (int i = 0; i < lines.NumGeometries; i++) {                  line = (ILineString) lines.GetGeometryN(i);                  addInt(elemInfoList' offset);                  addInt(elemInfoList' (int)SdoEType.Line);                  addInt(elemInfoList' 1); // INTERPRETATION straight edges                    offset += (line.NumPoints * len);              }                return;            case SdoGTemplate.Polygon:          	var polygon = (IPolygon)geom;              int holes = polygon.NumInteriorRings;                if (holes == 0) {                  addInt(elemInfoList' sOffSet);                  addInt(elemInfoList' (int)ElemInfoEType(polygon));                  addInt(elemInfoList' ElemInfoInterpretation(polygon' SdoEType.PolygonExterior));                  return;              }                dim = (int)gtype/1000;              len = dim + ((int)gtype-dim*1000)/100;              offset = sOffSet;              ILineString ring;                ring = polygon.ExteriorRing;              addInt(elemInfoList' offset);              addInt(elemInfoList' (int)ElemInfoEType(polygon));              addInt(elemInfoList' ElemInfoInterpretation(polygon' SdoEType.PolygonExterior));              offset += (ring.NumPoints * len);                for (int i = 1; i <= holes; i++) {                  ring = polygon.GetInteriorRingN(i - 1);                  addInt(elemInfoList' offset);                  addInt(elemInfoList' (int)SdoEType.PolygonInterior);                  addInt(elemInfoList' ElemInfoInterpretation(ring' SdoEType.PolygonInterior));                  offset += (ring.NumPoints * len);              }                return;            case SdoGTemplate.MultiPolygon:          	var polys = (IMultiPolygon) geom;              IPolygon poly;              offset = sOffSet;                dim = (int)gtype/1000;              len = dim + ((int)gtype-dim*1000)/100;                for (int i = 0; i < polys.NumGeometries; i++) {                  poly = (IPolygon) polys.GetGeometryN(i);                  ElemInfo(elemInfoList' poly' offset' GType(poly));                  if( IsRectangle( poly )){                      offset += (2 * len);                                  }                  else {                      offset += (poly.NumPoints * len);                                  }                          }                return;            case SdoGTemplate.Collection:          	var geoms = (IGeometryCollection) geom;              offset = sOffSet;              dim = (int)gtype/1000;              len = dim + ((int)gtype-dim*1000)/100;                for (int i = 0; i < geoms.NumGeometries; i++) {                  geom = geoms.GetGeometryN(i);                  // MD  20/3/07 modified to provide gType of component geometry                  ElemInfo(elemInfoList' geom' offset' GType(geom));                  if( geom is IPolygon && IsRectangle( (IPolygon) geom )){                      offset += (2 * len);                                  }                  else {                      offset += (geom.NumPoints * len);                                  }                                      }                return;          }
Magic Number,NetTopologySuite.IO,OracleGeometryWriter,C:\repos\NetTopologySuite_NetTopologySuite\NetTopologySuite.IO\NetTopologySuite.IO.Oracle\OracleGeometryWriter.cs,ElemInfo,The following statement contains a magic number: switch (gtype - ((int)gtype/100) * 100) { // removes right two digits          case SdoGTemplate.Coordinate:              addInt(elemInfoList' sOffSet);              addInt(elemInfoList' (int)SdoEType.Coordinate);              addInt(elemInfoList' 1); // INTERPRETATION single point                return;            case SdoGTemplate.MultiPoint:              var points = (IMultiPoint) geom;                addInt(elemInfoList' sOffSet);              addInt(elemInfoList' (int)SdoEType.Coordinate);              addInt(elemInfoList' ElemInfoInterpretation(points' SdoEType.Coordinate));                return;            case SdoGTemplate.Line:              addInt(elemInfoList' sOffSet);              addInt(elemInfoList' (int)SdoEType.Line);              addInt(elemInfoList' 1); // INTERPRETATION straight edges                    return;            case SdoGTemplate.MultiLine:          	var lines = (IMultiLineString) geom;              ILineString line;              int offset = sOffSet;              int dim = (int)gtype/1000;              int len = dim + ((int)gtype-dim*1000)/100;                for (int i = 0; i < lines.NumGeometries; i++) {                  line = (ILineString) lines.GetGeometryN(i);                  addInt(elemInfoList' offset);                  addInt(elemInfoList' (int)SdoEType.Line);                  addInt(elemInfoList' 1); // INTERPRETATION straight edges                    offset += (line.NumPoints * len);              }                return;            case SdoGTemplate.Polygon:          	var polygon = (IPolygon)geom;              int holes = polygon.NumInteriorRings;                if (holes == 0) {                  addInt(elemInfoList' sOffSet);                  addInt(elemInfoList' (int)ElemInfoEType(polygon));                  addInt(elemInfoList' ElemInfoInterpretation(polygon' SdoEType.PolygonExterior));                  return;              }                dim = (int)gtype/1000;              len = dim + ((int)gtype-dim*1000)/100;              offset = sOffSet;              ILineString ring;                ring = polygon.ExteriorRing;              addInt(elemInfoList' offset);              addInt(elemInfoList' (int)ElemInfoEType(polygon));              addInt(elemInfoList' ElemInfoInterpretation(polygon' SdoEType.PolygonExterior));              offset += (ring.NumPoints * len);                for (int i = 1; i <= holes; i++) {                  ring = polygon.GetInteriorRingN(i - 1);                  addInt(elemInfoList' offset);                  addInt(elemInfoList' (int)SdoEType.PolygonInterior);                  addInt(elemInfoList' ElemInfoInterpretation(ring' SdoEType.PolygonInterior));                  offset += (ring.NumPoints * len);              }                return;            case SdoGTemplate.MultiPolygon:          	var polys = (IMultiPolygon) geom;              IPolygon poly;              offset = sOffSet;                dim = (int)gtype/1000;              len = dim + ((int)gtype-dim*1000)/100;                for (int i = 0; i < polys.NumGeometries; i++) {                  poly = (IPolygon) polys.GetGeometryN(i);                  ElemInfo(elemInfoList' poly' offset' GType(poly));                  if( IsRectangle( poly )){                      offset += (2 * len);                                  }                  else {                      offset += (poly.NumPoints * len);                                  }                          }                return;            case SdoGTemplate.Collection:          	var geoms = (IGeometryCollection) geom;              offset = sOffSet;              dim = (int)gtype/1000;              len = dim + ((int)gtype-dim*1000)/100;                for (int i = 0; i < geoms.NumGeometries; i++) {                  geom = geoms.GetGeometryN(i);                  // MD  20/3/07 modified to provide gType of component geometry                  ElemInfo(elemInfoList' geom' offset' GType(geom));                  if( geom is IPolygon && IsRectangle( (IPolygon) geom )){                      offset += (2 * len);                                  }                  else {                      offset += (geom.NumPoints * len);                                  }                                      }                return;          }
Magic Number,NetTopologySuite.IO,OracleGeometryWriter,C:\repos\NetTopologySuite_NetTopologySuite\NetTopologySuite.IO\NetTopologySuite.IO.Oracle\OracleGeometryWriter.cs,ElemInfo,The following statement contains a magic number: switch (gtype - ((int)gtype/100) * 100) { // removes right two digits          case SdoGTemplate.Coordinate:              addInt(elemInfoList' sOffSet);              addInt(elemInfoList' (int)SdoEType.Coordinate);              addInt(elemInfoList' 1); // INTERPRETATION single point                return;            case SdoGTemplate.MultiPoint:              var points = (IMultiPoint) geom;                addInt(elemInfoList' sOffSet);              addInt(elemInfoList' (int)SdoEType.Coordinate);              addInt(elemInfoList' ElemInfoInterpretation(points' SdoEType.Coordinate));                return;            case SdoGTemplate.Line:              addInt(elemInfoList' sOffSet);              addInt(elemInfoList' (int)SdoEType.Line);              addInt(elemInfoList' 1); // INTERPRETATION straight edges                    return;            case SdoGTemplate.MultiLine:          	var lines = (IMultiLineString) geom;              ILineString line;              int offset = sOffSet;              int dim = (int)gtype/1000;              int len = dim + ((int)gtype-dim*1000)/100;                for (int i = 0; i < lines.NumGeometries; i++) {                  line = (ILineString) lines.GetGeometryN(i);                  addInt(elemInfoList' offset);                  addInt(elemInfoList' (int)SdoEType.Line);                  addInt(elemInfoList' 1); // INTERPRETATION straight edges                    offset += (line.NumPoints * len);              }                return;            case SdoGTemplate.Polygon:          	var polygon = (IPolygon)geom;              int holes = polygon.NumInteriorRings;                if (holes == 0) {                  addInt(elemInfoList' sOffSet);                  addInt(elemInfoList' (int)ElemInfoEType(polygon));                  addInt(elemInfoList' ElemInfoInterpretation(polygon' SdoEType.PolygonExterior));                  return;              }                dim = (int)gtype/1000;              len = dim + ((int)gtype-dim*1000)/100;              offset = sOffSet;              ILineString ring;                ring = polygon.ExteriorRing;              addInt(elemInfoList' offset);              addInt(elemInfoList' (int)ElemInfoEType(polygon));              addInt(elemInfoList' ElemInfoInterpretation(polygon' SdoEType.PolygonExterior));              offset += (ring.NumPoints * len);                for (int i = 1; i <= holes; i++) {                  ring = polygon.GetInteriorRingN(i - 1);                  addInt(elemInfoList' offset);                  addInt(elemInfoList' (int)SdoEType.PolygonInterior);                  addInt(elemInfoList' ElemInfoInterpretation(ring' SdoEType.PolygonInterior));                  offset += (ring.NumPoints * len);              }                return;            case SdoGTemplate.MultiPolygon:          	var polys = (IMultiPolygon) geom;              IPolygon poly;              offset = sOffSet;                dim = (int)gtype/1000;              len = dim + ((int)gtype-dim*1000)/100;                for (int i = 0; i < polys.NumGeometries; i++) {                  poly = (IPolygon) polys.GetGeometryN(i);                  ElemInfo(elemInfoList' poly' offset' GType(poly));                  if( IsRectangle( poly )){                      offset += (2 * len);                                  }                  else {                      offset += (poly.NumPoints * len);                                  }                          }                return;            case SdoGTemplate.Collection:          	var geoms = (IGeometryCollection) geom;              offset = sOffSet;              dim = (int)gtype/1000;              len = dim + ((int)gtype-dim*1000)/100;                for (int i = 0; i < geoms.NumGeometries; i++) {                  geom = geoms.GetGeometryN(i);                  // MD  20/3/07 modified to provide gType of component geometry                  ElemInfo(elemInfoList' geom' offset' GType(geom));                  if( geom is IPolygon && IsRectangle( (IPolygon) geom )){                      offset += (2 * len);                                  }                  else {                      offset += (geom.NumPoints * len);                                  }                                      }                return;          }
Magic Number,NetTopologySuite.IO,OracleGeometryWriter,C:\repos\NetTopologySuite_NetTopologySuite\NetTopologySuite.IO\NetTopologySuite.IO.Oracle\OracleGeometryWriter.cs,ElemInfo,The following statement contains a magic number: switch (gtype - ((int)gtype/100) * 100) { // removes right two digits          case SdoGTemplate.Coordinate:              addInt(elemInfoList' sOffSet);              addInt(elemInfoList' (int)SdoEType.Coordinate);              addInt(elemInfoList' 1); // INTERPRETATION single point                return;            case SdoGTemplate.MultiPoint:              var points = (IMultiPoint) geom;                addInt(elemInfoList' sOffSet);              addInt(elemInfoList' (int)SdoEType.Coordinate);              addInt(elemInfoList' ElemInfoInterpretation(points' SdoEType.Coordinate));                return;            case SdoGTemplate.Line:              addInt(elemInfoList' sOffSet);              addInt(elemInfoList' (int)SdoEType.Line);              addInt(elemInfoList' 1); // INTERPRETATION straight edges                    return;            case SdoGTemplate.MultiLine:          	var lines = (IMultiLineString) geom;              ILineString line;              int offset = sOffSet;              int dim = (int)gtype/1000;              int len = dim + ((int)gtype-dim*1000)/100;                for (int i = 0; i < lines.NumGeometries; i++) {                  line = (ILineString) lines.GetGeometryN(i);                  addInt(elemInfoList' offset);                  addInt(elemInfoList' (int)SdoEType.Line);                  addInt(elemInfoList' 1); // INTERPRETATION straight edges                    offset += (line.NumPoints * len);              }                return;            case SdoGTemplate.Polygon:          	var polygon = (IPolygon)geom;              int holes = polygon.NumInteriorRings;                if (holes == 0) {                  addInt(elemInfoList' sOffSet);                  addInt(elemInfoList' (int)ElemInfoEType(polygon));                  addInt(elemInfoList' ElemInfoInterpretation(polygon' SdoEType.PolygonExterior));                  return;              }                dim = (int)gtype/1000;              len = dim + ((int)gtype-dim*1000)/100;              offset = sOffSet;              ILineString ring;                ring = polygon.ExteriorRing;              addInt(elemInfoList' offset);              addInt(elemInfoList' (int)ElemInfoEType(polygon));              addInt(elemInfoList' ElemInfoInterpretation(polygon' SdoEType.PolygonExterior));              offset += (ring.NumPoints * len);                for (int i = 1; i <= holes; i++) {                  ring = polygon.GetInteriorRingN(i - 1);                  addInt(elemInfoList' offset);                  addInt(elemInfoList' (int)SdoEType.PolygonInterior);                  addInt(elemInfoList' ElemInfoInterpretation(ring' SdoEType.PolygonInterior));                  offset += (ring.NumPoints * len);              }                return;            case SdoGTemplate.MultiPolygon:          	var polys = (IMultiPolygon) geom;              IPolygon poly;              offset = sOffSet;                dim = (int)gtype/1000;              len = dim + ((int)gtype-dim*1000)/100;                for (int i = 0; i < polys.NumGeometries; i++) {                  poly = (IPolygon) polys.GetGeometryN(i);                  ElemInfo(elemInfoList' poly' offset' GType(poly));                  if( IsRectangle( poly )){                      offset += (2 * len);                                  }                  else {                      offset += (poly.NumPoints * len);                                  }                          }                return;            case SdoGTemplate.Collection:          	var geoms = (IGeometryCollection) geom;              offset = sOffSet;              dim = (int)gtype/1000;              len = dim + ((int)gtype-dim*1000)/100;                for (int i = 0; i < geoms.NumGeometries; i++) {                  geom = geoms.GetGeometryN(i);                  // MD  20/3/07 modified to provide gType of component geometry                  ElemInfo(elemInfoList' geom' offset' GType(geom));                  if( geom is IPolygon && IsRectangle( (IPolygon) geom )){                      offset += (2 * len);                                  }                  else {                      offset += (geom.NumPoints * len);                                  }                                      }                return;          }
Magic Number,NetTopologySuite.IO,OracleGeometryWriter,C:\repos\NetTopologySuite_NetTopologySuite\NetTopologySuite.IO\NetTopologySuite.IO.Oracle\OracleGeometryWriter.cs,ElemInfo,The following statement contains a magic number: switch (gtype - ((int)gtype/100) * 100) { // removes right two digits          case SdoGTemplate.Coordinate:              addInt(elemInfoList' sOffSet);              addInt(elemInfoList' (int)SdoEType.Coordinate);              addInt(elemInfoList' 1); // INTERPRETATION single point                return;            case SdoGTemplate.MultiPoint:              var points = (IMultiPoint) geom;                addInt(elemInfoList' sOffSet);              addInt(elemInfoList' (int)SdoEType.Coordinate);              addInt(elemInfoList' ElemInfoInterpretation(points' SdoEType.Coordinate));                return;            case SdoGTemplate.Line:              addInt(elemInfoList' sOffSet);              addInt(elemInfoList' (int)SdoEType.Line);              addInt(elemInfoList' 1); // INTERPRETATION straight edges                    return;            case SdoGTemplate.MultiLine:          	var lines = (IMultiLineString) geom;              ILineString line;              int offset = sOffSet;              int dim = (int)gtype/1000;              int len = dim + ((int)gtype-dim*1000)/100;                for (int i = 0; i < lines.NumGeometries; i++) {                  line = (ILineString) lines.GetGeometryN(i);                  addInt(elemInfoList' offset);                  addInt(elemInfoList' (int)SdoEType.Line);                  addInt(elemInfoList' 1); // INTERPRETATION straight edges                    offset += (line.NumPoints * len);              }                return;            case SdoGTemplate.Polygon:          	var polygon = (IPolygon)geom;              int holes = polygon.NumInteriorRings;                if (holes == 0) {                  addInt(elemInfoList' sOffSet);                  addInt(elemInfoList' (int)ElemInfoEType(polygon));                  addInt(elemInfoList' ElemInfoInterpretation(polygon' SdoEType.PolygonExterior));                  return;              }                dim = (int)gtype/1000;              len = dim + ((int)gtype-dim*1000)/100;              offset = sOffSet;              ILineString ring;                ring = polygon.ExteriorRing;              addInt(elemInfoList' offset);              addInt(elemInfoList' (int)ElemInfoEType(polygon));              addInt(elemInfoList' ElemInfoInterpretation(polygon' SdoEType.PolygonExterior));              offset += (ring.NumPoints * len);                for (int i = 1; i <= holes; i++) {                  ring = polygon.GetInteriorRingN(i - 1);                  addInt(elemInfoList' offset);                  addInt(elemInfoList' (int)SdoEType.PolygonInterior);                  addInt(elemInfoList' ElemInfoInterpretation(ring' SdoEType.PolygonInterior));                  offset += (ring.NumPoints * len);              }                return;            case SdoGTemplate.MultiPolygon:          	var polys = (IMultiPolygon) geom;              IPolygon poly;              offset = sOffSet;                dim = (int)gtype/1000;              len = dim + ((int)gtype-dim*1000)/100;                for (int i = 0; i < polys.NumGeometries; i++) {                  poly = (IPolygon) polys.GetGeometryN(i);                  ElemInfo(elemInfoList' poly' offset' GType(poly));                  if( IsRectangle( poly )){                      offset += (2 * len);                                  }                  else {                      offset += (poly.NumPoints * len);                                  }                          }                return;            case SdoGTemplate.Collection:          	var geoms = (IGeometryCollection) geom;              offset = sOffSet;              dim = (int)gtype/1000;              len = dim + ((int)gtype-dim*1000)/100;                for (int i = 0; i < geoms.NumGeometries; i++) {                  geom = geoms.GetGeometryN(i);                  // MD  20/3/07 modified to provide gType of component geometry                  ElemInfo(elemInfoList' geom' offset' GType(geom));                  if( geom is IPolygon && IsRectangle( (IPolygon) geom )){                      offset += (2 * len);                                  }                  else {                      offset += (geom.NumPoints * len);                                  }                                      }                return;          }
Magic Number,NetTopologySuite.IO,OracleGeometryWriter,C:\repos\NetTopologySuite_NetTopologySuite\NetTopologySuite.IO\NetTopologySuite.IO.Oracle\OracleGeometryWriter.cs,ElemInfo,The following statement contains a magic number: switch (gtype - ((int)gtype/100) * 100) { // removes right two digits          case SdoGTemplate.Coordinate:              addInt(elemInfoList' sOffSet);              addInt(elemInfoList' (int)SdoEType.Coordinate);              addInt(elemInfoList' 1); // INTERPRETATION single point                return;            case SdoGTemplate.MultiPoint:              var points = (IMultiPoint) geom;                addInt(elemInfoList' sOffSet);              addInt(elemInfoList' (int)SdoEType.Coordinate);              addInt(elemInfoList' ElemInfoInterpretation(points' SdoEType.Coordinate));                return;            case SdoGTemplate.Line:              addInt(elemInfoList' sOffSet);              addInt(elemInfoList' (int)SdoEType.Line);              addInt(elemInfoList' 1); // INTERPRETATION straight edges                    return;            case SdoGTemplate.MultiLine:          	var lines = (IMultiLineString) geom;              ILineString line;              int offset = sOffSet;              int dim = (int)gtype/1000;              int len = dim + ((int)gtype-dim*1000)/100;                for (int i = 0; i < lines.NumGeometries; i++) {                  line = (ILineString) lines.GetGeometryN(i);                  addInt(elemInfoList' offset);                  addInt(elemInfoList' (int)SdoEType.Line);                  addInt(elemInfoList' 1); // INTERPRETATION straight edges                    offset += (line.NumPoints * len);              }                return;            case SdoGTemplate.Polygon:          	var polygon = (IPolygon)geom;              int holes = polygon.NumInteriorRings;                if (holes == 0) {                  addInt(elemInfoList' sOffSet);                  addInt(elemInfoList' (int)ElemInfoEType(polygon));                  addInt(elemInfoList' ElemInfoInterpretation(polygon' SdoEType.PolygonExterior));                  return;              }                dim = (int)gtype/1000;              len = dim + ((int)gtype-dim*1000)/100;              offset = sOffSet;              ILineString ring;                ring = polygon.ExteriorRing;              addInt(elemInfoList' offset);              addInt(elemInfoList' (int)ElemInfoEType(polygon));              addInt(elemInfoList' ElemInfoInterpretation(polygon' SdoEType.PolygonExterior));              offset += (ring.NumPoints * len);                for (int i = 1; i <= holes; i++) {                  ring = polygon.GetInteriorRingN(i - 1);                  addInt(elemInfoList' offset);                  addInt(elemInfoList' (int)SdoEType.PolygonInterior);                  addInt(elemInfoList' ElemInfoInterpretation(ring' SdoEType.PolygonInterior));                  offset += (ring.NumPoints * len);              }                return;            case SdoGTemplate.MultiPolygon:          	var polys = (IMultiPolygon) geom;              IPolygon poly;              offset = sOffSet;                dim = (int)gtype/1000;              len = dim + ((int)gtype-dim*1000)/100;                for (int i = 0; i < polys.NumGeometries; i++) {                  poly = (IPolygon) polys.GetGeometryN(i);                  ElemInfo(elemInfoList' poly' offset' GType(poly));                  if( IsRectangle( poly )){                      offset += (2 * len);                                  }                  else {                      offset += (poly.NumPoints * len);                                  }                          }                return;            case SdoGTemplate.Collection:          	var geoms = (IGeometryCollection) geom;              offset = sOffSet;              dim = (int)gtype/1000;              len = dim + ((int)gtype-dim*1000)/100;                for (int i = 0; i < geoms.NumGeometries; i++) {                  geom = geoms.GetGeometryN(i);                  // MD  20/3/07 modified to provide gType of component geometry                  ElemInfo(elemInfoList' geom' offset' GType(geom));                  if( geom is IPolygon && IsRectangle( (IPolygon) geom )){                      offset += (2 * len);                                  }                  else {                      offset += (geom.NumPoints * len);                                  }                                      }                return;          }
Magic Number,NetTopologySuite.IO,OracleGeometryWriter,C:\repos\NetTopologySuite_NetTopologySuite\NetTopologySuite.IO\NetTopologySuite.IO.Oracle\OracleGeometryWriter.cs,ElemInfo,The following statement contains a magic number: switch (gtype - ((int)gtype/100) * 100) { // removes right two digits          case SdoGTemplate.Coordinate:              addInt(elemInfoList' sOffSet);              addInt(elemInfoList' (int)SdoEType.Coordinate);              addInt(elemInfoList' 1); // INTERPRETATION single point                return;            case SdoGTemplate.MultiPoint:              var points = (IMultiPoint) geom;                addInt(elemInfoList' sOffSet);              addInt(elemInfoList' (int)SdoEType.Coordinate);              addInt(elemInfoList' ElemInfoInterpretation(points' SdoEType.Coordinate));                return;            case SdoGTemplate.Line:              addInt(elemInfoList' sOffSet);              addInt(elemInfoList' (int)SdoEType.Line);              addInt(elemInfoList' 1); // INTERPRETATION straight edges                    return;            case SdoGTemplate.MultiLine:          	var lines = (IMultiLineString) geom;              ILineString line;              int offset = sOffSet;              int dim = (int)gtype/1000;              int len = dim + ((int)gtype-dim*1000)/100;                for (int i = 0; i < lines.NumGeometries; i++) {                  line = (ILineString) lines.GetGeometryN(i);                  addInt(elemInfoList' offset);                  addInt(elemInfoList' (int)SdoEType.Line);                  addInt(elemInfoList' 1); // INTERPRETATION straight edges                    offset += (line.NumPoints * len);              }                return;            case SdoGTemplate.Polygon:          	var polygon = (IPolygon)geom;              int holes = polygon.NumInteriorRings;                if (holes == 0) {                  addInt(elemInfoList' sOffSet);                  addInt(elemInfoList' (int)ElemInfoEType(polygon));                  addInt(elemInfoList' ElemInfoInterpretation(polygon' SdoEType.PolygonExterior));                  return;              }                dim = (int)gtype/1000;              len = dim + ((int)gtype-dim*1000)/100;              offset = sOffSet;              ILineString ring;                ring = polygon.ExteriorRing;              addInt(elemInfoList' offset);              addInt(elemInfoList' (int)ElemInfoEType(polygon));              addInt(elemInfoList' ElemInfoInterpretation(polygon' SdoEType.PolygonExterior));              offset += (ring.NumPoints * len);                for (int i = 1; i <= holes; i++) {                  ring = polygon.GetInteriorRingN(i - 1);                  addInt(elemInfoList' offset);                  addInt(elemInfoList' (int)SdoEType.PolygonInterior);                  addInt(elemInfoList' ElemInfoInterpretation(ring' SdoEType.PolygonInterior));                  offset += (ring.NumPoints * len);              }                return;            case SdoGTemplate.MultiPolygon:          	var polys = (IMultiPolygon) geom;              IPolygon poly;              offset = sOffSet;                dim = (int)gtype/1000;              len = dim + ((int)gtype-dim*1000)/100;                for (int i = 0; i < polys.NumGeometries; i++) {                  poly = (IPolygon) polys.GetGeometryN(i);                  ElemInfo(elemInfoList' poly' offset' GType(poly));                  if( IsRectangle( poly )){                      offset += (2 * len);                                  }                  else {                      offset += (poly.NumPoints * len);                                  }                          }                return;            case SdoGTemplate.Collection:          	var geoms = (IGeometryCollection) geom;              offset = sOffSet;              dim = (int)gtype/1000;              len = dim + ((int)gtype-dim*1000)/100;                for (int i = 0; i < geoms.NumGeometries; i++) {                  geom = geoms.GetGeometryN(i);                  // MD  20/3/07 modified to provide gType of component geometry                  ElemInfo(elemInfoList' geom' offset' GType(geom));                  if( geom is IPolygon && IsRectangle( (IPolygon) geom )){                      offset += (2 * len);                                  }                  else {                      offset += (geom.NumPoints * len);                                  }                                      }                return;          }
Magic Number,NetTopologySuite.IO,OracleGeometryWriter,C:\repos\NetTopologySuite_NetTopologySuite\NetTopologySuite.IO\NetTopologySuite.IO.Oracle\OracleGeometryWriter.cs,ElemInfo,The following statement contains a magic number: switch (gtype - ((int)gtype/100) * 100) { // removes right two digits          case SdoGTemplate.Coordinate:              addInt(elemInfoList' sOffSet);              addInt(elemInfoList' (int)SdoEType.Coordinate);              addInt(elemInfoList' 1); // INTERPRETATION single point                return;            case SdoGTemplate.MultiPoint:              var points = (IMultiPoint) geom;                addInt(elemInfoList' sOffSet);              addInt(elemInfoList' (int)SdoEType.Coordinate);              addInt(elemInfoList' ElemInfoInterpretation(points' SdoEType.Coordinate));                return;            case SdoGTemplate.Line:              addInt(elemInfoList' sOffSet);              addInt(elemInfoList' (int)SdoEType.Line);              addInt(elemInfoList' 1); // INTERPRETATION straight edges                    return;            case SdoGTemplate.MultiLine:          	var lines = (IMultiLineString) geom;              ILineString line;              int offset = sOffSet;              int dim = (int)gtype/1000;              int len = dim + ((int)gtype-dim*1000)/100;                for (int i = 0; i < lines.NumGeometries; i++) {                  line = (ILineString) lines.GetGeometryN(i);                  addInt(elemInfoList' offset);                  addInt(elemInfoList' (int)SdoEType.Line);                  addInt(elemInfoList' 1); // INTERPRETATION straight edges                    offset += (line.NumPoints * len);              }                return;            case SdoGTemplate.Polygon:          	var polygon = (IPolygon)geom;              int holes = polygon.NumInteriorRings;                if (holes == 0) {                  addInt(elemInfoList' sOffSet);                  addInt(elemInfoList' (int)ElemInfoEType(polygon));                  addInt(elemInfoList' ElemInfoInterpretation(polygon' SdoEType.PolygonExterior));                  return;              }                dim = (int)gtype/1000;              len = dim + ((int)gtype-dim*1000)/100;              offset = sOffSet;              ILineString ring;                ring = polygon.ExteriorRing;              addInt(elemInfoList' offset);              addInt(elemInfoList' (int)ElemInfoEType(polygon));              addInt(elemInfoList' ElemInfoInterpretation(polygon' SdoEType.PolygonExterior));              offset += (ring.NumPoints * len);                for (int i = 1; i <= holes; i++) {                  ring = polygon.GetInteriorRingN(i - 1);                  addInt(elemInfoList' offset);                  addInt(elemInfoList' (int)SdoEType.PolygonInterior);                  addInt(elemInfoList' ElemInfoInterpretation(ring' SdoEType.PolygonInterior));                  offset += (ring.NumPoints * len);              }                return;            case SdoGTemplate.MultiPolygon:          	var polys = (IMultiPolygon) geom;              IPolygon poly;              offset = sOffSet;                dim = (int)gtype/1000;              len = dim + ((int)gtype-dim*1000)/100;                for (int i = 0; i < polys.NumGeometries; i++) {                  poly = (IPolygon) polys.GetGeometryN(i);                  ElemInfo(elemInfoList' poly' offset' GType(poly));                  if( IsRectangle( poly )){                      offset += (2 * len);                                  }                  else {                      offset += (poly.NumPoints * len);                                  }                          }                return;            case SdoGTemplate.Collection:          	var geoms = (IGeometryCollection) geom;              offset = sOffSet;              dim = (int)gtype/1000;              len = dim + ((int)gtype-dim*1000)/100;                for (int i = 0; i < geoms.NumGeometries; i++) {                  geom = geoms.GetGeometryN(i);                  // MD  20/3/07 modified to provide gType of component geometry                  ElemInfo(elemInfoList' geom' offset' GType(geom));                  if( geom is IPolygon && IsRectangle( (IPolygon) geom )){                      offset += (2 * len);                                  }                  else {                      offset += (geom.NumPoints * len);                                  }                                      }                return;          }
Magic Number,NetTopologySuite.IO,OracleGeometryWriter,C:\repos\NetTopologySuite_NetTopologySuite\NetTopologySuite.IO\NetTopologySuite.IO.Oracle\OracleGeometryWriter.cs,ElemInfo,The following statement contains a magic number: switch (gtype - ((int)gtype/100) * 100) { // removes right two digits          case SdoGTemplate.Coordinate:              addInt(elemInfoList' sOffSet);              addInt(elemInfoList' (int)SdoEType.Coordinate);              addInt(elemInfoList' 1); // INTERPRETATION single point                return;            case SdoGTemplate.MultiPoint:              var points = (IMultiPoint) geom;                addInt(elemInfoList' sOffSet);              addInt(elemInfoList' (int)SdoEType.Coordinate);              addInt(elemInfoList' ElemInfoInterpretation(points' SdoEType.Coordinate));                return;            case SdoGTemplate.Line:              addInt(elemInfoList' sOffSet);              addInt(elemInfoList' (int)SdoEType.Line);              addInt(elemInfoList' 1); // INTERPRETATION straight edges                    return;            case SdoGTemplate.MultiLine:          	var lines = (IMultiLineString) geom;              ILineString line;              int offset = sOffSet;              int dim = (int)gtype/1000;              int len = dim + ((int)gtype-dim*1000)/100;                for (int i = 0; i < lines.NumGeometries; i++) {                  line = (ILineString) lines.GetGeometryN(i);                  addInt(elemInfoList' offset);                  addInt(elemInfoList' (int)SdoEType.Line);                  addInt(elemInfoList' 1); // INTERPRETATION straight edges                    offset += (line.NumPoints * len);              }                return;            case SdoGTemplate.Polygon:          	var polygon = (IPolygon)geom;              int holes = polygon.NumInteriorRings;                if (holes == 0) {                  addInt(elemInfoList' sOffSet);                  addInt(elemInfoList' (int)ElemInfoEType(polygon));                  addInt(elemInfoList' ElemInfoInterpretation(polygon' SdoEType.PolygonExterior));                  return;              }                dim = (int)gtype/1000;              len = dim + ((int)gtype-dim*1000)/100;              offset = sOffSet;              ILineString ring;                ring = polygon.ExteriorRing;              addInt(elemInfoList' offset);              addInt(elemInfoList' (int)ElemInfoEType(polygon));              addInt(elemInfoList' ElemInfoInterpretation(polygon' SdoEType.PolygonExterior));              offset += (ring.NumPoints * len);                for (int i = 1; i <= holes; i++) {                  ring = polygon.GetInteriorRingN(i - 1);                  addInt(elemInfoList' offset);                  addInt(elemInfoList' (int)SdoEType.PolygonInterior);                  addInt(elemInfoList' ElemInfoInterpretation(ring' SdoEType.PolygonInterior));                  offset += (ring.NumPoints * len);              }                return;            case SdoGTemplate.MultiPolygon:          	var polys = (IMultiPolygon) geom;              IPolygon poly;              offset = sOffSet;                dim = (int)gtype/1000;              len = dim + ((int)gtype-dim*1000)/100;                for (int i = 0; i < polys.NumGeometries; i++) {                  poly = (IPolygon) polys.GetGeometryN(i);                  ElemInfo(elemInfoList' poly' offset' GType(poly));                  if( IsRectangle( poly )){                      offset += (2 * len);                                  }                  else {                      offset += (poly.NumPoints * len);                                  }                          }                return;            case SdoGTemplate.Collection:          	var geoms = (IGeometryCollection) geom;              offset = sOffSet;              dim = (int)gtype/1000;              len = dim + ((int)gtype-dim*1000)/100;                for (int i = 0; i < geoms.NumGeometries; i++) {                  geom = geoms.GetGeometryN(i);                  // MD  20/3/07 modified to provide gType of component geometry                  ElemInfo(elemInfoList' geom' offset' GType(geom));                  if( geom is IPolygon && IsRectangle( (IPolygon) geom )){                      offset += (2 * len);                                  }                  else {                      offset += (geom.NumPoints * len);                                  }                                      }                return;          }
Magic Number,NetTopologySuite.IO,OracleGeometryWriter,C:\repos\NetTopologySuite_NetTopologySuite\NetTopologySuite.IO\NetTopologySuite.IO.Oracle\OracleGeometryWriter.cs,ElemInfo,The following statement contains a magic number: switch (gtype - ((int)gtype/100) * 100) { // removes right two digits          case SdoGTemplate.Coordinate:              addInt(elemInfoList' sOffSet);              addInt(elemInfoList' (int)SdoEType.Coordinate);              addInt(elemInfoList' 1); // INTERPRETATION single point                return;            case SdoGTemplate.MultiPoint:              var points = (IMultiPoint) geom;                addInt(elemInfoList' sOffSet);              addInt(elemInfoList' (int)SdoEType.Coordinate);              addInt(elemInfoList' ElemInfoInterpretation(points' SdoEType.Coordinate));                return;            case SdoGTemplate.Line:              addInt(elemInfoList' sOffSet);              addInt(elemInfoList' (int)SdoEType.Line);              addInt(elemInfoList' 1); // INTERPRETATION straight edges                    return;            case SdoGTemplate.MultiLine:          	var lines = (IMultiLineString) geom;              ILineString line;              int offset = sOffSet;              int dim = (int)gtype/1000;              int len = dim + ((int)gtype-dim*1000)/100;                for (int i = 0; i < lines.NumGeometries; i++) {                  line = (ILineString) lines.GetGeometryN(i);                  addInt(elemInfoList' offset);                  addInt(elemInfoList' (int)SdoEType.Line);                  addInt(elemInfoList' 1); // INTERPRETATION straight edges                    offset += (line.NumPoints * len);              }                return;            case SdoGTemplate.Polygon:          	var polygon = (IPolygon)geom;              int holes = polygon.NumInteriorRings;                if (holes == 0) {                  addInt(elemInfoList' sOffSet);                  addInt(elemInfoList' (int)ElemInfoEType(polygon));                  addInt(elemInfoList' ElemInfoInterpretation(polygon' SdoEType.PolygonExterior));                  return;              }                dim = (int)gtype/1000;              len = dim + ((int)gtype-dim*1000)/100;              offset = sOffSet;              ILineString ring;                ring = polygon.ExteriorRing;              addInt(elemInfoList' offset);              addInt(elemInfoList' (int)ElemInfoEType(polygon));              addInt(elemInfoList' ElemInfoInterpretation(polygon' SdoEType.PolygonExterior));              offset += (ring.NumPoints * len);                for (int i = 1; i <= holes; i++) {                  ring = polygon.GetInteriorRingN(i - 1);                  addInt(elemInfoList' offset);                  addInt(elemInfoList' (int)SdoEType.PolygonInterior);                  addInt(elemInfoList' ElemInfoInterpretation(ring' SdoEType.PolygonInterior));                  offset += (ring.NumPoints * len);              }                return;            case SdoGTemplate.MultiPolygon:          	var polys = (IMultiPolygon) geom;              IPolygon poly;              offset = sOffSet;                dim = (int)gtype/1000;              len = dim + ((int)gtype-dim*1000)/100;                for (int i = 0; i < polys.NumGeometries; i++) {                  poly = (IPolygon) polys.GetGeometryN(i);                  ElemInfo(elemInfoList' poly' offset' GType(poly));                  if( IsRectangle( poly )){                      offset += (2 * len);                                  }                  else {                      offset += (poly.NumPoints * len);                                  }                          }                return;            case SdoGTemplate.Collection:          	var geoms = (IGeometryCollection) geom;              offset = sOffSet;              dim = (int)gtype/1000;              len = dim + ((int)gtype-dim*1000)/100;                for (int i = 0; i < geoms.NumGeometries; i++) {                  geom = geoms.GetGeometryN(i);                  // MD  20/3/07 modified to provide gType of component geometry                  ElemInfo(elemInfoList' geom' offset' GType(geom));                  if( geom is IPolygon && IsRectangle( (IPolygon) geom )){                      offset += (2 * len);                                  }                  else {                      offset += (geom.NumPoints * len);                                  }                                      }                return;          }
Magic Number,NetTopologySuite.IO,OracleGeometryWriter,C:\repos\NetTopologySuite_NetTopologySuite\NetTopologySuite.IO\NetTopologySuite.IO.Oracle\OracleGeometryWriter.cs,ElemInfo,The following statement contains a magic number: switch (gtype - ((int)gtype/100) * 100) { // removes right two digits          case SdoGTemplate.Coordinate:              addInt(elemInfoList' sOffSet);              addInt(elemInfoList' (int)SdoEType.Coordinate);              addInt(elemInfoList' 1); // INTERPRETATION single point                return;            case SdoGTemplate.MultiPoint:              var points = (IMultiPoint) geom;                addInt(elemInfoList' sOffSet);              addInt(elemInfoList' (int)SdoEType.Coordinate);              addInt(elemInfoList' ElemInfoInterpretation(points' SdoEType.Coordinate));                return;            case SdoGTemplate.Line:              addInt(elemInfoList' sOffSet);              addInt(elemInfoList' (int)SdoEType.Line);              addInt(elemInfoList' 1); // INTERPRETATION straight edges                    return;            case SdoGTemplate.MultiLine:          	var lines = (IMultiLineString) geom;              ILineString line;              int offset = sOffSet;              int dim = (int)gtype/1000;              int len = dim + ((int)gtype-dim*1000)/100;                for (int i = 0; i < lines.NumGeometries; i++) {                  line = (ILineString) lines.GetGeometryN(i);                  addInt(elemInfoList' offset);                  addInt(elemInfoList' (int)SdoEType.Line);                  addInt(elemInfoList' 1); // INTERPRETATION straight edges                    offset += (line.NumPoints * len);              }                return;            case SdoGTemplate.Polygon:          	var polygon = (IPolygon)geom;              int holes = polygon.NumInteriorRings;                if (holes == 0) {                  addInt(elemInfoList' sOffSet);                  addInt(elemInfoList' (int)ElemInfoEType(polygon));                  addInt(elemInfoList' ElemInfoInterpretation(polygon' SdoEType.PolygonExterior));                  return;              }                dim = (int)gtype/1000;              len = dim + ((int)gtype-dim*1000)/100;              offset = sOffSet;              ILineString ring;                ring = polygon.ExteriorRing;              addInt(elemInfoList' offset);              addInt(elemInfoList' (int)ElemInfoEType(polygon));              addInt(elemInfoList' ElemInfoInterpretation(polygon' SdoEType.PolygonExterior));              offset += (ring.NumPoints * len);                for (int i = 1; i <= holes; i++) {                  ring = polygon.GetInteriorRingN(i - 1);                  addInt(elemInfoList' offset);                  addInt(elemInfoList' (int)SdoEType.PolygonInterior);                  addInt(elemInfoList' ElemInfoInterpretation(ring' SdoEType.PolygonInterior));                  offset += (ring.NumPoints * len);              }                return;            case SdoGTemplate.MultiPolygon:          	var polys = (IMultiPolygon) geom;              IPolygon poly;              offset = sOffSet;                dim = (int)gtype/1000;              len = dim + ((int)gtype-dim*1000)/100;                for (int i = 0; i < polys.NumGeometries; i++) {                  poly = (IPolygon) polys.GetGeometryN(i);                  ElemInfo(elemInfoList' poly' offset' GType(poly));                  if( IsRectangle( poly )){                      offset += (2 * len);                                  }                  else {                      offset += (poly.NumPoints * len);                                  }                          }                return;            case SdoGTemplate.Collection:          	var geoms = (IGeometryCollection) geom;              offset = sOffSet;              dim = (int)gtype/1000;              len = dim + ((int)gtype-dim*1000)/100;                for (int i = 0; i < geoms.NumGeometries; i++) {                  geom = geoms.GetGeometryN(i);                  // MD  20/3/07 modified to provide gType of component geometry                  ElemInfo(elemInfoList' geom' offset' GType(geom));                  if( geom is IPolygon && IsRectangle( (IPolygon) geom )){                      offset += (2 * len);                                  }                  else {                      offset += (geom.NumPoints * len);                                  }                                      }                return;          }
Magic Number,NetTopologySuite.IO,OracleGeometryWriter,C:\repos\NetTopologySuite_NetTopologySuite\NetTopologySuite.IO\NetTopologySuite.IO.Oracle\OracleGeometryWriter.cs,ElemInfo,The following statement contains a magic number: switch (gtype - ((int)gtype/100) * 100) { // removes right two digits          case SdoGTemplate.Coordinate:              addInt(elemInfoList' sOffSet);              addInt(elemInfoList' (int)SdoEType.Coordinate);              addInt(elemInfoList' 1); // INTERPRETATION single point                return;            case SdoGTemplate.MultiPoint:              var points = (IMultiPoint) geom;                addInt(elemInfoList' sOffSet);              addInt(elemInfoList' (int)SdoEType.Coordinate);              addInt(elemInfoList' ElemInfoInterpretation(points' SdoEType.Coordinate));                return;            case SdoGTemplate.Line:              addInt(elemInfoList' sOffSet);              addInt(elemInfoList' (int)SdoEType.Line);              addInt(elemInfoList' 1); // INTERPRETATION straight edges                    return;            case SdoGTemplate.MultiLine:          	var lines = (IMultiLineString) geom;              ILineString line;              int offset = sOffSet;              int dim = (int)gtype/1000;              int len = dim + ((int)gtype-dim*1000)/100;                for (int i = 0; i < lines.NumGeometries; i++) {                  line = (ILineString) lines.GetGeometryN(i);                  addInt(elemInfoList' offset);                  addInt(elemInfoList' (int)SdoEType.Line);                  addInt(elemInfoList' 1); // INTERPRETATION straight edges                    offset += (line.NumPoints * len);              }                return;            case SdoGTemplate.Polygon:          	var polygon = (IPolygon)geom;              int holes = polygon.NumInteriorRings;                if (holes == 0) {                  addInt(elemInfoList' sOffSet);                  addInt(elemInfoList' (int)ElemInfoEType(polygon));                  addInt(elemInfoList' ElemInfoInterpretation(polygon' SdoEType.PolygonExterior));                  return;              }                dim = (int)gtype/1000;              len = dim + ((int)gtype-dim*1000)/100;              offset = sOffSet;              ILineString ring;                ring = polygon.ExteriorRing;              addInt(elemInfoList' offset);              addInt(elemInfoList' (int)ElemInfoEType(polygon));              addInt(elemInfoList' ElemInfoInterpretation(polygon' SdoEType.PolygonExterior));              offset += (ring.NumPoints * len);                for (int i = 1; i <= holes; i++) {                  ring = polygon.GetInteriorRingN(i - 1);                  addInt(elemInfoList' offset);                  addInt(elemInfoList' (int)SdoEType.PolygonInterior);                  addInt(elemInfoList' ElemInfoInterpretation(ring' SdoEType.PolygonInterior));                  offset += (ring.NumPoints * len);              }                return;            case SdoGTemplate.MultiPolygon:          	var polys = (IMultiPolygon) geom;              IPolygon poly;              offset = sOffSet;                dim = (int)gtype/1000;              len = dim + ((int)gtype-dim*1000)/100;                for (int i = 0; i < polys.NumGeometries; i++) {                  poly = (IPolygon) polys.GetGeometryN(i);                  ElemInfo(elemInfoList' poly' offset' GType(poly));                  if( IsRectangle( poly )){                      offset += (2 * len);                                  }                  else {                      offset += (poly.NumPoints * len);                                  }                          }                return;            case SdoGTemplate.Collection:          	var geoms = (IGeometryCollection) geom;              offset = sOffSet;              dim = (int)gtype/1000;              len = dim + ((int)gtype-dim*1000)/100;                for (int i = 0; i < geoms.NumGeometries; i++) {                  geom = geoms.GetGeometryN(i);                  // MD  20/3/07 modified to provide gType of component geometry                  ElemInfo(elemInfoList' geom' offset' GType(geom));                  if( geom is IPolygon && IsRectangle( (IPolygon) geom )){                      offset += (2 * len);                                  }                  else {                      offset += (geom.NumPoints * len);                                  }                                      }                return;          }
Magic Number,NetTopologySuite.IO,OracleGeometryWriter,C:\repos\NetTopologySuite_NetTopologySuite\NetTopologySuite.IO\NetTopologySuite.IO.Oracle\OracleGeometryWriter.cs,IsRectangle,The following statement contains a magic number: if (coords.Length != 5) {              return false;          }
Magic Number,NetTopologySuite.IO,OracleGeometryWriter,C:\repos\NetTopologySuite_NetTopologySuite\NetTopologySuite.IO\NetTopologySuite.IO.Oracle\OracleGeometryWriter.cs,IsRectangle,The following statement contains a magic number: if ((coords[0] == null) || (coords[1] == null) || (coords[2] == null)                  || (coords[3] == null)) {              return false;          }
Magic Number,NetTopologySuite.IO,OracleGeometryWriter,C:\repos\NetTopologySuite_NetTopologySuite\NetTopologySuite.IO\NetTopologySuite.IO.Oracle\OracleGeometryWriter.cs,IsRectangle,The following statement contains a magic number: if ((coords[0] == null) || (coords[1] == null) || (coords[2] == null)                  || (coords[3] == null)) {              return false;          }
Magic Number,NetTopologySuite.IO,OracleGeometryWriter,C:\repos\NetTopologySuite_NetTopologySuite\NetTopologySuite.IO\NetTopologySuite.IO.Oracle\OracleGeometryWriter.cs,IsRectangle,The following statement contains a magic number: if (!coords[0].Equals2D(coords[4])) {              return false;          }
Magic Number,NetTopologySuite.IO,OracleGeometryWriter,C:\repos\NetTopologySuite_NetTopologySuite\NetTopologySuite.IO\NetTopologySuite.IO.Oracle\OracleGeometryWriter.cs,IsRectangle,The following statement contains a magic number: double x3 = coords[2].X;
Magic Number,NetTopologySuite.IO,OracleGeometryWriter,C:\repos\NetTopologySuite_NetTopologySuite\NetTopologySuite.IO\NetTopologySuite.IO.Oracle\OracleGeometryWriter.cs,IsRectangle,The following statement contains a magic number: double y3 = coords[2].Y;
Magic Number,NetTopologySuite.IO,OracleGeometryWriter,C:\repos\NetTopologySuite_NetTopologySuite\NetTopologySuite.IO\NetTopologySuite.IO.Oracle\OracleGeometryWriter.cs,IsRectangle,The following statement contains a magic number: double x4 = coords[3].X;
Magic Number,NetTopologySuite.IO,OracleGeometryWriter,C:\repos\NetTopologySuite_NetTopologySuite\NetTopologySuite.IO\NetTopologySuite.IO.Oracle\OracleGeometryWriter.cs,IsRectangle,The following statement contains a magic number: double y4 = coords[3].Y;
Magic Number,NetTopologySuite.IO,OracleGeometryWriter,C:\repos\NetTopologySuite_NetTopologySuite\NetTopologySuite.IO\NetTopologySuite.IO.Oracle\OracleGeometryWriter.cs,ElemInfoInterpretation,The following statement contains a magic number: switch (etype) {            case SdoEType.Coordinate:                if (geom is IPoint) {                  return 1;              }                if (geom is IMultiPoint) {                  return geom.NumGeometries;              }                break;            case SdoEType.Line:          	// always straight for jts              return 1;            case SdoEType.Polygon:          case SdoEType.PolygonExterior:          case SdoEType.PolygonInterior:                if (geom is IPolygon) {                  var polygon = (IPolygon) geom;              	// always straight for jts                  if (IsRectangle(polygon)) {                      return 3;                  }              }                return 1;          }
Magic Number,NetTopologySuite.IO,OracleGeometryWriter,C:\repos\NetTopologySuite_NetTopologySuite\NetTopologySuite.IO\NetTopologySuite.IO.Oracle\OracleGeometryWriter.cs,GType,The following statement contains a magic number: int d = (int)Dimension(geom) * 1000;
Magic Number,NetTopologySuite.IO,OracleGeometryWriter,C:\repos\NetTopologySuite_NetTopologySuite\NetTopologySuite.IO\NetTopologySuite.IO.Oracle\OracleGeometryWriter.cs,GType,The following statement contains a magic number: int l = Lrs(geom) * 100;
Magic Number,NetTopologySuite.IO,OracleGeometryWriter,C:\repos\NetTopologySuite_NetTopologySuite\NetTopologySuite.IO\NetTopologySuite.IO.Oracle\OracleGeometryWriter.cs,Dimension,The following statement contains a magic number: var d = Double.IsNaN(geom.Coordinate.Z)?2:3;
Magic Number,NetTopologySuite.IO,OracleGeometryWriter,C:\repos\NetTopologySuite_NetTopologySuite\NetTopologySuite.IO\NetTopologySuite.IO.Oracle\OracleGeometryWriter.cs,Dimension,The following statement contains a magic number: var d = Double.IsNaN(geom.Coordinate.Z)?2:3;
Magic Number,NetTopologySuite.IO.Sdo,SdoGeometry,C:\repos\NetTopologySuite_NetTopologySuite\NetTopologySuite.IO\NetTopologySuite.IO.Oracle\Sdo\SdoGeometry.cs,GetMinMax,The following statement contains a magic number: Int32 dim = Math.Min(((Int32)SdoGtype.Value)/1000' 3);
Magic Number,NetTopologySuite.IO.Sdo,SdoGeometry,C:\repos\NetTopologySuite_NetTopologySuite\NetTopologySuite.IO\NetTopologySuite.IO.Oracle\Sdo\SdoGeometry.cs,GetMinMax,The following statement contains a magic number: Int32 dim = Math.Min(((Int32)SdoGtype.Value)/1000' 3);
Magic Number,NetTopologySuite.IO.Sdo,SdoGeometry,C:\repos\NetTopologySuite_NetTopologySuite\NetTopologySuite.IO\NetTopologySuite.IO.Oracle\Sdo\SdoGeometry.cs,GetMinMax,The following statement contains a magic number: if (_point != null)              {                  _minX = _maxX = _point.X;                  _minY = _maxY = _point.Y;                  if (dim > 2)_minZ = _maxZ = _point.Z;              }
Magic Number,NetTopologySuite.IO.Sdo,SdoGeometry,C:\repos\NetTopologySuite_NetTopologySuite\NetTopologySuite.IO\NetTopologySuite.IO.Oracle\Sdo\SdoGeometry.cs,GetMinMax,The following statement contains a magic number: if ( _ordinatesArray != null )              {                  for (int i = 0; i < _ordinatesArray.Length; i+=dim )                  {                      _minX = _minX.HasValue ? Math.Min(_minX.Value' _ordinatesArray[i]) : _ordinatesArray[i];                       _minY = _minY.HasValue ? Math.Min(_minY.Value' _ordinatesArray[i+1]) : _ordinatesArray[i+1];                      if ( dim > 2 ) _minZ = _minZ.HasValue ? Math.Min(_minZ.Value' _ordinatesArray[i+2]) : _ordinatesArray[i+2];                      _maxX = _maxX.HasValue ? Math.Max(_maxX.Value' _ordinatesArray[i]) : _ordinatesArray[i];                      _maxY = _maxY.HasValue ? Math.Max(_maxY.Value' _ordinatesArray[i+1]) : _ordinatesArray[i+1];                      if ( dim > 2 )_maxZ = _maxZ.HasValue ? Math.Max(_maxZ.Value' _ordinatesArray[i+2]) : _ordinatesArray[i+2];                  }              }
Magic Number,NetTopologySuite.IO.Sdo,SdoGeometry,C:\repos\NetTopologySuite_NetTopologySuite\NetTopologySuite.IO\NetTopologySuite.IO.Oracle\Sdo\SdoGeometry.cs,GetMinMax,The following statement contains a magic number: if ( _ordinatesArray != null )              {                  for (int i = 0; i < _ordinatesArray.Length; i+=dim )                  {                      _minX = _minX.HasValue ? Math.Min(_minX.Value' _ordinatesArray[i]) : _ordinatesArray[i];                       _minY = _minY.HasValue ? Math.Min(_minY.Value' _ordinatesArray[i+1]) : _ordinatesArray[i+1];                      if ( dim > 2 ) _minZ = _minZ.HasValue ? Math.Min(_minZ.Value' _ordinatesArray[i+2]) : _ordinatesArray[i+2];                      _maxX = _maxX.HasValue ? Math.Max(_maxX.Value' _ordinatesArray[i]) : _ordinatesArray[i];                      _maxY = _maxY.HasValue ? Math.Max(_maxY.Value' _ordinatesArray[i+1]) : _ordinatesArray[i+1];                      if ( dim > 2 )_maxZ = _maxZ.HasValue ? Math.Max(_maxZ.Value' _ordinatesArray[i+2]) : _ordinatesArray[i+2];                  }              }
Magic Number,NetTopologySuite.IO.Sdo,SdoGeometry,C:\repos\NetTopologySuite_NetTopologySuite\NetTopologySuite.IO\NetTopologySuite.IO.Oracle\Sdo\SdoGeometry.cs,GetMinMax,The following statement contains a magic number: if ( _ordinatesArray != null )              {                  for (int i = 0; i < _ordinatesArray.Length; i+=dim )                  {                      _minX = _minX.HasValue ? Math.Min(_minX.Value' _ordinatesArray[i]) : _ordinatesArray[i];                       _minY = _minY.HasValue ? Math.Min(_minY.Value' _ordinatesArray[i+1]) : _ordinatesArray[i+1];                      if ( dim > 2 ) _minZ = _minZ.HasValue ? Math.Min(_minZ.Value' _ordinatesArray[i+2]) : _ordinatesArray[i+2];                      _maxX = _maxX.HasValue ? Math.Max(_maxX.Value' _ordinatesArray[i]) : _ordinatesArray[i];                      _maxY = _maxY.HasValue ? Math.Max(_maxY.Value' _ordinatesArray[i+1]) : _ordinatesArray[i+1];                      if ( dim > 2 )_maxZ = _maxZ.HasValue ? Math.Max(_maxZ.Value' _ordinatesArray[i+2]) : _ordinatesArray[i+2];                  }              }
Magic Number,NetTopologySuite.IO.Sdo,SdoGeometry,C:\repos\NetTopologySuite_NetTopologySuite\NetTopologySuite.IO\NetTopologySuite.IO.Oracle\Sdo\SdoGeometry.cs,GetMinMax,The following statement contains a magic number: if ( _ordinatesArray != null )              {                  for (int i = 0; i < _ordinatesArray.Length; i+=dim )                  {                      _minX = _minX.HasValue ? Math.Min(_minX.Value' _ordinatesArray[i]) : _ordinatesArray[i];                       _minY = _minY.HasValue ? Math.Min(_minY.Value' _ordinatesArray[i+1]) : _ordinatesArray[i+1];                      if ( dim > 2 ) _minZ = _minZ.HasValue ? Math.Min(_minZ.Value' _ordinatesArray[i+2]) : _ordinatesArray[i+2];                      _maxX = _maxX.HasValue ? Math.Max(_maxX.Value' _ordinatesArray[i]) : _ordinatesArray[i];                      _maxY = _maxY.HasValue ? Math.Max(_maxY.Value' _ordinatesArray[i+1]) : _ordinatesArray[i+1];                      if ( dim > 2 )_maxZ = _maxZ.HasValue ? Math.Max(_maxZ.Value' _ordinatesArray[i+2]) : _ordinatesArray[i+2];                  }              }
Magic Number,NetTopologySuite.IO.Sdo,SdoGeometry,C:\repos\NetTopologySuite_NetTopologySuite\NetTopologySuite.IO\NetTopologySuite.IO.Oracle\Sdo\SdoGeometry.cs,GetMinMax,The following statement contains a magic number: if ( _ordinatesArray != null )              {                  for (int i = 0; i < _ordinatesArray.Length; i+=dim )                  {                      _minX = _minX.HasValue ? Math.Min(_minX.Value' _ordinatesArray[i]) : _ordinatesArray[i];                       _minY = _minY.HasValue ? Math.Min(_minY.Value' _ordinatesArray[i+1]) : _ordinatesArray[i+1];                      if ( dim > 2 ) _minZ = _minZ.HasValue ? Math.Min(_minZ.Value' _ordinatesArray[i+2]) : _ordinatesArray[i+2];                      _maxX = _maxX.HasValue ? Math.Max(_maxX.Value' _ordinatesArray[i]) : _ordinatesArray[i];                      _maxY = _maxY.HasValue ? Math.Max(_maxY.Value' _ordinatesArray[i+1]) : _ordinatesArray[i+1];                      if ( dim > 2 )_maxZ = _maxZ.HasValue ? Math.Max(_maxZ.Value' _ordinatesArray[i+2]) : _ordinatesArray[i+2];                  }              }
Magic Number,NetTopologySuite.IO.Sdo,SdoGeometry,C:\repos\NetTopologySuite_NetTopologySuite\NetTopologySuite.IO\NetTopologySuite.IO.Oracle\Sdo\SdoGeometry.cs,GetMinMax,The following statement contains a magic number: if ( _ordinatesArray != null )              {                  for (int i = 0; i < _ordinatesArray.Length; i+=dim )                  {                      _minX = _minX.HasValue ? Math.Min(_minX.Value' _ordinatesArray[i]) : _ordinatesArray[i];                       _minY = _minY.HasValue ? Math.Min(_minY.Value' _ordinatesArray[i+1]) : _ordinatesArray[i+1];                      if ( dim > 2 ) _minZ = _minZ.HasValue ? Math.Min(_minZ.Value' _ordinatesArray[i+2]) : _ordinatesArray[i+2];                      _maxX = _maxX.HasValue ? Math.Max(_maxX.Value' _ordinatesArray[i]) : _ordinatesArray[i];                      _maxY = _maxY.HasValue ? Math.Max(_maxY.Value' _ordinatesArray[i+1]) : _ordinatesArray[i+1];                      if ( dim > 2 )_maxZ = _maxZ.HasValue ? Math.Max(_maxZ.Value' _ordinatesArray[i+2]) : _ordinatesArray[i+2];                  }              }
Missing Default,NetTopologySuite.IO,OracleGeometryReader,C:\repos\NetTopologySuite_NetTopologySuite\NetTopologySuite.IO\NetTopologySuite.IO.Oracle\OracleGeometryReader.cs,Coordinates,The following switch statement is missing a default case: switch (len)                  {                      case 2:                          pts.Add(new Coordinate((Double) ordinates[offset]' (Double) ordinates[offset + 1]' Double.NaN));                          break;                      case 3:                          pts.Add(new Coordinate((Double) ordinates[offset]' (Double) ordinates[offset + 1]'                                                 (Double) ordinates[offset + 2]));                          break;                  }
Missing Default,NetTopologySuite.IO,OracleGeometryWriter,C:\repos\NetTopologySuite_NetTopologySuite\NetTopologySuite.IO\NetTopologySuite.IO.Oracle\OracleGeometryWriter.cs,coordinates,The following switch statement is missing a default case: switch (Template(geom)) {            case SdoGTemplate.Coordinate:              AddCoordinates(list' ((IPoint)geom).CoordinateSequence);              return;          case SdoGTemplate.Line:              AddCoordinates(list' ((ILineString)geom).CoordinateSequence);              return;          case SdoGTemplate.Polygon:              switch (ElemInfoInterpretation(geom'SdoEType.PolygonExterior)) {              case 3:                  var e = geom.EnvelopeInternal;                  list.Add(new[] { e.MinX' e.MinY });                  list.Add(new[] { e.MaxX' e.MaxY });                  return;              case 1:              	var polygon = (IPolygon) geom;                  int holes = polygon.NumInteriorRings;                                    // check outer ring's direction                  var ring = polygon.ExteriorRing.CoordinateSequence;                  if (!Algorithm.CGAlgorithms.IsCCW(ring.ToCoordinateArray())) {                      ring = reverse(polygon.Factory.CoordinateSequenceFactory' ring);                   }                  AddCoordinates(list'ring);                    for (int i = 0; i < holes; i++) {                  	// check inner ring's direction                  	ring = polygon.InteriorRings[i].CoordinateSequence;                  	if (Algorithm.CGAlgorithms.IsCCW(ring.ToCoordinateArray())) {                          ring = reverse(polygon.Factory.CoordinateSequenceFactory' ring);                       }                                            AddCoordinates(list'ring);                  }                  return;              }              break; // interpretations 2'4 not supported          case SdoGTemplate.MultiPoint:          case SdoGTemplate.MultiLine:          case SdoGTemplate.MultiPolygon:          case SdoGTemplate.Collection:              for (int i = 0; i < geom.NumGeometries; i++) {                  coordinates(list'geom.GetGeometryN(i));              }              return;          }
Missing Default,NetTopologySuite.IO,OracleGeometryWriter,C:\repos\NetTopologySuite_NetTopologySuite\NetTopologySuite.IO\NetTopologySuite.IO.Oracle\OracleGeometryWriter.cs,coordinates,The following switch statement is missing a default case: switch (ElemInfoInterpretation(geom'SdoEType.PolygonExterior)) {              case 3:                  var e = geom.EnvelopeInternal;                  list.Add(new[] { e.MinX' e.MinY });                  list.Add(new[] { e.MaxX' e.MaxY });                  return;              case 1:              	var polygon = (IPolygon) geom;                  int holes = polygon.NumInteriorRings;                                    // check outer ring's direction                  var ring = polygon.ExteriorRing.CoordinateSequence;                  if (!Algorithm.CGAlgorithms.IsCCW(ring.ToCoordinateArray())) {                      ring = reverse(polygon.Factory.CoordinateSequenceFactory' ring);                   }                  AddCoordinates(list'ring);                    for (int i = 0; i < holes; i++) {                  	// check inner ring's direction                  	ring = polygon.InteriorRings[i].CoordinateSequence;                  	if (Algorithm.CGAlgorithms.IsCCW(ring.ToCoordinateArray())) {                          ring = reverse(polygon.Factory.CoordinateSequenceFactory' ring);                       }                                            AddCoordinates(list'ring);                  }                  return;              }
Missing Default,NetTopologySuite.IO,OracleGeometryWriter,C:\repos\NetTopologySuite_NetTopologySuite\NetTopologySuite.IO\NetTopologySuite.IO.Oracle\OracleGeometryWriter.cs,ElemInfo,The following switch statement is missing a default case: switch (gtype - ((int)gtype/100) * 100) { // removes right two digits          case SdoGTemplate.Coordinate:              addInt(elemInfoList' sOffSet);              addInt(elemInfoList' (int)SdoEType.Coordinate);              addInt(elemInfoList' 1); // INTERPRETATION single point                return;            case SdoGTemplate.MultiPoint:              var points = (IMultiPoint) geom;                addInt(elemInfoList' sOffSet);              addInt(elemInfoList' (int)SdoEType.Coordinate);              addInt(elemInfoList' ElemInfoInterpretation(points' SdoEType.Coordinate));                return;            case SdoGTemplate.Line:              addInt(elemInfoList' sOffSet);              addInt(elemInfoList' (int)SdoEType.Line);              addInt(elemInfoList' 1); // INTERPRETATION straight edges                    return;            case SdoGTemplate.MultiLine:          	var lines = (IMultiLineString) geom;              ILineString line;              int offset = sOffSet;              int dim = (int)gtype/1000;              int len = dim + ((int)gtype-dim*1000)/100;                for (int i = 0; i < lines.NumGeometries; i++) {                  line = (ILineString) lines.GetGeometryN(i);                  addInt(elemInfoList' offset);                  addInt(elemInfoList' (int)SdoEType.Line);                  addInt(elemInfoList' 1); // INTERPRETATION straight edges                    offset += (line.NumPoints * len);              }                return;            case SdoGTemplate.Polygon:          	var polygon = (IPolygon)geom;              int holes = polygon.NumInteriorRings;                if (holes == 0) {                  addInt(elemInfoList' sOffSet);                  addInt(elemInfoList' (int)ElemInfoEType(polygon));                  addInt(elemInfoList' ElemInfoInterpretation(polygon' SdoEType.PolygonExterior));                  return;              }                dim = (int)gtype/1000;              len = dim + ((int)gtype-dim*1000)/100;              offset = sOffSet;              ILineString ring;                ring = polygon.ExteriorRing;              addInt(elemInfoList' offset);              addInt(elemInfoList' (int)ElemInfoEType(polygon));              addInt(elemInfoList' ElemInfoInterpretation(polygon' SdoEType.PolygonExterior));              offset += (ring.NumPoints * len);                for (int i = 1; i <= holes; i++) {                  ring = polygon.GetInteriorRingN(i - 1);                  addInt(elemInfoList' offset);                  addInt(elemInfoList' (int)SdoEType.PolygonInterior);                  addInt(elemInfoList' ElemInfoInterpretation(ring' SdoEType.PolygonInterior));                  offset += (ring.NumPoints * len);              }                return;            case SdoGTemplate.MultiPolygon:          	var polys = (IMultiPolygon) geom;              IPolygon poly;              offset = sOffSet;                dim = (int)gtype/1000;              len = dim + ((int)gtype-dim*1000)/100;                for (int i = 0; i < polys.NumGeometries; i++) {                  poly = (IPolygon) polys.GetGeometryN(i);                  ElemInfo(elemInfoList' poly' offset' GType(poly));                  if( IsRectangle( poly )){                      offset += (2 * len);                                  }                  else {                      offset += (poly.NumPoints * len);                                  }                          }                return;            case SdoGTemplate.Collection:          	var geoms = (IGeometryCollection) geom;              offset = sOffSet;              dim = (int)gtype/1000;              len = dim + ((int)gtype-dim*1000)/100;                for (int i = 0; i < geoms.NumGeometries; i++) {                  geom = geoms.GetGeometryN(i);                  // MD  20/3/07 modified to provide gType of component geometry                  ElemInfo(elemInfoList' geom' offset' GType(geom));                  if( geom is IPolygon && IsRectangle( (IPolygon) geom )){                      offset += (2 * len);                                  }                  else {                      offset += (geom.NumPoints * len);                                  }                                      }                return;          }
Missing Default,NetTopologySuite.IO,OracleGeometryWriter,C:\repos\NetTopologySuite_NetTopologySuite\NetTopologySuite.IO\NetTopologySuite.IO.Oracle\OracleGeometryWriter.cs,ElemInfoInterpretation,The following switch statement is missing a default case: switch (etype) {            case SdoEType.Coordinate:                if (geom is IPoint) {                  return 1;              }                if (geom is IMultiPoint) {                  return geom.NumGeometries;              }                break;            case SdoEType.Line:          	// always straight for jts              return 1;            case SdoEType.Polygon:          case SdoEType.PolygonExterior:          case SdoEType.PolygonInterior:                if (geom is IPolygon) {                  var polygon = (IPolygon) geom;              	// always straight for jts                  if (IsRectangle(polygon)) {                      return 3;                  }              }                return 1;          }
