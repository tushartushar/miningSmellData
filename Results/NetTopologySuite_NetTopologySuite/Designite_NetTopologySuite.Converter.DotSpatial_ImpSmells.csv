Implementation smell,Namespace,Class,File,Method,Description
Complex Method,DotSpatial.Topology,GeometryConverter,C:\repos\NetTopologySuite_NetTopologySuite\NetTopologySuite.Converter\NetTopologySuite.Converter.DotSpatial\GeometryConverterToGeoAPI.cs,FromGeometry,Cyclomatic complexity of the method is 8
Complex Method,DotSpatial.Topology,GeometryConverter,C:\repos\NetTopologySuite_NetTopologySuite\NetTopologySuite.Converter\NetTopologySuite.Converter.DotSpatial\GeometryConverterToGeoAPI.cs,FromPolygonShape,Cyclomatic complexity of the method is 15
Magic Number,GeoAPI.Geometries,GeometryConverter,C:\repos\NetTopologySuite_NetTopologySuite\NetTopologySuite.Converter\NetTopologySuite.Converter.DotSpatial\GeometryConverterToDotSpatial.cs,ToDotSpatialShape,The following statement contains a magic number: var vertices = new double[geometry.NumPoints * 2];
Magic Number,GeoAPI.Geometries,GeometryConverter,C:\repos\NetTopologySuite_NetTopologySuite\NetTopologySuite.Converter\NetTopologySuite.Converter.DotSpatial\GeometryConverterToDotSpatial.cs,ToDotSpatialShape,The following statement contains a magic number: for (var i = 0; i < coords.Length; i++)              {                  var c = coords[i];                  vertices[i * 2] = c.X;                  vertices[i * 2 + 1] = c.Y;                    if (!Double.IsNaN(c.Z))                  {                      z[i] = c.Z;                      shape.MinZ = shape.MinZ < c.Z ? shape.MinZ : c.Z;                      shape.MaxZ = shape.MaxZ < c.Z ? shape.MaxZ : c.Z;                      hasZ = true;                  }                  /*                  if (!Double.IsNaN(c.M))                  {                      m[i] = c.M;                      shape.MinM = shape.MinM < c.M ? shape.MinM : c.M;                      shape.MaxM = shape.MaxM < c.M ? shape.MaxM : c.M;                      hasZ = true;                  }                   */              }
Magic Number,GeoAPI.Geometries,GeometryConverter,C:\repos\NetTopologySuite_NetTopologySuite\NetTopologySuite.Converter\NetTopologySuite.Converter.DotSpatial\GeometryConverterToDotSpatial.cs,ToDotSpatialShape,The following statement contains a magic number: for (var i = 0; i < coords.Length; i++)              {                  var c = coords[i];                  vertices[i * 2] = c.X;                  vertices[i * 2 + 1] = c.Y;                    if (!Double.IsNaN(c.Z))                  {                      z[i] = c.Z;                      shape.MinZ = shape.MinZ < c.Z ? shape.MinZ : c.Z;                      shape.MaxZ = shape.MaxZ < c.Z ? shape.MaxZ : c.Z;                      hasZ = true;                  }                  /*                  if (!Double.IsNaN(c.M))                  {                      m[i] = c.M;                      shape.MinM = shape.MinM < c.M ? shape.MinM : c.M;                      shape.MaxM = shape.MaxM < c.M ? shape.MaxM : c.M;                      hasZ = true;                  }                   */              }
Magic Number,GeoAPI.Geometries,GeometryConverter,C:\repos\NetTopologySuite_NetTopologySuite\NetTopologySuite.Converter\NetTopologySuite.Converter.DotSpatial\GeometryConverterToDotSpatial.cs,ShapeRangeFromGeometry,The following statement contains a magic number: var vIndex = offset / 2;
Missing Default,DotSpatial.Data,FeatureSetEx,C:\repos\NetTopologySuite_NetTopologySuite\NetTopologySuite.Converter\NetTopologySuite.Converter.DotSpatial\DotSpatialEx.cs,Select,The following switch statement is missing a default case: switch (predicate)                  {                      case SpatialPredicate.Intersects:                          valid = pg.Intersects(tryShape);                          break;                      case SpatialPredicate.Overlaps:                          valid = pg.Overlaps(tryShape);                          break;                      case SpatialPredicate.Touches:                          valid = pg.Touches(tryShape);                          break;                      case SpatialPredicate.Within:                          valid = pg.Within(tryShape);                          break;                      case SpatialPredicate.Contains:                          valid = pg.Contains(tryShape);                          break;                      case SpatialPredicate.ContainsProperly:                          valid = pg.ContainsProperly(tryShape);                          break;                      case SpatialPredicate.Covers:                          valid = pg.Covers(tryShape);                          break;                      case SpatialPredicate.CoveredBy:                          valid = pg.CoveredBy(tryShape);                          break;                      case SpatialPredicate.Disjoint:                          valid = pg.Disjoint(tryShape);                          break;                  }
Missing Default,DotSpatial.Topology,GeometryConverter,C:\repos\NetTopologySuite_NetTopologySuite\NetTopologySuite.Converter\NetTopologySuite.Converter.DotSpatial\GeometryConverterToGeoAPI.cs,ToGeoAPI,The following switch statement is missing a default case: switch (model)              {                  case PrecisionModelType.Floating:                      geoAPIPrecisionModel = geoService.CreatePrecisionModel(GeoAPI.Geometries.PrecisionModels.Floating);                      break;                  case PrecisionModelType.FloatingSingle:                      geoAPIPrecisionModel = geoService.CreatePrecisionModel(GeoAPI.Geometries.PrecisionModels.FloatingSingle);                      break;                  case PrecisionModelType.Fixed:                      geoAPIPrecisionModel = geoService.CreatePrecisionModel(GeoAPI.Geometries.PrecisionModels.Fixed);                      break;              }
