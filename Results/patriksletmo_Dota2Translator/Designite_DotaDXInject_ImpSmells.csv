Implementation smell,Namespace,Class,File,Method,Description
Long Method,DotaDXInject,DXHookD3D9,C:\repos\patriksletmo_Dota2Translator\DotaDXInject\DirectX\DXHookD3D9.cs,EndSceneHook,The method has 119 lines of code.
Long Statement,DotaDXInject,DXHookD3D9,C:\repos\patriksletmo_Dota2Translator\DotaDXInject\DirectX\DXHookD3D9.cs,Hook,The length of the statement  "                    using (device = new Device(d3d' 0' DeviceType.NullReference' hWnd' CreateFlags.HardwareVertexProcessing' new PresentParameters() { EnableAutoDepthStencil = false' BackBufferWidth = 1' BackBufferHeight = 1' DeviceWindowHandle = hWnd })) " is 235.
Long Statement,DotaDXInject,DXHookD3D9,C:\repos\patriksletmo_Dota2Translator\DotaDXInject\DirectX\DXHookD3D9.cs,ResetHook,The length of the statement  "                // EasyHook has already repatched the original Reset so calling it here will not cause an endless recursion to this function " is 124.
Long Statement,DotaDXInject,DXHookD3D9,C:\repos\patriksletmo_Dota2Translator\DotaDXInject\DirectX\DXHookD3D9.cs,EndSceneHook,The length of the statement  "                        using (SlimDX.Direct3D9.Font successFont = new SlimDX.Direct3D9.Font(device' new System.Drawing.Font("Times New Roman"' 80.0f / 1920f * width))) " is 144.
Long Statement,DotaDXInject,DXHookD3D9,C:\repos\patriksletmo_Dota2Translator\DotaDXInject\DirectX\DXHookD3D9.cs,EndSceneHook,The length of the statement  "                            // Draw the font with an alpha value related to the time passed since the overlay was added. The font will be completely invisible when the time has passed. " is 156.
Long Statement,DotaDXInject,DXHookD3D9,C:\repos\patriksletmo_Dota2Translator\DotaDXInject\DirectX\DXHookD3D9.cs,EndSceneHook,The length of the statement  "                            successFont.DrawString(null' "Overlay added!"' 50' 50' Color.FromArgb((int)((SuccessMessageTime - millisSinceAdd) / SuccessMessageTime * 255.0)' TextColor)); " is 157.
Long Statement,DotaDXInject,DXHookD3D9,C:\repos\patriksletmo_Dota2Translator\DotaDXInject\DirectX\DXHookD3D9.cs,EndSceneHook,The length of the statement  "                        if (OverlayFont == null || !FontName.Equals(LastFontName) || LastMessagesShown != MessagesShown || AutoMessageHeight != LastAutoMessageHeight || MessageHeight != LastMessageHeight) " is 180.
Long Statement,DotaDXInject,DXHookD3D9,C:\repos\patriksletmo_Dota2Translator\DotaDXInject\DirectX\DXHookD3D9.cs,EndSceneHook,The length of the statement  "                                float fadeDuration = (message.Time.AddSeconds(FadeWait + FadeDuration) - message.Time.AddSeconds(FadeWait)).Ticks / TimeSpan.TicksPerMillisecond; " is 145.
Long Statement,DotaDXInject,DXHookD3D9,C:\repos\patriksletmo_Dota2Translator\DotaDXInject\DirectX\DXHookD3D9.cs,EndSceneHook,The length of the statement  "                                    OverlayFont.DrawString(null' message.WrappedMessage[j]' TextStartWidth + FontHeight / 2 + message.SenderWidth' stringY + 1' TextShadowColor); " is 141.
Long Statement,DotaDXInject,DXHookD3D9,C:\repos\patriksletmo_Dota2Translator\DotaDXInject\DirectX\DXHookD3D9.cs,EndSceneHook,The length of the statement  "                                OverlayFont.DrawString(null' message.WrappedMessage[j]' TextStartWidth - 1 + FontHeight / 2 + message.SenderWidth' stringY' drawColor); " is 135.
Complex Conditional,DotaDXInject,DXHookD3D9,C:\repos\patriksletmo_Dota2Translator\DotaDXInject\DirectX\DXHookD3D9.cs,EndSceneHook,The conditional expression  "OverlayFont == null || !FontName.Equals(LastFontName) || LastMessagesShown != MessagesShown || AutoMessageHeight != LastAutoMessageHeight || MessageHeight != LastMessageHeight"  is complex.
Empty Catch Block,DotaDXInject,DotaInjection,C:\repos\patriksletmo_Dota2Translator\DotaDXInject\DotaInjection.cs,Run,The method has an empty catch block.
Empty Catch Block,DotaDXInject,DotaInjection,C:\repos\patriksletmo_Dota2Translator\DotaDXInject\DotaInjection.cs,Run,The method has an empty catch block.
Empty Catch Block,DotaDXInject,DXHookD3D9,C:\repos\patriksletmo_Dota2Translator\DotaDXInject\DirectX\DXHookD3D9.cs,Cleanup,The method has an empty catch block.
Empty Catch Block,DotaDXInject,DXHookD3D9,C:\repos\patriksletmo_Dota2Translator\DotaDXInject\DirectX\DXHookD3D9.cs,EndSceneHook,The method has an empty catch block.
Magic Number,DotaDXInject,DotaInjection,C:\repos\patriksletmo_Dota2Translator\DotaDXInject\DotaInjection.cs,Run,The following statement contains a magic number: try              {                  while (true)                  {                      // Check for new events every 100 millis.                      Thread.Sleep(100);                        // Parse all the pending events.                      object[] pendingEvent;                      while ((pendingEvent = chatInterface.GetPendingEvent()) != null)                      {                          // Handle the event and perform the specified action.                          int type = (int)pendingEvent[0];                          switch (type)                          {                              // Message                              case 0:                                  String sender = (String)pendingEvent[1];                                  String message = (String)pendingEvent[2];                                    directXHook.Messages.Add(new DXHookD3D9.Message(sender' message));                                    break;                              // Hide / Show                              case 1:                                  Boolean hide = (Boolean)pendingEvent[1];                                    directXHook.Hide = hide;                                    break;                              // Setting change                              case 2:                                  String fieldName = (String)pendingEvent[1];                                    FieldInfo info = typeof(DXHookD3D9).GetField(fieldName);                                  info.SetValue(directXHook' pendingEvent[2]);                                    break;                          }                      }                        // Make sure we're still connected.                      chatInterface.Ping();                  }              }              catch              {                  // Ping() will raise an exception if host is unreachable.              }              finally              {                  try                  {                      // Un-register DirectX hooks' clean up variables.                      directXHook.Cleanup();                  }                  catch                  {                  }              }
Magic Number,DotaDXInject,DotaInjection,C:\repos\patriksletmo_Dota2Translator\DotaDXInject\DotaInjection.cs,Run,The following statement contains a magic number: try              {                  while (true)                  {                      // Check for new events every 100 millis.                      Thread.Sleep(100);                        // Parse all the pending events.                      object[] pendingEvent;                      while ((pendingEvent = chatInterface.GetPendingEvent()) != null)                      {                          // Handle the event and perform the specified action.                          int type = (int)pendingEvent[0];                          switch (type)                          {                              // Message                              case 0:                                  String sender = (String)pendingEvent[1];                                  String message = (String)pendingEvent[2];                                    directXHook.Messages.Add(new DXHookD3D9.Message(sender' message));                                    break;                              // Hide / Show                              case 1:                                  Boolean hide = (Boolean)pendingEvent[1];                                    directXHook.Hide = hide;                                    break;                              // Setting change                              case 2:                                  String fieldName = (String)pendingEvent[1];                                    FieldInfo info = typeof(DXHookD3D9).GetField(fieldName);                                  info.SetValue(directXHook' pendingEvent[2]);                                    break;                          }                      }                        // Make sure we're still connected.                      chatInterface.Ping();                  }              }              catch              {                  // Ping() will raise an exception if host is unreachable.              }              finally              {                  try                  {                      // Un-register DirectX hooks' clean up variables.                      directXHook.Cleanup();                  }                  catch                  {                  }              }
Magic Number,DotaDXInject,DotaInjection,C:\repos\patriksletmo_Dota2Translator\DotaDXInject\DotaInjection.cs,Run,The following statement contains a magic number: try              {                  while (true)                  {                      // Check for new events every 100 millis.                      Thread.Sleep(100);                        // Parse all the pending events.                      object[] pendingEvent;                      while ((pendingEvent = chatInterface.GetPendingEvent()) != null)                      {                          // Handle the event and perform the specified action.                          int type = (int)pendingEvent[0];                          switch (type)                          {                              // Message                              case 0:                                  String sender = (String)pendingEvent[1];                                  String message = (String)pendingEvent[2];                                    directXHook.Messages.Add(new DXHookD3D9.Message(sender' message));                                    break;                              // Hide / Show                              case 1:                                  Boolean hide = (Boolean)pendingEvent[1];                                    directXHook.Hide = hide;                                    break;                              // Setting change                              case 2:                                  String fieldName = (String)pendingEvent[1];                                    FieldInfo info = typeof(DXHookD3D9).GetField(fieldName);                                  info.SetValue(directXHook' pendingEvent[2]);                                    break;                          }                      }                        // Make sure we're still connected.                      chatInterface.Ping();                  }              }              catch              {                  // Ping() will raise an exception if host is unreachable.              }              finally              {                  try                  {                      // Un-register DirectX hooks' clean up variables.                      directXHook.Cleanup();                  }                  catch                  {                  }              }
Magic Number,DotaDXInject,DotaInjection,C:\repos\patriksletmo_Dota2Translator\DotaDXInject\DotaInjection.cs,Run,The following statement contains a magic number: try              {                  while (true)                  {                      // Check for new events every 100 millis.                      Thread.Sleep(100);                        // Parse all the pending events.                      object[] pendingEvent;                      while ((pendingEvent = chatInterface.GetPendingEvent()) != null)                      {                          // Handle the event and perform the specified action.                          int type = (int)pendingEvent[0];                          switch (type)                          {                              // Message                              case 0:                                  String sender = (String)pendingEvent[1];                                  String message = (String)pendingEvent[2];                                    directXHook.Messages.Add(new DXHookD3D9.Message(sender' message));                                    break;                              // Hide / Show                              case 1:                                  Boolean hide = (Boolean)pendingEvent[1];                                    directXHook.Hide = hide;                                    break;                              // Setting change                              case 2:                                  String fieldName = (String)pendingEvent[1];                                    FieldInfo info = typeof(DXHookD3D9).GetField(fieldName);                                  info.SetValue(directXHook' pendingEvent[2]);                                    break;                          }                      }                        // Make sure we're still connected.                      chatInterface.Ping();                  }              }              catch              {                  // Ping() will raise an exception if host is unreachable.              }              finally              {                  try                  {                      // Un-register DirectX hooks' clean up variables.                      directXHook.Cleanup();                  }                  catch                  {                  }              }
Magic Number,DotaDXInject,DXGI,C:\repos\patriksletmo_Dota2Translator\DotaDXInject\DirectX\DXGI.cs,CreateSwapChainDescription,The following statement contains a magic number: return new SlimDX.DXGI.SwapChainDescription              {                  BufferCount = 1'                  Flags = SlimDX.DXGI.SwapChainFlags.None'                  IsWindowed = true'                  ModeDescription = new SlimDX.DXGI.ModeDescription(100' 100' new Rational(60' 1)' SlimDX.DXGI.Format.R8G8B8A8_UNorm)'                  OutputHandle = windowHandle'                  SampleDescription = new SlimDX.DXGI.SampleDescription(1' 0)'                  SwapEffect = SlimDX.DXGI.SwapEffect.Discard'                  Usage = SlimDX.DXGI.Usage.RenderTargetOutput              };
Magic Number,DotaDXInject,DXGI,C:\repos\patriksletmo_Dota2Translator\DotaDXInject\DirectX\DXGI.cs,CreateSwapChainDescription,The following statement contains a magic number: return new SlimDX.DXGI.SwapChainDescription              {                  BufferCount = 1'                  Flags = SlimDX.DXGI.SwapChainFlags.None'                  IsWindowed = true'                  ModeDescription = new SlimDX.DXGI.ModeDescription(100' 100' new Rational(60' 1)' SlimDX.DXGI.Format.R8G8B8A8_UNorm)'                  OutputHandle = windowHandle'                  SampleDescription = new SlimDX.DXGI.SampleDescription(1' 0)'                  SwapEffect = SlimDX.DXGI.SwapEffect.Discard'                  Usage = SlimDX.DXGI.Usage.RenderTargetOutput              };
Magic Number,DotaDXInject,DXGI,C:\repos\patriksletmo_Dota2Translator\DotaDXInject\DirectX\DXGI.cs,CreateSwapChainDescription,The following statement contains a magic number: return new SlimDX.DXGI.SwapChainDescription              {                  BufferCount = 1'                  Flags = SlimDX.DXGI.SwapChainFlags.None'                  IsWindowed = true'                  ModeDescription = new SlimDX.DXGI.ModeDescription(100' 100' new Rational(60' 1)' SlimDX.DXGI.Format.R8G8B8A8_UNorm)'                  OutputHandle = windowHandle'                  SampleDescription = new SlimDX.DXGI.SampleDescription(1' 0)'                  SwapEffect = SlimDX.DXGI.SwapEffect.Discard'                  Usage = SlimDX.DXGI.Usage.RenderTargetOutput              };
Magic Number,DotaDXInject,DXHookD3D9,C:\repos\patriksletmo_Dota2Translator\DotaDXInject\DirectX\DXHookD3D9.cs,EndSceneHook,The following statement contains a magic number: using (Device device = Device.FromPointer(devicePtr))              {                  // Retrieve the current time.                  DateTime now = DateTime.Now;                    // Retrieve the width and height of the surface.                  int width' height = 0;                  using (Surface renderTargetTemp = device.GetRenderTarget(0))                  {                      width = renderTargetTemp.Description.Width;                      height = renderTargetTemp.Description.Height;                        _renderTarget = renderTargetTemp;                  }                    // Re-calculate overlay position and dimension if the width or height changes.                  if (PreviousWidth != width || PreviousHeight != height)                  {                      // Refresh position and dimension.                      CalculatePositions(width' height);                      PreviousWidth = width;                      PreviousHeight = height;                        // Reset font.                      OverlayFont = null;                  }                    try                  {                      // Render a success message to indicate that the overlay was added successfully.                      long millisSinceAdd = (now - TimeAdded).Ticks / TimeSpan.TicksPerMillisecond;                      if (millisSinceAdd < SuccessMessageTime)                      {                          // Scale the font to the current resolution.                          using (SlimDX.Direct3D9.Font successFont = new SlimDX.Direct3D9.Font(device' new System.Drawing.Font("Times New Roman"' 80.0f / 1920f * width)))                          {                              // Draw the font with an alpha value related to the time passed since the overlay was added. The font will be completely invisible when the time has passed.                              successFont.DrawString(null' "Overlay added!"' 50' 50' Color.FromArgb((int)((SuccessMessageTime - millisSinceAdd) / SuccessMessageTime * 255.0)' TextColor));                          }                      }                        // Don't render the overlay if it's in auto hide mode and hidden.                      if (!Hide || !AutoHide)                      {                          // Refresh the font if the settings has been changed or create a font if null.                          if (OverlayFont == null || !FontName.Equals(LastFontName) || LastMessagesShown != MessagesShown || AutoMessageHeight != LastAutoMessageHeight || MessageHeight != LastMessageHeight)                          {                              LastFontName = FontName;                              LastMessagesShown = MessagesShown;                              LastAutoMessageHeight = AutoMessageHeight;                              LastMessageHeight = MessageHeight;                              LoadFont(device);                          }                            // Draw the last messages received. Amount defined by MessagesShown.                          int y = MessagesShown - 1;                          int i = Messages.Count - 1;                          while (y >= 0)                          {                              // Abort the loop if there are no more messages available.                              if (!(i >= Math.Max(0' Messages.Count - MessagesShown)))                                  break;                                Message message = Messages[i];                                // Wrap the message if it has not been done yet or the font/dimensions has been changed.                              if (!OverlayFont.Equals(message.FontUsed))                              {                                  message.WrapMessage(OverlayFont' AvailableTextWidth);                              }                                // Store the original text color.                              Color drawColor = TextColor;                                // Keep track of whether to draw the shadow or not (The shadow will not be drawn when fading).                              Boolean drawShadow = true;                                // Fade the color if in the fading phase.                              if (FadeMessages && message.Time.AddSeconds(FadeWait) <= now)                              {                                  if (message.Time.AddSeconds(FadeWait + FadeDuration) <= now)                                  {                                      // The message has already been faded' don't display it.                                      i--;                                      continue;                                  }                                    // Fade the color according to the duration and delay of the fade.                                  float fadeDuration = (message.Time.AddSeconds(FadeWait + FadeDuration) - message.Time.AddSeconds(FadeWait)).Ticks / TimeSpan.TicksPerMillisecond;                                  float fadeProgress = (now - message.Time.AddSeconds(FadeWait)).Ticks / TimeSpan.TicksPerMillisecond;                                  float fadePercentage = fadeProgress / fadeDuration;                                  drawColor = Color.FromArgb((int) ((1f - fadePercentage)*255)' drawColor);                                  drawShadow = false;                              }                                                            // Draw the wrapped message from the bottom.                              for (int j = message.WrappedMessage.Length - 1; j >= 0 && y >= 0; j--)                              {                                  // Calculate the y position for the string.                                  int stringY = TextStartHeight + (TextEndHeight - TextStartHeight) / MessagesShown * y;                                     if (drawShadow)                                      OverlayFont.DrawString(null' message.WrappedMessage[j]' TextStartWidth + FontHeight / 2 + message.SenderWidth' stringY + 1' TextShadowColor);                                    OverlayFont.DrawString(null' message.WrappedMessage[j]' TextStartWidth - 1 + FontHeight / 2 + message.SenderWidth' stringY' drawColor);                                    // Only draw the sender on the upmost line.                                  if (j == 0)                                  {                                      if (drawShadow)                                          OverlayFont.DrawString(null' message.Sender + ": "' TextStartWidth' stringY + 1' TextShadowColor);                                        OverlayFont.DrawString(null' message.Sender + ": "' TextStartWidth - 1' stringY' drawColor);                                  }                                  y--;                              }                                i--;                          }                      }                                       }                  catch                  {                      // Don't crash the hooked application if an exception is thrown.                  }                    // EasyHook has already repatched the original EndScene so we will not loop our method forever.                  return device.EndScene().Code;              }
Magic Number,DotaDXInject,DXHookD3D9,C:\repos\patriksletmo_Dota2Translator\DotaDXInject\DirectX\DXHookD3D9.cs,EndSceneHook,The following statement contains a magic number: using (Device device = Device.FromPointer(devicePtr))              {                  // Retrieve the current time.                  DateTime now = DateTime.Now;                    // Retrieve the width and height of the surface.                  int width' height = 0;                  using (Surface renderTargetTemp = device.GetRenderTarget(0))                  {                      width = renderTargetTemp.Description.Width;                      height = renderTargetTemp.Description.Height;                        _renderTarget = renderTargetTemp;                  }                    // Re-calculate overlay position and dimension if the width or height changes.                  if (PreviousWidth != width || PreviousHeight != height)                  {                      // Refresh position and dimension.                      CalculatePositions(width' height);                      PreviousWidth = width;                      PreviousHeight = height;                        // Reset font.                      OverlayFont = null;                  }                    try                  {                      // Render a success message to indicate that the overlay was added successfully.                      long millisSinceAdd = (now - TimeAdded).Ticks / TimeSpan.TicksPerMillisecond;                      if (millisSinceAdd < SuccessMessageTime)                      {                          // Scale the font to the current resolution.                          using (SlimDX.Direct3D9.Font successFont = new SlimDX.Direct3D9.Font(device' new System.Drawing.Font("Times New Roman"' 80.0f / 1920f * width)))                          {                              // Draw the font with an alpha value related to the time passed since the overlay was added. The font will be completely invisible when the time has passed.                              successFont.DrawString(null' "Overlay added!"' 50' 50' Color.FromArgb((int)((SuccessMessageTime - millisSinceAdd) / SuccessMessageTime * 255.0)' TextColor));                          }                      }                        // Don't render the overlay if it's in auto hide mode and hidden.                      if (!Hide || !AutoHide)                      {                          // Refresh the font if the settings has been changed or create a font if null.                          if (OverlayFont == null || !FontName.Equals(LastFontName) || LastMessagesShown != MessagesShown || AutoMessageHeight != LastAutoMessageHeight || MessageHeight != LastMessageHeight)                          {                              LastFontName = FontName;                              LastMessagesShown = MessagesShown;                              LastAutoMessageHeight = AutoMessageHeight;                              LastMessageHeight = MessageHeight;                              LoadFont(device);                          }                            // Draw the last messages received. Amount defined by MessagesShown.                          int y = MessagesShown - 1;                          int i = Messages.Count - 1;                          while (y >= 0)                          {                              // Abort the loop if there are no more messages available.                              if (!(i >= Math.Max(0' Messages.Count - MessagesShown)))                                  break;                                Message message = Messages[i];                                // Wrap the message if it has not been done yet or the font/dimensions has been changed.                              if (!OverlayFont.Equals(message.FontUsed))                              {                                  message.WrapMessage(OverlayFont' AvailableTextWidth);                              }                                // Store the original text color.                              Color drawColor = TextColor;                                // Keep track of whether to draw the shadow or not (The shadow will not be drawn when fading).                              Boolean drawShadow = true;                                // Fade the color if in the fading phase.                              if (FadeMessages && message.Time.AddSeconds(FadeWait) <= now)                              {                                  if (message.Time.AddSeconds(FadeWait + FadeDuration) <= now)                                  {                                      // The message has already been faded' don't display it.                                      i--;                                      continue;                                  }                                    // Fade the color according to the duration and delay of the fade.                                  float fadeDuration = (message.Time.AddSeconds(FadeWait + FadeDuration) - message.Time.AddSeconds(FadeWait)).Ticks / TimeSpan.TicksPerMillisecond;                                  float fadeProgress = (now - message.Time.AddSeconds(FadeWait)).Ticks / TimeSpan.TicksPerMillisecond;                                  float fadePercentage = fadeProgress / fadeDuration;                                  drawColor = Color.FromArgb((int) ((1f - fadePercentage)*255)' drawColor);                                  drawShadow = false;                              }                                                            // Draw the wrapped message from the bottom.                              for (int j = message.WrappedMessage.Length - 1; j >= 0 && y >= 0; j--)                              {                                  // Calculate the y position for the string.                                  int stringY = TextStartHeight + (TextEndHeight - TextStartHeight) / MessagesShown * y;                                     if (drawShadow)                                      OverlayFont.DrawString(null' message.WrappedMessage[j]' TextStartWidth + FontHeight / 2 + message.SenderWidth' stringY + 1' TextShadowColor);                                    OverlayFont.DrawString(null' message.WrappedMessage[j]' TextStartWidth - 1 + FontHeight / 2 + message.SenderWidth' stringY' drawColor);                                    // Only draw the sender on the upmost line.                                  if (j == 0)                                  {                                      if (drawShadow)                                          OverlayFont.DrawString(null' message.Sender + ": "' TextStartWidth' stringY + 1' TextShadowColor);                                        OverlayFont.DrawString(null' message.Sender + ": "' TextStartWidth - 1' stringY' drawColor);                                  }                                  y--;                              }                                i--;                          }                      }                                       }                  catch                  {                      // Don't crash the hooked application if an exception is thrown.                  }                    // EasyHook has already repatched the original EndScene so we will not loop our method forever.                  return device.EndScene().Code;              }
Magic Number,DotaDXInject,DXHookD3D9,C:\repos\patriksletmo_Dota2Translator\DotaDXInject\DirectX\DXHookD3D9.cs,EndSceneHook,The following statement contains a magic number: using (Device device = Device.FromPointer(devicePtr))              {                  // Retrieve the current time.                  DateTime now = DateTime.Now;                    // Retrieve the width and height of the surface.                  int width' height = 0;                  using (Surface renderTargetTemp = device.GetRenderTarget(0))                  {                      width = renderTargetTemp.Description.Width;                      height = renderTargetTemp.Description.Height;                        _renderTarget = renderTargetTemp;                  }                    // Re-calculate overlay position and dimension if the width or height changes.                  if (PreviousWidth != width || PreviousHeight != height)                  {                      // Refresh position and dimension.                      CalculatePositions(width' height);                      PreviousWidth = width;                      PreviousHeight = height;                        // Reset font.                      OverlayFont = null;                  }                    try                  {                      // Render a success message to indicate that the overlay was added successfully.                      long millisSinceAdd = (now - TimeAdded).Ticks / TimeSpan.TicksPerMillisecond;                      if (millisSinceAdd < SuccessMessageTime)                      {                          // Scale the font to the current resolution.                          using (SlimDX.Direct3D9.Font successFont = new SlimDX.Direct3D9.Font(device' new System.Drawing.Font("Times New Roman"' 80.0f / 1920f * width)))                          {                              // Draw the font with an alpha value related to the time passed since the overlay was added. The font will be completely invisible when the time has passed.                              successFont.DrawString(null' "Overlay added!"' 50' 50' Color.FromArgb((int)((SuccessMessageTime - millisSinceAdd) / SuccessMessageTime * 255.0)' TextColor));                          }                      }                        // Don't render the overlay if it's in auto hide mode and hidden.                      if (!Hide || !AutoHide)                      {                          // Refresh the font if the settings has been changed or create a font if null.                          if (OverlayFont == null || !FontName.Equals(LastFontName) || LastMessagesShown != MessagesShown || AutoMessageHeight != LastAutoMessageHeight || MessageHeight != LastMessageHeight)                          {                              LastFontName = FontName;                              LastMessagesShown = MessagesShown;                              LastAutoMessageHeight = AutoMessageHeight;                              LastMessageHeight = MessageHeight;                              LoadFont(device);                          }                            // Draw the last messages received. Amount defined by MessagesShown.                          int y = MessagesShown - 1;                          int i = Messages.Count - 1;                          while (y >= 0)                          {                              // Abort the loop if there are no more messages available.                              if (!(i >= Math.Max(0' Messages.Count - MessagesShown)))                                  break;                                Message message = Messages[i];                                // Wrap the message if it has not been done yet or the font/dimensions has been changed.                              if (!OverlayFont.Equals(message.FontUsed))                              {                                  message.WrapMessage(OverlayFont' AvailableTextWidth);                              }                                // Store the original text color.                              Color drawColor = TextColor;                                // Keep track of whether to draw the shadow or not (The shadow will not be drawn when fading).                              Boolean drawShadow = true;                                // Fade the color if in the fading phase.                              if (FadeMessages && message.Time.AddSeconds(FadeWait) <= now)                              {                                  if (message.Time.AddSeconds(FadeWait + FadeDuration) <= now)                                  {                                      // The message has already been faded' don't display it.                                      i--;                                      continue;                                  }                                    // Fade the color according to the duration and delay of the fade.                                  float fadeDuration = (message.Time.AddSeconds(FadeWait + FadeDuration) - message.Time.AddSeconds(FadeWait)).Ticks / TimeSpan.TicksPerMillisecond;                                  float fadeProgress = (now - message.Time.AddSeconds(FadeWait)).Ticks / TimeSpan.TicksPerMillisecond;                                  float fadePercentage = fadeProgress / fadeDuration;                                  drawColor = Color.FromArgb((int) ((1f - fadePercentage)*255)' drawColor);                                  drawShadow = false;                              }                                                            // Draw the wrapped message from the bottom.                              for (int j = message.WrappedMessage.Length - 1; j >= 0 && y >= 0; j--)                              {                                  // Calculate the y position for the string.                                  int stringY = TextStartHeight + (TextEndHeight - TextStartHeight) / MessagesShown * y;                                     if (drawShadow)                                      OverlayFont.DrawString(null' message.WrappedMessage[j]' TextStartWidth + FontHeight / 2 + message.SenderWidth' stringY + 1' TextShadowColor);                                    OverlayFont.DrawString(null' message.WrappedMessage[j]' TextStartWidth - 1 + FontHeight / 2 + message.SenderWidth' stringY' drawColor);                                    // Only draw the sender on the upmost line.                                  if (j == 0)                                  {                                      if (drawShadow)                                          OverlayFont.DrawString(null' message.Sender + ": "' TextStartWidth' stringY + 1' TextShadowColor);                                        OverlayFont.DrawString(null' message.Sender + ": "' TextStartWidth - 1' stringY' drawColor);                                  }                                  y--;                              }                                i--;                          }                      }                                       }                  catch                  {                      // Don't crash the hooked application if an exception is thrown.                  }                    // EasyHook has already repatched the original EndScene so we will not loop our method forever.                  return device.EndScene().Code;              }
Magic Number,DotaDXInject,DXHookD3D9,C:\repos\patriksletmo_Dota2Translator\DotaDXInject\DirectX\DXHookD3D9.cs,EndSceneHook,The following statement contains a magic number: using (Device device = Device.FromPointer(devicePtr))              {                  // Retrieve the current time.                  DateTime now = DateTime.Now;                    // Retrieve the width and height of the surface.                  int width' height = 0;                  using (Surface renderTargetTemp = device.GetRenderTarget(0))                  {                      width = renderTargetTemp.Description.Width;                      height = renderTargetTemp.Description.Height;                        _renderTarget = renderTargetTemp;                  }                    // Re-calculate overlay position and dimension if the width or height changes.                  if (PreviousWidth != width || PreviousHeight != height)                  {                      // Refresh position and dimension.                      CalculatePositions(width' height);                      PreviousWidth = width;                      PreviousHeight = height;                        // Reset font.                      OverlayFont = null;                  }                    try                  {                      // Render a success message to indicate that the overlay was added successfully.                      long millisSinceAdd = (now - TimeAdded).Ticks / TimeSpan.TicksPerMillisecond;                      if (millisSinceAdd < SuccessMessageTime)                      {                          // Scale the font to the current resolution.                          using (SlimDX.Direct3D9.Font successFont = new SlimDX.Direct3D9.Font(device' new System.Drawing.Font("Times New Roman"' 80.0f / 1920f * width)))                          {                              // Draw the font with an alpha value related to the time passed since the overlay was added. The font will be completely invisible when the time has passed.                              successFont.DrawString(null' "Overlay added!"' 50' 50' Color.FromArgb((int)((SuccessMessageTime - millisSinceAdd) / SuccessMessageTime * 255.0)' TextColor));                          }                      }                        // Don't render the overlay if it's in auto hide mode and hidden.                      if (!Hide || !AutoHide)                      {                          // Refresh the font if the settings has been changed or create a font if null.                          if (OverlayFont == null || !FontName.Equals(LastFontName) || LastMessagesShown != MessagesShown || AutoMessageHeight != LastAutoMessageHeight || MessageHeight != LastMessageHeight)                          {                              LastFontName = FontName;                              LastMessagesShown = MessagesShown;                              LastAutoMessageHeight = AutoMessageHeight;                              LastMessageHeight = MessageHeight;                              LoadFont(device);                          }                            // Draw the last messages received. Amount defined by MessagesShown.                          int y = MessagesShown - 1;                          int i = Messages.Count - 1;                          while (y >= 0)                          {                              // Abort the loop if there are no more messages available.                              if (!(i >= Math.Max(0' Messages.Count - MessagesShown)))                                  break;                                Message message = Messages[i];                                // Wrap the message if it has not been done yet or the font/dimensions has been changed.                              if (!OverlayFont.Equals(message.FontUsed))                              {                                  message.WrapMessage(OverlayFont' AvailableTextWidth);                              }                                // Store the original text color.                              Color drawColor = TextColor;                                // Keep track of whether to draw the shadow or not (The shadow will not be drawn when fading).                              Boolean drawShadow = true;                                // Fade the color if in the fading phase.                              if (FadeMessages && message.Time.AddSeconds(FadeWait) <= now)                              {                                  if (message.Time.AddSeconds(FadeWait + FadeDuration) <= now)                                  {                                      // The message has already been faded' don't display it.                                      i--;                                      continue;                                  }                                    // Fade the color according to the duration and delay of the fade.                                  float fadeDuration = (message.Time.AddSeconds(FadeWait + FadeDuration) - message.Time.AddSeconds(FadeWait)).Ticks / TimeSpan.TicksPerMillisecond;                                  float fadeProgress = (now - message.Time.AddSeconds(FadeWait)).Ticks / TimeSpan.TicksPerMillisecond;                                  float fadePercentage = fadeProgress / fadeDuration;                                  drawColor = Color.FromArgb((int) ((1f - fadePercentage)*255)' drawColor);                                  drawShadow = false;                              }                                                            // Draw the wrapped message from the bottom.                              for (int j = message.WrappedMessage.Length - 1; j >= 0 && y >= 0; j--)                              {                                  // Calculate the y position for the string.                                  int stringY = TextStartHeight + (TextEndHeight - TextStartHeight) / MessagesShown * y;                                     if (drawShadow)                                      OverlayFont.DrawString(null' message.WrappedMessage[j]' TextStartWidth + FontHeight / 2 + message.SenderWidth' stringY + 1' TextShadowColor);                                    OverlayFont.DrawString(null' message.WrappedMessage[j]' TextStartWidth - 1 + FontHeight / 2 + message.SenderWidth' stringY' drawColor);                                    // Only draw the sender on the upmost line.                                  if (j == 0)                                  {                                      if (drawShadow)                                          OverlayFont.DrawString(null' message.Sender + ": "' TextStartWidth' stringY + 1' TextShadowColor);                                        OverlayFont.DrawString(null' message.Sender + ": "' TextStartWidth - 1' stringY' drawColor);                                  }                                  y--;                              }                                i--;                          }                      }                                       }                  catch                  {                      // Don't crash the hooked application if an exception is thrown.                  }                    // EasyHook has already repatched the original EndScene so we will not loop our method forever.                  return device.EndScene().Code;              }
Magic Number,DotaDXInject,DXHookD3D9,C:\repos\patriksletmo_Dota2Translator\DotaDXInject\DirectX\DXHookD3D9.cs,EndSceneHook,The following statement contains a magic number: using (Device device = Device.FromPointer(devicePtr))              {                  // Retrieve the current time.                  DateTime now = DateTime.Now;                    // Retrieve the width and height of the surface.                  int width' height = 0;                  using (Surface renderTargetTemp = device.GetRenderTarget(0))                  {                      width = renderTargetTemp.Description.Width;                      height = renderTargetTemp.Description.Height;                        _renderTarget = renderTargetTemp;                  }                    // Re-calculate overlay position and dimension if the width or height changes.                  if (PreviousWidth != width || PreviousHeight != height)                  {                      // Refresh position and dimension.                      CalculatePositions(width' height);                      PreviousWidth = width;                      PreviousHeight = height;                        // Reset font.                      OverlayFont = null;                  }                    try                  {                      // Render a success message to indicate that the overlay was added successfully.                      long millisSinceAdd = (now - TimeAdded).Ticks / TimeSpan.TicksPerMillisecond;                      if (millisSinceAdd < SuccessMessageTime)                      {                          // Scale the font to the current resolution.                          using (SlimDX.Direct3D9.Font successFont = new SlimDX.Direct3D9.Font(device' new System.Drawing.Font("Times New Roman"' 80.0f / 1920f * width)))                          {                              // Draw the font with an alpha value related to the time passed since the overlay was added. The font will be completely invisible when the time has passed.                              successFont.DrawString(null' "Overlay added!"' 50' 50' Color.FromArgb((int)((SuccessMessageTime - millisSinceAdd) / SuccessMessageTime * 255.0)' TextColor));                          }                      }                        // Don't render the overlay if it's in auto hide mode and hidden.                      if (!Hide || !AutoHide)                      {                          // Refresh the font if the settings has been changed or create a font if null.                          if (OverlayFont == null || !FontName.Equals(LastFontName) || LastMessagesShown != MessagesShown || AutoMessageHeight != LastAutoMessageHeight || MessageHeight != LastMessageHeight)                          {                              LastFontName = FontName;                              LastMessagesShown = MessagesShown;                              LastAutoMessageHeight = AutoMessageHeight;                              LastMessageHeight = MessageHeight;                              LoadFont(device);                          }                            // Draw the last messages received. Amount defined by MessagesShown.                          int y = MessagesShown - 1;                          int i = Messages.Count - 1;                          while (y >= 0)                          {                              // Abort the loop if there are no more messages available.                              if (!(i >= Math.Max(0' Messages.Count - MessagesShown)))                                  break;                                Message message = Messages[i];                                // Wrap the message if it has not been done yet or the font/dimensions has been changed.                              if (!OverlayFont.Equals(message.FontUsed))                              {                                  message.WrapMessage(OverlayFont' AvailableTextWidth);                              }                                // Store the original text color.                              Color drawColor = TextColor;                                // Keep track of whether to draw the shadow or not (The shadow will not be drawn when fading).                              Boolean drawShadow = true;                                // Fade the color if in the fading phase.                              if (FadeMessages && message.Time.AddSeconds(FadeWait) <= now)                              {                                  if (message.Time.AddSeconds(FadeWait + FadeDuration) <= now)                                  {                                      // The message has already been faded' don't display it.                                      i--;                                      continue;                                  }                                    // Fade the color according to the duration and delay of the fade.                                  float fadeDuration = (message.Time.AddSeconds(FadeWait + FadeDuration) - message.Time.AddSeconds(FadeWait)).Ticks / TimeSpan.TicksPerMillisecond;                                  float fadeProgress = (now - message.Time.AddSeconds(FadeWait)).Ticks / TimeSpan.TicksPerMillisecond;                                  float fadePercentage = fadeProgress / fadeDuration;                                  drawColor = Color.FromArgb((int) ((1f - fadePercentage)*255)' drawColor);                                  drawShadow = false;                              }                                                            // Draw the wrapped message from the bottom.                              for (int j = message.WrappedMessage.Length - 1; j >= 0 && y >= 0; j--)                              {                                  // Calculate the y position for the string.                                  int stringY = TextStartHeight + (TextEndHeight - TextStartHeight) / MessagesShown * y;                                     if (drawShadow)                                      OverlayFont.DrawString(null' message.WrappedMessage[j]' TextStartWidth + FontHeight / 2 + message.SenderWidth' stringY + 1' TextShadowColor);                                    OverlayFont.DrawString(null' message.WrappedMessage[j]' TextStartWidth - 1 + FontHeight / 2 + message.SenderWidth' stringY' drawColor);                                    // Only draw the sender on the upmost line.                                  if (j == 0)                                  {                                      if (drawShadow)                                          OverlayFont.DrawString(null' message.Sender + ": "' TextStartWidth' stringY + 1' TextShadowColor);                                        OverlayFont.DrawString(null' message.Sender + ": "' TextStartWidth - 1' stringY' drawColor);                                  }                                  y--;                              }                                i--;                          }                      }                                       }                  catch                  {                      // Don't crash the hooked application if an exception is thrown.                  }                    // EasyHook has already repatched the original EndScene so we will not loop our method forever.                  return device.EndScene().Code;              }
Magic Number,DotaDXInject,DXHookD3D9,C:\repos\patriksletmo_Dota2Translator\DotaDXInject\DirectX\DXHookD3D9.cs,EndSceneHook,The following statement contains a magic number: using (Device device = Device.FromPointer(devicePtr))              {                  // Retrieve the current time.                  DateTime now = DateTime.Now;                    // Retrieve the width and height of the surface.                  int width' height = 0;                  using (Surface renderTargetTemp = device.GetRenderTarget(0))                  {                      width = renderTargetTemp.Description.Width;                      height = renderTargetTemp.Description.Height;                        _renderTarget = renderTargetTemp;                  }                    // Re-calculate overlay position and dimension if the width or height changes.                  if (PreviousWidth != width || PreviousHeight != height)                  {                      // Refresh position and dimension.                      CalculatePositions(width' height);                      PreviousWidth = width;                      PreviousHeight = height;                        // Reset font.                      OverlayFont = null;                  }                    try                  {                      // Render a success message to indicate that the overlay was added successfully.                      long millisSinceAdd = (now - TimeAdded).Ticks / TimeSpan.TicksPerMillisecond;                      if (millisSinceAdd < SuccessMessageTime)                      {                          // Scale the font to the current resolution.                          using (SlimDX.Direct3D9.Font successFont = new SlimDX.Direct3D9.Font(device' new System.Drawing.Font("Times New Roman"' 80.0f / 1920f * width)))                          {                              // Draw the font with an alpha value related to the time passed since the overlay was added. The font will be completely invisible when the time has passed.                              successFont.DrawString(null' "Overlay added!"' 50' 50' Color.FromArgb((int)((SuccessMessageTime - millisSinceAdd) / SuccessMessageTime * 255.0)' TextColor));                          }                      }                        // Don't render the overlay if it's in auto hide mode and hidden.                      if (!Hide || !AutoHide)                      {                          // Refresh the font if the settings has been changed or create a font if null.                          if (OverlayFont == null || !FontName.Equals(LastFontName) || LastMessagesShown != MessagesShown || AutoMessageHeight != LastAutoMessageHeight || MessageHeight != LastMessageHeight)                          {                              LastFontName = FontName;                              LastMessagesShown = MessagesShown;                              LastAutoMessageHeight = AutoMessageHeight;                              LastMessageHeight = MessageHeight;                              LoadFont(device);                          }                            // Draw the last messages received. Amount defined by MessagesShown.                          int y = MessagesShown - 1;                          int i = Messages.Count - 1;                          while (y >= 0)                          {                              // Abort the loop if there are no more messages available.                              if (!(i >= Math.Max(0' Messages.Count - MessagesShown)))                                  break;                                Message message = Messages[i];                                // Wrap the message if it has not been done yet or the font/dimensions has been changed.                              if (!OverlayFont.Equals(message.FontUsed))                              {                                  message.WrapMessage(OverlayFont' AvailableTextWidth);                              }                                // Store the original text color.                              Color drawColor = TextColor;                                // Keep track of whether to draw the shadow or not (The shadow will not be drawn when fading).                              Boolean drawShadow = true;                                // Fade the color if in the fading phase.                              if (FadeMessages && message.Time.AddSeconds(FadeWait) <= now)                              {                                  if (message.Time.AddSeconds(FadeWait + FadeDuration) <= now)                                  {                                      // The message has already been faded' don't display it.                                      i--;                                      continue;                                  }                                    // Fade the color according to the duration and delay of the fade.                                  float fadeDuration = (message.Time.AddSeconds(FadeWait + FadeDuration) - message.Time.AddSeconds(FadeWait)).Ticks / TimeSpan.TicksPerMillisecond;                                  float fadeProgress = (now - message.Time.AddSeconds(FadeWait)).Ticks / TimeSpan.TicksPerMillisecond;                                  float fadePercentage = fadeProgress / fadeDuration;                                  drawColor = Color.FromArgb((int) ((1f - fadePercentage)*255)' drawColor);                                  drawShadow = false;                              }                                                            // Draw the wrapped message from the bottom.                              for (int j = message.WrappedMessage.Length - 1; j >= 0 && y >= 0; j--)                              {                                  // Calculate the y position for the string.                                  int stringY = TextStartHeight + (TextEndHeight - TextStartHeight) / MessagesShown * y;                                     if (drawShadow)                                      OverlayFont.DrawString(null' message.WrappedMessage[j]' TextStartWidth + FontHeight / 2 + message.SenderWidth' stringY + 1' TextShadowColor);                                    OverlayFont.DrawString(null' message.WrappedMessage[j]' TextStartWidth - 1 + FontHeight / 2 + message.SenderWidth' stringY' drawColor);                                    // Only draw the sender on the upmost line.                                  if (j == 0)                                  {                                      if (drawShadow)                                          OverlayFont.DrawString(null' message.Sender + ": "' TextStartWidth' stringY + 1' TextShadowColor);                                        OverlayFont.DrawString(null' message.Sender + ": "' TextStartWidth - 1' stringY' drawColor);                                  }                                  y--;                              }                                i--;                          }                      }                                       }                  catch                  {                      // Don't crash the hooked application if an exception is thrown.                  }                    // EasyHook has already repatched the original EndScene so we will not loop our method forever.                  return device.EndScene().Code;              }
Magic Number,DotaDXInject,DXHookD3D9,C:\repos\patriksletmo_Dota2Translator\DotaDXInject\DirectX\DXHookD3D9.cs,LoadFont,The following statement contains a magic number: if (AutoMessageHeight)                  // Scale the font if in automatic mode.                  fontHeight = 12.0f * 6 / MessagesShown / 1080f * PreviousHeight;              else                  // Use the set height if automatic mode is off.                  fontHeight = MessageHeight;
Magic Number,DotaDXInject,DXHookD3D9,C:\repos\patriksletmo_Dota2Translator\DotaDXInject\DirectX\DXHookD3D9.cs,LoadFont,The following statement contains a magic number: FontHeight = (int) (fontHeight * 1.6);
Missing Default,DotaDXInject,DotaInjection,C:\repos\patriksletmo_Dota2Translator\DotaDXInject\DotaInjection.cs,Run,The following switch statement is missing a default case: switch (type)                          {                              // Message                              case 0:                                  String sender = (String)pendingEvent[1];                                  String message = (String)pendingEvent[2];                                    directXHook.Messages.Add(new DXHookD3D9.Message(sender' message));                                    break;                              // Hide / Show                              case 1:                                  Boolean hide = (Boolean)pendingEvent[1];                                    directXHook.Hide = hide;                                    break;                              // Setting change                              case 2:                                  String fieldName = (String)pendingEvent[1];                                    FieldInfo info = typeof(DXHookD3D9).GetField(fieldName);                                  info.SetValue(directXHook' pendingEvent[2]);                                    break;                          }
