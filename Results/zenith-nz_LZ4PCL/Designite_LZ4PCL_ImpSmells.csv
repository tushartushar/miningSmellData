Implementation smell,Namespace,Class,File,Method,Description
Complex Method,LZ4PCL,LZ4Codec,C:\repos\zenith-nz_LZ4PCL\LZ4Codec.cs,CheckArguments,Cyclomatic complexity of the method is 8
Complex Method,LZ4PCL,LZ4Stream,C:\repos\zenith-nz_LZ4PCL\LZ4Stream.cs,AcquireNextChunk,Cyclomatic complexity of the method is 8
Long Parameter List,LZ4PCL,LZ4Codec,C:\repos\zenith-nz_LZ4PCL\LZ4Codec.cs,CheckArguments,The method has 6 parameters.
Long Parameter List,LZ4PCL,LZ4Codec,C:\repos\zenith-nz_LZ4PCL\LZ4Codec.cs,Encode,The method has 7 parameters.
Long Parameter List,LZ4PCL,LZ4Codec,C:\repos\zenith-nz_LZ4PCL\LZ4Codec.cs,Decode,The method has 7 parameters.
Long Parameter List,LZ4PCL,LZ4Stream,C:\repos\zenith-nz_LZ4PCL\LZ4Stream.cs,LZ4Stream,The method has 5 parameters.
Long Statement,LZ4PCL,LZ4Codec,C:\repos\zenith-nz_LZ4PCL\LZ4Codec.cs,Encode,The length of the statement  "		return highCompression ? Encode32HC (input' inputOffset' inputLength' output' outputOffset' outputLength) : Encode32 (input' inputOffset' inputLength' output' outputOffset' outputLength); " is 187.
Long Statement,LZ4PCL,LZ4Codec,C:\repos\zenith-nz_LZ4PCL\LZ4Codec.cs,Encode,The length of the statement  "		return highCompression ? Encode32HC (input' inputOffset' inputLength' output' outputOffset' outputLength) : Encode32 (input' inputOffset' inputLength' output' outputOffset' outputLength); " is 187.
Magic Number,LZ4PCL,LZ4Codec,C:\repos\zenith-nz_LZ4PCL\LZ4Codec.cs,MaximumOutputLength,The following statement contains a magic number: return inputLength + (inputLength / 255) + 16;  
Magic Number,LZ4PCL,LZ4Codec,C:\repos\zenith-nz_LZ4PCL\LZ4Codec.cs,MaximumOutputLength,The following statement contains a magic number: return inputLength + (inputLength / 255) + 16;  
Magic Number,LZ4PCL,LZ4Codec,C:\repos\zenith-nz_LZ4PCL\LZ4Codec.cs,Encode,The following statement contains a magic number: switch (_platform) {  case 32:  	// x86 or other 32-bit word size ISA  	return highCompression ? Encode32HC (input' inputOffset' inputLength' output' outputOffset' outputLength) : Encode32 (input' inputOffset' inputLength' output' outputOffset' outputLength);  case 64:  	#if INCLUDE_UNSAFE  	                    return highCompression ?                         Encode64HC(input' inputOffset' inputLength' output' outputOffset' outputLength)                         : Encode64(input' inputOffset' inputLength' output' outputOffset' outputLength); #else  	return highCompression ? Encode32HC (input' inputOffset' inputLength' output' outputOffset' outputLength) : Encode32 (input' inputOffset' inputLength' output' outputOffset' outputLength);  #endif  default:  	throw new InvalidOperationException ();  }  
Magic Number,LZ4PCL,LZ4Codec,C:\repos\zenith-nz_LZ4PCL\LZ4Codec.cs,Encode,The following statement contains a magic number: switch (_platform) {  case 32:  	// x86 or other 32-bit word size ISA  	return highCompression ? Encode32HC (input' inputOffset' inputLength' output' outputOffset' outputLength) : Encode32 (input' inputOffset' inputLength' output' outputOffset' outputLength);  case 64:  	#if INCLUDE_UNSAFE  	                    return highCompression ?                         Encode64HC(input' inputOffset' inputLength' output' outputOffset' outputLength)                         : Encode64(input' inputOffset' inputLength' output' outputOffset' outputLength); #else  	return highCompression ? Encode32HC (input' inputOffset' inputLength' output' outputOffset' outputLength) : Encode32 (input' inputOffset' inputLength' output' outputOffset' outputLength);  #endif  default:  	throw new InvalidOperationException ();  }  
Magic Number,LZ4PCL,LZ4Codec,C:\repos\zenith-nz_LZ4PCL\LZ4Codec.cs,Decode,The following statement contains a magic number: switch (_platform) {  case 32:  	// x86 or other 32-bit word size ISA  	return Decode64 (input' inputOffset' inputLength' output' outputOffset' outputLength' knownLength);  case 64:  	#if INCLUDE_UNSAFE  	                    return Decode32(input' inputOffset' inputLength' output' outputOffset' outputLength' knownLength); #else  	return Decode64 (input' inputOffset' inputLength' output' outputOffset' outputLength' knownLength);  #endif  default:  	throw new InvalidOperationException ();  }  
Magic Number,LZ4PCL,LZ4Codec,C:\repos\zenith-nz_LZ4PCL\LZ4Codec.cs,Decode,The following statement contains a magic number: switch (_platform) {  case 32:  	// x86 or other 32-bit word size ISA  	return Decode64 (input' inputOffset' inputLength' output' outputOffset' outputLength' knownLength);  case 64:  	#if INCLUDE_UNSAFE  	                    return Decode32(input' inputOffset' inputLength' output' outputOffset' outputLength' knownLength); #else  	return Decode64 (input' inputOffset' inputLength' output' outputOffset' outputLength' knownLength);  #endif  default:  	throw new InvalidOperationException ();  }  
Magic Number,LZ4PCL,LZ4Stream,C:\repos\zenith-nz_LZ4PCL\LZ4Stream.cs,LZ4Stream,The following statement contains a magic number: _blockSize = Math.Max (16' blockSize);  
Magic Number,LZ4PCL,LZ4Stream,C:\repos\zenith-nz_LZ4PCL\LZ4Stream.cs,TryReadVarInt,The following statement contains a magic number: while (true) {  	if (_innerStream.Read (buffer' 0' 1) == 0) {  		if (count == 0) {  			return false;  		}  		throw EndOfStream ();  	}  	byte b = buffer [0];  	result = result + ((ulong)(b & 0x7F) << count);  	count += 7;  	if ((b & 0x80) == 0 || count >= 64) {  		break;  	}  }  
Magic Number,LZ4PCL,LZ4Stream,C:\repos\zenith-nz_LZ4PCL\LZ4Stream.cs,TryReadVarInt,The following statement contains a magic number: while (true) {  	if (_innerStream.Read (buffer' 0' 1) == 0) {  		if (count == 0) {  			return false;  		}  		throw EndOfStream ();  	}  	byte b = buffer [0];  	result = result + ((ulong)(b & 0x7F) << count);  	count += 7;  	if ((b & 0x80) == 0 || count >= 64) {  		break;  	}  }  
Magic Number,LZ4PCL,LZ4Stream,C:\repos\zenith-nz_LZ4PCL\LZ4Stream.cs,TryReadVarInt,The following statement contains a magic number: count += 7;  
Magic Number,LZ4PCL,LZ4Stream,C:\repos\zenith-nz_LZ4PCL\LZ4Stream.cs,TryReadVarInt,The following statement contains a magic number: if ((b & 0x80) == 0 || count >= 64) {  	break;  }  
Magic Number,LZ4PCL,LZ4Stream,C:\repos\zenith-nz_LZ4PCL\LZ4Stream.cs,WriteVarInt,The following statement contains a magic number: while (true) {  	var b = (byte)(value & 0x7F);  	value >>= 7;  	buffer [0] = (byte)(b | (value == 0 ? 0 : 0x80));  	_innerStream.Write (buffer' 0' 1);  	if (value == 0) {  		break;  	}  }  
Magic Number,LZ4PCL,LZ4Stream,C:\repos\zenith-nz_LZ4PCL\LZ4Stream.cs,WriteVarInt,The following statement contains a magic number: value >>= 7;  
Magic Number,LZ4PCL,LZ4Stream,C:\repos\zenith-nz_LZ4PCL\LZ4Stream.cs,AcquireNextChunk,The following statement contains a magic number: do {  	ulong varint;  	if (!TryReadVarInt (out varint)) {  		return false;  	}  	var flags = (ChunkFlags)varint;  	bool isCompressed = (flags & ChunkFlags.Compressed) != 0;  	var originalLength = (int)ReadVarInt ();  	int compressedLength = isCompressed ? (int)ReadVarInt () : originalLength;  	if (compressedLength > originalLength) {  		throw EndOfStream ();  		// corrupted  	}  	var compressed = new byte[compressedLength];  	int chunk = ReadBlock (compressed' 0' compressedLength);  	if (chunk != compressedLength) {  		throw EndOfStream ();  		// corrupted  	}  	if (!isCompressed) {  		_buffer = compressed;  		// no compression on this chunk  		_bufferLength = compressedLength;  	}  	else {  		if (_buffer == null || _buffer.Length < originalLength) {  			_buffer = new byte[originalLength];  		}  		int passes = (int)flags >> 2;  		if (passes != 0) {  			throw new NotSupportedException ("Chunks with multiple passes are not supported.");  		}  		LZ4Codec.Decode (compressed' 0' compressedLength' _buffer' 0' originalLength' true);  		_bufferLength = originalLength;  	}  	_bufferOffset = 0;  }  while (_bufferLength == 0);  
Magic Number,LZ4PCL,LZ4Stream,C:\repos\zenith-nz_LZ4PCL\LZ4Stream.cs,AcquireNextChunk,The following statement contains a magic number: if (!isCompressed) {  	_buffer = compressed;  	// no compression on this chunk  	_bufferLength = compressedLength;  }  else {  	if (_buffer == null || _buffer.Length < originalLength) {  		_buffer = new byte[originalLength];  	}  	int passes = (int)flags >> 2;  	if (passes != 0) {  		throw new NotSupportedException ("Chunks with multiple passes are not supported.");  	}  	LZ4Codec.Decode (compressed' 0' compressedLength' _buffer' 0' originalLength' true);  	_bufferLength = originalLength;  }  
