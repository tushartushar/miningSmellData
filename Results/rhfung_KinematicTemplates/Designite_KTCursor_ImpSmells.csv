Implementation smell,Namespace,Class,File,Method,Description
Long Method,KinTemplates.Cursor.Tools.Render,OnlineFeedback,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\Render\OnlineFeedback.cs,AddFilter,The method has 115 lines of code.
Complex Method,KinTemplates.Cursor,FilterManager,C:\repos\rhfung_KinematicTemplates\KTCursor\src\FilterManager.cs,Compute,Cyclomatic complexity of the method is 8
Complex Method,KinTemplates.Cursor.Tools,PointToolFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\PointToolFilter.cs,DrawArrowPoints,Cyclomatic complexity of the method is 9
Complex Method,KinTemplates.Cursor.Tools,RegionToolRegionFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\RegionToolRegionFilter.cs,Draw,Cyclomatic complexity of the method is 8
Complex Method,KinTemplates.Cursor.Tools.Model,BitmapPath,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\Model\BitmapPath.cs,AddPath,Cyclomatic complexity of the method is 10
Complex Method,KinTemplates.Cursor.Tools.Model,RegionToolParameter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\Model\RegionToolParameter.cs,SetBoundingRect,Cyclomatic complexity of the method is 16
Long Parameter List,KinTemplates.Cursor,FilterManager,C:\repos\rhfung_KinematicTemplates\KTCursor\src\FilterManager.cs,Draw,The method has 6 parameters.
Long Parameter List,KinTemplates.Cursor,FilterManager,C:\repos\rhfung_KinematicTemplates\KTCursor\src\FilterManager.cs,DrawTemplates,The method has 6 parameters.
Long Parameter List,KinTemplates.Cursor.Tools,IToolFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\IToolFilter.cs,Draw,The method has 5 parameters.
Long Parameter List,KinTemplates.Cursor.Tools,LineToolFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\LineToolFilter.cs,Draw,The method has 5 parameters.
Long Parameter List,KinTemplates.Cursor.Tools,LineToolFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\LineToolFilter.cs,FastNearestPoint,The method has 6 parameters.
Long Parameter List,KinTemplates.Cursor.Tools,LineToolFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\LineToolFilter.cs,FastNearestPoint,The method has 6 parameters.
Long Parameter List,KinTemplates.Cursor.Tools,LineToolFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\LineToolFilter.cs,NearestPoint,The method has 6 parameters.
Long Parameter List,KinTemplates.Cursor.Tools,LineToolFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\LineToolFilter.cs,SumAllPoints,The method has 5 parameters.
Long Parameter List,KinTemplates.Cursor.Tools,PointToolFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\PointToolFilter.cs,Draw,The method has 5 parameters.
Long Parameter List,KinTemplates.Cursor.Tools,RegionToolFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\RegionToolFilter.cs,Draw,The method has 5 parameters.
Long Parameter List,KinTemplates.Cursor.Tools,RegionToolPathFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\RegionToolPathFilter.cs,Draw,The method has 5 parameters.
Long Parameter List,KinTemplates.Cursor.Tools,RegionToolRegionFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\RegionToolRegionFilter.cs,Draw,The method has 5 parameters.
Long Statement,KinTemplates.Cursor.Logger,MouseLogger,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Logger\MouseLogger.cs,MouseMoved,The length of the statement  "	m_realDelta.Add (new PointD (mouseMove.GetPhysicalPoint ().X - mouseMove.GetLastPhysicalPoint ().X' mouseMove.GetPhysicalPoint ().Y - mouseMove.GetLastPhysicalPoint ().Y)); " is 172.
Long Statement,KinTemplates.Cursor.Position,ParameterizedMousePosition,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Position\ParameterizedMousePosition.cs,SetVelocity,The length of the statement  "	System.Diagnostics.Debug.Assert (newVelocity.X > -10000 && newVelocity.X < 100000 && newVelocity.Y > -10000 && newVelocity.Y < 10000); " is 134.
Long Statement,KinTemplates.Cursor.Position,VirtualMousePosition,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Position\VirtualMousePosition.cs,Distance,The length of the statement  "	return Math.Sqrt ((firstPoint.X - secondPoint.X) * (firstPoint.X - secondPoint.X) + (firstPoint.Y - secondPoint.Y) * (firstPoint.Y - secondPoint.Y)); " is 149.
Long Statement,KinTemplates.Cursor.Position,VirtualMousePosition,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Position\VirtualMousePosition.cs,Distance,The length of the statement  "	return Math.Sqrt ((firstPoint.X - secondPoint.X) * (firstPoint.X - secondPoint.X) + (firstPoint.Y - secondPoint.Y) * (firstPoint.Y - secondPoint.Y)); " is 149.
Long Statement,KinTemplates.Cursor.Tools,ConveyorBeltFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\ConveyorBeltFilter.cs,DrawRegionRepresentation,The length of the statement  "	for (double i = bounds.Width / (Render.DrawHelper.X_ARROWS + 1); i < bounds.Width; i += bounds.Width / (Render.DrawHelper.X_ARROWS + 1)) { " is 138.
Long Statement,KinTemplates.Cursor.Tools,ConveyorBeltFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\ConveyorBeltFilter.cs,DrawRegionRepresentation,The length of the statement  "		for (double j = bounds.Height / (Render.DrawHelper.Y_ARROWS + 1); j < bounds.Height; j += bounds.Height / (Render.DrawHelper.Y_ARROWS + 1)) { " is 141.
Long Statement,KinTemplates.Cursor.Tools,ConveyorBeltFilter2,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\ConveyorBeltFilter2.cs,DrawRegionRepresentation,The length of the statement  "	for (double i = bounds.Width / (Render.DrawHelper.X_ARROWS + 1); i < bounds.Width; i += bounds.Width / (Render.DrawHelper.X_ARROWS + 1)) { " is 138.
Long Statement,KinTemplates.Cursor.Tools,ConveyorBeltFilter2,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\ConveyorBeltFilter2.cs,DrawRegionRepresentation,The length of the statement  "		for (double j = bounds.Height / (Render.DrawHelper.Y_ARROWS + 1); j < bounds.Height; j += bounds.Height / (Render.DrawHelper.Y_ARROWS + 1)) { " is 141.
Long Statement,KinTemplates.Cursor.Tools,FurFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\FurFilter.cs,DrawRegionRepresentation,The length of the statement  "	for (double i = bounds.Width / (Render.DrawHelper.X_ARROWS + 1); i < bounds.Width; i += bounds.Width / (Render.DrawHelper.X_ARROWS + 1)) { " is 138.
Long Statement,KinTemplates.Cursor.Tools,FurFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\FurFilter.cs,DrawRegionRepresentation,The length of the statement  "		for (double j = bounds.Height / (Render.DrawHelper.Y_ARROWS + 1); j < bounds.Height; j += bounds.Height / (Render.DrawHelper.Y_ARROWS + 1)) { " is 141.
Long Statement,KinTemplates.Cursor.Tools,InertiaFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\InertiaFilter.cs,DrawRegionRepresentation,The length of the statement  "			gc.DrawString ("+ speed"' r.FontType' new SolidBrush (r.RegionGuides.Color)' new PointF ((float)mousePosition.X' (float)mousePosition.Y - 15)); " is 143.
Long Statement,KinTemplates.Cursor.Tools,InertiaFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\InertiaFilter.cs,DrawRegionRepresentation,The length of the statement  "		gc.DrawString ("+ speed"' r.FontType' new SolidBrush (r.RegionGuides.Color)' new PointF ((float)mousePosition.X' (float)mousePosition.Y - 15)); " is 143.
Long Statement,KinTemplates.Cursor.Tools,LineToolFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\LineToolFilter.cs,Draw,The length of the statement  "				gc.DrawEllipse (dashPen' (float)firstPoint.X - Tools.Render.DrawHelper.TARGET_SIZE / 2.0f' (float)firstPoint.Y - Tools.Render.DrawHelper.TARGET_SIZE / 2.0f' (float)Tools.Render.DrawHelper.TARGET_SIZE' (float)Tools.Render.DrawHelper.TARGET_SIZE); " is 245.
Long Statement,KinTemplates.Cursor.Tools,LineToolFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\LineToolFilter.cs,FastNearestPoint,The length of the statement  "		FastNearestPoint (sourcePoints' testPoint' (startIndex + endIndex) / 2 + 1' endIndex' out nearestIdx' out nearestRadius); " is 121.
Long Statement,KinTemplates.Cursor.Tools,MagneticLineAttractionFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\MagneticLineAttractionFilter.cs,DrawArrowForces,The length of the statement  "		PointD scaledVector1 = testNormal1 * (GetScalar () * 7 * m_Param.C / Math.Pow ((m_Param.PathThickness / 2.0) + 10' 0.5)); " is 121.
Long Statement,KinTemplates.Cursor.Tools,MagneticLineAttractionFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\MagneticLineAttractionFilter.cs,DrawArrowForces,The length of the statement  "		PointD scaledVector2 = testNormal2 * (GetScalar () * 7 * m_Param.C / Math.Pow ((m_Param.PathThickness / 2.0) + 10' 0.5)); " is 121.
Long Statement,KinTemplates.Cursor.Tools,MagneticPointAttractionFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\MagneticPointAttractionFilter.cs,GetInnerVelocity,The length of the statement  "	//    PointD scaledVector = unitVectorToPosition * (dir * 7 * m_Param.C / Math.Pow(vectorToPosition.Magnitude() + 10' 0.5)); " is 124.
Long Statement,KinTemplates.Cursor.Tools,PointToolFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\PointToolFilter.cs,GetVelocity,The length of the statement  "	//System.Diagnostics.Debug.WriteLine(String.Format("theta:{0} theta':{1} xy:{2} xy':{3}"' mp.Delta.Theta' mp.Delta.Theta * rfactors.Scaling.Theta' " is 146.
Long Statement,KinTemplates.Cursor.Tools,PointToolFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\PointToolFilter.cs,Draw,The length of the statement  "			//path.AddEllipse(new RectangleF(-(float)m_Param.PtRadius' -(float)m_Param.PtRadius' (float)m_Param.PtRadius *2 ' (float)m_Param.PtRadius * 2)); " is 144.
Long Statement,KinTemplates.Cursor.Tools,PointToolFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\PointToolFilter.cs,IsForce,The length of the statement  "	return this is OrbitFilter || this is OrbitFilter2 || this is OrbitFilter3 || this is MagneticPointAttractionFilter || this is RubberBandFilter; " is 144.
Long Statement,KinTemplates.Cursor.Tools,PointToolFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\PointToolFilter.cs,DrawInsides,The length of the statement  "			gc.DrawEllipse (r.RegionGuides' new RectangleF (-i * ringSpacing' -i * ringSpacing' i * ringSpacing * 2' i * ringSpacing * 2)); " is 127.
Long Statement,KinTemplates.Cursor.Tools,PointToolFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\PointToolFilter.cs,DrawArrowPoints,The length of the statement  "			//ParameterizedMousePosition fakeMouse = new ParameterizedMousePosition(mouse' 20);// TODO: instrument from the computer " is 120.
Long Statement,KinTemplates.Cursor.Tools,PointToolFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\PointToolFilter.cs,DrawArrowPoints,The length of the statement  "				vel = theVector * (m_Param.V.Y != 0 ? Math.Sign (m_Param.V.Y) : 1) * -Render.DrawHelper.SPEED_AMPLIFIER * (m_Param.C + 0.1); " is 124.
Long Statement,KinTemplates.Cursor.Tools,PointToolFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\PointToolFilter.cs,DrawArrowPoints,The length of the statement  "				vel = theVector * (m_Param.V.Y != 0 ? Math.Sign (m_Param.V.Y) : 1) * -Render.DrawHelper.SPEED_AMPLIFIER * (m_Param.C + 0.1) * Math.Pow (innerRadius / m_Param.PtRadius' 2); " is 171.
Long Statement,KinTemplates.Cursor.Tools,PointToolFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\PointToolFilter.cs,DrawArrowPoints,The length of the statement  "				vel = PointD.Orthogonal (theVector) * (m_Param.V.X != 0 ? Math.Sign (m_Param.V.X) : 1) * Render.DrawHelper.SPEED_AMPLIFIER * (m_Param.C + 0.1); " is 143.
Long Statement,KinTemplates.Cursor.Tools,PointToolFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\PointToolFilter.cs,DrawArrowPoints,The length of the statement  "				vel = PointD.Orthogonal (theVector) * (m_Param.V.X != 0 ? Math.Sign (m_Param.V.X) : 1) * (m_Param.C + 0.1) * (innerRadius / 4); " is 127.
Long Statement,KinTemplates.Cursor.Tools,PointToolFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\PointToolFilter.cs,DrawArrowPoints,The length of the statement  "				vel = PointD.Orthogonal (theVector) * (m_Param.V.X != 0 ? Math.Sign (m_Param.V.X) : 1) * (m_Param.C + 0.1) * (innerRadius / 4); " is 127.
Long Statement,KinTemplates.Cursor.Tools,RegionToolPathFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\RegionToolPathFilter.cs,Draw,The length of the statement  "				gc.DrawEllipse (dashPen' (float)firstPoint.X - Tools.Render.DrawHelper.TARGET_SIZE / 2.0f' (float)firstPoint.Y - Tools.Render.DrawHelper.TARGET_SIZE / 2.0f' (float)Tools.Render.DrawHelper.TARGET_SIZE' (float)Tools.Render.DrawHelper.TARGET_SIZE); " is 245.
Long Statement,KinTemplates.Cursor.Tools,RegionToolRegionFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\RegionToolRegionFilter.cs,Draw,The length of the statement  "					gc.DrawEllipse (dashPen' (float)firstPoint.X - Tools.Render.DrawHelper.TARGET_SIZE / 2.0f' (float)firstPoint.Y - Tools.Render.DrawHelper.TARGET_SIZE / 2.0f' (float)Tools.Render.DrawHelper.TARGET_SIZE' (float)Tools.Render.DrawHelper.TARGET_SIZE); " is 245.
Long Statement,KinTemplates.Cursor.Tools,RegionToolRegionFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\RegionToolRegionFilter.cs,DrawRegionRepresentation,The length of the statement  "		gc.DrawString (ToString ()' r.FontType' new SolidBrush (r.RegionGuides.Color)' new PointF ((float)mousePosition.X' (float)mousePosition.Y - 15)); " is 145.
Long Statement,KinTemplates.Cursor.Tools,RubberBandFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\RubberBandFilter.cs,GetInnerVelocity,The length of the statement  "	//        scaledVector = GetScalar() * m_Param.C * unitVectorToPosition * (vectorToPosition.Magnitude() - innerRadius) / (outerRadius - innerRadius); " is 149.
Long Statement,KinTemplates.Cursor.Tools,SteadyHandFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\SteadyHandFilter.cs,DrawRegionRepresentation,The length of the statement  "		gc.DrawString (ToString ()' r.FontType' new System.Drawing.SolidBrush (r.RegionGuides.Color)' new System.Drawing.PointF ((float)mousePosition.X' (float)mousePosition.Y - 15)); " is 175.
Long Statement,KinTemplates.Cursor.Tools,SteadyHandFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\SteadyHandFilter.cs,GetVelocity,The length of the statement  "			//velParallel = PointD.DotProduct(m_direction' m.GetVelocity()) * m_direction;// PointD.DotProduct(m_direction' m.GetVelocity()) * -(1 - m_Param.C) * m_direction; " is 162.
Long Statement,KinTemplates.Cursor.Tools,SteadyHandFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\SteadyHandFilter.cs,GetVelocity,The length of the statement  "		PointD origVelocityNormal = PointD.DotProduct (PointD.Orthogonal (m_direction)' m.GetVelocity ()) * PointD.Orthogonal (m_direction); " is 132.
Long Statement,KinTemplates.Cursor.Tools.Render,OnlineFeedback,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\Render\OnlineFeedback.cs,AddFilter,The length of the statement  "		//        c.ClipPath.AddLine((Point)(filter.Parameters.Pt + unitVector * Math.Max( filter.Parameters.PtSize.X' filter.Parameters.PtSize.Y) )' " is 141.
Long Statement,KinTemplates.Cursor.Tools.Render,OnlineFeedback,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\Render\OnlineFeedback.cs,AddFilter,The length of the statement  "		//            (Point)(filter.Parameters.Pt - unitVector * Math.Max(filter.Parameters.PtSize.X' filter.Parameters.PtSize.Y))); " is 125.
Long Statement,KinTemplates.Cursor.Tools.Render,StaticFeedback,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\Render\StaticFeedback.cs,AddFilter,The length of the statement  "	if (filter is Tools.ConveyorBeltFilter || filter is Tools.ConveyorBeltFilter2 || filter is Tools.OrbitFilter || filter is Tools.OrbitFilter2 || filter is Tools.OrbitFilter3 || filter is Tools.MagneticLineAttractionFilter || filter is Tools.MagneticPointAttractionFilter || filter is Tools.RubberBandFilter// || filter is Tools.TunnelLineFilter  " is 343.
Long Statement,KinTemplates.Cursor.Tools.Model,BitmapPath,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\Model\BitmapPath.cs,AddLine,The length of the statement  "		AddEllipse (new RectangleF (new PointF ((float)(pt.X - m_pathThickness)' (float)(pt.Y - m_pathThickness))' new SizeF ((float)(m_pathThickness * 2)' (float)(m_pathThickness * 2)))); " is 180.
Complex Conditional,KinTemplates.Cursor,FilterManager,C:\repos\rhfung_KinematicTemplates\KTCursor\src\FilterManager.cs,Compute,The conditional expression  "!(double.IsNaN (vel.X) || double.IsInfinity (vel.X) || double.IsNaN (vel.Y) || double.IsNaN (vel.Y))"  is complex.
Complex Conditional,KinTemplates.Cursor.Position,ParameterizedMousePosition,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Position\ParameterizedMousePosition.cs,SetVelocity,The conditional expression  "(newVelocity.X > -10000 && newVelocity.X < 100000 && newVelocity.Y > -10000 && newVelocity.Y < 10000)"  is complex.
Complex Conditional,KinTemplates.Cursor.Tools,LineToolFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\LineToolFilter.cs,FastNearestPoint,The conditional expression  "(rad_l < rad_m && rad_m < rad_u) || (rad_m < rad_l && rad_l < rad_u)"  is complex.
Complex Conditional,KinTemplates.Cursor.Tools,LineToolFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\LineToolFilter.cs,FastNearestPoint,The conditional expression  "(rad_u < rad_m && rad_m < rad_l) || (rad_m < rad_u && rad_u < rad_l)"  is complex.
Complex Conditional,KinTemplates.Cursor.Tools.Render,StaticFeedback,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\Render\StaticFeedback.cs,AddFilter,The conditional expression  "filter is Tools.ConveyorBeltFilter || filter is Tools.ConveyorBeltFilter2 || filter is Tools.OrbitFilter || filter is Tools.OrbitFilter2 || filter is Tools.OrbitFilter3 || filter is Tools.MagneticLineAttractionFilter || filter is Tools.MagneticPointAttractionFilter || filter is Tools.RubberBandFilter"  is complex.
Complex Conditional,KinTemplates.Cursor.Tools.Model,BitmapPath,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\Model\BitmapPath.cs,IsVisible,The conditional expression  "point.X < 0 || point.Y < 0 || point.X > imgSize.Width || point.Y > imgSize.Height"  is complex.
Empty Catch Block,KinTemplates.Cursor.Tools,LineToolFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\LineToolFilter.cs,DrawOutline,The method has an empty catch block.
Empty Catch Block,KinTemplates.Cursor.Tools,LineToolFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\LineToolFilter.cs,Draw,The method has an empty catch block.
Magic Number,KinTemplates.Cursor.Logger,MouseLogger,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Logger\MouseLogger.cs,MouseMoved,The following statement contains a magic number: if (m_virtualDelta.Count > MouseLogger.TAIL_LENGTH) {  	// BUG: sometimes mouseMoved gets fired with no movement of the mouse'  	// flooding the event queue with many points of data estimated to be  	// > 40'000 points. Remove first half of the point data when such a   	// condition may occur.  	m_virtualDelta.RemoveRange (0' MouseLogger.TAIL_LENGTH / 2);  	m_realDelta.RemoveRange (0' MouseLogger.TAIL_LENGTH / 2);  }  
Magic Number,KinTemplates.Cursor.Logger,MouseLogger,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Logger\MouseLogger.cs,MouseMoved,The following statement contains a magic number: if (m_virtualDelta.Count > MouseLogger.TAIL_LENGTH) {  	// BUG: sometimes mouseMoved gets fired with no movement of the mouse'  	// flooding the event queue with many points of data estimated to be  	// > 40'000 points. Remove first half of the point data when such a   	// condition may occur.  	m_virtualDelta.RemoveRange (0' MouseLogger.TAIL_LENGTH / 2);  	m_realDelta.RemoveRange (0' MouseLogger.TAIL_LENGTH / 2);  }  
Magic Number,KinTemplates.Cursor.Logger,MouseLogger,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Logger\MouseLogger.cs,MouseMoved,The following statement contains a magic number: m_virtualDelta.RemoveRange (0' MouseLogger.TAIL_LENGTH / 2);  
Magic Number,KinTemplates.Cursor.Logger,MouseLogger,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Logger\MouseLogger.cs,MouseMoved,The following statement contains a magic number: m_realDelta.RemoveRange (0' MouseLogger.TAIL_LENGTH / 2);  
Magic Number,KinTemplates,PointD,C:\repos\rhfung_KinematicTemplates\KTCursor\src\PointD.cs,UnitVector,The following statement contains a magic number: if (vector.Magnitude () < 0.0001)  	return PointD.Empty;  else  	return vector / vector.Magnitude ();  
Magic Number,KinTemplates.Cursor.Position,ParameterizedMousePosition,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Position\ParameterizedMousePosition.cs,SetVelocity,The following statement contains a magic number: System.Diagnostics.Debug.Assert (newVelocity.X > -10000 && newVelocity.X < 100000 && newVelocity.Y > -10000 && newVelocity.Y < 10000);  
Magic Number,KinTemplates.Cursor.Position,ParameterizedMousePosition,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Position\ParameterizedMousePosition.cs,SetVelocity,The following statement contains a magic number: System.Diagnostics.Debug.Assert (newVelocity.X > -10000 && newVelocity.X < 100000 && newVelocity.Y > -10000 && newVelocity.Y < 10000);  
Magic Number,KinTemplates.Cursor.Position,ParameterizedMousePosition,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Position\ParameterizedMousePosition.cs,SetVelocity,The following statement contains a magic number: System.Diagnostics.Debug.Assert (newVelocity.X > -10000 && newVelocity.X < 100000 && newVelocity.Y > -10000 && newVelocity.Y < 10000);  
Magic Number,KinTemplates.Cursor.Position,ParameterizedMousePosition,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Position\ParameterizedMousePosition.cs,SetVelocity,The following statement contains a magic number: System.Diagnostics.Debug.Assert (newVelocity.X > -10000 && newVelocity.X < 100000 && newVelocity.Y > -10000 && newVelocity.Y < 10000);  
Magic Number,KinTemplates.Cursor.Position,ParameterizedMousePosition,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Position\ParameterizedMousePosition.cs,SetVelocity,The following statement contains a magic number: if ((newVelocity.X > -10000 && newVelocity.X < 100000 && newVelocity.Y > -10000 && newVelocity.Y < 10000)) {  	m_newVelocity = newVelocity;  }  else {  	m_newVelocity = new PointD (0' 0);  }  
Magic Number,KinTemplates.Cursor.Position,ParameterizedMousePosition,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Position\ParameterizedMousePosition.cs,SetVelocity,The following statement contains a magic number: if ((newVelocity.X > -10000 && newVelocity.X < 100000 && newVelocity.Y > -10000 && newVelocity.Y < 10000)) {  	m_newVelocity = newVelocity;  }  else {  	m_newVelocity = new PointD (0' 0);  }  
Magic Number,KinTemplates.Cursor.Position,ParameterizedMousePosition,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Position\ParameterizedMousePosition.cs,SetVelocity,The following statement contains a magic number: if ((newVelocity.X > -10000 && newVelocity.X < 100000 && newVelocity.Y > -10000 && newVelocity.Y < 10000)) {  	m_newVelocity = newVelocity;  }  else {  	m_newVelocity = new PointD (0' 0);  }  
Magic Number,KinTemplates.Cursor.Position,ParameterizedMousePosition,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Position\ParameterizedMousePosition.cs,SetVelocity,The following statement contains a magic number: if ((newVelocity.X > -10000 && newVelocity.X < 100000 && newVelocity.Y > -10000 && newVelocity.Y < 10000)) {  	m_newVelocity = newVelocity;  }  else {  	m_newVelocity = new PointD (0' 0);  }  
Magic Number,KinTemplates.Cursor.Position,VirtualBoundedMousePosition,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Position\VirtualBoundedMousePosition.cs,VirtualBoundedMousePosition,The following statement contains a magic number: for (int i = 0; i < Screen.AllScreens.Length; i++) {  	m_bounds [i] = new Rectangle (Screen.AllScreens [i].Bounds.Left + 50' Screen.AllScreens [i].Bounds.Top + 50' Screen.AllScreens [i].Bounds.Width - 100' Screen.AllScreens [i].Bounds.Height - 100);  }  
Magic Number,KinTemplates.Cursor.Position,VirtualBoundedMousePosition,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Position\VirtualBoundedMousePosition.cs,VirtualBoundedMousePosition,The following statement contains a magic number: for (int i = 0; i < Screen.AllScreens.Length; i++) {  	m_bounds [i] = new Rectangle (Screen.AllScreens [i].Bounds.Left + 50' Screen.AllScreens [i].Bounds.Top + 50' Screen.AllScreens [i].Bounds.Width - 100' Screen.AllScreens [i].Bounds.Height - 100);  }  
Magic Number,KinTemplates.Cursor.Position,VirtualBoundedMousePosition,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Position\VirtualBoundedMousePosition.cs,VirtualBoundedMousePosition,The following statement contains a magic number: for (int i = 0; i < Screen.AllScreens.Length; i++) {  	m_bounds [i] = new Rectangle (Screen.AllScreens [i].Bounds.Left + 50' Screen.AllScreens [i].Bounds.Top + 50' Screen.AllScreens [i].Bounds.Width - 100' Screen.AllScreens [i].Bounds.Height - 100);  }  
Magic Number,KinTemplates.Cursor.Position,VirtualBoundedMousePosition,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Position\VirtualBoundedMousePosition.cs,VirtualBoundedMousePosition,The following statement contains a magic number: for (int i = 0; i < Screen.AllScreens.Length; i++) {  	m_bounds [i] = new Rectangle (Screen.AllScreens [i].Bounds.Left + 50' Screen.AllScreens [i].Bounds.Top + 50' Screen.AllScreens [i].Bounds.Width - 100' Screen.AllScreens [i].Bounds.Height - 100);  }  
Magic Number,KinTemplates.Cursor.Position,VirtualBoundedMousePosition,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Position\VirtualBoundedMousePosition.cs,VirtualBoundedMousePosition,The following statement contains a magic number: m_bounds [i] = new Rectangle (Screen.AllScreens [i].Bounds.Left + 50' Screen.AllScreens [i].Bounds.Top + 50' Screen.AllScreens [i].Bounds.Width - 100' Screen.AllScreens [i].Bounds.Height - 100);  
Magic Number,KinTemplates.Cursor.Position,VirtualBoundedMousePosition,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Position\VirtualBoundedMousePosition.cs,VirtualBoundedMousePosition,The following statement contains a magic number: m_bounds [i] = new Rectangle (Screen.AllScreens [i].Bounds.Left + 50' Screen.AllScreens [i].Bounds.Top + 50' Screen.AllScreens [i].Bounds.Width - 100' Screen.AllScreens [i].Bounds.Height - 100);  
Magic Number,KinTemplates.Cursor.Position,VirtualBoundedMousePosition,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Position\VirtualBoundedMousePosition.cs,VirtualBoundedMousePosition,The following statement contains a magic number: m_bounds [i] = new Rectangle (Screen.AllScreens [i].Bounds.Left + 50' Screen.AllScreens [i].Bounds.Top + 50' Screen.AllScreens [i].Bounds.Width - 100' Screen.AllScreens [i].Bounds.Height - 100);  
Magic Number,KinTemplates.Cursor.Position,VirtualBoundedMousePosition,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Position\VirtualBoundedMousePosition.cs,VirtualBoundedMousePosition,The following statement contains a magic number: m_bounds [i] = new Rectangle (Screen.AllScreens [i].Bounds.Left + 50' Screen.AllScreens [i].Bounds.Top + 50' Screen.AllScreens [i].Bounds.Width - 100' Screen.AllScreens [i].Bounds.Height - 100);  
Magic Number,KinTemplates.Cursor.Position,VirtualMousePosition,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Position\VirtualMousePosition.cs,SetPhysicalPoint,The following statement contains a magic number: if (m_Timer.DurationInterval < 10000) {  	m_Timer.Start ();  	return false;  }  else {  	//m_LastVelocity = new PointD(  	//    GetVelocity().X + 1.0 / 2.0 * GetAcceleration().X * GetTimeInterval()'  	//    GetVelocity().Y + 1.0 / 2.0 * GetAcceleration().Y * GetTimeInterval());  	m_LastVelocity = GetVelocity ();  	m_LastPhysicalPos = m_CurPhysicalPos;  	m_CurPhysicalPos = physicalPosition;  	m_TimeInterval = m_Timer.DurationInterval / 10000;  	m_LastTime = curTime;  	m_Timer.Start ();  	return true;  }  
Magic Number,KinTemplates.Cursor.Position,VirtualMousePosition,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Position\VirtualMousePosition.cs,SetPhysicalPoint,The following statement contains a magic number: if (m_Timer.DurationInterval < 10000) {  	m_Timer.Start ();  	return false;  }  else {  	//m_LastVelocity = new PointD(  	//    GetVelocity().X + 1.0 / 2.0 * GetAcceleration().X * GetTimeInterval()'  	//    GetVelocity().Y + 1.0 / 2.0 * GetAcceleration().Y * GetTimeInterval());  	m_LastVelocity = GetVelocity ();  	m_LastPhysicalPos = m_CurPhysicalPos;  	m_CurPhysicalPos = physicalPosition;  	m_TimeInterval = m_Timer.DurationInterval / 10000;  	m_LastTime = curTime;  	m_Timer.Start ();  	return true;  }  
Magic Number,KinTemplates.Cursor.Position,VirtualMousePosition,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Position\VirtualMousePosition.cs,SetPhysicalPoint,The following statement contains a magic number: m_TimeInterval = m_Timer.DurationInterval / 10000;  
Magic Number,KinTemplates.Cursor.Position,VirtualMousePosition,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Position\VirtualMousePosition.cs,GetUnitDirection,The following statement contains a magic number: if (GetDistance () < 0.00001) {  	return new PointD (0' 0);  }  else {  	return new PointD (GetDisplacement ().X / GetDistance ()' GetDisplacement ().Y / GetDistance ());  }  
Magic Number,KinTemplates.Cursor.Position,VirtualMousePosition,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Position\VirtualMousePosition.cs,GetAcceleration,The following statement contains a magic number: if (GetTimeInterval () < 1) {  	return new PointD (0' 0);  }  else {  	double deltaSpeed = vel.Magnitude () - m_LastVelocity.Magnitude ();  	double magnitudeVel = Distance (vel' m_LastVelocity);  	PointD unitAccel;  	if (Math.Abs (magnitudeVel) > 0.000001)  		unitAccel = new PointD ((vel.X - m_LastVelocity.X) / magnitudeVel' (vel.Y - m_LastVelocity.Y) / magnitudeVel);  	else  		unitAccel = new PointD (0' 0);  	return new PointD (unitAccel.X * deltaSpeed / GetTimeInterval ()' unitAccel.Y * deltaSpeed / GetTimeInterval ());  }  
Magic Number,KinTemplates.Cursor.Position,VirtualMousePosition,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Position\VirtualMousePosition.cs,GetAcceleration,The following statement contains a magic number: if (Math.Abs (magnitudeVel) > 0.000001)  	unitAccel = new PointD ((vel.X - m_LastVelocity.X) / magnitudeVel' (vel.Y - m_LastVelocity.Y) / magnitudeVel);  else  	unitAccel = new PointD (0' 0);  
Magic Number,KinTemplates.Cursor.Tools,ConveyorBeltFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\ConveyorBeltFilter.cs,DrawRegionRepresentation,The following statement contains a magic number: for (double i = bounds.Width / (Render.DrawHelper.X_ARROWS + 1); i < bounds.Width; i += bounds.Width / (Render.DrawHelper.X_ARROWS + 1)) {  	for (double j = bounds.Height / (Render.DrawHelper.Y_ARROWS + 1); j < bounds.Height; j += bounds.Height / (Render.DrawHelper.Y_ARROWS + 1)) {  		Point thePoint = new Point ((int)(bounds.Left + i)' (int)(bounds.Top + j));  		if (m_Param.Path.IsVisible (thePoint)) {  			Position.VirtualMousePosition mouse = new Position.VirtualMousePosition ((Point)thePoint);  			PointD vector = GetVelocity (mouse) * Render.DrawHelper.SPEED_AMPLIFIER * (m_Param.C + 0.1);  			drawMethods.DrawArrow (gc' r' (PointD)thePoint' vector);  		}  	}  }  
Magic Number,KinTemplates.Cursor.Tools,ConveyorBeltFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\ConveyorBeltFilter.cs,DrawRegionRepresentation,The following statement contains a magic number: for (double j = bounds.Height / (Render.DrawHelper.Y_ARROWS + 1); j < bounds.Height; j += bounds.Height / (Render.DrawHelper.Y_ARROWS + 1)) {  	Point thePoint = new Point ((int)(bounds.Left + i)' (int)(bounds.Top + j));  	if (m_Param.Path.IsVisible (thePoint)) {  		Position.VirtualMousePosition mouse = new Position.VirtualMousePosition ((Point)thePoint);  		PointD vector = GetVelocity (mouse) * Render.DrawHelper.SPEED_AMPLIFIER * (m_Param.C + 0.1);  		drawMethods.DrawArrow (gc' r' (PointD)thePoint' vector);  	}  }  
Magic Number,KinTemplates.Cursor.Tools,ConveyorBeltFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\ConveyorBeltFilter.cs,DrawRegionRepresentation,The following statement contains a magic number: if (m_Param.Path.IsVisible (thePoint)) {  	Position.VirtualMousePosition mouse = new Position.VirtualMousePosition ((Point)thePoint);  	PointD vector = GetVelocity (mouse) * Render.DrawHelper.SPEED_AMPLIFIER * (m_Param.C + 0.1);  	drawMethods.DrawArrow (gc' r' (PointD)thePoint' vector);  }  
Magic Number,KinTemplates.Cursor.Tools,ConveyorBeltFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\ConveyorBeltFilter.cs,GetParamHandlePos,The following statement contains a magic number: return PointD.FromSize (m_Param.Path.GetBounds ().Size) / 2.0;  
Magic Number,KinTemplates.Cursor.Tools,ConveyorBeltFilter2,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\ConveyorBeltFilter2.cs,GetVelocity,The following statement contains a magic number: if (m.GetDistance () > 0.1) {  	PointD dir = m_Param.V;  	return new PointD (dir.X * m_Param.C' dir.Y * m_Param.C);  }  else {  	return PointD.Empty;  }  
Magic Number,KinTemplates.Cursor.Tools,ConveyorBeltFilter2,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\ConveyorBeltFilter2.cs,DrawRegionRepresentation,The following statement contains a magic number: for (double i = bounds.Width / (Render.DrawHelper.X_ARROWS + 1); i < bounds.Width; i += bounds.Width / (Render.DrawHelper.X_ARROWS + 1)) {  	for (double j = bounds.Height / (Render.DrawHelper.Y_ARROWS + 1); j < bounds.Height; j += bounds.Height / (Render.DrawHelper.Y_ARROWS + 1)) {  		Point thePoint = new Point ((int)(bounds.Left + i)' (int)(bounds.Top + j));  		if (m_Param.Path.IsVisible (thePoint)) {  			Position.VirtualMousePosition mouse = new Position.VirtualMousePosition ((Point)thePoint);  			PointD vector = GetVelocity (mouse) * Render.DrawHelper.SPEED_AMPLIFIER * (m_Param.C + 0.1);  			drawMethods.DrawArrow (gc' r' (PointD)thePoint' vector);  		}  	}  }  
Magic Number,KinTemplates.Cursor.Tools,ConveyorBeltFilter2,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\ConveyorBeltFilter2.cs,DrawRegionRepresentation,The following statement contains a magic number: for (double j = bounds.Height / (Render.DrawHelper.Y_ARROWS + 1); j < bounds.Height; j += bounds.Height / (Render.DrawHelper.Y_ARROWS + 1)) {  	Point thePoint = new Point ((int)(bounds.Left + i)' (int)(bounds.Top + j));  	if (m_Param.Path.IsVisible (thePoint)) {  		Position.VirtualMousePosition mouse = new Position.VirtualMousePosition ((Point)thePoint);  		PointD vector = GetVelocity (mouse) * Render.DrawHelper.SPEED_AMPLIFIER * (m_Param.C + 0.1);  		drawMethods.DrawArrow (gc' r' (PointD)thePoint' vector);  	}  }  
Magic Number,KinTemplates.Cursor.Tools,ConveyorBeltFilter2,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\ConveyorBeltFilter2.cs,DrawRegionRepresentation,The following statement contains a magic number: if (m_Param.Path.IsVisible (thePoint)) {  	Position.VirtualMousePosition mouse = new Position.VirtualMousePosition ((Point)thePoint);  	PointD vector = GetVelocity (mouse) * Render.DrawHelper.SPEED_AMPLIFIER * (m_Param.C + 0.1);  	drawMethods.DrawArrow (gc' r' (PointD)thePoint' vector);  }  
Magic Number,KinTemplates.Cursor.Tools,ConveyorBeltFilter2,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\ConveyorBeltFilter2.cs,GetParamHandlePos,The following statement contains a magic number: return PointD.FromSize (m_Param.Path.GetBounds ().Size) / 2.0;  
Magic Number,KinTemplates.Cursor.Tools,CorduroyFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\CorduroyFilter.cs,DrawRegionRepresentation,The following statement contains a magic number: if (m_Param.Path.PointCount > 0) {  	GraphicsPath fill = new GraphicsPath ();  	RectangleF rect = m_Param.Path.GetBounds ();  	PointD refPt = (PointD)rect.Location + ((PointD)rect.Size.ToPointF ()) / 2;  	// this will draw beyond the shape's location  	for (double i = -rect.Height; i < rect.Height; i++) {  		PointD pt1 = refPt + PointD.Orthogonal (m_Param.V) * i * drawMethods.Spacing (m_Param.C);  		PointD pt2 = pt1 + m_Param.V * rect.Width * rect.Height;  		PointD pt3 = pt1 - m_Param.V * rect.Width * rect.Height;  		fill.StartFigure ();  		fill.AddLine ((Point)pt2' (Point)pt3);  	}  	GraphicsContainer c = gc.BeginContainer ();  	gc.SetClip ((Tools.Model.VectorPath)m_Param.Path);  	gc.DrawPath (r.RegionGuides' fill);  	gc.EndContainer (c);  }  
Magic Number,KinTemplates.Cursor.Tools,CorduroyFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\CorduroyFilter.cs,GetParamHandlePos,The following statement contains a magic number: return PointD.FromSize (m_Param.Path.GetBounds ().Size) / 2.0;  
Magic Number,KinTemplates.Cursor.Tools,FakeHatchingFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\FakeHatchingFilter.cs,DrawRegionRepresentation,The following statement contains a magic number: if (m_Param.Path.PointCount > 0) {  	GraphicsPath fill = new GraphicsPath ();  	RectangleF rect = m_Param.Path.GetBounds ();  	PointD refPt = (PointD)rect.Location + ((PointD)rect.Size.ToPointF ()) / 2;  	// this will draw beyond the shape's location  	for (double i = -rect.Height; i < rect.Height; i++) {  		PointD pt1 = refPt + PointD.Orthogonal (m_Param.V) * i * drawMethods.Spacing (m_Param.C);  		PointD pt2 = pt1 + m_Param.V * rect.Width * rect.Height;  		PointD pt3 = pt1 - m_Param.V * rect.Width * rect.Height;  		fill.StartFigure ();  		fill.AddLine ((Point)pt2' (Point)pt3);  	}  	GraphicsContainer c = gc.BeginContainer ();  	gc.SetClip ((Tools.Model.VectorPath)m_Param.Path);  	gc.DrawPath (r.RegionGuides' fill);  	gc.EndContainer (c);  }  
Magic Number,KinTemplates.Cursor.Tools,FakeHatchingFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\FakeHatchingFilter.cs,GetParamHandlePos,The following statement contains a magic number: return PointD.FromSize (m_Param.Path.GetBounds ().Size) / 2.0;  
Magic Number,KinTemplates.Cursor.Tools,FurFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\FurFilter.cs,GetParamHandlePos,The following statement contains a magic number: return PointD.FromSize (m_Param.Path.GetBounds ().Size) / 2.0;  
Magic Number,KinTemplates.Cursor.Tools,GridFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\GridFilter.cs,DrawRegionRepresentation,The following statement contains a magic number: if (m_Param.Path.PointCount > 0) {  	GraphicsPath fill = new GraphicsPath ();  	RectangleF rect = m_Param.Path.GetBounds ();  	PointD refPt = (PointD)rect.Location + ((PointD)rect.Size.ToPointF ()) / 2;  	// this will draw beyond the shape's location  	for (double i = -rect.Height; i < rect.Height; i++) {  		PointD orth = PointD.Orthogonal (m_Param.V);  		PointD pt1 = refPt + orth * i * drawMethods.Spacing (m_Param.C);  		PointD pt2 = pt1 + m_Param.V * rect.Width * rect.Height;  		PointD pt3 = pt1 - m_Param.V * rect.Width * rect.Height;  		PointD pt4 = refPt + m_Param.V * i * drawMethods.Spacing (m_Param.C);  		PointD pt5 = pt4 + orth * rect.Width * rect.Height;  		PointD pt6 = pt4 - orth * rect.Width * rect.Height;  		fill.StartFigure ();  		fill.AddLine ((Point)pt2' (Point)pt3);  		fill.StartFigure ();  		fill.AddLine ((Point)pt5' (Point)pt6);  	}  	GraphicsContainer c = gc.BeginContainer ();  	gc.SetClip ((Tools.Model.VectorPath)m_Param.Path);  	gc.DrawPath (r.RegionGuides' fill);  	gc.EndContainer (c);  }  
Magic Number,KinTemplates.Cursor.Tools,GridFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\GridFilter.cs,GetParamHandlePos,The following statement contains a magic number: return PointD.FromSize (m_Param.Path.GetBounds ().Size) / 2.0;  
Magic Number,KinTemplates.Cursor.Tools,InertiaFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\InertiaFilter.cs,DrawRegionRepresentation,The following statement contains a magic number: if (m_Param.Path != null) {  	if (m_Param.Path.IsVisible ((Point)mousePosition)) {  		gc.DrawString ("+ speed"' r.FontType' new SolidBrush (r.RegionGuides.Color)' new PointF ((float)mousePosition.X' (float)mousePosition.Y - 15));  	}  }  else {  	gc.DrawString ("+ speed"' r.FontType' new SolidBrush (r.RegionGuides.Color)' new PointF ((float)mousePosition.X' (float)mousePosition.Y - 15));  }  
Magic Number,KinTemplates.Cursor.Tools,InertiaFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\InertiaFilter.cs,DrawRegionRepresentation,The following statement contains a magic number: if (m_Param.Path != null) {  	if (m_Param.Path.IsVisible ((Point)mousePosition)) {  		gc.DrawString ("+ speed"' r.FontType' new SolidBrush (r.RegionGuides.Color)' new PointF ((float)mousePosition.X' (float)mousePosition.Y - 15));  	}  }  else {  	gc.DrawString ("+ speed"' r.FontType' new SolidBrush (r.RegionGuides.Color)' new PointF ((float)mousePosition.X' (float)mousePosition.Y - 15));  }  
Magic Number,KinTemplates.Cursor.Tools,InertiaFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\InertiaFilter.cs,DrawRegionRepresentation,The following statement contains a magic number: if (m_Param.Path.IsVisible ((Point)mousePosition)) {  	gc.DrawString ("+ speed"' r.FontType' new SolidBrush (r.RegionGuides.Color)' new PointF ((float)mousePosition.X' (float)mousePosition.Y - 15));  }  
Magic Number,KinTemplates.Cursor.Tools,InertiaFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\InertiaFilter.cs,DrawRegionRepresentation,The following statement contains a magic number: gc.DrawString ("+ speed"' r.FontType' new SolidBrush (r.RegionGuides.Color)' new PointF ((float)mousePosition.X' (float)mousePosition.Y - 15));  
Magic Number,KinTemplates.Cursor.Tools,InertiaFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\InertiaFilter.cs,DrawRegionRepresentation,The following statement contains a magic number: gc.DrawString ("+ speed"' r.FontType' new SolidBrush (r.RegionGuides.Color)' new PointF ((float)mousePosition.X' (float)mousePosition.Y - 15));  
Magic Number,KinTemplates.Cursor.Tools,InertiaFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\InertiaFilter.cs,GetVelocity,The following statement contains a magic number: m_previousVelocity = m_previousVelocity * (1 - Math.Pow (m_Param.C - 1' 2)) + m.GetVelocity () * 0.3;  
Magic Number,KinTemplates.Cursor.Tools,InertiaFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\InertiaFilter.cs,GetVelocity,The following statement contains a magic number: m_previousVelocity = m_previousVelocity * (1 - Math.Pow (m_Param.C - 1' 2)) + m.GetVelocity () * 0.3;  
Magic Number,KinTemplates.Cursor.Tools,LineToolFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\LineToolFilter.cs,LineToolFilter,The following statement contains a magic number: m_Param.PathThickness = 30;  
Magic Number,KinTemplates.Cursor.Tools,LineToolFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\LineToolFilter.cs,GetParamHandlePos,The following statement contains a magic number: if (m_pointsInPath != null && m_pointsInPath.Length > 1) {  	PointD firstPt = (PointD)m_pointsInPath [m_pointsInPath.Length / 2];  	PointD secondPt = (PointD)m_pointsInPath [m_pointsInPath.Length / 2 + 1];  	PointD tangent = firstPt - secondPt;  	tangent = tangent / tangent.Magnitude ();  	// normalize  	PointD normal = PointD.Orthogonal (tangent);  	PointD drawPt = (normal * m_Param.PathThickness / 2) + firstPt - (PointD)GetEffectiveBoundingRect ().Location;  	// should be BoundingRect' hacked in ResizeHandles  	return drawPt;  }  else {  	return PointD.Empty;  }  
Magic Number,KinTemplates.Cursor.Tools,LineToolFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\LineToolFilter.cs,GetParamHandlePos,The following statement contains a magic number: if (m_pointsInPath != null && m_pointsInPath.Length > 1) {  	PointD firstPt = (PointD)m_pointsInPath [m_pointsInPath.Length / 2];  	PointD secondPt = (PointD)m_pointsInPath [m_pointsInPath.Length / 2 + 1];  	PointD tangent = firstPt - secondPt;  	tangent = tangent / tangent.Magnitude ();  	// normalize  	PointD normal = PointD.Orthogonal (tangent);  	PointD drawPt = (normal * m_Param.PathThickness / 2) + firstPt - (PointD)GetEffectiveBoundingRect ().Location;  	// should be BoundingRect' hacked in ResizeHandles  	return drawPt;  }  else {  	return PointD.Empty;  }  
Magic Number,KinTemplates.Cursor.Tools,LineToolFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\LineToolFilter.cs,GetParamHandlePos,The following statement contains a magic number: if (m_pointsInPath != null && m_pointsInPath.Length > 1) {  	PointD firstPt = (PointD)m_pointsInPath [m_pointsInPath.Length / 2];  	PointD secondPt = (PointD)m_pointsInPath [m_pointsInPath.Length / 2 + 1];  	PointD tangent = firstPt - secondPt;  	tangent = tangent / tangent.Magnitude ();  	// normalize  	PointD normal = PointD.Orthogonal (tangent);  	PointD drawPt = (normal * m_Param.PathThickness / 2) + firstPt - (PointD)GetEffectiveBoundingRect ().Location;  	// should be BoundingRect' hacked in ResizeHandles  	return drawPt;  }  else {  	return PointD.Empty;  }  
Magic Number,KinTemplates.Cursor.Tools,LineToolFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\LineToolFilter.cs,Draw,The following statement contains a magic number: if (m_Param.Path != null && m_Param.Path.PointCount >= 2) {  	try {  		if (m_visibleThickPath != null) {  			if (r.RegionInsideFill != null)  				gc.FillPath (r.RegionInsideFill' m_visibleThickPath);  			gc.DrawPath (r.RegionOutline' m_visibleThickPath);  		}  		gc.DrawPath (r.RegionOutline' (Tools.Model.VectorPath)m_Param.Path);  	}  	catch {  		// don't know what happened here  	}  	if (editState == Render.RenderHint.Start) {  		Pen dashPen = (Pen)r.RegionOutline.Clone ();  		dashPen.DashStyle = System.Drawing.Drawing2D.DashStyle.Dot;  		if (m_Param.Path.PointCount > 0) {  			PointD firstPoint = mousePosition;  			// TODO ((States.LineHover)editState).FirstPoint;  			gc.DrawEllipse (dashPen' (float)firstPoint.X - Tools.Render.DrawHelper.TARGET_SIZE / 2.0f' (float)firstPoint.Y - Tools.Render.DrawHelper.TARGET_SIZE / 2.0f' (float)Tools.Render.DrawHelper.TARGET_SIZE' (float)Tools.Render.DrawHelper.TARGET_SIZE);  		}  		/*                     PointD normal;                     double radius;                     NormalOfPoint(mousePosition' out normal' out radius);                     gc.DrawLine(r.ActivePen' (Point)mousePosition' (Point)(mousePosition - normal * radius));                      */}  	else {  		DrawArrowForces (gc' r' drawMethods);  	}  	drawMethods.DrawHandles (gc' this' r);  	// TODO ((States.IFilterHandles)editState).Handles.DrawHandles(gc' m_Param' r);  }  
Magic Number,KinTemplates.Cursor.Tools,LineToolFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\LineToolFilter.cs,FastNearestPoint,The following statement contains a magic number: if ((rad_l < rad_m && rad_m < rad_u) || (rad_m < rad_l && rad_l < rad_u)) {  	FastNearestPoint (sourcePoints' testPoint' startIndex' (startIndex + endIndex) / 2' out nearestIdx' out nearestRadius);  }  else if ((rad_u < rad_m && rad_m < rad_l) || (rad_m < rad_u && rad_u < rad_l)) {  	FastNearestPoint (sourcePoints' testPoint' (startIndex + endIndex) / 2 + 1' endIndex' out nearestIdx' out nearestRadius);  }  else// ((rad_l < rad_u && rad_u < rad_m) ||  // (rad_u < rad_l && rad_l < rad_m)   {  	int lowerIdx' upperIdx;  	float lowerRad' upperRad;  	FastNearestPoint (sourcePoints' testPoint' startIndex' (startIndex + endIndex) / 2' out lowerIdx' out lowerRad);  	FastNearestPoint (sourcePoints' testPoint' (startIndex + endIndex) / 2 + 1' endIndex' out upperIdx' out upperRad);  	if (lowerRad < upperRad) {  		nearestIdx = lowerIdx;  		nearestRadius = lowerRad;  	}  	else {  		nearestIdx = upperIdx;  		nearestRadius = upperRad;  	}  }  
Magic Number,KinTemplates.Cursor.Tools,LineToolFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\LineToolFilter.cs,FastNearestPoint,The following statement contains a magic number: if ((rad_l < rad_m && rad_m < rad_u) || (rad_m < rad_l && rad_l < rad_u)) {  	FastNearestPoint (sourcePoints' testPoint' startIndex' (startIndex + endIndex) / 2' out nearestIdx' out nearestRadius);  }  else if ((rad_u < rad_m && rad_m < rad_l) || (rad_m < rad_u && rad_u < rad_l)) {  	FastNearestPoint (sourcePoints' testPoint' (startIndex + endIndex) / 2 + 1' endIndex' out nearestIdx' out nearestRadius);  }  else// ((rad_l < rad_u && rad_u < rad_m) ||  // (rad_u < rad_l && rad_l < rad_m)   {  	int lowerIdx' upperIdx;  	float lowerRad' upperRad;  	FastNearestPoint (sourcePoints' testPoint' startIndex' (startIndex + endIndex) / 2' out lowerIdx' out lowerRad);  	FastNearestPoint (sourcePoints' testPoint' (startIndex + endIndex) / 2 + 1' endIndex' out upperIdx' out upperRad);  	if (lowerRad < upperRad) {  		nearestIdx = lowerIdx;  		nearestRadius = lowerRad;  	}  	else {  		nearestIdx = upperIdx;  		nearestRadius = upperRad;  	}  }  
Magic Number,KinTemplates.Cursor.Tools,LineToolFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\LineToolFilter.cs,FastNearestPoint,The following statement contains a magic number: if ((rad_l < rad_m && rad_m < rad_u) || (rad_m < rad_l && rad_l < rad_u)) {  	FastNearestPoint (sourcePoints' testPoint' startIndex' (startIndex + endIndex) / 2' out nearestIdx' out nearestRadius);  }  else if ((rad_u < rad_m && rad_m < rad_l) || (rad_m < rad_u && rad_u < rad_l)) {  	FastNearestPoint (sourcePoints' testPoint' (startIndex + endIndex) / 2 + 1' endIndex' out nearestIdx' out nearestRadius);  }  else// ((rad_l < rad_u && rad_u < rad_m) ||  // (rad_u < rad_l && rad_l < rad_m)   {  	int lowerIdx' upperIdx;  	float lowerRad' upperRad;  	FastNearestPoint (sourcePoints' testPoint' startIndex' (startIndex + endIndex) / 2' out lowerIdx' out lowerRad);  	FastNearestPoint (sourcePoints' testPoint' (startIndex + endIndex) / 2 + 1' endIndex' out upperIdx' out upperRad);  	if (lowerRad < upperRad) {  		nearestIdx = lowerIdx;  		nearestRadius = lowerRad;  	}  	else {  		nearestIdx = upperIdx;  		nearestRadius = upperRad;  	}  }  
Magic Number,KinTemplates.Cursor.Tools,LineToolFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\LineToolFilter.cs,FastNearestPoint,The following statement contains a magic number: if ((rad_l < rad_m && rad_m < rad_u) || (rad_m < rad_l && rad_l < rad_u)) {  	FastNearestPoint (sourcePoints' testPoint' startIndex' (startIndex + endIndex) / 2' out nearestIdx' out nearestRadius);  }  else if ((rad_u < rad_m && rad_m < rad_l) || (rad_m < rad_u && rad_u < rad_l)) {  	FastNearestPoint (sourcePoints' testPoint' (startIndex + endIndex) / 2 + 1' endIndex' out nearestIdx' out nearestRadius);  }  else// ((rad_l < rad_u && rad_u < rad_m) ||  // (rad_u < rad_l && rad_l < rad_m)   {  	int lowerIdx' upperIdx;  	float lowerRad' upperRad;  	FastNearestPoint (sourcePoints' testPoint' startIndex' (startIndex + endIndex) / 2' out lowerIdx' out lowerRad);  	FastNearestPoint (sourcePoints' testPoint' (startIndex + endIndex) / 2 + 1' endIndex' out upperIdx' out upperRad);  	if (lowerRad < upperRad) {  		nearestIdx = lowerIdx;  		nearestRadius = lowerRad;  	}  	else {  		nearestIdx = upperIdx;  		nearestRadius = upperRad;  	}  }  
Magic Number,KinTemplates.Cursor.Tools,LineToolFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\LineToolFilter.cs,FastNearestPoint,The following statement contains a magic number: FastNearestPoint (sourcePoints' testPoint' startIndex' (startIndex + endIndex) / 2' out nearestIdx' out nearestRadius);  
Magic Number,KinTemplates.Cursor.Tools,LineToolFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\LineToolFilter.cs,FastNearestPoint,The following statement contains a magic number: if ((rad_u < rad_m && rad_m < rad_l) || (rad_m < rad_u && rad_u < rad_l)) {  	FastNearestPoint (sourcePoints' testPoint' (startIndex + endIndex) / 2 + 1' endIndex' out nearestIdx' out nearestRadius);  }  else// ((rad_l < rad_u && rad_u < rad_m) ||  // (rad_u < rad_l && rad_l < rad_m)   {  	int lowerIdx' upperIdx;  	float lowerRad' upperRad;  	FastNearestPoint (sourcePoints' testPoint' startIndex' (startIndex + endIndex) / 2' out lowerIdx' out lowerRad);  	FastNearestPoint (sourcePoints' testPoint' (startIndex + endIndex) / 2 + 1' endIndex' out upperIdx' out upperRad);  	if (lowerRad < upperRad) {  		nearestIdx = lowerIdx;  		nearestRadius = lowerRad;  	}  	else {  		nearestIdx = upperIdx;  		nearestRadius = upperRad;  	}  }  
Magic Number,KinTemplates.Cursor.Tools,LineToolFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\LineToolFilter.cs,FastNearestPoint,The following statement contains a magic number: if ((rad_u < rad_m && rad_m < rad_l) || (rad_m < rad_u && rad_u < rad_l)) {  	FastNearestPoint (sourcePoints' testPoint' (startIndex + endIndex) / 2 + 1' endIndex' out nearestIdx' out nearestRadius);  }  else// ((rad_l < rad_u && rad_u < rad_m) ||  // (rad_u < rad_l && rad_l < rad_m)   {  	int lowerIdx' upperIdx;  	float lowerRad' upperRad;  	FastNearestPoint (sourcePoints' testPoint' startIndex' (startIndex + endIndex) / 2' out lowerIdx' out lowerRad);  	FastNearestPoint (sourcePoints' testPoint' (startIndex + endIndex) / 2 + 1' endIndex' out upperIdx' out upperRad);  	if (lowerRad < upperRad) {  		nearestIdx = lowerIdx;  		nearestRadius = lowerRad;  	}  	else {  		nearestIdx = upperIdx;  		nearestRadius = upperRad;  	}  }  
Magic Number,KinTemplates.Cursor.Tools,LineToolFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\LineToolFilter.cs,FastNearestPoint,The following statement contains a magic number: if ((rad_u < rad_m && rad_m < rad_l) || (rad_m < rad_u && rad_u < rad_l)) {  	FastNearestPoint (sourcePoints' testPoint' (startIndex + endIndex) / 2 + 1' endIndex' out nearestIdx' out nearestRadius);  }  else// ((rad_l < rad_u && rad_u < rad_m) ||  // (rad_u < rad_l && rad_l < rad_m)   {  	int lowerIdx' upperIdx;  	float lowerRad' upperRad;  	FastNearestPoint (sourcePoints' testPoint' startIndex' (startIndex + endIndex) / 2' out lowerIdx' out lowerRad);  	FastNearestPoint (sourcePoints' testPoint' (startIndex + endIndex) / 2 + 1' endIndex' out upperIdx' out upperRad);  	if (lowerRad < upperRad) {  		nearestIdx = lowerIdx;  		nearestRadius = lowerRad;  	}  	else {  		nearestIdx = upperIdx;  		nearestRadius = upperRad;  	}  }  
Magic Number,KinTemplates.Cursor.Tools,LineToolFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\LineToolFilter.cs,FastNearestPoint,The following statement contains a magic number: FastNearestPoint (sourcePoints' testPoint' (startIndex + endIndex) / 2 + 1' endIndex' out nearestIdx' out nearestRadius);  
Magic Number,KinTemplates.Cursor.Tools,LineToolFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\LineToolFilter.cs,FastNearestPoint,The following statement contains a magic number: FastNearestPoint (sourcePoints' testPoint' startIndex' (startIndex + endIndex) / 2' out lowerIdx' out lowerRad);  
Magic Number,KinTemplates.Cursor.Tools,LineToolFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\LineToolFilter.cs,FastNearestPoint,The following statement contains a magic number: FastNearestPoint (sourcePoints' testPoint' (startIndex + endIndex) / 2 + 1' endIndex' out upperIdx' out upperRad);  
Magic Number,KinTemplates.Cursor.Tools,LineToolFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\LineToolFilter.cs,NearestPoint,The following statement contains a magic number: if (sourcePoints.Length < 2) {  	nearestIdx = -1;  	secondNearestIdx = -1;  }  
Magic Number,KinTemplates.Cursor.Tools,LineToolFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\LineToolFilter.cs,SumAllPoints,The following statement contains a magic number: if (sourcePoints.Length < 2) {  	tangent = PointD.Empty;  	nearestIdx = -1;  	nearestRadius = 0;  	return;  }  
Magic Number,KinTemplates.Cursor.Tools,LineToolFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\LineToolFilter.cs,SumAllPoints,The following statement contains a magic number: for (int i = 1; i < sourcePoints.Length; i++) {  	float testDist = Distance (sourcePoints [i]' testPoint);  	if (testDist > 0.001)  		weightedVector = weightedVector + ((PointD)sourcePoints [i] - (PointD)sourcePoints [i - 1]) / testDist;  	if (testDist < nearestRadius) {  		nearestRadius = testDist;  		nearestIdx = i;  	}  }  
Magic Number,KinTemplates.Cursor.Tools,LineToolFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\LineToolFilter.cs,SumAllPoints,The following statement contains a magic number: if (testDist > 0.001)  	weightedVector = weightedVector + ((PointD)sourcePoints [i] - (PointD)sourcePoints [i - 1]) / testDist;  
Magic Number,KinTemplates.Cursor.Tools,LineToolFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\LineToolFilter.cs,FillPoints,The following statement contains a magic number: if (sourcePoints.Length < 2) {  	PointF[] retArray = new PointF[sourcePoints.Length];  	sourcePoints.CopyTo (retArray' 0);  	return retArray;  }  
Magic Number,KinTemplates.Cursor.Tools,MagneticLineAttractionFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\MagneticLineAttractionFilter.cs,GetVelocity,The following statement contains a magic number: if (normalComponent.Magnitude () < 2.0)  	return PointD.Empty;  
Magic Number,KinTemplates.Cursor.Tools,MagneticLineAttractionFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\MagneticLineAttractionFilter.cs,DrawArrowForces,The following statement contains a magic number: for (int i = 1; i < array.Length; i += 20) {  	PointD tangent = new PointD (array [i].X - array [i - 1].X' array [i].Y - array [i - 1].Y);  	tangent = tangent / tangent.Magnitude ();  	PointD normalVector = PointD.Orthogonal (tangent);  	PointD pointOnLine = new PointD ((array [i].X + array [i - 1].X) / 2.0' (array [i].Y + array [i - 1].Y) / 2.0);  	PointD testPt1 = pointOnLine + normalVector * m_Param.PathThickness / 4.0;  	PointD testPt2 = pointOnLine - normalVector * m_Param.PathThickness / 4.0;  	PointD testNormal1 = (testPt1 - pointOnLine);  	testNormal1 = testNormal1 / testNormal1.Magnitude ();  	PointD testNormal2 = (testPt2 - pointOnLine);  	testNormal2 = testNormal2 / testNormal2.Magnitude ();  	PointD scaledVector1 = testNormal1 * (GetScalar () * 7 * m_Param.C / Math.Pow ((m_Param.PathThickness / 2.0) + 10' 0.5));  	PointD scaledVector2 = testNormal2 * (GetScalar () * 7 * m_Param.C / Math.Pow ((m_Param.PathThickness / 2.0) + 10' 0.5));  	drawMethods.DrawArrow (gc' r' testPt1' scaledVector1 * Render.DrawHelper.SPEED_AMPLIFIER);  	drawMethods.DrawArrow (gc' r' testPt2' scaledVector2 * Render.DrawHelper.SPEED_AMPLIFIER);  }  
Magic Number,KinTemplates.Cursor.Tools,MagneticLineAttractionFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\MagneticLineAttractionFilter.cs,DrawArrowForces,The following statement contains a magic number: for (int i = 1; i < array.Length; i += 20) {  	PointD tangent = new PointD (array [i].X - array [i - 1].X' array [i].Y - array [i - 1].Y);  	tangent = tangent / tangent.Magnitude ();  	PointD normalVector = PointD.Orthogonal (tangent);  	PointD pointOnLine = new PointD ((array [i].X + array [i - 1].X) / 2.0' (array [i].Y + array [i - 1].Y) / 2.0);  	PointD testPt1 = pointOnLine + normalVector * m_Param.PathThickness / 4.0;  	PointD testPt2 = pointOnLine - normalVector * m_Param.PathThickness / 4.0;  	PointD testNormal1 = (testPt1 - pointOnLine);  	testNormal1 = testNormal1 / testNormal1.Magnitude ();  	PointD testNormal2 = (testPt2 - pointOnLine);  	testNormal2 = testNormal2 / testNormal2.Magnitude ();  	PointD scaledVector1 = testNormal1 * (GetScalar () * 7 * m_Param.C / Math.Pow ((m_Param.PathThickness / 2.0) + 10' 0.5));  	PointD scaledVector2 = testNormal2 * (GetScalar () * 7 * m_Param.C / Math.Pow ((m_Param.PathThickness / 2.0) + 10' 0.5));  	drawMethods.DrawArrow (gc' r' testPt1' scaledVector1 * Render.DrawHelper.SPEED_AMPLIFIER);  	drawMethods.DrawArrow (gc' r' testPt2' scaledVector2 * Render.DrawHelper.SPEED_AMPLIFIER);  }  
Magic Number,KinTemplates.Cursor.Tools,MagneticLineAttractionFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\MagneticLineAttractionFilter.cs,DrawArrowForces,The following statement contains a magic number: for (int i = 1; i < array.Length; i += 20) {  	PointD tangent = new PointD (array [i].X - array [i - 1].X' array [i].Y - array [i - 1].Y);  	tangent = tangent / tangent.Magnitude ();  	PointD normalVector = PointD.Orthogonal (tangent);  	PointD pointOnLine = new PointD ((array [i].X + array [i - 1].X) / 2.0' (array [i].Y + array [i - 1].Y) / 2.0);  	PointD testPt1 = pointOnLine + normalVector * m_Param.PathThickness / 4.0;  	PointD testPt2 = pointOnLine - normalVector * m_Param.PathThickness / 4.0;  	PointD testNormal1 = (testPt1 - pointOnLine);  	testNormal1 = testNormal1 / testNormal1.Magnitude ();  	PointD testNormal2 = (testPt2 - pointOnLine);  	testNormal2 = testNormal2 / testNormal2.Magnitude ();  	PointD scaledVector1 = testNormal1 * (GetScalar () * 7 * m_Param.C / Math.Pow ((m_Param.PathThickness / 2.0) + 10' 0.5));  	PointD scaledVector2 = testNormal2 * (GetScalar () * 7 * m_Param.C / Math.Pow ((m_Param.PathThickness / 2.0) + 10' 0.5));  	drawMethods.DrawArrow (gc' r' testPt1' scaledVector1 * Render.DrawHelper.SPEED_AMPLIFIER);  	drawMethods.DrawArrow (gc' r' testPt2' scaledVector2 * Render.DrawHelper.SPEED_AMPLIFIER);  }  
Magic Number,KinTemplates.Cursor.Tools,MagneticLineAttractionFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\MagneticLineAttractionFilter.cs,DrawArrowForces,The following statement contains a magic number: for (int i = 1; i < array.Length; i += 20) {  	PointD tangent = new PointD (array [i].X - array [i - 1].X' array [i].Y - array [i - 1].Y);  	tangent = tangent / tangent.Magnitude ();  	PointD normalVector = PointD.Orthogonal (tangent);  	PointD pointOnLine = new PointD ((array [i].X + array [i - 1].X) / 2.0' (array [i].Y + array [i - 1].Y) / 2.0);  	PointD testPt1 = pointOnLine + normalVector * m_Param.PathThickness / 4.0;  	PointD testPt2 = pointOnLine - normalVector * m_Param.PathThickness / 4.0;  	PointD testNormal1 = (testPt1 - pointOnLine);  	testNormal1 = testNormal1 / testNormal1.Magnitude ();  	PointD testNormal2 = (testPt2 - pointOnLine);  	testNormal2 = testNormal2 / testNormal2.Magnitude ();  	PointD scaledVector1 = testNormal1 * (GetScalar () * 7 * m_Param.C / Math.Pow ((m_Param.PathThickness / 2.0) + 10' 0.5));  	PointD scaledVector2 = testNormal2 * (GetScalar () * 7 * m_Param.C / Math.Pow ((m_Param.PathThickness / 2.0) + 10' 0.5));  	drawMethods.DrawArrow (gc' r' testPt1' scaledVector1 * Render.DrawHelper.SPEED_AMPLIFIER);  	drawMethods.DrawArrow (gc' r' testPt2' scaledVector2 * Render.DrawHelper.SPEED_AMPLIFIER);  }  
Magic Number,KinTemplates.Cursor.Tools,MagneticLineAttractionFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\MagneticLineAttractionFilter.cs,DrawArrowForces,The following statement contains a magic number: for (int i = 1; i < array.Length; i += 20) {  	PointD tangent = new PointD (array [i].X - array [i - 1].X' array [i].Y - array [i - 1].Y);  	tangent = tangent / tangent.Magnitude ();  	PointD normalVector = PointD.Orthogonal (tangent);  	PointD pointOnLine = new PointD ((array [i].X + array [i - 1].X) / 2.0' (array [i].Y + array [i - 1].Y) / 2.0);  	PointD testPt1 = pointOnLine + normalVector * m_Param.PathThickness / 4.0;  	PointD testPt2 = pointOnLine - normalVector * m_Param.PathThickness / 4.0;  	PointD testNormal1 = (testPt1 - pointOnLine);  	testNormal1 = testNormal1 / testNormal1.Magnitude ();  	PointD testNormal2 = (testPt2 - pointOnLine);  	testNormal2 = testNormal2 / testNormal2.Magnitude ();  	PointD scaledVector1 = testNormal1 * (GetScalar () * 7 * m_Param.C / Math.Pow ((m_Param.PathThickness / 2.0) + 10' 0.5));  	PointD scaledVector2 = testNormal2 * (GetScalar () * 7 * m_Param.C / Math.Pow ((m_Param.PathThickness / 2.0) + 10' 0.5));  	drawMethods.DrawArrow (gc' r' testPt1' scaledVector1 * Render.DrawHelper.SPEED_AMPLIFIER);  	drawMethods.DrawArrow (gc' r' testPt2' scaledVector2 * Render.DrawHelper.SPEED_AMPLIFIER);  }  
Magic Number,KinTemplates.Cursor.Tools,MagneticLineAttractionFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\MagneticLineAttractionFilter.cs,DrawArrowForces,The following statement contains a magic number: for (int i = 1; i < array.Length; i += 20) {  	PointD tangent = new PointD (array [i].X - array [i - 1].X' array [i].Y - array [i - 1].Y);  	tangent = tangent / tangent.Magnitude ();  	PointD normalVector = PointD.Orthogonal (tangent);  	PointD pointOnLine = new PointD ((array [i].X + array [i - 1].X) / 2.0' (array [i].Y + array [i - 1].Y) / 2.0);  	PointD testPt1 = pointOnLine + normalVector * m_Param.PathThickness / 4.0;  	PointD testPt2 = pointOnLine - normalVector * m_Param.PathThickness / 4.0;  	PointD testNormal1 = (testPt1 - pointOnLine);  	testNormal1 = testNormal1 / testNormal1.Magnitude ();  	PointD testNormal2 = (testPt2 - pointOnLine);  	testNormal2 = testNormal2 / testNormal2.Magnitude ();  	PointD scaledVector1 = testNormal1 * (GetScalar () * 7 * m_Param.C / Math.Pow ((m_Param.PathThickness / 2.0) + 10' 0.5));  	PointD scaledVector2 = testNormal2 * (GetScalar () * 7 * m_Param.C / Math.Pow ((m_Param.PathThickness / 2.0) + 10' 0.5));  	drawMethods.DrawArrow (gc' r' testPt1' scaledVector1 * Render.DrawHelper.SPEED_AMPLIFIER);  	drawMethods.DrawArrow (gc' r' testPt2' scaledVector2 * Render.DrawHelper.SPEED_AMPLIFIER);  }  
Magic Number,KinTemplates.Cursor.Tools,MagneticLineAttractionFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\MagneticLineAttractionFilter.cs,DrawArrowForces,The following statement contains a magic number: for (int i = 1; i < array.Length; i += 20) {  	PointD tangent = new PointD (array [i].X - array [i - 1].X' array [i].Y - array [i - 1].Y);  	tangent = tangent / tangent.Magnitude ();  	PointD normalVector = PointD.Orthogonal (tangent);  	PointD pointOnLine = new PointD ((array [i].X + array [i - 1].X) / 2.0' (array [i].Y + array [i - 1].Y) / 2.0);  	PointD testPt1 = pointOnLine + normalVector * m_Param.PathThickness / 4.0;  	PointD testPt2 = pointOnLine - normalVector * m_Param.PathThickness / 4.0;  	PointD testNormal1 = (testPt1 - pointOnLine);  	testNormal1 = testNormal1 / testNormal1.Magnitude ();  	PointD testNormal2 = (testPt2 - pointOnLine);  	testNormal2 = testNormal2 / testNormal2.Magnitude ();  	PointD scaledVector1 = testNormal1 * (GetScalar () * 7 * m_Param.C / Math.Pow ((m_Param.PathThickness / 2.0) + 10' 0.5));  	PointD scaledVector2 = testNormal2 * (GetScalar () * 7 * m_Param.C / Math.Pow ((m_Param.PathThickness / 2.0) + 10' 0.5));  	drawMethods.DrawArrow (gc' r' testPt1' scaledVector1 * Render.DrawHelper.SPEED_AMPLIFIER);  	drawMethods.DrawArrow (gc' r' testPt2' scaledVector2 * Render.DrawHelper.SPEED_AMPLIFIER);  }  
Magic Number,KinTemplates.Cursor.Tools,MagneticLineAttractionFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\MagneticLineAttractionFilter.cs,DrawArrowForces,The following statement contains a magic number: for (int i = 1; i < array.Length; i += 20) {  	PointD tangent = new PointD (array [i].X - array [i - 1].X' array [i].Y - array [i - 1].Y);  	tangent = tangent / tangent.Magnitude ();  	PointD normalVector = PointD.Orthogonal (tangent);  	PointD pointOnLine = new PointD ((array [i].X + array [i - 1].X) / 2.0' (array [i].Y + array [i - 1].Y) / 2.0);  	PointD testPt1 = pointOnLine + normalVector * m_Param.PathThickness / 4.0;  	PointD testPt2 = pointOnLine - normalVector * m_Param.PathThickness / 4.0;  	PointD testNormal1 = (testPt1 - pointOnLine);  	testNormal1 = testNormal1 / testNormal1.Magnitude ();  	PointD testNormal2 = (testPt2 - pointOnLine);  	testNormal2 = testNormal2 / testNormal2.Magnitude ();  	PointD scaledVector1 = testNormal1 * (GetScalar () * 7 * m_Param.C / Math.Pow ((m_Param.PathThickness / 2.0) + 10' 0.5));  	PointD scaledVector2 = testNormal2 * (GetScalar () * 7 * m_Param.C / Math.Pow ((m_Param.PathThickness / 2.0) + 10' 0.5));  	drawMethods.DrawArrow (gc' r' testPt1' scaledVector1 * Render.DrawHelper.SPEED_AMPLIFIER);  	drawMethods.DrawArrow (gc' r' testPt2' scaledVector2 * Render.DrawHelper.SPEED_AMPLIFIER);  }  
Magic Number,KinTemplates.Cursor.Tools,MagneticLineAttractionFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\MagneticLineAttractionFilter.cs,DrawArrowForces,The following statement contains a magic number: for (int i = 1; i < array.Length; i += 20) {  	PointD tangent = new PointD (array [i].X - array [i - 1].X' array [i].Y - array [i - 1].Y);  	tangent = tangent / tangent.Magnitude ();  	PointD normalVector = PointD.Orthogonal (tangent);  	PointD pointOnLine = new PointD ((array [i].X + array [i - 1].X) / 2.0' (array [i].Y + array [i - 1].Y) / 2.0);  	PointD testPt1 = pointOnLine + normalVector * m_Param.PathThickness / 4.0;  	PointD testPt2 = pointOnLine - normalVector * m_Param.PathThickness / 4.0;  	PointD testNormal1 = (testPt1 - pointOnLine);  	testNormal1 = testNormal1 / testNormal1.Magnitude ();  	PointD testNormal2 = (testPt2 - pointOnLine);  	testNormal2 = testNormal2 / testNormal2.Magnitude ();  	PointD scaledVector1 = testNormal1 * (GetScalar () * 7 * m_Param.C / Math.Pow ((m_Param.PathThickness / 2.0) + 10' 0.5));  	PointD scaledVector2 = testNormal2 * (GetScalar () * 7 * m_Param.C / Math.Pow ((m_Param.PathThickness / 2.0) + 10' 0.5));  	drawMethods.DrawArrow (gc' r' testPt1' scaledVector1 * Render.DrawHelper.SPEED_AMPLIFIER);  	drawMethods.DrawArrow (gc' r' testPt2' scaledVector2 * Render.DrawHelper.SPEED_AMPLIFIER);  }  
Magic Number,KinTemplates.Cursor.Tools,MagneticLineAttractionFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\MagneticLineAttractionFilter.cs,DrawArrowForces,The following statement contains a magic number: for (int i = 1; i < array.Length; i += 20) {  	PointD tangent = new PointD (array [i].X - array [i - 1].X' array [i].Y - array [i - 1].Y);  	tangent = tangent / tangent.Magnitude ();  	PointD normalVector = PointD.Orthogonal (tangent);  	PointD pointOnLine = new PointD ((array [i].X + array [i - 1].X) / 2.0' (array [i].Y + array [i - 1].Y) / 2.0);  	PointD testPt1 = pointOnLine + normalVector * m_Param.PathThickness / 4.0;  	PointD testPt2 = pointOnLine - normalVector * m_Param.PathThickness / 4.0;  	PointD testNormal1 = (testPt1 - pointOnLine);  	testNormal1 = testNormal1 / testNormal1.Magnitude ();  	PointD testNormal2 = (testPt2 - pointOnLine);  	testNormal2 = testNormal2 / testNormal2.Magnitude ();  	PointD scaledVector1 = testNormal1 * (GetScalar () * 7 * m_Param.C / Math.Pow ((m_Param.PathThickness / 2.0) + 10' 0.5));  	PointD scaledVector2 = testNormal2 * (GetScalar () * 7 * m_Param.C / Math.Pow ((m_Param.PathThickness / 2.0) + 10' 0.5));  	drawMethods.DrawArrow (gc' r' testPt1' scaledVector1 * Render.DrawHelper.SPEED_AMPLIFIER);  	drawMethods.DrawArrow (gc' r' testPt2' scaledVector2 * Render.DrawHelper.SPEED_AMPLIFIER);  }  
Magic Number,KinTemplates.Cursor.Tools,MagneticLineAttractionFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\MagneticLineAttractionFilter.cs,DrawArrowForces,The following statement contains a magic number: for (int i = 1; i < array.Length; i += 20) {  	PointD tangent = new PointD (array [i].X - array [i - 1].X' array [i].Y - array [i - 1].Y);  	tangent = tangent / tangent.Magnitude ();  	PointD normalVector = PointD.Orthogonal (tangent);  	PointD pointOnLine = new PointD ((array [i].X + array [i - 1].X) / 2.0' (array [i].Y + array [i - 1].Y) / 2.0);  	PointD testPt1 = pointOnLine + normalVector * m_Param.PathThickness / 4.0;  	PointD testPt2 = pointOnLine - normalVector * m_Param.PathThickness / 4.0;  	PointD testNormal1 = (testPt1 - pointOnLine);  	testNormal1 = testNormal1 / testNormal1.Magnitude ();  	PointD testNormal2 = (testPt2 - pointOnLine);  	testNormal2 = testNormal2 / testNormal2.Magnitude ();  	PointD scaledVector1 = testNormal1 * (GetScalar () * 7 * m_Param.C / Math.Pow ((m_Param.PathThickness / 2.0) + 10' 0.5));  	PointD scaledVector2 = testNormal2 * (GetScalar () * 7 * m_Param.C / Math.Pow ((m_Param.PathThickness / 2.0) + 10' 0.5));  	drawMethods.DrawArrow (gc' r' testPt1' scaledVector1 * Render.DrawHelper.SPEED_AMPLIFIER);  	drawMethods.DrawArrow (gc' r' testPt2' scaledVector2 * Render.DrawHelper.SPEED_AMPLIFIER);  }  
Magic Number,KinTemplates.Cursor.Tools,MagneticLineAttractionFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\MagneticLineAttractionFilter.cs,DrawArrowForces,The following statement contains a magic number: for (int i = 1; i < array.Length; i += 20) {  	PointD tangent = new PointD (array [i].X - array [i - 1].X' array [i].Y - array [i - 1].Y);  	tangent = tangent / tangent.Magnitude ();  	PointD normalVector = PointD.Orthogonal (tangent);  	PointD pointOnLine = new PointD ((array [i].X + array [i - 1].X) / 2.0' (array [i].Y + array [i - 1].Y) / 2.0);  	PointD testPt1 = pointOnLine + normalVector * m_Param.PathThickness / 4.0;  	PointD testPt2 = pointOnLine - normalVector * m_Param.PathThickness / 4.0;  	PointD testNormal1 = (testPt1 - pointOnLine);  	testNormal1 = testNormal1 / testNormal1.Magnitude ();  	PointD testNormal2 = (testPt2 - pointOnLine);  	testNormal2 = testNormal2 / testNormal2.Magnitude ();  	PointD scaledVector1 = testNormal1 * (GetScalar () * 7 * m_Param.C / Math.Pow ((m_Param.PathThickness / 2.0) + 10' 0.5));  	PointD scaledVector2 = testNormal2 * (GetScalar () * 7 * m_Param.C / Math.Pow ((m_Param.PathThickness / 2.0) + 10' 0.5));  	drawMethods.DrawArrow (gc' r' testPt1' scaledVector1 * Render.DrawHelper.SPEED_AMPLIFIER);  	drawMethods.DrawArrow (gc' r' testPt2' scaledVector2 * Render.DrawHelper.SPEED_AMPLIFIER);  }  
Magic Number,KinTemplates.Cursor.Tools,MagneticLineAttractionFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\MagneticLineAttractionFilter.cs,DrawArrowForces,The following statement contains a magic number: for (int i = 1; i < array.Length; i += 20) {  	PointD tangent = new PointD (array [i].X - array [i - 1].X' array [i].Y - array [i - 1].Y);  	tangent = tangent / tangent.Magnitude ();  	PointD normalVector = PointD.Orthogonal (tangent);  	PointD pointOnLine = new PointD ((array [i].X + array [i - 1].X) / 2.0' (array [i].Y + array [i - 1].Y) / 2.0);  	PointD testPt1 = pointOnLine + normalVector * m_Param.PathThickness / 4.0;  	PointD testPt2 = pointOnLine - normalVector * m_Param.PathThickness / 4.0;  	PointD testNormal1 = (testPt1 - pointOnLine);  	testNormal1 = testNormal1 / testNormal1.Magnitude ();  	PointD testNormal2 = (testPt2 - pointOnLine);  	testNormal2 = testNormal2 / testNormal2.Magnitude ();  	PointD scaledVector1 = testNormal1 * (GetScalar () * 7 * m_Param.C / Math.Pow ((m_Param.PathThickness / 2.0) + 10' 0.5));  	PointD scaledVector2 = testNormal2 * (GetScalar () * 7 * m_Param.C / Math.Pow ((m_Param.PathThickness / 2.0) + 10' 0.5));  	drawMethods.DrawArrow (gc' r' testPt1' scaledVector1 * Render.DrawHelper.SPEED_AMPLIFIER);  	drawMethods.DrawArrow (gc' r' testPt2' scaledVector2 * Render.DrawHelper.SPEED_AMPLIFIER);  }  
Magic Number,KinTemplates.Cursor.Tools,MagneticLineAttractionFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\MagneticLineAttractionFilter.cs,DrawArrowForces,The following statement contains a magic number: i += 20
Magic Number,KinTemplates.Cursor.Tools,MagneticPointAttractionFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\MagneticPointAttractionFilter.cs,GetInnerVelocity,The following statement contains a magic number: return new RadialFactors (1' 1' dir * m_Param.C * 8' 0);  
Magic Number,KinTemplates.Cursor.Tools,MagneticPointAttractionFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\MagneticPointAttractionFilter.cs,GetParamHandlePos,The following statement contains a magic number: return PointD.FromSize (m_Param.GetBoundingRect ().Size) / 2.0 - new PointD (0' m_Param.PtRadius / 2.0);  
Magic Number,KinTemplates.Cursor.Tools,MagneticPointAttractionFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\MagneticPointAttractionFilter.cs,GetParamHandlePos,The following statement contains a magic number: return PointD.FromSize (m_Param.GetBoundingRect ().Size) / 2.0 - new PointD (0' m_Param.PtRadius / 2.0);  
Magic Number,KinTemplates.Cursor.Tools,OrbitFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\OrbitFilter.cs,GetParamHandlePos,The following statement contains a magic number: return PointD.FromSize (m_Param.GetBoundingRect ().Size) / 2.0 - new PointD (0' m_Param.PtRadius / 2.0);  
Magic Number,KinTemplates.Cursor.Tools,OrbitFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\OrbitFilter.cs,GetParamHandlePos,The following statement contains a magic number: return PointD.FromSize (m_Param.GetBoundingRect ().Size) / 2.0 - new PointD (0' m_Param.PtRadius / 2.0);  
Magic Number,KinTemplates.Cursor.Tools,OrbitFilter2,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\OrbitFilter2.cs,GetInnerVelocity,The following statement contains a magic number: return new RadialFactors (1' 1' 0' signedDirection * m_Param.C / 4);  
Magic Number,KinTemplates.Cursor.Tools,OrbitFilter2,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\OrbitFilter2.cs,GetParamHandlePos,The following statement contains a magic number: return PointD.FromSize (m_Param.GetBoundingRect ().Size) / 2.0 - new PointD (0' m_Param.PtRadius / 2.0);  
Magic Number,KinTemplates.Cursor.Tools,OrbitFilter2,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\OrbitFilter2.cs,GetParamHandlePos,The following statement contains a magic number: return PointD.FromSize (m_Param.GetBoundingRect ().Size) / 2.0 - new PointD (0' m_Param.PtRadius / 2.0);  
Magic Number,KinTemplates.Cursor.Tools,OrbitFilter3,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\OrbitFilter3.cs,GetInnerVelocity,The following statement contains a magic number: return new RadialFactors (0' 0' 0' signedDirection * m_Param.C / 4);  
Magic Number,KinTemplates.Cursor.Tools,OrbitFilter3,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\OrbitFilter3.cs,GetParamHandlePos,The following statement contains a magic number: return PointD.FromSize (m_Param.GetBoundingRect ().Size) / 2.0 - new PointD (0' m_Param.PtRadius / 2.0);  
Magic Number,KinTemplates.Cursor.Tools,OrbitFilter3,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\OrbitFilter3.cs,GetParamHandlePos,The following statement contains a magic number: return PointD.FromSize (m_Param.GetBoundingRect ().Size) / 2.0 - new PointD (0' m_Param.PtRadius / 2.0);  
Magic Number,KinTemplates.Cursor.Tools,PointToolFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\PointToolFilter.cs,GetVelocity,The following statement contains a magic number: mp.VirtualPoint = RadialPointD.ToPolar ((PointD)pointsToCheck [2]' PointD.Empty);  
Magic Number,KinTemplates.Cursor.Tools,PointToolFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\PointToolFilter.cs,GetVelocity,The following statement contains a magic number: if (signOrig != signNew) {  	if (signOrig == -1) {  		if (mp.Delta.Theta < -3.141592)  			mp.Delta.Theta += 2 * 3.141592;  	}  	else if (signOrig == 1) {  		if (mp.Delta.Theta > 3.141592)  			mp.Delta.Theta -= 2 * 3.141592;  	}  }  
Magic Number,KinTemplates.Cursor.Tools,PointToolFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\PointToolFilter.cs,GetVelocity,The following statement contains a magic number: if (signOrig != signNew) {  	if (signOrig == -1) {  		if (mp.Delta.Theta < -3.141592)  			mp.Delta.Theta += 2 * 3.141592;  	}  	else if (signOrig == 1) {  		if (mp.Delta.Theta > 3.141592)  			mp.Delta.Theta -= 2 * 3.141592;  	}  }  
Magic Number,KinTemplates.Cursor.Tools,PointToolFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\PointToolFilter.cs,GetVelocity,The following statement contains a magic number: if (signOrig != signNew) {  	if (signOrig == -1) {  		if (mp.Delta.Theta < -3.141592)  			mp.Delta.Theta += 2 * 3.141592;  	}  	else if (signOrig == 1) {  		if (mp.Delta.Theta > 3.141592)  			mp.Delta.Theta -= 2 * 3.141592;  	}  }  
Magic Number,KinTemplates.Cursor.Tools,PointToolFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\PointToolFilter.cs,GetVelocity,The following statement contains a magic number: if (signOrig != signNew) {  	if (signOrig == -1) {  		if (mp.Delta.Theta < -3.141592)  			mp.Delta.Theta += 2 * 3.141592;  	}  	else if (signOrig == 1) {  		if (mp.Delta.Theta > 3.141592)  			mp.Delta.Theta -= 2 * 3.141592;  	}  }  
Magic Number,KinTemplates.Cursor.Tools,PointToolFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\PointToolFilter.cs,GetVelocity,The following statement contains a magic number: if (signOrig != signNew) {  	if (signOrig == -1) {  		if (mp.Delta.Theta < -3.141592)  			mp.Delta.Theta += 2 * 3.141592;  	}  	else if (signOrig == 1) {  		if (mp.Delta.Theta > 3.141592)  			mp.Delta.Theta -= 2 * 3.141592;  	}  }  
Magic Number,KinTemplates.Cursor.Tools,PointToolFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\PointToolFilter.cs,GetVelocity,The following statement contains a magic number: if (signOrig != signNew) {  	if (signOrig == -1) {  		if (mp.Delta.Theta < -3.141592)  			mp.Delta.Theta += 2 * 3.141592;  	}  	else if (signOrig == 1) {  		if (mp.Delta.Theta > 3.141592)  			mp.Delta.Theta -= 2 * 3.141592;  	}  }  
Magic Number,KinTemplates.Cursor.Tools,PointToolFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\PointToolFilter.cs,GetVelocity,The following statement contains a magic number: if (signOrig == -1) {  	if (mp.Delta.Theta < -3.141592)  		mp.Delta.Theta += 2 * 3.141592;  }  else if (signOrig == 1) {  	if (mp.Delta.Theta > 3.141592)  		mp.Delta.Theta -= 2 * 3.141592;  }  
Magic Number,KinTemplates.Cursor.Tools,PointToolFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\PointToolFilter.cs,GetVelocity,The following statement contains a magic number: if (signOrig == -1) {  	if (mp.Delta.Theta < -3.141592)  		mp.Delta.Theta += 2 * 3.141592;  }  else if (signOrig == 1) {  	if (mp.Delta.Theta > 3.141592)  		mp.Delta.Theta -= 2 * 3.141592;  }  
Magic Number,KinTemplates.Cursor.Tools,PointToolFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\PointToolFilter.cs,GetVelocity,The following statement contains a magic number: if (signOrig == -1) {  	if (mp.Delta.Theta < -3.141592)  		mp.Delta.Theta += 2 * 3.141592;  }  else if (signOrig == 1) {  	if (mp.Delta.Theta > 3.141592)  		mp.Delta.Theta -= 2 * 3.141592;  }  
Magic Number,KinTemplates.Cursor.Tools,PointToolFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\PointToolFilter.cs,GetVelocity,The following statement contains a magic number: if (signOrig == -1) {  	if (mp.Delta.Theta < -3.141592)  		mp.Delta.Theta += 2 * 3.141592;  }  else if (signOrig == 1) {  	if (mp.Delta.Theta > 3.141592)  		mp.Delta.Theta -= 2 * 3.141592;  }  
Magic Number,KinTemplates.Cursor.Tools,PointToolFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\PointToolFilter.cs,GetVelocity,The following statement contains a magic number: if (signOrig == -1) {  	if (mp.Delta.Theta < -3.141592)  		mp.Delta.Theta += 2 * 3.141592;  }  else if (signOrig == 1) {  	if (mp.Delta.Theta > 3.141592)  		mp.Delta.Theta -= 2 * 3.141592;  }  
Magic Number,KinTemplates.Cursor.Tools,PointToolFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\PointToolFilter.cs,GetVelocity,The following statement contains a magic number: if (signOrig == -1) {  	if (mp.Delta.Theta < -3.141592)  		mp.Delta.Theta += 2 * 3.141592;  }  else if (signOrig == 1) {  	if (mp.Delta.Theta > 3.141592)  		mp.Delta.Theta -= 2 * 3.141592;  }  
Magic Number,KinTemplates.Cursor.Tools,PointToolFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\PointToolFilter.cs,GetVelocity,The following statement contains a magic number: if (mp.Delta.Theta < -3.141592)  	mp.Delta.Theta += 2 * 3.141592;  
Magic Number,KinTemplates.Cursor.Tools,PointToolFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\PointToolFilter.cs,GetVelocity,The following statement contains a magic number: if (mp.Delta.Theta < -3.141592)  	mp.Delta.Theta += 2 * 3.141592;  
Magic Number,KinTemplates.Cursor.Tools,PointToolFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\PointToolFilter.cs,GetVelocity,The following statement contains a magic number: if (mp.Delta.Theta < -3.141592)  	mp.Delta.Theta += 2 * 3.141592;  
Magic Number,KinTemplates.Cursor.Tools,PointToolFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\PointToolFilter.cs,GetVelocity,The following statement contains a magic number: mp.Delta.Theta += 2 * 3.141592;  
Magic Number,KinTemplates.Cursor.Tools,PointToolFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\PointToolFilter.cs,GetVelocity,The following statement contains a magic number: mp.Delta.Theta += 2 * 3.141592;  
Magic Number,KinTemplates.Cursor.Tools,PointToolFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\PointToolFilter.cs,GetVelocity,The following statement contains a magic number: if (signOrig == 1) {  	if (mp.Delta.Theta > 3.141592)  		mp.Delta.Theta -= 2 * 3.141592;  }  
Magic Number,KinTemplates.Cursor.Tools,PointToolFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\PointToolFilter.cs,GetVelocity,The following statement contains a magic number: if (signOrig == 1) {  	if (mp.Delta.Theta > 3.141592)  		mp.Delta.Theta -= 2 * 3.141592;  }  
Magic Number,KinTemplates.Cursor.Tools,PointToolFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\PointToolFilter.cs,GetVelocity,The following statement contains a magic number: if (signOrig == 1) {  	if (mp.Delta.Theta > 3.141592)  		mp.Delta.Theta -= 2 * 3.141592;  }  
Magic Number,KinTemplates.Cursor.Tools,PointToolFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\PointToolFilter.cs,GetVelocity,The following statement contains a magic number: if (mp.Delta.Theta > 3.141592)  	mp.Delta.Theta -= 2 * 3.141592;  
Magic Number,KinTemplates.Cursor.Tools,PointToolFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\PointToolFilter.cs,GetVelocity,The following statement contains a magic number: if (mp.Delta.Theta > 3.141592)  	mp.Delta.Theta -= 2 * 3.141592;  
Magic Number,KinTemplates.Cursor.Tools,PointToolFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\PointToolFilter.cs,GetVelocity,The following statement contains a magic number: if (mp.Delta.Theta > 3.141592)  	mp.Delta.Theta -= 2 * 3.141592;  
Magic Number,KinTemplates.Cursor.Tools,PointToolFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\PointToolFilter.cs,GetVelocity,The following statement contains a magic number: mp.Delta.Theta -= 2 * 3.141592;  
Magic Number,KinTemplates.Cursor.Tools,PointToolFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\PointToolFilter.cs,GetVelocity,The following statement contains a magic number: mp.Delta.Theta -= 2 * 3.141592;  
Magic Number,KinTemplates.Cursor.Tools,PointToolFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\PointToolFilter.cs,GetVelocity,The following statement contains a magic number: if (this is OrbitFilter3) {  	if (mp.VirtualPoint.Theta < 0)// top half  	 {  		if (m.GetVelocity ().Y > 0)  			// moving down  			return (PointD)outputPoints [0] / m.GetTimeInterval () - new PointD (m.GetVelocity ().X' 0);  		else  			// moving up  			return (PointD)outputPoints [0] / m.GetTimeInterval () - new PointD (m.GetVelocity ().X' 0);  	}  	else// bottom half  	 {  		if (m.GetVelocity ().Y > 0)  			// moving down  			return (PointD)outputPoints [0] / m.GetTimeInterval () - new PointD (m.GetVelocity ().X' 2 * m.GetVelocity ().Y);  		else  			// moving up  			return (PointD)outputPoints [0] / m.GetTimeInterval () - new PointD (m.GetVelocity ().X' 2 * m.GetVelocity ().Y);  	}  }  else {  	return (PointD)outputPoints [0] / m.GetTimeInterval () - m.GetVelocity ();  }  
Magic Number,KinTemplates.Cursor.Tools,PointToolFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\PointToolFilter.cs,GetVelocity,The following statement contains a magic number: if (this is OrbitFilter3) {  	if (mp.VirtualPoint.Theta < 0)// top half  	 {  		if (m.GetVelocity ().Y > 0)  			// moving down  			return (PointD)outputPoints [0] / m.GetTimeInterval () - new PointD (m.GetVelocity ().X' 0);  		else  			// moving up  			return (PointD)outputPoints [0] / m.GetTimeInterval () - new PointD (m.GetVelocity ().X' 0);  	}  	else// bottom half  	 {  		if (m.GetVelocity ().Y > 0)  			// moving down  			return (PointD)outputPoints [0] / m.GetTimeInterval () - new PointD (m.GetVelocity ().X' 2 * m.GetVelocity ().Y);  		else  			// moving up  			return (PointD)outputPoints [0] / m.GetTimeInterval () - new PointD (m.GetVelocity ().X' 2 * m.GetVelocity ().Y);  	}  }  else {  	return (PointD)outputPoints [0] / m.GetTimeInterval () - m.GetVelocity ();  }  
Magic Number,KinTemplates.Cursor.Tools,PointToolFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\PointToolFilter.cs,GetVelocity,The following statement contains a magic number: if (mp.VirtualPoint.Theta < 0)// top half   {  	if (m.GetVelocity ().Y > 0)  		// moving down  		return (PointD)outputPoints [0] / m.GetTimeInterval () - new PointD (m.GetVelocity ().X' 0);  	else  		// moving up  		return (PointD)outputPoints [0] / m.GetTimeInterval () - new PointD (m.GetVelocity ().X' 0);  }  else// bottom half   {  	if (m.GetVelocity ().Y > 0)  		// moving down  		return (PointD)outputPoints [0] / m.GetTimeInterval () - new PointD (m.GetVelocity ().X' 2 * m.GetVelocity ().Y);  	else  		// moving up  		return (PointD)outputPoints [0] / m.GetTimeInterval () - new PointD (m.GetVelocity ().X' 2 * m.GetVelocity ().Y);  }  
Magic Number,KinTemplates.Cursor.Tools,PointToolFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\PointToolFilter.cs,GetVelocity,The following statement contains a magic number: if (mp.VirtualPoint.Theta < 0)// top half   {  	if (m.GetVelocity ().Y > 0)  		// moving down  		return (PointD)outputPoints [0] / m.GetTimeInterval () - new PointD (m.GetVelocity ().X' 0);  	else  		// moving up  		return (PointD)outputPoints [0] / m.GetTimeInterval () - new PointD (m.GetVelocity ().X' 0);  }  else// bottom half   {  	if (m.GetVelocity ().Y > 0)  		// moving down  		return (PointD)outputPoints [0] / m.GetTimeInterval () - new PointD (m.GetVelocity ().X' 2 * m.GetVelocity ().Y);  	else  		// moving up  		return (PointD)outputPoints [0] / m.GetTimeInterval () - new PointD (m.GetVelocity ().X' 2 * m.GetVelocity ().Y);  }  
Magic Number,KinTemplates.Cursor.Tools,PointToolFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\PointToolFilter.cs,GetVelocity,The following statement contains a magic number: if (m.GetVelocity ().Y > 0)  	// moving down  	return (PointD)outputPoints [0] / m.GetTimeInterval () - new PointD (m.GetVelocity ().X' 2 * m.GetVelocity ().Y);  else  	// moving up  	return (PointD)outputPoints [0] / m.GetTimeInterval () - new PointD (m.GetVelocity ().X' 2 * m.GetVelocity ().Y);  
Magic Number,KinTemplates.Cursor.Tools,PointToolFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\PointToolFilter.cs,GetVelocity,The following statement contains a magic number: if (m.GetVelocity ().Y > 0)  	// moving down  	return (PointD)outputPoints [0] / m.GetTimeInterval () - new PointD (m.GetVelocity ().X' 2 * m.GetVelocity ().Y);  else  	// moving up  	return (PointD)outputPoints [0] / m.GetTimeInterval () - new PointD (m.GetVelocity ().X' 2 * m.GetVelocity ().Y);  
Magic Number,KinTemplates.Cursor.Tools,PointToolFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\PointToolFilter.cs,GetVelocity,The following statement contains a magic number: return (PointD)outputPoints [0] / m.GetTimeInterval () - new PointD (m.GetVelocity ().X' 2 * m.GetVelocity ().Y);  
Magic Number,KinTemplates.Cursor.Tools,PointToolFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\PointToolFilter.cs,GetVelocity,The following statement contains a magic number: return (PointD)outputPoints [0] / m.GetTimeInterval () - new PointD (m.GetVelocity ().X' 2 * m.GetVelocity ().Y);  
Magic Number,KinTemplates.Cursor.Tools,PointToolFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\PointToolFilter.cs,DrawOutline,The following statement contains a magic number: if (!m_Param.Pt.IsEmpty) {  	gc.DrawEllipse (r.RegionOutline' new Rectangle ((int)m_Param.Pt.X - 2' (int)m_Param.Pt.Y - 2' 4' 4));  	if (m_Param.PtRadius > 0) {  		gc.DrawPath (r.RegionOutline' m_Param.Path.InternalPath);  	}  }  
Magic Number,KinTemplates.Cursor.Tools,PointToolFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\PointToolFilter.cs,DrawOutline,The following statement contains a magic number: if (!m_Param.Pt.IsEmpty) {  	gc.DrawEllipse (r.RegionOutline' new Rectangle ((int)m_Param.Pt.X - 2' (int)m_Param.Pt.Y - 2' 4' 4));  	if (m_Param.PtRadius > 0) {  		gc.DrawPath (r.RegionOutline' m_Param.Path.InternalPath);  	}  }  
Magic Number,KinTemplates.Cursor.Tools,PointToolFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\PointToolFilter.cs,DrawOutline,The following statement contains a magic number: if (!m_Param.Pt.IsEmpty) {  	gc.DrawEllipse (r.RegionOutline' new Rectangle ((int)m_Param.Pt.X - 2' (int)m_Param.Pt.Y - 2' 4' 4));  	if (m_Param.PtRadius > 0) {  		gc.DrawPath (r.RegionOutline' m_Param.Path.InternalPath);  	}  }  
Magic Number,KinTemplates.Cursor.Tools,PointToolFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\PointToolFilter.cs,DrawOutline,The following statement contains a magic number: if (!m_Param.Pt.IsEmpty) {  	gc.DrawEllipse (r.RegionOutline' new Rectangle ((int)m_Param.Pt.X - 2' (int)m_Param.Pt.Y - 2' 4' 4));  	if (m_Param.PtRadius > 0) {  		gc.DrawPath (r.RegionOutline' m_Param.Path.InternalPath);  	}  }  
Magic Number,KinTemplates.Cursor.Tools,PointToolFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\PointToolFilter.cs,DrawOutline,The following statement contains a magic number: gc.DrawEllipse (r.RegionOutline' new Rectangle ((int)m_Param.Pt.X - 2' (int)m_Param.Pt.Y - 2' 4' 4));  
Magic Number,KinTemplates.Cursor.Tools,PointToolFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\PointToolFilter.cs,DrawOutline,The following statement contains a magic number: gc.DrawEllipse (r.RegionOutline' new Rectangle ((int)m_Param.Pt.X - 2' (int)m_Param.Pt.Y - 2' 4' 4));  
Magic Number,KinTemplates.Cursor.Tools,PointToolFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\PointToolFilter.cs,DrawOutline,The following statement contains a magic number: gc.DrawEllipse (r.RegionOutline' new Rectangle ((int)m_Param.Pt.X - 2' (int)m_Param.Pt.Y - 2' 4' 4));  
Magic Number,KinTemplates.Cursor.Tools,PointToolFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\PointToolFilter.cs,DrawOutline,The following statement contains a magic number: gc.DrawEllipse (r.RegionOutline' new Rectangle ((int)m_Param.Pt.X - 2' (int)m_Param.Pt.Y - 2' 4' 4));  
Magic Number,KinTemplates.Cursor.Tools,PointToolFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\PointToolFilter.cs,Draw,The following statement contains a magic number: if (!m_Param.Pt.IsEmpty) {  	if (Math.Min (m_Param.PtSize.X' m_Param.PtSize.Y) > Render.DrawHelper.MIN_SPEED_SENSITIVITY) {  		//m_Param.Path = new Tools.Model.VectorPath();  		//m_Param.Path.AddEllipse(m_Param.GetBoundingRect());  		drawMethods.DrawNegativeSpace (gc' m_Param.Path.InternalPath' r);  		drawMethods.DrawPositiveSpace (gc' m_Param.Path.InternalPath' r);  		// crosshair  		gc.DrawLine (r.RegionOutline' (Point)(m_Param.Pt + new PointD (-5' 0))' (Point)(m_Param.Pt + new PointD (5' 0)));  		gc.DrawLine (r.RegionOutline' (Point)(m_Param.Pt + new PointD (0' -5))' (Point)(m_Param.Pt + new PointD (0' 5)));  		// transform coordinate system  		GraphicsState origGC = gc.Save ();  		gc.Clip = new Region (m_Param.Path.InternalPath);  		gc.TranslateTransform ((float)m_Param.Pt.X' (float)m_Param.Pt.Y);  		gc.RotateTransform ((float)(m_Param.Rotation));  		if (m_Param.PtSize.X < m_Param.PtSize.Y)  			gc.ScaleTransform (1' (float)(m_Param.PtSize.Y / m_Param.PtSize.X));  		else  			gc.ScaleTransform ((float)(m_Param.PtSize.X / m_Param.PtSize.Y)' 1);  		// draw outline  		//GraphicsPath path = new GraphicsPath();  		//path.AddEllipse(new RectangleF(-(float)m_Param.PtRadius' -(float)m_Param.PtRadius' (float)m_Param.PtRadius *2 ' (float)m_Param.PtRadius * 2));  		// draw feedback -- suppress for when feedback state is asked for (??)  		if (IsForce () && (editState != Render.RenderHint.Feedback)) {  			DrawInsides (gc' r' drawMethods);  		}  		else if (!IsForce ()) {  			DrawInsides (gc' r' drawMethods);  		}  		// restore old graphics system  		gc.Restore (origGC);  	}  	else {  		// crosshair  		gc.DrawLine (r.RegionOutline' (Point)(new PointD (-5' 0))' (Point)(new PointD (5' 0)));  		gc.DrawLine (r.RegionOutline' (Point)(new PointD (0' -5))' (Point)(new PointD (0' 5)));  	}  }  
Magic Number,KinTemplates.Cursor.Tools,PointToolFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\PointToolFilter.cs,Draw,The following statement contains a magic number: if (!m_Param.Pt.IsEmpty) {  	if (Math.Min (m_Param.PtSize.X' m_Param.PtSize.Y) > Render.DrawHelper.MIN_SPEED_SENSITIVITY) {  		//m_Param.Path = new Tools.Model.VectorPath();  		//m_Param.Path.AddEllipse(m_Param.GetBoundingRect());  		drawMethods.DrawNegativeSpace (gc' m_Param.Path.InternalPath' r);  		drawMethods.DrawPositiveSpace (gc' m_Param.Path.InternalPath' r);  		// crosshair  		gc.DrawLine (r.RegionOutline' (Point)(m_Param.Pt + new PointD (-5' 0))' (Point)(m_Param.Pt + new PointD (5' 0)));  		gc.DrawLine (r.RegionOutline' (Point)(m_Param.Pt + new PointD (0' -5))' (Point)(m_Param.Pt + new PointD (0' 5)));  		// transform coordinate system  		GraphicsState origGC = gc.Save ();  		gc.Clip = new Region (m_Param.Path.InternalPath);  		gc.TranslateTransform ((float)m_Param.Pt.X' (float)m_Param.Pt.Y);  		gc.RotateTransform ((float)(m_Param.Rotation));  		if (m_Param.PtSize.X < m_Param.PtSize.Y)  			gc.ScaleTransform (1' (float)(m_Param.PtSize.Y / m_Param.PtSize.X));  		else  			gc.ScaleTransform ((float)(m_Param.PtSize.X / m_Param.PtSize.Y)' 1);  		// draw outline  		//GraphicsPath path = new GraphicsPath();  		//path.AddEllipse(new RectangleF(-(float)m_Param.PtRadius' -(float)m_Param.PtRadius' (float)m_Param.PtRadius *2 ' (float)m_Param.PtRadius * 2));  		// draw feedback -- suppress for when feedback state is asked for (??)  		if (IsForce () && (editState != Render.RenderHint.Feedback)) {  			DrawInsides (gc' r' drawMethods);  		}  		else if (!IsForce ()) {  			DrawInsides (gc' r' drawMethods);  		}  		// restore old graphics system  		gc.Restore (origGC);  	}  	else {  		// crosshair  		gc.DrawLine (r.RegionOutline' (Point)(new PointD (-5' 0))' (Point)(new PointD (5' 0)));  		gc.DrawLine (r.RegionOutline' (Point)(new PointD (0' -5))' (Point)(new PointD (0' 5)));  	}  }  
Magic Number,KinTemplates.Cursor.Tools,PointToolFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\PointToolFilter.cs,Draw,The following statement contains a magic number: if (!m_Param.Pt.IsEmpty) {  	if (Math.Min (m_Param.PtSize.X' m_Param.PtSize.Y) > Render.DrawHelper.MIN_SPEED_SENSITIVITY) {  		//m_Param.Path = new Tools.Model.VectorPath();  		//m_Param.Path.AddEllipse(m_Param.GetBoundingRect());  		drawMethods.DrawNegativeSpace (gc' m_Param.Path.InternalPath' r);  		drawMethods.DrawPositiveSpace (gc' m_Param.Path.InternalPath' r);  		// crosshair  		gc.DrawLine (r.RegionOutline' (Point)(m_Param.Pt + new PointD (-5' 0))' (Point)(m_Param.Pt + new PointD (5' 0)));  		gc.DrawLine (r.RegionOutline' (Point)(m_Param.Pt + new PointD (0' -5))' (Point)(m_Param.Pt + new PointD (0' 5)));  		// transform coordinate system  		GraphicsState origGC = gc.Save ();  		gc.Clip = new Region (m_Param.Path.InternalPath);  		gc.TranslateTransform ((float)m_Param.Pt.X' (float)m_Param.Pt.Y);  		gc.RotateTransform ((float)(m_Param.Rotation));  		if (m_Param.PtSize.X < m_Param.PtSize.Y)  			gc.ScaleTransform (1' (float)(m_Param.PtSize.Y / m_Param.PtSize.X));  		else  			gc.ScaleTransform ((float)(m_Param.PtSize.X / m_Param.PtSize.Y)' 1);  		// draw outline  		//GraphicsPath path = new GraphicsPath();  		//path.AddEllipse(new RectangleF(-(float)m_Param.PtRadius' -(float)m_Param.PtRadius' (float)m_Param.PtRadius *2 ' (float)m_Param.PtRadius * 2));  		// draw feedback -- suppress for when feedback state is asked for (??)  		if (IsForce () && (editState != Render.RenderHint.Feedback)) {  			DrawInsides (gc' r' drawMethods);  		}  		else if (!IsForce ()) {  			DrawInsides (gc' r' drawMethods);  		}  		// restore old graphics system  		gc.Restore (origGC);  	}  	else {  		// crosshair  		gc.DrawLine (r.RegionOutline' (Point)(new PointD (-5' 0))' (Point)(new PointD (5' 0)));  		gc.DrawLine (r.RegionOutline' (Point)(new PointD (0' -5))' (Point)(new PointD (0' 5)));  	}  }  
Magic Number,KinTemplates.Cursor.Tools,PointToolFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\PointToolFilter.cs,Draw,The following statement contains a magic number: if (!m_Param.Pt.IsEmpty) {  	if (Math.Min (m_Param.PtSize.X' m_Param.PtSize.Y) > Render.DrawHelper.MIN_SPEED_SENSITIVITY) {  		//m_Param.Path = new Tools.Model.VectorPath();  		//m_Param.Path.AddEllipse(m_Param.GetBoundingRect());  		drawMethods.DrawNegativeSpace (gc' m_Param.Path.InternalPath' r);  		drawMethods.DrawPositiveSpace (gc' m_Param.Path.InternalPath' r);  		// crosshair  		gc.DrawLine (r.RegionOutline' (Point)(m_Param.Pt + new PointD (-5' 0))' (Point)(m_Param.Pt + new PointD (5' 0)));  		gc.DrawLine (r.RegionOutline' (Point)(m_Param.Pt + new PointD (0' -5))' (Point)(m_Param.Pt + new PointD (0' 5)));  		// transform coordinate system  		GraphicsState origGC = gc.Save ();  		gc.Clip = new Region (m_Param.Path.InternalPath);  		gc.TranslateTransform ((float)m_Param.Pt.X' (float)m_Param.Pt.Y);  		gc.RotateTransform ((float)(m_Param.Rotation));  		if (m_Param.PtSize.X < m_Param.PtSize.Y)  			gc.ScaleTransform (1' (float)(m_Param.PtSize.Y / m_Param.PtSize.X));  		else  			gc.ScaleTransform ((float)(m_Param.PtSize.X / m_Param.PtSize.Y)' 1);  		// draw outline  		//GraphicsPath path = new GraphicsPath();  		//path.AddEllipse(new RectangleF(-(float)m_Param.PtRadius' -(float)m_Param.PtRadius' (float)m_Param.PtRadius *2 ' (float)m_Param.PtRadius * 2));  		// draw feedback -- suppress for when feedback state is asked for (??)  		if (IsForce () && (editState != Render.RenderHint.Feedback)) {  			DrawInsides (gc' r' drawMethods);  		}  		else if (!IsForce ()) {  			DrawInsides (gc' r' drawMethods);  		}  		// restore old graphics system  		gc.Restore (origGC);  	}  	else {  		// crosshair  		gc.DrawLine (r.RegionOutline' (Point)(new PointD (-5' 0))' (Point)(new PointD (5' 0)));  		gc.DrawLine (r.RegionOutline' (Point)(new PointD (0' -5))' (Point)(new PointD (0' 5)));  	}  }  
Magic Number,KinTemplates.Cursor.Tools,PointToolFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\PointToolFilter.cs,Draw,The following statement contains a magic number: if (!m_Param.Pt.IsEmpty) {  	if (Math.Min (m_Param.PtSize.X' m_Param.PtSize.Y) > Render.DrawHelper.MIN_SPEED_SENSITIVITY) {  		//m_Param.Path = new Tools.Model.VectorPath();  		//m_Param.Path.AddEllipse(m_Param.GetBoundingRect());  		drawMethods.DrawNegativeSpace (gc' m_Param.Path.InternalPath' r);  		drawMethods.DrawPositiveSpace (gc' m_Param.Path.InternalPath' r);  		// crosshair  		gc.DrawLine (r.RegionOutline' (Point)(m_Param.Pt + new PointD (-5' 0))' (Point)(m_Param.Pt + new PointD (5' 0)));  		gc.DrawLine (r.RegionOutline' (Point)(m_Param.Pt + new PointD (0' -5))' (Point)(m_Param.Pt + new PointD (0' 5)));  		// transform coordinate system  		GraphicsState origGC = gc.Save ();  		gc.Clip = new Region (m_Param.Path.InternalPath);  		gc.TranslateTransform ((float)m_Param.Pt.X' (float)m_Param.Pt.Y);  		gc.RotateTransform ((float)(m_Param.Rotation));  		if (m_Param.PtSize.X < m_Param.PtSize.Y)  			gc.ScaleTransform (1' (float)(m_Param.PtSize.Y / m_Param.PtSize.X));  		else  			gc.ScaleTransform ((float)(m_Param.PtSize.X / m_Param.PtSize.Y)' 1);  		// draw outline  		//GraphicsPath path = new GraphicsPath();  		//path.AddEllipse(new RectangleF(-(float)m_Param.PtRadius' -(float)m_Param.PtRadius' (float)m_Param.PtRadius *2 ' (float)m_Param.PtRadius * 2));  		// draw feedback -- suppress for when feedback state is asked for (??)  		if (IsForce () && (editState != Render.RenderHint.Feedback)) {  			DrawInsides (gc' r' drawMethods);  		}  		else if (!IsForce ()) {  			DrawInsides (gc' r' drawMethods);  		}  		// restore old graphics system  		gc.Restore (origGC);  	}  	else {  		// crosshair  		gc.DrawLine (r.RegionOutline' (Point)(new PointD (-5' 0))' (Point)(new PointD (5' 0)));  		gc.DrawLine (r.RegionOutline' (Point)(new PointD (0' -5))' (Point)(new PointD (0' 5)));  	}  }  
Magic Number,KinTemplates.Cursor.Tools,PointToolFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\PointToolFilter.cs,Draw,The following statement contains a magic number: if (!m_Param.Pt.IsEmpty) {  	if (Math.Min (m_Param.PtSize.X' m_Param.PtSize.Y) > Render.DrawHelper.MIN_SPEED_SENSITIVITY) {  		//m_Param.Path = new Tools.Model.VectorPath();  		//m_Param.Path.AddEllipse(m_Param.GetBoundingRect());  		drawMethods.DrawNegativeSpace (gc' m_Param.Path.InternalPath' r);  		drawMethods.DrawPositiveSpace (gc' m_Param.Path.InternalPath' r);  		// crosshair  		gc.DrawLine (r.RegionOutline' (Point)(m_Param.Pt + new PointD (-5' 0))' (Point)(m_Param.Pt + new PointD (5' 0)));  		gc.DrawLine (r.RegionOutline' (Point)(m_Param.Pt + new PointD (0' -5))' (Point)(m_Param.Pt + new PointD (0' 5)));  		// transform coordinate system  		GraphicsState origGC = gc.Save ();  		gc.Clip = new Region (m_Param.Path.InternalPath);  		gc.TranslateTransform ((float)m_Param.Pt.X' (float)m_Param.Pt.Y);  		gc.RotateTransform ((float)(m_Param.Rotation));  		if (m_Param.PtSize.X < m_Param.PtSize.Y)  			gc.ScaleTransform (1' (float)(m_Param.PtSize.Y / m_Param.PtSize.X));  		else  			gc.ScaleTransform ((float)(m_Param.PtSize.X / m_Param.PtSize.Y)' 1);  		// draw outline  		//GraphicsPath path = new GraphicsPath();  		//path.AddEllipse(new RectangleF(-(float)m_Param.PtRadius' -(float)m_Param.PtRadius' (float)m_Param.PtRadius *2 ' (float)m_Param.PtRadius * 2));  		// draw feedback -- suppress for when feedback state is asked for (??)  		if (IsForce () && (editState != Render.RenderHint.Feedback)) {  			DrawInsides (gc' r' drawMethods);  		}  		else if (!IsForce ()) {  			DrawInsides (gc' r' drawMethods);  		}  		// restore old graphics system  		gc.Restore (origGC);  	}  	else {  		// crosshair  		gc.DrawLine (r.RegionOutline' (Point)(new PointD (-5' 0))' (Point)(new PointD (5' 0)));  		gc.DrawLine (r.RegionOutline' (Point)(new PointD (0' -5))' (Point)(new PointD (0' 5)));  	}  }  
Magic Number,KinTemplates.Cursor.Tools,PointToolFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\PointToolFilter.cs,Draw,The following statement contains a magic number: if (!m_Param.Pt.IsEmpty) {  	if (Math.Min (m_Param.PtSize.X' m_Param.PtSize.Y) > Render.DrawHelper.MIN_SPEED_SENSITIVITY) {  		//m_Param.Path = new Tools.Model.VectorPath();  		//m_Param.Path.AddEllipse(m_Param.GetBoundingRect());  		drawMethods.DrawNegativeSpace (gc' m_Param.Path.InternalPath' r);  		drawMethods.DrawPositiveSpace (gc' m_Param.Path.InternalPath' r);  		// crosshair  		gc.DrawLine (r.RegionOutline' (Point)(m_Param.Pt + new PointD (-5' 0))' (Point)(m_Param.Pt + new PointD (5' 0)));  		gc.DrawLine (r.RegionOutline' (Point)(m_Param.Pt + new PointD (0' -5))' (Point)(m_Param.Pt + new PointD (0' 5)));  		// transform coordinate system  		GraphicsState origGC = gc.Save ();  		gc.Clip = new Region (m_Param.Path.InternalPath);  		gc.TranslateTransform ((float)m_Param.Pt.X' (float)m_Param.Pt.Y);  		gc.RotateTransform ((float)(m_Param.Rotation));  		if (m_Param.PtSize.X < m_Param.PtSize.Y)  			gc.ScaleTransform (1' (float)(m_Param.PtSize.Y / m_Param.PtSize.X));  		else  			gc.ScaleTransform ((float)(m_Param.PtSize.X / m_Param.PtSize.Y)' 1);  		// draw outline  		//GraphicsPath path = new GraphicsPath();  		//path.AddEllipse(new RectangleF(-(float)m_Param.PtRadius' -(float)m_Param.PtRadius' (float)m_Param.PtRadius *2 ' (float)m_Param.PtRadius * 2));  		// draw feedback -- suppress for when feedback state is asked for (??)  		if (IsForce () && (editState != Render.RenderHint.Feedback)) {  			DrawInsides (gc' r' drawMethods);  		}  		else if (!IsForce ()) {  			DrawInsides (gc' r' drawMethods);  		}  		// restore old graphics system  		gc.Restore (origGC);  	}  	else {  		// crosshair  		gc.DrawLine (r.RegionOutline' (Point)(new PointD (-5' 0))' (Point)(new PointD (5' 0)));  		gc.DrawLine (r.RegionOutline' (Point)(new PointD (0' -5))' (Point)(new PointD (0' 5)));  	}  }  
Magic Number,KinTemplates.Cursor.Tools,PointToolFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\PointToolFilter.cs,Draw,The following statement contains a magic number: if (!m_Param.Pt.IsEmpty) {  	if (Math.Min (m_Param.PtSize.X' m_Param.PtSize.Y) > Render.DrawHelper.MIN_SPEED_SENSITIVITY) {  		//m_Param.Path = new Tools.Model.VectorPath();  		//m_Param.Path.AddEllipse(m_Param.GetBoundingRect());  		drawMethods.DrawNegativeSpace (gc' m_Param.Path.InternalPath' r);  		drawMethods.DrawPositiveSpace (gc' m_Param.Path.InternalPath' r);  		// crosshair  		gc.DrawLine (r.RegionOutline' (Point)(m_Param.Pt + new PointD (-5' 0))' (Point)(m_Param.Pt + new PointD (5' 0)));  		gc.DrawLine (r.RegionOutline' (Point)(m_Param.Pt + new PointD (0' -5))' (Point)(m_Param.Pt + new PointD (0' 5)));  		// transform coordinate system  		GraphicsState origGC = gc.Save ();  		gc.Clip = new Region (m_Param.Path.InternalPath);  		gc.TranslateTransform ((float)m_Param.Pt.X' (float)m_Param.Pt.Y);  		gc.RotateTransform ((float)(m_Param.Rotation));  		if (m_Param.PtSize.X < m_Param.PtSize.Y)  			gc.ScaleTransform (1' (float)(m_Param.PtSize.Y / m_Param.PtSize.X));  		else  			gc.ScaleTransform ((float)(m_Param.PtSize.X / m_Param.PtSize.Y)' 1);  		// draw outline  		//GraphicsPath path = new GraphicsPath();  		//path.AddEllipse(new RectangleF(-(float)m_Param.PtRadius' -(float)m_Param.PtRadius' (float)m_Param.PtRadius *2 ' (float)m_Param.PtRadius * 2));  		// draw feedback -- suppress for when feedback state is asked for (??)  		if (IsForce () && (editState != Render.RenderHint.Feedback)) {  			DrawInsides (gc' r' drawMethods);  		}  		else if (!IsForce ()) {  			DrawInsides (gc' r' drawMethods);  		}  		// restore old graphics system  		gc.Restore (origGC);  	}  	else {  		// crosshair  		gc.DrawLine (r.RegionOutline' (Point)(new PointD (-5' 0))' (Point)(new PointD (5' 0)));  		gc.DrawLine (r.RegionOutline' (Point)(new PointD (0' -5))' (Point)(new PointD (0' 5)));  	}  }  
Magic Number,KinTemplates.Cursor.Tools,PointToolFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\PointToolFilter.cs,Draw,The following statement contains a magic number: if (Math.Min (m_Param.PtSize.X' m_Param.PtSize.Y) > Render.DrawHelper.MIN_SPEED_SENSITIVITY) {  	//m_Param.Path = new Tools.Model.VectorPath();  	//m_Param.Path.AddEllipse(m_Param.GetBoundingRect());  	drawMethods.DrawNegativeSpace (gc' m_Param.Path.InternalPath' r);  	drawMethods.DrawPositiveSpace (gc' m_Param.Path.InternalPath' r);  	// crosshair  	gc.DrawLine (r.RegionOutline' (Point)(m_Param.Pt + new PointD (-5' 0))' (Point)(m_Param.Pt + new PointD (5' 0)));  	gc.DrawLine (r.RegionOutline' (Point)(m_Param.Pt + new PointD (0' -5))' (Point)(m_Param.Pt + new PointD (0' 5)));  	// transform coordinate system  	GraphicsState origGC = gc.Save ();  	gc.Clip = new Region (m_Param.Path.InternalPath);  	gc.TranslateTransform ((float)m_Param.Pt.X' (float)m_Param.Pt.Y);  	gc.RotateTransform ((float)(m_Param.Rotation));  	if (m_Param.PtSize.X < m_Param.PtSize.Y)  		gc.ScaleTransform (1' (float)(m_Param.PtSize.Y / m_Param.PtSize.X));  	else  		gc.ScaleTransform ((float)(m_Param.PtSize.X / m_Param.PtSize.Y)' 1);  	// draw outline  	//GraphicsPath path = new GraphicsPath();  	//path.AddEllipse(new RectangleF(-(float)m_Param.PtRadius' -(float)m_Param.PtRadius' (float)m_Param.PtRadius *2 ' (float)m_Param.PtRadius * 2));  	// draw feedback -- suppress for when feedback state is asked for (??)  	if (IsForce () && (editState != Render.RenderHint.Feedback)) {  		DrawInsides (gc' r' drawMethods);  	}  	else if (!IsForce ()) {  		DrawInsides (gc' r' drawMethods);  	}  	// restore old graphics system  	gc.Restore (origGC);  }  else {  	// crosshair  	gc.DrawLine (r.RegionOutline' (Point)(new PointD (-5' 0))' (Point)(new PointD (5' 0)));  	gc.DrawLine (r.RegionOutline' (Point)(new PointD (0' -5))' (Point)(new PointD (0' 5)));  }  
Magic Number,KinTemplates.Cursor.Tools,PointToolFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\PointToolFilter.cs,Draw,The following statement contains a magic number: if (Math.Min (m_Param.PtSize.X' m_Param.PtSize.Y) > Render.DrawHelper.MIN_SPEED_SENSITIVITY) {  	//m_Param.Path = new Tools.Model.VectorPath();  	//m_Param.Path.AddEllipse(m_Param.GetBoundingRect());  	drawMethods.DrawNegativeSpace (gc' m_Param.Path.InternalPath' r);  	drawMethods.DrawPositiveSpace (gc' m_Param.Path.InternalPath' r);  	// crosshair  	gc.DrawLine (r.RegionOutline' (Point)(m_Param.Pt + new PointD (-5' 0))' (Point)(m_Param.Pt + new PointD (5' 0)));  	gc.DrawLine (r.RegionOutline' (Point)(m_Param.Pt + new PointD (0' -5))' (Point)(m_Param.Pt + new PointD (0' 5)));  	// transform coordinate system  	GraphicsState origGC = gc.Save ();  	gc.Clip = new Region (m_Param.Path.InternalPath);  	gc.TranslateTransform ((float)m_Param.Pt.X' (float)m_Param.Pt.Y);  	gc.RotateTransform ((float)(m_Param.Rotation));  	if (m_Param.PtSize.X < m_Param.PtSize.Y)  		gc.ScaleTransform (1' (float)(m_Param.PtSize.Y / m_Param.PtSize.X));  	else  		gc.ScaleTransform ((float)(m_Param.PtSize.X / m_Param.PtSize.Y)' 1);  	// draw outline  	//GraphicsPath path = new GraphicsPath();  	//path.AddEllipse(new RectangleF(-(float)m_Param.PtRadius' -(float)m_Param.PtRadius' (float)m_Param.PtRadius *2 ' (float)m_Param.PtRadius * 2));  	// draw feedback -- suppress for when feedback state is asked for (??)  	if (IsForce () && (editState != Render.RenderHint.Feedback)) {  		DrawInsides (gc' r' drawMethods);  	}  	else if (!IsForce ()) {  		DrawInsides (gc' r' drawMethods);  	}  	// restore old graphics system  	gc.Restore (origGC);  }  else {  	// crosshair  	gc.DrawLine (r.RegionOutline' (Point)(new PointD (-5' 0))' (Point)(new PointD (5' 0)));  	gc.DrawLine (r.RegionOutline' (Point)(new PointD (0' -5))' (Point)(new PointD (0' 5)));  }  
Magic Number,KinTemplates.Cursor.Tools,PointToolFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\PointToolFilter.cs,Draw,The following statement contains a magic number: if (Math.Min (m_Param.PtSize.X' m_Param.PtSize.Y) > Render.DrawHelper.MIN_SPEED_SENSITIVITY) {  	//m_Param.Path = new Tools.Model.VectorPath();  	//m_Param.Path.AddEllipse(m_Param.GetBoundingRect());  	drawMethods.DrawNegativeSpace (gc' m_Param.Path.InternalPath' r);  	drawMethods.DrawPositiveSpace (gc' m_Param.Path.InternalPath' r);  	// crosshair  	gc.DrawLine (r.RegionOutline' (Point)(m_Param.Pt + new PointD (-5' 0))' (Point)(m_Param.Pt + new PointD (5' 0)));  	gc.DrawLine (r.RegionOutline' (Point)(m_Param.Pt + new PointD (0' -5))' (Point)(m_Param.Pt + new PointD (0' 5)));  	// transform coordinate system  	GraphicsState origGC = gc.Save ();  	gc.Clip = new Region (m_Param.Path.InternalPath);  	gc.TranslateTransform ((float)m_Param.Pt.X' (float)m_Param.Pt.Y);  	gc.RotateTransform ((float)(m_Param.Rotation));  	if (m_Param.PtSize.X < m_Param.PtSize.Y)  		gc.ScaleTransform (1' (float)(m_Param.PtSize.Y / m_Param.PtSize.X));  	else  		gc.ScaleTransform ((float)(m_Param.PtSize.X / m_Param.PtSize.Y)' 1);  	// draw outline  	//GraphicsPath path = new GraphicsPath();  	//path.AddEllipse(new RectangleF(-(float)m_Param.PtRadius' -(float)m_Param.PtRadius' (float)m_Param.PtRadius *2 ' (float)m_Param.PtRadius * 2));  	// draw feedback -- suppress for when feedback state is asked for (??)  	if (IsForce () && (editState != Render.RenderHint.Feedback)) {  		DrawInsides (gc' r' drawMethods);  	}  	else if (!IsForce ()) {  		DrawInsides (gc' r' drawMethods);  	}  	// restore old graphics system  	gc.Restore (origGC);  }  else {  	// crosshair  	gc.DrawLine (r.RegionOutline' (Point)(new PointD (-5' 0))' (Point)(new PointD (5' 0)));  	gc.DrawLine (r.RegionOutline' (Point)(new PointD (0' -5))' (Point)(new PointD (0' 5)));  }  
Magic Number,KinTemplates.Cursor.Tools,PointToolFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\PointToolFilter.cs,Draw,The following statement contains a magic number: if (Math.Min (m_Param.PtSize.X' m_Param.PtSize.Y) > Render.DrawHelper.MIN_SPEED_SENSITIVITY) {  	//m_Param.Path = new Tools.Model.VectorPath();  	//m_Param.Path.AddEllipse(m_Param.GetBoundingRect());  	drawMethods.DrawNegativeSpace (gc' m_Param.Path.InternalPath' r);  	drawMethods.DrawPositiveSpace (gc' m_Param.Path.InternalPath' r);  	// crosshair  	gc.DrawLine (r.RegionOutline' (Point)(m_Param.Pt + new PointD (-5' 0))' (Point)(m_Param.Pt + new PointD (5' 0)));  	gc.DrawLine (r.RegionOutline' (Point)(m_Param.Pt + new PointD (0' -5))' (Point)(m_Param.Pt + new PointD (0' 5)));  	// transform coordinate system  	GraphicsState origGC = gc.Save ();  	gc.Clip = new Region (m_Param.Path.InternalPath);  	gc.TranslateTransform ((float)m_Param.Pt.X' (float)m_Param.Pt.Y);  	gc.RotateTransform ((float)(m_Param.Rotation));  	if (m_Param.PtSize.X < m_Param.PtSize.Y)  		gc.ScaleTransform (1' (float)(m_Param.PtSize.Y / m_Param.PtSize.X));  	else  		gc.ScaleTransform ((float)(m_Param.PtSize.X / m_Param.PtSize.Y)' 1);  	// draw outline  	//GraphicsPath path = new GraphicsPath();  	//path.AddEllipse(new RectangleF(-(float)m_Param.PtRadius' -(float)m_Param.PtRadius' (float)m_Param.PtRadius *2 ' (float)m_Param.PtRadius * 2));  	// draw feedback -- suppress for when feedback state is asked for (??)  	if (IsForce () && (editState != Render.RenderHint.Feedback)) {  		DrawInsides (gc' r' drawMethods);  	}  	else if (!IsForce ()) {  		DrawInsides (gc' r' drawMethods);  	}  	// restore old graphics system  	gc.Restore (origGC);  }  else {  	// crosshair  	gc.DrawLine (r.RegionOutline' (Point)(new PointD (-5' 0))' (Point)(new PointD (5' 0)));  	gc.DrawLine (r.RegionOutline' (Point)(new PointD (0' -5))' (Point)(new PointD (0' 5)));  }  
Magic Number,KinTemplates.Cursor.Tools,PointToolFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\PointToolFilter.cs,Draw,The following statement contains a magic number: if (Math.Min (m_Param.PtSize.X' m_Param.PtSize.Y) > Render.DrawHelper.MIN_SPEED_SENSITIVITY) {  	//m_Param.Path = new Tools.Model.VectorPath();  	//m_Param.Path.AddEllipse(m_Param.GetBoundingRect());  	drawMethods.DrawNegativeSpace (gc' m_Param.Path.InternalPath' r);  	drawMethods.DrawPositiveSpace (gc' m_Param.Path.InternalPath' r);  	// crosshair  	gc.DrawLine (r.RegionOutline' (Point)(m_Param.Pt + new PointD (-5' 0))' (Point)(m_Param.Pt + new PointD (5' 0)));  	gc.DrawLine (r.RegionOutline' (Point)(m_Param.Pt + new PointD (0' -5))' (Point)(m_Param.Pt + new PointD (0' 5)));  	// transform coordinate system  	GraphicsState origGC = gc.Save ();  	gc.Clip = new Region (m_Param.Path.InternalPath);  	gc.TranslateTransform ((float)m_Param.Pt.X' (float)m_Param.Pt.Y);  	gc.RotateTransform ((float)(m_Param.Rotation));  	if (m_Param.PtSize.X < m_Param.PtSize.Y)  		gc.ScaleTransform (1' (float)(m_Param.PtSize.Y / m_Param.PtSize.X));  	else  		gc.ScaleTransform ((float)(m_Param.PtSize.X / m_Param.PtSize.Y)' 1);  	// draw outline  	//GraphicsPath path = new GraphicsPath();  	//path.AddEllipse(new RectangleF(-(float)m_Param.PtRadius' -(float)m_Param.PtRadius' (float)m_Param.PtRadius *2 ' (float)m_Param.PtRadius * 2));  	// draw feedback -- suppress for when feedback state is asked for (??)  	if (IsForce () && (editState != Render.RenderHint.Feedback)) {  		DrawInsides (gc' r' drawMethods);  	}  	else if (!IsForce ()) {  		DrawInsides (gc' r' drawMethods);  	}  	// restore old graphics system  	gc.Restore (origGC);  }  else {  	// crosshair  	gc.DrawLine (r.RegionOutline' (Point)(new PointD (-5' 0))' (Point)(new PointD (5' 0)));  	gc.DrawLine (r.RegionOutline' (Point)(new PointD (0' -5))' (Point)(new PointD (0' 5)));  }  
Magic Number,KinTemplates.Cursor.Tools,PointToolFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\PointToolFilter.cs,Draw,The following statement contains a magic number: if (Math.Min (m_Param.PtSize.X' m_Param.PtSize.Y) > Render.DrawHelper.MIN_SPEED_SENSITIVITY) {  	//m_Param.Path = new Tools.Model.VectorPath();  	//m_Param.Path.AddEllipse(m_Param.GetBoundingRect());  	drawMethods.DrawNegativeSpace (gc' m_Param.Path.InternalPath' r);  	drawMethods.DrawPositiveSpace (gc' m_Param.Path.InternalPath' r);  	// crosshair  	gc.DrawLine (r.RegionOutline' (Point)(m_Param.Pt + new PointD (-5' 0))' (Point)(m_Param.Pt + new PointD (5' 0)));  	gc.DrawLine (r.RegionOutline' (Point)(m_Param.Pt + new PointD (0' -5))' (Point)(m_Param.Pt + new PointD (0' 5)));  	// transform coordinate system  	GraphicsState origGC = gc.Save ();  	gc.Clip = new Region (m_Param.Path.InternalPath);  	gc.TranslateTransform ((float)m_Param.Pt.X' (float)m_Param.Pt.Y);  	gc.RotateTransform ((float)(m_Param.Rotation));  	if (m_Param.PtSize.X < m_Param.PtSize.Y)  		gc.ScaleTransform (1' (float)(m_Param.PtSize.Y / m_Param.PtSize.X));  	else  		gc.ScaleTransform ((float)(m_Param.PtSize.X / m_Param.PtSize.Y)' 1);  	// draw outline  	//GraphicsPath path = new GraphicsPath();  	//path.AddEllipse(new RectangleF(-(float)m_Param.PtRadius' -(float)m_Param.PtRadius' (float)m_Param.PtRadius *2 ' (float)m_Param.PtRadius * 2));  	// draw feedback -- suppress for when feedback state is asked for (??)  	if (IsForce () && (editState != Render.RenderHint.Feedback)) {  		DrawInsides (gc' r' drawMethods);  	}  	else if (!IsForce ()) {  		DrawInsides (gc' r' drawMethods);  	}  	// restore old graphics system  	gc.Restore (origGC);  }  else {  	// crosshair  	gc.DrawLine (r.RegionOutline' (Point)(new PointD (-5' 0))' (Point)(new PointD (5' 0)));  	gc.DrawLine (r.RegionOutline' (Point)(new PointD (0' -5))' (Point)(new PointD (0' 5)));  }  
Magic Number,KinTemplates.Cursor.Tools,PointToolFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\PointToolFilter.cs,Draw,The following statement contains a magic number: if (Math.Min (m_Param.PtSize.X' m_Param.PtSize.Y) > Render.DrawHelper.MIN_SPEED_SENSITIVITY) {  	//m_Param.Path = new Tools.Model.VectorPath();  	//m_Param.Path.AddEllipse(m_Param.GetBoundingRect());  	drawMethods.DrawNegativeSpace (gc' m_Param.Path.InternalPath' r);  	drawMethods.DrawPositiveSpace (gc' m_Param.Path.InternalPath' r);  	// crosshair  	gc.DrawLine (r.RegionOutline' (Point)(m_Param.Pt + new PointD (-5' 0))' (Point)(m_Param.Pt + new PointD (5' 0)));  	gc.DrawLine (r.RegionOutline' (Point)(m_Param.Pt + new PointD (0' -5))' (Point)(m_Param.Pt + new PointD (0' 5)));  	// transform coordinate system  	GraphicsState origGC = gc.Save ();  	gc.Clip = new Region (m_Param.Path.InternalPath);  	gc.TranslateTransform ((float)m_Param.Pt.X' (float)m_Param.Pt.Y);  	gc.RotateTransform ((float)(m_Param.Rotation));  	if (m_Param.PtSize.X < m_Param.PtSize.Y)  		gc.ScaleTransform (1' (float)(m_Param.PtSize.Y / m_Param.PtSize.X));  	else  		gc.ScaleTransform ((float)(m_Param.PtSize.X / m_Param.PtSize.Y)' 1);  	// draw outline  	//GraphicsPath path = new GraphicsPath();  	//path.AddEllipse(new RectangleF(-(float)m_Param.PtRadius' -(float)m_Param.PtRadius' (float)m_Param.PtRadius *2 ' (float)m_Param.PtRadius * 2));  	// draw feedback -- suppress for when feedback state is asked for (??)  	if (IsForce () && (editState != Render.RenderHint.Feedback)) {  		DrawInsides (gc' r' drawMethods);  	}  	else if (!IsForce ()) {  		DrawInsides (gc' r' drawMethods);  	}  	// restore old graphics system  	gc.Restore (origGC);  }  else {  	// crosshair  	gc.DrawLine (r.RegionOutline' (Point)(new PointD (-5' 0))' (Point)(new PointD (5' 0)));  	gc.DrawLine (r.RegionOutline' (Point)(new PointD (0' -5))' (Point)(new PointD (0' 5)));  }  
Magic Number,KinTemplates.Cursor.Tools,PointToolFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\PointToolFilter.cs,Draw,The following statement contains a magic number: if (Math.Min (m_Param.PtSize.X' m_Param.PtSize.Y) > Render.DrawHelper.MIN_SPEED_SENSITIVITY) {  	//m_Param.Path = new Tools.Model.VectorPath();  	//m_Param.Path.AddEllipse(m_Param.GetBoundingRect());  	drawMethods.DrawNegativeSpace (gc' m_Param.Path.InternalPath' r);  	drawMethods.DrawPositiveSpace (gc' m_Param.Path.InternalPath' r);  	// crosshair  	gc.DrawLine (r.RegionOutline' (Point)(m_Param.Pt + new PointD (-5' 0))' (Point)(m_Param.Pt + new PointD (5' 0)));  	gc.DrawLine (r.RegionOutline' (Point)(m_Param.Pt + new PointD (0' -5))' (Point)(m_Param.Pt + new PointD (0' 5)));  	// transform coordinate system  	GraphicsState origGC = gc.Save ();  	gc.Clip = new Region (m_Param.Path.InternalPath);  	gc.TranslateTransform ((float)m_Param.Pt.X' (float)m_Param.Pt.Y);  	gc.RotateTransform ((float)(m_Param.Rotation));  	if (m_Param.PtSize.X < m_Param.PtSize.Y)  		gc.ScaleTransform (1' (float)(m_Param.PtSize.Y / m_Param.PtSize.X));  	else  		gc.ScaleTransform ((float)(m_Param.PtSize.X / m_Param.PtSize.Y)' 1);  	// draw outline  	//GraphicsPath path = new GraphicsPath();  	//path.AddEllipse(new RectangleF(-(float)m_Param.PtRadius' -(float)m_Param.PtRadius' (float)m_Param.PtRadius *2 ' (float)m_Param.PtRadius * 2));  	// draw feedback -- suppress for when feedback state is asked for (??)  	if (IsForce () && (editState != Render.RenderHint.Feedback)) {  		DrawInsides (gc' r' drawMethods);  	}  	else if (!IsForce ()) {  		DrawInsides (gc' r' drawMethods);  	}  	// restore old graphics system  	gc.Restore (origGC);  }  else {  	// crosshair  	gc.DrawLine (r.RegionOutline' (Point)(new PointD (-5' 0))' (Point)(new PointD (5' 0)));  	gc.DrawLine (r.RegionOutline' (Point)(new PointD (0' -5))' (Point)(new PointD (0' 5)));  }  
Magic Number,KinTemplates.Cursor.Tools,PointToolFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\PointToolFilter.cs,Draw,The following statement contains a magic number: gc.DrawLine (r.RegionOutline' (Point)(m_Param.Pt + new PointD (-5' 0))' (Point)(m_Param.Pt + new PointD (5' 0)));  
Magic Number,KinTemplates.Cursor.Tools,PointToolFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\PointToolFilter.cs,Draw,The following statement contains a magic number: gc.DrawLine (r.RegionOutline' (Point)(m_Param.Pt + new PointD (-5' 0))' (Point)(m_Param.Pt + new PointD (5' 0)));  
Magic Number,KinTemplates.Cursor.Tools,PointToolFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\PointToolFilter.cs,Draw,The following statement contains a magic number: gc.DrawLine (r.RegionOutline' (Point)(m_Param.Pt + new PointD (0' -5))' (Point)(m_Param.Pt + new PointD (0' 5)));  
Magic Number,KinTemplates.Cursor.Tools,PointToolFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\PointToolFilter.cs,Draw,The following statement contains a magic number: gc.DrawLine (r.RegionOutline' (Point)(m_Param.Pt + new PointD (0' -5))' (Point)(m_Param.Pt + new PointD (0' 5)));  
Magic Number,KinTemplates.Cursor.Tools,PointToolFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\PointToolFilter.cs,Draw,The following statement contains a magic number: gc.DrawLine (r.RegionOutline' (Point)(new PointD (-5' 0))' (Point)(new PointD (5' 0)));  
Magic Number,KinTemplates.Cursor.Tools,PointToolFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\PointToolFilter.cs,Draw,The following statement contains a magic number: gc.DrawLine (r.RegionOutline' (Point)(new PointD (-5' 0))' (Point)(new PointD (5' 0)));  
Magic Number,KinTemplates.Cursor.Tools,PointToolFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\PointToolFilter.cs,Draw,The following statement contains a magic number: gc.DrawLine (r.RegionOutline' (Point)(new PointD (0' -5))' (Point)(new PointD (0' 5)));  
Magic Number,KinTemplates.Cursor.Tools,PointToolFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\PointToolFilter.cs,Draw,The following statement contains a magic number: gc.DrawLine (r.RegionOutline' (Point)(new PointD (0' -5))' (Point)(new PointD (0' 5)));  
Magic Number,KinTemplates.Cursor.Tools,PointToolFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\PointToolFilter.cs,DrawInsides,The following statement contains a magic number: if (IsForce ())  	DrawArrowPoints (gc' r' drawMethods);  else if (this is CompassFilter) {  	float ringSpacing = (float)drawMethods.Spacing (m_Param.C);  	int numRings = (int)(m_Param.PtRadius / ringSpacing);  	for (int i = 1; i < numRings; i++) {  		gc.DrawEllipse (r.RegionGuides' new RectangleF (-i * ringSpacing' -i * ringSpacing' i * ringSpacing * 2' i * ringSpacing * 2));  	}  }  else if (this is DimpleChadFilter) {  	double angle = 360 / 8;  	for (int j = 0; j < 8; j++) {  		// put some points in the circle region  		PointD theVector = new PointD (Math.Cos (angle * j / 180.0 * Math.PI)' Math.Sin (angle * j / 180.0 * Math.PI));  		gc.DrawLine (r.RegionGuides' new PointF (0' 0)' (PointF)(theVector * m_Param.PtRadius));  	}  }  
Magic Number,KinTemplates.Cursor.Tools,PointToolFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\PointToolFilter.cs,DrawInsides,The following statement contains a magic number: if (IsForce ())  	DrawArrowPoints (gc' r' drawMethods);  else if (this is CompassFilter) {  	float ringSpacing = (float)drawMethods.Spacing (m_Param.C);  	int numRings = (int)(m_Param.PtRadius / ringSpacing);  	for (int i = 1; i < numRings; i++) {  		gc.DrawEllipse (r.RegionGuides' new RectangleF (-i * ringSpacing' -i * ringSpacing' i * ringSpacing * 2' i * ringSpacing * 2));  	}  }  else if (this is DimpleChadFilter) {  	double angle = 360 / 8;  	for (int j = 0; j < 8; j++) {  		// put some points in the circle region  		PointD theVector = new PointD (Math.Cos (angle * j / 180.0 * Math.PI)' Math.Sin (angle * j / 180.0 * Math.PI));  		gc.DrawLine (r.RegionGuides' new PointF (0' 0)' (PointF)(theVector * m_Param.PtRadius));  	}  }  
Magic Number,KinTemplates.Cursor.Tools,PointToolFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\PointToolFilter.cs,DrawInsides,The following statement contains a magic number: if (IsForce ())  	DrawArrowPoints (gc' r' drawMethods);  else if (this is CompassFilter) {  	float ringSpacing = (float)drawMethods.Spacing (m_Param.C);  	int numRings = (int)(m_Param.PtRadius / ringSpacing);  	for (int i = 1; i < numRings; i++) {  		gc.DrawEllipse (r.RegionGuides' new RectangleF (-i * ringSpacing' -i * ringSpacing' i * ringSpacing * 2' i * ringSpacing * 2));  	}  }  else if (this is DimpleChadFilter) {  	double angle = 360 / 8;  	for (int j = 0; j < 8; j++) {  		// put some points in the circle region  		PointD theVector = new PointD (Math.Cos (angle * j / 180.0 * Math.PI)' Math.Sin (angle * j / 180.0 * Math.PI));  		gc.DrawLine (r.RegionGuides' new PointF (0' 0)' (PointF)(theVector * m_Param.PtRadius));  	}  }  
Magic Number,KinTemplates.Cursor.Tools,PointToolFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\PointToolFilter.cs,DrawInsides,The following statement contains a magic number: if (IsForce ())  	DrawArrowPoints (gc' r' drawMethods);  else if (this is CompassFilter) {  	float ringSpacing = (float)drawMethods.Spacing (m_Param.C);  	int numRings = (int)(m_Param.PtRadius / ringSpacing);  	for (int i = 1; i < numRings; i++) {  		gc.DrawEllipse (r.RegionGuides' new RectangleF (-i * ringSpacing' -i * ringSpacing' i * ringSpacing * 2' i * ringSpacing * 2));  	}  }  else if (this is DimpleChadFilter) {  	double angle = 360 / 8;  	for (int j = 0; j < 8; j++) {  		// put some points in the circle region  		PointD theVector = new PointD (Math.Cos (angle * j / 180.0 * Math.PI)' Math.Sin (angle * j / 180.0 * Math.PI));  		gc.DrawLine (r.RegionGuides' new PointF (0' 0)' (PointF)(theVector * m_Param.PtRadius));  	}  }  
Magic Number,KinTemplates.Cursor.Tools,PointToolFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\PointToolFilter.cs,DrawInsides,The following statement contains a magic number: if (IsForce ())  	DrawArrowPoints (gc' r' drawMethods);  else if (this is CompassFilter) {  	float ringSpacing = (float)drawMethods.Spacing (m_Param.C);  	int numRings = (int)(m_Param.PtRadius / ringSpacing);  	for (int i = 1; i < numRings; i++) {  		gc.DrawEllipse (r.RegionGuides' new RectangleF (-i * ringSpacing' -i * ringSpacing' i * ringSpacing * 2' i * ringSpacing * 2));  	}  }  else if (this is DimpleChadFilter) {  	double angle = 360 / 8;  	for (int j = 0; j < 8; j++) {  		// put some points in the circle region  		PointD theVector = new PointD (Math.Cos (angle * j / 180.0 * Math.PI)' Math.Sin (angle * j / 180.0 * Math.PI));  		gc.DrawLine (r.RegionGuides' new PointF (0' 0)' (PointF)(theVector * m_Param.PtRadius));  	}  }  
Magic Number,KinTemplates.Cursor.Tools,PointToolFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\PointToolFilter.cs,DrawInsides,The following statement contains a magic number: if (IsForce ())  	DrawArrowPoints (gc' r' drawMethods);  else if (this is CompassFilter) {  	float ringSpacing = (float)drawMethods.Spacing (m_Param.C);  	int numRings = (int)(m_Param.PtRadius / ringSpacing);  	for (int i = 1; i < numRings; i++) {  		gc.DrawEllipse (r.RegionGuides' new RectangleF (-i * ringSpacing' -i * ringSpacing' i * ringSpacing * 2' i * ringSpacing * 2));  	}  }  else if (this is DimpleChadFilter) {  	double angle = 360 / 8;  	for (int j = 0; j < 8; j++) {  		// put some points in the circle region  		PointD theVector = new PointD (Math.Cos (angle * j / 180.0 * Math.PI)' Math.Sin (angle * j / 180.0 * Math.PI));  		gc.DrawLine (r.RegionGuides' new PointF (0' 0)' (PointF)(theVector * m_Param.PtRadius));  	}  }  
Magic Number,KinTemplates.Cursor.Tools,PointToolFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\PointToolFilter.cs,DrawInsides,The following statement contains a magic number: if (IsForce ())  	DrawArrowPoints (gc' r' drawMethods);  else if (this is CompassFilter) {  	float ringSpacing = (float)drawMethods.Spacing (m_Param.C);  	int numRings = (int)(m_Param.PtRadius / ringSpacing);  	for (int i = 1; i < numRings; i++) {  		gc.DrawEllipse (r.RegionGuides' new RectangleF (-i * ringSpacing' -i * ringSpacing' i * ringSpacing * 2' i * ringSpacing * 2));  	}  }  else if (this is DimpleChadFilter) {  	double angle = 360 / 8;  	for (int j = 0; j < 8; j++) {  		// put some points in the circle region  		PointD theVector = new PointD (Math.Cos (angle * j / 180.0 * Math.PI)' Math.Sin (angle * j / 180.0 * Math.PI));  		gc.DrawLine (r.RegionGuides' new PointF (0' 0)' (PointF)(theVector * m_Param.PtRadius));  	}  }  
Magic Number,KinTemplates.Cursor.Tools,PointToolFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\PointToolFilter.cs,DrawInsides,The following statement contains a magic number: if (this is CompassFilter) {  	float ringSpacing = (float)drawMethods.Spacing (m_Param.C);  	int numRings = (int)(m_Param.PtRadius / ringSpacing);  	for (int i = 1; i < numRings; i++) {  		gc.DrawEllipse (r.RegionGuides' new RectangleF (-i * ringSpacing' -i * ringSpacing' i * ringSpacing * 2' i * ringSpacing * 2));  	}  }  else if (this is DimpleChadFilter) {  	double angle = 360 / 8;  	for (int j = 0; j < 8; j++) {  		// put some points in the circle region  		PointD theVector = new PointD (Math.Cos (angle * j / 180.0 * Math.PI)' Math.Sin (angle * j / 180.0 * Math.PI));  		gc.DrawLine (r.RegionGuides' new PointF (0' 0)' (PointF)(theVector * m_Param.PtRadius));  	}  }  
Magic Number,KinTemplates.Cursor.Tools,PointToolFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\PointToolFilter.cs,DrawInsides,The following statement contains a magic number: if (this is CompassFilter) {  	float ringSpacing = (float)drawMethods.Spacing (m_Param.C);  	int numRings = (int)(m_Param.PtRadius / ringSpacing);  	for (int i = 1; i < numRings; i++) {  		gc.DrawEllipse (r.RegionGuides' new RectangleF (-i * ringSpacing' -i * ringSpacing' i * ringSpacing * 2' i * ringSpacing * 2));  	}  }  else if (this is DimpleChadFilter) {  	double angle = 360 / 8;  	for (int j = 0; j < 8; j++) {  		// put some points in the circle region  		PointD theVector = new PointD (Math.Cos (angle * j / 180.0 * Math.PI)' Math.Sin (angle * j / 180.0 * Math.PI));  		gc.DrawLine (r.RegionGuides' new PointF (0' 0)' (PointF)(theVector * m_Param.PtRadius));  	}  }  
Magic Number,KinTemplates.Cursor.Tools,PointToolFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\PointToolFilter.cs,DrawInsides,The following statement contains a magic number: if (this is CompassFilter) {  	float ringSpacing = (float)drawMethods.Spacing (m_Param.C);  	int numRings = (int)(m_Param.PtRadius / ringSpacing);  	for (int i = 1; i < numRings; i++) {  		gc.DrawEllipse (r.RegionGuides' new RectangleF (-i * ringSpacing' -i * ringSpacing' i * ringSpacing * 2' i * ringSpacing * 2));  	}  }  else if (this is DimpleChadFilter) {  	double angle = 360 / 8;  	for (int j = 0; j < 8; j++) {  		// put some points in the circle region  		PointD theVector = new PointD (Math.Cos (angle * j / 180.0 * Math.PI)' Math.Sin (angle * j / 180.0 * Math.PI));  		gc.DrawLine (r.RegionGuides' new PointF (0' 0)' (PointF)(theVector * m_Param.PtRadius));  	}  }  
Magic Number,KinTemplates.Cursor.Tools,PointToolFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\PointToolFilter.cs,DrawInsides,The following statement contains a magic number: if (this is CompassFilter) {  	float ringSpacing = (float)drawMethods.Spacing (m_Param.C);  	int numRings = (int)(m_Param.PtRadius / ringSpacing);  	for (int i = 1; i < numRings; i++) {  		gc.DrawEllipse (r.RegionGuides' new RectangleF (-i * ringSpacing' -i * ringSpacing' i * ringSpacing * 2' i * ringSpacing * 2));  	}  }  else if (this is DimpleChadFilter) {  	double angle = 360 / 8;  	for (int j = 0; j < 8; j++) {  		// put some points in the circle region  		PointD theVector = new PointD (Math.Cos (angle * j / 180.0 * Math.PI)' Math.Sin (angle * j / 180.0 * Math.PI));  		gc.DrawLine (r.RegionGuides' new PointF (0' 0)' (PointF)(theVector * m_Param.PtRadius));  	}  }  
Magic Number,KinTemplates.Cursor.Tools,PointToolFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\PointToolFilter.cs,DrawInsides,The following statement contains a magic number: if (this is CompassFilter) {  	float ringSpacing = (float)drawMethods.Spacing (m_Param.C);  	int numRings = (int)(m_Param.PtRadius / ringSpacing);  	for (int i = 1; i < numRings; i++) {  		gc.DrawEllipse (r.RegionGuides' new RectangleF (-i * ringSpacing' -i * ringSpacing' i * ringSpacing * 2' i * ringSpacing * 2));  	}  }  else if (this is DimpleChadFilter) {  	double angle = 360 / 8;  	for (int j = 0; j < 8; j++) {  		// put some points in the circle region  		PointD theVector = new PointD (Math.Cos (angle * j / 180.0 * Math.PI)' Math.Sin (angle * j / 180.0 * Math.PI));  		gc.DrawLine (r.RegionGuides' new PointF (0' 0)' (PointF)(theVector * m_Param.PtRadius));  	}  }  
Magic Number,KinTemplates.Cursor.Tools,PointToolFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\PointToolFilter.cs,DrawInsides,The following statement contains a magic number: if (this is CompassFilter) {  	float ringSpacing = (float)drawMethods.Spacing (m_Param.C);  	int numRings = (int)(m_Param.PtRadius / ringSpacing);  	for (int i = 1; i < numRings; i++) {  		gc.DrawEllipse (r.RegionGuides' new RectangleF (-i * ringSpacing' -i * ringSpacing' i * ringSpacing * 2' i * ringSpacing * 2));  	}  }  else if (this is DimpleChadFilter) {  	double angle = 360 / 8;  	for (int j = 0; j < 8; j++) {  		// put some points in the circle region  		PointD theVector = new PointD (Math.Cos (angle * j / 180.0 * Math.PI)' Math.Sin (angle * j / 180.0 * Math.PI));  		gc.DrawLine (r.RegionGuides' new PointF (0' 0)' (PointF)(theVector * m_Param.PtRadius));  	}  }  
Magic Number,KinTemplates.Cursor.Tools,PointToolFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\PointToolFilter.cs,DrawInsides,The following statement contains a magic number: if (this is CompassFilter) {  	float ringSpacing = (float)drawMethods.Spacing (m_Param.C);  	int numRings = (int)(m_Param.PtRadius / ringSpacing);  	for (int i = 1; i < numRings; i++) {  		gc.DrawEllipse (r.RegionGuides' new RectangleF (-i * ringSpacing' -i * ringSpacing' i * ringSpacing * 2' i * ringSpacing * 2));  	}  }  else if (this is DimpleChadFilter) {  	double angle = 360 / 8;  	for (int j = 0; j < 8; j++) {  		// put some points in the circle region  		PointD theVector = new PointD (Math.Cos (angle * j / 180.0 * Math.PI)' Math.Sin (angle * j / 180.0 * Math.PI));  		gc.DrawLine (r.RegionGuides' new PointF (0' 0)' (PointF)(theVector * m_Param.PtRadius));  	}  }  
Magic Number,KinTemplates.Cursor.Tools,PointToolFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\PointToolFilter.cs,DrawInsides,The following statement contains a magic number: for (int i = 1; i < numRings; i++) {  	gc.DrawEllipse (r.RegionGuides' new RectangleF (-i * ringSpacing' -i * ringSpacing' i * ringSpacing * 2' i * ringSpacing * 2));  }  
Magic Number,KinTemplates.Cursor.Tools,PointToolFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\PointToolFilter.cs,DrawInsides,The following statement contains a magic number: for (int i = 1; i < numRings; i++) {  	gc.DrawEllipse (r.RegionGuides' new RectangleF (-i * ringSpacing' -i * ringSpacing' i * ringSpacing * 2' i * ringSpacing * 2));  }  
Magic Number,KinTemplates.Cursor.Tools,PointToolFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\PointToolFilter.cs,DrawInsides,The following statement contains a magic number: gc.DrawEllipse (r.RegionGuides' new RectangleF (-i * ringSpacing' -i * ringSpacing' i * ringSpacing * 2' i * ringSpacing * 2));  
Magic Number,KinTemplates.Cursor.Tools,PointToolFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\PointToolFilter.cs,DrawInsides,The following statement contains a magic number: gc.DrawEllipse (r.RegionGuides' new RectangleF (-i * ringSpacing' -i * ringSpacing' i * ringSpacing * 2' i * ringSpacing * 2));  
Magic Number,KinTemplates.Cursor.Tools,PointToolFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\PointToolFilter.cs,DrawInsides,The following statement contains a magic number: if (this is DimpleChadFilter) {  	double angle = 360 / 8;  	for (int j = 0; j < 8; j++) {  		// put some points in the circle region  		PointD theVector = new PointD (Math.Cos (angle * j / 180.0 * Math.PI)' Math.Sin (angle * j / 180.0 * Math.PI));  		gc.DrawLine (r.RegionGuides' new PointF (0' 0)' (PointF)(theVector * m_Param.PtRadius));  	}  }  
Magic Number,KinTemplates.Cursor.Tools,PointToolFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\PointToolFilter.cs,DrawInsides,The following statement contains a magic number: if (this is DimpleChadFilter) {  	double angle = 360 / 8;  	for (int j = 0; j < 8; j++) {  		// put some points in the circle region  		PointD theVector = new PointD (Math.Cos (angle * j / 180.0 * Math.PI)' Math.Sin (angle * j / 180.0 * Math.PI));  		gc.DrawLine (r.RegionGuides' new PointF (0' 0)' (PointF)(theVector * m_Param.PtRadius));  	}  }  
Magic Number,KinTemplates.Cursor.Tools,PointToolFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\PointToolFilter.cs,DrawInsides,The following statement contains a magic number: if (this is DimpleChadFilter) {  	double angle = 360 / 8;  	for (int j = 0; j < 8; j++) {  		// put some points in the circle region  		PointD theVector = new PointD (Math.Cos (angle * j / 180.0 * Math.PI)' Math.Sin (angle * j / 180.0 * Math.PI));  		gc.DrawLine (r.RegionGuides' new PointF (0' 0)' (PointF)(theVector * m_Param.PtRadius));  	}  }  
Magic Number,KinTemplates.Cursor.Tools,PointToolFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\PointToolFilter.cs,DrawInsides,The following statement contains a magic number: if (this is DimpleChadFilter) {  	double angle = 360 / 8;  	for (int j = 0; j < 8; j++) {  		// put some points in the circle region  		PointD theVector = new PointD (Math.Cos (angle * j / 180.0 * Math.PI)' Math.Sin (angle * j / 180.0 * Math.PI));  		gc.DrawLine (r.RegionGuides' new PointF (0' 0)' (PointF)(theVector * m_Param.PtRadius));  	}  }  
Magic Number,KinTemplates.Cursor.Tools,PointToolFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\PointToolFilter.cs,DrawInsides,The following statement contains a magic number: if (this is DimpleChadFilter) {  	double angle = 360 / 8;  	for (int j = 0; j < 8; j++) {  		// put some points in the circle region  		PointD theVector = new PointD (Math.Cos (angle * j / 180.0 * Math.PI)' Math.Sin (angle * j / 180.0 * Math.PI));  		gc.DrawLine (r.RegionGuides' new PointF (0' 0)' (PointF)(theVector * m_Param.PtRadius));  	}  }  
Magic Number,KinTemplates.Cursor.Tools,PointToolFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\PointToolFilter.cs,DrawInsides,The following statement contains a magic number: for (int j = 0; j < 8; j++) {  	// put some points in the circle region  	PointD theVector = new PointD (Math.Cos (angle * j / 180.0 * Math.PI)' Math.Sin (angle * j / 180.0 * Math.PI));  	gc.DrawLine (r.RegionGuides' new PointF (0' 0)' (PointF)(theVector * m_Param.PtRadius));  }  
Magic Number,KinTemplates.Cursor.Tools,PointToolFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\PointToolFilter.cs,DrawInsides,The following statement contains a magic number: for (int j = 0; j < 8; j++) {  	// put some points in the circle region  	PointD theVector = new PointD (Math.Cos (angle * j / 180.0 * Math.PI)' Math.Sin (angle * j / 180.0 * Math.PI));  	gc.DrawLine (r.RegionGuides' new PointF (0' 0)' (PointF)(theVector * m_Param.PtRadius));  }  
Magic Number,KinTemplates.Cursor.Tools,PointToolFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\PointToolFilter.cs,DrawInsides,The following statement contains a magic number: for (int j = 0; j < 8; j++) {  	// put some points in the circle region  	PointD theVector = new PointD (Math.Cos (angle * j / 180.0 * Math.PI)' Math.Sin (angle * j / 180.0 * Math.PI));  	gc.DrawLine (r.RegionGuides' new PointF (0' 0)' (PointF)(theVector * m_Param.PtRadius));  }  
Magic Number,KinTemplates.Cursor.Tools,PointToolFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\PointToolFilter.cs,DrawArrowPoints,The following statement contains a magic number: for (int i = 1; i <= ptRings; i++) {  	double innerRadius = (Render.DrawHelper.SPEED_AMPLIFIER * 1.1 + 10) * i;  	for (int j = 0; j < 8; j++) {  		// put some points in the circle region  		PointD theVector = new PointD (Math.Cos (angle * j / 180.0 * Math.PI)' Math.Sin (angle * j / 180.0 * Math.PI));  		PointD thePoint = theVector * innerRadius;  		// test these points  		//Position.VirtualMousePosition mouse = new Position.VirtualMousePosition((Point)thePoint);  		//ParameterizedMousePosition fakeMouse = new ParameterizedMousePosition(mouse' 20);// TODO: instrument from the computer  		//PointD vel = GetVelocity(fakeMouse) * Render.DrawHelper.SPEED_AMPLIFIER ;    		PointD vel = PointD.Empty;  		if (this is MagneticPointAttractionFilter) {  			vel = theVector * (m_Param.V.Y != 0 ? Math.Sign (m_Param.V.Y) : 1) * -Render.DrawHelper.SPEED_AMPLIFIER * (m_Param.C + 0.1);  		}  		if (this is RubberBandFilter) {  			vel = theVector * (m_Param.V.Y != 0 ? Math.Sign (m_Param.V.Y) : 1) * -Render.DrawHelper.SPEED_AMPLIFIER * (m_Param.C + 0.1) * Math.Pow (innerRadius / m_Param.PtRadius' 2);  		}  		if (this is OrbitFilter) {  			vel = PointD.Orthogonal (theVector) * (m_Param.V.X != 0 ? Math.Sign (m_Param.V.X) : 1) * Render.DrawHelper.SPEED_AMPLIFIER * (m_Param.C + 0.1);  		}  		if (this is OrbitFilter2) {  			vel = PointD.Orthogonal (theVector) * (m_Param.V.X != 0 ? Math.Sign (m_Param.V.X) : 1) * (m_Param.C + 0.1) * (innerRadius / 4);  		}  		if (this is OrbitFilter3) {  			vel = PointD.Orthogonal (theVector) * (m_Param.V.X != 0 ? Math.Sign (m_Param.V.X) : 1) * (m_Param.C + 0.1) * (innerRadius / 4);  		}  		drawMethods.DrawArrow (gc' r' thePoint' vel);  	}  }  
Magic Number,KinTemplates.Cursor.Tools,PointToolFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\PointToolFilter.cs,DrawArrowPoints,The following statement contains a magic number: for (int i = 1; i <= ptRings; i++) {  	double innerRadius = (Render.DrawHelper.SPEED_AMPLIFIER * 1.1 + 10) * i;  	for (int j = 0; j < 8; j++) {  		// put some points in the circle region  		PointD theVector = new PointD (Math.Cos (angle * j / 180.0 * Math.PI)' Math.Sin (angle * j / 180.0 * Math.PI));  		PointD thePoint = theVector * innerRadius;  		// test these points  		//Position.VirtualMousePosition mouse = new Position.VirtualMousePosition((Point)thePoint);  		//ParameterizedMousePosition fakeMouse = new ParameterizedMousePosition(mouse' 20);// TODO: instrument from the computer  		//PointD vel = GetVelocity(fakeMouse) * Render.DrawHelper.SPEED_AMPLIFIER ;    		PointD vel = PointD.Empty;  		if (this is MagneticPointAttractionFilter) {  			vel = theVector * (m_Param.V.Y != 0 ? Math.Sign (m_Param.V.Y) : 1) * -Render.DrawHelper.SPEED_AMPLIFIER * (m_Param.C + 0.1);  		}  		if (this is RubberBandFilter) {  			vel = theVector * (m_Param.V.Y != 0 ? Math.Sign (m_Param.V.Y) : 1) * -Render.DrawHelper.SPEED_AMPLIFIER * (m_Param.C + 0.1) * Math.Pow (innerRadius / m_Param.PtRadius' 2);  		}  		if (this is OrbitFilter) {  			vel = PointD.Orthogonal (theVector) * (m_Param.V.X != 0 ? Math.Sign (m_Param.V.X) : 1) * Render.DrawHelper.SPEED_AMPLIFIER * (m_Param.C + 0.1);  		}  		if (this is OrbitFilter2) {  			vel = PointD.Orthogonal (theVector) * (m_Param.V.X != 0 ? Math.Sign (m_Param.V.X) : 1) * (m_Param.C + 0.1) * (innerRadius / 4);  		}  		if (this is OrbitFilter3) {  			vel = PointD.Orthogonal (theVector) * (m_Param.V.X != 0 ? Math.Sign (m_Param.V.X) : 1) * (m_Param.C + 0.1) * (innerRadius / 4);  		}  		drawMethods.DrawArrow (gc' r' thePoint' vel);  	}  }  
Magic Number,KinTemplates.Cursor.Tools,PointToolFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\PointToolFilter.cs,DrawArrowPoints,The following statement contains a magic number: for (int i = 1; i <= ptRings; i++) {  	double innerRadius = (Render.DrawHelper.SPEED_AMPLIFIER * 1.1 + 10) * i;  	for (int j = 0; j < 8; j++) {  		// put some points in the circle region  		PointD theVector = new PointD (Math.Cos (angle * j / 180.0 * Math.PI)' Math.Sin (angle * j / 180.0 * Math.PI));  		PointD thePoint = theVector * innerRadius;  		// test these points  		//Position.VirtualMousePosition mouse = new Position.VirtualMousePosition((Point)thePoint);  		//ParameterizedMousePosition fakeMouse = new ParameterizedMousePosition(mouse' 20);// TODO: instrument from the computer  		//PointD vel = GetVelocity(fakeMouse) * Render.DrawHelper.SPEED_AMPLIFIER ;    		PointD vel = PointD.Empty;  		if (this is MagneticPointAttractionFilter) {  			vel = theVector * (m_Param.V.Y != 0 ? Math.Sign (m_Param.V.Y) : 1) * -Render.DrawHelper.SPEED_AMPLIFIER * (m_Param.C + 0.1);  		}  		if (this is RubberBandFilter) {  			vel = theVector * (m_Param.V.Y != 0 ? Math.Sign (m_Param.V.Y) : 1) * -Render.DrawHelper.SPEED_AMPLIFIER * (m_Param.C + 0.1) * Math.Pow (innerRadius / m_Param.PtRadius' 2);  		}  		if (this is OrbitFilter) {  			vel = PointD.Orthogonal (theVector) * (m_Param.V.X != 0 ? Math.Sign (m_Param.V.X) : 1) * Render.DrawHelper.SPEED_AMPLIFIER * (m_Param.C + 0.1);  		}  		if (this is OrbitFilter2) {  			vel = PointD.Orthogonal (theVector) * (m_Param.V.X != 0 ? Math.Sign (m_Param.V.X) : 1) * (m_Param.C + 0.1) * (innerRadius / 4);  		}  		if (this is OrbitFilter3) {  			vel = PointD.Orthogonal (theVector) * (m_Param.V.X != 0 ? Math.Sign (m_Param.V.X) : 1) * (m_Param.C + 0.1) * (innerRadius / 4);  		}  		drawMethods.DrawArrow (gc' r' thePoint' vel);  	}  }  
Magic Number,KinTemplates.Cursor.Tools,PointToolFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\PointToolFilter.cs,DrawArrowPoints,The following statement contains a magic number: for (int i = 1; i <= ptRings; i++) {  	double innerRadius = (Render.DrawHelper.SPEED_AMPLIFIER * 1.1 + 10) * i;  	for (int j = 0; j < 8; j++) {  		// put some points in the circle region  		PointD theVector = new PointD (Math.Cos (angle * j / 180.0 * Math.PI)' Math.Sin (angle * j / 180.0 * Math.PI));  		PointD thePoint = theVector * innerRadius;  		// test these points  		//Position.VirtualMousePosition mouse = new Position.VirtualMousePosition((Point)thePoint);  		//ParameterizedMousePosition fakeMouse = new ParameterizedMousePosition(mouse' 20);// TODO: instrument from the computer  		//PointD vel = GetVelocity(fakeMouse) * Render.DrawHelper.SPEED_AMPLIFIER ;    		PointD vel = PointD.Empty;  		if (this is MagneticPointAttractionFilter) {  			vel = theVector * (m_Param.V.Y != 0 ? Math.Sign (m_Param.V.Y) : 1) * -Render.DrawHelper.SPEED_AMPLIFIER * (m_Param.C + 0.1);  		}  		if (this is RubberBandFilter) {  			vel = theVector * (m_Param.V.Y != 0 ? Math.Sign (m_Param.V.Y) : 1) * -Render.DrawHelper.SPEED_AMPLIFIER * (m_Param.C + 0.1) * Math.Pow (innerRadius / m_Param.PtRadius' 2);  		}  		if (this is OrbitFilter) {  			vel = PointD.Orthogonal (theVector) * (m_Param.V.X != 0 ? Math.Sign (m_Param.V.X) : 1) * Render.DrawHelper.SPEED_AMPLIFIER * (m_Param.C + 0.1);  		}  		if (this is OrbitFilter2) {  			vel = PointD.Orthogonal (theVector) * (m_Param.V.X != 0 ? Math.Sign (m_Param.V.X) : 1) * (m_Param.C + 0.1) * (innerRadius / 4);  		}  		if (this is OrbitFilter3) {  			vel = PointD.Orthogonal (theVector) * (m_Param.V.X != 0 ? Math.Sign (m_Param.V.X) : 1) * (m_Param.C + 0.1) * (innerRadius / 4);  		}  		drawMethods.DrawArrow (gc' r' thePoint' vel);  	}  }  
Magic Number,KinTemplates.Cursor.Tools,PointToolFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\PointToolFilter.cs,DrawArrowPoints,The following statement contains a magic number: for (int i = 1; i <= ptRings; i++) {  	double innerRadius = (Render.DrawHelper.SPEED_AMPLIFIER * 1.1 + 10) * i;  	for (int j = 0; j < 8; j++) {  		// put some points in the circle region  		PointD theVector = new PointD (Math.Cos (angle * j / 180.0 * Math.PI)' Math.Sin (angle * j / 180.0 * Math.PI));  		PointD thePoint = theVector * innerRadius;  		// test these points  		//Position.VirtualMousePosition mouse = new Position.VirtualMousePosition((Point)thePoint);  		//ParameterizedMousePosition fakeMouse = new ParameterizedMousePosition(mouse' 20);// TODO: instrument from the computer  		//PointD vel = GetVelocity(fakeMouse) * Render.DrawHelper.SPEED_AMPLIFIER ;    		PointD vel = PointD.Empty;  		if (this is MagneticPointAttractionFilter) {  			vel = theVector * (m_Param.V.Y != 0 ? Math.Sign (m_Param.V.Y) : 1) * -Render.DrawHelper.SPEED_AMPLIFIER * (m_Param.C + 0.1);  		}  		if (this is RubberBandFilter) {  			vel = theVector * (m_Param.V.Y != 0 ? Math.Sign (m_Param.V.Y) : 1) * -Render.DrawHelper.SPEED_AMPLIFIER * (m_Param.C + 0.1) * Math.Pow (innerRadius / m_Param.PtRadius' 2);  		}  		if (this is OrbitFilter) {  			vel = PointD.Orthogonal (theVector) * (m_Param.V.X != 0 ? Math.Sign (m_Param.V.X) : 1) * Render.DrawHelper.SPEED_AMPLIFIER * (m_Param.C + 0.1);  		}  		if (this is OrbitFilter2) {  			vel = PointD.Orthogonal (theVector) * (m_Param.V.X != 0 ? Math.Sign (m_Param.V.X) : 1) * (m_Param.C + 0.1) * (innerRadius / 4);  		}  		if (this is OrbitFilter3) {  			vel = PointD.Orthogonal (theVector) * (m_Param.V.X != 0 ? Math.Sign (m_Param.V.X) : 1) * (m_Param.C + 0.1) * (innerRadius / 4);  		}  		drawMethods.DrawArrow (gc' r' thePoint' vel);  	}  }  
Magic Number,KinTemplates.Cursor.Tools,PointToolFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\PointToolFilter.cs,DrawArrowPoints,The following statement contains a magic number: for (int i = 1; i <= ptRings; i++) {  	double innerRadius = (Render.DrawHelper.SPEED_AMPLIFIER * 1.1 + 10) * i;  	for (int j = 0; j < 8; j++) {  		// put some points in the circle region  		PointD theVector = new PointD (Math.Cos (angle * j / 180.0 * Math.PI)' Math.Sin (angle * j / 180.0 * Math.PI));  		PointD thePoint = theVector * innerRadius;  		// test these points  		//Position.VirtualMousePosition mouse = new Position.VirtualMousePosition((Point)thePoint);  		//ParameterizedMousePosition fakeMouse = new ParameterizedMousePosition(mouse' 20);// TODO: instrument from the computer  		//PointD vel = GetVelocity(fakeMouse) * Render.DrawHelper.SPEED_AMPLIFIER ;    		PointD vel = PointD.Empty;  		if (this is MagneticPointAttractionFilter) {  			vel = theVector * (m_Param.V.Y != 0 ? Math.Sign (m_Param.V.Y) : 1) * -Render.DrawHelper.SPEED_AMPLIFIER * (m_Param.C + 0.1);  		}  		if (this is RubberBandFilter) {  			vel = theVector * (m_Param.V.Y != 0 ? Math.Sign (m_Param.V.Y) : 1) * -Render.DrawHelper.SPEED_AMPLIFIER * (m_Param.C + 0.1) * Math.Pow (innerRadius / m_Param.PtRadius' 2);  		}  		if (this is OrbitFilter) {  			vel = PointD.Orthogonal (theVector) * (m_Param.V.X != 0 ? Math.Sign (m_Param.V.X) : 1) * Render.DrawHelper.SPEED_AMPLIFIER * (m_Param.C + 0.1);  		}  		if (this is OrbitFilter2) {  			vel = PointD.Orthogonal (theVector) * (m_Param.V.X != 0 ? Math.Sign (m_Param.V.X) : 1) * (m_Param.C + 0.1) * (innerRadius / 4);  		}  		if (this is OrbitFilter3) {  			vel = PointD.Orthogonal (theVector) * (m_Param.V.X != 0 ? Math.Sign (m_Param.V.X) : 1) * (m_Param.C + 0.1) * (innerRadius / 4);  		}  		drawMethods.DrawArrow (gc' r' thePoint' vel);  	}  }  
Magic Number,KinTemplates.Cursor.Tools,PointToolFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\PointToolFilter.cs,DrawArrowPoints,The following statement contains a magic number: for (int i = 1; i <= ptRings; i++) {  	double innerRadius = (Render.DrawHelper.SPEED_AMPLIFIER * 1.1 + 10) * i;  	for (int j = 0; j < 8; j++) {  		// put some points in the circle region  		PointD theVector = new PointD (Math.Cos (angle * j / 180.0 * Math.PI)' Math.Sin (angle * j / 180.0 * Math.PI));  		PointD thePoint = theVector * innerRadius;  		// test these points  		//Position.VirtualMousePosition mouse = new Position.VirtualMousePosition((Point)thePoint);  		//ParameterizedMousePosition fakeMouse = new ParameterizedMousePosition(mouse' 20);// TODO: instrument from the computer  		//PointD vel = GetVelocity(fakeMouse) * Render.DrawHelper.SPEED_AMPLIFIER ;    		PointD vel = PointD.Empty;  		if (this is MagneticPointAttractionFilter) {  			vel = theVector * (m_Param.V.Y != 0 ? Math.Sign (m_Param.V.Y) : 1) * -Render.DrawHelper.SPEED_AMPLIFIER * (m_Param.C + 0.1);  		}  		if (this is RubberBandFilter) {  			vel = theVector * (m_Param.V.Y != 0 ? Math.Sign (m_Param.V.Y) : 1) * -Render.DrawHelper.SPEED_AMPLIFIER * (m_Param.C + 0.1) * Math.Pow (innerRadius / m_Param.PtRadius' 2);  		}  		if (this is OrbitFilter) {  			vel = PointD.Orthogonal (theVector) * (m_Param.V.X != 0 ? Math.Sign (m_Param.V.X) : 1) * Render.DrawHelper.SPEED_AMPLIFIER * (m_Param.C + 0.1);  		}  		if (this is OrbitFilter2) {  			vel = PointD.Orthogonal (theVector) * (m_Param.V.X != 0 ? Math.Sign (m_Param.V.X) : 1) * (m_Param.C + 0.1) * (innerRadius / 4);  		}  		if (this is OrbitFilter3) {  			vel = PointD.Orthogonal (theVector) * (m_Param.V.X != 0 ? Math.Sign (m_Param.V.X) : 1) * (m_Param.C + 0.1) * (innerRadius / 4);  		}  		drawMethods.DrawArrow (gc' r' thePoint' vel);  	}  }  
Magic Number,KinTemplates.Cursor.Tools,PointToolFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\PointToolFilter.cs,DrawArrowPoints,The following statement contains a magic number: for (int i = 1; i <= ptRings; i++) {  	double innerRadius = (Render.DrawHelper.SPEED_AMPLIFIER * 1.1 + 10) * i;  	for (int j = 0; j < 8; j++) {  		// put some points in the circle region  		PointD theVector = new PointD (Math.Cos (angle * j / 180.0 * Math.PI)' Math.Sin (angle * j / 180.0 * Math.PI));  		PointD thePoint = theVector * innerRadius;  		// test these points  		//Position.VirtualMousePosition mouse = new Position.VirtualMousePosition((Point)thePoint);  		//ParameterizedMousePosition fakeMouse = new ParameterizedMousePosition(mouse' 20);// TODO: instrument from the computer  		//PointD vel = GetVelocity(fakeMouse) * Render.DrawHelper.SPEED_AMPLIFIER ;    		PointD vel = PointD.Empty;  		if (this is MagneticPointAttractionFilter) {  			vel = theVector * (m_Param.V.Y != 0 ? Math.Sign (m_Param.V.Y) : 1) * -Render.DrawHelper.SPEED_AMPLIFIER * (m_Param.C + 0.1);  		}  		if (this is RubberBandFilter) {  			vel = theVector * (m_Param.V.Y != 0 ? Math.Sign (m_Param.V.Y) : 1) * -Render.DrawHelper.SPEED_AMPLIFIER * (m_Param.C + 0.1) * Math.Pow (innerRadius / m_Param.PtRadius' 2);  		}  		if (this is OrbitFilter) {  			vel = PointD.Orthogonal (theVector) * (m_Param.V.X != 0 ? Math.Sign (m_Param.V.X) : 1) * Render.DrawHelper.SPEED_AMPLIFIER * (m_Param.C + 0.1);  		}  		if (this is OrbitFilter2) {  			vel = PointD.Orthogonal (theVector) * (m_Param.V.X != 0 ? Math.Sign (m_Param.V.X) : 1) * (m_Param.C + 0.1) * (innerRadius / 4);  		}  		if (this is OrbitFilter3) {  			vel = PointD.Orthogonal (theVector) * (m_Param.V.X != 0 ? Math.Sign (m_Param.V.X) : 1) * (m_Param.C + 0.1) * (innerRadius / 4);  		}  		drawMethods.DrawArrow (gc' r' thePoint' vel);  	}  }  
Magic Number,KinTemplates.Cursor.Tools,PointToolFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\PointToolFilter.cs,DrawArrowPoints,The following statement contains a magic number: for (int i = 1; i <= ptRings; i++) {  	double innerRadius = (Render.DrawHelper.SPEED_AMPLIFIER * 1.1 + 10) * i;  	for (int j = 0; j < 8; j++) {  		// put some points in the circle region  		PointD theVector = new PointD (Math.Cos (angle * j / 180.0 * Math.PI)' Math.Sin (angle * j / 180.0 * Math.PI));  		PointD thePoint = theVector * innerRadius;  		// test these points  		//Position.VirtualMousePosition mouse = new Position.VirtualMousePosition((Point)thePoint);  		//ParameterizedMousePosition fakeMouse = new ParameterizedMousePosition(mouse' 20);// TODO: instrument from the computer  		//PointD vel = GetVelocity(fakeMouse) * Render.DrawHelper.SPEED_AMPLIFIER ;    		PointD vel = PointD.Empty;  		if (this is MagneticPointAttractionFilter) {  			vel = theVector * (m_Param.V.Y != 0 ? Math.Sign (m_Param.V.Y) : 1) * -Render.DrawHelper.SPEED_AMPLIFIER * (m_Param.C + 0.1);  		}  		if (this is RubberBandFilter) {  			vel = theVector * (m_Param.V.Y != 0 ? Math.Sign (m_Param.V.Y) : 1) * -Render.DrawHelper.SPEED_AMPLIFIER * (m_Param.C + 0.1) * Math.Pow (innerRadius / m_Param.PtRadius' 2);  		}  		if (this is OrbitFilter) {  			vel = PointD.Orthogonal (theVector) * (m_Param.V.X != 0 ? Math.Sign (m_Param.V.X) : 1) * Render.DrawHelper.SPEED_AMPLIFIER * (m_Param.C + 0.1);  		}  		if (this is OrbitFilter2) {  			vel = PointD.Orthogonal (theVector) * (m_Param.V.X != 0 ? Math.Sign (m_Param.V.X) : 1) * (m_Param.C + 0.1) * (innerRadius / 4);  		}  		if (this is OrbitFilter3) {  			vel = PointD.Orthogonal (theVector) * (m_Param.V.X != 0 ? Math.Sign (m_Param.V.X) : 1) * (m_Param.C + 0.1) * (innerRadius / 4);  		}  		drawMethods.DrawArrow (gc' r' thePoint' vel);  	}  }  
Magic Number,KinTemplates.Cursor.Tools,PointToolFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\PointToolFilter.cs,DrawArrowPoints,The following statement contains a magic number: for (int i = 1; i <= ptRings; i++) {  	double innerRadius = (Render.DrawHelper.SPEED_AMPLIFIER * 1.1 + 10) * i;  	for (int j = 0; j < 8; j++) {  		// put some points in the circle region  		PointD theVector = new PointD (Math.Cos (angle * j / 180.0 * Math.PI)' Math.Sin (angle * j / 180.0 * Math.PI));  		PointD thePoint = theVector * innerRadius;  		// test these points  		//Position.VirtualMousePosition mouse = new Position.VirtualMousePosition((Point)thePoint);  		//ParameterizedMousePosition fakeMouse = new ParameterizedMousePosition(mouse' 20);// TODO: instrument from the computer  		//PointD vel = GetVelocity(fakeMouse) * Render.DrawHelper.SPEED_AMPLIFIER ;    		PointD vel = PointD.Empty;  		if (this is MagneticPointAttractionFilter) {  			vel = theVector * (m_Param.V.Y != 0 ? Math.Sign (m_Param.V.Y) : 1) * -Render.DrawHelper.SPEED_AMPLIFIER * (m_Param.C + 0.1);  		}  		if (this is RubberBandFilter) {  			vel = theVector * (m_Param.V.Y != 0 ? Math.Sign (m_Param.V.Y) : 1) * -Render.DrawHelper.SPEED_AMPLIFIER * (m_Param.C + 0.1) * Math.Pow (innerRadius / m_Param.PtRadius' 2);  		}  		if (this is OrbitFilter) {  			vel = PointD.Orthogonal (theVector) * (m_Param.V.X != 0 ? Math.Sign (m_Param.V.X) : 1) * Render.DrawHelper.SPEED_AMPLIFIER * (m_Param.C + 0.1);  		}  		if (this is OrbitFilter2) {  			vel = PointD.Orthogonal (theVector) * (m_Param.V.X != 0 ? Math.Sign (m_Param.V.X) : 1) * (m_Param.C + 0.1) * (innerRadius / 4);  		}  		if (this is OrbitFilter3) {  			vel = PointD.Orthogonal (theVector) * (m_Param.V.X != 0 ? Math.Sign (m_Param.V.X) : 1) * (m_Param.C + 0.1) * (innerRadius / 4);  		}  		drawMethods.DrawArrow (gc' r' thePoint' vel);  	}  }  
Magic Number,KinTemplates.Cursor.Tools,PointToolFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\PointToolFilter.cs,DrawArrowPoints,The following statement contains a magic number: for (int i = 1; i <= ptRings; i++) {  	double innerRadius = (Render.DrawHelper.SPEED_AMPLIFIER * 1.1 + 10) * i;  	for (int j = 0; j < 8; j++) {  		// put some points in the circle region  		PointD theVector = new PointD (Math.Cos (angle * j / 180.0 * Math.PI)' Math.Sin (angle * j / 180.0 * Math.PI));  		PointD thePoint = theVector * innerRadius;  		// test these points  		//Position.VirtualMousePosition mouse = new Position.VirtualMousePosition((Point)thePoint);  		//ParameterizedMousePosition fakeMouse = new ParameterizedMousePosition(mouse' 20);// TODO: instrument from the computer  		//PointD vel = GetVelocity(fakeMouse) * Render.DrawHelper.SPEED_AMPLIFIER ;    		PointD vel = PointD.Empty;  		if (this is MagneticPointAttractionFilter) {  			vel = theVector * (m_Param.V.Y != 0 ? Math.Sign (m_Param.V.Y) : 1) * -Render.DrawHelper.SPEED_AMPLIFIER * (m_Param.C + 0.1);  		}  		if (this is RubberBandFilter) {  			vel = theVector * (m_Param.V.Y != 0 ? Math.Sign (m_Param.V.Y) : 1) * -Render.DrawHelper.SPEED_AMPLIFIER * (m_Param.C + 0.1) * Math.Pow (innerRadius / m_Param.PtRadius' 2);  		}  		if (this is OrbitFilter) {  			vel = PointD.Orthogonal (theVector) * (m_Param.V.X != 0 ? Math.Sign (m_Param.V.X) : 1) * Render.DrawHelper.SPEED_AMPLIFIER * (m_Param.C + 0.1);  		}  		if (this is OrbitFilter2) {  			vel = PointD.Orthogonal (theVector) * (m_Param.V.X != 0 ? Math.Sign (m_Param.V.X) : 1) * (m_Param.C + 0.1) * (innerRadius / 4);  		}  		if (this is OrbitFilter3) {  			vel = PointD.Orthogonal (theVector) * (m_Param.V.X != 0 ? Math.Sign (m_Param.V.X) : 1) * (m_Param.C + 0.1) * (innerRadius / 4);  		}  		drawMethods.DrawArrow (gc' r' thePoint' vel);  	}  }  
Magic Number,KinTemplates.Cursor.Tools,PointToolFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\PointToolFilter.cs,DrawArrowPoints,The following statement contains a magic number: for (int i = 1; i <= ptRings; i++) {  	double innerRadius = (Render.DrawHelper.SPEED_AMPLIFIER * 1.1 + 10) * i;  	for (int j = 0; j < 8; j++) {  		// put some points in the circle region  		PointD theVector = new PointD (Math.Cos (angle * j / 180.0 * Math.PI)' Math.Sin (angle * j / 180.0 * Math.PI));  		PointD thePoint = theVector * innerRadius;  		// test these points  		//Position.VirtualMousePosition mouse = new Position.VirtualMousePosition((Point)thePoint);  		//ParameterizedMousePosition fakeMouse = new ParameterizedMousePosition(mouse' 20);// TODO: instrument from the computer  		//PointD vel = GetVelocity(fakeMouse) * Render.DrawHelper.SPEED_AMPLIFIER ;    		PointD vel = PointD.Empty;  		if (this is MagneticPointAttractionFilter) {  			vel = theVector * (m_Param.V.Y != 0 ? Math.Sign (m_Param.V.Y) : 1) * -Render.DrawHelper.SPEED_AMPLIFIER * (m_Param.C + 0.1);  		}  		if (this is RubberBandFilter) {  			vel = theVector * (m_Param.V.Y != 0 ? Math.Sign (m_Param.V.Y) : 1) * -Render.DrawHelper.SPEED_AMPLIFIER * (m_Param.C + 0.1) * Math.Pow (innerRadius / m_Param.PtRadius' 2);  		}  		if (this is OrbitFilter) {  			vel = PointD.Orthogonal (theVector) * (m_Param.V.X != 0 ? Math.Sign (m_Param.V.X) : 1) * Render.DrawHelper.SPEED_AMPLIFIER * (m_Param.C + 0.1);  		}  		if (this is OrbitFilter2) {  			vel = PointD.Orthogonal (theVector) * (m_Param.V.X != 0 ? Math.Sign (m_Param.V.X) : 1) * (m_Param.C + 0.1) * (innerRadius / 4);  		}  		if (this is OrbitFilter3) {  			vel = PointD.Orthogonal (theVector) * (m_Param.V.X != 0 ? Math.Sign (m_Param.V.X) : 1) * (m_Param.C + 0.1) * (innerRadius / 4);  		}  		drawMethods.DrawArrow (gc' r' thePoint' vel);  	}  }  
Magic Number,KinTemplates.Cursor.Tools,PointToolFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\PointToolFilter.cs,DrawArrowPoints,The following statement contains a magic number: for (int i = 1; i <= ptRings; i++) {  	double innerRadius = (Render.DrawHelper.SPEED_AMPLIFIER * 1.1 + 10) * i;  	for (int j = 0; j < 8; j++) {  		// put some points in the circle region  		PointD theVector = new PointD (Math.Cos (angle * j / 180.0 * Math.PI)' Math.Sin (angle * j / 180.0 * Math.PI));  		PointD thePoint = theVector * innerRadius;  		// test these points  		//Position.VirtualMousePosition mouse = new Position.VirtualMousePosition((Point)thePoint);  		//ParameterizedMousePosition fakeMouse = new ParameterizedMousePosition(mouse' 20);// TODO: instrument from the computer  		//PointD vel = GetVelocity(fakeMouse) * Render.DrawHelper.SPEED_AMPLIFIER ;    		PointD vel = PointD.Empty;  		if (this is MagneticPointAttractionFilter) {  			vel = theVector * (m_Param.V.Y != 0 ? Math.Sign (m_Param.V.Y) : 1) * -Render.DrawHelper.SPEED_AMPLIFIER * (m_Param.C + 0.1);  		}  		if (this is RubberBandFilter) {  			vel = theVector * (m_Param.V.Y != 0 ? Math.Sign (m_Param.V.Y) : 1) * -Render.DrawHelper.SPEED_AMPLIFIER * (m_Param.C + 0.1) * Math.Pow (innerRadius / m_Param.PtRadius' 2);  		}  		if (this is OrbitFilter) {  			vel = PointD.Orthogonal (theVector) * (m_Param.V.X != 0 ? Math.Sign (m_Param.V.X) : 1) * Render.DrawHelper.SPEED_AMPLIFIER * (m_Param.C + 0.1);  		}  		if (this is OrbitFilter2) {  			vel = PointD.Orthogonal (theVector) * (m_Param.V.X != 0 ? Math.Sign (m_Param.V.X) : 1) * (m_Param.C + 0.1) * (innerRadius / 4);  		}  		if (this is OrbitFilter3) {  			vel = PointD.Orthogonal (theVector) * (m_Param.V.X != 0 ? Math.Sign (m_Param.V.X) : 1) * (m_Param.C + 0.1) * (innerRadius / 4);  		}  		drawMethods.DrawArrow (gc' r' thePoint' vel);  	}  }  
Magic Number,KinTemplates.Cursor.Tools,PointToolFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\PointToolFilter.cs,DrawArrowPoints,The following statement contains a magic number: for (int j = 0; j < 8; j++) {  	// put some points in the circle region  	PointD theVector = new PointD (Math.Cos (angle * j / 180.0 * Math.PI)' Math.Sin (angle * j / 180.0 * Math.PI));  	PointD thePoint = theVector * innerRadius;  	// test these points  	//Position.VirtualMousePosition mouse = new Position.VirtualMousePosition((Point)thePoint);  	//ParameterizedMousePosition fakeMouse = new ParameterizedMousePosition(mouse' 20);// TODO: instrument from the computer  	//PointD vel = GetVelocity(fakeMouse) * Render.DrawHelper.SPEED_AMPLIFIER ;    	PointD vel = PointD.Empty;  	if (this is MagneticPointAttractionFilter) {  		vel = theVector * (m_Param.V.Y != 0 ? Math.Sign (m_Param.V.Y) : 1) * -Render.DrawHelper.SPEED_AMPLIFIER * (m_Param.C + 0.1);  	}  	if (this is RubberBandFilter) {  		vel = theVector * (m_Param.V.Y != 0 ? Math.Sign (m_Param.V.Y) : 1) * -Render.DrawHelper.SPEED_AMPLIFIER * (m_Param.C + 0.1) * Math.Pow (innerRadius / m_Param.PtRadius' 2);  	}  	if (this is OrbitFilter) {  		vel = PointD.Orthogonal (theVector) * (m_Param.V.X != 0 ? Math.Sign (m_Param.V.X) : 1) * Render.DrawHelper.SPEED_AMPLIFIER * (m_Param.C + 0.1);  	}  	if (this is OrbitFilter2) {  		vel = PointD.Orthogonal (theVector) * (m_Param.V.X != 0 ? Math.Sign (m_Param.V.X) : 1) * (m_Param.C + 0.1) * (innerRadius / 4);  	}  	if (this is OrbitFilter3) {  		vel = PointD.Orthogonal (theVector) * (m_Param.V.X != 0 ? Math.Sign (m_Param.V.X) : 1) * (m_Param.C + 0.1) * (innerRadius / 4);  	}  	drawMethods.DrawArrow (gc' r' thePoint' vel);  }  
Magic Number,KinTemplates.Cursor.Tools,PointToolFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\PointToolFilter.cs,DrawArrowPoints,The following statement contains a magic number: for (int j = 0; j < 8; j++) {  	// put some points in the circle region  	PointD theVector = new PointD (Math.Cos (angle * j / 180.0 * Math.PI)' Math.Sin (angle * j / 180.0 * Math.PI));  	PointD thePoint = theVector * innerRadius;  	// test these points  	//Position.VirtualMousePosition mouse = new Position.VirtualMousePosition((Point)thePoint);  	//ParameterizedMousePosition fakeMouse = new ParameterizedMousePosition(mouse' 20);// TODO: instrument from the computer  	//PointD vel = GetVelocity(fakeMouse) * Render.DrawHelper.SPEED_AMPLIFIER ;    	PointD vel = PointD.Empty;  	if (this is MagneticPointAttractionFilter) {  		vel = theVector * (m_Param.V.Y != 0 ? Math.Sign (m_Param.V.Y) : 1) * -Render.DrawHelper.SPEED_AMPLIFIER * (m_Param.C + 0.1);  	}  	if (this is RubberBandFilter) {  		vel = theVector * (m_Param.V.Y != 0 ? Math.Sign (m_Param.V.Y) : 1) * -Render.DrawHelper.SPEED_AMPLIFIER * (m_Param.C + 0.1) * Math.Pow (innerRadius / m_Param.PtRadius' 2);  	}  	if (this is OrbitFilter) {  		vel = PointD.Orthogonal (theVector) * (m_Param.V.X != 0 ? Math.Sign (m_Param.V.X) : 1) * Render.DrawHelper.SPEED_AMPLIFIER * (m_Param.C + 0.1);  	}  	if (this is OrbitFilter2) {  		vel = PointD.Orthogonal (theVector) * (m_Param.V.X != 0 ? Math.Sign (m_Param.V.X) : 1) * (m_Param.C + 0.1) * (innerRadius / 4);  	}  	if (this is OrbitFilter3) {  		vel = PointD.Orthogonal (theVector) * (m_Param.V.X != 0 ? Math.Sign (m_Param.V.X) : 1) * (m_Param.C + 0.1) * (innerRadius / 4);  	}  	drawMethods.DrawArrow (gc' r' thePoint' vel);  }  
Magic Number,KinTemplates.Cursor.Tools,PointToolFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\PointToolFilter.cs,DrawArrowPoints,The following statement contains a magic number: for (int j = 0; j < 8; j++) {  	// put some points in the circle region  	PointD theVector = new PointD (Math.Cos (angle * j / 180.0 * Math.PI)' Math.Sin (angle * j / 180.0 * Math.PI));  	PointD thePoint = theVector * innerRadius;  	// test these points  	//Position.VirtualMousePosition mouse = new Position.VirtualMousePosition((Point)thePoint);  	//ParameterizedMousePosition fakeMouse = new ParameterizedMousePosition(mouse' 20);// TODO: instrument from the computer  	//PointD vel = GetVelocity(fakeMouse) * Render.DrawHelper.SPEED_AMPLIFIER ;    	PointD vel = PointD.Empty;  	if (this is MagneticPointAttractionFilter) {  		vel = theVector * (m_Param.V.Y != 0 ? Math.Sign (m_Param.V.Y) : 1) * -Render.DrawHelper.SPEED_AMPLIFIER * (m_Param.C + 0.1);  	}  	if (this is RubberBandFilter) {  		vel = theVector * (m_Param.V.Y != 0 ? Math.Sign (m_Param.V.Y) : 1) * -Render.DrawHelper.SPEED_AMPLIFIER * (m_Param.C + 0.1) * Math.Pow (innerRadius / m_Param.PtRadius' 2);  	}  	if (this is OrbitFilter) {  		vel = PointD.Orthogonal (theVector) * (m_Param.V.X != 0 ? Math.Sign (m_Param.V.X) : 1) * Render.DrawHelper.SPEED_AMPLIFIER * (m_Param.C + 0.1);  	}  	if (this is OrbitFilter2) {  		vel = PointD.Orthogonal (theVector) * (m_Param.V.X != 0 ? Math.Sign (m_Param.V.X) : 1) * (m_Param.C + 0.1) * (innerRadius / 4);  	}  	if (this is OrbitFilter3) {  		vel = PointD.Orthogonal (theVector) * (m_Param.V.X != 0 ? Math.Sign (m_Param.V.X) : 1) * (m_Param.C + 0.1) * (innerRadius / 4);  	}  	drawMethods.DrawArrow (gc' r' thePoint' vel);  }  
Magic Number,KinTemplates.Cursor.Tools,PointToolFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\PointToolFilter.cs,DrawArrowPoints,The following statement contains a magic number: for (int j = 0; j < 8; j++) {  	// put some points in the circle region  	PointD theVector = new PointD (Math.Cos (angle * j / 180.0 * Math.PI)' Math.Sin (angle * j / 180.0 * Math.PI));  	PointD thePoint = theVector * innerRadius;  	// test these points  	//Position.VirtualMousePosition mouse = new Position.VirtualMousePosition((Point)thePoint);  	//ParameterizedMousePosition fakeMouse = new ParameterizedMousePosition(mouse' 20);// TODO: instrument from the computer  	//PointD vel = GetVelocity(fakeMouse) * Render.DrawHelper.SPEED_AMPLIFIER ;    	PointD vel = PointD.Empty;  	if (this is MagneticPointAttractionFilter) {  		vel = theVector * (m_Param.V.Y != 0 ? Math.Sign (m_Param.V.Y) : 1) * -Render.DrawHelper.SPEED_AMPLIFIER * (m_Param.C + 0.1);  	}  	if (this is RubberBandFilter) {  		vel = theVector * (m_Param.V.Y != 0 ? Math.Sign (m_Param.V.Y) : 1) * -Render.DrawHelper.SPEED_AMPLIFIER * (m_Param.C + 0.1) * Math.Pow (innerRadius / m_Param.PtRadius' 2);  	}  	if (this is OrbitFilter) {  		vel = PointD.Orthogonal (theVector) * (m_Param.V.X != 0 ? Math.Sign (m_Param.V.X) : 1) * Render.DrawHelper.SPEED_AMPLIFIER * (m_Param.C + 0.1);  	}  	if (this is OrbitFilter2) {  		vel = PointD.Orthogonal (theVector) * (m_Param.V.X != 0 ? Math.Sign (m_Param.V.X) : 1) * (m_Param.C + 0.1) * (innerRadius / 4);  	}  	if (this is OrbitFilter3) {  		vel = PointD.Orthogonal (theVector) * (m_Param.V.X != 0 ? Math.Sign (m_Param.V.X) : 1) * (m_Param.C + 0.1) * (innerRadius / 4);  	}  	drawMethods.DrawArrow (gc' r' thePoint' vel);  }  
Magic Number,KinTemplates.Cursor.Tools,PointToolFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\PointToolFilter.cs,DrawArrowPoints,The following statement contains a magic number: for (int j = 0; j < 8; j++) {  	// put some points in the circle region  	PointD theVector = new PointD (Math.Cos (angle * j / 180.0 * Math.PI)' Math.Sin (angle * j / 180.0 * Math.PI));  	PointD thePoint = theVector * innerRadius;  	// test these points  	//Position.VirtualMousePosition mouse = new Position.VirtualMousePosition((Point)thePoint);  	//ParameterizedMousePosition fakeMouse = new ParameterizedMousePosition(mouse' 20);// TODO: instrument from the computer  	//PointD vel = GetVelocity(fakeMouse) * Render.DrawHelper.SPEED_AMPLIFIER ;    	PointD vel = PointD.Empty;  	if (this is MagneticPointAttractionFilter) {  		vel = theVector * (m_Param.V.Y != 0 ? Math.Sign (m_Param.V.Y) : 1) * -Render.DrawHelper.SPEED_AMPLIFIER * (m_Param.C + 0.1);  	}  	if (this is RubberBandFilter) {  		vel = theVector * (m_Param.V.Y != 0 ? Math.Sign (m_Param.V.Y) : 1) * -Render.DrawHelper.SPEED_AMPLIFIER * (m_Param.C + 0.1) * Math.Pow (innerRadius / m_Param.PtRadius' 2);  	}  	if (this is OrbitFilter) {  		vel = PointD.Orthogonal (theVector) * (m_Param.V.X != 0 ? Math.Sign (m_Param.V.X) : 1) * Render.DrawHelper.SPEED_AMPLIFIER * (m_Param.C + 0.1);  	}  	if (this is OrbitFilter2) {  		vel = PointD.Orthogonal (theVector) * (m_Param.V.X != 0 ? Math.Sign (m_Param.V.X) : 1) * (m_Param.C + 0.1) * (innerRadius / 4);  	}  	if (this is OrbitFilter3) {  		vel = PointD.Orthogonal (theVector) * (m_Param.V.X != 0 ? Math.Sign (m_Param.V.X) : 1) * (m_Param.C + 0.1) * (innerRadius / 4);  	}  	drawMethods.DrawArrow (gc' r' thePoint' vel);  }  
Magic Number,KinTemplates.Cursor.Tools,PointToolFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\PointToolFilter.cs,DrawArrowPoints,The following statement contains a magic number: for (int j = 0; j < 8; j++) {  	// put some points in the circle region  	PointD theVector = new PointD (Math.Cos (angle * j / 180.0 * Math.PI)' Math.Sin (angle * j / 180.0 * Math.PI));  	PointD thePoint = theVector * innerRadius;  	// test these points  	//Position.VirtualMousePosition mouse = new Position.VirtualMousePosition((Point)thePoint);  	//ParameterizedMousePosition fakeMouse = new ParameterizedMousePosition(mouse' 20);// TODO: instrument from the computer  	//PointD vel = GetVelocity(fakeMouse) * Render.DrawHelper.SPEED_AMPLIFIER ;    	PointD vel = PointD.Empty;  	if (this is MagneticPointAttractionFilter) {  		vel = theVector * (m_Param.V.Y != 0 ? Math.Sign (m_Param.V.Y) : 1) * -Render.DrawHelper.SPEED_AMPLIFIER * (m_Param.C + 0.1);  	}  	if (this is RubberBandFilter) {  		vel = theVector * (m_Param.V.Y != 0 ? Math.Sign (m_Param.V.Y) : 1) * -Render.DrawHelper.SPEED_AMPLIFIER * (m_Param.C + 0.1) * Math.Pow (innerRadius / m_Param.PtRadius' 2);  	}  	if (this is OrbitFilter) {  		vel = PointD.Orthogonal (theVector) * (m_Param.V.X != 0 ? Math.Sign (m_Param.V.X) : 1) * Render.DrawHelper.SPEED_AMPLIFIER * (m_Param.C + 0.1);  	}  	if (this is OrbitFilter2) {  		vel = PointD.Orthogonal (theVector) * (m_Param.V.X != 0 ? Math.Sign (m_Param.V.X) : 1) * (m_Param.C + 0.1) * (innerRadius / 4);  	}  	if (this is OrbitFilter3) {  		vel = PointD.Orthogonal (theVector) * (m_Param.V.X != 0 ? Math.Sign (m_Param.V.X) : 1) * (m_Param.C + 0.1) * (innerRadius / 4);  	}  	drawMethods.DrawArrow (gc' r' thePoint' vel);  }  
Magic Number,KinTemplates.Cursor.Tools,PointToolFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\PointToolFilter.cs,DrawArrowPoints,The following statement contains a magic number: for (int j = 0; j < 8; j++) {  	// put some points in the circle region  	PointD theVector = new PointD (Math.Cos (angle * j / 180.0 * Math.PI)' Math.Sin (angle * j / 180.0 * Math.PI));  	PointD thePoint = theVector * innerRadius;  	// test these points  	//Position.VirtualMousePosition mouse = new Position.VirtualMousePosition((Point)thePoint);  	//ParameterizedMousePosition fakeMouse = new ParameterizedMousePosition(mouse' 20);// TODO: instrument from the computer  	//PointD vel = GetVelocity(fakeMouse) * Render.DrawHelper.SPEED_AMPLIFIER ;    	PointD vel = PointD.Empty;  	if (this is MagneticPointAttractionFilter) {  		vel = theVector * (m_Param.V.Y != 0 ? Math.Sign (m_Param.V.Y) : 1) * -Render.DrawHelper.SPEED_AMPLIFIER * (m_Param.C + 0.1);  	}  	if (this is RubberBandFilter) {  		vel = theVector * (m_Param.V.Y != 0 ? Math.Sign (m_Param.V.Y) : 1) * -Render.DrawHelper.SPEED_AMPLIFIER * (m_Param.C + 0.1) * Math.Pow (innerRadius / m_Param.PtRadius' 2);  	}  	if (this is OrbitFilter) {  		vel = PointD.Orthogonal (theVector) * (m_Param.V.X != 0 ? Math.Sign (m_Param.V.X) : 1) * Render.DrawHelper.SPEED_AMPLIFIER * (m_Param.C + 0.1);  	}  	if (this is OrbitFilter2) {  		vel = PointD.Orthogonal (theVector) * (m_Param.V.X != 0 ? Math.Sign (m_Param.V.X) : 1) * (m_Param.C + 0.1) * (innerRadius / 4);  	}  	if (this is OrbitFilter3) {  		vel = PointD.Orthogonal (theVector) * (m_Param.V.X != 0 ? Math.Sign (m_Param.V.X) : 1) * (m_Param.C + 0.1) * (innerRadius / 4);  	}  	drawMethods.DrawArrow (gc' r' thePoint' vel);  }  
Magic Number,KinTemplates.Cursor.Tools,PointToolFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\PointToolFilter.cs,DrawArrowPoints,The following statement contains a magic number: for (int j = 0; j < 8; j++) {  	// put some points in the circle region  	PointD theVector = new PointD (Math.Cos (angle * j / 180.0 * Math.PI)' Math.Sin (angle * j / 180.0 * Math.PI));  	PointD thePoint = theVector * innerRadius;  	// test these points  	//Position.VirtualMousePosition mouse = new Position.VirtualMousePosition((Point)thePoint);  	//ParameterizedMousePosition fakeMouse = new ParameterizedMousePosition(mouse' 20);// TODO: instrument from the computer  	//PointD vel = GetVelocity(fakeMouse) * Render.DrawHelper.SPEED_AMPLIFIER ;    	PointD vel = PointD.Empty;  	if (this is MagneticPointAttractionFilter) {  		vel = theVector * (m_Param.V.Y != 0 ? Math.Sign (m_Param.V.Y) : 1) * -Render.DrawHelper.SPEED_AMPLIFIER * (m_Param.C + 0.1);  	}  	if (this is RubberBandFilter) {  		vel = theVector * (m_Param.V.Y != 0 ? Math.Sign (m_Param.V.Y) : 1) * -Render.DrawHelper.SPEED_AMPLIFIER * (m_Param.C + 0.1) * Math.Pow (innerRadius / m_Param.PtRadius' 2);  	}  	if (this is OrbitFilter) {  		vel = PointD.Orthogonal (theVector) * (m_Param.V.X != 0 ? Math.Sign (m_Param.V.X) : 1) * Render.DrawHelper.SPEED_AMPLIFIER * (m_Param.C + 0.1);  	}  	if (this is OrbitFilter2) {  		vel = PointD.Orthogonal (theVector) * (m_Param.V.X != 0 ? Math.Sign (m_Param.V.X) : 1) * (m_Param.C + 0.1) * (innerRadius / 4);  	}  	if (this is OrbitFilter3) {  		vel = PointD.Orthogonal (theVector) * (m_Param.V.X != 0 ? Math.Sign (m_Param.V.X) : 1) * (m_Param.C + 0.1) * (innerRadius / 4);  	}  	drawMethods.DrawArrow (gc' r' thePoint' vel);  }  
Magic Number,KinTemplates.Cursor.Tools,PointToolFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\PointToolFilter.cs,DrawArrowPoints,The following statement contains a magic number: for (int j = 0; j < 8; j++) {  	// put some points in the circle region  	PointD theVector = new PointD (Math.Cos (angle * j / 180.0 * Math.PI)' Math.Sin (angle * j / 180.0 * Math.PI));  	PointD thePoint = theVector * innerRadius;  	// test these points  	//Position.VirtualMousePosition mouse = new Position.VirtualMousePosition((Point)thePoint);  	//ParameterizedMousePosition fakeMouse = new ParameterizedMousePosition(mouse' 20);// TODO: instrument from the computer  	//PointD vel = GetVelocity(fakeMouse) * Render.DrawHelper.SPEED_AMPLIFIER ;    	PointD vel = PointD.Empty;  	if (this is MagneticPointAttractionFilter) {  		vel = theVector * (m_Param.V.Y != 0 ? Math.Sign (m_Param.V.Y) : 1) * -Render.DrawHelper.SPEED_AMPLIFIER * (m_Param.C + 0.1);  	}  	if (this is RubberBandFilter) {  		vel = theVector * (m_Param.V.Y != 0 ? Math.Sign (m_Param.V.Y) : 1) * -Render.DrawHelper.SPEED_AMPLIFIER * (m_Param.C + 0.1) * Math.Pow (innerRadius / m_Param.PtRadius' 2);  	}  	if (this is OrbitFilter) {  		vel = PointD.Orthogonal (theVector) * (m_Param.V.X != 0 ? Math.Sign (m_Param.V.X) : 1) * Render.DrawHelper.SPEED_AMPLIFIER * (m_Param.C + 0.1);  	}  	if (this is OrbitFilter2) {  		vel = PointD.Orthogonal (theVector) * (m_Param.V.X != 0 ? Math.Sign (m_Param.V.X) : 1) * (m_Param.C + 0.1) * (innerRadius / 4);  	}  	if (this is OrbitFilter3) {  		vel = PointD.Orthogonal (theVector) * (m_Param.V.X != 0 ? Math.Sign (m_Param.V.X) : 1) * (m_Param.C + 0.1) * (innerRadius / 4);  	}  	drawMethods.DrawArrow (gc' r' thePoint' vel);  }  
Magic Number,KinTemplates.Cursor.Tools,PointToolFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\PointToolFilter.cs,DrawArrowPoints,The following statement contains a magic number: for (int j = 0; j < 8; j++) {  	// put some points in the circle region  	PointD theVector = new PointD (Math.Cos (angle * j / 180.0 * Math.PI)' Math.Sin (angle * j / 180.0 * Math.PI));  	PointD thePoint = theVector * innerRadius;  	// test these points  	//Position.VirtualMousePosition mouse = new Position.VirtualMousePosition((Point)thePoint);  	//ParameterizedMousePosition fakeMouse = new ParameterizedMousePosition(mouse' 20);// TODO: instrument from the computer  	//PointD vel = GetVelocity(fakeMouse) * Render.DrawHelper.SPEED_AMPLIFIER ;    	PointD vel = PointD.Empty;  	if (this is MagneticPointAttractionFilter) {  		vel = theVector * (m_Param.V.Y != 0 ? Math.Sign (m_Param.V.Y) : 1) * -Render.DrawHelper.SPEED_AMPLIFIER * (m_Param.C + 0.1);  	}  	if (this is RubberBandFilter) {  		vel = theVector * (m_Param.V.Y != 0 ? Math.Sign (m_Param.V.Y) : 1) * -Render.DrawHelper.SPEED_AMPLIFIER * (m_Param.C + 0.1) * Math.Pow (innerRadius / m_Param.PtRadius' 2);  	}  	if (this is OrbitFilter) {  		vel = PointD.Orthogonal (theVector) * (m_Param.V.X != 0 ? Math.Sign (m_Param.V.X) : 1) * Render.DrawHelper.SPEED_AMPLIFIER * (m_Param.C + 0.1);  	}  	if (this is OrbitFilter2) {  		vel = PointD.Orthogonal (theVector) * (m_Param.V.X != 0 ? Math.Sign (m_Param.V.X) : 1) * (m_Param.C + 0.1) * (innerRadius / 4);  	}  	if (this is OrbitFilter3) {  		vel = PointD.Orthogonal (theVector) * (m_Param.V.X != 0 ? Math.Sign (m_Param.V.X) : 1) * (m_Param.C + 0.1) * (innerRadius / 4);  	}  	drawMethods.DrawArrow (gc' r' thePoint' vel);  }  
Magic Number,KinTemplates.Cursor.Tools,PointToolFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\PointToolFilter.cs,DrawArrowPoints,The following statement contains a magic number: for (int j = 0; j < 8; j++) {  	// put some points in the circle region  	PointD theVector = new PointD (Math.Cos (angle * j / 180.0 * Math.PI)' Math.Sin (angle * j / 180.0 * Math.PI));  	PointD thePoint = theVector * innerRadius;  	// test these points  	//Position.VirtualMousePosition mouse = new Position.VirtualMousePosition((Point)thePoint);  	//ParameterizedMousePosition fakeMouse = new ParameterizedMousePosition(mouse' 20);// TODO: instrument from the computer  	//PointD vel = GetVelocity(fakeMouse) * Render.DrawHelper.SPEED_AMPLIFIER ;    	PointD vel = PointD.Empty;  	if (this is MagneticPointAttractionFilter) {  		vel = theVector * (m_Param.V.Y != 0 ? Math.Sign (m_Param.V.Y) : 1) * -Render.DrawHelper.SPEED_AMPLIFIER * (m_Param.C + 0.1);  	}  	if (this is RubberBandFilter) {  		vel = theVector * (m_Param.V.Y != 0 ? Math.Sign (m_Param.V.Y) : 1) * -Render.DrawHelper.SPEED_AMPLIFIER * (m_Param.C + 0.1) * Math.Pow (innerRadius / m_Param.PtRadius' 2);  	}  	if (this is OrbitFilter) {  		vel = PointD.Orthogonal (theVector) * (m_Param.V.X != 0 ? Math.Sign (m_Param.V.X) : 1) * Render.DrawHelper.SPEED_AMPLIFIER * (m_Param.C + 0.1);  	}  	if (this is OrbitFilter2) {  		vel = PointD.Orthogonal (theVector) * (m_Param.V.X != 0 ? Math.Sign (m_Param.V.X) : 1) * (m_Param.C + 0.1) * (innerRadius / 4);  	}  	if (this is OrbitFilter3) {  		vel = PointD.Orthogonal (theVector) * (m_Param.V.X != 0 ? Math.Sign (m_Param.V.X) : 1) * (m_Param.C + 0.1) * (innerRadius / 4);  	}  	drawMethods.DrawArrow (gc' r' thePoint' vel);  }  
Magic Number,KinTemplates.Cursor.Tools,PointToolFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\PointToolFilter.cs,DrawArrowPoints,The following statement contains a magic number: if (this is MagneticPointAttractionFilter) {  	vel = theVector * (m_Param.V.Y != 0 ? Math.Sign (m_Param.V.Y) : 1) * -Render.DrawHelper.SPEED_AMPLIFIER * (m_Param.C + 0.1);  }  
Magic Number,KinTemplates.Cursor.Tools,PointToolFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\PointToolFilter.cs,DrawArrowPoints,The following statement contains a magic number: vel = theVector * (m_Param.V.Y != 0 ? Math.Sign (m_Param.V.Y) : 1) * -Render.DrawHelper.SPEED_AMPLIFIER * (m_Param.C + 0.1);  
Magic Number,KinTemplates.Cursor.Tools,PointToolFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\PointToolFilter.cs,DrawArrowPoints,The following statement contains a magic number: if (this is RubberBandFilter) {  	vel = theVector * (m_Param.V.Y != 0 ? Math.Sign (m_Param.V.Y) : 1) * -Render.DrawHelper.SPEED_AMPLIFIER * (m_Param.C + 0.1) * Math.Pow (innerRadius / m_Param.PtRadius' 2);  }  
Magic Number,KinTemplates.Cursor.Tools,PointToolFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\PointToolFilter.cs,DrawArrowPoints,The following statement contains a magic number: if (this is RubberBandFilter) {  	vel = theVector * (m_Param.V.Y != 0 ? Math.Sign (m_Param.V.Y) : 1) * -Render.DrawHelper.SPEED_AMPLIFIER * (m_Param.C + 0.1) * Math.Pow (innerRadius / m_Param.PtRadius' 2);  }  
Magic Number,KinTemplates.Cursor.Tools,PointToolFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\PointToolFilter.cs,DrawArrowPoints,The following statement contains a magic number: vel = theVector * (m_Param.V.Y != 0 ? Math.Sign (m_Param.V.Y) : 1) * -Render.DrawHelper.SPEED_AMPLIFIER * (m_Param.C + 0.1) * Math.Pow (innerRadius / m_Param.PtRadius' 2);  
Magic Number,KinTemplates.Cursor.Tools,PointToolFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\PointToolFilter.cs,DrawArrowPoints,The following statement contains a magic number: vel = theVector * (m_Param.V.Y != 0 ? Math.Sign (m_Param.V.Y) : 1) * -Render.DrawHelper.SPEED_AMPLIFIER * (m_Param.C + 0.1) * Math.Pow (innerRadius / m_Param.PtRadius' 2);  
Magic Number,KinTemplates.Cursor.Tools,PointToolFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\PointToolFilter.cs,DrawArrowPoints,The following statement contains a magic number: if (this is OrbitFilter) {  	vel = PointD.Orthogonal (theVector) * (m_Param.V.X != 0 ? Math.Sign (m_Param.V.X) : 1) * Render.DrawHelper.SPEED_AMPLIFIER * (m_Param.C + 0.1);  }  
Magic Number,KinTemplates.Cursor.Tools,PointToolFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\PointToolFilter.cs,DrawArrowPoints,The following statement contains a magic number: vel = PointD.Orthogonal (theVector) * (m_Param.V.X != 0 ? Math.Sign (m_Param.V.X) : 1) * Render.DrawHelper.SPEED_AMPLIFIER * (m_Param.C + 0.1);  
Magic Number,KinTemplates.Cursor.Tools,PointToolFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\PointToolFilter.cs,DrawArrowPoints,The following statement contains a magic number: if (this is OrbitFilter2) {  	vel = PointD.Orthogonal (theVector) * (m_Param.V.X != 0 ? Math.Sign (m_Param.V.X) : 1) * (m_Param.C + 0.1) * (innerRadius / 4);  }  
Magic Number,KinTemplates.Cursor.Tools,PointToolFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\PointToolFilter.cs,DrawArrowPoints,The following statement contains a magic number: if (this is OrbitFilter2) {  	vel = PointD.Orthogonal (theVector) * (m_Param.V.X != 0 ? Math.Sign (m_Param.V.X) : 1) * (m_Param.C + 0.1) * (innerRadius / 4);  }  
Magic Number,KinTemplates.Cursor.Tools,PointToolFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\PointToolFilter.cs,DrawArrowPoints,The following statement contains a magic number: vel = PointD.Orthogonal (theVector) * (m_Param.V.X != 0 ? Math.Sign (m_Param.V.X) : 1) * (m_Param.C + 0.1) * (innerRadius / 4);  
Magic Number,KinTemplates.Cursor.Tools,PointToolFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\PointToolFilter.cs,DrawArrowPoints,The following statement contains a magic number: vel = PointD.Orthogonal (theVector) * (m_Param.V.X != 0 ? Math.Sign (m_Param.V.X) : 1) * (m_Param.C + 0.1) * (innerRadius / 4);  
Magic Number,KinTemplates.Cursor.Tools,PointToolFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\PointToolFilter.cs,DrawArrowPoints,The following statement contains a magic number: if (this is OrbitFilter3) {  	vel = PointD.Orthogonal (theVector) * (m_Param.V.X != 0 ? Math.Sign (m_Param.V.X) : 1) * (m_Param.C + 0.1) * (innerRadius / 4);  }  
Magic Number,KinTemplates.Cursor.Tools,PointToolFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\PointToolFilter.cs,DrawArrowPoints,The following statement contains a magic number: if (this is OrbitFilter3) {  	vel = PointD.Orthogonal (theVector) * (m_Param.V.X != 0 ? Math.Sign (m_Param.V.X) : 1) * (m_Param.C + 0.1) * (innerRadius / 4);  }  
Magic Number,KinTemplates.Cursor.Tools,PointToolFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\PointToolFilter.cs,DrawArrowPoints,The following statement contains a magic number: vel = PointD.Orthogonal (theVector) * (m_Param.V.X != 0 ? Math.Sign (m_Param.V.X) : 1) * (m_Param.C + 0.1) * (innerRadius / 4);  
Magic Number,KinTemplates.Cursor.Tools,PointToolFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\PointToolFilter.cs,DrawArrowPoints,The following statement contains a magic number: vel = PointD.Orthogonal (theVector) * (m_Param.V.X != 0 ? Math.Sign (m_Param.V.X) : 1) * (m_Param.C + 0.1) * (innerRadius / 4);  
Magic Number,KinTemplates.Cursor.Tools,PointToolFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\PointToolFilter.cs,DrawDirectionHint,The following statement contains a magic number: gc.DrawLine (r.RegionGuides' (Point)(thePoint - theVector * 0.5)' (Point)(thePoint + theVector));  
Magic Number,KinTemplates.Cursor.Tools,PointToolFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\PointToolFilter.cs,Cache,The following statement contains a magic number: s.X -= Render.DrawHelper.EDGE_WIDTH / 2;  
Magic Number,KinTemplates.Cursor.Tools,PointToolFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\PointToolFilter.cs,Cache,The following statement contains a magic number: s.Y -= Render.DrawHelper.EDGE_WIDTH / 2;  
Magic Number,KinTemplates.Cursor.Tools,RegionToolRegionFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\RegionToolRegionFilter.cs,DrawRegionRepresentation,The following statement contains a magic number: if (HitTest (mousePosition)) {  	gc.DrawString (ToString ()' r.FontType' new SolidBrush (r.RegionGuides.Color)' new PointF ((float)mousePosition.X' (float)mousePosition.Y - 15));  }  
Magic Number,KinTemplates.Cursor.Tools,RegionToolRegionFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\RegionToolRegionFilter.cs,DrawRegionRepresentation,The following statement contains a magic number: gc.DrawString (ToString ()' r.FontType' new SolidBrush (r.RegionGuides.Color)' new PointF ((float)mousePosition.X' (float)mousePosition.Y - 15));  
Magic Number,KinTemplates.Cursor.Tools,RegionToolRegionFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\RegionToolRegionFilter.cs,GetStrength,The following statement contains a magic number: if (m_Param.Path is Model.VectorPath) {  	return HitTest (point) ? 1.0 : 0.0;  }  else if (m_Param.Path is Model.BitmapPath) {  	Model.BitmapPath bp = (Model.BitmapPath)m_Param.Path;  	return (255 - bp.GetPixelValue ((PointF)point)) / 255.0;  }  else {  	throw new Exception ("Not handled");  }  
Magic Number,KinTemplates.Cursor.Tools,RegionToolRegionFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\RegionToolRegionFilter.cs,GetStrength,The following statement contains a magic number: if (m_Param.Path is Model.VectorPath) {  	return HitTest (point) ? 1.0 : 0.0;  }  else if (m_Param.Path is Model.BitmapPath) {  	Model.BitmapPath bp = (Model.BitmapPath)m_Param.Path;  	return (255 - bp.GetPixelValue ((PointF)point)) / 255.0;  }  else {  	throw new Exception ("Not handled");  }  
Magic Number,KinTemplates.Cursor.Tools,RegionToolRegionFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\RegionToolRegionFilter.cs,GetStrength,The following statement contains a magic number: if (m_Param.Path is Model.BitmapPath) {  	Model.BitmapPath bp = (Model.BitmapPath)m_Param.Path;  	return (255 - bp.GetPixelValue ((PointF)point)) / 255.0;  }  else {  	throw new Exception ("Not handled");  }  
Magic Number,KinTemplates.Cursor.Tools,RegionToolRegionFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\RegionToolRegionFilter.cs,GetStrength,The following statement contains a magic number: if (m_Param.Path is Model.BitmapPath) {  	Model.BitmapPath bp = (Model.BitmapPath)m_Param.Path;  	return (255 - bp.GetPixelValue ((PointF)point)) / 255.0;  }  else {  	throw new Exception ("Not handled");  }  
Magic Number,KinTemplates.Cursor.Tools,RegionToolRegionFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\RegionToolRegionFilter.cs,GetStrength,The following statement contains a magic number: return (255 - bp.GetPixelValue ((PointF)point)) / 255.0;  
Magic Number,KinTemplates.Cursor.Tools,RegionToolRegionFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\RegionToolRegionFilter.cs,GetStrength,The following statement contains a magic number: return (255 - bp.GetPixelValue ((PointF)point)) / 255.0;  
Magic Number,KinTemplates.Cursor.Tools,RubberBandFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\RubberBandFilter.cs,GetInnerVelocity,The following statement contains a magic number: return new RadialFactors (1' 1' -(10 * m_Param.C) * Math.Pow (mp.VirtualPoint.R / m_Param.PtRadius' 2)' 0);  
Magic Number,KinTemplates.Cursor.Tools,RubberBandFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\RubberBandFilter.cs,GetInnerVelocity,The following statement contains a magic number: return new RadialFactors (1' 1' -(10 * m_Param.C) * Math.Pow (mp.VirtualPoint.R / m_Param.PtRadius' 2)' 0);  
Magic Number,KinTemplates.Cursor.Tools,SandpaperFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\SandpaperFilter.cs,SandpaperFilter,The following statement contains a magic number: m_Param.C = 0.75;  
Magic Number,KinTemplates.Cursor.Tools,SandpaperFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\SandpaperFilter.cs,GetBrush,The following statement contains a magic number: textureContext.DrawEllipse (r.RegionGuides' 2' 2' 1' 1);  
Magic Number,KinTemplates.Cursor.Tools,SandpaperFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\SandpaperFilter.cs,GetBrush,The following statement contains a magic number: textureContext.DrawEllipse (r.RegionGuides' 2' 2' 1' 1);  
Magic Number,KinTemplates.Cursor.Tools,SandpaperFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\SandpaperFilter.cs,GetBrush,The following statement contains a magic number: textureContext.DrawEllipse (r.RegionGuides' (size + 1) / 2' (size + 1) / 2' 1' 1);  
Magic Number,KinTemplates.Cursor.Tools,SandpaperFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\SandpaperFilter.cs,GetBrush,The following statement contains a magic number: textureContext.DrawEllipse (r.RegionGuides' (size + 1) / 2' (size + 1) / 2' 1' 1);  
Magic Number,KinTemplates.Cursor.Tools,SandpaperImageFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\SandpaperImageFilter.cs,SandpaperImageFilter,The following statement contains a magic number: m_Param.C = 0.75;  
Magic Number,KinTemplates.Cursor.Tools,SandpaperImageFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\SandpaperImageFilter.cs,GetVelocity,The following statement contains a magic number: return orig * -m_Param.C * (255 - c.G) / 255.0;  
Magic Number,KinTemplates.Cursor.Tools,SandpaperImageFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\SandpaperImageFilter.cs,GetVelocity,The following statement contains a magic number: return orig * -m_Param.C * (255 - c.G) / 255.0;  
Magic Number,KinTemplates.Cursor.Tools,SpeedPreservingHatchingFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\SpeedPreservingHatchingFilter.cs,DrawRegionRepresentation,The following statement contains a magic number: if (m_Param.Path.PointCount > 0) {  	GraphicsPath fill = new GraphicsPath ();  	RectangleF rect = m_Param.Path.GetBounds ();  	PointD refPt = (PointD)rect.Location + ((PointD)rect.Size.ToPointF ()) / 2;  	// this will draw beyond the shape's location  	for (double i = -rect.Height; i < rect.Height; i++) {  		PointD pt1 = refPt + PointD.Orthogonal (m_Param.V) * i * drawMethods.Spacing (m_Param.C);  		PointD pt2 = pt1 + m_Param.V * rect.Width * rect.Height;  		PointD pt3 = pt1 - m_Param.V * rect.Width * rect.Height;  		fill.StartFigure ();  		fill.AddLine ((Point)pt2' (Point)pt3);  	}  	GraphicsContainer c = gc.BeginContainer ();  	gc.SetClip ((Tools.Model.VectorPath)m_Param.Path);  	gc.DrawPath (r.RegionGuides' fill);  	gc.EndContainer (c);  }  
Magic Number,KinTemplates.Cursor.Tools,SpeedPreservingHatchingFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\SpeedPreservingHatchingFilter.cs,GetVelocity,The following statement contains a magic number: if (speed > 0.01) {  	PointD dir = PointD.UnitVector (PointD.DotProduct (m_Param.V' PointD.UnitVector (m.GetVelocity ())) * m_Param.V);  	PointD usr = PointD.UnitVector (m.GetVelocity ());  	// this will deaden any movement (dir is NULL' usr is NULL :: no movement of the cursor)  	if (dir.Magnitude () < 0.001)  		usr = dir;  	return -1 * m.GetVelocity () + PointD.UnitVector (m_Param.C * dir + (1 - m_Param.C) * usr) * speed;  }  else {  	return -1 * m.GetVelocity ();  }  
Magic Number,KinTemplates.Cursor.Tools,SpeedPreservingHatchingFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\SpeedPreservingHatchingFilter.cs,GetVelocity,The following statement contains a magic number: if (speed > 0.01) {  	PointD dir = PointD.UnitVector (PointD.DotProduct (m_Param.V' PointD.UnitVector (m.GetVelocity ())) * m_Param.V);  	PointD usr = PointD.UnitVector (m.GetVelocity ());  	// this will deaden any movement (dir is NULL' usr is NULL :: no movement of the cursor)  	if (dir.Magnitude () < 0.001)  		usr = dir;  	return -1 * m.GetVelocity () + PointD.UnitVector (m_Param.C * dir + (1 - m_Param.C) * usr) * speed;  }  else {  	return -1 * m.GetVelocity ();  }  
Magic Number,KinTemplates.Cursor.Tools,SpeedPreservingHatchingFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\SpeedPreservingHatchingFilter.cs,GetVelocity,The following statement contains a magic number: if (dir.Magnitude () < 0.001)  	usr = dir;  
Magic Number,KinTemplates.Cursor.Tools,SpeedPreservingHatchingFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\SpeedPreservingHatchingFilter.cs,GetParamHandlePos,The following statement contains a magic number: return PointD.FromSize (m_Param.Path.GetBounds ().Size) / 2.0;  
Magic Number,KinTemplates.Cursor.Tools,SteadyHandFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\SteadyHandFilter.cs,DrawRegionRepresentation,The following statement contains a magic number: if (m_Param.Path.IsVisible ((System.Drawing.Point)mousePosition)) {  	gc.DrawString (ToString ()' r.FontType' new System.Drawing.SolidBrush (r.RegionGuides.Color)' new System.Drawing.PointF ((float)mousePosition.X' (float)mousePosition.Y - 15));  }  
Magic Number,KinTemplates.Cursor.Tools,SteadyHandFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\SteadyHandFilter.cs,DrawRegionRepresentation,The following statement contains a magic number: gc.DrawString (ToString ()' r.FontType' new System.Drawing.SolidBrush (r.RegionGuides.Color)' new System.Drawing.PointF ((float)mousePosition.X' (float)mousePosition.Y - 15));  
Magic Number,KinTemplates.Cursor.Tools,SteadyHandFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\SteadyHandFilter.cs,GetVelocity,The following statement contains a magic number: if (direction.Magnitude () > 0.1) {  	m_direction = direction * 0.1 + m_direction * 0.9;  	// mixture of previous and current input  }  
Magic Number,KinTemplates.Cursor.Tools,SteadyHandFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\SteadyHandFilter.cs,GetVelocity,The following statement contains a magic number: if (direction.Magnitude () > 0.1) {  	m_direction = direction * 0.1 + m_direction * 0.9;  	// mixture of previous and current input  }  
Magic Number,KinTemplates.Cursor.Tools,SteadyHandFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\SteadyHandFilter.cs,GetVelocity,The following statement contains a magic number: if (direction.Magnitude () > 0.1) {  	m_direction = direction * 0.1 + m_direction * 0.9;  	// mixture of previous and current input  }  
Magic Number,KinTemplates.Cursor.Tools,SteadyHandFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\SteadyHandFilter.cs,GetVelocity,The following statement contains a magic number: m_direction = direction * 0.1 + m_direction * 0.9;  
Magic Number,KinTemplates.Cursor.Tools,SteadyHandFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\SteadyHandFilter.cs,GetVelocity,The following statement contains a magic number: m_direction = direction * 0.1 + m_direction * 0.9;  
Magic Number,KinTemplates.Cursor.Tools,TunnelLineFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\TunnelLineFilter.cs,SecondCache,The following statement contains a magic number: for (int i = 1; i < array.Length; i += 2) {  	PointD tangent = new PointD (array [i].X - array [i - 1].X' array [i].Y - array [i - 1].Y);  	tangent = tangent / tangent.Magnitude ();  	PointD normalVector = PointD.Orthogonal (tangent);  	PointD pointOnLine = new PointD ((array [i].X + array [i - 1].X) / 2.0' (array [i].Y + array [i - 1].Y) / 2.0);  	for (int k = 0; k < numLines; k++) {  		PointD testPt = pointOnLine + normalVector * spacing * (k - numLines / 2);  		m_traceLines [k].Add ((PointF)testPt);  	}  	//PointD testNormal1 = (testPt1 - pointOnLine);  	//testNormal1 = testNormal1 / testNormal1.Magnitude();  	//PointD testNormal2 = (testPt2 - pointOnLine);  	//testNormal2 = testNormal2 / testNormal2.Magnitude();  	//PointD scaledVector1 = testNormal1 * (GetScalar() * 7 * m_Param.C / Math.Pow((m_Param.PtRadius / 2.0) + 10' 0.5));  	//PointD scaledVector2 = testNormal2 * (GetScalar() * 7 * m_Param.C / Math.Pow((m_Param.PtRadius / 2.0) + 10' 0.5));  	//drawMethods.DrawArrow(gc' r' testPt1' scaledVector1 * Render.DrawHelper.SPEED_AMPLIFIER);  	//drawMethods.DrawArrow(gc' r' testPt2' scaledVector2 * Render.DrawHelper.SPEED_AMPLIFIER);  }  
Magic Number,KinTemplates.Cursor.Tools,TunnelLineFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\TunnelLineFilter.cs,SecondCache,The following statement contains a magic number: for (int i = 1; i < array.Length; i += 2) {  	PointD tangent = new PointD (array [i].X - array [i - 1].X' array [i].Y - array [i - 1].Y);  	tangent = tangent / tangent.Magnitude ();  	PointD normalVector = PointD.Orthogonal (tangent);  	PointD pointOnLine = new PointD ((array [i].X + array [i - 1].X) / 2.0' (array [i].Y + array [i - 1].Y) / 2.0);  	for (int k = 0; k < numLines; k++) {  		PointD testPt = pointOnLine + normalVector * spacing * (k - numLines / 2);  		m_traceLines [k].Add ((PointF)testPt);  	}  	//PointD testNormal1 = (testPt1 - pointOnLine);  	//testNormal1 = testNormal1 / testNormal1.Magnitude();  	//PointD testNormal2 = (testPt2 - pointOnLine);  	//testNormal2 = testNormal2 / testNormal2.Magnitude();  	//PointD scaledVector1 = testNormal1 * (GetScalar() * 7 * m_Param.C / Math.Pow((m_Param.PtRadius / 2.0) + 10' 0.5));  	//PointD scaledVector2 = testNormal2 * (GetScalar() * 7 * m_Param.C / Math.Pow((m_Param.PtRadius / 2.0) + 10' 0.5));  	//drawMethods.DrawArrow(gc' r' testPt1' scaledVector1 * Render.DrawHelper.SPEED_AMPLIFIER);  	//drawMethods.DrawArrow(gc' r' testPt2' scaledVector2 * Render.DrawHelper.SPEED_AMPLIFIER);  }  
Magic Number,KinTemplates.Cursor.Tools,TunnelLineFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\TunnelLineFilter.cs,SecondCache,The following statement contains a magic number: for (int i = 1; i < array.Length; i += 2) {  	PointD tangent = new PointD (array [i].X - array [i - 1].X' array [i].Y - array [i - 1].Y);  	tangent = tangent / tangent.Magnitude ();  	PointD normalVector = PointD.Orthogonal (tangent);  	PointD pointOnLine = new PointD ((array [i].X + array [i - 1].X) / 2.0' (array [i].Y + array [i - 1].Y) / 2.0);  	for (int k = 0; k < numLines; k++) {  		PointD testPt = pointOnLine + normalVector * spacing * (k - numLines / 2);  		m_traceLines [k].Add ((PointF)testPt);  	}  	//PointD testNormal1 = (testPt1 - pointOnLine);  	//testNormal1 = testNormal1 / testNormal1.Magnitude();  	//PointD testNormal2 = (testPt2 - pointOnLine);  	//testNormal2 = testNormal2 / testNormal2.Magnitude();  	//PointD scaledVector1 = testNormal1 * (GetScalar() * 7 * m_Param.C / Math.Pow((m_Param.PtRadius / 2.0) + 10' 0.5));  	//PointD scaledVector2 = testNormal2 * (GetScalar() * 7 * m_Param.C / Math.Pow((m_Param.PtRadius / 2.0) + 10' 0.5));  	//drawMethods.DrawArrow(gc' r' testPt1' scaledVector1 * Render.DrawHelper.SPEED_AMPLIFIER);  	//drawMethods.DrawArrow(gc' r' testPt2' scaledVector2 * Render.DrawHelper.SPEED_AMPLIFIER);  }  
Magic Number,KinTemplates.Cursor.Tools,TunnelLineFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\TunnelLineFilter.cs,SecondCache,The following statement contains a magic number: for (int i = 1; i < array.Length; i += 2) {  	PointD tangent = new PointD (array [i].X - array [i - 1].X' array [i].Y - array [i - 1].Y);  	tangent = tangent / tangent.Magnitude ();  	PointD normalVector = PointD.Orthogonal (tangent);  	PointD pointOnLine = new PointD ((array [i].X + array [i - 1].X) / 2.0' (array [i].Y + array [i - 1].Y) / 2.0);  	for (int k = 0; k < numLines; k++) {  		PointD testPt = pointOnLine + normalVector * spacing * (k - numLines / 2);  		m_traceLines [k].Add ((PointF)testPt);  	}  	//PointD testNormal1 = (testPt1 - pointOnLine);  	//testNormal1 = testNormal1 / testNormal1.Magnitude();  	//PointD testNormal2 = (testPt2 - pointOnLine);  	//testNormal2 = testNormal2 / testNormal2.Magnitude();  	//PointD scaledVector1 = testNormal1 * (GetScalar() * 7 * m_Param.C / Math.Pow((m_Param.PtRadius / 2.0) + 10' 0.5));  	//PointD scaledVector2 = testNormal2 * (GetScalar() * 7 * m_Param.C / Math.Pow((m_Param.PtRadius / 2.0) + 10' 0.5));  	//drawMethods.DrawArrow(gc' r' testPt1' scaledVector1 * Render.DrawHelper.SPEED_AMPLIFIER);  	//drawMethods.DrawArrow(gc' r' testPt2' scaledVector2 * Render.DrawHelper.SPEED_AMPLIFIER);  }  
Magic Number,KinTemplates.Cursor.Tools,TunnelLineFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\TunnelLineFilter.cs,SecondCache,The following statement contains a magic number: i += 2
Magic Number,KinTemplates.Cursor.Tools,TunnelLineFilter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\TunnelLineFilter.cs,SecondCache,The following statement contains a magic number: for (int k = 0; k < numLines; k++) {  	PointD testPt = pointOnLine + normalVector * spacing * (k - numLines / 2);  	m_traceLines [k].Add ((PointF)testPt);  }  
Magic Number,KinTemplates.Cursor.Tools.Render,DefaultDrawVisitor,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\Render\DefaultDrawVisitor.cs,Spacing,The following statement contains a magic number: return (1.5 - C) * Render.DrawHelper.SPEED_AMPLIFIER;  
Magic Number,KinTemplates.Cursor.Tools.Render,RenderParameter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\Render\RenderParameter.cs,CreateDrawMode,The following statement contains a magic number: n.RegionOutline = new Pen (Color.FromArgb (192' Color.Silver));  
Magic Number,KinTemplates.Cursor.Tools.Render,RenderParameter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\Render\RenderParameter.cs,CreateDrawMode,The following statement contains a magic number: n.FontType = new Font (System.Drawing.FontFamily.GenericSansSerif' 8);  
Magic Number,KinTemplates.Cursor.Tools.Render,RenderParameter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\Render\RenderParameter.cs,CreateDetailedMode,The following statement contains a magic number: n.StrokeFill = new SolidBrush (Color.FromArgb (127' Color.White));  
Magic Number,KinTemplates.Cursor.Tools.Render,RenderParameter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\Render\RenderParameter.cs,CreateDetailedMode,The following statement contains a magic number: n.RegionInsideFill = new SolidBrush (Color.FromArgb (127' Color.White));  
Magic Number,KinTemplates.Cursor.Tools.Render,RenderParameter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\Render\RenderParameter.cs,CreateDetailedMode,The following statement contains a magic number: n.FontType = new Font (System.Drawing.FontFamily.GenericSansSerif' 8);  
Magic Number,KinTemplates.Cursor.Tools.Render,OnlineFeedback,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\Render\OnlineFeedback.cs,ClearFeedback,The following statement contains a magic number: m_zoom = 50;  
Magic Number,KinTemplates.Cursor.Tools.Render,OnlineFeedback,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\Render\OnlineFeedback.cs,AddFilter,The following statement contains a magic number: if (filter.HitTest (mousePos)) {  	// zoom in and out  	if (filter is Tools.SandpaperFilter || filter is Tools.MaxFilter) {  		RegionToolRegionFilter rtrf = (RegionToolRegionFilter)filter;  		m_zoom = (int)((m_zoom + filter.Parameters.C * 100 * rtrf.GetStrength (mousePos)));  	}  	else if (filter is Tools.MinFilter || filter is Tools.IceSheetFilter) {  		RegionToolRegionFilter rtrf = (RegionToolRegionFilter)filter;  		m_zoom = (int)((m_zoom - filter.Parameters.C * 40 * rtrf.GetStrength (mousePos)));  		if (m_zoom < 10)  			m_zoom = 10;  	}  	//// shade out surrounding area  	//if (filter is Tools.TunnelLineFilter || (filter is Tools.MagneticLineAttractionFilter  	//    && !(filter is Tools.MagneticLineRepulsionFilter)))  	//{  	//    /*  	//    if (m_shadeRegion == null)  	//    {  	//        m_shadeRegion = new Region();  	//        m_shadeRegion.MakeEmpty();  	//    }  	//    Region inversion = new Region();  	//    inversion.MakeInfinite();  	//    GraphicsPath test = (GraphicsPath)((Tools.Model.VectorPath)filter.Parameters.Path).InternalPath.Clone();  	//    test.Widen(new Pen(Color.Black' (float)filter.Parameters.PtRadius));  	//    inversion.Exclude(test);  	//    m_shadeRegion.Union(inversion);  	//    inversion.Dispose();  	//    test.Dispose();  	//     */  	//    // shade in the region  	//    if (m_shadeRegion == null)  	//    {  	//        m_shadeRegion = new Region();  	//        m_shadeRegion.MakeEmpty();  	//    }  	//    GraphicsPath test = (GraphicsPath)((Tools.Model.VectorPath)filter.Parameters.Path).InternalPath.Clone();  	//    test.Widen(new Pen(Color.Black' (float)filter.Parameters.PathThickness));  	//    m_shadeRegion.Union(test);  	//    test.Dispose();      	//}  	//// shade in the filter  	//else if (filter is Tools.MagneticLineRepulsionFilter)  	//{  	//    if (m_shadeRegion == null)  	//    {  	//        m_shadeRegion = new Region();  	//        m_shadeRegion.MakeEmpty();  	//    }  	//    GraphicsPath test = (GraphicsPath)((Tools.Model.VectorPath)filter.Parameters.Path).InternalPath.Clone();  	//    test.Widen(new Pen(Color.Black' (float)filter.Parameters.PathThickness));  	//    m_shadeRegion.Union(test);  	//    test.Dispose();                      	//}  	//// draw guide lines  	//if (filter is Tools.CorduroyFilter || filter is Tools.GridFilter  	//    || filter is Tools.SteadyHandFilter)  	//{  	//    if (m_guideLines == null)  	//        m_guideLines = new List<Clip>();  	//    Clip c = new Clip();  	//    PointD norm = filter.Parameters.V;  	//    PointD side1 = mousePos + norm * 1000;  	//    PointD side2 = mousePos - norm * 1000;  	//    c.ClipPath = new GraphicsPath();  	//    c.ClipPath.StartFigure();  	//    c.ClipPath.AddLine((Point)side1' (Point)side2);  	//    c.Filter = filter;  	//    if (filter is Tools.GridFilter)  	//    {  	//        PointD orth = PointD.Orthogonal(filter.Parameters.V);  	//        PointD end1 = mousePos + orth * 1000;  	//        PointD end2 = mousePos - orth * 1000;  	//        c.ClipPath.StartFigure();  	//        c.ClipPath.AddLine((Point)end1' (Point)end2);  	//    }  	//    m_guideLines.Add(c);  	//}  	//// draw online guides  	//if (filter is Tools.CompassFilter)  	//{  	//    PointD radiusVector = mousePos - filter.Parameters.Pt;  	//    double radius = radiusVector.Magnitude();  	//    if (radius > 0.0001)  	//    {  	//        if (m_guideLines == null)  	//            m_guideLines = new List<Clip>();  	//        Clip c = new Clip();  	//        c.ClipPath = new GraphicsPath();  	//        c.ClipPath.StartFigure();  	//        c.ClipPath.AddEllipse((float)(filter.Parameters.Pt.X - radius)' (float)(filter.Parameters.Pt.Y - radius)'  	//            (float)radius * 2' (float)radius * 2);  	//        m_guideLines.Add(c);  	//    }  	//}  	//if (filter is Tools.DimpleChadFilter)  	//{  	//    PointD vector = mousePos - filter.Parameters.Pt;  	//    if (vector.Magnitude() > 0.0001)  	//    {  	//        PointD unitVector = vector / vector.Magnitude();  	//        if (m_guideLines == null)  	//            m_guideLines = new List<Clip>();  	//        Clip c = new Clip();  	//        c.ClipPath = new GraphicsPath();  	//        c.ClipPath.StartFigure();  	//        c.ClipPath.AddLine((Point)(filter.Parameters.Pt + unitVector * Math.Max( filter.Parameters.PtSize.X' filter.Parameters.PtSize.Y) )'  	//            (Point)(filter.Parameters.Pt - unitVector * Math.Max(filter.Parameters.PtSize.X' filter.Parameters.PtSize.Y)));  	//        m_guideLines.Add(c);  	//    }  	//}  }  
Magic Number,KinTemplates.Cursor.Tools.Render,OnlineFeedback,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\Render\OnlineFeedback.cs,AddFilter,The following statement contains a magic number: if (filter.HitTest (mousePos)) {  	// zoom in and out  	if (filter is Tools.SandpaperFilter || filter is Tools.MaxFilter) {  		RegionToolRegionFilter rtrf = (RegionToolRegionFilter)filter;  		m_zoom = (int)((m_zoom + filter.Parameters.C * 100 * rtrf.GetStrength (mousePos)));  	}  	else if (filter is Tools.MinFilter || filter is Tools.IceSheetFilter) {  		RegionToolRegionFilter rtrf = (RegionToolRegionFilter)filter;  		m_zoom = (int)((m_zoom - filter.Parameters.C * 40 * rtrf.GetStrength (mousePos)));  		if (m_zoom < 10)  			m_zoom = 10;  	}  	//// shade out surrounding area  	//if (filter is Tools.TunnelLineFilter || (filter is Tools.MagneticLineAttractionFilter  	//    && !(filter is Tools.MagneticLineRepulsionFilter)))  	//{  	//    /*  	//    if (m_shadeRegion == null)  	//    {  	//        m_shadeRegion = new Region();  	//        m_shadeRegion.MakeEmpty();  	//    }  	//    Region inversion = new Region();  	//    inversion.MakeInfinite();  	//    GraphicsPath test = (GraphicsPath)((Tools.Model.VectorPath)filter.Parameters.Path).InternalPath.Clone();  	//    test.Widen(new Pen(Color.Black' (float)filter.Parameters.PtRadius));  	//    inversion.Exclude(test);  	//    m_shadeRegion.Union(inversion);  	//    inversion.Dispose();  	//    test.Dispose();  	//     */  	//    // shade in the region  	//    if (m_shadeRegion == null)  	//    {  	//        m_shadeRegion = new Region();  	//        m_shadeRegion.MakeEmpty();  	//    }  	//    GraphicsPath test = (GraphicsPath)((Tools.Model.VectorPath)filter.Parameters.Path).InternalPath.Clone();  	//    test.Widen(new Pen(Color.Black' (float)filter.Parameters.PathThickness));  	//    m_shadeRegion.Union(test);  	//    test.Dispose();      	//}  	//// shade in the filter  	//else if (filter is Tools.MagneticLineRepulsionFilter)  	//{  	//    if (m_shadeRegion == null)  	//    {  	//        m_shadeRegion = new Region();  	//        m_shadeRegion.MakeEmpty();  	//    }  	//    GraphicsPath test = (GraphicsPath)((Tools.Model.VectorPath)filter.Parameters.Path).InternalPath.Clone();  	//    test.Widen(new Pen(Color.Black' (float)filter.Parameters.PathThickness));  	//    m_shadeRegion.Union(test);  	//    test.Dispose();                      	//}  	//// draw guide lines  	//if (filter is Tools.CorduroyFilter || filter is Tools.GridFilter  	//    || filter is Tools.SteadyHandFilter)  	//{  	//    if (m_guideLines == null)  	//        m_guideLines = new List<Clip>();  	//    Clip c = new Clip();  	//    PointD norm = filter.Parameters.V;  	//    PointD side1 = mousePos + norm * 1000;  	//    PointD side2 = mousePos - norm * 1000;  	//    c.ClipPath = new GraphicsPath();  	//    c.ClipPath.StartFigure();  	//    c.ClipPath.AddLine((Point)side1' (Point)side2);  	//    c.Filter = filter;  	//    if (filter is Tools.GridFilter)  	//    {  	//        PointD orth = PointD.Orthogonal(filter.Parameters.V);  	//        PointD end1 = mousePos + orth * 1000;  	//        PointD end2 = mousePos - orth * 1000;  	//        c.ClipPath.StartFigure();  	//        c.ClipPath.AddLine((Point)end1' (Point)end2);  	//    }  	//    m_guideLines.Add(c);  	//}  	//// draw online guides  	//if (filter is Tools.CompassFilter)  	//{  	//    PointD radiusVector = mousePos - filter.Parameters.Pt;  	//    double radius = radiusVector.Magnitude();  	//    if (radius > 0.0001)  	//    {  	//        if (m_guideLines == null)  	//            m_guideLines = new List<Clip>();  	//        Clip c = new Clip();  	//        c.ClipPath = new GraphicsPath();  	//        c.ClipPath.StartFigure();  	//        c.ClipPath.AddEllipse((float)(filter.Parameters.Pt.X - radius)' (float)(filter.Parameters.Pt.Y - radius)'  	//            (float)radius * 2' (float)radius * 2);  	//        m_guideLines.Add(c);  	//    }  	//}  	//if (filter is Tools.DimpleChadFilter)  	//{  	//    PointD vector = mousePos - filter.Parameters.Pt;  	//    if (vector.Magnitude() > 0.0001)  	//    {  	//        PointD unitVector = vector / vector.Magnitude();  	//        if (m_guideLines == null)  	//            m_guideLines = new List<Clip>();  	//        Clip c = new Clip();  	//        c.ClipPath = new GraphicsPath();  	//        c.ClipPath.StartFigure();  	//        c.ClipPath.AddLine((Point)(filter.Parameters.Pt + unitVector * Math.Max( filter.Parameters.PtSize.X' filter.Parameters.PtSize.Y) )'  	//            (Point)(filter.Parameters.Pt - unitVector * Math.Max(filter.Parameters.PtSize.X' filter.Parameters.PtSize.Y)));  	//        m_guideLines.Add(c);  	//    }  	//}  }  
Magic Number,KinTemplates.Cursor.Tools.Render,OnlineFeedback,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\Render\OnlineFeedback.cs,AddFilter,The following statement contains a magic number: if (filter.HitTest (mousePos)) {  	// zoom in and out  	if (filter is Tools.SandpaperFilter || filter is Tools.MaxFilter) {  		RegionToolRegionFilter rtrf = (RegionToolRegionFilter)filter;  		m_zoom = (int)((m_zoom + filter.Parameters.C * 100 * rtrf.GetStrength (mousePos)));  	}  	else if (filter is Tools.MinFilter || filter is Tools.IceSheetFilter) {  		RegionToolRegionFilter rtrf = (RegionToolRegionFilter)filter;  		m_zoom = (int)((m_zoom - filter.Parameters.C * 40 * rtrf.GetStrength (mousePos)));  		if (m_zoom < 10)  			m_zoom = 10;  	}  	//// shade out surrounding area  	//if (filter is Tools.TunnelLineFilter || (filter is Tools.MagneticLineAttractionFilter  	//    && !(filter is Tools.MagneticLineRepulsionFilter)))  	//{  	//    /*  	//    if (m_shadeRegion == null)  	//    {  	//        m_shadeRegion = new Region();  	//        m_shadeRegion.MakeEmpty();  	//    }  	//    Region inversion = new Region();  	//    inversion.MakeInfinite();  	//    GraphicsPath test = (GraphicsPath)((Tools.Model.VectorPath)filter.Parameters.Path).InternalPath.Clone();  	//    test.Widen(new Pen(Color.Black' (float)filter.Parameters.PtRadius));  	//    inversion.Exclude(test);  	//    m_shadeRegion.Union(inversion);  	//    inversion.Dispose();  	//    test.Dispose();  	//     */  	//    // shade in the region  	//    if (m_shadeRegion == null)  	//    {  	//        m_shadeRegion = new Region();  	//        m_shadeRegion.MakeEmpty();  	//    }  	//    GraphicsPath test = (GraphicsPath)((Tools.Model.VectorPath)filter.Parameters.Path).InternalPath.Clone();  	//    test.Widen(new Pen(Color.Black' (float)filter.Parameters.PathThickness));  	//    m_shadeRegion.Union(test);  	//    test.Dispose();      	//}  	//// shade in the filter  	//else if (filter is Tools.MagneticLineRepulsionFilter)  	//{  	//    if (m_shadeRegion == null)  	//    {  	//        m_shadeRegion = new Region();  	//        m_shadeRegion.MakeEmpty();  	//    }  	//    GraphicsPath test = (GraphicsPath)((Tools.Model.VectorPath)filter.Parameters.Path).InternalPath.Clone();  	//    test.Widen(new Pen(Color.Black' (float)filter.Parameters.PathThickness));  	//    m_shadeRegion.Union(test);  	//    test.Dispose();                      	//}  	//// draw guide lines  	//if (filter is Tools.CorduroyFilter || filter is Tools.GridFilter  	//    || filter is Tools.SteadyHandFilter)  	//{  	//    if (m_guideLines == null)  	//        m_guideLines = new List<Clip>();  	//    Clip c = new Clip();  	//    PointD norm = filter.Parameters.V;  	//    PointD side1 = mousePos + norm * 1000;  	//    PointD side2 = mousePos - norm * 1000;  	//    c.ClipPath = new GraphicsPath();  	//    c.ClipPath.StartFigure();  	//    c.ClipPath.AddLine((Point)side1' (Point)side2);  	//    c.Filter = filter;  	//    if (filter is Tools.GridFilter)  	//    {  	//        PointD orth = PointD.Orthogonal(filter.Parameters.V);  	//        PointD end1 = mousePos + orth * 1000;  	//        PointD end2 = mousePos - orth * 1000;  	//        c.ClipPath.StartFigure();  	//        c.ClipPath.AddLine((Point)end1' (Point)end2);  	//    }  	//    m_guideLines.Add(c);  	//}  	//// draw online guides  	//if (filter is Tools.CompassFilter)  	//{  	//    PointD radiusVector = mousePos - filter.Parameters.Pt;  	//    double radius = radiusVector.Magnitude();  	//    if (radius > 0.0001)  	//    {  	//        if (m_guideLines == null)  	//            m_guideLines = new List<Clip>();  	//        Clip c = new Clip();  	//        c.ClipPath = new GraphicsPath();  	//        c.ClipPath.StartFigure();  	//        c.ClipPath.AddEllipse((float)(filter.Parameters.Pt.X - radius)' (float)(filter.Parameters.Pt.Y - radius)'  	//            (float)radius * 2' (float)radius * 2);  	//        m_guideLines.Add(c);  	//    }  	//}  	//if (filter is Tools.DimpleChadFilter)  	//{  	//    PointD vector = mousePos - filter.Parameters.Pt;  	//    if (vector.Magnitude() > 0.0001)  	//    {  	//        PointD unitVector = vector / vector.Magnitude();  	//        if (m_guideLines == null)  	//            m_guideLines = new List<Clip>();  	//        Clip c = new Clip();  	//        c.ClipPath = new GraphicsPath();  	//        c.ClipPath.StartFigure();  	//        c.ClipPath.AddLine((Point)(filter.Parameters.Pt + unitVector * Math.Max( filter.Parameters.PtSize.X' filter.Parameters.PtSize.Y) )'  	//            (Point)(filter.Parameters.Pt - unitVector * Math.Max(filter.Parameters.PtSize.X' filter.Parameters.PtSize.Y)));  	//        m_guideLines.Add(c);  	//    }  	//}  }  
Magic Number,KinTemplates.Cursor.Tools.Render,OnlineFeedback,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\Render\OnlineFeedback.cs,AddFilter,The following statement contains a magic number: if (filter.HitTest (mousePos)) {  	// zoom in and out  	if (filter is Tools.SandpaperFilter || filter is Tools.MaxFilter) {  		RegionToolRegionFilter rtrf = (RegionToolRegionFilter)filter;  		m_zoom = (int)((m_zoom + filter.Parameters.C * 100 * rtrf.GetStrength (mousePos)));  	}  	else if (filter is Tools.MinFilter || filter is Tools.IceSheetFilter) {  		RegionToolRegionFilter rtrf = (RegionToolRegionFilter)filter;  		m_zoom = (int)((m_zoom - filter.Parameters.C * 40 * rtrf.GetStrength (mousePos)));  		if (m_zoom < 10)  			m_zoom = 10;  	}  	//// shade out surrounding area  	//if (filter is Tools.TunnelLineFilter || (filter is Tools.MagneticLineAttractionFilter  	//    && !(filter is Tools.MagneticLineRepulsionFilter)))  	//{  	//    /*  	//    if (m_shadeRegion == null)  	//    {  	//        m_shadeRegion = new Region();  	//        m_shadeRegion.MakeEmpty();  	//    }  	//    Region inversion = new Region();  	//    inversion.MakeInfinite();  	//    GraphicsPath test = (GraphicsPath)((Tools.Model.VectorPath)filter.Parameters.Path).InternalPath.Clone();  	//    test.Widen(new Pen(Color.Black' (float)filter.Parameters.PtRadius));  	//    inversion.Exclude(test);  	//    m_shadeRegion.Union(inversion);  	//    inversion.Dispose();  	//    test.Dispose();  	//     */  	//    // shade in the region  	//    if (m_shadeRegion == null)  	//    {  	//        m_shadeRegion = new Region();  	//        m_shadeRegion.MakeEmpty();  	//    }  	//    GraphicsPath test = (GraphicsPath)((Tools.Model.VectorPath)filter.Parameters.Path).InternalPath.Clone();  	//    test.Widen(new Pen(Color.Black' (float)filter.Parameters.PathThickness));  	//    m_shadeRegion.Union(test);  	//    test.Dispose();      	//}  	//// shade in the filter  	//else if (filter is Tools.MagneticLineRepulsionFilter)  	//{  	//    if (m_shadeRegion == null)  	//    {  	//        m_shadeRegion = new Region();  	//        m_shadeRegion.MakeEmpty();  	//    }  	//    GraphicsPath test = (GraphicsPath)((Tools.Model.VectorPath)filter.Parameters.Path).InternalPath.Clone();  	//    test.Widen(new Pen(Color.Black' (float)filter.Parameters.PathThickness));  	//    m_shadeRegion.Union(test);  	//    test.Dispose();                      	//}  	//// draw guide lines  	//if (filter is Tools.CorduroyFilter || filter is Tools.GridFilter  	//    || filter is Tools.SteadyHandFilter)  	//{  	//    if (m_guideLines == null)  	//        m_guideLines = new List<Clip>();  	//    Clip c = new Clip();  	//    PointD norm = filter.Parameters.V;  	//    PointD side1 = mousePos + norm * 1000;  	//    PointD side2 = mousePos - norm * 1000;  	//    c.ClipPath = new GraphicsPath();  	//    c.ClipPath.StartFigure();  	//    c.ClipPath.AddLine((Point)side1' (Point)side2);  	//    c.Filter = filter;  	//    if (filter is Tools.GridFilter)  	//    {  	//        PointD orth = PointD.Orthogonal(filter.Parameters.V);  	//        PointD end1 = mousePos + orth * 1000;  	//        PointD end2 = mousePos - orth * 1000;  	//        c.ClipPath.StartFigure();  	//        c.ClipPath.AddLine((Point)end1' (Point)end2);  	//    }  	//    m_guideLines.Add(c);  	//}  	//// draw online guides  	//if (filter is Tools.CompassFilter)  	//{  	//    PointD radiusVector = mousePos - filter.Parameters.Pt;  	//    double radius = radiusVector.Magnitude();  	//    if (radius > 0.0001)  	//    {  	//        if (m_guideLines == null)  	//            m_guideLines = new List<Clip>();  	//        Clip c = new Clip();  	//        c.ClipPath = new GraphicsPath();  	//        c.ClipPath.StartFigure();  	//        c.ClipPath.AddEllipse((float)(filter.Parameters.Pt.X - radius)' (float)(filter.Parameters.Pt.Y - radius)'  	//            (float)radius * 2' (float)radius * 2);  	//        m_guideLines.Add(c);  	//    }  	//}  	//if (filter is Tools.DimpleChadFilter)  	//{  	//    PointD vector = mousePos - filter.Parameters.Pt;  	//    if (vector.Magnitude() > 0.0001)  	//    {  	//        PointD unitVector = vector / vector.Magnitude();  	//        if (m_guideLines == null)  	//            m_guideLines = new List<Clip>();  	//        Clip c = new Clip();  	//        c.ClipPath = new GraphicsPath();  	//        c.ClipPath.StartFigure();  	//        c.ClipPath.AddLine((Point)(filter.Parameters.Pt + unitVector * Math.Max( filter.Parameters.PtSize.X' filter.Parameters.PtSize.Y) )'  	//            (Point)(filter.Parameters.Pt - unitVector * Math.Max(filter.Parameters.PtSize.X' filter.Parameters.PtSize.Y)));  	//        m_guideLines.Add(c);  	//    }  	//}  }  
Magic Number,KinTemplates.Cursor.Tools.Render,OnlineFeedback,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\Render\OnlineFeedback.cs,AddFilter,The following statement contains a magic number: if (filter is Tools.SandpaperFilter || filter is Tools.MaxFilter) {  	RegionToolRegionFilter rtrf = (RegionToolRegionFilter)filter;  	m_zoom = (int)((m_zoom + filter.Parameters.C * 100 * rtrf.GetStrength (mousePos)));  }  else if (filter is Tools.MinFilter || filter is Tools.IceSheetFilter) {  	RegionToolRegionFilter rtrf = (RegionToolRegionFilter)filter;  	m_zoom = (int)((m_zoom - filter.Parameters.C * 40 * rtrf.GetStrength (mousePos)));  	if (m_zoom < 10)  		m_zoom = 10;  }  
Magic Number,KinTemplates.Cursor.Tools.Render,OnlineFeedback,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\Render\OnlineFeedback.cs,AddFilter,The following statement contains a magic number: if (filter is Tools.SandpaperFilter || filter is Tools.MaxFilter) {  	RegionToolRegionFilter rtrf = (RegionToolRegionFilter)filter;  	m_zoom = (int)((m_zoom + filter.Parameters.C * 100 * rtrf.GetStrength (mousePos)));  }  else if (filter is Tools.MinFilter || filter is Tools.IceSheetFilter) {  	RegionToolRegionFilter rtrf = (RegionToolRegionFilter)filter;  	m_zoom = (int)((m_zoom - filter.Parameters.C * 40 * rtrf.GetStrength (mousePos)));  	if (m_zoom < 10)  		m_zoom = 10;  }  
Magic Number,KinTemplates.Cursor.Tools.Render,OnlineFeedback,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\Render\OnlineFeedback.cs,AddFilter,The following statement contains a magic number: if (filter is Tools.SandpaperFilter || filter is Tools.MaxFilter) {  	RegionToolRegionFilter rtrf = (RegionToolRegionFilter)filter;  	m_zoom = (int)((m_zoom + filter.Parameters.C * 100 * rtrf.GetStrength (mousePos)));  }  else if (filter is Tools.MinFilter || filter is Tools.IceSheetFilter) {  	RegionToolRegionFilter rtrf = (RegionToolRegionFilter)filter;  	m_zoom = (int)((m_zoom - filter.Parameters.C * 40 * rtrf.GetStrength (mousePos)));  	if (m_zoom < 10)  		m_zoom = 10;  }  
Magic Number,KinTemplates.Cursor.Tools.Render,OnlineFeedback,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\Render\OnlineFeedback.cs,AddFilter,The following statement contains a magic number: if (filter is Tools.SandpaperFilter || filter is Tools.MaxFilter) {  	RegionToolRegionFilter rtrf = (RegionToolRegionFilter)filter;  	m_zoom = (int)((m_zoom + filter.Parameters.C * 100 * rtrf.GetStrength (mousePos)));  }  else if (filter is Tools.MinFilter || filter is Tools.IceSheetFilter) {  	RegionToolRegionFilter rtrf = (RegionToolRegionFilter)filter;  	m_zoom = (int)((m_zoom - filter.Parameters.C * 40 * rtrf.GetStrength (mousePos)));  	if (m_zoom < 10)  		m_zoom = 10;  }  
Magic Number,KinTemplates.Cursor.Tools.Render,OnlineFeedback,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\Render\OnlineFeedback.cs,AddFilter,The following statement contains a magic number: m_zoom = (int)((m_zoom + filter.Parameters.C * 100 * rtrf.GetStrength (mousePos)));  
Magic Number,KinTemplates.Cursor.Tools.Render,OnlineFeedback,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\Render\OnlineFeedback.cs,AddFilter,The following statement contains a magic number: if (filter is Tools.MinFilter || filter is Tools.IceSheetFilter) {  	RegionToolRegionFilter rtrf = (RegionToolRegionFilter)filter;  	m_zoom = (int)((m_zoom - filter.Parameters.C * 40 * rtrf.GetStrength (mousePos)));  	if (m_zoom < 10)  		m_zoom = 10;  }  
Magic Number,KinTemplates.Cursor.Tools.Render,OnlineFeedback,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\Render\OnlineFeedback.cs,AddFilter,The following statement contains a magic number: if (filter is Tools.MinFilter || filter is Tools.IceSheetFilter) {  	RegionToolRegionFilter rtrf = (RegionToolRegionFilter)filter;  	m_zoom = (int)((m_zoom - filter.Parameters.C * 40 * rtrf.GetStrength (mousePos)));  	if (m_zoom < 10)  		m_zoom = 10;  }  
Magic Number,KinTemplates.Cursor.Tools.Render,OnlineFeedback,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\Render\OnlineFeedback.cs,AddFilter,The following statement contains a magic number: if (filter is Tools.MinFilter || filter is Tools.IceSheetFilter) {  	RegionToolRegionFilter rtrf = (RegionToolRegionFilter)filter;  	m_zoom = (int)((m_zoom - filter.Parameters.C * 40 * rtrf.GetStrength (mousePos)));  	if (m_zoom < 10)  		m_zoom = 10;  }  
Magic Number,KinTemplates.Cursor.Tools.Render,OnlineFeedback,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\Render\OnlineFeedback.cs,AddFilter,The following statement contains a magic number: m_zoom = (int)((m_zoom - filter.Parameters.C * 40 * rtrf.GetStrength (mousePos)));  
Magic Number,KinTemplates.Cursor.Tools.Render,OnlineFeedback,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\Render\OnlineFeedback.cs,AddFilter,The following statement contains a magic number: if (m_zoom < 10)  	m_zoom = 10;  
Magic Number,KinTemplates.Cursor.Tools.Render,OnlineFeedback,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\Render\OnlineFeedback.cs,AddFilter,The following statement contains a magic number: if (m_zoom < 10)  	m_zoom = 10;  
Magic Number,KinTemplates.Cursor.Tools.Render,OnlineFeedback,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\Render\OnlineFeedback.cs,AddFilter,The following statement contains a magic number: m_zoom = 10;  
Magic Number,KinTemplates.Cursor.Tools.Render,StaticFeedback,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\Render\StaticFeedback.cs,AddFilter,The following statement contains a magic number: if (filter is Tools.ConveyorBeltFilter || filter is Tools.ConveyorBeltFilter2 || filter is Tools.OrbitFilter || filter is Tools.OrbitFilter2 || filter is Tools.OrbitFilter3 || filter is Tools.MagneticLineAttractionFilter || filter is Tools.MagneticPointAttractionFilter || filter is Tools.RubberBandFilter// || filter is Tools.TunnelLineFilter   ) {  	if (m_forces == null) {  		Rectangle screenBounds = System.Windows.Forms.Screen.PrimaryScreen.Bounds;  		m_forces = new PointD[screenBounds.Width / FORCE_GRID][];  		for (int i = 0; i < m_forces.Length; i++) {  			m_forces [i] = new PointD[screenBounds.Height / FORCE_GRID];  		}  		//m_renderedForces = new Bitmap(screenBounds.Width' screenBounds.Height);  	}  	for (int i = 0; i < m_forces.Length; i++) {  		for (int j = 0; j < m_forces [i].Length; j++) {  			Point thePoint = new Point (i * FORCE_GRID' j * FORCE_GRID);  			if (filter.HitTest ((PointD)thePoint)) {  				// test all points with the filter  				Position.VirtualMousePosition mouse = new Position.VirtualMousePosition (thePoint);  				Position.ParameterizedMousePosition fakeMouse = new Position.ParameterizedMousePosition (mouse' 20);  				// TODO: instrument from the computer  				m_forces [i] [j] += filter.GetVelocity (fakeMouse) * Render.DrawHelper.SPEED_AMPLIFIER;  			}  		}  	}  }  
Magic Number,KinTemplates.Cursor.Tools.Render,StaticFeedback,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\Render\StaticFeedback.cs,AddFilter,The following statement contains a magic number: for (int i = 0; i < m_forces.Length; i++) {  	for (int j = 0; j < m_forces [i].Length; j++) {  		Point thePoint = new Point (i * FORCE_GRID' j * FORCE_GRID);  		if (filter.HitTest ((PointD)thePoint)) {  			// test all points with the filter  			Position.VirtualMousePosition mouse = new Position.VirtualMousePosition (thePoint);  			Position.ParameterizedMousePosition fakeMouse = new Position.ParameterizedMousePosition (mouse' 20);  			// TODO: instrument from the computer  			m_forces [i] [j] += filter.GetVelocity (fakeMouse) * Render.DrawHelper.SPEED_AMPLIFIER;  		}  	}  }  
Magic Number,KinTemplates.Cursor.Tools.Render,StaticFeedback,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\Render\StaticFeedback.cs,AddFilter,The following statement contains a magic number: for (int j = 0; j < m_forces [i].Length; j++) {  	Point thePoint = new Point (i * FORCE_GRID' j * FORCE_GRID);  	if (filter.HitTest ((PointD)thePoint)) {  		// test all points with the filter  		Position.VirtualMousePosition mouse = new Position.VirtualMousePosition (thePoint);  		Position.ParameterizedMousePosition fakeMouse = new Position.ParameterizedMousePosition (mouse' 20);  		// TODO: instrument from the computer  		m_forces [i] [j] += filter.GetVelocity (fakeMouse) * Render.DrawHelper.SPEED_AMPLIFIER;  	}  }  
Magic Number,KinTemplates.Cursor.Tools.Render,StaticFeedback,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\Render\StaticFeedback.cs,AddFilter,The following statement contains a magic number: if (filter.HitTest ((PointD)thePoint)) {  	// test all points with the filter  	Position.VirtualMousePosition mouse = new Position.VirtualMousePosition (thePoint);  	Position.ParameterizedMousePosition fakeMouse = new Position.ParameterizedMousePosition (mouse' 20);  	// TODO: instrument from the computer  	m_forces [i] [j] += filter.GetVelocity (fakeMouse) * Render.DrawHelper.SPEED_AMPLIFIER;  }  
Magic Number,KinTemplates.Cursor.Tools.Model,AspectRatioToolParameter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\Model\AspectRatioToolParameter.cs,SetBoundingRect,The following statement contains a magic number: m_ctrPt = new PointD (bounds.X + bounds.Width / 2' bounds.Y + bounds.Height / 2);  
Magic Number,KinTemplates.Cursor.Tools.Model,AspectRatioToolParameter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\Model\AspectRatioToolParameter.cs,SetBoundingRect,The following statement contains a magic number: m_ctrPt = new PointD (bounds.X + bounds.Width / 2' bounds.Y + bounds.Height / 2);  
Magic Number,KinTemplates.Cursor.Tools.Model,BitmapPath,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\Model\BitmapPath.cs,AddLine,The following statement contains a magic number: foreach (PointF pt in fill) {  	AddEllipse (new RectangleF (new PointF ((float)(pt.X - m_pathThickness)' (float)(pt.Y - m_pathThickness))' new SizeF ((float)(m_pathThickness * 2)' (float)(m_pathThickness * 2))));  }  
Magic Number,KinTemplates.Cursor.Tools.Model,BitmapPath,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\Model\BitmapPath.cs,AddLine,The following statement contains a magic number: foreach (PointF pt in fill) {  	AddEllipse (new RectangleF (new PointF ((float)(pt.X - m_pathThickness)' (float)(pt.Y - m_pathThickness))' new SizeF ((float)(m_pathThickness * 2)' (float)(m_pathThickness * 2))));  }  
Magic Number,KinTemplates.Cursor.Tools.Model,BitmapPath,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\Model\BitmapPath.cs,AddLine,The following statement contains a magic number: AddEllipse (new RectangleF (new PointF ((float)(pt.X - m_pathThickness)' (float)(pt.Y - m_pathThickness))' new SizeF ((float)(m_pathThickness * 2)' (float)(m_pathThickness * 2))));  
Magic Number,KinTemplates.Cursor.Tools.Model,BitmapPath,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\Model\BitmapPath.cs,AddLine,The following statement contains a magic number: AddEllipse (new RectangleF (new PointF ((float)(pt.X - m_pathThickness)' (float)(pt.Y - m_pathThickness))' new SizeF ((float)(m_pathThickness * 2)' (float)(m_pathThickness * 2))));  
Magic Number,KinTemplates.Cursor.Tools.Model,BitmapPath,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\Model\BitmapPath.cs,IsVisible,The following statement contains a magic number: return IsVisible (point' 255);  
Magic Number,KinTemplates.Cursor.Tools.Model,ToolParameter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\Model\ToolParameter.cs,ToolParameter,The following statement contains a magic number: C = 0.75;  
Missing Default,KinTemplates.Cursor.Tools.Model,RegionToolParameter,C:\repos\rhfung_KinematicTemplates\KTCursor\src\Tools\Model\RegionToolParameter.cs,SetBoundingRect,The following switch statement is missing a default case: switch (this.Shape) {  case PathShape.Curve:  	throw new NotImplementedException ();  case PathShape.Ellipse:  //m_path = new VectorPath();  //m_path.AddEllipse(bounds);  //break;  case PathShape.Rectangle:  //m_path = new VectorPath();  //m_path.AddRectangle(bounds);  //break;  case PathShape.Freeform:  	RectangleF oldBounds = GetBoundingRect ();  	SizeF oldSize = oldBounds.Size;  	SizeF newSize = bounds.Size;  	PointF oldCorner = oldBounds.Location;  	PointF newCorner = bounds.Location;  	System.Drawing.Drawing2D.Matrix m = new System.Drawing.Drawing2D.Matrix ();  	m.Translate (-oldCorner.X' -oldCorner.Y);  	m.Scale (newSize.Width / oldSize.Width' newSize.Height / oldSize.Height);  	m.Translate (newCorner.X' newCorner.Y);  	m_path.Transform (m);  	break;  }  
