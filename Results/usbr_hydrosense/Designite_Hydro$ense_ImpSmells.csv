Implementation smell,Namespace,Class,File,Method,Description
Long Method,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadHardcoded,The method has 286 lines of code.
Complex Method,HydroSense,GradientDescentSolver,C:\repos\usbr_hydrosense\Hydro$ense\GradientDescentSolver.cs,Solve,Cyclomatic complexity of the method is 13
Complex Method,HydroSense,GradientDescentSolver,C:\repos\usbr_hydrosense\Hydro$ense\GradientDescentSolver.cs,CheckConstraints,Cyclomatic complexity of the method is 17
Complex Method,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadLinksDataFromSheet,Cyclomatic complexity of the method is 8
Complex Method,HydroSense,Util,C:\repos\usbr_hydrosense\Hydro$ense\Util.cs,LUPDecomposition,Cyclomatic complexity of the method is 9
Complex Method,HydroSense,Util,C:\repos\usbr_hydrosense\Hydro$ense\Util.cs,LinearEquationSolver,Cyclomatic complexity of the method is 9
Long Parameter List,HydroSense,Util,C:\repos\usbr_hydrosense\Hydro$ense\Util.cs,WriteResultsToLog,The method has 6 parameters.
Long Statement,HydroSense,GradientDescentSolver,C:\repos\usbr_hydrosense\Hydro$ense\GradientDescentSolver.cs,Solve,The length of the statement  "				/* use the Marquardt Algorithm to condition the matrix */del2OFdelQ2 [i * nSupNodes + j] [i * nSupNodes + j] += Math.Exp ((iter - 500) * deltad); " is 145.
Long Statement,HydroSense,MainForm,C:\repos\usbr_hydrosense\Hydro$ense\MainForm.cs,MainForm_FormClosing,The length of the statement  "	DialogResult result = MessageBox.Show ("Are you sure you want to quit?"' ""' MessageBoxButtons.YesNo' MessageBoxIcon.Exclamation); " is 130.
Magic Number,HydroSense,GradientDescentSolver,C:\repos\usbr_hydrosense\Hydro$ense\GradientDescentSolver.cs,Solve,The following statement contains a magic number: while (delta > tol && iter < maxIter) {  	iter++;  	OF = ObjectiveFunction (mi' quantS' quantD);  	delQ1 = Util.CopyArray (quantS);  	delQ2 = Util.CopyArray (quantS);  	delQ12 = Util.CopyArray (quantS);  	/* Compute the numerical derivates for the Objective Function with                  * respect to each decision variable:                  *   The Objective Function is the integral of the marginal demand                  *   functions from zero to the Quantity provided at each demand node minus                  *   the integral of the marginal cost functions from zero to the Quantity                  *   provided from supply node j to demand node i. The DVs are the array                   *   of quantity from supply node j to demand node i */for (int i = 0; i < nDemNodes; i++) {  		for (int j = 0; j < nSupNodes; j++) {  			delQ1 [i] [j] -= deltad;  			delQ12 [i] [j] -= deltad;  			OF1 = ObjectiveFunction (mi' delQ1' quantD);  			delOFdelQ [i] [j] = (OF - OF1) / deltad;  			for (int ii = 0; ii < nDemNodes; ii++) {  				for (int jj = 0; jj < nSupNodes; jj++) {  					if (ii == i && jj == j)  						continue;  					delQ2 [ii] [jj] -= deltad;  					delQ12 [ii] [jj] -= deltad;  					OF2 = ObjectiveFunction (mi' delQ2' quantD);  					OF12 = ObjectiveFunction (mi' delQ12' quantD);  					delOFdelQ2 [ii] [jj] = (OF2 - OF12) / deltad;  					del2OFdelQ2 [i * nSupNodes + j] [ii * nSupNodes + jj] = (delOFdelQ [i] [j] - delOFdelQ2 [ii] [jj]) / deltad;  					delQ2 [ii] [jj] = quantS [ii] [jj];  					delQ12 [ii] [jj] = quantS [ii] [jj];  				}  			}  			/* set the second derivative on the diagonal */delQ1 [i] [j] += 2 * deltad;  			OF2 = ObjectiveFunction (mi' delQ1' quantD);  			delOFdelQ2 [i] [j] = (OF2 - OF) / deltad;  			del2OFdelQ2 [i * nSupNodes + j] [i * nSupNodes + j] = (delOFdelQ2 [i] [j] - delOFdelQ [i] [j]) / deltad;  			/* use the Marquardt Algorithm to condition the matrix */del2OFdelQ2 [i * nSupNodes + j] [i * nSupNodes + j] += Math.Exp ((iter - 500) * deltad);  			delQ2 [i] [j] = quantS [i] [j];  			delQ1 [i] [j] = quantS [i] [j];  			delQ12 [i] [j] = quantS [i] [j];  		}  	}  	/*  Determine the change in quantity from Demand Node i to Supply Node j                   *  by solving the linear set of equations [del2OFdelQ2]{dQ} = {delOFdelQ}                  *  using LUP Decomposition */double[] dQ = Util.LUPSolve (ref del2OFdelQ2' Util.ToFlat (delOFdelQ));  	for (int i = 0; i < nDemNodes; i++) {  		for (int j = 0; j < nSupNodes; j++) {  			quantS [i] [j] += dQ [i * nSupNodes + j];  		}  	}  	/* The partial derivates of the Objective Function with respect to the                  * Quantity provided from supply node j to demand node i are the                  * "direction" that decision variables should be adjusted for the simple                  * non-linear solver routine.  The "distance" the decision variables should                  * be adjusted is assumed to be 1.0. */double sum = 0.0;  	for (int i = 0; i < dQ.Length; i++) {  		sum += dQ [i] * dQ [i];  	}  	/* Adjust change in decision variables */delta = Math.Sqrt (sum);  	/* Calculate new objective function */OF = ObjectiveFunction (mi' quantS' quantD);  	/* Write iteration results to log */Util.WriteResultsToLog (log' OF' quantS' quantD' iter' delta);  	if (iter == maxIter)  		log.AppendLine ("Solver reached max iterations' solution may not be valid.");  }  
Magic Number,HydroSense,GradientDescentSolver,C:\repos\usbr_hydrosense\Hydro$ense\GradientDescentSolver.cs,Solve,The following statement contains a magic number: while (delta > tol && iter < maxIter) {  	iter++;  	OF = ObjectiveFunction (mi' quantS' quantD);  	delQ1 = Util.CopyArray (quantS);  	delQ2 = Util.CopyArray (quantS);  	delQ12 = Util.CopyArray (quantS);  	/* Compute the numerical derivates for the Objective Function with                  * respect to each decision variable:                  *   The Objective Function is the integral of the marginal demand                  *   functions from zero to the Quantity provided at each demand node minus                  *   the integral of the marginal cost functions from zero to the Quantity                  *   provided from supply node j to demand node i. The DVs are the array                   *   of quantity from supply node j to demand node i */for (int i = 0; i < nDemNodes; i++) {  		for (int j = 0; j < nSupNodes; j++) {  			delQ1 [i] [j] -= deltad;  			delQ12 [i] [j] -= deltad;  			OF1 = ObjectiveFunction (mi' delQ1' quantD);  			delOFdelQ [i] [j] = (OF - OF1) / deltad;  			for (int ii = 0; ii < nDemNodes; ii++) {  				for (int jj = 0; jj < nSupNodes; jj++) {  					if (ii == i && jj == j)  						continue;  					delQ2 [ii] [jj] -= deltad;  					delQ12 [ii] [jj] -= deltad;  					OF2 = ObjectiveFunction (mi' delQ2' quantD);  					OF12 = ObjectiveFunction (mi' delQ12' quantD);  					delOFdelQ2 [ii] [jj] = (OF2 - OF12) / deltad;  					del2OFdelQ2 [i * nSupNodes + j] [ii * nSupNodes + jj] = (delOFdelQ [i] [j] - delOFdelQ2 [ii] [jj]) / deltad;  					delQ2 [ii] [jj] = quantS [ii] [jj];  					delQ12 [ii] [jj] = quantS [ii] [jj];  				}  			}  			/* set the second derivative on the diagonal */delQ1 [i] [j] += 2 * deltad;  			OF2 = ObjectiveFunction (mi' delQ1' quantD);  			delOFdelQ2 [i] [j] = (OF2 - OF) / deltad;  			del2OFdelQ2 [i * nSupNodes + j] [i * nSupNodes + j] = (delOFdelQ2 [i] [j] - delOFdelQ [i] [j]) / deltad;  			/* use the Marquardt Algorithm to condition the matrix */del2OFdelQ2 [i * nSupNodes + j] [i * nSupNodes + j] += Math.Exp ((iter - 500) * deltad);  			delQ2 [i] [j] = quantS [i] [j];  			delQ1 [i] [j] = quantS [i] [j];  			delQ12 [i] [j] = quantS [i] [j];  		}  	}  	/*  Determine the change in quantity from Demand Node i to Supply Node j                   *  by solving the linear set of equations [del2OFdelQ2]{dQ} = {delOFdelQ}                  *  using LUP Decomposition */double[] dQ = Util.LUPSolve (ref del2OFdelQ2' Util.ToFlat (delOFdelQ));  	for (int i = 0; i < nDemNodes; i++) {  		for (int j = 0; j < nSupNodes; j++) {  			quantS [i] [j] += dQ [i * nSupNodes + j];  		}  	}  	/* The partial derivates of the Objective Function with respect to the                  * Quantity provided from supply node j to demand node i are the                  * "direction" that decision variables should be adjusted for the simple                  * non-linear solver routine.  The "distance" the decision variables should                  * be adjusted is assumed to be 1.0. */double sum = 0.0;  	for (int i = 0; i < dQ.Length; i++) {  		sum += dQ [i] * dQ [i];  	}  	/* Adjust change in decision variables */delta = Math.Sqrt (sum);  	/* Calculate new objective function */OF = ObjectiveFunction (mi' quantS' quantD);  	/* Write iteration results to log */Util.WriteResultsToLog (log' OF' quantS' quantD' iter' delta);  	if (iter == maxIter)  		log.AppendLine ("Solver reached max iterations' solution may not be valid.");  }  
Magic Number,HydroSense,GradientDescentSolver,C:\repos\usbr_hydrosense\Hydro$ense\GradientDescentSolver.cs,Solve,The following statement contains a magic number: for (int i = 0; i < nDemNodes; i++) {  	for (int j = 0; j < nSupNodes; j++) {  		delQ1 [i] [j] -= deltad;  		delQ12 [i] [j] -= deltad;  		OF1 = ObjectiveFunction (mi' delQ1' quantD);  		delOFdelQ [i] [j] = (OF - OF1) / deltad;  		for (int ii = 0; ii < nDemNodes; ii++) {  			for (int jj = 0; jj < nSupNodes; jj++) {  				if (ii == i && jj == j)  					continue;  				delQ2 [ii] [jj] -= deltad;  				delQ12 [ii] [jj] -= deltad;  				OF2 = ObjectiveFunction (mi' delQ2' quantD);  				OF12 = ObjectiveFunction (mi' delQ12' quantD);  				delOFdelQ2 [ii] [jj] = (OF2 - OF12) / deltad;  				del2OFdelQ2 [i * nSupNodes + j] [ii * nSupNodes + jj] = (delOFdelQ [i] [j] - delOFdelQ2 [ii] [jj]) / deltad;  				delQ2 [ii] [jj] = quantS [ii] [jj];  				delQ12 [ii] [jj] = quantS [ii] [jj];  			}  		}  		/* set the second derivative on the diagonal */delQ1 [i] [j] += 2 * deltad;  		OF2 = ObjectiveFunction (mi' delQ1' quantD);  		delOFdelQ2 [i] [j] = (OF2 - OF) / deltad;  		del2OFdelQ2 [i * nSupNodes + j] [i * nSupNodes + j] = (delOFdelQ2 [i] [j] - delOFdelQ [i] [j]) / deltad;  		/* use the Marquardt Algorithm to condition the matrix */del2OFdelQ2 [i * nSupNodes + j] [i * nSupNodes + j] += Math.Exp ((iter - 500) * deltad);  		delQ2 [i] [j] = quantS [i] [j];  		delQ1 [i] [j] = quantS [i] [j];  		delQ12 [i] [j] = quantS [i] [j];  	}  }  
Magic Number,HydroSense,GradientDescentSolver,C:\repos\usbr_hydrosense\Hydro$ense\GradientDescentSolver.cs,Solve,The following statement contains a magic number: for (int i = 0; i < nDemNodes; i++) {  	for (int j = 0; j < nSupNodes; j++) {  		delQ1 [i] [j] -= deltad;  		delQ12 [i] [j] -= deltad;  		OF1 = ObjectiveFunction (mi' delQ1' quantD);  		delOFdelQ [i] [j] = (OF - OF1) / deltad;  		for (int ii = 0; ii < nDemNodes; ii++) {  			for (int jj = 0; jj < nSupNodes; jj++) {  				if (ii == i && jj == j)  					continue;  				delQ2 [ii] [jj] -= deltad;  				delQ12 [ii] [jj] -= deltad;  				OF2 = ObjectiveFunction (mi' delQ2' quantD);  				OF12 = ObjectiveFunction (mi' delQ12' quantD);  				delOFdelQ2 [ii] [jj] = (OF2 - OF12) / deltad;  				del2OFdelQ2 [i * nSupNodes + j] [ii * nSupNodes + jj] = (delOFdelQ [i] [j] - delOFdelQ2 [ii] [jj]) / deltad;  				delQ2 [ii] [jj] = quantS [ii] [jj];  				delQ12 [ii] [jj] = quantS [ii] [jj];  			}  		}  		/* set the second derivative on the diagonal */delQ1 [i] [j] += 2 * deltad;  		OF2 = ObjectiveFunction (mi' delQ1' quantD);  		delOFdelQ2 [i] [j] = (OF2 - OF) / deltad;  		del2OFdelQ2 [i * nSupNodes + j] [i * nSupNodes + j] = (delOFdelQ2 [i] [j] - delOFdelQ [i] [j]) / deltad;  		/* use the Marquardt Algorithm to condition the matrix */del2OFdelQ2 [i * nSupNodes + j] [i * nSupNodes + j] += Math.Exp ((iter - 500) * deltad);  		delQ2 [i] [j] = quantS [i] [j];  		delQ1 [i] [j] = quantS [i] [j];  		delQ12 [i] [j] = quantS [i] [j];  	}  }  
Magic Number,HydroSense,GradientDescentSolver,C:\repos\usbr_hydrosense\Hydro$ense\GradientDescentSolver.cs,Solve,The following statement contains a magic number: for (int j = 0; j < nSupNodes; j++) {  	delQ1 [i] [j] -= deltad;  	delQ12 [i] [j] -= deltad;  	OF1 = ObjectiveFunction (mi' delQ1' quantD);  	delOFdelQ [i] [j] = (OF - OF1) / deltad;  	for (int ii = 0; ii < nDemNodes; ii++) {  		for (int jj = 0; jj < nSupNodes; jj++) {  			if (ii == i && jj == j)  				continue;  			delQ2 [ii] [jj] -= deltad;  			delQ12 [ii] [jj] -= deltad;  			OF2 = ObjectiveFunction (mi' delQ2' quantD);  			OF12 = ObjectiveFunction (mi' delQ12' quantD);  			delOFdelQ2 [ii] [jj] = (OF2 - OF12) / deltad;  			del2OFdelQ2 [i * nSupNodes + j] [ii * nSupNodes + jj] = (delOFdelQ [i] [j] - delOFdelQ2 [ii] [jj]) / deltad;  			delQ2 [ii] [jj] = quantS [ii] [jj];  			delQ12 [ii] [jj] = quantS [ii] [jj];  		}  	}  	/* set the second derivative on the diagonal */delQ1 [i] [j] += 2 * deltad;  	OF2 = ObjectiveFunction (mi' delQ1' quantD);  	delOFdelQ2 [i] [j] = (OF2 - OF) / deltad;  	del2OFdelQ2 [i * nSupNodes + j] [i * nSupNodes + j] = (delOFdelQ2 [i] [j] - delOFdelQ [i] [j]) / deltad;  	/* use the Marquardt Algorithm to condition the matrix */del2OFdelQ2 [i * nSupNodes + j] [i * nSupNodes + j] += Math.Exp ((iter - 500) * deltad);  	delQ2 [i] [j] = quantS [i] [j];  	delQ1 [i] [j] = quantS [i] [j];  	delQ12 [i] [j] = quantS [i] [j];  }  
Magic Number,HydroSense,GradientDescentSolver,C:\repos\usbr_hydrosense\Hydro$ense\GradientDescentSolver.cs,Solve,The following statement contains a magic number: for (int j = 0; j < nSupNodes; j++) {  	delQ1 [i] [j] -= deltad;  	delQ12 [i] [j] -= deltad;  	OF1 = ObjectiveFunction (mi' delQ1' quantD);  	delOFdelQ [i] [j] = (OF - OF1) / deltad;  	for (int ii = 0; ii < nDemNodes; ii++) {  		for (int jj = 0; jj < nSupNodes; jj++) {  			if (ii == i && jj == j)  				continue;  			delQ2 [ii] [jj] -= deltad;  			delQ12 [ii] [jj] -= deltad;  			OF2 = ObjectiveFunction (mi' delQ2' quantD);  			OF12 = ObjectiveFunction (mi' delQ12' quantD);  			delOFdelQ2 [ii] [jj] = (OF2 - OF12) / deltad;  			del2OFdelQ2 [i * nSupNodes + j] [ii * nSupNodes + jj] = (delOFdelQ [i] [j] - delOFdelQ2 [ii] [jj]) / deltad;  			delQ2 [ii] [jj] = quantS [ii] [jj];  			delQ12 [ii] [jj] = quantS [ii] [jj];  		}  	}  	/* set the second derivative on the diagonal */delQ1 [i] [j] += 2 * deltad;  	OF2 = ObjectiveFunction (mi' delQ1' quantD);  	delOFdelQ2 [i] [j] = (OF2 - OF) / deltad;  	del2OFdelQ2 [i * nSupNodes + j] [i * nSupNodes + j] = (delOFdelQ2 [i] [j] - delOFdelQ [i] [j]) / deltad;  	/* use the Marquardt Algorithm to condition the matrix */del2OFdelQ2 [i * nSupNodes + j] [i * nSupNodes + j] += Math.Exp ((iter - 500) * deltad);  	delQ2 [i] [j] = quantS [i] [j];  	delQ1 [i] [j] = quantS [i] [j];  	delQ12 [i] [j] = quantS [i] [j];  }  
Magic Number,HydroSense,GradientDescentSolver,C:\repos\usbr_hydrosense\Hydro$ense\GradientDescentSolver.cs,Solve,The following statement contains a magic number: delQ1 [i] [j] += 2 * deltad;  
Magic Number,HydroSense,GradientDescentSolver,C:\repos\usbr_hydrosense\Hydro$ense\GradientDescentSolver.cs,Solve,The following statement contains a magic number: del2OFdelQ2 [i * nSupNodes + j] [i * nSupNodes + j] += Math.Exp ((iter - 500) * deltad);  
Magic Number,HydroSense,GradientDescentSolver,C:\repos\usbr_hydrosense\Hydro$ense\GradientDescentSolver.cs,CheckConstraints,The following statement contains a magic number: for (int i = 0; i < nSupNodes; i++) {  	double totalS = Util.SumColumn (quantS' i);  	double limit = mi.supplyNodes.UpperLimit (i);  	if (totalS > limit) {  		double ratio = 0.9999 * (limit / totalS);  		for (int j = 0; j < nDemNodes; j++) {  			quantS [j] [i] *= ratio;  		}  	}  }  
Magic Number,HydroSense,GradientDescentSolver,C:\repos\usbr_hydrosense\Hydro$ense\GradientDescentSolver.cs,CheckConstraints,The following statement contains a magic number: if (totalS > limit) {  	double ratio = 0.9999 * (limit / totalS);  	for (int j = 0; j < nDemNodes; j++) {  		quantS [j] [i] *= ratio;  	}  }  
Magic Number,HydroSense,LinkCosts,C:\repos\usbr_hydrosense\Hydro$ense\LinkCosts.cs,LinkCosts,The following statement contains a magic number: for (int i = 0; i < YC.Length; i++) {  	YC [i] = new double[x [i].Length][];  	for (int j = 0; j < YC [i].Length; j++) {  		val = 0.0;  		YC [i] [j] = new double[x [i] [j].Length];  		for (int k = 0; k < YC [i] [j].Length; k++) {  			if (k > 0) {  				val += ((y [i] [j] [k] + y [i] [j] [k - 1]) / 2.0) * (x [i] [j] [k] - x [i] [j] [k - 1]);  			}  			YC [i] [j] [k] = val;  		}  	}  }  
Magic Number,HydroSense,LinkCosts,C:\repos\usbr_hydrosense\Hydro$ense\LinkCosts.cs,LinkCosts,The following statement contains a magic number: for (int j = 0; j < YC [i].Length; j++) {  	val = 0.0;  	YC [i] [j] = new double[x [i] [j].Length];  	for (int k = 0; k < YC [i] [j].Length; k++) {  		if (k > 0) {  			val += ((y [i] [j] [k] + y [i] [j] [k - 1]) / 2.0) * (x [i] [j] [k] - x [i] [j] [k - 1]);  		}  		YC [i] [j] [k] = val;  	}  }  
Magic Number,HydroSense,LinkCosts,C:\repos\usbr_hydrosense\Hydro$ense\LinkCosts.cs,LinkCosts,The following statement contains a magic number: for (int k = 0; k < YC [i] [j].Length; k++) {  	if (k > 0) {  		val += ((y [i] [j] [k] + y [i] [j] [k - 1]) / 2.0) * (x [i] [j] [k] - x [i] [j] [k - 1]);  	}  	YC [i] [j] [k] = val;  }  
Magic Number,HydroSense,LinkCosts,C:\repos\usbr_hydrosense\Hydro$ense\LinkCosts.cs,LinkCosts,The following statement contains a magic number: if (k > 0) {  	val += ((y [i] [j] [k] + y [i] [j] [k - 1]) / 2.0) * (x [i] [j] [k] - x [i] [j] [k - 1]);  }  
Magic Number,HydroSense,LinkCosts,C:\repos\usbr_hydrosense\Hydro$ense\LinkCosts.cs,LinkCosts,The following statement contains a magic number: val += ((y [i] [j] [k] + y [i] [j] [k - 1]) / 2.0) * (x [i] [j] [k] - x [i] [j] [k - 1]);  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadLinksDataFromSheet,The following statement contains a magic number: numSupplies /= 2;  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadLinksDataFromSheet,The following statement contains a magic number: for (int i = 0; i < rowCount; i++) {  	IRow row = sheet.GetRow (i);  	int dem = Convert.ToInt32 (sheet.GetRow (i).GetCell (0).NumericCellValue) - 1;  	int sup = Convert.ToInt32 (sheet.GetRow (i).GetCell (1).NumericCellValue) - 1;  	int numPoints = GetPointCount (row) - 2;  	if (numPoints > 0) {  		if (i % 2 == 0) {  			x [dem] [sup] = new double[numPoints];  			for (int k = 0; k < numPoints; k++) {  				x [dem] [sup] [k] = row.GetCell (k + 2).NumericCellValue;  			}  		}  		else {  			y [dem] [sup] = new double[numPoints];  			for (int k = 0; k < numPoints; k++) {  				y [dem] [sup] [k] = row.GetCell (k + 2).NumericCellValue;  			}  		}  	}  }  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadLinksDataFromSheet,The following statement contains a magic number: for (int i = 0; i < rowCount; i++) {  	IRow row = sheet.GetRow (i);  	int dem = Convert.ToInt32 (sheet.GetRow (i).GetCell (0).NumericCellValue) - 1;  	int sup = Convert.ToInt32 (sheet.GetRow (i).GetCell (1).NumericCellValue) - 1;  	int numPoints = GetPointCount (row) - 2;  	if (numPoints > 0) {  		if (i % 2 == 0) {  			x [dem] [sup] = new double[numPoints];  			for (int k = 0; k < numPoints; k++) {  				x [dem] [sup] [k] = row.GetCell (k + 2).NumericCellValue;  			}  		}  		else {  			y [dem] [sup] = new double[numPoints];  			for (int k = 0; k < numPoints; k++) {  				y [dem] [sup] [k] = row.GetCell (k + 2).NumericCellValue;  			}  		}  	}  }  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadLinksDataFromSheet,The following statement contains a magic number: for (int i = 0; i < rowCount; i++) {  	IRow row = sheet.GetRow (i);  	int dem = Convert.ToInt32 (sheet.GetRow (i).GetCell (0).NumericCellValue) - 1;  	int sup = Convert.ToInt32 (sheet.GetRow (i).GetCell (1).NumericCellValue) - 1;  	int numPoints = GetPointCount (row) - 2;  	if (numPoints > 0) {  		if (i % 2 == 0) {  			x [dem] [sup] = new double[numPoints];  			for (int k = 0; k < numPoints; k++) {  				x [dem] [sup] [k] = row.GetCell (k + 2).NumericCellValue;  			}  		}  		else {  			y [dem] [sup] = new double[numPoints];  			for (int k = 0; k < numPoints; k++) {  				y [dem] [sup] [k] = row.GetCell (k + 2).NumericCellValue;  			}  		}  	}  }  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadLinksDataFromSheet,The following statement contains a magic number: for (int i = 0; i < rowCount; i++) {  	IRow row = sheet.GetRow (i);  	int dem = Convert.ToInt32 (sheet.GetRow (i).GetCell (0).NumericCellValue) - 1;  	int sup = Convert.ToInt32 (sheet.GetRow (i).GetCell (1).NumericCellValue) - 1;  	int numPoints = GetPointCount (row) - 2;  	if (numPoints > 0) {  		if (i % 2 == 0) {  			x [dem] [sup] = new double[numPoints];  			for (int k = 0; k < numPoints; k++) {  				x [dem] [sup] [k] = row.GetCell (k + 2).NumericCellValue;  			}  		}  		else {  			y [dem] [sup] = new double[numPoints];  			for (int k = 0; k < numPoints; k++) {  				y [dem] [sup] [k] = row.GetCell (k + 2).NumericCellValue;  			}  		}  	}  }  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadLinksDataFromSheet,The following statement contains a magic number: if (numPoints > 0) {  	if (i % 2 == 0) {  		x [dem] [sup] = new double[numPoints];  		for (int k = 0; k < numPoints; k++) {  			x [dem] [sup] [k] = row.GetCell (k + 2).NumericCellValue;  		}  	}  	else {  		y [dem] [sup] = new double[numPoints];  		for (int k = 0; k < numPoints; k++) {  			y [dem] [sup] [k] = row.GetCell (k + 2).NumericCellValue;  		}  	}  }  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadLinksDataFromSheet,The following statement contains a magic number: if (numPoints > 0) {  	if (i % 2 == 0) {  		x [dem] [sup] = new double[numPoints];  		for (int k = 0; k < numPoints; k++) {  			x [dem] [sup] [k] = row.GetCell (k + 2).NumericCellValue;  		}  	}  	else {  		y [dem] [sup] = new double[numPoints];  		for (int k = 0; k < numPoints; k++) {  			y [dem] [sup] [k] = row.GetCell (k + 2).NumericCellValue;  		}  	}  }  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadLinksDataFromSheet,The following statement contains a magic number: if (numPoints > 0) {  	if (i % 2 == 0) {  		x [dem] [sup] = new double[numPoints];  		for (int k = 0; k < numPoints; k++) {  			x [dem] [sup] [k] = row.GetCell (k + 2).NumericCellValue;  		}  	}  	else {  		y [dem] [sup] = new double[numPoints];  		for (int k = 0; k < numPoints; k++) {  			y [dem] [sup] [k] = row.GetCell (k + 2).NumericCellValue;  		}  	}  }  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadLinksDataFromSheet,The following statement contains a magic number: if (i % 2 == 0) {  	x [dem] [sup] = new double[numPoints];  	for (int k = 0; k < numPoints; k++) {  		x [dem] [sup] [k] = row.GetCell (k + 2).NumericCellValue;  	}  }  else {  	y [dem] [sup] = new double[numPoints];  	for (int k = 0; k < numPoints; k++) {  		y [dem] [sup] [k] = row.GetCell (k + 2).NumericCellValue;  	}  }  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadLinksDataFromSheet,The following statement contains a magic number: if (i % 2 == 0) {  	x [dem] [sup] = new double[numPoints];  	for (int k = 0; k < numPoints; k++) {  		x [dem] [sup] [k] = row.GetCell (k + 2).NumericCellValue;  	}  }  else {  	y [dem] [sup] = new double[numPoints];  	for (int k = 0; k < numPoints; k++) {  		y [dem] [sup] [k] = row.GetCell (k + 2).NumericCellValue;  	}  }  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadLinksDataFromSheet,The following statement contains a magic number: if (i % 2 == 0) {  	x [dem] [sup] = new double[numPoints];  	for (int k = 0; k < numPoints; k++) {  		x [dem] [sup] [k] = row.GetCell (k + 2).NumericCellValue;  	}  }  else {  	y [dem] [sup] = new double[numPoints];  	for (int k = 0; k < numPoints; k++) {  		y [dem] [sup] [k] = row.GetCell (k + 2).NumericCellValue;  	}  }  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadLinksDataFromSheet,The following statement contains a magic number: for (int k = 0; k < numPoints; k++) {  	x [dem] [sup] [k] = row.GetCell (k + 2).NumericCellValue;  }  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadLinksDataFromSheet,The following statement contains a magic number: x [dem] [sup] [k] = row.GetCell (k + 2).NumericCellValue;  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadLinksDataFromSheet,The following statement contains a magic number: for (int k = 0; k < numPoints; k++) {  	y [dem] [sup] [k] = row.GetCell (k + 2).NumericCellValue;  }  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadLinksDataFromSheet,The following statement contains a magic number: y [dem] [sup] [k] = row.GetCell (k + 2).NumericCellValue;  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadNodesDataFromSheet,The following statement contains a magic number: for (int i = 0; i < rowCount; i++) {  	IRow row = sheet.GetRow (i);  	int numPoints = GetPointCount (row);  	if (numPoints > 0) {  		if (i % 2 == 0) {  			x [xidx] = new double[numPoints];  			for (int j = 0; j < numPoints; j++) {  				x [xidx] [j] = row.GetCell (j).NumericCellValue;  			}  			xidx++;  		}  		else {  			y [yidx] = new double[numPoints];  			for (int j = 0; j < numPoints; j++) {  				y [yidx] [j] = row.GetCell (j).NumericCellValue;  			}  			yidx++;  		}  	}  }  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadNodesDataFromSheet,The following statement contains a magic number: if (numPoints > 0) {  	if (i % 2 == 0) {  		x [xidx] = new double[numPoints];  		for (int j = 0; j < numPoints; j++) {  			x [xidx] [j] = row.GetCell (j).NumericCellValue;  		}  		xidx++;  	}  	else {  		y [yidx] = new double[numPoints];  		for (int j = 0; j < numPoints; j++) {  			y [yidx] [j] = row.GetCell (j).NumericCellValue;  		}  		yidx++;  	}  }  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadNodesDataFromSheet,The following statement contains a magic number: if (i % 2 == 0) {  	x [xidx] = new double[numPoints];  	for (int j = 0; j < numPoints; j++) {  		x [xidx] [j] = row.GetCell (j).NumericCellValue;  	}  	xidx++;  }  else {  	y [yidx] = new double[numPoints];  	for (int j = 0; j < numPoints; j++) {  		y [yidx] [j] = row.GetCell (j).NumericCellValue;  	}  	yidx++;  }  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadHardcoded,The following statement contains a magic number: Xs = new double[2][];  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadHardcoded,The following statement contains a magic number: Ys = new double[2][];  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadHardcoded,The following statement contains a magic number: Xs [0] = new double[] {  	0.0'  	2000.0'  	4000.0'  	5000.0'  	7500.0'  	10000.0'  	20000.0'  	30000.0'  	50000.0'  	65000.0  };  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadHardcoded,The following statement contains a magic number: Xs [0] = new double[] {  	0.0'  	2000.0'  	4000.0'  	5000.0'  	7500.0'  	10000.0'  	20000.0'  	30000.0'  	50000.0'  	65000.0  };  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadHardcoded,The following statement contains a magic number: Xs [0] = new double[] {  	0.0'  	2000.0'  	4000.0'  	5000.0'  	7500.0'  	10000.0'  	20000.0'  	30000.0'  	50000.0'  	65000.0  };  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadHardcoded,The following statement contains a magic number: Xs [0] = new double[] {  	0.0'  	2000.0'  	4000.0'  	5000.0'  	7500.0'  	10000.0'  	20000.0'  	30000.0'  	50000.0'  	65000.0  };  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadHardcoded,The following statement contains a magic number: Xs [0] = new double[] {  	0.0'  	2000.0'  	4000.0'  	5000.0'  	7500.0'  	10000.0'  	20000.0'  	30000.0'  	50000.0'  	65000.0  };  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadHardcoded,The following statement contains a magic number: Xs [0] = new double[] {  	0.0'  	2000.0'  	4000.0'  	5000.0'  	7500.0'  	10000.0'  	20000.0'  	30000.0'  	50000.0'  	65000.0  };  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadHardcoded,The following statement contains a magic number: Xs [0] = new double[] {  	0.0'  	2000.0'  	4000.0'  	5000.0'  	7500.0'  	10000.0'  	20000.0'  	30000.0'  	50000.0'  	65000.0  };  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadHardcoded,The following statement contains a magic number: Xs [0] = new double[] {  	0.0'  	2000.0'  	4000.0'  	5000.0'  	7500.0'  	10000.0'  	20000.0'  	30000.0'  	50000.0'  	65000.0  };  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadHardcoded,The following statement contains a magic number: Xs [0] = new double[] {  	0.0'  	2000.0'  	4000.0'  	5000.0'  	7500.0'  	10000.0'  	20000.0'  	30000.0'  	50000.0'  	65000.0  };  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadHardcoded,The following statement contains a magic number: Xs [1] = new double[] {  	0.0'  	1000.0'  	2500.0'  	5000.0'  	8000.0'  	10000.0'  	15000.0'  	25000.0  };  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadHardcoded,The following statement contains a magic number: Xs [1] = new double[] {  	0.0'  	1000.0'  	2500.0'  	5000.0'  	8000.0'  	10000.0'  	15000.0'  	25000.0  };  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadHardcoded,The following statement contains a magic number: Xs [1] = new double[] {  	0.0'  	1000.0'  	2500.0'  	5000.0'  	8000.0'  	10000.0'  	15000.0'  	25000.0  };  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadHardcoded,The following statement contains a magic number: Xs [1] = new double[] {  	0.0'  	1000.0'  	2500.0'  	5000.0'  	8000.0'  	10000.0'  	15000.0'  	25000.0  };  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadHardcoded,The following statement contains a magic number: Xs [1] = new double[] {  	0.0'  	1000.0'  	2500.0'  	5000.0'  	8000.0'  	10000.0'  	15000.0'  	25000.0  };  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadHardcoded,The following statement contains a magic number: Xs [1] = new double[] {  	0.0'  	1000.0'  	2500.0'  	5000.0'  	8000.0'  	10000.0'  	15000.0'  	25000.0  };  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadHardcoded,The following statement contains a magic number: Xs [1] = new double[] {  	0.0'  	1000.0'  	2500.0'  	5000.0'  	8000.0'  	10000.0'  	15000.0'  	25000.0  };  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadHardcoded,The following statement contains a magic number: Ys [0] = new double[] {  	3.0'  	3.061'  	3.122'  	3.154'  	3.234'  	3.316'  	3.664'  	4.050'  	4.946'  	5.747  };  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadHardcoded,The following statement contains a magic number: Ys [0] = new double[] {  	3.0'  	3.061'  	3.122'  	3.154'  	3.234'  	3.316'  	3.664'  	4.050'  	4.946'  	5.747  };  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadHardcoded,The following statement contains a magic number: Ys [0] = new double[] {  	3.0'  	3.061'  	3.122'  	3.154'  	3.234'  	3.316'  	3.664'  	4.050'  	4.946'  	5.747  };  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadHardcoded,The following statement contains a magic number: Ys [0] = new double[] {  	3.0'  	3.061'  	3.122'  	3.154'  	3.234'  	3.316'  	3.664'  	4.050'  	4.946'  	5.747  };  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadHardcoded,The following statement contains a magic number: Ys [0] = new double[] {  	3.0'  	3.061'  	3.122'  	3.154'  	3.234'  	3.316'  	3.664'  	4.050'  	4.946'  	5.747  };  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadHardcoded,The following statement contains a magic number: Ys [0] = new double[] {  	3.0'  	3.061'  	3.122'  	3.154'  	3.234'  	3.316'  	3.664'  	4.050'  	4.946'  	5.747  };  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadHardcoded,The following statement contains a magic number: Ys [0] = new double[] {  	3.0'  	3.061'  	3.122'  	3.154'  	3.234'  	3.316'  	3.664'  	4.050'  	4.946'  	5.747  };  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadHardcoded,The following statement contains a magic number: Ys [0] = new double[] {  	3.0'  	3.061'  	3.122'  	3.154'  	3.234'  	3.316'  	3.664'  	4.050'  	4.946'  	5.747  };  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadHardcoded,The following statement contains a magic number: Ys [0] = new double[] {  	3.0'  	3.061'  	3.122'  	3.154'  	3.234'  	3.316'  	3.664'  	4.050'  	4.946'  	5.747  };  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadHardcoded,The following statement contains a magic number: Ys [0] = new double[] {  	3.0'  	3.061'  	3.122'  	3.154'  	3.234'  	3.316'  	3.664'  	4.050'  	4.946'  	5.747  };  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadHardcoded,The following statement contains a magic number: Ys [1] = new double[] {  	1.50'  	1.546'  	1.617'  	1.743'  	1.907'  	2.025'  	2.352'  	3.176  };  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadHardcoded,The following statement contains a magic number: Ys [1] = new double[] {  	1.50'  	1.546'  	1.617'  	1.743'  	1.907'  	2.025'  	2.352'  	3.176  };  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadHardcoded,The following statement contains a magic number: Ys [1] = new double[] {  	1.50'  	1.546'  	1.617'  	1.743'  	1.907'  	2.025'  	2.352'  	3.176  };  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadHardcoded,The following statement contains a magic number: Ys [1] = new double[] {  	1.50'  	1.546'  	1.617'  	1.743'  	1.907'  	2.025'  	2.352'  	3.176  };  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadHardcoded,The following statement contains a magic number: Ys [1] = new double[] {  	1.50'  	1.546'  	1.617'  	1.743'  	1.907'  	2.025'  	2.352'  	3.176  };  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadHardcoded,The following statement contains a magic number: Ys [1] = new double[] {  	1.50'  	1.546'  	1.617'  	1.743'  	1.907'  	2.025'  	2.352'  	3.176  };  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadHardcoded,The following statement contains a magic number: Ys [1] = new double[] {  	1.50'  	1.546'  	1.617'  	1.743'  	1.907'  	2.025'  	2.352'  	3.176  };  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadHardcoded,The following statement contains a magic number: Ys [1] = new double[] {  	1.50'  	1.546'  	1.617'  	1.743'  	1.907'  	2.025'  	2.352'  	3.176  };  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadHardcoded,The following statement contains a magic number: Xd = new double[3][];  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadHardcoded,The following statement contains a magic number: Yd = new double[3][];  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadHardcoded,The following statement contains a magic number: Xd [0] = new double[] {  	0.0'  	2000.0'  	4000.0'  	7500.0'  	10000.0'  	15000.0'  	20000.0'  	30000.0'  	40000.0  };  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadHardcoded,The following statement contains a magic number: Xd [0] = new double[] {  	0.0'  	2000.0'  	4000.0'  	7500.0'  	10000.0'  	15000.0'  	20000.0'  	30000.0'  	40000.0  };  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadHardcoded,The following statement contains a magic number: Xd [0] = new double[] {  	0.0'  	2000.0'  	4000.0'  	7500.0'  	10000.0'  	15000.0'  	20000.0'  	30000.0'  	40000.0  };  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadHardcoded,The following statement contains a magic number: Xd [0] = new double[] {  	0.0'  	2000.0'  	4000.0'  	7500.0'  	10000.0'  	15000.0'  	20000.0'  	30000.0'  	40000.0  };  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadHardcoded,The following statement contains a magic number: Xd [0] = new double[] {  	0.0'  	2000.0'  	4000.0'  	7500.0'  	10000.0'  	15000.0'  	20000.0'  	30000.0'  	40000.0  };  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadHardcoded,The following statement contains a magic number: Xd [0] = new double[] {  	0.0'  	2000.0'  	4000.0'  	7500.0'  	10000.0'  	15000.0'  	20000.0'  	30000.0'  	40000.0  };  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadHardcoded,The following statement contains a magic number: Xd [0] = new double[] {  	0.0'  	2000.0'  	4000.0'  	7500.0'  	10000.0'  	15000.0'  	20000.0'  	30000.0'  	40000.0  };  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadHardcoded,The following statement contains a magic number: Xd [0] = new double[] {  	0.0'  	2000.0'  	4000.0'  	7500.0'  	10000.0'  	15000.0'  	20000.0'  	30000.0'  	40000.0  };  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadHardcoded,The following statement contains a magic number: Xd [1] = new double[] {  	0.0'  	3000.0'  	7500.0'  	12500.0'  	20000.0'  	30000.0  };  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadHardcoded,The following statement contains a magic number: Xd [1] = new double[] {  	0.0'  	3000.0'  	7500.0'  	12500.0'  	20000.0'  	30000.0  };  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadHardcoded,The following statement contains a magic number: Xd [1] = new double[] {  	0.0'  	3000.0'  	7500.0'  	12500.0'  	20000.0'  	30000.0  };  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadHardcoded,The following statement contains a magic number: Xd [1] = new double[] {  	0.0'  	3000.0'  	7500.0'  	12500.0'  	20000.0'  	30000.0  };  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadHardcoded,The following statement contains a magic number: Xd [1] = new double[] {  	0.0'  	3000.0'  	7500.0'  	12500.0'  	20000.0'  	30000.0  };  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadHardcoded,The following statement contains a magic number: Xd [2] = new double[] {  	0.0'  	2500.0'  	5000.0'  	10000.0'  	15000.0'  	25000.0'  	35000.0  };  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadHardcoded,The following statement contains a magic number: Xd [2] = new double[] {  	0.0'  	2500.0'  	5000.0'  	10000.0'  	15000.0'  	25000.0'  	35000.0  };  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadHardcoded,The following statement contains a magic number: Xd [2] = new double[] {  	0.0'  	2500.0'  	5000.0'  	10000.0'  	15000.0'  	25000.0'  	35000.0  };  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadHardcoded,The following statement contains a magic number: Xd [2] = new double[] {  	0.0'  	2500.0'  	5000.0'  	10000.0'  	15000.0'  	25000.0'  	35000.0  };  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadHardcoded,The following statement contains a magic number: Xd [2] = new double[] {  	0.0'  	2500.0'  	5000.0'  	10000.0'  	15000.0'  	25000.0'  	35000.0  };  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadHardcoded,The following statement contains a magic number: Xd [2] = new double[] {  	0.0'  	2500.0'  	5000.0'  	10000.0'  	15000.0'  	25000.0'  	35000.0  };  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadHardcoded,The following statement contains a magic number: Xd [2] = new double[] {  	0.0'  	2500.0'  	5000.0'  	10000.0'  	15000.0'  	25000.0'  	35000.0  };  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadHardcoded,The following statement contains a magic number: Yd [0] = new double[] {  	15.0'  	12.782'  	10.892'  	8.232'  	6.740'  	4.518'  	3.028'  	1.361'  	0.611  };  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadHardcoded,The following statement contains a magic number: Yd [0] = new double[] {  	15.0'  	12.782'  	10.892'  	8.232'  	6.740'  	4.518'  	3.028'  	1.361'  	0.611  };  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadHardcoded,The following statement contains a magic number: Yd [0] = new double[] {  	15.0'  	12.782'  	10.892'  	8.232'  	6.740'  	4.518'  	3.028'  	1.361'  	0.611  };  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadHardcoded,The following statement contains a magic number: Yd [0] = new double[] {  	15.0'  	12.782'  	10.892'  	8.232'  	6.740'  	4.518'  	3.028'  	1.361'  	0.611  };  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadHardcoded,The following statement contains a magic number: Yd [0] = new double[] {  	15.0'  	12.782'  	10.892'  	8.232'  	6.740'  	4.518'  	3.028'  	1.361'  	0.611  };  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadHardcoded,The following statement contains a magic number: Yd [0] = new double[] {  	15.0'  	12.782'  	10.892'  	8.232'  	6.740'  	4.518'  	3.028'  	1.361'  	0.611  };  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadHardcoded,The following statement contains a magic number: Yd [0] = new double[] {  	15.0'  	12.782'  	10.892'  	8.232'  	6.740'  	4.518'  	3.028'  	1.361'  	0.611  };  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadHardcoded,The following statement contains a magic number: Yd [0] = new double[] {  	15.0'  	12.782'  	10.892'  	8.232'  	6.740'  	4.518'  	3.028'  	1.361'  	0.611  };  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadHardcoded,The following statement contains a magic number: Yd [0] = new double[] {  	15.0'  	12.782'  	10.892'  	8.232'  	6.740'  	4.518'  	3.028'  	1.361'  	0.611  };  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadHardcoded,The following statement contains a magic number: Yd [1] = new double[] {  	10.0'  	8.607'  	6.873'  	5.353'  	3.679'  	2.231  };  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadHardcoded,The following statement contains a magic number: Yd [1] = new double[] {  	10.0'  	8.607'  	6.873'  	5.353'  	3.679'  	2.231  };  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadHardcoded,The following statement contains a magic number: Yd [1] = new double[] {  	10.0'  	8.607'  	6.873'  	5.353'  	3.679'  	2.231  };  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadHardcoded,The following statement contains a magic number: Yd [1] = new double[] {  	10.0'  	8.607'  	6.873'  	5.353'  	3.679'  	2.231  };  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadHardcoded,The following statement contains a magic number: Yd [1] = new double[] {  	10.0'  	8.607'  	6.873'  	5.353'  	3.679'  	2.231  };  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadHardcoded,The following statement contains a magic number: Yd [1] = new double[] {  	10.0'  	8.607'  	6.873'  	5.353'  	3.679'  	2.231  };  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadHardcoded,The following statement contains a magic number: Yd [2] = new double[] {  	25.0'  	19.470'  	15.163'  	9.197'  	5.578'  	2.052'  	0.755  };  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadHardcoded,The following statement contains a magic number: Yd [2] = new double[] {  	25.0'  	19.470'  	15.163'  	9.197'  	5.578'  	2.052'  	0.755  };  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadHardcoded,The following statement contains a magic number: Yd [2] = new double[] {  	25.0'  	19.470'  	15.163'  	9.197'  	5.578'  	2.052'  	0.755  };  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadHardcoded,The following statement contains a magic number: Yd [2] = new double[] {  	25.0'  	19.470'  	15.163'  	9.197'  	5.578'  	2.052'  	0.755  };  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadHardcoded,The following statement contains a magic number: Yd [2] = new double[] {  	25.0'  	19.470'  	15.163'  	9.197'  	5.578'  	2.052'  	0.755  };  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadHardcoded,The following statement contains a magic number: Yd [2] = new double[] {  	25.0'  	19.470'  	15.163'  	9.197'  	5.578'  	2.052'  	0.755  };  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadHardcoded,The following statement contains a magic number: Yd [2] = new double[] {  	25.0'  	19.470'  	15.163'  	9.197'  	5.578'  	2.052'  	0.755  };  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadHardcoded,The following statement contains a magic number: Yd [2] = new double[] {  	25.0'  	19.470'  	15.163'  	9.197'  	5.578'  	2.052'  	0.755  };  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadHardcoded,The following statement contains a magic number: Xt = new double[3][][];  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadHardcoded,The following statement contains a magic number: Xt [0] = new double[2][];  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadHardcoded,The following statement contains a magic number: Xt [1] = new double[2][];  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadHardcoded,The following statement contains a magic number: Xt [2] = new double[2][];  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadHardcoded,The following statement contains a magic number: Xt [2] = new double[2][];  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadHardcoded,The following statement contains a magic number: Xt [0] [0] = new double[] {  	0.0'  	40000.0  };  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadHardcoded,The following statement contains a magic number: Xt [0] [1] = new double[] {  	0.0'  	20000.0  };  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadHardcoded,The following statement contains a magic number: Xt [1] [0] = new double[] {  	0.0'  	43000.0  };  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadHardcoded,The following statement contains a magic number: Xt [1] [1] = new double[] {  	0.0'  	50000.0  };  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadHardcoded,The following statement contains a magic number: Xt [2] [0] = new double[] {  	0.0'  	50000.0  };  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadHardcoded,The following statement contains a magic number: Xt [2] [0] = new double[] {  	0.0'  	50000.0  };  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadHardcoded,The following statement contains a magic number: Xt [2] [1] = new double[] {  	0.0'  	17500.0  };  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadHardcoded,The following statement contains a magic number: Xt [2] [1] = new double[] {  	0.0'  	17500.0  };  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadHardcoded,The following statement contains a magic number: Yt = new double[3][][];  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadHardcoded,The following statement contains a magic number: Yt [0] = new double[2][];  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadHardcoded,The following statement contains a magic number: Yt [1] = new double[2][];  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadHardcoded,The following statement contains a magic number: Yt [2] = new double[2][];  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadHardcoded,The following statement contains a magic number: Yt [2] = new double[2][];  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadHardcoded,The following statement contains a magic number: Yt [0] [0] = new double[] {  	1.5'  	1.5  };  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadHardcoded,The following statement contains a magic number: Yt [0] [0] = new double[] {  	1.5'  	1.5  };  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadHardcoded,The following statement contains a magic number: Yt [0] [1] = new double[] {  	0.75'  	0.75  };  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadHardcoded,The following statement contains a magic number: Yt [0] [1] = new double[] {  	0.75'  	0.75  };  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadHardcoded,The following statement contains a magic number: Yt [1] [0] = new double[] {  	1.25'  	1.25  };  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadHardcoded,The following statement contains a magic number: Yt [1] [0] = new double[] {  	1.25'  	1.25  };  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadHardcoded,The following statement contains a magic number: Yt [1] [1] = new double[] {  	100.0'  	100.0  };  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadHardcoded,The following statement contains a magic number: Yt [1] [1] = new double[] {  	100.0'  	100.0  };  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadHardcoded,The following statement contains a magic number: Yt [2] [0] = new double[] {  	100.0'  	100.0  };  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadHardcoded,The following statement contains a magic number: Yt [2] [0] = new double[] {  	100.0'  	100.0  };  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadHardcoded,The following statement contains a magic number: Yt [2] [0] = new double[] {  	100.0'  	100.0  };  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadHardcoded,The following statement contains a magic number: Yt [2] [1] = new double[] {  	1.3'  	1.3  };  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadHardcoded,The following statement contains a magic number: Yt [2] [1] = new double[] {  	1.3'  	1.3  };  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadHardcoded,The following statement contains a magic number: Yt [2] [1] = new double[] {  	1.3'  	1.3  };  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadHardcoded,The following statement contains a magic number: Xtl = new double[3][][];  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadHardcoded,The following statement contains a magic number: Xtl [0] = new double[2][];  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadHardcoded,The following statement contains a magic number: Xtl [1] = new double[2][];  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadHardcoded,The following statement contains a magic number: Xtl [2] = new double[2][];  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadHardcoded,The following statement contains a magic number: Xtl [2] = new double[2][];  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadHardcoded,The following statement contains a magic number: Xtl [0] [0] = new double[] {  	0.0'  	5000.0'  	10000.0'  	15000.0'  	20000.0'  	30000.0'  	40000.0  };  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadHardcoded,The following statement contains a magic number: Xtl [0] [0] = new double[] {  	0.0'  	5000.0'  	10000.0'  	15000.0'  	20000.0'  	30000.0'  	40000.0  };  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadHardcoded,The following statement contains a magic number: Xtl [0] [0] = new double[] {  	0.0'  	5000.0'  	10000.0'  	15000.0'  	20000.0'  	30000.0'  	40000.0  };  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadHardcoded,The following statement contains a magic number: Xtl [0] [0] = new double[] {  	0.0'  	5000.0'  	10000.0'  	15000.0'  	20000.0'  	30000.0'  	40000.0  };  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadHardcoded,The following statement contains a magic number: Xtl [0] [0] = new double[] {  	0.0'  	5000.0'  	10000.0'  	15000.0'  	20000.0'  	30000.0'  	40000.0  };  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadHardcoded,The following statement contains a magic number: Xtl [0] [0] = new double[] {  	0.0'  	5000.0'  	10000.0'  	15000.0'  	20000.0'  	30000.0'  	40000.0  };  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadHardcoded,The following statement contains a magic number: Xtl [0] [1] = new double[] {  	0.0'  	2500.0'  	5000.0'  	10000.0'  	15000.0'  	20000.0  };  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadHardcoded,The following statement contains a magic number: Xtl [0] [1] = new double[] {  	0.0'  	2500.0'  	5000.0'  	10000.0'  	15000.0'  	20000.0  };  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadHardcoded,The following statement contains a magic number: Xtl [0] [1] = new double[] {  	0.0'  	2500.0'  	5000.0'  	10000.0'  	15000.0'  	20000.0  };  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadHardcoded,The following statement contains a magic number: Xtl [0] [1] = new double[] {  	0.0'  	2500.0'  	5000.0'  	10000.0'  	15000.0'  	20000.0  };  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadHardcoded,The following statement contains a magic number: Xtl [0] [1] = new double[] {  	0.0'  	2500.0'  	5000.0'  	10000.0'  	15000.0'  	20000.0  };  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadHardcoded,The following statement contains a magic number: Xtl [1] [0] = new double[] {  	0.0'  	5000.0'  	10000.0'  	17500.0'  	25000.0'  	35000.0'  	43000.0  };  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadHardcoded,The following statement contains a magic number: Xtl [1] [0] = new double[] {  	0.0'  	5000.0'  	10000.0'  	17500.0'  	25000.0'  	35000.0'  	43000.0  };  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadHardcoded,The following statement contains a magic number: Xtl [1] [0] = new double[] {  	0.0'  	5000.0'  	10000.0'  	17500.0'  	25000.0'  	35000.0'  	43000.0  };  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadHardcoded,The following statement contains a magic number: Xtl [1] [0] = new double[] {  	0.0'  	5000.0'  	10000.0'  	17500.0'  	25000.0'  	35000.0'  	43000.0  };  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadHardcoded,The following statement contains a magic number: Xtl [1] [0] = new double[] {  	0.0'  	5000.0'  	10000.0'  	17500.0'  	25000.0'  	35000.0'  	43000.0  };  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadHardcoded,The following statement contains a magic number: Xtl [1] [0] = new double[] {  	0.0'  	5000.0'  	10000.0'  	17500.0'  	25000.0'  	35000.0'  	43000.0  };  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadHardcoded,The following statement contains a magic number: Xtl [1] [1] = new double[] {  	0.0'  	50000.0  };  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadHardcoded,The following statement contains a magic number: Xtl [2] [0] = new double[] {  	0.0'  	50000.0  };  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadHardcoded,The following statement contains a magic number: Xtl [2] [0] = new double[] {  	0.0'  	50000.0  };  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadHardcoded,The following statement contains a magic number: Xtl [2] [1] = new double[] {  	0.0'  	2500.0'  	5000.0'  	7500.0'  	10000.0'  	15000.0'  	17500.0  };  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadHardcoded,The following statement contains a magic number: Xtl [2] [1] = new double[] {  	0.0'  	2500.0'  	5000.0'  	7500.0'  	10000.0'  	15000.0'  	17500.0  };  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadHardcoded,The following statement contains a magic number: Xtl [2] [1] = new double[] {  	0.0'  	2500.0'  	5000.0'  	7500.0'  	10000.0'  	15000.0'  	17500.0  };  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadHardcoded,The following statement contains a magic number: Xtl [2] [1] = new double[] {  	0.0'  	2500.0'  	5000.0'  	7500.0'  	10000.0'  	15000.0'  	17500.0  };  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadHardcoded,The following statement contains a magic number: Xtl [2] [1] = new double[] {  	0.0'  	2500.0'  	5000.0'  	7500.0'  	10000.0'  	15000.0'  	17500.0  };  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadHardcoded,The following statement contains a magic number: Xtl [2] [1] = new double[] {  	0.0'  	2500.0'  	5000.0'  	7500.0'  	10000.0'  	15000.0'  	17500.0  };  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadHardcoded,The following statement contains a magic number: Xtl [2] [1] = new double[] {  	0.0'  	2500.0'  	5000.0'  	7500.0'  	10000.0'  	15000.0'  	17500.0  };  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadHardcoded,The following statement contains a magic number: Ytl = new double[3][][];  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadHardcoded,The following statement contains a magic number: Ytl [0] = new double[2][];  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadHardcoded,The following statement contains a magic number: Ytl [1] = new double[2][];  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadHardcoded,The following statement contains a magic number: Ytl [2] = new double[2][];  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadHardcoded,The following statement contains a magic number: Ytl [2] = new double[2][];  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadHardcoded,The following statement contains a magic number: Ytl [0] [0] = new double[] {  	0.0'  	2661.0'  	8147.0'  	13753.0'  	19134.0'  	29426.0'  	39487.0  };  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadHardcoded,The following statement contains a magic number: Ytl [0] [0] = new double[] {  	0.0'  	2661.0'  	8147.0'  	13753.0'  	19134.0'  	29426.0'  	39487.0  };  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadHardcoded,The following statement contains a magic number: Ytl [0] [0] = new double[] {  	0.0'  	2661.0'  	8147.0'  	13753.0'  	19134.0'  	29426.0'  	39487.0  };  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadHardcoded,The following statement contains a magic number: Ytl [0] [0] = new double[] {  	0.0'  	2661.0'  	8147.0'  	13753.0'  	19134.0'  	29426.0'  	39487.0  };  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadHardcoded,The following statement contains a magic number: Ytl [0] [0] = new double[] {  	0.0'  	2661.0'  	8147.0'  	13753.0'  	19134.0'  	29426.0'  	39487.0  };  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadHardcoded,The following statement contains a magic number: Ytl [0] [0] = new double[] {  	0.0'  	2661.0'  	8147.0'  	13753.0'  	19134.0'  	29426.0'  	39487.0  };  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadHardcoded,The following statement contains a magic number: Ytl [0] [1] = new double[] {  	0.0'  	0.0'  	1390.0'  	6275.0'  	11866.0'  	17515.0  };  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadHardcoded,The following statement contains a magic number: Ytl [0] [1] = new double[] {  	0.0'  	0.0'  	1390.0'  	6275.0'  	11866.0'  	17515.0  };  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadHardcoded,The following statement contains a magic number: Ytl [0] [1] = new double[] {  	0.0'  	0.0'  	1390.0'  	6275.0'  	11866.0'  	17515.0  };  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadHardcoded,The following statement contains a magic number: Ytl [0] [1] = new double[] {  	0.0'  	0.0'  	1390.0'  	6275.0'  	11866.0'  	17515.0  };  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadHardcoded,The following statement contains a magic number: Ytl [1] [0] = new double[] {  	0.0'  	1467.0'  	5821.0'  	13959.0'  	22448.0'  	33443.0'  	41917.0  };  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadHardcoded,The following statement contains a magic number: Ytl [1] [0] = new double[] {  	0.0'  	1467.0'  	5821.0'  	13959.0'  	22448.0'  	33443.0'  	41917.0  };  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadHardcoded,The following statement contains a magic number: Ytl [1] [0] = new double[] {  	0.0'  	1467.0'  	5821.0'  	13959.0'  	22448.0'  	33443.0'  	41917.0  };  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadHardcoded,The following statement contains a magic number: Ytl [1] [0] = new double[] {  	0.0'  	1467.0'  	5821.0'  	13959.0'  	22448.0'  	33443.0'  	41917.0  };  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadHardcoded,The following statement contains a magic number: Ytl [1] [0] = new double[] {  	0.0'  	1467.0'  	5821.0'  	13959.0'  	22448.0'  	33443.0'  	41917.0  };  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadHardcoded,The following statement contains a magic number: Ytl [1] [0] = new double[] {  	0.0'  	1467.0'  	5821.0'  	13959.0'  	22448.0'  	33443.0'  	41917.0  };  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadHardcoded,The following statement contains a magic number: Ytl [2] [0] = new double[] {  	0.0'  	0.0  };  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadHardcoded,The following statement contains a magic number: Ytl [2] [1] = new double[] {  	0.0'  	303.0'  	1717.0'  	3707.0'  	6071.0'  	11403.0'  	14209.0  };  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadHardcoded,The following statement contains a magic number: Ytl [2] [1] = new double[] {  	0.0'  	303.0'  	1717.0'  	3707.0'  	6071.0'  	11403.0'  	14209.0  };  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadHardcoded,The following statement contains a magic number: Ytl [2] [1] = new double[] {  	0.0'  	303.0'  	1717.0'  	3707.0'  	6071.0'  	11403.0'  	14209.0  };  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadHardcoded,The following statement contains a magic number: Ytl [2] [1] = new double[] {  	0.0'  	303.0'  	1717.0'  	3707.0'  	6071.0'  	11403.0'  	14209.0  };  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadHardcoded,The following statement contains a magic number: Ytl [2] [1] = new double[] {  	0.0'  	303.0'  	1717.0'  	3707.0'  	6071.0'  	11403.0'  	14209.0  };  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadHardcoded,The following statement contains a magic number: Ytl [2] [1] = new double[] {  	0.0'  	303.0'  	1717.0'  	3707.0'  	6071.0'  	11403.0'  	14209.0  };  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadHardcoded,The following statement contains a magic number: Ytl [2] [1] = new double[] {  	0.0'  	303.0'  	1717.0'  	3707.0'  	6071.0'  	11403.0'  	14209.0  };  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadHardcoded,The following statement contains a magic number: Q = new double[3][];  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadHardcoded,The following statement contains a magic number: Q [0] = new double[] {  	10000'  	10000  };  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadHardcoded,The following statement contains a magic number: Q [0] = new double[] {  	10000'  	10000  };  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadHardcoded,The following statement contains a magic number: Q [1] = new double[] {  	10000'  	0  };  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadHardcoded,The following statement contains a magic number: Q [2] = new double[] {  	0'  	10000  };  
Magic Number,HydroSense,ModelInput,C:\repos\usbr_hydrosense\Hydro$ense\ModelInput.cs,ReadHardcoded,The following statement contains a magic number: Q [2] = new double[] {  	0'  	10000  };  
Magic Number,HydroSense,Nodes,C:\repos\usbr_hydrosense\Hydro$ense\Nodes.cs,Nodes,The following statement contains a magic number: for (int i = 0; i < X.Length; i++) {  	if (X [i].Length != Y [i].Length) {  		throw new DataMisalignedException ("must have same number of quantities and costs' check inputs");  	}  	val = 0.0;  	YC [i] = new double[X [i].Length];  	for (int j = 0; j < X [i].Length; j++) {  		if (j > 0) {  			val += ((Y [i] [j] + Y [i] [j - 1]) / 2.0) * (X [i] [j] - X [i] [j - 1]);  		}  		YC [i] [j] = val;  	}  }  
Magic Number,HydroSense,Nodes,C:\repos\usbr_hydrosense\Hydro$ense\Nodes.cs,Nodes,The following statement contains a magic number: for (int j = 0; j < X [i].Length; j++) {  	if (j > 0) {  		val += ((Y [i] [j] + Y [i] [j - 1]) / 2.0) * (X [i] [j] - X [i] [j - 1]);  	}  	YC [i] [j] = val;  }  
Magic Number,HydroSense,Nodes,C:\repos\usbr_hydrosense\Hydro$ense\Nodes.cs,Nodes,The following statement contains a magic number: if (j > 0) {  	val += ((Y [i] [j] + Y [i] [j - 1]) / 2.0) * (X [i] [j] - X [i] [j - 1]);  }  
Magic Number,HydroSense,Nodes,C:\repos\usbr_hydrosense\Hydro$ense\Nodes.cs,Nodes,The following statement contains a magic number: val += ((Y [i] [j] + Y [i] [j - 1]) / 2.0) * (X [i] [j] - X [i] [j - 1]);  
Magic Number,HydroSense,Util,C:\repos\usbr_hydrosense\Hydro$ense\Util.cs,LinearEquationSolver,The following statement contains a magic number: while (k < MaxIt && maxdel > DelLimit) {  	maxdel = 0.0;  	for (int i = 0; i < N - 1; i++) {  		double sum0 = y [i];  		double sum1 = y [i + 1];  		for (int j = 0; j < i; j++) {  			sum0 -= C [i] [j] * rval [j];  			sum1 -= C [i + 1] [j] * rval [j];  		}  		for (int j = i + 2; j < N; j++) {  			sum0 -= C [i] [j] * rval [j];  			sum1 -= C [i + 1] [j] * rval [j];  		}  		double num = C [i + 1] [i + 1] * sum0 - C [i] [i + 1] * sum1;  		double den = C [i + 1] [i + 1] * C [i] [i] - C [i] [i + 1] * C [i + 1] [i];  		double xnew = num / den;  		double delx = xnew - rval [i];  		rval [i] = xnew;  		if (Math.Abs (delx) > maxdel)  			maxdel = Math.Abs (delx);  		sum0 = y [N - 2];  		sum1 = y [N - 1];  		for (int j = 0; j < N - 2; j++) {  			sum0 -= C [N - 2] [j] * rval [j];  			sum1 -= C [N - 1] [j] * rval [j];  		}  		num = C [N - 1] [N - 2] * sum0 - C [N - 2] [N - 2] * sum1;  		den = C [N - 1] [N - 2] * C [N - 2] [N - 1] - C [N - 2] [N - 2] * C [N - 1] [N - 1];  		xnew = num / den;  		delx = xnew - rval [N - 1];  		rval [N - 1] = xnew;  		if (Math.Abs (delx) > maxdel)  			maxdel = Math.Abs (delx);  		if (maxdel < DelLimit)  			k = MaxIt;  		k += 1;  	}  }  
Magic Number,HydroSense,Util,C:\repos\usbr_hydrosense\Hydro$ense\Util.cs,LinearEquationSolver,The following statement contains a magic number: while (k < MaxIt && maxdel > DelLimit) {  	maxdel = 0.0;  	for (int i = 0; i < N - 1; i++) {  		double sum0 = y [i];  		double sum1 = y [i + 1];  		for (int j = 0; j < i; j++) {  			sum0 -= C [i] [j] * rval [j];  			sum1 -= C [i + 1] [j] * rval [j];  		}  		for (int j = i + 2; j < N; j++) {  			sum0 -= C [i] [j] * rval [j];  			sum1 -= C [i + 1] [j] * rval [j];  		}  		double num = C [i + 1] [i + 1] * sum0 - C [i] [i + 1] * sum1;  		double den = C [i + 1] [i + 1] * C [i] [i] - C [i] [i + 1] * C [i + 1] [i];  		double xnew = num / den;  		double delx = xnew - rval [i];  		rval [i] = xnew;  		if (Math.Abs (delx) > maxdel)  			maxdel = Math.Abs (delx);  		sum0 = y [N - 2];  		sum1 = y [N - 1];  		for (int j = 0; j < N - 2; j++) {  			sum0 -= C [N - 2] [j] * rval [j];  			sum1 -= C [N - 1] [j] * rval [j];  		}  		num = C [N - 1] [N - 2] * sum0 - C [N - 2] [N - 2] * sum1;  		den = C [N - 1] [N - 2] * C [N - 2] [N - 1] - C [N - 2] [N - 2] * C [N - 1] [N - 1];  		xnew = num / den;  		delx = xnew - rval [N - 1];  		rval [N - 1] = xnew;  		if (Math.Abs (delx) > maxdel)  			maxdel = Math.Abs (delx);  		if (maxdel < DelLimit)  			k = MaxIt;  		k += 1;  	}  }  
Magic Number,HydroSense,Util,C:\repos\usbr_hydrosense\Hydro$ense\Util.cs,LinearEquationSolver,The following statement contains a magic number: while (k < MaxIt && maxdel > DelLimit) {  	maxdel = 0.0;  	for (int i = 0; i < N - 1; i++) {  		double sum0 = y [i];  		double sum1 = y [i + 1];  		for (int j = 0; j < i; j++) {  			sum0 -= C [i] [j] * rval [j];  			sum1 -= C [i + 1] [j] * rval [j];  		}  		for (int j = i + 2; j < N; j++) {  			sum0 -= C [i] [j] * rval [j];  			sum1 -= C [i + 1] [j] * rval [j];  		}  		double num = C [i + 1] [i + 1] * sum0 - C [i] [i + 1] * sum1;  		double den = C [i + 1] [i + 1] * C [i] [i] - C [i] [i + 1] * C [i + 1] [i];  		double xnew = num / den;  		double delx = xnew - rval [i];  		rval [i] = xnew;  		if (Math.Abs (delx) > maxdel)  			maxdel = Math.Abs (delx);  		sum0 = y [N - 2];  		sum1 = y [N - 1];  		for (int j = 0; j < N - 2; j++) {  			sum0 -= C [N - 2] [j] * rval [j];  			sum1 -= C [N - 1] [j] * rval [j];  		}  		num = C [N - 1] [N - 2] * sum0 - C [N - 2] [N - 2] * sum1;  		den = C [N - 1] [N - 2] * C [N - 2] [N - 1] - C [N - 2] [N - 2] * C [N - 1] [N - 1];  		xnew = num / den;  		delx = xnew - rval [N - 1];  		rval [N - 1] = xnew;  		if (Math.Abs (delx) > maxdel)  			maxdel = Math.Abs (delx);  		if (maxdel < DelLimit)  			k = MaxIt;  		k += 1;  	}  }  
Magic Number,HydroSense,Util,C:\repos\usbr_hydrosense\Hydro$ense\Util.cs,LinearEquationSolver,The following statement contains a magic number: while (k < MaxIt && maxdel > DelLimit) {  	maxdel = 0.0;  	for (int i = 0; i < N - 1; i++) {  		double sum0 = y [i];  		double sum1 = y [i + 1];  		for (int j = 0; j < i; j++) {  			sum0 -= C [i] [j] * rval [j];  			sum1 -= C [i + 1] [j] * rval [j];  		}  		for (int j = i + 2; j < N; j++) {  			sum0 -= C [i] [j] * rval [j];  			sum1 -= C [i + 1] [j] * rval [j];  		}  		double num = C [i + 1] [i + 1] * sum0 - C [i] [i + 1] * sum1;  		double den = C [i + 1] [i + 1] * C [i] [i] - C [i] [i + 1] * C [i + 1] [i];  		double xnew = num / den;  		double delx = xnew - rval [i];  		rval [i] = xnew;  		if (Math.Abs (delx) > maxdel)  			maxdel = Math.Abs (delx);  		sum0 = y [N - 2];  		sum1 = y [N - 1];  		for (int j = 0; j < N - 2; j++) {  			sum0 -= C [N - 2] [j] * rval [j];  			sum1 -= C [N - 1] [j] * rval [j];  		}  		num = C [N - 1] [N - 2] * sum0 - C [N - 2] [N - 2] * sum1;  		den = C [N - 1] [N - 2] * C [N - 2] [N - 1] - C [N - 2] [N - 2] * C [N - 1] [N - 1];  		xnew = num / den;  		delx = xnew - rval [N - 1];  		rval [N - 1] = xnew;  		if (Math.Abs (delx) > maxdel)  			maxdel = Math.Abs (delx);  		if (maxdel < DelLimit)  			k = MaxIt;  		k += 1;  	}  }  
Magic Number,HydroSense,Util,C:\repos\usbr_hydrosense\Hydro$ense\Util.cs,LinearEquationSolver,The following statement contains a magic number: while (k < MaxIt && maxdel > DelLimit) {  	maxdel = 0.0;  	for (int i = 0; i < N - 1; i++) {  		double sum0 = y [i];  		double sum1 = y [i + 1];  		for (int j = 0; j < i; j++) {  			sum0 -= C [i] [j] * rval [j];  			sum1 -= C [i + 1] [j] * rval [j];  		}  		for (int j = i + 2; j < N; j++) {  			sum0 -= C [i] [j] * rval [j];  			sum1 -= C [i + 1] [j] * rval [j];  		}  		double num = C [i + 1] [i + 1] * sum0 - C [i] [i + 1] * sum1;  		double den = C [i + 1] [i + 1] * C [i] [i] - C [i] [i + 1] * C [i + 1] [i];  		double xnew = num / den;  		double delx = xnew - rval [i];  		rval [i] = xnew;  		if (Math.Abs (delx) > maxdel)  			maxdel = Math.Abs (delx);  		sum0 = y [N - 2];  		sum1 = y [N - 1];  		for (int j = 0; j < N - 2; j++) {  			sum0 -= C [N - 2] [j] * rval [j];  			sum1 -= C [N - 1] [j] * rval [j];  		}  		num = C [N - 1] [N - 2] * sum0 - C [N - 2] [N - 2] * sum1;  		den = C [N - 1] [N - 2] * C [N - 2] [N - 1] - C [N - 2] [N - 2] * C [N - 1] [N - 1];  		xnew = num / den;  		delx = xnew - rval [N - 1];  		rval [N - 1] = xnew;  		if (Math.Abs (delx) > maxdel)  			maxdel = Math.Abs (delx);  		if (maxdel < DelLimit)  			k = MaxIt;  		k += 1;  	}  }  
Magic Number,HydroSense,Util,C:\repos\usbr_hydrosense\Hydro$ense\Util.cs,LinearEquationSolver,The following statement contains a magic number: while (k < MaxIt && maxdel > DelLimit) {  	maxdel = 0.0;  	for (int i = 0; i < N - 1; i++) {  		double sum0 = y [i];  		double sum1 = y [i + 1];  		for (int j = 0; j < i; j++) {  			sum0 -= C [i] [j] * rval [j];  			sum1 -= C [i + 1] [j] * rval [j];  		}  		for (int j = i + 2; j < N; j++) {  			sum0 -= C [i] [j] * rval [j];  			sum1 -= C [i + 1] [j] * rval [j];  		}  		double num = C [i + 1] [i + 1] * sum0 - C [i] [i + 1] * sum1;  		double den = C [i + 1] [i + 1] * C [i] [i] - C [i] [i + 1] * C [i + 1] [i];  		double xnew = num / den;  		double delx = xnew - rval [i];  		rval [i] = xnew;  		if (Math.Abs (delx) > maxdel)  			maxdel = Math.Abs (delx);  		sum0 = y [N - 2];  		sum1 = y [N - 1];  		for (int j = 0; j < N - 2; j++) {  			sum0 -= C [N - 2] [j] * rval [j];  			sum1 -= C [N - 1] [j] * rval [j];  		}  		num = C [N - 1] [N - 2] * sum0 - C [N - 2] [N - 2] * sum1;  		den = C [N - 1] [N - 2] * C [N - 2] [N - 1] - C [N - 2] [N - 2] * C [N - 1] [N - 1];  		xnew = num / den;  		delx = xnew - rval [N - 1];  		rval [N - 1] = xnew;  		if (Math.Abs (delx) > maxdel)  			maxdel = Math.Abs (delx);  		if (maxdel < DelLimit)  			k = MaxIt;  		k += 1;  	}  }  
Magic Number,HydroSense,Util,C:\repos\usbr_hydrosense\Hydro$ense\Util.cs,LinearEquationSolver,The following statement contains a magic number: while (k < MaxIt && maxdel > DelLimit) {  	maxdel = 0.0;  	for (int i = 0; i < N - 1; i++) {  		double sum0 = y [i];  		double sum1 = y [i + 1];  		for (int j = 0; j < i; j++) {  			sum0 -= C [i] [j] * rval [j];  			sum1 -= C [i + 1] [j] * rval [j];  		}  		for (int j = i + 2; j < N; j++) {  			sum0 -= C [i] [j] * rval [j];  			sum1 -= C [i + 1] [j] * rval [j];  		}  		double num = C [i + 1] [i + 1] * sum0 - C [i] [i + 1] * sum1;  		double den = C [i + 1] [i + 1] * C [i] [i] - C [i] [i + 1] * C [i + 1] [i];  		double xnew = num / den;  		double delx = xnew - rval [i];  		rval [i] = xnew;  		if (Math.Abs (delx) > maxdel)  			maxdel = Math.Abs (delx);  		sum0 = y [N - 2];  		sum1 = y [N - 1];  		for (int j = 0; j < N - 2; j++) {  			sum0 -= C [N - 2] [j] * rval [j];  			sum1 -= C [N - 1] [j] * rval [j];  		}  		num = C [N - 1] [N - 2] * sum0 - C [N - 2] [N - 2] * sum1;  		den = C [N - 1] [N - 2] * C [N - 2] [N - 1] - C [N - 2] [N - 2] * C [N - 1] [N - 1];  		xnew = num / den;  		delx = xnew - rval [N - 1];  		rval [N - 1] = xnew;  		if (Math.Abs (delx) > maxdel)  			maxdel = Math.Abs (delx);  		if (maxdel < DelLimit)  			k = MaxIt;  		k += 1;  	}  }  
Magic Number,HydroSense,Util,C:\repos\usbr_hydrosense\Hydro$ense\Util.cs,LinearEquationSolver,The following statement contains a magic number: while (k < MaxIt && maxdel > DelLimit) {  	maxdel = 0.0;  	for (int i = 0; i < N - 1; i++) {  		double sum0 = y [i];  		double sum1 = y [i + 1];  		for (int j = 0; j < i; j++) {  			sum0 -= C [i] [j] * rval [j];  			sum1 -= C [i + 1] [j] * rval [j];  		}  		for (int j = i + 2; j < N; j++) {  			sum0 -= C [i] [j] * rval [j];  			sum1 -= C [i + 1] [j] * rval [j];  		}  		double num = C [i + 1] [i + 1] * sum0 - C [i] [i + 1] * sum1;  		double den = C [i + 1] [i + 1] * C [i] [i] - C [i] [i + 1] * C [i + 1] [i];  		double xnew = num / den;  		double delx = xnew - rval [i];  		rval [i] = xnew;  		if (Math.Abs (delx) > maxdel)  			maxdel = Math.Abs (delx);  		sum0 = y [N - 2];  		sum1 = y [N - 1];  		for (int j = 0; j < N - 2; j++) {  			sum0 -= C [N - 2] [j] * rval [j];  			sum1 -= C [N - 1] [j] * rval [j];  		}  		num = C [N - 1] [N - 2] * sum0 - C [N - 2] [N - 2] * sum1;  		den = C [N - 1] [N - 2] * C [N - 2] [N - 1] - C [N - 2] [N - 2] * C [N - 1] [N - 1];  		xnew = num / den;  		delx = xnew - rval [N - 1];  		rval [N - 1] = xnew;  		if (Math.Abs (delx) > maxdel)  			maxdel = Math.Abs (delx);  		if (maxdel < DelLimit)  			k = MaxIt;  		k += 1;  	}  }  
Magic Number,HydroSense,Util,C:\repos\usbr_hydrosense\Hydro$ense\Util.cs,LinearEquationSolver,The following statement contains a magic number: while (k < MaxIt && maxdel > DelLimit) {  	maxdel = 0.0;  	for (int i = 0; i < N - 1; i++) {  		double sum0 = y [i];  		double sum1 = y [i + 1];  		for (int j = 0; j < i; j++) {  			sum0 -= C [i] [j] * rval [j];  			sum1 -= C [i + 1] [j] * rval [j];  		}  		for (int j = i + 2; j < N; j++) {  			sum0 -= C [i] [j] * rval [j];  			sum1 -= C [i + 1] [j] * rval [j];  		}  		double num = C [i + 1] [i + 1] * sum0 - C [i] [i + 1] * sum1;  		double den = C [i + 1] [i + 1] * C [i] [i] - C [i] [i + 1] * C [i + 1] [i];  		double xnew = num / den;  		double delx = xnew - rval [i];  		rval [i] = xnew;  		if (Math.Abs (delx) > maxdel)  			maxdel = Math.Abs (delx);  		sum0 = y [N - 2];  		sum1 = y [N - 1];  		for (int j = 0; j < N - 2; j++) {  			sum0 -= C [N - 2] [j] * rval [j];  			sum1 -= C [N - 1] [j] * rval [j];  		}  		num = C [N - 1] [N - 2] * sum0 - C [N - 2] [N - 2] * sum1;  		den = C [N - 1] [N - 2] * C [N - 2] [N - 1] - C [N - 2] [N - 2] * C [N - 1] [N - 1];  		xnew = num / den;  		delx = xnew - rval [N - 1];  		rval [N - 1] = xnew;  		if (Math.Abs (delx) > maxdel)  			maxdel = Math.Abs (delx);  		if (maxdel < DelLimit)  			k = MaxIt;  		k += 1;  	}  }  
Magic Number,HydroSense,Util,C:\repos\usbr_hydrosense\Hydro$ense\Util.cs,LinearEquationSolver,The following statement contains a magic number: while (k < MaxIt && maxdel > DelLimit) {  	maxdel = 0.0;  	for (int i = 0; i < N - 1; i++) {  		double sum0 = y [i];  		double sum1 = y [i + 1];  		for (int j = 0; j < i; j++) {  			sum0 -= C [i] [j] * rval [j];  			sum1 -= C [i + 1] [j] * rval [j];  		}  		for (int j = i + 2; j < N; j++) {  			sum0 -= C [i] [j] * rval [j];  			sum1 -= C [i + 1] [j] * rval [j];  		}  		double num = C [i + 1] [i + 1] * sum0 - C [i] [i + 1] * sum1;  		double den = C [i + 1] [i + 1] * C [i] [i] - C [i] [i + 1] * C [i + 1] [i];  		double xnew = num / den;  		double delx = xnew - rval [i];  		rval [i] = xnew;  		if (Math.Abs (delx) > maxdel)  			maxdel = Math.Abs (delx);  		sum0 = y [N - 2];  		sum1 = y [N - 1];  		for (int j = 0; j < N - 2; j++) {  			sum0 -= C [N - 2] [j] * rval [j];  			sum1 -= C [N - 1] [j] * rval [j];  		}  		num = C [N - 1] [N - 2] * sum0 - C [N - 2] [N - 2] * sum1;  		den = C [N - 1] [N - 2] * C [N - 2] [N - 1] - C [N - 2] [N - 2] * C [N - 1] [N - 1];  		xnew = num / den;  		delx = xnew - rval [N - 1];  		rval [N - 1] = xnew;  		if (Math.Abs (delx) > maxdel)  			maxdel = Math.Abs (delx);  		if (maxdel < DelLimit)  			k = MaxIt;  		k += 1;  	}  }  
Magic Number,HydroSense,Util,C:\repos\usbr_hydrosense\Hydro$ense\Util.cs,LinearEquationSolver,The following statement contains a magic number: while (k < MaxIt && maxdel > DelLimit) {  	maxdel = 0.0;  	for (int i = 0; i < N - 1; i++) {  		double sum0 = y [i];  		double sum1 = y [i + 1];  		for (int j = 0; j < i; j++) {  			sum0 -= C [i] [j] * rval [j];  			sum1 -= C [i + 1] [j] * rval [j];  		}  		for (int j = i + 2; j < N; j++) {  			sum0 -= C [i] [j] * rval [j];  			sum1 -= C [i + 1] [j] * rval [j];  		}  		double num = C [i + 1] [i + 1] * sum0 - C [i] [i + 1] * sum1;  		double den = C [i + 1] [i + 1] * C [i] [i] - C [i] [i + 1] * C [i + 1] [i];  		double xnew = num / den;  		double delx = xnew - rval [i];  		rval [i] = xnew;  		if (Math.Abs (delx) > maxdel)  			maxdel = Math.Abs (delx);  		sum0 = y [N - 2];  		sum1 = y [N - 1];  		for (int j = 0; j < N - 2; j++) {  			sum0 -= C [N - 2] [j] * rval [j];  			sum1 -= C [N - 1] [j] * rval [j];  		}  		num = C [N - 1] [N - 2] * sum0 - C [N - 2] [N - 2] * sum1;  		den = C [N - 1] [N - 2] * C [N - 2] [N - 1] - C [N - 2] [N - 2] * C [N - 1] [N - 1];  		xnew = num / den;  		delx = xnew - rval [N - 1];  		rval [N - 1] = xnew;  		if (Math.Abs (delx) > maxdel)  			maxdel = Math.Abs (delx);  		if (maxdel < DelLimit)  			k = MaxIt;  		k += 1;  	}  }  
Magic Number,HydroSense,Util,C:\repos\usbr_hydrosense\Hydro$ense\Util.cs,LinearEquationSolver,The following statement contains a magic number: for (int i = 0; i < N - 1; i++) {  	double sum0 = y [i];  	double sum1 = y [i + 1];  	for (int j = 0; j < i; j++) {  		sum0 -= C [i] [j] * rval [j];  		sum1 -= C [i + 1] [j] * rval [j];  	}  	for (int j = i + 2; j < N; j++) {  		sum0 -= C [i] [j] * rval [j];  		sum1 -= C [i + 1] [j] * rval [j];  	}  	double num = C [i + 1] [i + 1] * sum0 - C [i] [i + 1] * sum1;  	double den = C [i + 1] [i + 1] * C [i] [i] - C [i] [i + 1] * C [i + 1] [i];  	double xnew = num / den;  	double delx = xnew - rval [i];  	rval [i] = xnew;  	if (Math.Abs (delx) > maxdel)  		maxdel = Math.Abs (delx);  	sum0 = y [N - 2];  	sum1 = y [N - 1];  	for (int j = 0; j < N - 2; j++) {  		sum0 -= C [N - 2] [j] * rval [j];  		sum1 -= C [N - 1] [j] * rval [j];  	}  	num = C [N - 1] [N - 2] * sum0 - C [N - 2] [N - 2] * sum1;  	den = C [N - 1] [N - 2] * C [N - 2] [N - 1] - C [N - 2] [N - 2] * C [N - 1] [N - 1];  	xnew = num / den;  	delx = xnew - rval [N - 1];  	rval [N - 1] = xnew;  	if (Math.Abs (delx) > maxdel)  		maxdel = Math.Abs (delx);  	if (maxdel < DelLimit)  		k = MaxIt;  	k += 1;  }  
Magic Number,HydroSense,Util,C:\repos\usbr_hydrosense\Hydro$ense\Util.cs,LinearEquationSolver,The following statement contains a magic number: for (int i = 0; i < N - 1; i++) {  	double sum0 = y [i];  	double sum1 = y [i + 1];  	for (int j = 0; j < i; j++) {  		sum0 -= C [i] [j] * rval [j];  		sum1 -= C [i + 1] [j] * rval [j];  	}  	for (int j = i + 2; j < N; j++) {  		sum0 -= C [i] [j] * rval [j];  		sum1 -= C [i + 1] [j] * rval [j];  	}  	double num = C [i + 1] [i + 1] * sum0 - C [i] [i + 1] * sum1;  	double den = C [i + 1] [i + 1] * C [i] [i] - C [i] [i + 1] * C [i + 1] [i];  	double xnew = num / den;  	double delx = xnew - rval [i];  	rval [i] = xnew;  	if (Math.Abs (delx) > maxdel)  		maxdel = Math.Abs (delx);  	sum0 = y [N - 2];  	sum1 = y [N - 1];  	for (int j = 0; j < N - 2; j++) {  		sum0 -= C [N - 2] [j] * rval [j];  		sum1 -= C [N - 1] [j] * rval [j];  	}  	num = C [N - 1] [N - 2] * sum0 - C [N - 2] [N - 2] * sum1;  	den = C [N - 1] [N - 2] * C [N - 2] [N - 1] - C [N - 2] [N - 2] * C [N - 1] [N - 1];  	xnew = num / den;  	delx = xnew - rval [N - 1];  	rval [N - 1] = xnew;  	if (Math.Abs (delx) > maxdel)  		maxdel = Math.Abs (delx);  	if (maxdel < DelLimit)  		k = MaxIt;  	k += 1;  }  
Magic Number,HydroSense,Util,C:\repos\usbr_hydrosense\Hydro$ense\Util.cs,LinearEquationSolver,The following statement contains a magic number: for (int i = 0; i < N - 1; i++) {  	double sum0 = y [i];  	double sum1 = y [i + 1];  	for (int j = 0; j < i; j++) {  		sum0 -= C [i] [j] * rval [j];  		sum1 -= C [i + 1] [j] * rval [j];  	}  	for (int j = i + 2; j < N; j++) {  		sum0 -= C [i] [j] * rval [j];  		sum1 -= C [i + 1] [j] * rval [j];  	}  	double num = C [i + 1] [i + 1] * sum0 - C [i] [i + 1] * sum1;  	double den = C [i + 1] [i + 1] * C [i] [i] - C [i] [i + 1] * C [i + 1] [i];  	double xnew = num / den;  	double delx = xnew - rval [i];  	rval [i] = xnew;  	if (Math.Abs (delx) > maxdel)  		maxdel = Math.Abs (delx);  	sum0 = y [N - 2];  	sum1 = y [N - 1];  	for (int j = 0; j < N - 2; j++) {  		sum0 -= C [N - 2] [j] * rval [j];  		sum1 -= C [N - 1] [j] * rval [j];  	}  	num = C [N - 1] [N - 2] * sum0 - C [N - 2] [N - 2] * sum1;  	den = C [N - 1] [N - 2] * C [N - 2] [N - 1] - C [N - 2] [N - 2] * C [N - 1] [N - 1];  	xnew = num / den;  	delx = xnew - rval [N - 1];  	rval [N - 1] = xnew;  	if (Math.Abs (delx) > maxdel)  		maxdel = Math.Abs (delx);  	if (maxdel < DelLimit)  		k = MaxIt;  	k += 1;  }  
Magic Number,HydroSense,Util,C:\repos\usbr_hydrosense\Hydro$ense\Util.cs,LinearEquationSolver,The following statement contains a magic number: for (int i = 0; i < N - 1; i++) {  	double sum0 = y [i];  	double sum1 = y [i + 1];  	for (int j = 0; j < i; j++) {  		sum0 -= C [i] [j] * rval [j];  		sum1 -= C [i + 1] [j] * rval [j];  	}  	for (int j = i + 2; j < N; j++) {  		sum0 -= C [i] [j] * rval [j];  		sum1 -= C [i + 1] [j] * rval [j];  	}  	double num = C [i + 1] [i + 1] * sum0 - C [i] [i + 1] * sum1;  	double den = C [i + 1] [i + 1] * C [i] [i] - C [i] [i + 1] * C [i + 1] [i];  	double xnew = num / den;  	double delx = xnew - rval [i];  	rval [i] = xnew;  	if (Math.Abs (delx) > maxdel)  		maxdel = Math.Abs (delx);  	sum0 = y [N - 2];  	sum1 = y [N - 1];  	for (int j = 0; j < N - 2; j++) {  		sum0 -= C [N - 2] [j] * rval [j];  		sum1 -= C [N - 1] [j] * rval [j];  	}  	num = C [N - 1] [N - 2] * sum0 - C [N - 2] [N - 2] * sum1;  	den = C [N - 1] [N - 2] * C [N - 2] [N - 1] - C [N - 2] [N - 2] * C [N - 1] [N - 1];  	xnew = num / den;  	delx = xnew - rval [N - 1];  	rval [N - 1] = xnew;  	if (Math.Abs (delx) > maxdel)  		maxdel = Math.Abs (delx);  	if (maxdel < DelLimit)  		k = MaxIt;  	k += 1;  }  
Magic Number,HydroSense,Util,C:\repos\usbr_hydrosense\Hydro$ense\Util.cs,LinearEquationSolver,The following statement contains a magic number: for (int i = 0; i < N - 1; i++) {  	double sum0 = y [i];  	double sum1 = y [i + 1];  	for (int j = 0; j < i; j++) {  		sum0 -= C [i] [j] * rval [j];  		sum1 -= C [i + 1] [j] * rval [j];  	}  	for (int j = i + 2; j < N; j++) {  		sum0 -= C [i] [j] * rval [j];  		sum1 -= C [i + 1] [j] * rval [j];  	}  	double num = C [i + 1] [i + 1] * sum0 - C [i] [i + 1] * sum1;  	double den = C [i + 1] [i + 1] * C [i] [i] - C [i] [i + 1] * C [i + 1] [i];  	double xnew = num / den;  	double delx = xnew - rval [i];  	rval [i] = xnew;  	if (Math.Abs (delx) > maxdel)  		maxdel = Math.Abs (delx);  	sum0 = y [N - 2];  	sum1 = y [N - 1];  	for (int j = 0; j < N - 2; j++) {  		sum0 -= C [N - 2] [j] * rval [j];  		sum1 -= C [N - 1] [j] * rval [j];  	}  	num = C [N - 1] [N - 2] * sum0 - C [N - 2] [N - 2] * sum1;  	den = C [N - 1] [N - 2] * C [N - 2] [N - 1] - C [N - 2] [N - 2] * C [N - 1] [N - 1];  	xnew = num / den;  	delx = xnew - rval [N - 1];  	rval [N - 1] = xnew;  	if (Math.Abs (delx) > maxdel)  		maxdel = Math.Abs (delx);  	if (maxdel < DelLimit)  		k = MaxIt;  	k += 1;  }  
Magic Number,HydroSense,Util,C:\repos\usbr_hydrosense\Hydro$ense\Util.cs,LinearEquationSolver,The following statement contains a magic number: for (int i = 0; i < N - 1; i++) {  	double sum0 = y [i];  	double sum1 = y [i + 1];  	for (int j = 0; j < i; j++) {  		sum0 -= C [i] [j] * rval [j];  		sum1 -= C [i + 1] [j] * rval [j];  	}  	for (int j = i + 2; j < N; j++) {  		sum0 -= C [i] [j] * rval [j];  		sum1 -= C [i + 1] [j] * rval [j];  	}  	double num = C [i + 1] [i + 1] * sum0 - C [i] [i + 1] * sum1;  	double den = C [i + 1] [i + 1] * C [i] [i] - C [i] [i + 1] * C [i + 1] [i];  	double xnew = num / den;  	double delx = xnew - rval [i];  	rval [i] = xnew;  	if (Math.Abs (delx) > maxdel)  		maxdel = Math.Abs (delx);  	sum0 = y [N - 2];  	sum1 = y [N - 1];  	for (int j = 0; j < N - 2; j++) {  		sum0 -= C [N - 2] [j] * rval [j];  		sum1 -= C [N - 1] [j] * rval [j];  	}  	num = C [N - 1] [N - 2] * sum0 - C [N - 2] [N - 2] * sum1;  	den = C [N - 1] [N - 2] * C [N - 2] [N - 1] - C [N - 2] [N - 2] * C [N - 1] [N - 1];  	xnew = num / den;  	delx = xnew - rval [N - 1];  	rval [N - 1] = xnew;  	if (Math.Abs (delx) > maxdel)  		maxdel = Math.Abs (delx);  	if (maxdel < DelLimit)  		k = MaxIt;  	k += 1;  }  
Magic Number,HydroSense,Util,C:\repos\usbr_hydrosense\Hydro$ense\Util.cs,LinearEquationSolver,The following statement contains a magic number: for (int i = 0; i < N - 1; i++) {  	double sum0 = y [i];  	double sum1 = y [i + 1];  	for (int j = 0; j < i; j++) {  		sum0 -= C [i] [j] * rval [j];  		sum1 -= C [i + 1] [j] * rval [j];  	}  	for (int j = i + 2; j < N; j++) {  		sum0 -= C [i] [j] * rval [j];  		sum1 -= C [i + 1] [j] * rval [j];  	}  	double num = C [i + 1] [i + 1] * sum0 - C [i] [i + 1] * sum1;  	double den = C [i + 1] [i + 1] * C [i] [i] - C [i] [i + 1] * C [i + 1] [i];  	double xnew = num / den;  	double delx = xnew - rval [i];  	rval [i] = xnew;  	if (Math.Abs (delx) > maxdel)  		maxdel = Math.Abs (delx);  	sum0 = y [N - 2];  	sum1 = y [N - 1];  	for (int j = 0; j < N - 2; j++) {  		sum0 -= C [N - 2] [j] * rval [j];  		sum1 -= C [N - 1] [j] * rval [j];  	}  	num = C [N - 1] [N - 2] * sum0 - C [N - 2] [N - 2] * sum1;  	den = C [N - 1] [N - 2] * C [N - 2] [N - 1] - C [N - 2] [N - 2] * C [N - 1] [N - 1];  	xnew = num / den;  	delx = xnew - rval [N - 1];  	rval [N - 1] = xnew;  	if (Math.Abs (delx) > maxdel)  		maxdel = Math.Abs (delx);  	if (maxdel < DelLimit)  		k = MaxIt;  	k += 1;  }  
Magic Number,HydroSense,Util,C:\repos\usbr_hydrosense\Hydro$ense\Util.cs,LinearEquationSolver,The following statement contains a magic number: for (int i = 0; i < N - 1; i++) {  	double sum0 = y [i];  	double sum1 = y [i + 1];  	for (int j = 0; j < i; j++) {  		sum0 -= C [i] [j] * rval [j];  		sum1 -= C [i + 1] [j] * rval [j];  	}  	for (int j = i + 2; j < N; j++) {  		sum0 -= C [i] [j] * rval [j];  		sum1 -= C [i + 1] [j] * rval [j];  	}  	double num = C [i + 1] [i + 1] * sum0 - C [i] [i + 1] * sum1;  	double den = C [i + 1] [i + 1] * C [i] [i] - C [i] [i + 1] * C [i + 1] [i];  	double xnew = num / den;  	double delx = xnew - rval [i];  	rval [i] = xnew;  	if (Math.Abs (delx) > maxdel)  		maxdel = Math.Abs (delx);  	sum0 = y [N - 2];  	sum1 = y [N - 1];  	for (int j = 0; j < N - 2; j++) {  		sum0 -= C [N - 2] [j] * rval [j];  		sum1 -= C [N - 1] [j] * rval [j];  	}  	num = C [N - 1] [N - 2] * sum0 - C [N - 2] [N - 2] * sum1;  	den = C [N - 1] [N - 2] * C [N - 2] [N - 1] - C [N - 2] [N - 2] * C [N - 1] [N - 1];  	xnew = num / den;  	delx = xnew - rval [N - 1];  	rval [N - 1] = xnew;  	if (Math.Abs (delx) > maxdel)  		maxdel = Math.Abs (delx);  	if (maxdel < DelLimit)  		k = MaxIt;  	k += 1;  }  
Magic Number,HydroSense,Util,C:\repos\usbr_hydrosense\Hydro$ense\Util.cs,LinearEquationSolver,The following statement contains a magic number: for (int i = 0; i < N - 1; i++) {  	double sum0 = y [i];  	double sum1 = y [i + 1];  	for (int j = 0; j < i; j++) {  		sum0 -= C [i] [j] * rval [j];  		sum1 -= C [i + 1] [j] * rval [j];  	}  	for (int j = i + 2; j < N; j++) {  		sum0 -= C [i] [j] * rval [j];  		sum1 -= C [i + 1] [j] * rval [j];  	}  	double num = C [i + 1] [i + 1] * sum0 - C [i] [i + 1] * sum1;  	double den = C [i + 1] [i + 1] * C [i] [i] - C [i] [i + 1] * C [i + 1] [i];  	double xnew = num / den;  	double delx = xnew - rval [i];  	rval [i] = xnew;  	if (Math.Abs (delx) > maxdel)  		maxdel = Math.Abs (delx);  	sum0 = y [N - 2];  	sum1 = y [N - 1];  	for (int j = 0; j < N - 2; j++) {  		sum0 -= C [N - 2] [j] * rval [j];  		sum1 -= C [N - 1] [j] * rval [j];  	}  	num = C [N - 1] [N - 2] * sum0 - C [N - 2] [N - 2] * sum1;  	den = C [N - 1] [N - 2] * C [N - 2] [N - 1] - C [N - 2] [N - 2] * C [N - 1] [N - 1];  	xnew = num / den;  	delx = xnew - rval [N - 1];  	rval [N - 1] = xnew;  	if (Math.Abs (delx) > maxdel)  		maxdel = Math.Abs (delx);  	if (maxdel < DelLimit)  		k = MaxIt;  	k += 1;  }  
Magic Number,HydroSense,Util,C:\repos\usbr_hydrosense\Hydro$ense\Util.cs,LinearEquationSolver,The following statement contains a magic number: for (int i = 0; i < N - 1; i++) {  	double sum0 = y [i];  	double sum1 = y [i + 1];  	for (int j = 0; j < i; j++) {  		sum0 -= C [i] [j] * rval [j];  		sum1 -= C [i + 1] [j] * rval [j];  	}  	for (int j = i + 2; j < N; j++) {  		sum0 -= C [i] [j] * rval [j];  		sum1 -= C [i + 1] [j] * rval [j];  	}  	double num = C [i + 1] [i + 1] * sum0 - C [i] [i + 1] * sum1;  	double den = C [i + 1] [i + 1] * C [i] [i] - C [i] [i + 1] * C [i + 1] [i];  	double xnew = num / den;  	double delx = xnew - rval [i];  	rval [i] = xnew;  	if (Math.Abs (delx) > maxdel)  		maxdel = Math.Abs (delx);  	sum0 = y [N - 2];  	sum1 = y [N - 1];  	for (int j = 0; j < N - 2; j++) {  		sum0 -= C [N - 2] [j] * rval [j];  		sum1 -= C [N - 1] [j] * rval [j];  	}  	num = C [N - 1] [N - 2] * sum0 - C [N - 2] [N - 2] * sum1;  	den = C [N - 1] [N - 2] * C [N - 2] [N - 1] - C [N - 2] [N - 2] * C [N - 1] [N - 1];  	xnew = num / den;  	delx = xnew - rval [N - 1];  	rval [N - 1] = xnew;  	if (Math.Abs (delx) > maxdel)  		maxdel = Math.Abs (delx);  	if (maxdel < DelLimit)  		k = MaxIt;  	k += 1;  }  
Magic Number,HydroSense,Util,C:\repos\usbr_hydrosense\Hydro$ense\Util.cs,LinearEquationSolver,The following statement contains a magic number: for (int i = 0; i < N - 1; i++) {  	double sum0 = y [i];  	double sum1 = y [i + 1];  	for (int j = 0; j < i; j++) {  		sum0 -= C [i] [j] * rval [j];  		sum1 -= C [i + 1] [j] * rval [j];  	}  	for (int j = i + 2; j < N; j++) {  		sum0 -= C [i] [j] * rval [j];  		sum1 -= C [i + 1] [j] * rval [j];  	}  	double num = C [i + 1] [i + 1] * sum0 - C [i] [i + 1] * sum1;  	double den = C [i + 1] [i + 1] * C [i] [i] - C [i] [i + 1] * C [i + 1] [i];  	double xnew = num / den;  	double delx = xnew - rval [i];  	rval [i] = xnew;  	if (Math.Abs (delx) > maxdel)  		maxdel = Math.Abs (delx);  	sum0 = y [N - 2];  	sum1 = y [N - 1];  	for (int j = 0; j < N - 2; j++) {  		sum0 -= C [N - 2] [j] * rval [j];  		sum1 -= C [N - 1] [j] * rval [j];  	}  	num = C [N - 1] [N - 2] * sum0 - C [N - 2] [N - 2] * sum1;  	den = C [N - 1] [N - 2] * C [N - 2] [N - 1] - C [N - 2] [N - 2] * C [N - 1] [N - 1];  	xnew = num / den;  	delx = xnew - rval [N - 1];  	rval [N - 1] = xnew;  	if (Math.Abs (delx) > maxdel)  		maxdel = Math.Abs (delx);  	if (maxdel < DelLimit)  		k = MaxIt;  	k += 1;  }  
Magic Number,HydroSense,Util,C:\repos\usbr_hydrosense\Hydro$ense\Util.cs,LinearEquationSolver,The following statement contains a magic number: for (int j = i + 2; j < N; j++) {  	sum0 -= C [i] [j] * rval [j];  	sum1 -= C [i + 1] [j] * rval [j];  }  
Magic Number,HydroSense,Util,C:\repos\usbr_hydrosense\Hydro$ense\Util.cs,LinearEquationSolver,The following statement contains a magic number: sum0 = y [N - 2];  
Magic Number,HydroSense,Util,C:\repos\usbr_hydrosense\Hydro$ense\Util.cs,LinearEquationSolver,The following statement contains a magic number: for (int j = 0; j < N - 2; j++) {  	sum0 -= C [N - 2] [j] * rval [j];  	sum1 -= C [N - 1] [j] * rval [j];  }  
Magic Number,HydroSense,Util,C:\repos\usbr_hydrosense\Hydro$ense\Util.cs,LinearEquationSolver,The following statement contains a magic number: for (int j = 0; j < N - 2; j++) {  	sum0 -= C [N - 2] [j] * rval [j];  	sum1 -= C [N - 1] [j] * rval [j];  }  
Magic Number,HydroSense,Util,C:\repos\usbr_hydrosense\Hydro$ense\Util.cs,LinearEquationSolver,The following statement contains a magic number: sum0 -= C [N - 2] [j] * rval [j];  
Magic Number,HydroSense,Util,C:\repos\usbr_hydrosense\Hydro$ense\Util.cs,LinearEquationSolver,The following statement contains a magic number: num = C [N - 1] [N - 2] * sum0 - C [N - 2] [N - 2] * sum1;  
Magic Number,HydroSense,Util,C:\repos\usbr_hydrosense\Hydro$ense\Util.cs,LinearEquationSolver,The following statement contains a magic number: num = C [N - 1] [N - 2] * sum0 - C [N - 2] [N - 2] * sum1;  
Magic Number,HydroSense,Util,C:\repos\usbr_hydrosense\Hydro$ense\Util.cs,LinearEquationSolver,The following statement contains a magic number: num = C [N - 1] [N - 2] * sum0 - C [N - 2] [N - 2] * sum1;  
Magic Number,HydroSense,Util,C:\repos\usbr_hydrosense\Hydro$ense\Util.cs,LinearEquationSolver,The following statement contains a magic number: den = C [N - 1] [N - 2] * C [N - 2] [N - 1] - C [N - 2] [N - 2] * C [N - 1] [N - 1];  
Magic Number,HydroSense,Util,C:\repos\usbr_hydrosense\Hydro$ense\Util.cs,LinearEquationSolver,The following statement contains a magic number: den = C [N - 1] [N - 2] * C [N - 2] [N - 1] - C [N - 2] [N - 2] * C [N - 1] [N - 1];  
Magic Number,HydroSense,Util,C:\repos\usbr_hydrosense\Hydro$ense\Util.cs,LinearEquationSolver,The following statement contains a magic number: den = C [N - 1] [N - 2] * C [N - 2] [N - 1] - C [N - 2] [N - 2] * C [N - 1] [N - 1];  
Magic Number,HydroSense,Util,C:\repos\usbr_hydrosense\Hydro$ense\Util.cs,LinearEquationSolver,The following statement contains a magic number: den = C [N - 1] [N - 2] * C [N - 2] [N - 1] - C [N - 2] [N - 2] * C [N - 1] [N - 1];  
