Implementation smell,Namespace,Class,File,Method,Description
Long Method,DogSE.Server.Core.Config,StaticConfigFileManager,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\Config\StaticConfigFileManager.cs,LoadData,The method has 196 lines of code.
Long Method,DogSE.Server.Core,GameServerService,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\GameServerService.cs,StartCommandlinesDisposal,The method has 150 lines of code.
Long Method,DogSE.Server.Core.Protocol,CreateReadCode,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\Protocol\CreateReadCode.cs,AddMethod,The method has 104 lines of code.
Complex Method,DogSE.Server.Core.Config,StaticConfigFileManager,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\Config\StaticConfigFileManager.cs,LoadData,Cyclomatic complexity of the method is 8
Complex Method,DogSE.Server.Core,GameServerService,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\GameServerService.cs,StartGame,Cyclomatic complexity of the method is 8
Complex Method,DogSE.Server.Core,WorldBase,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\WorldBase.cs,OnSocketRecv,Cyclomatic complexity of the method is 12
Complex Method,DogSE.Server.Core.LogicModule,LogicModuleManager,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\LogicModule\LogicModuleManager.cs,Initializationing,Cyclomatic complexity of the method is 14
Complex Method,DogSE.Server.Core.Protocol,CreateProxyCode,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\Protocol\CreateProxyCode.cs,AddMethod,Cyclomatic complexity of the method is 8
Complex Method,DogSE.Server.Core.Protocol,CreateReadCode,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\Protocol\CreateReadCode.cs,AddMethod,Cyclomatic complexity of the method is 14
Complex Method,DogSE.Server.Core.Timer,TimerThread,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\Timer\TimerThread.cs,RunTimerThread,Cyclomatic complexity of the method is 17
Complex Method,DogSE.Server.Core.Util,AssemblyUtil,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\Util\AssemblyUtil.cs,GetAssemblies,Cyclomatic complexity of the method is 8
Long Parameter List,DogSE.Server.Core.Task,NetTaskCodeRuntimeWriter,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\Task\NetTaskCodeRuntimeWriter.cs,Write,The method has 5 parameters. Parameters: code' playerId' runTime' waitTime' isException
Long Parameter List,DogSE.Server.Core.Timer,DelayCallTimer,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\Timer\DelayCallTimer.cs,DelayCallTimer,The method has 5 parameters. Parameters: delayTimeSpan' intervalTimeSpan' iTimes' timeLeft' timerCallback
Long Parameter List,DogSE.Server.Core.Timer,DelayStateCallTimer<T>,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\Timer\DelayStateCallTimer.cs,DelayStateCallTimer,The method has 6 parameters. Parameters: delayTimeSpan' intervalTimeSpan' iTimes' timeLeft' timerStateCallback' tState
Long Parameter List,DogSE.Server.Core.Timer,TimeSliceUtil,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\Timer\TimeSliceUtil.cs,StartTimeSlice,The method has 5 parameters. Parameters: delayTimeSpan' intervalTimeSpan' iTimes' timeLeft' timerCallback
Long Parameter List,DogSE.Server.Core.Timer,TimeSliceUtil,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\Timer\TimeSliceUtil.cs,StartTimeSlice,The method has 5 parameters. Parameters: delayTimeSpan' intervalTimeSpan' iTimes' timerStateCallback' tState
Long Parameter List,DogSE.Server.Core.Timer,TimeSliceUtil,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\Timer\TimeSliceUtil.cs,StartTimeSlice,The method has 5 parameters. Parameters: delayTimeSpan' intervalTimeSpan' timeLeft' timerStateCallback' tState
Long Parameter List,DogSE.Server.Core.Timer,TimeSliceUtil,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\Timer\TimeSliceUtil.cs,StartTimeSlice,The method has 6 parameters. Parameters: delayTimeSpan' intervalTimeSpan' iTimes' timeLeft' timerStateCallback' tState
Long Identifier,DogSE.Server.Core.Timer,TimerThread,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\Timer\TimerThread.cs,,The length of the parameter s_LockTimerChangeEntryChangeQueue is 33.
Long Statement,DogSE.Server.Core.Config,DynamicConfigFileManager,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\Config\DynamicConfigFileManager.cs,LoadCSVConfig,The length of the statement  "                var rootAttribute =(DynamicCSVConfigRootAttribute)type.GetCustomAttributes(typeof(DynamicCSVConfigRootAttribute)' true)[0]; " is 123.
Long Statement,DogSE.Server.Core.Config,StaticConfigFileManager,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\Config\StaticConfigFileManager.cs,LoadData,The length of the statement  "                var rootAttribute = (StaticXmlConfigRootAttribute) type.GetCustomAttributes(typeof (StaticXmlConfigRootAttribute)' true)[0]; " is 124.
Long Statement,DogSE.Server.Core.Config,StaticConfigFileManager,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\Config\StaticConfigFileManager.cs,LoadData,The length of the statement  "                foreach(var pro in type.GetProperties(BindingFlags.Public | BindingFlags.Static | BindingFlags.SetProperty | BindingFlags.GetProperty )) " is 136.
Long Statement,DogSE.Server.Core.Net,PacketReader,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\Net\PacketReader.cs,ReadLong64,The length of the statement  "                return ( (long)m_Data[m_Index++] << 56 ) | ( (long)m_Data[m_Index++] << 48 ) | ( (long)m_Data[m_Index++] << 40 ) | ( (long)m_Data[m_Index++] << 32 ) | ( (uint)( m_Data[m_Index++] << 24 ) ) | ( (uint)m_Data[m_Index++] << 16 ) | ( (uint)m_Data[m_Index++] << 8 ) | m_Data[m_Index++]; " is 280.
Long Statement,DogSE.Server.Core.Net,PacketReader,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\Net\PacketReader.cs,ReadLong64,The length of the statement  "                return m_Data[m_Index++] | ((long)m_Data[m_Index++] << 8) | ((long)m_Data[m_Index++] << 16) | ((long)m_Data[m_Index++] << 24) | ((long)m_Data[m_Index++] << 32) | ((long)m_Data[m_Index++] << 40) | ((long)m_Data[m_Index++] << 48) | ((long)m_Data[m_Index++] << 56); " is 262.
Long Statement,DogSE.Server.Core.Net,PacketReader,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\Net\PacketReader.cs,ReadULong64,The length of the statement  "                return (ulong)( ( (long)m_Data[m_Index++] << 56 ) | ( (long)m_Data[m_Index++] << 48 ) | ( (long)m_Data[m_Index++] << 40 ) | ( (long)m_Data[m_Index++] << 32 ) | ( (uint)m_Data[m_Index++] << 24 ) | ( (uint)m_Data[m_Index++] << 16 ) | ( (uint)m_Data[m_Index++] << 8 ) | m_Data[m_Index++] ); " is 287.
Long Statement,DogSE.Server.Core.Net,PacketReader,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\Net\PacketReader.cs,ReadULong64,The length of the statement  "                return (ulong)(m_Data[m_Index++] | ((long)m_Data[m_Index++] << 8) | ((long)m_Data[m_Index++] << 16) | ((long)m_Data[m_Index++] << 24) | ((long)m_Data[m_Index++] << 32) | ((long)m_Data[m_Index++] << 40) | ((long)m_Data[m_Index++] << 48) | ((long)m_Data[m_Index++] << 56)); " is 271.
Long Statement,DogSE.Server.Core.Net,PacketReader,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\Net\PacketReader.cs,ReadUInt32,The length of the statement  "                return (uint)( ( m_Data[m_Index++] << 24 ) | ( m_Data[m_Index++] << 16 ) | ( m_Data[m_Index++] << 8 ) | m_Data[m_Index++] ); " is 124.
Long Statement,DogSE.Server.Core.Protocol,CreateReadCode,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\Protocol\CreateReadCode.cs,AddMethod,The length of the statement  "                callCode.AppendFormat(" var package = DogSE.Library.Common.StaticObjectPool<{0}>.AcquireContent();"' param[1].ParameterType.FullName); " is 134.
Long Statement,DogSE.Server.Core.Protocol,CreateReadCode,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\Protocol\CreateReadCode.cs,AddMethod,The length of the statement  "                callCode.AppendFormat("DogSE.Library.Common.StaticObjectPool<{0}>.ReleaseContent(package);"' param[1].ParameterType.FullName); " is 126.
Long Statement,DogSE.Server.Core.Timer,TimeSliceUtil,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\Timer\TimeSliceUtil.cs,StartTimeSlice,The length of the statement  "            TimeSlice timeSlice = new DelayStateCallTimer<T>(delayTimeSpan' intervalTimeSpan' iTimes' timeLeft' timerStateCallback' tState); " is 128.
Complex Conditional,DogSE.Server.Core,GameServerService,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\GameServerService.cs,StartCommandlinesDisposal,The conditional expression  "((int)keyInfo.Key >= 65 && (int)keyInfo.Key <= 90) || ((int)keyInfo.Key >= 97 && (int)keyInfo.Key <= 122)                              || ((keyInfo.KeyChar >= '0') && keyInfo.KeyChar <= '9')"  is complex.
Magic Number,DogSE.Server.Core.Config,ServerConfig,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\Config\ServerConfig.cs,ServerConfig,The following statement contains a magic number: CheckOfflinePlayerTimeSpan = 60;
Magic Number,DogSE.Server.Core,GameServerService,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\GameServerService.cs,StartCommandlinesDisposal,The following statement contains a magic number: while (RunType == ServerStateType.Runing)              {                  ConsoleKeyInfo keyInfo = new ConsoleKeyInfo();                  StringBuilder strStringBuilder = new StringBuilder();                  string strReadLine = string.Empty;                    do                  {                      #region 等待键盘的输入                        try                      {                          while (true)                          {                              //  这里通过100ms间隔的方式检测是否有键盘输入事件                              //  如果是，则进行下面的逻辑处理，如果没有判断服务器是否要停止                              //  如果需要停止，则不再走下面的流程，这样才能让主线程退出                              //  添加这个的目的是为了让GM命令使服务器退出，而不卡在主线程的键盘输入等待里                              if (Console.KeyAvailable)                              {                                  keyInfo = Console.ReadKey(false);                                  break;                              }                                if (RunType == ServerStateType.Closing)                                  break;                                Thread.Sleep(100);                          }                      }                      catch (Exception ex)                      {                          Logs.Error("Console read key fail."' ex);                          if (RunType == ServerStateType.Closing)                              break;                          continue;                      }                        #endregion                        // 再次检测程序已经运行                      if (RunType == ServerStateType.Closing)                          break;                        // 像是串一个命令行' 如果收到"回车"则退出while                      #region 对输入的按键（回车，空格，退格，方向键【用于快速切换上下命令】）做处理                        // 回车                      if (keyInfo.Key == ConsoleKey.Enter)                      {                          strReadLine = strStringBuilder.ToString();                          strStringBuilder.Clear();                            // 如果输入的键值为空，继续等待输入                          if (string.IsNullOrEmpty(strReadLine))                              continue;                          break;                      }                        // 退格                      if (keyInfo.Key == ConsoleKey.Backspace)                      {                          if (strStringBuilder.Length > 0)                              strStringBuilder.Remove(strStringBuilder.Length - 1' 1);                          else                              continue;                      }                      else if (keyInfo.Key == ConsoleKey.UpArrow)                      {                          s_CommandlinesIndex--;                          int iCommandlinesIndex = s_CommandlinesIndex;                            if (iCommandlinesIndex < 0)                          {                              s_CommandlinesIndex = 0;                              continue;                          }                          else                          {                              strStringBuilder.Clear();                              strStringBuilder.Append(s_Commandlines[iCommandlinesIndex]);                          }                      }                      else if (keyInfo.Key == ConsoleKey.DownArrow)                      {                          s_CommandlinesIndex++;                          int iCommandlinesIndex = s_CommandlinesIndex;                            if (iCommandlinesIndex >= s_Commandlines.Count)                          {                              s_CommandlinesIndex = s_Commandlines.Count - 1;                              continue;                          }                          else                          {                              strStringBuilder.Clear();                              strStringBuilder.Append(s_Commandlines[iCommandlinesIndex]);                          }                      }                      else if (keyInfo.Key == ConsoleKey.Spacebar)                      {                          if (strStringBuilder.Length < 255)                              strStringBuilder.Append(keyInfo.KeyChar);                          else                              continue;                      }                      else                      {                          if (((int)keyInfo.Key >= 65 && (int)keyInfo.Key <= 90) || ((int)keyInfo.Key >= 97 && (int)keyInfo.Key <= 122)                              || ((keyInfo.KeyChar >= '0') && keyInfo.KeyChar <= '9'))                          {                              // 最多 255 个有效的字符                              if (strStringBuilder.Length < 255)                                  strStringBuilder.Append(keyInfo.KeyChar);                              else                                  continue;                          }                      }                        #endregion                        strReadLine = strStringBuilder.ToString();                      //Logs.WriteLine(true' LogMessageType.MSG_INPUT' strReadLine);                    } while (true);                    if (string.IsNullOrEmpty(strReadLine))                  {                      continue;                  }                    s_Commandlines.Add(strReadLine);                  s_CommandlinesIndex++;                    string cmdStr = strReadLine.TrimStart();                  var first = cmdStr.Split(new[] { ' ' }' StringSplitOptions.RemoveEmptyEntries);                  var op = string.Empty;                  if (first.Length > 0)                      op = first[0].ToLower();                    if (first.Length > 0 && s_cmdProcList.ContainsKey(op))                  {                      try                      {                          if (!s_cmdProcList[op](cmdStr))                              Logs.Error(string.Format("run gm command fail. {0}"' op));                      }                      catch (Exception ex)                      {                          Logs.Error(string.Format("run gm exception. command={0}"' op)' ex);                      }                  }                  else                  {                      if (strReadLine != string.Empty)                          Logs.Warn("命令({0}) : 未知的无效命令"' cmdStr);                  }                }
Magic Number,DogSE.Server.Core,GameServerService,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\GameServerService.cs,StartCommandlinesDisposal,The following statement contains a magic number: while (RunType == ServerStateType.Runing)              {                  ConsoleKeyInfo keyInfo = new ConsoleKeyInfo();                  StringBuilder strStringBuilder = new StringBuilder();                  string strReadLine = string.Empty;                    do                  {                      #region 等待键盘的输入                        try                      {                          while (true)                          {                              //  这里通过100ms间隔的方式检测是否有键盘输入事件                              //  如果是，则进行下面的逻辑处理，如果没有判断服务器是否要停止                              //  如果需要停止，则不再走下面的流程，这样才能让主线程退出                              //  添加这个的目的是为了让GM命令使服务器退出，而不卡在主线程的键盘输入等待里                              if (Console.KeyAvailable)                              {                                  keyInfo = Console.ReadKey(false);                                  break;                              }                                if (RunType == ServerStateType.Closing)                                  break;                                Thread.Sleep(100);                          }                      }                      catch (Exception ex)                      {                          Logs.Error("Console read key fail."' ex);                          if (RunType == ServerStateType.Closing)                              break;                          continue;                      }                        #endregion                        // 再次检测程序已经运行                      if (RunType == ServerStateType.Closing)                          break;                        // 像是串一个命令行' 如果收到"回车"则退出while                      #region 对输入的按键（回车，空格，退格，方向键【用于快速切换上下命令】）做处理                        // 回车                      if (keyInfo.Key == ConsoleKey.Enter)                      {                          strReadLine = strStringBuilder.ToString();                          strStringBuilder.Clear();                            // 如果输入的键值为空，继续等待输入                          if (string.IsNullOrEmpty(strReadLine))                              continue;                          break;                      }                        // 退格                      if (keyInfo.Key == ConsoleKey.Backspace)                      {                          if (strStringBuilder.Length > 0)                              strStringBuilder.Remove(strStringBuilder.Length - 1' 1);                          else                              continue;                      }                      else if (keyInfo.Key == ConsoleKey.UpArrow)                      {                          s_CommandlinesIndex--;                          int iCommandlinesIndex = s_CommandlinesIndex;                            if (iCommandlinesIndex < 0)                          {                              s_CommandlinesIndex = 0;                              continue;                          }                          else                          {                              strStringBuilder.Clear();                              strStringBuilder.Append(s_Commandlines[iCommandlinesIndex]);                          }                      }                      else if (keyInfo.Key == ConsoleKey.DownArrow)                      {                          s_CommandlinesIndex++;                          int iCommandlinesIndex = s_CommandlinesIndex;                            if (iCommandlinesIndex >= s_Commandlines.Count)                          {                              s_CommandlinesIndex = s_Commandlines.Count - 1;                              continue;                          }                          else                          {                              strStringBuilder.Clear();                              strStringBuilder.Append(s_Commandlines[iCommandlinesIndex]);                          }                      }                      else if (keyInfo.Key == ConsoleKey.Spacebar)                      {                          if (strStringBuilder.Length < 255)                              strStringBuilder.Append(keyInfo.KeyChar);                          else                              continue;                      }                      else                      {                          if (((int)keyInfo.Key >= 65 && (int)keyInfo.Key <= 90) || ((int)keyInfo.Key >= 97 && (int)keyInfo.Key <= 122)                              || ((keyInfo.KeyChar >= '0') && keyInfo.KeyChar <= '9'))                          {                              // 最多 255 个有效的字符                              if (strStringBuilder.Length < 255)                                  strStringBuilder.Append(keyInfo.KeyChar);                              else                                  continue;                          }                      }                        #endregion                        strReadLine = strStringBuilder.ToString();                      //Logs.WriteLine(true' LogMessageType.MSG_INPUT' strReadLine);                    } while (true);                    if (string.IsNullOrEmpty(strReadLine))                  {                      continue;                  }                    s_Commandlines.Add(strReadLine);                  s_CommandlinesIndex++;                    string cmdStr = strReadLine.TrimStart();                  var first = cmdStr.Split(new[] { ' ' }' StringSplitOptions.RemoveEmptyEntries);                  var op = string.Empty;                  if (first.Length > 0)                      op = first[0].ToLower();                    if (first.Length > 0 && s_cmdProcList.ContainsKey(op))                  {                      try                      {                          if (!s_cmdProcList[op](cmdStr))                              Logs.Error(string.Format("run gm command fail. {0}"' op));                      }                      catch (Exception ex)                      {                          Logs.Error(string.Format("run gm exception. command={0}"' op)' ex);                      }                  }                  else                  {                      if (strReadLine != string.Empty)                          Logs.Warn("命令({0}) : 未知的无效命令"' cmdStr);                  }                }
Magic Number,DogSE.Server.Core,GameServerService,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\GameServerService.cs,StartCommandlinesDisposal,The following statement contains a magic number: while (RunType == ServerStateType.Runing)              {                  ConsoleKeyInfo keyInfo = new ConsoleKeyInfo();                  StringBuilder strStringBuilder = new StringBuilder();                  string strReadLine = string.Empty;                    do                  {                      #region 等待键盘的输入                        try                      {                          while (true)                          {                              //  这里通过100ms间隔的方式检测是否有键盘输入事件                              //  如果是，则进行下面的逻辑处理，如果没有判断服务器是否要停止                              //  如果需要停止，则不再走下面的流程，这样才能让主线程退出                              //  添加这个的目的是为了让GM命令使服务器退出，而不卡在主线程的键盘输入等待里                              if (Console.KeyAvailable)                              {                                  keyInfo = Console.ReadKey(false);                                  break;                              }                                if (RunType == ServerStateType.Closing)                                  break;                                Thread.Sleep(100);                          }                      }                      catch (Exception ex)                      {                          Logs.Error("Console read key fail."' ex);                          if (RunType == ServerStateType.Closing)                              break;                          continue;                      }                        #endregion                        // 再次检测程序已经运行                      if (RunType == ServerStateType.Closing)                          break;                        // 像是串一个命令行' 如果收到"回车"则退出while                      #region 对输入的按键（回车，空格，退格，方向键【用于快速切换上下命令】）做处理                        // 回车                      if (keyInfo.Key == ConsoleKey.Enter)                      {                          strReadLine = strStringBuilder.ToString();                          strStringBuilder.Clear();                            // 如果输入的键值为空，继续等待输入                          if (string.IsNullOrEmpty(strReadLine))                              continue;                          break;                      }                        // 退格                      if (keyInfo.Key == ConsoleKey.Backspace)                      {                          if (strStringBuilder.Length > 0)                              strStringBuilder.Remove(strStringBuilder.Length - 1' 1);                          else                              continue;                      }                      else if (keyInfo.Key == ConsoleKey.UpArrow)                      {                          s_CommandlinesIndex--;                          int iCommandlinesIndex = s_CommandlinesIndex;                            if (iCommandlinesIndex < 0)                          {                              s_CommandlinesIndex = 0;                              continue;                          }                          else                          {                              strStringBuilder.Clear();                              strStringBuilder.Append(s_Commandlines[iCommandlinesIndex]);                          }                      }                      else if (keyInfo.Key == ConsoleKey.DownArrow)                      {                          s_CommandlinesIndex++;                          int iCommandlinesIndex = s_CommandlinesIndex;                            if (iCommandlinesIndex >= s_Commandlines.Count)                          {                              s_CommandlinesIndex = s_Commandlines.Count - 1;                              continue;                          }                          else                          {                              strStringBuilder.Clear();                              strStringBuilder.Append(s_Commandlines[iCommandlinesIndex]);                          }                      }                      else if (keyInfo.Key == ConsoleKey.Spacebar)                      {                          if (strStringBuilder.Length < 255)                              strStringBuilder.Append(keyInfo.KeyChar);                          else                              continue;                      }                      else                      {                          if (((int)keyInfo.Key >= 65 && (int)keyInfo.Key <= 90) || ((int)keyInfo.Key >= 97 && (int)keyInfo.Key <= 122)                              || ((keyInfo.KeyChar >= '0') && keyInfo.KeyChar <= '9'))                          {                              // 最多 255 个有效的字符                              if (strStringBuilder.Length < 255)                                  strStringBuilder.Append(keyInfo.KeyChar);                              else                                  continue;                          }                      }                        #endregion                        strReadLine = strStringBuilder.ToString();                      //Logs.WriteLine(true' LogMessageType.MSG_INPUT' strReadLine);                    } while (true);                    if (string.IsNullOrEmpty(strReadLine))                  {                      continue;                  }                    s_Commandlines.Add(strReadLine);                  s_CommandlinesIndex++;                    string cmdStr = strReadLine.TrimStart();                  var first = cmdStr.Split(new[] { ' ' }' StringSplitOptions.RemoveEmptyEntries);                  var op = string.Empty;                  if (first.Length > 0)                      op = first[0].ToLower();                    if (first.Length > 0 && s_cmdProcList.ContainsKey(op))                  {                      try                      {                          if (!s_cmdProcList[op](cmdStr))                              Logs.Error(string.Format("run gm command fail. {0}"' op));                      }                      catch (Exception ex)                      {                          Logs.Error(string.Format("run gm exception. command={0}"' op)' ex);                      }                  }                  else                  {                      if (strReadLine != string.Empty)                          Logs.Warn("命令({0}) : 未知的无效命令"' cmdStr);                  }                }
Magic Number,DogSE.Server.Core,GameServerService,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\GameServerService.cs,StartCommandlinesDisposal,The following statement contains a magic number: while (RunType == ServerStateType.Runing)              {                  ConsoleKeyInfo keyInfo = new ConsoleKeyInfo();                  StringBuilder strStringBuilder = new StringBuilder();                  string strReadLine = string.Empty;                    do                  {                      #region 等待键盘的输入                        try                      {                          while (true)                          {                              //  这里通过100ms间隔的方式检测是否有键盘输入事件                              //  如果是，则进行下面的逻辑处理，如果没有判断服务器是否要停止                              //  如果需要停止，则不再走下面的流程，这样才能让主线程退出                              //  添加这个的目的是为了让GM命令使服务器退出，而不卡在主线程的键盘输入等待里                              if (Console.KeyAvailable)                              {                                  keyInfo = Console.ReadKey(false);                                  break;                              }                                if (RunType == ServerStateType.Closing)                                  break;                                Thread.Sleep(100);                          }                      }                      catch (Exception ex)                      {                          Logs.Error("Console read key fail."' ex);                          if (RunType == ServerStateType.Closing)                              break;                          continue;                      }                        #endregion                        // 再次检测程序已经运行                      if (RunType == ServerStateType.Closing)                          break;                        // 像是串一个命令行' 如果收到"回车"则退出while                      #region 对输入的按键（回车，空格，退格，方向键【用于快速切换上下命令】）做处理                        // 回车                      if (keyInfo.Key == ConsoleKey.Enter)                      {                          strReadLine = strStringBuilder.ToString();                          strStringBuilder.Clear();                            // 如果输入的键值为空，继续等待输入                          if (string.IsNullOrEmpty(strReadLine))                              continue;                          break;                      }                        // 退格                      if (keyInfo.Key == ConsoleKey.Backspace)                      {                          if (strStringBuilder.Length > 0)                              strStringBuilder.Remove(strStringBuilder.Length - 1' 1);                          else                              continue;                      }                      else if (keyInfo.Key == ConsoleKey.UpArrow)                      {                          s_CommandlinesIndex--;                          int iCommandlinesIndex = s_CommandlinesIndex;                            if (iCommandlinesIndex < 0)                          {                              s_CommandlinesIndex = 0;                              continue;                          }                          else                          {                              strStringBuilder.Clear();                              strStringBuilder.Append(s_Commandlines[iCommandlinesIndex]);                          }                      }                      else if (keyInfo.Key == ConsoleKey.DownArrow)                      {                          s_CommandlinesIndex++;                          int iCommandlinesIndex = s_CommandlinesIndex;                            if (iCommandlinesIndex >= s_Commandlines.Count)                          {                              s_CommandlinesIndex = s_Commandlines.Count - 1;                              continue;                          }                          else                          {                              strStringBuilder.Clear();                              strStringBuilder.Append(s_Commandlines[iCommandlinesIndex]);                          }                      }                      else if (keyInfo.Key == ConsoleKey.Spacebar)                      {                          if (strStringBuilder.Length < 255)                              strStringBuilder.Append(keyInfo.KeyChar);                          else                              continue;                      }                      else                      {                          if (((int)keyInfo.Key >= 65 && (int)keyInfo.Key <= 90) || ((int)keyInfo.Key >= 97 && (int)keyInfo.Key <= 122)                              || ((keyInfo.KeyChar >= '0') && keyInfo.KeyChar <= '9'))                          {                              // 最多 255 个有效的字符                              if (strStringBuilder.Length < 255)                                  strStringBuilder.Append(keyInfo.KeyChar);                              else                                  continue;                          }                      }                        #endregion                        strReadLine = strStringBuilder.ToString();                      //Logs.WriteLine(true' LogMessageType.MSG_INPUT' strReadLine);                    } while (true);                    if (string.IsNullOrEmpty(strReadLine))                  {                      continue;                  }                    s_Commandlines.Add(strReadLine);                  s_CommandlinesIndex++;                    string cmdStr = strReadLine.TrimStart();                  var first = cmdStr.Split(new[] { ' ' }' StringSplitOptions.RemoveEmptyEntries);                  var op = string.Empty;                  if (first.Length > 0)                      op = first[0].ToLower();                    if (first.Length > 0 && s_cmdProcList.ContainsKey(op))                  {                      try                      {                          if (!s_cmdProcList[op](cmdStr))                              Logs.Error(string.Format("run gm command fail. {0}"' op));                      }                      catch (Exception ex)                      {                          Logs.Error(string.Format("run gm exception. command={0}"' op)' ex);                      }                  }                  else                  {                      if (strReadLine != string.Empty)                          Logs.Warn("命令({0}) : 未知的无效命令"' cmdStr);                  }                }
Magic Number,DogSE.Server.Core,GameServerService,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\GameServerService.cs,StartCommandlinesDisposal,The following statement contains a magic number: while (RunType == ServerStateType.Runing)              {                  ConsoleKeyInfo keyInfo = new ConsoleKeyInfo();                  StringBuilder strStringBuilder = new StringBuilder();                  string strReadLine = string.Empty;                    do                  {                      #region 等待键盘的输入                        try                      {                          while (true)                          {                              //  这里通过100ms间隔的方式检测是否有键盘输入事件                              //  如果是，则进行下面的逻辑处理，如果没有判断服务器是否要停止                              //  如果需要停止，则不再走下面的流程，这样才能让主线程退出                              //  添加这个的目的是为了让GM命令使服务器退出，而不卡在主线程的键盘输入等待里                              if (Console.KeyAvailable)                              {                                  keyInfo = Console.ReadKey(false);                                  break;                              }                                if (RunType == ServerStateType.Closing)                                  break;                                Thread.Sleep(100);                          }                      }                      catch (Exception ex)                      {                          Logs.Error("Console read key fail."' ex);                          if (RunType == ServerStateType.Closing)                              break;                          continue;                      }                        #endregion                        // 再次检测程序已经运行                      if (RunType == ServerStateType.Closing)                          break;                        // 像是串一个命令行' 如果收到"回车"则退出while                      #region 对输入的按键（回车，空格，退格，方向键【用于快速切换上下命令】）做处理                        // 回车                      if (keyInfo.Key == ConsoleKey.Enter)                      {                          strReadLine = strStringBuilder.ToString();                          strStringBuilder.Clear();                            // 如果输入的键值为空，继续等待输入                          if (string.IsNullOrEmpty(strReadLine))                              continue;                          break;                      }                        // 退格                      if (keyInfo.Key == ConsoleKey.Backspace)                      {                          if (strStringBuilder.Length > 0)                              strStringBuilder.Remove(strStringBuilder.Length - 1' 1);                          else                              continue;                      }                      else if (keyInfo.Key == ConsoleKey.UpArrow)                      {                          s_CommandlinesIndex--;                          int iCommandlinesIndex = s_CommandlinesIndex;                            if (iCommandlinesIndex < 0)                          {                              s_CommandlinesIndex = 0;                              continue;                          }                          else                          {                              strStringBuilder.Clear();                              strStringBuilder.Append(s_Commandlines[iCommandlinesIndex]);                          }                      }                      else if (keyInfo.Key == ConsoleKey.DownArrow)                      {                          s_CommandlinesIndex++;                          int iCommandlinesIndex = s_CommandlinesIndex;                            if (iCommandlinesIndex >= s_Commandlines.Count)                          {                              s_CommandlinesIndex = s_Commandlines.Count - 1;                              continue;                          }                          else                          {                              strStringBuilder.Clear();                              strStringBuilder.Append(s_Commandlines[iCommandlinesIndex]);                          }                      }                      else if (keyInfo.Key == ConsoleKey.Spacebar)                      {                          if (strStringBuilder.Length < 255)                              strStringBuilder.Append(keyInfo.KeyChar);                          else                              continue;                      }                      else                      {                          if (((int)keyInfo.Key >= 65 && (int)keyInfo.Key <= 90) || ((int)keyInfo.Key >= 97 && (int)keyInfo.Key <= 122)                              || ((keyInfo.KeyChar >= '0') && keyInfo.KeyChar <= '9'))                          {                              // 最多 255 个有效的字符                              if (strStringBuilder.Length < 255)                                  strStringBuilder.Append(keyInfo.KeyChar);                              else                                  continue;                          }                      }                        #endregion                        strReadLine = strStringBuilder.ToString();                      //Logs.WriteLine(true' LogMessageType.MSG_INPUT' strReadLine);                    } while (true);                    if (string.IsNullOrEmpty(strReadLine))                  {                      continue;                  }                    s_Commandlines.Add(strReadLine);                  s_CommandlinesIndex++;                    string cmdStr = strReadLine.TrimStart();                  var first = cmdStr.Split(new[] { ' ' }' StringSplitOptions.RemoveEmptyEntries);                  var op = string.Empty;                  if (first.Length > 0)                      op = first[0].ToLower();                    if (first.Length > 0 && s_cmdProcList.ContainsKey(op))                  {                      try                      {                          if (!s_cmdProcList[op](cmdStr))                              Logs.Error(string.Format("run gm command fail. {0}"' op));                      }                      catch (Exception ex)                      {                          Logs.Error(string.Format("run gm exception. command={0}"' op)' ex);                      }                  }                  else                  {                      if (strReadLine != string.Empty)                          Logs.Warn("命令({0}) : 未知的无效命令"' cmdStr);                  }                }
Magic Number,DogSE.Server.Core,GameServerService,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\GameServerService.cs,StartCommandlinesDisposal,The following statement contains a magic number: while (RunType == ServerStateType.Runing)              {                  ConsoleKeyInfo keyInfo = new ConsoleKeyInfo();                  StringBuilder strStringBuilder = new StringBuilder();                  string strReadLine = string.Empty;                    do                  {                      #region 等待键盘的输入                        try                      {                          while (true)                          {                              //  这里通过100ms间隔的方式检测是否有键盘输入事件                              //  如果是，则进行下面的逻辑处理，如果没有判断服务器是否要停止                              //  如果需要停止，则不再走下面的流程，这样才能让主线程退出                              //  添加这个的目的是为了让GM命令使服务器退出，而不卡在主线程的键盘输入等待里                              if (Console.KeyAvailable)                              {                                  keyInfo = Console.ReadKey(false);                                  break;                              }                                if (RunType == ServerStateType.Closing)                                  break;                                Thread.Sleep(100);                          }                      }                      catch (Exception ex)                      {                          Logs.Error("Console read key fail."' ex);                          if (RunType == ServerStateType.Closing)                              break;                          continue;                      }                        #endregion                        // 再次检测程序已经运行                      if (RunType == ServerStateType.Closing)                          break;                        // 像是串一个命令行' 如果收到"回车"则退出while                      #region 对输入的按键（回车，空格，退格，方向键【用于快速切换上下命令】）做处理                        // 回车                      if (keyInfo.Key == ConsoleKey.Enter)                      {                          strReadLine = strStringBuilder.ToString();                          strStringBuilder.Clear();                            // 如果输入的键值为空，继续等待输入                          if (string.IsNullOrEmpty(strReadLine))                              continue;                          break;                      }                        // 退格                      if (keyInfo.Key == ConsoleKey.Backspace)                      {                          if (strStringBuilder.Length > 0)                              strStringBuilder.Remove(strStringBuilder.Length - 1' 1);                          else                              continue;                      }                      else if (keyInfo.Key == ConsoleKey.UpArrow)                      {                          s_CommandlinesIndex--;                          int iCommandlinesIndex = s_CommandlinesIndex;                            if (iCommandlinesIndex < 0)                          {                              s_CommandlinesIndex = 0;                              continue;                          }                          else                          {                              strStringBuilder.Clear();                              strStringBuilder.Append(s_Commandlines[iCommandlinesIndex]);                          }                      }                      else if (keyInfo.Key == ConsoleKey.DownArrow)                      {                          s_CommandlinesIndex++;                          int iCommandlinesIndex = s_CommandlinesIndex;                            if (iCommandlinesIndex >= s_Commandlines.Count)                          {                              s_CommandlinesIndex = s_Commandlines.Count - 1;                              continue;                          }                          else                          {                              strStringBuilder.Clear();                              strStringBuilder.Append(s_Commandlines[iCommandlinesIndex]);                          }                      }                      else if (keyInfo.Key == ConsoleKey.Spacebar)                      {                          if (strStringBuilder.Length < 255)                              strStringBuilder.Append(keyInfo.KeyChar);                          else                              continue;                      }                      else                      {                          if (((int)keyInfo.Key >= 65 && (int)keyInfo.Key <= 90) || ((int)keyInfo.Key >= 97 && (int)keyInfo.Key <= 122)                              || ((keyInfo.KeyChar >= '0') && keyInfo.KeyChar <= '9'))                          {                              // 最多 255 个有效的字符                              if (strStringBuilder.Length < 255)                                  strStringBuilder.Append(keyInfo.KeyChar);                              else                                  continue;                          }                      }                        #endregion                        strReadLine = strStringBuilder.ToString();                      //Logs.WriteLine(true' LogMessageType.MSG_INPUT' strReadLine);                    } while (true);                    if (string.IsNullOrEmpty(strReadLine))                  {                      continue;                  }                    s_Commandlines.Add(strReadLine);                  s_CommandlinesIndex++;                    string cmdStr = strReadLine.TrimStart();                  var first = cmdStr.Split(new[] { ' ' }' StringSplitOptions.RemoveEmptyEntries);                  var op = string.Empty;                  if (first.Length > 0)                      op = first[0].ToLower();                    if (first.Length > 0 && s_cmdProcList.ContainsKey(op))                  {                      try                      {                          if (!s_cmdProcList[op](cmdStr))                              Logs.Error(string.Format("run gm command fail. {0}"' op));                      }                      catch (Exception ex)                      {                          Logs.Error(string.Format("run gm exception. command={0}"' op)' ex);                      }                  }                  else                  {                      if (strReadLine != string.Empty)                          Logs.Warn("命令({0}) : 未知的无效命令"' cmdStr);                  }                }
Magic Number,DogSE.Server.Core,GameServerService,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\GameServerService.cs,StartCommandlinesDisposal,The following statement contains a magic number: while (RunType == ServerStateType.Runing)              {                  ConsoleKeyInfo keyInfo = new ConsoleKeyInfo();                  StringBuilder strStringBuilder = new StringBuilder();                  string strReadLine = string.Empty;                    do                  {                      #region 等待键盘的输入                        try                      {                          while (true)                          {                              //  这里通过100ms间隔的方式检测是否有键盘输入事件                              //  如果是，则进行下面的逻辑处理，如果没有判断服务器是否要停止                              //  如果需要停止，则不再走下面的流程，这样才能让主线程退出                              //  添加这个的目的是为了让GM命令使服务器退出，而不卡在主线程的键盘输入等待里                              if (Console.KeyAvailable)                              {                                  keyInfo = Console.ReadKey(false);                                  break;                              }                                if (RunType == ServerStateType.Closing)                                  break;                                Thread.Sleep(100);                          }                      }                      catch (Exception ex)                      {                          Logs.Error("Console read key fail."' ex);                          if (RunType == ServerStateType.Closing)                              break;                          continue;                      }                        #endregion                        // 再次检测程序已经运行                      if (RunType == ServerStateType.Closing)                          break;                        // 像是串一个命令行' 如果收到"回车"则退出while                      #region 对输入的按键（回车，空格，退格，方向键【用于快速切换上下命令】）做处理                        // 回车                      if (keyInfo.Key == ConsoleKey.Enter)                      {                          strReadLine = strStringBuilder.ToString();                          strStringBuilder.Clear();                            // 如果输入的键值为空，继续等待输入                          if (string.IsNullOrEmpty(strReadLine))                              continue;                          break;                      }                        // 退格                      if (keyInfo.Key == ConsoleKey.Backspace)                      {                          if (strStringBuilder.Length > 0)                              strStringBuilder.Remove(strStringBuilder.Length - 1' 1);                          else                              continue;                      }                      else if (keyInfo.Key == ConsoleKey.UpArrow)                      {                          s_CommandlinesIndex--;                          int iCommandlinesIndex = s_CommandlinesIndex;                            if (iCommandlinesIndex < 0)                          {                              s_CommandlinesIndex = 0;                              continue;                          }                          else                          {                              strStringBuilder.Clear();                              strStringBuilder.Append(s_Commandlines[iCommandlinesIndex]);                          }                      }                      else if (keyInfo.Key == ConsoleKey.DownArrow)                      {                          s_CommandlinesIndex++;                          int iCommandlinesIndex = s_CommandlinesIndex;                            if (iCommandlinesIndex >= s_Commandlines.Count)                          {                              s_CommandlinesIndex = s_Commandlines.Count - 1;                              continue;                          }                          else                          {                              strStringBuilder.Clear();                              strStringBuilder.Append(s_Commandlines[iCommandlinesIndex]);                          }                      }                      else if (keyInfo.Key == ConsoleKey.Spacebar)                      {                          if (strStringBuilder.Length < 255)                              strStringBuilder.Append(keyInfo.KeyChar);                          else                              continue;                      }                      else                      {                          if (((int)keyInfo.Key >= 65 && (int)keyInfo.Key <= 90) || ((int)keyInfo.Key >= 97 && (int)keyInfo.Key <= 122)                              || ((keyInfo.KeyChar >= '0') && keyInfo.KeyChar <= '9'))                          {                              // 最多 255 个有效的字符                              if (strStringBuilder.Length < 255)                                  strStringBuilder.Append(keyInfo.KeyChar);                              else                                  continue;                          }                      }                        #endregion                        strReadLine = strStringBuilder.ToString();                      //Logs.WriteLine(true' LogMessageType.MSG_INPUT' strReadLine);                    } while (true);                    if (string.IsNullOrEmpty(strReadLine))                  {                      continue;                  }                    s_Commandlines.Add(strReadLine);                  s_CommandlinesIndex++;                    string cmdStr = strReadLine.TrimStart();                  var first = cmdStr.Split(new[] { ' ' }' StringSplitOptions.RemoveEmptyEntries);                  var op = string.Empty;                  if (first.Length > 0)                      op = first[0].ToLower();                    if (first.Length > 0 && s_cmdProcList.ContainsKey(op))                  {                      try                      {                          if (!s_cmdProcList[op](cmdStr))                              Logs.Error(string.Format("run gm command fail. {0}"' op));                      }                      catch (Exception ex)                      {                          Logs.Error(string.Format("run gm exception. command={0}"' op)' ex);                      }                  }                  else                  {                      if (strReadLine != string.Empty)                          Logs.Warn("命令({0}) : 未知的无效命令"' cmdStr);                  }                }
Magic Number,DogSE.Server.Core,GameServerService,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\GameServerService.cs,StopGame,The following statement contains a magic number: while (ThreadQueueEntity.HasActionInAllQueue)              {                  Thread.Sleep(100);              }
Magic Number,DogSE.Server.Core,WorldBase,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\WorldBase.cs,StopServerSocket,The following statement contains a magic number: foreach (var linster in Listeners)              {                  linster.Close();                    int count = 30; //  3秒后直接关闭session                  while (m_netStateManager.Count > 0)                  {                      Thread.Sleep(100);                      count--;                      if (count < 0)                      {                          Logs.Info("等待超时，直接关闭session");                          linster.CloseAllSession();                          break;                      }                  }                    linster.SocketConnect -= OnSocketConnect;                  linster.SocketDisconnect -= OnSocketDisconnect;                  linster.SocketRecv -= OnSocketRecv;              }
Magic Number,DogSE.Server.Core,WorldBase,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\WorldBase.cs,StopServerSocket,The following statement contains a magic number: foreach (var linster in Listeners)              {                  linster.Close();                    int count = 30; //  3秒后直接关闭session                  while (m_netStateManager.Count > 0)                  {                      Thread.Sleep(100);                      count--;                      if (count < 0)                      {                          Logs.Info("等待超时，直接关闭session");                          linster.CloseAllSession();                          break;                      }                  }                    linster.SocketConnect -= OnSocketConnect;                  linster.SocketDisconnect -= OnSocketDisconnect;                  linster.SocketRecv -= OnSocketRecv;              }
Magic Number,DogSE.Server.Core,WorldBase,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\WorldBase.cs,OnSocketRecv,The following statement contains a magic number: while (netState.ReceiveBuffer.Length > 2)   // 大于包头长度才具备解析的需求              {                  var len = netState.ReceiveBuffer.GetPacketLength();                  if (len == 0)                  {                      Logs.Error("get package len is zero.");                      netState.NetSocket.CloseSocket();                      return;                  }                    if (len < 4)                  {                      Logs.Error("get package len is min 4.");                      netState.NetSocket.CloseSocket();                      return;                  }                    if (len > MaxPackageSize)                  {                      Logs.Error("get package len is error. size:{0}"' len);                      netState.NetSocket.CloseSocket();                      return;                  }                    if (len <= netState.ReceiveBuffer.Length)                  {                        DogBuffer readBuffer;                      if (len < 1024*4)                          readBuffer = DogBuffer.GetFromPool4K();                      else                          readBuffer = DogBuffer.GetFromPool32K();                        var get = netState.ReceiveBuffer.Dequeue(readBuffer.Bytes' 0' len);                      if (get == len)                      {                          readBuffer.Length = len;                            var packageReader = PacketReader.AcquireContent(readBuffer);                          var packageId = packageReader.GetPacketID();                          //Debug.Write("msgId = " + packageId.ToString());                            var packetHandler = PacketHandlersManger.GetHandler(packageId);                          if (packetHandler != null)                          {                              //  加入网络消息处理                              if (_useManyTaskThread)                              {                                  switch (packetHandler.TaskType)                                  {                                      case TaskType.Low:                                          lowTask.AppendTask(netState' packetHandler' packageReader);                                          break;                                      case TaskType.Assist:                                          Logs.Debug("assist task.");                                          assistTask.AppendTask(netState' packetHandler' packageReader);                                          break;                                      default:                                          mainTask.AppendTask(netState' packetHandler' packageReader);                                          break;                                  }                              }                              else                              {                                  mainTask.AppendTask(netState' packetHandler' packageReader);                              }                          }                          else                          {                              Logs.Error("unknow packetid. code={0}"' packageId);                              netState.ErrorCount++;                              if (netState.ErrorCount >= 10)                              {                                  //  错误达到极大值，则关闭连接                                  Logs.Error("ip {0} error count max."' netState.GetIP());                                  netState.NetSocket.CloseSocket();                              }                          }                      }                      continue;                  }                  break;              }
Magic Number,DogSE.Server.Core,WorldBase,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\WorldBase.cs,OnSocketRecv,The following statement contains a magic number: while (netState.ReceiveBuffer.Length > 2)   // 大于包头长度才具备解析的需求              {                  var len = netState.ReceiveBuffer.GetPacketLength();                  if (len == 0)                  {                      Logs.Error("get package len is zero.");                      netState.NetSocket.CloseSocket();                      return;                  }                    if (len < 4)                  {                      Logs.Error("get package len is min 4.");                      netState.NetSocket.CloseSocket();                      return;                  }                    if (len > MaxPackageSize)                  {                      Logs.Error("get package len is error. size:{0}"' len);                      netState.NetSocket.CloseSocket();                      return;                  }                    if (len <= netState.ReceiveBuffer.Length)                  {                        DogBuffer readBuffer;                      if (len < 1024*4)                          readBuffer = DogBuffer.GetFromPool4K();                      else                          readBuffer = DogBuffer.GetFromPool32K();                        var get = netState.ReceiveBuffer.Dequeue(readBuffer.Bytes' 0' len);                      if (get == len)                      {                          readBuffer.Length = len;                            var packageReader = PacketReader.AcquireContent(readBuffer);                          var packageId = packageReader.GetPacketID();                          //Debug.Write("msgId = " + packageId.ToString());                            var packetHandler = PacketHandlersManger.GetHandler(packageId);                          if (packetHandler != null)                          {                              //  加入网络消息处理                              if (_useManyTaskThread)                              {                                  switch (packetHandler.TaskType)                                  {                                      case TaskType.Low:                                          lowTask.AppendTask(netState' packetHandler' packageReader);                                          break;                                      case TaskType.Assist:                                          Logs.Debug("assist task.");                                          assistTask.AppendTask(netState' packetHandler' packageReader);                                          break;                                      default:                                          mainTask.AppendTask(netState' packetHandler' packageReader);                                          break;                                  }                              }                              else                              {                                  mainTask.AppendTask(netState' packetHandler' packageReader);                              }                          }                          else                          {                              Logs.Error("unknow packetid. code={0}"' packageId);                              netState.ErrorCount++;                              if (netState.ErrorCount >= 10)                              {                                  //  错误达到极大值，则关闭连接                                  Logs.Error("ip {0} error count max."' netState.GetIP());                                  netState.NetSocket.CloseSocket();                              }                          }                      }                      continue;                  }                  break;              }
Magic Number,DogSE.Server.Core,WorldBase,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\WorldBase.cs,OnSocketRecv,The following statement contains a magic number: while (netState.ReceiveBuffer.Length > 2)   // 大于包头长度才具备解析的需求              {                  var len = netState.ReceiveBuffer.GetPacketLength();                  if (len == 0)                  {                      Logs.Error("get package len is zero.");                      netState.NetSocket.CloseSocket();                      return;                  }                    if (len < 4)                  {                      Logs.Error("get package len is min 4.");                      netState.NetSocket.CloseSocket();                      return;                  }                    if (len > MaxPackageSize)                  {                      Logs.Error("get package len is error. size:{0}"' len);                      netState.NetSocket.CloseSocket();                      return;                  }                    if (len <= netState.ReceiveBuffer.Length)                  {                        DogBuffer readBuffer;                      if (len < 1024*4)                          readBuffer = DogBuffer.GetFromPool4K();                      else                          readBuffer = DogBuffer.GetFromPool32K();                        var get = netState.ReceiveBuffer.Dequeue(readBuffer.Bytes' 0' len);                      if (get == len)                      {                          readBuffer.Length = len;                            var packageReader = PacketReader.AcquireContent(readBuffer);                          var packageId = packageReader.GetPacketID();                          //Debug.Write("msgId = " + packageId.ToString());                            var packetHandler = PacketHandlersManger.GetHandler(packageId);                          if (packetHandler != null)                          {                              //  加入网络消息处理                              if (_useManyTaskThread)                              {                                  switch (packetHandler.TaskType)                                  {                                      case TaskType.Low:                                          lowTask.AppendTask(netState' packetHandler' packageReader);                                          break;                                      case TaskType.Assist:                                          Logs.Debug("assist task.");                                          assistTask.AppendTask(netState' packetHandler' packageReader);                                          break;                                      default:                                          mainTask.AppendTask(netState' packetHandler' packageReader);                                          break;                                  }                              }                              else                              {                                  mainTask.AppendTask(netState' packetHandler' packageReader);                              }                          }                          else                          {                              Logs.Error("unknow packetid. code={0}"' packageId);                              netState.ErrorCount++;                              if (netState.ErrorCount >= 10)                              {                                  //  错误达到极大值，则关闭连接                                  Logs.Error("ip {0} error count max."' netState.GetIP());                                  netState.NetSocket.CloseSocket();                              }                          }                      }                      continue;                  }                  break;              }
Magic Number,DogSE.Server.Core,WorldBase,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\WorldBase.cs,OnSocketRecv,The following statement contains a magic number: while (netState.ReceiveBuffer.Length > 2)   // 大于包头长度才具备解析的需求              {                  var len = netState.ReceiveBuffer.GetPacketLength();                  if (len == 0)                  {                      Logs.Error("get package len is zero.");                      netState.NetSocket.CloseSocket();                      return;                  }                    if (len < 4)                  {                      Logs.Error("get package len is min 4.");                      netState.NetSocket.CloseSocket();                      return;                  }                    if (len > MaxPackageSize)                  {                      Logs.Error("get package len is error. size:{0}"' len);                      netState.NetSocket.CloseSocket();                      return;                  }                    if (len <= netState.ReceiveBuffer.Length)                  {                        DogBuffer readBuffer;                      if (len < 1024*4)                          readBuffer = DogBuffer.GetFromPool4K();                      else                          readBuffer = DogBuffer.GetFromPool32K();                        var get = netState.ReceiveBuffer.Dequeue(readBuffer.Bytes' 0' len);                      if (get == len)                      {                          readBuffer.Length = len;                            var packageReader = PacketReader.AcquireContent(readBuffer);                          var packageId = packageReader.GetPacketID();                          //Debug.Write("msgId = " + packageId.ToString());                            var packetHandler = PacketHandlersManger.GetHandler(packageId);                          if (packetHandler != null)                          {                              //  加入网络消息处理                              if (_useManyTaskThread)                              {                                  switch (packetHandler.TaskType)                                  {                                      case TaskType.Low:                                          lowTask.AppendTask(netState' packetHandler' packageReader);                                          break;                                      case TaskType.Assist:                                          Logs.Debug("assist task.");                                          assistTask.AppendTask(netState' packetHandler' packageReader);                                          break;                                      default:                                          mainTask.AppendTask(netState' packetHandler' packageReader);                                          break;                                  }                              }                              else                              {                                  mainTask.AppendTask(netState' packetHandler' packageReader);                              }                          }                          else                          {                              Logs.Error("unknow packetid. code={0}"' packageId);                              netState.ErrorCount++;                              if (netState.ErrorCount >= 10)                              {                                  //  错误达到极大值，则关闭连接                                  Logs.Error("ip {0} error count max."' netState.GetIP());                                  netState.NetSocket.CloseSocket();                              }                          }                      }                      continue;                  }                  break;              }
Magic Number,DogSE.Server.Core,WorldBase,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\WorldBase.cs,OnSocketRecv,The following statement contains a magic number: while (netState.ReceiveBuffer.Length > 2)   // 大于包头长度才具备解析的需求              {                  var len = netState.ReceiveBuffer.GetPacketLength();                  if (len == 0)                  {                      Logs.Error("get package len is zero.");                      netState.NetSocket.CloseSocket();                      return;                  }                    if (len < 4)                  {                      Logs.Error("get package len is min 4.");                      netState.NetSocket.CloseSocket();                      return;                  }                    if (len > MaxPackageSize)                  {                      Logs.Error("get package len is error. size:{0}"' len);                      netState.NetSocket.CloseSocket();                      return;                  }                    if (len <= netState.ReceiveBuffer.Length)                  {                        DogBuffer readBuffer;                      if (len < 1024*4)                          readBuffer = DogBuffer.GetFromPool4K();                      else                          readBuffer = DogBuffer.GetFromPool32K();                        var get = netState.ReceiveBuffer.Dequeue(readBuffer.Bytes' 0' len);                      if (get == len)                      {                          readBuffer.Length = len;                            var packageReader = PacketReader.AcquireContent(readBuffer);                          var packageId = packageReader.GetPacketID();                          //Debug.Write("msgId = " + packageId.ToString());                            var packetHandler = PacketHandlersManger.GetHandler(packageId);                          if (packetHandler != null)                          {                              //  加入网络消息处理                              if (_useManyTaskThread)                              {                                  switch (packetHandler.TaskType)                                  {                                      case TaskType.Low:                                          lowTask.AppendTask(netState' packetHandler' packageReader);                                          break;                                      case TaskType.Assist:                                          Logs.Debug("assist task.");                                          assistTask.AppendTask(netState' packetHandler' packageReader);                                          break;                                      default:                                          mainTask.AppendTask(netState' packetHandler' packageReader);                                          break;                                  }                              }                              else                              {                                  mainTask.AppendTask(netState' packetHandler' packageReader);                              }                          }                          else                          {                              Logs.Error("unknow packetid. code={0}"' packageId);                              netState.ErrorCount++;                              if (netState.ErrorCount >= 10)                              {                                  //  错误达到极大值，则关闭连接                                  Logs.Error("ip {0} error count max."' netState.GetIP());                                  netState.NetSocket.CloseSocket();                              }                          }                      }                      continue;                  }                  break;              }
Magic Number,DogSE.Server.Core.Net,PacketReader,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\Net\PacketReader.cs,SetBuffer,The following statement contains a magic number: m_Index = ReceiveQueue.PacketLengthSize + 2;
Magic Number,DogSE.Server.Core.Net,PacketReader,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\Net\PacketReader.cs,ReadLong64,The following statement contains a magic number: if ( ( m_Index + 8 ) > m_Size )                  return 0;
Magic Number,DogSE.Server.Core.Net,PacketReader,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\Net\PacketReader.cs,ReadLong64,The following statement contains a magic number: if ( m_Endian == Endian.LITTLE_ENDIAN )                  return ( (long)m_Data[m_Index++] << 56 ) | ( (long)m_Data[m_Index++] << 48 ) | ( (long)m_Data[m_Index++] << 40 ) | ( (long)m_Data[m_Index++] << 32 ) | ( (uint)( m_Data[m_Index++] << 24 ) ) | ( (uint)m_Data[m_Index++] << 16 ) | ( (uint)m_Data[m_Index++] << 8 ) | m_Data[m_Index++];              else                  return m_Data[m_Index++] | ((long)m_Data[m_Index++] << 8) | ((long)m_Data[m_Index++] << 16) | ((long)m_Data[m_Index++] << 24) | ((long)m_Data[m_Index++] << 32) | ((long)m_Data[m_Index++] << 40) | ((long)m_Data[m_Index++] << 48) | ((long)m_Data[m_Index++] << 56);
Magic Number,DogSE.Server.Core.Net,PacketReader,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\Net\PacketReader.cs,ReadLong64,The following statement contains a magic number: if ( m_Endian == Endian.LITTLE_ENDIAN )                  return ( (long)m_Data[m_Index++] << 56 ) | ( (long)m_Data[m_Index++] << 48 ) | ( (long)m_Data[m_Index++] << 40 ) | ( (long)m_Data[m_Index++] << 32 ) | ( (uint)( m_Data[m_Index++] << 24 ) ) | ( (uint)m_Data[m_Index++] << 16 ) | ( (uint)m_Data[m_Index++] << 8 ) | m_Data[m_Index++];              else                  return m_Data[m_Index++] | ((long)m_Data[m_Index++] << 8) | ((long)m_Data[m_Index++] << 16) | ((long)m_Data[m_Index++] << 24) | ((long)m_Data[m_Index++] << 32) | ((long)m_Data[m_Index++] << 40) | ((long)m_Data[m_Index++] << 48) | ((long)m_Data[m_Index++] << 56);
Magic Number,DogSE.Server.Core.Net,PacketReader,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\Net\PacketReader.cs,ReadLong64,The following statement contains a magic number: if ( m_Endian == Endian.LITTLE_ENDIAN )                  return ( (long)m_Data[m_Index++] << 56 ) | ( (long)m_Data[m_Index++] << 48 ) | ( (long)m_Data[m_Index++] << 40 ) | ( (long)m_Data[m_Index++] << 32 ) | ( (uint)( m_Data[m_Index++] << 24 ) ) | ( (uint)m_Data[m_Index++] << 16 ) | ( (uint)m_Data[m_Index++] << 8 ) | m_Data[m_Index++];              else                  return m_Data[m_Index++] | ((long)m_Data[m_Index++] << 8) | ((long)m_Data[m_Index++] << 16) | ((long)m_Data[m_Index++] << 24) | ((long)m_Data[m_Index++] << 32) | ((long)m_Data[m_Index++] << 40) | ((long)m_Data[m_Index++] << 48) | ((long)m_Data[m_Index++] << 56);
Magic Number,DogSE.Server.Core.Net,PacketReader,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\Net\PacketReader.cs,ReadLong64,The following statement contains a magic number: if ( m_Endian == Endian.LITTLE_ENDIAN )                  return ( (long)m_Data[m_Index++] << 56 ) | ( (long)m_Data[m_Index++] << 48 ) | ( (long)m_Data[m_Index++] << 40 ) | ( (long)m_Data[m_Index++] << 32 ) | ( (uint)( m_Data[m_Index++] << 24 ) ) | ( (uint)m_Data[m_Index++] << 16 ) | ( (uint)m_Data[m_Index++] << 8 ) | m_Data[m_Index++];              else                  return m_Data[m_Index++] | ((long)m_Data[m_Index++] << 8) | ((long)m_Data[m_Index++] << 16) | ((long)m_Data[m_Index++] << 24) | ((long)m_Data[m_Index++] << 32) | ((long)m_Data[m_Index++] << 40) | ((long)m_Data[m_Index++] << 48) | ((long)m_Data[m_Index++] << 56);
Magic Number,DogSE.Server.Core.Net,PacketReader,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\Net\PacketReader.cs,ReadLong64,The following statement contains a magic number: if ( m_Endian == Endian.LITTLE_ENDIAN )                  return ( (long)m_Data[m_Index++] << 56 ) | ( (long)m_Data[m_Index++] << 48 ) | ( (long)m_Data[m_Index++] << 40 ) | ( (long)m_Data[m_Index++] << 32 ) | ( (uint)( m_Data[m_Index++] << 24 ) ) | ( (uint)m_Data[m_Index++] << 16 ) | ( (uint)m_Data[m_Index++] << 8 ) | m_Data[m_Index++];              else                  return m_Data[m_Index++] | ((long)m_Data[m_Index++] << 8) | ((long)m_Data[m_Index++] << 16) | ((long)m_Data[m_Index++] << 24) | ((long)m_Data[m_Index++] << 32) | ((long)m_Data[m_Index++] << 40) | ((long)m_Data[m_Index++] << 48) | ((long)m_Data[m_Index++] << 56);
Magic Number,DogSE.Server.Core.Net,PacketReader,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\Net\PacketReader.cs,ReadLong64,The following statement contains a magic number: if ( m_Endian == Endian.LITTLE_ENDIAN )                  return ( (long)m_Data[m_Index++] << 56 ) | ( (long)m_Data[m_Index++] << 48 ) | ( (long)m_Data[m_Index++] << 40 ) | ( (long)m_Data[m_Index++] << 32 ) | ( (uint)( m_Data[m_Index++] << 24 ) ) | ( (uint)m_Data[m_Index++] << 16 ) | ( (uint)m_Data[m_Index++] << 8 ) | m_Data[m_Index++];              else                  return m_Data[m_Index++] | ((long)m_Data[m_Index++] << 8) | ((long)m_Data[m_Index++] << 16) | ((long)m_Data[m_Index++] << 24) | ((long)m_Data[m_Index++] << 32) | ((long)m_Data[m_Index++] << 40) | ((long)m_Data[m_Index++] << 48) | ((long)m_Data[m_Index++] << 56);
Magic Number,DogSE.Server.Core.Net,PacketReader,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\Net\PacketReader.cs,ReadLong64,The following statement contains a magic number: if ( m_Endian == Endian.LITTLE_ENDIAN )                  return ( (long)m_Data[m_Index++] << 56 ) | ( (long)m_Data[m_Index++] << 48 ) | ( (long)m_Data[m_Index++] << 40 ) | ( (long)m_Data[m_Index++] << 32 ) | ( (uint)( m_Data[m_Index++] << 24 ) ) | ( (uint)m_Data[m_Index++] << 16 ) | ( (uint)m_Data[m_Index++] << 8 ) | m_Data[m_Index++];              else                  return m_Data[m_Index++] | ((long)m_Data[m_Index++] << 8) | ((long)m_Data[m_Index++] << 16) | ((long)m_Data[m_Index++] << 24) | ((long)m_Data[m_Index++] << 32) | ((long)m_Data[m_Index++] << 40) | ((long)m_Data[m_Index++] << 48) | ((long)m_Data[m_Index++] << 56);
Magic Number,DogSE.Server.Core.Net,PacketReader,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\Net\PacketReader.cs,ReadLong64,The following statement contains a magic number: if ( m_Endian == Endian.LITTLE_ENDIAN )                  return ( (long)m_Data[m_Index++] << 56 ) | ( (long)m_Data[m_Index++] << 48 ) | ( (long)m_Data[m_Index++] << 40 ) | ( (long)m_Data[m_Index++] << 32 ) | ( (uint)( m_Data[m_Index++] << 24 ) ) | ( (uint)m_Data[m_Index++] << 16 ) | ( (uint)m_Data[m_Index++] << 8 ) | m_Data[m_Index++];              else                  return m_Data[m_Index++] | ((long)m_Data[m_Index++] << 8) | ((long)m_Data[m_Index++] << 16) | ((long)m_Data[m_Index++] << 24) | ((long)m_Data[m_Index++] << 32) | ((long)m_Data[m_Index++] << 40) | ((long)m_Data[m_Index++] << 48) | ((long)m_Data[m_Index++] << 56);
Magic Number,DogSE.Server.Core.Net,PacketReader,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\Net\PacketReader.cs,ReadLong64,The following statement contains a magic number: if ( m_Endian == Endian.LITTLE_ENDIAN )                  return ( (long)m_Data[m_Index++] << 56 ) | ( (long)m_Data[m_Index++] << 48 ) | ( (long)m_Data[m_Index++] << 40 ) | ( (long)m_Data[m_Index++] << 32 ) | ( (uint)( m_Data[m_Index++] << 24 ) ) | ( (uint)m_Data[m_Index++] << 16 ) | ( (uint)m_Data[m_Index++] << 8 ) | m_Data[m_Index++];              else                  return m_Data[m_Index++] | ((long)m_Data[m_Index++] << 8) | ((long)m_Data[m_Index++] << 16) | ((long)m_Data[m_Index++] << 24) | ((long)m_Data[m_Index++] << 32) | ((long)m_Data[m_Index++] << 40) | ((long)m_Data[m_Index++] << 48) | ((long)m_Data[m_Index++] << 56);
Magic Number,DogSE.Server.Core.Net,PacketReader,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\Net\PacketReader.cs,ReadLong64,The following statement contains a magic number: if ( m_Endian == Endian.LITTLE_ENDIAN )                  return ( (long)m_Data[m_Index++] << 56 ) | ( (long)m_Data[m_Index++] << 48 ) | ( (long)m_Data[m_Index++] << 40 ) | ( (long)m_Data[m_Index++] << 32 ) | ( (uint)( m_Data[m_Index++] << 24 ) ) | ( (uint)m_Data[m_Index++] << 16 ) | ( (uint)m_Data[m_Index++] << 8 ) | m_Data[m_Index++];              else                  return m_Data[m_Index++] | ((long)m_Data[m_Index++] << 8) | ((long)m_Data[m_Index++] << 16) | ((long)m_Data[m_Index++] << 24) | ((long)m_Data[m_Index++] << 32) | ((long)m_Data[m_Index++] << 40) | ((long)m_Data[m_Index++] << 48) | ((long)m_Data[m_Index++] << 56);
Magic Number,DogSE.Server.Core.Net,PacketReader,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\Net\PacketReader.cs,ReadLong64,The following statement contains a magic number: if ( m_Endian == Endian.LITTLE_ENDIAN )                  return ( (long)m_Data[m_Index++] << 56 ) | ( (long)m_Data[m_Index++] << 48 ) | ( (long)m_Data[m_Index++] << 40 ) | ( (long)m_Data[m_Index++] << 32 ) | ( (uint)( m_Data[m_Index++] << 24 ) ) | ( (uint)m_Data[m_Index++] << 16 ) | ( (uint)m_Data[m_Index++] << 8 ) | m_Data[m_Index++];              else                  return m_Data[m_Index++] | ((long)m_Data[m_Index++] << 8) | ((long)m_Data[m_Index++] << 16) | ((long)m_Data[m_Index++] << 24) | ((long)m_Data[m_Index++] << 32) | ((long)m_Data[m_Index++] << 40) | ((long)m_Data[m_Index++] << 48) | ((long)m_Data[m_Index++] << 56);
Magic Number,DogSE.Server.Core.Net,PacketReader,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\Net\PacketReader.cs,ReadLong64,The following statement contains a magic number: if ( m_Endian == Endian.LITTLE_ENDIAN )                  return ( (long)m_Data[m_Index++] << 56 ) | ( (long)m_Data[m_Index++] << 48 ) | ( (long)m_Data[m_Index++] << 40 ) | ( (long)m_Data[m_Index++] << 32 ) | ( (uint)( m_Data[m_Index++] << 24 ) ) | ( (uint)m_Data[m_Index++] << 16 ) | ( (uint)m_Data[m_Index++] << 8 ) | m_Data[m_Index++];              else                  return m_Data[m_Index++] | ((long)m_Data[m_Index++] << 8) | ((long)m_Data[m_Index++] << 16) | ((long)m_Data[m_Index++] << 24) | ((long)m_Data[m_Index++] << 32) | ((long)m_Data[m_Index++] << 40) | ((long)m_Data[m_Index++] << 48) | ((long)m_Data[m_Index++] << 56);
Magic Number,DogSE.Server.Core.Net,PacketReader,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\Net\PacketReader.cs,ReadLong64,The following statement contains a magic number: if ( m_Endian == Endian.LITTLE_ENDIAN )                  return ( (long)m_Data[m_Index++] << 56 ) | ( (long)m_Data[m_Index++] << 48 ) | ( (long)m_Data[m_Index++] << 40 ) | ( (long)m_Data[m_Index++] << 32 ) | ( (uint)( m_Data[m_Index++] << 24 ) ) | ( (uint)m_Data[m_Index++] << 16 ) | ( (uint)m_Data[m_Index++] << 8 ) | m_Data[m_Index++];              else                  return m_Data[m_Index++] | ((long)m_Data[m_Index++] << 8) | ((long)m_Data[m_Index++] << 16) | ((long)m_Data[m_Index++] << 24) | ((long)m_Data[m_Index++] << 32) | ((long)m_Data[m_Index++] << 40) | ((long)m_Data[m_Index++] << 48) | ((long)m_Data[m_Index++] << 56);
Magic Number,DogSE.Server.Core.Net,PacketReader,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\Net\PacketReader.cs,ReadLong64,The following statement contains a magic number: if ( m_Endian == Endian.LITTLE_ENDIAN )                  return ( (long)m_Data[m_Index++] << 56 ) | ( (long)m_Data[m_Index++] << 48 ) | ( (long)m_Data[m_Index++] << 40 ) | ( (long)m_Data[m_Index++] << 32 ) | ( (uint)( m_Data[m_Index++] << 24 ) ) | ( (uint)m_Data[m_Index++] << 16 ) | ( (uint)m_Data[m_Index++] << 8 ) | m_Data[m_Index++];              else                  return m_Data[m_Index++] | ((long)m_Data[m_Index++] << 8) | ((long)m_Data[m_Index++] << 16) | ((long)m_Data[m_Index++] << 24) | ((long)m_Data[m_Index++] << 32) | ((long)m_Data[m_Index++] << 40) | ((long)m_Data[m_Index++] << 48) | ((long)m_Data[m_Index++] << 56);
Magic Number,DogSE.Server.Core.Net,PacketReader,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\Net\PacketReader.cs,ReadInt32,The following statement contains a magic number: if ( ( m_Index + 4 ) > m_Size )                  return 0;
Magic Number,DogSE.Server.Core.Net,PacketReader,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\Net\PacketReader.cs,ReadInt32,The following statement contains a magic number: if ( m_Endian == Endian.LITTLE_ENDIAN )                  return ( m_Data[m_Index++] << 24 ) | ( m_Data[m_Index++] << 16 ) | ( m_Data[m_Index++] << 8 ) | m_Data[m_Index++];              else                  return m_Data[m_Index++] | (m_Data[m_Index++] << 8) | (m_Data[m_Index++] << 16) | (m_Data[m_Index++] << 24);
Magic Number,DogSE.Server.Core.Net,PacketReader,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\Net\PacketReader.cs,ReadInt32,The following statement contains a magic number: if ( m_Endian == Endian.LITTLE_ENDIAN )                  return ( m_Data[m_Index++] << 24 ) | ( m_Data[m_Index++] << 16 ) | ( m_Data[m_Index++] << 8 ) | m_Data[m_Index++];              else                  return m_Data[m_Index++] | (m_Data[m_Index++] << 8) | (m_Data[m_Index++] << 16) | (m_Data[m_Index++] << 24);
Magic Number,DogSE.Server.Core.Net,PacketReader,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\Net\PacketReader.cs,ReadInt32,The following statement contains a magic number: if ( m_Endian == Endian.LITTLE_ENDIAN )                  return ( m_Data[m_Index++] << 24 ) | ( m_Data[m_Index++] << 16 ) | ( m_Data[m_Index++] << 8 ) | m_Data[m_Index++];              else                  return m_Data[m_Index++] | (m_Data[m_Index++] << 8) | (m_Data[m_Index++] << 16) | (m_Data[m_Index++] << 24);
Magic Number,DogSE.Server.Core.Net,PacketReader,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\Net\PacketReader.cs,ReadInt32,The following statement contains a magic number: if ( m_Endian == Endian.LITTLE_ENDIAN )                  return ( m_Data[m_Index++] << 24 ) | ( m_Data[m_Index++] << 16 ) | ( m_Data[m_Index++] << 8 ) | m_Data[m_Index++];              else                  return m_Data[m_Index++] | (m_Data[m_Index++] << 8) | (m_Data[m_Index++] << 16) | (m_Data[m_Index++] << 24);
Magic Number,DogSE.Server.Core.Net,PacketReader,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\Net\PacketReader.cs,ReadInt32,The following statement contains a magic number: if ( m_Endian == Endian.LITTLE_ENDIAN )                  return ( m_Data[m_Index++] << 24 ) | ( m_Data[m_Index++] << 16 ) | ( m_Data[m_Index++] << 8 ) | m_Data[m_Index++];              else                  return m_Data[m_Index++] | (m_Data[m_Index++] << 8) | (m_Data[m_Index++] << 16) | (m_Data[m_Index++] << 24);
Magic Number,DogSE.Server.Core.Net,PacketReader,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\Net\PacketReader.cs,ReadInt32,The following statement contains a magic number: if ( m_Endian == Endian.LITTLE_ENDIAN )                  return ( m_Data[m_Index++] << 24 ) | ( m_Data[m_Index++] << 16 ) | ( m_Data[m_Index++] << 8 ) | m_Data[m_Index++];              else                  return m_Data[m_Index++] | (m_Data[m_Index++] << 8) | (m_Data[m_Index++] << 16) | (m_Data[m_Index++] << 24);
Magic Number,DogSE.Server.Core.Net,PacketReader,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\Net\PacketReader.cs,ReadInt16,The following statement contains a magic number: if ( ( m_Index + 2 ) > m_Size )                  return 0;
Magic Number,DogSE.Server.Core.Net,PacketReader,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\Net\PacketReader.cs,ReadInt16,The following statement contains a magic number: if ( m_Endian == Endian.LITTLE_ENDIAN )                   return (short)( m_Data[m_Index++] << 8 | ( m_Data[m_Index++] ) );              else                  return (short)(m_Data[m_Index++] | (m_Data[m_Index++] << 8));
Magic Number,DogSE.Server.Core.Net,PacketReader,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\Net\PacketReader.cs,ReadInt16,The following statement contains a magic number: if ( m_Endian == Endian.LITTLE_ENDIAN )                   return (short)( m_Data[m_Index++] << 8 | ( m_Data[m_Index++] ) );              else                  return (short)(m_Data[m_Index++] | (m_Data[m_Index++] << 8));
Magic Number,DogSE.Server.Core.Net,PacketReader,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\Net\PacketReader.cs,ReadULong64,The following statement contains a magic number: if ( ( m_Index + 8 ) > m_Size )                  return 0;
Magic Number,DogSE.Server.Core.Net,PacketReader,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\Net\PacketReader.cs,ReadULong64,The following statement contains a magic number: if ( m_Endian == Endian.LITTLE_ENDIAN )                  return (ulong)( ( (long)m_Data[m_Index++] << 56 ) | ( (long)m_Data[m_Index++] << 48 ) | ( (long)m_Data[m_Index++] << 40 ) | ( (long)m_Data[m_Index++] << 32 ) | ( (uint)m_Data[m_Index++] << 24 ) | ( (uint)m_Data[m_Index++] << 16 ) | ( (uint)m_Data[m_Index++] << 8 ) | m_Data[m_Index++] );              else                  return (ulong)(m_Data[m_Index++] | ((long)m_Data[m_Index++] << 8) | ((long)m_Data[m_Index++] << 16) | ((long)m_Data[m_Index++] << 24) | ((long)m_Data[m_Index++] << 32) | ((long)m_Data[m_Index++] << 40) | ((long)m_Data[m_Index++] << 48) | ((long)m_Data[m_Index++] << 56));
Magic Number,DogSE.Server.Core.Net,PacketReader,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\Net\PacketReader.cs,ReadULong64,The following statement contains a magic number: if ( m_Endian == Endian.LITTLE_ENDIAN )                  return (ulong)( ( (long)m_Data[m_Index++] << 56 ) | ( (long)m_Data[m_Index++] << 48 ) | ( (long)m_Data[m_Index++] << 40 ) | ( (long)m_Data[m_Index++] << 32 ) | ( (uint)m_Data[m_Index++] << 24 ) | ( (uint)m_Data[m_Index++] << 16 ) | ( (uint)m_Data[m_Index++] << 8 ) | m_Data[m_Index++] );              else                  return (ulong)(m_Data[m_Index++] | ((long)m_Data[m_Index++] << 8) | ((long)m_Data[m_Index++] << 16) | ((long)m_Data[m_Index++] << 24) | ((long)m_Data[m_Index++] << 32) | ((long)m_Data[m_Index++] << 40) | ((long)m_Data[m_Index++] << 48) | ((long)m_Data[m_Index++] << 56));
Magic Number,DogSE.Server.Core.Net,PacketReader,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\Net\PacketReader.cs,ReadULong64,The following statement contains a magic number: if ( m_Endian == Endian.LITTLE_ENDIAN )                  return (ulong)( ( (long)m_Data[m_Index++] << 56 ) | ( (long)m_Data[m_Index++] << 48 ) | ( (long)m_Data[m_Index++] << 40 ) | ( (long)m_Data[m_Index++] << 32 ) | ( (uint)m_Data[m_Index++] << 24 ) | ( (uint)m_Data[m_Index++] << 16 ) | ( (uint)m_Data[m_Index++] << 8 ) | m_Data[m_Index++] );              else                  return (ulong)(m_Data[m_Index++] | ((long)m_Data[m_Index++] << 8) | ((long)m_Data[m_Index++] << 16) | ((long)m_Data[m_Index++] << 24) | ((long)m_Data[m_Index++] << 32) | ((long)m_Data[m_Index++] << 40) | ((long)m_Data[m_Index++] << 48) | ((long)m_Data[m_Index++] << 56));
Magic Number,DogSE.Server.Core.Net,PacketReader,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\Net\PacketReader.cs,ReadULong64,The following statement contains a magic number: if ( m_Endian == Endian.LITTLE_ENDIAN )                  return (ulong)( ( (long)m_Data[m_Index++] << 56 ) | ( (long)m_Data[m_Index++] << 48 ) | ( (long)m_Data[m_Index++] << 40 ) | ( (long)m_Data[m_Index++] << 32 ) | ( (uint)m_Data[m_Index++] << 24 ) | ( (uint)m_Data[m_Index++] << 16 ) | ( (uint)m_Data[m_Index++] << 8 ) | m_Data[m_Index++] );              else                  return (ulong)(m_Data[m_Index++] | ((long)m_Data[m_Index++] << 8) | ((long)m_Data[m_Index++] << 16) | ((long)m_Data[m_Index++] << 24) | ((long)m_Data[m_Index++] << 32) | ((long)m_Data[m_Index++] << 40) | ((long)m_Data[m_Index++] << 48) | ((long)m_Data[m_Index++] << 56));
Magic Number,DogSE.Server.Core.Net,PacketReader,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\Net\PacketReader.cs,ReadULong64,The following statement contains a magic number: if ( m_Endian == Endian.LITTLE_ENDIAN )                  return (ulong)( ( (long)m_Data[m_Index++] << 56 ) | ( (long)m_Data[m_Index++] << 48 ) | ( (long)m_Data[m_Index++] << 40 ) | ( (long)m_Data[m_Index++] << 32 ) | ( (uint)m_Data[m_Index++] << 24 ) | ( (uint)m_Data[m_Index++] << 16 ) | ( (uint)m_Data[m_Index++] << 8 ) | m_Data[m_Index++] );              else                  return (ulong)(m_Data[m_Index++] | ((long)m_Data[m_Index++] << 8) | ((long)m_Data[m_Index++] << 16) | ((long)m_Data[m_Index++] << 24) | ((long)m_Data[m_Index++] << 32) | ((long)m_Data[m_Index++] << 40) | ((long)m_Data[m_Index++] << 48) | ((long)m_Data[m_Index++] << 56));
Magic Number,DogSE.Server.Core.Net,PacketReader,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\Net\PacketReader.cs,ReadULong64,The following statement contains a magic number: if ( m_Endian == Endian.LITTLE_ENDIAN )                  return (ulong)( ( (long)m_Data[m_Index++] << 56 ) | ( (long)m_Data[m_Index++] << 48 ) | ( (long)m_Data[m_Index++] << 40 ) | ( (long)m_Data[m_Index++] << 32 ) | ( (uint)m_Data[m_Index++] << 24 ) | ( (uint)m_Data[m_Index++] << 16 ) | ( (uint)m_Data[m_Index++] << 8 ) | m_Data[m_Index++] );              else                  return (ulong)(m_Data[m_Index++] | ((long)m_Data[m_Index++] << 8) | ((long)m_Data[m_Index++] << 16) | ((long)m_Data[m_Index++] << 24) | ((long)m_Data[m_Index++] << 32) | ((long)m_Data[m_Index++] << 40) | ((long)m_Data[m_Index++] << 48) | ((long)m_Data[m_Index++] << 56));
Magic Number,DogSE.Server.Core.Net,PacketReader,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\Net\PacketReader.cs,ReadULong64,The following statement contains a magic number: if ( m_Endian == Endian.LITTLE_ENDIAN )                  return (ulong)( ( (long)m_Data[m_Index++] << 56 ) | ( (long)m_Data[m_Index++] << 48 ) | ( (long)m_Data[m_Index++] << 40 ) | ( (long)m_Data[m_Index++] << 32 ) | ( (uint)m_Data[m_Index++] << 24 ) | ( (uint)m_Data[m_Index++] << 16 ) | ( (uint)m_Data[m_Index++] << 8 ) | m_Data[m_Index++] );              else                  return (ulong)(m_Data[m_Index++] | ((long)m_Data[m_Index++] << 8) | ((long)m_Data[m_Index++] << 16) | ((long)m_Data[m_Index++] << 24) | ((long)m_Data[m_Index++] << 32) | ((long)m_Data[m_Index++] << 40) | ((long)m_Data[m_Index++] << 48) | ((long)m_Data[m_Index++] << 56));
Magic Number,DogSE.Server.Core.Net,PacketReader,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\Net\PacketReader.cs,ReadULong64,The following statement contains a magic number: if ( m_Endian == Endian.LITTLE_ENDIAN )                  return (ulong)( ( (long)m_Data[m_Index++] << 56 ) | ( (long)m_Data[m_Index++] << 48 ) | ( (long)m_Data[m_Index++] << 40 ) | ( (long)m_Data[m_Index++] << 32 ) | ( (uint)m_Data[m_Index++] << 24 ) | ( (uint)m_Data[m_Index++] << 16 ) | ( (uint)m_Data[m_Index++] << 8 ) | m_Data[m_Index++] );              else                  return (ulong)(m_Data[m_Index++] | ((long)m_Data[m_Index++] << 8) | ((long)m_Data[m_Index++] << 16) | ((long)m_Data[m_Index++] << 24) | ((long)m_Data[m_Index++] << 32) | ((long)m_Data[m_Index++] << 40) | ((long)m_Data[m_Index++] << 48) | ((long)m_Data[m_Index++] << 56));
Magic Number,DogSE.Server.Core.Net,PacketReader,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\Net\PacketReader.cs,ReadULong64,The following statement contains a magic number: if ( m_Endian == Endian.LITTLE_ENDIAN )                  return (ulong)( ( (long)m_Data[m_Index++] << 56 ) | ( (long)m_Data[m_Index++] << 48 ) | ( (long)m_Data[m_Index++] << 40 ) | ( (long)m_Data[m_Index++] << 32 ) | ( (uint)m_Data[m_Index++] << 24 ) | ( (uint)m_Data[m_Index++] << 16 ) | ( (uint)m_Data[m_Index++] << 8 ) | m_Data[m_Index++] );              else                  return (ulong)(m_Data[m_Index++] | ((long)m_Data[m_Index++] << 8) | ((long)m_Data[m_Index++] << 16) | ((long)m_Data[m_Index++] << 24) | ((long)m_Data[m_Index++] << 32) | ((long)m_Data[m_Index++] << 40) | ((long)m_Data[m_Index++] << 48) | ((long)m_Data[m_Index++] << 56));
Magic Number,DogSE.Server.Core.Net,PacketReader,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\Net\PacketReader.cs,ReadULong64,The following statement contains a magic number: if ( m_Endian == Endian.LITTLE_ENDIAN )                  return (ulong)( ( (long)m_Data[m_Index++] << 56 ) | ( (long)m_Data[m_Index++] << 48 ) | ( (long)m_Data[m_Index++] << 40 ) | ( (long)m_Data[m_Index++] << 32 ) | ( (uint)m_Data[m_Index++] << 24 ) | ( (uint)m_Data[m_Index++] << 16 ) | ( (uint)m_Data[m_Index++] << 8 ) | m_Data[m_Index++] );              else                  return (ulong)(m_Data[m_Index++] | ((long)m_Data[m_Index++] << 8) | ((long)m_Data[m_Index++] << 16) | ((long)m_Data[m_Index++] << 24) | ((long)m_Data[m_Index++] << 32) | ((long)m_Data[m_Index++] << 40) | ((long)m_Data[m_Index++] << 48) | ((long)m_Data[m_Index++] << 56));
Magic Number,DogSE.Server.Core.Net,PacketReader,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\Net\PacketReader.cs,ReadULong64,The following statement contains a magic number: if ( m_Endian == Endian.LITTLE_ENDIAN )                  return (ulong)( ( (long)m_Data[m_Index++] << 56 ) | ( (long)m_Data[m_Index++] << 48 ) | ( (long)m_Data[m_Index++] << 40 ) | ( (long)m_Data[m_Index++] << 32 ) | ( (uint)m_Data[m_Index++] << 24 ) | ( (uint)m_Data[m_Index++] << 16 ) | ( (uint)m_Data[m_Index++] << 8 ) | m_Data[m_Index++] );              else                  return (ulong)(m_Data[m_Index++] | ((long)m_Data[m_Index++] << 8) | ((long)m_Data[m_Index++] << 16) | ((long)m_Data[m_Index++] << 24) | ((long)m_Data[m_Index++] << 32) | ((long)m_Data[m_Index++] << 40) | ((long)m_Data[m_Index++] << 48) | ((long)m_Data[m_Index++] << 56));
Magic Number,DogSE.Server.Core.Net,PacketReader,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\Net\PacketReader.cs,ReadULong64,The following statement contains a magic number: if ( m_Endian == Endian.LITTLE_ENDIAN )                  return (ulong)( ( (long)m_Data[m_Index++] << 56 ) | ( (long)m_Data[m_Index++] << 48 ) | ( (long)m_Data[m_Index++] << 40 ) | ( (long)m_Data[m_Index++] << 32 ) | ( (uint)m_Data[m_Index++] << 24 ) | ( (uint)m_Data[m_Index++] << 16 ) | ( (uint)m_Data[m_Index++] << 8 ) | m_Data[m_Index++] );              else                  return (ulong)(m_Data[m_Index++] | ((long)m_Data[m_Index++] << 8) | ((long)m_Data[m_Index++] << 16) | ((long)m_Data[m_Index++] << 24) | ((long)m_Data[m_Index++] << 32) | ((long)m_Data[m_Index++] << 40) | ((long)m_Data[m_Index++] << 48) | ((long)m_Data[m_Index++] << 56));
Magic Number,DogSE.Server.Core.Net,PacketReader,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\Net\PacketReader.cs,ReadULong64,The following statement contains a magic number: if ( m_Endian == Endian.LITTLE_ENDIAN )                  return (ulong)( ( (long)m_Data[m_Index++] << 56 ) | ( (long)m_Data[m_Index++] << 48 ) | ( (long)m_Data[m_Index++] << 40 ) | ( (long)m_Data[m_Index++] << 32 ) | ( (uint)m_Data[m_Index++] << 24 ) | ( (uint)m_Data[m_Index++] << 16 ) | ( (uint)m_Data[m_Index++] << 8 ) | m_Data[m_Index++] );              else                  return (ulong)(m_Data[m_Index++] | ((long)m_Data[m_Index++] << 8) | ((long)m_Data[m_Index++] << 16) | ((long)m_Data[m_Index++] << 24) | ((long)m_Data[m_Index++] << 32) | ((long)m_Data[m_Index++] << 40) | ((long)m_Data[m_Index++] << 48) | ((long)m_Data[m_Index++] << 56));
Magic Number,DogSE.Server.Core.Net,PacketReader,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\Net\PacketReader.cs,ReadULong64,The following statement contains a magic number: if ( m_Endian == Endian.LITTLE_ENDIAN )                  return (ulong)( ( (long)m_Data[m_Index++] << 56 ) | ( (long)m_Data[m_Index++] << 48 ) | ( (long)m_Data[m_Index++] << 40 ) | ( (long)m_Data[m_Index++] << 32 ) | ( (uint)m_Data[m_Index++] << 24 ) | ( (uint)m_Data[m_Index++] << 16 ) | ( (uint)m_Data[m_Index++] << 8 ) | m_Data[m_Index++] );              else                  return (ulong)(m_Data[m_Index++] | ((long)m_Data[m_Index++] << 8) | ((long)m_Data[m_Index++] << 16) | ((long)m_Data[m_Index++] << 24) | ((long)m_Data[m_Index++] << 32) | ((long)m_Data[m_Index++] << 40) | ((long)m_Data[m_Index++] << 48) | ((long)m_Data[m_Index++] << 56));
Magic Number,DogSE.Server.Core.Net,PacketReader,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\Net\PacketReader.cs,ReadUInt32,The following statement contains a magic number: if ( ( m_Index + 4 ) > m_Size )                  return 0;
Magic Number,DogSE.Server.Core.Net,PacketReader,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\Net\PacketReader.cs,ReadUInt32,The following statement contains a magic number: if ( m_Endian == Endian.LITTLE_ENDIAN )                   return (uint)( ( m_Data[m_Index++] << 24 ) | ( m_Data[m_Index++] << 16 ) | ( m_Data[m_Index++] << 8 ) | m_Data[m_Index++] );              else                  return (uint)(m_Data[m_Index++] | (m_Data[m_Index++] << 8) | (m_Data[m_Index++] << 16) | (m_Data[m_Index++] << 24));
Magic Number,DogSE.Server.Core.Net,PacketReader,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\Net\PacketReader.cs,ReadUInt32,The following statement contains a magic number: if ( m_Endian == Endian.LITTLE_ENDIAN )                   return (uint)( ( m_Data[m_Index++] << 24 ) | ( m_Data[m_Index++] << 16 ) | ( m_Data[m_Index++] << 8 ) | m_Data[m_Index++] );              else                  return (uint)(m_Data[m_Index++] | (m_Data[m_Index++] << 8) | (m_Data[m_Index++] << 16) | (m_Data[m_Index++] << 24));
Magic Number,DogSE.Server.Core.Net,PacketReader,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\Net\PacketReader.cs,ReadUInt32,The following statement contains a magic number: if ( m_Endian == Endian.LITTLE_ENDIAN )                   return (uint)( ( m_Data[m_Index++] << 24 ) | ( m_Data[m_Index++] << 16 ) | ( m_Data[m_Index++] << 8 ) | m_Data[m_Index++] );              else                  return (uint)(m_Data[m_Index++] | (m_Data[m_Index++] << 8) | (m_Data[m_Index++] << 16) | (m_Data[m_Index++] << 24));
Magic Number,DogSE.Server.Core.Net,PacketReader,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\Net\PacketReader.cs,ReadUInt32,The following statement contains a magic number: if ( m_Endian == Endian.LITTLE_ENDIAN )                   return (uint)( ( m_Data[m_Index++] << 24 ) | ( m_Data[m_Index++] << 16 ) | ( m_Data[m_Index++] << 8 ) | m_Data[m_Index++] );              else                  return (uint)(m_Data[m_Index++] | (m_Data[m_Index++] << 8) | (m_Data[m_Index++] << 16) | (m_Data[m_Index++] << 24));
Magic Number,DogSE.Server.Core.Net,PacketReader,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\Net\PacketReader.cs,ReadUInt32,The following statement contains a magic number: if ( m_Endian == Endian.LITTLE_ENDIAN )                   return (uint)( ( m_Data[m_Index++] << 24 ) | ( m_Data[m_Index++] << 16 ) | ( m_Data[m_Index++] << 8 ) | m_Data[m_Index++] );              else                  return (uint)(m_Data[m_Index++] | (m_Data[m_Index++] << 8) | (m_Data[m_Index++] << 16) | (m_Data[m_Index++] << 24));
Magic Number,DogSE.Server.Core.Net,PacketReader,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\Net\PacketReader.cs,ReadUInt32,The following statement contains a magic number: if ( m_Endian == Endian.LITTLE_ENDIAN )                   return (uint)( ( m_Data[m_Index++] << 24 ) | ( m_Data[m_Index++] << 16 ) | ( m_Data[m_Index++] << 8 ) | m_Data[m_Index++] );              else                  return (uint)(m_Data[m_Index++] | (m_Data[m_Index++] << 8) | (m_Data[m_Index++] << 16) | (m_Data[m_Index++] << 24));
Magic Number,DogSE.Server.Core.Net,PacketReader,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\Net\PacketReader.cs,ReadUInt16,The following statement contains a magic number: if ( ( m_Index + 2 ) > m_Size )                  return 0;
Magic Number,DogSE.Server.Core.Net,PacketReader,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\Net\PacketReader.cs,ReadUInt16,The following statement contains a magic number: if ( m_Endian == Endian.LITTLE_ENDIAN )                   return (ushort)( ( m_Data[m_Index++] << 8 ) | m_Data[m_Index++] );              else                  return (ushort)(m_Data[m_Index++] | (m_Data[m_Index++] << 8));
Magic Number,DogSE.Server.Core.Net,PacketReader,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\Net\PacketReader.cs,ReadUInt16,The following statement contains a magic number: if ( m_Endian == Endian.LITTLE_ENDIAN )                   return (ushort)( ( m_Data[m_Index++] << 8 ) | m_Data[m_Index++] );              else                  return (ushort)(m_Data[m_Index++] | (m_Data[m_Index++] << 8));
Magic Number,DogSE.Server.Core.Net,PacketReader,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\Net\PacketReader.cs,ReadUnicodeStringLE,The following statement contains a magic number: while ( ( m_Index + 1 ) < m_Size && ( cChar = ( m_Data[m_Index++] | ( m_Data[m_Index++] << 8 ) ) ) != 0 )                  stringBuilder.Append( (char)cChar );
Magic Number,DogSE.Server.Core.Net,PacketReader,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\Net\PacketReader.cs,ReadUnicodeStringLESafe,The following statement contains a magic number: while ( ( m_Index + 1 ) < m_Size && ( cChar = ( m_Data[m_Index++] | ( m_Data[m_Index++] << 8 ) ) ) != 0 )              {                  if ( IsSafeChar( cChar ) )                      stringBuilder.Append( (char)cChar );              }
Magic Number,DogSE.Server.Core.Net,PacketReader,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\Net\PacketReader.cs,ReadUnicodeString,The following statement contains a magic number: while ( ( m_Index + 1 ) < m_Size && ( cChar = ( ( m_Data[m_Index++] << 8 ) | m_Data[m_Index++] ) ) != 0 )                  stringBuilder.Append( (char)cChar );
Magic Number,DogSE.Server.Core.Net,PacketReader,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\Net\PacketReader.cs,ReadUnicodeStringSafe,The following statement contains a magic number: while ( ( m_Index + 1 ) < m_Size && ( cChar = ( ( m_Data[m_Index++] << 8 ) | m_Data[m_Index++] ) ) != 0 )              {                  if ( IsSafeChar( cChar ) )                      stringBuilder.Append( (char)cChar );              }
Magic Number,DogSE.Server.Core.Net,PacketReader,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\Net\PacketReader.cs,GetPacketID,The following statement contains a magic number: if ((index + 2) > m_Size)                  return 0;
Magic Number,DogSE.Server.Core.Net,PacketReader,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\Net\PacketReader.cs,GetPacketID,The following statement contains a magic number: if (m_Endian == Endian.LITTLE_ENDIAN)                  return (ushort)((m_Data[index++] << 8) | m_Data[index]);              else                  return (ushort)(m_Data[index++] | (m_Data[index] << 8));
Magic Number,DogSE.Server.Core.Net,PacketReader,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\Net\PacketReader.cs,GetPacketID,The following statement contains a magic number: if (m_Endian == Endian.LITTLE_ENDIAN)                  return (ushort)((m_Data[index++] << 8) | m_Data[index]);              else                  return (ushort)(m_Data[index++] | (m_Data[index] << 8));
Magic Number,DogSE.Server.Core.Net,PacketWriter,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\Net\PacketWriter.cs,Write,The following statement contains a magic number: FixBuffer(2);
Magic Number,DogSE.Server.Core.Net,PacketWriter,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\Net\PacketWriter.cs,Write,The following statement contains a magic number: if ( m_Endian == Endian.LITTLE_ENDIAN )              {                  buffer.Bytes[buffer.Length++] = (byte)(shortValue >> 8);                  buffer.Bytes[buffer.Length++] = (byte)shortValue;              }              else              {                  buffer.Bytes[buffer.Length++] = (byte)shortValue;                  buffer.Bytes[buffer.Length++] = (byte)(shortValue >> 8);              }
Magic Number,DogSE.Server.Core.Net,PacketWriter,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\Net\PacketWriter.cs,Write,The following statement contains a magic number: if ( m_Endian == Endian.LITTLE_ENDIAN )              {                  buffer.Bytes[buffer.Length++] = (byte)(shortValue >> 8);                  buffer.Bytes[buffer.Length++] = (byte)shortValue;              }              else              {                  buffer.Bytes[buffer.Length++] = (byte)shortValue;                  buffer.Bytes[buffer.Length++] = (byte)(shortValue >> 8);              }
Magic Number,DogSE.Server.Core.Net,PacketWriter,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\Net\PacketWriter.cs,Write,The following statement contains a magic number: FixBuffer(2);
Magic Number,DogSE.Server.Core.Net,PacketWriter,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\Net\PacketWriter.cs,Write,The following statement contains a magic number: if ( m_Endian == Endian.LITTLE_ENDIAN )              {                  buffer.Bytes[buffer.Length++] = (byte)(ushortValue >> 8);                  buffer.Bytes[buffer.Length++] = (byte)ushortValue;              }              else              {                  buffer.Bytes[buffer.Length++] = (byte)ushortValue;                  buffer.Bytes[buffer.Length++] = (byte)(ushortValue >> 8);              }
Magic Number,DogSE.Server.Core.Net,PacketWriter,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\Net\PacketWriter.cs,Write,The following statement contains a magic number: if ( m_Endian == Endian.LITTLE_ENDIAN )              {                  buffer.Bytes[buffer.Length++] = (byte)(ushortValue >> 8);                  buffer.Bytes[buffer.Length++] = (byte)ushortValue;              }              else              {                  buffer.Bytes[buffer.Length++] = (byte)ushortValue;                  buffer.Bytes[buffer.Length++] = (byte)(ushortValue >> 8);              }
Magic Number,DogSE.Server.Core.Net,PacketWriter,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\Net\PacketWriter.cs,Write,The following statement contains a magic number: FixBuffer(4);
Magic Number,DogSE.Server.Core.Net,PacketWriter,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\Net\PacketWriter.cs,Write,The following statement contains a magic number: if ( m_Endian == Endian.LITTLE_ENDIAN )              {                  buffer.Bytes[buffer.Length++] = (byte)(intValue >> 24);                  buffer.Bytes[buffer.Length++] = (byte)(intValue >> 16);                  buffer.Bytes[buffer.Length++] = (byte)(intValue >> 8);                  buffer.Bytes[buffer.Length++] = (byte)intValue;              }              else              {                  buffer.Bytes[buffer.Length++] = (byte)intValue;                  buffer.Bytes[buffer.Length++] = (byte)(intValue >> 8);                  buffer.Bytes[buffer.Length++] = (byte)(intValue >> 16);                  buffer.Bytes[buffer.Length++] = (byte)(intValue >> 24);              }
Magic Number,DogSE.Server.Core.Net,PacketWriter,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\Net\PacketWriter.cs,Write,The following statement contains a magic number: if ( m_Endian == Endian.LITTLE_ENDIAN )              {                  buffer.Bytes[buffer.Length++] = (byte)(intValue >> 24);                  buffer.Bytes[buffer.Length++] = (byte)(intValue >> 16);                  buffer.Bytes[buffer.Length++] = (byte)(intValue >> 8);                  buffer.Bytes[buffer.Length++] = (byte)intValue;              }              else              {                  buffer.Bytes[buffer.Length++] = (byte)intValue;                  buffer.Bytes[buffer.Length++] = (byte)(intValue >> 8);                  buffer.Bytes[buffer.Length++] = (byte)(intValue >> 16);                  buffer.Bytes[buffer.Length++] = (byte)(intValue >> 24);              }
Magic Number,DogSE.Server.Core.Net,PacketWriter,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\Net\PacketWriter.cs,Write,The following statement contains a magic number: if ( m_Endian == Endian.LITTLE_ENDIAN )              {                  buffer.Bytes[buffer.Length++] = (byte)(intValue >> 24);                  buffer.Bytes[buffer.Length++] = (byte)(intValue >> 16);                  buffer.Bytes[buffer.Length++] = (byte)(intValue >> 8);                  buffer.Bytes[buffer.Length++] = (byte)intValue;              }              else              {                  buffer.Bytes[buffer.Length++] = (byte)intValue;                  buffer.Bytes[buffer.Length++] = (byte)(intValue >> 8);                  buffer.Bytes[buffer.Length++] = (byte)(intValue >> 16);                  buffer.Bytes[buffer.Length++] = (byte)(intValue >> 24);              }
Magic Number,DogSE.Server.Core.Net,PacketWriter,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\Net\PacketWriter.cs,Write,The following statement contains a magic number: if ( m_Endian == Endian.LITTLE_ENDIAN )              {                  buffer.Bytes[buffer.Length++] = (byte)(intValue >> 24);                  buffer.Bytes[buffer.Length++] = (byte)(intValue >> 16);                  buffer.Bytes[buffer.Length++] = (byte)(intValue >> 8);                  buffer.Bytes[buffer.Length++] = (byte)intValue;              }              else              {                  buffer.Bytes[buffer.Length++] = (byte)intValue;                  buffer.Bytes[buffer.Length++] = (byte)(intValue >> 8);                  buffer.Bytes[buffer.Length++] = (byte)(intValue >> 16);                  buffer.Bytes[buffer.Length++] = (byte)(intValue >> 24);              }
Magic Number,DogSE.Server.Core.Net,PacketWriter,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\Net\PacketWriter.cs,Write,The following statement contains a magic number: if ( m_Endian == Endian.LITTLE_ENDIAN )              {                  buffer.Bytes[buffer.Length++] = (byte)(intValue >> 24);                  buffer.Bytes[buffer.Length++] = (byte)(intValue >> 16);                  buffer.Bytes[buffer.Length++] = (byte)(intValue >> 8);                  buffer.Bytes[buffer.Length++] = (byte)intValue;              }              else              {                  buffer.Bytes[buffer.Length++] = (byte)intValue;                  buffer.Bytes[buffer.Length++] = (byte)(intValue >> 8);                  buffer.Bytes[buffer.Length++] = (byte)(intValue >> 16);                  buffer.Bytes[buffer.Length++] = (byte)(intValue >> 24);              }
Magic Number,DogSE.Server.Core.Net,PacketWriter,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\Net\PacketWriter.cs,Write,The following statement contains a magic number: if ( m_Endian == Endian.LITTLE_ENDIAN )              {                  buffer.Bytes[buffer.Length++] = (byte)(intValue >> 24);                  buffer.Bytes[buffer.Length++] = (byte)(intValue >> 16);                  buffer.Bytes[buffer.Length++] = (byte)(intValue >> 8);                  buffer.Bytes[buffer.Length++] = (byte)intValue;              }              else              {                  buffer.Bytes[buffer.Length++] = (byte)intValue;                  buffer.Bytes[buffer.Length++] = (byte)(intValue >> 8);                  buffer.Bytes[buffer.Length++] = (byte)(intValue >> 16);                  buffer.Bytes[buffer.Length++] = (byte)(intValue >> 24);              }
Magic Number,DogSE.Server.Core.Net,PacketWriter,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\Net\PacketWriter.cs,Write,The following statement contains a magic number: FixBuffer(4);
Magic Number,DogSE.Server.Core.Net,PacketWriter,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\Net\PacketWriter.cs,Write,The following statement contains a magic number: if ( m_Endian == Endian.LITTLE_ENDIAN )              {                  buffer.Bytes[buffer.Length++]  = (byte)( uintValue >> 24 );                  buffer.Bytes[buffer.Length++]  = (byte)( uintValue >> 16 );                  buffer.Bytes[buffer.Length++]  = (byte)( uintValue >> 8 );                  buffer.Bytes[buffer.Length++]  = (byte)uintValue;              }              else              {                  buffer.Bytes[buffer.Length++]  = (byte)uintValue;                  buffer.Bytes[buffer.Length++]  = (byte)( uintValue >> 8 );                  buffer.Bytes[buffer.Length++]  = (byte)( uintValue >> 16 );                  buffer.Bytes[buffer.Length++]  = (byte)( uintValue >> 24 );              }
Magic Number,DogSE.Server.Core.Net,PacketWriter,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\Net\PacketWriter.cs,Write,The following statement contains a magic number: if ( m_Endian == Endian.LITTLE_ENDIAN )              {                  buffer.Bytes[buffer.Length++]  = (byte)( uintValue >> 24 );                  buffer.Bytes[buffer.Length++]  = (byte)( uintValue >> 16 );                  buffer.Bytes[buffer.Length++]  = (byte)( uintValue >> 8 );                  buffer.Bytes[buffer.Length++]  = (byte)uintValue;              }              else              {                  buffer.Bytes[buffer.Length++]  = (byte)uintValue;                  buffer.Bytes[buffer.Length++]  = (byte)( uintValue >> 8 );                  buffer.Bytes[buffer.Length++]  = (byte)( uintValue >> 16 );                  buffer.Bytes[buffer.Length++]  = (byte)( uintValue >> 24 );              }
Magic Number,DogSE.Server.Core.Net,PacketWriter,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\Net\PacketWriter.cs,Write,The following statement contains a magic number: if ( m_Endian == Endian.LITTLE_ENDIAN )              {                  buffer.Bytes[buffer.Length++]  = (byte)( uintValue >> 24 );                  buffer.Bytes[buffer.Length++]  = (byte)( uintValue >> 16 );                  buffer.Bytes[buffer.Length++]  = (byte)( uintValue >> 8 );                  buffer.Bytes[buffer.Length++]  = (byte)uintValue;              }              else              {                  buffer.Bytes[buffer.Length++]  = (byte)uintValue;                  buffer.Bytes[buffer.Length++]  = (byte)( uintValue >> 8 );                  buffer.Bytes[buffer.Length++]  = (byte)( uintValue >> 16 );                  buffer.Bytes[buffer.Length++]  = (byte)( uintValue >> 24 );              }
Magic Number,DogSE.Server.Core.Net,PacketWriter,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\Net\PacketWriter.cs,Write,The following statement contains a magic number: if ( m_Endian == Endian.LITTLE_ENDIAN )              {                  buffer.Bytes[buffer.Length++]  = (byte)( uintValue >> 24 );                  buffer.Bytes[buffer.Length++]  = (byte)( uintValue >> 16 );                  buffer.Bytes[buffer.Length++]  = (byte)( uintValue >> 8 );                  buffer.Bytes[buffer.Length++]  = (byte)uintValue;              }              else              {                  buffer.Bytes[buffer.Length++]  = (byte)uintValue;                  buffer.Bytes[buffer.Length++]  = (byte)( uintValue >> 8 );                  buffer.Bytes[buffer.Length++]  = (byte)( uintValue >> 16 );                  buffer.Bytes[buffer.Length++]  = (byte)( uintValue >> 24 );              }
Magic Number,DogSE.Server.Core.Net,PacketWriter,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\Net\PacketWriter.cs,Write,The following statement contains a magic number: if ( m_Endian == Endian.LITTLE_ENDIAN )              {                  buffer.Bytes[buffer.Length++]  = (byte)( uintValue >> 24 );                  buffer.Bytes[buffer.Length++]  = (byte)( uintValue >> 16 );                  buffer.Bytes[buffer.Length++]  = (byte)( uintValue >> 8 );                  buffer.Bytes[buffer.Length++]  = (byte)uintValue;              }              else              {                  buffer.Bytes[buffer.Length++]  = (byte)uintValue;                  buffer.Bytes[buffer.Length++]  = (byte)( uintValue >> 8 );                  buffer.Bytes[buffer.Length++]  = (byte)( uintValue >> 16 );                  buffer.Bytes[buffer.Length++]  = (byte)( uintValue >> 24 );              }
Magic Number,DogSE.Server.Core.Net,PacketWriter,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\Net\PacketWriter.cs,Write,The following statement contains a magic number: if ( m_Endian == Endian.LITTLE_ENDIAN )              {                  buffer.Bytes[buffer.Length++]  = (byte)( uintValue >> 24 );                  buffer.Bytes[buffer.Length++]  = (byte)( uintValue >> 16 );                  buffer.Bytes[buffer.Length++]  = (byte)( uintValue >> 8 );                  buffer.Bytes[buffer.Length++]  = (byte)uintValue;              }              else              {                  buffer.Bytes[buffer.Length++]  = (byte)uintValue;                  buffer.Bytes[buffer.Length++]  = (byte)( uintValue >> 8 );                  buffer.Bytes[buffer.Length++]  = (byte)( uintValue >> 16 );                  buffer.Bytes[buffer.Length++]  = (byte)( uintValue >> 24 );              }
Magic Number,DogSE.Server.Core.Net,PacketWriter,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\Net\PacketWriter.cs,Write,The following statement contains a magic number: FixBuffer(4);
Magic Number,DogSE.Server.Core.Net,PacketWriter,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\Net\PacketWriter.cs,Write,The following statement contains a magic number: FixBuffer(8);
Magic Number,DogSE.Server.Core.Net,PacketWriter,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\Net\PacketWriter.cs,Write,The following statement contains a magic number: if (m_Endian == Endian.LITTLE_ENDIAN)              {                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 56);                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 48);                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 40);                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 32);                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 24);                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 16);                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 8);                  buffer.Bytes[buffer.Length++] = (byte) longValue;                }              else              {                  buffer.Bytes[buffer.Length++] = (byte) longValue;                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 8);                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 16);                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 24);                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 32);                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 40);                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 48);                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 56);              }
Magic Number,DogSE.Server.Core.Net,PacketWriter,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\Net\PacketWriter.cs,Write,The following statement contains a magic number: if (m_Endian == Endian.LITTLE_ENDIAN)              {                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 56);                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 48);                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 40);                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 32);                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 24);                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 16);                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 8);                  buffer.Bytes[buffer.Length++] = (byte) longValue;                }              else              {                  buffer.Bytes[buffer.Length++] = (byte) longValue;                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 8);                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 16);                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 24);                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 32);                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 40);                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 48);                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 56);              }
Magic Number,DogSE.Server.Core.Net,PacketWriter,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\Net\PacketWriter.cs,Write,The following statement contains a magic number: if (m_Endian == Endian.LITTLE_ENDIAN)              {                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 56);                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 48);                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 40);                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 32);                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 24);                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 16);                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 8);                  buffer.Bytes[buffer.Length++] = (byte) longValue;                }              else              {                  buffer.Bytes[buffer.Length++] = (byte) longValue;                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 8);                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 16);                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 24);                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 32);                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 40);                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 48);                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 56);              }
Magic Number,DogSE.Server.Core.Net,PacketWriter,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\Net\PacketWriter.cs,Write,The following statement contains a magic number: if (m_Endian == Endian.LITTLE_ENDIAN)              {                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 56);                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 48);                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 40);                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 32);                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 24);                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 16);                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 8);                  buffer.Bytes[buffer.Length++] = (byte) longValue;                }              else              {                  buffer.Bytes[buffer.Length++] = (byte) longValue;                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 8);                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 16);                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 24);                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 32);                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 40);                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 48);                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 56);              }
Magic Number,DogSE.Server.Core.Net,PacketWriter,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\Net\PacketWriter.cs,Write,The following statement contains a magic number: if (m_Endian == Endian.LITTLE_ENDIAN)              {                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 56);                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 48);                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 40);                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 32);                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 24);                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 16);                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 8);                  buffer.Bytes[buffer.Length++] = (byte) longValue;                }              else              {                  buffer.Bytes[buffer.Length++] = (byte) longValue;                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 8);                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 16);                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 24);                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 32);                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 40);                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 48);                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 56);              }
Magic Number,DogSE.Server.Core.Net,PacketWriter,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\Net\PacketWriter.cs,Write,The following statement contains a magic number: if (m_Endian == Endian.LITTLE_ENDIAN)              {                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 56);                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 48);                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 40);                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 32);                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 24);                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 16);                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 8);                  buffer.Bytes[buffer.Length++] = (byte) longValue;                }              else              {                  buffer.Bytes[buffer.Length++] = (byte) longValue;                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 8);                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 16);                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 24);                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 32);                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 40);                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 48);                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 56);              }
Magic Number,DogSE.Server.Core.Net,PacketWriter,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\Net\PacketWriter.cs,Write,The following statement contains a magic number: if (m_Endian == Endian.LITTLE_ENDIAN)              {                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 56);                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 48);                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 40);                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 32);                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 24);                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 16);                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 8);                  buffer.Bytes[buffer.Length++] = (byte) longValue;                }              else              {                  buffer.Bytes[buffer.Length++] = (byte) longValue;                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 8);                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 16);                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 24);                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 32);                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 40);                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 48);                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 56);              }
Magic Number,DogSE.Server.Core.Net,PacketWriter,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\Net\PacketWriter.cs,Write,The following statement contains a magic number: if (m_Endian == Endian.LITTLE_ENDIAN)              {                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 56);                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 48);                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 40);                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 32);                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 24);                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 16);                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 8);                  buffer.Bytes[buffer.Length++] = (byte) longValue;                }              else              {                  buffer.Bytes[buffer.Length++] = (byte) longValue;                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 8);                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 16);                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 24);                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 32);                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 40);                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 48);                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 56);              }
Magic Number,DogSE.Server.Core.Net,PacketWriter,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\Net\PacketWriter.cs,Write,The following statement contains a magic number: if (m_Endian == Endian.LITTLE_ENDIAN)              {                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 56);                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 48);                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 40);                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 32);                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 24);                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 16);                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 8);                  buffer.Bytes[buffer.Length++] = (byte) longValue;                }              else              {                  buffer.Bytes[buffer.Length++] = (byte) longValue;                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 8);                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 16);                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 24);                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 32);                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 40);                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 48);                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 56);              }
Magic Number,DogSE.Server.Core.Net,PacketWriter,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\Net\PacketWriter.cs,Write,The following statement contains a magic number: if (m_Endian == Endian.LITTLE_ENDIAN)              {                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 56);                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 48);                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 40);                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 32);                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 24);                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 16);                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 8);                  buffer.Bytes[buffer.Length++] = (byte) longValue;                }              else              {                  buffer.Bytes[buffer.Length++] = (byte) longValue;                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 8);                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 16);                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 24);                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 32);                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 40);                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 48);                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 56);              }
Magic Number,DogSE.Server.Core.Net,PacketWriter,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\Net\PacketWriter.cs,Write,The following statement contains a magic number: if (m_Endian == Endian.LITTLE_ENDIAN)              {                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 56);                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 48);                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 40);                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 32);                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 24);                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 16);                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 8);                  buffer.Bytes[buffer.Length++] = (byte) longValue;                }              else              {                  buffer.Bytes[buffer.Length++] = (byte) longValue;                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 8);                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 16);                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 24);                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 32);                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 40);                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 48);                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 56);              }
Magic Number,DogSE.Server.Core.Net,PacketWriter,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\Net\PacketWriter.cs,Write,The following statement contains a magic number: if (m_Endian == Endian.LITTLE_ENDIAN)              {                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 56);                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 48);                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 40);                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 32);                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 24);                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 16);                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 8);                  buffer.Bytes[buffer.Length++] = (byte) longValue;                }              else              {                  buffer.Bytes[buffer.Length++] = (byte) longValue;                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 8);                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 16);                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 24);                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 32);                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 40);                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 48);                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 56);              }
Magic Number,DogSE.Server.Core.Net,PacketWriter,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\Net\PacketWriter.cs,Write,The following statement contains a magic number: if (m_Endian == Endian.LITTLE_ENDIAN)              {                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 56);                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 48);                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 40);                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 32);                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 24);                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 16);                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 8);                  buffer.Bytes[buffer.Length++] = (byte) longValue;                }              else              {                  buffer.Bytes[buffer.Length++] = (byte) longValue;                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 8);                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 16);                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 24);                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 32);                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 40);                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 48);                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 56);              }
Magic Number,DogSE.Server.Core.Net,PacketWriter,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\Net\PacketWriter.cs,Write,The following statement contains a magic number: if (m_Endian == Endian.LITTLE_ENDIAN)              {                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 56);                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 48);                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 40);                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 32);                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 24);                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 16);                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 8);                  buffer.Bytes[buffer.Length++] = (byte) longValue;                }              else              {                  buffer.Bytes[buffer.Length++] = (byte) longValue;                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 8);                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 16);                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 24);                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 32);                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 40);                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 48);                  buffer.Bytes[buffer.Length++] = (byte) (longValue >> 56);              }
Magic Number,DogSE.Server.Core.Net,PacketWriter,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\Net\PacketWriter.cs,Write,The following statement contains a magic number: FixBuffer(8);
Magic Number,DogSE.Server.Core.Net,PacketWriter,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\Net\PacketWriter.cs,Write,The following statement contains a magic number: if (m_Endian == Endian.LITTLE_ENDIAN)              {                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 56);                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 48);                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 40);                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 32);                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 24);                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 16);                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 8);                  buffer.Bytes[buffer.Length++] = (byte) ulongValue;                }              else              {                  buffer.Bytes[buffer.Length++] = (byte) ulongValue;                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 8);                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 16);                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 24);                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 32);                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 40);                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 48);                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 56);              }
Magic Number,DogSE.Server.Core.Net,PacketWriter,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\Net\PacketWriter.cs,Write,The following statement contains a magic number: if (m_Endian == Endian.LITTLE_ENDIAN)              {                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 56);                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 48);                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 40);                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 32);                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 24);                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 16);                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 8);                  buffer.Bytes[buffer.Length++] = (byte) ulongValue;                }              else              {                  buffer.Bytes[buffer.Length++] = (byte) ulongValue;                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 8);                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 16);                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 24);                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 32);                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 40);                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 48);                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 56);              }
Magic Number,DogSE.Server.Core.Net,PacketWriter,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\Net\PacketWriter.cs,Write,The following statement contains a magic number: if (m_Endian == Endian.LITTLE_ENDIAN)              {                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 56);                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 48);                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 40);                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 32);                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 24);                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 16);                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 8);                  buffer.Bytes[buffer.Length++] = (byte) ulongValue;                }              else              {                  buffer.Bytes[buffer.Length++] = (byte) ulongValue;                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 8);                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 16);                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 24);                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 32);                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 40);                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 48);                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 56);              }
Magic Number,DogSE.Server.Core.Net,PacketWriter,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\Net\PacketWriter.cs,Write,The following statement contains a magic number: if (m_Endian == Endian.LITTLE_ENDIAN)              {                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 56);                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 48);                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 40);                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 32);                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 24);                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 16);                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 8);                  buffer.Bytes[buffer.Length++] = (byte) ulongValue;                }              else              {                  buffer.Bytes[buffer.Length++] = (byte) ulongValue;                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 8);                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 16);                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 24);                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 32);                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 40);                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 48);                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 56);              }
Magic Number,DogSE.Server.Core.Net,PacketWriter,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\Net\PacketWriter.cs,Write,The following statement contains a magic number: if (m_Endian == Endian.LITTLE_ENDIAN)              {                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 56);                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 48);                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 40);                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 32);                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 24);                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 16);                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 8);                  buffer.Bytes[buffer.Length++] = (byte) ulongValue;                }              else              {                  buffer.Bytes[buffer.Length++] = (byte) ulongValue;                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 8);                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 16);                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 24);                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 32);                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 40);                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 48);                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 56);              }
Magic Number,DogSE.Server.Core.Net,PacketWriter,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\Net\PacketWriter.cs,Write,The following statement contains a magic number: if (m_Endian == Endian.LITTLE_ENDIAN)              {                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 56);                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 48);                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 40);                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 32);                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 24);                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 16);                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 8);                  buffer.Bytes[buffer.Length++] = (byte) ulongValue;                }              else              {                  buffer.Bytes[buffer.Length++] = (byte) ulongValue;                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 8);                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 16);                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 24);                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 32);                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 40);                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 48);                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 56);              }
Magic Number,DogSE.Server.Core.Net,PacketWriter,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\Net\PacketWriter.cs,Write,The following statement contains a magic number: if (m_Endian == Endian.LITTLE_ENDIAN)              {                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 56);                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 48);                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 40);                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 32);                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 24);                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 16);                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 8);                  buffer.Bytes[buffer.Length++] = (byte) ulongValue;                }              else              {                  buffer.Bytes[buffer.Length++] = (byte) ulongValue;                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 8);                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 16);                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 24);                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 32);                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 40);                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 48);                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 56);              }
Magic Number,DogSE.Server.Core.Net,PacketWriter,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\Net\PacketWriter.cs,Write,The following statement contains a magic number: if (m_Endian == Endian.LITTLE_ENDIAN)              {                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 56);                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 48);                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 40);                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 32);                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 24);                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 16);                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 8);                  buffer.Bytes[buffer.Length++] = (byte) ulongValue;                }              else              {                  buffer.Bytes[buffer.Length++] = (byte) ulongValue;                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 8);                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 16);                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 24);                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 32);                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 40);                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 48);                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 56);              }
Magic Number,DogSE.Server.Core.Net,PacketWriter,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\Net\PacketWriter.cs,Write,The following statement contains a magic number: if (m_Endian == Endian.LITTLE_ENDIAN)              {                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 56);                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 48);                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 40);                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 32);                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 24);                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 16);                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 8);                  buffer.Bytes[buffer.Length++] = (byte) ulongValue;                }              else              {                  buffer.Bytes[buffer.Length++] = (byte) ulongValue;                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 8);                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 16);                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 24);                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 32);                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 40);                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 48);                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 56);              }
Magic Number,DogSE.Server.Core.Net,PacketWriter,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\Net\PacketWriter.cs,Write,The following statement contains a magic number: if (m_Endian == Endian.LITTLE_ENDIAN)              {                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 56);                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 48);                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 40);                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 32);                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 24);                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 16);                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 8);                  buffer.Bytes[buffer.Length++] = (byte) ulongValue;                }              else              {                  buffer.Bytes[buffer.Length++] = (byte) ulongValue;                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 8);                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 16);                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 24);                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 32);                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 40);                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 48);                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 56);              }
Magic Number,DogSE.Server.Core.Net,PacketWriter,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\Net\PacketWriter.cs,Write,The following statement contains a magic number: if (m_Endian == Endian.LITTLE_ENDIAN)              {                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 56);                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 48);                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 40);                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 32);                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 24);                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 16);                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 8);                  buffer.Bytes[buffer.Length++] = (byte) ulongValue;                }              else              {                  buffer.Bytes[buffer.Length++] = (byte) ulongValue;                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 8);                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 16);                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 24);                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 32);                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 40);                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 48);                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 56);              }
Magic Number,DogSE.Server.Core.Net,PacketWriter,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\Net\PacketWriter.cs,Write,The following statement contains a magic number: if (m_Endian == Endian.LITTLE_ENDIAN)              {                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 56);                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 48);                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 40);                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 32);                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 24);                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 16);                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 8);                  buffer.Bytes[buffer.Length++] = (byte) ulongValue;                }              else              {                  buffer.Bytes[buffer.Length++] = (byte) ulongValue;                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 8);                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 16);                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 24);                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 32);                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 40);                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 48);                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 56);              }
Magic Number,DogSE.Server.Core.Net,PacketWriter,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\Net\PacketWriter.cs,Write,The following statement contains a magic number: if (m_Endian == Endian.LITTLE_ENDIAN)              {                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 56);                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 48);                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 40);                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 32);                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 24);                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 16);                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 8);                  buffer.Bytes[buffer.Length++] = (byte) ulongValue;                }              else              {                  buffer.Bytes[buffer.Length++] = (byte) ulongValue;                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 8);                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 16);                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 24);                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 32);                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 40);                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 48);                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 56);              }
Magic Number,DogSE.Server.Core.Net,PacketWriter,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\Net\PacketWriter.cs,Write,The following statement contains a magic number: if (m_Endian == Endian.LITTLE_ENDIAN)              {                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 56);                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 48);                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 40);                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 32);                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 24);                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 16);                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 8);                  buffer.Bytes[buffer.Length++] = (byte) ulongValue;                }              else              {                  buffer.Bytes[buffer.Length++] = (byte) ulongValue;                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 8);                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 16);                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 24);                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 32);                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 40);                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 48);                  buffer.Bytes[buffer.Length++] = (byte) (ulongValue >> 56);              }
Magic Number,DogSE.Server.Core.Net,PacketWriter,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\Net\PacketWriter.cs,Write,The following statement contains a magic number: FixBuffer(8);
Magic Number,DogSE.Server.Core.Net,PacketWriter,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\Net\PacketWriter.cs,GetBuffer,The following statement contains a magic number: if (m_Endian == Endian.LITTLE_ENDIAN)              {                  buffer.Bytes[0] = (byte)(intValue >> 24);                  buffer.Bytes[1] = (byte)(intValue >> 16);                  buffer.Bytes[2] = (byte)(intValue >> 8);                  buffer.Bytes[3] = (byte)intValue;                }              else              {                  buffer.Bytes[0] = (byte)intValue;                  buffer.Bytes[1] = (byte)(intValue >> 8);                  buffer.Bytes[2] = (byte)(intValue >> 16);                  buffer.Bytes[3] = (byte)(intValue >> 24);              }
Magic Number,DogSE.Server.Core.Net,PacketWriter,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\Net\PacketWriter.cs,GetBuffer,The following statement contains a magic number: if (m_Endian == Endian.LITTLE_ENDIAN)              {                  buffer.Bytes[0] = (byte)(intValue >> 24);                  buffer.Bytes[1] = (byte)(intValue >> 16);                  buffer.Bytes[2] = (byte)(intValue >> 8);                  buffer.Bytes[3] = (byte)intValue;                }              else              {                  buffer.Bytes[0] = (byte)intValue;                  buffer.Bytes[1] = (byte)(intValue >> 8);                  buffer.Bytes[2] = (byte)(intValue >> 16);                  buffer.Bytes[3] = (byte)(intValue >> 24);              }
Magic Number,DogSE.Server.Core.Net,PacketWriter,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\Net\PacketWriter.cs,GetBuffer,The following statement contains a magic number: if (m_Endian == Endian.LITTLE_ENDIAN)              {                  buffer.Bytes[0] = (byte)(intValue >> 24);                  buffer.Bytes[1] = (byte)(intValue >> 16);                  buffer.Bytes[2] = (byte)(intValue >> 8);                  buffer.Bytes[3] = (byte)intValue;                }              else              {                  buffer.Bytes[0] = (byte)intValue;                  buffer.Bytes[1] = (byte)(intValue >> 8);                  buffer.Bytes[2] = (byte)(intValue >> 16);                  buffer.Bytes[3] = (byte)(intValue >> 24);              }
Magic Number,DogSE.Server.Core.Net,PacketWriter,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\Net\PacketWriter.cs,GetBuffer,The following statement contains a magic number: if (m_Endian == Endian.LITTLE_ENDIAN)              {                  buffer.Bytes[0] = (byte)(intValue >> 24);                  buffer.Bytes[1] = (byte)(intValue >> 16);                  buffer.Bytes[2] = (byte)(intValue >> 8);                  buffer.Bytes[3] = (byte)intValue;                }              else              {                  buffer.Bytes[0] = (byte)intValue;                  buffer.Bytes[1] = (byte)(intValue >> 8);                  buffer.Bytes[2] = (byte)(intValue >> 16);                  buffer.Bytes[3] = (byte)(intValue >> 24);              }
Magic Number,DogSE.Server.Core.Net,PacketWriter,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\Net\PacketWriter.cs,GetBuffer,The following statement contains a magic number: if (m_Endian == Endian.LITTLE_ENDIAN)              {                  buffer.Bytes[0] = (byte)(intValue >> 24);                  buffer.Bytes[1] = (byte)(intValue >> 16);                  buffer.Bytes[2] = (byte)(intValue >> 8);                  buffer.Bytes[3] = (byte)intValue;                }              else              {                  buffer.Bytes[0] = (byte)intValue;                  buffer.Bytes[1] = (byte)(intValue >> 8);                  buffer.Bytes[2] = (byte)(intValue >> 16);                  buffer.Bytes[3] = (byte)(intValue >> 24);              }
Magic Number,DogSE.Server.Core.Net,PacketWriter,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\Net\PacketWriter.cs,GetBuffer,The following statement contains a magic number: if (m_Endian == Endian.LITTLE_ENDIAN)              {                  buffer.Bytes[0] = (byte)(intValue >> 24);                  buffer.Bytes[1] = (byte)(intValue >> 16);                  buffer.Bytes[2] = (byte)(intValue >> 8);                  buffer.Bytes[3] = (byte)intValue;                }              else              {                  buffer.Bytes[0] = (byte)intValue;                  buffer.Bytes[1] = (byte)(intValue >> 8);                  buffer.Bytes[2] = (byte)(intValue >> 16);                  buffer.Bytes[3] = (byte)(intValue >> 24);              }
Magic Number,DogSE.Server.Core.Net,PacketWriter,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\Net\PacketWriter.cs,GetBuffer,The following statement contains a magic number: if (m_Endian == Endian.LITTLE_ENDIAN)              {                  buffer.Bytes[0] = (byte)(intValue >> 24);                  buffer.Bytes[1] = (byte)(intValue >> 16);                  buffer.Bytes[2] = (byte)(intValue >> 8);                  buffer.Bytes[3] = (byte)intValue;                }              else              {                  buffer.Bytes[0] = (byte)intValue;                  buffer.Bytes[1] = (byte)(intValue >> 8);                  buffer.Bytes[2] = (byte)(intValue >> 16);                  buffer.Bytes[3] = (byte)(intValue >> 24);              }
Magic Number,DogSE.Server.Core.Net,PacketWriter,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\Net\PacketWriter.cs,GetBuffer,The following statement contains a magic number: if (m_Endian == Endian.LITTLE_ENDIAN)              {                  buffer.Bytes[0] = (byte)(intValue >> 24);                  buffer.Bytes[1] = (byte)(intValue >> 16);                  buffer.Bytes[2] = (byte)(intValue >> 8);                  buffer.Bytes[3] = (byte)intValue;                }              else              {                  buffer.Bytes[0] = (byte)intValue;                  buffer.Bytes[1] = (byte)(intValue >> 8);                  buffer.Bytes[2] = (byte)(intValue >> 16);                  buffer.Bytes[3] = (byte)(intValue >> 24);              }
Magic Number,DogSE.Server.Core.Net,PacketWriter,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\Net\PacketWriter.cs,GetBuffer,The following statement contains a magic number: if (m_Endian == Endian.LITTLE_ENDIAN)              {                  buffer.Bytes[0] = (byte)(intValue >> 24);                  buffer.Bytes[1] = (byte)(intValue >> 16);                  buffer.Bytes[2] = (byte)(intValue >> 8);                  buffer.Bytes[3] = (byte)intValue;                }              else              {                  buffer.Bytes[0] = (byte)intValue;                  buffer.Bytes[1] = (byte)(intValue >> 8);                  buffer.Bytes[2] = (byte)(intValue >> 16);                  buffer.Bytes[3] = (byte)(intValue >> 24);              }
Magic Number,DogSE.Server.Core.Net,PacketWriter,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\Net\PacketWriter.cs,GetBuffer,The following statement contains a magic number: if (m_Endian == Endian.LITTLE_ENDIAN)              {                  buffer.Bytes[0] = (byte)(intValue >> 24);                  buffer.Bytes[1] = (byte)(intValue >> 16);                  buffer.Bytes[2] = (byte)(intValue >> 8);                  buffer.Bytes[3] = (byte)intValue;                }              else              {                  buffer.Bytes[0] = (byte)intValue;                  buffer.Bytes[1] = (byte)(intValue >> 8);                  buffer.Bytes[2] = (byte)(intValue >> 16);                  buffer.Bytes[3] = (byte)(intValue >> 24);              }
Magic Number,DogSE.Server.Core.Net,ReceiveQueue,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\Net\ReceiveQueue.cs,Enqueue,The following statement contains a magic number: lock( m_LockBuffer )              {                  if ( ( m_Size + iSize ) >= m_Buffer.Length )                      SetCapacityInLock( ( m_Size + iSize + 2047 ) & ~2047 ); // 总是以2048的倍数来增大字节数' :( 弄得我老半天才明白原理呢!                    if ( m_Head < m_Tail )                  {                      long rightLength = m_Buffer.Length - m_Tail;                        if ( rightLength >= iSize )                          Buffer.BlockCopy( byteBuffer' (int)iOffset' m_Buffer' (int)m_Tail' (int)iSize );                      else                      {                          Buffer.BlockCopy( byteBuffer' (int)iOffset' m_Buffer' (int)m_Tail' (int)rightLength );                          Buffer.BlockCopy( byteBuffer' (int)( iOffset + rightLength )' m_Buffer' 0' (int)( iSize - rightLength ) );                      }                  }                  else                      Buffer.BlockCopy( byteBuffer' (int)iOffset' m_Buffer' (int)m_Tail' (int)iSize );                    m_Tail = ( m_Tail + iSize ) % m_Buffer.Length;                  m_Size += iSize;              }
Magic Number,DogSE.Server.Core.Net,ReceiveQueue,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\Net\ReceiveQueue.cs,Enqueue,The following statement contains a magic number: lock( m_LockBuffer )              {                  if ( ( m_Size + iSize ) >= m_Buffer.Length )                      SetCapacityInLock( ( m_Size + iSize + 2047 ) & ~2047 ); // 总是以2048的倍数来增大字节数' :( 弄得我老半天才明白原理呢!                    if ( m_Head < m_Tail )                  {                      long rightLength = m_Buffer.Length - m_Tail;                        if ( rightLength >= iSize )                          Buffer.BlockCopy( byteBuffer' (int)iOffset' m_Buffer' (int)m_Tail' (int)iSize );                      else                      {                          Buffer.BlockCopy( byteBuffer' (int)iOffset' m_Buffer' (int)m_Tail' (int)rightLength );                          Buffer.BlockCopy( byteBuffer' (int)( iOffset + rightLength )' m_Buffer' 0' (int)( iSize - rightLength ) );                      }                  }                  else                      Buffer.BlockCopy( byteBuffer' (int)iOffset' m_Buffer' (int)m_Tail' (int)iSize );                    m_Tail = ( m_Tail + iSize ) % m_Buffer.Length;                  m_Size += iSize;              }
Magic Number,DogSE.Server.Core.Net,ReceiveQueue,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\Net\ReceiveQueue.cs,GetPacketLength,The following statement contains a magic number: lock (m_LockBuffer)              {                  if (PacketLengthSize > m_Size)                      return 0;                    if (m_Head + PacketLengthSize < m_Buffer.Length)                  {                      //  保证要读取的数据在字节数组里                      var index = m_Head;                        //  读四字节长度                      if (m_Endian == Endian.LITTLE_ENDIAN)                          return (m_Buffer[index] << 24) | (m_Buffer[index + 1] << 16) | (m_Buffer[index + 2] << 8) | m_Buffer[index + 3];                      else                          return m_Buffer[index] | (m_Buffer[index + 1] << 8) | (m_Buffer[index + 2] << 16) | (m_Buffer[index + 3] << 24);                        //if (m_Endian == Endian.LITTLE_ENDIAN)                      //    return (m_Buffer[index] << 8) | (m_Buffer[index + 1]);                      //else                      //    return m_Buffer[index] | (m_Buffer[index + 1] << 8);                  }              }
Magic Number,DogSE.Server.Core.Net,ReceiveQueue,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\Net\ReceiveQueue.cs,GetPacketLength,The following statement contains a magic number: lock (m_LockBuffer)              {                  if (PacketLengthSize > m_Size)                      return 0;                    if (m_Head + PacketLengthSize < m_Buffer.Length)                  {                      //  保证要读取的数据在字节数组里                      var index = m_Head;                        //  读四字节长度                      if (m_Endian == Endian.LITTLE_ENDIAN)                          return (m_Buffer[index] << 24) | (m_Buffer[index + 1] << 16) | (m_Buffer[index + 2] << 8) | m_Buffer[index + 3];                      else                          return m_Buffer[index] | (m_Buffer[index + 1] << 8) | (m_Buffer[index + 2] << 16) | (m_Buffer[index + 3] << 24);                        //if (m_Endian == Endian.LITTLE_ENDIAN)                      //    return (m_Buffer[index] << 8) | (m_Buffer[index + 1]);                      //else                      //    return m_Buffer[index] | (m_Buffer[index + 1] << 8);                  }              }
Magic Number,DogSE.Server.Core.Net,ReceiveQueue,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\Net\ReceiveQueue.cs,GetPacketLength,The following statement contains a magic number: lock (m_LockBuffer)              {                  if (PacketLengthSize > m_Size)                      return 0;                    if (m_Head + PacketLengthSize < m_Buffer.Length)                  {                      //  保证要读取的数据在字节数组里                      var index = m_Head;                        //  读四字节长度                      if (m_Endian == Endian.LITTLE_ENDIAN)                          return (m_Buffer[index] << 24) | (m_Buffer[index + 1] << 16) | (m_Buffer[index + 2] << 8) | m_Buffer[index + 3];                      else                          return m_Buffer[index] | (m_Buffer[index + 1] << 8) | (m_Buffer[index + 2] << 16) | (m_Buffer[index + 3] << 24);                        //if (m_Endian == Endian.LITTLE_ENDIAN)                      //    return (m_Buffer[index] << 8) | (m_Buffer[index + 1]);                      //else                      //    return m_Buffer[index] | (m_Buffer[index + 1] << 8);                  }              }
Magic Number,DogSE.Server.Core.Net,ReceiveQueue,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\Net\ReceiveQueue.cs,GetPacketLength,The following statement contains a magic number: lock (m_LockBuffer)              {                  if (PacketLengthSize > m_Size)                      return 0;                    if (m_Head + PacketLengthSize < m_Buffer.Length)                  {                      //  保证要读取的数据在字节数组里                      var index = m_Head;                        //  读四字节长度                      if (m_Endian == Endian.LITTLE_ENDIAN)                          return (m_Buffer[index] << 24) | (m_Buffer[index + 1] << 16) | (m_Buffer[index + 2] << 8) | m_Buffer[index + 3];                      else                          return m_Buffer[index] | (m_Buffer[index + 1] << 8) | (m_Buffer[index + 2] << 16) | (m_Buffer[index + 3] << 24);                        //if (m_Endian == Endian.LITTLE_ENDIAN)                      //    return (m_Buffer[index] << 8) | (m_Buffer[index + 1]);                      //else                      //    return m_Buffer[index] | (m_Buffer[index + 1] << 8);                  }              }
Magic Number,DogSE.Server.Core.Net,ReceiveQueue,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\Net\ReceiveQueue.cs,GetPacketLength,The following statement contains a magic number: lock (m_LockBuffer)              {                  if (PacketLengthSize > m_Size)                      return 0;                    if (m_Head + PacketLengthSize < m_Buffer.Length)                  {                      //  保证要读取的数据在字节数组里                      var index = m_Head;                        //  读四字节长度                      if (m_Endian == Endian.LITTLE_ENDIAN)                          return (m_Buffer[index] << 24) | (m_Buffer[index + 1] << 16) | (m_Buffer[index + 2] << 8) | m_Buffer[index + 3];                      else                          return m_Buffer[index] | (m_Buffer[index + 1] << 8) | (m_Buffer[index + 2] << 16) | (m_Buffer[index + 3] << 24);                        //if (m_Endian == Endian.LITTLE_ENDIAN)                      //    return (m_Buffer[index] << 8) | (m_Buffer[index + 1]);                      //else                      //    return m_Buffer[index] | (m_Buffer[index + 1] << 8);                  }              }
Magic Number,DogSE.Server.Core.Net,ReceiveQueue,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\Net\ReceiveQueue.cs,GetPacketLength,The following statement contains a magic number: lock (m_LockBuffer)              {                  if (PacketLengthSize > m_Size)                      return 0;                    if (m_Head + PacketLengthSize < m_Buffer.Length)                  {                      //  保证要读取的数据在字节数组里                      var index = m_Head;                        //  读四字节长度                      if (m_Endian == Endian.LITTLE_ENDIAN)                          return (m_Buffer[index] << 24) | (m_Buffer[index + 1] << 16) | (m_Buffer[index + 2] << 8) | m_Buffer[index + 3];                      else                          return m_Buffer[index] | (m_Buffer[index + 1] << 8) | (m_Buffer[index + 2] << 16) | (m_Buffer[index + 3] << 24);                        //if (m_Endian == Endian.LITTLE_ENDIAN)                      //    return (m_Buffer[index] << 8) | (m_Buffer[index + 1]);                      //else                      //    return m_Buffer[index] | (m_Buffer[index + 1] << 8);                  }              }
Magic Number,DogSE.Server.Core.Net,ReceiveQueue,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\Net\ReceiveQueue.cs,GetPacketLength,The following statement contains a magic number: lock (m_LockBuffer)              {                  if (PacketLengthSize > m_Size)                      return 0;                    if (m_Head + PacketLengthSize < m_Buffer.Length)                  {                      //  保证要读取的数据在字节数组里                      var index = m_Head;                        //  读四字节长度                      if (m_Endian == Endian.LITTLE_ENDIAN)                          return (m_Buffer[index] << 24) | (m_Buffer[index + 1] << 16) | (m_Buffer[index + 2] << 8) | m_Buffer[index + 3];                      else                          return m_Buffer[index] | (m_Buffer[index + 1] << 8) | (m_Buffer[index + 2] << 16) | (m_Buffer[index + 3] << 24);                        //if (m_Endian == Endian.LITTLE_ENDIAN)                      //    return (m_Buffer[index] << 8) | (m_Buffer[index + 1]);                      //else                      //    return m_Buffer[index] | (m_Buffer[index + 1] << 8);                  }              }
Magic Number,DogSE.Server.Core.Net,ReceiveQueue,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\Net\ReceiveQueue.cs,GetPacketLength,The following statement contains a magic number: lock (m_LockBuffer)              {                  if (PacketLengthSize > m_Size)                      return 0;                    if (m_Head + PacketLengthSize < m_Buffer.Length)                  {                      //  保证要读取的数据在字节数组里                      var index = m_Head;                        //  读四字节长度                      if (m_Endian == Endian.LITTLE_ENDIAN)                          return (m_Buffer[index] << 24) | (m_Buffer[index + 1] << 16) | (m_Buffer[index + 2] << 8) | m_Buffer[index + 3];                      else                          return m_Buffer[index] | (m_Buffer[index + 1] << 8) | (m_Buffer[index + 2] << 16) | (m_Buffer[index + 3] << 24);                        //if (m_Endian == Endian.LITTLE_ENDIAN)                      //    return (m_Buffer[index] << 8) | (m_Buffer[index + 1]);                      //else                      //    return m_Buffer[index] | (m_Buffer[index + 1] << 8);                  }              }
Magic Number,DogSE.Server.Core.Net,ReceiveQueue,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\Net\ReceiveQueue.cs,GetPacketLength,The following statement contains a magic number: lock (m_LockBuffer)              {                  if (PacketLengthSize > m_Size)                      return 0;                    if (m_Head + PacketLengthSize < m_Buffer.Length)                  {                      //  保证要读取的数据在字节数组里                      var index = m_Head;                        //  读四字节长度                      if (m_Endian == Endian.LITTLE_ENDIAN)                          return (m_Buffer[index] << 24) | (m_Buffer[index + 1] << 16) | (m_Buffer[index + 2] << 8) | m_Buffer[index + 3];                      else                          return m_Buffer[index] | (m_Buffer[index + 1] << 8) | (m_Buffer[index + 2] << 16) | (m_Buffer[index + 3] << 24);                        //if (m_Endian == Endian.LITTLE_ENDIAN)                      //    return (m_Buffer[index] << 8) | (m_Buffer[index + 1]);                      //else                      //    return m_Buffer[index] | (m_Buffer[index + 1] << 8);                  }              }
Magic Number,DogSE.Server.Core.Net,ReceiveQueue,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\Net\ReceiveQueue.cs,GetPacketLength,The following statement contains a magic number: lock (m_LockBuffer)              {                  if (PacketLengthSize > m_Size)                      return 0;                    if (m_Head + PacketLengthSize < m_Buffer.Length)                  {                      //  保证要读取的数据在字节数组里                      var index = m_Head;                        //  读四字节长度                      if (m_Endian == Endian.LITTLE_ENDIAN)                          return (m_Buffer[index] << 24) | (m_Buffer[index + 1] << 16) | (m_Buffer[index + 2] << 8) | m_Buffer[index + 3];                      else                          return m_Buffer[index] | (m_Buffer[index + 1] << 8) | (m_Buffer[index + 2] << 16) | (m_Buffer[index + 3] << 24);                        //if (m_Endian == Endian.LITTLE_ENDIAN)                      //    return (m_Buffer[index] << 8) | (m_Buffer[index + 1]);                      //else                      //    return m_Buffer[index] | (m_Buffer[index + 1] << 8);                  }              }
Magic Number,DogSE.Server.Core.Protocol,CreateProxyCode,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\Protocol\CreateProxyCode.cs,Builder,The following statement contains a magic number: using (var csharpCodeProvider = new CSharpCodeProvider())              {                  var compilerParameters = new CompilerParameters();                    compilerParameters.ReferencedAssemblies.Add("mscorlib.dll");                  compilerParameters.ReferencedAssemblies.Add("System.dll");                  compilerParameters.ReferencedAssemblies.Add("System.Core.dll");                  compilerParameters.ReferencedAssemblies.Add("DogSE.Library.dll");                  compilerParameters.ReferencedAssemblies.Add("DogSE.Server.Core.dll");                    var assFileFullName = classType.Assembly.CodeBase;                  var rightLen = assFileFullName.LastIndexOf("/");                  var assFile = classType.Assembly.CodeBase.Substring(rightLen + 1' assFileFullName.Length - rightLen - 1);                  compilerParameters.ReferencedAssemblies.Add(assFile);                    compilerParameters.WarningLevel = 4;                  compilerParameters.GenerateInMemory = true;                    CompilerResults compilerResults = csharpCodeProvider.CompileAssemblyFromSource(compilerParameters' code);                    if (compilerResults.Errors.Count > 0)                  {                      Logs.Error("在动态编译游戏客户端代理类 {0} 时失败。"' "");                      foreach (var error in compilerResults.Errors)                      {                          Console.WriteLine(error.ToString());                          Logs.Error(error.ToString());                      }                      return null;                  }                    string className = string.Format("DogSE.Server.Core.Protocol.AutoCode.{0}Proxy{1}"' classType.Name' Version);                    var obj = compilerResults.CompiledAssembly.CreateInstance(className);                    if (obj == null)                  {                      Logs.Error("在创建动态客户端代理类 {0} 时失败。"' classType.Name);                      return null;                  }                    CompiledAssembly = compilerResults.CompiledAssembly;                    return obj;              }
Magic Number,DogSE.Server.Core.Protocol,CreateReadCode,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\Protocol\CreateReadCode.cs,AddMethod,The following statement contains a magic number: if (param.Length < 2)              {                  Logs.Error(string.Format("{0}.{1} 不支持 {2} 个参数"' classType.Name' methodinfo.Name' param.Length.ToString()));                  return;              }
Magic Number,DogSE.Server.Core.Protocol,CreateReadCode,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\Protocol\CreateReadCode.cs,Builder,The following statement contains a magic number: using (var csharpCodeProvider = new CSharpCodeProvider())              {                  var compilerParameters = new CompilerParameters();                    compilerParameters.ReferencedAssemblies.Add("mscorlib.dll");                  compilerParameters.ReferencedAssemblies.Add("System.dll");                  compilerParameters.ReferencedAssemblies.Add("System.Core.dll");                  compilerParameters.ReferencedAssemblies.Add("DogSE.Library.dll");                  compilerParameters.ReferencedAssemblies.Add("DogSE.Server.Core.dll");                  //compilerParameters.ReferencedAssemblies.Add("DogSE.Server.Core.UnitTest.dll");                    var assFileFullName = classType.Assembly.CodeBase;                  var rightLen = assFileFullName.LastIndexOf("/");                  var assFile = classType.Assembly.CodeBase.Substring(rightLen + 1' assFileFullName.Length - rightLen - 1);                  compilerParameters.ReferencedAssemblies.Add(assFile);                    compilerParameters.WarningLevel = 4;                  compilerParameters.GenerateInMemory = true;                    CompilerResults compilerResults = csharpCodeProvider.CompileAssemblyFromSource(compilerParameters' code);                    if (compilerResults.Errors.Count > 0)                  {                      Logs.Error("在动态编译游戏逻辑模块代理类 {0} 时失败。"' "");                      foreach (var error in compilerResults.Errors)                      {                          Console.WriteLine(error.ToString());                          Logs.Error(error.ToString());                      }                      return null;                  }                    string className = string.Format("DogSE.Server.Core.Protocol.AutoCode.{0}Access{1}"' classType.Name' Version);                    var obj = compilerResults.CompiledAssembly.CreateInstance(className);                    if (obj == null)                  {                      Logs.Error("在创建动态游戏逻辑模块代理类 {0} 时失败。"' classType.Name);                      return null;                  }                    CompiledAssembly = compilerResults.CompiledAssembly;                    return obj as IProtoclAutoCode;              }
Magic Number,DogSE.Server.Core.ServerState,ServerStateManager,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\ServerState\ServerStateManager.cs,WriterSimpleStates,The following statement contains a magic number: var buff = new StringBuilder(s_modules.Count*32*1024);
Magic Number,DogSE.Server.Core.ServerState,ServerStateManager,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\ServerState\ServerStateManager.cs,WriterSimpleStates,The following statement contains a magic number: var buff = new StringBuilder(s_modules.Count*32*1024);
Magic Number,DogSE.Server.Core.ServerState,ServerStateManager,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\ServerState\ServerStateManager.cs,WriterSimpleStates,The following statement contains a magic number: using (var memStream = new MemoryStream(s_modules.Count * 32 * 1024))              {                  var writer = new StreamWriter(memStream);                  foreach (var module in s_modules.ToArray())                  {                      buff.AppendFormat("[{0}]"' module.ModuleId);                      buff.AppendLine();                      module.AppendSimpleState(writer);                      buff.AppendLine();                  }                    memStream.Position = 0;                  return new StreamReader(memStream).ReadToEnd();              }
Magic Number,DogSE.Server.Core.ServerState,ServerStateManager,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\ServerState\ServerStateManager.cs,WriterSimpleStates,The following statement contains a magic number: using (var memStream = new MemoryStream(s_modules.Count * 32 * 1024))              {                  var writer = new StreamWriter(memStream);                  foreach (var module in s_modules.ToArray())                  {                      buff.AppendFormat("[{0}]"' module.ModuleId);                      buff.AppendLine();                      module.AppendSimpleState(writer);                      buff.AppendLine();                  }                    memStream.Position = 0;                  return new StreamReader(memStream).ReadToEnd();              }
Magic Number,DogSE.Server.Core.ServerState,ServerStateManager,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\ServerState\ServerStateManager.cs,WriterFullStates,The following statement contains a magic number: var buff = new StringBuilder(s_modules.Count * 32 * 1024);
Magic Number,DogSE.Server.Core.ServerState,ServerStateManager,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\ServerState\ServerStateManager.cs,WriterFullStates,The following statement contains a magic number: var buff = new StringBuilder(s_modules.Count * 32 * 1024);
Magic Number,DogSE.Server.Core.ServerState,ServerStateManager,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\ServerState\ServerStateManager.cs,WriterFullStates,The following statement contains a magic number: using (var memStream = new MemoryStream(s_modules.Count * 32 * 1024))              {                  var writer = new StreamWriter(memStream);                  foreach (var module in s_modules.ToArray())                  {                      buff.AppendFormat("[{0}]"' module.ModuleId);                      buff.AppendLine();                      module.AppendFullState(writer);                      buff.AppendLine();                  }                    memStream.Position = 0;                  return new StreamReader(memStream).ReadToEnd();              }
Magic Number,DogSE.Server.Core.ServerState,ServerStateManager,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\ServerState\ServerStateManager.cs,WriterFullStates,The following statement contains a magic number: using (var memStream = new MemoryStream(s_modules.Count * 32 * 1024))              {                  var writer = new StreamWriter(memStream);                  foreach (var module in s_modules.ToArray())                  {                      buff.AppendFormat("[{0}]"' module.ModuleId);                      buff.AppendLine();                      module.AppendFullState(writer);                      buff.AppendLine();                  }                    memStream.Position = 0;                  return new StreamReader(memStream).ReadToEnd();              }
Magic Number,DogSE.Server.Core.TaskT,TaskManagerT<T>,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\TaskT\TaskManagerT.cs,WorkThread,The following statement contains a magic number: while (isRuning || taskList.Count > 0)              {                  ITaskT<T> task;                  if (taskList.TryDequeue(out task))                  {                      lastTask = task;                      watch.Restart();                      bool isError = false;                      try                      {                          task.Execute();                      }                      catch (Exception ex)                      {                          Logs.Error("{0} run task fail."' taskName_' ex);                          isError = true;                      }                      watch.Stop();                        task.Parent = this;                        var timeTicks = watch.ElapsedTicks;                        task.TaskProfile.Append(timeTicks' isError);                      task.WriteLog(timeTicks' isError);                      task.Release();                        var now = OneServer.NowTime;                      if (now.Ticks - start.Ticks > 10000 * 1000 * 10)                      {                          start = now;                          NetTaskLogWriter.Flush();                          ActionTaskLogWriter.Flush();                      }                        lastTask = null;                  }                  else                  {                      //  队列里没任务，则让线程先休息一小会                      Thread.Sleep(1);                  }              }
Magic Number,DogSE.Server.Core.TaskT,TaskManagerT<T>,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\TaskT\TaskManagerT.cs,WorkThread,The following statement contains a magic number: while (isRuning || taskList.Count > 0)              {                  ITaskT<T> task;                  if (taskList.TryDequeue(out task))                  {                      lastTask = task;                      watch.Restart();                      bool isError = false;                      try                      {                          task.Execute();                      }                      catch (Exception ex)                      {                          Logs.Error("{0} run task fail."' taskName_' ex);                          isError = true;                      }                      watch.Stop();                        task.Parent = this;                        var timeTicks = watch.ElapsedTicks;                        task.TaskProfile.Append(timeTicks' isError);                      task.WriteLog(timeTicks' isError);                      task.Release();                        var now = OneServer.NowTime;                      if (now.Ticks - start.Ticks > 10000 * 1000 * 10)                      {                          start = now;                          NetTaskLogWriter.Flush();                          ActionTaskLogWriter.Flush();                      }                        lastTask = null;                  }                  else                  {                      //  队列里没任务，则让线程先休息一小会                      Thread.Sleep(1);                  }              }
Magic Number,DogSE.Server.Core.TaskT,TaskManagerT<T>,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\TaskT\TaskManagerT.cs,WorkThread,The following statement contains a magic number: while (isRuning || taskList.Count > 0)              {                  ITaskT<T> task;                  if (taskList.TryDequeue(out task))                  {                      lastTask = task;                      watch.Restart();                      bool isError = false;                      try                      {                          task.Execute();                      }                      catch (Exception ex)                      {                          Logs.Error("{0} run task fail."' taskName_' ex);                          isError = true;                      }                      watch.Stop();                        task.Parent = this;                        var timeTicks = watch.ElapsedTicks;                        task.TaskProfile.Append(timeTicks' isError);                      task.WriteLog(timeTicks' isError);                      task.Release();                        var now = OneServer.NowTime;                      if (now.Ticks - start.Ticks > 10000 * 1000 * 10)                      {                          start = now;                          NetTaskLogWriter.Flush();                          ActionTaskLogWriter.Flush();                      }                        lastTask = null;                  }                  else                  {                      //  队列里没任务，则让线程先休息一小会                      Thread.Sleep(1);                  }              }
Magic Number,DogSE.Server.Core.Task,ActionTaskCodeRuntimeWriter,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\Task\ActionTaskCodeRuntimeWriter.cs,OpenFile,The following statement contains a magic number: if (!File.Exists(fileName)) //  文件不存在则新建一个文件              {                  new FileInfo(fileName).Directory.Create(); //  创建日志文件目录                    //  纯数字和英文的数据记录，因此开ascii的编码写入                  //  开一个2M的缓冲区，应该够日志数据的收集了。                  _writer = new StreamWriter(fileName' true' Encoding.UTF8' 1024*1024*2);                  _writer.WriteLine("TimeTick'Fun'RunTime'WaitTime'IsException");                  //  不用自动刷新，我们有一个定时器每隔1s进行一次刷新，正常些日志时，数据会先些在写入流的缓冲区里的                  _writer.AutoFlush = false;              }              else              {                  _writer = new StreamWriter(fileName' true' Encoding.UTF8' 1024*1024*2); //  开一个2M的缓冲区，应该够日志数据的收集了。                  _writer.AutoFlush = false;              }
Magic Number,DogSE.Server.Core.Task,ActionTaskCodeRuntimeWriter,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\Task\ActionTaskCodeRuntimeWriter.cs,OpenFile,The following statement contains a magic number: if (!File.Exists(fileName)) //  文件不存在则新建一个文件              {                  new FileInfo(fileName).Directory.Create(); //  创建日志文件目录                    //  纯数字和英文的数据记录，因此开ascii的编码写入                  //  开一个2M的缓冲区，应该够日志数据的收集了。                  _writer = new StreamWriter(fileName' true' Encoding.UTF8' 1024*1024*2);                  _writer.WriteLine("TimeTick'Fun'RunTime'WaitTime'IsException");                  //  不用自动刷新，我们有一个定时器每隔1s进行一次刷新，正常些日志时，数据会先些在写入流的缓冲区里的                  _writer.AutoFlush = false;              }              else              {                  _writer = new StreamWriter(fileName' true' Encoding.UTF8' 1024*1024*2); //  开一个2M的缓冲区，应该够日志数据的收集了。                  _writer.AutoFlush = false;              }
Magic Number,DogSE.Server.Core.Task,ActionTaskCodeRuntimeWriter,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\Task\ActionTaskCodeRuntimeWriter.cs,OpenFile,The following statement contains a magic number: if (!File.Exists(fileName)) //  文件不存在则新建一个文件              {                  new FileInfo(fileName).Directory.Create(); //  创建日志文件目录                    //  纯数字和英文的数据记录，因此开ascii的编码写入                  //  开一个2M的缓冲区，应该够日志数据的收集了。                  _writer = new StreamWriter(fileName' true' Encoding.UTF8' 1024*1024*2);                  _writer.WriteLine("TimeTick'Fun'RunTime'WaitTime'IsException");                  //  不用自动刷新，我们有一个定时器每隔1s进行一次刷新，正常些日志时，数据会先些在写入流的缓冲区里的                  _writer.AutoFlush = false;              }              else              {                  _writer = new StreamWriter(fileName' true' Encoding.UTF8' 1024*1024*2); //  开一个2M的缓冲区，应该够日志数据的收集了。                  _writer.AutoFlush = false;              }
Magic Number,DogSE.Server.Core.Task,ActionTaskCodeRuntimeWriter,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\Task\ActionTaskCodeRuntimeWriter.cs,OpenFile,The following statement contains a magic number: if (!File.Exists(fileName)) //  文件不存在则新建一个文件              {                  new FileInfo(fileName).Directory.Create(); //  创建日志文件目录                    //  纯数字和英文的数据记录，因此开ascii的编码写入                  //  开一个2M的缓冲区，应该够日志数据的收集了。                  _writer = new StreamWriter(fileName' true' Encoding.UTF8' 1024*1024*2);                  _writer.WriteLine("TimeTick'Fun'RunTime'WaitTime'IsException");                  //  不用自动刷新，我们有一个定时器每隔1s进行一次刷新，正常些日志时，数据会先些在写入流的缓冲区里的                  _writer.AutoFlush = false;              }              else              {                  _writer = new StreamWriter(fileName' true' Encoding.UTF8' 1024*1024*2); //  开一个2M的缓冲区，应该够日志数据的收集了。                  _writer.AutoFlush = false;              }
Magic Number,DogSE.Server.Core.Task,ActionTaskCodeRuntimeWriter,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\Task\ActionTaskCodeRuntimeWriter.cs,OpenFile,The following statement contains a magic number: if (!File.Exists(fileName)) //  文件不存在则新建一个文件              {                  new FileInfo(fileName).Directory.Create(); //  创建日志文件目录                    //  纯数字和英文的数据记录，因此开ascii的编码写入                  //  开一个2M的缓冲区，应该够日志数据的收集了。                  _writer = new StreamWriter(fileName' true' Encoding.UTF8' 1024*1024*2);                  _writer.WriteLine("TimeTick'Fun'RunTime'WaitTime'IsException");                  //  不用自动刷新，我们有一个定时器每隔1s进行一次刷新，正常些日志时，数据会先些在写入流的缓冲区里的                  _writer.AutoFlush = false;              }              else              {                  _writer = new StreamWriter(fileName' true' Encoding.UTF8' 1024*1024*2); //  开一个2M的缓冲区，应该够日志数据的收集了。                  _writer.AutoFlush = false;              }
Magic Number,DogSE.Server.Core.Task,ActionTaskCodeRuntimeWriter,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\Task\ActionTaskCodeRuntimeWriter.cs,OpenFile,The following statement contains a magic number: if (!File.Exists(fileName)) //  文件不存在则新建一个文件              {                  new FileInfo(fileName).Directory.Create(); //  创建日志文件目录                    //  纯数字和英文的数据记录，因此开ascii的编码写入                  //  开一个2M的缓冲区，应该够日志数据的收集了。                  _writer = new StreamWriter(fileName' true' Encoding.UTF8' 1024*1024*2);                  _writer.WriteLine("TimeTick'Fun'RunTime'WaitTime'IsException");                  //  不用自动刷新，我们有一个定时器每隔1s进行一次刷新，正常些日志时，数据会先些在写入流的缓冲区里的                  _writer.AutoFlush = false;              }              else              {                  _writer = new StreamWriter(fileName' true' Encoding.UTF8' 1024*1024*2); //  开一个2M的缓冲区，应该够日志数据的收集了。                  _writer.AutoFlush = false;              }
Magic Number,DogSE.Server.Core.Task,NetTaskCodeRuntimeWriter,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\Task\NetTaskCodeRuntimeWriter.cs,OpenFile,The following statement contains a magic number: if (!File.Exists(fileName)) //  文件不存在则新建一个文件              {                  new FileInfo(fileName).Directory.Create(); //  创建日志文件目录                    //  纯数字和英文的数据记录，因此开ascii的编码写入                  //  开一个2M的缓冲区，应该够日志数据的收集了。                  _writer = new StreamWriter(fileName' true' Encoding.UTF8' 1024*1024*2);                  _writer.WriteLine("TimeTick'Code'PlayerId'RunTime'WaitTime'IsException");                  //  不用自动刷新，我们有一个定时器每隔1s进行一次刷新，正常些日志时，数据会先些在写入流的缓冲区里的                  _writer.AutoFlush = false;              }              else              {                  _writer = new StreamWriter(fileName' true' Encoding.UTF8' 1024*1024*2); //  开一个2M的缓冲区，应该够日志数据的收集了。                  _writer.AutoFlush = false;              }
Magic Number,DogSE.Server.Core.Task,NetTaskCodeRuntimeWriter,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\Task\NetTaskCodeRuntimeWriter.cs,OpenFile,The following statement contains a magic number: if (!File.Exists(fileName)) //  文件不存在则新建一个文件              {                  new FileInfo(fileName).Directory.Create(); //  创建日志文件目录                    //  纯数字和英文的数据记录，因此开ascii的编码写入                  //  开一个2M的缓冲区，应该够日志数据的收集了。                  _writer = new StreamWriter(fileName' true' Encoding.UTF8' 1024*1024*2);                  _writer.WriteLine("TimeTick'Code'PlayerId'RunTime'WaitTime'IsException");                  //  不用自动刷新，我们有一个定时器每隔1s进行一次刷新，正常些日志时，数据会先些在写入流的缓冲区里的                  _writer.AutoFlush = false;              }              else              {                  _writer = new StreamWriter(fileName' true' Encoding.UTF8' 1024*1024*2); //  开一个2M的缓冲区，应该够日志数据的收集了。                  _writer.AutoFlush = false;              }
Magic Number,DogSE.Server.Core.Task,NetTaskCodeRuntimeWriter,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\Task\NetTaskCodeRuntimeWriter.cs,OpenFile,The following statement contains a magic number: if (!File.Exists(fileName)) //  文件不存在则新建一个文件              {                  new FileInfo(fileName).Directory.Create(); //  创建日志文件目录                    //  纯数字和英文的数据记录，因此开ascii的编码写入                  //  开一个2M的缓冲区，应该够日志数据的收集了。                  _writer = new StreamWriter(fileName' true' Encoding.UTF8' 1024*1024*2);                  _writer.WriteLine("TimeTick'Code'PlayerId'RunTime'WaitTime'IsException");                  //  不用自动刷新，我们有一个定时器每隔1s进行一次刷新，正常些日志时，数据会先些在写入流的缓冲区里的                  _writer.AutoFlush = false;              }              else              {                  _writer = new StreamWriter(fileName' true' Encoding.UTF8' 1024*1024*2); //  开一个2M的缓冲区，应该够日志数据的收集了。                  _writer.AutoFlush = false;              }
Magic Number,DogSE.Server.Core.Task,NetTaskCodeRuntimeWriter,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\Task\NetTaskCodeRuntimeWriter.cs,OpenFile,The following statement contains a magic number: if (!File.Exists(fileName)) //  文件不存在则新建一个文件              {                  new FileInfo(fileName).Directory.Create(); //  创建日志文件目录                    //  纯数字和英文的数据记录，因此开ascii的编码写入                  //  开一个2M的缓冲区，应该够日志数据的收集了。                  _writer = new StreamWriter(fileName' true' Encoding.UTF8' 1024*1024*2);                  _writer.WriteLine("TimeTick'Code'PlayerId'RunTime'WaitTime'IsException");                  //  不用自动刷新，我们有一个定时器每隔1s进行一次刷新，正常些日志时，数据会先些在写入流的缓冲区里的                  _writer.AutoFlush = false;              }              else              {                  _writer = new StreamWriter(fileName' true' Encoding.UTF8' 1024*1024*2); //  开一个2M的缓冲区，应该够日志数据的收集了。                  _writer.AutoFlush = false;              }
Magic Number,DogSE.Server.Core.Task,NetTaskCodeRuntimeWriter,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\Task\NetTaskCodeRuntimeWriter.cs,OpenFile,The following statement contains a magic number: if (!File.Exists(fileName)) //  文件不存在则新建一个文件              {                  new FileInfo(fileName).Directory.Create(); //  创建日志文件目录                    //  纯数字和英文的数据记录，因此开ascii的编码写入                  //  开一个2M的缓冲区，应该够日志数据的收集了。                  _writer = new StreamWriter(fileName' true' Encoding.UTF8' 1024*1024*2);                  _writer.WriteLine("TimeTick'Code'PlayerId'RunTime'WaitTime'IsException");                  //  不用自动刷新，我们有一个定时器每隔1s进行一次刷新，正常些日志时，数据会先些在写入流的缓冲区里的                  _writer.AutoFlush = false;              }              else              {                  _writer = new StreamWriter(fileName' true' Encoding.UTF8' 1024*1024*2); //  开一个2M的缓冲区，应该够日志数据的收集了。                  _writer.AutoFlush = false;              }
Magic Number,DogSE.Server.Core.Task,NetTaskCodeRuntimeWriter,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\Task\NetTaskCodeRuntimeWriter.cs,OpenFile,The following statement contains a magic number: if (!File.Exists(fileName)) //  文件不存在则新建一个文件              {                  new FileInfo(fileName).Directory.Create(); //  创建日志文件目录                    //  纯数字和英文的数据记录，因此开ascii的编码写入                  //  开一个2M的缓冲区，应该够日志数据的收集了。                  _writer = new StreamWriter(fileName' true' Encoding.UTF8' 1024*1024*2);                  _writer.WriteLine("TimeTick'Code'PlayerId'RunTime'WaitTime'IsException");                  //  不用自动刷新，我们有一个定时器每隔1s进行一次刷新，正常些日志时，数据会先些在写入流的缓冲区里的                  _writer.AutoFlush = false;              }              else              {                  _writer = new StreamWriter(fileName' true' Encoding.UTF8' 1024*1024*2); //  开一个2M的缓冲区，应该够日志数据的收集了。                  _writer.AutoFlush = false;              }
Magic Number,DogSE.Server.Core.Task,TaskManager,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\Task\TaskManager.cs,WorkThread,The following statement contains a magic number: while(isRuning || taskList.Count > 0)              {                  ITask task;                  if(taskList.TryDequeue(out task))                  {                      lastTask = task;                      watch.Restart();                      bool isError = false;                      try                      {                          task.Execute();                      }                      catch (Exception ex)                      {                          Logs.Error("{0} run task fail."' taskName_' ex);                          isError = true;                      }                      watch.Stop();                        task.Parent = this;                        var timeTicks = watch.ElapsedTicks;                        task.TaskProfile.Append(timeTicks' isError);                      task.WriteLog(timeTicks' isError);                      task.Release();                        var now = OneServer.NowTime;                      if (now.Ticks - start.Ticks > 10000 * 1000 * 10)                      {                          start = now;                          NetTaskLogWriter.Flush();                          ActionTaskLogWriter.Flush();                      }                        lastTask = null;                  }                  else                  {                      //  队列里没任务，则让线程先休息一小会                      Thread.Sleep(1);                  }              }
Magic Number,DogSE.Server.Core.Task,TaskManager,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\Task\TaskManager.cs,WorkThread,The following statement contains a magic number: while(isRuning || taskList.Count > 0)              {                  ITask task;                  if(taskList.TryDequeue(out task))                  {                      lastTask = task;                      watch.Restart();                      bool isError = false;                      try                      {                          task.Execute();                      }                      catch (Exception ex)                      {                          Logs.Error("{0} run task fail."' taskName_' ex);                          isError = true;                      }                      watch.Stop();                        task.Parent = this;                        var timeTicks = watch.ElapsedTicks;                        task.TaskProfile.Append(timeTicks' isError);                      task.WriteLog(timeTicks' isError);                      task.Release();                        var now = OneServer.NowTime;                      if (now.Ticks - start.Ticks > 10000 * 1000 * 10)                      {                          start = now;                          NetTaskLogWriter.Flush();                          ActionTaskLogWriter.Flush();                      }                        lastTask = null;                  }                  else                  {                      //  队列里没任务，则让线程先休息一小会                      Thread.Sleep(1);                  }              }
Magic Number,DogSE.Server.Core.Task,TaskManager,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\Task\TaskManager.cs,WorkThread,The following statement contains a magic number: while(isRuning || taskList.Count > 0)              {                  ITask task;                  if(taskList.TryDequeue(out task))                  {                      lastTask = task;                      watch.Restart();                      bool isError = false;                      try                      {                          task.Execute();                      }                      catch (Exception ex)                      {                          Logs.Error("{0} run task fail."' taskName_' ex);                          isError = true;                      }                      watch.Stop();                        task.Parent = this;                        var timeTicks = watch.ElapsedTicks;                        task.TaskProfile.Append(timeTicks' isError);                      task.WriteLog(timeTicks' isError);                      task.Release();                        var now = OneServer.NowTime;                      if (now.Ticks - start.Ticks > 10000 * 1000 * 10)                      {                          start = now;                          NetTaskLogWriter.Flush();                          ActionTaskLogWriter.Flush();                      }                        lastTask = null;                  }                  else                  {                      //  队列里没任务，则让线程先休息一小会                      Thread.Sleep(1);                  }              }
Magic Number,DogSE.Server.Core.Timer,TimerThread,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\Timer\TimerThread.cs,RunTimerThread,The following statement contains a magic number: const int longTimeIndex = 3;
Magic Number,DogSE.Server.Core.Util,AssemblyUtil,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\Util\AssemblyUtil.cs,LoadLogicAssemblyInMem,The following statement contains a magic number: foreach (var file in dllFiles)              {                  if (file.ToLower().IndexOf(logicKeyString) > -1)                  {                      if (!ass.Any(o=>o.FullName.IndexOf(file.Substring(0' file.Length - 4)) > -1))                          Assembly.Load(File.ReadAllBytes(file));                  }              }
Missing Default,DogSE.Server.Core.Config,KeyValueItem,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\Config\KeyValueConfig.cs,ClearAndUpdate,The following switch statement is missing a default case: switch (type)              {                  case KeyValueType.Int:                      GetInt();                      break;                  case KeyValueType.Double:                      GetDouble();                      break;                  case KeyValueType.String:                      GetString();                      break;                  case KeyValueType.IntArray:                      GetIntArray();                      break;              }
Missing Default,DogSE.Server.Core.Net,PacketReader,C:\repos\dogvane_DogSE\DogSE\DogSE.Server.Core\Net\PacketReader.cs,Seek,The following switch statement is missing a default case: switch ( seekOrigin )              {                  case SeekOrigin.Begin:                      m_Index = iOffset;                      break;                  case SeekOrigin.Current:                      m_Index += iOffset;                      break;                  case SeekOrigin.End:                      m_Index = m_Size - iOffset;                      break;              }
