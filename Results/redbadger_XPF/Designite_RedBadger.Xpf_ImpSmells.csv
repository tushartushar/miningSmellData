Implementation smell,Namespace,Class,File,Method,Description
Complex Method,RedBadger.Xpf.Internal.Controls,Viewbox,C:\research\architectureSmells\repos\redbadger_XPF\XPF\RedBadger.Xpf\Internal\Controls\Viewbox.cs,ComputeScaleFactor,Cyclomatic complexity of the method is 10
Complex Method,RedBadger.Xpf.Controls,ItemsControl,C:\research\architectureSmells\repos\redbadger_XPF\XPF\RedBadger.Xpf\Controls\ItemsControl.cs,OnNextItemChange,Cyclomatic complexity of the method is 8
Complex Method,RedBadger.Xpf.Controls,Grid,C:\research\architectureSmells\repos\redbadger_XPF\XPF\RedBadger.Xpf\Controls\Grid.cs,AllocateProportionalSpace,Cyclomatic complexity of the method is 9
Complex Method,RedBadger.Xpf.Controls,Grid,C:\research\architectureSmells\repos\redbadger_XPF\XPF\RedBadger.Xpf\Controls\Grid.cs,SetFinalLength,Cyclomatic complexity of the method is 12
Complex Method,RedBadger.Xpf.Controls,Grid,C:\research\architectureSmells\repos\redbadger_XPF\XPF\RedBadger.Xpf\Controls\Grid.cs,MeasureCells,Cyclomatic complexity of the method is 11
Long Identifier,RedBadger.Xpf.Data,OneWayBinding<T>,C:\research\architectureSmells\repos\redbadger_XPF\XPF\RedBadger.Xpf\Data\OneWayBinding.cs,,The length of the parameter shouldPushInitialValueOnSubscribe is 33.
Long Identifier,RedBadger.Xpf,UIElement,C:\research\architectureSmells\repos\redbadger_XPF\XPF\RedBadger.Xpf\UIElement.cs,GetClippingRect,The length of the parameter isClippingRequiredDueToMaxSize is 30.
Long Identifier,RedBadger.Xpf,UIElement,C:\research\architectureSmells\repos\redbadger_XPF\XPF\RedBadger.Xpf\UIElement.cs,GetClippingRect,The length of the parameter isClippingRequiredDueToClientSize is 33.
Long Identifier,RedBadger.Xpf.Controls,ScrollViewer,C:\research\architectureSmells\repos\redbadger_XPF\XPF\RedBadger.Xpf\Controls\ScrollViewer.cs,,The length of the parameter isInsertingScrollContentPresenter is 33.
Long Identifier,RedBadger.Xpf.Controls,Grid,C:\research\architectureSmells\repos\redbadger_XPF\XPF\RedBadger.Xpf\Controls\Grid.cs,MeasureCell,The length of the parameter shouldChildBeMeasuredWithInfiniteHeight is 39.
Long Identifier,RedBadger.Xpf.Controls,Grid,C:\research\architectureSmells\repos\redbadger_XPF\XPF\RedBadger.Xpf\Controls\Grid.cs,MeasureCells,The length of the parameter shouldChildBeMeasuredWithInfiniteHeight is 39.
Long Statement,RedBadger.Xpf,License,C:\research\architectureSmells\repos\redbadger_XPF\XPF\RedBadger.Xpf\License.cs,Validate,The length of the statement  "                    "Your trial license of XPF has expired.  Please visit http://red-badger.com to obtain a license or download the latest nightly build."); " is 136.
Magic Number,RedBadger.Xpf.Internal,DoubleExtensions,C:\research\architectureSmells\repos\redbadger_XPF\XPF\RedBadger.Xpf\Internal\DoubleExtensions.cs,IsDifferentFrom,The following statement contains a magic number: double epsilon = (Math.Abs(value1) + Math.Abs(value2) + 10.0) * 1e-15;
Magic Number,RedBadger.Xpf.Internal,DoubleExtensions,C:\research\architectureSmells\repos\redbadger_XPF\XPF\RedBadger.Xpf\Internal\DoubleExtensions.cs,IsDifferentFrom,The following statement contains a magic number: double epsilon = (Math.Abs(value1) + Math.Abs(value2) + 10.0) * 1e-15;
Magic Number,RedBadger.Xpf,License,C:\research\architectureSmells\repos\redbadger_XPF\XPF\RedBadger.Xpf\License.cs,Validate,The following statement contains a magic number: var buildTime =                  new TimeSpan((TimeSpan.TicksPerDay * version.Build) + (TimeSpan.TicksPerSecond * 2 * version.Revision));
Magic Number,RedBadger.Xpf,License,C:\research\architectureSmells\repos\redbadger_XPF\XPF\RedBadger.Xpf\License.cs,Validate,The following statement contains a magic number: DateTime buildDateTime = new DateTime(2000' 1' 1).Add(buildTime);
Magic Number,RedBadger.Xpf,License,C:\research\architectureSmells\repos\redbadger_XPF\XPF\RedBadger.Xpf\License.cs,Validate,The following statement contains a magic number: DateTime expiryDate = buildDateTime.AddDays(30).Date;
Magic Number,RedBadger.Xpf,Point,C:\research\architectureSmells\repos\redbadger_XPF\XPF\RedBadger.Xpf\Point.cs,GetHashCode,The following statement contains a magic number: return (this.X.GetHashCode() * 397) ^ this.Y.GetHashCode();
Magic Number,RedBadger.Xpf,Size,C:\research\architectureSmells\repos\redbadger_XPF\XPF\RedBadger.Xpf\Size.cs,GetHashCode,The following statement contains a magic number: return (this.Width.GetHashCode() * 397) ^ this.Height.GetHashCode();
Magic Number,RedBadger.Xpf,Rect,C:\research\architectureSmells\repos\redbadger_XPF\XPF\RedBadger.Xpf\Rect.cs,GetHashCode,The following statement contains a magic number: result = (result * 397) ^ this.Width.GetHashCode();
Magic Number,RedBadger.Xpf,Rect,C:\research\architectureSmells\repos\redbadger_XPF\XPF\RedBadger.Xpf\Rect.cs,GetHashCode,The following statement contains a magic number: result = (result * 397) ^ this.X.GetHashCode();
Magic Number,RedBadger.Xpf,Rect,C:\research\architectureSmells\repos\redbadger_XPF\XPF\RedBadger.Xpf\Rect.cs,GetHashCode,The following statement contains a magic number: result = (result * 397) ^ this.Y.GetHashCode();
Magic Number,RedBadger.Xpf,Thickness,C:\research\architectureSmells\repos\redbadger_XPF\XPF\RedBadger.Xpf\Thickness.cs,GetHashCode,The following statement contains a magic number: result = (result * 397) ^ this.Left.GetHashCode();
Magic Number,RedBadger.Xpf,Thickness,C:\research\architectureSmells\repos\redbadger_XPF\XPF\RedBadger.Xpf\Thickness.cs,GetHashCode,The following statement contains a magic number: result = (result * 397) ^ this.Right.GetHashCode();
Magic Number,RedBadger.Xpf,Thickness,C:\research\architectureSmells\repos\redbadger_XPF\XPF\RedBadger.Xpf\Thickness.cs,GetHashCode,The following statement contains a magic number: result = (result * 397) ^ this.Top.GetHashCode();
Magic Number,RedBadger.Xpf,Vector,C:\research\architectureSmells\repos\redbadger_XPF\XPF\RedBadger.Xpf\Vector.cs,GetHashCode,The following statement contains a magic number: return (this.X.GetHashCode() * 397) ^ this.Y.GetHashCode();
Magic Number,RedBadger.Xpf,UIElement,C:\research\architectureSmells\repos\redbadger_XPF\XPF\RedBadger.Xpf\UIElement.cs,ComputeAlignmentOffset,The following statement contains a magic number: switch (horizontalAlignment)              {                  case HorizontalAlignment.Center:                  case HorizontalAlignment.Stretch:                      vector.X = (clientSize.Width - inkSize.Width) * 0.5;                      break;                  case HorizontalAlignment.Left:                      vector.X = 0;                      break;                  case HorizontalAlignment.Right:                      vector.X = clientSize.Width - inkSize.Width;                      break;              }
Magic Number,RedBadger.Xpf,UIElement,C:\research\architectureSmells\repos\redbadger_XPF\XPF\RedBadger.Xpf\UIElement.cs,ComputeAlignmentOffset,The following statement contains a magic number: switch (verticalAlignment)              {                  case VerticalAlignment.Center:                  case VerticalAlignment.Stretch:                      vector.Y = (clientSize.Height - inkSize.Height) * 0.5;                      return vector;                  case VerticalAlignment.Bottom:                      vector.Y = clientSize.Height - inkSize.Height;                      return vector;                  case VerticalAlignment.Top:                      vector.Y = 0;                      break;              }
Magic Number,RedBadger.Xpf.Media,Color,C:\research\architectureSmells\repos\redbadger_XPF\XPF\RedBadger.Xpf\Media\Color.cs,FromUInt32,The following statement contains a magic number: return new Color                  {                      A = (byte)((value & -16777216) >> 0x18)'                       R = (byte)((value & 0xff0000) >> 0x10)'                       G = (byte)((value & 0xff00) >> 8)'                       B = (byte)(value & 0xff)                  };
Magic Number,RedBadger.Xpf.Media,Color,C:\research\architectureSmells\repos\redbadger_XPF\XPF\RedBadger.Xpf\Media\Color.cs,FromUInt32,The following statement contains a magic number: return new Color                  {                      A = (byte)((value & -16777216) >> 0x18)'                       R = (byte)((value & 0xff0000) >> 0x10)'                       G = (byte)((value & 0xff00) >> 8)'                       B = (byte)(value & 0xff)                  };
Magic Number,RedBadger.Xpf.Media,Color,C:\research\architectureSmells\repos\redbadger_XPF\XPF\RedBadger.Xpf\Media\Color.cs,GetHashCode,The following statement contains a magic number: result = (result * 397) ^ this.B.GetHashCode();
Magic Number,RedBadger.Xpf.Media,Color,C:\research\architectureSmells\repos\redbadger_XPF\XPF\RedBadger.Xpf\Media\Color.cs,GetHashCode,The following statement contains a magic number: result = (result * 397) ^ this.G.GetHashCode();
Magic Number,RedBadger.Xpf.Media,Color,C:\research\architectureSmells\repos\redbadger_XPF\XPF\RedBadger.Xpf\Media\Color.cs,GetHashCode,The following statement contains a magic number: result = (result * 397) ^ this.R.GetHashCode();
Missing Default,RedBadger.Xpf.Controls.Primitives,ButtonBase,C:\research\architectureSmells\repos\redbadger_XPF\XPF\RedBadger.Xpf\Controls\Primitives\ButtonBase.cs,OnNextGesture,The following switch statement is missing a default case: switch (gesture.Type)              {                  case GestureType.LeftButtonDown:                      this.isLeftButtonDown = true;                        if (this.CaptureMouse())                      {                          this.IsPressed = true;                      }                        break;                  case GestureType.LeftButtonUp:                      this.isLeftButtonDown = false;                        if (this.IsPressed)                      {                          this.OnClick();                      }                        this.ReleaseMouseCapture();                      this.IsPressed = false;                      break;                  case GestureType.Move:                      if (this.isLeftButtonDown && this.IsMouseCaptured)                      {                          this.IsPressed = this.HitTest(gesture.Point);                      }                        break;              }
Missing Default,RedBadger.Xpf.Internal.Controls,Viewbox,C:\research\architectureSmells\repos\redbadger_XPF\XPF\RedBadger.Xpf\Internal\Controls\Viewbox.cs,ComputeScaleFactor,The following switch statement is missing a default case: switch (stretch)                  {                      case Stretch.Uniform:                          scaleX = scaleY = (scaleX < scaleY) ? scaleX : scaleY;                          break;                        case Stretch.UniformToFill:                          scaleX = scaleY = (scaleX > scaleY) ? scaleX : scaleY;                          break;                  }
Missing Default,RedBadger.Xpf.Internal.Controls,Viewbox,C:\research\architectureSmells\repos\redbadger_XPF\XPF\RedBadger.Xpf\Internal\Controls\Viewbox.cs,ComputeScaleFactor,The following switch statement is missing a default case: switch (stretchDirection)              {                  case StretchDirection.UpOnly:                      if (scaleX < 1.0)                      {                          scaleX = 1.0;                      }                        if (scaleY < 1.0)                      {                          scaleY = 1.0;                      }                        break;                    case StretchDirection.DownOnly:                      if (scaleX > 1.0)                      {                          scaleX = 1.0;                      }                        if (scaleY > 1.0)                      {                          scaleY = 1.0;                      }                        break;              }
Missing Default,RedBadger.Xpf,UIElement,C:\research\architectureSmells\repos\redbadger_XPF\XPF\RedBadger.Xpf\UIElement.cs,ComputeAlignmentOffset,The following switch statement is missing a default case: switch (horizontalAlignment)              {                  case HorizontalAlignment.Center:                  case HorizontalAlignment.Stretch:                      vector.X = (clientSize.Width - inkSize.Width) * 0.5;                      break;                  case HorizontalAlignment.Left:                      vector.X = 0;                      break;                  case HorizontalAlignment.Right:                      vector.X = clientSize.Width - inkSize.Width;                      break;              }
Missing Default,RedBadger.Xpf,UIElement,C:\research\architectureSmells\repos\redbadger_XPF\XPF\RedBadger.Xpf\UIElement.cs,ComputeAlignmentOffset,The following switch statement is missing a default case: switch (verticalAlignment)              {                  case VerticalAlignment.Center:                  case VerticalAlignment.Stretch:                      vector.Y = (clientSize.Height - inkSize.Height) * 0.5;                      return vector;                  case VerticalAlignment.Bottom:                      vector.Y = clientSize.Height - inkSize.Height;                      return vector;                  case VerticalAlignment.Top:                      vector.Y = 0;                      break;              }
Missing Default,RedBadger.Xpf.Controls,ItemsControl,C:\research\architectureSmells\repos\redbadger_XPF\XPF\RedBadger.Xpf\Controls\ItemsControl.cs,OnNextItemChange,The following switch statement is missing a default case: switch (eventData.EventArgs.Action)              {                  case NotifyCollectionChangedAction.Add:                      foreach (object newItem in eventData.EventArgs.NewItems)                      {                          children.Add(newItem' this.ItemTemplate);                      }                        break;                  case NotifyCollectionChangedAction.Remove:                      {                          int startingIndex = eventData.EventArgs.OldStartingIndex;                          for (int index = startingIndex;                               index < startingIndex + eventData.EventArgs.OldItems.Count;                               index++)                          {                              children.RemoveAt(index);                          }                            break;                      }                    case NotifyCollectionChangedAction.Replace:                      {                          int startingIndex = eventData.EventArgs.NewStartingIndex;                            foreach (object newItem in eventData.EventArgs.NewItems)                          {                              this.ItemsPanel.Children.RemoveAt(startingIndex);                              children.Insert(startingIndex' newItem' this.ItemTemplate);                              startingIndex++;                          }                            break;                      }    #if !WINDOWS_PHONE                  case NotifyCollectionChangedAction.Move:                      children.Move(eventData.EventArgs.OldStartingIndex' eventData.EventArgs.NewStartingIndex);                        break;  #endif                  case NotifyCollectionChangedAction.Reset:                      this.PopulatePanelFromItemsSource();                      break;              }
Missing Default,RedBadger.Xpf.Controls,ScrollViewer,C:\research\architectureSmells\repos\redbadger_XPF\XPF\RedBadger.Xpf\Controls\ScrollViewer.cs,OnNextGesture,The following switch statement is missing a default case: switch (gesture.Type)              {                  case GestureType.LeftButtonDown:                      this.CaptureMouse();                      break;                  case GestureType.FreeDrag:                      if (this.scrollInfo != null && this.IsMouseCaptured)                      {                          this.scrollInfo.SetHorizontalOffset(this.scrollInfo.Offset.X - gesture.Delta.X);                          this.scrollInfo.SetVerticalOffset(this.scrollInfo.Offset.Y - gesture.Delta.Y);                      }                        break;                  case GestureType.LeftButtonUp:                      if (this.IsMouseCaptured)                      {                          this.ReleaseMouseCapture();                      }                        break;              }
Missing Default,RedBadger.Xpf.Controls,Grid,C:\research\architectureSmells\repos\redbadger_XPF\XPF\RedBadger.Xpf\Controls\Grid.cs,AllocateProportionalSpace,The following switch statement is missing a default case: switch (definition.LengthType)                  {                      case GridUnitType.Auto:                          occupiedLength += definition.MinLength;                          break;                      case GridUnitType.Pixel:                          occupiedLength += definition.AvailableLength;                          break;                      case GridUnitType.Star:                          double numerator = definition.UserLength.Value;                          if (numerator.IsCloseTo(0d))                          {                              definition.Numerator = 0d;                              definition.StarAllocationOrder = 0d;                          }                          else                          {                              definition.Numerator = numerator;                              definition.StarAllocationOrder = Math.Max(definition.MinLength' definition.UserMaxLength) /                                                               numerator;                          }                            stars.AddLast(definition);                          break;                  }
Missing Default,RedBadger.Xpf.Controls,Grid,C:\research\architectureSmells\repos\redbadger_XPF\XPF\RedBadger.Xpf\Controls\Grid.cs,SetFinalLength,The following switch statement is missing a default case: switch (definition.UserLength.GridUnitType)                  {                      case GridUnitType.Auto:                          minLength = definition.MinLength;                            definition.FinalLength = minLength.Coerce(definition.MinLength' definition.UserMaxLength);                            occupiedLength += definition.FinalLength;                          nonStarDefinitions.AddFirst(definition);                          break;                      case GridUnitType.Pixel:                          minLength = definition.UserLength.Value;                            definition.FinalLength = minLength.Coerce(definition.MinLength' definition.UserMaxLength);                            occupiedLength += definition.FinalLength;                          nonStarDefinitions.AddFirst(definition);                          break;                      case GridUnitType.Star:                          double numerator = definition.UserLength.Value;                          if (numerator.IsCloseTo(0d))                          {                              definition.Numerator = 0d;                              definition.StarAllocationOrder = 0d;                          }                          else                          {                              definition.Numerator = numerator;                              definition.StarAllocationOrder = Math.Max(definition.MinLength' definition.UserMaxLength) /                                                               numerator;                          }                            stars.AddLast(definition);                          break;                  }
Missing Default,RedBadger.Xpf.Controls,Grid,C:\research\architectureSmells\repos\redbadger_XPF\XPF\RedBadger.Xpf\Controls\Grid.cs,InitializeMeasureData,The following switch statement is missing a default case: switch (definition.UserLength.GridUnitType)                  {                      case GridUnitType.Auto:                          definition.LengthType = GridUnitType.Auto;                          availableLength = double.PositiveInfinity;                          this.hasAuto[(int)dimension] = true;                          break;                      case GridUnitType.Pixel:                          definition.LengthType = GridUnitType.Pixel;                          availableLength = definition.UserLength.Value;                          userMinLength = availableLength.Coerce(userMinLength' userMaxLength);                          break;                      case GridUnitType.Star:                          definition.LengthType = treatStarAsAuto ? GridUnitType.Auto : GridUnitType.Star;                          availableLength = double.PositiveInfinity;                          this.hasStar[(int)dimension] = true;                          break;                  }
