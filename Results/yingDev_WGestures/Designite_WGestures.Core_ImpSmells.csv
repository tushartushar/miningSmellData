Implementation smell,Namespace,Class,File,Method,Description
Long Method,WGestures.Core.Impl.Windows,EdgeInteractDetector,C:\repos\yingDev_WGestures\WGestures.Core\Impl\Windows\ScreenEdgeInteractDetector.cs,DetectCollide,The method has 110 lines of code.
Long Method,WGestures.Core.Impl.Windows,TouchHook,C:\repos\yingDev_WGestures\WGestures.Core\Impl\Windows\TouchHook.cs,Install,The method has 119 lines of code.
Long Method,WGestures.Core.Impl.Windows,Win32MousePathTracker2,C:\repos\yingDev_WGestures\WGestures.Core\Impl\Windows\Win32MousePathTracker2.cs,MouseHookProc,The method has 169 lines of code.
Complex Method,WGestures.Core.Commands.Impl,HotKeyCommand,C:\repos\yingDev_WGestures\WGestures.Core\Commands\Impl\HotKeyCommand.cs,Execute,Cyclomatic complexity of the method is 10
Complex Method,WGestures.Core.Commands.Impl,HotKeyCommand,C:\repos\yingDev_WGestures\WGestures.Core\Commands\Impl\HotKeyCommand.cs,HotKeyToString,Cyclomatic complexity of the method is 8
Complex Method,WGestures.Core,GestureParser,C:\repos\yingDev_WGestures\WGestures.Core\GestureParser.cs,PathTrackerOnPathEnd,Cyclomatic complexity of the method is 8
Complex Method,WGestures.Core,GestureParser,C:\repos\yingDev_WGestures\WGestures.Core\GestureParser.cs,PathTrackerOnPathModifier,Cyclomatic complexity of the method is 9
Complex Method,WGestures.Core.Impl.Windows,Win32MousePathTracker2,C:\repos\yingDev_WGestures\WGestures.Core\Impl\Windows\Win32MousePathTracker2.cs,OnMouseMove,Cyclomatic complexity of the method is 13
Long Parameter List,WGestures.Core.Impl.Windows,TouchHook,C:\repos\yingDev_WGestures\WGestures.Core\Impl\Windows\TouchHook.cs,MakePointerTouchInfo,The method has 6 parameters. Parameters: x' y' radius' id' orientation' pressure
Long Parameter List,WGestures.Core.Impl.Windows,MouseHookEventArgs,C:\repos\yingDev_WGestures\WGestures.Core\Impl\Windows\MouseHook.cs,MouseHookEventArgs,The method has 5 parameters. Parameters: msg' x' y' wParam' lParam
Long Identifier,WGestures.Core,GestureParser,C:\repos\yingDev_WGestures\WGestures.Core\GestureParser.cs,,The length of the parameter _gestureCapturedEventHandlerContexts is 36.
Long Statement,WGestures.Core.Commands.Impl,SearchBox,C:\repos\yingDev_WGestures\WGestures.Core\Commands\Impl\SearchBox.cs,InitializeComponent,The length of the statement  "            this.txt_content.Font = new System.Drawing.Font("Microsoft YaHei"' 12F' System.Drawing.FontStyle.Regular' System.Drawing.GraphicsUnit.Point' ((byte)(134))); " is 156.
Long Statement,WGestures.Core.Commands.Impl,SearchBox,C:\repos\yingDev_WGestures\WGestures.Core\Commands\Impl\SearchBox.cs,InitializeComponent,The length of the statement  "            this.button1.Font = new System.Drawing.Font("SimSun"' 12F' System.Drawing.FontStyle.Regular' System.Drawing.GraphicsUnit.Point' ((byte)(134))); " is 143.
Long Statement,WGestures.Core.Commands.Impl,SearchBox,C:\repos\yingDev_WGestures\WGestures.Core\Commands\Impl\SearchBox.cs,InitializeComponent,The length of the statement  "            this.label1.Font = new System.Drawing.Font("SimSun"' 14.25F' System.Drawing.FontStyle.Regular' System.Drawing.GraphicsUnit.Point' ((byte)(134))); " is 145.
Long Statement,WGestures.Core.Commands.Impl,WebSearchCommand,C:\repos\yingDev_WGestures\WGestures.Core\Commands\Impl\WebSearchCommand.cs,GetDefaultBrowserPath,The length of the statement  "            using (var key = Registry.CurrentUser.OpenSubKey("Software\\Microsoft\\Windows\\Shell\\Associations\\UrlAssociations\\http\\UserChoice")) " is 137.
Long Statement,WGestures.Core.Commands.Impl,WindowControlCommand,C:\repos\yingDev_WGestures\WGestures.Core\Commands\Impl\WindowControlCommand.cs,DoOperation,The length of the statement  "                        else if (topLevelWin != rootWin && (long) User32.WS.WS_MINIMIZEBOX == (topLevelWinstyle & (long) User32.WS.WS_MINIMIZEBOX)) " is 123.
Long Statement,WGestures.Core,GestureParser,C:\repos\yingDev_WGestures\WGestures.Core\GestureParser.cs,Parse,The length of the statement  "                                if (GetAngle(new Point(_firstStrokeEndPoint.X - args.Context.StartPoint.X' _firstStrokeEndPoint.Y - args.Context.StartPoint.X)' " is 127.
Long Statement,WGestures.Core.Impl.Windows,EdgeInteractDetector,C:\repos\yingDev_WGestures\WGestures.Core\Impl\Windows\ScreenEdgeInteractDetector.cs,DetectCollide,The length of the statement  "                else if (e.Pos.X >= _screenBounds.Width - edgeThick && (e.Pos.Y < _screenBounds.Height - cornerExcludeDist && e.Pos.Y > cornerExcludeDist)) " is 139.
Long Statement,WGestures.Core.Impl.Windows,EdgeInteractDetector,C:\repos\yingDev_WGestures\WGestures.Core\Impl\Windows\ScreenEdgeInteractDetector.cs,DetectCollide,The length of the statement  "                else if (e.Pos.Y >= _screenBounds.Height - edgeThick && (e.Pos.X < _screenBounds.Width - cornerExcludeDist && e.Pos.X > cornerExcludeDist)) " is 139.
Long Statement,WGestures.Core.Impl.Windows,EdgeInteractDetector,C:\repos\yingDev_WGestures\WGestures.Core\Impl\Windows\ScreenEdgeInteractDetector.cs,DetectRub,The length of the statement  "                    if (GetDistToEdge(_activeRubEdge.Value' p) >= RED_LINE_DIST || DateTime.UtcNow - _lastRubTriggerTime > TimeSpan.FromMilliseconds(TRIGGER_INTERVAL)) " is 147.
Long Statement,WGestures.Core.Impl.Windows,TouchHook,C:\repos\yingDev_WGestures\WGestures.Core\Impl\Windows\TouchHook.cs,Install,The length of the statement  "                    var MSG = new Message() { HWnd = msg.hwnd' LParam = msg.lParam' WParam = msg.wParam' Msg = (int)msg.message' Result = IntPtr.Zero }; " is 132.
Long Statement,WGestures.Core.Impl.Windows,Win32MousePathTracker2,C:\repos\yingDev_WGestures\WGestures.Core\Impl\Windows\Win32MousePathTracker2.cs,MouseHookProc,The length of the statement  "                        GestureModifier gestMod;// = m == MouseMsg.WM_RBUTTONDOWN ? GestureModifier.RightButtonDown : GestureModifier.MiddleButtonDown; " is 127.
Long Statement,WGestures.Core.Impl.Windows,Win32MousePathTracker2,C:\repos\yingDev_WGestures\WGestures.Core\Impl\Windows\Win32MousePathTracker2.cs,MouseHookProc,The length of the statement  "                    else if (DateTime.UtcNow - _modifierEventHappendPrevTime < TimeSpan.FromMilliseconds(300))//延迟一下，因为 中键手势 + 滚动，可能导致快捷键还没结束，而滚轮事件发送到了目标窗口，可鞥解释成其他功能（比如ctrl + 滚轮 = 缩放） " is 163.
Long Statement,WGestures.Core.Persistence.Impl,JsonGestureIntentStore,C:\repos\yingDev_WGestures\WGestures.Core\Persistence\Impl\JsonGestureIntentStore.cs,Deserialize,The length of the statement  "            var wrapperRef = (ISerializeWrapper)deserializeDomain.CreateInstanceAndUnwrap("SerializeWrapper"' "SerializeWrapper.SerializeWrapper"); " is 135.
Long Statement,WGestures.Core.Persistence.Impl,JsonGestureIntentStore,C:\repos\yingDev_WGestures\WGestures.Core\Persistence\Impl\JsonGestureIntentStore.cs,Serialize,The length of the statement  "                    ser.Serialize(writer'new SerializeWrapper(){Apps = Apps' FileVersion = FileVersion' Global = GlobalApp' HotCornerCommands = HotCornerCommands}); " is 144.
Long Statement,WGestures.Core.Persistence.Impl,JsonGestureIntentStore,C:\repos\yingDev_WGestures\WGestures.Core\Persistence\Impl\JsonGestureIntentStore.cs,Serialize,The length of the statement  "            var wrapperRef = (ISerializeWrapper)serializeDomain.CreateInstanceAndUnwrap("SerializeWrapper"' "SerializeWrapper.SerializeWrapper"); " is 133.
Complex Conditional,WGestures.Core.Commands.Impl,HotKeyCommand,C:\repos\yingDev_WGestures\WGestures.Core\Commands\Impl\HotKeyCommand.cs,Execute,The conditional expression  "Keys.Count == 1 && (Keys[0] == VirtualKeyCode.VK_L) &&                  Modifiers.Count == 1 && (Modifiers[0] == VirtualKeyCode.LWIN || Modifiers[0] == VirtualKeyCode.RWIN)"  is complex.
Complex Conditional,WGestures.Core,GestureParser,C:\repos\yingDev_WGestures\WGestures.Core\GestureParser.cs,Get8DirectionDir,The conditional expression  "nIsEven && (mod > 45 - slashRange / 2) || !nIsEven && (mod > 45 + slashRange / 2)"  is complex.
Complex Conditional,WGestures.Core.Impl.Windows,Win32MousePathTracker2,C:\repos\yingDev_WGestures\WGestures.Core\Impl\Windows\Win32MousePathTracker2.cs,MouseHookProc,The conditional expression  "m == MouseMsg.WM_MBUTTONDOWN && (TriggerButton & GestureTriggerButton.Middle) == 0                              || m == MouseMsg.WM_RBUTTONDOWN && (TriggerButton & GestureTriggerButton.Right) == 0                              || m == MouseMsg.WM_XBUTTONDOWN && (TriggerButton & GestureTriggerButton.X) == 0"  is complex.
Complex Conditional,WGestures.Core.Impl.Windows,Win32MousePathTracker2,C:\repos\yingDev_WGestures\WGestures.Core\Impl\Windows\Win32MousePathTracker2.cs,IsInFullScreenMode,The conditional expression  "classNameStr == "WorkerW" || //桌面窗口                      classNameStr == "CanvasWindow" ||                      classNameStr == "ImmersiveLauncher" || //win8 开始屏幕                      classNameStr == "Windows.UI.Core.CoreWindow""  is complex.
Empty Catch Block,WGestures.Core.Commands.Impl,CmdCommand,C:\repos\yingDev_WGestures\WGestures.Core\Commands\Impl\CmdCommand.cs,Execute,The method has an empty catch block.
Empty Catch Block,WGestures.Core.Commands.Impl,WebSearchCommand,C:\repos\yingDev_WGestures\WGestures.Core\Commands\Impl\WebSearchCommand.cs,GetDefaultBrowserPath,The method has an empty catch block.
Magic Number,WGestures.Core.Commands.Impl,CmdCommand,C:\repos\yingDev_WGestures\WGestures.Core\Commands\Impl\CmdCommand.cs,Description,The following statement contains a magic number: if(Code != null)              {                  var lines = Code.Split(new string[] { Environment.NewLine }' StringSplitOptions.RemoveEmptyEntries);                    if(lines.Length > 0)                  {                      var regex = new Regex(@"^(::|rem )(.*)");                      var matches = regex.Matches(lines[0].Trim());                      if(matches.Count > 0)                      {                          var msg = matches[0].Groups[2].Value.Trim();                          if (msg.Length > 8) msg = msg.Substring(0' 8);                          if (msg.Length > 0)                          {                              return msg;                          }                      }                                        }                }
Magic Number,WGestures.Core.Commands.Impl,CmdCommand,C:\repos\yingDev_WGestures\WGestures.Core\Commands\Impl\CmdCommand.cs,Description,The following statement contains a magic number: if(Code != null)              {                  var lines = Code.Split(new string[] { Environment.NewLine }' StringSplitOptions.RemoveEmptyEntries);                    if(lines.Length > 0)                  {                      var regex = new Regex(@"^(::|rem )(.*)");                      var matches = regex.Matches(lines[0].Trim());                      if(matches.Count > 0)                      {                          var msg = matches[0].Groups[2].Value.Trim();                          if (msg.Length > 8) msg = msg.Substring(0' 8);                          if (msg.Length > 0)                          {                              return msg;                          }                      }                                        }                }
Magic Number,WGestures.Core.Commands.Impl,CmdCommand,C:\repos\yingDev_WGestures\WGestures.Core\Commands\Impl\CmdCommand.cs,Description,The following statement contains a magic number: if(Code != null)              {                  var lines = Code.Split(new string[] { Environment.NewLine }' StringSplitOptions.RemoveEmptyEntries);                    if(lines.Length > 0)                  {                      var regex = new Regex(@"^(::|rem )(.*)");                      var matches = regex.Matches(lines[0].Trim());                      if(matches.Count > 0)                      {                          var msg = matches[0].Groups[2].Value.Trim();                          if (msg.Length > 8) msg = msg.Substring(0' 8);                          if (msg.Length > 0)                          {                              return msg;                          }                      }                                        }                }
Magic Number,WGestures.Core.Commands.Impl,HotKeyCommand,C:\repos\yingDev_WGestures\WGestures.Core\Commands\Impl\HotKeyCommand.cs,PerformKey,The following statement contains a magic number: Thread.Sleep(10);
Magic Number,WGestures.Core.Commands.Impl,HotKeyCommand,C:\repos\yingDev_WGestures\WGestures.Core\Commands\Impl\HotKeyCommand.cs,ForceWindowIntoForeground,The following statement contains a magic number: const uint LSFW_UNLOCK = 2;
Magic Number,WGestures.Core.Commands.Impl,HotKeyCommand,C:\repos\yingDev_WGestures\WGestures.Core\Commands\Impl\HotKeyCommand.cs,HotKeyToString,The following statement contains a magic number: if (keys.Count != 0 || modifiers.Count != 0)              {                  var sb = new StringBuilder(32);                  foreach (var k in modifiers)                  {                      string str = "";                      switch (k)                      {                          case VirtualKeyCode.MENU:                          case VirtualKeyCode.RMENU:                          case VirtualKeyCode.LMENU:                              str = "Alt";                              break;                          case VirtualKeyCode.LCONTROL:                          case VirtualKeyCode.RCONTROL:                          case VirtualKeyCode.CONTROL:                              str = "Ctrl";                              break;                          case VirtualKeyCode.RWIN:                          case VirtualKeyCode.LWIN:                              str = "Win";                              break;                          case VirtualKeyCode.SHIFT:                          case VirtualKeyCode.LSHIFT:                          case VirtualKeyCode.RSHIFT:                              str = "Shift";                              break;                          default:                              str = k.ToString();                              break;                      }                      if(sb.Length > 0) sb.Append('-');                      sb.Append(str);                  }                    if(sb.Length > 0) sb.Append(" + ");                    foreach (var k in keys)                  {                      string str = k.ToString();                      if (str.StartsWith("VK_")) str = str.Substring(3);                        sb.Append(str);                      sb.Append(" + ");                  }                      sb.Remove(sb.Length - 3' 3);                  return sb.ToString();              }
Magic Number,WGestures.Core.Commands.Impl,HotKeyCommand,C:\repos\yingDev_WGestures\WGestures.Core\Commands\Impl\HotKeyCommand.cs,HotKeyToString,The following statement contains a magic number: if (keys.Count != 0 || modifiers.Count != 0)              {                  var sb = new StringBuilder(32);                  foreach (var k in modifiers)                  {                      string str = "";                      switch (k)                      {                          case VirtualKeyCode.MENU:                          case VirtualKeyCode.RMENU:                          case VirtualKeyCode.LMENU:                              str = "Alt";                              break;                          case VirtualKeyCode.LCONTROL:                          case VirtualKeyCode.RCONTROL:                          case VirtualKeyCode.CONTROL:                              str = "Ctrl";                              break;                          case VirtualKeyCode.RWIN:                          case VirtualKeyCode.LWIN:                              str = "Win";                              break;                          case VirtualKeyCode.SHIFT:                          case VirtualKeyCode.LSHIFT:                          case VirtualKeyCode.RSHIFT:                              str = "Shift";                              break;                          default:                              str = k.ToString();                              break;                      }                      if(sb.Length > 0) sb.Append('-');                      sb.Append(str);                  }                    if(sb.Length > 0) sb.Append(" + ");                    foreach (var k in keys)                  {                      string str = k.ToString();                      if (str.StartsWith("VK_")) str = str.Substring(3);                        sb.Append(str);                      sb.Append(" + ");                  }                      sb.Remove(sb.Length - 3' 3);                  return sb.ToString();              }
Magic Number,WGestures.Core.Commands.Impl,HotKeyCommand,C:\repos\yingDev_WGestures\WGestures.Core\Commands\Impl\HotKeyCommand.cs,HotKeyToString,The following statement contains a magic number: if (keys.Count != 0 || modifiers.Count != 0)              {                  var sb = new StringBuilder(32);                  foreach (var k in modifiers)                  {                      string str = "";                      switch (k)                      {                          case VirtualKeyCode.MENU:                          case VirtualKeyCode.RMENU:                          case VirtualKeyCode.LMENU:                              str = "Alt";                              break;                          case VirtualKeyCode.LCONTROL:                          case VirtualKeyCode.RCONTROL:                          case VirtualKeyCode.CONTROL:                              str = "Ctrl";                              break;                          case VirtualKeyCode.RWIN:                          case VirtualKeyCode.LWIN:                              str = "Win";                              break;                          case VirtualKeyCode.SHIFT:                          case VirtualKeyCode.LSHIFT:                          case VirtualKeyCode.RSHIFT:                              str = "Shift";                              break;                          default:                              str = k.ToString();                              break;                      }                      if(sb.Length > 0) sb.Append('-');                      sb.Append(str);                  }                    if(sb.Length > 0) sb.Append(" + ");                    foreach (var k in keys)                  {                      string str = k.ToString();                      if (str.StartsWith("VK_")) str = str.Substring(3);                        sb.Append(str);                      sb.Append(" + ");                  }                      sb.Remove(sb.Length - 3' 3);                  return sb.ToString();              }
Magic Number,WGestures.Core.Commands.Impl,HotKeyCommand,C:\repos\yingDev_WGestures\WGestures.Core\Commands\Impl\HotKeyCommand.cs,HotKeyToString,The following statement contains a magic number: if (keys.Count != 0 || modifiers.Count != 0)              {                  var sb = new StringBuilder(32);                  foreach (var k in modifiers)                  {                      string str = "";                      switch (k)                      {                          case VirtualKeyCode.MENU:                          case VirtualKeyCode.RMENU:                          case VirtualKeyCode.LMENU:                              str = "Alt";                              break;                          case VirtualKeyCode.LCONTROL:                          case VirtualKeyCode.RCONTROL:                          case VirtualKeyCode.CONTROL:                              str = "Ctrl";                              break;                          case VirtualKeyCode.RWIN:                          case VirtualKeyCode.LWIN:                              str = "Win";                              break;                          case VirtualKeyCode.SHIFT:                          case VirtualKeyCode.LSHIFT:                          case VirtualKeyCode.RSHIFT:                              str = "Shift";                              break;                          default:                              str = k.ToString();                              break;                      }                      if(sb.Length > 0) sb.Append('-');                      sb.Append(str);                  }                    if(sb.Length > 0) sb.Append(" + ");                    foreach (var k in keys)                  {                      string str = k.ToString();                      if (str.StartsWith("VK_")) str = str.Substring(3);                        sb.Append(str);                      sb.Append(" + ");                  }                      sb.Remove(sb.Length - 3' 3);                  return sb.ToString();              }
Magic Number,WGestures.Core.Commands.Impl,SearchBox,C:\repos\yingDev_WGestures\WGestures.Core\Commands\Impl\SearchBox.cs,InitializeComponent,The following statement contains a magic number: this.txt_content.Font = new System.Drawing.Font("Microsoft YaHei"' 12F' System.Drawing.FontStyle.Regular' System.Drawing.GraphicsUnit.Point' ((byte)(134)));
Magic Number,WGestures.Core.Commands.Impl,SearchBox,C:\repos\yingDev_WGestures\WGestures.Core\Commands\Impl\SearchBox.cs,InitializeComponent,The following statement contains a magic number: this.txt_content.Location = new System.Drawing.Point(12' 12);
Magic Number,WGestures.Core.Commands.Impl,SearchBox,C:\repos\yingDev_WGestures\WGestures.Core\Commands\Impl\SearchBox.cs,InitializeComponent,The following statement contains a magic number: this.txt_content.Location = new System.Drawing.Point(12' 12);
Magic Number,WGestures.Core.Commands.Impl,SearchBox,C:\repos\yingDev_WGestures\WGestures.Core\Commands\Impl\SearchBox.cs,InitializeComponent,The following statement contains a magic number: this.txt_content.Size = new System.Drawing.Size(290' 29);
Magic Number,WGestures.Core.Commands.Impl,SearchBox,C:\repos\yingDev_WGestures\WGestures.Core\Commands\Impl\SearchBox.cs,InitializeComponent,The following statement contains a magic number: this.txt_content.Size = new System.Drawing.Size(290' 29);
Magic Number,WGestures.Core.Commands.Impl,SearchBox,C:\repos\yingDev_WGestures\WGestures.Core\Commands\Impl\SearchBox.cs,InitializeComponent,The following statement contains a magic number: this.comboBox1.Location = new System.Drawing.Point(308' 16);
Magic Number,WGestures.Core.Commands.Impl,SearchBox,C:\repos\yingDev_WGestures\WGestures.Core\Commands\Impl\SearchBox.cs,InitializeComponent,The following statement contains a magic number: this.comboBox1.Location = new System.Drawing.Point(308' 16);
Magic Number,WGestures.Core.Commands.Impl,SearchBox,C:\repos\yingDev_WGestures\WGestures.Core\Commands\Impl\SearchBox.cs,InitializeComponent,The following statement contains a magic number: this.comboBox1.Margin = new System.Windows.Forms.Padding(3' 3' 0' 3);
Magic Number,WGestures.Core.Commands.Impl,SearchBox,C:\repos\yingDev_WGestures\WGestures.Core\Commands\Impl\SearchBox.cs,InitializeComponent,The following statement contains a magic number: this.comboBox1.Margin = new System.Windows.Forms.Padding(3' 3' 0' 3);
Magic Number,WGestures.Core.Commands.Impl,SearchBox,C:\repos\yingDev_WGestures\WGestures.Core\Commands\Impl\SearchBox.cs,InitializeComponent,The following statement contains a magic number: this.comboBox1.Margin = new System.Windows.Forms.Padding(3' 3' 0' 3);
Magic Number,WGestures.Core.Commands.Impl,SearchBox,C:\repos\yingDev_WGestures\WGestures.Core\Commands\Impl\SearchBox.cs,InitializeComponent,The following statement contains a magic number: this.comboBox1.Size = new System.Drawing.Size(55' 20);
Magic Number,WGestures.Core.Commands.Impl,SearchBox,C:\repos\yingDev_WGestures\WGestures.Core\Commands\Impl\SearchBox.cs,InitializeComponent,The following statement contains a magic number: this.comboBox1.Size = new System.Drawing.Size(55' 20);
Magic Number,WGestures.Core.Commands.Impl,SearchBox,C:\repos\yingDev_WGestures\WGestures.Core\Commands\Impl\SearchBox.cs,InitializeComponent,The following statement contains a magic number: this.button1.Font = new System.Drawing.Font("SimSun"' 12F' System.Drawing.FontStyle.Regular' System.Drawing.GraphicsUnit.Point' ((byte)(134)));
Magic Number,WGestures.Core.Commands.Impl,SearchBox,C:\repos\yingDev_WGestures\WGestures.Core\Commands\Impl\SearchBox.cs,InitializeComponent,The following statement contains a magic number: this.button1.Location = new System.Drawing.Point(401' 12);
Magic Number,WGestures.Core.Commands.Impl,SearchBox,C:\repos\yingDev_WGestures\WGestures.Core\Commands\Impl\SearchBox.cs,InitializeComponent,The following statement contains a magic number: this.button1.Location = new System.Drawing.Point(401' 12);
Magic Number,WGestures.Core.Commands.Impl,SearchBox,C:\repos\yingDev_WGestures\WGestures.Core\Commands\Impl\SearchBox.cs,InitializeComponent,The following statement contains a magic number: this.button1.Size = new System.Drawing.Size(66' 29);
Magic Number,WGestures.Core.Commands.Impl,SearchBox,C:\repos\yingDev_WGestures\WGestures.Core\Commands\Impl\SearchBox.cs,InitializeComponent,The following statement contains a magic number: this.button1.Size = new System.Drawing.Size(66' 29);
Magic Number,WGestures.Core.Commands.Impl,SearchBox,C:\repos\yingDev_WGestures\WGestures.Core\Commands\Impl\SearchBox.cs,InitializeComponent,The following statement contains a magic number: this.button1.TabIndex = 2;
Magic Number,WGestures.Core.Commands.Impl,SearchBox,C:\repos\yingDev_WGestures\WGestures.Core\Commands\Impl\SearchBox.cs,InitializeComponent,The following statement contains a magic number: this.label1.Font = new System.Drawing.Font("SimSun"' 14.25F' System.Drawing.FontStyle.Regular' System.Drawing.GraphicsUnit.Point' ((byte)(134)));
Magic Number,WGestures.Core.Commands.Impl,SearchBox,C:\repos\yingDev_WGestures\WGestures.Core\Commands\Impl\SearchBox.cs,InitializeComponent,The following statement contains a magic number: this.label1.Location = new System.Drawing.Point(364' 12);
Magic Number,WGestures.Core.Commands.Impl,SearchBox,C:\repos\yingDev_WGestures\WGestures.Core\Commands\Impl\SearchBox.cs,InitializeComponent,The following statement contains a magic number: this.label1.Location = new System.Drawing.Point(364' 12);
Magic Number,WGestures.Core.Commands.Impl,SearchBox,C:\repos\yingDev_WGestures\WGestures.Core\Commands\Impl\SearchBox.cs,InitializeComponent,The following statement contains a magic number: this.label1.Margin = new System.Windows.Forms.Padding(0' 0' 3' 0);
Magic Number,WGestures.Core.Commands.Impl,SearchBox,C:\repos\yingDev_WGestures\WGestures.Core\Commands\Impl\SearchBox.cs,InitializeComponent,The following statement contains a magic number: this.label1.Size = new System.Drawing.Size(19' 29);
Magic Number,WGestures.Core.Commands.Impl,SearchBox,C:\repos\yingDev_WGestures\WGestures.Core\Commands\Impl\SearchBox.cs,InitializeComponent,The following statement contains a magic number: this.label1.Size = new System.Drawing.Size(19' 29);
Magic Number,WGestures.Core.Commands.Impl,SearchBox,C:\repos\yingDev_WGestures\WGestures.Core\Commands\Impl\SearchBox.cs,InitializeComponent,The following statement contains a magic number: this.label1.TabIndex = 3;
Magic Number,WGestures.Core.Commands.Impl,SearchBox,C:\repos\yingDev_WGestures\WGestures.Core\Commands\Impl\SearchBox.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size(479' 54);
Magic Number,WGestures.Core.Commands.Impl,SearchBox,C:\repos\yingDev_WGestures\WGestures.Core\Commands\Impl\SearchBox.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size(479' 54);
Magic Number,WGestures.Core.Commands.Impl,TaskSwitcherCommand,C:\repos\yingDev_WGestures\WGestures.Core\Commands\Impl\TaskSwitcherCommand.cs,Execute,The following statement contains a magic number: try              {                  Sim.KeyDown(VirtualKeyCode.LMENU);                    //Thread.Sleep(50);                  Sim.KeyDown(VirtualKeyCode.TAB);                    //如果不延迟，foxitreader等ctrl+C可能失效！                  Thread.Sleep(20);                    Sim.KeyUp(VirtualKeyCode.TAB);                    Sim.KeyUp(VirtualKeyCode.LMENU);              }              catch (Exception ex)              {                  Debug.WriteLine("发送alt + tab失败: " + ex);                  TryRecoverAltTab();  #if TEST                  throw;  #endif              }
Magic Number,WGestures.Core.Commands.Impl,WebSearchCommand,C:\repos\yingDev_WGestures\WGestures.Core\Commands\Impl\WebSearchCommand.cs,Execute,The following statement contains a magic number: var t = new Thread(() =>              {                    var clipboardMonitor = new ClipboardMonitor();                    clipboardMonitor.MonitorRegistered += () =>                  {                      var timer = new Timer() { Interval = 2000 };                      timer.Tick += (sender' args) =>                      {                          Debug.WriteLine("WebSearchCommand Timeout!");                          timer.Enabled = false;                            clipboardMonitor.StopMonitor();                          clipboardMonitor.DestroyHandle();                          Application.ExitThread();                                                    Debug.WriteLine("超时结束 WebSearchCommand Runloop");                        };                        timer.Enabled = true;                        try                      {                          Sim.KeyDown(VirtualKeyCode.CONTROL);                          Sim.KeyDown(VirtualKeyCode.VK_C);                                                    Sim.KeyUp(VirtualKeyCode.VK_C);                          Sim.KeyUp(VirtualKeyCode.CONTROL);                          //_sim.Keyboard.ModifiedKeyStroke(VirtualKeyCode.CONTROL' new[] { VirtualKeyCode.VK_C });                      }                      catch (Exception ex)                      {                          Debug.WriteLine("发送按键失败:" + ex);                          Native.TryResetKeys(new []{VirtualKeyCode.CONTROL' VirtualKeyCode.VK_C});  #if DEBUG                          //throw;  #endif                      }                  };                    clipboardMonitor.ClipboardUpdated += args =>                  {                      Debug.WriteLine("ClipboardChanged");                      args.Handled = true;                        var text = "";                      if (Clipboard.ContainsText() && (text = Clipboard.GetText().Trim()).Length > 0)                      {                          var browser = GetDefaultBrowserPath();                          if (UseBrowser != null && File.Exists(UseBrowser.Replace("\""' "")) )                          {                              browser = UseBrowser;                          }                            string urlToOpen;                          //如果是URL则打开，否则搜索                          if (Uri.IsWellFormedUriString(text' UriKind.Absolute))                          {                              urlToOpen = text;                          }                          else                          {                              if (text.Length > 100) text = text.Substring(0' 100);                              urlToOpen = PopulateSearchEngingUrl(text);                          }                          //M$ Edge Hack                          if (browser.Contains("LaunchWinApp.exe"))                          {                              urlToOpen = "microsoft-edge:" + urlToOpen;                              Process.Start(urlToOpen);                          }else                          {                              var startInfo = new ProcessStartInfo(browser' "\"" + urlToOpen + "\"");                              using (Process.Start(startInfo)) ;                          }                      }                        clipboardMonitor.StopMonitor();                      clipboardMonitor.DestroyHandle();                        Application.ExitThread();                  };                    clipboardMonitor.StartMonitor();                    Application.Run();                  Debug.WriteLine("Thread End?");                }) {Name = "WebSearchCommand Runloop(Bug！我不应该存在！)"};
Magic Number,WGestures.Core.Commands.Impl,WebSearchCommand,C:\repos\yingDev_WGestures\WGestures.Core\Commands\Impl\WebSearchCommand.cs,Execute,The following statement contains a magic number: var t = new Thread(() =>              {                    var clipboardMonitor = new ClipboardMonitor();                    clipboardMonitor.MonitorRegistered += () =>                  {                      var timer = new Timer() { Interval = 2000 };                      timer.Tick += (sender' args) =>                      {                          Debug.WriteLine("WebSearchCommand Timeout!");                          timer.Enabled = false;                            clipboardMonitor.StopMonitor();                          clipboardMonitor.DestroyHandle();                          Application.ExitThread();                                                    Debug.WriteLine("超时结束 WebSearchCommand Runloop");                        };                        timer.Enabled = true;                        try                      {                          Sim.KeyDown(VirtualKeyCode.CONTROL);                          Sim.KeyDown(VirtualKeyCode.VK_C);                                                    Sim.KeyUp(VirtualKeyCode.VK_C);                          Sim.KeyUp(VirtualKeyCode.CONTROL);                          //_sim.Keyboard.ModifiedKeyStroke(VirtualKeyCode.CONTROL' new[] { VirtualKeyCode.VK_C });                      }                      catch (Exception ex)                      {                          Debug.WriteLine("发送按键失败:" + ex);                          Native.TryResetKeys(new []{VirtualKeyCode.CONTROL' VirtualKeyCode.VK_C});  #if DEBUG                          //throw;  #endif                      }                  };                    clipboardMonitor.ClipboardUpdated += args =>                  {                      Debug.WriteLine("ClipboardChanged");                      args.Handled = true;                        var text = "";                      if (Clipboard.ContainsText() && (text = Clipboard.GetText().Trim()).Length > 0)                      {                          var browser = GetDefaultBrowserPath();                          if (UseBrowser != null && File.Exists(UseBrowser.Replace("\""' "")) )                          {                              browser = UseBrowser;                          }                            string urlToOpen;                          //如果是URL则打开，否则搜索                          if (Uri.IsWellFormedUriString(text' UriKind.Absolute))                          {                              urlToOpen = text;                          }                          else                          {                              if (text.Length > 100) text = text.Substring(0' 100);                              urlToOpen = PopulateSearchEngingUrl(text);                          }                          //M$ Edge Hack                          if (browser.Contains("LaunchWinApp.exe"))                          {                              urlToOpen = "microsoft-edge:" + urlToOpen;                              Process.Start(urlToOpen);                          }else                          {                              var startInfo = new ProcessStartInfo(browser' "\"" + urlToOpen + "\"");                              using (Process.Start(startInfo)) ;                          }                      }                        clipboardMonitor.StopMonitor();                      clipboardMonitor.DestroyHandle();                        Application.ExitThread();                  };                    clipboardMonitor.StartMonitor();                    Application.Run();                  Debug.WriteLine("Thread End?");                }) {Name = "WebSearchCommand Runloop(Bug！我不应该存在！)"};
Magic Number,WGestures.Core.Commands.Impl,WebSearchCommand,C:\repos\yingDev_WGestures\WGestures.Core\Commands\Impl\WebSearchCommand.cs,Execute,The following statement contains a magic number: var t = new Thread(() =>              {                    var clipboardMonitor = new ClipboardMonitor();                    clipboardMonitor.MonitorRegistered += () =>                  {                      var timer = new Timer() { Interval = 2000 };                      timer.Tick += (sender' args) =>                      {                          Debug.WriteLine("WebSearchCommand Timeout!");                          timer.Enabled = false;                            clipboardMonitor.StopMonitor();                          clipboardMonitor.DestroyHandle();                          Application.ExitThread();                                                    Debug.WriteLine("超时结束 WebSearchCommand Runloop");                        };                        timer.Enabled = true;                        try                      {                          Sim.KeyDown(VirtualKeyCode.CONTROL);                          Sim.KeyDown(VirtualKeyCode.VK_C);                                                    Sim.KeyUp(VirtualKeyCode.VK_C);                          Sim.KeyUp(VirtualKeyCode.CONTROL);                          //_sim.Keyboard.ModifiedKeyStroke(VirtualKeyCode.CONTROL' new[] { VirtualKeyCode.VK_C });                      }                      catch (Exception ex)                      {                          Debug.WriteLine("发送按键失败:" + ex);                          Native.TryResetKeys(new []{VirtualKeyCode.CONTROL' VirtualKeyCode.VK_C});  #if DEBUG                          //throw;  #endif                      }                  };                    clipboardMonitor.ClipboardUpdated += args =>                  {                      Debug.WriteLine("ClipboardChanged");                      args.Handled = true;                        var text = "";                      if (Clipboard.ContainsText() && (text = Clipboard.GetText().Trim()).Length > 0)                      {                          var browser = GetDefaultBrowserPath();                          if (UseBrowser != null && File.Exists(UseBrowser.Replace("\""' "")) )                          {                              browser = UseBrowser;                          }                            string urlToOpen;                          //如果是URL则打开，否则搜索                          if (Uri.IsWellFormedUriString(text' UriKind.Absolute))                          {                              urlToOpen = text;                          }                          else                          {                              if (text.Length > 100) text = text.Substring(0' 100);                              urlToOpen = PopulateSearchEngingUrl(text);                          }                          //M$ Edge Hack                          if (browser.Contains("LaunchWinApp.exe"))                          {                              urlToOpen = "microsoft-edge:" + urlToOpen;                              Process.Start(urlToOpen);                          }else                          {                              var startInfo = new ProcessStartInfo(browser' "\"" + urlToOpen + "\"");                              using (Process.Start(startInfo)) ;                          }                      }                        clipboardMonitor.StopMonitor();                      clipboardMonitor.DestroyHandle();                        Application.ExitThread();                  };                    clipboardMonitor.StartMonitor();                    Application.Run();                  Debug.WriteLine("Thread End?");                }) {Name = "WebSearchCommand Runloop(Bug！我不应该存在！)"};
Magic Number,WGestures.Core.Commands.Impl,WindowControlCommand,C:\repos\yingDev_WGestures\WGestures.Core\Commands\Impl\WindowControlCommand.cs,DoOperation,The following statement contains a magic number: while (true)              {                  //topLevelWin是本进程（？）内的顶层窗口                  //rootWindow可能会跨进程                  var topLevelWin = Native.GetTopLevelWindow(win);                  var rootWin = Native.GetAncestor(topLevelWin' Native.GetAncestorFlags.GetRoot);                    if (rootWin == IntPtr.Zero) return;                    Debug.WriteLine(string.Format("win     : {0:X}"' win.ToInt64()));                  Debug.WriteLine(string.Format("root    : {0:X}"'rootWin.ToInt64()));                  Debug.WriteLine(string.Format("topLevel: {0:X}"' topLevelWin.ToInt64()));                    var rootWinExStyle = User32.GetWindowLong(rootWin' User32.GWL.GWL_EXSTYLE);                  var rootWinStyle = User32.GetWindowLong(rootWin' User32.GWL.GWL_STYLE);                  var topLevelWinstyle = User32.GetWindowLong(topLevelWin' User32.GWL.GWL_STYLE);                    switch (ChangeWindowStateTo)                  {                      case WindowOperation.MAXIMIZE_RESTORE:                          IntPtr winToControl;                          if ((long) User32.WS.WS_MAXIMIZEBOX == (topLevelWinstyle & (long) User32.WS.WS_MAXIMIZEBOX))                          {                              winToControl = topLevelWin;                          }                          else if (topLevelWin != rootWin && (long) User32.WS.WS_MAXIMIZEBOX == (rootWinStyle & (long) User32.WS.WS_MAXIMIZEBOX))                          {                              winToControl = rootWin;                          }                          else //如果窗口都不响应， 考虑回滚为处理活动窗口                          {                              var fgWin = Native.GetForegroundWindow();                              if (fgWin == win) return;                                win = fgWin;                              continue;                          }                            var wp = new User32.WINDOWPLACEMENT();                          wp.length = Marshal.SizeOf(typeof (User32.WINDOWPLACEMENT));                            if (!User32.GetWindowPlacement(rootWin' ref wp)) return;                            if (wp.showCmd == (int) ShowWindowCommands.MAXIMIZED)                          {                              User32.ShowWindowAsync(winToControl' (int) ShowWindowCommands.NORMAL);                          }                          else                          {                              User32.ShowWindowAsync(winToControl' (int) ShowWindowCommands.MAXIMIZED);                          }                          goto end;                        case WindowOperation.MINIMIZE:                          if ((long) User32.WS.WS_MINIMIZEBOX == (rootWinStyle & (long) User32.WS.WS_MINIMIZEBOX))                          {                              User32.PostMessage(rootWin' User32.WM.WM_SYSCOMMAND' (int) User32.SysCommands.SC_MINIMIZE' 0);                          }                          else if (topLevelWin != rootWin && (long) User32.WS.WS_MINIMIZEBOX == (topLevelWinstyle & (long) User32.WS.WS_MINIMIZEBOX))                          {                              User32.PostMessage(topLevelWin' User32.WM.WM_SYSCOMMAND' (int) User32.SysCommands.SC_MINIMIZE' 0);                          }                          goto end;                        case WindowOperation.CLOSE:                          User32.PostMessage(rootWin' User32.WM.WM_SYSCOMMAND' (int) User32.SysCommands.SC_CLOSE' 0);                          goto end;                        case WindowOperation.TOP_MOST:                            if ((rootWinExStyle & (int)User32.WS_EX.WS_EX_TOPMOST) != 0)                          {                              User32.SetWindowPos(rootWin' new IntPtr(-2)' 0' 0' 0' 0' User32.SWP.SWP_NOMOVE | User32.SWP.SWP_NOSIZE);                          }                          else                          {                              User32.SetWindowPos(rootWin' new IntPtr(-1)' 0' 0' 0' 0' User32.SWP.SWP_NOMOVE | User32.SWP.SWP_NOSIZE);                          }                                                    goto end;                  }                  break;              }
Magic Number,WGestures.Core,Gesture,C:\repos\yingDev_WGestures\WGestures.Core\Gesture.cs,ToString,The following statement contains a magic number: var sb = new StringBuilder(Count() + 4);
Magic Number,WGestures.Core,Gesture,C:\repos\yingDev_WGestures\WGestures.Core\Gesture.cs,GetHashCode,The following statement contains a magic number: var hash = 19;
Magic Number,WGestures.Core,Gesture,C:\repos\yingDev_WGestures\WGestures.Core\Gesture.cs,GetHashCode,The following statement contains a magic number: hash += hash*31 + GestureButton.GetHashCode();
Magic Number,WGestures.Core,Gesture,C:\repos\yingDev_WGestures\WGestures.Core\Gesture.cs,GetHashCode,The following statement contains a magic number: foreach (var d in Dirs)              {                  hash = hash * 31 + (int)d;              }
Magic Number,WGestures.Core,Gesture,C:\repos\yingDev_WGestures\WGestures.Core\Gesture.cs,GetHashCode,The following statement contains a magic number: hash = hash * 31 + (int)Modifier;
Magic Number,WGestures.Core,GestureParser,C:\repos\yingDev_WGestures\WGestures.Core\GestureParser.cs,GestureParser,The following statement contains a magic number: MaxGestureSteps = 12;
Magic Number,WGestures.Core,GestureParser,C:\repos\yingDev_WGestures\WGestures.Core\GestureParser.cs,Parse,The following statement contains a magic number: if (_pointCount != 0 && args.Location != _lastPoint)              {                  var vector = new Point(args.Location.X - _lastPoint.X' -args.Location.Y + _lastPoint.Y);                  Gesture.GestureDir dir;                    if (Enable8DirGesture)                  {                      var count = _gesture.Count();                      switch (count)                      {                          case 0:                              dir = Get8DirectionDir(vector);                              _lastVector = vector;                              _firstStrokeEndPoint = args.Location;                              break;                          case 1:                              var last = _gesture.Last().Value;                              if ((int)last % 2 == 0) //如果不是斜线                              {                                  dir = Get4DirectionDir(vector);                                  break;                              }                                dir = Get8DirectionDir(vector);                              if (dir != last)                              {                                  if (GetAngle(new Point(_firstStrokeEndPoint.X - args.Context.StartPoint.X' _firstStrokeEndPoint.Y - args.Context.StartPoint.X)'                                      new Point(args.Location.X - _firstStrokeEndPoint.X' args.Location.Y - _firstStrokeEndPoint.Y)) < 36f)                                  {                                      dir = last;                                      break;                                  }                                    dir = Get4DirectionDir(vector);                                    var lastDirShouldBe = Get4DirectionDir(_lastVector);                                    _gesture.Dirs[0] = lastDirShouldBe;                                    gestureChanged = true;                              }                              else                              {                                  //如果依然延续斜线，则记录下最后一个点                                  _firstStrokeEndPoint = args.Location;                              }                              break;                          default:                              dir = Get4DirectionDir(vector);                              break;                      }                  }                  else                  {                      dir = Get4DirectionDir(vector);                  }                                      if (dir != _gesture.Last())                  {                      _gesture.Add(dir);                      gestureChanged = true;                  }                    if (_gesture.Modifier != args.Modifier)                  {                      _gesture.Modifier = args.Modifier;                      gestureChanged = true;                  }              }
Magic Number,WGestures.Core,GestureParser,C:\repos\yingDev_WGestures\WGestures.Core\GestureParser.cs,PathTracker_EdgeRubbed,The following statement contains a magic number: var cmd = IntentFinder.IntentStore.HotCornerCommands[4 + (int)edge];
Magic Number,WGestures.Core,GestureParser,C:\repos\yingDev_WGestures\WGestures.Core\GestureParser.cs,Get8DirectionDir,The following statement contains a magic number: if (vector.X < 0) angle = 360 - angle;
Magic Number,WGestures.Core,GestureParser,C:\repos\yingDev_WGestures\WGestures.Core\GestureParser.cs,Get8DirectionDir,The following statement contains a magic number: var mod = angle % 90;
Magic Number,WGestures.Core,GestureParser,C:\repos\yingDev_WGestures\WGestures.Core\GestureParser.cs,Get8DirectionDir,The following statement contains a magic number: var n = (int)Math.Floor(angle / 45);
Magic Number,WGestures.Core,GestureParser,C:\repos\yingDev_WGestures\WGestures.Core\GestureParser.cs,Get8DirectionDir,The following statement contains a magic number: const float slashRange = 50;
Magic Number,WGestures.Core,GestureParser,C:\repos\yingDev_WGestures\WGestures.Core\GestureParser.cs,Get8DirectionDir,The following statement contains a magic number: if (nIsEven && (mod > 45 - slashRange / 2) || !nIsEven && (mod > 45 + slashRange / 2))              {                  n++;                  if (n == 8) n = 0;              }
Magic Number,WGestures.Core,GestureParser,C:\repos\yingDev_WGestures\WGestures.Core\GestureParser.cs,Get8DirectionDir,The following statement contains a magic number: if (nIsEven && (mod > 45 - slashRange / 2) || !nIsEven && (mod > 45 + slashRange / 2))              {                  n++;                  if (n == 8) n = 0;              }
Magic Number,WGestures.Core,GestureParser,C:\repos\yingDev_WGestures\WGestures.Core\GestureParser.cs,Get8DirectionDir,The following statement contains a magic number: if (nIsEven && (mod > 45 - slashRange / 2) || !nIsEven && (mod > 45 + slashRange / 2))              {                  n++;                  if (n == 8) n = 0;              }
Magic Number,WGestures.Core,GestureParser,C:\repos\yingDev_WGestures\WGestures.Core\GestureParser.cs,Get8DirectionDir,The following statement contains a magic number: if (nIsEven && (mod > 45 - slashRange / 2) || !nIsEven && (mod > 45 + slashRange / 2))              {                  n++;                  if (n == 8) n = 0;              }
Magic Number,WGestures.Core,GestureParser,C:\repos\yingDev_WGestures\WGestures.Core\GestureParser.cs,Get8DirectionDir,The following statement contains a magic number: if (nIsEven && (mod > 45 - slashRange / 2) || !nIsEven && (mod > 45 + slashRange / 2))              {                  n++;                  if (n == 8) n = 0;              }
Magic Number,WGestures.Core,GestureParser,C:\repos\yingDev_WGestures\WGestures.Core\GestureParser.cs,GetAngle,The following statement contains a magic number: if (cosValue < -1 && cosValue > -2)                  cosValue = -1;              else if (cosValue > 1 && cosValue < 2)                  cosValue = 1;
Magic Number,WGestures.Core,GestureParser,C:\repos\yingDev_WGestures\WGestures.Core\GestureParser.cs,GetAngle,The following statement contains a magic number: if (cosValue < -1 && cosValue > -2)                  cosValue = -1;              else if (cosValue > 1 && cosValue < 2)                  cosValue = 1;
Magic Number,WGestures.Core,GestureParser,C:\repos\yingDev_WGestures\WGestures.Core\GestureParser.cs,GetAngle,The following statement contains a magic number: angle = (float)(Math.Acos(cosValue) * 180 / Math.PI);
Magic Number,WGestures.Core.Impl.Windows,EdgeInteractDetector,C:\repos\yingDev_WGestures\WGestures.Core\Impl\Windows\ScreenEdgeInteractDetector.cs,DetectCollide,The following statement contains a magic number: var redLineDist = 100 * _dpiScale;
Magic Number,WGestures.Core.Impl.Windows,EdgeInteractDetector,C:\repos\yingDev_WGestures\WGestures.Core\Impl\Windows\ScreenEdgeInteractDetector.cs,DetectCollide,The following statement contains a magic number: var minSpeed = 0.3 * _dpiScale;
Magic Number,WGestures.Core.Impl.Windows,EdgeInteractDetector,C:\repos\yingDev_WGestures\WGestures.Core\Impl\Windows\ScreenEdgeInteractDetector.cs,DetectCollide,The following statement contains a magic number: var maxAllowedBias = 100 * _dpiScale;
Magic Number,WGestures.Core.Impl.Windows,EdgeInteractDetector,C:\repos\yingDev_WGestures\WGestures.Core\Impl\Windows\ScreenEdgeInteractDetector.cs,DetectCollide,The following statement contains a magic number: var cornerExcludeDist = 100 * _dpiScale;
Magic Number,WGestures.Core.Impl.Windows,EdgeInteractDetector,C:\repos\yingDev_WGestures\WGestures.Core\Impl\Windows\ScreenEdgeInteractDetector.cs,DetectCollide,The following statement contains a magic number: var edgeThick = 4;
Magic Number,WGestures.Core.Impl.Windows,EdgeInteractDetector,C:\repos\yingDev_WGestures\WGestures.Core\Impl\Windows\ScreenEdgeInteractDetector.cs,DetectRub,The following statement contains a magic number: var MIN_MOVE = 80;
Magic Number,WGestures.Core.Impl.Windows,EdgeInteractDetector,C:\repos\yingDev_WGestures\WGestures.Core\Impl\Windows\ScreenEdgeInteractDetector.cs,DetectRub,The following statement contains a magic number: var RED_LINE_DIST = 50;
Magic Number,WGestures.Core.Impl.Windows,EdgeInteractDetector,C:\repos\yingDev_WGestures\WGestures.Core\Impl\Windows\ScreenEdgeInteractDetector.cs,DetectRub,The following statement contains a magic number: var TRIGGER_INTERVAL = 1500;
Magic Number,WGestures.Core.Impl.Windows,EdgeInteractDetector,C:\repos\yingDev_WGestures\WGestures.Core\Impl\Windows\ScreenEdgeInteractDetector.cs,DetectRub,The following statement contains a magic number: var EDGE_THICK = (int)(16 * _dpiScale);
Magic Number,WGestures.Core.Impl.Windows,EdgeInteractDetector,C:\repos\yingDev_WGestures\WGestures.Core\Impl\Windows\ScreenEdgeInteractDetector.cs,DetectRub,The following statement contains a magic number: var MOVES_REQUIERED = 4;
Magic Number,WGestures.Core.Impl.Windows,EdgeInteractDetector,C:\repos\yingDev_WGestures\WGestures.Core\Impl\Windows\ScreenEdgeInteractDetector.cs,DetectRub,The following statement contains a magic number: if (_activeRubEdge == null)              {                  _activeRubEdge = GetActiveEdge(p' EDGE_THICK);                  if (_activeRubEdge == null) return;                    _lastRubTriggerTime = DateTime.UtcNow;                  _rubPeakPos = GetPosOnEdge(_activeRubEdge.Value' p);                  _rubTimes = 0;                  _lastRubDir = 0;              }              else              {                  if (_rubTimes >= MOVES_REQUIERED)                  {                      if (GetDistToEdge(_activeRubEdge.Value' p) >= RED_LINE_DIST || DateTime.UtcNow - _lastRubTriggerTime > TimeSpan.FromMilliseconds(TRIGGER_INTERVAL))                      {                          _activeRubEdge = null;                      }                        return;                  }                    if (GetActiveEdge(p' EDGE_THICK) != _activeRubEdge)                  {                      _activeRubEdge = null;                      return;                  }                    var pos = GetPosOnEdge(_activeRubEdge.Value' p);                    var dist = pos - _rubPeakPos;                  if (Math.Sign(dist) == Math.Sign(_lastRubDir) && _lastRubDir != 0)                  {                      _rubPeakPos = pos;                      return;                  }                    if (Math.Abs(dist) >= MIN_MOVE)                  {                      var now = DateTime.UtcNow;                      if (now - _lastRubTriggerTime > TimeSpan.FromMilliseconds(600))                      {                          _activeRubEdge = null;                          return;                      }                        _lastRubTriggerTime = now;                          _rubTimes += 1;                      _rubPeakPos = pos;                      _lastRubDir = Math.Sign(dist);                        Debug.WriteLine("Rub: " + _rubTimes);                        if (_rubTimes >= MOVES_REQUIERED)                      {                          Debug.WriteLine("Rub: Trigger!");                            OnRub(_activeRubEdge.Value);                      }                    }              }
Magic Number,WGestures.Core.Impl.Windows,TouchHook,C:\repos\yingDev_WGestures\WGestures.Core\Impl\Windows\TouchHook.cs,Install,The following statement contains a magic number: var thread = new Thread(() =>               {                  _win = new InputTargetWindow();                    var ok = RegisterPointerInputTarget(_win.Handle' PointerInputType.TOUCH);                  if(!ok)                  {                      Debug.WriteLine("失败 RegisterPointerInputTarget: " + Native.GetLastError());                      return; //todo: !!                  }else                  {                      Debug.WriteLine("TouchHook Installed.");                  }                    Native.MSG msg;                  int ret;                                    var sim = new InputSimulator();                    TouchInjector.InitializeTouchInjection();                  var screenBounds = Rectangle.Empty;                    var contacts = new PointerTouchInfo[10];                  uint contactCount = 10;                  uint startingPointId = 0;                                    while ((ret = Native.GetMessage(out msg' IntPtr.Zero' 0' 0)) != 0)                  {                      if(ret == -1)                      {                          Debug.WriteLine("Error!");                          continue;                      }                      var pointerId = GET_POINTERID_WPARAM((uint)msg.wParam.ToInt32());                        if (! GetPointerFrameTouchInfo(pointerId' ref contactCount' contacts))                      {                          Debug.WriteLine("GetPointerFrameTouchInfo Error: " + Native.GetLastError());                          continue;                      }                        //TODO: refactor... just hacking...                      switch (msg.message)                      {                          case WM_POINTERDOWN:                              Debug.WriteLine("Touch Down: " + contactCount);                                                            if(contactCount == 3)                              {                                  startingPointId = contacts[0].PointerInfo.PointerId;                                  if (screenBounds.Width > 0 && screenBounds.Height > 0)                                  {                                      var pos = contacts[0].PointerInfo.PtPixelLocation;                                      User32.SetCursorPos(pos.X' pos.Y);                                  }                                  screenBounds = Native.GetScreenBounds();                                  sim.Keyboard.KeyDown(WindowsInput.Native.VirtualKeyCode.LWIN);                                  continue;                              }                              ConvertToNewTouchInfo(contacts' PointerFlags.DOWN | PointerFlags.INRANGE | PointerFlags.INCONTACT);                              if (!TouchInjector.InjectTouchInput(1' contacts))                              {                                  Debug.WriteLine("Error InjectTouchInput: " + Native.GetLastError());                              }                              break;                            case WM_POINTERUPDATE:                              Debug.Write('.');                                if(contactCount == 3)                              {                                  TouchPoint? pos = null;                                  foreach(var contact in contacts)                                  {                                      if(contact.PointerInfo.PointerId == startingPointId)                                      {                                          pos = contact.PointerInfo.PtPixelLocation;                                      }                                  }                                    if(pos != null && screenBounds.Width > 0 && screenBounds.Height > 0)                                  {                                      var absX = pos.Value.X * (65535.0 / screenBounds.Width);                                      var absY = pos.Value.Y * (65535.0 / screenBounds.Height);                                      sim.Mouse.MoveMouseTo(absX' absY);                                  }                                  continue;                              }                                ConvertToNewTouchInfo(contacts' PointerFlags.UPDATE | PointerFlags.INRANGE | PointerFlags.INCONTACT);                              if (!TouchInjector.InjectTouchInput((int)contactCount' contacts))                              {                                  Debug.WriteLine("Error InjectTouchInput: " + Native.GetLastError());                              }                                break;                              case WM_POINTERUP:                              Debug.WriteLine("Touch Up");                              if (contactCount == 3)                              {                                  sim.Keyboard.KeyUp(WindowsInput.Native.VirtualKeyCode.LWIN);                                  continue;                              }                              ConvertToNewTouchInfo(contacts' PointerFlags.UP);                              if (!TouchInjector.InjectTouchInput(1' contacts))                              {                                  Debug.WriteLine("Error InjectTouchInput: " + Native.GetLastError());                              }                              break;                            case WM_POINTERENTER:                              Debug.WriteLine("Touch Enter");                              //ConvertToNewTouchInfo(contacts' PointerFlags.DOWN | PointerFlags.INRANGE | PointerFlags.INCONTACT);                              continue;                            case WM_POINTERLEAVE:                              Debug.WriteLine("Touch Leave");                              //ConvertToNewTouchInfo(contacts' PointerFlags.UP | PointerFlags.INRANGE | PointerFlags.INCONTACT);                              continue;                            default:                              Debug.WriteLine("Unhandled Msg: " + msg.message);                              continue;                      }                            var MSG = new Message() { HWnd = msg.hwnd' LParam = msg.lParam' WParam = msg.wParam' Msg = (int)msg.message' Result = IntPtr.Zero };                      _win.DefWndProc(ref MSG);                  }                });
Magic Number,WGestures.Core.Impl.Windows,TouchHook,C:\repos\yingDev_WGestures\WGestures.Core\Impl\Windows\TouchHook.cs,Install,The following statement contains a magic number: var thread = new Thread(() =>               {                  _win = new InputTargetWindow();                    var ok = RegisterPointerInputTarget(_win.Handle' PointerInputType.TOUCH);                  if(!ok)                  {                      Debug.WriteLine("失败 RegisterPointerInputTarget: " + Native.GetLastError());                      return; //todo: !!                  }else                  {                      Debug.WriteLine("TouchHook Installed.");                  }                    Native.MSG msg;                  int ret;                                    var sim = new InputSimulator();                    TouchInjector.InitializeTouchInjection();                  var screenBounds = Rectangle.Empty;                    var contacts = new PointerTouchInfo[10];                  uint contactCount = 10;                  uint startingPointId = 0;                                    while ((ret = Native.GetMessage(out msg' IntPtr.Zero' 0' 0)) != 0)                  {                      if(ret == -1)                      {                          Debug.WriteLine("Error!");                          continue;                      }                      var pointerId = GET_POINTERID_WPARAM((uint)msg.wParam.ToInt32());                        if (! GetPointerFrameTouchInfo(pointerId' ref contactCount' contacts))                      {                          Debug.WriteLine("GetPointerFrameTouchInfo Error: " + Native.GetLastError());                          continue;                      }                        //TODO: refactor... just hacking...                      switch (msg.message)                      {                          case WM_POINTERDOWN:                              Debug.WriteLine("Touch Down: " + contactCount);                                                            if(contactCount == 3)                              {                                  startingPointId = contacts[0].PointerInfo.PointerId;                                  if (screenBounds.Width > 0 && screenBounds.Height > 0)                                  {                                      var pos = contacts[0].PointerInfo.PtPixelLocation;                                      User32.SetCursorPos(pos.X' pos.Y);                                  }                                  screenBounds = Native.GetScreenBounds();                                  sim.Keyboard.KeyDown(WindowsInput.Native.VirtualKeyCode.LWIN);                                  continue;                              }                              ConvertToNewTouchInfo(contacts' PointerFlags.DOWN | PointerFlags.INRANGE | PointerFlags.INCONTACT);                              if (!TouchInjector.InjectTouchInput(1' contacts))                              {                                  Debug.WriteLine("Error InjectTouchInput: " + Native.GetLastError());                              }                              break;                            case WM_POINTERUPDATE:                              Debug.Write('.');                                if(contactCount == 3)                              {                                  TouchPoint? pos = null;                                  foreach(var contact in contacts)                                  {                                      if(contact.PointerInfo.PointerId == startingPointId)                                      {                                          pos = contact.PointerInfo.PtPixelLocation;                                      }                                  }                                    if(pos != null && screenBounds.Width > 0 && screenBounds.Height > 0)                                  {                                      var absX = pos.Value.X * (65535.0 / screenBounds.Width);                                      var absY = pos.Value.Y * (65535.0 / screenBounds.Height);                                      sim.Mouse.MoveMouseTo(absX' absY);                                  }                                  continue;                              }                                ConvertToNewTouchInfo(contacts' PointerFlags.UPDATE | PointerFlags.INRANGE | PointerFlags.INCONTACT);                              if (!TouchInjector.InjectTouchInput((int)contactCount' contacts))                              {                                  Debug.WriteLine("Error InjectTouchInput: " + Native.GetLastError());                              }                                break;                              case WM_POINTERUP:                              Debug.WriteLine("Touch Up");                              if (contactCount == 3)                              {                                  sim.Keyboard.KeyUp(WindowsInput.Native.VirtualKeyCode.LWIN);                                  continue;                              }                              ConvertToNewTouchInfo(contacts' PointerFlags.UP);                              if (!TouchInjector.InjectTouchInput(1' contacts))                              {                                  Debug.WriteLine("Error InjectTouchInput: " + Native.GetLastError());                              }                              break;                            case WM_POINTERENTER:                              Debug.WriteLine("Touch Enter");                              //ConvertToNewTouchInfo(contacts' PointerFlags.DOWN | PointerFlags.INRANGE | PointerFlags.INCONTACT);                              continue;                            case WM_POINTERLEAVE:                              Debug.WriteLine("Touch Leave");                              //ConvertToNewTouchInfo(contacts' PointerFlags.UP | PointerFlags.INRANGE | PointerFlags.INCONTACT);                              continue;                            default:                              Debug.WriteLine("Unhandled Msg: " + msg.message);                              continue;                      }                            var MSG = new Message() { HWnd = msg.hwnd' LParam = msg.lParam' WParam = msg.wParam' Msg = (int)msg.message' Result = IntPtr.Zero };                      _win.DefWndProc(ref MSG);                  }                });
Magic Number,WGestures.Core.Impl.Windows,TouchHook,C:\repos\yingDev_WGestures\WGestures.Core\Impl\Windows\TouchHook.cs,Install,The following statement contains a magic number: var thread = new Thread(() =>               {                  _win = new InputTargetWindow();                    var ok = RegisterPointerInputTarget(_win.Handle' PointerInputType.TOUCH);                  if(!ok)                  {                      Debug.WriteLine("失败 RegisterPointerInputTarget: " + Native.GetLastError());                      return; //todo: !!                  }else                  {                      Debug.WriteLine("TouchHook Installed.");                  }                    Native.MSG msg;                  int ret;                                    var sim = new InputSimulator();                    TouchInjector.InitializeTouchInjection();                  var screenBounds = Rectangle.Empty;                    var contacts = new PointerTouchInfo[10];                  uint contactCount = 10;                  uint startingPointId = 0;                                    while ((ret = Native.GetMessage(out msg' IntPtr.Zero' 0' 0)) != 0)                  {                      if(ret == -1)                      {                          Debug.WriteLine("Error!");                          continue;                      }                      var pointerId = GET_POINTERID_WPARAM((uint)msg.wParam.ToInt32());                        if (! GetPointerFrameTouchInfo(pointerId' ref contactCount' contacts))                      {                          Debug.WriteLine("GetPointerFrameTouchInfo Error: " + Native.GetLastError());                          continue;                      }                        //TODO: refactor... just hacking...                      switch (msg.message)                      {                          case WM_POINTERDOWN:                              Debug.WriteLine("Touch Down: " + contactCount);                                                            if(contactCount == 3)                              {                                  startingPointId = contacts[0].PointerInfo.PointerId;                                  if (screenBounds.Width > 0 && screenBounds.Height > 0)                                  {                                      var pos = contacts[0].PointerInfo.PtPixelLocation;                                      User32.SetCursorPos(pos.X' pos.Y);                                  }                                  screenBounds = Native.GetScreenBounds();                                  sim.Keyboard.KeyDown(WindowsInput.Native.VirtualKeyCode.LWIN);                                  continue;                              }                              ConvertToNewTouchInfo(contacts' PointerFlags.DOWN | PointerFlags.INRANGE | PointerFlags.INCONTACT);                              if (!TouchInjector.InjectTouchInput(1' contacts))                              {                                  Debug.WriteLine("Error InjectTouchInput: " + Native.GetLastError());                              }                              break;                            case WM_POINTERUPDATE:                              Debug.Write('.');                                if(contactCount == 3)                              {                                  TouchPoint? pos = null;                                  foreach(var contact in contacts)                                  {                                      if(contact.PointerInfo.PointerId == startingPointId)                                      {                                          pos = contact.PointerInfo.PtPixelLocation;                                      }                                  }                                    if(pos != null && screenBounds.Width > 0 && screenBounds.Height > 0)                                  {                                      var absX = pos.Value.X * (65535.0 / screenBounds.Width);                                      var absY = pos.Value.Y * (65535.0 / screenBounds.Height);                                      sim.Mouse.MoveMouseTo(absX' absY);                                  }                                  continue;                              }                                ConvertToNewTouchInfo(contacts' PointerFlags.UPDATE | PointerFlags.INRANGE | PointerFlags.INCONTACT);                              if (!TouchInjector.InjectTouchInput((int)contactCount' contacts))                              {                                  Debug.WriteLine("Error InjectTouchInput: " + Native.GetLastError());                              }                                break;                              case WM_POINTERUP:                              Debug.WriteLine("Touch Up");                              if (contactCount == 3)                              {                                  sim.Keyboard.KeyUp(WindowsInput.Native.VirtualKeyCode.LWIN);                                  continue;                              }                              ConvertToNewTouchInfo(contacts' PointerFlags.UP);                              if (!TouchInjector.InjectTouchInput(1' contacts))                              {                                  Debug.WriteLine("Error InjectTouchInput: " + Native.GetLastError());                              }                              break;                            case WM_POINTERENTER:                              Debug.WriteLine("Touch Enter");                              //ConvertToNewTouchInfo(contacts' PointerFlags.DOWN | PointerFlags.INRANGE | PointerFlags.INCONTACT);                              continue;                            case WM_POINTERLEAVE:                              Debug.WriteLine("Touch Leave");                              //ConvertToNewTouchInfo(contacts' PointerFlags.UP | PointerFlags.INRANGE | PointerFlags.INCONTACT);                              continue;                            default:                              Debug.WriteLine("Unhandled Msg: " + msg.message);                              continue;                      }                            var MSG = new Message() { HWnd = msg.hwnd' LParam = msg.lParam' WParam = msg.wParam' Msg = (int)msg.message' Result = IntPtr.Zero };                      _win.DefWndProc(ref MSG);                  }                });
Magic Number,WGestures.Core.Impl.Windows,TouchHook,C:\repos\yingDev_WGestures\WGestures.Core\Impl\Windows\TouchHook.cs,Install,The following statement contains a magic number: var thread = new Thread(() =>               {                  _win = new InputTargetWindow();                    var ok = RegisterPointerInputTarget(_win.Handle' PointerInputType.TOUCH);                  if(!ok)                  {                      Debug.WriteLine("失败 RegisterPointerInputTarget: " + Native.GetLastError());                      return; //todo: !!                  }else                  {                      Debug.WriteLine("TouchHook Installed.");                  }                    Native.MSG msg;                  int ret;                                    var sim = new InputSimulator();                    TouchInjector.InitializeTouchInjection();                  var screenBounds = Rectangle.Empty;                    var contacts = new PointerTouchInfo[10];                  uint contactCount = 10;                  uint startingPointId = 0;                                    while ((ret = Native.GetMessage(out msg' IntPtr.Zero' 0' 0)) != 0)                  {                      if(ret == -1)                      {                          Debug.WriteLine("Error!");                          continue;                      }                      var pointerId = GET_POINTERID_WPARAM((uint)msg.wParam.ToInt32());                        if (! GetPointerFrameTouchInfo(pointerId' ref contactCount' contacts))                      {                          Debug.WriteLine("GetPointerFrameTouchInfo Error: " + Native.GetLastError());                          continue;                      }                        //TODO: refactor... just hacking...                      switch (msg.message)                      {                          case WM_POINTERDOWN:                              Debug.WriteLine("Touch Down: " + contactCount);                                                            if(contactCount == 3)                              {                                  startingPointId = contacts[0].PointerInfo.PointerId;                                  if (screenBounds.Width > 0 && screenBounds.Height > 0)                                  {                                      var pos = contacts[0].PointerInfo.PtPixelLocation;                                      User32.SetCursorPos(pos.X' pos.Y);                                  }                                  screenBounds = Native.GetScreenBounds();                                  sim.Keyboard.KeyDown(WindowsInput.Native.VirtualKeyCode.LWIN);                                  continue;                              }                              ConvertToNewTouchInfo(contacts' PointerFlags.DOWN | PointerFlags.INRANGE | PointerFlags.INCONTACT);                              if (!TouchInjector.InjectTouchInput(1' contacts))                              {                                  Debug.WriteLine("Error InjectTouchInput: " + Native.GetLastError());                              }                              break;                            case WM_POINTERUPDATE:                              Debug.Write('.');                                if(contactCount == 3)                              {                                  TouchPoint? pos = null;                                  foreach(var contact in contacts)                                  {                                      if(contact.PointerInfo.PointerId == startingPointId)                                      {                                          pos = contact.PointerInfo.PtPixelLocation;                                      }                                  }                                    if(pos != null && screenBounds.Width > 0 && screenBounds.Height > 0)                                  {                                      var absX = pos.Value.X * (65535.0 / screenBounds.Width);                                      var absY = pos.Value.Y * (65535.0 / screenBounds.Height);                                      sim.Mouse.MoveMouseTo(absX' absY);                                  }                                  continue;                              }                                ConvertToNewTouchInfo(contacts' PointerFlags.UPDATE | PointerFlags.INRANGE | PointerFlags.INCONTACT);                              if (!TouchInjector.InjectTouchInput((int)contactCount' contacts))                              {                                  Debug.WriteLine("Error InjectTouchInput: " + Native.GetLastError());                              }                                break;                              case WM_POINTERUP:                              Debug.WriteLine("Touch Up");                              if (contactCount == 3)                              {                                  sim.Keyboard.KeyUp(WindowsInput.Native.VirtualKeyCode.LWIN);                                  continue;                              }                              ConvertToNewTouchInfo(contacts' PointerFlags.UP);                              if (!TouchInjector.InjectTouchInput(1' contacts))                              {                                  Debug.WriteLine("Error InjectTouchInput: " + Native.GetLastError());                              }                              break;                            case WM_POINTERENTER:                              Debug.WriteLine("Touch Enter");                              //ConvertToNewTouchInfo(contacts' PointerFlags.DOWN | PointerFlags.INRANGE | PointerFlags.INCONTACT);                              continue;                            case WM_POINTERLEAVE:                              Debug.WriteLine("Touch Leave");                              //ConvertToNewTouchInfo(contacts' PointerFlags.UP | PointerFlags.INRANGE | PointerFlags.INCONTACT);                              continue;                            default:                              Debug.WriteLine("Unhandled Msg: " + msg.message);                              continue;                      }                            var MSG = new Message() { HWnd = msg.hwnd' LParam = msg.lParam' WParam = msg.wParam' Msg = (int)msg.message' Result = IntPtr.Zero };                      _win.DefWndProc(ref MSG);                  }                });
Magic Number,WGestures.Core.Impl.Windows,TouchHook,C:\repos\yingDev_WGestures\WGestures.Core\Impl\Windows\TouchHook.cs,Install,The following statement contains a magic number: var thread = new Thread(() =>               {                  _win = new InputTargetWindow();                    var ok = RegisterPointerInputTarget(_win.Handle' PointerInputType.TOUCH);                  if(!ok)                  {                      Debug.WriteLine("失败 RegisterPointerInputTarget: " + Native.GetLastError());                      return; //todo: !!                  }else                  {                      Debug.WriteLine("TouchHook Installed.");                  }                    Native.MSG msg;                  int ret;                                    var sim = new InputSimulator();                    TouchInjector.InitializeTouchInjection();                  var screenBounds = Rectangle.Empty;                    var contacts = new PointerTouchInfo[10];                  uint contactCount = 10;                  uint startingPointId = 0;                                    while ((ret = Native.GetMessage(out msg' IntPtr.Zero' 0' 0)) != 0)                  {                      if(ret == -1)                      {                          Debug.WriteLine("Error!");                          continue;                      }                      var pointerId = GET_POINTERID_WPARAM((uint)msg.wParam.ToInt32());                        if (! GetPointerFrameTouchInfo(pointerId' ref contactCount' contacts))                      {                          Debug.WriteLine("GetPointerFrameTouchInfo Error: " + Native.GetLastError());                          continue;                      }                        //TODO: refactor... just hacking...                      switch (msg.message)                      {                          case WM_POINTERDOWN:                              Debug.WriteLine("Touch Down: " + contactCount);                                                            if(contactCount == 3)                              {                                  startingPointId = contacts[0].PointerInfo.PointerId;                                  if (screenBounds.Width > 0 && screenBounds.Height > 0)                                  {                                      var pos = contacts[0].PointerInfo.PtPixelLocation;                                      User32.SetCursorPos(pos.X' pos.Y);                                  }                                  screenBounds = Native.GetScreenBounds();                                  sim.Keyboard.KeyDown(WindowsInput.Native.VirtualKeyCode.LWIN);                                  continue;                              }                              ConvertToNewTouchInfo(contacts' PointerFlags.DOWN | PointerFlags.INRANGE | PointerFlags.INCONTACT);                              if (!TouchInjector.InjectTouchInput(1' contacts))                              {                                  Debug.WriteLine("Error InjectTouchInput: " + Native.GetLastError());                              }                              break;                            case WM_POINTERUPDATE:                              Debug.Write('.');                                if(contactCount == 3)                              {                                  TouchPoint? pos = null;                                  foreach(var contact in contacts)                                  {                                      if(contact.PointerInfo.PointerId == startingPointId)                                      {                                          pos = contact.PointerInfo.PtPixelLocation;                                      }                                  }                                    if(pos != null && screenBounds.Width > 0 && screenBounds.Height > 0)                                  {                                      var absX = pos.Value.X * (65535.0 / screenBounds.Width);                                      var absY = pos.Value.Y * (65535.0 / screenBounds.Height);                                      sim.Mouse.MoveMouseTo(absX' absY);                                  }                                  continue;                              }                                ConvertToNewTouchInfo(contacts' PointerFlags.UPDATE | PointerFlags.INRANGE | PointerFlags.INCONTACT);                              if (!TouchInjector.InjectTouchInput((int)contactCount' contacts))                              {                                  Debug.WriteLine("Error InjectTouchInput: " + Native.GetLastError());                              }                                break;                              case WM_POINTERUP:                              Debug.WriteLine("Touch Up");                              if (contactCount == 3)                              {                                  sim.Keyboard.KeyUp(WindowsInput.Native.VirtualKeyCode.LWIN);                                  continue;                              }                              ConvertToNewTouchInfo(contacts' PointerFlags.UP);                              if (!TouchInjector.InjectTouchInput(1' contacts))                              {                                  Debug.WriteLine("Error InjectTouchInput: " + Native.GetLastError());                              }                              break;                            case WM_POINTERENTER:                              Debug.WriteLine("Touch Enter");                              //ConvertToNewTouchInfo(contacts' PointerFlags.DOWN | PointerFlags.INRANGE | PointerFlags.INCONTACT);                              continue;                            case WM_POINTERLEAVE:                              Debug.WriteLine("Touch Leave");                              //ConvertToNewTouchInfo(contacts' PointerFlags.UP | PointerFlags.INRANGE | PointerFlags.INCONTACT);                              continue;                            default:                              Debug.WriteLine("Unhandled Msg: " + msg.message);                              continue;                      }                            var MSG = new Message() { HWnd = msg.hwnd' LParam = msg.lParam' WParam = msg.wParam' Msg = (int)msg.message' Result = IntPtr.Zero };                      _win.DefWndProc(ref MSG);                  }                });
Magic Number,WGestures.Core.Impl.Windows,TouchHook,C:\repos\yingDev_WGestures\WGestures.Core\Impl\Windows\TouchHook.cs,Install,The following statement contains a magic number: var thread = new Thread(() =>               {                  _win = new InputTargetWindow();                    var ok = RegisterPointerInputTarget(_win.Handle' PointerInputType.TOUCH);                  if(!ok)                  {                      Debug.WriteLine("失败 RegisterPointerInputTarget: " + Native.GetLastError());                      return; //todo: !!                  }else                  {                      Debug.WriteLine("TouchHook Installed.");                  }                    Native.MSG msg;                  int ret;                                    var sim = new InputSimulator();                    TouchInjector.InitializeTouchInjection();                  var screenBounds = Rectangle.Empty;                    var contacts = new PointerTouchInfo[10];                  uint contactCount = 10;                  uint startingPointId = 0;                                    while ((ret = Native.GetMessage(out msg' IntPtr.Zero' 0' 0)) != 0)                  {                      if(ret == -1)                      {                          Debug.WriteLine("Error!");                          continue;                      }                      var pointerId = GET_POINTERID_WPARAM((uint)msg.wParam.ToInt32());                        if (! GetPointerFrameTouchInfo(pointerId' ref contactCount' contacts))                      {                          Debug.WriteLine("GetPointerFrameTouchInfo Error: " + Native.GetLastError());                          continue;                      }                        //TODO: refactor... just hacking...                      switch (msg.message)                      {                          case WM_POINTERDOWN:                              Debug.WriteLine("Touch Down: " + contactCount);                                                            if(contactCount == 3)                              {                                  startingPointId = contacts[0].PointerInfo.PointerId;                                  if (screenBounds.Width > 0 && screenBounds.Height > 0)                                  {                                      var pos = contacts[0].PointerInfo.PtPixelLocation;                                      User32.SetCursorPos(pos.X' pos.Y);                                  }                                  screenBounds = Native.GetScreenBounds();                                  sim.Keyboard.KeyDown(WindowsInput.Native.VirtualKeyCode.LWIN);                                  continue;                              }                              ConvertToNewTouchInfo(contacts' PointerFlags.DOWN | PointerFlags.INRANGE | PointerFlags.INCONTACT);                              if (!TouchInjector.InjectTouchInput(1' contacts))                              {                                  Debug.WriteLine("Error InjectTouchInput: " + Native.GetLastError());                              }                              break;                            case WM_POINTERUPDATE:                              Debug.Write('.');                                if(contactCount == 3)                              {                                  TouchPoint? pos = null;                                  foreach(var contact in contacts)                                  {                                      if(contact.PointerInfo.PointerId == startingPointId)                                      {                                          pos = contact.PointerInfo.PtPixelLocation;                                      }                                  }                                    if(pos != null && screenBounds.Width > 0 && screenBounds.Height > 0)                                  {                                      var absX = pos.Value.X * (65535.0 / screenBounds.Width);                                      var absY = pos.Value.Y * (65535.0 / screenBounds.Height);                                      sim.Mouse.MoveMouseTo(absX' absY);                                  }                                  continue;                              }                                ConvertToNewTouchInfo(contacts' PointerFlags.UPDATE | PointerFlags.INRANGE | PointerFlags.INCONTACT);                              if (!TouchInjector.InjectTouchInput((int)contactCount' contacts))                              {                                  Debug.WriteLine("Error InjectTouchInput: " + Native.GetLastError());                              }                                break;                              case WM_POINTERUP:                              Debug.WriteLine("Touch Up");                              if (contactCount == 3)                              {                                  sim.Keyboard.KeyUp(WindowsInput.Native.VirtualKeyCode.LWIN);                                  continue;                              }                              ConvertToNewTouchInfo(contacts' PointerFlags.UP);                              if (!TouchInjector.InjectTouchInput(1' contacts))                              {                                  Debug.WriteLine("Error InjectTouchInput: " + Native.GetLastError());                              }                              break;                            case WM_POINTERENTER:                              Debug.WriteLine("Touch Enter");                              //ConvertToNewTouchInfo(contacts' PointerFlags.DOWN | PointerFlags.INRANGE | PointerFlags.INCONTACT);                              continue;                            case WM_POINTERLEAVE:                              Debug.WriteLine("Touch Leave");                              //ConvertToNewTouchInfo(contacts' PointerFlags.UP | PointerFlags.INRANGE | PointerFlags.INCONTACT);                              continue;                            default:                              Debug.WriteLine("Unhandled Msg: " + msg.message);                              continue;                      }                            var MSG = new Message() { HWnd = msg.hwnd' LParam = msg.lParam' WParam = msg.wParam' Msg = (int)msg.message' Result = IntPtr.Zero };                      _win.DefWndProc(ref MSG);                  }                });
Magic Number,WGestures.Core.Impl.Windows,TouchHook,C:\repos\yingDev_WGestures\WGestures.Core\Impl\Windows\TouchHook.cs,Install,The following statement contains a magic number: var thread = new Thread(() =>               {                  _win = new InputTargetWindow();                    var ok = RegisterPointerInputTarget(_win.Handle' PointerInputType.TOUCH);                  if(!ok)                  {                      Debug.WriteLine("失败 RegisterPointerInputTarget: " + Native.GetLastError());                      return; //todo: !!                  }else                  {                      Debug.WriteLine("TouchHook Installed.");                  }                    Native.MSG msg;                  int ret;                                    var sim = new InputSimulator();                    TouchInjector.InitializeTouchInjection();                  var screenBounds = Rectangle.Empty;                    var contacts = new PointerTouchInfo[10];                  uint contactCount = 10;                  uint startingPointId = 0;                                    while ((ret = Native.GetMessage(out msg' IntPtr.Zero' 0' 0)) != 0)                  {                      if(ret == -1)                      {                          Debug.WriteLine("Error!");                          continue;                      }                      var pointerId = GET_POINTERID_WPARAM((uint)msg.wParam.ToInt32());                        if (! GetPointerFrameTouchInfo(pointerId' ref contactCount' contacts))                      {                          Debug.WriteLine("GetPointerFrameTouchInfo Error: " + Native.GetLastError());                          continue;                      }                        //TODO: refactor... just hacking...                      switch (msg.message)                      {                          case WM_POINTERDOWN:                              Debug.WriteLine("Touch Down: " + contactCount);                                                            if(contactCount == 3)                              {                                  startingPointId = contacts[0].PointerInfo.PointerId;                                  if (screenBounds.Width > 0 && screenBounds.Height > 0)                                  {                                      var pos = contacts[0].PointerInfo.PtPixelLocation;                                      User32.SetCursorPos(pos.X' pos.Y);                                  }                                  screenBounds = Native.GetScreenBounds();                                  sim.Keyboard.KeyDown(WindowsInput.Native.VirtualKeyCode.LWIN);                                  continue;                              }                              ConvertToNewTouchInfo(contacts' PointerFlags.DOWN | PointerFlags.INRANGE | PointerFlags.INCONTACT);                              if (!TouchInjector.InjectTouchInput(1' contacts))                              {                                  Debug.WriteLine("Error InjectTouchInput: " + Native.GetLastError());                              }                              break;                            case WM_POINTERUPDATE:                              Debug.Write('.');                                if(contactCount == 3)                              {                                  TouchPoint? pos = null;                                  foreach(var contact in contacts)                                  {                                      if(contact.PointerInfo.PointerId == startingPointId)                                      {                                          pos = contact.PointerInfo.PtPixelLocation;                                      }                                  }                                    if(pos != null && screenBounds.Width > 0 && screenBounds.Height > 0)                                  {                                      var absX = pos.Value.X * (65535.0 / screenBounds.Width);                                      var absY = pos.Value.Y * (65535.0 / screenBounds.Height);                                      sim.Mouse.MoveMouseTo(absX' absY);                                  }                                  continue;                              }                                ConvertToNewTouchInfo(contacts' PointerFlags.UPDATE | PointerFlags.INRANGE | PointerFlags.INCONTACT);                              if (!TouchInjector.InjectTouchInput((int)contactCount' contacts))                              {                                  Debug.WriteLine("Error InjectTouchInput: " + Native.GetLastError());                              }                                break;                              case WM_POINTERUP:                              Debug.WriteLine("Touch Up");                              if (contactCount == 3)                              {                                  sim.Keyboard.KeyUp(WindowsInput.Native.VirtualKeyCode.LWIN);                                  continue;                              }                              ConvertToNewTouchInfo(contacts' PointerFlags.UP);                              if (!TouchInjector.InjectTouchInput(1' contacts))                              {                                  Debug.WriteLine("Error InjectTouchInput: " + Native.GetLastError());                              }                              break;                            case WM_POINTERENTER:                              Debug.WriteLine("Touch Enter");                              //ConvertToNewTouchInfo(contacts' PointerFlags.DOWN | PointerFlags.INRANGE | PointerFlags.INCONTACT);                              continue;                            case WM_POINTERLEAVE:                              Debug.WriteLine("Touch Leave");                              //ConvertToNewTouchInfo(contacts' PointerFlags.UP | PointerFlags.INRANGE | PointerFlags.INCONTACT);                              continue;                            default:                              Debug.WriteLine("Unhandled Msg: " + msg.message);                              continue;                      }                            var MSG = new Message() { HWnd = msg.hwnd' LParam = msg.lParam' WParam = msg.wParam' Msg = (int)msg.message' Result = IntPtr.Zero };                      _win.DefWndProc(ref MSG);                  }                });
Magic Number,WGestures.Core.Impl.Windows,MouseKeyboardHook,C:\repos\yingDev_WGestures\WGestures.Core\Impl\Windows\MouseHook.cs,Uninstall,The following statement contains a magic number: if (_hookThread != null && _hookThread.IsAlive)              {                  Native.PostThreadMessage(_hookThreadNativeId' (uint)User32.WM.WM_CLOSE' UIntPtr.Zero' IntPtr.Zero);                    if (!_hookThread.Join(1000 * 3))                  {                      throw new TimeoutException("等待钩子线程结束超时");                  }                    _hookThread = null;              }
Magic Number,WGestures.Core.Impl.Windows,MouseKeyboardHook,C:\repos\yingDev_WGestures\WGestures.Core\Impl\Windows\MouseHook.cs,Uninstall,The following statement contains a magic number: if (_hookThread != null && _hookThread.IsAlive)              {                  Native.PostThreadMessage(_hookThreadNativeId' (uint)User32.WM.WM_CLOSE' UIntPtr.Zero' IntPtr.Zero);                    if (!_hookThread.Join(1000 * 3))                  {                      throw new TimeoutException("等待钩子线程结束超时");                  }                    _hookThread = null;              }
Magic Number,WGestures.Core.Impl.Windows,MouseKeyboardHook,C:\repos\yingDev_WGestures\WGestures.Core\Impl\Windows\MouseHook.cs,MouseHookProc,The following statement contains a magic number: try              {                  if (MouseHookEvent != null)                  {                      var timeBefore = DateTime.UtcNow;                        MouseHookEvent(args);                        var timeElapsed = DateTime.UtcNow - timeBefore;                      //Debug.WriteLine("MouseHookEvent used time: " + timeElapsed.TotalMilliseconds);                        //如果用了太长时间，则假定卡住了，重新安装                      if(timeElapsed.TotalMilliseconds > 1000)                      {                          Debug.WriteLine("MouseHookEvent消耗了太多时间，假定hook已失效；重新安装ing...");                          Native.PostThreadMessage(_hookThreadNativeId' WM_HOOK_TIMEOUT' UIntPtr.Zero' IntPtr.Zero);                      }                    }              }              catch(Exception e)              {                  Debug.WriteLine("MouseHookEvent中发生了未处理的异常，并且冒泡到了MouseHookProc。这是不应该出现的。"+e);              }
Magic Number,WGestures.Core.Impl.Windows,Win32MousePathTracker2,C:\repos\yingDev_WGestures\WGestures.Core\Impl\Windows\Win32MousePathTracker2.cs,Win32MousePathTracker2,The following statement contains a magic number: InitialValidMove = (int)(5 * dpiFactor);
Magic Number,WGestures.Core.Impl.Windows,Win32MousePathTracker2,C:\repos\yingDev_WGestures\WGestures.Core\Impl\Windows\Win32MousePathTracker2.cs,Win32MousePathTracker2,The following statement contains a magic number: InitialStayTimeoutMillis = 150;
Magic Number,WGestures.Core.Impl.Windows,Win32MousePathTracker2,C:\repos\yingDev_WGestures\WGestures.Core\Impl\Windows\Win32MousePathTracker2.cs,Win32MousePathTracker2,The following statement contains a magic number: EffectiveMove = (int)(10 * dpiFactor) * 2;
Magic Number,WGestures.Core.Impl.Windows,Win32MousePathTracker2,C:\repos\yingDev_WGestures\WGestures.Core\Impl\Windows\Win32MousePathTracker2.cs,Win32MousePathTracker2,The following statement contains a magic number: EffectiveMove = (int)(10 * dpiFactor) * 2;
Magic Number,WGestures.Core.Impl.Windows,Win32MousePathTracker2,C:\repos\yingDev_WGestures\WGestures.Core\Impl\Windows\Win32MousePathTracker2.cs,Win32MousePathTracker2,The following statement contains a magic number: StepSize = 3;
Magic Number,WGestures.Core.Impl.Windows,Win32MousePathTracker2,C:\repos\yingDev_WGestures\WGestures.Core\Impl\Windows\Win32MousePathTracker2.cs,Win32MousePathTracker2,The following statement contains a magic number: if (OSVersion.Major >= 6 && OSVersion.Minor > 1)              {                  //太难弄，暂时屏蔽                  //_touchHook = new TouchHook();              }
Magic Number,WGestures.Core.Impl.Windows,Win32MousePathTracker2,C:\repos\yingDev_WGestures\WGestures.Core\Impl\Windows\Win32MousePathTracker2.cs,MouseHookProc,The following statement contains a magic number: switch (m)              {                  //必须在这里立即决定是否应该捕获                  case MouseMsg.WM_RBUTTONDOWN:                  case MouseMsg.WM_MBUTTONDOWN:                  case MouseMsg.WM_XBUTTONDOWN:                      if (!_captured)                      {                          if (m == MouseMsg.WM_MBUTTONDOWN && (TriggerButton & GestureTriggerButton.Middle) == 0                              || m == MouseMsg.WM_RBUTTONDOWN && (TriggerButton & GestureTriggerButton.Right) == 0                              || m == MouseMsg.WM_XBUTTONDOWN && (TriggerButton & GestureTriggerButton.X) == 0)                          {                              return;                          }                          try                          {                              //notice: 这个方法在钩子线程中运行，因此必须足够快，而且不能失败                              _captured = OnBeforePathStart();                                                        }                          catch (Exception ex)                          {  #if DEBUG                              throw;  #endif                              //如果出错，则不捕获手势                              _captured = false;                          }                                                    if (_captured)                          {                              //_gestureBtn = (m == MouseMsg.WM_RBUTTONDOWN ? GestureButtons.RightButton : GestureButtons.MiddleButton);                              switch(m) //TODO: extract function                              {                                  case MouseMsg.WM_RBUTTONDOWN:                                      _gestureBtn = GestureTriggerButton.Right;                                      break;                                  case MouseMsg.WM_MBUTTONDOWN:                                      _gestureBtn = GestureTriggerButton.Middle;                                      break;                                  case MouseMsg.WM_XBUTTONDOWN:                                      var x = (XButtonNumber)(mouseData.mouseData >> 16); //which X Button                                      _gestureBtn = x == XButtonNumber.One ? GestureTriggerButton.X1 : GestureTriggerButton.X2;                                      break;                                  default:                                      Debug.Assert(false' "WTF! shouldn't happen");                                      break;                              }                                                            _modifierEventHappendPrevTime = new DateTime(0);                              e.Handled = true;                              Post(WM.GESTBTN_DOWN);                          }                      }                      else //另一个键作为手势键的时候，作为修饰键                      {                          GestureModifier gestMod;// = m == MouseMsg.WM_RBUTTONDOWN ? GestureModifier.RightButtonDown : GestureModifier.MiddleButtonDown;                            switch(m) //TODO: extract function                          {                              case MouseMsg.WM_RBUTTONDOWN:                                  gestMod = GestureModifier.RightButtonDown;                                  break;                              case MouseMsg.WM_MBUTTONDOWN:                                  gestMod = GestureModifier.MiddleButtonDown;                                  break;                              case MouseMsg.WM_XBUTTONDOWN:                                  var x = (XButtonNumber)(mouseData.mouseData >> 16); //which X Button                                  gestMod = x == XButtonNumber.One ? GestureModifier.X1 : GestureModifier.X2;                                  break;                              default:                                  gestMod = GestureModifier.LeftButtonDown;                                  break;                          }                            e.Handled = HandleModifier(gestMod);                      }                      break;                    case MouseMsg.WM_MOUSEMOVE:                      if (_captured)                      {                          //永远不拦截move消息，所以不设置e.Handled = true                          Post(WM.GESTBTN_MOVE);                      }                      else                       {                         if(_isVirtualGesturing)                          {                              //忽略禁用列表                              OnBeforePathStart();                              _captured = true;                              _gestureBtn = GestureTriggerButton.Right;                              Post(WM.GESTBTN_DOWN' 1);                            }                          //未捕获的情况下才允许hotcorner                          HotCornerHitTest();                      }                      break;                    case MouseMsg.WM_MOUSEWHEEL:                      if (_captured)                      {                          //获得滚动方向                          int delta = (short)(mouseData.mouseData >> 16);                          var gestMod = delta > 0 ? GestureModifier.WheelForward : GestureModifier.WheelBackward;                            e.Handled = HandleModifier(gestMod);                      }                      else if (DateTime.UtcNow - _modifierEventHappendPrevTime < TimeSpan.FromMilliseconds(300))//延迟一下，因为 中键手势 + 滚动，可能导致快捷键还没结束，而滚轮事件发送到了目标窗口，可鞥解释成其他功能（比如ctrl + 滚轮 = 缩放）                      {                          e.Handled = true;                      }                      break;                    case MouseMsg.WM_LBUTTONDOWN:                      if (_captured)                      {                          e.Handled = HandleModifier(GestureModifier.LeftButtonDown);                      }                      break;                    case MouseMsg.WM_RBUTTONUP:                  case MouseMsg.WM_MBUTTONUP:                  case MouseMsg.WM_XBUTTONUP:                      if (_captured)                      {                          var gestBtn_as_MouseMsg = (MouseMsg)(-1);                          switch(_gestureBtn)                          {                              case GestureTriggerButton.Middle:                                  gestBtn_as_MouseMsg = MouseMsg.WM_MBUTTONUP;                                  break;                              case GestureTriggerButton.Right:                                  gestBtn_as_MouseMsg = MouseMsg.WM_RBUTTONUP;                                  break;                              case GestureTriggerButton.X1:                              case GestureTriggerButton.X2:                                  gestBtn_as_MouseMsg = MouseMsg.WM_XBUTTONUP;                                  break;                              }                                                    //是手势键up                          if (m == gestBtn_as_MouseMsg)                          {                                _captured = false;                                        Post(WM.GESTBTN_UP);                          }                            e.Handled = true;                      }                      break;                  default:                      //其他消息不处理                      break;              }
Magic Number,WGestures.Core.Impl.Windows,Win32MousePathTracker2,C:\repos\yingDev_WGestures\WGestures.Core\Impl\Windows\Win32MousePathTracker2.cs,MouseHookProc,The following statement contains a magic number: switch (m)              {                  //必须在这里立即决定是否应该捕获                  case MouseMsg.WM_RBUTTONDOWN:                  case MouseMsg.WM_MBUTTONDOWN:                  case MouseMsg.WM_XBUTTONDOWN:                      if (!_captured)                      {                          if (m == MouseMsg.WM_MBUTTONDOWN && (TriggerButton & GestureTriggerButton.Middle) == 0                              || m == MouseMsg.WM_RBUTTONDOWN && (TriggerButton & GestureTriggerButton.Right) == 0                              || m == MouseMsg.WM_XBUTTONDOWN && (TriggerButton & GestureTriggerButton.X) == 0)                          {                              return;                          }                          try                          {                              //notice: 这个方法在钩子线程中运行，因此必须足够快，而且不能失败                              _captured = OnBeforePathStart();                                                        }                          catch (Exception ex)                          {  #if DEBUG                              throw;  #endif                              //如果出错，则不捕获手势                              _captured = false;                          }                                                    if (_captured)                          {                              //_gestureBtn = (m == MouseMsg.WM_RBUTTONDOWN ? GestureButtons.RightButton : GestureButtons.MiddleButton);                              switch(m) //TODO: extract function                              {                                  case MouseMsg.WM_RBUTTONDOWN:                                      _gestureBtn = GestureTriggerButton.Right;                                      break;                                  case MouseMsg.WM_MBUTTONDOWN:                                      _gestureBtn = GestureTriggerButton.Middle;                                      break;                                  case MouseMsg.WM_XBUTTONDOWN:                                      var x = (XButtonNumber)(mouseData.mouseData >> 16); //which X Button                                      _gestureBtn = x == XButtonNumber.One ? GestureTriggerButton.X1 : GestureTriggerButton.X2;                                      break;                                  default:                                      Debug.Assert(false' "WTF! shouldn't happen");                                      break;                              }                                                            _modifierEventHappendPrevTime = new DateTime(0);                              e.Handled = true;                              Post(WM.GESTBTN_DOWN);                          }                      }                      else //另一个键作为手势键的时候，作为修饰键                      {                          GestureModifier gestMod;// = m == MouseMsg.WM_RBUTTONDOWN ? GestureModifier.RightButtonDown : GestureModifier.MiddleButtonDown;                            switch(m) //TODO: extract function                          {                              case MouseMsg.WM_RBUTTONDOWN:                                  gestMod = GestureModifier.RightButtonDown;                                  break;                              case MouseMsg.WM_MBUTTONDOWN:                                  gestMod = GestureModifier.MiddleButtonDown;                                  break;                              case MouseMsg.WM_XBUTTONDOWN:                                  var x = (XButtonNumber)(mouseData.mouseData >> 16); //which X Button                                  gestMod = x == XButtonNumber.One ? GestureModifier.X1 : GestureModifier.X2;                                  break;                              default:                                  gestMod = GestureModifier.LeftButtonDown;                                  break;                          }                            e.Handled = HandleModifier(gestMod);                      }                      break;                    case MouseMsg.WM_MOUSEMOVE:                      if (_captured)                      {                          //永远不拦截move消息，所以不设置e.Handled = true                          Post(WM.GESTBTN_MOVE);                      }                      else                       {                         if(_isVirtualGesturing)                          {                              //忽略禁用列表                              OnBeforePathStart();                              _captured = true;                              _gestureBtn = GestureTriggerButton.Right;                              Post(WM.GESTBTN_DOWN' 1);                            }                          //未捕获的情况下才允许hotcorner                          HotCornerHitTest();                      }                      break;                    case MouseMsg.WM_MOUSEWHEEL:                      if (_captured)                      {                          //获得滚动方向                          int delta = (short)(mouseData.mouseData >> 16);                          var gestMod = delta > 0 ? GestureModifier.WheelForward : GestureModifier.WheelBackward;                            e.Handled = HandleModifier(gestMod);                      }                      else if (DateTime.UtcNow - _modifierEventHappendPrevTime < TimeSpan.FromMilliseconds(300))//延迟一下，因为 中键手势 + 滚动，可能导致快捷键还没结束，而滚轮事件发送到了目标窗口，可鞥解释成其他功能（比如ctrl + 滚轮 = 缩放）                      {                          e.Handled = true;                      }                      break;                    case MouseMsg.WM_LBUTTONDOWN:                      if (_captured)                      {                          e.Handled = HandleModifier(GestureModifier.LeftButtonDown);                      }                      break;                    case MouseMsg.WM_RBUTTONUP:                  case MouseMsg.WM_MBUTTONUP:                  case MouseMsg.WM_XBUTTONUP:                      if (_captured)                      {                          var gestBtn_as_MouseMsg = (MouseMsg)(-1);                          switch(_gestureBtn)                          {                              case GestureTriggerButton.Middle:                                  gestBtn_as_MouseMsg = MouseMsg.WM_MBUTTONUP;                                  break;                              case GestureTriggerButton.Right:                                  gestBtn_as_MouseMsg = MouseMsg.WM_RBUTTONUP;                                  break;                              case GestureTriggerButton.X1:                              case GestureTriggerButton.X2:                                  gestBtn_as_MouseMsg = MouseMsg.WM_XBUTTONUP;                                  break;                              }                                                    //是手势键up                          if (m == gestBtn_as_MouseMsg)                          {                                _captured = false;                                        Post(WM.GESTBTN_UP);                          }                            e.Handled = true;                      }                      break;                  default:                      //其他消息不处理                      break;              }
Magic Number,WGestures.Core.Impl.Windows,Win32MousePathTracker2,C:\repos\yingDev_WGestures\WGestures.Core\Impl\Windows\Win32MousePathTracker2.cs,MouseHookProc,The following statement contains a magic number: switch (m)              {                  //必须在这里立即决定是否应该捕获                  case MouseMsg.WM_RBUTTONDOWN:                  case MouseMsg.WM_MBUTTONDOWN:                  case MouseMsg.WM_XBUTTONDOWN:                      if (!_captured)                      {                          if (m == MouseMsg.WM_MBUTTONDOWN && (TriggerButton & GestureTriggerButton.Middle) == 0                              || m == MouseMsg.WM_RBUTTONDOWN && (TriggerButton & GestureTriggerButton.Right) == 0                              || m == MouseMsg.WM_XBUTTONDOWN && (TriggerButton & GestureTriggerButton.X) == 0)                          {                              return;                          }                          try                          {                              //notice: 这个方法在钩子线程中运行，因此必须足够快，而且不能失败                              _captured = OnBeforePathStart();                                                        }                          catch (Exception ex)                          {  #if DEBUG                              throw;  #endif                              //如果出错，则不捕获手势                              _captured = false;                          }                                                    if (_captured)                          {                              //_gestureBtn = (m == MouseMsg.WM_RBUTTONDOWN ? GestureButtons.RightButton : GestureButtons.MiddleButton);                              switch(m) //TODO: extract function                              {                                  case MouseMsg.WM_RBUTTONDOWN:                                      _gestureBtn = GestureTriggerButton.Right;                                      break;                                  case MouseMsg.WM_MBUTTONDOWN:                                      _gestureBtn = GestureTriggerButton.Middle;                                      break;                                  case MouseMsg.WM_XBUTTONDOWN:                                      var x = (XButtonNumber)(mouseData.mouseData >> 16); //which X Button                                      _gestureBtn = x == XButtonNumber.One ? GestureTriggerButton.X1 : GestureTriggerButton.X2;                                      break;                                  default:                                      Debug.Assert(false' "WTF! shouldn't happen");                                      break;                              }                                                            _modifierEventHappendPrevTime = new DateTime(0);                              e.Handled = true;                              Post(WM.GESTBTN_DOWN);                          }                      }                      else //另一个键作为手势键的时候，作为修饰键                      {                          GestureModifier gestMod;// = m == MouseMsg.WM_RBUTTONDOWN ? GestureModifier.RightButtonDown : GestureModifier.MiddleButtonDown;                            switch(m) //TODO: extract function                          {                              case MouseMsg.WM_RBUTTONDOWN:                                  gestMod = GestureModifier.RightButtonDown;                                  break;                              case MouseMsg.WM_MBUTTONDOWN:                                  gestMod = GestureModifier.MiddleButtonDown;                                  break;                              case MouseMsg.WM_XBUTTONDOWN:                                  var x = (XButtonNumber)(mouseData.mouseData >> 16); //which X Button                                  gestMod = x == XButtonNumber.One ? GestureModifier.X1 : GestureModifier.X2;                                  break;                              default:                                  gestMod = GestureModifier.LeftButtonDown;                                  break;                          }                            e.Handled = HandleModifier(gestMod);                      }                      break;                    case MouseMsg.WM_MOUSEMOVE:                      if (_captured)                      {                          //永远不拦截move消息，所以不设置e.Handled = true                          Post(WM.GESTBTN_MOVE);                      }                      else                       {                         if(_isVirtualGesturing)                          {                              //忽略禁用列表                              OnBeforePathStart();                              _captured = true;                              _gestureBtn = GestureTriggerButton.Right;                              Post(WM.GESTBTN_DOWN' 1);                            }                          //未捕获的情况下才允许hotcorner                          HotCornerHitTest();                      }                      break;                    case MouseMsg.WM_MOUSEWHEEL:                      if (_captured)                      {                          //获得滚动方向                          int delta = (short)(mouseData.mouseData >> 16);                          var gestMod = delta > 0 ? GestureModifier.WheelForward : GestureModifier.WheelBackward;                            e.Handled = HandleModifier(gestMod);                      }                      else if (DateTime.UtcNow - _modifierEventHappendPrevTime < TimeSpan.FromMilliseconds(300))//延迟一下，因为 中键手势 + 滚动，可能导致快捷键还没结束，而滚轮事件发送到了目标窗口，可鞥解释成其他功能（比如ctrl + 滚轮 = 缩放）                      {                          e.Handled = true;                      }                      break;                    case MouseMsg.WM_LBUTTONDOWN:                      if (_captured)                      {                          e.Handled = HandleModifier(GestureModifier.LeftButtonDown);                      }                      break;                    case MouseMsg.WM_RBUTTONUP:                  case MouseMsg.WM_MBUTTONUP:                  case MouseMsg.WM_XBUTTONUP:                      if (_captured)                      {                          var gestBtn_as_MouseMsg = (MouseMsg)(-1);                          switch(_gestureBtn)                          {                              case GestureTriggerButton.Middle:                                  gestBtn_as_MouseMsg = MouseMsg.WM_MBUTTONUP;                                  break;                              case GestureTriggerButton.Right:                                  gestBtn_as_MouseMsg = MouseMsg.WM_RBUTTONUP;                                  break;                              case GestureTriggerButton.X1:                              case GestureTriggerButton.X2:                                  gestBtn_as_MouseMsg = MouseMsg.WM_XBUTTONUP;                                  break;                              }                                                    //是手势键up                          if (m == gestBtn_as_MouseMsg)                          {                                _captured = false;                                        Post(WM.GESTBTN_UP);                          }                            e.Handled = true;                      }                      break;                  default:                      //其他消息不处理                      break;              }
Magic Number,WGestures.Core.Impl.Windows,Win32MousePathTracker2,C:\repos\yingDev_WGestures\WGestures.Core\Impl\Windows\Win32MousePathTracker2.cs,MouseHookProc,The following statement contains a magic number: switch (m)              {                  //必须在这里立即决定是否应该捕获                  case MouseMsg.WM_RBUTTONDOWN:                  case MouseMsg.WM_MBUTTONDOWN:                  case MouseMsg.WM_XBUTTONDOWN:                      if (!_captured)                      {                          if (m == MouseMsg.WM_MBUTTONDOWN && (TriggerButton & GestureTriggerButton.Middle) == 0                              || m == MouseMsg.WM_RBUTTONDOWN && (TriggerButton & GestureTriggerButton.Right) == 0                              || m == MouseMsg.WM_XBUTTONDOWN && (TriggerButton & GestureTriggerButton.X) == 0)                          {                              return;                          }                          try                          {                              //notice: 这个方法在钩子线程中运行，因此必须足够快，而且不能失败                              _captured = OnBeforePathStart();                                                        }                          catch (Exception ex)                          {  #if DEBUG                              throw;  #endif                              //如果出错，则不捕获手势                              _captured = false;                          }                                                    if (_captured)                          {                              //_gestureBtn = (m == MouseMsg.WM_RBUTTONDOWN ? GestureButtons.RightButton : GestureButtons.MiddleButton);                              switch(m) //TODO: extract function                              {                                  case MouseMsg.WM_RBUTTONDOWN:                                      _gestureBtn = GestureTriggerButton.Right;                                      break;                                  case MouseMsg.WM_MBUTTONDOWN:                                      _gestureBtn = GestureTriggerButton.Middle;                                      break;                                  case MouseMsg.WM_XBUTTONDOWN:                                      var x = (XButtonNumber)(mouseData.mouseData >> 16); //which X Button                                      _gestureBtn = x == XButtonNumber.One ? GestureTriggerButton.X1 : GestureTriggerButton.X2;                                      break;                                  default:                                      Debug.Assert(false' "WTF! shouldn't happen");                                      break;                              }                                                            _modifierEventHappendPrevTime = new DateTime(0);                              e.Handled = true;                              Post(WM.GESTBTN_DOWN);                          }                      }                      else //另一个键作为手势键的时候，作为修饰键                      {                          GestureModifier gestMod;// = m == MouseMsg.WM_RBUTTONDOWN ? GestureModifier.RightButtonDown : GestureModifier.MiddleButtonDown;                            switch(m) //TODO: extract function                          {                              case MouseMsg.WM_RBUTTONDOWN:                                  gestMod = GestureModifier.RightButtonDown;                                  break;                              case MouseMsg.WM_MBUTTONDOWN:                                  gestMod = GestureModifier.MiddleButtonDown;                                  break;                              case MouseMsg.WM_XBUTTONDOWN:                                  var x = (XButtonNumber)(mouseData.mouseData >> 16); //which X Button                                  gestMod = x == XButtonNumber.One ? GestureModifier.X1 : GestureModifier.X2;                                  break;                              default:                                  gestMod = GestureModifier.LeftButtonDown;                                  break;                          }                            e.Handled = HandleModifier(gestMod);                      }                      break;                    case MouseMsg.WM_MOUSEMOVE:                      if (_captured)                      {                          //永远不拦截move消息，所以不设置e.Handled = true                          Post(WM.GESTBTN_MOVE);                      }                      else                       {                         if(_isVirtualGesturing)                          {                              //忽略禁用列表                              OnBeforePathStart();                              _captured = true;                              _gestureBtn = GestureTriggerButton.Right;                              Post(WM.GESTBTN_DOWN' 1);                            }                          //未捕获的情况下才允许hotcorner                          HotCornerHitTest();                      }                      break;                    case MouseMsg.WM_MOUSEWHEEL:                      if (_captured)                      {                          //获得滚动方向                          int delta = (short)(mouseData.mouseData >> 16);                          var gestMod = delta > 0 ? GestureModifier.WheelForward : GestureModifier.WheelBackward;                            e.Handled = HandleModifier(gestMod);                      }                      else if (DateTime.UtcNow - _modifierEventHappendPrevTime < TimeSpan.FromMilliseconds(300))//延迟一下，因为 中键手势 + 滚动，可能导致快捷键还没结束，而滚轮事件发送到了目标窗口，可鞥解释成其他功能（比如ctrl + 滚轮 = 缩放）                      {                          e.Handled = true;                      }                      break;                    case MouseMsg.WM_LBUTTONDOWN:                      if (_captured)                      {                          e.Handled = HandleModifier(GestureModifier.LeftButtonDown);                      }                      break;                    case MouseMsg.WM_RBUTTONUP:                  case MouseMsg.WM_MBUTTONUP:                  case MouseMsg.WM_XBUTTONUP:                      if (_captured)                      {                          var gestBtn_as_MouseMsg = (MouseMsg)(-1);                          switch(_gestureBtn)                          {                              case GestureTriggerButton.Middle:                                  gestBtn_as_MouseMsg = MouseMsg.WM_MBUTTONUP;                                  break;                              case GestureTriggerButton.Right:                                  gestBtn_as_MouseMsg = MouseMsg.WM_RBUTTONUP;                                  break;                              case GestureTriggerButton.X1:                              case GestureTriggerButton.X2:                                  gestBtn_as_MouseMsg = MouseMsg.WM_XBUTTONUP;                                  break;                              }                                                    //是手势键up                          if (m == gestBtn_as_MouseMsg)                          {                                _captured = false;                                        Post(WM.GESTBTN_UP);                          }                            e.Handled = true;                      }                      break;                  default:                      //其他消息不处理                      break;              }
Magic Number,WGestures.Core.Impl.Windows,Win32MousePathTracker2,C:\repos\yingDev_WGestures\WGestures.Core\Impl\Windows\Win32MousePathTracker2.cs,HotCornerHitTest,The following statement contains a magic number: const int TRIGGER_DIST = 2;
Magic Number,WGestures.Core.Impl.Windows,Win32MousePathTracker2,C:\repos\yingDev_WGestures\WGestures.Core\Impl\Windows\Win32MousePathTracker2.cs,HotCornerHitTest,The following statement contains a magic number: const int REST_DIST = 40;
Magic Number,WGestures.Core.Impl.Windows,Win32MousePathTracker2,C:\repos\yingDev_WGestures\WGestures.Core\Impl\Windows\Win32MousePathTracker2.cs,HotCornerHitTest,The following statement contains a magic number: for(corner=0; corner<4; corner++)              {                  var p = GetBoundsCornerPoint( scr.Value' (ScreenCorner)corner );                  var dist = GetPointDistance(ref p' ref _curPos);                    if (!_isHotCornerReset && _lastTriggeredCorner == (ScreenCorner) corner && dist > REST_DIST)                  {                      _isHotCornerReset = true;                  }                  else if (dist <= TRIGGER_DIST && _isHotCornerReset)                  {                      _isHotCornerReset = false;                      _lastTriggeredCorner = (ScreenCorner) corner;                      Post(WM.HOT_CORNER' (int)corner);                  }              }
Magic Number,WGestures.Core.Impl.Windows,Win32MousePathTracker2,C:\repos\yingDev_WGestures\WGestures.Core\Impl\Windows\Win32MousePathTracker2.cs,MakeGestureBtnEvent,The following statement contains a magic number: switch(btn)              {                  case GestureTriggerButton.Right:                      var isMouseSwapped = Native.IsMouseButtonSwapped();                      if(!isMouseSwapped)                      {                          return isUp ? User32.MOUSEEVENTF.MOUSEEVENTF_RIGHTUP : User32.MOUSEEVENTF.MOUSEEVENTF_RIGHTDOWN;                      }else                      {                          return isUp ? User32.MOUSEEVENTF.MOUSEEVENTF_LEFTUP : User32.MOUSEEVENTF.MOUSEEVENTF_LEFTDOWN;                      }                                        case GestureTriggerButton.Middle:                      return isUp ? User32.MOUSEEVENTF.MOUSEEVENTF_MIDDLEUP : User32.MOUSEEVENTF.MOUSEEVENTF_MIDDLEDOWN;                  case GestureTriggerButton.X1:                      data = 1;                      return isUp ? User32.MOUSEEVENTF.MOUSEEVENTF_XUP : User32.MOUSEEVENTF.MOUSEEVENTF_XDOWN;                  case GestureTriggerButton.X2:                      data = 2;                      return isUp ? User32.MOUSEEVENTF.MOUSEEVENTF_XUP : User32.MOUSEEVENTF.MOUSEEVENTF_XDOWN;                    default:                      Debug.Assert(false' "WTF");                      return User32.MOUSEEVENTF.MOUSEEVENTF_ABSOLUTE;              }
Magic Number,WGestures.Core.Impl.Windows,Win32MousePathTracker2,C:\repos\yingDev_WGestures\WGestures.Core\Impl\Windows\Win32MousePathTracker2.cs,HandleModifier,The following statement contains a magic number: if (modifier == (modifier & GestureModifier.Scroll))              {                  //如果事件发生的间隔不到x毫秒，则不发布新事件                  var now = DateTime.UtcNow;                  if (now - _modifierEventHappendPrevTime > TimeSpan.FromMilliseconds(100))                  {                      Post(WM.GESTBTN_MODIFIER' (int)modifier);                      _modifierEventHappendPrevTime = now;                  }              }              else              {                  Post(WM.GESTBTN_MODIFIER' (int)modifier);              }
Magic Number,WGestures.Core.Impl.Windows,Win32MousePathTracker2,C:\repos\yingDev_WGestures\WGestures.Core\Impl\Windows\Win32MousePathTracker2.cs,IsInFullScreenMode,The following statement contains a magic number: if (fgRect == screenRect)              {                  var className = new StringBuilder(64);                  User32.GetClassName(fgWindow' className' className.Capacity);                    var classNameStr = className.ToString();                  if (classNameStr == "WorkerW" || //桌面窗口                      classNameStr == "CanvasWindow" ||                      classNameStr == "ImmersiveLauncher" || //win8 开始屏幕                      classNameStr == "Windows.UI.Core.CoreWindow") //win8 metro                  {                      return false;                  }                    Debug.WriteLine(string.Format("Window[{0:x}] IsInFullScreenMode:"' fgWindow.ToInt64()));                  return true;                }
Magic Number,WGestures.Core.Persistence.Impl,JsonGestureIntentStore,C:\repos\yingDev_WGestures\WGestures.Core\Persistence\Impl\JsonGestureIntentStore.cs,JsonGestureIntentStore,The following statement contains a magic number: if (File.Exists(jsonPath))              {                  Deserialize();              }              else              {                  Apps = new Dictionary<string' ExeApp>();                  GlobalApp = new GlobalApp();                  HotCornerCommands = new AbstractCommand[8]; //4 corners + 4 edges              }
Magic Number,WGestures.Core.Persistence.Impl,JsonGestureIntentStore,C:\repos\yingDev_WGestures\WGestures.Core\Persistence\Impl\JsonGestureIntentStore.cs,Deserialize,The following statement contains a magic number: try              {                  using (var txtReader = new StreamReader(stream))                  using (var jsonReader = new JsonTextReader(txtReader))                  {                      /*var ser = new JsonSerializer();                      ser.Formatting = Formatting.None;                      ser.TypeNameHandling = TypeNameHandling.Auto;                        if (FileVersion.Equals("1"))                      {                          ser.Converters.Add(new GestureIntentConverter_V1());                        }                      else// if (FileVersion.Equals("2"))                      {                          ser.Converters.Add(new GestureIntentConverter());                        }*/                      var result = ser.Deserialize<SerializeWrapper>(jsonReader);                        FileVersion = result.FileVersion;                      GlobalApp = result.Global;                      //Apps = result.Apps;                        Apps = new Dictionary<string' ExeApp>();                        //to lower                      foreach(var a in result.Apps.Values)                      {                          a.ExecutablePath = a.ExecutablePath.ToLower();                          Apps.Add(a.ExecutablePath' a);                      }                        //convert old version GestureButton Value ( 0->1' 1->2)                      if(FileVersion == "1" || FileVersion == "2")                      {                          var globalIntents = GlobalApp.GestureIntents.Values.ToArray();                          GlobalApp.GestureIntents.Clear();                            foreach(var gestIntent in globalIntents)                          {                              gestIntent.Gesture.GestureButton += 1;                              GlobalApp.GestureIntents.Add(gestIntent);                          }                            foreach(var app in Apps.Values)                          {                              var intents = app.GestureIntents.Values.ToArray();                              app.GestureIntents.Clear();                                                     foreach (var gestIntent in intents)                              {                                  gestIntent.Gesture.GestureButton += 1;                                  app.GestureIntents.Add(gestIntent);                              }                          }                      }                        HotCornerCommands = new AbstractCommand[8];                      Array.Copy(result.HotCornerCommands' HotCornerCommands' result.HotCornerCommands.Length);                      //HotCornerCommands = result.HotCornerCommands;                  }              }              finally              {                  if (closeStream) stream.Dispose();              }
Missing Default,WGestures.Core.Commands.Impl,ChangeAudioVolumeCommand,C:\repos\yingDev_WGestures\WGestures.Core\Commands\Impl\ChangeAudioVolumeCommand.cs,ModifierTriggered,The following switch statement is missing a default case: switch (modifier)                  {                      case GestureModifier.WheelForward:                          ReportStatus("+");                          Delta.Times(() => Sim.KeyPress(VirtualKeyCode.VOLUME_UP));                          break;                      case GestureModifier.WheelBackward:                          ReportStatus("-");                          Delta.Times(() => Sim.KeyPress(VirtualKeyCode.VOLUME_DOWN));                          break;                      case GestureModifier.MiddleButtonDown:                          ReportStatus("x");                          Sim.KeyPress(VirtualKeyCode.VOLUME_MUTE);                          break;                    }
Missing Default,WGestures.Core.Commands.Impl,WindowControlCommand,C:\repos\yingDev_WGestures\WGestures.Core\Commands\Impl\WindowControlCommand.cs,DoOperation,The following switch statement is missing a default case: switch (ChangeWindowStateTo)                  {                      case WindowOperation.MAXIMIZE_RESTORE:                          IntPtr winToControl;                          if ((long) User32.WS.WS_MAXIMIZEBOX == (topLevelWinstyle & (long) User32.WS.WS_MAXIMIZEBOX))                          {                              winToControl = topLevelWin;                          }                          else if (topLevelWin != rootWin && (long) User32.WS.WS_MAXIMIZEBOX == (rootWinStyle & (long) User32.WS.WS_MAXIMIZEBOX))                          {                              winToControl = rootWin;                          }                          else //如果窗口都不响应， 考虑回滚为处理活动窗口                          {                              var fgWin = Native.GetForegroundWindow();                              if (fgWin == win) return;                                win = fgWin;                              continue;                          }                            var wp = new User32.WINDOWPLACEMENT();                          wp.length = Marshal.SizeOf(typeof (User32.WINDOWPLACEMENT));                            if (!User32.GetWindowPlacement(rootWin' ref wp)) return;                            if (wp.showCmd == (int) ShowWindowCommands.MAXIMIZED)                          {                              User32.ShowWindowAsync(winToControl' (int) ShowWindowCommands.NORMAL);                          }                          else                          {                              User32.ShowWindowAsync(winToControl' (int) ShowWindowCommands.MAXIMIZED);                          }                          goto end;                        case WindowOperation.MINIMIZE:                          if ((long) User32.WS.WS_MINIMIZEBOX == (rootWinStyle & (long) User32.WS.WS_MINIMIZEBOX))                          {                              User32.PostMessage(rootWin' User32.WM.WM_SYSCOMMAND' (int) User32.SysCommands.SC_MINIMIZE' 0);                          }                          else if (topLevelWin != rootWin && (long) User32.WS.WS_MINIMIZEBOX == (topLevelWinstyle & (long) User32.WS.WS_MINIMIZEBOX))                          {                              User32.PostMessage(topLevelWin' User32.WM.WM_SYSCOMMAND' (int) User32.SysCommands.SC_MINIMIZE' 0);                          }                          goto end;                        case WindowOperation.CLOSE:                          User32.PostMessage(rootWin' User32.WM.WM_SYSCOMMAND' (int) User32.SysCommands.SC_CLOSE' 0);                          goto end;                        case WindowOperation.TOP_MOST:                            if ((rootWinExStyle & (int)User32.WS_EX.WS_EX_TOPMOST) != 0)                          {                              User32.SetWindowPos(rootWin' new IntPtr(-2)' 0' 0' 0' 0' User32.SWP.SWP_NOMOVE | User32.SWP.SWP_NOSIZE);                          }                          else                          {                              User32.SetWindowPos(rootWin' new IntPtr(-1)' 0' 0' 0' 0' User32.SWP.SWP_NOMOVE | User32.SWP.SWP_NOSIZE);                          }                                                    goto end;                  }
Missing Default,WGestures.Core.Impl.Windows,EdgeInteractDetector,C:\repos\yingDev_WGestures\WGestures.Core\Impl\Windows\ScreenEdgeInteractDetector.cs,DetectCollide,The following switch statement is missing a default case: switch (_activeCollideEdge)                  {                      case ScreenEdge.Left:                          bias = Math.Abs(_hLastPtOutsideRedline.Pos.Y - now.Pos.Y);                          if (bias > _currentBias) _currentBias = bias;                          if (e.Pos.X >= redLineDist)                          {                              speed = PointAndTime.CalSpeedVec(_collidePoint' now).X;                          }                          else return;                          break;                      case ScreenEdge.Right:                          bias = Math.Abs(_hLastPtOutsideRedline.Pos.Y - now.Pos.Y);                          if (bias > _currentBias) _currentBias = bias;                          if (e.Pos.X <= _screenBounds.Width - redLineDist)                          {                              speed = -PointAndTime.CalSpeedVec(_collidePoint' now).X;                          }                          else return;                          break;                      case ScreenEdge.Top:                          bias = Math.Abs(_vLastPtOutsideRedline.Pos.X - now.Pos.X);                          if (bias > _currentBias) _currentBias = bias;                          if (e.Pos.Y >= redLineDist)                            {                              speed = PointAndTime.CalSpeedVec(_collidePoint' now).Y;                          }                          else return;                          break;                      case ScreenEdge.Bottom:                          bias = Math.Abs(_vLastPtOutsideRedline.Pos.X - now.Pos.X);                          if (bias > _currentBias) _currentBias = bias;                          if (e.Pos.Y <= _screenBounds.Height - redLineDist)                          {                              speed = -PointAndTime.CalSpeedVec(_collidePoint' now).Y;                          }                          else return;                          break;                  }
Missing Default,WGestures.Core.Impl.Windows,MouseKeyboardHook,C:\repos\yingDev_WGestures\WGestures.Core\Impl\Windows\MouseHook.cs,Install,The following switch statement is missing a default case: switch(msg.message)                          {                              case WM_HOOK_TIMEOUT:                                  Debug.WriteLine("Reinstalling Mouse Hook");                                  try                                  {                                      _uinstall();                                  }catch(Win32Exception e)                                  {                                      Debug.WriteLine(e); //ignore                                  }                                  _install();                                  break;                                                                case (uint)User32.WM.WM_CLOSE:                                  @continue = false;                                  _uinstall();                                  _hookThreadNativeId = 0;                                  break;                          }
Missing Default,WGestures.Core.Impl.Windows,Win32MousePathTracker2,C:\repos\yingDev_WGestures\WGestures.Core\Impl\Windows\Win32MousePathTracker2.cs,Start,The following switch statement is missing a default case: switch (msg.message)                  {                      case WM.GESTBTN_DOWN:                          OnMouseDown();break;                      case WM.GESTBTN_MOVE:                          OnMouseMove();break;                      case WM.HOT_CORNER:                          OnHotCorner((ScreenCorner)msg.param);break;                      case WM.RUB_EDGE:                          OnRubEdge((ScreenEdge)msg.param); break;                      case WM.GESTBTN_MODIFIER:                          OnModifier((GestureModifier)msg.param);break;                      case WM.GESTBTN_UP:                          OnMouseUp(msg.param != 0);break;                      case WM.STAY_TIMEOUT:                          OnTimeout();break;                      case WM.PAUSE_RESUME:                          var pause = (msg.param == 1);                          OnPauseResume(pause);break;                      case WM.GUI_REQUEST:                          if (msg.param == (int) GUI_RequestType.PauseResume)                          {                              if(RequestPauseResume != null) RequestPauseResume(_isPaused);//todo: 必要这个参数吗                          }else if (msg.param == (int) GUI_RequestType.ShowHideTray)                          {                              if (RequestShowHideTray != null) RequestShowHideTray();                          }                          break;                      //case WM.SIMULATE_MOUSE:                        case WM.STOP:                          OnStop();return;                  }
Missing Default,WGestures.Core.Impl.Windows,Win32MousePathTracker2,C:\repos\yingDev_WGestures\WGestures.Core\Impl\Windows\Win32MousePathTracker2.cs,MouseHookProc,The following switch statement is missing a default case: switch(_gestureBtn)                          {                              case GestureTriggerButton.Middle:                                  gestBtn_as_MouseMsg = MouseMsg.WM_MBUTTONUP;                                  break;                              case GestureTriggerButton.Right:                                  gestBtn_as_MouseMsg = MouseMsg.WM_RBUTTONUP;                                  break;                              case GestureTriggerButton.X1:                              case GestureTriggerButton.X2:                                  gestBtn_as_MouseMsg = MouseMsg.WM_XBUTTONUP;                                  break;                              }
