Implementation smell,Namespace,Class,File,Method,Description
Long Parameter List,WGestures.Common.OsSpecific.Windows,CanvasWindow,C:\repos\yingDev_WGestures\WGestures.Common\OsSpecific\Windows\CanvasWindow.cs,SetDiBitmap,The method has 5 parameters. Parameters: bmp' newWindowBounds' drawAt' dirtyRect' opacity
Long Parameter List,WGestures.Common.OsSpecific.Windows,CanvasWindow,C:\repos\yingDev_WGestures\WGestures.Common\OsSpecific\Windows\CanvasWindow.cs,SetHBitmap,The method has 5 parameters. Parameters: hBitmap' newWindowBounds' drawAt' dirtyRect' opacity
Long Parameter List,WGestures.Common.OsSpecific.Windows,Native,C:\repos\yingDev_WGestures\WGestures.Common\OsSpecific\Windows\Native.cs,NtQueryInformationProcess,The method has 5 parameters. Parameters: hProcess' pic' pbi' cb' pSize
Long Parameter List,WGestures.Common.OsSpecific.Windows,Native,C:\repos\yingDev_WGestures\WGestures.Common\OsSpecific\Windows\Native.cs,UpdateLayeredWindow,The method has 9 parameters. Parameters: hwnd' hdcDst' pptDst' psize' hdcSrc' pprSrc' crKey' pblend' dwFlags
Long Parameter List,WGestures.Common.OsSpecific.Windows,Native,C:\repos\yingDev_WGestures\WGestures.Common\OsSpecific\Windows\Native.cs,PeekMessage,The method has 5 parameters. Parameters: lpMsg' hWnd' wMsgFilterMin' wMsgFilterMax' wRemoveMsg
Long Parameter List,WGestures.Common.OsSpecific.Windows,Native,C:\repos\yingDev_WGestures\WGestures.Common\OsSpecific\Windows\Native.cs,CreateDIBSection,The method has 6 parameters. Parameters: hdc' pbmi' pila' ppvBits' hSection' dwOffset
Long Parameter List,Win32,GDI32,C:\repos\yingDev_WGestures\WGestures.Common\OsSpecific\Windows\Win32\GDI32.cs,StretchBlt,The method has 11 parameters. Parameters: hdcDest' nXOriginDest' nYOriginDest' nWidthDest' nHeightDest' hdcSrc' nXOriginSrc' nYOriginSrc' nWidthSrc' nHeightSrc' dwRop
Long Parameter List,Win32,GDI32,C:\repos\yingDev_WGestures\WGestures.Common\OsSpecific\Windows\Win32\GDI32.cs,BitBlt,The method has 9 parameters. Parameters: hdcDest' nXDest' nYDest' nWidth' nHeight' hdcSrc' nXSrc' nYSrc' dwRop
Long Parameter List,Win32,GDI32,C:\repos\yingDev_WGestures\WGestures.Common\OsSpecific\Windows\Win32\GDI32.cs,BitBlt,The method has 9 parameters. Parameters: hdc' nXDest' nYDest' nWidth' nHeight' hdcSrc' nXSrc' nYSrc' dwRop
Long Parameter List,Win32,GDI32,C:\repos\yingDev_WGestures\WGestures.Common\OsSpecific\Windows\Win32\GDI32.cs,TextOut,The method has 5 parameters. Parameters: hdc' nXStart' nYStart' lpString' cbString
Long Parameter List,Win32,Kernel32,C:\repos\yingDev_WGestures\WGestures.Common\OsSpecific\Windows\Win32\Kernel32.cs,SetPowerRequirement,The method has 5 parameters. Parameters: pvDevice' DeviceState' DeviceFlags' pvSystemState' StateFlags
Long Parameter List,Win32,User32,C:\repos\yingDev_WGestures\WGestures.Common\OsSpecific\Windows\Win32\User32.cs,CreateWindowEx,The method has 12 parameters. Parameters: dwExStyle' lpClassName' lpWindowName' dwStyle' x' y' nWidth' nHeight' hWndParent' hMenu' hInstance' lpParam
Long Parameter List,Win32,User32,C:\repos\yingDev_WGestures\WGestures.Common\OsSpecific\Windows\Win32\User32.cs,CallWindowProc,The method has 5 parameters. Parameters: lpPrevWndFunc' hwnd' msg' wParam' lParam
Long Parameter List,Win32,User32,C:\repos\yingDev_WGestures\WGestures.Common\OsSpecific\Windows\Win32\User32.cs,SetWindowPos,The method has 7 parameters. Parameters: hWnd' hWndInsertAfter' X' Y' cx' cy' uFlags
Long Parameter List,Win32,User32,C:\repos\yingDev_WGestures\WGestures.Common\OsSpecific\Windows\Win32\User32.cs,mouse_event,The method has 5 parameters. Parameters: dwFlags' dx' dy' dwData' dwExtraInfo
Long Statement,WGestures.Common.Config,Plist,C:\repos\yingDev_WGestures\WGestures.Common\Config\Plist.cs,writeXml,The length of the statement  "					//xmlWriter.WriteComment("DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" " + "\"http://www.apple.com/DTDs/PropertyList-1.0.dtd\""); " is 137.
Long Statement,WGestures.Common.Config,Plist,C:\repos\yingDev_WGestures\WGestures.Common\Config\Plist.cs,writeXml,The length of the statement  "					xmlWriter.WriteDocType("plist"' "-//Apple Computer//DTD PLIST 1.0//EN"' "http://www.apple.com/DTDs/PropertyList-1.0.dtd"' null); " is 128.
Long Statement,WGestures.Common.Config,Plist,C:\repos\yingDev_WGestures\WGestures.Common\Config\Plist.cs,writeBinaryDate,The length of the statement  "			List<byte> buffer =new List<byte>(RegulateNullBytes(BitConverter.GetBytes(PlistDateConverter.ConvertToAppleTimeStamp(obj))' 8)); " is 128.
Long Statement,WGestures.Common.Config,Plist,C:\repos\yingDev_WGestures\WGestures.Common\Config\Plist.cs,parseBinary,The length of the statement  "					return (objectTable[offsetTable[objRef]] == 0) ? (object)null : ((objectTable[offsetTable[objRef]] == 9) ? true : false); " is 121.
Long Statement,WGestures.Common.OsSpecific.Windows,AutoStarter,C:\repos\yingDev_WGestures\WGestures.Common\OsSpecific\Windows\AutoStarter.cs,CreateShortcut,The length of the statement  "                shortcut.TargetPath = targetFileLocation;                 // The path of the file that will launch when the shortcut is run " is 123.
Long Statement,WGestures.Common.OsSpecific.Windows,CanvasWindow,C:\repos\yingDev_WGestures\WGestures.Common\OsSpecific\Windows\CanvasWindow.cs,SetHBitmap,The length of the statement  "                var blend = new Native.BLENDFUNCTION { BlendOp = GDI32.AC_SRC_OVER' BlendFlags = 0' SourceConstantAlpha = opacity' AlphaFormat = GDI32.AC_SRC_ALPHA }; " is 150.
Long Statement,WGestures.Common.OsSpecific.Windows,CanvasWindow,C:\repos\yingDev_WGestures\WGestures.Common\OsSpecific\Windows\CanvasWindow.cs,SetHBitmap,The length of the statement  "                //Native.UpdateLayeredWindow(Handle' IntPtr.Zero' ref topPos' ref size' memDc' ref pointSource' 0' ref blend' GDI32.ULW_ALPHA); " is 127.
Long Statement,WGestures.Common.OsSpecific.Windows,CanvasWindow,C:\repos\yingDev_WGestures\WGestures.Common\OsSpecific\Windows\CanvasWindow.cs,SetHBitmap,The length of the statement  "                    //Windows.DeleteObject(hBitmap); // The documentation says that we have to use the Windows.DeleteObject... but since there is no such method I use the normal DeleteObject from Win32 GDI and it's working fine without any resource leak. " is 234.
Long Statement,WGestures.Common.OsSpecific.Windows,Native,C:\repos\yingDev_WGestures\WGestures.Common\OsSpecific\Windows\Native.cs,TryResetKeys,The length of the statement  "                dummyWnd.CreateHandle(new CreateParams(){ExStyle = (int) (User32.WS_EX.WS_EX_LAYERED | User32.WS_EX.WS_EX_TOOLWINDOW)}); " is 120.
Long Statement,WGestures.Common.OsSpecific.Windows,Screen,C:\repos\yingDev_WGestures\WGestures.Common\OsSpecific\Windows\Screen.cs,ToString,The length of the statement  "            return GetType().Name + "[Bounds=" + bounds.ToString() + " WorkingArea=" + WorkingArea.ToString() + " Primary=" + primary.ToString() + " DeviceName=" + deviceName; " is 163.
Virtual Method Call from Constructor,WGestures.Common.Product,VersionChecker,C:\repos\yingDev_WGestures\WGestures.Common\Product\VersionChecker.cs,VersionChecker,The constructor "VersionChecker" calls a virtual method "OnCanceled".
Virtual Method Call from Constructor,WGestures.Common.Product,VersionChecker,C:\repos\yingDev_WGestures\WGestures.Common\Product\VersionChecker.cs,VersionChecker,The constructor "VersionChecker" calls a virtual method "OnErrorHappened".
Virtual Method Call from Constructor,WGestures.Common.Product,VersionChecker,C:\repos\yingDev_WGestures\WGestures.Common\Product\VersionChecker.cs,VersionChecker,The constructor "VersionChecker" calls a virtual method "OnErrorHappened".
Virtual Method Call from Constructor,WGestures.Common.Product,VersionChecker,C:\repos\yingDev_WGestures\WGestures.Common\Product\VersionChecker.cs,VersionChecker,The constructor "VersionChecker" calls a virtual method "OnFinished".
Magic Number,WGestures.Common.Config,Plist,C:\repos\yingDev_WGestures\WGestures.Common\Config\Plist.cs,getPlistType,The following statement contains a magic number: byte[] magicHeader = new byte[8];
Magic Number,WGestures.Common.Config,Plist,C:\repos\yingDev_WGestures\WGestures.Common\Config\Plist.cs,getPlistType,The following statement contains a magic number: stream.Read(magicHeader' 0' 8);
Magic Number,WGestures.Common.Config,Plist,C:\repos\yingDev_WGestures\WGestures.Common\Config\Plist.cs,getPlistType,The following statement contains a magic number: if (BitConverter.ToInt64(magicHeader' 0) == 3472403351741427810)  			{  				return plistType.Binary;  			}  			else  			{  				return plistType.Xml;  			}
Magic Number,WGestures.Common.Config,Plist,C:\repos\yingDev_WGestures\WGestures.Common\Config\Plist.cs,writeBinary,The following statement contains a magic number: offsetTable.Add(objectTable.Count - 8);
Magic Number,WGestures.Common.Config,Plist,C:\repos\yingDev_WGestures\WGestures.Common\Config\Plist.cs,writeBinary,The following statement contains a magic number: objectTable.AddRange(new byte[6]);
Magic Number,WGestures.Common.Config,Plist,C:\repos\yingDev_WGestures\WGestures.Common\Config\Plist.cs,readBinary,The following statement contains a magic number: List<byte> trailer = bList.GetRange(bList.Count - 32' 32);
Magic Number,WGestures.Common.Config,Plist,C:\repos\yingDev_WGestures\WGestures.Common\Config\Plist.cs,readBinary,The following statement contains a magic number: List<byte> trailer = bList.GetRange(bList.Count - 32' 32);
Magic Number,WGestures.Common.Config,Plist,C:\repos\yingDev_WGestures\WGestures.Common\Config\Plist.cs,readBinary,The following statement contains a magic number: offsetTableBytes = bList.GetRange((int)offsetTableOffset' bList.Count - (int)offsetTableOffset - 32);
Magic Number,WGestures.Common.Config,Plist,C:\repos\yingDev_WGestures\WGestures.Common\Config\Plist.cs,parseDictionary,The following statement contains a magic number: if (children.Count % 2 != 0)  			{  				throw new DataMisalignedException("Dictionary elements must have an even number of child nodes");  			}
Magic Number,WGestures.Common.Config,Plist,C:\repos\yingDev_WGestures\WGestures.Common\Config\Plist.cs,parseDictionary,The following statement contains a magic number: for (int i = 0; i < children.Count; i += 2)  			{  				XmlNode keynode = children[i];  				XmlNode valnode = children[i + 1];    				if (keynode.Name != "key")  				{  					throw new ApplicationException("expected a key node");  				}    				object result = parse(valnode);    				if (result != null)  				{  					dict.Add(keynode.InnerText' result);  				}  			}
Magic Number,WGestures.Common.Config,Plist,C:\repos\yingDev_WGestures\WGestures.Common\Config\Plist.cs,writeBinaryDictionary,The following statement contains a magic number: if (dictionary.Count < 15)  			{  				header.Add(Convert.ToByte(0xD0 | Convert.ToByte(dictionary.Count)));  			}  			else  			{  				header.Add(0xD0 | 0xf);  				header.AddRange(writeBinaryInteger(dictionary.Count' false));  			}
Magic Number,WGestures.Common.Config,Plist,C:\repos\yingDev_WGestures\WGestures.Common\Config\Plist.cs,composeBinaryArray,The following statement contains a magic number: if (objects.Count < 15)  			{  				header.Add(Convert.ToByte(0xA0 | Convert.ToByte(objects.Count)));  			}  			else  			{  				header.Add(0xA0 | 0xf);  				header.AddRange(writeBinaryInteger(objects.Count' false));  			}
Magic Number,WGestures.Common.Config,Plist,C:\repos\yingDev_WGestures\WGestures.Common\Config\Plist.cs,writeBinaryDate,The following statement contains a magic number: List<byte> buffer =new List<byte>(RegulateNullBytes(BitConverter.GetBytes(PlistDateConverter.ConvertToAppleTimeStamp(obj))' 8));
Magic Number,WGestures.Common.Config,Plist,C:\repos\yingDev_WGestures\WGestures.Common\Config\Plist.cs,writeBinaryBool,The following statement contains a magic number: List<byte> buffer = new List<byte>(new byte[1] { (bool)obj ? (byte)9 : (byte)8 });
Magic Number,WGestures.Common.Config,Plist,C:\repos\yingDev_WGestures\WGestures.Common\Config\Plist.cs,writeBinaryBool,The following statement contains a magic number: List<byte> buffer = new List<byte>(new byte[1] { (bool)obj ? (byte)9 : (byte)8 });
Magic Number,WGestures.Common.Config,Plist,C:\repos\yingDev_WGestures\WGestures.Common\Config\Plist.cs,writeBinaryInteger,The following statement contains a magic number: while (buffer.Count != Math.Pow(2' Math.Log(buffer.Count) / Math.Log(2)))  				buffer.Add(0);
Magic Number,WGestures.Common.Config,Plist,C:\repos\yingDev_WGestures\WGestures.Common\Config\Plist.cs,writeBinaryInteger,The following statement contains a magic number: while (buffer.Count != Math.Pow(2' Math.Log(buffer.Count) / Math.Log(2)))  				buffer.Add(0);
Magic Number,WGestures.Common.Config,Plist,C:\repos\yingDev_WGestures\WGestures.Common\Config\Plist.cs,writeBinaryInteger,The following statement contains a magic number: int header = 0x10 | (int)(Math.Log(buffer.Count) / Math.Log(2));
Magic Number,WGestures.Common.Config,Plist,C:\repos\yingDev_WGestures\WGestures.Common\Config\Plist.cs,writeBinaryDouble,The following statement contains a magic number: List<byte> buffer =new List<byte>(RegulateNullBytes(BitConverter.GetBytes(value)' 4));
Magic Number,WGestures.Common.Config,Plist,C:\repos\yingDev_WGestures\WGestures.Common\Config\Plist.cs,writeBinaryDouble,The following statement contains a magic number: while (buffer.Count != Math.Pow(2' Math.Log(buffer.Count) / Math.Log(2)))  				buffer.Add(0);
Magic Number,WGestures.Common.Config,Plist,C:\repos\yingDev_WGestures\WGestures.Common\Config\Plist.cs,writeBinaryDouble,The following statement contains a magic number: while (buffer.Count != Math.Pow(2' Math.Log(buffer.Count) / Math.Log(2)))  				buffer.Add(0);
Magic Number,WGestures.Common.Config,Plist,C:\repos\yingDev_WGestures\WGestures.Common\Config\Plist.cs,writeBinaryDouble,The following statement contains a magic number: int header = 0x20 | (int)(Math.Log(buffer.Count) / Math.Log(2));
Magic Number,WGestures.Common.Config,Plist,C:\repos\yingDev_WGestures\WGestures.Common\Config\Plist.cs,writeBinaryByteArray,The following statement contains a magic number: if (value.Length < 15)  			{  				header.Add(Convert.ToByte(0x40 | Convert.ToByte(value.Length)));  			}  			else  			{  				header.Add(0x40 | 0xf);  				header.AddRange(writeBinaryInteger(buffer.Count' false));  			}
Magic Number,WGestures.Common.Config,Plist,C:\repos\yingDev_WGestures\WGestures.Common\Config\Plist.cs,writeBinaryString,The following statement contains a magic number: if (head)  			{  				if (value.Length < 15)  				{  					header.Add(Convert.ToByte(0x50 | Convert.ToByte(value.Length)));  				}  				else  				{  					header.Add(0x50 | 0xf);  					header.AddRange(writeBinaryInteger(buffer.Count' false));  				}  			}
Magic Number,WGestures.Common.Config,Plist,C:\repos\yingDev_WGestures\WGestures.Common\Config\Plist.cs,parseTrailer,The following statement contains a magic number: offsetByteSize = BitConverter.ToInt32(RegulateNullBytes(trailer.GetRange(6' 1).ToArray()' 4)' 0);
Magic Number,WGestures.Common.Config,Plist,C:\repos\yingDev_WGestures\WGestures.Common\Config\Plist.cs,parseTrailer,The following statement contains a magic number: offsetByteSize = BitConverter.ToInt32(RegulateNullBytes(trailer.GetRange(6' 1).ToArray()' 4)' 0);
Magic Number,WGestures.Common.Config,Plist,C:\repos\yingDev_WGestures\WGestures.Common\Config\Plist.cs,parseTrailer,The following statement contains a magic number: objRefSize = BitConverter.ToInt32(RegulateNullBytes(trailer.GetRange(7' 1).ToArray()' 4)' 0);
Magic Number,WGestures.Common.Config,Plist,C:\repos\yingDev_WGestures\WGestures.Common\Config\Plist.cs,parseTrailer,The following statement contains a magic number: objRefSize = BitConverter.ToInt32(RegulateNullBytes(trailer.GetRange(7' 1).ToArray()' 4)' 0);
Magic Number,WGestures.Common.Config,Plist,C:\repos\yingDev_WGestures\WGestures.Common\Config\Plist.cs,parseTrailer,The following statement contains a magic number: byte[] refCountBytes = trailer.GetRange(12' 4).ToArray();
Magic Number,WGestures.Common.Config,Plist,C:\repos\yingDev_WGestures\WGestures.Common\Config\Plist.cs,parseTrailer,The following statement contains a magic number: byte[] refCountBytes = trailer.GetRange(12' 4).ToArray();
Magic Number,WGestures.Common.Config,Plist,C:\repos\yingDev_WGestures\WGestures.Common\Config\Plist.cs,parseTrailer,The following statement contains a magic number: byte[] offsetTableOffsetBytes = trailer.GetRange(24' 8).ToArray();
Magic Number,WGestures.Common.Config,Plist,C:\repos\yingDev_WGestures\WGestures.Common\Config\Plist.cs,parseTrailer,The following statement contains a magic number: byte[] offsetTableOffsetBytes = trailer.GetRange(24' 8).ToArray();
Magic Number,WGestures.Common.Config,Plist,C:\repos\yingDev_WGestures\WGestures.Common\Config\Plist.cs,parseOffsetTable,The following statement contains a magic number: for (int i = 0; i < offsetTableBytes.Count; i += offsetByteSize)  			{  				byte[] buffer = offsetTableBytes.GetRange(i' offsetByteSize).ToArray();  				Array.Reverse(buffer);  				offsetTable.Add(BitConverter.ToInt32(RegulateNullBytes(buffer' 4)' 0));  			}
Magic Number,WGestures.Common.Config,Plist,C:\repos\yingDev_WGestures\WGestures.Common\Config\Plist.cs,parseBinaryDictionary,The following statement contains a magic number: if (refCount < 15)  				refStartPosition = offsetTable[objRef] + 1;  			else  				refStartPosition = offsetTable[objRef] + 2 + RegulateNullBytes(BitConverter.GetBytes(refCount)' 1).Length;
Magic Number,WGestures.Common.Config,Plist,C:\repos\yingDev_WGestures\WGestures.Common\Config\Plist.cs,parseBinaryDictionary,The following statement contains a magic number: if (refCount < 15)  				refStartPosition = offsetTable[objRef] + 1;  			else  				refStartPosition = offsetTable[objRef] + 2 + RegulateNullBytes(BitConverter.GetBytes(refCount)' 1).Length;
Magic Number,WGestures.Common.Config,Plist,C:\repos\yingDev_WGestures\WGestures.Common\Config\Plist.cs,parseBinaryDictionary,The following statement contains a magic number: for (int i = refStartPosition; i < refStartPosition + refCount * 2 * objRefSize; i += objRefSize)  			{  				byte[] refBuffer = objectTable.GetRange(i' objRefSize).ToArray();  				Array.Reverse(refBuffer);  				refs.Add(BitConverter.ToInt32(RegulateNullBytes(refBuffer' 4)' 0));  			}
Magic Number,WGestures.Common.Config,Plist,C:\repos\yingDev_WGestures\WGestures.Common\Config\Plist.cs,parseBinaryDictionary,The following statement contains a magic number: for (int i = refStartPosition; i < refStartPosition + refCount * 2 * objRefSize; i += objRefSize)  			{  				byte[] refBuffer = objectTable.GetRange(i' objRefSize).ToArray();  				Array.Reverse(refBuffer);  				refs.Add(BitConverter.ToInt32(RegulateNullBytes(refBuffer' 4)' 0));  			}
Magic Number,WGestures.Common.Config,Plist,C:\repos\yingDev_WGestures\WGestures.Common\Config\Plist.cs,parseBinaryArray,The following statement contains a magic number: if (refCount < 15)  				refStartPosition = offsetTable[objRef] + 1;  			else  				//The following integer has a header aswell so we increase the refStartPosition by two to account for that.  				refStartPosition = offsetTable[objRef] + 2 + RegulateNullBytes(BitConverter.GetBytes(refCount)' 1).Length;
Magic Number,WGestures.Common.Config,Plist,C:\repos\yingDev_WGestures\WGestures.Common\Config\Plist.cs,parseBinaryArray,The following statement contains a magic number: if (refCount < 15)  				refStartPosition = offsetTable[objRef] + 1;  			else  				//The following integer has a header aswell so we increase the refStartPosition by two to account for that.  				refStartPosition = offsetTable[objRef] + 2 + RegulateNullBytes(BitConverter.GetBytes(refCount)' 1).Length;
Magic Number,WGestures.Common.Config,Plist,C:\repos\yingDev_WGestures\WGestures.Common\Config\Plist.cs,parseBinaryArray,The following statement contains a magic number: for (int i = refStartPosition; i < refStartPosition + refCount * objRefSize; i += objRefSize)  			{  				byte[] refBuffer = objectTable.GetRange(i' objRefSize).ToArray();  				Array.Reverse(refBuffer);  				refs.Add(BitConverter.ToInt32(RegulateNullBytes(refBuffer' 4)' 0));  			}
Magic Number,WGestures.Common.Config,Plist,C:\repos\yingDev_WGestures\WGestures.Common\Config\Plist.cs,getCount,The following statement contains a magic number: if (headerByteTrail < 15)  			{  				count = headerByteTrail;  				newBytePosition = bytePosition + 1;  			}  			else  				count = (int)parseBinaryInt(bytePosition + 1' out newBytePosition);
Magic Number,WGestures.Common.Config,Plist,C:\repos\yingDev_WGestures\WGestures.Common\Config\Plist.cs,parseBinary,The following statement contains a magic number: switch (header & 0xF0)  			{  			case 0:  				{  					//If the byte is  					//0 return null  					//9 return true  					//8 return false  					return (objectTable[offsetTable[objRef]] == 0) ? (object)null : ((objectTable[offsetTable[objRef]] == 9) ? true : false);  				}  			case 0x10:  				{  					return parseBinaryInt(offsetTable[objRef]);  				}  			case 0x20:  				{  					return parseBinaryReal(offsetTable[objRef]);  				}  			case 0x30:  				{  					return parseBinaryDate(offsetTable[objRef]);  				}  			case 0x40:  				{  					return parseBinaryByteArray(offsetTable[objRef]);  				}  			case 0x50://String ASCII  				{  					return parseBinaryAsciiString(offsetTable[objRef]);  				}  			case 0x60://String Unicode  				{  					return parseBinaryUnicodeString(offsetTable[objRef]);  				}  			case 0xD0:  				{  					return parseBinaryDictionary(objRef);  				}  			case 0xA0:  				{  					return parseBinaryArray(objRef);  				}  			}
Magic Number,WGestures.Common.Config,Plist,C:\repos\yingDev_WGestures\WGestures.Common\Config\Plist.cs,parseBinaryDate,The following statement contains a magic number: byte[] buffer = objectTable.GetRange(headerPosition + 1' 8).ToArray();
Magic Number,WGestures.Common.Config,Plist,C:\repos\yingDev_WGestures\WGestures.Common\Config\Plist.cs,parseBinaryInt,The following statement contains a magic number: int byteCount = (int)Math.Pow(2' header & 0xf);
Magic Number,WGestures.Common.Config,Plist,C:\repos\yingDev_WGestures\WGestures.Common\Config\Plist.cs,parseBinaryInt,The following statement contains a magic number: return BitConverter.ToInt32(RegulateNullBytes(buffer' 4)' 0);
Magic Number,WGestures.Common.Config,Plist,C:\repos\yingDev_WGestures\WGestures.Common\Config\Plist.cs,parseBinaryReal,The following statement contains a magic number: int byteCount = (int)Math.Pow(2' header & 0xf);
Magic Number,WGestures.Common.Config,Plist,C:\repos\yingDev_WGestures\WGestures.Common\Config\Plist.cs,parseBinaryReal,The following statement contains a magic number: return BitConverter.ToDouble(RegulateNullBytes(buffer' 8)' 0);
Magic Number,WGestures.Common.Config,Plist,C:\repos\yingDev_WGestures\WGestures.Common\Config\Plist.cs,parseBinaryUnicodeString,The following statement contains a magic number: charCount = charCount * 2;
Magic Number,WGestures.Common.Config,Plist,C:\repos\yingDev_WGestures\WGestures.Common\Config\Plist.cs,parseBinaryUnicodeString,The following statement contains a magic number: for (int i = 0; i < charCount; i+=2)  			{  				one = objectTable.GetRange(charStartPosition+i'1)[0];  				two = objectTable.GetRange(charStartPosition + i+1' 1)[0];    				if (BitConverter.IsLittleEndian)  				{  					buffer[i] = two;  					buffer[i + 1] = one;  				}  				else  				{  					buffer[i] = one;  					buffer[i + 1] = two;  				}  			}
Magic Number,WGestures.Common.Config,PlistDateConverter,C:\repos\yingDev_WGestures\WGestures.Common\Config\Plist.cs,ConvertFromAppleTimeStamp,The following statement contains a magic number: DateTime origin = new DateTime(2001' 1' 1' 0' 0' 0' 0);
Magic Number,WGestures.Common.Config,PlistDateConverter,C:\repos\yingDev_WGestures\WGestures.Common\Config\Plist.cs,ConvertToAppleTimeStamp,The following statement contains a magic number: DateTime begin = new DateTime(2001' 1' 1' 0' 0' 0' 0);
Magic Number,WGestures.Common,DetailedConsoleListener,C:\repos\yingDev_WGestures\WGestures.Common\DetailedDebugListener.cs,WriteLine,The following statement contains a magic number: var mth = new StackTrace().GetFrame(2).GetMethod();
Magic Number,WGestures.Common.OsSpecific.Windows,CanvasWindow,C:\repos\yingDev_WGestures\WGestures.Common\OsSpecific\Windows\CanvasWindow.cs,CanvasWindow,The following statement contains a magic number: _bounds = new Rectangle(0' 0' 400' 300);
Magic Number,WGestures.Common.OsSpecific.Windows,CanvasWindow,C:\repos\yingDev_WGestures\WGestures.Common\OsSpecific\Windows\CanvasWindow.cs,CanvasWindow,The following statement contains a magic number: _bounds = new Rectangle(0' 0' 400' 300);
Magic Number,WGestures.Common.OsSpecific.Windows,CanvasWindow,C:\repos\yingDev_WGestures\WGestures.Common\OsSpecific\Windows\CanvasWindow.cs,SetDiBitmap,The following statement contains a magic number: SetDiBitmap(bmp'dirtyRect'255);
Magic Number,WGestures.Common.OsSpecific.Windows,CanvasWindow,C:\repos\yingDev_WGestures\WGestures.Common\OsSpecific\Windows\CanvasWindow.cs,SetDiBitmap,The following statement contains a magic number: SetHBitmap(bmp.HBitmap' _bounds' new Point()' new Rectangle(new Point()' bmp.Size)' 255);
Magic Number,WGestures.Common.OsSpecific.Windows,CanvasWindow,C:\repos\yingDev_WGestures\WGestures.Common\OsSpecific\Windows\CanvasWindow.cs,SetDiBitmap,The following statement contains a magic number: SetHBitmap(bmp.HBitmap' _bounds' drawAt' new Rectangle(0' 0' bmp.Size.Width' bmp.Size.Height)' 255);
Magic Number,WGestures.Common.OsSpecific.Windows,HotKey,C:\repos\yingDev_WGestures\WGestures.Common\OsSpecific\Windows\GlobalHotKeyManager.cs,ToBytes,The following statement contains a magic number: return BitConverter.GetBytes( ((ulong)key) | ( ((ulong)modifiers) << 32 ) );
Magic Number,WGestures.Common.OsSpecific.Windows,HotKey,C:\repos\yingDev_WGestures\WGestures.Common\OsSpecific\Windows\GlobalHotKeyManager.cs,FromBytes,The following statement contains a magic number: ret.modifiers = (ModifierKeys)(valueUlong >> 32);
Magic Number,WGestures.Common.OsSpecific.Windows,Window,C:\repos\yingDev_WGestures\WGestures.Common\OsSpecific\Windows\GlobalHotKeyManager.cs,WndProc,The following statement contains a magic number: if (m.Msg == WM_HOTKEY)                  {                      // get the keys.                      Keys key = (Keys)(((int)m.LParam >> 16) & 0xFFFF);                      ModifierKeys modifier = (ModifierKeys)((int)m.LParam & 0xFFFF);                        // invoke the event to notify the parent.                      if (KeyPressed != null)                          KeyPressed(this' new HotKeyEventArgs(new HotKey(modifier' key)));                                        }else                  {                      base.WndProc(ref m);                  }
Magic Number,WGestures.Common.OsSpecific.Windows,Native,C:\repos\yingDev_WGestures\WGestures.Common\OsSpecific\Windows\Native.cs,GetWindowColorization,The following statement contains a magic number: try              {                  var argbColor = (int)Microsoft.Win32.Registry.GetValue(@"HKEY_CURRENT_USER\Software\Microsoft\Windows\DWM"'                  "ColorizationColor"' 0);                  return Color.FromArgb(argbColor);                }              catch (Exception e)              {                  Debug.WriteLine("WindowsUtil.GetWindowColorization: " + e);                  return Color.FromArgb(120' 0'0'0);              }
Magic Number,WGestures.Common.OsSpecific.Windows,Native,C:\repos\yingDev_WGestures\WGestures.Common\OsSpecific\Windows\Native.cs,WaitForInputIdle,The following statement contains a magic number: do              {                  //Thread.Sleep(10);                    if (IsThreadIdle(pid' tid))                  {                      //Console.Write(" Idle ");                      return true;                  }                    Thread.Sleep(10);              } while (timeout > 0 && Environment.TickCount - tick < timeout);
Magic Number,WGestures.Common.OsSpecific.Windows,Native,C:\repos\yingDev_WGestures\WGestures.Common\OsSpecific\Windows\Native.cs,GetProcessFile,The following statement contains a magic number: const int pathLength = 256;
Magic Number,WGestures.Common.OsSpecific.Windows,Native,C:\repos\yingDev_WGestures\WGestures.Common\OsSpecific\Windows\Native.cs,TryResetKeys,The following statement contains a magic number: try              {                  //如果被系统或者杀毒软件阻止， 则发送给自己的一个窗口，这样避免被在此拦截。                  dummyWnd.CreateHandle(new CreateParams(){ExStyle = (int) (User32.WS_EX.WS_EX_LAYERED | User32.WS_EX.WS_EX_TOOLWINDOW)});                  User32.ShowWindow(dummyWnd.Handle' User32.SW.SW_SHOWNORMAL);                    var sim = new InputSimulator() { ExtraInfo = new IntPtr(19900620) };                  sim.Keyboard.Sleep(10);                    foreach (var keys in allKeys)                  {                       foreach (var k in keys)                      {                          User32.SetForegroundWindow(dummyWnd.Handle);                          sim.Keyboard.KeyUp(k);                      }                  }                }              catch (Exception)              {                  Debug.WriteLine("恢复键盘状态失败");  #if TEST                  throw;  #endif              }              finally              {                  dummyWnd.DestroyHandle();              }
Magic Number,WGestures.Common.OsSpecific.Windows,Native,C:\repos\yingDev_WGestures\WGestures.Common\OsSpecific\Windows\Native.cs,TryResetKeys,The following statement contains a magic number: try              {                  //如果被系统或者杀毒软件阻止， 则发送给自己的一个窗口，这样避免被在此拦截。                  dummyWnd.CreateHandle(new CreateParams(){ExStyle = (int) (User32.WS_EX.WS_EX_LAYERED | User32.WS_EX.WS_EX_TOOLWINDOW)});                  User32.ShowWindow(dummyWnd.Handle' User32.SW.SW_SHOWNORMAL);                    var sim = new InputSimulator() { ExtraInfo = new IntPtr(19900620) };                  sim.Keyboard.Sleep(10);                    foreach (var keys in allKeys)                  {                       foreach (var k in keys)                      {                          User32.SetForegroundWindow(dummyWnd.Handle);                          sim.Keyboard.KeyUp(k);                      }                  }                }              catch (Exception)              {                  Debug.WriteLine("恢复键盘状态失败");  #if TEST                  throw;  #endif              }              finally              {                  dummyWnd.DestroyHandle();              }
Magic Number,WGestures.Common.OsSpecific.Windows,Screen,C:\repos\yingDev_WGestures\WGestures.Common\OsSpecific\Windows\Screen.cs,Screen,The following statement contains a magic number: if (!multiMonitorSupport || monitor == (IntPtr)PRIMARY_MONITOR) {                  // Single monitor system                  //                    if (User32.GetSystemMetrics(80) != 0)                  {                      bounds = new Rectangle(User32.GetSystemMetrics(76)'                                           User32.GetSystemMetrics(77)'                                           User32.GetSystemMetrics(78)'                                           User32.GetSystemMetrics(79));                  }                  else                  {                      Size size = new Size(User32.GetSystemMetrics(0)'User32.GetSystemMetrics(1));                      bounds =  new Rectangle(0' 0' size.Width' size.Height);                  }                  //bounds = SystemInformation.VirtualScreen;                  primary = true;                  deviceName = "DISPLAY";              }              else {                  // MultiMonitor System                  // We call the 'A' version of GetMonitorInfoA() because                  // the 'W' version just never fills out the struct properly on Win2K.                  //                  var info = new User32.MonitorInfoEx();                  info.Init();                    User32.GetMonitorInfo(monitor' ref info);                  bounds = Rectangle.FromLTRB(info.Monitor.Left' info.Monitor.Top' info.Monitor.Right' info.Monitor.Bottom);                  primary = ((info.Flags & MONITORINFOF_PRIMARY) != 0);                  /*int count = info.DeviceName.Length;                  while (count > 0 && info.DeviceName[count - 1] == (char)0) {                      count--;                  }                     deviceName = new string(info.szDevice);                  deviceName = deviceName.TrimEnd((char)0);*/                    deviceName = info.DeviceName;                  if (hdc == IntPtr.Zero) {                                            screenDC = GDI32.CreateDC(deviceName' null' null' new HandleRef());                  }                 }
Magic Number,WGestures.Common.OsSpecific.Windows,Screen,C:\repos\yingDev_WGestures\WGestures.Common\OsSpecific\Windows\Screen.cs,Screen,The following statement contains a magic number: if (!multiMonitorSupport || monitor == (IntPtr)PRIMARY_MONITOR) {                  // Single monitor system                  //                    if (User32.GetSystemMetrics(80) != 0)                  {                      bounds = new Rectangle(User32.GetSystemMetrics(76)'                                           User32.GetSystemMetrics(77)'                                           User32.GetSystemMetrics(78)'                                           User32.GetSystemMetrics(79));                  }                  else                  {                      Size size = new Size(User32.GetSystemMetrics(0)'User32.GetSystemMetrics(1));                      bounds =  new Rectangle(0' 0' size.Width' size.Height);                  }                  //bounds = SystemInformation.VirtualScreen;                  primary = true;                  deviceName = "DISPLAY";              }              else {                  // MultiMonitor System                  // We call the 'A' version of GetMonitorInfoA() because                  // the 'W' version just never fills out the struct properly on Win2K.                  //                  var info = new User32.MonitorInfoEx();                  info.Init();                    User32.GetMonitorInfo(monitor' ref info);                  bounds = Rectangle.FromLTRB(info.Monitor.Left' info.Monitor.Top' info.Monitor.Right' info.Monitor.Bottom);                  primary = ((info.Flags & MONITORINFOF_PRIMARY) != 0);                  /*int count = info.DeviceName.Length;                  while (count > 0 && info.DeviceName[count - 1] == (char)0) {                      count--;                  }                     deviceName = new string(info.szDevice);                  deviceName = deviceName.TrimEnd((char)0);*/                    deviceName = info.DeviceName;                  if (hdc == IntPtr.Zero) {                                            screenDC = GDI32.CreateDC(deviceName' null' null' new HandleRef());                  }                 }
Magic Number,WGestures.Common.OsSpecific.Windows,Screen,C:\repos\yingDev_WGestures\WGestures.Common\OsSpecific\Windows\Screen.cs,Screen,The following statement contains a magic number: if (!multiMonitorSupport || monitor == (IntPtr)PRIMARY_MONITOR) {                  // Single monitor system                  //                    if (User32.GetSystemMetrics(80) != 0)                  {                      bounds = new Rectangle(User32.GetSystemMetrics(76)'                                           User32.GetSystemMetrics(77)'                                           User32.GetSystemMetrics(78)'                                           User32.GetSystemMetrics(79));                  }                  else                  {                      Size size = new Size(User32.GetSystemMetrics(0)'User32.GetSystemMetrics(1));                      bounds =  new Rectangle(0' 0' size.Width' size.Height);                  }                  //bounds = SystemInformation.VirtualScreen;                  primary = true;                  deviceName = "DISPLAY";              }              else {                  // MultiMonitor System                  // We call the 'A' version of GetMonitorInfoA() because                  // the 'W' version just never fills out the struct properly on Win2K.                  //                  var info = new User32.MonitorInfoEx();                  info.Init();                    User32.GetMonitorInfo(monitor' ref info);                  bounds = Rectangle.FromLTRB(info.Monitor.Left' info.Monitor.Top' info.Monitor.Right' info.Monitor.Bottom);                  primary = ((info.Flags & MONITORINFOF_PRIMARY) != 0);                  /*int count = info.DeviceName.Length;                  while (count > 0 && info.DeviceName[count - 1] == (char)0) {                      count--;                  }                     deviceName = new string(info.szDevice);                  deviceName = deviceName.TrimEnd((char)0);*/                    deviceName = info.DeviceName;                  if (hdc == IntPtr.Zero) {                                            screenDC = GDI32.CreateDC(deviceName' null' null' new HandleRef());                  }                 }
Magic Number,WGestures.Common.OsSpecific.Windows,Screen,C:\repos\yingDev_WGestures\WGestures.Common\OsSpecific\Windows\Screen.cs,Screen,The following statement contains a magic number: if (!multiMonitorSupport || monitor == (IntPtr)PRIMARY_MONITOR) {                  // Single monitor system                  //                    if (User32.GetSystemMetrics(80) != 0)                  {                      bounds = new Rectangle(User32.GetSystemMetrics(76)'                                           User32.GetSystemMetrics(77)'                                           User32.GetSystemMetrics(78)'                                           User32.GetSystemMetrics(79));                  }                  else                  {                      Size size = new Size(User32.GetSystemMetrics(0)'User32.GetSystemMetrics(1));                      bounds =  new Rectangle(0' 0' size.Width' size.Height);                  }                  //bounds = SystemInformation.VirtualScreen;                  primary = true;                  deviceName = "DISPLAY";              }              else {                  // MultiMonitor System                  // We call the 'A' version of GetMonitorInfoA() because                  // the 'W' version just never fills out the struct properly on Win2K.                  //                  var info = new User32.MonitorInfoEx();                  info.Init();                    User32.GetMonitorInfo(monitor' ref info);                  bounds = Rectangle.FromLTRB(info.Monitor.Left' info.Monitor.Top' info.Monitor.Right' info.Monitor.Bottom);                  primary = ((info.Flags & MONITORINFOF_PRIMARY) != 0);                  /*int count = info.DeviceName.Length;                  while (count > 0 && info.DeviceName[count - 1] == (char)0) {                      count--;                  }                     deviceName = new string(info.szDevice);                  deviceName = deviceName.TrimEnd((char)0);*/                    deviceName = info.DeviceName;                  if (hdc == IntPtr.Zero) {                                            screenDC = GDI32.CreateDC(deviceName' null' null' new HandleRef());                  }                 }
Magic Number,WGestures.Common.OsSpecific.Windows,Screen,C:\repos\yingDev_WGestures\WGestures.Common\OsSpecific\Windows\Screen.cs,Screen,The following statement contains a magic number: if (!multiMonitorSupport || monitor == (IntPtr)PRIMARY_MONITOR) {                  // Single monitor system                  //                    if (User32.GetSystemMetrics(80) != 0)                  {                      bounds = new Rectangle(User32.GetSystemMetrics(76)'                                           User32.GetSystemMetrics(77)'                                           User32.GetSystemMetrics(78)'                                           User32.GetSystemMetrics(79));                  }                  else                  {                      Size size = new Size(User32.GetSystemMetrics(0)'User32.GetSystemMetrics(1));                      bounds =  new Rectangle(0' 0' size.Width' size.Height);                  }                  //bounds = SystemInformation.VirtualScreen;                  primary = true;                  deviceName = "DISPLAY";              }              else {                  // MultiMonitor System                  // We call the 'A' version of GetMonitorInfoA() because                  // the 'W' version just never fills out the struct properly on Win2K.                  //                  var info = new User32.MonitorInfoEx();                  info.Init();                    User32.GetMonitorInfo(monitor' ref info);                  bounds = Rectangle.FromLTRB(info.Monitor.Left' info.Monitor.Top' info.Monitor.Right' info.Monitor.Bottom);                  primary = ((info.Flags & MONITORINFOF_PRIMARY) != 0);                  /*int count = info.DeviceName.Length;                  while (count > 0 && info.DeviceName[count - 1] == (char)0) {                      count--;                  }                     deviceName = new string(info.szDevice);                  deviceName = deviceName.TrimEnd((char)0);*/                    deviceName = info.DeviceName;                  if (hdc == IntPtr.Zero) {                                            screenDC = GDI32.CreateDC(deviceName' null' null' new HandleRef());                  }                 }
Magic Number,WGestures.Common.OsSpecific.Windows,Screen,C:\repos\yingDev_WGestures\WGestures.Common\OsSpecific\Windows\Screen.cs,Screen,The following statement contains a magic number: this.bitDepth = GDI32.GetDeviceCaps(new HandleRef(null' screenDC).Handle' 12);
Magic Number,WGestures.Common.OsSpecific.Windows,Screen,C:\repos\yingDev_WGestures\WGestures.Common\OsSpecific\Windows\Screen.cs,Screen,The following statement contains a magic number: this.bitDepth *= GDI32.GetDeviceCaps(new HandleRef(null' screenDC).Handle' 14);
Magic Number,Win32,Kernel32,C:\repos\yingDev_WGestures\WGestures.Common\OsSpecific\Windows\Win32\Kernel32.cs,GetIdleTime,The following statement contains a magic number: ulong idleTimeLong = ((ulong)idleTime.dwHighDateTime << 32) + (uint)idleTime.dwLowDateTime;
Magic Number,Win32,Kernel32,C:\repos\yingDev_WGestures\WGestures.Common\OsSpecific\Windows\Win32\Kernel32.cs,GetKernelTime,The following statement contains a magic number: ulong kernelTimeLong = ((ulong)kernelTime.dwHighDateTime << 32) + (uint)kernelTime.dwLowDateTime;
Magic Number,Win32,Kernel32,C:\repos\yingDev_WGestures\WGestures.Common\OsSpecific\Windows\Win32\Kernel32.cs,GetUserTime,The following statement contains a magic number: ulong userTimeLong = ((ulong)userTime.dwHighDateTime << 32) + (uint)userTime.dwLowDateTime;
Magic Number,Win32,MonitorInfoEx,C:\repos\yingDev_WGestures\WGestures.Common\OsSpecific\Windows\Win32\User32.cs,Init,The following statement contains a magic number: this.Size = 40 + 2 * CCHDEVICENAME;
Magic Number,Win32,MonitorInfoEx,C:\repos\yingDev_WGestures\WGestures.Common\OsSpecific\Windows\Win32\User32.cs,Init,The following statement contains a magic number: this.Size = 40 + 2 * CCHDEVICENAME;
Magic Number,WGestures.Common.Product,TimeOutWebClient,C:\repos\yingDev_WGestures\WGestures.Common\Product\VersionChecker.cs,TimeOutWebClient,The following statement contains a magic number: TimeOutSecs = 30;
Magic Number,WGestures.Common.Product,TimeOutWebClient,C:\repos\yingDev_WGestures\WGestures.Common\Product\VersionChecker.cs,GetWebRequest,The following statement contains a magic number: w.Timeout = TimeOutSecs * 1000;
Missing Default,WGestures.Common.Config,Plist,C:\repos\yingDev_WGestures\WGestures.Common\Config\Plist.cs,parse,The following switch statement is missing a default case: switch (node.Name)  			{  			case "dict":  				return parseDictionary(node);  			case "array":  				return parseArray(node);  			case "string":  				return node.InnerText;  			case "integer":  				// int result;  				//int.TryParse(node.InnerText' System.Globalization.NumberFormatInfo.InvariantInfo' out result);  				return Convert.ToInt32(node.InnerText' System.Globalization.NumberFormatInfo.InvariantInfo);  			case "real":  				return Convert.ToDouble(node.InnerText'System.Globalization.NumberFormatInfo.InvariantInfo);  			case "false":  				return false;  			case "true":  				return true;  			case "null":  				return null;  			case "date":  				return XmlConvert.ToDateTime(node.InnerText' XmlDateTimeSerializationMode.Utc);  			case "data":  				return Convert.FromBase64String(node.InnerText);  			}
Missing Default,WGestures.Common.Config,Plist,C:\repos\yingDev_WGestures\WGestures.Common\Config\Plist.cs,parseBinary,The following switch statement is missing a default case: switch (header & 0xF0)  			{  			case 0:  				{  					//If the byte is  					//0 return null  					//9 return true  					//8 return false  					return (objectTable[offsetTable[objRef]] == 0) ? (object)null : ((objectTable[offsetTable[objRef]] == 9) ? true : false);  				}  			case 0x10:  				{  					return parseBinaryInt(offsetTable[objRef]);  				}  			case 0x20:  				{  					return parseBinaryReal(offsetTable[objRef]);  				}  			case 0x30:  				{  					return parseBinaryDate(offsetTable[objRef]);  				}  			case 0x40:  				{  					return parseBinaryByteArray(offsetTable[objRef]);  				}  			case 0x50://String ASCII  				{  					return parseBinaryAsciiString(offsetTable[objRef]);  				}  			case 0x60://String Unicode  				{  					return parseBinaryUnicodeString(offsetTable[objRef]);  				}  			case 0xD0:  				{  					return parseBinaryDictionary(objRef);  				}  			case 0xA0:  				{  					return parseBinaryArray(objRef);  				}  			}
Missing Default,WGestures.Common.OsSpecific.Windows,ClipboardMonitor,C:\repos\yingDev_WGestures\WGestures.Common\OsSpecific\Windows\ClipboardMonitor.cs,WndProc,The following switch statement is missing a default case: switch (m.Msg)              {                  case WM_CLIPBOARDUPDATE:                      var args = new ClipbardUpdatedEventArgs();                      OnClipboardUpdated(args);                      if (args.Handled) m.Result = IntPtr.Zero;                      return;                  case WM_DESTROY:  #if DEBUG                      Console.WriteLine("ClipboardMonitor: WM_DESTROY");  #endif                      StopMonitor();                      break;                  case WM_CLOSE:  #if DEBUG                      Console.WriteLine("ClipboardMonitor: WM_CLOSE");  #endif                      StopMonitor();                      break;              }
