Implementation smell,Namespace,Class,File,Method,Description
Long Method,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The method has 167 lines of code.
Long Method,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The method has 150 lines of code.
Long Method,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,CalculateBitrate,The method has 100 lines of code.
Long Method,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,getSamples,The method has 137 lines of code.
Complex Method,IdSharp.AudioInfo,AudioFile,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\AudioFile.cs,Create,Cyclomatic complexity of the method is 11
Complex Method,IdSharp.AudioInfo,Flac,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Flac\Flac.cs,Flac,Cyclomatic complexity of the method is 9
Complex Method,IdSharp.AudioInfo,MonkeysAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\MonkeysAudio\MonkeysAudio.cs,MonkeysAudio,Cyclomatic complexity of the method is 8
Complex Method,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,Cyclomatic complexity of the method is 27
Complex Method,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,CalculateBitrate,Cyclomatic complexity of the method is 12
Complex Method,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,FindFrameSync,Cyclomatic complexity of the method is 18
Complex Method,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,GetSamplesPerFrame,Cyclomatic complexity of the method is 12
Complex Method,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,GetFrequency,Cyclomatic complexity of the method is 9
Complex Method,IdSharp.AudioInfo,Musepack,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Musepack\Musepack.cs,Musepack,Cyclomatic complexity of the method is 20
Complex Method,IdSharp.AudioInfo,OggVorbis,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\OggVorbis\OggVorbis.cs,OggVorbis,Cyclomatic complexity of the method is 14
Complex Method,IdSharp.AudioInfo,RiffWave,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\RiffWave\RiffWave.cs,ReadStream,Cyclomatic complexity of the method is 10
Complex Method,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,getSamples,Cyclomatic complexity of the method is 33
Complex Method,IdSharp.AudioInfo,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\TagSizes\Mpeg4Tag.cs,ParseAtom,Cyclomatic complexity of the method is 19
Complex Method,IdSharp.AudioInfo.Inspection,BasicLameTagReader,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\BasicLameTagReader.cs,BasicLameTagReader,Cyclomatic complexity of the method is 11
Complex Method,IdSharp.AudioInfo.Inspection,DescriptiveLameTagReader,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\DescriptiveLameTagReader.cs,DeterminePreset,Cyclomatic complexity of the method is 72
Complex Method,IdSharp.AudioInfo.Inspection,DescriptiveLameTagReader,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\DescriptiveLameTagReader.cs,DeterminePresetGuess,Cyclomatic complexity of the method is 62
Complex Method,IdSharp.AudioInfo.Inspection,MpegAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\MpegAudio.cs,GetCBREncoderID,Cyclomatic complexity of the method is 10
Long Parameter List,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,FindFrameSync,The method has 9 parameters.
Long Parameter List,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,GuessPreset,The method has 9 parameters.
Long Parameter List,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,GuessForVersion,The method has 9 parameters.
Long Parameter List,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,BestGuessTwoVersions,The method has 10 parameters.
Long Parameter List,IdSharp.AudioInfo.Inspection,PresetGuessRow,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuessRow.cs,PresetGuessRow,The method has 9 parameters.
Long Parameter List,IdSharp.AudioInfo.Inspection,PresetGuessRow,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuessRow.cs,PresetGuessRow,The method has 10 parameters.
Long Parameter List,IdSharp.AudioInfo.Inspection,PresetGuessRow,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuessRow.cs,PresetGuessRow,The method has 11 parameters.
Long Parameter List,IdSharp.AudioInfo.Inspection,PresetGuessRow,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuessRow.cs,Initialize,The method has 11 parameters.
Long Statement,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,CalculateBitrate,The length of the statement  "			if (FindFrameSync (FH' audioData' BufLen' ref FrameOffset' ref offset' ref mPerfect' ref ignoreall' ref bTrusting' ref reservedlayer)) { " is 136.
Long Statement,IdSharp.AudioInfo,RiffWave,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\RiffWave\RiffWave.cs,ReadStream,The length of the statement  "		if (identifierHeader [0] == 'd' && identifierHeader [1] == 'a' && identifierHeader [2] == 't' && identifierHeader [3] == 'a') " is 125.
Long Statement,IdSharp.AudioInfo,RiffWave,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\RiffWave\RiffWave.cs,ReadStream,The length of the statement  "		if (identifierHeader [0] == 'f' && identifierHeader [1] == 'm' && identifierHeader [2] == 't' && identifierHeader [3] == ' ') { " is 127.
Long Statement,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,word_get,The length of the statement  "	uint buffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]); " is 169.
Long Statement,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,getSamples,The length of the statement  "						gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]); " is 165.
Long Statement,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,getSamples,The length of the statement  "							gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]); " is 165.
Long Statement,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,getSamples,The length of the statement  "							gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]); " is 165.
Long Statement,IdSharp.AudioInfo.Inspection,DescriptiveLameTagReader,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\DescriptiveLameTagReader.cs,DeterminePreset,The length of the statement  "		if (preset == 410 || preset == 420 || preset == 430 || preset == 440 || preset == 450 || preset == 460 || preset == 470 || preset == 480 || preset == 490 || preset == 500) { " is 173.
Long Statement,IdSharp.AudioInfo.Inspection,MpegAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\MpegAudio.cs,IsFrameHeader,The length of the statement  "	if ((headerData [0] & 0xFF) != 0xFF || (headerData [1] & 0xE0) != 0xE0 || ((headerData [1] >> 3) & 3) == 1 || ((headerData [1] >> 1) & 3) == 0 || (headerData [2] & 0xF0) == 0xF0 || (headerData [2] & 0xF0) == 0 || ((headerData [2] >> 2) & 3) == 3 || (headerData [3] & 3) == 2) { " is 277.
Long Statement,IdSharp.AudioInfo.Inspection,MpegAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\MpegAudio.cs,IsXing,The length of the statement  "	bool result = (data [index] == 0) && (data [index + 1] == 0) && (data [index + 2] == 0) && (data [index + 3] == 0) && (data [index + 4] == 0) && (data [index + 5] == 0); " is 169.
Long Statement,IdSharp.AudioInfo.Inspection,MpegAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\MpegAudio.cs,FindVBR,The length of the statement  "	String id = String.Format ("{0}{1}{2}{3}"' (Char)data [index]' (Char)data [index + 1]' (Char)data [index + 2]' (Char)data [index + 3]); " is 135.
Long Statement,IdSharp.AudioInfo.Inspection,MpegAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\MpegAudio.cs,GetXingInfo,The length of the statement  "	result.Frames = data [index + 8] * 0x1000000 + data [index + 9] * 0x10000 + data [index + 10] * 0x100 + data [index + 11]; " is 122.
Long Statement,IdSharp.AudioInfo.Inspection,MpegAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\MpegAudio.cs,GetXingInfo,The length of the statement  "	result.Bytes = data [index + 12] * 0x1000000 + data [index + 13] * 0x10000 + data [index + 14] * 0x100 + data [index + 15]; " is 123.
Long Statement,IdSharp.AudioInfo.Inspection,MpegAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\MpegAudio.cs,GetXingInfo,The length of the statement  "	result.VendorID = String.Format ("{0}{1}{2}{3}{4}{5}{6}{7}"' (Char)data [index + 120]' (Char)data [index + 121]' (Char)data [index + 122]' (Char)data [index + 123]' (Char)data [index + 124]' (Char)data [index + 125]' (Char)data [index + 126]' (Char)data [index + 127]); " is 269.
Long Statement,IdSharp.AudioInfo.Inspection,MpegAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\MpegAudio.cs,GetFhGInfo,The length of the statement  "	result.Bytes = data [index + 10] * 0x1000000 + data [index + 11] * 0x10000 + data [index + 12] * 0x100 + data [index + 13]; " is 123.
Long Statement,IdSharp.AudioInfo.Inspection,MpegAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\MpegAudio.cs,GetFhGInfo,The length of the statement  "	result.Frames = data [index + 14] * 0x1000000 + data [index + 15] * 0x10000 + data [index + 16] * 0x100 + data [index + 17]; " is 124.
Long Statement,IdSharp.AudioInfo.Inspection,MpegAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\MpegAudio.cs,FindVendorID,The length of the statement  "		String VendorID = String.Format ("{0}{1}{2}{3}"' (Char)data [size - i - 8]' (Char)data [size - i - 7]' (Char)data [size - i - 6]' (Char)data [size - i - 5]); " is 157.
Long Statement,IdSharp.AudioInfo.Inspection,MpegAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\MpegAudio.cs,FindVendorID,The length of the statement  "			result = VendorID + String.Format ("{0}{1}{2}{3}"' (Char)data [size - i - 4]' (Char)data [size - i - 3]' (Char)data [size - i - 2]' (Char)data [size - i - 1]); " is 159.
Long Statement,IdSharp.AudioInfo.Inspection,MpegAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\MpegAudio.cs,GetVBREncoderID,The length of the statement  "	if (Encoding.ASCII.GetString (m_VBR.ID) == VBRHeaderID.Xing && vbrVendor != VBRVendorID.LAME && vbrVendor != VBRVendorID.GoGoNew && vbrVendor != VBRVendorID.GoGoOld) " is 165.
Long Statement,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,GuessPreset,The length of the statement  "		Result = GuessForVersion (LameVersionGroup.lvg390_3901_392' ABitrate' AQuality' AEncodingMethod' ANoiseShaping' AStereoMode' AATHType' ALowpassDiv100' out ANonBitrate); " is 168.
Long Statement,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,GuessPreset,The length of the statement  "		Result = BestGuessTwoVersions (LameVersionGroup.lvg3902_391' LameVersionGroup.lvg3931_3903up' ABitrate' AQuality' AEncodingMethod' ANoiseShaping' AStereoMode' AATHType' ALowpassDiv100' out ANonBitrate); " is 202.
Long Statement,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,GuessPreset,The length of the statement  "		Result = GuessForVersion (LameVersionGroup.lvg3902_391' ABitrate' AQuality' AEncodingMethod' ANoiseShaping' AStereoMode' AATHType' ALowpassDiv100' out ANonBitrate); " is 164.
Long Statement,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,GuessPreset,The length of the statement  "		Result = BestGuessTwoVersions (LameVersionGroup.lvg3931_3903up' LameVersionGroup.lvg393' ABitrate' AQuality' AEncodingMethod' ANoiseShaping' AStereoMode' AATHType' ALowpassDiv100' out ANonBitrate); " is 197.
Long Statement,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,GuessPreset,The length of the statement  "		Result = GuessForVersion (LameVersionGroup.lvg394up' ABitrate' AQuality' AEncodingMethod' ANoiseShaping' AStereoMode' AATHType' ALowpassDiv100' out ANonBitrate); " is 161.
Long Statement,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,GuessForVersion,The length of the statement  "		if ((row.HasVersionGroup (AVersionGroup)) && (row.TVs [1] == AQuality) && (row.TVs [2] == AEncodingMethod) && (row.TVs [3] == ANoiseShaping) && (row.TVs [4] == AStereoMode) && (row.TVs [5] == AATHType) && (row.TVs [6] == ALowpassDiv100)) { " is 239.
Long Statement,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,BestGuessTwoVersions,The length of the statement  "	FirstPreset = GuessForVersion (AGroup1' ABitrate' AQuality' AEncodingMethod' ANoiseShaping' AStereoMode' AATHType' ALowpassDiv100' out ANonBitrate); " is 148.
Long Statement,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,BestGuessTwoVersions,The length of the statement  "	SecondPreset = GuessForVersion (AGroup2' ABitrate' AQuality' AEncodingMethod' ANoiseShaping' AStereoMode' AATHType' ALowpassDiv100' out ANonBitrate); " is 149.
Complex Conditional,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The conditional expression  "_bitrate == 0 || _isVBR == null || _frames == 0 || _totalSeconds == 0"  is complex.
Complex Conditional,IdSharp.AudioInfo,RiffWave,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\RiffWave\RiffWave.cs,ReadStream,The conditional expression  "header [0] != 'R' || header [1] != 'I' || header [2] != 'F' || header [3] != 'F'"  is complex.
Complex Conditional,IdSharp.AudioInfo,RiffWave,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\RiffWave\RiffWave.cs,ReadStream,The conditional expression  "header [8] != 'W' || header [9] != 'A' || header [10] != 'V' || header [11] != 'E'"  is complex.
Complex Conditional,IdSharp.AudioInfo,RiffWave,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\RiffWave\RiffWave.cs,ReadStream,The conditional expression  "identifierHeader [0] == 'd' && identifierHeader [1] == 'a' && identifierHeader [2] == 't' && identifierHeader [3] == 'a'"  is complex.
Complex Conditional,IdSharp.AudioInfo,RiffWave,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\RiffWave\RiffWave.cs,ReadStream,The conditional expression  "identifierHeader [0] == 'f' && identifierHeader [1] == 'm' && identifierHeader [2] == 't' && identifierHeader [3] == ' '"  is complex.
Complex Conditional,IdSharp.AudioInfo,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\TagSizes\Mpeg4Tag.cs,ParseAtom,The conditional expression  "atomdata [i] == 'i' && atomdata [i + 1] == 'l' && atomdata [i + 2] == 's' && atomdata [i + 3] == 't'"  is complex.
Complex Conditional,IdSharp.AudioInfo.Inspection,DescriptiveLameTagReader,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\DescriptiveLameTagReader.cs,DeterminePreset,The conditional expression  "preset == 410 || preset == 420 || preset == 430 || preset == 440 || preset == 450 || preset == 460 || preset == 470 || preset == 480 || preset == 490 || preset == 500"  is complex.
Complex Conditional,IdSharp.AudioInfo.Inspection,MpegAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\MpegAudio.cs,IsFrameHeader,The conditional expression  "(headerData [0] & 0xFF) != 0xFF || (headerData [1] & 0xE0) != 0xE0 || ((headerData [1] >> 3) & 3) == 1 || ((headerData [1] >> 1) & 3) == 0 || (headerData [2] & 0xF0) == 0xF0 || (headerData [2] & 0xF0) == 0 || ((headerData [2] >> 2) & 3) == 3 || (headerData [3] & 3) == 2"  is complex.
Complex Conditional,IdSharp.AudioInfo.Inspection,MpegAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\MpegAudio.cs,GetVBREncoderID,The conditional expression  "Encoding.ASCII.GetString (m_VBR.ID) == VBRHeaderID.Xing && vbrVendor != VBRVendorID.LAME && vbrVendor != VBRVendorID.GoGoNew && vbrVendor != VBRVendorID.GoGoOld"  is complex.
Complex Conditional,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,GuessForVersion,The conditional expression  "(row.HasVersionGroup (AVersionGroup)) && (row.TVs [1] == AQuality) && (row.TVs [2] == AEncodingMethod) && (row.TVs [3] == ANoiseShaping) && (row.TVs [4] == AStereoMode) && (row.TVs [5] == AATHType) && (row.TVs [6] == ALowpassDiv100)"  is complex.
Magic Number,IdSharp.AudioInfo,Flac,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Flac\Flac.cs,Flac,The following statement contains a magic number: try {  	using (FileStream stream = File.Open (path' FileMode.Open' FileAccess.Read' FileShare.Read)) {  		// Skip ID3v2 tag  		int tmpID3v2TagSize = ID3v2.GetTagSize (stream);  		int tmpID3v1TagSize = ID3v1.GetTagSize (stream);  		int tmpAPEv2TagSize = APEv2.GetTagSize (stream);  		stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  		// Read flac marker  		byte[] flacMarker = new Byte[4];  		stream.Read (flacMarker' 0' 4);  		if (ByteUtils.Compare (flacMarker' FLAC_MARKER) == false) {  			throw new InvalidDataException ("No header found");  		}  		// skip frame header and stuff we're not interested in  		stream.Seek (14' SeekOrigin.Current);  		byte[] buf = stream.Read (8);  		_frequency = (buf [0] << 12) + (buf [1] << 4) + (buf [2] >> 4);  		_channels = ((buf [2] >> 1) & 0x03) + 1;  		_samples = ((buf [3] & 0x0F) << 32) + (buf [4] << 24) + (buf [5] << 16) + (buf [6] << 8) + buf [7];  		_totalSeconds = _samples / (decimal)_frequency;  		// Find first sync  		// TODO: There's probably a better way to do this.. also an embedded PICTURE might  		// cause a false sync. Not high priority since it will only cause a slight error  		// in bitrate calculation if a false sync is found.  		int c = stream.ReadByte ();  		// keep as ReadByte  		while (c != -1) {  			if (c == 0xFF) {  				c = stream.ReadByte ();  				// keep as ReadByte  				if (c >= 0xF8 && c <= 0xFB) {  					break;  				}  			} else {  				c = stream.ReadByte ();  				// keep as ReadByte  			}  		}  		if (c == -1) {  			throw new InvalidDataException ("No sync found");  		}  		long startaudio = stream.Position;  		long totalsize = stream.Length - startaudio - tmpAPEv2TagSize - tmpID3v1TagSize;  		_bitrate = totalsize / (_totalSeconds * 125);  	}  } catch (InvalidDataException ex) {  	throw new InvalidDataException (String.Format ("Cannot read FLAC file '{0}'"' path)' ex);  }  
Magic Number,IdSharp.AudioInfo,Flac,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Flac\Flac.cs,Flac,The following statement contains a magic number: try {  	using (FileStream stream = File.Open (path' FileMode.Open' FileAccess.Read' FileShare.Read)) {  		// Skip ID3v2 tag  		int tmpID3v2TagSize = ID3v2.GetTagSize (stream);  		int tmpID3v1TagSize = ID3v1.GetTagSize (stream);  		int tmpAPEv2TagSize = APEv2.GetTagSize (stream);  		stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  		// Read flac marker  		byte[] flacMarker = new Byte[4];  		stream.Read (flacMarker' 0' 4);  		if (ByteUtils.Compare (flacMarker' FLAC_MARKER) == false) {  			throw new InvalidDataException ("No header found");  		}  		// skip frame header and stuff we're not interested in  		stream.Seek (14' SeekOrigin.Current);  		byte[] buf = stream.Read (8);  		_frequency = (buf [0] << 12) + (buf [1] << 4) + (buf [2] >> 4);  		_channels = ((buf [2] >> 1) & 0x03) + 1;  		_samples = ((buf [3] & 0x0F) << 32) + (buf [4] << 24) + (buf [5] << 16) + (buf [6] << 8) + buf [7];  		_totalSeconds = _samples / (decimal)_frequency;  		// Find first sync  		// TODO: There's probably a better way to do this.. also an embedded PICTURE might  		// cause a false sync. Not high priority since it will only cause a slight error  		// in bitrate calculation if a false sync is found.  		int c = stream.ReadByte ();  		// keep as ReadByte  		while (c != -1) {  			if (c == 0xFF) {  				c = stream.ReadByte ();  				// keep as ReadByte  				if (c >= 0xF8 && c <= 0xFB) {  					break;  				}  			} else {  				c = stream.ReadByte ();  				// keep as ReadByte  			}  		}  		if (c == -1) {  			throw new InvalidDataException ("No sync found");  		}  		long startaudio = stream.Position;  		long totalsize = stream.Length - startaudio - tmpAPEv2TagSize - tmpID3v1TagSize;  		_bitrate = totalsize / (_totalSeconds * 125);  	}  } catch (InvalidDataException ex) {  	throw new InvalidDataException (String.Format ("Cannot read FLAC file '{0}'"' path)' ex);  }  
Magic Number,IdSharp.AudioInfo,Flac,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Flac\Flac.cs,Flac,The following statement contains a magic number: try {  	using (FileStream stream = File.Open (path' FileMode.Open' FileAccess.Read' FileShare.Read)) {  		// Skip ID3v2 tag  		int tmpID3v2TagSize = ID3v2.GetTagSize (stream);  		int tmpID3v1TagSize = ID3v1.GetTagSize (stream);  		int tmpAPEv2TagSize = APEv2.GetTagSize (stream);  		stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  		// Read flac marker  		byte[] flacMarker = new Byte[4];  		stream.Read (flacMarker' 0' 4);  		if (ByteUtils.Compare (flacMarker' FLAC_MARKER) == false) {  			throw new InvalidDataException ("No header found");  		}  		// skip frame header and stuff we're not interested in  		stream.Seek (14' SeekOrigin.Current);  		byte[] buf = stream.Read (8);  		_frequency = (buf [0] << 12) + (buf [1] << 4) + (buf [2] >> 4);  		_channels = ((buf [2] >> 1) & 0x03) + 1;  		_samples = ((buf [3] & 0x0F) << 32) + (buf [4] << 24) + (buf [5] << 16) + (buf [6] << 8) + buf [7];  		_totalSeconds = _samples / (decimal)_frequency;  		// Find first sync  		// TODO: There's probably a better way to do this.. also an embedded PICTURE might  		// cause a false sync. Not high priority since it will only cause a slight error  		// in bitrate calculation if a false sync is found.  		int c = stream.ReadByte ();  		// keep as ReadByte  		while (c != -1) {  			if (c == 0xFF) {  				c = stream.ReadByte ();  				// keep as ReadByte  				if (c >= 0xF8 && c <= 0xFB) {  					break;  				}  			} else {  				c = stream.ReadByte ();  				// keep as ReadByte  			}  		}  		if (c == -1) {  			throw new InvalidDataException ("No sync found");  		}  		long startaudio = stream.Position;  		long totalsize = stream.Length - startaudio - tmpAPEv2TagSize - tmpID3v1TagSize;  		_bitrate = totalsize / (_totalSeconds * 125);  	}  } catch (InvalidDataException ex) {  	throw new InvalidDataException (String.Format ("Cannot read FLAC file '{0}'"' path)' ex);  }  
Magic Number,IdSharp.AudioInfo,Flac,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Flac\Flac.cs,Flac,The following statement contains a magic number: try {  	using (FileStream stream = File.Open (path' FileMode.Open' FileAccess.Read' FileShare.Read)) {  		// Skip ID3v2 tag  		int tmpID3v2TagSize = ID3v2.GetTagSize (stream);  		int tmpID3v1TagSize = ID3v1.GetTagSize (stream);  		int tmpAPEv2TagSize = APEv2.GetTagSize (stream);  		stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  		// Read flac marker  		byte[] flacMarker = new Byte[4];  		stream.Read (flacMarker' 0' 4);  		if (ByteUtils.Compare (flacMarker' FLAC_MARKER) == false) {  			throw new InvalidDataException ("No header found");  		}  		// skip frame header and stuff we're not interested in  		stream.Seek (14' SeekOrigin.Current);  		byte[] buf = stream.Read (8);  		_frequency = (buf [0] << 12) + (buf [1] << 4) + (buf [2] >> 4);  		_channels = ((buf [2] >> 1) & 0x03) + 1;  		_samples = ((buf [3] & 0x0F) << 32) + (buf [4] << 24) + (buf [5] << 16) + (buf [6] << 8) + buf [7];  		_totalSeconds = _samples / (decimal)_frequency;  		// Find first sync  		// TODO: There's probably a better way to do this.. also an embedded PICTURE might  		// cause a false sync. Not high priority since it will only cause a slight error  		// in bitrate calculation if a false sync is found.  		int c = stream.ReadByte ();  		// keep as ReadByte  		while (c != -1) {  			if (c == 0xFF) {  				c = stream.ReadByte ();  				// keep as ReadByte  				if (c >= 0xF8 && c <= 0xFB) {  					break;  				}  			} else {  				c = stream.ReadByte ();  				// keep as ReadByte  			}  		}  		if (c == -1) {  			throw new InvalidDataException ("No sync found");  		}  		long startaudio = stream.Position;  		long totalsize = stream.Length - startaudio - tmpAPEv2TagSize - tmpID3v1TagSize;  		_bitrate = totalsize / (_totalSeconds * 125);  	}  } catch (InvalidDataException ex) {  	throw new InvalidDataException (String.Format ("Cannot read FLAC file '{0}'"' path)' ex);  }  
Magic Number,IdSharp.AudioInfo,Flac,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Flac\Flac.cs,Flac,The following statement contains a magic number: try {  	using (FileStream stream = File.Open (path' FileMode.Open' FileAccess.Read' FileShare.Read)) {  		// Skip ID3v2 tag  		int tmpID3v2TagSize = ID3v2.GetTagSize (stream);  		int tmpID3v1TagSize = ID3v1.GetTagSize (stream);  		int tmpAPEv2TagSize = APEv2.GetTagSize (stream);  		stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  		// Read flac marker  		byte[] flacMarker = new Byte[4];  		stream.Read (flacMarker' 0' 4);  		if (ByteUtils.Compare (flacMarker' FLAC_MARKER) == false) {  			throw new InvalidDataException ("No header found");  		}  		// skip frame header and stuff we're not interested in  		stream.Seek (14' SeekOrigin.Current);  		byte[] buf = stream.Read (8);  		_frequency = (buf [0] << 12) + (buf [1] << 4) + (buf [2] >> 4);  		_channels = ((buf [2] >> 1) & 0x03) + 1;  		_samples = ((buf [3] & 0x0F) << 32) + (buf [4] << 24) + (buf [5] << 16) + (buf [6] << 8) + buf [7];  		_totalSeconds = _samples / (decimal)_frequency;  		// Find first sync  		// TODO: There's probably a better way to do this.. also an embedded PICTURE might  		// cause a false sync. Not high priority since it will only cause a slight error  		// in bitrate calculation if a false sync is found.  		int c = stream.ReadByte ();  		// keep as ReadByte  		while (c != -1) {  			if (c == 0xFF) {  				c = stream.ReadByte ();  				// keep as ReadByte  				if (c >= 0xF8 && c <= 0xFB) {  					break;  				}  			} else {  				c = stream.ReadByte ();  				// keep as ReadByte  			}  		}  		if (c == -1) {  			throw new InvalidDataException ("No sync found");  		}  		long startaudio = stream.Position;  		long totalsize = stream.Length - startaudio - tmpAPEv2TagSize - tmpID3v1TagSize;  		_bitrate = totalsize / (_totalSeconds * 125);  	}  } catch (InvalidDataException ex) {  	throw new InvalidDataException (String.Format ("Cannot read FLAC file '{0}'"' path)' ex);  }  
Magic Number,IdSharp.AudioInfo,Flac,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Flac\Flac.cs,Flac,The following statement contains a magic number: try {  	using (FileStream stream = File.Open (path' FileMode.Open' FileAccess.Read' FileShare.Read)) {  		// Skip ID3v2 tag  		int tmpID3v2TagSize = ID3v2.GetTagSize (stream);  		int tmpID3v1TagSize = ID3v1.GetTagSize (stream);  		int tmpAPEv2TagSize = APEv2.GetTagSize (stream);  		stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  		// Read flac marker  		byte[] flacMarker = new Byte[4];  		stream.Read (flacMarker' 0' 4);  		if (ByteUtils.Compare (flacMarker' FLAC_MARKER) == false) {  			throw new InvalidDataException ("No header found");  		}  		// skip frame header and stuff we're not interested in  		stream.Seek (14' SeekOrigin.Current);  		byte[] buf = stream.Read (8);  		_frequency = (buf [0] << 12) + (buf [1] << 4) + (buf [2] >> 4);  		_channels = ((buf [2] >> 1) & 0x03) + 1;  		_samples = ((buf [3] & 0x0F) << 32) + (buf [4] << 24) + (buf [5] << 16) + (buf [6] << 8) + buf [7];  		_totalSeconds = _samples / (decimal)_frequency;  		// Find first sync  		// TODO: There's probably a better way to do this.. also an embedded PICTURE might  		// cause a false sync. Not high priority since it will only cause a slight error  		// in bitrate calculation if a false sync is found.  		int c = stream.ReadByte ();  		// keep as ReadByte  		while (c != -1) {  			if (c == 0xFF) {  				c = stream.ReadByte ();  				// keep as ReadByte  				if (c >= 0xF8 && c <= 0xFB) {  					break;  				}  			} else {  				c = stream.ReadByte ();  				// keep as ReadByte  			}  		}  		if (c == -1) {  			throw new InvalidDataException ("No sync found");  		}  		long startaudio = stream.Position;  		long totalsize = stream.Length - startaudio - tmpAPEv2TagSize - tmpID3v1TagSize;  		_bitrate = totalsize / (_totalSeconds * 125);  	}  } catch (InvalidDataException ex) {  	throw new InvalidDataException (String.Format ("Cannot read FLAC file '{0}'"' path)' ex);  }  
Magic Number,IdSharp.AudioInfo,Flac,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Flac\Flac.cs,Flac,The following statement contains a magic number: try {  	using (FileStream stream = File.Open (path' FileMode.Open' FileAccess.Read' FileShare.Read)) {  		// Skip ID3v2 tag  		int tmpID3v2TagSize = ID3v2.GetTagSize (stream);  		int tmpID3v1TagSize = ID3v1.GetTagSize (stream);  		int tmpAPEv2TagSize = APEv2.GetTagSize (stream);  		stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  		// Read flac marker  		byte[] flacMarker = new Byte[4];  		stream.Read (flacMarker' 0' 4);  		if (ByteUtils.Compare (flacMarker' FLAC_MARKER) == false) {  			throw new InvalidDataException ("No header found");  		}  		// skip frame header and stuff we're not interested in  		stream.Seek (14' SeekOrigin.Current);  		byte[] buf = stream.Read (8);  		_frequency = (buf [0] << 12) + (buf [1] << 4) + (buf [2] >> 4);  		_channels = ((buf [2] >> 1) & 0x03) + 1;  		_samples = ((buf [3] & 0x0F) << 32) + (buf [4] << 24) + (buf [5] << 16) + (buf [6] << 8) + buf [7];  		_totalSeconds = _samples / (decimal)_frequency;  		// Find first sync  		// TODO: There's probably a better way to do this.. also an embedded PICTURE might  		// cause a false sync. Not high priority since it will only cause a slight error  		// in bitrate calculation if a false sync is found.  		int c = stream.ReadByte ();  		// keep as ReadByte  		while (c != -1) {  			if (c == 0xFF) {  				c = stream.ReadByte ();  				// keep as ReadByte  				if (c >= 0xF8 && c <= 0xFB) {  					break;  				}  			} else {  				c = stream.ReadByte ();  				// keep as ReadByte  			}  		}  		if (c == -1) {  			throw new InvalidDataException ("No sync found");  		}  		long startaudio = stream.Position;  		long totalsize = stream.Length - startaudio - tmpAPEv2TagSize - tmpID3v1TagSize;  		_bitrate = totalsize / (_totalSeconds * 125);  	}  } catch (InvalidDataException ex) {  	throw new InvalidDataException (String.Format ("Cannot read FLAC file '{0}'"' path)' ex);  }  
Magic Number,IdSharp.AudioInfo,Flac,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Flac\Flac.cs,Flac,The following statement contains a magic number: try {  	using (FileStream stream = File.Open (path' FileMode.Open' FileAccess.Read' FileShare.Read)) {  		// Skip ID3v2 tag  		int tmpID3v2TagSize = ID3v2.GetTagSize (stream);  		int tmpID3v1TagSize = ID3v1.GetTagSize (stream);  		int tmpAPEv2TagSize = APEv2.GetTagSize (stream);  		stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  		// Read flac marker  		byte[] flacMarker = new Byte[4];  		stream.Read (flacMarker' 0' 4);  		if (ByteUtils.Compare (flacMarker' FLAC_MARKER) == false) {  			throw new InvalidDataException ("No header found");  		}  		// skip frame header and stuff we're not interested in  		stream.Seek (14' SeekOrigin.Current);  		byte[] buf = stream.Read (8);  		_frequency = (buf [0] << 12) + (buf [1] << 4) + (buf [2] >> 4);  		_channels = ((buf [2] >> 1) & 0x03) + 1;  		_samples = ((buf [3] & 0x0F) << 32) + (buf [4] << 24) + (buf [5] << 16) + (buf [6] << 8) + buf [7];  		_totalSeconds = _samples / (decimal)_frequency;  		// Find first sync  		// TODO: There's probably a better way to do this.. also an embedded PICTURE might  		// cause a false sync. Not high priority since it will only cause a slight error  		// in bitrate calculation if a false sync is found.  		int c = stream.ReadByte ();  		// keep as ReadByte  		while (c != -1) {  			if (c == 0xFF) {  				c = stream.ReadByte ();  				// keep as ReadByte  				if (c >= 0xF8 && c <= 0xFB) {  					break;  				}  			} else {  				c = stream.ReadByte ();  				// keep as ReadByte  			}  		}  		if (c == -1) {  			throw new InvalidDataException ("No sync found");  		}  		long startaudio = stream.Position;  		long totalsize = stream.Length - startaudio - tmpAPEv2TagSize - tmpID3v1TagSize;  		_bitrate = totalsize / (_totalSeconds * 125);  	}  } catch (InvalidDataException ex) {  	throw new InvalidDataException (String.Format ("Cannot read FLAC file '{0}'"' path)' ex);  }  
Magic Number,IdSharp.AudioInfo,Flac,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Flac\Flac.cs,Flac,The following statement contains a magic number: try {  	using (FileStream stream = File.Open (path' FileMode.Open' FileAccess.Read' FileShare.Read)) {  		// Skip ID3v2 tag  		int tmpID3v2TagSize = ID3v2.GetTagSize (stream);  		int tmpID3v1TagSize = ID3v1.GetTagSize (stream);  		int tmpAPEv2TagSize = APEv2.GetTagSize (stream);  		stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  		// Read flac marker  		byte[] flacMarker = new Byte[4];  		stream.Read (flacMarker' 0' 4);  		if (ByteUtils.Compare (flacMarker' FLAC_MARKER) == false) {  			throw new InvalidDataException ("No header found");  		}  		// skip frame header and stuff we're not interested in  		stream.Seek (14' SeekOrigin.Current);  		byte[] buf = stream.Read (8);  		_frequency = (buf [0] << 12) + (buf [1] << 4) + (buf [2] >> 4);  		_channels = ((buf [2] >> 1) & 0x03) + 1;  		_samples = ((buf [3] & 0x0F) << 32) + (buf [4] << 24) + (buf [5] << 16) + (buf [6] << 8) + buf [7];  		_totalSeconds = _samples / (decimal)_frequency;  		// Find first sync  		// TODO: There's probably a better way to do this.. also an embedded PICTURE might  		// cause a false sync. Not high priority since it will only cause a slight error  		// in bitrate calculation if a false sync is found.  		int c = stream.ReadByte ();  		// keep as ReadByte  		while (c != -1) {  			if (c == 0xFF) {  				c = stream.ReadByte ();  				// keep as ReadByte  				if (c >= 0xF8 && c <= 0xFB) {  					break;  				}  			} else {  				c = stream.ReadByte ();  				// keep as ReadByte  			}  		}  		if (c == -1) {  			throw new InvalidDataException ("No sync found");  		}  		long startaudio = stream.Position;  		long totalsize = stream.Length - startaudio - tmpAPEv2TagSize - tmpID3v1TagSize;  		_bitrate = totalsize / (_totalSeconds * 125);  	}  } catch (InvalidDataException ex) {  	throw new InvalidDataException (String.Format ("Cannot read FLAC file '{0}'"' path)' ex);  }  
Magic Number,IdSharp.AudioInfo,Flac,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Flac\Flac.cs,Flac,The following statement contains a magic number: try {  	using (FileStream stream = File.Open (path' FileMode.Open' FileAccess.Read' FileShare.Read)) {  		// Skip ID3v2 tag  		int tmpID3v2TagSize = ID3v2.GetTagSize (stream);  		int tmpID3v1TagSize = ID3v1.GetTagSize (stream);  		int tmpAPEv2TagSize = APEv2.GetTagSize (stream);  		stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  		// Read flac marker  		byte[] flacMarker = new Byte[4];  		stream.Read (flacMarker' 0' 4);  		if (ByteUtils.Compare (flacMarker' FLAC_MARKER) == false) {  			throw new InvalidDataException ("No header found");  		}  		// skip frame header and stuff we're not interested in  		stream.Seek (14' SeekOrigin.Current);  		byte[] buf = stream.Read (8);  		_frequency = (buf [0] << 12) + (buf [1] << 4) + (buf [2] >> 4);  		_channels = ((buf [2] >> 1) & 0x03) + 1;  		_samples = ((buf [3] & 0x0F) << 32) + (buf [4] << 24) + (buf [5] << 16) + (buf [6] << 8) + buf [7];  		_totalSeconds = _samples / (decimal)_frequency;  		// Find first sync  		// TODO: There's probably a better way to do this.. also an embedded PICTURE might  		// cause a false sync. Not high priority since it will only cause a slight error  		// in bitrate calculation if a false sync is found.  		int c = stream.ReadByte ();  		// keep as ReadByte  		while (c != -1) {  			if (c == 0xFF) {  				c = stream.ReadByte ();  				// keep as ReadByte  				if (c >= 0xF8 && c <= 0xFB) {  					break;  				}  			} else {  				c = stream.ReadByte ();  				// keep as ReadByte  			}  		}  		if (c == -1) {  			throw new InvalidDataException ("No sync found");  		}  		long startaudio = stream.Position;  		long totalsize = stream.Length - startaudio - tmpAPEv2TagSize - tmpID3v1TagSize;  		_bitrate = totalsize / (_totalSeconds * 125);  	}  } catch (InvalidDataException ex) {  	throw new InvalidDataException (String.Format ("Cannot read FLAC file '{0}'"' path)' ex);  }  
Magic Number,IdSharp.AudioInfo,Flac,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Flac\Flac.cs,Flac,The following statement contains a magic number: try {  	using (FileStream stream = File.Open (path' FileMode.Open' FileAccess.Read' FileShare.Read)) {  		// Skip ID3v2 tag  		int tmpID3v2TagSize = ID3v2.GetTagSize (stream);  		int tmpID3v1TagSize = ID3v1.GetTagSize (stream);  		int tmpAPEv2TagSize = APEv2.GetTagSize (stream);  		stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  		// Read flac marker  		byte[] flacMarker = new Byte[4];  		stream.Read (flacMarker' 0' 4);  		if (ByteUtils.Compare (flacMarker' FLAC_MARKER) == false) {  			throw new InvalidDataException ("No header found");  		}  		// skip frame header and stuff we're not interested in  		stream.Seek (14' SeekOrigin.Current);  		byte[] buf = stream.Read (8);  		_frequency = (buf [0] << 12) + (buf [1] << 4) + (buf [2] >> 4);  		_channels = ((buf [2] >> 1) & 0x03) + 1;  		_samples = ((buf [3] & 0x0F) << 32) + (buf [4] << 24) + (buf [5] << 16) + (buf [6] << 8) + buf [7];  		_totalSeconds = _samples / (decimal)_frequency;  		// Find first sync  		// TODO: There's probably a better way to do this.. also an embedded PICTURE might  		// cause a false sync. Not high priority since it will only cause a slight error  		// in bitrate calculation if a false sync is found.  		int c = stream.ReadByte ();  		// keep as ReadByte  		while (c != -1) {  			if (c == 0xFF) {  				c = stream.ReadByte ();  				// keep as ReadByte  				if (c >= 0xF8 && c <= 0xFB) {  					break;  				}  			} else {  				c = stream.ReadByte ();  				// keep as ReadByte  			}  		}  		if (c == -1) {  			throw new InvalidDataException ("No sync found");  		}  		long startaudio = stream.Position;  		long totalsize = stream.Length - startaudio - tmpAPEv2TagSize - tmpID3v1TagSize;  		_bitrate = totalsize / (_totalSeconds * 125);  	}  } catch (InvalidDataException ex) {  	throw new InvalidDataException (String.Format ("Cannot read FLAC file '{0}'"' path)' ex);  }  
Magic Number,IdSharp.AudioInfo,Flac,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Flac\Flac.cs,Flac,The following statement contains a magic number: try {  	using (FileStream stream = File.Open (path' FileMode.Open' FileAccess.Read' FileShare.Read)) {  		// Skip ID3v2 tag  		int tmpID3v2TagSize = ID3v2.GetTagSize (stream);  		int tmpID3v1TagSize = ID3v1.GetTagSize (stream);  		int tmpAPEv2TagSize = APEv2.GetTagSize (stream);  		stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  		// Read flac marker  		byte[] flacMarker = new Byte[4];  		stream.Read (flacMarker' 0' 4);  		if (ByteUtils.Compare (flacMarker' FLAC_MARKER) == false) {  			throw new InvalidDataException ("No header found");  		}  		// skip frame header and stuff we're not interested in  		stream.Seek (14' SeekOrigin.Current);  		byte[] buf = stream.Read (8);  		_frequency = (buf [0] << 12) + (buf [1] << 4) + (buf [2] >> 4);  		_channels = ((buf [2] >> 1) & 0x03) + 1;  		_samples = ((buf [3] & 0x0F) << 32) + (buf [4] << 24) + (buf [5] << 16) + (buf [6] << 8) + buf [7];  		_totalSeconds = _samples / (decimal)_frequency;  		// Find first sync  		// TODO: There's probably a better way to do this.. also an embedded PICTURE might  		// cause a false sync. Not high priority since it will only cause a slight error  		// in bitrate calculation if a false sync is found.  		int c = stream.ReadByte ();  		// keep as ReadByte  		while (c != -1) {  			if (c == 0xFF) {  				c = stream.ReadByte ();  				// keep as ReadByte  				if (c >= 0xF8 && c <= 0xFB) {  					break;  				}  			} else {  				c = stream.ReadByte ();  				// keep as ReadByte  			}  		}  		if (c == -1) {  			throw new InvalidDataException ("No sync found");  		}  		long startaudio = stream.Position;  		long totalsize = stream.Length - startaudio - tmpAPEv2TagSize - tmpID3v1TagSize;  		_bitrate = totalsize / (_totalSeconds * 125);  	}  } catch (InvalidDataException ex) {  	throw new InvalidDataException (String.Format ("Cannot read FLAC file '{0}'"' path)' ex);  }  
Magic Number,IdSharp.AudioInfo,Flac,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Flac\Flac.cs,Flac,The following statement contains a magic number: try {  	using (FileStream stream = File.Open (path' FileMode.Open' FileAccess.Read' FileShare.Read)) {  		// Skip ID3v2 tag  		int tmpID3v2TagSize = ID3v2.GetTagSize (stream);  		int tmpID3v1TagSize = ID3v1.GetTagSize (stream);  		int tmpAPEv2TagSize = APEv2.GetTagSize (stream);  		stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  		// Read flac marker  		byte[] flacMarker = new Byte[4];  		stream.Read (flacMarker' 0' 4);  		if (ByteUtils.Compare (flacMarker' FLAC_MARKER) == false) {  			throw new InvalidDataException ("No header found");  		}  		// skip frame header and stuff we're not interested in  		stream.Seek (14' SeekOrigin.Current);  		byte[] buf = stream.Read (8);  		_frequency = (buf [0] << 12) + (buf [1] << 4) + (buf [2] >> 4);  		_channels = ((buf [2] >> 1) & 0x03) + 1;  		_samples = ((buf [3] & 0x0F) << 32) + (buf [4] << 24) + (buf [5] << 16) + (buf [6] << 8) + buf [7];  		_totalSeconds = _samples / (decimal)_frequency;  		// Find first sync  		// TODO: There's probably a better way to do this.. also an embedded PICTURE might  		// cause a false sync. Not high priority since it will only cause a slight error  		// in bitrate calculation if a false sync is found.  		int c = stream.ReadByte ();  		// keep as ReadByte  		while (c != -1) {  			if (c == 0xFF) {  				c = stream.ReadByte ();  				// keep as ReadByte  				if (c >= 0xF8 && c <= 0xFB) {  					break;  				}  			} else {  				c = stream.ReadByte ();  				// keep as ReadByte  			}  		}  		if (c == -1) {  			throw new InvalidDataException ("No sync found");  		}  		long startaudio = stream.Position;  		long totalsize = stream.Length - startaudio - tmpAPEv2TagSize - tmpID3v1TagSize;  		_bitrate = totalsize / (_totalSeconds * 125);  	}  } catch (InvalidDataException ex) {  	throw new InvalidDataException (String.Format ("Cannot read FLAC file '{0}'"' path)' ex);  }  
Magic Number,IdSharp.AudioInfo,Flac,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Flac\Flac.cs,Flac,The following statement contains a magic number: try {  	using (FileStream stream = File.Open (path' FileMode.Open' FileAccess.Read' FileShare.Read)) {  		// Skip ID3v2 tag  		int tmpID3v2TagSize = ID3v2.GetTagSize (stream);  		int tmpID3v1TagSize = ID3v1.GetTagSize (stream);  		int tmpAPEv2TagSize = APEv2.GetTagSize (stream);  		stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  		// Read flac marker  		byte[] flacMarker = new Byte[4];  		stream.Read (flacMarker' 0' 4);  		if (ByteUtils.Compare (flacMarker' FLAC_MARKER) == false) {  			throw new InvalidDataException ("No header found");  		}  		// skip frame header and stuff we're not interested in  		stream.Seek (14' SeekOrigin.Current);  		byte[] buf = stream.Read (8);  		_frequency = (buf [0] << 12) + (buf [1] << 4) + (buf [2] >> 4);  		_channels = ((buf [2] >> 1) & 0x03) + 1;  		_samples = ((buf [3] & 0x0F) << 32) + (buf [4] << 24) + (buf [5] << 16) + (buf [6] << 8) + buf [7];  		_totalSeconds = _samples / (decimal)_frequency;  		// Find first sync  		// TODO: There's probably a better way to do this.. also an embedded PICTURE might  		// cause a false sync. Not high priority since it will only cause a slight error  		// in bitrate calculation if a false sync is found.  		int c = stream.ReadByte ();  		// keep as ReadByte  		while (c != -1) {  			if (c == 0xFF) {  				c = stream.ReadByte ();  				// keep as ReadByte  				if (c >= 0xF8 && c <= 0xFB) {  					break;  				}  			} else {  				c = stream.ReadByte ();  				// keep as ReadByte  			}  		}  		if (c == -1) {  			throw new InvalidDataException ("No sync found");  		}  		long startaudio = stream.Position;  		long totalsize = stream.Length - startaudio - tmpAPEv2TagSize - tmpID3v1TagSize;  		_bitrate = totalsize / (_totalSeconds * 125);  	}  } catch (InvalidDataException ex) {  	throw new InvalidDataException (String.Format ("Cannot read FLAC file '{0}'"' path)' ex);  }  
Magic Number,IdSharp.AudioInfo,Flac,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Flac\Flac.cs,Flac,The following statement contains a magic number: try {  	using (FileStream stream = File.Open (path' FileMode.Open' FileAccess.Read' FileShare.Read)) {  		// Skip ID3v2 tag  		int tmpID3v2TagSize = ID3v2.GetTagSize (stream);  		int tmpID3v1TagSize = ID3v1.GetTagSize (stream);  		int tmpAPEv2TagSize = APEv2.GetTagSize (stream);  		stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  		// Read flac marker  		byte[] flacMarker = new Byte[4];  		stream.Read (flacMarker' 0' 4);  		if (ByteUtils.Compare (flacMarker' FLAC_MARKER) == false) {  			throw new InvalidDataException ("No header found");  		}  		// skip frame header and stuff we're not interested in  		stream.Seek (14' SeekOrigin.Current);  		byte[] buf = stream.Read (8);  		_frequency = (buf [0] << 12) + (buf [1] << 4) + (buf [2] >> 4);  		_channels = ((buf [2] >> 1) & 0x03) + 1;  		_samples = ((buf [3] & 0x0F) << 32) + (buf [4] << 24) + (buf [5] << 16) + (buf [6] << 8) + buf [7];  		_totalSeconds = _samples / (decimal)_frequency;  		// Find first sync  		// TODO: There's probably a better way to do this.. also an embedded PICTURE might  		// cause a false sync. Not high priority since it will only cause a slight error  		// in bitrate calculation if a false sync is found.  		int c = stream.ReadByte ();  		// keep as ReadByte  		while (c != -1) {  			if (c == 0xFF) {  				c = stream.ReadByte ();  				// keep as ReadByte  				if (c >= 0xF8 && c <= 0xFB) {  					break;  				}  			} else {  				c = stream.ReadByte ();  				// keep as ReadByte  			}  		}  		if (c == -1) {  			throw new InvalidDataException ("No sync found");  		}  		long startaudio = stream.Position;  		long totalsize = stream.Length - startaudio - tmpAPEv2TagSize - tmpID3v1TagSize;  		_bitrate = totalsize / (_totalSeconds * 125);  	}  } catch (InvalidDataException ex) {  	throw new InvalidDataException (String.Format ("Cannot read FLAC file '{0}'"' path)' ex);  }  
Magic Number,IdSharp.AudioInfo,Flac,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Flac\Flac.cs,Flac,The following statement contains a magic number: try {  	using (FileStream stream = File.Open (path' FileMode.Open' FileAccess.Read' FileShare.Read)) {  		// Skip ID3v2 tag  		int tmpID3v2TagSize = ID3v2.GetTagSize (stream);  		int tmpID3v1TagSize = ID3v1.GetTagSize (stream);  		int tmpAPEv2TagSize = APEv2.GetTagSize (stream);  		stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  		// Read flac marker  		byte[] flacMarker = new Byte[4];  		stream.Read (flacMarker' 0' 4);  		if (ByteUtils.Compare (flacMarker' FLAC_MARKER) == false) {  			throw new InvalidDataException ("No header found");  		}  		// skip frame header and stuff we're not interested in  		stream.Seek (14' SeekOrigin.Current);  		byte[] buf = stream.Read (8);  		_frequency = (buf [0] << 12) + (buf [1] << 4) + (buf [2] >> 4);  		_channels = ((buf [2] >> 1) & 0x03) + 1;  		_samples = ((buf [3] & 0x0F) << 32) + (buf [4] << 24) + (buf [5] << 16) + (buf [6] << 8) + buf [7];  		_totalSeconds = _samples / (decimal)_frequency;  		// Find first sync  		// TODO: There's probably a better way to do this.. also an embedded PICTURE might  		// cause a false sync. Not high priority since it will only cause a slight error  		// in bitrate calculation if a false sync is found.  		int c = stream.ReadByte ();  		// keep as ReadByte  		while (c != -1) {  			if (c == 0xFF) {  				c = stream.ReadByte ();  				// keep as ReadByte  				if (c >= 0xF8 && c <= 0xFB) {  					break;  				}  			} else {  				c = stream.ReadByte ();  				// keep as ReadByte  			}  		}  		if (c == -1) {  			throw new InvalidDataException ("No sync found");  		}  		long startaudio = stream.Position;  		long totalsize = stream.Length - startaudio - tmpAPEv2TagSize - tmpID3v1TagSize;  		_bitrate = totalsize / (_totalSeconds * 125);  	}  } catch (InvalidDataException ex) {  	throw new InvalidDataException (String.Format ("Cannot read FLAC file '{0}'"' path)' ex);  }  
Magic Number,IdSharp.AudioInfo,Flac,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Flac\Flac.cs,Flac,The following statement contains a magic number: try {  	using (FileStream stream = File.Open (path' FileMode.Open' FileAccess.Read' FileShare.Read)) {  		// Skip ID3v2 tag  		int tmpID3v2TagSize = ID3v2.GetTagSize (stream);  		int tmpID3v1TagSize = ID3v1.GetTagSize (stream);  		int tmpAPEv2TagSize = APEv2.GetTagSize (stream);  		stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  		// Read flac marker  		byte[] flacMarker = new Byte[4];  		stream.Read (flacMarker' 0' 4);  		if (ByteUtils.Compare (flacMarker' FLAC_MARKER) == false) {  			throw new InvalidDataException ("No header found");  		}  		// skip frame header and stuff we're not interested in  		stream.Seek (14' SeekOrigin.Current);  		byte[] buf = stream.Read (8);  		_frequency = (buf [0] << 12) + (buf [1] << 4) + (buf [2] >> 4);  		_channels = ((buf [2] >> 1) & 0x03) + 1;  		_samples = ((buf [3] & 0x0F) << 32) + (buf [4] << 24) + (buf [5] << 16) + (buf [6] << 8) + buf [7];  		_totalSeconds = _samples / (decimal)_frequency;  		// Find first sync  		// TODO: There's probably a better way to do this.. also an embedded PICTURE might  		// cause a false sync. Not high priority since it will only cause a slight error  		// in bitrate calculation if a false sync is found.  		int c = stream.ReadByte ();  		// keep as ReadByte  		while (c != -1) {  			if (c == 0xFF) {  				c = stream.ReadByte ();  				// keep as ReadByte  				if (c >= 0xF8 && c <= 0xFB) {  					break;  				}  			} else {  				c = stream.ReadByte ();  				// keep as ReadByte  			}  		}  		if (c == -1) {  			throw new InvalidDataException ("No sync found");  		}  		long startaudio = stream.Position;  		long totalsize = stream.Length - startaudio - tmpAPEv2TagSize - tmpID3v1TagSize;  		_bitrate = totalsize / (_totalSeconds * 125);  	}  } catch (InvalidDataException ex) {  	throw new InvalidDataException (String.Format ("Cannot read FLAC file '{0}'"' path)' ex);  }  
Magic Number,IdSharp.AudioInfo,Flac,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Flac\Flac.cs,Flac,The following statement contains a magic number: try {  	using (FileStream stream = File.Open (path' FileMode.Open' FileAccess.Read' FileShare.Read)) {  		// Skip ID3v2 tag  		int tmpID3v2TagSize = ID3v2.GetTagSize (stream);  		int tmpID3v1TagSize = ID3v1.GetTagSize (stream);  		int tmpAPEv2TagSize = APEv2.GetTagSize (stream);  		stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  		// Read flac marker  		byte[] flacMarker = new Byte[4];  		stream.Read (flacMarker' 0' 4);  		if (ByteUtils.Compare (flacMarker' FLAC_MARKER) == false) {  			throw new InvalidDataException ("No header found");  		}  		// skip frame header and stuff we're not interested in  		stream.Seek (14' SeekOrigin.Current);  		byte[] buf = stream.Read (8);  		_frequency = (buf [0] << 12) + (buf [1] << 4) + (buf [2] >> 4);  		_channels = ((buf [2] >> 1) & 0x03) + 1;  		_samples = ((buf [3] & 0x0F) << 32) + (buf [4] << 24) + (buf [5] << 16) + (buf [6] << 8) + buf [7];  		_totalSeconds = _samples / (decimal)_frequency;  		// Find first sync  		// TODO: There's probably a better way to do this.. also an embedded PICTURE might  		// cause a false sync. Not high priority since it will only cause a slight error  		// in bitrate calculation if a false sync is found.  		int c = stream.ReadByte ();  		// keep as ReadByte  		while (c != -1) {  			if (c == 0xFF) {  				c = stream.ReadByte ();  				// keep as ReadByte  				if (c >= 0xF8 && c <= 0xFB) {  					break;  				}  			} else {  				c = stream.ReadByte ();  				// keep as ReadByte  			}  		}  		if (c == -1) {  			throw new InvalidDataException ("No sync found");  		}  		long startaudio = stream.Position;  		long totalsize = stream.Length - startaudio - tmpAPEv2TagSize - tmpID3v1TagSize;  		_bitrate = totalsize / (_totalSeconds * 125);  	}  } catch (InvalidDataException ex) {  	throw new InvalidDataException (String.Format ("Cannot read FLAC file '{0}'"' path)' ex);  }  
Magic Number,IdSharp.AudioInfo,Flac,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Flac\Flac.cs,Flac,The following statement contains a magic number: try {  	using (FileStream stream = File.Open (path' FileMode.Open' FileAccess.Read' FileShare.Read)) {  		// Skip ID3v2 tag  		int tmpID3v2TagSize = ID3v2.GetTagSize (stream);  		int tmpID3v1TagSize = ID3v1.GetTagSize (stream);  		int tmpAPEv2TagSize = APEv2.GetTagSize (stream);  		stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  		// Read flac marker  		byte[] flacMarker = new Byte[4];  		stream.Read (flacMarker' 0' 4);  		if (ByteUtils.Compare (flacMarker' FLAC_MARKER) == false) {  			throw new InvalidDataException ("No header found");  		}  		// skip frame header and stuff we're not interested in  		stream.Seek (14' SeekOrigin.Current);  		byte[] buf = stream.Read (8);  		_frequency = (buf [0] << 12) + (buf [1] << 4) + (buf [2] >> 4);  		_channels = ((buf [2] >> 1) & 0x03) + 1;  		_samples = ((buf [3] & 0x0F) << 32) + (buf [4] << 24) + (buf [5] << 16) + (buf [6] << 8) + buf [7];  		_totalSeconds = _samples / (decimal)_frequency;  		// Find first sync  		// TODO: There's probably a better way to do this.. also an embedded PICTURE might  		// cause a false sync. Not high priority since it will only cause a slight error  		// in bitrate calculation if a false sync is found.  		int c = stream.ReadByte ();  		// keep as ReadByte  		while (c != -1) {  			if (c == 0xFF) {  				c = stream.ReadByte ();  				// keep as ReadByte  				if (c >= 0xF8 && c <= 0xFB) {  					break;  				}  			} else {  				c = stream.ReadByte ();  				// keep as ReadByte  			}  		}  		if (c == -1) {  			throw new InvalidDataException ("No sync found");  		}  		long startaudio = stream.Position;  		long totalsize = stream.Length - startaudio - tmpAPEv2TagSize - tmpID3v1TagSize;  		_bitrate = totalsize / (_totalSeconds * 125);  	}  } catch (InvalidDataException ex) {  	throw new InvalidDataException (String.Format ("Cannot read FLAC file '{0}'"' path)' ex);  }  
Magic Number,IdSharp.AudioInfo,Flac,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Flac\Flac.cs,Flac,The following statement contains a magic number: using (FileStream stream = File.Open (path' FileMode.Open' FileAccess.Read' FileShare.Read)) {  	// Skip ID3v2 tag  	int tmpID3v2TagSize = ID3v2.GetTagSize (stream);  	int tmpID3v1TagSize = ID3v1.GetTagSize (stream);  	int tmpAPEv2TagSize = APEv2.GetTagSize (stream);  	stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  	// Read flac marker  	byte[] flacMarker = new Byte[4];  	stream.Read (flacMarker' 0' 4);  	if (ByteUtils.Compare (flacMarker' FLAC_MARKER) == false) {  		throw new InvalidDataException ("No header found");  	}  	// skip frame header and stuff we're not interested in  	stream.Seek (14' SeekOrigin.Current);  	byte[] buf = stream.Read (8);  	_frequency = (buf [0] << 12) + (buf [1] << 4) + (buf [2] >> 4);  	_channels = ((buf [2] >> 1) & 0x03) + 1;  	_samples = ((buf [3] & 0x0F) << 32) + (buf [4] << 24) + (buf [5] << 16) + (buf [6] << 8) + buf [7];  	_totalSeconds = _samples / (decimal)_frequency;  	// Find first sync  	// TODO: There's probably a better way to do this.. also an embedded PICTURE might  	// cause a false sync. Not high priority since it will only cause a slight error  	// in bitrate calculation if a false sync is found.  	int c = stream.ReadByte ();  	// keep as ReadByte  	while (c != -1) {  		if (c == 0xFF) {  			c = stream.ReadByte ();  			// keep as ReadByte  			if (c >= 0xF8 && c <= 0xFB) {  				break;  			}  		} else {  			c = stream.ReadByte ();  			// keep as ReadByte  		}  	}  	if (c == -1) {  		throw new InvalidDataException ("No sync found");  	}  	long startaudio = stream.Position;  	long totalsize = stream.Length - startaudio - tmpAPEv2TagSize - tmpID3v1TagSize;  	_bitrate = totalsize / (_totalSeconds * 125);  }  
Magic Number,IdSharp.AudioInfo,Flac,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Flac\Flac.cs,Flac,The following statement contains a magic number: using (FileStream stream = File.Open (path' FileMode.Open' FileAccess.Read' FileShare.Read)) {  	// Skip ID3v2 tag  	int tmpID3v2TagSize = ID3v2.GetTagSize (stream);  	int tmpID3v1TagSize = ID3v1.GetTagSize (stream);  	int tmpAPEv2TagSize = APEv2.GetTagSize (stream);  	stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  	// Read flac marker  	byte[] flacMarker = new Byte[4];  	stream.Read (flacMarker' 0' 4);  	if (ByteUtils.Compare (flacMarker' FLAC_MARKER) == false) {  		throw new InvalidDataException ("No header found");  	}  	// skip frame header and stuff we're not interested in  	stream.Seek (14' SeekOrigin.Current);  	byte[] buf = stream.Read (8);  	_frequency = (buf [0] << 12) + (buf [1] << 4) + (buf [2] >> 4);  	_channels = ((buf [2] >> 1) & 0x03) + 1;  	_samples = ((buf [3] & 0x0F) << 32) + (buf [4] << 24) + (buf [5] << 16) + (buf [6] << 8) + buf [7];  	_totalSeconds = _samples / (decimal)_frequency;  	// Find first sync  	// TODO: There's probably a better way to do this.. also an embedded PICTURE might  	// cause a false sync. Not high priority since it will only cause a slight error  	// in bitrate calculation if a false sync is found.  	int c = stream.ReadByte ();  	// keep as ReadByte  	while (c != -1) {  		if (c == 0xFF) {  			c = stream.ReadByte ();  			// keep as ReadByte  			if (c >= 0xF8 && c <= 0xFB) {  				break;  			}  		} else {  			c = stream.ReadByte ();  			// keep as ReadByte  		}  	}  	if (c == -1) {  		throw new InvalidDataException ("No sync found");  	}  	long startaudio = stream.Position;  	long totalsize = stream.Length - startaudio - tmpAPEv2TagSize - tmpID3v1TagSize;  	_bitrate = totalsize / (_totalSeconds * 125);  }  
Magic Number,IdSharp.AudioInfo,Flac,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Flac\Flac.cs,Flac,The following statement contains a magic number: using (FileStream stream = File.Open (path' FileMode.Open' FileAccess.Read' FileShare.Read)) {  	// Skip ID3v2 tag  	int tmpID3v2TagSize = ID3v2.GetTagSize (stream);  	int tmpID3v1TagSize = ID3v1.GetTagSize (stream);  	int tmpAPEv2TagSize = APEv2.GetTagSize (stream);  	stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  	// Read flac marker  	byte[] flacMarker = new Byte[4];  	stream.Read (flacMarker' 0' 4);  	if (ByteUtils.Compare (flacMarker' FLAC_MARKER) == false) {  		throw new InvalidDataException ("No header found");  	}  	// skip frame header and stuff we're not interested in  	stream.Seek (14' SeekOrigin.Current);  	byte[] buf = stream.Read (8);  	_frequency = (buf [0] << 12) + (buf [1] << 4) + (buf [2] >> 4);  	_channels = ((buf [2] >> 1) & 0x03) + 1;  	_samples = ((buf [3] & 0x0F) << 32) + (buf [4] << 24) + (buf [5] << 16) + (buf [6] << 8) + buf [7];  	_totalSeconds = _samples / (decimal)_frequency;  	// Find first sync  	// TODO: There's probably a better way to do this.. also an embedded PICTURE might  	// cause a false sync. Not high priority since it will only cause a slight error  	// in bitrate calculation if a false sync is found.  	int c = stream.ReadByte ();  	// keep as ReadByte  	while (c != -1) {  		if (c == 0xFF) {  			c = stream.ReadByte ();  			// keep as ReadByte  			if (c >= 0xF8 && c <= 0xFB) {  				break;  			}  		} else {  			c = stream.ReadByte ();  			// keep as ReadByte  		}  	}  	if (c == -1) {  		throw new InvalidDataException ("No sync found");  	}  	long startaudio = stream.Position;  	long totalsize = stream.Length - startaudio - tmpAPEv2TagSize - tmpID3v1TagSize;  	_bitrate = totalsize / (_totalSeconds * 125);  }  
Magic Number,IdSharp.AudioInfo,Flac,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Flac\Flac.cs,Flac,The following statement contains a magic number: using (FileStream stream = File.Open (path' FileMode.Open' FileAccess.Read' FileShare.Read)) {  	// Skip ID3v2 tag  	int tmpID3v2TagSize = ID3v2.GetTagSize (stream);  	int tmpID3v1TagSize = ID3v1.GetTagSize (stream);  	int tmpAPEv2TagSize = APEv2.GetTagSize (stream);  	stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  	// Read flac marker  	byte[] flacMarker = new Byte[4];  	stream.Read (flacMarker' 0' 4);  	if (ByteUtils.Compare (flacMarker' FLAC_MARKER) == false) {  		throw new InvalidDataException ("No header found");  	}  	// skip frame header and stuff we're not interested in  	stream.Seek (14' SeekOrigin.Current);  	byte[] buf = stream.Read (8);  	_frequency = (buf [0] << 12) + (buf [1] << 4) + (buf [2] >> 4);  	_channels = ((buf [2] >> 1) & 0x03) + 1;  	_samples = ((buf [3] & 0x0F) << 32) + (buf [4] << 24) + (buf [5] << 16) + (buf [6] << 8) + buf [7];  	_totalSeconds = _samples / (decimal)_frequency;  	// Find first sync  	// TODO: There's probably a better way to do this.. also an embedded PICTURE might  	// cause a false sync. Not high priority since it will only cause a slight error  	// in bitrate calculation if a false sync is found.  	int c = stream.ReadByte ();  	// keep as ReadByte  	while (c != -1) {  		if (c == 0xFF) {  			c = stream.ReadByte ();  			// keep as ReadByte  			if (c >= 0xF8 && c <= 0xFB) {  				break;  			}  		} else {  			c = stream.ReadByte ();  			// keep as ReadByte  		}  	}  	if (c == -1) {  		throw new InvalidDataException ("No sync found");  	}  	long startaudio = stream.Position;  	long totalsize = stream.Length - startaudio - tmpAPEv2TagSize - tmpID3v1TagSize;  	_bitrate = totalsize / (_totalSeconds * 125);  }  
Magic Number,IdSharp.AudioInfo,Flac,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Flac\Flac.cs,Flac,The following statement contains a magic number: using (FileStream stream = File.Open (path' FileMode.Open' FileAccess.Read' FileShare.Read)) {  	// Skip ID3v2 tag  	int tmpID3v2TagSize = ID3v2.GetTagSize (stream);  	int tmpID3v1TagSize = ID3v1.GetTagSize (stream);  	int tmpAPEv2TagSize = APEv2.GetTagSize (stream);  	stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  	// Read flac marker  	byte[] flacMarker = new Byte[4];  	stream.Read (flacMarker' 0' 4);  	if (ByteUtils.Compare (flacMarker' FLAC_MARKER) == false) {  		throw new InvalidDataException ("No header found");  	}  	// skip frame header and stuff we're not interested in  	stream.Seek (14' SeekOrigin.Current);  	byte[] buf = stream.Read (8);  	_frequency = (buf [0] << 12) + (buf [1] << 4) + (buf [2] >> 4);  	_channels = ((buf [2] >> 1) & 0x03) + 1;  	_samples = ((buf [3] & 0x0F) << 32) + (buf [4] << 24) + (buf [5] << 16) + (buf [6] << 8) + buf [7];  	_totalSeconds = _samples / (decimal)_frequency;  	// Find first sync  	// TODO: There's probably a better way to do this.. also an embedded PICTURE might  	// cause a false sync. Not high priority since it will only cause a slight error  	// in bitrate calculation if a false sync is found.  	int c = stream.ReadByte ();  	// keep as ReadByte  	while (c != -1) {  		if (c == 0xFF) {  			c = stream.ReadByte ();  			// keep as ReadByte  			if (c >= 0xF8 && c <= 0xFB) {  				break;  			}  		} else {  			c = stream.ReadByte ();  			// keep as ReadByte  		}  	}  	if (c == -1) {  		throw new InvalidDataException ("No sync found");  	}  	long startaudio = stream.Position;  	long totalsize = stream.Length - startaudio - tmpAPEv2TagSize - tmpID3v1TagSize;  	_bitrate = totalsize / (_totalSeconds * 125);  }  
Magic Number,IdSharp.AudioInfo,Flac,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Flac\Flac.cs,Flac,The following statement contains a magic number: using (FileStream stream = File.Open (path' FileMode.Open' FileAccess.Read' FileShare.Read)) {  	// Skip ID3v2 tag  	int tmpID3v2TagSize = ID3v2.GetTagSize (stream);  	int tmpID3v1TagSize = ID3v1.GetTagSize (stream);  	int tmpAPEv2TagSize = APEv2.GetTagSize (stream);  	stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  	// Read flac marker  	byte[] flacMarker = new Byte[4];  	stream.Read (flacMarker' 0' 4);  	if (ByteUtils.Compare (flacMarker' FLAC_MARKER) == false) {  		throw new InvalidDataException ("No header found");  	}  	// skip frame header and stuff we're not interested in  	stream.Seek (14' SeekOrigin.Current);  	byte[] buf = stream.Read (8);  	_frequency = (buf [0] << 12) + (buf [1] << 4) + (buf [2] >> 4);  	_channels = ((buf [2] >> 1) & 0x03) + 1;  	_samples = ((buf [3] & 0x0F) << 32) + (buf [4] << 24) + (buf [5] << 16) + (buf [6] << 8) + buf [7];  	_totalSeconds = _samples / (decimal)_frequency;  	// Find first sync  	// TODO: There's probably a better way to do this.. also an embedded PICTURE might  	// cause a false sync. Not high priority since it will only cause a slight error  	// in bitrate calculation if a false sync is found.  	int c = stream.ReadByte ();  	// keep as ReadByte  	while (c != -1) {  		if (c == 0xFF) {  			c = stream.ReadByte ();  			// keep as ReadByte  			if (c >= 0xF8 && c <= 0xFB) {  				break;  			}  		} else {  			c = stream.ReadByte ();  			// keep as ReadByte  		}  	}  	if (c == -1) {  		throw new InvalidDataException ("No sync found");  	}  	long startaudio = stream.Position;  	long totalsize = stream.Length - startaudio - tmpAPEv2TagSize - tmpID3v1TagSize;  	_bitrate = totalsize / (_totalSeconds * 125);  }  
Magic Number,IdSharp.AudioInfo,Flac,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Flac\Flac.cs,Flac,The following statement contains a magic number: using (FileStream stream = File.Open (path' FileMode.Open' FileAccess.Read' FileShare.Read)) {  	// Skip ID3v2 tag  	int tmpID3v2TagSize = ID3v2.GetTagSize (stream);  	int tmpID3v1TagSize = ID3v1.GetTagSize (stream);  	int tmpAPEv2TagSize = APEv2.GetTagSize (stream);  	stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  	// Read flac marker  	byte[] flacMarker = new Byte[4];  	stream.Read (flacMarker' 0' 4);  	if (ByteUtils.Compare (flacMarker' FLAC_MARKER) == false) {  		throw new InvalidDataException ("No header found");  	}  	// skip frame header and stuff we're not interested in  	stream.Seek (14' SeekOrigin.Current);  	byte[] buf = stream.Read (8);  	_frequency = (buf [0] << 12) + (buf [1] << 4) + (buf [2] >> 4);  	_channels = ((buf [2] >> 1) & 0x03) + 1;  	_samples = ((buf [3] & 0x0F) << 32) + (buf [4] << 24) + (buf [5] << 16) + (buf [6] << 8) + buf [7];  	_totalSeconds = _samples / (decimal)_frequency;  	// Find first sync  	// TODO: There's probably a better way to do this.. also an embedded PICTURE might  	// cause a false sync. Not high priority since it will only cause a slight error  	// in bitrate calculation if a false sync is found.  	int c = stream.ReadByte ();  	// keep as ReadByte  	while (c != -1) {  		if (c == 0xFF) {  			c = stream.ReadByte ();  			// keep as ReadByte  			if (c >= 0xF8 && c <= 0xFB) {  				break;  			}  		} else {  			c = stream.ReadByte ();  			// keep as ReadByte  		}  	}  	if (c == -1) {  		throw new InvalidDataException ("No sync found");  	}  	long startaudio = stream.Position;  	long totalsize = stream.Length - startaudio - tmpAPEv2TagSize - tmpID3v1TagSize;  	_bitrate = totalsize / (_totalSeconds * 125);  }  
Magic Number,IdSharp.AudioInfo,Flac,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Flac\Flac.cs,Flac,The following statement contains a magic number: using (FileStream stream = File.Open (path' FileMode.Open' FileAccess.Read' FileShare.Read)) {  	// Skip ID3v2 tag  	int tmpID3v2TagSize = ID3v2.GetTagSize (stream);  	int tmpID3v1TagSize = ID3v1.GetTagSize (stream);  	int tmpAPEv2TagSize = APEv2.GetTagSize (stream);  	stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  	// Read flac marker  	byte[] flacMarker = new Byte[4];  	stream.Read (flacMarker' 0' 4);  	if (ByteUtils.Compare (flacMarker' FLAC_MARKER) == false) {  		throw new InvalidDataException ("No header found");  	}  	// skip frame header and stuff we're not interested in  	stream.Seek (14' SeekOrigin.Current);  	byte[] buf = stream.Read (8);  	_frequency = (buf [0] << 12) + (buf [1] << 4) + (buf [2] >> 4);  	_channels = ((buf [2] >> 1) & 0x03) + 1;  	_samples = ((buf [3] & 0x0F) << 32) + (buf [4] << 24) + (buf [5] << 16) + (buf [6] << 8) + buf [7];  	_totalSeconds = _samples / (decimal)_frequency;  	// Find first sync  	// TODO: There's probably a better way to do this.. also an embedded PICTURE might  	// cause a false sync. Not high priority since it will only cause a slight error  	// in bitrate calculation if a false sync is found.  	int c = stream.ReadByte ();  	// keep as ReadByte  	while (c != -1) {  		if (c == 0xFF) {  			c = stream.ReadByte ();  			// keep as ReadByte  			if (c >= 0xF8 && c <= 0xFB) {  				break;  			}  		} else {  			c = stream.ReadByte ();  			// keep as ReadByte  		}  	}  	if (c == -1) {  		throw new InvalidDataException ("No sync found");  	}  	long startaudio = stream.Position;  	long totalsize = stream.Length - startaudio - tmpAPEv2TagSize - tmpID3v1TagSize;  	_bitrate = totalsize / (_totalSeconds * 125);  }  
Magic Number,IdSharp.AudioInfo,Flac,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Flac\Flac.cs,Flac,The following statement contains a magic number: using (FileStream stream = File.Open (path' FileMode.Open' FileAccess.Read' FileShare.Read)) {  	// Skip ID3v2 tag  	int tmpID3v2TagSize = ID3v2.GetTagSize (stream);  	int tmpID3v1TagSize = ID3v1.GetTagSize (stream);  	int tmpAPEv2TagSize = APEv2.GetTagSize (stream);  	stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  	// Read flac marker  	byte[] flacMarker = new Byte[4];  	stream.Read (flacMarker' 0' 4);  	if (ByteUtils.Compare (flacMarker' FLAC_MARKER) == false) {  		throw new InvalidDataException ("No header found");  	}  	// skip frame header and stuff we're not interested in  	stream.Seek (14' SeekOrigin.Current);  	byte[] buf = stream.Read (8);  	_frequency = (buf [0] << 12) + (buf [1] << 4) + (buf [2] >> 4);  	_channels = ((buf [2] >> 1) & 0x03) + 1;  	_samples = ((buf [3] & 0x0F) << 32) + (buf [4] << 24) + (buf [5] << 16) + (buf [6] << 8) + buf [7];  	_totalSeconds = _samples / (decimal)_frequency;  	// Find first sync  	// TODO: There's probably a better way to do this.. also an embedded PICTURE might  	// cause a false sync. Not high priority since it will only cause a slight error  	// in bitrate calculation if a false sync is found.  	int c = stream.ReadByte ();  	// keep as ReadByte  	while (c != -1) {  		if (c == 0xFF) {  			c = stream.ReadByte ();  			// keep as ReadByte  			if (c >= 0xF8 && c <= 0xFB) {  				break;  			}  		} else {  			c = stream.ReadByte ();  			// keep as ReadByte  		}  	}  	if (c == -1) {  		throw new InvalidDataException ("No sync found");  	}  	long startaudio = stream.Position;  	long totalsize = stream.Length - startaudio - tmpAPEv2TagSize - tmpID3v1TagSize;  	_bitrate = totalsize / (_totalSeconds * 125);  }  
Magic Number,IdSharp.AudioInfo,Flac,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Flac\Flac.cs,Flac,The following statement contains a magic number: using (FileStream stream = File.Open (path' FileMode.Open' FileAccess.Read' FileShare.Read)) {  	// Skip ID3v2 tag  	int tmpID3v2TagSize = ID3v2.GetTagSize (stream);  	int tmpID3v1TagSize = ID3v1.GetTagSize (stream);  	int tmpAPEv2TagSize = APEv2.GetTagSize (stream);  	stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  	// Read flac marker  	byte[] flacMarker = new Byte[4];  	stream.Read (flacMarker' 0' 4);  	if (ByteUtils.Compare (flacMarker' FLAC_MARKER) == false) {  		throw new InvalidDataException ("No header found");  	}  	// skip frame header and stuff we're not interested in  	stream.Seek (14' SeekOrigin.Current);  	byte[] buf = stream.Read (8);  	_frequency = (buf [0] << 12) + (buf [1] << 4) + (buf [2] >> 4);  	_channels = ((buf [2] >> 1) & 0x03) + 1;  	_samples = ((buf [3] & 0x0F) << 32) + (buf [4] << 24) + (buf [5] << 16) + (buf [6] << 8) + buf [7];  	_totalSeconds = _samples / (decimal)_frequency;  	// Find first sync  	// TODO: There's probably a better way to do this.. also an embedded PICTURE might  	// cause a false sync. Not high priority since it will only cause a slight error  	// in bitrate calculation if a false sync is found.  	int c = stream.ReadByte ();  	// keep as ReadByte  	while (c != -1) {  		if (c == 0xFF) {  			c = stream.ReadByte ();  			// keep as ReadByte  			if (c >= 0xF8 && c <= 0xFB) {  				break;  			}  		} else {  			c = stream.ReadByte ();  			// keep as ReadByte  		}  	}  	if (c == -1) {  		throw new InvalidDataException ("No sync found");  	}  	long startaudio = stream.Position;  	long totalsize = stream.Length - startaudio - tmpAPEv2TagSize - tmpID3v1TagSize;  	_bitrate = totalsize / (_totalSeconds * 125);  }  
Magic Number,IdSharp.AudioInfo,Flac,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Flac\Flac.cs,Flac,The following statement contains a magic number: using (FileStream stream = File.Open (path' FileMode.Open' FileAccess.Read' FileShare.Read)) {  	// Skip ID3v2 tag  	int tmpID3v2TagSize = ID3v2.GetTagSize (stream);  	int tmpID3v1TagSize = ID3v1.GetTagSize (stream);  	int tmpAPEv2TagSize = APEv2.GetTagSize (stream);  	stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  	// Read flac marker  	byte[] flacMarker = new Byte[4];  	stream.Read (flacMarker' 0' 4);  	if (ByteUtils.Compare (flacMarker' FLAC_MARKER) == false) {  		throw new InvalidDataException ("No header found");  	}  	// skip frame header and stuff we're not interested in  	stream.Seek (14' SeekOrigin.Current);  	byte[] buf = stream.Read (8);  	_frequency = (buf [0] << 12) + (buf [1] << 4) + (buf [2] >> 4);  	_channels = ((buf [2] >> 1) & 0x03) + 1;  	_samples = ((buf [3] & 0x0F) << 32) + (buf [4] << 24) + (buf [5] << 16) + (buf [6] << 8) + buf [7];  	_totalSeconds = _samples / (decimal)_frequency;  	// Find first sync  	// TODO: There's probably a better way to do this.. also an embedded PICTURE might  	// cause a false sync. Not high priority since it will only cause a slight error  	// in bitrate calculation if a false sync is found.  	int c = stream.ReadByte ();  	// keep as ReadByte  	while (c != -1) {  		if (c == 0xFF) {  			c = stream.ReadByte ();  			// keep as ReadByte  			if (c >= 0xF8 && c <= 0xFB) {  				break;  			}  		} else {  			c = stream.ReadByte ();  			// keep as ReadByte  		}  	}  	if (c == -1) {  		throw new InvalidDataException ("No sync found");  	}  	long startaudio = stream.Position;  	long totalsize = stream.Length - startaudio - tmpAPEv2TagSize - tmpID3v1TagSize;  	_bitrate = totalsize / (_totalSeconds * 125);  }  
Magic Number,IdSharp.AudioInfo,Flac,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Flac\Flac.cs,Flac,The following statement contains a magic number: using (FileStream stream = File.Open (path' FileMode.Open' FileAccess.Read' FileShare.Read)) {  	// Skip ID3v2 tag  	int tmpID3v2TagSize = ID3v2.GetTagSize (stream);  	int tmpID3v1TagSize = ID3v1.GetTagSize (stream);  	int tmpAPEv2TagSize = APEv2.GetTagSize (stream);  	stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  	// Read flac marker  	byte[] flacMarker = new Byte[4];  	stream.Read (flacMarker' 0' 4);  	if (ByteUtils.Compare (flacMarker' FLAC_MARKER) == false) {  		throw new InvalidDataException ("No header found");  	}  	// skip frame header and stuff we're not interested in  	stream.Seek (14' SeekOrigin.Current);  	byte[] buf = stream.Read (8);  	_frequency = (buf [0] << 12) + (buf [1] << 4) + (buf [2] >> 4);  	_channels = ((buf [2] >> 1) & 0x03) + 1;  	_samples = ((buf [3] & 0x0F) << 32) + (buf [4] << 24) + (buf [5] << 16) + (buf [6] << 8) + buf [7];  	_totalSeconds = _samples / (decimal)_frequency;  	// Find first sync  	// TODO: There's probably a better way to do this.. also an embedded PICTURE might  	// cause a false sync. Not high priority since it will only cause a slight error  	// in bitrate calculation if a false sync is found.  	int c = stream.ReadByte ();  	// keep as ReadByte  	while (c != -1) {  		if (c == 0xFF) {  			c = stream.ReadByte ();  			// keep as ReadByte  			if (c >= 0xF8 && c <= 0xFB) {  				break;  			}  		} else {  			c = stream.ReadByte ();  			// keep as ReadByte  		}  	}  	if (c == -1) {  		throw new InvalidDataException ("No sync found");  	}  	long startaudio = stream.Position;  	long totalsize = stream.Length - startaudio - tmpAPEv2TagSize - tmpID3v1TagSize;  	_bitrate = totalsize / (_totalSeconds * 125);  }  
Magic Number,IdSharp.AudioInfo,Flac,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Flac\Flac.cs,Flac,The following statement contains a magic number: using (FileStream stream = File.Open (path' FileMode.Open' FileAccess.Read' FileShare.Read)) {  	// Skip ID3v2 tag  	int tmpID3v2TagSize = ID3v2.GetTagSize (stream);  	int tmpID3v1TagSize = ID3v1.GetTagSize (stream);  	int tmpAPEv2TagSize = APEv2.GetTagSize (stream);  	stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  	// Read flac marker  	byte[] flacMarker = new Byte[4];  	stream.Read (flacMarker' 0' 4);  	if (ByteUtils.Compare (flacMarker' FLAC_MARKER) == false) {  		throw new InvalidDataException ("No header found");  	}  	// skip frame header and stuff we're not interested in  	stream.Seek (14' SeekOrigin.Current);  	byte[] buf = stream.Read (8);  	_frequency = (buf [0] << 12) + (buf [1] << 4) + (buf [2] >> 4);  	_channels = ((buf [2] >> 1) & 0x03) + 1;  	_samples = ((buf [3] & 0x0F) << 32) + (buf [4] << 24) + (buf [5] << 16) + (buf [6] << 8) + buf [7];  	_totalSeconds = _samples / (decimal)_frequency;  	// Find first sync  	// TODO: There's probably a better way to do this.. also an embedded PICTURE might  	// cause a false sync. Not high priority since it will only cause a slight error  	// in bitrate calculation if a false sync is found.  	int c = stream.ReadByte ();  	// keep as ReadByte  	while (c != -1) {  		if (c == 0xFF) {  			c = stream.ReadByte ();  			// keep as ReadByte  			if (c >= 0xF8 && c <= 0xFB) {  				break;  			}  		} else {  			c = stream.ReadByte ();  			// keep as ReadByte  		}  	}  	if (c == -1) {  		throw new InvalidDataException ("No sync found");  	}  	long startaudio = stream.Position;  	long totalsize = stream.Length - startaudio - tmpAPEv2TagSize - tmpID3v1TagSize;  	_bitrate = totalsize / (_totalSeconds * 125);  }  
Magic Number,IdSharp.AudioInfo,Flac,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Flac\Flac.cs,Flac,The following statement contains a magic number: using (FileStream stream = File.Open (path' FileMode.Open' FileAccess.Read' FileShare.Read)) {  	// Skip ID3v2 tag  	int tmpID3v2TagSize = ID3v2.GetTagSize (stream);  	int tmpID3v1TagSize = ID3v1.GetTagSize (stream);  	int tmpAPEv2TagSize = APEv2.GetTagSize (stream);  	stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  	// Read flac marker  	byte[] flacMarker = new Byte[4];  	stream.Read (flacMarker' 0' 4);  	if (ByteUtils.Compare (flacMarker' FLAC_MARKER) == false) {  		throw new InvalidDataException ("No header found");  	}  	// skip frame header and stuff we're not interested in  	stream.Seek (14' SeekOrigin.Current);  	byte[] buf = stream.Read (8);  	_frequency = (buf [0] << 12) + (buf [1] << 4) + (buf [2] >> 4);  	_channels = ((buf [2] >> 1) & 0x03) + 1;  	_samples = ((buf [3] & 0x0F) << 32) + (buf [4] << 24) + (buf [5] << 16) + (buf [6] << 8) + buf [7];  	_totalSeconds = _samples / (decimal)_frequency;  	// Find first sync  	// TODO: There's probably a better way to do this.. also an embedded PICTURE might  	// cause a false sync. Not high priority since it will only cause a slight error  	// in bitrate calculation if a false sync is found.  	int c = stream.ReadByte ();  	// keep as ReadByte  	while (c != -1) {  		if (c == 0xFF) {  			c = stream.ReadByte ();  			// keep as ReadByte  			if (c >= 0xF8 && c <= 0xFB) {  				break;  			}  		} else {  			c = stream.ReadByte ();  			// keep as ReadByte  		}  	}  	if (c == -1) {  		throw new InvalidDataException ("No sync found");  	}  	long startaudio = stream.Position;  	long totalsize = stream.Length - startaudio - tmpAPEv2TagSize - tmpID3v1TagSize;  	_bitrate = totalsize / (_totalSeconds * 125);  }  
Magic Number,IdSharp.AudioInfo,Flac,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Flac\Flac.cs,Flac,The following statement contains a magic number: using (FileStream stream = File.Open (path' FileMode.Open' FileAccess.Read' FileShare.Read)) {  	// Skip ID3v2 tag  	int tmpID3v2TagSize = ID3v2.GetTagSize (stream);  	int tmpID3v1TagSize = ID3v1.GetTagSize (stream);  	int tmpAPEv2TagSize = APEv2.GetTagSize (stream);  	stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  	// Read flac marker  	byte[] flacMarker = new Byte[4];  	stream.Read (flacMarker' 0' 4);  	if (ByteUtils.Compare (flacMarker' FLAC_MARKER) == false) {  		throw new InvalidDataException ("No header found");  	}  	// skip frame header and stuff we're not interested in  	stream.Seek (14' SeekOrigin.Current);  	byte[] buf = stream.Read (8);  	_frequency = (buf [0] << 12) + (buf [1] << 4) + (buf [2] >> 4);  	_channels = ((buf [2] >> 1) & 0x03) + 1;  	_samples = ((buf [3] & 0x0F) << 32) + (buf [4] << 24) + (buf [5] << 16) + (buf [6] << 8) + buf [7];  	_totalSeconds = _samples / (decimal)_frequency;  	// Find first sync  	// TODO: There's probably a better way to do this.. also an embedded PICTURE might  	// cause a false sync. Not high priority since it will only cause a slight error  	// in bitrate calculation if a false sync is found.  	int c = stream.ReadByte ();  	// keep as ReadByte  	while (c != -1) {  		if (c == 0xFF) {  			c = stream.ReadByte ();  			// keep as ReadByte  			if (c >= 0xF8 && c <= 0xFB) {  				break;  			}  		} else {  			c = stream.ReadByte ();  			// keep as ReadByte  		}  	}  	if (c == -1) {  		throw new InvalidDataException ("No sync found");  	}  	long startaudio = stream.Position;  	long totalsize = stream.Length - startaudio - tmpAPEv2TagSize - tmpID3v1TagSize;  	_bitrate = totalsize / (_totalSeconds * 125);  }  
Magic Number,IdSharp.AudioInfo,Flac,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Flac\Flac.cs,Flac,The following statement contains a magic number: using (FileStream stream = File.Open (path' FileMode.Open' FileAccess.Read' FileShare.Read)) {  	// Skip ID3v2 tag  	int tmpID3v2TagSize = ID3v2.GetTagSize (stream);  	int tmpID3v1TagSize = ID3v1.GetTagSize (stream);  	int tmpAPEv2TagSize = APEv2.GetTagSize (stream);  	stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  	// Read flac marker  	byte[] flacMarker = new Byte[4];  	stream.Read (flacMarker' 0' 4);  	if (ByteUtils.Compare (flacMarker' FLAC_MARKER) == false) {  		throw new InvalidDataException ("No header found");  	}  	// skip frame header and stuff we're not interested in  	stream.Seek (14' SeekOrigin.Current);  	byte[] buf = stream.Read (8);  	_frequency = (buf [0] << 12) + (buf [1] << 4) + (buf [2] >> 4);  	_channels = ((buf [2] >> 1) & 0x03) + 1;  	_samples = ((buf [3] & 0x0F) << 32) + (buf [4] << 24) + (buf [5] << 16) + (buf [6] << 8) + buf [7];  	_totalSeconds = _samples / (decimal)_frequency;  	// Find first sync  	// TODO: There's probably a better way to do this.. also an embedded PICTURE might  	// cause a false sync. Not high priority since it will only cause a slight error  	// in bitrate calculation if a false sync is found.  	int c = stream.ReadByte ();  	// keep as ReadByte  	while (c != -1) {  		if (c == 0xFF) {  			c = stream.ReadByte ();  			// keep as ReadByte  			if (c >= 0xF8 && c <= 0xFB) {  				break;  			}  		} else {  			c = stream.ReadByte ();  			// keep as ReadByte  		}  	}  	if (c == -1) {  		throw new InvalidDataException ("No sync found");  	}  	long startaudio = stream.Position;  	long totalsize = stream.Length - startaudio - tmpAPEv2TagSize - tmpID3v1TagSize;  	_bitrate = totalsize / (_totalSeconds * 125);  }  
Magic Number,IdSharp.AudioInfo,Flac,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Flac\Flac.cs,Flac,The following statement contains a magic number: using (FileStream stream = File.Open (path' FileMode.Open' FileAccess.Read' FileShare.Read)) {  	// Skip ID3v2 tag  	int tmpID3v2TagSize = ID3v2.GetTagSize (stream);  	int tmpID3v1TagSize = ID3v1.GetTagSize (stream);  	int tmpAPEv2TagSize = APEv2.GetTagSize (stream);  	stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  	// Read flac marker  	byte[] flacMarker = new Byte[4];  	stream.Read (flacMarker' 0' 4);  	if (ByteUtils.Compare (flacMarker' FLAC_MARKER) == false) {  		throw new InvalidDataException ("No header found");  	}  	// skip frame header and stuff we're not interested in  	stream.Seek (14' SeekOrigin.Current);  	byte[] buf = stream.Read (8);  	_frequency = (buf [0] << 12) + (buf [1] << 4) + (buf [2] >> 4);  	_channels = ((buf [2] >> 1) & 0x03) + 1;  	_samples = ((buf [3] & 0x0F) << 32) + (buf [4] << 24) + (buf [5] << 16) + (buf [6] << 8) + buf [7];  	_totalSeconds = _samples / (decimal)_frequency;  	// Find first sync  	// TODO: There's probably a better way to do this.. also an embedded PICTURE might  	// cause a false sync. Not high priority since it will only cause a slight error  	// in bitrate calculation if a false sync is found.  	int c = stream.ReadByte ();  	// keep as ReadByte  	while (c != -1) {  		if (c == 0xFF) {  			c = stream.ReadByte ();  			// keep as ReadByte  			if (c >= 0xF8 && c <= 0xFB) {  				break;  			}  		} else {  			c = stream.ReadByte ();  			// keep as ReadByte  		}  	}  	if (c == -1) {  		throw new InvalidDataException ("No sync found");  	}  	long startaudio = stream.Position;  	long totalsize = stream.Length - startaudio - tmpAPEv2TagSize - tmpID3v1TagSize;  	_bitrate = totalsize / (_totalSeconds * 125);  }  
Magic Number,IdSharp.AudioInfo,Flac,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Flac\Flac.cs,Flac,The following statement contains a magic number: using (FileStream stream = File.Open (path' FileMode.Open' FileAccess.Read' FileShare.Read)) {  	// Skip ID3v2 tag  	int tmpID3v2TagSize = ID3v2.GetTagSize (stream);  	int tmpID3v1TagSize = ID3v1.GetTagSize (stream);  	int tmpAPEv2TagSize = APEv2.GetTagSize (stream);  	stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  	// Read flac marker  	byte[] flacMarker = new Byte[4];  	stream.Read (flacMarker' 0' 4);  	if (ByteUtils.Compare (flacMarker' FLAC_MARKER) == false) {  		throw new InvalidDataException ("No header found");  	}  	// skip frame header and stuff we're not interested in  	stream.Seek (14' SeekOrigin.Current);  	byte[] buf = stream.Read (8);  	_frequency = (buf [0] << 12) + (buf [1] << 4) + (buf [2] >> 4);  	_channels = ((buf [2] >> 1) & 0x03) + 1;  	_samples = ((buf [3] & 0x0F) << 32) + (buf [4] << 24) + (buf [5] << 16) + (buf [6] << 8) + buf [7];  	_totalSeconds = _samples / (decimal)_frequency;  	// Find first sync  	// TODO: There's probably a better way to do this.. also an embedded PICTURE might  	// cause a false sync. Not high priority since it will only cause a slight error  	// in bitrate calculation if a false sync is found.  	int c = stream.ReadByte ();  	// keep as ReadByte  	while (c != -1) {  		if (c == 0xFF) {  			c = stream.ReadByte ();  			// keep as ReadByte  			if (c >= 0xF8 && c <= 0xFB) {  				break;  			}  		} else {  			c = stream.ReadByte ();  			// keep as ReadByte  		}  	}  	if (c == -1) {  		throw new InvalidDataException ("No sync found");  	}  	long startaudio = stream.Position;  	long totalsize = stream.Length - startaudio - tmpAPEv2TagSize - tmpID3v1TagSize;  	_bitrate = totalsize / (_totalSeconds * 125);  }  
Magic Number,IdSharp.AudioInfo,Flac,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Flac\Flac.cs,Flac,The following statement contains a magic number: using (FileStream stream = File.Open (path' FileMode.Open' FileAccess.Read' FileShare.Read)) {  	// Skip ID3v2 tag  	int tmpID3v2TagSize = ID3v2.GetTagSize (stream);  	int tmpID3v1TagSize = ID3v1.GetTagSize (stream);  	int tmpAPEv2TagSize = APEv2.GetTagSize (stream);  	stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  	// Read flac marker  	byte[] flacMarker = new Byte[4];  	stream.Read (flacMarker' 0' 4);  	if (ByteUtils.Compare (flacMarker' FLAC_MARKER) == false) {  		throw new InvalidDataException ("No header found");  	}  	// skip frame header and stuff we're not interested in  	stream.Seek (14' SeekOrigin.Current);  	byte[] buf = stream.Read (8);  	_frequency = (buf [0] << 12) + (buf [1] << 4) + (buf [2] >> 4);  	_channels = ((buf [2] >> 1) & 0x03) + 1;  	_samples = ((buf [3] & 0x0F) << 32) + (buf [4] << 24) + (buf [5] << 16) + (buf [6] << 8) + buf [7];  	_totalSeconds = _samples / (decimal)_frequency;  	// Find first sync  	// TODO: There's probably a better way to do this.. also an embedded PICTURE might  	// cause a false sync. Not high priority since it will only cause a slight error  	// in bitrate calculation if a false sync is found.  	int c = stream.ReadByte ();  	// keep as ReadByte  	while (c != -1) {  		if (c == 0xFF) {  			c = stream.ReadByte ();  			// keep as ReadByte  			if (c >= 0xF8 && c <= 0xFB) {  				break;  			}  		} else {  			c = stream.ReadByte ();  			// keep as ReadByte  		}  	}  	if (c == -1) {  		throw new InvalidDataException ("No sync found");  	}  	long startaudio = stream.Position;  	long totalsize = stream.Length - startaudio - tmpAPEv2TagSize - tmpID3v1TagSize;  	_bitrate = totalsize / (_totalSeconds * 125);  }  
Magic Number,IdSharp.AudioInfo,Flac,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Flac\Flac.cs,Flac,The following statement contains a magic number: stream.Read (flacMarker' 0' 4);  
Magic Number,IdSharp.AudioInfo,Flac,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Flac\Flac.cs,Flac,The following statement contains a magic number: stream.Seek (14' SeekOrigin.Current);  
Magic Number,IdSharp.AudioInfo,Flac,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Flac\Flac.cs,Flac,The following statement contains a magic number: _frequency = (buf [0] << 12) + (buf [1] << 4) + (buf [2] >> 4);  
Magic Number,IdSharp.AudioInfo,Flac,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Flac\Flac.cs,Flac,The following statement contains a magic number: _frequency = (buf [0] << 12) + (buf [1] << 4) + (buf [2] >> 4);  
Magic Number,IdSharp.AudioInfo,Flac,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Flac\Flac.cs,Flac,The following statement contains a magic number: _frequency = (buf [0] << 12) + (buf [1] << 4) + (buf [2] >> 4);  
Magic Number,IdSharp.AudioInfo,Flac,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Flac\Flac.cs,Flac,The following statement contains a magic number: _frequency = (buf [0] << 12) + (buf [1] << 4) + (buf [2] >> 4);  
Magic Number,IdSharp.AudioInfo,Flac,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Flac\Flac.cs,Flac,The following statement contains a magic number: _channels = ((buf [2] >> 1) & 0x03) + 1;  
Magic Number,IdSharp.AudioInfo,Flac,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Flac\Flac.cs,Flac,The following statement contains a magic number: _samples = ((buf [3] & 0x0F) << 32) + (buf [4] << 24) + (buf [5] << 16) + (buf [6] << 8) + buf [7];  
Magic Number,IdSharp.AudioInfo,Flac,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Flac\Flac.cs,Flac,The following statement contains a magic number: _samples = ((buf [3] & 0x0F) << 32) + (buf [4] << 24) + (buf [5] << 16) + (buf [6] << 8) + buf [7];  
Magic Number,IdSharp.AudioInfo,Flac,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Flac\Flac.cs,Flac,The following statement contains a magic number: _samples = ((buf [3] & 0x0F) << 32) + (buf [4] << 24) + (buf [5] << 16) + (buf [6] << 8) + buf [7];  
Magic Number,IdSharp.AudioInfo,Flac,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Flac\Flac.cs,Flac,The following statement contains a magic number: _samples = ((buf [3] & 0x0F) << 32) + (buf [4] << 24) + (buf [5] << 16) + (buf [6] << 8) + buf [7];  
Magic Number,IdSharp.AudioInfo,Flac,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Flac\Flac.cs,Flac,The following statement contains a magic number: _samples = ((buf [3] & 0x0F) << 32) + (buf [4] << 24) + (buf [5] << 16) + (buf [6] << 8) + buf [7];  
Magic Number,IdSharp.AudioInfo,Flac,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Flac\Flac.cs,Flac,The following statement contains a magic number: _samples = ((buf [3] & 0x0F) << 32) + (buf [4] << 24) + (buf [5] << 16) + (buf [6] << 8) + buf [7];  
Magic Number,IdSharp.AudioInfo,Flac,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Flac\Flac.cs,Flac,The following statement contains a magic number: _samples = ((buf [3] & 0x0F) << 32) + (buf [4] << 24) + (buf [5] << 16) + (buf [6] << 8) + buf [7];  
Magic Number,IdSharp.AudioInfo,Flac,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Flac\Flac.cs,Flac,The following statement contains a magic number: _samples = ((buf [3] & 0x0F) << 32) + (buf [4] << 24) + (buf [5] << 16) + (buf [6] << 8) + buf [7];  
Magic Number,IdSharp.AudioInfo,Flac,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Flac\Flac.cs,Flac,The following statement contains a magic number: _samples = ((buf [3] & 0x0F) << 32) + (buf [4] << 24) + (buf [5] << 16) + (buf [6] << 8) + buf [7];  
Magic Number,IdSharp.AudioInfo,Flac,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Flac\Flac.cs,Flac,The following statement contains a magic number: _bitrate = totalsize / (_totalSeconds * 125);  
Magic Number,IdSharp.AudioInfo,MonkeysAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\MonkeysAudio\MonkeysAudio.cs,MonkeysAudio,The following statement contains a magic number: using (FileStream stream = File.Open (path' FileMode.Open' FileAccess.Read' FileShare.Read)) {  	// Skip ID3v2 tag  	int tmpID3v2TagSize = ID3v2.GetTagSize (stream);  	int tmpID3v1TagSize = ID3v1.GetTagSize (stream);  	int tmpAPEv2TagSize = APEv2.GetTagSize (stream);  	stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  	byte[] identifier = stream.Read (4);  	if (ByteUtils.Compare (identifier' MAC_IDENTIFIER' 4) == false) {  		throw new InvalidDataException ("Invalid Monkey's Audio file");  	}  	byte[] buf = stream.Read (4);  	_version = buf [0] + (buf [1] << 8);  	int blocksPerFrame;  	int finalBlocks;  	if (_version >= 3980 && _version <= 3990) {  		buf = stream.Read (4);  		int descriptorLength = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  		stream.Seek (descriptorLength - 12' SeekOrigin.Current);  		// skip DESCRIPTOR  		buf = stream.Read (4);  		_compressionLevel = buf [0] + (buf [1] << 8);  		blocksPerFrame = stream.ReadInt32LittleEndian ();  		finalBlocks = stream.ReadInt32LittleEndian ();  		_frames = stream.ReadInt32LittleEndian ();  		buf = stream.Read (4);  		// skip bits per sample  		_channels = buf [2] + (buf [3] << 8);  		_frequency = stream.ReadInt32LittleEndian ();  	} else if (_version <= 3970) {  		// TODO: This section needs work  		_compressionLevel = buf [2] + (buf [3] << 8);  		buf = stream.Read (24);  		// skip format flags  		_channels = buf [2] + (buf [3] << 8);  		_frequency = buf [4] + (buf [5] << 8) + (buf [6] << 16) + (buf [7] << 32);  		if (_version >= 3950)  			blocksPerFrame = 73728 * 4;  		else if (_version >= 3900 || (_version >= 3800 && _compressionLevel == COMPRESSION_LEVEL_EXTRA_HIGH))  			blocksPerFrame = 73728;  		else  			blocksPerFrame = 9216;  		// TODO: This is definitely fucked up  		finalBlocks = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  		_frames = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  	} else {  		throw new NotImplementedException (string.Format ("MAC {0:0.00} not supported"' _version / 1000.0));  	}  	long totalBlocks = ((_frames - 1) * blocksPerFrame) + finalBlocks;  	long totalSize = stream.Length - stream.Position - tmpAPEv2TagSize - tmpID3v1TagSize;  	_totalSeconds = totalBlocks / (decimal)_frequency;  	_bitrate = totalSize / (_totalSeconds * 125.0m);  }  
Magic Number,IdSharp.AudioInfo,MonkeysAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\MonkeysAudio\MonkeysAudio.cs,MonkeysAudio,The following statement contains a magic number: using (FileStream stream = File.Open (path' FileMode.Open' FileAccess.Read' FileShare.Read)) {  	// Skip ID3v2 tag  	int tmpID3v2TagSize = ID3v2.GetTagSize (stream);  	int tmpID3v1TagSize = ID3v1.GetTagSize (stream);  	int tmpAPEv2TagSize = APEv2.GetTagSize (stream);  	stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  	byte[] identifier = stream.Read (4);  	if (ByteUtils.Compare (identifier' MAC_IDENTIFIER' 4) == false) {  		throw new InvalidDataException ("Invalid Monkey's Audio file");  	}  	byte[] buf = stream.Read (4);  	_version = buf [0] + (buf [1] << 8);  	int blocksPerFrame;  	int finalBlocks;  	if (_version >= 3980 && _version <= 3990) {  		buf = stream.Read (4);  		int descriptorLength = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  		stream.Seek (descriptorLength - 12' SeekOrigin.Current);  		// skip DESCRIPTOR  		buf = stream.Read (4);  		_compressionLevel = buf [0] + (buf [1] << 8);  		blocksPerFrame = stream.ReadInt32LittleEndian ();  		finalBlocks = stream.ReadInt32LittleEndian ();  		_frames = stream.ReadInt32LittleEndian ();  		buf = stream.Read (4);  		// skip bits per sample  		_channels = buf [2] + (buf [3] << 8);  		_frequency = stream.ReadInt32LittleEndian ();  	} else if (_version <= 3970) {  		// TODO: This section needs work  		_compressionLevel = buf [2] + (buf [3] << 8);  		buf = stream.Read (24);  		// skip format flags  		_channels = buf [2] + (buf [3] << 8);  		_frequency = buf [4] + (buf [5] << 8) + (buf [6] << 16) + (buf [7] << 32);  		if (_version >= 3950)  			blocksPerFrame = 73728 * 4;  		else if (_version >= 3900 || (_version >= 3800 && _compressionLevel == COMPRESSION_LEVEL_EXTRA_HIGH))  			blocksPerFrame = 73728;  		else  			blocksPerFrame = 9216;  		// TODO: This is definitely fucked up  		finalBlocks = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  		_frames = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  	} else {  		throw new NotImplementedException (string.Format ("MAC {0:0.00} not supported"' _version / 1000.0));  	}  	long totalBlocks = ((_frames - 1) * blocksPerFrame) + finalBlocks;  	long totalSize = stream.Length - stream.Position - tmpAPEv2TagSize - tmpID3v1TagSize;  	_totalSeconds = totalBlocks / (decimal)_frequency;  	_bitrate = totalSize / (_totalSeconds * 125.0m);  }  
Magic Number,IdSharp.AudioInfo,MonkeysAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\MonkeysAudio\MonkeysAudio.cs,MonkeysAudio,The following statement contains a magic number: using (FileStream stream = File.Open (path' FileMode.Open' FileAccess.Read' FileShare.Read)) {  	// Skip ID3v2 tag  	int tmpID3v2TagSize = ID3v2.GetTagSize (stream);  	int tmpID3v1TagSize = ID3v1.GetTagSize (stream);  	int tmpAPEv2TagSize = APEv2.GetTagSize (stream);  	stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  	byte[] identifier = stream.Read (4);  	if (ByteUtils.Compare (identifier' MAC_IDENTIFIER' 4) == false) {  		throw new InvalidDataException ("Invalid Monkey's Audio file");  	}  	byte[] buf = stream.Read (4);  	_version = buf [0] + (buf [1] << 8);  	int blocksPerFrame;  	int finalBlocks;  	if (_version >= 3980 && _version <= 3990) {  		buf = stream.Read (4);  		int descriptorLength = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  		stream.Seek (descriptorLength - 12' SeekOrigin.Current);  		// skip DESCRIPTOR  		buf = stream.Read (4);  		_compressionLevel = buf [0] + (buf [1] << 8);  		blocksPerFrame = stream.ReadInt32LittleEndian ();  		finalBlocks = stream.ReadInt32LittleEndian ();  		_frames = stream.ReadInt32LittleEndian ();  		buf = stream.Read (4);  		// skip bits per sample  		_channels = buf [2] + (buf [3] << 8);  		_frequency = stream.ReadInt32LittleEndian ();  	} else if (_version <= 3970) {  		// TODO: This section needs work  		_compressionLevel = buf [2] + (buf [3] << 8);  		buf = stream.Read (24);  		// skip format flags  		_channels = buf [2] + (buf [3] << 8);  		_frequency = buf [4] + (buf [5] << 8) + (buf [6] << 16) + (buf [7] << 32);  		if (_version >= 3950)  			blocksPerFrame = 73728 * 4;  		else if (_version >= 3900 || (_version >= 3800 && _compressionLevel == COMPRESSION_LEVEL_EXTRA_HIGH))  			blocksPerFrame = 73728;  		else  			blocksPerFrame = 9216;  		// TODO: This is definitely fucked up  		finalBlocks = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  		_frames = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  	} else {  		throw new NotImplementedException (string.Format ("MAC {0:0.00} not supported"' _version / 1000.0));  	}  	long totalBlocks = ((_frames - 1) * blocksPerFrame) + finalBlocks;  	long totalSize = stream.Length - stream.Position - tmpAPEv2TagSize - tmpID3v1TagSize;  	_totalSeconds = totalBlocks / (decimal)_frequency;  	_bitrate = totalSize / (_totalSeconds * 125.0m);  }  
Magic Number,IdSharp.AudioInfo,MonkeysAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\MonkeysAudio\MonkeysAudio.cs,MonkeysAudio,The following statement contains a magic number: using (FileStream stream = File.Open (path' FileMode.Open' FileAccess.Read' FileShare.Read)) {  	// Skip ID3v2 tag  	int tmpID3v2TagSize = ID3v2.GetTagSize (stream);  	int tmpID3v1TagSize = ID3v1.GetTagSize (stream);  	int tmpAPEv2TagSize = APEv2.GetTagSize (stream);  	stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  	byte[] identifier = stream.Read (4);  	if (ByteUtils.Compare (identifier' MAC_IDENTIFIER' 4) == false) {  		throw new InvalidDataException ("Invalid Monkey's Audio file");  	}  	byte[] buf = stream.Read (4);  	_version = buf [0] + (buf [1] << 8);  	int blocksPerFrame;  	int finalBlocks;  	if (_version >= 3980 && _version <= 3990) {  		buf = stream.Read (4);  		int descriptorLength = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  		stream.Seek (descriptorLength - 12' SeekOrigin.Current);  		// skip DESCRIPTOR  		buf = stream.Read (4);  		_compressionLevel = buf [0] + (buf [1] << 8);  		blocksPerFrame = stream.ReadInt32LittleEndian ();  		finalBlocks = stream.ReadInt32LittleEndian ();  		_frames = stream.ReadInt32LittleEndian ();  		buf = stream.Read (4);  		// skip bits per sample  		_channels = buf [2] + (buf [3] << 8);  		_frequency = stream.ReadInt32LittleEndian ();  	} else if (_version <= 3970) {  		// TODO: This section needs work  		_compressionLevel = buf [2] + (buf [3] << 8);  		buf = stream.Read (24);  		// skip format flags  		_channels = buf [2] + (buf [3] << 8);  		_frequency = buf [4] + (buf [5] << 8) + (buf [6] << 16) + (buf [7] << 32);  		if (_version >= 3950)  			blocksPerFrame = 73728 * 4;  		else if (_version >= 3900 || (_version >= 3800 && _compressionLevel == COMPRESSION_LEVEL_EXTRA_HIGH))  			blocksPerFrame = 73728;  		else  			blocksPerFrame = 9216;  		// TODO: This is definitely fucked up  		finalBlocks = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  		_frames = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  	} else {  		throw new NotImplementedException (string.Format ("MAC {0:0.00} not supported"' _version / 1000.0));  	}  	long totalBlocks = ((_frames - 1) * blocksPerFrame) + finalBlocks;  	long totalSize = stream.Length - stream.Position - tmpAPEv2TagSize - tmpID3v1TagSize;  	_totalSeconds = totalBlocks / (decimal)_frequency;  	_bitrate = totalSize / (_totalSeconds * 125.0m);  }  
Magic Number,IdSharp.AudioInfo,MonkeysAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\MonkeysAudio\MonkeysAudio.cs,MonkeysAudio,The following statement contains a magic number: using (FileStream stream = File.Open (path' FileMode.Open' FileAccess.Read' FileShare.Read)) {  	// Skip ID3v2 tag  	int tmpID3v2TagSize = ID3v2.GetTagSize (stream);  	int tmpID3v1TagSize = ID3v1.GetTagSize (stream);  	int tmpAPEv2TagSize = APEv2.GetTagSize (stream);  	stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  	byte[] identifier = stream.Read (4);  	if (ByteUtils.Compare (identifier' MAC_IDENTIFIER' 4) == false) {  		throw new InvalidDataException ("Invalid Monkey's Audio file");  	}  	byte[] buf = stream.Read (4);  	_version = buf [0] + (buf [1] << 8);  	int blocksPerFrame;  	int finalBlocks;  	if (_version >= 3980 && _version <= 3990) {  		buf = stream.Read (4);  		int descriptorLength = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  		stream.Seek (descriptorLength - 12' SeekOrigin.Current);  		// skip DESCRIPTOR  		buf = stream.Read (4);  		_compressionLevel = buf [0] + (buf [1] << 8);  		blocksPerFrame = stream.ReadInt32LittleEndian ();  		finalBlocks = stream.ReadInt32LittleEndian ();  		_frames = stream.ReadInt32LittleEndian ();  		buf = stream.Read (4);  		// skip bits per sample  		_channels = buf [2] + (buf [3] << 8);  		_frequency = stream.ReadInt32LittleEndian ();  	} else if (_version <= 3970) {  		// TODO: This section needs work  		_compressionLevel = buf [2] + (buf [3] << 8);  		buf = stream.Read (24);  		// skip format flags  		_channels = buf [2] + (buf [3] << 8);  		_frequency = buf [4] + (buf [5] << 8) + (buf [6] << 16) + (buf [7] << 32);  		if (_version >= 3950)  			blocksPerFrame = 73728 * 4;  		else if (_version >= 3900 || (_version >= 3800 && _compressionLevel == COMPRESSION_LEVEL_EXTRA_HIGH))  			blocksPerFrame = 73728;  		else  			blocksPerFrame = 9216;  		// TODO: This is definitely fucked up  		finalBlocks = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  		_frames = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  	} else {  		throw new NotImplementedException (string.Format ("MAC {0:0.00} not supported"' _version / 1000.0));  	}  	long totalBlocks = ((_frames - 1) * blocksPerFrame) + finalBlocks;  	long totalSize = stream.Length - stream.Position - tmpAPEv2TagSize - tmpID3v1TagSize;  	_totalSeconds = totalBlocks / (decimal)_frequency;  	_bitrate = totalSize / (_totalSeconds * 125.0m);  }  
Magic Number,IdSharp.AudioInfo,MonkeysAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\MonkeysAudio\MonkeysAudio.cs,MonkeysAudio,The following statement contains a magic number: using (FileStream stream = File.Open (path' FileMode.Open' FileAccess.Read' FileShare.Read)) {  	// Skip ID3v2 tag  	int tmpID3v2TagSize = ID3v2.GetTagSize (stream);  	int tmpID3v1TagSize = ID3v1.GetTagSize (stream);  	int tmpAPEv2TagSize = APEv2.GetTagSize (stream);  	stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  	byte[] identifier = stream.Read (4);  	if (ByteUtils.Compare (identifier' MAC_IDENTIFIER' 4) == false) {  		throw new InvalidDataException ("Invalid Monkey's Audio file");  	}  	byte[] buf = stream.Read (4);  	_version = buf [0] + (buf [1] << 8);  	int blocksPerFrame;  	int finalBlocks;  	if (_version >= 3980 && _version <= 3990) {  		buf = stream.Read (4);  		int descriptorLength = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  		stream.Seek (descriptorLength - 12' SeekOrigin.Current);  		// skip DESCRIPTOR  		buf = stream.Read (4);  		_compressionLevel = buf [0] + (buf [1] << 8);  		blocksPerFrame = stream.ReadInt32LittleEndian ();  		finalBlocks = stream.ReadInt32LittleEndian ();  		_frames = stream.ReadInt32LittleEndian ();  		buf = stream.Read (4);  		// skip bits per sample  		_channels = buf [2] + (buf [3] << 8);  		_frequency = stream.ReadInt32LittleEndian ();  	} else if (_version <= 3970) {  		// TODO: This section needs work  		_compressionLevel = buf [2] + (buf [3] << 8);  		buf = stream.Read (24);  		// skip format flags  		_channels = buf [2] + (buf [3] << 8);  		_frequency = buf [4] + (buf [5] << 8) + (buf [6] << 16) + (buf [7] << 32);  		if (_version >= 3950)  			blocksPerFrame = 73728 * 4;  		else if (_version >= 3900 || (_version >= 3800 && _compressionLevel == COMPRESSION_LEVEL_EXTRA_HIGH))  			blocksPerFrame = 73728;  		else  			blocksPerFrame = 9216;  		// TODO: This is definitely fucked up  		finalBlocks = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  		_frames = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  	} else {  		throw new NotImplementedException (string.Format ("MAC {0:0.00} not supported"' _version / 1000.0));  	}  	long totalBlocks = ((_frames - 1) * blocksPerFrame) + finalBlocks;  	long totalSize = stream.Length - stream.Position - tmpAPEv2TagSize - tmpID3v1TagSize;  	_totalSeconds = totalBlocks / (decimal)_frequency;  	_bitrate = totalSize / (_totalSeconds * 125.0m);  }  
Magic Number,IdSharp.AudioInfo,MonkeysAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\MonkeysAudio\MonkeysAudio.cs,MonkeysAudio,The following statement contains a magic number: using (FileStream stream = File.Open (path' FileMode.Open' FileAccess.Read' FileShare.Read)) {  	// Skip ID3v2 tag  	int tmpID3v2TagSize = ID3v2.GetTagSize (stream);  	int tmpID3v1TagSize = ID3v1.GetTagSize (stream);  	int tmpAPEv2TagSize = APEv2.GetTagSize (stream);  	stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  	byte[] identifier = stream.Read (4);  	if (ByteUtils.Compare (identifier' MAC_IDENTIFIER' 4) == false) {  		throw new InvalidDataException ("Invalid Monkey's Audio file");  	}  	byte[] buf = stream.Read (4);  	_version = buf [0] + (buf [1] << 8);  	int blocksPerFrame;  	int finalBlocks;  	if (_version >= 3980 && _version <= 3990) {  		buf = stream.Read (4);  		int descriptorLength = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  		stream.Seek (descriptorLength - 12' SeekOrigin.Current);  		// skip DESCRIPTOR  		buf = stream.Read (4);  		_compressionLevel = buf [0] + (buf [1] << 8);  		blocksPerFrame = stream.ReadInt32LittleEndian ();  		finalBlocks = stream.ReadInt32LittleEndian ();  		_frames = stream.ReadInt32LittleEndian ();  		buf = stream.Read (4);  		// skip bits per sample  		_channels = buf [2] + (buf [3] << 8);  		_frequency = stream.ReadInt32LittleEndian ();  	} else if (_version <= 3970) {  		// TODO: This section needs work  		_compressionLevel = buf [2] + (buf [3] << 8);  		buf = stream.Read (24);  		// skip format flags  		_channels = buf [2] + (buf [3] << 8);  		_frequency = buf [4] + (buf [5] << 8) + (buf [6] << 16) + (buf [7] << 32);  		if (_version >= 3950)  			blocksPerFrame = 73728 * 4;  		else if (_version >= 3900 || (_version >= 3800 && _compressionLevel == COMPRESSION_LEVEL_EXTRA_HIGH))  			blocksPerFrame = 73728;  		else  			blocksPerFrame = 9216;  		// TODO: This is definitely fucked up  		finalBlocks = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  		_frames = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  	} else {  		throw new NotImplementedException (string.Format ("MAC {0:0.00} not supported"' _version / 1000.0));  	}  	long totalBlocks = ((_frames - 1) * blocksPerFrame) + finalBlocks;  	long totalSize = stream.Length - stream.Position - tmpAPEv2TagSize - tmpID3v1TagSize;  	_totalSeconds = totalBlocks / (decimal)_frequency;  	_bitrate = totalSize / (_totalSeconds * 125.0m);  }  
Magic Number,IdSharp.AudioInfo,MonkeysAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\MonkeysAudio\MonkeysAudio.cs,MonkeysAudio,The following statement contains a magic number: using (FileStream stream = File.Open (path' FileMode.Open' FileAccess.Read' FileShare.Read)) {  	// Skip ID3v2 tag  	int tmpID3v2TagSize = ID3v2.GetTagSize (stream);  	int tmpID3v1TagSize = ID3v1.GetTagSize (stream);  	int tmpAPEv2TagSize = APEv2.GetTagSize (stream);  	stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  	byte[] identifier = stream.Read (4);  	if (ByteUtils.Compare (identifier' MAC_IDENTIFIER' 4) == false) {  		throw new InvalidDataException ("Invalid Monkey's Audio file");  	}  	byte[] buf = stream.Read (4);  	_version = buf [0] + (buf [1] << 8);  	int blocksPerFrame;  	int finalBlocks;  	if (_version >= 3980 && _version <= 3990) {  		buf = stream.Read (4);  		int descriptorLength = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  		stream.Seek (descriptorLength - 12' SeekOrigin.Current);  		// skip DESCRIPTOR  		buf = stream.Read (4);  		_compressionLevel = buf [0] + (buf [1] << 8);  		blocksPerFrame = stream.ReadInt32LittleEndian ();  		finalBlocks = stream.ReadInt32LittleEndian ();  		_frames = stream.ReadInt32LittleEndian ();  		buf = stream.Read (4);  		// skip bits per sample  		_channels = buf [2] + (buf [3] << 8);  		_frequency = stream.ReadInt32LittleEndian ();  	} else if (_version <= 3970) {  		// TODO: This section needs work  		_compressionLevel = buf [2] + (buf [3] << 8);  		buf = stream.Read (24);  		// skip format flags  		_channels = buf [2] + (buf [3] << 8);  		_frequency = buf [4] + (buf [5] << 8) + (buf [6] << 16) + (buf [7] << 32);  		if (_version >= 3950)  			blocksPerFrame = 73728 * 4;  		else if (_version >= 3900 || (_version >= 3800 && _compressionLevel == COMPRESSION_LEVEL_EXTRA_HIGH))  			blocksPerFrame = 73728;  		else  			blocksPerFrame = 9216;  		// TODO: This is definitely fucked up  		finalBlocks = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  		_frames = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  	} else {  		throw new NotImplementedException (string.Format ("MAC {0:0.00} not supported"' _version / 1000.0));  	}  	long totalBlocks = ((_frames - 1) * blocksPerFrame) + finalBlocks;  	long totalSize = stream.Length - stream.Position - tmpAPEv2TagSize - tmpID3v1TagSize;  	_totalSeconds = totalBlocks / (decimal)_frequency;  	_bitrate = totalSize / (_totalSeconds * 125.0m);  }  
Magic Number,IdSharp.AudioInfo,MonkeysAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\MonkeysAudio\MonkeysAudio.cs,MonkeysAudio,The following statement contains a magic number: using (FileStream stream = File.Open (path' FileMode.Open' FileAccess.Read' FileShare.Read)) {  	// Skip ID3v2 tag  	int tmpID3v2TagSize = ID3v2.GetTagSize (stream);  	int tmpID3v1TagSize = ID3v1.GetTagSize (stream);  	int tmpAPEv2TagSize = APEv2.GetTagSize (stream);  	stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  	byte[] identifier = stream.Read (4);  	if (ByteUtils.Compare (identifier' MAC_IDENTIFIER' 4) == false) {  		throw new InvalidDataException ("Invalid Monkey's Audio file");  	}  	byte[] buf = stream.Read (4);  	_version = buf [0] + (buf [1] << 8);  	int blocksPerFrame;  	int finalBlocks;  	if (_version >= 3980 && _version <= 3990) {  		buf = stream.Read (4);  		int descriptorLength = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  		stream.Seek (descriptorLength - 12' SeekOrigin.Current);  		// skip DESCRIPTOR  		buf = stream.Read (4);  		_compressionLevel = buf [0] + (buf [1] << 8);  		blocksPerFrame = stream.ReadInt32LittleEndian ();  		finalBlocks = stream.ReadInt32LittleEndian ();  		_frames = stream.ReadInt32LittleEndian ();  		buf = stream.Read (4);  		// skip bits per sample  		_channels = buf [2] + (buf [3] << 8);  		_frequency = stream.ReadInt32LittleEndian ();  	} else if (_version <= 3970) {  		// TODO: This section needs work  		_compressionLevel = buf [2] + (buf [3] << 8);  		buf = stream.Read (24);  		// skip format flags  		_channels = buf [2] + (buf [3] << 8);  		_frequency = buf [4] + (buf [5] << 8) + (buf [6] << 16) + (buf [7] << 32);  		if (_version >= 3950)  			blocksPerFrame = 73728 * 4;  		else if (_version >= 3900 || (_version >= 3800 && _compressionLevel == COMPRESSION_LEVEL_EXTRA_HIGH))  			blocksPerFrame = 73728;  		else  			blocksPerFrame = 9216;  		// TODO: This is definitely fucked up  		finalBlocks = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  		_frames = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  	} else {  		throw new NotImplementedException (string.Format ("MAC {0:0.00} not supported"' _version / 1000.0));  	}  	long totalBlocks = ((_frames - 1) * blocksPerFrame) + finalBlocks;  	long totalSize = stream.Length - stream.Position - tmpAPEv2TagSize - tmpID3v1TagSize;  	_totalSeconds = totalBlocks / (decimal)_frequency;  	_bitrate = totalSize / (_totalSeconds * 125.0m);  }  
Magic Number,IdSharp.AudioInfo,MonkeysAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\MonkeysAudio\MonkeysAudio.cs,MonkeysAudio,The following statement contains a magic number: using (FileStream stream = File.Open (path' FileMode.Open' FileAccess.Read' FileShare.Read)) {  	// Skip ID3v2 tag  	int tmpID3v2TagSize = ID3v2.GetTagSize (stream);  	int tmpID3v1TagSize = ID3v1.GetTagSize (stream);  	int tmpAPEv2TagSize = APEv2.GetTagSize (stream);  	stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  	byte[] identifier = stream.Read (4);  	if (ByteUtils.Compare (identifier' MAC_IDENTIFIER' 4) == false) {  		throw new InvalidDataException ("Invalid Monkey's Audio file");  	}  	byte[] buf = stream.Read (4);  	_version = buf [0] + (buf [1] << 8);  	int blocksPerFrame;  	int finalBlocks;  	if (_version >= 3980 && _version <= 3990) {  		buf = stream.Read (4);  		int descriptorLength = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  		stream.Seek (descriptorLength - 12' SeekOrigin.Current);  		// skip DESCRIPTOR  		buf = stream.Read (4);  		_compressionLevel = buf [0] + (buf [1] << 8);  		blocksPerFrame = stream.ReadInt32LittleEndian ();  		finalBlocks = stream.ReadInt32LittleEndian ();  		_frames = stream.ReadInt32LittleEndian ();  		buf = stream.Read (4);  		// skip bits per sample  		_channels = buf [2] + (buf [3] << 8);  		_frequency = stream.ReadInt32LittleEndian ();  	} else if (_version <= 3970) {  		// TODO: This section needs work  		_compressionLevel = buf [2] + (buf [3] << 8);  		buf = stream.Read (24);  		// skip format flags  		_channels = buf [2] + (buf [3] << 8);  		_frequency = buf [4] + (buf [5] << 8) + (buf [6] << 16) + (buf [7] << 32);  		if (_version >= 3950)  			blocksPerFrame = 73728 * 4;  		else if (_version >= 3900 || (_version >= 3800 && _compressionLevel == COMPRESSION_LEVEL_EXTRA_HIGH))  			blocksPerFrame = 73728;  		else  			blocksPerFrame = 9216;  		// TODO: This is definitely fucked up  		finalBlocks = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  		_frames = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  	} else {  		throw new NotImplementedException (string.Format ("MAC {0:0.00} not supported"' _version / 1000.0));  	}  	long totalBlocks = ((_frames - 1) * blocksPerFrame) + finalBlocks;  	long totalSize = stream.Length - stream.Position - tmpAPEv2TagSize - tmpID3v1TagSize;  	_totalSeconds = totalBlocks / (decimal)_frequency;  	_bitrate = totalSize / (_totalSeconds * 125.0m);  }  
Magic Number,IdSharp.AudioInfo,MonkeysAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\MonkeysAudio\MonkeysAudio.cs,MonkeysAudio,The following statement contains a magic number: using (FileStream stream = File.Open (path' FileMode.Open' FileAccess.Read' FileShare.Read)) {  	// Skip ID3v2 tag  	int tmpID3v2TagSize = ID3v2.GetTagSize (stream);  	int tmpID3v1TagSize = ID3v1.GetTagSize (stream);  	int tmpAPEv2TagSize = APEv2.GetTagSize (stream);  	stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  	byte[] identifier = stream.Read (4);  	if (ByteUtils.Compare (identifier' MAC_IDENTIFIER' 4) == false) {  		throw new InvalidDataException ("Invalid Monkey's Audio file");  	}  	byte[] buf = stream.Read (4);  	_version = buf [0] + (buf [1] << 8);  	int blocksPerFrame;  	int finalBlocks;  	if (_version >= 3980 && _version <= 3990) {  		buf = stream.Read (4);  		int descriptorLength = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  		stream.Seek (descriptorLength - 12' SeekOrigin.Current);  		// skip DESCRIPTOR  		buf = stream.Read (4);  		_compressionLevel = buf [0] + (buf [1] << 8);  		blocksPerFrame = stream.ReadInt32LittleEndian ();  		finalBlocks = stream.ReadInt32LittleEndian ();  		_frames = stream.ReadInt32LittleEndian ();  		buf = stream.Read (4);  		// skip bits per sample  		_channels = buf [2] + (buf [3] << 8);  		_frequency = stream.ReadInt32LittleEndian ();  	} else if (_version <= 3970) {  		// TODO: This section needs work  		_compressionLevel = buf [2] + (buf [3] << 8);  		buf = stream.Read (24);  		// skip format flags  		_channels = buf [2] + (buf [3] << 8);  		_frequency = buf [4] + (buf [5] << 8) + (buf [6] << 16) + (buf [7] << 32);  		if (_version >= 3950)  			blocksPerFrame = 73728 * 4;  		else if (_version >= 3900 || (_version >= 3800 && _compressionLevel == COMPRESSION_LEVEL_EXTRA_HIGH))  			blocksPerFrame = 73728;  		else  			blocksPerFrame = 9216;  		// TODO: This is definitely fucked up  		finalBlocks = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  		_frames = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  	} else {  		throw new NotImplementedException (string.Format ("MAC {0:0.00} not supported"' _version / 1000.0));  	}  	long totalBlocks = ((_frames - 1) * blocksPerFrame) + finalBlocks;  	long totalSize = stream.Length - stream.Position - tmpAPEv2TagSize - tmpID3v1TagSize;  	_totalSeconds = totalBlocks / (decimal)_frequency;  	_bitrate = totalSize / (_totalSeconds * 125.0m);  }  
Magic Number,IdSharp.AudioInfo,MonkeysAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\MonkeysAudio\MonkeysAudio.cs,MonkeysAudio,The following statement contains a magic number: using (FileStream stream = File.Open (path' FileMode.Open' FileAccess.Read' FileShare.Read)) {  	// Skip ID3v2 tag  	int tmpID3v2TagSize = ID3v2.GetTagSize (stream);  	int tmpID3v1TagSize = ID3v1.GetTagSize (stream);  	int tmpAPEv2TagSize = APEv2.GetTagSize (stream);  	stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  	byte[] identifier = stream.Read (4);  	if (ByteUtils.Compare (identifier' MAC_IDENTIFIER' 4) == false) {  		throw new InvalidDataException ("Invalid Monkey's Audio file");  	}  	byte[] buf = stream.Read (4);  	_version = buf [0] + (buf [1] << 8);  	int blocksPerFrame;  	int finalBlocks;  	if (_version >= 3980 && _version <= 3990) {  		buf = stream.Read (4);  		int descriptorLength = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  		stream.Seek (descriptorLength - 12' SeekOrigin.Current);  		// skip DESCRIPTOR  		buf = stream.Read (4);  		_compressionLevel = buf [0] + (buf [1] << 8);  		blocksPerFrame = stream.ReadInt32LittleEndian ();  		finalBlocks = stream.ReadInt32LittleEndian ();  		_frames = stream.ReadInt32LittleEndian ();  		buf = stream.Read (4);  		// skip bits per sample  		_channels = buf [2] + (buf [3] << 8);  		_frequency = stream.ReadInt32LittleEndian ();  	} else if (_version <= 3970) {  		// TODO: This section needs work  		_compressionLevel = buf [2] + (buf [3] << 8);  		buf = stream.Read (24);  		// skip format flags  		_channels = buf [2] + (buf [3] << 8);  		_frequency = buf [4] + (buf [5] << 8) + (buf [6] << 16) + (buf [7] << 32);  		if (_version >= 3950)  			blocksPerFrame = 73728 * 4;  		else if (_version >= 3900 || (_version >= 3800 && _compressionLevel == COMPRESSION_LEVEL_EXTRA_HIGH))  			blocksPerFrame = 73728;  		else  			blocksPerFrame = 9216;  		// TODO: This is definitely fucked up  		finalBlocks = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  		_frames = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  	} else {  		throw new NotImplementedException (string.Format ("MAC {0:0.00} not supported"' _version / 1000.0));  	}  	long totalBlocks = ((_frames - 1) * blocksPerFrame) + finalBlocks;  	long totalSize = stream.Length - stream.Position - tmpAPEv2TagSize - tmpID3v1TagSize;  	_totalSeconds = totalBlocks / (decimal)_frequency;  	_bitrate = totalSize / (_totalSeconds * 125.0m);  }  
Magic Number,IdSharp.AudioInfo,MonkeysAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\MonkeysAudio\MonkeysAudio.cs,MonkeysAudio,The following statement contains a magic number: using (FileStream stream = File.Open (path' FileMode.Open' FileAccess.Read' FileShare.Read)) {  	// Skip ID3v2 tag  	int tmpID3v2TagSize = ID3v2.GetTagSize (stream);  	int tmpID3v1TagSize = ID3v1.GetTagSize (stream);  	int tmpAPEv2TagSize = APEv2.GetTagSize (stream);  	stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  	byte[] identifier = stream.Read (4);  	if (ByteUtils.Compare (identifier' MAC_IDENTIFIER' 4) == false) {  		throw new InvalidDataException ("Invalid Monkey's Audio file");  	}  	byte[] buf = stream.Read (4);  	_version = buf [0] + (buf [1] << 8);  	int blocksPerFrame;  	int finalBlocks;  	if (_version >= 3980 && _version <= 3990) {  		buf = stream.Read (4);  		int descriptorLength = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  		stream.Seek (descriptorLength - 12' SeekOrigin.Current);  		// skip DESCRIPTOR  		buf = stream.Read (4);  		_compressionLevel = buf [0] + (buf [1] << 8);  		blocksPerFrame = stream.ReadInt32LittleEndian ();  		finalBlocks = stream.ReadInt32LittleEndian ();  		_frames = stream.ReadInt32LittleEndian ();  		buf = stream.Read (4);  		// skip bits per sample  		_channels = buf [2] + (buf [3] << 8);  		_frequency = stream.ReadInt32LittleEndian ();  	} else if (_version <= 3970) {  		// TODO: This section needs work  		_compressionLevel = buf [2] + (buf [3] << 8);  		buf = stream.Read (24);  		// skip format flags  		_channels = buf [2] + (buf [3] << 8);  		_frequency = buf [4] + (buf [5] << 8) + (buf [6] << 16) + (buf [7] << 32);  		if (_version >= 3950)  			blocksPerFrame = 73728 * 4;  		else if (_version >= 3900 || (_version >= 3800 && _compressionLevel == COMPRESSION_LEVEL_EXTRA_HIGH))  			blocksPerFrame = 73728;  		else  			blocksPerFrame = 9216;  		// TODO: This is definitely fucked up  		finalBlocks = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  		_frames = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  	} else {  		throw new NotImplementedException (string.Format ("MAC {0:0.00} not supported"' _version / 1000.0));  	}  	long totalBlocks = ((_frames - 1) * blocksPerFrame) + finalBlocks;  	long totalSize = stream.Length - stream.Position - tmpAPEv2TagSize - tmpID3v1TagSize;  	_totalSeconds = totalBlocks / (decimal)_frequency;  	_bitrate = totalSize / (_totalSeconds * 125.0m);  }  
Magic Number,IdSharp.AudioInfo,MonkeysAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\MonkeysAudio\MonkeysAudio.cs,MonkeysAudio,The following statement contains a magic number: using (FileStream stream = File.Open (path' FileMode.Open' FileAccess.Read' FileShare.Read)) {  	// Skip ID3v2 tag  	int tmpID3v2TagSize = ID3v2.GetTagSize (stream);  	int tmpID3v1TagSize = ID3v1.GetTagSize (stream);  	int tmpAPEv2TagSize = APEv2.GetTagSize (stream);  	stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  	byte[] identifier = stream.Read (4);  	if (ByteUtils.Compare (identifier' MAC_IDENTIFIER' 4) == false) {  		throw new InvalidDataException ("Invalid Monkey's Audio file");  	}  	byte[] buf = stream.Read (4);  	_version = buf [0] + (buf [1] << 8);  	int blocksPerFrame;  	int finalBlocks;  	if (_version >= 3980 && _version <= 3990) {  		buf = stream.Read (4);  		int descriptorLength = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  		stream.Seek (descriptorLength - 12' SeekOrigin.Current);  		// skip DESCRIPTOR  		buf = stream.Read (4);  		_compressionLevel = buf [0] + (buf [1] << 8);  		blocksPerFrame = stream.ReadInt32LittleEndian ();  		finalBlocks = stream.ReadInt32LittleEndian ();  		_frames = stream.ReadInt32LittleEndian ();  		buf = stream.Read (4);  		// skip bits per sample  		_channels = buf [2] + (buf [3] << 8);  		_frequency = stream.ReadInt32LittleEndian ();  	} else if (_version <= 3970) {  		// TODO: This section needs work  		_compressionLevel = buf [2] + (buf [3] << 8);  		buf = stream.Read (24);  		// skip format flags  		_channels = buf [2] + (buf [3] << 8);  		_frequency = buf [4] + (buf [5] << 8) + (buf [6] << 16) + (buf [7] << 32);  		if (_version >= 3950)  			blocksPerFrame = 73728 * 4;  		else if (_version >= 3900 || (_version >= 3800 && _compressionLevel == COMPRESSION_LEVEL_EXTRA_HIGH))  			blocksPerFrame = 73728;  		else  			blocksPerFrame = 9216;  		// TODO: This is definitely fucked up  		finalBlocks = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  		_frames = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  	} else {  		throw new NotImplementedException (string.Format ("MAC {0:0.00} not supported"' _version / 1000.0));  	}  	long totalBlocks = ((_frames - 1) * blocksPerFrame) + finalBlocks;  	long totalSize = stream.Length - stream.Position - tmpAPEv2TagSize - tmpID3v1TagSize;  	_totalSeconds = totalBlocks / (decimal)_frequency;  	_bitrate = totalSize / (_totalSeconds * 125.0m);  }  
Magic Number,IdSharp.AudioInfo,MonkeysAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\MonkeysAudio\MonkeysAudio.cs,MonkeysAudio,The following statement contains a magic number: using (FileStream stream = File.Open (path' FileMode.Open' FileAccess.Read' FileShare.Read)) {  	// Skip ID3v2 tag  	int tmpID3v2TagSize = ID3v2.GetTagSize (stream);  	int tmpID3v1TagSize = ID3v1.GetTagSize (stream);  	int tmpAPEv2TagSize = APEv2.GetTagSize (stream);  	stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  	byte[] identifier = stream.Read (4);  	if (ByteUtils.Compare (identifier' MAC_IDENTIFIER' 4) == false) {  		throw new InvalidDataException ("Invalid Monkey's Audio file");  	}  	byte[] buf = stream.Read (4);  	_version = buf [0] + (buf [1] << 8);  	int blocksPerFrame;  	int finalBlocks;  	if (_version >= 3980 && _version <= 3990) {  		buf = stream.Read (4);  		int descriptorLength = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  		stream.Seek (descriptorLength - 12' SeekOrigin.Current);  		// skip DESCRIPTOR  		buf = stream.Read (4);  		_compressionLevel = buf [0] + (buf [1] << 8);  		blocksPerFrame = stream.ReadInt32LittleEndian ();  		finalBlocks = stream.ReadInt32LittleEndian ();  		_frames = stream.ReadInt32LittleEndian ();  		buf = stream.Read (4);  		// skip bits per sample  		_channels = buf [2] + (buf [3] << 8);  		_frequency = stream.ReadInt32LittleEndian ();  	} else if (_version <= 3970) {  		// TODO: This section needs work  		_compressionLevel = buf [2] + (buf [3] << 8);  		buf = stream.Read (24);  		// skip format flags  		_channels = buf [2] + (buf [3] << 8);  		_frequency = buf [4] + (buf [5] << 8) + (buf [6] << 16) + (buf [7] << 32);  		if (_version >= 3950)  			blocksPerFrame = 73728 * 4;  		else if (_version >= 3900 || (_version >= 3800 && _compressionLevel == COMPRESSION_LEVEL_EXTRA_HIGH))  			blocksPerFrame = 73728;  		else  			blocksPerFrame = 9216;  		// TODO: This is definitely fucked up  		finalBlocks = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  		_frames = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  	} else {  		throw new NotImplementedException (string.Format ("MAC {0:0.00} not supported"' _version / 1000.0));  	}  	long totalBlocks = ((_frames - 1) * blocksPerFrame) + finalBlocks;  	long totalSize = stream.Length - stream.Position - tmpAPEv2TagSize - tmpID3v1TagSize;  	_totalSeconds = totalBlocks / (decimal)_frequency;  	_bitrate = totalSize / (_totalSeconds * 125.0m);  }  
Magic Number,IdSharp.AudioInfo,MonkeysAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\MonkeysAudio\MonkeysAudio.cs,MonkeysAudio,The following statement contains a magic number: using (FileStream stream = File.Open (path' FileMode.Open' FileAccess.Read' FileShare.Read)) {  	// Skip ID3v2 tag  	int tmpID3v2TagSize = ID3v2.GetTagSize (stream);  	int tmpID3v1TagSize = ID3v1.GetTagSize (stream);  	int tmpAPEv2TagSize = APEv2.GetTagSize (stream);  	stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  	byte[] identifier = stream.Read (4);  	if (ByteUtils.Compare (identifier' MAC_IDENTIFIER' 4) == false) {  		throw new InvalidDataException ("Invalid Monkey's Audio file");  	}  	byte[] buf = stream.Read (4);  	_version = buf [0] + (buf [1] << 8);  	int blocksPerFrame;  	int finalBlocks;  	if (_version >= 3980 && _version <= 3990) {  		buf = stream.Read (4);  		int descriptorLength = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  		stream.Seek (descriptorLength - 12' SeekOrigin.Current);  		// skip DESCRIPTOR  		buf = stream.Read (4);  		_compressionLevel = buf [0] + (buf [1] << 8);  		blocksPerFrame = stream.ReadInt32LittleEndian ();  		finalBlocks = stream.ReadInt32LittleEndian ();  		_frames = stream.ReadInt32LittleEndian ();  		buf = stream.Read (4);  		// skip bits per sample  		_channels = buf [2] + (buf [3] << 8);  		_frequency = stream.ReadInt32LittleEndian ();  	} else if (_version <= 3970) {  		// TODO: This section needs work  		_compressionLevel = buf [2] + (buf [3] << 8);  		buf = stream.Read (24);  		// skip format flags  		_channels = buf [2] + (buf [3] << 8);  		_frequency = buf [4] + (buf [5] << 8) + (buf [6] << 16) + (buf [7] << 32);  		if (_version >= 3950)  			blocksPerFrame = 73728 * 4;  		else if (_version >= 3900 || (_version >= 3800 && _compressionLevel == COMPRESSION_LEVEL_EXTRA_HIGH))  			blocksPerFrame = 73728;  		else  			blocksPerFrame = 9216;  		// TODO: This is definitely fucked up  		finalBlocks = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  		_frames = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  	} else {  		throw new NotImplementedException (string.Format ("MAC {0:0.00} not supported"' _version / 1000.0));  	}  	long totalBlocks = ((_frames - 1) * blocksPerFrame) + finalBlocks;  	long totalSize = stream.Length - stream.Position - tmpAPEv2TagSize - tmpID3v1TagSize;  	_totalSeconds = totalBlocks / (decimal)_frequency;  	_bitrate = totalSize / (_totalSeconds * 125.0m);  }  
Magic Number,IdSharp.AudioInfo,MonkeysAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\MonkeysAudio\MonkeysAudio.cs,MonkeysAudio,The following statement contains a magic number: using (FileStream stream = File.Open (path' FileMode.Open' FileAccess.Read' FileShare.Read)) {  	// Skip ID3v2 tag  	int tmpID3v2TagSize = ID3v2.GetTagSize (stream);  	int tmpID3v1TagSize = ID3v1.GetTagSize (stream);  	int tmpAPEv2TagSize = APEv2.GetTagSize (stream);  	stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  	byte[] identifier = stream.Read (4);  	if (ByteUtils.Compare (identifier' MAC_IDENTIFIER' 4) == false) {  		throw new InvalidDataException ("Invalid Monkey's Audio file");  	}  	byte[] buf = stream.Read (4);  	_version = buf [0] + (buf [1] << 8);  	int blocksPerFrame;  	int finalBlocks;  	if (_version >= 3980 && _version <= 3990) {  		buf = stream.Read (4);  		int descriptorLength = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  		stream.Seek (descriptorLength - 12' SeekOrigin.Current);  		// skip DESCRIPTOR  		buf = stream.Read (4);  		_compressionLevel = buf [0] + (buf [1] << 8);  		blocksPerFrame = stream.ReadInt32LittleEndian ();  		finalBlocks = stream.ReadInt32LittleEndian ();  		_frames = stream.ReadInt32LittleEndian ();  		buf = stream.Read (4);  		// skip bits per sample  		_channels = buf [2] + (buf [3] << 8);  		_frequency = stream.ReadInt32LittleEndian ();  	} else if (_version <= 3970) {  		// TODO: This section needs work  		_compressionLevel = buf [2] + (buf [3] << 8);  		buf = stream.Read (24);  		// skip format flags  		_channels = buf [2] + (buf [3] << 8);  		_frequency = buf [4] + (buf [5] << 8) + (buf [6] << 16) + (buf [7] << 32);  		if (_version >= 3950)  			blocksPerFrame = 73728 * 4;  		else if (_version >= 3900 || (_version >= 3800 && _compressionLevel == COMPRESSION_LEVEL_EXTRA_HIGH))  			blocksPerFrame = 73728;  		else  			blocksPerFrame = 9216;  		// TODO: This is definitely fucked up  		finalBlocks = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  		_frames = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  	} else {  		throw new NotImplementedException (string.Format ("MAC {0:0.00} not supported"' _version / 1000.0));  	}  	long totalBlocks = ((_frames - 1) * blocksPerFrame) + finalBlocks;  	long totalSize = stream.Length - stream.Position - tmpAPEv2TagSize - tmpID3v1TagSize;  	_totalSeconds = totalBlocks / (decimal)_frequency;  	_bitrate = totalSize / (_totalSeconds * 125.0m);  }  
Magic Number,IdSharp.AudioInfo,MonkeysAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\MonkeysAudio\MonkeysAudio.cs,MonkeysAudio,The following statement contains a magic number: using (FileStream stream = File.Open (path' FileMode.Open' FileAccess.Read' FileShare.Read)) {  	// Skip ID3v2 tag  	int tmpID3v2TagSize = ID3v2.GetTagSize (stream);  	int tmpID3v1TagSize = ID3v1.GetTagSize (stream);  	int tmpAPEv2TagSize = APEv2.GetTagSize (stream);  	stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  	byte[] identifier = stream.Read (4);  	if (ByteUtils.Compare (identifier' MAC_IDENTIFIER' 4) == false) {  		throw new InvalidDataException ("Invalid Monkey's Audio file");  	}  	byte[] buf = stream.Read (4);  	_version = buf [0] + (buf [1] << 8);  	int blocksPerFrame;  	int finalBlocks;  	if (_version >= 3980 && _version <= 3990) {  		buf = stream.Read (4);  		int descriptorLength = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  		stream.Seek (descriptorLength - 12' SeekOrigin.Current);  		// skip DESCRIPTOR  		buf = stream.Read (4);  		_compressionLevel = buf [0] + (buf [1] << 8);  		blocksPerFrame = stream.ReadInt32LittleEndian ();  		finalBlocks = stream.ReadInt32LittleEndian ();  		_frames = stream.ReadInt32LittleEndian ();  		buf = stream.Read (4);  		// skip bits per sample  		_channels = buf [2] + (buf [3] << 8);  		_frequency = stream.ReadInt32LittleEndian ();  	} else if (_version <= 3970) {  		// TODO: This section needs work  		_compressionLevel = buf [2] + (buf [3] << 8);  		buf = stream.Read (24);  		// skip format flags  		_channels = buf [2] + (buf [3] << 8);  		_frequency = buf [4] + (buf [5] << 8) + (buf [6] << 16) + (buf [7] << 32);  		if (_version >= 3950)  			blocksPerFrame = 73728 * 4;  		else if (_version >= 3900 || (_version >= 3800 && _compressionLevel == COMPRESSION_LEVEL_EXTRA_HIGH))  			blocksPerFrame = 73728;  		else  			blocksPerFrame = 9216;  		// TODO: This is definitely fucked up  		finalBlocks = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  		_frames = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  	} else {  		throw new NotImplementedException (string.Format ("MAC {0:0.00} not supported"' _version / 1000.0));  	}  	long totalBlocks = ((_frames - 1) * blocksPerFrame) + finalBlocks;  	long totalSize = stream.Length - stream.Position - tmpAPEv2TagSize - tmpID3v1TagSize;  	_totalSeconds = totalBlocks / (decimal)_frequency;  	_bitrate = totalSize / (_totalSeconds * 125.0m);  }  
Magic Number,IdSharp.AudioInfo,MonkeysAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\MonkeysAudio\MonkeysAudio.cs,MonkeysAudio,The following statement contains a magic number: using (FileStream stream = File.Open (path' FileMode.Open' FileAccess.Read' FileShare.Read)) {  	// Skip ID3v2 tag  	int tmpID3v2TagSize = ID3v2.GetTagSize (stream);  	int tmpID3v1TagSize = ID3v1.GetTagSize (stream);  	int tmpAPEv2TagSize = APEv2.GetTagSize (stream);  	stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  	byte[] identifier = stream.Read (4);  	if (ByteUtils.Compare (identifier' MAC_IDENTIFIER' 4) == false) {  		throw new InvalidDataException ("Invalid Monkey's Audio file");  	}  	byte[] buf = stream.Read (4);  	_version = buf [0] + (buf [1] << 8);  	int blocksPerFrame;  	int finalBlocks;  	if (_version >= 3980 && _version <= 3990) {  		buf = stream.Read (4);  		int descriptorLength = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  		stream.Seek (descriptorLength - 12' SeekOrigin.Current);  		// skip DESCRIPTOR  		buf = stream.Read (4);  		_compressionLevel = buf [0] + (buf [1] << 8);  		blocksPerFrame = stream.ReadInt32LittleEndian ();  		finalBlocks = stream.ReadInt32LittleEndian ();  		_frames = stream.ReadInt32LittleEndian ();  		buf = stream.Read (4);  		// skip bits per sample  		_channels = buf [2] + (buf [3] << 8);  		_frequency = stream.ReadInt32LittleEndian ();  	} else if (_version <= 3970) {  		// TODO: This section needs work  		_compressionLevel = buf [2] + (buf [3] << 8);  		buf = stream.Read (24);  		// skip format flags  		_channels = buf [2] + (buf [3] << 8);  		_frequency = buf [4] + (buf [5] << 8) + (buf [6] << 16) + (buf [7] << 32);  		if (_version >= 3950)  			blocksPerFrame = 73728 * 4;  		else if (_version >= 3900 || (_version >= 3800 && _compressionLevel == COMPRESSION_LEVEL_EXTRA_HIGH))  			blocksPerFrame = 73728;  		else  			blocksPerFrame = 9216;  		// TODO: This is definitely fucked up  		finalBlocks = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  		_frames = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  	} else {  		throw new NotImplementedException (string.Format ("MAC {0:0.00} not supported"' _version / 1000.0));  	}  	long totalBlocks = ((_frames - 1) * blocksPerFrame) + finalBlocks;  	long totalSize = stream.Length - stream.Position - tmpAPEv2TagSize - tmpID3v1TagSize;  	_totalSeconds = totalBlocks / (decimal)_frequency;  	_bitrate = totalSize / (_totalSeconds * 125.0m);  }  
Magic Number,IdSharp.AudioInfo,MonkeysAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\MonkeysAudio\MonkeysAudio.cs,MonkeysAudio,The following statement contains a magic number: using (FileStream stream = File.Open (path' FileMode.Open' FileAccess.Read' FileShare.Read)) {  	// Skip ID3v2 tag  	int tmpID3v2TagSize = ID3v2.GetTagSize (stream);  	int tmpID3v1TagSize = ID3v1.GetTagSize (stream);  	int tmpAPEv2TagSize = APEv2.GetTagSize (stream);  	stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  	byte[] identifier = stream.Read (4);  	if (ByteUtils.Compare (identifier' MAC_IDENTIFIER' 4) == false) {  		throw new InvalidDataException ("Invalid Monkey's Audio file");  	}  	byte[] buf = stream.Read (4);  	_version = buf [0] + (buf [1] << 8);  	int blocksPerFrame;  	int finalBlocks;  	if (_version >= 3980 && _version <= 3990) {  		buf = stream.Read (4);  		int descriptorLength = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  		stream.Seek (descriptorLength - 12' SeekOrigin.Current);  		// skip DESCRIPTOR  		buf = stream.Read (4);  		_compressionLevel = buf [0] + (buf [1] << 8);  		blocksPerFrame = stream.ReadInt32LittleEndian ();  		finalBlocks = stream.ReadInt32LittleEndian ();  		_frames = stream.ReadInt32LittleEndian ();  		buf = stream.Read (4);  		// skip bits per sample  		_channels = buf [2] + (buf [3] << 8);  		_frequency = stream.ReadInt32LittleEndian ();  	} else if (_version <= 3970) {  		// TODO: This section needs work  		_compressionLevel = buf [2] + (buf [3] << 8);  		buf = stream.Read (24);  		// skip format flags  		_channels = buf [2] + (buf [3] << 8);  		_frequency = buf [4] + (buf [5] << 8) + (buf [6] << 16) + (buf [7] << 32);  		if (_version >= 3950)  			blocksPerFrame = 73728 * 4;  		else if (_version >= 3900 || (_version >= 3800 && _compressionLevel == COMPRESSION_LEVEL_EXTRA_HIGH))  			blocksPerFrame = 73728;  		else  			blocksPerFrame = 9216;  		// TODO: This is definitely fucked up  		finalBlocks = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  		_frames = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  	} else {  		throw new NotImplementedException (string.Format ("MAC {0:0.00} not supported"' _version / 1000.0));  	}  	long totalBlocks = ((_frames - 1) * blocksPerFrame) + finalBlocks;  	long totalSize = stream.Length - stream.Position - tmpAPEv2TagSize - tmpID3v1TagSize;  	_totalSeconds = totalBlocks / (decimal)_frequency;  	_bitrate = totalSize / (_totalSeconds * 125.0m);  }  
Magic Number,IdSharp.AudioInfo,MonkeysAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\MonkeysAudio\MonkeysAudio.cs,MonkeysAudio,The following statement contains a magic number: using (FileStream stream = File.Open (path' FileMode.Open' FileAccess.Read' FileShare.Read)) {  	// Skip ID3v2 tag  	int tmpID3v2TagSize = ID3v2.GetTagSize (stream);  	int tmpID3v1TagSize = ID3v1.GetTagSize (stream);  	int tmpAPEv2TagSize = APEv2.GetTagSize (stream);  	stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  	byte[] identifier = stream.Read (4);  	if (ByteUtils.Compare (identifier' MAC_IDENTIFIER' 4) == false) {  		throw new InvalidDataException ("Invalid Monkey's Audio file");  	}  	byte[] buf = stream.Read (4);  	_version = buf [0] + (buf [1] << 8);  	int blocksPerFrame;  	int finalBlocks;  	if (_version >= 3980 && _version <= 3990) {  		buf = stream.Read (4);  		int descriptorLength = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  		stream.Seek (descriptorLength - 12' SeekOrigin.Current);  		// skip DESCRIPTOR  		buf = stream.Read (4);  		_compressionLevel = buf [0] + (buf [1] << 8);  		blocksPerFrame = stream.ReadInt32LittleEndian ();  		finalBlocks = stream.ReadInt32LittleEndian ();  		_frames = stream.ReadInt32LittleEndian ();  		buf = stream.Read (4);  		// skip bits per sample  		_channels = buf [2] + (buf [3] << 8);  		_frequency = stream.ReadInt32LittleEndian ();  	} else if (_version <= 3970) {  		// TODO: This section needs work  		_compressionLevel = buf [2] + (buf [3] << 8);  		buf = stream.Read (24);  		// skip format flags  		_channels = buf [2] + (buf [3] << 8);  		_frequency = buf [4] + (buf [5] << 8) + (buf [6] << 16) + (buf [7] << 32);  		if (_version >= 3950)  			blocksPerFrame = 73728 * 4;  		else if (_version >= 3900 || (_version >= 3800 && _compressionLevel == COMPRESSION_LEVEL_EXTRA_HIGH))  			blocksPerFrame = 73728;  		else  			blocksPerFrame = 9216;  		// TODO: This is definitely fucked up  		finalBlocks = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  		_frames = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  	} else {  		throw new NotImplementedException (string.Format ("MAC {0:0.00} not supported"' _version / 1000.0));  	}  	long totalBlocks = ((_frames - 1) * blocksPerFrame) + finalBlocks;  	long totalSize = stream.Length - stream.Position - tmpAPEv2TagSize - tmpID3v1TagSize;  	_totalSeconds = totalBlocks / (decimal)_frequency;  	_bitrate = totalSize / (_totalSeconds * 125.0m);  }  
Magic Number,IdSharp.AudioInfo,MonkeysAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\MonkeysAudio\MonkeysAudio.cs,MonkeysAudio,The following statement contains a magic number: using (FileStream stream = File.Open (path' FileMode.Open' FileAccess.Read' FileShare.Read)) {  	// Skip ID3v2 tag  	int tmpID3v2TagSize = ID3v2.GetTagSize (stream);  	int tmpID3v1TagSize = ID3v1.GetTagSize (stream);  	int tmpAPEv2TagSize = APEv2.GetTagSize (stream);  	stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  	byte[] identifier = stream.Read (4);  	if (ByteUtils.Compare (identifier' MAC_IDENTIFIER' 4) == false) {  		throw new InvalidDataException ("Invalid Monkey's Audio file");  	}  	byte[] buf = stream.Read (4);  	_version = buf [0] + (buf [1] << 8);  	int blocksPerFrame;  	int finalBlocks;  	if (_version >= 3980 && _version <= 3990) {  		buf = stream.Read (4);  		int descriptorLength = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  		stream.Seek (descriptorLength - 12' SeekOrigin.Current);  		// skip DESCRIPTOR  		buf = stream.Read (4);  		_compressionLevel = buf [0] + (buf [1] << 8);  		blocksPerFrame = stream.ReadInt32LittleEndian ();  		finalBlocks = stream.ReadInt32LittleEndian ();  		_frames = stream.ReadInt32LittleEndian ();  		buf = stream.Read (4);  		// skip bits per sample  		_channels = buf [2] + (buf [3] << 8);  		_frequency = stream.ReadInt32LittleEndian ();  	} else if (_version <= 3970) {  		// TODO: This section needs work  		_compressionLevel = buf [2] + (buf [3] << 8);  		buf = stream.Read (24);  		// skip format flags  		_channels = buf [2] + (buf [3] << 8);  		_frequency = buf [4] + (buf [5] << 8) + (buf [6] << 16) + (buf [7] << 32);  		if (_version >= 3950)  			blocksPerFrame = 73728 * 4;  		else if (_version >= 3900 || (_version >= 3800 && _compressionLevel == COMPRESSION_LEVEL_EXTRA_HIGH))  			blocksPerFrame = 73728;  		else  			blocksPerFrame = 9216;  		// TODO: This is definitely fucked up  		finalBlocks = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  		_frames = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  	} else {  		throw new NotImplementedException (string.Format ("MAC {0:0.00} not supported"' _version / 1000.0));  	}  	long totalBlocks = ((_frames - 1) * blocksPerFrame) + finalBlocks;  	long totalSize = stream.Length - stream.Position - tmpAPEv2TagSize - tmpID3v1TagSize;  	_totalSeconds = totalBlocks / (decimal)_frequency;  	_bitrate = totalSize / (_totalSeconds * 125.0m);  }  
Magic Number,IdSharp.AudioInfo,MonkeysAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\MonkeysAudio\MonkeysAudio.cs,MonkeysAudio,The following statement contains a magic number: using (FileStream stream = File.Open (path' FileMode.Open' FileAccess.Read' FileShare.Read)) {  	// Skip ID3v2 tag  	int tmpID3v2TagSize = ID3v2.GetTagSize (stream);  	int tmpID3v1TagSize = ID3v1.GetTagSize (stream);  	int tmpAPEv2TagSize = APEv2.GetTagSize (stream);  	stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  	byte[] identifier = stream.Read (4);  	if (ByteUtils.Compare (identifier' MAC_IDENTIFIER' 4) == false) {  		throw new InvalidDataException ("Invalid Monkey's Audio file");  	}  	byte[] buf = stream.Read (4);  	_version = buf [0] + (buf [1] << 8);  	int blocksPerFrame;  	int finalBlocks;  	if (_version >= 3980 && _version <= 3990) {  		buf = stream.Read (4);  		int descriptorLength = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  		stream.Seek (descriptorLength - 12' SeekOrigin.Current);  		// skip DESCRIPTOR  		buf = stream.Read (4);  		_compressionLevel = buf [0] + (buf [1] << 8);  		blocksPerFrame = stream.ReadInt32LittleEndian ();  		finalBlocks = stream.ReadInt32LittleEndian ();  		_frames = stream.ReadInt32LittleEndian ();  		buf = stream.Read (4);  		// skip bits per sample  		_channels = buf [2] + (buf [3] << 8);  		_frequency = stream.ReadInt32LittleEndian ();  	} else if (_version <= 3970) {  		// TODO: This section needs work  		_compressionLevel = buf [2] + (buf [3] << 8);  		buf = stream.Read (24);  		// skip format flags  		_channels = buf [2] + (buf [3] << 8);  		_frequency = buf [4] + (buf [5] << 8) + (buf [6] << 16) + (buf [7] << 32);  		if (_version >= 3950)  			blocksPerFrame = 73728 * 4;  		else if (_version >= 3900 || (_version >= 3800 && _compressionLevel == COMPRESSION_LEVEL_EXTRA_HIGH))  			blocksPerFrame = 73728;  		else  			blocksPerFrame = 9216;  		// TODO: This is definitely fucked up  		finalBlocks = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  		_frames = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  	} else {  		throw new NotImplementedException (string.Format ("MAC {0:0.00} not supported"' _version / 1000.0));  	}  	long totalBlocks = ((_frames - 1) * blocksPerFrame) + finalBlocks;  	long totalSize = stream.Length - stream.Position - tmpAPEv2TagSize - tmpID3v1TagSize;  	_totalSeconds = totalBlocks / (decimal)_frequency;  	_bitrate = totalSize / (_totalSeconds * 125.0m);  }  
Magic Number,IdSharp.AudioInfo,MonkeysAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\MonkeysAudio\MonkeysAudio.cs,MonkeysAudio,The following statement contains a magic number: using (FileStream stream = File.Open (path' FileMode.Open' FileAccess.Read' FileShare.Read)) {  	// Skip ID3v2 tag  	int tmpID3v2TagSize = ID3v2.GetTagSize (stream);  	int tmpID3v1TagSize = ID3v1.GetTagSize (stream);  	int tmpAPEv2TagSize = APEv2.GetTagSize (stream);  	stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  	byte[] identifier = stream.Read (4);  	if (ByteUtils.Compare (identifier' MAC_IDENTIFIER' 4) == false) {  		throw new InvalidDataException ("Invalid Monkey's Audio file");  	}  	byte[] buf = stream.Read (4);  	_version = buf [0] + (buf [1] << 8);  	int blocksPerFrame;  	int finalBlocks;  	if (_version >= 3980 && _version <= 3990) {  		buf = stream.Read (4);  		int descriptorLength = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  		stream.Seek (descriptorLength - 12' SeekOrigin.Current);  		// skip DESCRIPTOR  		buf = stream.Read (4);  		_compressionLevel = buf [0] + (buf [1] << 8);  		blocksPerFrame = stream.ReadInt32LittleEndian ();  		finalBlocks = stream.ReadInt32LittleEndian ();  		_frames = stream.ReadInt32LittleEndian ();  		buf = stream.Read (4);  		// skip bits per sample  		_channels = buf [2] + (buf [3] << 8);  		_frequency = stream.ReadInt32LittleEndian ();  	} else if (_version <= 3970) {  		// TODO: This section needs work  		_compressionLevel = buf [2] + (buf [3] << 8);  		buf = stream.Read (24);  		// skip format flags  		_channels = buf [2] + (buf [3] << 8);  		_frequency = buf [4] + (buf [5] << 8) + (buf [6] << 16) + (buf [7] << 32);  		if (_version >= 3950)  			blocksPerFrame = 73728 * 4;  		else if (_version >= 3900 || (_version >= 3800 && _compressionLevel == COMPRESSION_LEVEL_EXTRA_HIGH))  			blocksPerFrame = 73728;  		else  			blocksPerFrame = 9216;  		// TODO: This is definitely fucked up  		finalBlocks = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  		_frames = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  	} else {  		throw new NotImplementedException (string.Format ("MAC {0:0.00} not supported"' _version / 1000.0));  	}  	long totalBlocks = ((_frames - 1) * blocksPerFrame) + finalBlocks;  	long totalSize = stream.Length - stream.Position - tmpAPEv2TagSize - tmpID3v1TagSize;  	_totalSeconds = totalBlocks / (decimal)_frequency;  	_bitrate = totalSize / (_totalSeconds * 125.0m);  }  
Magic Number,IdSharp.AudioInfo,MonkeysAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\MonkeysAudio\MonkeysAudio.cs,MonkeysAudio,The following statement contains a magic number: using (FileStream stream = File.Open (path' FileMode.Open' FileAccess.Read' FileShare.Read)) {  	// Skip ID3v2 tag  	int tmpID3v2TagSize = ID3v2.GetTagSize (stream);  	int tmpID3v1TagSize = ID3v1.GetTagSize (stream);  	int tmpAPEv2TagSize = APEv2.GetTagSize (stream);  	stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  	byte[] identifier = stream.Read (4);  	if (ByteUtils.Compare (identifier' MAC_IDENTIFIER' 4) == false) {  		throw new InvalidDataException ("Invalid Monkey's Audio file");  	}  	byte[] buf = stream.Read (4);  	_version = buf [0] + (buf [1] << 8);  	int blocksPerFrame;  	int finalBlocks;  	if (_version >= 3980 && _version <= 3990) {  		buf = stream.Read (4);  		int descriptorLength = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  		stream.Seek (descriptorLength - 12' SeekOrigin.Current);  		// skip DESCRIPTOR  		buf = stream.Read (4);  		_compressionLevel = buf [0] + (buf [1] << 8);  		blocksPerFrame = stream.ReadInt32LittleEndian ();  		finalBlocks = stream.ReadInt32LittleEndian ();  		_frames = stream.ReadInt32LittleEndian ();  		buf = stream.Read (4);  		// skip bits per sample  		_channels = buf [2] + (buf [3] << 8);  		_frequency = stream.ReadInt32LittleEndian ();  	} else if (_version <= 3970) {  		// TODO: This section needs work  		_compressionLevel = buf [2] + (buf [3] << 8);  		buf = stream.Read (24);  		// skip format flags  		_channels = buf [2] + (buf [3] << 8);  		_frequency = buf [4] + (buf [5] << 8) + (buf [6] << 16) + (buf [7] << 32);  		if (_version >= 3950)  			blocksPerFrame = 73728 * 4;  		else if (_version >= 3900 || (_version >= 3800 && _compressionLevel == COMPRESSION_LEVEL_EXTRA_HIGH))  			blocksPerFrame = 73728;  		else  			blocksPerFrame = 9216;  		// TODO: This is definitely fucked up  		finalBlocks = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  		_frames = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  	} else {  		throw new NotImplementedException (string.Format ("MAC {0:0.00} not supported"' _version / 1000.0));  	}  	long totalBlocks = ((_frames - 1) * blocksPerFrame) + finalBlocks;  	long totalSize = stream.Length - stream.Position - tmpAPEv2TagSize - tmpID3v1TagSize;  	_totalSeconds = totalBlocks / (decimal)_frequency;  	_bitrate = totalSize / (_totalSeconds * 125.0m);  }  
Magic Number,IdSharp.AudioInfo,MonkeysAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\MonkeysAudio\MonkeysAudio.cs,MonkeysAudio,The following statement contains a magic number: using (FileStream stream = File.Open (path' FileMode.Open' FileAccess.Read' FileShare.Read)) {  	// Skip ID3v2 tag  	int tmpID3v2TagSize = ID3v2.GetTagSize (stream);  	int tmpID3v1TagSize = ID3v1.GetTagSize (stream);  	int tmpAPEv2TagSize = APEv2.GetTagSize (stream);  	stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  	byte[] identifier = stream.Read (4);  	if (ByteUtils.Compare (identifier' MAC_IDENTIFIER' 4) == false) {  		throw new InvalidDataException ("Invalid Monkey's Audio file");  	}  	byte[] buf = stream.Read (4);  	_version = buf [0] + (buf [1] << 8);  	int blocksPerFrame;  	int finalBlocks;  	if (_version >= 3980 && _version <= 3990) {  		buf = stream.Read (4);  		int descriptorLength = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  		stream.Seek (descriptorLength - 12' SeekOrigin.Current);  		// skip DESCRIPTOR  		buf = stream.Read (4);  		_compressionLevel = buf [0] + (buf [1] << 8);  		blocksPerFrame = stream.ReadInt32LittleEndian ();  		finalBlocks = stream.ReadInt32LittleEndian ();  		_frames = stream.ReadInt32LittleEndian ();  		buf = stream.Read (4);  		// skip bits per sample  		_channels = buf [2] + (buf [3] << 8);  		_frequency = stream.ReadInt32LittleEndian ();  	} else if (_version <= 3970) {  		// TODO: This section needs work  		_compressionLevel = buf [2] + (buf [3] << 8);  		buf = stream.Read (24);  		// skip format flags  		_channels = buf [2] + (buf [3] << 8);  		_frequency = buf [4] + (buf [5] << 8) + (buf [6] << 16) + (buf [7] << 32);  		if (_version >= 3950)  			blocksPerFrame = 73728 * 4;  		else if (_version >= 3900 || (_version >= 3800 && _compressionLevel == COMPRESSION_LEVEL_EXTRA_HIGH))  			blocksPerFrame = 73728;  		else  			blocksPerFrame = 9216;  		// TODO: This is definitely fucked up  		finalBlocks = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  		_frames = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  	} else {  		throw new NotImplementedException (string.Format ("MAC {0:0.00} not supported"' _version / 1000.0));  	}  	long totalBlocks = ((_frames - 1) * blocksPerFrame) + finalBlocks;  	long totalSize = stream.Length - stream.Position - tmpAPEv2TagSize - tmpID3v1TagSize;  	_totalSeconds = totalBlocks / (decimal)_frequency;  	_bitrate = totalSize / (_totalSeconds * 125.0m);  }  
Magic Number,IdSharp.AudioInfo,MonkeysAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\MonkeysAudio\MonkeysAudio.cs,MonkeysAudio,The following statement contains a magic number: using (FileStream stream = File.Open (path' FileMode.Open' FileAccess.Read' FileShare.Read)) {  	// Skip ID3v2 tag  	int tmpID3v2TagSize = ID3v2.GetTagSize (stream);  	int tmpID3v1TagSize = ID3v1.GetTagSize (stream);  	int tmpAPEv2TagSize = APEv2.GetTagSize (stream);  	stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  	byte[] identifier = stream.Read (4);  	if (ByteUtils.Compare (identifier' MAC_IDENTIFIER' 4) == false) {  		throw new InvalidDataException ("Invalid Monkey's Audio file");  	}  	byte[] buf = stream.Read (4);  	_version = buf [0] + (buf [1] << 8);  	int blocksPerFrame;  	int finalBlocks;  	if (_version >= 3980 && _version <= 3990) {  		buf = stream.Read (4);  		int descriptorLength = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  		stream.Seek (descriptorLength - 12' SeekOrigin.Current);  		// skip DESCRIPTOR  		buf = stream.Read (4);  		_compressionLevel = buf [0] + (buf [1] << 8);  		blocksPerFrame = stream.ReadInt32LittleEndian ();  		finalBlocks = stream.ReadInt32LittleEndian ();  		_frames = stream.ReadInt32LittleEndian ();  		buf = stream.Read (4);  		// skip bits per sample  		_channels = buf [2] + (buf [3] << 8);  		_frequency = stream.ReadInt32LittleEndian ();  	} else if (_version <= 3970) {  		// TODO: This section needs work  		_compressionLevel = buf [2] + (buf [3] << 8);  		buf = stream.Read (24);  		// skip format flags  		_channels = buf [2] + (buf [3] << 8);  		_frequency = buf [4] + (buf [5] << 8) + (buf [6] << 16) + (buf [7] << 32);  		if (_version >= 3950)  			blocksPerFrame = 73728 * 4;  		else if (_version >= 3900 || (_version >= 3800 && _compressionLevel == COMPRESSION_LEVEL_EXTRA_HIGH))  			blocksPerFrame = 73728;  		else  			blocksPerFrame = 9216;  		// TODO: This is definitely fucked up  		finalBlocks = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  		_frames = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  	} else {  		throw new NotImplementedException (string.Format ("MAC {0:0.00} not supported"' _version / 1000.0));  	}  	long totalBlocks = ((_frames - 1) * blocksPerFrame) + finalBlocks;  	long totalSize = stream.Length - stream.Position - tmpAPEv2TagSize - tmpID3v1TagSize;  	_totalSeconds = totalBlocks / (decimal)_frequency;  	_bitrate = totalSize / (_totalSeconds * 125.0m);  }  
Magic Number,IdSharp.AudioInfo,MonkeysAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\MonkeysAudio\MonkeysAudio.cs,MonkeysAudio,The following statement contains a magic number: using (FileStream stream = File.Open (path' FileMode.Open' FileAccess.Read' FileShare.Read)) {  	// Skip ID3v2 tag  	int tmpID3v2TagSize = ID3v2.GetTagSize (stream);  	int tmpID3v1TagSize = ID3v1.GetTagSize (stream);  	int tmpAPEv2TagSize = APEv2.GetTagSize (stream);  	stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  	byte[] identifier = stream.Read (4);  	if (ByteUtils.Compare (identifier' MAC_IDENTIFIER' 4) == false) {  		throw new InvalidDataException ("Invalid Monkey's Audio file");  	}  	byte[] buf = stream.Read (4);  	_version = buf [0] + (buf [1] << 8);  	int blocksPerFrame;  	int finalBlocks;  	if (_version >= 3980 && _version <= 3990) {  		buf = stream.Read (4);  		int descriptorLength = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  		stream.Seek (descriptorLength - 12' SeekOrigin.Current);  		// skip DESCRIPTOR  		buf = stream.Read (4);  		_compressionLevel = buf [0] + (buf [1] << 8);  		blocksPerFrame = stream.ReadInt32LittleEndian ();  		finalBlocks = stream.ReadInt32LittleEndian ();  		_frames = stream.ReadInt32LittleEndian ();  		buf = stream.Read (4);  		// skip bits per sample  		_channels = buf [2] + (buf [3] << 8);  		_frequency = stream.ReadInt32LittleEndian ();  	} else if (_version <= 3970) {  		// TODO: This section needs work  		_compressionLevel = buf [2] + (buf [3] << 8);  		buf = stream.Read (24);  		// skip format flags  		_channels = buf [2] + (buf [3] << 8);  		_frequency = buf [4] + (buf [5] << 8) + (buf [6] << 16) + (buf [7] << 32);  		if (_version >= 3950)  			blocksPerFrame = 73728 * 4;  		else if (_version >= 3900 || (_version >= 3800 && _compressionLevel == COMPRESSION_LEVEL_EXTRA_HIGH))  			blocksPerFrame = 73728;  		else  			blocksPerFrame = 9216;  		// TODO: This is definitely fucked up  		finalBlocks = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  		_frames = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  	} else {  		throw new NotImplementedException (string.Format ("MAC {0:0.00} not supported"' _version / 1000.0));  	}  	long totalBlocks = ((_frames - 1) * blocksPerFrame) + finalBlocks;  	long totalSize = stream.Length - stream.Position - tmpAPEv2TagSize - tmpID3v1TagSize;  	_totalSeconds = totalBlocks / (decimal)_frequency;  	_bitrate = totalSize / (_totalSeconds * 125.0m);  }  
Magic Number,IdSharp.AudioInfo,MonkeysAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\MonkeysAudio\MonkeysAudio.cs,MonkeysAudio,The following statement contains a magic number: using (FileStream stream = File.Open (path' FileMode.Open' FileAccess.Read' FileShare.Read)) {  	// Skip ID3v2 tag  	int tmpID3v2TagSize = ID3v2.GetTagSize (stream);  	int tmpID3v1TagSize = ID3v1.GetTagSize (stream);  	int tmpAPEv2TagSize = APEv2.GetTagSize (stream);  	stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  	byte[] identifier = stream.Read (4);  	if (ByteUtils.Compare (identifier' MAC_IDENTIFIER' 4) == false) {  		throw new InvalidDataException ("Invalid Monkey's Audio file");  	}  	byte[] buf = stream.Read (4);  	_version = buf [0] + (buf [1] << 8);  	int blocksPerFrame;  	int finalBlocks;  	if (_version >= 3980 && _version <= 3990) {  		buf = stream.Read (4);  		int descriptorLength = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  		stream.Seek (descriptorLength - 12' SeekOrigin.Current);  		// skip DESCRIPTOR  		buf = stream.Read (4);  		_compressionLevel = buf [0] + (buf [1] << 8);  		blocksPerFrame = stream.ReadInt32LittleEndian ();  		finalBlocks = stream.ReadInt32LittleEndian ();  		_frames = stream.ReadInt32LittleEndian ();  		buf = stream.Read (4);  		// skip bits per sample  		_channels = buf [2] + (buf [3] << 8);  		_frequency = stream.ReadInt32LittleEndian ();  	} else if (_version <= 3970) {  		// TODO: This section needs work  		_compressionLevel = buf [2] + (buf [3] << 8);  		buf = stream.Read (24);  		// skip format flags  		_channels = buf [2] + (buf [3] << 8);  		_frequency = buf [4] + (buf [5] << 8) + (buf [6] << 16) + (buf [7] << 32);  		if (_version >= 3950)  			blocksPerFrame = 73728 * 4;  		else if (_version >= 3900 || (_version >= 3800 && _compressionLevel == COMPRESSION_LEVEL_EXTRA_HIGH))  			blocksPerFrame = 73728;  		else  			blocksPerFrame = 9216;  		// TODO: This is definitely fucked up  		finalBlocks = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  		_frames = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  	} else {  		throw new NotImplementedException (string.Format ("MAC {0:0.00} not supported"' _version / 1000.0));  	}  	long totalBlocks = ((_frames - 1) * blocksPerFrame) + finalBlocks;  	long totalSize = stream.Length - stream.Position - tmpAPEv2TagSize - tmpID3v1TagSize;  	_totalSeconds = totalBlocks / (decimal)_frequency;  	_bitrate = totalSize / (_totalSeconds * 125.0m);  }  
Magic Number,IdSharp.AudioInfo,MonkeysAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\MonkeysAudio\MonkeysAudio.cs,MonkeysAudio,The following statement contains a magic number: using (FileStream stream = File.Open (path' FileMode.Open' FileAccess.Read' FileShare.Read)) {  	// Skip ID3v2 tag  	int tmpID3v2TagSize = ID3v2.GetTagSize (stream);  	int tmpID3v1TagSize = ID3v1.GetTagSize (stream);  	int tmpAPEv2TagSize = APEv2.GetTagSize (stream);  	stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  	byte[] identifier = stream.Read (4);  	if (ByteUtils.Compare (identifier' MAC_IDENTIFIER' 4) == false) {  		throw new InvalidDataException ("Invalid Monkey's Audio file");  	}  	byte[] buf = stream.Read (4);  	_version = buf [0] + (buf [1] << 8);  	int blocksPerFrame;  	int finalBlocks;  	if (_version >= 3980 && _version <= 3990) {  		buf = stream.Read (4);  		int descriptorLength = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  		stream.Seek (descriptorLength - 12' SeekOrigin.Current);  		// skip DESCRIPTOR  		buf = stream.Read (4);  		_compressionLevel = buf [0] + (buf [1] << 8);  		blocksPerFrame = stream.ReadInt32LittleEndian ();  		finalBlocks = stream.ReadInt32LittleEndian ();  		_frames = stream.ReadInt32LittleEndian ();  		buf = stream.Read (4);  		// skip bits per sample  		_channels = buf [2] + (buf [3] << 8);  		_frequency = stream.ReadInt32LittleEndian ();  	} else if (_version <= 3970) {  		// TODO: This section needs work  		_compressionLevel = buf [2] + (buf [3] << 8);  		buf = stream.Read (24);  		// skip format flags  		_channels = buf [2] + (buf [3] << 8);  		_frequency = buf [4] + (buf [5] << 8) + (buf [6] << 16) + (buf [7] << 32);  		if (_version >= 3950)  			blocksPerFrame = 73728 * 4;  		else if (_version >= 3900 || (_version >= 3800 && _compressionLevel == COMPRESSION_LEVEL_EXTRA_HIGH))  			blocksPerFrame = 73728;  		else  			blocksPerFrame = 9216;  		// TODO: This is definitely fucked up  		finalBlocks = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  		_frames = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  	} else {  		throw new NotImplementedException (string.Format ("MAC {0:0.00} not supported"' _version / 1000.0));  	}  	long totalBlocks = ((_frames - 1) * blocksPerFrame) + finalBlocks;  	long totalSize = stream.Length - stream.Position - tmpAPEv2TagSize - tmpID3v1TagSize;  	_totalSeconds = totalBlocks / (decimal)_frequency;  	_bitrate = totalSize / (_totalSeconds * 125.0m);  }  
Magic Number,IdSharp.AudioInfo,MonkeysAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\MonkeysAudio\MonkeysAudio.cs,MonkeysAudio,The following statement contains a magic number: using (FileStream stream = File.Open (path' FileMode.Open' FileAccess.Read' FileShare.Read)) {  	// Skip ID3v2 tag  	int tmpID3v2TagSize = ID3v2.GetTagSize (stream);  	int tmpID3v1TagSize = ID3v1.GetTagSize (stream);  	int tmpAPEv2TagSize = APEv2.GetTagSize (stream);  	stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  	byte[] identifier = stream.Read (4);  	if (ByteUtils.Compare (identifier' MAC_IDENTIFIER' 4) == false) {  		throw new InvalidDataException ("Invalid Monkey's Audio file");  	}  	byte[] buf = stream.Read (4);  	_version = buf [0] + (buf [1] << 8);  	int blocksPerFrame;  	int finalBlocks;  	if (_version >= 3980 && _version <= 3990) {  		buf = stream.Read (4);  		int descriptorLength = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  		stream.Seek (descriptorLength - 12' SeekOrigin.Current);  		// skip DESCRIPTOR  		buf = stream.Read (4);  		_compressionLevel = buf [0] + (buf [1] << 8);  		blocksPerFrame = stream.ReadInt32LittleEndian ();  		finalBlocks = stream.ReadInt32LittleEndian ();  		_frames = stream.ReadInt32LittleEndian ();  		buf = stream.Read (4);  		// skip bits per sample  		_channels = buf [2] + (buf [3] << 8);  		_frequency = stream.ReadInt32LittleEndian ();  	} else if (_version <= 3970) {  		// TODO: This section needs work  		_compressionLevel = buf [2] + (buf [3] << 8);  		buf = stream.Read (24);  		// skip format flags  		_channels = buf [2] + (buf [3] << 8);  		_frequency = buf [4] + (buf [5] << 8) + (buf [6] << 16) + (buf [7] << 32);  		if (_version >= 3950)  			blocksPerFrame = 73728 * 4;  		else if (_version >= 3900 || (_version >= 3800 && _compressionLevel == COMPRESSION_LEVEL_EXTRA_HIGH))  			blocksPerFrame = 73728;  		else  			blocksPerFrame = 9216;  		// TODO: This is definitely fucked up  		finalBlocks = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  		_frames = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  	} else {  		throw new NotImplementedException (string.Format ("MAC {0:0.00} not supported"' _version / 1000.0));  	}  	long totalBlocks = ((_frames - 1) * blocksPerFrame) + finalBlocks;  	long totalSize = stream.Length - stream.Position - tmpAPEv2TagSize - tmpID3v1TagSize;  	_totalSeconds = totalBlocks / (decimal)_frequency;  	_bitrate = totalSize / (_totalSeconds * 125.0m);  }  
Magic Number,IdSharp.AudioInfo,MonkeysAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\MonkeysAudio\MonkeysAudio.cs,MonkeysAudio,The following statement contains a magic number: using (FileStream stream = File.Open (path' FileMode.Open' FileAccess.Read' FileShare.Read)) {  	// Skip ID3v2 tag  	int tmpID3v2TagSize = ID3v2.GetTagSize (stream);  	int tmpID3v1TagSize = ID3v1.GetTagSize (stream);  	int tmpAPEv2TagSize = APEv2.GetTagSize (stream);  	stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  	byte[] identifier = stream.Read (4);  	if (ByteUtils.Compare (identifier' MAC_IDENTIFIER' 4) == false) {  		throw new InvalidDataException ("Invalid Monkey's Audio file");  	}  	byte[] buf = stream.Read (4);  	_version = buf [0] + (buf [1] << 8);  	int blocksPerFrame;  	int finalBlocks;  	if (_version >= 3980 && _version <= 3990) {  		buf = stream.Read (4);  		int descriptorLength = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  		stream.Seek (descriptorLength - 12' SeekOrigin.Current);  		// skip DESCRIPTOR  		buf = stream.Read (4);  		_compressionLevel = buf [0] + (buf [1] << 8);  		blocksPerFrame = stream.ReadInt32LittleEndian ();  		finalBlocks = stream.ReadInt32LittleEndian ();  		_frames = stream.ReadInt32LittleEndian ();  		buf = stream.Read (4);  		// skip bits per sample  		_channels = buf [2] + (buf [3] << 8);  		_frequency = stream.ReadInt32LittleEndian ();  	} else if (_version <= 3970) {  		// TODO: This section needs work  		_compressionLevel = buf [2] + (buf [3] << 8);  		buf = stream.Read (24);  		// skip format flags  		_channels = buf [2] + (buf [3] << 8);  		_frequency = buf [4] + (buf [5] << 8) + (buf [6] << 16) + (buf [7] << 32);  		if (_version >= 3950)  			blocksPerFrame = 73728 * 4;  		else if (_version >= 3900 || (_version >= 3800 && _compressionLevel == COMPRESSION_LEVEL_EXTRA_HIGH))  			blocksPerFrame = 73728;  		else  			blocksPerFrame = 9216;  		// TODO: This is definitely fucked up  		finalBlocks = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  		_frames = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  	} else {  		throw new NotImplementedException (string.Format ("MAC {0:0.00} not supported"' _version / 1000.0));  	}  	long totalBlocks = ((_frames - 1) * blocksPerFrame) + finalBlocks;  	long totalSize = stream.Length - stream.Position - tmpAPEv2TagSize - tmpID3v1TagSize;  	_totalSeconds = totalBlocks / (decimal)_frequency;  	_bitrate = totalSize / (_totalSeconds * 125.0m);  }  
Magic Number,IdSharp.AudioInfo,MonkeysAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\MonkeysAudio\MonkeysAudio.cs,MonkeysAudio,The following statement contains a magic number: using (FileStream stream = File.Open (path' FileMode.Open' FileAccess.Read' FileShare.Read)) {  	// Skip ID3v2 tag  	int tmpID3v2TagSize = ID3v2.GetTagSize (stream);  	int tmpID3v1TagSize = ID3v1.GetTagSize (stream);  	int tmpAPEv2TagSize = APEv2.GetTagSize (stream);  	stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  	byte[] identifier = stream.Read (4);  	if (ByteUtils.Compare (identifier' MAC_IDENTIFIER' 4) == false) {  		throw new InvalidDataException ("Invalid Monkey's Audio file");  	}  	byte[] buf = stream.Read (4);  	_version = buf [0] + (buf [1] << 8);  	int blocksPerFrame;  	int finalBlocks;  	if (_version >= 3980 && _version <= 3990) {  		buf = stream.Read (4);  		int descriptorLength = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  		stream.Seek (descriptorLength - 12' SeekOrigin.Current);  		// skip DESCRIPTOR  		buf = stream.Read (4);  		_compressionLevel = buf [0] + (buf [1] << 8);  		blocksPerFrame = stream.ReadInt32LittleEndian ();  		finalBlocks = stream.ReadInt32LittleEndian ();  		_frames = stream.ReadInt32LittleEndian ();  		buf = stream.Read (4);  		// skip bits per sample  		_channels = buf [2] + (buf [3] << 8);  		_frequency = stream.ReadInt32LittleEndian ();  	} else if (_version <= 3970) {  		// TODO: This section needs work  		_compressionLevel = buf [2] + (buf [3] << 8);  		buf = stream.Read (24);  		// skip format flags  		_channels = buf [2] + (buf [3] << 8);  		_frequency = buf [4] + (buf [5] << 8) + (buf [6] << 16) + (buf [7] << 32);  		if (_version >= 3950)  			blocksPerFrame = 73728 * 4;  		else if (_version >= 3900 || (_version >= 3800 && _compressionLevel == COMPRESSION_LEVEL_EXTRA_HIGH))  			blocksPerFrame = 73728;  		else  			blocksPerFrame = 9216;  		// TODO: This is definitely fucked up  		finalBlocks = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  		_frames = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  	} else {  		throw new NotImplementedException (string.Format ("MAC {0:0.00} not supported"' _version / 1000.0));  	}  	long totalBlocks = ((_frames - 1) * blocksPerFrame) + finalBlocks;  	long totalSize = stream.Length - stream.Position - tmpAPEv2TagSize - tmpID3v1TagSize;  	_totalSeconds = totalBlocks / (decimal)_frequency;  	_bitrate = totalSize / (_totalSeconds * 125.0m);  }  
Magic Number,IdSharp.AudioInfo,MonkeysAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\MonkeysAudio\MonkeysAudio.cs,MonkeysAudio,The following statement contains a magic number: using (FileStream stream = File.Open (path' FileMode.Open' FileAccess.Read' FileShare.Read)) {  	// Skip ID3v2 tag  	int tmpID3v2TagSize = ID3v2.GetTagSize (stream);  	int tmpID3v1TagSize = ID3v1.GetTagSize (stream);  	int tmpAPEv2TagSize = APEv2.GetTagSize (stream);  	stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  	byte[] identifier = stream.Read (4);  	if (ByteUtils.Compare (identifier' MAC_IDENTIFIER' 4) == false) {  		throw new InvalidDataException ("Invalid Monkey's Audio file");  	}  	byte[] buf = stream.Read (4);  	_version = buf [0] + (buf [1] << 8);  	int blocksPerFrame;  	int finalBlocks;  	if (_version >= 3980 && _version <= 3990) {  		buf = stream.Read (4);  		int descriptorLength = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  		stream.Seek (descriptorLength - 12' SeekOrigin.Current);  		// skip DESCRIPTOR  		buf = stream.Read (4);  		_compressionLevel = buf [0] + (buf [1] << 8);  		blocksPerFrame = stream.ReadInt32LittleEndian ();  		finalBlocks = stream.ReadInt32LittleEndian ();  		_frames = stream.ReadInt32LittleEndian ();  		buf = stream.Read (4);  		// skip bits per sample  		_channels = buf [2] + (buf [3] << 8);  		_frequency = stream.ReadInt32LittleEndian ();  	} else if (_version <= 3970) {  		// TODO: This section needs work  		_compressionLevel = buf [2] + (buf [3] << 8);  		buf = stream.Read (24);  		// skip format flags  		_channels = buf [2] + (buf [3] << 8);  		_frequency = buf [4] + (buf [5] << 8) + (buf [6] << 16) + (buf [7] << 32);  		if (_version >= 3950)  			blocksPerFrame = 73728 * 4;  		else if (_version >= 3900 || (_version >= 3800 && _compressionLevel == COMPRESSION_LEVEL_EXTRA_HIGH))  			blocksPerFrame = 73728;  		else  			blocksPerFrame = 9216;  		// TODO: This is definitely fucked up  		finalBlocks = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  		_frames = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  	} else {  		throw new NotImplementedException (string.Format ("MAC {0:0.00} not supported"' _version / 1000.0));  	}  	long totalBlocks = ((_frames - 1) * blocksPerFrame) + finalBlocks;  	long totalSize = stream.Length - stream.Position - tmpAPEv2TagSize - tmpID3v1TagSize;  	_totalSeconds = totalBlocks / (decimal)_frequency;  	_bitrate = totalSize / (_totalSeconds * 125.0m);  }  
Magic Number,IdSharp.AudioInfo,MonkeysAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\MonkeysAudio\MonkeysAudio.cs,MonkeysAudio,The following statement contains a magic number: using (FileStream stream = File.Open (path' FileMode.Open' FileAccess.Read' FileShare.Read)) {  	// Skip ID3v2 tag  	int tmpID3v2TagSize = ID3v2.GetTagSize (stream);  	int tmpID3v1TagSize = ID3v1.GetTagSize (stream);  	int tmpAPEv2TagSize = APEv2.GetTagSize (stream);  	stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  	byte[] identifier = stream.Read (4);  	if (ByteUtils.Compare (identifier' MAC_IDENTIFIER' 4) == false) {  		throw new InvalidDataException ("Invalid Monkey's Audio file");  	}  	byte[] buf = stream.Read (4);  	_version = buf [0] + (buf [1] << 8);  	int blocksPerFrame;  	int finalBlocks;  	if (_version >= 3980 && _version <= 3990) {  		buf = stream.Read (4);  		int descriptorLength = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  		stream.Seek (descriptorLength - 12' SeekOrigin.Current);  		// skip DESCRIPTOR  		buf = stream.Read (4);  		_compressionLevel = buf [0] + (buf [1] << 8);  		blocksPerFrame = stream.ReadInt32LittleEndian ();  		finalBlocks = stream.ReadInt32LittleEndian ();  		_frames = stream.ReadInt32LittleEndian ();  		buf = stream.Read (4);  		// skip bits per sample  		_channels = buf [2] + (buf [3] << 8);  		_frequency = stream.ReadInt32LittleEndian ();  	} else if (_version <= 3970) {  		// TODO: This section needs work  		_compressionLevel = buf [2] + (buf [3] << 8);  		buf = stream.Read (24);  		// skip format flags  		_channels = buf [2] + (buf [3] << 8);  		_frequency = buf [4] + (buf [5] << 8) + (buf [6] << 16) + (buf [7] << 32);  		if (_version >= 3950)  			blocksPerFrame = 73728 * 4;  		else if (_version >= 3900 || (_version >= 3800 && _compressionLevel == COMPRESSION_LEVEL_EXTRA_HIGH))  			blocksPerFrame = 73728;  		else  			blocksPerFrame = 9216;  		// TODO: This is definitely fucked up  		finalBlocks = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  		_frames = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  	} else {  		throw new NotImplementedException (string.Format ("MAC {0:0.00} not supported"' _version / 1000.0));  	}  	long totalBlocks = ((_frames - 1) * blocksPerFrame) + finalBlocks;  	long totalSize = stream.Length - stream.Position - tmpAPEv2TagSize - tmpID3v1TagSize;  	_totalSeconds = totalBlocks / (decimal)_frequency;  	_bitrate = totalSize / (_totalSeconds * 125.0m);  }  
Magic Number,IdSharp.AudioInfo,MonkeysAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\MonkeysAudio\MonkeysAudio.cs,MonkeysAudio,The following statement contains a magic number: using (FileStream stream = File.Open (path' FileMode.Open' FileAccess.Read' FileShare.Read)) {  	// Skip ID3v2 tag  	int tmpID3v2TagSize = ID3v2.GetTagSize (stream);  	int tmpID3v1TagSize = ID3v1.GetTagSize (stream);  	int tmpAPEv2TagSize = APEv2.GetTagSize (stream);  	stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  	byte[] identifier = stream.Read (4);  	if (ByteUtils.Compare (identifier' MAC_IDENTIFIER' 4) == false) {  		throw new InvalidDataException ("Invalid Monkey's Audio file");  	}  	byte[] buf = stream.Read (4);  	_version = buf [0] + (buf [1] << 8);  	int blocksPerFrame;  	int finalBlocks;  	if (_version >= 3980 && _version <= 3990) {  		buf = stream.Read (4);  		int descriptorLength = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  		stream.Seek (descriptorLength - 12' SeekOrigin.Current);  		// skip DESCRIPTOR  		buf = stream.Read (4);  		_compressionLevel = buf [0] + (buf [1] << 8);  		blocksPerFrame = stream.ReadInt32LittleEndian ();  		finalBlocks = stream.ReadInt32LittleEndian ();  		_frames = stream.ReadInt32LittleEndian ();  		buf = stream.Read (4);  		// skip bits per sample  		_channels = buf [2] + (buf [3] << 8);  		_frequency = stream.ReadInt32LittleEndian ();  	} else if (_version <= 3970) {  		// TODO: This section needs work  		_compressionLevel = buf [2] + (buf [3] << 8);  		buf = stream.Read (24);  		// skip format flags  		_channels = buf [2] + (buf [3] << 8);  		_frequency = buf [4] + (buf [5] << 8) + (buf [6] << 16) + (buf [7] << 32);  		if (_version >= 3950)  			blocksPerFrame = 73728 * 4;  		else if (_version >= 3900 || (_version >= 3800 && _compressionLevel == COMPRESSION_LEVEL_EXTRA_HIGH))  			blocksPerFrame = 73728;  		else  			blocksPerFrame = 9216;  		// TODO: This is definitely fucked up  		finalBlocks = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  		_frames = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  	} else {  		throw new NotImplementedException (string.Format ("MAC {0:0.00} not supported"' _version / 1000.0));  	}  	long totalBlocks = ((_frames - 1) * blocksPerFrame) + finalBlocks;  	long totalSize = stream.Length - stream.Position - tmpAPEv2TagSize - tmpID3v1TagSize;  	_totalSeconds = totalBlocks / (decimal)_frequency;  	_bitrate = totalSize / (_totalSeconds * 125.0m);  }  
Magic Number,IdSharp.AudioInfo,MonkeysAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\MonkeysAudio\MonkeysAudio.cs,MonkeysAudio,The following statement contains a magic number: using (FileStream stream = File.Open (path' FileMode.Open' FileAccess.Read' FileShare.Read)) {  	// Skip ID3v2 tag  	int tmpID3v2TagSize = ID3v2.GetTagSize (stream);  	int tmpID3v1TagSize = ID3v1.GetTagSize (stream);  	int tmpAPEv2TagSize = APEv2.GetTagSize (stream);  	stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  	byte[] identifier = stream.Read (4);  	if (ByteUtils.Compare (identifier' MAC_IDENTIFIER' 4) == false) {  		throw new InvalidDataException ("Invalid Monkey's Audio file");  	}  	byte[] buf = stream.Read (4);  	_version = buf [0] + (buf [1] << 8);  	int blocksPerFrame;  	int finalBlocks;  	if (_version >= 3980 && _version <= 3990) {  		buf = stream.Read (4);  		int descriptorLength = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  		stream.Seek (descriptorLength - 12' SeekOrigin.Current);  		// skip DESCRIPTOR  		buf = stream.Read (4);  		_compressionLevel = buf [0] + (buf [1] << 8);  		blocksPerFrame = stream.ReadInt32LittleEndian ();  		finalBlocks = stream.ReadInt32LittleEndian ();  		_frames = stream.ReadInt32LittleEndian ();  		buf = stream.Read (4);  		// skip bits per sample  		_channels = buf [2] + (buf [3] << 8);  		_frequency = stream.ReadInt32LittleEndian ();  	} else if (_version <= 3970) {  		// TODO: This section needs work  		_compressionLevel = buf [2] + (buf [3] << 8);  		buf = stream.Read (24);  		// skip format flags  		_channels = buf [2] + (buf [3] << 8);  		_frequency = buf [4] + (buf [5] << 8) + (buf [6] << 16) + (buf [7] << 32);  		if (_version >= 3950)  			blocksPerFrame = 73728 * 4;  		else if (_version >= 3900 || (_version >= 3800 && _compressionLevel == COMPRESSION_LEVEL_EXTRA_HIGH))  			blocksPerFrame = 73728;  		else  			blocksPerFrame = 9216;  		// TODO: This is definitely fucked up  		finalBlocks = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  		_frames = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  	} else {  		throw new NotImplementedException (string.Format ("MAC {0:0.00} not supported"' _version / 1000.0));  	}  	long totalBlocks = ((_frames - 1) * blocksPerFrame) + finalBlocks;  	long totalSize = stream.Length - stream.Position - tmpAPEv2TagSize - tmpID3v1TagSize;  	_totalSeconds = totalBlocks / (decimal)_frequency;  	_bitrate = totalSize / (_totalSeconds * 125.0m);  }  
Magic Number,IdSharp.AudioInfo,MonkeysAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\MonkeysAudio\MonkeysAudio.cs,MonkeysAudio,The following statement contains a magic number: using (FileStream stream = File.Open (path' FileMode.Open' FileAccess.Read' FileShare.Read)) {  	// Skip ID3v2 tag  	int tmpID3v2TagSize = ID3v2.GetTagSize (stream);  	int tmpID3v1TagSize = ID3v1.GetTagSize (stream);  	int tmpAPEv2TagSize = APEv2.GetTagSize (stream);  	stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  	byte[] identifier = stream.Read (4);  	if (ByteUtils.Compare (identifier' MAC_IDENTIFIER' 4) == false) {  		throw new InvalidDataException ("Invalid Monkey's Audio file");  	}  	byte[] buf = stream.Read (4);  	_version = buf [0] + (buf [1] << 8);  	int blocksPerFrame;  	int finalBlocks;  	if (_version >= 3980 && _version <= 3990) {  		buf = stream.Read (4);  		int descriptorLength = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  		stream.Seek (descriptorLength - 12' SeekOrigin.Current);  		// skip DESCRIPTOR  		buf = stream.Read (4);  		_compressionLevel = buf [0] + (buf [1] << 8);  		blocksPerFrame = stream.ReadInt32LittleEndian ();  		finalBlocks = stream.ReadInt32LittleEndian ();  		_frames = stream.ReadInt32LittleEndian ();  		buf = stream.Read (4);  		// skip bits per sample  		_channels = buf [2] + (buf [3] << 8);  		_frequency = stream.ReadInt32LittleEndian ();  	} else if (_version <= 3970) {  		// TODO: This section needs work  		_compressionLevel = buf [2] + (buf [3] << 8);  		buf = stream.Read (24);  		// skip format flags  		_channels = buf [2] + (buf [3] << 8);  		_frequency = buf [4] + (buf [5] << 8) + (buf [6] << 16) + (buf [7] << 32);  		if (_version >= 3950)  			blocksPerFrame = 73728 * 4;  		else if (_version >= 3900 || (_version >= 3800 && _compressionLevel == COMPRESSION_LEVEL_EXTRA_HIGH))  			blocksPerFrame = 73728;  		else  			blocksPerFrame = 9216;  		// TODO: This is definitely fucked up  		finalBlocks = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  		_frames = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  	} else {  		throw new NotImplementedException (string.Format ("MAC {0:0.00} not supported"' _version / 1000.0));  	}  	long totalBlocks = ((_frames - 1) * blocksPerFrame) + finalBlocks;  	long totalSize = stream.Length - stream.Position - tmpAPEv2TagSize - tmpID3v1TagSize;  	_totalSeconds = totalBlocks / (decimal)_frequency;  	_bitrate = totalSize / (_totalSeconds * 125.0m);  }  
Magic Number,IdSharp.AudioInfo,MonkeysAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\MonkeysAudio\MonkeysAudio.cs,MonkeysAudio,The following statement contains a magic number: using (FileStream stream = File.Open (path' FileMode.Open' FileAccess.Read' FileShare.Read)) {  	// Skip ID3v2 tag  	int tmpID3v2TagSize = ID3v2.GetTagSize (stream);  	int tmpID3v1TagSize = ID3v1.GetTagSize (stream);  	int tmpAPEv2TagSize = APEv2.GetTagSize (stream);  	stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  	byte[] identifier = stream.Read (4);  	if (ByteUtils.Compare (identifier' MAC_IDENTIFIER' 4) == false) {  		throw new InvalidDataException ("Invalid Monkey's Audio file");  	}  	byte[] buf = stream.Read (4);  	_version = buf [0] + (buf [1] << 8);  	int blocksPerFrame;  	int finalBlocks;  	if (_version >= 3980 && _version <= 3990) {  		buf = stream.Read (4);  		int descriptorLength = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  		stream.Seek (descriptorLength - 12' SeekOrigin.Current);  		// skip DESCRIPTOR  		buf = stream.Read (4);  		_compressionLevel = buf [0] + (buf [1] << 8);  		blocksPerFrame = stream.ReadInt32LittleEndian ();  		finalBlocks = stream.ReadInt32LittleEndian ();  		_frames = stream.ReadInt32LittleEndian ();  		buf = stream.Read (4);  		// skip bits per sample  		_channels = buf [2] + (buf [3] << 8);  		_frequency = stream.ReadInt32LittleEndian ();  	} else if (_version <= 3970) {  		// TODO: This section needs work  		_compressionLevel = buf [2] + (buf [3] << 8);  		buf = stream.Read (24);  		// skip format flags  		_channels = buf [2] + (buf [3] << 8);  		_frequency = buf [4] + (buf [5] << 8) + (buf [6] << 16) + (buf [7] << 32);  		if (_version >= 3950)  			blocksPerFrame = 73728 * 4;  		else if (_version >= 3900 || (_version >= 3800 && _compressionLevel == COMPRESSION_LEVEL_EXTRA_HIGH))  			blocksPerFrame = 73728;  		else  			blocksPerFrame = 9216;  		// TODO: This is definitely fucked up  		finalBlocks = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  		_frames = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  	} else {  		throw new NotImplementedException (string.Format ("MAC {0:0.00} not supported"' _version / 1000.0));  	}  	long totalBlocks = ((_frames - 1) * blocksPerFrame) + finalBlocks;  	long totalSize = stream.Length - stream.Position - tmpAPEv2TagSize - tmpID3v1TagSize;  	_totalSeconds = totalBlocks / (decimal)_frequency;  	_bitrate = totalSize / (_totalSeconds * 125.0m);  }  
Magic Number,IdSharp.AudioInfo,MonkeysAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\MonkeysAudio\MonkeysAudio.cs,MonkeysAudio,The following statement contains a magic number: using (FileStream stream = File.Open (path' FileMode.Open' FileAccess.Read' FileShare.Read)) {  	// Skip ID3v2 tag  	int tmpID3v2TagSize = ID3v2.GetTagSize (stream);  	int tmpID3v1TagSize = ID3v1.GetTagSize (stream);  	int tmpAPEv2TagSize = APEv2.GetTagSize (stream);  	stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  	byte[] identifier = stream.Read (4);  	if (ByteUtils.Compare (identifier' MAC_IDENTIFIER' 4) == false) {  		throw new InvalidDataException ("Invalid Monkey's Audio file");  	}  	byte[] buf = stream.Read (4);  	_version = buf [0] + (buf [1] << 8);  	int blocksPerFrame;  	int finalBlocks;  	if (_version >= 3980 && _version <= 3990) {  		buf = stream.Read (4);  		int descriptorLength = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  		stream.Seek (descriptorLength - 12' SeekOrigin.Current);  		// skip DESCRIPTOR  		buf = stream.Read (4);  		_compressionLevel = buf [0] + (buf [1] << 8);  		blocksPerFrame = stream.ReadInt32LittleEndian ();  		finalBlocks = stream.ReadInt32LittleEndian ();  		_frames = stream.ReadInt32LittleEndian ();  		buf = stream.Read (4);  		// skip bits per sample  		_channels = buf [2] + (buf [3] << 8);  		_frequency = stream.ReadInt32LittleEndian ();  	} else if (_version <= 3970) {  		// TODO: This section needs work  		_compressionLevel = buf [2] + (buf [3] << 8);  		buf = stream.Read (24);  		// skip format flags  		_channels = buf [2] + (buf [3] << 8);  		_frequency = buf [4] + (buf [5] << 8) + (buf [6] << 16) + (buf [7] << 32);  		if (_version >= 3950)  			blocksPerFrame = 73728 * 4;  		else if (_version >= 3900 || (_version >= 3800 && _compressionLevel == COMPRESSION_LEVEL_EXTRA_HIGH))  			blocksPerFrame = 73728;  		else  			blocksPerFrame = 9216;  		// TODO: This is definitely fucked up  		finalBlocks = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  		_frames = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  	} else {  		throw new NotImplementedException (string.Format ("MAC {0:0.00} not supported"' _version / 1000.0));  	}  	long totalBlocks = ((_frames - 1) * blocksPerFrame) + finalBlocks;  	long totalSize = stream.Length - stream.Position - tmpAPEv2TagSize - tmpID3v1TagSize;  	_totalSeconds = totalBlocks / (decimal)_frequency;  	_bitrate = totalSize / (_totalSeconds * 125.0m);  }  
Magic Number,IdSharp.AudioInfo,MonkeysAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\MonkeysAudio\MonkeysAudio.cs,MonkeysAudio,The following statement contains a magic number: using (FileStream stream = File.Open (path' FileMode.Open' FileAccess.Read' FileShare.Read)) {  	// Skip ID3v2 tag  	int tmpID3v2TagSize = ID3v2.GetTagSize (stream);  	int tmpID3v1TagSize = ID3v1.GetTagSize (stream);  	int tmpAPEv2TagSize = APEv2.GetTagSize (stream);  	stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  	byte[] identifier = stream.Read (4);  	if (ByteUtils.Compare (identifier' MAC_IDENTIFIER' 4) == false) {  		throw new InvalidDataException ("Invalid Monkey's Audio file");  	}  	byte[] buf = stream.Read (4);  	_version = buf [0] + (buf [1] << 8);  	int blocksPerFrame;  	int finalBlocks;  	if (_version >= 3980 && _version <= 3990) {  		buf = stream.Read (4);  		int descriptorLength = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  		stream.Seek (descriptorLength - 12' SeekOrigin.Current);  		// skip DESCRIPTOR  		buf = stream.Read (4);  		_compressionLevel = buf [0] + (buf [1] << 8);  		blocksPerFrame = stream.ReadInt32LittleEndian ();  		finalBlocks = stream.ReadInt32LittleEndian ();  		_frames = stream.ReadInt32LittleEndian ();  		buf = stream.Read (4);  		// skip bits per sample  		_channels = buf [2] + (buf [3] << 8);  		_frequency = stream.ReadInt32LittleEndian ();  	} else if (_version <= 3970) {  		// TODO: This section needs work  		_compressionLevel = buf [2] + (buf [3] << 8);  		buf = stream.Read (24);  		// skip format flags  		_channels = buf [2] + (buf [3] << 8);  		_frequency = buf [4] + (buf [5] << 8) + (buf [6] << 16) + (buf [7] << 32);  		if (_version >= 3950)  			blocksPerFrame = 73728 * 4;  		else if (_version >= 3900 || (_version >= 3800 && _compressionLevel == COMPRESSION_LEVEL_EXTRA_HIGH))  			blocksPerFrame = 73728;  		else  			blocksPerFrame = 9216;  		// TODO: This is definitely fucked up  		finalBlocks = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  		_frames = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  	} else {  		throw new NotImplementedException (string.Format ("MAC {0:0.00} not supported"' _version / 1000.0));  	}  	long totalBlocks = ((_frames - 1) * blocksPerFrame) + finalBlocks;  	long totalSize = stream.Length - stream.Position - tmpAPEv2TagSize - tmpID3v1TagSize;  	_totalSeconds = totalBlocks / (decimal)_frequency;  	_bitrate = totalSize / (_totalSeconds * 125.0m);  }  
Magic Number,IdSharp.AudioInfo,MonkeysAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\MonkeysAudio\MonkeysAudio.cs,MonkeysAudio,The following statement contains a magic number: using (FileStream stream = File.Open (path' FileMode.Open' FileAccess.Read' FileShare.Read)) {  	// Skip ID3v2 tag  	int tmpID3v2TagSize = ID3v2.GetTagSize (stream);  	int tmpID3v1TagSize = ID3v1.GetTagSize (stream);  	int tmpAPEv2TagSize = APEv2.GetTagSize (stream);  	stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  	byte[] identifier = stream.Read (4);  	if (ByteUtils.Compare (identifier' MAC_IDENTIFIER' 4) == false) {  		throw new InvalidDataException ("Invalid Monkey's Audio file");  	}  	byte[] buf = stream.Read (4);  	_version = buf [0] + (buf [1] << 8);  	int blocksPerFrame;  	int finalBlocks;  	if (_version >= 3980 && _version <= 3990) {  		buf = stream.Read (4);  		int descriptorLength = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  		stream.Seek (descriptorLength - 12' SeekOrigin.Current);  		// skip DESCRIPTOR  		buf = stream.Read (4);  		_compressionLevel = buf [0] + (buf [1] << 8);  		blocksPerFrame = stream.ReadInt32LittleEndian ();  		finalBlocks = stream.ReadInt32LittleEndian ();  		_frames = stream.ReadInt32LittleEndian ();  		buf = stream.Read (4);  		// skip bits per sample  		_channels = buf [2] + (buf [3] << 8);  		_frequency = stream.ReadInt32LittleEndian ();  	} else if (_version <= 3970) {  		// TODO: This section needs work  		_compressionLevel = buf [2] + (buf [3] << 8);  		buf = stream.Read (24);  		// skip format flags  		_channels = buf [2] + (buf [3] << 8);  		_frequency = buf [4] + (buf [5] << 8) + (buf [6] << 16) + (buf [7] << 32);  		if (_version >= 3950)  			blocksPerFrame = 73728 * 4;  		else if (_version >= 3900 || (_version >= 3800 && _compressionLevel == COMPRESSION_LEVEL_EXTRA_HIGH))  			blocksPerFrame = 73728;  		else  			blocksPerFrame = 9216;  		// TODO: This is definitely fucked up  		finalBlocks = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  		_frames = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  	} else {  		throw new NotImplementedException (string.Format ("MAC {0:0.00} not supported"' _version / 1000.0));  	}  	long totalBlocks = ((_frames - 1) * blocksPerFrame) + finalBlocks;  	long totalSize = stream.Length - stream.Position - tmpAPEv2TagSize - tmpID3v1TagSize;  	_totalSeconds = totalBlocks / (decimal)_frequency;  	_bitrate = totalSize / (_totalSeconds * 125.0m);  }  
Magic Number,IdSharp.AudioInfo,MonkeysAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\MonkeysAudio\MonkeysAudio.cs,MonkeysAudio,The following statement contains a magic number: using (FileStream stream = File.Open (path' FileMode.Open' FileAccess.Read' FileShare.Read)) {  	// Skip ID3v2 tag  	int tmpID3v2TagSize = ID3v2.GetTagSize (stream);  	int tmpID3v1TagSize = ID3v1.GetTagSize (stream);  	int tmpAPEv2TagSize = APEv2.GetTagSize (stream);  	stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  	byte[] identifier = stream.Read (4);  	if (ByteUtils.Compare (identifier' MAC_IDENTIFIER' 4) == false) {  		throw new InvalidDataException ("Invalid Monkey's Audio file");  	}  	byte[] buf = stream.Read (4);  	_version = buf [0] + (buf [1] << 8);  	int blocksPerFrame;  	int finalBlocks;  	if (_version >= 3980 && _version <= 3990) {  		buf = stream.Read (4);  		int descriptorLength = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  		stream.Seek (descriptorLength - 12' SeekOrigin.Current);  		// skip DESCRIPTOR  		buf = stream.Read (4);  		_compressionLevel = buf [0] + (buf [1] << 8);  		blocksPerFrame = stream.ReadInt32LittleEndian ();  		finalBlocks = stream.ReadInt32LittleEndian ();  		_frames = stream.ReadInt32LittleEndian ();  		buf = stream.Read (4);  		// skip bits per sample  		_channels = buf [2] + (buf [3] << 8);  		_frequency = stream.ReadInt32LittleEndian ();  	} else if (_version <= 3970) {  		// TODO: This section needs work  		_compressionLevel = buf [2] + (buf [3] << 8);  		buf = stream.Read (24);  		// skip format flags  		_channels = buf [2] + (buf [3] << 8);  		_frequency = buf [4] + (buf [5] << 8) + (buf [6] << 16) + (buf [7] << 32);  		if (_version >= 3950)  			blocksPerFrame = 73728 * 4;  		else if (_version >= 3900 || (_version >= 3800 && _compressionLevel == COMPRESSION_LEVEL_EXTRA_HIGH))  			blocksPerFrame = 73728;  		else  			blocksPerFrame = 9216;  		// TODO: This is definitely fucked up  		finalBlocks = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  		_frames = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  	} else {  		throw new NotImplementedException (string.Format ("MAC {0:0.00} not supported"' _version / 1000.0));  	}  	long totalBlocks = ((_frames - 1) * blocksPerFrame) + finalBlocks;  	long totalSize = stream.Length - stream.Position - tmpAPEv2TagSize - tmpID3v1TagSize;  	_totalSeconds = totalBlocks / (decimal)_frequency;  	_bitrate = totalSize / (_totalSeconds * 125.0m);  }  
Magic Number,IdSharp.AudioInfo,MonkeysAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\MonkeysAudio\MonkeysAudio.cs,MonkeysAudio,The following statement contains a magic number: using (FileStream stream = File.Open (path' FileMode.Open' FileAccess.Read' FileShare.Read)) {  	// Skip ID3v2 tag  	int tmpID3v2TagSize = ID3v2.GetTagSize (stream);  	int tmpID3v1TagSize = ID3v1.GetTagSize (stream);  	int tmpAPEv2TagSize = APEv2.GetTagSize (stream);  	stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  	byte[] identifier = stream.Read (4);  	if (ByteUtils.Compare (identifier' MAC_IDENTIFIER' 4) == false) {  		throw new InvalidDataException ("Invalid Monkey's Audio file");  	}  	byte[] buf = stream.Read (4);  	_version = buf [0] + (buf [1] << 8);  	int blocksPerFrame;  	int finalBlocks;  	if (_version >= 3980 && _version <= 3990) {  		buf = stream.Read (4);  		int descriptorLength = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  		stream.Seek (descriptorLength - 12' SeekOrigin.Current);  		// skip DESCRIPTOR  		buf = stream.Read (4);  		_compressionLevel = buf [0] + (buf [1] << 8);  		blocksPerFrame = stream.ReadInt32LittleEndian ();  		finalBlocks = stream.ReadInt32LittleEndian ();  		_frames = stream.ReadInt32LittleEndian ();  		buf = stream.Read (4);  		// skip bits per sample  		_channels = buf [2] + (buf [3] << 8);  		_frequency = stream.ReadInt32LittleEndian ();  	} else if (_version <= 3970) {  		// TODO: This section needs work  		_compressionLevel = buf [2] + (buf [3] << 8);  		buf = stream.Read (24);  		// skip format flags  		_channels = buf [2] + (buf [3] << 8);  		_frequency = buf [4] + (buf [5] << 8) + (buf [6] << 16) + (buf [7] << 32);  		if (_version >= 3950)  			blocksPerFrame = 73728 * 4;  		else if (_version >= 3900 || (_version >= 3800 && _compressionLevel == COMPRESSION_LEVEL_EXTRA_HIGH))  			blocksPerFrame = 73728;  		else  			blocksPerFrame = 9216;  		// TODO: This is definitely fucked up  		finalBlocks = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  		_frames = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  	} else {  		throw new NotImplementedException (string.Format ("MAC {0:0.00} not supported"' _version / 1000.0));  	}  	long totalBlocks = ((_frames - 1) * blocksPerFrame) + finalBlocks;  	long totalSize = stream.Length - stream.Position - tmpAPEv2TagSize - tmpID3v1TagSize;  	_totalSeconds = totalBlocks / (decimal)_frequency;  	_bitrate = totalSize / (_totalSeconds * 125.0m);  }  
Magic Number,IdSharp.AudioInfo,MonkeysAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\MonkeysAudio\MonkeysAudio.cs,MonkeysAudio,The following statement contains a magic number: using (FileStream stream = File.Open (path' FileMode.Open' FileAccess.Read' FileShare.Read)) {  	// Skip ID3v2 tag  	int tmpID3v2TagSize = ID3v2.GetTagSize (stream);  	int tmpID3v1TagSize = ID3v1.GetTagSize (stream);  	int tmpAPEv2TagSize = APEv2.GetTagSize (stream);  	stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  	byte[] identifier = stream.Read (4);  	if (ByteUtils.Compare (identifier' MAC_IDENTIFIER' 4) == false) {  		throw new InvalidDataException ("Invalid Monkey's Audio file");  	}  	byte[] buf = stream.Read (4);  	_version = buf [0] + (buf [1] << 8);  	int blocksPerFrame;  	int finalBlocks;  	if (_version >= 3980 && _version <= 3990) {  		buf = stream.Read (4);  		int descriptorLength = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  		stream.Seek (descriptorLength - 12' SeekOrigin.Current);  		// skip DESCRIPTOR  		buf = stream.Read (4);  		_compressionLevel = buf [0] + (buf [1] << 8);  		blocksPerFrame = stream.ReadInt32LittleEndian ();  		finalBlocks = stream.ReadInt32LittleEndian ();  		_frames = stream.ReadInt32LittleEndian ();  		buf = stream.Read (4);  		// skip bits per sample  		_channels = buf [2] + (buf [3] << 8);  		_frequency = stream.ReadInt32LittleEndian ();  	} else if (_version <= 3970) {  		// TODO: This section needs work  		_compressionLevel = buf [2] + (buf [3] << 8);  		buf = stream.Read (24);  		// skip format flags  		_channels = buf [2] + (buf [3] << 8);  		_frequency = buf [4] + (buf [5] << 8) + (buf [6] << 16) + (buf [7] << 32);  		if (_version >= 3950)  			blocksPerFrame = 73728 * 4;  		else if (_version >= 3900 || (_version >= 3800 && _compressionLevel == COMPRESSION_LEVEL_EXTRA_HIGH))  			blocksPerFrame = 73728;  		else  			blocksPerFrame = 9216;  		// TODO: This is definitely fucked up  		finalBlocks = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  		_frames = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  	} else {  		throw new NotImplementedException (string.Format ("MAC {0:0.00} not supported"' _version / 1000.0));  	}  	long totalBlocks = ((_frames - 1) * blocksPerFrame) + finalBlocks;  	long totalSize = stream.Length - stream.Position - tmpAPEv2TagSize - tmpID3v1TagSize;  	_totalSeconds = totalBlocks / (decimal)_frequency;  	_bitrate = totalSize / (_totalSeconds * 125.0m);  }  
Magic Number,IdSharp.AudioInfo,MonkeysAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\MonkeysAudio\MonkeysAudio.cs,MonkeysAudio,The following statement contains a magic number: using (FileStream stream = File.Open (path' FileMode.Open' FileAccess.Read' FileShare.Read)) {  	// Skip ID3v2 tag  	int tmpID3v2TagSize = ID3v2.GetTagSize (stream);  	int tmpID3v1TagSize = ID3v1.GetTagSize (stream);  	int tmpAPEv2TagSize = APEv2.GetTagSize (stream);  	stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  	byte[] identifier = stream.Read (4);  	if (ByteUtils.Compare (identifier' MAC_IDENTIFIER' 4) == false) {  		throw new InvalidDataException ("Invalid Monkey's Audio file");  	}  	byte[] buf = stream.Read (4);  	_version = buf [0] + (buf [1] << 8);  	int blocksPerFrame;  	int finalBlocks;  	if (_version >= 3980 && _version <= 3990) {  		buf = stream.Read (4);  		int descriptorLength = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  		stream.Seek (descriptorLength - 12' SeekOrigin.Current);  		// skip DESCRIPTOR  		buf = stream.Read (4);  		_compressionLevel = buf [0] + (buf [1] << 8);  		blocksPerFrame = stream.ReadInt32LittleEndian ();  		finalBlocks = stream.ReadInt32LittleEndian ();  		_frames = stream.ReadInt32LittleEndian ();  		buf = stream.Read (4);  		// skip bits per sample  		_channels = buf [2] + (buf [3] << 8);  		_frequency = stream.ReadInt32LittleEndian ();  	} else if (_version <= 3970) {  		// TODO: This section needs work  		_compressionLevel = buf [2] + (buf [3] << 8);  		buf = stream.Read (24);  		// skip format flags  		_channels = buf [2] + (buf [3] << 8);  		_frequency = buf [4] + (buf [5] << 8) + (buf [6] << 16) + (buf [7] << 32);  		if (_version >= 3950)  			blocksPerFrame = 73728 * 4;  		else if (_version >= 3900 || (_version >= 3800 && _compressionLevel == COMPRESSION_LEVEL_EXTRA_HIGH))  			blocksPerFrame = 73728;  		else  			blocksPerFrame = 9216;  		// TODO: This is definitely fucked up  		finalBlocks = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  		_frames = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  	} else {  		throw new NotImplementedException (string.Format ("MAC {0:0.00} not supported"' _version / 1000.0));  	}  	long totalBlocks = ((_frames - 1) * blocksPerFrame) + finalBlocks;  	long totalSize = stream.Length - stream.Position - tmpAPEv2TagSize - tmpID3v1TagSize;  	_totalSeconds = totalBlocks / (decimal)_frequency;  	_bitrate = totalSize / (_totalSeconds * 125.0m);  }  
Magic Number,IdSharp.AudioInfo,MonkeysAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\MonkeysAudio\MonkeysAudio.cs,MonkeysAudio,The following statement contains a magic number: using (FileStream stream = File.Open (path' FileMode.Open' FileAccess.Read' FileShare.Read)) {  	// Skip ID3v2 tag  	int tmpID3v2TagSize = ID3v2.GetTagSize (stream);  	int tmpID3v1TagSize = ID3v1.GetTagSize (stream);  	int tmpAPEv2TagSize = APEv2.GetTagSize (stream);  	stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  	byte[] identifier = stream.Read (4);  	if (ByteUtils.Compare (identifier' MAC_IDENTIFIER' 4) == false) {  		throw new InvalidDataException ("Invalid Monkey's Audio file");  	}  	byte[] buf = stream.Read (4);  	_version = buf [0] + (buf [1] << 8);  	int blocksPerFrame;  	int finalBlocks;  	if (_version >= 3980 && _version <= 3990) {  		buf = stream.Read (4);  		int descriptorLength = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  		stream.Seek (descriptorLength - 12' SeekOrigin.Current);  		// skip DESCRIPTOR  		buf = stream.Read (4);  		_compressionLevel = buf [0] + (buf [1] << 8);  		blocksPerFrame = stream.ReadInt32LittleEndian ();  		finalBlocks = stream.ReadInt32LittleEndian ();  		_frames = stream.ReadInt32LittleEndian ();  		buf = stream.Read (4);  		// skip bits per sample  		_channels = buf [2] + (buf [3] << 8);  		_frequency = stream.ReadInt32LittleEndian ();  	} else if (_version <= 3970) {  		// TODO: This section needs work  		_compressionLevel = buf [2] + (buf [3] << 8);  		buf = stream.Read (24);  		// skip format flags  		_channels = buf [2] + (buf [3] << 8);  		_frequency = buf [4] + (buf [5] << 8) + (buf [6] << 16) + (buf [7] << 32);  		if (_version >= 3950)  			blocksPerFrame = 73728 * 4;  		else if (_version >= 3900 || (_version >= 3800 && _compressionLevel == COMPRESSION_LEVEL_EXTRA_HIGH))  			blocksPerFrame = 73728;  		else  			blocksPerFrame = 9216;  		// TODO: This is definitely fucked up  		finalBlocks = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  		_frames = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  	} else {  		throw new NotImplementedException (string.Format ("MAC {0:0.00} not supported"' _version / 1000.0));  	}  	long totalBlocks = ((_frames - 1) * blocksPerFrame) + finalBlocks;  	long totalSize = stream.Length - stream.Position - tmpAPEv2TagSize - tmpID3v1TagSize;  	_totalSeconds = totalBlocks / (decimal)_frequency;  	_bitrate = totalSize / (_totalSeconds * 125.0m);  }  
Magic Number,IdSharp.AudioInfo,MonkeysAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\MonkeysAudio\MonkeysAudio.cs,MonkeysAudio,The following statement contains a magic number: using (FileStream stream = File.Open (path' FileMode.Open' FileAccess.Read' FileShare.Read)) {  	// Skip ID3v2 tag  	int tmpID3v2TagSize = ID3v2.GetTagSize (stream);  	int tmpID3v1TagSize = ID3v1.GetTagSize (stream);  	int tmpAPEv2TagSize = APEv2.GetTagSize (stream);  	stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  	byte[] identifier = stream.Read (4);  	if (ByteUtils.Compare (identifier' MAC_IDENTIFIER' 4) == false) {  		throw new InvalidDataException ("Invalid Monkey's Audio file");  	}  	byte[] buf = stream.Read (4);  	_version = buf [0] + (buf [1] << 8);  	int blocksPerFrame;  	int finalBlocks;  	if (_version >= 3980 && _version <= 3990) {  		buf = stream.Read (4);  		int descriptorLength = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  		stream.Seek (descriptorLength - 12' SeekOrigin.Current);  		// skip DESCRIPTOR  		buf = stream.Read (4);  		_compressionLevel = buf [0] + (buf [1] << 8);  		blocksPerFrame = stream.ReadInt32LittleEndian ();  		finalBlocks = stream.ReadInt32LittleEndian ();  		_frames = stream.ReadInt32LittleEndian ();  		buf = stream.Read (4);  		// skip bits per sample  		_channels = buf [2] + (buf [3] << 8);  		_frequency = stream.ReadInt32LittleEndian ();  	} else if (_version <= 3970) {  		// TODO: This section needs work  		_compressionLevel = buf [2] + (buf [3] << 8);  		buf = stream.Read (24);  		// skip format flags  		_channels = buf [2] + (buf [3] << 8);  		_frequency = buf [4] + (buf [5] << 8) + (buf [6] << 16) + (buf [7] << 32);  		if (_version >= 3950)  			blocksPerFrame = 73728 * 4;  		else if (_version >= 3900 || (_version >= 3800 && _compressionLevel == COMPRESSION_LEVEL_EXTRA_HIGH))  			blocksPerFrame = 73728;  		else  			blocksPerFrame = 9216;  		// TODO: This is definitely fucked up  		finalBlocks = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  		_frames = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  	} else {  		throw new NotImplementedException (string.Format ("MAC {0:0.00} not supported"' _version / 1000.0));  	}  	long totalBlocks = ((_frames - 1) * blocksPerFrame) + finalBlocks;  	long totalSize = stream.Length - stream.Position - tmpAPEv2TagSize - tmpID3v1TagSize;  	_totalSeconds = totalBlocks / (decimal)_frequency;  	_bitrate = totalSize / (_totalSeconds * 125.0m);  }  
Magic Number,IdSharp.AudioInfo,MonkeysAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\MonkeysAudio\MonkeysAudio.cs,MonkeysAudio,The following statement contains a magic number: using (FileStream stream = File.Open (path' FileMode.Open' FileAccess.Read' FileShare.Read)) {  	// Skip ID3v2 tag  	int tmpID3v2TagSize = ID3v2.GetTagSize (stream);  	int tmpID3v1TagSize = ID3v1.GetTagSize (stream);  	int tmpAPEv2TagSize = APEv2.GetTagSize (stream);  	stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  	byte[] identifier = stream.Read (4);  	if (ByteUtils.Compare (identifier' MAC_IDENTIFIER' 4) == false) {  		throw new InvalidDataException ("Invalid Monkey's Audio file");  	}  	byte[] buf = stream.Read (4);  	_version = buf [0] + (buf [1] << 8);  	int blocksPerFrame;  	int finalBlocks;  	if (_version >= 3980 && _version <= 3990) {  		buf = stream.Read (4);  		int descriptorLength = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  		stream.Seek (descriptorLength - 12' SeekOrigin.Current);  		// skip DESCRIPTOR  		buf = stream.Read (4);  		_compressionLevel = buf [0] + (buf [1] << 8);  		blocksPerFrame = stream.ReadInt32LittleEndian ();  		finalBlocks = stream.ReadInt32LittleEndian ();  		_frames = stream.ReadInt32LittleEndian ();  		buf = stream.Read (4);  		// skip bits per sample  		_channels = buf [2] + (buf [3] << 8);  		_frequency = stream.ReadInt32LittleEndian ();  	} else if (_version <= 3970) {  		// TODO: This section needs work  		_compressionLevel = buf [2] + (buf [3] << 8);  		buf = stream.Read (24);  		// skip format flags  		_channels = buf [2] + (buf [3] << 8);  		_frequency = buf [4] + (buf [5] << 8) + (buf [6] << 16) + (buf [7] << 32);  		if (_version >= 3950)  			blocksPerFrame = 73728 * 4;  		else if (_version >= 3900 || (_version >= 3800 && _compressionLevel == COMPRESSION_LEVEL_EXTRA_HIGH))  			blocksPerFrame = 73728;  		else  			blocksPerFrame = 9216;  		// TODO: This is definitely fucked up  		finalBlocks = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  		_frames = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  	} else {  		throw new NotImplementedException (string.Format ("MAC {0:0.00} not supported"' _version / 1000.0));  	}  	long totalBlocks = ((_frames - 1) * blocksPerFrame) + finalBlocks;  	long totalSize = stream.Length - stream.Position - tmpAPEv2TagSize - tmpID3v1TagSize;  	_totalSeconds = totalBlocks / (decimal)_frequency;  	_bitrate = totalSize / (_totalSeconds * 125.0m);  }  
Magic Number,IdSharp.AudioInfo,MonkeysAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\MonkeysAudio\MonkeysAudio.cs,MonkeysAudio,The following statement contains a magic number: using (FileStream stream = File.Open (path' FileMode.Open' FileAccess.Read' FileShare.Read)) {  	// Skip ID3v2 tag  	int tmpID3v2TagSize = ID3v2.GetTagSize (stream);  	int tmpID3v1TagSize = ID3v1.GetTagSize (stream);  	int tmpAPEv2TagSize = APEv2.GetTagSize (stream);  	stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  	byte[] identifier = stream.Read (4);  	if (ByteUtils.Compare (identifier' MAC_IDENTIFIER' 4) == false) {  		throw new InvalidDataException ("Invalid Monkey's Audio file");  	}  	byte[] buf = stream.Read (4);  	_version = buf [0] + (buf [1] << 8);  	int blocksPerFrame;  	int finalBlocks;  	if (_version >= 3980 && _version <= 3990) {  		buf = stream.Read (4);  		int descriptorLength = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  		stream.Seek (descriptorLength - 12' SeekOrigin.Current);  		// skip DESCRIPTOR  		buf = stream.Read (4);  		_compressionLevel = buf [0] + (buf [1] << 8);  		blocksPerFrame = stream.ReadInt32LittleEndian ();  		finalBlocks = stream.ReadInt32LittleEndian ();  		_frames = stream.ReadInt32LittleEndian ();  		buf = stream.Read (4);  		// skip bits per sample  		_channels = buf [2] + (buf [3] << 8);  		_frequency = stream.ReadInt32LittleEndian ();  	} else if (_version <= 3970) {  		// TODO: This section needs work  		_compressionLevel = buf [2] + (buf [3] << 8);  		buf = stream.Read (24);  		// skip format flags  		_channels = buf [2] + (buf [3] << 8);  		_frequency = buf [4] + (buf [5] << 8) + (buf [6] << 16) + (buf [7] << 32);  		if (_version >= 3950)  			blocksPerFrame = 73728 * 4;  		else if (_version >= 3900 || (_version >= 3800 && _compressionLevel == COMPRESSION_LEVEL_EXTRA_HIGH))  			blocksPerFrame = 73728;  		else  			blocksPerFrame = 9216;  		// TODO: This is definitely fucked up  		finalBlocks = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  		_frames = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  	} else {  		throw new NotImplementedException (string.Format ("MAC {0:0.00} not supported"' _version / 1000.0));  	}  	long totalBlocks = ((_frames - 1) * blocksPerFrame) + finalBlocks;  	long totalSize = stream.Length - stream.Position - tmpAPEv2TagSize - tmpID3v1TagSize;  	_totalSeconds = totalBlocks / (decimal)_frequency;  	_bitrate = totalSize / (_totalSeconds * 125.0m);  }  
Magic Number,IdSharp.AudioInfo,MonkeysAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\MonkeysAudio\MonkeysAudio.cs,MonkeysAudio,The following statement contains a magic number: using (FileStream stream = File.Open (path' FileMode.Open' FileAccess.Read' FileShare.Read)) {  	// Skip ID3v2 tag  	int tmpID3v2TagSize = ID3v2.GetTagSize (stream);  	int tmpID3v1TagSize = ID3v1.GetTagSize (stream);  	int tmpAPEv2TagSize = APEv2.GetTagSize (stream);  	stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  	byte[] identifier = stream.Read (4);  	if (ByteUtils.Compare (identifier' MAC_IDENTIFIER' 4) == false) {  		throw new InvalidDataException ("Invalid Monkey's Audio file");  	}  	byte[] buf = stream.Read (4);  	_version = buf [0] + (buf [1] << 8);  	int blocksPerFrame;  	int finalBlocks;  	if (_version >= 3980 && _version <= 3990) {  		buf = stream.Read (4);  		int descriptorLength = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  		stream.Seek (descriptorLength - 12' SeekOrigin.Current);  		// skip DESCRIPTOR  		buf = stream.Read (4);  		_compressionLevel = buf [0] + (buf [1] << 8);  		blocksPerFrame = stream.ReadInt32LittleEndian ();  		finalBlocks = stream.ReadInt32LittleEndian ();  		_frames = stream.ReadInt32LittleEndian ();  		buf = stream.Read (4);  		// skip bits per sample  		_channels = buf [2] + (buf [3] << 8);  		_frequency = stream.ReadInt32LittleEndian ();  	} else if (_version <= 3970) {  		// TODO: This section needs work  		_compressionLevel = buf [2] + (buf [3] << 8);  		buf = stream.Read (24);  		// skip format flags  		_channels = buf [2] + (buf [3] << 8);  		_frequency = buf [4] + (buf [5] << 8) + (buf [6] << 16) + (buf [7] << 32);  		if (_version >= 3950)  			blocksPerFrame = 73728 * 4;  		else if (_version >= 3900 || (_version >= 3800 && _compressionLevel == COMPRESSION_LEVEL_EXTRA_HIGH))  			blocksPerFrame = 73728;  		else  			blocksPerFrame = 9216;  		// TODO: This is definitely fucked up  		finalBlocks = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  		_frames = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  	} else {  		throw new NotImplementedException (string.Format ("MAC {0:0.00} not supported"' _version / 1000.0));  	}  	long totalBlocks = ((_frames - 1) * blocksPerFrame) + finalBlocks;  	long totalSize = stream.Length - stream.Position - tmpAPEv2TagSize - tmpID3v1TagSize;  	_totalSeconds = totalBlocks / (decimal)_frequency;  	_bitrate = totalSize / (_totalSeconds * 125.0m);  }  
Magic Number,IdSharp.AudioInfo,MonkeysAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\MonkeysAudio\MonkeysAudio.cs,MonkeysAudio,The following statement contains a magic number: using (FileStream stream = File.Open (path' FileMode.Open' FileAccess.Read' FileShare.Read)) {  	// Skip ID3v2 tag  	int tmpID3v2TagSize = ID3v2.GetTagSize (stream);  	int tmpID3v1TagSize = ID3v1.GetTagSize (stream);  	int tmpAPEv2TagSize = APEv2.GetTagSize (stream);  	stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  	byte[] identifier = stream.Read (4);  	if (ByteUtils.Compare (identifier' MAC_IDENTIFIER' 4) == false) {  		throw new InvalidDataException ("Invalid Monkey's Audio file");  	}  	byte[] buf = stream.Read (4);  	_version = buf [0] + (buf [1] << 8);  	int blocksPerFrame;  	int finalBlocks;  	if (_version >= 3980 && _version <= 3990) {  		buf = stream.Read (4);  		int descriptorLength = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  		stream.Seek (descriptorLength - 12' SeekOrigin.Current);  		// skip DESCRIPTOR  		buf = stream.Read (4);  		_compressionLevel = buf [0] + (buf [1] << 8);  		blocksPerFrame = stream.ReadInt32LittleEndian ();  		finalBlocks = stream.ReadInt32LittleEndian ();  		_frames = stream.ReadInt32LittleEndian ();  		buf = stream.Read (4);  		// skip bits per sample  		_channels = buf [2] + (buf [3] << 8);  		_frequency = stream.ReadInt32LittleEndian ();  	} else if (_version <= 3970) {  		// TODO: This section needs work  		_compressionLevel = buf [2] + (buf [3] << 8);  		buf = stream.Read (24);  		// skip format flags  		_channels = buf [2] + (buf [3] << 8);  		_frequency = buf [4] + (buf [5] << 8) + (buf [6] << 16) + (buf [7] << 32);  		if (_version >= 3950)  			blocksPerFrame = 73728 * 4;  		else if (_version >= 3900 || (_version >= 3800 && _compressionLevel == COMPRESSION_LEVEL_EXTRA_HIGH))  			blocksPerFrame = 73728;  		else  			blocksPerFrame = 9216;  		// TODO: This is definitely fucked up  		finalBlocks = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  		_frames = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  	} else {  		throw new NotImplementedException (string.Format ("MAC {0:0.00} not supported"' _version / 1000.0));  	}  	long totalBlocks = ((_frames - 1) * blocksPerFrame) + finalBlocks;  	long totalSize = stream.Length - stream.Position - tmpAPEv2TagSize - tmpID3v1TagSize;  	_totalSeconds = totalBlocks / (decimal)_frequency;  	_bitrate = totalSize / (_totalSeconds * 125.0m);  }  
Magic Number,IdSharp.AudioInfo,MonkeysAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\MonkeysAudio\MonkeysAudio.cs,MonkeysAudio,The following statement contains a magic number: if (ByteUtils.Compare (identifier' MAC_IDENTIFIER' 4) == false) {  	throw new InvalidDataException ("Invalid Monkey's Audio file");  }  
Magic Number,IdSharp.AudioInfo,MonkeysAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\MonkeysAudio\MonkeysAudio.cs,MonkeysAudio,The following statement contains a magic number: _version = buf [0] + (buf [1] << 8);  
Magic Number,IdSharp.AudioInfo,MonkeysAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\MonkeysAudio\MonkeysAudio.cs,MonkeysAudio,The following statement contains a magic number: if (_version >= 3980 && _version <= 3990) {  	buf = stream.Read (4);  	int descriptorLength = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  	stream.Seek (descriptorLength - 12' SeekOrigin.Current);  	// skip DESCRIPTOR  	buf = stream.Read (4);  	_compressionLevel = buf [0] + (buf [1] << 8);  	blocksPerFrame = stream.ReadInt32LittleEndian ();  	finalBlocks = stream.ReadInt32LittleEndian ();  	_frames = stream.ReadInt32LittleEndian ();  	buf = stream.Read (4);  	// skip bits per sample  	_channels = buf [2] + (buf [3] << 8);  	_frequency = stream.ReadInt32LittleEndian ();  } else if (_version <= 3970) {  	// TODO: This section needs work  	_compressionLevel = buf [2] + (buf [3] << 8);  	buf = stream.Read (24);  	// skip format flags  	_channels = buf [2] + (buf [3] << 8);  	_frequency = buf [4] + (buf [5] << 8) + (buf [6] << 16) + (buf [7] << 32);  	if (_version >= 3950)  		blocksPerFrame = 73728 * 4;  	else if (_version >= 3900 || (_version >= 3800 && _compressionLevel == COMPRESSION_LEVEL_EXTRA_HIGH))  		blocksPerFrame = 73728;  	else  		blocksPerFrame = 9216;  	// TODO: This is definitely fucked up  	finalBlocks = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  	_frames = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  } else {  	throw new NotImplementedException (string.Format ("MAC {0:0.00} not supported"' _version / 1000.0));  }  
Magic Number,IdSharp.AudioInfo,MonkeysAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\MonkeysAudio\MonkeysAudio.cs,MonkeysAudio,The following statement contains a magic number: if (_version >= 3980 && _version <= 3990) {  	buf = stream.Read (4);  	int descriptorLength = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  	stream.Seek (descriptorLength - 12' SeekOrigin.Current);  	// skip DESCRIPTOR  	buf = stream.Read (4);  	_compressionLevel = buf [0] + (buf [1] << 8);  	blocksPerFrame = stream.ReadInt32LittleEndian ();  	finalBlocks = stream.ReadInt32LittleEndian ();  	_frames = stream.ReadInt32LittleEndian ();  	buf = stream.Read (4);  	// skip bits per sample  	_channels = buf [2] + (buf [3] << 8);  	_frequency = stream.ReadInt32LittleEndian ();  } else if (_version <= 3970) {  	// TODO: This section needs work  	_compressionLevel = buf [2] + (buf [3] << 8);  	buf = stream.Read (24);  	// skip format flags  	_channels = buf [2] + (buf [3] << 8);  	_frequency = buf [4] + (buf [5] << 8) + (buf [6] << 16) + (buf [7] << 32);  	if (_version >= 3950)  		blocksPerFrame = 73728 * 4;  	else if (_version >= 3900 || (_version >= 3800 && _compressionLevel == COMPRESSION_LEVEL_EXTRA_HIGH))  		blocksPerFrame = 73728;  	else  		blocksPerFrame = 9216;  	// TODO: This is definitely fucked up  	finalBlocks = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  	_frames = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  } else {  	throw new NotImplementedException (string.Format ("MAC {0:0.00} not supported"' _version / 1000.0));  }  
Magic Number,IdSharp.AudioInfo,MonkeysAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\MonkeysAudio\MonkeysAudio.cs,MonkeysAudio,The following statement contains a magic number: if (_version >= 3980 && _version <= 3990) {  	buf = stream.Read (4);  	int descriptorLength = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  	stream.Seek (descriptorLength - 12' SeekOrigin.Current);  	// skip DESCRIPTOR  	buf = stream.Read (4);  	_compressionLevel = buf [0] + (buf [1] << 8);  	blocksPerFrame = stream.ReadInt32LittleEndian ();  	finalBlocks = stream.ReadInt32LittleEndian ();  	_frames = stream.ReadInt32LittleEndian ();  	buf = stream.Read (4);  	// skip bits per sample  	_channels = buf [2] + (buf [3] << 8);  	_frequency = stream.ReadInt32LittleEndian ();  } else if (_version <= 3970) {  	// TODO: This section needs work  	_compressionLevel = buf [2] + (buf [3] << 8);  	buf = stream.Read (24);  	// skip format flags  	_channels = buf [2] + (buf [3] << 8);  	_frequency = buf [4] + (buf [5] << 8) + (buf [6] << 16) + (buf [7] << 32);  	if (_version >= 3950)  		blocksPerFrame = 73728 * 4;  	else if (_version >= 3900 || (_version >= 3800 && _compressionLevel == COMPRESSION_LEVEL_EXTRA_HIGH))  		blocksPerFrame = 73728;  	else  		blocksPerFrame = 9216;  	// TODO: This is definitely fucked up  	finalBlocks = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  	_frames = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  } else {  	throw new NotImplementedException (string.Format ("MAC {0:0.00} not supported"' _version / 1000.0));  }  
Magic Number,IdSharp.AudioInfo,MonkeysAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\MonkeysAudio\MonkeysAudio.cs,MonkeysAudio,The following statement contains a magic number: if (_version >= 3980 && _version <= 3990) {  	buf = stream.Read (4);  	int descriptorLength = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  	stream.Seek (descriptorLength - 12' SeekOrigin.Current);  	// skip DESCRIPTOR  	buf = stream.Read (4);  	_compressionLevel = buf [0] + (buf [1] << 8);  	blocksPerFrame = stream.ReadInt32LittleEndian ();  	finalBlocks = stream.ReadInt32LittleEndian ();  	_frames = stream.ReadInt32LittleEndian ();  	buf = stream.Read (4);  	// skip bits per sample  	_channels = buf [2] + (buf [3] << 8);  	_frequency = stream.ReadInt32LittleEndian ();  } else if (_version <= 3970) {  	// TODO: This section needs work  	_compressionLevel = buf [2] + (buf [3] << 8);  	buf = stream.Read (24);  	// skip format flags  	_channels = buf [2] + (buf [3] << 8);  	_frequency = buf [4] + (buf [5] << 8) + (buf [6] << 16) + (buf [7] << 32);  	if (_version >= 3950)  		blocksPerFrame = 73728 * 4;  	else if (_version >= 3900 || (_version >= 3800 && _compressionLevel == COMPRESSION_LEVEL_EXTRA_HIGH))  		blocksPerFrame = 73728;  	else  		blocksPerFrame = 9216;  	// TODO: This is definitely fucked up  	finalBlocks = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  	_frames = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  } else {  	throw new NotImplementedException (string.Format ("MAC {0:0.00} not supported"' _version / 1000.0));  }  
Magic Number,IdSharp.AudioInfo,MonkeysAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\MonkeysAudio\MonkeysAudio.cs,MonkeysAudio,The following statement contains a magic number: if (_version >= 3980 && _version <= 3990) {  	buf = stream.Read (4);  	int descriptorLength = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  	stream.Seek (descriptorLength - 12' SeekOrigin.Current);  	// skip DESCRIPTOR  	buf = stream.Read (4);  	_compressionLevel = buf [0] + (buf [1] << 8);  	blocksPerFrame = stream.ReadInt32LittleEndian ();  	finalBlocks = stream.ReadInt32LittleEndian ();  	_frames = stream.ReadInt32LittleEndian ();  	buf = stream.Read (4);  	// skip bits per sample  	_channels = buf [2] + (buf [3] << 8);  	_frequency = stream.ReadInt32LittleEndian ();  } else if (_version <= 3970) {  	// TODO: This section needs work  	_compressionLevel = buf [2] + (buf [3] << 8);  	buf = stream.Read (24);  	// skip format flags  	_channels = buf [2] + (buf [3] << 8);  	_frequency = buf [4] + (buf [5] << 8) + (buf [6] << 16) + (buf [7] << 32);  	if (_version >= 3950)  		blocksPerFrame = 73728 * 4;  	else if (_version >= 3900 || (_version >= 3800 && _compressionLevel == COMPRESSION_LEVEL_EXTRA_HIGH))  		blocksPerFrame = 73728;  	else  		blocksPerFrame = 9216;  	// TODO: This is definitely fucked up  	finalBlocks = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  	_frames = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  } else {  	throw new NotImplementedException (string.Format ("MAC {0:0.00} not supported"' _version / 1000.0));  }  
Magic Number,IdSharp.AudioInfo,MonkeysAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\MonkeysAudio\MonkeysAudio.cs,MonkeysAudio,The following statement contains a magic number: if (_version >= 3980 && _version <= 3990) {  	buf = stream.Read (4);  	int descriptorLength = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  	stream.Seek (descriptorLength - 12' SeekOrigin.Current);  	// skip DESCRIPTOR  	buf = stream.Read (4);  	_compressionLevel = buf [0] + (buf [1] << 8);  	blocksPerFrame = stream.ReadInt32LittleEndian ();  	finalBlocks = stream.ReadInt32LittleEndian ();  	_frames = stream.ReadInt32LittleEndian ();  	buf = stream.Read (4);  	// skip bits per sample  	_channels = buf [2] + (buf [3] << 8);  	_frequency = stream.ReadInt32LittleEndian ();  } else if (_version <= 3970) {  	// TODO: This section needs work  	_compressionLevel = buf [2] + (buf [3] << 8);  	buf = stream.Read (24);  	// skip format flags  	_channels = buf [2] + (buf [3] << 8);  	_frequency = buf [4] + (buf [5] << 8) + (buf [6] << 16) + (buf [7] << 32);  	if (_version >= 3950)  		blocksPerFrame = 73728 * 4;  	else if (_version >= 3900 || (_version >= 3800 && _compressionLevel == COMPRESSION_LEVEL_EXTRA_HIGH))  		blocksPerFrame = 73728;  	else  		blocksPerFrame = 9216;  	// TODO: This is definitely fucked up  	finalBlocks = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  	_frames = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  } else {  	throw new NotImplementedException (string.Format ("MAC {0:0.00} not supported"' _version / 1000.0));  }  
Magic Number,IdSharp.AudioInfo,MonkeysAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\MonkeysAudio\MonkeysAudio.cs,MonkeysAudio,The following statement contains a magic number: if (_version >= 3980 && _version <= 3990) {  	buf = stream.Read (4);  	int descriptorLength = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  	stream.Seek (descriptorLength - 12' SeekOrigin.Current);  	// skip DESCRIPTOR  	buf = stream.Read (4);  	_compressionLevel = buf [0] + (buf [1] << 8);  	blocksPerFrame = stream.ReadInt32LittleEndian ();  	finalBlocks = stream.ReadInt32LittleEndian ();  	_frames = stream.ReadInt32LittleEndian ();  	buf = stream.Read (4);  	// skip bits per sample  	_channels = buf [2] + (buf [3] << 8);  	_frequency = stream.ReadInt32LittleEndian ();  } else if (_version <= 3970) {  	// TODO: This section needs work  	_compressionLevel = buf [2] + (buf [3] << 8);  	buf = stream.Read (24);  	// skip format flags  	_channels = buf [2] + (buf [3] << 8);  	_frequency = buf [4] + (buf [5] << 8) + (buf [6] << 16) + (buf [7] << 32);  	if (_version >= 3950)  		blocksPerFrame = 73728 * 4;  	else if (_version >= 3900 || (_version >= 3800 && _compressionLevel == COMPRESSION_LEVEL_EXTRA_HIGH))  		blocksPerFrame = 73728;  	else  		blocksPerFrame = 9216;  	// TODO: This is definitely fucked up  	finalBlocks = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  	_frames = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  } else {  	throw new NotImplementedException (string.Format ("MAC {0:0.00} not supported"' _version / 1000.0));  }  
Magic Number,IdSharp.AudioInfo,MonkeysAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\MonkeysAudio\MonkeysAudio.cs,MonkeysAudio,The following statement contains a magic number: if (_version >= 3980 && _version <= 3990) {  	buf = stream.Read (4);  	int descriptorLength = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  	stream.Seek (descriptorLength - 12' SeekOrigin.Current);  	// skip DESCRIPTOR  	buf = stream.Read (4);  	_compressionLevel = buf [0] + (buf [1] << 8);  	blocksPerFrame = stream.ReadInt32LittleEndian ();  	finalBlocks = stream.ReadInt32LittleEndian ();  	_frames = stream.ReadInt32LittleEndian ();  	buf = stream.Read (4);  	// skip bits per sample  	_channels = buf [2] + (buf [3] << 8);  	_frequency = stream.ReadInt32LittleEndian ();  } else if (_version <= 3970) {  	// TODO: This section needs work  	_compressionLevel = buf [2] + (buf [3] << 8);  	buf = stream.Read (24);  	// skip format flags  	_channels = buf [2] + (buf [3] << 8);  	_frequency = buf [4] + (buf [5] << 8) + (buf [6] << 16) + (buf [7] << 32);  	if (_version >= 3950)  		blocksPerFrame = 73728 * 4;  	else if (_version >= 3900 || (_version >= 3800 && _compressionLevel == COMPRESSION_LEVEL_EXTRA_HIGH))  		blocksPerFrame = 73728;  	else  		blocksPerFrame = 9216;  	// TODO: This is definitely fucked up  	finalBlocks = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  	_frames = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  } else {  	throw new NotImplementedException (string.Format ("MAC {0:0.00} not supported"' _version / 1000.0));  }  
Magic Number,IdSharp.AudioInfo,MonkeysAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\MonkeysAudio\MonkeysAudio.cs,MonkeysAudio,The following statement contains a magic number: if (_version >= 3980 && _version <= 3990) {  	buf = stream.Read (4);  	int descriptorLength = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  	stream.Seek (descriptorLength - 12' SeekOrigin.Current);  	// skip DESCRIPTOR  	buf = stream.Read (4);  	_compressionLevel = buf [0] + (buf [1] << 8);  	blocksPerFrame = stream.ReadInt32LittleEndian ();  	finalBlocks = stream.ReadInt32LittleEndian ();  	_frames = stream.ReadInt32LittleEndian ();  	buf = stream.Read (4);  	// skip bits per sample  	_channels = buf [2] + (buf [3] << 8);  	_frequency = stream.ReadInt32LittleEndian ();  } else if (_version <= 3970) {  	// TODO: This section needs work  	_compressionLevel = buf [2] + (buf [3] << 8);  	buf = stream.Read (24);  	// skip format flags  	_channels = buf [2] + (buf [3] << 8);  	_frequency = buf [4] + (buf [5] << 8) + (buf [6] << 16) + (buf [7] << 32);  	if (_version >= 3950)  		blocksPerFrame = 73728 * 4;  	else if (_version >= 3900 || (_version >= 3800 && _compressionLevel == COMPRESSION_LEVEL_EXTRA_HIGH))  		blocksPerFrame = 73728;  	else  		blocksPerFrame = 9216;  	// TODO: This is definitely fucked up  	finalBlocks = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  	_frames = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  } else {  	throw new NotImplementedException (string.Format ("MAC {0:0.00} not supported"' _version / 1000.0));  }  
Magic Number,IdSharp.AudioInfo,MonkeysAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\MonkeysAudio\MonkeysAudio.cs,MonkeysAudio,The following statement contains a magic number: if (_version >= 3980 && _version <= 3990) {  	buf = stream.Read (4);  	int descriptorLength = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  	stream.Seek (descriptorLength - 12' SeekOrigin.Current);  	// skip DESCRIPTOR  	buf = stream.Read (4);  	_compressionLevel = buf [0] + (buf [1] << 8);  	blocksPerFrame = stream.ReadInt32LittleEndian ();  	finalBlocks = stream.ReadInt32LittleEndian ();  	_frames = stream.ReadInt32LittleEndian ();  	buf = stream.Read (4);  	// skip bits per sample  	_channels = buf [2] + (buf [3] << 8);  	_frequency = stream.ReadInt32LittleEndian ();  } else if (_version <= 3970) {  	// TODO: This section needs work  	_compressionLevel = buf [2] + (buf [3] << 8);  	buf = stream.Read (24);  	// skip format flags  	_channels = buf [2] + (buf [3] << 8);  	_frequency = buf [4] + (buf [5] << 8) + (buf [6] << 16) + (buf [7] << 32);  	if (_version >= 3950)  		blocksPerFrame = 73728 * 4;  	else if (_version >= 3900 || (_version >= 3800 && _compressionLevel == COMPRESSION_LEVEL_EXTRA_HIGH))  		blocksPerFrame = 73728;  	else  		blocksPerFrame = 9216;  	// TODO: This is definitely fucked up  	finalBlocks = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  	_frames = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  } else {  	throw new NotImplementedException (string.Format ("MAC {0:0.00} not supported"' _version / 1000.0));  }  
Magic Number,IdSharp.AudioInfo,MonkeysAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\MonkeysAudio\MonkeysAudio.cs,MonkeysAudio,The following statement contains a magic number: if (_version >= 3980 && _version <= 3990) {  	buf = stream.Read (4);  	int descriptorLength = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  	stream.Seek (descriptorLength - 12' SeekOrigin.Current);  	// skip DESCRIPTOR  	buf = stream.Read (4);  	_compressionLevel = buf [0] + (buf [1] << 8);  	blocksPerFrame = stream.ReadInt32LittleEndian ();  	finalBlocks = stream.ReadInt32LittleEndian ();  	_frames = stream.ReadInt32LittleEndian ();  	buf = stream.Read (4);  	// skip bits per sample  	_channels = buf [2] + (buf [3] << 8);  	_frequency = stream.ReadInt32LittleEndian ();  } else if (_version <= 3970) {  	// TODO: This section needs work  	_compressionLevel = buf [2] + (buf [3] << 8);  	buf = stream.Read (24);  	// skip format flags  	_channels = buf [2] + (buf [3] << 8);  	_frequency = buf [4] + (buf [5] << 8) + (buf [6] << 16) + (buf [7] << 32);  	if (_version >= 3950)  		blocksPerFrame = 73728 * 4;  	else if (_version >= 3900 || (_version >= 3800 && _compressionLevel == COMPRESSION_LEVEL_EXTRA_HIGH))  		blocksPerFrame = 73728;  	else  		blocksPerFrame = 9216;  	// TODO: This is definitely fucked up  	finalBlocks = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  	_frames = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  } else {  	throw new NotImplementedException (string.Format ("MAC {0:0.00} not supported"' _version / 1000.0));  }  
Magic Number,IdSharp.AudioInfo,MonkeysAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\MonkeysAudio\MonkeysAudio.cs,MonkeysAudio,The following statement contains a magic number: if (_version >= 3980 && _version <= 3990) {  	buf = stream.Read (4);  	int descriptorLength = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  	stream.Seek (descriptorLength - 12' SeekOrigin.Current);  	// skip DESCRIPTOR  	buf = stream.Read (4);  	_compressionLevel = buf [0] + (buf [1] << 8);  	blocksPerFrame = stream.ReadInt32LittleEndian ();  	finalBlocks = stream.ReadInt32LittleEndian ();  	_frames = stream.ReadInt32LittleEndian ();  	buf = stream.Read (4);  	// skip bits per sample  	_channels = buf [2] + (buf [3] << 8);  	_frequency = stream.ReadInt32LittleEndian ();  } else if (_version <= 3970) {  	// TODO: This section needs work  	_compressionLevel = buf [2] + (buf [3] << 8);  	buf = stream.Read (24);  	// skip format flags  	_channels = buf [2] + (buf [3] << 8);  	_frequency = buf [4] + (buf [5] << 8) + (buf [6] << 16) + (buf [7] << 32);  	if (_version >= 3950)  		blocksPerFrame = 73728 * 4;  	else if (_version >= 3900 || (_version >= 3800 && _compressionLevel == COMPRESSION_LEVEL_EXTRA_HIGH))  		blocksPerFrame = 73728;  	else  		blocksPerFrame = 9216;  	// TODO: This is definitely fucked up  	finalBlocks = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  	_frames = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  } else {  	throw new NotImplementedException (string.Format ("MAC {0:0.00} not supported"' _version / 1000.0));  }  
Magic Number,IdSharp.AudioInfo,MonkeysAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\MonkeysAudio\MonkeysAudio.cs,MonkeysAudio,The following statement contains a magic number: if (_version >= 3980 && _version <= 3990) {  	buf = stream.Read (4);  	int descriptorLength = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  	stream.Seek (descriptorLength - 12' SeekOrigin.Current);  	// skip DESCRIPTOR  	buf = stream.Read (4);  	_compressionLevel = buf [0] + (buf [1] << 8);  	blocksPerFrame = stream.ReadInt32LittleEndian ();  	finalBlocks = stream.ReadInt32LittleEndian ();  	_frames = stream.ReadInt32LittleEndian ();  	buf = stream.Read (4);  	// skip bits per sample  	_channels = buf [2] + (buf [3] << 8);  	_frequency = stream.ReadInt32LittleEndian ();  } else if (_version <= 3970) {  	// TODO: This section needs work  	_compressionLevel = buf [2] + (buf [3] << 8);  	buf = stream.Read (24);  	// skip format flags  	_channels = buf [2] + (buf [3] << 8);  	_frequency = buf [4] + (buf [5] << 8) + (buf [6] << 16) + (buf [7] << 32);  	if (_version >= 3950)  		blocksPerFrame = 73728 * 4;  	else if (_version >= 3900 || (_version >= 3800 && _compressionLevel == COMPRESSION_LEVEL_EXTRA_HIGH))  		blocksPerFrame = 73728;  	else  		blocksPerFrame = 9216;  	// TODO: This is definitely fucked up  	finalBlocks = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  	_frames = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  } else {  	throw new NotImplementedException (string.Format ("MAC {0:0.00} not supported"' _version / 1000.0));  }  
Magic Number,IdSharp.AudioInfo,MonkeysAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\MonkeysAudio\MonkeysAudio.cs,MonkeysAudio,The following statement contains a magic number: if (_version >= 3980 && _version <= 3990) {  	buf = stream.Read (4);  	int descriptorLength = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  	stream.Seek (descriptorLength - 12' SeekOrigin.Current);  	// skip DESCRIPTOR  	buf = stream.Read (4);  	_compressionLevel = buf [0] + (buf [1] << 8);  	blocksPerFrame = stream.ReadInt32LittleEndian ();  	finalBlocks = stream.ReadInt32LittleEndian ();  	_frames = stream.ReadInt32LittleEndian ();  	buf = stream.Read (4);  	// skip bits per sample  	_channels = buf [2] + (buf [3] << 8);  	_frequency = stream.ReadInt32LittleEndian ();  } else if (_version <= 3970) {  	// TODO: This section needs work  	_compressionLevel = buf [2] + (buf [3] << 8);  	buf = stream.Read (24);  	// skip format flags  	_channels = buf [2] + (buf [3] << 8);  	_frequency = buf [4] + (buf [5] << 8) + (buf [6] << 16) + (buf [7] << 32);  	if (_version >= 3950)  		blocksPerFrame = 73728 * 4;  	else if (_version >= 3900 || (_version >= 3800 && _compressionLevel == COMPRESSION_LEVEL_EXTRA_HIGH))  		blocksPerFrame = 73728;  	else  		blocksPerFrame = 9216;  	// TODO: This is definitely fucked up  	finalBlocks = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  	_frames = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  } else {  	throw new NotImplementedException (string.Format ("MAC {0:0.00} not supported"' _version / 1000.0));  }  
Magic Number,IdSharp.AudioInfo,MonkeysAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\MonkeysAudio\MonkeysAudio.cs,MonkeysAudio,The following statement contains a magic number: if (_version >= 3980 && _version <= 3990) {  	buf = stream.Read (4);  	int descriptorLength = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  	stream.Seek (descriptorLength - 12' SeekOrigin.Current);  	// skip DESCRIPTOR  	buf = stream.Read (4);  	_compressionLevel = buf [0] + (buf [1] << 8);  	blocksPerFrame = stream.ReadInt32LittleEndian ();  	finalBlocks = stream.ReadInt32LittleEndian ();  	_frames = stream.ReadInt32LittleEndian ();  	buf = stream.Read (4);  	// skip bits per sample  	_channels = buf [2] + (buf [3] << 8);  	_frequency = stream.ReadInt32LittleEndian ();  } else if (_version <= 3970) {  	// TODO: This section needs work  	_compressionLevel = buf [2] + (buf [3] << 8);  	buf = stream.Read (24);  	// skip format flags  	_channels = buf [2] + (buf [3] << 8);  	_frequency = buf [4] + (buf [5] << 8) + (buf [6] << 16) + (buf [7] << 32);  	if (_version >= 3950)  		blocksPerFrame = 73728 * 4;  	else if (_version >= 3900 || (_version >= 3800 && _compressionLevel == COMPRESSION_LEVEL_EXTRA_HIGH))  		blocksPerFrame = 73728;  	else  		blocksPerFrame = 9216;  	// TODO: This is definitely fucked up  	finalBlocks = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  	_frames = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  } else {  	throw new NotImplementedException (string.Format ("MAC {0:0.00} not supported"' _version / 1000.0));  }  
Magic Number,IdSharp.AudioInfo,MonkeysAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\MonkeysAudio\MonkeysAudio.cs,MonkeysAudio,The following statement contains a magic number: if (_version >= 3980 && _version <= 3990) {  	buf = stream.Read (4);  	int descriptorLength = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  	stream.Seek (descriptorLength - 12' SeekOrigin.Current);  	// skip DESCRIPTOR  	buf = stream.Read (4);  	_compressionLevel = buf [0] + (buf [1] << 8);  	blocksPerFrame = stream.ReadInt32LittleEndian ();  	finalBlocks = stream.ReadInt32LittleEndian ();  	_frames = stream.ReadInt32LittleEndian ();  	buf = stream.Read (4);  	// skip bits per sample  	_channels = buf [2] + (buf [3] << 8);  	_frequency = stream.ReadInt32LittleEndian ();  } else if (_version <= 3970) {  	// TODO: This section needs work  	_compressionLevel = buf [2] + (buf [3] << 8);  	buf = stream.Read (24);  	// skip format flags  	_channels = buf [2] + (buf [3] << 8);  	_frequency = buf [4] + (buf [5] << 8) + (buf [6] << 16) + (buf [7] << 32);  	if (_version >= 3950)  		blocksPerFrame = 73728 * 4;  	else if (_version >= 3900 || (_version >= 3800 && _compressionLevel == COMPRESSION_LEVEL_EXTRA_HIGH))  		blocksPerFrame = 73728;  	else  		blocksPerFrame = 9216;  	// TODO: This is definitely fucked up  	finalBlocks = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  	_frames = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  } else {  	throw new NotImplementedException (string.Format ("MAC {0:0.00} not supported"' _version / 1000.0));  }  
Magic Number,IdSharp.AudioInfo,MonkeysAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\MonkeysAudio\MonkeysAudio.cs,MonkeysAudio,The following statement contains a magic number: if (_version >= 3980 && _version <= 3990) {  	buf = stream.Read (4);  	int descriptorLength = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  	stream.Seek (descriptorLength - 12' SeekOrigin.Current);  	// skip DESCRIPTOR  	buf = stream.Read (4);  	_compressionLevel = buf [0] + (buf [1] << 8);  	blocksPerFrame = stream.ReadInt32LittleEndian ();  	finalBlocks = stream.ReadInt32LittleEndian ();  	_frames = stream.ReadInt32LittleEndian ();  	buf = stream.Read (4);  	// skip bits per sample  	_channels = buf [2] + (buf [3] << 8);  	_frequency = stream.ReadInt32LittleEndian ();  } else if (_version <= 3970) {  	// TODO: This section needs work  	_compressionLevel = buf [2] + (buf [3] << 8);  	buf = stream.Read (24);  	// skip format flags  	_channels = buf [2] + (buf [3] << 8);  	_frequency = buf [4] + (buf [5] << 8) + (buf [6] << 16) + (buf [7] << 32);  	if (_version >= 3950)  		blocksPerFrame = 73728 * 4;  	else if (_version >= 3900 || (_version >= 3800 && _compressionLevel == COMPRESSION_LEVEL_EXTRA_HIGH))  		blocksPerFrame = 73728;  	else  		blocksPerFrame = 9216;  	// TODO: This is definitely fucked up  	finalBlocks = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  	_frames = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  } else {  	throw new NotImplementedException (string.Format ("MAC {0:0.00} not supported"' _version / 1000.0));  }  
Magic Number,IdSharp.AudioInfo,MonkeysAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\MonkeysAudio\MonkeysAudio.cs,MonkeysAudio,The following statement contains a magic number: if (_version >= 3980 && _version <= 3990) {  	buf = stream.Read (4);  	int descriptorLength = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  	stream.Seek (descriptorLength - 12' SeekOrigin.Current);  	// skip DESCRIPTOR  	buf = stream.Read (4);  	_compressionLevel = buf [0] + (buf [1] << 8);  	blocksPerFrame = stream.ReadInt32LittleEndian ();  	finalBlocks = stream.ReadInt32LittleEndian ();  	_frames = stream.ReadInt32LittleEndian ();  	buf = stream.Read (4);  	// skip bits per sample  	_channels = buf [2] + (buf [3] << 8);  	_frequency = stream.ReadInt32LittleEndian ();  } else if (_version <= 3970) {  	// TODO: This section needs work  	_compressionLevel = buf [2] + (buf [3] << 8);  	buf = stream.Read (24);  	// skip format flags  	_channels = buf [2] + (buf [3] << 8);  	_frequency = buf [4] + (buf [5] << 8) + (buf [6] << 16) + (buf [7] << 32);  	if (_version >= 3950)  		blocksPerFrame = 73728 * 4;  	else if (_version >= 3900 || (_version >= 3800 && _compressionLevel == COMPRESSION_LEVEL_EXTRA_HIGH))  		blocksPerFrame = 73728;  	else  		blocksPerFrame = 9216;  	// TODO: This is definitely fucked up  	finalBlocks = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  	_frames = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  } else {  	throw new NotImplementedException (string.Format ("MAC {0:0.00} not supported"' _version / 1000.0));  }  
Magic Number,IdSharp.AudioInfo,MonkeysAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\MonkeysAudio\MonkeysAudio.cs,MonkeysAudio,The following statement contains a magic number: if (_version >= 3980 && _version <= 3990) {  	buf = stream.Read (4);  	int descriptorLength = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  	stream.Seek (descriptorLength - 12' SeekOrigin.Current);  	// skip DESCRIPTOR  	buf = stream.Read (4);  	_compressionLevel = buf [0] + (buf [1] << 8);  	blocksPerFrame = stream.ReadInt32LittleEndian ();  	finalBlocks = stream.ReadInt32LittleEndian ();  	_frames = stream.ReadInt32LittleEndian ();  	buf = stream.Read (4);  	// skip bits per sample  	_channels = buf [2] + (buf [3] << 8);  	_frequency = stream.ReadInt32LittleEndian ();  } else if (_version <= 3970) {  	// TODO: This section needs work  	_compressionLevel = buf [2] + (buf [3] << 8);  	buf = stream.Read (24);  	// skip format flags  	_channels = buf [2] + (buf [3] << 8);  	_frequency = buf [4] + (buf [5] << 8) + (buf [6] << 16) + (buf [7] << 32);  	if (_version >= 3950)  		blocksPerFrame = 73728 * 4;  	else if (_version >= 3900 || (_version >= 3800 && _compressionLevel == COMPRESSION_LEVEL_EXTRA_HIGH))  		blocksPerFrame = 73728;  	else  		blocksPerFrame = 9216;  	// TODO: This is definitely fucked up  	finalBlocks = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  	_frames = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  } else {  	throw new NotImplementedException (string.Format ("MAC {0:0.00} not supported"' _version / 1000.0));  }  
Magic Number,IdSharp.AudioInfo,MonkeysAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\MonkeysAudio\MonkeysAudio.cs,MonkeysAudio,The following statement contains a magic number: if (_version >= 3980 && _version <= 3990) {  	buf = stream.Read (4);  	int descriptorLength = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  	stream.Seek (descriptorLength - 12' SeekOrigin.Current);  	// skip DESCRIPTOR  	buf = stream.Read (4);  	_compressionLevel = buf [0] + (buf [1] << 8);  	blocksPerFrame = stream.ReadInt32LittleEndian ();  	finalBlocks = stream.ReadInt32LittleEndian ();  	_frames = stream.ReadInt32LittleEndian ();  	buf = stream.Read (4);  	// skip bits per sample  	_channels = buf [2] + (buf [3] << 8);  	_frequency = stream.ReadInt32LittleEndian ();  } else if (_version <= 3970) {  	// TODO: This section needs work  	_compressionLevel = buf [2] + (buf [3] << 8);  	buf = stream.Read (24);  	// skip format flags  	_channels = buf [2] + (buf [3] << 8);  	_frequency = buf [4] + (buf [5] << 8) + (buf [6] << 16) + (buf [7] << 32);  	if (_version >= 3950)  		blocksPerFrame = 73728 * 4;  	else if (_version >= 3900 || (_version >= 3800 && _compressionLevel == COMPRESSION_LEVEL_EXTRA_HIGH))  		blocksPerFrame = 73728;  	else  		blocksPerFrame = 9216;  	// TODO: This is definitely fucked up  	finalBlocks = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  	_frames = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  } else {  	throw new NotImplementedException (string.Format ("MAC {0:0.00} not supported"' _version / 1000.0));  }  
Magic Number,IdSharp.AudioInfo,MonkeysAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\MonkeysAudio\MonkeysAudio.cs,MonkeysAudio,The following statement contains a magic number: if (_version >= 3980 && _version <= 3990) {  	buf = stream.Read (4);  	int descriptorLength = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  	stream.Seek (descriptorLength - 12' SeekOrigin.Current);  	// skip DESCRIPTOR  	buf = stream.Read (4);  	_compressionLevel = buf [0] + (buf [1] << 8);  	blocksPerFrame = stream.ReadInt32LittleEndian ();  	finalBlocks = stream.ReadInt32LittleEndian ();  	_frames = stream.ReadInt32LittleEndian ();  	buf = stream.Read (4);  	// skip bits per sample  	_channels = buf [2] + (buf [3] << 8);  	_frequency = stream.ReadInt32LittleEndian ();  } else if (_version <= 3970) {  	// TODO: This section needs work  	_compressionLevel = buf [2] + (buf [3] << 8);  	buf = stream.Read (24);  	// skip format flags  	_channels = buf [2] + (buf [3] << 8);  	_frequency = buf [4] + (buf [5] << 8) + (buf [6] << 16) + (buf [7] << 32);  	if (_version >= 3950)  		blocksPerFrame = 73728 * 4;  	else if (_version >= 3900 || (_version >= 3800 && _compressionLevel == COMPRESSION_LEVEL_EXTRA_HIGH))  		blocksPerFrame = 73728;  	else  		blocksPerFrame = 9216;  	// TODO: This is definitely fucked up  	finalBlocks = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  	_frames = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  } else {  	throw new NotImplementedException (string.Format ("MAC {0:0.00} not supported"' _version / 1000.0));  }  
Magic Number,IdSharp.AudioInfo,MonkeysAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\MonkeysAudio\MonkeysAudio.cs,MonkeysAudio,The following statement contains a magic number: if (_version >= 3980 && _version <= 3990) {  	buf = stream.Read (4);  	int descriptorLength = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  	stream.Seek (descriptorLength - 12' SeekOrigin.Current);  	// skip DESCRIPTOR  	buf = stream.Read (4);  	_compressionLevel = buf [0] + (buf [1] << 8);  	blocksPerFrame = stream.ReadInt32LittleEndian ();  	finalBlocks = stream.ReadInt32LittleEndian ();  	_frames = stream.ReadInt32LittleEndian ();  	buf = stream.Read (4);  	// skip bits per sample  	_channels = buf [2] + (buf [3] << 8);  	_frequency = stream.ReadInt32LittleEndian ();  } else if (_version <= 3970) {  	// TODO: This section needs work  	_compressionLevel = buf [2] + (buf [3] << 8);  	buf = stream.Read (24);  	// skip format flags  	_channels = buf [2] + (buf [3] << 8);  	_frequency = buf [4] + (buf [5] << 8) + (buf [6] << 16) + (buf [7] << 32);  	if (_version >= 3950)  		blocksPerFrame = 73728 * 4;  	else if (_version >= 3900 || (_version >= 3800 && _compressionLevel == COMPRESSION_LEVEL_EXTRA_HIGH))  		blocksPerFrame = 73728;  	else  		blocksPerFrame = 9216;  	// TODO: This is definitely fucked up  	finalBlocks = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  	_frames = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  } else {  	throw new NotImplementedException (string.Format ("MAC {0:0.00} not supported"' _version / 1000.0));  }  
Magic Number,IdSharp.AudioInfo,MonkeysAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\MonkeysAudio\MonkeysAudio.cs,MonkeysAudio,The following statement contains a magic number: if (_version >= 3980 && _version <= 3990) {  	buf = stream.Read (4);  	int descriptorLength = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  	stream.Seek (descriptorLength - 12' SeekOrigin.Current);  	// skip DESCRIPTOR  	buf = stream.Read (4);  	_compressionLevel = buf [0] + (buf [1] << 8);  	blocksPerFrame = stream.ReadInt32LittleEndian ();  	finalBlocks = stream.ReadInt32LittleEndian ();  	_frames = stream.ReadInt32LittleEndian ();  	buf = stream.Read (4);  	// skip bits per sample  	_channels = buf [2] + (buf [3] << 8);  	_frequency = stream.ReadInt32LittleEndian ();  } else if (_version <= 3970) {  	// TODO: This section needs work  	_compressionLevel = buf [2] + (buf [3] << 8);  	buf = stream.Read (24);  	// skip format flags  	_channels = buf [2] + (buf [3] << 8);  	_frequency = buf [4] + (buf [5] << 8) + (buf [6] << 16) + (buf [7] << 32);  	if (_version >= 3950)  		blocksPerFrame = 73728 * 4;  	else if (_version >= 3900 || (_version >= 3800 && _compressionLevel == COMPRESSION_LEVEL_EXTRA_HIGH))  		blocksPerFrame = 73728;  	else  		blocksPerFrame = 9216;  	// TODO: This is definitely fucked up  	finalBlocks = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  	_frames = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  } else {  	throw new NotImplementedException (string.Format ("MAC {0:0.00} not supported"' _version / 1000.0));  }  
Magic Number,IdSharp.AudioInfo,MonkeysAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\MonkeysAudio\MonkeysAudio.cs,MonkeysAudio,The following statement contains a magic number: if (_version >= 3980 && _version <= 3990) {  	buf = stream.Read (4);  	int descriptorLength = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  	stream.Seek (descriptorLength - 12' SeekOrigin.Current);  	// skip DESCRIPTOR  	buf = stream.Read (4);  	_compressionLevel = buf [0] + (buf [1] << 8);  	blocksPerFrame = stream.ReadInt32LittleEndian ();  	finalBlocks = stream.ReadInt32LittleEndian ();  	_frames = stream.ReadInt32LittleEndian ();  	buf = stream.Read (4);  	// skip bits per sample  	_channels = buf [2] + (buf [3] << 8);  	_frequency = stream.ReadInt32LittleEndian ();  } else if (_version <= 3970) {  	// TODO: This section needs work  	_compressionLevel = buf [2] + (buf [3] << 8);  	buf = stream.Read (24);  	// skip format flags  	_channels = buf [2] + (buf [3] << 8);  	_frequency = buf [4] + (buf [5] << 8) + (buf [6] << 16) + (buf [7] << 32);  	if (_version >= 3950)  		blocksPerFrame = 73728 * 4;  	else if (_version >= 3900 || (_version >= 3800 && _compressionLevel == COMPRESSION_LEVEL_EXTRA_HIGH))  		blocksPerFrame = 73728;  	else  		blocksPerFrame = 9216;  	// TODO: This is definitely fucked up  	finalBlocks = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  	_frames = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  } else {  	throw new NotImplementedException (string.Format ("MAC {0:0.00} not supported"' _version / 1000.0));  }  
Magic Number,IdSharp.AudioInfo,MonkeysAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\MonkeysAudio\MonkeysAudio.cs,MonkeysAudio,The following statement contains a magic number: if (_version >= 3980 && _version <= 3990) {  	buf = stream.Read (4);  	int descriptorLength = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  	stream.Seek (descriptorLength - 12' SeekOrigin.Current);  	// skip DESCRIPTOR  	buf = stream.Read (4);  	_compressionLevel = buf [0] + (buf [1] << 8);  	blocksPerFrame = stream.ReadInt32LittleEndian ();  	finalBlocks = stream.ReadInt32LittleEndian ();  	_frames = stream.ReadInt32LittleEndian ();  	buf = stream.Read (4);  	// skip bits per sample  	_channels = buf [2] + (buf [3] << 8);  	_frequency = stream.ReadInt32LittleEndian ();  } else if (_version <= 3970) {  	// TODO: This section needs work  	_compressionLevel = buf [2] + (buf [3] << 8);  	buf = stream.Read (24);  	// skip format flags  	_channels = buf [2] + (buf [3] << 8);  	_frequency = buf [4] + (buf [5] << 8) + (buf [6] << 16) + (buf [7] << 32);  	if (_version >= 3950)  		blocksPerFrame = 73728 * 4;  	else if (_version >= 3900 || (_version >= 3800 && _compressionLevel == COMPRESSION_LEVEL_EXTRA_HIGH))  		blocksPerFrame = 73728;  	else  		blocksPerFrame = 9216;  	// TODO: This is definitely fucked up  	finalBlocks = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  	_frames = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  } else {  	throw new NotImplementedException (string.Format ("MAC {0:0.00} not supported"' _version / 1000.0));  }  
Magic Number,IdSharp.AudioInfo,MonkeysAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\MonkeysAudio\MonkeysAudio.cs,MonkeysAudio,The following statement contains a magic number: if (_version >= 3980 && _version <= 3990) {  	buf = stream.Read (4);  	int descriptorLength = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  	stream.Seek (descriptorLength - 12' SeekOrigin.Current);  	// skip DESCRIPTOR  	buf = stream.Read (4);  	_compressionLevel = buf [0] + (buf [1] << 8);  	blocksPerFrame = stream.ReadInt32LittleEndian ();  	finalBlocks = stream.ReadInt32LittleEndian ();  	_frames = stream.ReadInt32LittleEndian ();  	buf = stream.Read (4);  	// skip bits per sample  	_channels = buf [2] + (buf [3] << 8);  	_frequency = stream.ReadInt32LittleEndian ();  } else if (_version <= 3970) {  	// TODO: This section needs work  	_compressionLevel = buf [2] + (buf [3] << 8);  	buf = stream.Read (24);  	// skip format flags  	_channels = buf [2] + (buf [3] << 8);  	_frequency = buf [4] + (buf [5] << 8) + (buf [6] << 16) + (buf [7] << 32);  	if (_version >= 3950)  		blocksPerFrame = 73728 * 4;  	else if (_version >= 3900 || (_version >= 3800 && _compressionLevel == COMPRESSION_LEVEL_EXTRA_HIGH))  		blocksPerFrame = 73728;  	else  		blocksPerFrame = 9216;  	// TODO: This is definitely fucked up  	finalBlocks = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  	_frames = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  } else {  	throw new NotImplementedException (string.Format ("MAC {0:0.00} not supported"' _version / 1000.0));  }  
Magic Number,IdSharp.AudioInfo,MonkeysAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\MonkeysAudio\MonkeysAudio.cs,MonkeysAudio,The following statement contains a magic number: if (_version >= 3980 && _version <= 3990) {  	buf = stream.Read (4);  	int descriptorLength = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  	stream.Seek (descriptorLength - 12' SeekOrigin.Current);  	// skip DESCRIPTOR  	buf = stream.Read (4);  	_compressionLevel = buf [0] + (buf [1] << 8);  	blocksPerFrame = stream.ReadInt32LittleEndian ();  	finalBlocks = stream.ReadInt32LittleEndian ();  	_frames = stream.ReadInt32LittleEndian ();  	buf = stream.Read (4);  	// skip bits per sample  	_channels = buf [2] + (buf [3] << 8);  	_frequency = stream.ReadInt32LittleEndian ();  } else if (_version <= 3970) {  	// TODO: This section needs work  	_compressionLevel = buf [2] + (buf [3] << 8);  	buf = stream.Read (24);  	// skip format flags  	_channels = buf [2] + (buf [3] << 8);  	_frequency = buf [4] + (buf [5] << 8) + (buf [6] << 16) + (buf [7] << 32);  	if (_version >= 3950)  		blocksPerFrame = 73728 * 4;  	else if (_version >= 3900 || (_version >= 3800 && _compressionLevel == COMPRESSION_LEVEL_EXTRA_HIGH))  		blocksPerFrame = 73728;  	else  		blocksPerFrame = 9216;  	// TODO: This is definitely fucked up  	finalBlocks = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  	_frames = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  } else {  	throw new NotImplementedException (string.Format ("MAC {0:0.00} not supported"' _version / 1000.0));  }  
Magic Number,IdSharp.AudioInfo,MonkeysAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\MonkeysAudio\MonkeysAudio.cs,MonkeysAudio,The following statement contains a magic number: if (_version >= 3980 && _version <= 3990) {  	buf = stream.Read (4);  	int descriptorLength = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  	stream.Seek (descriptorLength - 12' SeekOrigin.Current);  	// skip DESCRIPTOR  	buf = stream.Read (4);  	_compressionLevel = buf [0] + (buf [1] << 8);  	blocksPerFrame = stream.ReadInt32LittleEndian ();  	finalBlocks = stream.ReadInt32LittleEndian ();  	_frames = stream.ReadInt32LittleEndian ();  	buf = stream.Read (4);  	// skip bits per sample  	_channels = buf [2] + (buf [3] << 8);  	_frequency = stream.ReadInt32LittleEndian ();  } else if (_version <= 3970) {  	// TODO: This section needs work  	_compressionLevel = buf [2] + (buf [3] << 8);  	buf = stream.Read (24);  	// skip format flags  	_channels = buf [2] + (buf [3] << 8);  	_frequency = buf [4] + (buf [5] << 8) + (buf [6] << 16) + (buf [7] << 32);  	if (_version >= 3950)  		blocksPerFrame = 73728 * 4;  	else if (_version >= 3900 || (_version >= 3800 && _compressionLevel == COMPRESSION_LEVEL_EXTRA_HIGH))  		blocksPerFrame = 73728;  	else  		blocksPerFrame = 9216;  	// TODO: This is definitely fucked up  	finalBlocks = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  	_frames = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  } else {  	throw new NotImplementedException (string.Format ("MAC {0:0.00} not supported"' _version / 1000.0));  }  
Magic Number,IdSharp.AudioInfo,MonkeysAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\MonkeysAudio\MonkeysAudio.cs,MonkeysAudio,The following statement contains a magic number: if (_version >= 3980 && _version <= 3990) {  	buf = stream.Read (4);  	int descriptorLength = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  	stream.Seek (descriptorLength - 12' SeekOrigin.Current);  	// skip DESCRIPTOR  	buf = stream.Read (4);  	_compressionLevel = buf [0] + (buf [1] << 8);  	blocksPerFrame = stream.ReadInt32LittleEndian ();  	finalBlocks = stream.ReadInt32LittleEndian ();  	_frames = stream.ReadInt32LittleEndian ();  	buf = stream.Read (4);  	// skip bits per sample  	_channels = buf [2] + (buf [3] << 8);  	_frequency = stream.ReadInt32LittleEndian ();  } else if (_version <= 3970) {  	// TODO: This section needs work  	_compressionLevel = buf [2] + (buf [3] << 8);  	buf = stream.Read (24);  	// skip format flags  	_channels = buf [2] + (buf [3] << 8);  	_frequency = buf [4] + (buf [5] << 8) + (buf [6] << 16) + (buf [7] << 32);  	if (_version >= 3950)  		blocksPerFrame = 73728 * 4;  	else if (_version >= 3900 || (_version >= 3800 && _compressionLevel == COMPRESSION_LEVEL_EXTRA_HIGH))  		blocksPerFrame = 73728;  	else  		blocksPerFrame = 9216;  	// TODO: This is definitely fucked up  	finalBlocks = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  	_frames = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  } else {  	throw new NotImplementedException (string.Format ("MAC {0:0.00} not supported"' _version / 1000.0));  }  
Magic Number,IdSharp.AudioInfo,MonkeysAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\MonkeysAudio\MonkeysAudio.cs,MonkeysAudio,The following statement contains a magic number: if (_version >= 3980 && _version <= 3990) {  	buf = stream.Read (4);  	int descriptorLength = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  	stream.Seek (descriptorLength - 12' SeekOrigin.Current);  	// skip DESCRIPTOR  	buf = stream.Read (4);  	_compressionLevel = buf [0] + (buf [1] << 8);  	blocksPerFrame = stream.ReadInt32LittleEndian ();  	finalBlocks = stream.ReadInt32LittleEndian ();  	_frames = stream.ReadInt32LittleEndian ();  	buf = stream.Read (4);  	// skip bits per sample  	_channels = buf [2] + (buf [3] << 8);  	_frequency = stream.ReadInt32LittleEndian ();  } else if (_version <= 3970) {  	// TODO: This section needs work  	_compressionLevel = buf [2] + (buf [3] << 8);  	buf = stream.Read (24);  	// skip format flags  	_channels = buf [2] + (buf [3] << 8);  	_frequency = buf [4] + (buf [5] << 8) + (buf [6] << 16) + (buf [7] << 32);  	if (_version >= 3950)  		blocksPerFrame = 73728 * 4;  	else if (_version >= 3900 || (_version >= 3800 && _compressionLevel == COMPRESSION_LEVEL_EXTRA_HIGH))  		blocksPerFrame = 73728;  	else  		blocksPerFrame = 9216;  	// TODO: This is definitely fucked up  	finalBlocks = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  	_frames = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  } else {  	throw new NotImplementedException (string.Format ("MAC {0:0.00} not supported"' _version / 1000.0));  }  
Magic Number,IdSharp.AudioInfo,MonkeysAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\MonkeysAudio\MonkeysAudio.cs,MonkeysAudio,The following statement contains a magic number: if (_version >= 3980 && _version <= 3990) {  	buf = stream.Read (4);  	int descriptorLength = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  	stream.Seek (descriptorLength - 12' SeekOrigin.Current);  	// skip DESCRIPTOR  	buf = stream.Read (4);  	_compressionLevel = buf [0] + (buf [1] << 8);  	blocksPerFrame = stream.ReadInt32LittleEndian ();  	finalBlocks = stream.ReadInt32LittleEndian ();  	_frames = stream.ReadInt32LittleEndian ();  	buf = stream.Read (4);  	// skip bits per sample  	_channels = buf [2] + (buf [3] << 8);  	_frequency = stream.ReadInt32LittleEndian ();  } else if (_version <= 3970) {  	// TODO: This section needs work  	_compressionLevel = buf [2] + (buf [3] << 8);  	buf = stream.Read (24);  	// skip format flags  	_channels = buf [2] + (buf [3] << 8);  	_frequency = buf [4] + (buf [5] << 8) + (buf [6] << 16) + (buf [7] << 32);  	if (_version >= 3950)  		blocksPerFrame = 73728 * 4;  	else if (_version >= 3900 || (_version >= 3800 && _compressionLevel == COMPRESSION_LEVEL_EXTRA_HIGH))  		blocksPerFrame = 73728;  	else  		blocksPerFrame = 9216;  	// TODO: This is definitely fucked up  	finalBlocks = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  	_frames = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  } else {  	throw new NotImplementedException (string.Format ("MAC {0:0.00} not supported"' _version / 1000.0));  }  
Magic Number,IdSharp.AudioInfo,MonkeysAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\MonkeysAudio\MonkeysAudio.cs,MonkeysAudio,The following statement contains a magic number: if (_version >= 3980 && _version <= 3990) {  	buf = stream.Read (4);  	int descriptorLength = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  	stream.Seek (descriptorLength - 12' SeekOrigin.Current);  	// skip DESCRIPTOR  	buf = stream.Read (4);  	_compressionLevel = buf [0] + (buf [1] << 8);  	blocksPerFrame = stream.ReadInt32LittleEndian ();  	finalBlocks = stream.ReadInt32LittleEndian ();  	_frames = stream.ReadInt32LittleEndian ();  	buf = stream.Read (4);  	// skip bits per sample  	_channels = buf [2] + (buf [3] << 8);  	_frequency = stream.ReadInt32LittleEndian ();  } else if (_version <= 3970) {  	// TODO: This section needs work  	_compressionLevel = buf [2] + (buf [3] << 8);  	buf = stream.Read (24);  	// skip format flags  	_channels = buf [2] + (buf [3] << 8);  	_frequency = buf [4] + (buf [5] << 8) + (buf [6] << 16) + (buf [7] << 32);  	if (_version >= 3950)  		blocksPerFrame = 73728 * 4;  	else if (_version >= 3900 || (_version >= 3800 && _compressionLevel == COMPRESSION_LEVEL_EXTRA_HIGH))  		blocksPerFrame = 73728;  	else  		blocksPerFrame = 9216;  	// TODO: This is definitely fucked up  	finalBlocks = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  	_frames = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  } else {  	throw new NotImplementedException (string.Format ("MAC {0:0.00} not supported"' _version / 1000.0));  }  
Magic Number,IdSharp.AudioInfo,MonkeysAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\MonkeysAudio\MonkeysAudio.cs,MonkeysAudio,The following statement contains a magic number: if (_version >= 3980 && _version <= 3990) {  	buf = stream.Read (4);  	int descriptorLength = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  	stream.Seek (descriptorLength - 12' SeekOrigin.Current);  	// skip DESCRIPTOR  	buf = stream.Read (4);  	_compressionLevel = buf [0] + (buf [1] << 8);  	blocksPerFrame = stream.ReadInt32LittleEndian ();  	finalBlocks = stream.ReadInt32LittleEndian ();  	_frames = stream.ReadInt32LittleEndian ();  	buf = stream.Read (4);  	// skip bits per sample  	_channels = buf [2] + (buf [3] << 8);  	_frequency = stream.ReadInt32LittleEndian ();  } else if (_version <= 3970) {  	// TODO: This section needs work  	_compressionLevel = buf [2] + (buf [3] << 8);  	buf = stream.Read (24);  	// skip format flags  	_channels = buf [2] + (buf [3] << 8);  	_frequency = buf [4] + (buf [5] << 8) + (buf [6] << 16) + (buf [7] << 32);  	if (_version >= 3950)  		blocksPerFrame = 73728 * 4;  	else if (_version >= 3900 || (_version >= 3800 && _compressionLevel == COMPRESSION_LEVEL_EXTRA_HIGH))  		blocksPerFrame = 73728;  	else  		blocksPerFrame = 9216;  	// TODO: This is definitely fucked up  	finalBlocks = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  	_frames = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  } else {  	throw new NotImplementedException (string.Format ("MAC {0:0.00} not supported"' _version / 1000.0));  }  
Magic Number,IdSharp.AudioInfo,MonkeysAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\MonkeysAudio\MonkeysAudio.cs,MonkeysAudio,The following statement contains a magic number: if (_version >= 3980 && _version <= 3990) {  	buf = stream.Read (4);  	int descriptorLength = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  	stream.Seek (descriptorLength - 12' SeekOrigin.Current);  	// skip DESCRIPTOR  	buf = stream.Read (4);  	_compressionLevel = buf [0] + (buf [1] << 8);  	blocksPerFrame = stream.ReadInt32LittleEndian ();  	finalBlocks = stream.ReadInt32LittleEndian ();  	_frames = stream.ReadInt32LittleEndian ();  	buf = stream.Read (4);  	// skip bits per sample  	_channels = buf [2] + (buf [3] << 8);  	_frequency = stream.ReadInt32LittleEndian ();  } else if (_version <= 3970) {  	// TODO: This section needs work  	_compressionLevel = buf [2] + (buf [3] << 8);  	buf = stream.Read (24);  	// skip format flags  	_channels = buf [2] + (buf [3] << 8);  	_frequency = buf [4] + (buf [5] << 8) + (buf [6] << 16) + (buf [7] << 32);  	if (_version >= 3950)  		blocksPerFrame = 73728 * 4;  	else if (_version >= 3900 || (_version >= 3800 && _compressionLevel == COMPRESSION_LEVEL_EXTRA_HIGH))  		blocksPerFrame = 73728;  	else  		blocksPerFrame = 9216;  	// TODO: This is definitely fucked up  	finalBlocks = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  	_frames = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  } else {  	throw new NotImplementedException (string.Format ("MAC {0:0.00} not supported"' _version / 1000.0));  }  
Magic Number,IdSharp.AudioInfo,MonkeysAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\MonkeysAudio\MonkeysAudio.cs,MonkeysAudio,The following statement contains a magic number: if (_version >= 3980 && _version <= 3990) {  	buf = stream.Read (4);  	int descriptorLength = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  	stream.Seek (descriptorLength - 12' SeekOrigin.Current);  	// skip DESCRIPTOR  	buf = stream.Read (4);  	_compressionLevel = buf [0] + (buf [1] << 8);  	blocksPerFrame = stream.ReadInt32LittleEndian ();  	finalBlocks = stream.ReadInt32LittleEndian ();  	_frames = stream.ReadInt32LittleEndian ();  	buf = stream.Read (4);  	// skip bits per sample  	_channels = buf [2] + (buf [3] << 8);  	_frequency = stream.ReadInt32LittleEndian ();  } else if (_version <= 3970) {  	// TODO: This section needs work  	_compressionLevel = buf [2] + (buf [3] << 8);  	buf = stream.Read (24);  	// skip format flags  	_channels = buf [2] + (buf [3] << 8);  	_frequency = buf [4] + (buf [5] << 8) + (buf [6] << 16) + (buf [7] << 32);  	if (_version >= 3950)  		blocksPerFrame = 73728 * 4;  	else if (_version >= 3900 || (_version >= 3800 && _compressionLevel == COMPRESSION_LEVEL_EXTRA_HIGH))  		blocksPerFrame = 73728;  	else  		blocksPerFrame = 9216;  	// TODO: This is definitely fucked up  	finalBlocks = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  	_frames = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  } else {  	throw new NotImplementedException (string.Format ("MAC {0:0.00} not supported"' _version / 1000.0));  }  
Magic Number,IdSharp.AudioInfo,MonkeysAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\MonkeysAudio\MonkeysAudio.cs,MonkeysAudio,The following statement contains a magic number: if (_version >= 3980 && _version <= 3990) {  	buf = stream.Read (4);  	int descriptorLength = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  	stream.Seek (descriptorLength - 12' SeekOrigin.Current);  	// skip DESCRIPTOR  	buf = stream.Read (4);  	_compressionLevel = buf [0] + (buf [1] << 8);  	blocksPerFrame = stream.ReadInt32LittleEndian ();  	finalBlocks = stream.ReadInt32LittleEndian ();  	_frames = stream.ReadInt32LittleEndian ();  	buf = stream.Read (4);  	// skip bits per sample  	_channels = buf [2] + (buf [3] << 8);  	_frequency = stream.ReadInt32LittleEndian ();  } else if (_version <= 3970) {  	// TODO: This section needs work  	_compressionLevel = buf [2] + (buf [3] << 8);  	buf = stream.Read (24);  	// skip format flags  	_channels = buf [2] + (buf [3] << 8);  	_frequency = buf [4] + (buf [5] << 8) + (buf [6] << 16) + (buf [7] << 32);  	if (_version >= 3950)  		blocksPerFrame = 73728 * 4;  	else if (_version >= 3900 || (_version >= 3800 && _compressionLevel == COMPRESSION_LEVEL_EXTRA_HIGH))  		blocksPerFrame = 73728;  	else  		blocksPerFrame = 9216;  	// TODO: This is definitely fucked up  	finalBlocks = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  	_frames = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  } else {  	throw new NotImplementedException (string.Format ("MAC {0:0.00} not supported"' _version / 1000.0));  }  
Magic Number,IdSharp.AudioInfo,MonkeysAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\MonkeysAudio\MonkeysAudio.cs,MonkeysAudio,The following statement contains a magic number: if (_version >= 3980 && _version <= 3990) {  	buf = stream.Read (4);  	int descriptorLength = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  	stream.Seek (descriptorLength - 12' SeekOrigin.Current);  	// skip DESCRIPTOR  	buf = stream.Read (4);  	_compressionLevel = buf [0] + (buf [1] << 8);  	blocksPerFrame = stream.ReadInt32LittleEndian ();  	finalBlocks = stream.ReadInt32LittleEndian ();  	_frames = stream.ReadInt32LittleEndian ();  	buf = stream.Read (4);  	// skip bits per sample  	_channels = buf [2] + (buf [3] << 8);  	_frequency = stream.ReadInt32LittleEndian ();  } else if (_version <= 3970) {  	// TODO: This section needs work  	_compressionLevel = buf [2] + (buf [3] << 8);  	buf = stream.Read (24);  	// skip format flags  	_channels = buf [2] + (buf [3] << 8);  	_frequency = buf [4] + (buf [5] << 8) + (buf [6] << 16) + (buf [7] << 32);  	if (_version >= 3950)  		blocksPerFrame = 73728 * 4;  	else if (_version >= 3900 || (_version >= 3800 && _compressionLevel == COMPRESSION_LEVEL_EXTRA_HIGH))  		blocksPerFrame = 73728;  	else  		blocksPerFrame = 9216;  	// TODO: This is definitely fucked up  	finalBlocks = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  	_frames = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  } else {  	throw new NotImplementedException (string.Format ("MAC {0:0.00} not supported"' _version / 1000.0));  }  
Magic Number,IdSharp.AudioInfo,MonkeysAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\MonkeysAudio\MonkeysAudio.cs,MonkeysAudio,The following statement contains a magic number: if (_version >= 3980 && _version <= 3990) {  	buf = stream.Read (4);  	int descriptorLength = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  	stream.Seek (descriptorLength - 12' SeekOrigin.Current);  	// skip DESCRIPTOR  	buf = stream.Read (4);  	_compressionLevel = buf [0] + (buf [1] << 8);  	blocksPerFrame = stream.ReadInt32LittleEndian ();  	finalBlocks = stream.ReadInt32LittleEndian ();  	_frames = stream.ReadInt32LittleEndian ();  	buf = stream.Read (4);  	// skip bits per sample  	_channels = buf [2] + (buf [3] << 8);  	_frequency = stream.ReadInt32LittleEndian ();  } else if (_version <= 3970) {  	// TODO: This section needs work  	_compressionLevel = buf [2] + (buf [3] << 8);  	buf = stream.Read (24);  	// skip format flags  	_channels = buf [2] + (buf [3] << 8);  	_frequency = buf [4] + (buf [5] << 8) + (buf [6] << 16) + (buf [7] << 32);  	if (_version >= 3950)  		blocksPerFrame = 73728 * 4;  	else if (_version >= 3900 || (_version >= 3800 && _compressionLevel == COMPRESSION_LEVEL_EXTRA_HIGH))  		blocksPerFrame = 73728;  	else  		blocksPerFrame = 9216;  	// TODO: This is definitely fucked up  	finalBlocks = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  	_frames = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  } else {  	throw new NotImplementedException (string.Format ("MAC {0:0.00} not supported"' _version / 1000.0));  }  
Magic Number,IdSharp.AudioInfo,MonkeysAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\MonkeysAudio\MonkeysAudio.cs,MonkeysAudio,The following statement contains a magic number: if (_version >= 3980 && _version <= 3990) {  	buf = stream.Read (4);  	int descriptorLength = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  	stream.Seek (descriptorLength - 12' SeekOrigin.Current);  	// skip DESCRIPTOR  	buf = stream.Read (4);  	_compressionLevel = buf [0] + (buf [1] << 8);  	blocksPerFrame = stream.ReadInt32LittleEndian ();  	finalBlocks = stream.ReadInt32LittleEndian ();  	_frames = stream.ReadInt32LittleEndian ();  	buf = stream.Read (4);  	// skip bits per sample  	_channels = buf [2] + (buf [3] << 8);  	_frequency = stream.ReadInt32LittleEndian ();  } else if (_version <= 3970) {  	// TODO: This section needs work  	_compressionLevel = buf [2] + (buf [3] << 8);  	buf = stream.Read (24);  	// skip format flags  	_channels = buf [2] + (buf [3] << 8);  	_frequency = buf [4] + (buf [5] << 8) + (buf [6] << 16) + (buf [7] << 32);  	if (_version >= 3950)  		blocksPerFrame = 73728 * 4;  	else if (_version >= 3900 || (_version >= 3800 && _compressionLevel == COMPRESSION_LEVEL_EXTRA_HIGH))  		blocksPerFrame = 73728;  	else  		blocksPerFrame = 9216;  	// TODO: This is definitely fucked up  	finalBlocks = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  	_frames = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  } else {  	throw new NotImplementedException (string.Format ("MAC {0:0.00} not supported"' _version / 1000.0));  }  
Magic Number,IdSharp.AudioInfo,MonkeysAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\MonkeysAudio\MonkeysAudio.cs,MonkeysAudio,The following statement contains a magic number: if (_version >= 3980 && _version <= 3990) {  	buf = stream.Read (4);  	int descriptorLength = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  	stream.Seek (descriptorLength - 12' SeekOrigin.Current);  	// skip DESCRIPTOR  	buf = stream.Read (4);  	_compressionLevel = buf [0] + (buf [1] << 8);  	blocksPerFrame = stream.ReadInt32LittleEndian ();  	finalBlocks = stream.ReadInt32LittleEndian ();  	_frames = stream.ReadInt32LittleEndian ();  	buf = stream.Read (4);  	// skip bits per sample  	_channels = buf [2] + (buf [3] << 8);  	_frequency = stream.ReadInt32LittleEndian ();  } else if (_version <= 3970) {  	// TODO: This section needs work  	_compressionLevel = buf [2] + (buf [3] << 8);  	buf = stream.Read (24);  	// skip format flags  	_channels = buf [2] + (buf [3] << 8);  	_frequency = buf [4] + (buf [5] << 8) + (buf [6] << 16) + (buf [7] << 32);  	if (_version >= 3950)  		blocksPerFrame = 73728 * 4;  	else if (_version >= 3900 || (_version >= 3800 && _compressionLevel == COMPRESSION_LEVEL_EXTRA_HIGH))  		blocksPerFrame = 73728;  	else  		blocksPerFrame = 9216;  	// TODO: This is definitely fucked up  	finalBlocks = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  	_frames = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  } else {  	throw new NotImplementedException (string.Format ("MAC {0:0.00} not supported"' _version / 1000.0));  }  
Magic Number,IdSharp.AudioInfo,MonkeysAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\MonkeysAudio\MonkeysAudio.cs,MonkeysAudio,The following statement contains a magic number: if (_version >= 3980 && _version <= 3990) {  	buf = stream.Read (4);  	int descriptorLength = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  	stream.Seek (descriptorLength - 12' SeekOrigin.Current);  	// skip DESCRIPTOR  	buf = stream.Read (4);  	_compressionLevel = buf [0] + (buf [1] << 8);  	blocksPerFrame = stream.ReadInt32LittleEndian ();  	finalBlocks = stream.ReadInt32LittleEndian ();  	_frames = stream.ReadInt32LittleEndian ();  	buf = stream.Read (4);  	// skip bits per sample  	_channels = buf [2] + (buf [3] << 8);  	_frequency = stream.ReadInt32LittleEndian ();  } else if (_version <= 3970) {  	// TODO: This section needs work  	_compressionLevel = buf [2] + (buf [3] << 8);  	buf = stream.Read (24);  	// skip format flags  	_channels = buf [2] + (buf [3] << 8);  	_frequency = buf [4] + (buf [5] << 8) + (buf [6] << 16) + (buf [7] << 32);  	if (_version >= 3950)  		blocksPerFrame = 73728 * 4;  	else if (_version >= 3900 || (_version >= 3800 && _compressionLevel == COMPRESSION_LEVEL_EXTRA_HIGH))  		blocksPerFrame = 73728;  	else  		blocksPerFrame = 9216;  	// TODO: This is definitely fucked up  	finalBlocks = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  	_frames = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  } else {  	throw new NotImplementedException (string.Format ("MAC {0:0.00} not supported"' _version / 1000.0));  }  
Magic Number,IdSharp.AudioInfo,MonkeysAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\MonkeysAudio\MonkeysAudio.cs,MonkeysAudio,The following statement contains a magic number: if (_version >= 3980 && _version <= 3990) {  	buf = stream.Read (4);  	int descriptorLength = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  	stream.Seek (descriptorLength - 12' SeekOrigin.Current);  	// skip DESCRIPTOR  	buf = stream.Read (4);  	_compressionLevel = buf [0] + (buf [1] << 8);  	blocksPerFrame = stream.ReadInt32LittleEndian ();  	finalBlocks = stream.ReadInt32LittleEndian ();  	_frames = stream.ReadInt32LittleEndian ();  	buf = stream.Read (4);  	// skip bits per sample  	_channels = buf [2] + (buf [3] << 8);  	_frequency = stream.ReadInt32LittleEndian ();  } else if (_version <= 3970) {  	// TODO: This section needs work  	_compressionLevel = buf [2] + (buf [3] << 8);  	buf = stream.Read (24);  	// skip format flags  	_channels = buf [2] + (buf [3] << 8);  	_frequency = buf [4] + (buf [5] << 8) + (buf [6] << 16) + (buf [7] << 32);  	if (_version >= 3950)  		blocksPerFrame = 73728 * 4;  	else if (_version >= 3900 || (_version >= 3800 && _compressionLevel == COMPRESSION_LEVEL_EXTRA_HIGH))  		blocksPerFrame = 73728;  	else  		blocksPerFrame = 9216;  	// TODO: This is definitely fucked up  	finalBlocks = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  	_frames = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  } else {  	throw new NotImplementedException (string.Format ("MAC {0:0.00} not supported"' _version / 1000.0));  }  
Magic Number,IdSharp.AudioInfo,MonkeysAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\MonkeysAudio\MonkeysAudio.cs,MonkeysAudio,The following statement contains a magic number: if (_version >= 3980 && _version <= 3990) {  	buf = stream.Read (4);  	int descriptorLength = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  	stream.Seek (descriptorLength - 12' SeekOrigin.Current);  	// skip DESCRIPTOR  	buf = stream.Read (4);  	_compressionLevel = buf [0] + (buf [1] << 8);  	blocksPerFrame = stream.ReadInt32LittleEndian ();  	finalBlocks = stream.ReadInt32LittleEndian ();  	_frames = stream.ReadInt32LittleEndian ();  	buf = stream.Read (4);  	// skip bits per sample  	_channels = buf [2] + (buf [3] << 8);  	_frequency = stream.ReadInt32LittleEndian ();  } else if (_version <= 3970) {  	// TODO: This section needs work  	_compressionLevel = buf [2] + (buf [3] << 8);  	buf = stream.Read (24);  	// skip format flags  	_channels = buf [2] + (buf [3] << 8);  	_frequency = buf [4] + (buf [5] << 8) + (buf [6] << 16) + (buf [7] << 32);  	if (_version >= 3950)  		blocksPerFrame = 73728 * 4;  	else if (_version >= 3900 || (_version >= 3800 && _compressionLevel == COMPRESSION_LEVEL_EXTRA_HIGH))  		blocksPerFrame = 73728;  	else  		blocksPerFrame = 9216;  	// TODO: This is definitely fucked up  	finalBlocks = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  	_frames = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  } else {  	throw new NotImplementedException (string.Format ("MAC {0:0.00} not supported"' _version / 1000.0));  }  
Magic Number,IdSharp.AudioInfo,MonkeysAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\MonkeysAudio\MonkeysAudio.cs,MonkeysAudio,The following statement contains a magic number: if (_version >= 3980 && _version <= 3990) {  	buf = stream.Read (4);  	int descriptorLength = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  	stream.Seek (descriptorLength - 12' SeekOrigin.Current);  	// skip DESCRIPTOR  	buf = stream.Read (4);  	_compressionLevel = buf [0] + (buf [1] << 8);  	blocksPerFrame = stream.ReadInt32LittleEndian ();  	finalBlocks = stream.ReadInt32LittleEndian ();  	_frames = stream.ReadInt32LittleEndian ();  	buf = stream.Read (4);  	// skip bits per sample  	_channels = buf [2] + (buf [3] << 8);  	_frequency = stream.ReadInt32LittleEndian ();  } else if (_version <= 3970) {  	// TODO: This section needs work  	_compressionLevel = buf [2] + (buf [3] << 8);  	buf = stream.Read (24);  	// skip format flags  	_channels = buf [2] + (buf [3] << 8);  	_frequency = buf [4] + (buf [5] << 8) + (buf [6] << 16) + (buf [7] << 32);  	if (_version >= 3950)  		blocksPerFrame = 73728 * 4;  	else if (_version >= 3900 || (_version >= 3800 && _compressionLevel == COMPRESSION_LEVEL_EXTRA_HIGH))  		blocksPerFrame = 73728;  	else  		blocksPerFrame = 9216;  	// TODO: This is definitely fucked up  	finalBlocks = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  	_frames = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  } else {  	throw new NotImplementedException (string.Format ("MAC {0:0.00} not supported"' _version / 1000.0));  }  
Magic Number,IdSharp.AudioInfo,MonkeysAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\MonkeysAudio\MonkeysAudio.cs,MonkeysAudio,The following statement contains a magic number: if (_version >= 3980 && _version <= 3990) {  	buf = stream.Read (4);  	int descriptorLength = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  	stream.Seek (descriptorLength - 12' SeekOrigin.Current);  	// skip DESCRIPTOR  	buf = stream.Read (4);  	_compressionLevel = buf [0] + (buf [1] << 8);  	blocksPerFrame = stream.ReadInt32LittleEndian ();  	finalBlocks = stream.ReadInt32LittleEndian ();  	_frames = stream.ReadInt32LittleEndian ();  	buf = stream.Read (4);  	// skip bits per sample  	_channels = buf [2] + (buf [3] << 8);  	_frequency = stream.ReadInt32LittleEndian ();  } else if (_version <= 3970) {  	// TODO: This section needs work  	_compressionLevel = buf [2] + (buf [3] << 8);  	buf = stream.Read (24);  	// skip format flags  	_channels = buf [2] + (buf [3] << 8);  	_frequency = buf [4] + (buf [5] << 8) + (buf [6] << 16) + (buf [7] << 32);  	if (_version >= 3950)  		blocksPerFrame = 73728 * 4;  	else if (_version >= 3900 || (_version >= 3800 && _compressionLevel == COMPRESSION_LEVEL_EXTRA_HIGH))  		blocksPerFrame = 73728;  	else  		blocksPerFrame = 9216;  	// TODO: This is definitely fucked up  	finalBlocks = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  	_frames = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  } else {  	throw new NotImplementedException (string.Format ("MAC {0:0.00} not supported"' _version / 1000.0));  }  
Magic Number,IdSharp.AudioInfo,MonkeysAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\MonkeysAudio\MonkeysAudio.cs,MonkeysAudio,The following statement contains a magic number: if (_version >= 3980 && _version <= 3990) {  	buf = stream.Read (4);  	int descriptorLength = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  	stream.Seek (descriptorLength - 12' SeekOrigin.Current);  	// skip DESCRIPTOR  	buf = stream.Read (4);  	_compressionLevel = buf [0] + (buf [1] << 8);  	blocksPerFrame = stream.ReadInt32LittleEndian ();  	finalBlocks = stream.ReadInt32LittleEndian ();  	_frames = stream.ReadInt32LittleEndian ();  	buf = stream.Read (4);  	// skip bits per sample  	_channels = buf [2] + (buf [3] << 8);  	_frequency = stream.ReadInt32LittleEndian ();  } else if (_version <= 3970) {  	// TODO: This section needs work  	_compressionLevel = buf [2] + (buf [3] << 8);  	buf = stream.Read (24);  	// skip format flags  	_channels = buf [2] + (buf [3] << 8);  	_frequency = buf [4] + (buf [5] << 8) + (buf [6] << 16) + (buf [7] << 32);  	if (_version >= 3950)  		blocksPerFrame = 73728 * 4;  	else if (_version >= 3900 || (_version >= 3800 && _compressionLevel == COMPRESSION_LEVEL_EXTRA_HIGH))  		blocksPerFrame = 73728;  	else  		blocksPerFrame = 9216;  	// TODO: This is definitely fucked up  	finalBlocks = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  	_frames = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  } else {  	throw new NotImplementedException (string.Format ("MAC {0:0.00} not supported"' _version / 1000.0));  }  
Magic Number,IdSharp.AudioInfo,MonkeysAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\MonkeysAudio\MonkeysAudio.cs,MonkeysAudio,The following statement contains a magic number: if (_version >= 3980 && _version <= 3990) {  	buf = stream.Read (4);  	int descriptorLength = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  	stream.Seek (descriptorLength - 12' SeekOrigin.Current);  	// skip DESCRIPTOR  	buf = stream.Read (4);  	_compressionLevel = buf [0] + (buf [1] << 8);  	blocksPerFrame = stream.ReadInt32LittleEndian ();  	finalBlocks = stream.ReadInt32LittleEndian ();  	_frames = stream.ReadInt32LittleEndian ();  	buf = stream.Read (4);  	// skip bits per sample  	_channels = buf [2] + (buf [3] << 8);  	_frequency = stream.ReadInt32LittleEndian ();  } else if (_version <= 3970) {  	// TODO: This section needs work  	_compressionLevel = buf [2] + (buf [3] << 8);  	buf = stream.Read (24);  	// skip format flags  	_channels = buf [2] + (buf [3] << 8);  	_frequency = buf [4] + (buf [5] << 8) + (buf [6] << 16) + (buf [7] << 32);  	if (_version >= 3950)  		blocksPerFrame = 73728 * 4;  	else if (_version >= 3900 || (_version >= 3800 && _compressionLevel == COMPRESSION_LEVEL_EXTRA_HIGH))  		blocksPerFrame = 73728;  	else  		blocksPerFrame = 9216;  	// TODO: This is definitely fucked up  	finalBlocks = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  	_frames = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  } else {  	throw new NotImplementedException (string.Format ("MAC {0:0.00} not supported"' _version / 1000.0));  }  
Magic Number,IdSharp.AudioInfo,MonkeysAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\MonkeysAudio\MonkeysAudio.cs,MonkeysAudio,The following statement contains a magic number: if (_version >= 3980 && _version <= 3990) {  	buf = stream.Read (4);  	int descriptorLength = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  	stream.Seek (descriptorLength - 12' SeekOrigin.Current);  	// skip DESCRIPTOR  	buf = stream.Read (4);  	_compressionLevel = buf [0] + (buf [1] << 8);  	blocksPerFrame = stream.ReadInt32LittleEndian ();  	finalBlocks = stream.ReadInt32LittleEndian ();  	_frames = stream.ReadInt32LittleEndian ();  	buf = stream.Read (4);  	// skip bits per sample  	_channels = buf [2] + (buf [3] << 8);  	_frequency = stream.ReadInt32LittleEndian ();  } else if (_version <= 3970) {  	// TODO: This section needs work  	_compressionLevel = buf [2] + (buf [3] << 8);  	buf = stream.Read (24);  	// skip format flags  	_channels = buf [2] + (buf [3] << 8);  	_frequency = buf [4] + (buf [5] << 8) + (buf [6] << 16) + (buf [7] << 32);  	if (_version >= 3950)  		blocksPerFrame = 73728 * 4;  	else if (_version >= 3900 || (_version >= 3800 && _compressionLevel == COMPRESSION_LEVEL_EXTRA_HIGH))  		blocksPerFrame = 73728;  	else  		blocksPerFrame = 9216;  	// TODO: This is definitely fucked up  	finalBlocks = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  	_frames = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  } else {  	throw new NotImplementedException (string.Format ("MAC {0:0.00} not supported"' _version / 1000.0));  }  
Magic Number,IdSharp.AudioInfo,MonkeysAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\MonkeysAudio\MonkeysAudio.cs,MonkeysAudio,The following statement contains a magic number: buf = stream.Read (4);  
Magic Number,IdSharp.AudioInfo,MonkeysAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\MonkeysAudio\MonkeysAudio.cs,MonkeysAudio,The following statement contains a magic number: stream.Seek (descriptorLength - 12' SeekOrigin.Current);  
Magic Number,IdSharp.AudioInfo,MonkeysAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\MonkeysAudio\MonkeysAudio.cs,MonkeysAudio,The following statement contains a magic number: buf = stream.Read (4);  
Magic Number,IdSharp.AudioInfo,MonkeysAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\MonkeysAudio\MonkeysAudio.cs,MonkeysAudio,The following statement contains a magic number: _compressionLevel = buf [0] + (buf [1] << 8);  
Magic Number,IdSharp.AudioInfo,MonkeysAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\MonkeysAudio\MonkeysAudio.cs,MonkeysAudio,The following statement contains a magic number: buf = stream.Read (4);  
Magic Number,IdSharp.AudioInfo,MonkeysAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\MonkeysAudio\MonkeysAudio.cs,MonkeysAudio,The following statement contains a magic number: _channels = buf [2] + (buf [3] << 8);  
Magic Number,IdSharp.AudioInfo,MonkeysAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\MonkeysAudio\MonkeysAudio.cs,MonkeysAudio,The following statement contains a magic number: _channels = buf [2] + (buf [3] << 8);  
Magic Number,IdSharp.AudioInfo,MonkeysAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\MonkeysAudio\MonkeysAudio.cs,MonkeysAudio,The following statement contains a magic number: _channels = buf [2] + (buf [3] << 8);  
Magic Number,IdSharp.AudioInfo,MonkeysAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\MonkeysAudio\MonkeysAudio.cs,MonkeysAudio,The following statement contains a magic number: if (_version <= 3970) {  	// TODO: This section needs work  	_compressionLevel = buf [2] + (buf [3] << 8);  	buf = stream.Read (24);  	// skip format flags  	_channels = buf [2] + (buf [3] << 8);  	_frequency = buf [4] + (buf [5] << 8) + (buf [6] << 16) + (buf [7] << 32);  	if (_version >= 3950)  		blocksPerFrame = 73728 * 4;  	else if (_version >= 3900 || (_version >= 3800 && _compressionLevel == COMPRESSION_LEVEL_EXTRA_HIGH))  		blocksPerFrame = 73728;  	else  		blocksPerFrame = 9216;  	// TODO: This is definitely fucked up  	finalBlocks = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  	_frames = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  } else {  	throw new NotImplementedException (string.Format ("MAC {0:0.00} not supported"' _version / 1000.0));  }  
Magic Number,IdSharp.AudioInfo,MonkeysAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\MonkeysAudio\MonkeysAudio.cs,MonkeysAudio,The following statement contains a magic number: if (_version <= 3970) {  	// TODO: This section needs work  	_compressionLevel = buf [2] + (buf [3] << 8);  	buf = stream.Read (24);  	// skip format flags  	_channels = buf [2] + (buf [3] << 8);  	_frequency = buf [4] + (buf [5] << 8) + (buf [6] << 16) + (buf [7] << 32);  	if (_version >= 3950)  		blocksPerFrame = 73728 * 4;  	else if (_version >= 3900 || (_version >= 3800 && _compressionLevel == COMPRESSION_LEVEL_EXTRA_HIGH))  		blocksPerFrame = 73728;  	else  		blocksPerFrame = 9216;  	// TODO: This is definitely fucked up  	finalBlocks = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  	_frames = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  } else {  	throw new NotImplementedException (string.Format ("MAC {0:0.00} not supported"' _version / 1000.0));  }  
Magic Number,IdSharp.AudioInfo,MonkeysAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\MonkeysAudio\MonkeysAudio.cs,MonkeysAudio,The following statement contains a magic number: if (_version <= 3970) {  	// TODO: This section needs work  	_compressionLevel = buf [2] + (buf [3] << 8);  	buf = stream.Read (24);  	// skip format flags  	_channels = buf [2] + (buf [3] << 8);  	_frequency = buf [4] + (buf [5] << 8) + (buf [6] << 16) + (buf [7] << 32);  	if (_version >= 3950)  		blocksPerFrame = 73728 * 4;  	else if (_version >= 3900 || (_version >= 3800 && _compressionLevel == COMPRESSION_LEVEL_EXTRA_HIGH))  		blocksPerFrame = 73728;  	else  		blocksPerFrame = 9216;  	// TODO: This is definitely fucked up  	finalBlocks = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  	_frames = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  } else {  	throw new NotImplementedException (string.Format ("MAC {0:0.00} not supported"' _version / 1000.0));  }  
Magic Number,IdSharp.AudioInfo,MonkeysAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\MonkeysAudio\MonkeysAudio.cs,MonkeysAudio,The following statement contains a magic number: if (_version <= 3970) {  	// TODO: This section needs work  	_compressionLevel = buf [2] + (buf [3] << 8);  	buf = stream.Read (24);  	// skip format flags  	_channels = buf [2] + (buf [3] << 8);  	_frequency = buf [4] + (buf [5] << 8) + (buf [6] << 16) + (buf [7] << 32);  	if (_version >= 3950)  		blocksPerFrame = 73728 * 4;  	else if (_version >= 3900 || (_version >= 3800 && _compressionLevel == COMPRESSION_LEVEL_EXTRA_HIGH))  		blocksPerFrame = 73728;  	else  		blocksPerFrame = 9216;  	// TODO: This is definitely fucked up  	finalBlocks = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  	_frames = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  } else {  	throw new NotImplementedException (string.Format ("MAC {0:0.00} not supported"' _version / 1000.0));  }  
Magic Number,IdSharp.AudioInfo,MonkeysAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\MonkeysAudio\MonkeysAudio.cs,MonkeysAudio,The following statement contains a magic number: if (_version <= 3970) {  	// TODO: This section needs work  	_compressionLevel = buf [2] + (buf [3] << 8);  	buf = stream.Read (24);  	// skip format flags  	_channels = buf [2] + (buf [3] << 8);  	_frequency = buf [4] + (buf [5] << 8) + (buf [6] << 16) + (buf [7] << 32);  	if (_version >= 3950)  		blocksPerFrame = 73728 * 4;  	else if (_version >= 3900 || (_version >= 3800 && _compressionLevel == COMPRESSION_LEVEL_EXTRA_HIGH))  		blocksPerFrame = 73728;  	else  		blocksPerFrame = 9216;  	// TODO: This is definitely fucked up  	finalBlocks = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  	_frames = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  } else {  	throw new NotImplementedException (string.Format ("MAC {0:0.00} not supported"' _version / 1000.0));  }  
Magic Number,IdSharp.AudioInfo,MonkeysAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\MonkeysAudio\MonkeysAudio.cs,MonkeysAudio,The following statement contains a magic number: if (_version <= 3970) {  	// TODO: This section needs work  	_compressionLevel = buf [2] + (buf [3] << 8);  	buf = stream.Read (24);  	// skip format flags  	_channels = buf [2] + (buf [3] << 8);  	_frequency = buf [4] + (buf [5] << 8) + (buf [6] << 16) + (buf [7] << 32);  	if (_version >= 3950)  		blocksPerFrame = 73728 * 4;  	else if (_version >= 3900 || (_version >= 3800 && _compressionLevel == COMPRESSION_LEVEL_EXTRA_HIGH))  		blocksPerFrame = 73728;  	else  		blocksPerFrame = 9216;  	// TODO: This is definitely fucked up  	finalBlocks = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  	_frames = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  } else {  	throw new NotImplementedException (string.Format ("MAC {0:0.00} not supported"' _version / 1000.0));  }  
Magic Number,IdSharp.AudioInfo,MonkeysAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\MonkeysAudio\MonkeysAudio.cs,MonkeysAudio,The following statement contains a magic number: if (_version <= 3970) {  	// TODO: This section needs work  	_compressionLevel = buf [2] + (buf [3] << 8);  	buf = stream.Read (24);  	// skip format flags  	_channels = buf [2] + (buf [3] << 8);  	_frequency = buf [4] + (buf [5] << 8) + (buf [6] << 16) + (buf [7] << 32);  	if (_version >= 3950)  		blocksPerFrame = 73728 * 4;  	else if (_version >= 3900 || (_version >= 3800 && _compressionLevel == COMPRESSION_LEVEL_EXTRA_HIGH))  		blocksPerFrame = 73728;  	else  		blocksPerFrame = 9216;  	// TODO: This is definitely fucked up  	finalBlocks = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  	_frames = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  } else {  	throw new NotImplementedException (string.Format ("MAC {0:0.00} not supported"' _version / 1000.0));  }  
Magic Number,IdSharp.AudioInfo,MonkeysAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\MonkeysAudio\MonkeysAudio.cs,MonkeysAudio,The following statement contains a magic number: if (_version <= 3970) {  	// TODO: This section needs work  	_compressionLevel = buf [2] + (buf [3] << 8);  	buf = stream.Read (24);  	// skip format flags  	_channels = buf [2] + (buf [3] << 8);  	_frequency = buf [4] + (buf [5] << 8) + (buf [6] << 16) + (buf [7] << 32);  	if (_version >= 3950)  		blocksPerFrame = 73728 * 4;  	else if (_version >= 3900 || (_version >= 3800 && _compressionLevel == COMPRESSION_LEVEL_EXTRA_HIGH))  		blocksPerFrame = 73728;  	else  		blocksPerFrame = 9216;  	// TODO: This is definitely fucked up  	finalBlocks = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  	_frames = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  } else {  	throw new NotImplementedException (string.Format ("MAC {0:0.00} not supported"' _version / 1000.0));  }  
Magic Number,IdSharp.AudioInfo,MonkeysAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\MonkeysAudio\MonkeysAudio.cs,MonkeysAudio,The following statement contains a magic number: if (_version <= 3970) {  	// TODO: This section needs work  	_compressionLevel = buf [2] + (buf [3] << 8);  	buf = stream.Read (24);  	// skip format flags  	_channels = buf [2] + (buf [3] << 8);  	_frequency = buf [4] + (buf [5] << 8) + (buf [6] << 16) + (buf [7] << 32);  	if (_version >= 3950)  		blocksPerFrame = 73728 * 4;  	else if (_version >= 3900 || (_version >= 3800 && _compressionLevel == COMPRESSION_LEVEL_EXTRA_HIGH))  		blocksPerFrame = 73728;  	else  		blocksPerFrame = 9216;  	// TODO: This is definitely fucked up  	finalBlocks = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  	_frames = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  } else {  	throw new NotImplementedException (string.Format ("MAC {0:0.00} not supported"' _version / 1000.0));  }  
Magic Number,IdSharp.AudioInfo,MonkeysAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\MonkeysAudio\MonkeysAudio.cs,MonkeysAudio,The following statement contains a magic number: if (_version <= 3970) {  	// TODO: This section needs work  	_compressionLevel = buf [2] + (buf [3] << 8);  	buf = stream.Read (24);  	// skip format flags  	_channels = buf [2] + (buf [3] << 8);  	_frequency = buf [4] + (buf [5] << 8) + (buf [6] << 16) + (buf [7] << 32);  	if (_version >= 3950)  		blocksPerFrame = 73728 * 4;  	else if (_version >= 3900 || (_version >= 3800 && _compressionLevel == COMPRESSION_LEVEL_EXTRA_HIGH))  		blocksPerFrame = 73728;  	else  		blocksPerFrame = 9216;  	// TODO: This is definitely fucked up  	finalBlocks = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  	_frames = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  } else {  	throw new NotImplementedException (string.Format ("MAC {0:0.00} not supported"' _version / 1000.0));  }  
Magic Number,IdSharp.AudioInfo,MonkeysAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\MonkeysAudio\MonkeysAudio.cs,MonkeysAudio,The following statement contains a magic number: if (_version <= 3970) {  	// TODO: This section needs work  	_compressionLevel = buf [2] + (buf [3] << 8);  	buf = stream.Read (24);  	// skip format flags  	_channels = buf [2] + (buf [3] << 8);  	_frequency = buf [4] + (buf [5] << 8) + (buf [6] << 16) + (buf [7] << 32);  	if (_version >= 3950)  		blocksPerFrame = 73728 * 4;  	else if (_version >= 3900 || (_version >= 3800 && _compressionLevel == COMPRESSION_LEVEL_EXTRA_HIGH))  		blocksPerFrame = 73728;  	else  		blocksPerFrame = 9216;  	// TODO: This is definitely fucked up  	finalBlocks = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  	_frames = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  } else {  	throw new NotImplementedException (string.Format ("MAC {0:0.00} not supported"' _version / 1000.0));  }  
Magic Number,IdSharp.AudioInfo,MonkeysAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\MonkeysAudio\MonkeysAudio.cs,MonkeysAudio,The following statement contains a magic number: if (_version <= 3970) {  	// TODO: This section needs work  	_compressionLevel = buf [2] + (buf [3] << 8);  	buf = stream.Read (24);  	// skip format flags  	_channels = buf [2] + (buf [3] << 8);  	_frequency = buf [4] + (buf [5] << 8) + (buf [6] << 16) + (buf [7] << 32);  	if (_version >= 3950)  		blocksPerFrame = 73728 * 4;  	else if (_version >= 3900 || (_version >= 3800 && _compressionLevel == COMPRESSION_LEVEL_EXTRA_HIGH))  		blocksPerFrame = 73728;  	else  		blocksPerFrame = 9216;  	// TODO: This is definitely fucked up  	finalBlocks = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  	_frames = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  } else {  	throw new NotImplementedException (string.Format ("MAC {0:0.00} not supported"' _version / 1000.0));  }  
Magic Number,IdSharp.AudioInfo,MonkeysAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\MonkeysAudio\MonkeysAudio.cs,MonkeysAudio,The following statement contains a magic number: if (_version <= 3970) {  	// TODO: This section needs work  	_compressionLevel = buf [2] + (buf [3] << 8);  	buf = stream.Read (24);  	// skip format flags  	_channels = buf [2] + (buf [3] << 8);  	_frequency = buf [4] + (buf [5] << 8) + (buf [6] << 16) + (buf [7] << 32);  	if (_version >= 3950)  		blocksPerFrame = 73728 * 4;  	else if (_version >= 3900 || (_version >= 3800 && _compressionLevel == COMPRESSION_LEVEL_EXTRA_HIGH))  		blocksPerFrame = 73728;  	else  		blocksPerFrame = 9216;  	// TODO: This is definitely fucked up  	finalBlocks = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  	_frames = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  } else {  	throw new NotImplementedException (string.Format ("MAC {0:0.00} not supported"' _version / 1000.0));  }  
Magic Number,IdSharp.AudioInfo,MonkeysAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\MonkeysAudio\MonkeysAudio.cs,MonkeysAudio,The following statement contains a magic number: if (_version <= 3970) {  	// TODO: This section needs work  	_compressionLevel = buf [2] + (buf [3] << 8);  	buf = stream.Read (24);  	// skip format flags  	_channels = buf [2] + (buf [3] << 8);  	_frequency = buf [4] + (buf [5] << 8) + (buf [6] << 16) + (buf [7] << 32);  	if (_version >= 3950)  		blocksPerFrame = 73728 * 4;  	else if (_version >= 3900 || (_version >= 3800 && _compressionLevel == COMPRESSION_LEVEL_EXTRA_HIGH))  		blocksPerFrame = 73728;  	else  		blocksPerFrame = 9216;  	// TODO: This is definitely fucked up  	finalBlocks = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  	_frames = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  } else {  	throw new NotImplementedException (string.Format ("MAC {0:0.00} not supported"' _version / 1000.0));  }  
Magic Number,IdSharp.AudioInfo,MonkeysAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\MonkeysAudio\MonkeysAudio.cs,MonkeysAudio,The following statement contains a magic number: if (_version <= 3970) {  	// TODO: This section needs work  	_compressionLevel = buf [2] + (buf [3] << 8);  	buf = stream.Read (24);  	// skip format flags  	_channels = buf [2] + (buf [3] << 8);  	_frequency = buf [4] + (buf [5] << 8) + (buf [6] << 16) + (buf [7] << 32);  	if (_version >= 3950)  		blocksPerFrame = 73728 * 4;  	else if (_version >= 3900 || (_version >= 3800 && _compressionLevel == COMPRESSION_LEVEL_EXTRA_HIGH))  		blocksPerFrame = 73728;  	else  		blocksPerFrame = 9216;  	// TODO: This is definitely fucked up  	finalBlocks = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  	_frames = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  } else {  	throw new NotImplementedException (string.Format ("MAC {0:0.00} not supported"' _version / 1000.0));  }  
Magic Number,IdSharp.AudioInfo,MonkeysAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\MonkeysAudio\MonkeysAudio.cs,MonkeysAudio,The following statement contains a magic number: if (_version <= 3970) {  	// TODO: This section needs work  	_compressionLevel = buf [2] + (buf [3] << 8);  	buf = stream.Read (24);  	// skip format flags  	_channels = buf [2] + (buf [3] << 8);  	_frequency = buf [4] + (buf [5] << 8) + (buf [6] << 16) + (buf [7] << 32);  	if (_version >= 3950)  		blocksPerFrame = 73728 * 4;  	else if (_version >= 3900 || (_version >= 3800 && _compressionLevel == COMPRESSION_LEVEL_EXTRA_HIGH))  		blocksPerFrame = 73728;  	else  		blocksPerFrame = 9216;  	// TODO: This is definitely fucked up  	finalBlocks = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  	_frames = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  } else {  	throw new NotImplementedException (string.Format ("MAC {0:0.00} not supported"' _version / 1000.0));  }  
Magic Number,IdSharp.AudioInfo,MonkeysAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\MonkeysAudio\MonkeysAudio.cs,MonkeysAudio,The following statement contains a magic number: if (_version <= 3970) {  	// TODO: This section needs work  	_compressionLevel = buf [2] + (buf [3] << 8);  	buf = stream.Read (24);  	// skip format flags  	_channels = buf [2] + (buf [3] << 8);  	_frequency = buf [4] + (buf [5] << 8) + (buf [6] << 16) + (buf [7] << 32);  	if (_version >= 3950)  		blocksPerFrame = 73728 * 4;  	else if (_version >= 3900 || (_version >= 3800 && _compressionLevel == COMPRESSION_LEVEL_EXTRA_HIGH))  		blocksPerFrame = 73728;  	else  		blocksPerFrame = 9216;  	// TODO: This is definitely fucked up  	finalBlocks = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  	_frames = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  } else {  	throw new NotImplementedException (string.Format ("MAC {0:0.00} not supported"' _version / 1000.0));  }  
Magic Number,IdSharp.AudioInfo,MonkeysAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\MonkeysAudio\MonkeysAudio.cs,MonkeysAudio,The following statement contains a magic number: if (_version <= 3970) {  	// TODO: This section needs work  	_compressionLevel = buf [2] + (buf [3] << 8);  	buf = stream.Read (24);  	// skip format flags  	_channels = buf [2] + (buf [3] << 8);  	_frequency = buf [4] + (buf [5] << 8) + (buf [6] << 16) + (buf [7] << 32);  	if (_version >= 3950)  		blocksPerFrame = 73728 * 4;  	else if (_version >= 3900 || (_version >= 3800 && _compressionLevel == COMPRESSION_LEVEL_EXTRA_HIGH))  		blocksPerFrame = 73728;  	else  		blocksPerFrame = 9216;  	// TODO: This is definitely fucked up  	finalBlocks = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  	_frames = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  } else {  	throw new NotImplementedException (string.Format ("MAC {0:0.00} not supported"' _version / 1000.0));  }  
Magic Number,IdSharp.AudioInfo,MonkeysAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\MonkeysAudio\MonkeysAudio.cs,MonkeysAudio,The following statement contains a magic number: if (_version <= 3970) {  	// TODO: This section needs work  	_compressionLevel = buf [2] + (buf [3] << 8);  	buf = stream.Read (24);  	// skip format flags  	_channels = buf [2] + (buf [3] << 8);  	_frequency = buf [4] + (buf [5] << 8) + (buf [6] << 16) + (buf [7] << 32);  	if (_version >= 3950)  		blocksPerFrame = 73728 * 4;  	else if (_version >= 3900 || (_version >= 3800 && _compressionLevel == COMPRESSION_LEVEL_EXTRA_HIGH))  		blocksPerFrame = 73728;  	else  		blocksPerFrame = 9216;  	// TODO: This is definitely fucked up  	finalBlocks = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  	_frames = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  } else {  	throw new NotImplementedException (string.Format ("MAC {0:0.00} not supported"' _version / 1000.0));  }  
Magic Number,IdSharp.AudioInfo,MonkeysAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\MonkeysAudio\MonkeysAudio.cs,MonkeysAudio,The following statement contains a magic number: if (_version <= 3970) {  	// TODO: This section needs work  	_compressionLevel = buf [2] + (buf [3] << 8);  	buf = stream.Read (24);  	// skip format flags  	_channels = buf [2] + (buf [3] << 8);  	_frequency = buf [4] + (buf [5] << 8) + (buf [6] << 16) + (buf [7] << 32);  	if (_version >= 3950)  		blocksPerFrame = 73728 * 4;  	else if (_version >= 3900 || (_version >= 3800 && _compressionLevel == COMPRESSION_LEVEL_EXTRA_HIGH))  		blocksPerFrame = 73728;  	else  		blocksPerFrame = 9216;  	// TODO: This is definitely fucked up  	finalBlocks = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  	_frames = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  } else {  	throw new NotImplementedException (string.Format ("MAC {0:0.00} not supported"' _version / 1000.0));  }  
Magic Number,IdSharp.AudioInfo,MonkeysAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\MonkeysAudio\MonkeysAudio.cs,MonkeysAudio,The following statement contains a magic number: if (_version <= 3970) {  	// TODO: This section needs work  	_compressionLevel = buf [2] + (buf [3] << 8);  	buf = stream.Read (24);  	// skip format flags  	_channels = buf [2] + (buf [3] << 8);  	_frequency = buf [4] + (buf [5] << 8) + (buf [6] << 16) + (buf [7] << 32);  	if (_version >= 3950)  		blocksPerFrame = 73728 * 4;  	else if (_version >= 3900 || (_version >= 3800 && _compressionLevel == COMPRESSION_LEVEL_EXTRA_HIGH))  		blocksPerFrame = 73728;  	else  		blocksPerFrame = 9216;  	// TODO: This is definitely fucked up  	finalBlocks = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  	_frames = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  } else {  	throw new NotImplementedException (string.Format ("MAC {0:0.00} not supported"' _version / 1000.0));  }  
Magic Number,IdSharp.AudioInfo,MonkeysAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\MonkeysAudio\MonkeysAudio.cs,MonkeysAudio,The following statement contains a magic number: if (_version <= 3970) {  	// TODO: This section needs work  	_compressionLevel = buf [2] + (buf [3] << 8);  	buf = stream.Read (24);  	// skip format flags  	_channels = buf [2] + (buf [3] << 8);  	_frequency = buf [4] + (buf [5] << 8) + (buf [6] << 16) + (buf [7] << 32);  	if (_version >= 3950)  		blocksPerFrame = 73728 * 4;  	else if (_version >= 3900 || (_version >= 3800 && _compressionLevel == COMPRESSION_LEVEL_EXTRA_HIGH))  		blocksPerFrame = 73728;  	else  		blocksPerFrame = 9216;  	// TODO: This is definitely fucked up  	finalBlocks = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  	_frames = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  } else {  	throw new NotImplementedException (string.Format ("MAC {0:0.00} not supported"' _version / 1000.0));  }  
Magic Number,IdSharp.AudioInfo,MonkeysAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\MonkeysAudio\MonkeysAudio.cs,MonkeysAudio,The following statement contains a magic number: if (_version <= 3970) {  	// TODO: This section needs work  	_compressionLevel = buf [2] + (buf [3] << 8);  	buf = stream.Read (24);  	// skip format flags  	_channels = buf [2] + (buf [3] << 8);  	_frequency = buf [4] + (buf [5] << 8) + (buf [6] << 16) + (buf [7] << 32);  	if (_version >= 3950)  		blocksPerFrame = 73728 * 4;  	else if (_version >= 3900 || (_version >= 3800 && _compressionLevel == COMPRESSION_LEVEL_EXTRA_HIGH))  		blocksPerFrame = 73728;  	else  		blocksPerFrame = 9216;  	// TODO: This is definitely fucked up  	finalBlocks = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  	_frames = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  } else {  	throw new NotImplementedException (string.Format ("MAC {0:0.00} not supported"' _version / 1000.0));  }  
Magic Number,IdSharp.AudioInfo,MonkeysAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\MonkeysAudio\MonkeysAudio.cs,MonkeysAudio,The following statement contains a magic number: if (_version <= 3970) {  	// TODO: This section needs work  	_compressionLevel = buf [2] + (buf [3] << 8);  	buf = stream.Read (24);  	// skip format flags  	_channels = buf [2] + (buf [3] << 8);  	_frequency = buf [4] + (buf [5] << 8) + (buf [6] << 16) + (buf [7] << 32);  	if (_version >= 3950)  		blocksPerFrame = 73728 * 4;  	else if (_version >= 3900 || (_version >= 3800 && _compressionLevel == COMPRESSION_LEVEL_EXTRA_HIGH))  		blocksPerFrame = 73728;  	else  		blocksPerFrame = 9216;  	// TODO: This is definitely fucked up  	finalBlocks = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  	_frames = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  } else {  	throw new NotImplementedException (string.Format ("MAC {0:0.00} not supported"' _version / 1000.0));  }  
Magic Number,IdSharp.AudioInfo,MonkeysAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\MonkeysAudio\MonkeysAudio.cs,MonkeysAudio,The following statement contains a magic number: if (_version <= 3970) {  	// TODO: This section needs work  	_compressionLevel = buf [2] + (buf [3] << 8);  	buf = stream.Read (24);  	// skip format flags  	_channels = buf [2] + (buf [3] << 8);  	_frequency = buf [4] + (buf [5] << 8) + (buf [6] << 16) + (buf [7] << 32);  	if (_version >= 3950)  		blocksPerFrame = 73728 * 4;  	else if (_version >= 3900 || (_version >= 3800 && _compressionLevel == COMPRESSION_LEVEL_EXTRA_HIGH))  		blocksPerFrame = 73728;  	else  		blocksPerFrame = 9216;  	// TODO: This is definitely fucked up  	finalBlocks = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  	_frames = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  } else {  	throw new NotImplementedException (string.Format ("MAC {0:0.00} not supported"' _version / 1000.0));  }  
Magic Number,IdSharp.AudioInfo,MonkeysAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\MonkeysAudio\MonkeysAudio.cs,MonkeysAudio,The following statement contains a magic number: if (_version <= 3970) {  	// TODO: This section needs work  	_compressionLevel = buf [2] + (buf [3] << 8);  	buf = stream.Read (24);  	// skip format flags  	_channels = buf [2] + (buf [3] << 8);  	_frequency = buf [4] + (buf [5] << 8) + (buf [6] << 16) + (buf [7] << 32);  	if (_version >= 3950)  		blocksPerFrame = 73728 * 4;  	else if (_version >= 3900 || (_version >= 3800 && _compressionLevel == COMPRESSION_LEVEL_EXTRA_HIGH))  		blocksPerFrame = 73728;  	else  		blocksPerFrame = 9216;  	// TODO: This is definitely fucked up  	finalBlocks = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  	_frames = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  } else {  	throw new NotImplementedException (string.Format ("MAC {0:0.00} not supported"' _version / 1000.0));  }  
Magic Number,IdSharp.AudioInfo,MonkeysAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\MonkeysAudio\MonkeysAudio.cs,MonkeysAudio,The following statement contains a magic number: if (_version <= 3970) {  	// TODO: This section needs work  	_compressionLevel = buf [2] + (buf [3] << 8);  	buf = stream.Read (24);  	// skip format flags  	_channels = buf [2] + (buf [3] << 8);  	_frequency = buf [4] + (buf [5] << 8) + (buf [6] << 16) + (buf [7] << 32);  	if (_version >= 3950)  		blocksPerFrame = 73728 * 4;  	else if (_version >= 3900 || (_version >= 3800 && _compressionLevel == COMPRESSION_LEVEL_EXTRA_HIGH))  		blocksPerFrame = 73728;  	else  		blocksPerFrame = 9216;  	// TODO: This is definitely fucked up  	finalBlocks = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  	_frames = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  } else {  	throw new NotImplementedException (string.Format ("MAC {0:0.00} not supported"' _version / 1000.0));  }  
Magic Number,IdSharp.AudioInfo,MonkeysAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\MonkeysAudio\MonkeysAudio.cs,MonkeysAudio,The following statement contains a magic number: if (_version <= 3970) {  	// TODO: This section needs work  	_compressionLevel = buf [2] + (buf [3] << 8);  	buf = stream.Read (24);  	// skip format flags  	_channels = buf [2] + (buf [3] << 8);  	_frequency = buf [4] + (buf [5] << 8) + (buf [6] << 16) + (buf [7] << 32);  	if (_version >= 3950)  		blocksPerFrame = 73728 * 4;  	else if (_version >= 3900 || (_version >= 3800 && _compressionLevel == COMPRESSION_LEVEL_EXTRA_HIGH))  		blocksPerFrame = 73728;  	else  		blocksPerFrame = 9216;  	// TODO: This is definitely fucked up  	finalBlocks = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  	_frames = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  } else {  	throw new NotImplementedException (string.Format ("MAC {0:0.00} not supported"' _version / 1000.0));  }  
Magic Number,IdSharp.AudioInfo,MonkeysAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\MonkeysAudio\MonkeysAudio.cs,MonkeysAudio,The following statement contains a magic number: if (_version <= 3970) {  	// TODO: This section needs work  	_compressionLevel = buf [2] + (buf [3] << 8);  	buf = stream.Read (24);  	// skip format flags  	_channels = buf [2] + (buf [3] << 8);  	_frequency = buf [4] + (buf [5] << 8) + (buf [6] << 16) + (buf [7] << 32);  	if (_version >= 3950)  		blocksPerFrame = 73728 * 4;  	else if (_version >= 3900 || (_version >= 3800 && _compressionLevel == COMPRESSION_LEVEL_EXTRA_HIGH))  		blocksPerFrame = 73728;  	else  		blocksPerFrame = 9216;  	// TODO: This is definitely fucked up  	finalBlocks = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  	_frames = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  } else {  	throw new NotImplementedException (string.Format ("MAC {0:0.00} not supported"' _version / 1000.0));  }  
Magic Number,IdSharp.AudioInfo,MonkeysAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\MonkeysAudio\MonkeysAudio.cs,MonkeysAudio,The following statement contains a magic number: if (_version <= 3970) {  	// TODO: This section needs work  	_compressionLevel = buf [2] + (buf [3] << 8);  	buf = stream.Read (24);  	// skip format flags  	_channels = buf [2] + (buf [3] << 8);  	_frequency = buf [4] + (buf [5] << 8) + (buf [6] << 16) + (buf [7] << 32);  	if (_version >= 3950)  		blocksPerFrame = 73728 * 4;  	else if (_version >= 3900 || (_version >= 3800 && _compressionLevel == COMPRESSION_LEVEL_EXTRA_HIGH))  		blocksPerFrame = 73728;  	else  		blocksPerFrame = 9216;  	// TODO: This is definitely fucked up  	finalBlocks = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  	_frames = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  } else {  	throw new NotImplementedException (string.Format ("MAC {0:0.00} not supported"' _version / 1000.0));  }  
Magic Number,IdSharp.AudioInfo,MonkeysAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\MonkeysAudio\MonkeysAudio.cs,MonkeysAudio,The following statement contains a magic number: if (_version <= 3970) {  	// TODO: This section needs work  	_compressionLevel = buf [2] + (buf [3] << 8);  	buf = stream.Read (24);  	// skip format flags  	_channels = buf [2] + (buf [3] << 8);  	_frequency = buf [4] + (buf [5] << 8) + (buf [6] << 16) + (buf [7] << 32);  	if (_version >= 3950)  		blocksPerFrame = 73728 * 4;  	else if (_version >= 3900 || (_version >= 3800 && _compressionLevel == COMPRESSION_LEVEL_EXTRA_HIGH))  		blocksPerFrame = 73728;  	else  		blocksPerFrame = 9216;  	// TODO: This is definitely fucked up  	finalBlocks = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  	_frames = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  } else {  	throw new NotImplementedException (string.Format ("MAC {0:0.00} not supported"' _version / 1000.0));  }  
Magic Number,IdSharp.AudioInfo,MonkeysAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\MonkeysAudio\MonkeysAudio.cs,MonkeysAudio,The following statement contains a magic number: if (_version <= 3970) {  	// TODO: This section needs work  	_compressionLevel = buf [2] + (buf [3] << 8);  	buf = stream.Read (24);  	// skip format flags  	_channels = buf [2] + (buf [3] << 8);  	_frequency = buf [4] + (buf [5] << 8) + (buf [6] << 16) + (buf [7] << 32);  	if (_version >= 3950)  		blocksPerFrame = 73728 * 4;  	else if (_version >= 3900 || (_version >= 3800 && _compressionLevel == COMPRESSION_LEVEL_EXTRA_HIGH))  		blocksPerFrame = 73728;  	else  		blocksPerFrame = 9216;  	// TODO: This is definitely fucked up  	finalBlocks = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  	_frames = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  } else {  	throw new NotImplementedException (string.Format ("MAC {0:0.00} not supported"' _version / 1000.0));  }  
Magic Number,IdSharp.AudioInfo,MonkeysAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\MonkeysAudio\MonkeysAudio.cs,MonkeysAudio,The following statement contains a magic number: if (_version <= 3970) {  	// TODO: This section needs work  	_compressionLevel = buf [2] + (buf [3] << 8);  	buf = stream.Read (24);  	// skip format flags  	_channels = buf [2] + (buf [3] << 8);  	_frequency = buf [4] + (buf [5] << 8) + (buf [6] << 16) + (buf [7] << 32);  	if (_version >= 3950)  		blocksPerFrame = 73728 * 4;  	else if (_version >= 3900 || (_version >= 3800 && _compressionLevel == COMPRESSION_LEVEL_EXTRA_HIGH))  		blocksPerFrame = 73728;  	else  		blocksPerFrame = 9216;  	// TODO: This is definitely fucked up  	finalBlocks = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  	_frames = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  } else {  	throw new NotImplementedException (string.Format ("MAC {0:0.00} not supported"' _version / 1000.0));  }  
Magic Number,IdSharp.AudioInfo,MonkeysAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\MonkeysAudio\MonkeysAudio.cs,MonkeysAudio,The following statement contains a magic number: _compressionLevel = buf [2] + (buf [3] << 8);  
Magic Number,IdSharp.AudioInfo,MonkeysAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\MonkeysAudio\MonkeysAudio.cs,MonkeysAudio,The following statement contains a magic number: _compressionLevel = buf [2] + (buf [3] << 8);  
Magic Number,IdSharp.AudioInfo,MonkeysAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\MonkeysAudio\MonkeysAudio.cs,MonkeysAudio,The following statement contains a magic number: _compressionLevel = buf [2] + (buf [3] << 8);  
Magic Number,IdSharp.AudioInfo,MonkeysAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\MonkeysAudio\MonkeysAudio.cs,MonkeysAudio,The following statement contains a magic number: buf = stream.Read (24);  
Magic Number,IdSharp.AudioInfo,MonkeysAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\MonkeysAudio\MonkeysAudio.cs,MonkeysAudio,The following statement contains a magic number: _channels = buf [2] + (buf [3] << 8);  
Magic Number,IdSharp.AudioInfo,MonkeysAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\MonkeysAudio\MonkeysAudio.cs,MonkeysAudio,The following statement contains a magic number: _channels = buf [2] + (buf [3] << 8);  
Magic Number,IdSharp.AudioInfo,MonkeysAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\MonkeysAudio\MonkeysAudio.cs,MonkeysAudio,The following statement contains a magic number: _channels = buf [2] + (buf [3] << 8);  
Magic Number,IdSharp.AudioInfo,MonkeysAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\MonkeysAudio\MonkeysAudio.cs,MonkeysAudio,The following statement contains a magic number: _frequency = buf [4] + (buf [5] << 8) + (buf [6] << 16) + (buf [7] << 32);  
Magic Number,IdSharp.AudioInfo,MonkeysAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\MonkeysAudio\MonkeysAudio.cs,MonkeysAudio,The following statement contains a magic number: _frequency = buf [4] + (buf [5] << 8) + (buf [6] << 16) + (buf [7] << 32);  
Magic Number,IdSharp.AudioInfo,MonkeysAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\MonkeysAudio\MonkeysAudio.cs,MonkeysAudio,The following statement contains a magic number: _frequency = buf [4] + (buf [5] << 8) + (buf [6] << 16) + (buf [7] << 32);  
Magic Number,IdSharp.AudioInfo,MonkeysAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\MonkeysAudio\MonkeysAudio.cs,MonkeysAudio,The following statement contains a magic number: _frequency = buf [4] + (buf [5] << 8) + (buf [6] << 16) + (buf [7] << 32);  
Magic Number,IdSharp.AudioInfo,MonkeysAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\MonkeysAudio\MonkeysAudio.cs,MonkeysAudio,The following statement contains a magic number: _frequency = buf [4] + (buf [5] << 8) + (buf [6] << 16) + (buf [7] << 32);  
Magic Number,IdSharp.AudioInfo,MonkeysAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\MonkeysAudio\MonkeysAudio.cs,MonkeysAudio,The following statement contains a magic number: _frequency = buf [4] + (buf [5] << 8) + (buf [6] << 16) + (buf [7] << 32);  
Magic Number,IdSharp.AudioInfo,MonkeysAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\MonkeysAudio\MonkeysAudio.cs,MonkeysAudio,The following statement contains a magic number: _frequency = buf [4] + (buf [5] << 8) + (buf [6] << 16) + (buf [7] << 32);  
Magic Number,IdSharp.AudioInfo,MonkeysAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\MonkeysAudio\MonkeysAudio.cs,MonkeysAudio,The following statement contains a magic number: if (_version >= 3950)  	blocksPerFrame = 73728 * 4;  else if (_version >= 3900 || (_version >= 3800 && _compressionLevel == COMPRESSION_LEVEL_EXTRA_HIGH))  	blocksPerFrame = 73728;  else  	blocksPerFrame = 9216;  
Magic Number,IdSharp.AudioInfo,MonkeysAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\MonkeysAudio\MonkeysAudio.cs,MonkeysAudio,The following statement contains a magic number: if (_version >= 3950)  	blocksPerFrame = 73728 * 4;  else if (_version >= 3900 || (_version >= 3800 && _compressionLevel == COMPRESSION_LEVEL_EXTRA_HIGH))  	blocksPerFrame = 73728;  else  	blocksPerFrame = 9216;  
Magic Number,IdSharp.AudioInfo,MonkeysAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\MonkeysAudio\MonkeysAudio.cs,MonkeysAudio,The following statement contains a magic number: if (_version >= 3950)  	blocksPerFrame = 73728 * 4;  else if (_version >= 3900 || (_version >= 3800 && _compressionLevel == COMPRESSION_LEVEL_EXTRA_HIGH))  	blocksPerFrame = 73728;  else  	blocksPerFrame = 9216;  
Magic Number,IdSharp.AudioInfo,MonkeysAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\MonkeysAudio\MonkeysAudio.cs,MonkeysAudio,The following statement contains a magic number: if (_version >= 3950)  	blocksPerFrame = 73728 * 4;  else if (_version >= 3900 || (_version >= 3800 && _compressionLevel == COMPRESSION_LEVEL_EXTRA_HIGH))  	blocksPerFrame = 73728;  else  	blocksPerFrame = 9216;  
Magic Number,IdSharp.AudioInfo,MonkeysAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\MonkeysAudio\MonkeysAudio.cs,MonkeysAudio,The following statement contains a magic number: if (_version >= 3950)  	blocksPerFrame = 73728 * 4;  else if (_version >= 3900 || (_version >= 3800 && _compressionLevel == COMPRESSION_LEVEL_EXTRA_HIGH))  	blocksPerFrame = 73728;  else  	blocksPerFrame = 9216;  
Magic Number,IdSharp.AudioInfo,MonkeysAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\MonkeysAudio\MonkeysAudio.cs,MonkeysAudio,The following statement contains a magic number: if (_version >= 3950)  	blocksPerFrame = 73728 * 4;  else if (_version >= 3900 || (_version >= 3800 && _compressionLevel == COMPRESSION_LEVEL_EXTRA_HIGH))  	blocksPerFrame = 73728;  else  	blocksPerFrame = 9216;  
Magic Number,IdSharp.AudioInfo,MonkeysAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\MonkeysAudio\MonkeysAudio.cs,MonkeysAudio,The following statement contains a magic number: if (_version >= 3950)  	blocksPerFrame = 73728 * 4;  else if (_version >= 3900 || (_version >= 3800 && _compressionLevel == COMPRESSION_LEVEL_EXTRA_HIGH))  	blocksPerFrame = 73728;  else  	blocksPerFrame = 9216;  
Magic Number,IdSharp.AudioInfo,MonkeysAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\MonkeysAudio\MonkeysAudio.cs,MonkeysAudio,The following statement contains a magic number: blocksPerFrame = 73728 * 4;  
Magic Number,IdSharp.AudioInfo,MonkeysAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\MonkeysAudio\MonkeysAudio.cs,MonkeysAudio,The following statement contains a magic number: blocksPerFrame = 73728 * 4;  
Magic Number,IdSharp.AudioInfo,MonkeysAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\MonkeysAudio\MonkeysAudio.cs,MonkeysAudio,The following statement contains a magic number: if (_version >= 3900 || (_version >= 3800 && _compressionLevel == COMPRESSION_LEVEL_EXTRA_HIGH))  	blocksPerFrame = 73728;  else  	blocksPerFrame = 9216;  
Magic Number,IdSharp.AudioInfo,MonkeysAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\MonkeysAudio\MonkeysAudio.cs,MonkeysAudio,The following statement contains a magic number: if (_version >= 3900 || (_version >= 3800 && _compressionLevel == COMPRESSION_LEVEL_EXTRA_HIGH))  	blocksPerFrame = 73728;  else  	blocksPerFrame = 9216;  
Magic Number,IdSharp.AudioInfo,MonkeysAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\MonkeysAudio\MonkeysAudio.cs,MonkeysAudio,The following statement contains a magic number: if (_version >= 3900 || (_version >= 3800 && _compressionLevel == COMPRESSION_LEVEL_EXTRA_HIGH))  	blocksPerFrame = 73728;  else  	blocksPerFrame = 9216;  
Magic Number,IdSharp.AudioInfo,MonkeysAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\MonkeysAudio\MonkeysAudio.cs,MonkeysAudio,The following statement contains a magic number: if (_version >= 3900 || (_version >= 3800 && _compressionLevel == COMPRESSION_LEVEL_EXTRA_HIGH))  	blocksPerFrame = 73728;  else  	blocksPerFrame = 9216;  
Magic Number,IdSharp.AudioInfo,MonkeysAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\MonkeysAudio\MonkeysAudio.cs,MonkeysAudio,The following statement contains a magic number: blocksPerFrame = 73728;  
Magic Number,IdSharp.AudioInfo,MonkeysAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\MonkeysAudio\MonkeysAudio.cs,MonkeysAudio,The following statement contains a magic number: blocksPerFrame = 9216;  
Magic Number,IdSharp.AudioInfo,MonkeysAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\MonkeysAudio\MonkeysAudio.cs,MonkeysAudio,The following statement contains a magic number: finalBlocks = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  
Magic Number,IdSharp.AudioInfo,MonkeysAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\MonkeysAudio\MonkeysAudio.cs,MonkeysAudio,The following statement contains a magic number: finalBlocks = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  
Magic Number,IdSharp.AudioInfo,MonkeysAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\MonkeysAudio\MonkeysAudio.cs,MonkeysAudio,The following statement contains a magic number: finalBlocks = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  
Magic Number,IdSharp.AudioInfo,MonkeysAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\MonkeysAudio\MonkeysAudio.cs,MonkeysAudio,The following statement contains a magic number: finalBlocks = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  
Magic Number,IdSharp.AudioInfo,MonkeysAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\MonkeysAudio\MonkeysAudio.cs,MonkeysAudio,The following statement contains a magic number: finalBlocks = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  
Magic Number,IdSharp.AudioInfo,MonkeysAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\MonkeysAudio\MonkeysAudio.cs,MonkeysAudio,The following statement contains a magic number: _frames = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  
Magic Number,IdSharp.AudioInfo,MonkeysAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\MonkeysAudio\MonkeysAudio.cs,MonkeysAudio,The following statement contains a magic number: _frames = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  
Magic Number,IdSharp.AudioInfo,MonkeysAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\MonkeysAudio\MonkeysAudio.cs,MonkeysAudio,The following statement contains a magic number: _frames = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  
Magic Number,IdSharp.AudioInfo,MonkeysAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\MonkeysAudio\MonkeysAudio.cs,MonkeysAudio,The following statement contains a magic number: _frames = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  
Magic Number,IdSharp.AudioInfo,MonkeysAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\MonkeysAudio\MonkeysAudio.cs,MonkeysAudio,The following statement contains a magic number: _frames = buf [0] + (buf [1] << 8) + (buf [2] << 16) + (buf [3] << 24);  
Magic Number,IdSharp.AudioInfo,MonkeysAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\MonkeysAudio\MonkeysAudio.cs,MonkeysAudio,The following statement contains a magic number: throw new NotImplementedException (string.Format ("MAC {0:0.00} not supported"' _version / 1000.0));  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: BitrateTable = new[] {  	new[] {  		// MPEG-2.5  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new int[3][]'  	new[] {  		// MPEG-2  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new[] {  		// MPEG-1  		new[] {  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320  		}'  		// Layer-3  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320'  			384  		}'  		// Layer-2  		new[] {  			32'  			64'  			96'  			128'  			160'  			192'  			224'  			256'  			288'  			320'  			352'  			384'  			416'  			448  		}  	// Layer-1  	}  };  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: BitrateTable = new[] {  	new[] {  		// MPEG-2.5  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new int[3][]'  	new[] {  		// MPEG-2  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new[] {  		// MPEG-1  		new[] {  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320  		}'  		// Layer-3  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320'  			384  		}'  		// Layer-2  		new[] {  			32'  			64'  			96'  			128'  			160'  			192'  			224'  			256'  			288'  			320'  			352'  			384'  			416'  			448  		}  	// Layer-1  	}  };  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: BitrateTable = new[] {  	new[] {  		// MPEG-2.5  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new int[3][]'  	new[] {  		// MPEG-2  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new[] {  		// MPEG-1  		new[] {  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320  		}'  		// Layer-3  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320'  			384  		}'  		// Layer-2  		new[] {  			32'  			64'  			96'  			128'  			160'  			192'  			224'  			256'  			288'  			320'  			352'  			384'  			416'  			448  		}  	// Layer-1  	}  };  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: BitrateTable = new[] {  	new[] {  		// MPEG-2.5  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new int[3][]'  	new[] {  		// MPEG-2  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new[] {  		// MPEG-1  		new[] {  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320  		}'  		// Layer-3  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320'  			384  		}'  		// Layer-2  		new[] {  			32'  			64'  			96'  			128'  			160'  			192'  			224'  			256'  			288'  			320'  			352'  			384'  			416'  			448  		}  	// Layer-1  	}  };  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: BitrateTable = new[] {  	new[] {  		// MPEG-2.5  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new int[3][]'  	new[] {  		// MPEG-2  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new[] {  		// MPEG-1  		new[] {  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320  		}'  		// Layer-3  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320'  			384  		}'  		// Layer-2  		new[] {  			32'  			64'  			96'  			128'  			160'  			192'  			224'  			256'  			288'  			320'  			352'  			384'  			416'  			448  		}  	// Layer-1  	}  };  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: BitrateTable = new[] {  	new[] {  		// MPEG-2.5  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new int[3][]'  	new[] {  		// MPEG-2  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new[] {  		// MPEG-1  		new[] {  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320  		}'  		// Layer-3  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320'  			384  		}'  		// Layer-2  		new[] {  			32'  			64'  			96'  			128'  			160'  			192'  			224'  			256'  			288'  			320'  			352'  			384'  			416'  			448  		}  	// Layer-1  	}  };  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: BitrateTable = new[] {  	new[] {  		// MPEG-2.5  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new int[3][]'  	new[] {  		// MPEG-2  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new[] {  		// MPEG-1  		new[] {  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320  		}'  		// Layer-3  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320'  			384  		}'  		// Layer-2  		new[] {  			32'  			64'  			96'  			128'  			160'  			192'  			224'  			256'  			288'  			320'  			352'  			384'  			416'  			448  		}  	// Layer-1  	}  };  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: BitrateTable = new[] {  	new[] {  		// MPEG-2.5  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new int[3][]'  	new[] {  		// MPEG-2  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new[] {  		// MPEG-1  		new[] {  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320  		}'  		// Layer-3  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320'  			384  		}'  		// Layer-2  		new[] {  			32'  			64'  			96'  			128'  			160'  			192'  			224'  			256'  			288'  			320'  			352'  			384'  			416'  			448  		}  	// Layer-1  	}  };  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: BitrateTable = new[] {  	new[] {  		// MPEG-2.5  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new int[3][]'  	new[] {  		// MPEG-2  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new[] {  		// MPEG-1  		new[] {  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320  		}'  		// Layer-3  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320'  			384  		}'  		// Layer-2  		new[] {  			32'  			64'  			96'  			128'  			160'  			192'  			224'  			256'  			288'  			320'  			352'  			384'  			416'  			448  		}  	// Layer-1  	}  };  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: BitrateTable = new[] {  	new[] {  		// MPEG-2.5  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new int[3][]'  	new[] {  		// MPEG-2  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new[] {  		// MPEG-1  		new[] {  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320  		}'  		// Layer-3  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320'  			384  		}'  		// Layer-2  		new[] {  			32'  			64'  			96'  			128'  			160'  			192'  			224'  			256'  			288'  			320'  			352'  			384'  			416'  			448  		}  	// Layer-1  	}  };  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: BitrateTable = new[] {  	new[] {  		// MPEG-2.5  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new int[3][]'  	new[] {  		// MPEG-2  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new[] {  		// MPEG-1  		new[] {  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320  		}'  		// Layer-3  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320'  			384  		}'  		// Layer-2  		new[] {  			32'  			64'  			96'  			128'  			160'  			192'  			224'  			256'  			288'  			320'  			352'  			384'  			416'  			448  		}  	// Layer-1  	}  };  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: BitrateTable = new[] {  	new[] {  		// MPEG-2.5  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new int[3][]'  	new[] {  		// MPEG-2  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new[] {  		// MPEG-1  		new[] {  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320  		}'  		// Layer-3  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320'  			384  		}'  		// Layer-2  		new[] {  			32'  			64'  			96'  			128'  			160'  			192'  			224'  			256'  			288'  			320'  			352'  			384'  			416'  			448  		}  	// Layer-1  	}  };  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: BitrateTable = new[] {  	new[] {  		// MPEG-2.5  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new int[3][]'  	new[] {  		// MPEG-2  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new[] {  		// MPEG-1  		new[] {  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320  		}'  		// Layer-3  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320'  			384  		}'  		// Layer-2  		new[] {  			32'  			64'  			96'  			128'  			160'  			192'  			224'  			256'  			288'  			320'  			352'  			384'  			416'  			448  		}  	// Layer-1  	}  };  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: BitrateTable = new[] {  	new[] {  		// MPEG-2.5  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new int[3][]'  	new[] {  		// MPEG-2  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new[] {  		// MPEG-1  		new[] {  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320  		}'  		// Layer-3  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320'  			384  		}'  		// Layer-2  		new[] {  			32'  			64'  			96'  			128'  			160'  			192'  			224'  			256'  			288'  			320'  			352'  			384'  			416'  			448  		}  	// Layer-1  	}  };  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: BitrateTable = new[] {  	new[] {  		// MPEG-2.5  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new int[3][]'  	new[] {  		// MPEG-2  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new[] {  		// MPEG-1  		new[] {  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320  		}'  		// Layer-3  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320'  			384  		}'  		// Layer-2  		new[] {  			32'  			64'  			96'  			128'  			160'  			192'  			224'  			256'  			288'  			320'  			352'  			384'  			416'  			448  		}  	// Layer-1  	}  };  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: BitrateTable = new[] {  	new[] {  		// MPEG-2.5  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new int[3][]'  	new[] {  		// MPEG-2  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new[] {  		// MPEG-1  		new[] {  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320  		}'  		// Layer-3  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320'  			384  		}'  		// Layer-2  		new[] {  			32'  			64'  			96'  			128'  			160'  			192'  			224'  			256'  			288'  			320'  			352'  			384'  			416'  			448  		}  	// Layer-1  	}  };  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: BitrateTable = new[] {  	new[] {  		// MPEG-2.5  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new int[3][]'  	new[] {  		// MPEG-2  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new[] {  		// MPEG-1  		new[] {  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320  		}'  		// Layer-3  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320'  			384  		}'  		// Layer-2  		new[] {  			32'  			64'  			96'  			128'  			160'  			192'  			224'  			256'  			288'  			320'  			352'  			384'  			416'  			448  		}  	// Layer-1  	}  };  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: BitrateTable = new[] {  	new[] {  		// MPEG-2.5  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new int[3][]'  	new[] {  		// MPEG-2  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new[] {  		// MPEG-1  		new[] {  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320  		}'  		// Layer-3  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320'  			384  		}'  		// Layer-2  		new[] {  			32'  			64'  			96'  			128'  			160'  			192'  			224'  			256'  			288'  			320'  			352'  			384'  			416'  			448  		}  	// Layer-1  	}  };  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: BitrateTable = new[] {  	new[] {  		// MPEG-2.5  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new int[3][]'  	new[] {  		// MPEG-2  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new[] {  		// MPEG-1  		new[] {  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320  		}'  		// Layer-3  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320'  			384  		}'  		// Layer-2  		new[] {  			32'  			64'  			96'  			128'  			160'  			192'  			224'  			256'  			288'  			320'  			352'  			384'  			416'  			448  		}  	// Layer-1  	}  };  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: BitrateTable = new[] {  	new[] {  		// MPEG-2.5  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new int[3][]'  	new[] {  		// MPEG-2  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new[] {  		// MPEG-1  		new[] {  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320  		}'  		// Layer-3  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320'  			384  		}'  		// Layer-2  		new[] {  			32'  			64'  			96'  			128'  			160'  			192'  			224'  			256'  			288'  			320'  			352'  			384'  			416'  			448  		}  	// Layer-1  	}  };  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: BitrateTable = new[] {  	new[] {  		// MPEG-2.5  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new int[3][]'  	new[] {  		// MPEG-2  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new[] {  		// MPEG-1  		new[] {  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320  		}'  		// Layer-3  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320'  			384  		}'  		// Layer-2  		new[] {  			32'  			64'  			96'  			128'  			160'  			192'  			224'  			256'  			288'  			320'  			352'  			384'  			416'  			448  		}  	// Layer-1  	}  };  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: BitrateTable = new[] {  	new[] {  		// MPEG-2.5  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new int[3][]'  	new[] {  		// MPEG-2  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new[] {  		// MPEG-1  		new[] {  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320  		}'  		// Layer-3  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320'  			384  		}'  		// Layer-2  		new[] {  			32'  			64'  			96'  			128'  			160'  			192'  			224'  			256'  			288'  			320'  			352'  			384'  			416'  			448  		}  	// Layer-1  	}  };  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: BitrateTable = new[] {  	new[] {  		// MPEG-2.5  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new int[3][]'  	new[] {  		// MPEG-2  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new[] {  		// MPEG-1  		new[] {  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320  		}'  		// Layer-3  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320'  			384  		}'  		// Layer-2  		new[] {  			32'  			64'  			96'  			128'  			160'  			192'  			224'  			256'  			288'  			320'  			352'  			384'  			416'  			448  		}  	// Layer-1  	}  };  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: BitrateTable = new[] {  	new[] {  		// MPEG-2.5  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new int[3][]'  	new[] {  		// MPEG-2  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new[] {  		// MPEG-1  		new[] {  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320  		}'  		// Layer-3  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320'  			384  		}'  		// Layer-2  		new[] {  			32'  			64'  			96'  			128'  			160'  			192'  			224'  			256'  			288'  			320'  			352'  			384'  			416'  			448  		}  	// Layer-1  	}  };  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: BitrateTable = new[] {  	new[] {  		// MPEG-2.5  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new int[3][]'  	new[] {  		// MPEG-2  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new[] {  		// MPEG-1  		new[] {  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320  		}'  		// Layer-3  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320'  			384  		}'  		// Layer-2  		new[] {  			32'  			64'  			96'  			128'  			160'  			192'  			224'  			256'  			288'  			320'  			352'  			384'  			416'  			448  		}  	// Layer-1  	}  };  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: BitrateTable = new[] {  	new[] {  		// MPEG-2.5  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new int[3][]'  	new[] {  		// MPEG-2  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new[] {  		// MPEG-1  		new[] {  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320  		}'  		// Layer-3  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320'  			384  		}'  		// Layer-2  		new[] {  			32'  			64'  			96'  			128'  			160'  			192'  			224'  			256'  			288'  			320'  			352'  			384'  			416'  			448  		}  	// Layer-1  	}  };  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: BitrateTable = new[] {  	new[] {  		// MPEG-2.5  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new int[3][]'  	new[] {  		// MPEG-2  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new[] {  		// MPEG-1  		new[] {  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320  		}'  		// Layer-3  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320'  			384  		}'  		// Layer-2  		new[] {  			32'  			64'  			96'  			128'  			160'  			192'  			224'  			256'  			288'  			320'  			352'  			384'  			416'  			448  		}  	// Layer-1  	}  };  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: BitrateTable = new[] {  	new[] {  		// MPEG-2.5  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new int[3][]'  	new[] {  		// MPEG-2  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new[] {  		// MPEG-1  		new[] {  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320  		}'  		// Layer-3  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320'  			384  		}'  		// Layer-2  		new[] {  			32'  			64'  			96'  			128'  			160'  			192'  			224'  			256'  			288'  			320'  			352'  			384'  			416'  			448  		}  	// Layer-1  	}  };  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: BitrateTable = new[] {  	new[] {  		// MPEG-2.5  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new int[3][]'  	new[] {  		// MPEG-2  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new[] {  		// MPEG-1  		new[] {  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320  		}'  		// Layer-3  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320'  			384  		}'  		// Layer-2  		new[] {  			32'  			64'  			96'  			128'  			160'  			192'  			224'  			256'  			288'  			320'  			352'  			384'  			416'  			448  		}  	// Layer-1  	}  };  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: BitrateTable = new[] {  	new[] {  		// MPEG-2.5  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new int[3][]'  	new[] {  		// MPEG-2  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new[] {  		// MPEG-1  		new[] {  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320  		}'  		// Layer-3  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320'  			384  		}'  		// Layer-2  		new[] {  			32'  			64'  			96'  			128'  			160'  			192'  			224'  			256'  			288'  			320'  			352'  			384'  			416'  			448  		}  	// Layer-1  	}  };  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: BitrateTable = new[] {  	new[] {  		// MPEG-2.5  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new int[3][]'  	new[] {  		// MPEG-2  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new[] {  		// MPEG-1  		new[] {  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320  		}'  		// Layer-3  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320'  			384  		}'  		// Layer-2  		new[] {  			32'  			64'  			96'  			128'  			160'  			192'  			224'  			256'  			288'  			320'  			352'  			384'  			416'  			448  		}  	// Layer-1  	}  };  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: BitrateTable = new[] {  	new[] {  		// MPEG-2.5  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new int[3][]'  	new[] {  		// MPEG-2  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new[] {  		// MPEG-1  		new[] {  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320  		}'  		// Layer-3  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320'  			384  		}'  		// Layer-2  		new[] {  			32'  			64'  			96'  			128'  			160'  			192'  			224'  			256'  			288'  			320'  			352'  			384'  			416'  			448  		}  	// Layer-1  	}  };  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: BitrateTable = new[] {  	new[] {  		// MPEG-2.5  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new int[3][]'  	new[] {  		// MPEG-2  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new[] {  		// MPEG-1  		new[] {  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320  		}'  		// Layer-3  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320'  			384  		}'  		// Layer-2  		new[] {  			32'  			64'  			96'  			128'  			160'  			192'  			224'  			256'  			288'  			320'  			352'  			384'  			416'  			448  		}  	// Layer-1  	}  };  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: BitrateTable = new[] {  	new[] {  		// MPEG-2.5  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new int[3][]'  	new[] {  		// MPEG-2  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new[] {  		// MPEG-1  		new[] {  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320  		}'  		// Layer-3  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320'  			384  		}'  		// Layer-2  		new[] {  			32'  			64'  			96'  			128'  			160'  			192'  			224'  			256'  			288'  			320'  			352'  			384'  			416'  			448  		}  	// Layer-1  	}  };  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: BitrateTable = new[] {  	new[] {  		// MPEG-2.5  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new int[3][]'  	new[] {  		// MPEG-2  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new[] {  		// MPEG-1  		new[] {  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320  		}'  		// Layer-3  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320'  			384  		}'  		// Layer-2  		new[] {  			32'  			64'  			96'  			128'  			160'  			192'  			224'  			256'  			288'  			320'  			352'  			384'  			416'  			448  		}  	// Layer-1  	}  };  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: BitrateTable = new[] {  	new[] {  		// MPEG-2.5  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new int[3][]'  	new[] {  		// MPEG-2  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new[] {  		// MPEG-1  		new[] {  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320  		}'  		// Layer-3  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320'  			384  		}'  		// Layer-2  		new[] {  			32'  			64'  			96'  			128'  			160'  			192'  			224'  			256'  			288'  			320'  			352'  			384'  			416'  			448  		}  	// Layer-1  	}  };  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: BitrateTable = new[] {  	new[] {  		// MPEG-2.5  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new int[3][]'  	new[] {  		// MPEG-2  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new[] {  		// MPEG-1  		new[] {  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320  		}'  		// Layer-3  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320'  			384  		}'  		// Layer-2  		new[] {  			32'  			64'  			96'  			128'  			160'  			192'  			224'  			256'  			288'  			320'  			352'  			384'  			416'  			448  		}  	// Layer-1  	}  };  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: BitrateTable = new[] {  	new[] {  		// MPEG-2.5  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new int[3][]'  	new[] {  		// MPEG-2  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new[] {  		// MPEG-1  		new[] {  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320  		}'  		// Layer-3  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320'  			384  		}'  		// Layer-2  		new[] {  			32'  			64'  			96'  			128'  			160'  			192'  			224'  			256'  			288'  			320'  			352'  			384'  			416'  			448  		}  	// Layer-1  	}  };  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: BitrateTable = new[] {  	new[] {  		// MPEG-2.5  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new int[3][]'  	new[] {  		// MPEG-2  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new[] {  		// MPEG-1  		new[] {  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320  		}'  		// Layer-3  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320'  			384  		}'  		// Layer-2  		new[] {  			32'  			64'  			96'  			128'  			160'  			192'  			224'  			256'  			288'  			320'  			352'  			384'  			416'  			448  		}  	// Layer-1  	}  };  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: BitrateTable = new[] {  	new[] {  		// MPEG-2.5  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new int[3][]'  	new[] {  		// MPEG-2  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new[] {  		// MPEG-1  		new[] {  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320  		}'  		// Layer-3  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320'  			384  		}'  		// Layer-2  		new[] {  			32'  			64'  			96'  			128'  			160'  			192'  			224'  			256'  			288'  			320'  			352'  			384'  			416'  			448  		}  	// Layer-1  	}  };  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: BitrateTable = new[] {  	new[] {  		// MPEG-2.5  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new int[3][]'  	new[] {  		// MPEG-2  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new[] {  		// MPEG-1  		new[] {  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320  		}'  		// Layer-3  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320'  			384  		}'  		// Layer-2  		new[] {  			32'  			64'  			96'  			128'  			160'  			192'  			224'  			256'  			288'  			320'  			352'  			384'  			416'  			448  		}  	// Layer-1  	}  };  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: BitrateTable = new[] {  	new[] {  		// MPEG-2.5  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new int[3][]'  	new[] {  		// MPEG-2  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new[] {  		// MPEG-1  		new[] {  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320  		}'  		// Layer-3  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320'  			384  		}'  		// Layer-2  		new[] {  			32'  			64'  			96'  			128'  			160'  			192'  			224'  			256'  			288'  			320'  			352'  			384'  			416'  			448  		}  	// Layer-1  	}  };  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: BitrateTable = new[] {  	new[] {  		// MPEG-2.5  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new int[3][]'  	new[] {  		// MPEG-2  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new[] {  		// MPEG-1  		new[] {  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320  		}'  		// Layer-3  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320'  			384  		}'  		// Layer-2  		new[] {  			32'  			64'  			96'  			128'  			160'  			192'  			224'  			256'  			288'  			320'  			352'  			384'  			416'  			448  		}  	// Layer-1  	}  };  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: BitrateTable = new[] {  	new[] {  		// MPEG-2.5  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new int[3][]'  	new[] {  		// MPEG-2  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new[] {  		// MPEG-1  		new[] {  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320  		}'  		// Layer-3  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320'  			384  		}'  		// Layer-2  		new[] {  			32'  			64'  			96'  			128'  			160'  			192'  			224'  			256'  			288'  			320'  			352'  			384'  			416'  			448  		}  	// Layer-1  	}  };  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: BitrateTable = new[] {  	new[] {  		// MPEG-2.5  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new int[3][]'  	new[] {  		// MPEG-2  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new[] {  		// MPEG-1  		new[] {  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320  		}'  		// Layer-3  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320'  			384  		}'  		// Layer-2  		new[] {  			32'  			64'  			96'  			128'  			160'  			192'  			224'  			256'  			288'  			320'  			352'  			384'  			416'  			448  		}  	// Layer-1  	}  };  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: BitrateTable = new[] {  	new[] {  		// MPEG-2.5  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new int[3][]'  	new[] {  		// MPEG-2  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new[] {  		// MPEG-1  		new[] {  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320  		}'  		// Layer-3  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320'  			384  		}'  		// Layer-2  		new[] {  			32'  			64'  			96'  			128'  			160'  			192'  			224'  			256'  			288'  			320'  			352'  			384'  			416'  			448  		}  	// Layer-1  	}  };  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: BitrateTable = new[] {  	new[] {  		// MPEG-2.5  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new int[3][]'  	new[] {  		// MPEG-2  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new[] {  		// MPEG-1  		new[] {  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320  		}'  		// Layer-3  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320'  			384  		}'  		// Layer-2  		new[] {  			32'  			64'  			96'  			128'  			160'  			192'  			224'  			256'  			288'  			320'  			352'  			384'  			416'  			448  		}  	// Layer-1  	}  };  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: BitrateTable = new[] {  	new[] {  		// MPEG-2.5  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new int[3][]'  	new[] {  		// MPEG-2  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new[] {  		// MPEG-1  		new[] {  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320  		}'  		// Layer-3  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320'  			384  		}'  		// Layer-2  		new[] {  			32'  			64'  			96'  			128'  			160'  			192'  			224'  			256'  			288'  			320'  			352'  			384'  			416'  			448  		}  	// Layer-1  	}  };  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: BitrateTable = new[] {  	new[] {  		// MPEG-2.5  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new int[3][]'  	new[] {  		// MPEG-2  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new[] {  		// MPEG-1  		new[] {  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320  		}'  		// Layer-3  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320'  			384  		}'  		// Layer-2  		new[] {  			32'  			64'  			96'  			128'  			160'  			192'  			224'  			256'  			288'  			320'  			352'  			384'  			416'  			448  		}  	// Layer-1  	}  };  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: BitrateTable = new[] {  	new[] {  		// MPEG-2.5  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new int[3][]'  	new[] {  		// MPEG-2  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new[] {  		// MPEG-1  		new[] {  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320  		}'  		// Layer-3  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320'  			384  		}'  		// Layer-2  		new[] {  			32'  			64'  			96'  			128'  			160'  			192'  			224'  			256'  			288'  			320'  			352'  			384'  			416'  			448  		}  	// Layer-1  	}  };  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: BitrateTable = new[] {  	new[] {  		// MPEG-2.5  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new int[3][]'  	new[] {  		// MPEG-2  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new[] {  		// MPEG-1  		new[] {  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320  		}'  		// Layer-3  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320'  			384  		}'  		// Layer-2  		new[] {  			32'  			64'  			96'  			128'  			160'  			192'  			224'  			256'  			288'  			320'  			352'  			384'  			416'  			448  		}  	// Layer-1  	}  };  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: BitrateTable = new[] {  	new[] {  		// MPEG-2.5  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new int[3][]'  	new[] {  		// MPEG-2  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new[] {  		// MPEG-1  		new[] {  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320  		}'  		// Layer-3  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320'  			384  		}'  		// Layer-2  		new[] {  			32'  			64'  			96'  			128'  			160'  			192'  			224'  			256'  			288'  			320'  			352'  			384'  			416'  			448  		}  	// Layer-1  	}  };  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: BitrateTable = new[] {  	new[] {  		// MPEG-2.5  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new int[3][]'  	new[] {  		// MPEG-2  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new[] {  		// MPEG-1  		new[] {  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320  		}'  		// Layer-3  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320'  			384  		}'  		// Layer-2  		new[] {  			32'  			64'  			96'  			128'  			160'  			192'  			224'  			256'  			288'  			320'  			352'  			384'  			416'  			448  		}  	// Layer-1  	}  };  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: BitrateTable = new[] {  	new[] {  		// MPEG-2.5  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new int[3][]'  	new[] {  		// MPEG-2  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new[] {  		// MPEG-1  		new[] {  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320  		}'  		// Layer-3  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320'  			384  		}'  		// Layer-2  		new[] {  			32'  			64'  			96'  			128'  			160'  			192'  			224'  			256'  			288'  			320'  			352'  			384'  			416'  			448  		}  	// Layer-1  	}  };  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: BitrateTable = new[] {  	new[] {  		// MPEG-2.5  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new int[3][]'  	new[] {  		// MPEG-2  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new[] {  		// MPEG-1  		new[] {  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320  		}'  		// Layer-3  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320'  			384  		}'  		// Layer-2  		new[] {  			32'  			64'  			96'  			128'  			160'  			192'  			224'  			256'  			288'  			320'  			352'  			384'  			416'  			448  		}  	// Layer-1  	}  };  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: BitrateTable = new[] {  	new[] {  		// MPEG-2.5  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new int[3][]'  	new[] {  		// MPEG-2  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new[] {  		// MPEG-1  		new[] {  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320  		}'  		// Layer-3  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320'  			384  		}'  		// Layer-2  		new[] {  			32'  			64'  			96'  			128'  			160'  			192'  			224'  			256'  			288'  			320'  			352'  			384'  			416'  			448  		}  	// Layer-1  	}  };  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: BitrateTable = new[] {  	new[] {  		// MPEG-2.5  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new int[3][]'  	new[] {  		// MPEG-2  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new[] {  		// MPEG-1  		new[] {  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320  		}'  		// Layer-3  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320'  			384  		}'  		// Layer-2  		new[] {  			32'  			64'  			96'  			128'  			160'  			192'  			224'  			256'  			288'  			320'  			352'  			384'  			416'  			448  		}  	// Layer-1  	}  };  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: BitrateTable = new[] {  	new[] {  		// MPEG-2.5  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new int[3][]'  	new[] {  		// MPEG-2  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new[] {  		// MPEG-1  		new[] {  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320  		}'  		// Layer-3  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320'  			384  		}'  		// Layer-2  		new[] {  			32'  			64'  			96'  			128'  			160'  			192'  			224'  			256'  			288'  			320'  			352'  			384'  			416'  			448  		}  	// Layer-1  	}  };  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: BitrateTable = new[] {  	new[] {  		// MPEG-2.5  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new int[3][]'  	new[] {  		// MPEG-2  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new[] {  		// MPEG-1  		new[] {  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320  		}'  		// Layer-3  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320'  			384  		}'  		// Layer-2  		new[] {  			32'  			64'  			96'  			128'  			160'  			192'  			224'  			256'  			288'  			320'  			352'  			384'  			416'  			448  		}  	// Layer-1  	}  };  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: BitrateTable = new[] {  	new[] {  		// MPEG-2.5  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new int[3][]'  	new[] {  		// MPEG-2  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new[] {  		// MPEG-1  		new[] {  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320  		}'  		// Layer-3  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320'  			384  		}'  		// Layer-2  		new[] {  			32'  			64'  			96'  			128'  			160'  			192'  			224'  			256'  			288'  			320'  			352'  			384'  			416'  			448  		}  	// Layer-1  	}  };  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: BitrateTable = new[] {  	new[] {  		// MPEG-2.5  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new int[3][]'  	new[] {  		// MPEG-2  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new[] {  		// MPEG-1  		new[] {  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320  		}'  		// Layer-3  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320'  			384  		}'  		// Layer-2  		new[] {  			32'  			64'  			96'  			128'  			160'  			192'  			224'  			256'  			288'  			320'  			352'  			384'  			416'  			448  		}  	// Layer-1  	}  };  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: BitrateTable = new[] {  	new[] {  		// MPEG-2.5  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new int[3][]'  	new[] {  		// MPEG-2  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new[] {  		// MPEG-1  		new[] {  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320  		}'  		// Layer-3  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320'  			384  		}'  		// Layer-2  		new[] {  			32'  			64'  			96'  			128'  			160'  			192'  			224'  			256'  			288'  			320'  			352'  			384'  			416'  			448  		}  	// Layer-1  	}  };  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: BitrateTable = new[] {  	new[] {  		// MPEG-2.5  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new int[3][]'  	new[] {  		// MPEG-2  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new[] {  		// MPEG-1  		new[] {  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320  		}'  		// Layer-3  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320'  			384  		}'  		// Layer-2  		new[] {  			32'  			64'  			96'  			128'  			160'  			192'  			224'  			256'  			288'  			320'  			352'  			384'  			416'  			448  		}  	// Layer-1  	}  };  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: BitrateTable = new[] {  	new[] {  		// MPEG-2.5  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new int[3][]'  	new[] {  		// MPEG-2  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new[] {  		// MPEG-1  		new[] {  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320  		}'  		// Layer-3  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320'  			384  		}'  		// Layer-2  		new[] {  			32'  			64'  			96'  			128'  			160'  			192'  			224'  			256'  			288'  			320'  			352'  			384'  			416'  			448  		}  	// Layer-1  	}  };  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: BitrateTable = new[] {  	new[] {  		// MPEG-2.5  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new int[3][]'  	new[] {  		// MPEG-2  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new[] {  		// MPEG-1  		new[] {  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320  		}'  		// Layer-3  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320'  			384  		}'  		// Layer-2  		new[] {  			32'  			64'  			96'  			128'  			160'  			192'  			224'  			256'  			288'  			320'  			352'  			384'  			416'  			448  		}  	// Layer-1  	}  };  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: BitrateTable = new[] {  	new[] {  		// MPEG-2.5  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new int[3][]'  	new[] {  		// MPEG-2  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new[] {  		// MPEG-1  		new[] {  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320  		}'  		// Layer-3  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320'  			384  		}'  		// Layer-2  		new[] {  			32'  			64'  			96'  			128'  			160'  			192'  			224'  			256'  			288'  			320'  			352'  			384'  			416'  			448  		}  	// Layer-1  	}  };  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: BitrateTable = new[] {  	new[] {  		// MPEG-2.5  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new int[3][]'  	new[] {  		// MPEG-2  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new[] {  		// MPEG-1  		new[] {  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320  		}'  		// Layer-3  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320'  			384  		}'  		// Layer-2  		new[] {  			32'  			64'  			96'  			128'  			160'  			192'  			224'  			256'  			288'  			320'  			352'  			384'  			416'  			448  		}  	// Layer-1  	}  };  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: BitrateTable = new[] {  	new[] {  		// MPEG-2.5  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new int[3][]'  	new[] {  		// MPEG-2  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new[] {  		// MPEG-1  		new[] {  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320  		}'  		// Layer-3  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320'  			384  		}'  		// Layer-2  		new[] {  			32'  			64'  			96'  			128'  			160'  			192'  			224'  			256'  			288'  			320'  			352'  			384'  			416'  			448  		}  	// Layer-1  	}  };  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: BitrateTable = new[] {  	new[] {  		// MPEG-2.5  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new int[3][]'  	new[] {  		// MPEG-2  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new[] {  		// MPEG-1  		new[] {  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320  		}'  		// Layer-3  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320'  			384  		}'  		// Layer-2  		new[] {  			32'  			64'  			96'  			128'  			160'  			192'  			224'  			256'  			288'  			320'  			352'  			384'  			416'  			448  		}  	// Layer-1  	}  };  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: BitrateTable = new[] {  	new[] {  		// MPEG-2.5  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new int[3][]'  	new[] {  		// MPEG-2  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new[] {  		// MPEG-1  		new[] {  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320  		}'  		// Layer-3  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320'  			384  		}'  		// Layer-2  		new[] {  			32'  			64'  			96'  			128'  			160'  			192'  			224'  			256'  			288'  			320'  			352'  			384'  			416'  			448  		}  	// Layer-1  	}  };  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: BitrateTable = new[] {  	new[] {  		// MPEG-2.5  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new int[3][]'  	new[] {  		// MPEG-2  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new[] {  		// MPEG-1  		new[] {  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320  		}'  		// Layer-3  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320'  			384  		}'  		// Layer-2  		new[] {  			32'  			64'  			96'  			128'  			160'  			192'  			224'  			256'  			288'  			320'  			352'  			384'  			416'  			448  		}  	// Layer-1  	}  };  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: BitrateTable = new[] {  	new[] {  		// MPEG-2.5  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new int[3][]'  	new[] {  		// MPEG-2  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new[] {  		// MPEG-1  		new[] {  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320  		}'  		// Layer-3  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320'  			384  		}'  		// Layer-2  		new[] {  			32'  			64'  			96'  			128'  			160'  			192'  			224'  			256'  			288'  			320'  			352'  			384'  			416'  			448  		}  	// Layer-1  	}  };  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: BitrateTable = new[] {  	new[] {  		// MPEG-2.5  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new int[3][]'  	new[] {  		// MPEG-2  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new[] {  		// MPEG-1  		new[] {  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320  		}'  		// Layer-3  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320'  			384  		}'  		// Layer-2  		new[] {  			32'  			64'  			96'  			128'  			160'  			192'  			224'  			256'  			288'  			320'  			352'  			384'  			416'  			448  		}  	// Layer-1  	}  };  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: BitrateTable = new[] {  	new[] {  		// MPEG-2.5  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new int[3][]'  	new[] {  		// MPEG-2  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new[] {  		// MPEG-1  		new[] {  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320  		}'  		// Layer-3  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320'  			384  		}'  		// Layer-2  		new[] {  			32'  			64'  			96'  			128'  			160'  			192'  			224'  			256'  			288'  			320'  			352'  			384'  			416'  			448  		}  	// Layer-1  	}  };  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: BitrateTable = new[] {  	new[] {  		// MPEG-2.5  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new int[3][]'  	new[] {  		// MPEG-2  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new[] {  		// MPEG-1  		new[] {  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320  		}'  		// Layer-3  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320'  			384  		}'  		// Layer-2  		new[] {  			32'  			64'  			96'  			128'  			160'  			192'  			224'  			256'  			288'  			320'  			352'  			384'  			416'  			448  		}  	// Layer-1  	}  };  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: BitrateTable = new[] {  	new[] {  		// MPEG-2.5  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new int[3][]'  	new[] {  		// MPEG-2  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new[] {  		// MPEG-1  		new[] {  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320  		}'  		// Layer-3  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320'  			384  		}'  		// Layer-2  		new[] {  			32'  			64'  			96'  			128'  			160'  			192'  			224'  			256'  			288'  			320'  			352'  			384'  			416'  			448  		}  	// Layer-1  	}  };  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: BitrateTable = new[] {  	new[] {  		// MPEG-2.5  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new int[3][]'  	new[] {  		// MPEG-2  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new[] {  		// MPEG-1  		new[] {  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320  		}'  		// Layer-3  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320'  			384  		}'  		// Layer-2  		new[] {  			32'  			64'  			96'  			128'  			160'  			192'  			224'  			256'  			288'  			320'  			352'  			384'  			416'  			448  		}  	// Layer-1  	}  };  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: BitrateTable = new[] {  	new[] {  		// MPEG-2.5  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new int[3][]'  	new[] {  		// MPEG-2  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new[] {  		// MPEG-1  		new[] {  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320  		}'  		// Layer-3  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320'  			384  		}'  		// Layer-2  		new[] {  			32'  			64'  			96'  			128'  			160'  			192'  			224'  			256'  			288'  			320'  			352'  			384'  			416'  			448  		}  	// Layer-1  	}  };  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: BitrateTable = new[] {  	new[] {  		// MPEG-2.5  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new int[3][]'  	new[] {  		// MPEG-2  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new[] {  		// MPEG-1  		new[] {  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320  		}'  		// Layer-3  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320'  			384  		}'  		// Layer-2  		new[] {  			32'  			64'  			96'  			128'  			160'  			192'  			224'  			256'  			288'  			320'  			352'  			384'  			416'  			448  		}  	// Layer-1  	}  };  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: BitrateTable = new[] {  	new[] {  		// MPEG-2.5  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new int[3][]'  	new[] {  		// MPEG-2  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new[] {  		// MPEG-1  		new[] {  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320  		}'  		// Layer-3  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320'  			384  		}'  		// Layer-2  		new[] {  			32'  			64'  			96'  			128'  			160'  			192'  			224'  			256'  			288'  			320'  			352'  			384'  			416'  			448  		}  	// Layer-1  	}  };  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: BitrateTable = new[] {  	new[] {  		// MPEG-2.5  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new int[3][]'  	new[] {  		// MPEG-2  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new[] {  		// MPEG-1  		new[] {  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320  		}'  		// Layer-3  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320'  			384  		}'  		// Layer-2  		new[] {  			32'  			64'  			96'  			128'  			160'  			192'  			224'  			256'  			288'  			320'  			352'  			384'  			416'  			448  		}  	// Layer-1  	}  };  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: BitrateTable = new[] {  	new[] {  		// MPEG-2.5  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new int[3][]'  	new[] {  		// MPEG-2  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new[] {  		// MPEG-1  		new[] {  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320  		}'  		// Layer-3  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320'  			384  		}'  		// Layer-2  		new[] {  			32'  			64'  			96'  			128'  			160'  			192'  			224'  			256'  			288'  			320'  			352'  			384'  			416'  			448  		}  	// Layer-1  	}  };  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: BitrateTable = new[] {  	new[] {  		// MPEG-2.5  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new int[3][]'  	new[] {  		// MPEG-2  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new[] {  		// MPEG-1  		new[] {  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320  		}'  		// Layer-3  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320'  			384  		}'  		// Layer-2  		new[] {  			32'  			64'  			96'  			128'  			160'  			192'  			224'  			256'  			288'  			320'  			352'  			384'  			416'  			448  		}  	// Layer-1  	}  };  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: BitrateTable = new[] {  	new[] {  		// MPEG-2.5  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new int[3][]'  	new[] {  		// MPEG-2  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new[] {  		// MPEG-1  		new[] {  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320  		}'  		// Layer-3  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320'  			384  		}'  		// Layer-2  		new[] {  			32'  			64'  			96'  			128'  			160'  			192'  			224'  			256'  			288'  			320'  			352'  			384'  			416'  			448  		}  	// Layer-1  	}  };  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: BitrateTable = new[] {  	new[] {  		// MPEG-2.5  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new int[3][]'  	new[] {  		// MPEG-2  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new[] {  		// MPEG-1  		new[] {  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320  		}'  		// Layer-3  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320'  			384  		}'  		// Layer-2  		new[] {  			32'  			64'  			96'  			128'  			160'  			192'  			224'  			256'  			288'  			320'  			352'  			384'  			416'  			448  		}  	// Layer-1  	}  };  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: BitrateTable = new[] {  	new[] {  		// MPEG-2.5  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new int[3][]'  	new[] {  		// MPEG-2  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new[] {  		// MPEG-1  		new[] {  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320  		}'  		// Layer-3  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320'  			384  		}'  		// Layer-2  		new[] {  			32'  			64'  			96'  			128'  			160'  			192'  			224'  			256'  			288'  			320'  			352'  			384'  			416'  			448  		}  	// Layer-1  	}  };  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: BitrateTable = new[] {  	new[] {  		// MPEG-2.5  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new int[3][]'  	new[] {  		// MPEG-2  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new[] {  		// MPEG-1  		new[] {  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320  		}'  		// Layer-3  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320'  			384  		}'  		// Layer-2  		new[] {  			32'  			64'  			96'  			128'  			160'  			192'  			224'  			256'  			288'  			320'  			352'  			384'  			416'  			448  		}  	// Layer-1  	}  };  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: BitrateTable = new[] {  	new[] {  		// MPEG-2.5  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new int[3][]'  	new[] {  		// MPEG-2  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new[] {  		// MPEG-1  		new[] {  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320  		}'  		// Layer-3  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320'  			384  		}'  		// Layer-2  		new[] {  			32'  			64'  			96'  			128'  			160'  			192'  			224'  			256'  			288'  			320'  			352'  			384'  			416'  			448  		}  	// Layer-1  	}  };  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: BitrateTable = new[] {  	new[] {  		// MPEG-2.5  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new int[3][]'  	new[] {  		// MPEG-2  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new[] {  		// MPEG-1  		new[] {  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320  		}'  		// Layer-3  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320'  			384  		}'  		// Layer-2  		new[] {  			32'  			64'  			96'  			128'  			160'  			192'  			224'  			256'  			288'  			320'  			352'  			384'  			416'  			448  		}  	// Layer-1  	}  };  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: BitrateTable = new[] {  	new[] {  		// MPEG-2.5  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new int[3][]'  	new[] {  		// MPEG-2  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new[] {  		// MPEG-1  		new[] {  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320  		}'  		// Layer-3  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320'  			384  		}'  		// Layer-2  		new[] {  			32'  			64'  			96'  			128'  			160'  			192'  			224'  			256'  			288'  			320'  			352'  			384'  			416'  			448  		}  	// Layer-1  	}  };  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: BitrateTable = new[] {  	new[] {  		// MPEG-2.5  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new int[3][]'  	new[] {  		// MPEG-2  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new[] {  		// MPEG-1  		new[] {  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320  		}'  		// Layer-3  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320'  			384  		}'  		// Layer-2  		new[] {  			32'  			64'  			96'  			128'  			160'  			192'  			224'  			256'  			288'  			320'  			352'  			384'  			416'  			448  		}  	// Layer-1  	}  };  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: BitrateTable = new[] {  	new[] {  		// MPEG-2.5  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new int[3][]'  	new[] {  		// MPEG-2  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new[] {  		// MPEG-1  		new[] {  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320  		}'  		// Layer-3  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320'  			384  		}'  		// Layer-2  		new[] {  			32'  			64'  			96'  			128'  			160'  			192'  			224'  			256'  			288'  			320'  			352'  			384'  			416'  			448  		}  	// Layer-1  	}  };  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: BitrateTable = new[] {  	new[] {  		// MPEG-2.5  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new int[3][]'  	new[] {  		// MPEG-2  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new[] {  		// MPEG-1  		new[] {  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320  		}'  		// Layer-3  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320'  			384  		}'  		// Layer-2  		new[] {  			32'  			64'  			96'  			128'  			160'  			192'  			224'  			256'  			288'  			320'  			352'  			384'  			416'  			448  		}  	// Layer-1  	}  };  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: BitrateTable = new[] {  	new[] {  		// MPEG-2.5  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new int[3][]'  	new[] {  		// MPEG-2  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new[] {  		// MPEG-1  		new[] {  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320  		}'  		// Layer-3  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320'  			384  		}'  		// Layer-2  		new[] {  			32'  			64'  			96'  			128'  			160'  			192'  			224'  			256'  			288'  			320'  			352'  			384'  			416'  			448  		}  	// Layer-1  	}  };  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: BitrateTable = new[] {  	new[] {  		// MPEG-2.5  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new int[3][]'  	new[] {  		// MPEG-2  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new[] {  		// MPEG-1  		new[] {  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320  		}'  		// Layer-3  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320'  			384  		}'  		// Layer-2  		new[] {  			32'  			64'  			96'  			128'  			160'  			192'  			224'  			256'  			288'  			320'  			352'  			384'  			416'  			448  		}  	// Layer-1  	}  };  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: BitrateTable = new[] {  	new[] {  		// MPEG-2.5  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new int[3][]'  	new[] {  		// MPEG-2  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new[] {  		// MPEG-1  		new[] {  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320  		}'  		// Layer-3  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320'  			384  		}'  		// Layer-2  		new[] {  			32'  			64'  			96'  			128'  			160'  			192'  			224'  			256'  			288'  			320'  			352'  			384'  			416'  			448  		}  	// Layer-1  	}  };  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: BitrateTable = new[] {  	new[] {  		// MPEG-2.5  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new int[3][]'  	new[] {  		// MPEG-2  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new[] {  		// MPEG-1  		new[] {  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320  		}'  		// Layer-3  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320'  			384  		}'  		// Layer-2  		new[] {  			32'  			64'  			96'  			128'  			160'  			192'  			224'  			256'  			288'  			320'  			352'  			384'  			416'  			448  		}  	// Layer-1  	}  };  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: BitrateTable = new[] {  	new[] {  		// MPEG-2.5  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new int[3][]'  	new[] {  		// MPEG-2  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new[] {  		// MPEG-1  		new[] {  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320  		}'  		// Layer-3  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320'  			384  		}'  		// Layer-2  		new[] {  			32'  			64'  			96'  			128'  			160'  			192'  			224'  			256'  			288'  			320'  			352'  			384'  			416'  			448  		}  	// Layer-1  	}  };  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: BitrateTable = new[] {  	new[] {  		// MPEG-2.5  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new int[3][]'  	new[] {  		// MPEG-2  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new[] {  		// MPEG-1  		new[] {  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320  		}'  		// Layer-3  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320'  			384  		}'  		// Layer-2  		new[] {  			32'  			64'  			96'  			128'  			160'  			192'  			224'  			256'  			288'  			320'  			352'  			384'  			416'  			448  		}  	// Layer-1  	}  };  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: BitrateTable = new[] {  	new[] {  		// MPEG-2.5  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new int[3][]'  	new[] {  		// MPEG-2  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new[] {  		// MPEG-1  		new[] {  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320  		}'  		// Layer-3  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320'  			384  		}'  		// Layer-2  		new[] {  			32'  			64'  			96'  			128'  			160'  			192'  			224'  			256'  			288'  			320'  			352'  			384'  			416'  			448  		}  	// Layer-1  	}  };  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: BitrateTable = new[] {  	new[] {  		// MPEG-2.5  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new int[3][]'  	new[] {  		// MPEG-2  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new[] {  		// MPEG-1  		new[] {  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320  		}'  		// Layer-3  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320'  			384  		}'  		// Layer-2  		new[] {  			32'  			64'  			96'  			128'  			160'  			192'  			224'  			256'  			288'  			320'  			352'  			384'  			416'  			448  		}  	// Layer-1  	}  };  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: BitrateTable = new[] {  	new[] {  		// MPEG-2.5  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new int[3][]'  	new[] {  		// MPEG-2  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new[] {  		// MPEG-1  		new[] {  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320  		}'  		// Layer-3  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320'  			384  		}'  		// Layer-2  		new[] {  			32'  			64'  			96'  			128'  			160'  			192'  			224'  			256'  			288'  			320'  			352'  			384'  			416'  			448  		}  	// Layer-1  	}  };  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: BitrateTable = new[] {  	new[] {  		// MPEG-2.5  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new int[3][]'  	new[] {  		// MPEG-2  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new[] {  		// MPEG-1  		new[] {  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320  		}'  		// Layer-3  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320'  			384  		}'  		// Layer-2  		new[] {  			32'  			64'  			96'  			128'  			160'  			192'  			224'  			256'  			288'  			320'  			352'  			384'  			416'  			448  		}  	// Layer-1  	}  };  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: BitrateTable = new[] {  	new[] {  		// MPEG-2.5  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new int[3][]'  	new[] {  		// MPEG-2  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new[] {  		// MPEG-1  		new[] {  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320  		}'  		// Layer-3  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320'  			384  		}'  		// Layer-2  		new[] {  			32'  			64'  			96'  			128'  			160'  			192'  			224'  			256'  			288'  			320'  			352'  			384'  			416'  			448  		}  	// Layer-1  	}  };  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: BitrateTable = new[] {  	new[] {  		// MPEG-2.5  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new int[3][]'  	new[] {  		// MPEG-2  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new[] {  		// MPEG-1  		new[] {  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320  		}'  		// Layer-3  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320'  			384  		}'  		// Layer-2  		new[] {  			32'  			64'  			96'  			128'  			160'  			192'  			224'  			256'  			288'  			320'  			352'  			384'  			416'  			448  		}  	// Layer-1  	}  };  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: BitrateTable = new[] {  	new[] {  		// MPEG-2.5  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new int[3][]'  	new[] {  		// MPEG-2  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new[] {  		// MPEG-1  		new[] {  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320  		}'  		// Layer-3  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320'  			384  		}'  		// Layer-2  		new[] {  			32'  			64'  			96'  			128'  			160'  			192'  			224'  			256'  			288'  			320'  			352'  			384'  			416'  			448  		}  	// Layer-1  	}  };  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: BitrateTable = new[] {  	new[] {  		// MPEG-2.5  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new int[3][]'  	new[] {  		// MPEG-2  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new[] {  		// MPEG-1  		new[] {  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320  		}'  		// Layer-3  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320'  			384  		}'  		// Layer-2  		new[] {  			32'  			64'  			96'  			128'  			160'  			192'  			224'  			256'  			288'  			320'  			352'  			384'  			416'  			448  		}  	// Layer-1  	}  };  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: BitrateTable = new[] {  	new[] {  		// MPEG-2.5  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new int[3][]'  	new[] {  		// MPEG-2  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new[] {  		// MPEG-1  		new[] {  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320  		}'  		// Layer-3  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320'  			384  		}'  		// Layer-2  		new[] {  			32'  			64'  			96'  			128'  			160'  			192'  			224'  			256'  			288'  			320'  			352'  			384'  			416'  			448  		}  	// Layer-1  	}  };  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: BitrateTable = new[] {  	new[] {  		// MPEG-2.5  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new int[3][]'  	new[] {  		// MPEG-2  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new[] {  		// MPEG-1  		new[] {  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320  		}'  		// Layer-3  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320'  			384  		}'  		// Layer-2  		new[] {  			32'  			64'  			96'  			128'  			160'  			192'  			224'  			256'  			288'  			320'  			352'  			384'  			416'  			448  		}  	// Layer-1  	}  };  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: BitrateTable = new[] {  	new[] {  		// MPEG-2.5  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new int[3][]'  	new[] {  		// MPEG-2  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new[] {  		// MPEG-1  		new[] {  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320  		}'  		// Layer-3  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320'  			384  		}'  		// Layer-2  		new[] {  			32'  			64'  			96'  			128'  			160'  			192'  			224'  			256'  			288'  			320'  			352'  			384'  			416'  			448  		}  	// Layer-1  	}  };  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: BitrateTable = new[] {  	new[] {  		// MPEG-2.5  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new int[3][]'  	new[] {  		// MPEG-2  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new[] {  		// MPEG-1  		new[] {  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320  		}'  		// Layer-3  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320'  			384  		}'  		// Layer-2  		new[] {  			32'  			64'  			96'  			128'  			160'  			192'  			224'  			256'  			288'  			320'  			352'  			384'  			416'  			448  		}  	// Layer-1  	}  };  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: BitrateTable = new[] {  	new[] {  		// MPEG-2.5  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new int[3][]'  	new[] {  		// MPEG-2  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new[] {  		// MPEG-1  		new[] {  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320  		}'  		// Layer-3  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320'  			384  		}'  		// Layer-2  		new[] {  			32'  			64'  			96'  			128'  			160'  			192'  			224'  			256'  			288'  			320'  			352'  			384'  			416'  			448  		}  	// Layer-1  	}  };  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: BitrateTable = new[] {  	new[] {  		// MPEG-2.5  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new int[3][]'  	new[] {  		// MPEG-2  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new[] {  		// MPEG-1  		new[] {  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320  		}'  		// Layer-3  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320'  			384  		}'  		// Layer-2  		new[] {  			32'  			64'  			96'  			128'  			160'  			192'  			224'  			256'  			288'  			320'  			352'  			384'  			416'  			448  		}  	// Layer-1  	}  };  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: BitrateTable = new[] {  	new[] {  		// MPEG-2.5  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new int[3][]'  	new[] {  		// MPEG-2  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new[] {  		// MPEG-1  		new[] {  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320  		}'  		// Layer-3  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320'  			384  		}'  		// Layer-2  		new[] {  			32'  			64'  			96'  			128'  			160'  			192'  			224'  			256'  			288'  			320'  			352'  			384'  			416'  			448  		}  	// Layer-1  	}  };  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: BitrateTable = new[] {  	new[] {  		// MPEG-2.5  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new int[3][]'  	new[] {  		// MPEG-2  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new[] {  		// MPEG-1  		new[] {  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320  		}'  		// Layer-3  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320'  			384  		}'  		// Layer-2  		new[] {  			32'  			64'  			96'  			128'  			160'  			192'  			224'  			256'  			288'  			320'  			352'  			384'  			416'  			448  		}  	// Layer-1  	}  };  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: BitrateTable = new[] {  	new[] {  		// MPEG-2.5  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new int[3][]'  	new[] {  		// MPEG-2  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new[] {  		// MPEG-1  		new[] {  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320  		}'  		// Layer-3  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320'  			384  		}'  		// Layer-2  		new[] {  			32'  			64'  			96'  			128'  			160'  			192'  			224'  			256'  			288'  			320'  			352'  			384'  			416'  			448  		}  	// Layer-1  	}  };  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: BitrateTable = new[] {  	new[] {  		// MPEG-2.5  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new int[3][]'  	new[] {  		// MPEG-2  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new[] {  		// MPEG-1  		new[] {  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320  		}'  		// Layer-3  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320'  			384  		}'  		// Layer-2  		new[] {  			32'  			64'  			96'  			128'  			160'  			192'  			224'  			256'  			288'  			320'  			352'  			384'  			416'  			448  		}  	// Layer-1  	}  };  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: BitrateTable = new[] {  	new[] {  		// MPEG-2.5  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new int[3][]'  	new[] {  		// MPEG-2  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new[] {  		// MPEG-1  		new[] {  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320  		}'  		// Layer-3  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320'  			384  		}'  		// Layer-2  		new[] {  			32'  			64'  			96'  			128'  			160'  			192'  			224'  			256'  			288'  			320'  			352'  			384'  			416'  			448  		}  	// Layer-1  	}  };  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: BitrateTable = new[] {  	new[] {  		// MPEG-2.5  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new int[3][]'  	new[] {  		// MPEG-2  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new[] {  		// MPEG-1  		new[] {  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320  		}'  		// Layer-3  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320'  			384  		}'  		// Layer-2  		new[] {  			32'  			64'  			96'  			128'  			160'  			192'  			224'  			256'  			288'  			320'  			352'  			384'  			416'  			448  		}  	// Layer-1  	}  };  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: BitrateTable = new[] {  	new[] {  		// MPEG-2.5  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new int[3][]'  	new[] {  		// MPEG-2  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new[] {  		// MPEG-1  		new[] {  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320  		}'  		// Layer-3  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320'  			384  		}'  		// Layer-2  		new[] {  			32'  			64'  			96'  			128'  			160'  			192'  			224'  			256'  			288'  			320'  			352'  			384'  			416'  			448  		}  	// Layer-1  	}  };  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: BitrateTable = new[] {  	new[] {  		// MPEG-2.5  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new int[3][]'  	new[] {  		// MPEG-2  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new[] {  		// MPEG-1  		new[] {  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320  		}'  		// Layer-3  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320'  			384  		}'  		// Layer-2  		new[] {  			32'  			64'  			96'  			128'  			160'  			192'  			224'  			256'  			288'  			320'  			352'  			384'  			416'  			448  		}  	// Layer-1  	}  };  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: BitrateTable = new[] {  	new[] {  		// MPEG-2.5  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new int[3][]'  	new[] {  		// MPEG-2  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new[] {  		// MPEG-1  		new[] {  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320  		}'  		// Layer-3  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320'  			384  		}'  		// Layer-2  		new[] {  			32'  			64'  			96'  			128'  			160'  			192'  			224'  			256'  			288'  			320'  			352'  			384'  			416'  			448  		}  	// Layer-1  	}  };  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: BitrateTable = new[] {  	new[] {  		// MPEG-2.5  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new int[3][]'  	new[] {  		// MPEG-2  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new[] {  		// MPEG-1  		new[] {  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320  		}'  		// Layer-3  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320'  			384  		}'  		// Layer-2  		new[] {  			32'  			64'  			96'  			128'  			160'  			192'  			224'  			256'  			288'  			320'  			352'  			384'  			416'  			448  		}  	// Layer-1  	}  };  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: BitrateTable = new[] {  	new[] {  		// MPEG-2.5  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new int[3][]'  	new[] {  		// MPEG-2  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new[] {  		// MPEG-1  		new[] {  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320  		}'  		// Layer-3  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320'  			384  		}'  		// Layer-2  		new[] {  			32'  			64'  			96'  			128'  			160'  			192'  			224'  			256'  			288'  			320'  			352'  			384'  			416'  			448  		}  	// Layer-1  	}  };  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: BitrateTable = new[] {  	new[] {  		// MPEG-2.5  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new int[3][]'  	new[] {  		// MPEG-2  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new[] {  		// MPEG-1  		new[] {  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320  		}'  		// Layer-3  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320'  			384  		}'  		// Layer-2  		new[] {  			32'  			64'  			96'  			128'  			160'  			192'  			224'  			256'  			288'  			320'  			352'  			384'  			416'  			448  		}  	// Layer-1  	}  };  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: BitrateTable = new[] {  	new[] {  		// MPEG-2.5  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new int[3][]'  	new[] {  		// MPEG-2  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new[] {  		// MPEG-1  		new[] {  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320  		}'  		// Layer-3  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320'  			384  		}'  		// Layer-2  		new[] {  			32'  			64'  			96'  			128'  			160'  			192'  			224'  			256'  			288'  			320'  			352'  			384'  			416'  			448  		}  	// Layer-1  	}  };  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: BitrateTable = new[] {  	new[] {  		// MPEG-2.5  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new int[3][]'  	new[] {  		// MPEG-2  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-3  		new[] {  			8'  			16'  			24'  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160  		}'  		// Layer-2  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			144'  			160'  			176'  			192'  			224'  			256  		}  	// Layer-1  	}'  	new[] {  		// MPEG-1  		new[] {  			32'  			40'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320  		}'  		// Layer-3  		new[] {  			32'  			48'  			56'  			64'  			80'  			96'  			112'  			128'  			160'  			192'  			224'  			256'  			320'  			384  		}'  		// Layer-2  		new[] {  			32'  			64'  			96'  			128'  			160'  			192'  			224'  			256'  			288'  			320'  			352'  			384'  			416'  			448  		}  	// Layer-1  	}  };  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: using (FileStream stream = File.Open (path' FileMode.Open' FileAccess.Read' FileShare.Read)) {  	int tmpID3v2TagSize = ID3v2.GetTagSize (stream);  	stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  	byte[] tmpFrameHeader = new byte[4];  	bool acceptNullSamples = false;  	while (true) {  		int tmpByte = stream.ReadByte ();  		// keep as ReadByte  		while (tmpByte != 0xFF && tmpByte != -1) {  			tmpByte = stream.ReadByte ();  			// keep as ReadByte  		}  		if (tmpByte == -1) {  			if (acceptNullSamples) {  				throw new InvalidDataException (string.Format ("'{0}': Can't find frame sync"' path));  			}  			stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  			acceptNullSamples = true;  			continue;  		}  		tmpFrameHeader [0] = (byte)tmpByte;  		// Get frame header  		if (stream.Read (tmpFrameHeader' 1' 3) != 3) {  			throw new InvalidDataException (string.Format ("'{0}': Invalid MPEG file; end of stream reached"' path));  		}  		// No sync  		if ((tmpFrameHeader [1] >> 5) != 0x07 || ((tmpFrameHeader [1] >> 1) & 0x03) == 0)// 2/18/05 - ignore reserved layer  		 {  			stream.Seek (-3' SeekOrigin.Current);  		} else if (tmpFrameHeader [1] == 0xFF || ((tmpFrameHeader [1] >> 3) & 0x03) == 1)// 2/19/05 - more bad data  		 {  			stream.Seek (-3' SeekOrigin.Current);  		} else {  			int tmpMpegID = (tmpFrameHeader [1] >> 3) & 0x03;  			int tmpLayerNum = (tmpFrameHeader [1] >> 1) & 0x03;  			int tmpFrequency = GetFrequency ((MpegVersion)tmpMpegID' (tmpFrameHeader [2] >> 2) & 0x03);  			// Check for invalid frequency  			if (tmpFrequency == 0) {  				stream.Seek (-3' SeekOrigin.Current);  				continue;  			}  			int tmpSamplesPerFrame = GetSamplesPerFrame ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum);  			int tmpUsesPadding = (tmpFrameHeader [2] >> 1) & 0x01;  			double tmpFrameSizeConst = 125.0 * tmpSamplesPerFrame / tmpFrequency;  			int tmpPaddingSize = (tmpLayerNum == 3 ? 4 : 1);  			int tmpBitrateIndex = tmpFrameHeader [2] >> 4;  			// Check for invalid values  			if (tmpBitrateIndex < 1 || tmpBitrateIndex > 14 || tmpLayerNum == 0) {  				stream.Seek (-3' SeekOrigin.Current);  				continue;  			}  			int tmpFrameBitrate = GetBitrate ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum' tmpBitrateIndex);  			int tmpFrameSize = (int)(tmpFrameBitrate * tmpFrameSizeConst) + (tmpUsesPadding * tmpPaddingSize);  			_headerOffset = stream.Position - 4;  			if (tmpFrameSize < 8) {  				stream.Seek (-3' SeekOrigin.Current);  				continue;  			}  			// 7/21/05 - Check for 0x00 or 0xFF at end of last frame  			// this sucks for tracks that start with silence  			if (_headerOffset >= 1 && !acceptNullSamples)// if (ftell(fp) >= 5)  			 {  				stream.Seek (-5' SeekOrigin.Current);  				byte tmpLastByte = stream.Read1 ();  				stream.Seek (4' SeekOrigin.Current);  				if (tmpFrameBitrate != 320 && (tmpLastByte == 0x00 || tmpLastByte == 0xFF)) {  					// 7/31/05  					// may be a valid frame - skip its contents to prevent false sync  					long tmpNewPosition = _headerOffset + tmpFrameSize;  					if (tmpFrameSize == 0)  						tmpNewPosition++;  					stream.Seek (tmpNewPosition' SeekOrigin.Begin);  					continue;  				}  			}  			/*if (BR == 0 || FrameSizeConst == 0)                         {                             startpos = HeaderOffset+1;                             fseek(fp' startpos' SEEK_SET);                             continue;                         }*/stream.Seek (_headerOffset + tmpFrameSize' SeekOrigin.Begin);  			if (stream.Read1 () == 0xFF) {  				fh1 = stream.Read1 ();  				fh2 = stream.Read1 ();  				if (tmpFrameHeader [1] == fh1 && (tmpFrameHeader [2] & 0x0D) == (fh2 & 0x0D)) {  					// header found  					break;  				}  			}  			stream.Seek (_headerOffset + 1' SeekOrigin.Begin);  			continue;  		}  	}  	_mpegVersion = (MpegVersion)((tmpFrameHeader [1] >> 3) & 0x03);  	_mpegLayer = (MpegLayer)((tmpFrameHeader [1] >> 1) & 0x03);  	_frequency = GetFrequency (_mpegVersion' (tmpFrameHeader [2] >> 2) & 0x03);  	if (_frequency == 0) {  		throw new InvalidDataException (String.Format ("'{0}'; cannot determine frequency"' path));  	}  	_isPrivate = ((tmpFrameHeader [2] & 0x01) == 0x01);  	_samplesPerFrame = GetSamplesPerFrame (_mpegVersion' _mpegLayer);  	_frameSizeConst = 125.0 * _samplesPerFrame / _frequency;  	_paddingSizeConst = (_mpegLayer == MpegLayer.Layer1 ? 4 : 1);  	_isCopyright = (((tmpFrameHeader [3] >> 3) & 0x01) == 0x01);  	_isOriginal = (((tmpFrameHeader [3] >> 2) & 0x01) == 0x01);  	//tmpModeExtension = (FH[3] >> 4) & 0x03; // not interested' only used in joint-stereo  	//_mpegEmphasis = (MpegEmphasis)(tmpFrameHeader[3] & 0x03);  	if ((tmpFrameHeader [3] >> 6) == 3)  		_channels = 1;  	// Single Channel  	else  		_channels = 2;  	// Read LAME Info Tag  	bool tmpHasLameInfoTag = false;  	stream.Seek (tmpID3v2TagSize + 36' SeekOrigin.Begin);  	Byte[] buf = stream.Read (4);  	if (ByteUtils.Compare (buf' INFO_MARKER))// CBR  	 {  		tmpHasLameInfoTag = true;  		_isVBR = false;  	} else if (ByteUtils.Compare (buf' XING_MARKER))// VBR  	 {  		tmpHasLameInfoTag = true;  		_isVBR = true;  	}  	if (tmpHasLameInfoTag) {  		stream.Seek (4' SeekOrigin.Current);  		int tmpFrames = stream.ReadInt32 ();  		uint tmpBytes = (uint)stream.ReadInt32 ();  		if (tmpFrames > 256 && tmpBytes > 50000) {  			decimal tmpBitrate = tmpBytes / 125.0m / (tmpFrames * _samplesPerFrame / (decimal)_frequency);  			if (tmpBitrate <= 320 && tmpBitrate >= 32) {  				_frames = tmpFrames;  				_bitrate = tmpBitrate;  				_totalSeconds = (tmpBytes / 125.0m) / _bitrate;  			}  		}  	}  	// TODO: Take these 2 lines out  	/*fs.Position = 0;                 CalculateBitrate(fs' null);*/if (calculateBitrate) {  		if (_bitrate == 0 || _isVBR == null || _frames == 0 || _totalSeconds == 0) {  			stream.Position = 0;  			CalculateBitrate (stream' null);  		}  	}  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: using (FileStream stream = File.Open (path' FileMode.Open' FileAccess.Read' FileShare.Read)) {  	int tmpID3v2TagSize = ID3v2.GetTagSize (stream);  	stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  	byte[] tmpFrameHeader = new byte[4];  	bool acceptNullSamples = false;  	while (true) {  		int tmpByte = stream.ReadByte ();  		// keep as ReadByte  		while (tmpByte != 0xFF && tmpByte != -1) {  			tmpByte = stream.ReadByte ();  			// keep as ReadByte  		}  		if (tmpByte == -1) {  			if (acceptNullSamples) {  				throw new InvalidDataException (string.Format ("'{0}': Can't find frame sync"' path));  			}  			stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  			acceptNullSamples = true;  			continue;  		}  		tmpFrameHeader [0] = (byte)tmpByte;  		// Get frame header  		if (stream.Read (tmpFrameHeader' 1' 3) != 3) {  			throw new InvalidDataException (string.Format ("'{0}': Invalid MPEG file; end of stream reached"' path));  		}  		// No sync  		if ((tmpFrameHeader [1] >> 5) != 0x07 || ((tmpFrameHeader [1] >> 1) & 0x03) == 0)// 2/18/05 - ignore reserved layer  		 {  			stream.Seek (-3' SeekOrigin.Current);  		} else if (tmpFrameHeader [1] == 0xFF || ((tmpFrameHeader [1] >> 3) & 0x03) == 1)// 2/19/05 - more bad data  		 {  			stream.Seek (-3' SeekOrigin.Current);  		} else {  			int tmpMpegID = (tmpFrameHeader [1] >> 3) & 0x03;  			int tmpLayerNum = (tmpFrameHeader [1] >> 1) & 0x03;  			int tmpFrequency = GetFrequency ((MpegVersion)tmpMpegID' (tmpFrameHeader [2] >> 2) & 0x03);  			// Check for invalid frequency  			if (tmpFrequency == 0) {  				stream.Seek (-3' SeekOrigin.Current);  				continue;  			}  			int tmpSamplesPerFrame = GetSamplesPerFrame ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum);  			int tmpUsesPadding = (tmpFrameHeader [2] >> 1) & 0x01;  			double tmpFrameSizeConst = 125.0 * tmpSamplesPerFrame / tmpFrequency;  			int tmpPaddingSize = (tmpLayerNum == 3 ? 4 : 1);  			int tmpBitrateIndex = tmpFrameHeader [2] >> 4;  			// Check for invalid values  			if (tmpBitrateIndex < 1 || tmpBitrateIndex > 14 || tmpLayerNum == 0) {  				stream.Seek (-3' SeekOrigin.Current);  				continue;  			}  			int tmpFrameBitrate = GetBitrate ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum' tmpBitrateIndex);  			int tmpFrameSize = (int)(tmpFrameBitrate * tmpFrameSizeConst) + (tmpUsesPadding * tmpPaddingSize);  			_headerOffset = stream.Position - 4;  			if (tmpFrameSize < 8) {  				stream.Seek (-3' SeekOrigin.Current);  				continue;  			}  			// 7/21/05 - Check for 0x00 or 0xFF at end of last frame  			// this sucks for tracks that start with silence  			if (_headerOffset >= 1 && !acceptNullSamples)// if (ftell(fp) >= 5)  			 {  				stream.Seek (-5' SeekOrigin.Current);  				byte tmpLastByte = stream.Read1 ();  				stream.Seek (4' SeekOrigin.Current);  				if (tmpFrameBitrate != 320 && (tmpLastByte == 0x00 || tmpLastByte == 0xFF)) {  					// 7/31/05  					// may be a valid frame - skip its contents to prevent false sync  					long tmpNewPosition = _headerOffset + tmpFrameSize;  					if (tmpFrameSize == 0)  						tmpNewPosition++;  					stream.Seek (tmpNewPosition' SeekOrigin.Begin);  					continue;  				}  			}  			/*if (BR == 0 || FrameSizeConst == 0)                         {                             startpos = HeaderOffset+1;                             fseek(fp' startpos' SEEK_SET);                             continue;                         }*/stream.Seek (_headerOffset + tmpFrameSize' SeekOrigin.Begin);  			if (stream.Read1 () == 0xFF) {  				fh1 = stream.Read1 ();  				fh2 = stream.Read1 ();  				if (tmpFrameHeader [1] == fh1 && (tmpFrameHeader [2] & 0x0D) == (fh2 & 0x0D)) {  					// header found  					break;  				}  			}  			stream.Seek (_headerOffset + 1' SeekOrigin.Begin);  			continue;  		}  	}  	_mpegVersion = (MpegVersion)((tmpFrameHeader [1] >> 3) & 0x03);  	_mpegLayer = (MpegLayer)((tmpFrameHeader [1] >> 1) & 0x03);  	_frequency = GetFrequency (_mpegVersion' (tmpFrameHeader [2] >> 2) & 0x03);  	if (_frequency == 0) {  		throw new InvalidDataException (String.Format ("'{0}'; cannot determine frequency"' path));  	}  	_isPrivate = ((tmpFrameHeader [2] & 0x01) == 0x01);  	_samplesPerFrame = GetSamplesPerFrame (_mpegVersion' _mpegLayer);  	_frameSizeConst = 125.0 * _samplesPerFrame / _frequency;  	_paddingSizeConst = (_mpegLayer == MpegLayer.Layer1 ? 4 : 1);  	_isCopyright = (((tmpFrameHeader [3] >> 3) & 0x01) == 0x01);  	_isOriginal = (((tmpFrameHeader [3] >> 2) & 0x01) == 0x01);  	//tmpModeExtension = (FH[3] >> 4) & 0x03; // not interested' only used in joint-stereo  	//_mpegEmphasis = (MpegEmphasis)(tmpFrameHeader[3] & 0x03);  	if ((tmpFrameHeader [3] >> 6) == 3)  		_channels = 1;  	// Single Channel  	else  		_channels = 2;  	// Read LAME Info Tag  	bool tmpHasLameInfoTag = false;  	stream.Seek (tmpID3v2TagSize + 36' SeekOrigin.Begin);  	Byte[] buf = stream.Read (4);  	if (ByteUtils.Compare (buf' INFO_MARKER))// CBR  	 {  		tmpHasLameInfoTag = true;  		_isVBR = false;  	} else if (ByteUtils.Compare (buf' XING_MARKER))// VBR  	 {  		tmpHasLameInfoTag = true;  		_isVBR = true;  	}  	if (tmpHasLameInfoTag) {  		stream.Seek (4' SeekOrigin.Current);  		int tmpFrames = stream.ReadInt32 ();  		uint tmpBytes = (uint)stream.ReadInt32 ();  		if (tmpFrames > 256 && tmpBytes > 50000) {  			decimal tmpBitrate = tmpBytes / 125.0m / (tmpFrames * _samplesPerFrame / (decimal)_frequency);  			if (tmpBitrate <= 320 && tmpBitrate >= 32) {  				_frames = tmpFrames;  				_bitrate = tmpBitrate;  				_totalSeconds = (tmpBytes / 125.0m) / _bitrate;  			}  		}  	}  	// TODO: Take these 2 lines out  	/*fs.Position = 0;                 CalculateBitrate(fs' null);*/if (calculateBitrate) {  		if (_bitrate == 0 || _isVBR == null || _frames == 0 || _totalSeconds == 0) {  			stream.Position = 0;  			CalculateBitrate (stream' null);  		}  	}  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: using (FileStream stream = File.Open (path' FileMode.Open' FileAccess.Read' FileShare.Read)) {  	int tmpID3v2TagSize = ID3v2.GetTagSize (stream);  	stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  	byte[] tmpFrameHeader = new byte[4];  	bool acceptNullSamples = false;  	while (true) {  		int tmpByte = stream.ReadByte ();  		// keep as ReadByte  		while (tmpByte != 0xFF && tmpByte != -1) {  			tmpByte = stream.ReadByte ();  			// keep as ReadByte  		}  		if (tmpByte == -1) {  			if (acceptNullSamples) {  				throw new InvalidDataException (string.Format ("'{0}': Can't find frame sync"' path));  			}  			stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  			acceptNullSamples = true;  			continue;  		}  		tmpFrameHeader [0] = (byte)tmpByte;  		// Get frame header  		if (stream.Read (tmpFrameHeader' 1' 3) != 3) {  			throw new InvalidDataException (string.Format ("'{0}': Invalid MPEG file; end of stream reached"' path));  		}  		// No sync  		if ((tmpFrameHeader [1] >> 5) != 0x07 || ((tmpFrameHeader [1] >> 1) & 0x03) == 0)// 2/18/05 - ignore reserved layer  		 {  			stream.Seek (-3' SeekOrigin.Current);  		} else if (tmpFrameHeader [1] == 0xFF || ((tmpFrameHeader [1] >> 3) & 0x03) == 1)// 2/19/05 - more bad data  		 {  			stream.Seek (-3' SeekOrigin.Current);  		} else {  			int tmpMpegID = (tmpFrameHeader [1] >> 3) & 0x03;  			int tmpLayerNum = (tmpFrameHeader [1] >> 1) & 0x03;  			int tmpFrequency = GetFrequency ((MpegVersion)tmpMpegID' (tmpFrameHeader [2] >> 2) & 0x03);  			// Check for invalid frequency  			if (tmpFrequency == 0) {  				stream.Seek (-3' SeekOrigin.Current);  				continue;  			}  			int tmpSamplesPerFrame = GetSamplesPerFrame ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum);  			int tmpUsesPadding = (tmpFrameHeader [2] >> 1) & 0x01;  			double tmpFrameSizeConst = 125.0 * tmpSamplesPerFrame / tmpFrequency;  			int tmpPaddingSize = (tmpLayerNum == 3 ? 4 : 1);  			int tmpBitrateIndex = tmpFrameHeader [2] >> 4;  			// Check for invalid values  			if (tmpBitrateIndex < 1 || tmpBitrateIndex > 14 || tmpLayerNum == 0) {  				stream.Seek (-3' SeekOrigin.Current);  				continue;  			}  			int tmpFrameBitrate = GetBitrate ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum' tmpBitrateIndex);  			int tmpFrameSize = (int)(tmpFrameBitrate * tmpFrameSizeConst) + (tmpUsesPadding * tmpPaddingSize);  			_headerOffset = stream.Position - 4;  			if (tmpFrameSize < 8) {  				stream.Seek (-3' SeekOrigin.Current);  				continue;  			}  			// 7/21/05 - Check for 0x00 or 0xFF at end of last frame  			// this sucks for tracks that start with silence  			if (_headerOffset >= 1 && !acceptNullSamples)// if (ftell(fp) >= 5)  			 {  				stream.Seek (-5' SeekOrigin.Current);  				byte tmpLastByte = stream.Read1 ();  				stream.Seek (4' SeekOrigin.Current);  				if (tmpFrameBitrate != 320 && (tmpLastByte == 0x00 || tmpLastByte == 0xFF)) {  					// 7/31/05  					// may be a valid frame - skip its contents to prevent false sync  					long tmpNewPosition = _headerOffset + tmpFrameSize;  					if (tmpFrameSize == 0)  						tmpNewPosition++;  					stream.Seek (tmpNewPosition' SeekOrigin.Begin);  					continue;  				}  			}  			/*if (BR == 0 || FrameSizeConst == 0)                         {                             startpos = HeaderOffset+1;                             fseek(fp' startpos' SEEK_SET);                             continue;                         }*/stream.Seek (_headerOffset + tmpFrameSize' SeekOrigin.Begin);  			if (stream.Read1 () == 0xFF) {  				fh1 = stream.Read1 ();  				fh2 = stream.Read1 ();  				if (tmpFrameHeader [1] == fh1 && (tmpFrameHeader [2] & 0x0D) == (fh2 & 0x0D)) {  					// header found  					break;  				}  			}  			stream.Seek (_headerOffset + 1' SeekOrigin.Begin);  			continue;  		}  	}  	_mpegVersion = (MpegVersion)((tmpFrameHeader [1] >> 3) & 0x03);  	_mpegLayer = (MpegLayer)((tmpFrameHeader [1] >> 1) & 0x03);  	_frequency = GetFrequency (_mpegVersion' (tmpFrameHeader [2] >> 2) & 0x03);  	if (_frequency == 0) {  		throw new InvalidDataException (String.Format ("'{0}'; cannot determine frequency"' path));  	}  	_isPrivate = ((tmpFrameHeader [2] & 0x01) == 0x01);  	_samplesPerFrame = GetSamplesPerFrame (_mpegVersion' _mpegLayer);  	_frameSizeConst = 125.0 * _samplesPerFrame / _frequency;  	_paddingSizeConst = (_mpegLayer == MpegLayer.Layer1 ? 4 : 1);  	_isCopyright = (((tmpFrameHeader [3] >> 3) & 0x01) == 0x01);  	_isOriginal = (((tmpFrameHeader [3] >> 2) & 0x01) == 0x01);  	//tmpModeExtension = (FH[3] >> 4) & 0x03; // not interested' only used in joint-stereo  	//_mpegEmphasis = (MpegEmphasis)(tmpFrameHeader[3] & 0x03);  	if ((tmpFrameHeader [3] >> 6) == 3)  		_channels = 1;  	// Single Channel  	else  		_channels = 2;  	// Read LAME Info Tag  	bool tmpHasLameInfoTag = false;  	stream.Seek (tmpID3v2TagSize + 36' SeekOrigin.Begin);  	Byte[] buf = stream.Read (4);  	if (ByteUtils.Compare (buf' INFO_MARKER))// CBR  	 {  		tmpHasLameInfoTag = true;  		_isVBR = false;  	} else if (ByteUtils.Compare (buf' XING_MARKER))// VBR  	 {  		tmpHasLameInfoTag = true;  		_isVBR = true;  	}  	if (tmpHasLameInfoTag) {  		stream.Seek (4' SeekOrigin.Current);  		int tmpFrames = stream.ReadInt32 ();  		uint tmpBytes = (uint)stream.ReadInt32 ();  		if (tmpFrames > 256 && tmpBytes > 50000) {  			decimal tmpBitrate = tmpBytes / 125.0m / (tmpFrames * _samplesPerFrame / (decimal)_frequency);  			if (tmpBitrate <= 320 && tmpBitrate >= 32) {  				_frames = tmpFrames;  				_bitrate = tmpBitrate;  				_totalSeconds = (tmpBytes / 125.0m) / _bitrate;  			}  		}  	}  	// TODO: Take these 2 lines out  	/*fs.Position = 0;                 CalculateBitrate(fs' null);*/if (calculateBitrate) {  		if (_bitrate == 0 || _isVBR == null || _frames == 0 || _totalSeconds == 0) {  			stream.Position = 0;  			CalculateBitrate (stream' null);  		}  	}  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: using (FileStream stream = File.Open (path' FileMode.Open' FileAccess.Read' FileShare.Read)) {  	int tmpID3v2TagSize = ID3v2.GetTagSize (stream);  	stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  	byte[] tmpFrameHeader = new byte[4];  	bool acceptNullSamples = false;  	while (true) {  		int tmpByte = stream.ReadByte ();  		// keep as ReadByte  		while (tmpByte != 0xFF && tmpByte != -1) {  			tmpByte = stream.ReadByte ();  			// keep as ReadByte  		}  		if (tmpByte == -1) {  			if (acceptNullSamples) {  				throw new InvalidDataException (string.Format ("'{0}': Can't find frame sync"' path));  			}  			stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  			acceptNullSamples = true;  			continue;  		}  		tmpFrameHeader [0] = (byte)tmpByte;  		// Get frame header  		if (stream.Read (tmpFrameHeader' 1' 3) != 3) {  			throw new InvalidDataException (string.Format ("'{0}': Invalid MPEG file; end of stream reached"' path));  		}  		// No sync  		if ((tmpFrameHeader [1] >> 5) != 0x07 || ((tmpFrameHeader [1] >> 1) & 0x03) == 0)// 2/18/05 - ignore reserved layer  		 {  			stream.Seek (-3' SeekOrigin.Current);  		} else if (tmpFrameHeader [1] == 0xFF || ((tmpFrameHeader [1] >> 3) & 0x03) == 1)// 2/19/05 - more bad data  		 {  			stream.Seek (-3' SeekOrigin.Current);  		} else {  			int tmpMpegID = (tmpFrameHeader [1] >> 3) & 0x03;  			int tmpLayerNum = (tmpFrameHeader [1] >> 1) & 0x03;  			int tmpFrequency = GetFrequency ((MpegVersion)tmpMpegID' (tmpFrameHeader [2] >> 2) & 0x03);  			// Check for invalid frequency  			if (tmpFrequency == 0) {  				stream.Seek (-3' SeekOrigin.Current);  				continue;  			}  			int tmpSamplesPerFrame = GetSamplesPerFrame ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum);  			int tmpUsesPadding = (tmpFrameHeader [2] >> 1) & 0x01;  			double tmpFrameSizeConst = 125.0 * tmpSamplesPerFrame / tmpFrequency;  			int tmpPaddingSize = (tmpLayerNum == 3 ? 4 : 1);  			int tmpBitrateIndex = tmpFrameHeader [2] >> 4;  			// Check for invalid values  			if (tmpBitrateIndex < 1 || tmpBitrateIndex > 14 || tmpLayerNum == 0) {  				stream.Seek (-3' SeekOrigin.Current);  				continue;  			}  			int tmpFrameBitrate = GetBitrate ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum' tmpBitrateIndex);  			int tmpFrameSize = (int)(tmpFrameBitrate * tmpFrameSizeConst) + (tmpUsesPadding * tmpPaddingSize);  			_headerOffset = stream.Position - 4;  			if (tmpFrameSize < 8) {  				stream.Seek (-3' SeekOrigin.Current);  				continue;  			}  			// 7/21/05 - Check for 0x00 or 0xFF at end of last frame  			// this sucks for tracks that start with silence  			if (_headerOffset >= 1 && !acceptNullSamples)// if (ftell(fp) >= 5)  			 {  				stream.Seek (-5' SeekOrigin.Current);  				byte tmpLastByte = stream.Read1 ();  				stream.Seek (4' SeekOrigin.Current);  				if (tmpFrameBitrate != 320 && (tmpLastByte == 0x00 || tmpLastByte == 0xFF)) {  					// 7/31/05  					// may be a valid frame - skip its contents to prevent false sync  					long tmpNewPosition = _headerOffset + tmpFrameSize;  					if (tmpFrameSize == 0)  						tmpNewPosition++;  					stream.Seek (tmpNewPosition' SeekOrigin.Begin);  					continue;  				}  			}  			/*if (BR == 0 || FrameSizeConst == 0)                         {                             startpos = HeaderOffset+1;                             fseek(fp' startpos' SEEK_SET);                             continue;                         }*/stream.Seek (_headerOffset + tmpFrameSize' SeekOrigin.Begin);  			if (stream.Read1 () == 0xFF) {  				fh1 = stream.Read1 ();  				fh2 = stream.Read1 ();  				if (tmpFrameHeader [1] == fh1 && (tmpFrameHeader [2] & 0x0D) == (fh2 & 0x0D)) {  					// header found  					break;  				}  			}  			stream.Seek (_headerOffset + 1' SeekOrigin.Begin);  			continue;  		}  	}  	_mpegVersion = (MpegVersion)((tmpFrameHeader [1] >> 3) & 0x03);  	_mpegLayer = (MpegLayer)((tmpFrameHeader [1] >> 1) & 0x03);  	_frequency = GetFrequency (_mpegVersion' (tmpFrameHeader [2] >> 2) & 0x03);  	if (_frequency == 0) {  		throw new InvalidDataException (String.Format ("'{0}'; cannot determine frequency"' path));  	}  	_isPrivate = ((tmpFrameHeader [2] & 0x01) == 0x01);  	_samplesPerFrame = GetSamplesPerFrame (_mpegVersion' _mpegLayer);  	_frameSizeConst = 125.0 * _samplesPerFrame / _frequency;  	_paddingSizeConst = (_mpegLayer == MpegLayer.Layer1 ? 4 : 1);  	_isCopyright = (((tmpFrameHeader [3] >> 3) & 0x01) == 0x01);  	_isOriginal = (((tmpFrameHeader [3] >> 2) & 0x01) == 0x01);  	//tmpModeExtension = (FH[3] >> 4) & 0x03; // not interested' only used in joint-stereo  	//_mpegEmphasis = (MpegEmphasis)(tmpFrameHeader[3] & 0x03);  	if ((tmpFrameHeader [3] >> 6) == 3)  		_channels = 1;  	// Single Channel  	else  		_channels = 2;  	// Read LAME Info Tag  	bool tmpHasLameInfoTag = false;  	stream.Seek (tmpID3v2TagSize + 36' SeekOrigin.Begin);  	Byte[] buf = stream.Read (4);  	if (ByteUtils.Compare (buf' INFO_MARKER))// CBR  	 {  		tmpHasLameInfoTag = true;  		_isVBR = false;  	} else if (ByteUtils.Compare (buf' XING_MARKER))// VBR  	 {  		tmpHasLameInfoTag = true;  		_isVBR = true;  	}  	if (tmpHasLameInfoTag) {  		stream.Seek (4' SeekOrigin.Current);  		int tmpFrames = stream.ReadInt32 ();  		uint tmpBytes = (uint)stream.ReadInt32 ();  		if (tmpFrames > 256 && tmpBytes > 50000) {  			decimal tmpBitrate = tmpBytes / 125.0m / (tmpFrames * _samplesPerFrame / (decimal)_frequency);  			if (tmpBitrate <= 320 && tmpBitrate >= 32) {  				_frames = tmpFrames;  				_bitrate = tmpBitrate;  				_totalSeconds = (tmpBytes / 125.0m) / _bitrate;  			}  		}  	}  	// TODO: Take these 2 lines out  	/*fs.Position = 0;                 CalculateBitrate(fs' null);*/if (calculateBitrate) {  		if (_bitrate == 0 || _isVBR == null || _frames == 0 || _totalSeconds == 0) {  			stream.Position = 0;  			CalculateBitrate (stream' null);  		}  	}  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: using (FileStream stream = File.Open (path' FileMode.Open' FileAccess.Read' FileShare.Read)) {  	int tmpID3v2TagSize = ID3v2.GetTagSize (stream);  	stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  	byte[] tmpFrameHeader = new byte[4];  	bool acceptNullSamples = false;  	while (true) {  		int tmpByte = stream.ReadByte ();  		// keep as ReadByte  		while (tmpByte != 0xFF && tmpByte != -1) {  			tmpByte = stream.ReadByte ();  			// keep as ReadByte  		}  		if (tmpByte == -1) {  			if (acceptNullSamples) {  				throw new InvalidDataException (string.Format ("'{0}': Can't find frame sync"' path));  			}  			stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  			acceptNullSamples = true;  			continue;  		}  		tmpFrameHeader [0] = (byte)tmpByte;  		// Get frame header  		if (stream.Read (tmpFrameHeader' 1' 3) != 3) {  			throw new InvalidDataException (string.Format ("'{0}': Invalid MPEG file; end of stream reached"' path));  		}  		// No sync  		if ((tmpFrameHeader [1] >> 5) != 0x07 || ((tmpFrameHeader [1] >> 1) & 0x03) == 0)// 2/18/05 - ignore reserved layer  		 {  			stream.Seek (-3' SeekOrigin.Current);  		} else if (tmpFrameHeader [1] == 0xFF || ((tmpFrameHeader [1] >> 3) & 0x03) == 1)// 2/19/05 - more bad data  		 {  			stream.Seek (-3' SeekOrigin.Current);  		} else {  			int tmpMpegID = (tmpFrameHeader [1] >> 3) & 0x03;  			int tmpLayerNum = (tmpFrameHeader [1] >> 1) & 0x03;  			int tmpFrequency = GetFrequency ((MpegVersion)tmpMpegID' (tmpFrameHeader [2] >> 2) & 0x03);  			// Check for invalid frequency  			if (tmpFrequency == 0) {  				stream.Seek (-3' SeekOrigin.Current);  				continue;  			}  			int tmpSamplesPerFrame = GetSamplesPerFrame ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum);  			int tmpUsesPadding = (tmpFrameHeader [2] >> 1) & 0x01;  			double tmpFrameSizeConst = 125.0 * tmpSamplesPerFrame / tmpFrequency;  			int tmpPaddingSize = (tmpLayerNum == 3 ? 4 : 1);  			int tmpBitrateIndex = tmpFrameHeader [2] >> 4;  			// Check for invalid values  			if (tmpBitrateIndex < 1 || tmpBitrateIndex > 14 || tmpLayerNum == 0) {  				stream.Seek (-3' SeekOrigin.Current);  				continue;  			}  			int tmpFrameBitrate = GetBitrate ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum' tmpBitrateIndex);  			int tmpFrameSize = (int)(tmpFrameBitrate * tmpFrameSizeConst) + (tmpUsesPadding * tmpPaddingSize);  			_headerOffset = stream.Position - 4;  			if (tmpFrameSize < 8) {  				stream.Seek (-3' SeekOrigin.Current);  				continue;  			}  			// 7/21/05 - Check for 0x00 or 0xFF at end of last frame  			// this sucks for tracks that start with silence  			if (_headerOffset >= 1 && !acceptNullSamples)// if (ftell(fp) >= 5)  			 {  				stream.Seek (-5' SeekOrigin.Current);  				byte tmpLastByte = stream.Read1 ();  				stream.Seek (4' SeekOrigin.Current);  				if (tmpFrameBitrate != 320 && (tmpLastByte == 0x00 || tmpLastByte == 0xFF)) {  					// 7/31/05  					// may be a valid frame - skip its contents to prevent false sync  					long tmpNewPosition = _headerOffset + tmpFrameSize;  					if (tmpFrameSize == 0)  						tmpNewPosition++;  					stream.Seek (tmpNewPosition' SeekOrigin.Begin);  					continue;  				}  			}  			/*if (BR == 0 || FrameSizeConst == 0)                         {                             startpos = HeaderOffset+1;                             fseek(fp' startpos' SEEK_SET);                             continue;                         }*/stream.Seek (_headerOffset + tmpFrameSize' SeekOrigin.Begin);  			if (stream.Read1 () == 0xFF) {  				fh1 = stream.Read1 ();  				fh2 = stream.Read1 ();  				if (tmpFrameHeader [1] == fh1 && (tmpFrameHeader [2] & 0x0D) == (fh2 & 0x0D)) {  					// header found  					break;  				}  			}  			stream.Seek (_headerOffset + 1' SeekOrigin.Begin);  			continue;  		}  	}  	_mpegVersion = (MpegVersion)((tmpFrameHeader [1] >> 3) & 0x03);  	_mpegLayer = (MpegLayer)((tmpFrameHeader [1] >> 1) & 0x03);  	_frequency = GetFrequency (_mpegVersion' (tmpFrameHeader [2] >> 2) & 0x03);  	if (_frequency == 0) {  		throw new InvalidDataException (String.Format ("'{0}'; cannot determine frequency"' path));  	}  	_isPrivate = ((tmpFrameHeader [2] & 0x01) == 0x01);  	_samplesPerFrame = GetSamplesPerFrame (_mpegVersion' _mpegLayer);  	_frameSizeConst = 125.0 * _samplesPerFrame / _frequency;  	_paddingSizeConst = (_mpegLayer == MpegLayer.Layer1 ? 4 : 1);  	_isCopyright = (((tmpFrameHeader [3] >> 3) & 0x01) == 0x01);  	_isOriginal = (((tmpFrameHeader [3] >> 2) & 0x01) == 0x01);  	//tmpModeExtension = (FH[3] >> 4) & 0x03; // not interested' only used in joint-stereo  	//_mpegEmphasis = (MpegEmphasis)(tmpFrameHeader[3] & 0x03);  	if ((tmpFrameHeader [3] >> 6) == 3)  		_channels = 1;  	// Single Channel  	else  		_channels = 2;  	// Read LAME Info Tag  	bool tmpHasLameInfoTag = false;  	stream.Seek (tmpID3v2TagSize + 36' SeekOrigin.Begin);  	Byte[] buf = stream.Read (4);  	if (ByteUtils.Compare (buf' INFO_MARKER))// CBR  	 {  		tmpHasLameInfoTag = true;  		_isVBR = false;  	} else if (ByteUtils.Compare (buf' XING_MARKER))// VBR  	 {  		tmpHasLameInfoTag = true;  		_isVBR = true;  	}  	if (tmpHasLameInfoTag) {  		stream.Seek (4' SeekOrigin.Current);  		int tmpFrames = stream.ReadInt32 ();  		uint tmpBytes = (uint)stream.ReadInt32 ();  		if (tmpFrames > 256 && tmpBytes > 50000) {  			decimal tmpBitrate = tmpBytes / 125.0m / (tmpFrames * _samplesPerFrame / (decimal)_frequency);  			if (tmpBitrate <= 320 && tmpBitrate >= 32) {  				_frames = tmpFrames;  				_bitrate = tmpBitrate;  				_totalSeconds = (tmpBytes / 125.0m) / _bitrate;  			}  		}  	}  	// TODO: Take these 2 lines out  	/*fs.Position = 0;                 CalculateBitrate(fs' null);*/if (calculateBitrate) {  		if (_bitrate == 0 || _isVBR == null || _frames == 0 || _totalSeconds == 0) {  			stream.Position = 0;  			CalculateBitrate (stream' null);  		}  	}  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: using (FileStream stream = File.Open (path' FileMode.Open' FileAccess.Read' FileShare.Read)) {  	int tmpID3v2TagSize = ID3v2.GetTagSize (stream);  	stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  	byte[] tmpFrameHeader = new byte[4];  	bool acceptNullSamples = false;  	while (true) {  		int tmpByte = stream.ReadByte ();  		// keep as ReadByte  		while (tmpByte != 0xFF && tmpByte != -1) {  			tmpByte = stream.ReadByte ();  			// keep as ReadByte  		}  		if (tmpByte == -1) {  			if (acceptNullSamples) {  				throw new InvalidDataException (string.Format ("'{0}': Can't find frame sync"' path));  			}  			stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  			acceptNullSamples = true;  			continue;  		}  		tmpFrameHeader [0] = (byte)tmpByte;  		// Get frame header  		if (stream.Read (tmpFrameHeader' 1' 3) != 3) {  			throw new InvalidDataException (string.Format ("'{0}': Invalid MPEG file; end of stream reached"' path));  		}  		// No sync  		if ((tmpFrameHeader [1] >> 5) != 0x07 || ((tmpFrameHeader [1] >> 1) & 0x03) == 0)// 2/18/05 - ignore reserved layer  		 {  			stream.Seek (-3' SeekOrigin.Current);  		} else if (tmpFrameHeader [1] == 0xFF || ((tmpFrameHeader [1] >> 3) & 0x03) == 1)// 2/19/05 - more bad data  		 {  			stream.Seek (-3' SeekOrigin.Current);  		} else {  			int tmpMpegID = (tmpFrameHeader [1] >> 3) & 0x03;  			int tmpLayerNum = (tmpFrameHeader [1] >> 1) & 0x03;  			int tmpFrequency = GetFrequency ((MpegVersion)tmpMpegID' (tmpFrameHeader [2] >> 2) & 0x03);  			// Check for invalid frequency  			if (tmpFrequency == 0) {  				stream.Seek (-3' SeekOrigin.Current);  				continue;  			}  			int tmpSamplesPerFrame = GetSamplesPerFrame ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum);  			int tmpUsesPadding = (tmpFrameHeader [2] >> 1) & 0x01;  			double tmpFrameSizeConst = 125.0 * tmpSamplesPerFrame / tmpFrequency;  			int tmpPaddingSize = (tmpLayerNum == 3 ? 4 : 1);  			int tmpBitrateIndex = tmpFrameHeader [2] >> 4;  			// Check for invalid values  			if (tmpBitrateIndex < 1 || tmpBitrateIndex > 14 || tmpLayerNum == 0) {  				stream.Seek (-3' SeekOrigin.Current);  				continue;  			}  			int tmpFrameBitrate = GetBitrate ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum' tmpBitrateIndex);  			int tmpFrameSize = (int)(tmpFrameBitrate * tmpFrameSizeConst) + (tmpUsesPadding * tmpPaddingSize);  			_headerOffset = stream.Position - 4;  			if (tmpFrameSize < 8) {  				stream.Seek (-3' SeekOrigin.Current);  				continue;  			}  			// 7/21/05 - Check for 0x00 or 0xFF at end of last frame  			// this sucks for tracks that start with silence  			if (_headerOffset >= 1 && !acceptNullSamples)// if (ftell(fp) >= 5)  			 {  				stream.Seek (-5' SeekOrigin.Current);  				byte tmpLastByte = stream.Read1 ();  				stream.Seek (4' SeekOrigin.Current);  				if (tmpFrameBitrate != 320 && (tmpLastByte == 0x00 || tmpLastByte == 0xFF)) {  					// 7/31/05  					// may be a valid frame - skip its contents to prevent false sync  					long tmpNewPosition = _headerOffset + tmpFrameSize;  					if (tmpFrameSize == 0)  						tmpNewPosition++;  					stream.Seek (tmpNewPosition' SeekOrigin.Begin);  					continue;  				}  			}  			/*if (BR == 0 || FrameSizeConst == 0)                         {                             startpos = HeaderOffset+1;                             fseek(fp' startpos' SEEK_SET);                             continue;                         }*/stream.Seek (_headerOffset + tmpFrameSize' SeekOrigin.Begin);  			if (stream.Read1 () == 0xFF) {  				fh1 = stream.Read1 ();  				fh2 = stream.Read1 ();  				if (tmpFrameHeader [1] == fh1 && (tmpFrameHeader [2] & 0x0D) == (fh2 & 0x0D)) {  					// header found  					break;  				}  			}  			stream.Seek (_headerOffset + 1' SeekOrigin.Begin);  			continue;  		}  	}  	_mpegVersion = (MpegVersion)((tmpFrameHeader [1] >> 3) & 0x03);  	_mpegLayer = (MpegLayer)((tmpFrameHeader [1] >> 1) & 0x03);  	_frequency = GetFrequency (_mpegVersion' (tmpFrameHeader [2] >> 2) & 0x03);  	if (_frequency == 0) {  		throw new InvalidDataException (String.Format ("'{0}'; cannot determine frequency"' path));  	}  	_isPrivate = ((tmpFrameHeader [2] & 0x01) == 0x01);  	_samplesPerFrame = GetSamplesPerFrame (_mpegVersion' _mpegLayer);  	_frameSizeConst = 125.0 * _samplesPerFrame / _frequency;  	_paddingSizeConst = (_mpegLayer == MpegLayer.Layer1 ? 4 : 1);  	_isCopyright = (((tmpFrameHeader [3] >> 3) & 0x01) == 0x01);  	_isOriginal = (((tmpFrameHeader [3] >> 2) & 0x01) == 0x01);  	//tmpModeExtension = (FH[3] >> 4) & 0x03; // not interested' only used in joint-stereo  	//_mpegEmphasis = (MpegEmphasis)(tmpFrameHeader[3] & 0x03);  	if ((tmpFrameHeader [3] >> 6) == 3)  		_channels = 1;  	// Single Channel  	else  		_channels = 2;  	// Read LAME Info Tag  	bool tmpHasLameInfoTag = false;  	stream.Seek (tmpID3v2TagSize + 36' SeekOrigin.Begin);  	Byte[] buf = stream.Read (4);  	if (ByteUtils.Compare (buf' INFO_MARKER))// CBR  	 {  		tmpHasLameInfoTag = true;  		_isVBR = false;  	} else if (ByteUtils.Compare (buf' XING_MARKER))// VBR  	 {  		tmpHasLameInfoTag = true;  		_isVBR = true;  	}  	if (tmpHasLameInfoTag) {  		stream.Seek (4' SeekOrigin.Current);  		int tmpFrames = stream.ReadInt32 ();  		uint tmpBytes = (uint)stream.ReadInt32 ();  		if (tmpFrames > 256 && tmpBytes > 50000) {  			decimal tmpBitrate = tmpBytes / 125.0m / (tmpFrames * _samplesPerFrame / (decimal)_frequency);  			if (tmpBitrate <= 320 && tmpBitrate >= 32) {  				_frames = tmpFrames;  				_bitrate = tmpBitrate;  				_totalSeconds = (tmpBytes / 125.0m) / _bitrate;  			}  		}  	}  	// TODO: Take these 2 lines out  	/*fs.Position = 0;                 CalculateBitrate(fs' null);*/if (calculateBitrate) {  		if (_bitrate == 0 || _isVBR == null || _frames == 0 || _totalSeconds == 0) {  			stream.Position = 0;  			CalculateBitrate (stream' null);  		}  	}  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: using (FileStream stream = File.Open (path' FileMode.Open' FileAccess.Read' FileShare.Read)) {  	int tmpID3v2TagSize = ID3v2.GetTagSize (stream);  	stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  	byte[] tmpFrameHeader = new byte[4];  	bool acceptNullSamples = false;  	while (true) {  		int tmpByte = stream.ReadByte ();  		// keep as ReadByte  		while (tmpByte != 0xFF && tmpByte != -1) {  			tmpByte = stream.ReadByte ();  			// keep as ReadByte  		}  		if (tmpByte == -1) {  			if (acceptNullSamples) {  				throw new InvalidDataException (string.Format ("'{0}': Can't find frame sync"' path));  			}  			stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  			acceptNullSamples = true;  			continue;  		}  		tmpFrameHeader [0] = (byte)tmpByte;  		// Get frame header  		if (stream.Read (tmpFrameHeader' 1' 3) != 3) {  			throw new InvalidDataException (string.Format ("'{0}': Invalid MPEG file; end of stream reached"' path));  		}  		// No sync  		if ((tmpFrameHeader [1] >> 5) != 0x07 || ((tmpFrameHeader [1] >> 1) & 0x03) == 0)// 2/18/05 - ignore reserved layer  		 {  			stream.Seek (-3' SeekOrigin.Current);  		} else if (tmpFrameHeader [1] == 0xFF || ((tmpFrameHeader [1] >> 3) & 0x03) == 1)// 2/19/05 - more bad data  		 {  			stream.Seek (-3' SeekOrigin.Current);  		} else {  			int tmpMpegID = (tmpFrameHeader [1] >> 3) & 0x03;  			int tmpLayerNum = (tmpFrameHeader [1] >> 1) & 0x03;  			int tmpFrequency = GetFrequency ((MpegVersion)tmpMpegID' (tmpFrameHeader [2] >> 2) & 0x03);  			// Check for invalid frequency  			if (tmpFrequency == 0) {  				stream.Seek (-3' SeekOrigin.Current);  				continue;  			}  			int tmpSamplesPerFrame = GetSamplesPerFrame ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum);  			int tmpUsesPadding = (tmpFrameHeader [2] >> 1) & 0x01;  			double tmpFrameSizeConst = 125.0 * tmpSamplesPerFrame / tmpFrequency;  			int tmpPaddingSize = (tmpLayerNum == 3 ? 4 : 1);  			int tmpBitrateIndex = tmpFrameHeader [2] >> 4;  			// Check for invalid values  			if (tmpBitrateIndex < 1 || tmpBitrateIndex > 14 || tmpLayerNum == 0) {  				stream.Seek (-3' SeekOrigin.Current);  				continue;  			}  			int tmpFrameBitrate = GetBitrate ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum' tmpBitrateIndex);  			int tmpFrameSize = (int)(tmpFrameBitrate * tmpFrameSizeConst) + (tmpUsesPadding * tmpPaddingSize);  			_headerOffset = stream.Position - 4;  			if (tmpFrameSize < 8) {  				stream.Seek (-3' SeekOrigin.Current);  				continue;  			}  			// 7/21/05 - Check for 0x00 or 0xFF at end of last frame  			// this sucks for tracks that start with silence  			if (_headerOffset >= 1 && !acceptNullSamples)// if (ftell(fp) >= 5)  			 {  				stream.Seek (-5' SeekOrigin.Current);  				byte tmpLastByte = stream.Read1 ();  				stream.Seek (4' SeekOrigin.Current);  				if (tmpFrameBitrate != 320 && (tmpLastByte == 0x00 || tmpLastByte == 0xFF)) {  					// 7/31/05  					// may be a valid frame - skip its contents to prevent false sync  					long tmpNewPosition = _headerOffset + tmpFrameSize;  					if (tmpFrameSize == 0)  						tmpNewPosition++;  					stream.Seek (tmpNewPosition' SeekOrigin.Begin);  					continue;  				}  			}  			/*if (BR == 0 || FrameSizeConst == 0)                         {                             startpos = HeaderOffset+1;                             fseek(fp' startpos' SEEK_SET);                             continue;                         }*/stream.Seek (_headerOffset + tmpFrameSize' SeekOrigin.Begin);  			if (stream.Read1 () == 0xFF) {  				fh1 = stream.Read1 ();  				fh2 = stream.Read1 ();  				if (tmpFrameHeader [1] == fh1 && (tmpFrameHeader [2] & 0x0D) == (fh2 & 0x0D)) {  					// header found  					break;  				}  			}  			stream.Seek (_headerOffset + 1' SeekOrigin.Begin);  			continue;  		}  	}  	_mpegVersion = (MpegVersion)((tmpFrameHeader [1] >> 3) & 0x03);  	_mpegLayer = (MpegLayer)((tmpFrameHeader [1] >> 1) & 0x03);  	_frequency = GetFrequency (_mpegVersion' (tmpFrameHeader [2] >> 2) & 0x03);  	if (_frequency == 0) {  		throw new InvalidDataException (String.Format ("'{0}'; cannot determine frequency"' path));  	}  	_isPrivate = ((tmpFrameHeader [2] & 0x01) == 0x01);  	_samplesPerFrame = GetSamplesPerFrame (_mpegVersion' _mpegLayer);  	_frameSizeConst = 125.0 * _samplesPerFrame / _frequency;  	_paddingSizeConst = (_mpegLayer == MpegLayer.Layer1 ? 4 : 1);  	_isCopyright = (((tmpFrameHeader [3] >> 3) & 0x01) == 0x01);  	_isOriginal = (((tmpFrameHeader [3] >> 2) & 0x01) == 0x01);  	//tmpModeExtension = (FH[3] >> 4) & 0x03; // not interested' only used in joint-stereo  	//_mpegEmphasis = (MpegEmphasis)(tmpFrameHeader[3] & 0x03);  	if ((tmpFrameHeader [3] >> 6) == 3)  		_channels = 1;  	// Single Channel  	else  		_channels = 2;  	// Read LAME Info Tag  	bool tmpHasLameInfoTag = false;  	stream.Seek (tmpID3v2TagSize + 36' SeekOrigin.Begin);  	Byte[] buf = stream.Read (4);  	if (ByteUtils.Compare (buf' INFO_MARKER))// CBR  	 {  		tmpHasLameInfoTag = true;  		_isVBR = false;  	} else if (ByteUtils.Compare (buf' XING_MARKER))// VBR  	 {  		tmpHasLameInfoTag = true;  		_isVBR = true;  	}  	if (tmpHasLameInfoTag) {  		stream.Seek (4' SeekOrigin.Current);  		int tmpFrames = stream.ReadInt32 ();  		uint tmpBytes = (uint)stream.ReadInt32 ();  		if (tmpFrames > 256 && tmpBytes > 50000) {  			decimal tmpBitrate = tmpBytes / 125.0m / (tmpFrames * _samplesPerFrame / (decimal)_frequency);  			if (tmpBitrate <= 320 && tmpBitrate >= 32) {  				_frames = tmpFrames;  				_bitrate = tmpBitrate;  				_totalSeconds = (tmpBytes / 125.0m) / _bitrate;  			}  		}  	}  	// TODO: Take these 2 lines out  	/*fs.Position = 0;                 CalculateBitrate(fs' null);*/if (calculateBitrate) {  		if (_bitrate == 0 || _isVBR == null || _frames == 0 || _totalSeconds == 0) {  			stream.Position = 0;  			CalculateBitrate (stream' null);  		}  	}  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: using (FileStream stream = File.Open (path' FileMode.Open' FileAccess.Read' FileShare.Read)) {  	int tmpID3v2TagSize = ID3v2.GetTagSize (stream);  	stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  	byte[] tmpFrameHeader = new byte[4];  	bool acceptNullSamples = false;  	while (true) {  		int tmpByte = stream.ReadByte ();  		// keep as ReadByte  		while (tmpByte != 0xFF && tmpByte != -1) {  			tmpByte = stream.ReadByte ();  			// keep as ReadByte  		}  		if (tmpByte == -1) {  			if (acceptNullSamples) {  				throw new InvalidDataException (string.Format ("'{0}': Can't find frame sync"' path));  			}  			stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  			acceptNullSamples = true;  			continue;  		}  		tmpFrameHeader [0] = (byte)tmpByte;  		// Get frame header  		if (stream.Read (tmpFrameHeader' 1' 3) != 3) {  			throw new InvalidDataException (string.Format ("'{0}': Invalid MPEG file; end of stream reached"' path));  		}  		// No sync  		if ((tmpFrameHeader [1] >> 5) != 0x07 || ((tmpFrameHeader [1] >> 1) & 0x03) == 0)// 2/18/05 - ignore reserved layer  		 {  			stream.Seek (-3' SeekOrigin.Current);  		} else if (tmpFrameHeader [1] == 0xFF || ((tmpFrameHeader [1] >> 3) & 0x03) == 1)// 2/19/05 - more bad data  		 {  			stream.Seek (-3' SeekOrigin.Current);  		} else {  			int tmpMpegID = (tmpFrameHeader [1] >> 3) & 0x03;  			int tmpLayerNum = (tmpFrameHeader [1] >> 1) & 0x03;  			int tmpFrequency = GetFrequency ((MpegVersion)tmpMpegID' (tmpFrameHeader [2] >> 2) & 0x03);  			// Check for invalid frequency  			if (tmpFrequency == 0) {  				stream.Seek (-3' SeekOrigin.Current);  				continue;  			}  			int tmpSamplesPerFrame = GetSamplesPerFrame ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum);  			int tmpUsesPadding = (tmpFrameHeader [2] >> 1) & 0x01;  			double tmpFrameSizeConst = 125.0 * tmpSamplesPerFrame / tmpFrequency;  			int tmpPaddingSize = (tmpLayerNum == 3 ? 4 : 1);  			int tmpBitrateIndex = tmpFrameHeader [2] >> 4;  			// Check for invalid values  			if (tmpBitrateIndex < 1 || tmpBitrateIndex > 14 || tmpLayerNum == 0) {  				stream.Seek (-3' SeekOrigin.Current);  				continue;  			}  			int tmpFrameBitrate = GetBitrate ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum' tmpBitrateIndex);  			int tmpFrameSize = (int)(tmpFrameBitrate * tmpFrameSizeConst) + (tmpUsesPadding * tmpPaddingSize);  			_headerOffset = stream.Position - 4;  			if (tmpFrameSize < 8) {  				stream.Seek (-3' SeekOrigin.Current);  				continue;  			}  			// 7/21/05 - Check for 0x00 or 0xFF at end of last frame  			// this sucks for tracks that start with silence  			if (_headerOffset >= 1 && !acceptNullSamples)// if (ftell(fp) >= 5)  			 {  				stream.Seek (-5' SeekOrigin.Current);  				byte tmpLastByte = stream.Read1 ();  				stream.Seek (4' SeekOrigin.Current);  				if (tmpFrameBitrate != 320 && (tmpLastByte == 0x00 || tmpLastByte == 0xFF)) {  					// 7/31/05  					// may be a valid frame - skip its contents to prevent false sync  					long tmpNewPosition = _headerOffset + tmpFrameSize;  					if (tmpFrameSize == 0)  						tmpNewPosition++;  					stream.Seek (tmpNewPosition' SeekOrigin.Begin);  					continue;  				}  			}  			/*if (BR == 0 || FrameSizeConst == 0)                         {                             startpos = HeaderOffset+1;                             fseek(fp' startpos' SEEK_SET);                             continue;                         }*/stream.Seek (_headerOffset + tmpFrameSize' SeekOrigin.Begin);  			if (stream.Read1 () == 0xFF) {  				fh1 = stream.Read1 ();  				fh2 = stream.Read1 ();  				if (tmpFrameHeader [1] == fh1 && (tmpFrameHeader [2] & 0x0D) == (fh2 & 0x0D)) {  					// header found  					break;  				}  			}  			stream.Seek (_headerOffset + 1' SeekOrigin.Begin);  			continue;  		}  	}  	_mpegVersion = (MpegVersion)((tmpFrameHeader [1] >> 3) & 0x03);  	_mpegLayer = (MpegLayer)((tmpFrameHeader [1] >> 1) & 0x03);  	_frequency = GetFrequency (_mpegVersion' (tmpFrameHeader [2] >> 2) & 0x03);  	if (_frequency == 0) {  		throw new InvalidDataException (String.Format ("'{0}'; cannot determine frequency"' path));  	}  	_isPrivate = ((tmpFrameHeader [2] & 0x01) == 0x01);  	_samplesPerFrame = GetSamplesPerFrame (_mpegVersion' _mpegLayer);  	_frameSizeConst = 125.0 * _samplesPerFrame / _frequency;  	_paddingSizeConst = (_mpegLayer == MpegLayer.Layer1 ? 4 : 1);  	_isCopyright = (((tmpFrameHeader [3] >> 3) & 0x01) == 0x01);  	_isOriginal = (((tmpFrameHeader [3] >> 2) & 0x01) == 0x01);  	//tmpModeExtension = (FH[3] >> 4) & 0x03; // not interested' only used in joint-stereo  	//_mpegEmphasis = (MpegEmphasis)(tmpFrameHeader[3] & 0x03);  	if ((tmpFrameHeader [3] >> 6) == 3)  		_channels = 1;  	// Single Channel  	else  		_channels = 2;  	// Read LAME Info Tag  	bool tmpHasLameInfoTag = false;  	stream.Seek (tmpID3v2TagSize + 36' SeekOrigin.Begin);  	Byte[] buf = stream.Read (4);  	if (ByteUtils.Compare (buf' INFO_MARKER))// CBR  	 {  		tmpHasLameInfoTag = true;  		_isVBR = false;  	} else if (ByteUtils.Compare (buf' XING_MARKER))// VBR  	 {  		tmpHasLameInfoTag = true;  		_isVBR = true;  	}  	if (tmpHasLameInfoTag) {  		stream.Seek (4' SeekOrigin.Current);  		int tmpFrames = stream.ReadInt32 ();  		uint tmpBytes = (uint)stream.ReadInt32 ();  		if (tmpFrames > 256 && tmpBytes > 50000) {  			decimal tmpBitrate = tmpBytes / 125.0m / (tmpFrames * _samplesPerFrame / (decimal)_frequency);  			if (tmpBitrate <= 320 && tmpBitrate >= 32) {  				_frames = tmpFrames;  				_bitrate = tmpBitrate;  				_totalSeconds = (tmpBytes / 125.0m) / _bitrate;  			}  		}  	}  	// TODO: Take these 2 lines out  	/*fs.Position = 0;                 CalculateBitrate(fs' null);*/if (calculateBitrate) {  		if (_bitrate == 0 || _isVBR == null || _frames == 0 || _totalSeconds == 0) {  			stream.Position = 0;  			CalculateBitrate (stream' null);  		}  	}  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: using (FileStream stream = File.Open (path' FileMode.Open' FileAccess.Read' FileShare.Read)) {  	int tmpID3v2TagSize = ID3v2.GetTagSize (stream);  	stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  	byte[] tmpFrameHeader = new byte[4];  	bool acceptNullSamples = false;  	while (true) {  		int tmpByte = stream.ReadByte ();  		// keep as ReadByte  		while (tmpByte != 0xFF && tmpByte != -1) {  			tmpByte = stream.ReadByte ();  			// keep as ReadByte  		}  		if (tmpByte == -1) {  			if (acceptNullSamples) {  				throw new InvalidDataException (string.Format ("'{0}': Can't find frame sync"' path));  			}  			stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  			acceptNullSamples = true;  			continue;  		}  		tmpFrameHeader [0] = (byte)tmpByte;  		// Get frame header  		if (stream.Read (tmpFrameHeader' 1' 3) != 3) {  			throw new InvalidDataException (string.Format ("'{0}': Invalid MPEG file; end of stream reached"' path));  		}  		// No sync  		if ((tmpFrameHeader [1] >> 5) != 0x07 || ((tmpFrameHeader [1] >> 1) & 0x03) == 0)// 2/18/05 - ignore reserved layer  		 {  			stream.Seek (-3' SeekOrigin.Current);  		} else if (tmpFrameHeader [1] == 0xFF || ((tmpFrameHeader [1] >> 3) & 0x03) == 1)// 2/19/05 - more bad data  		 {  			stream.Seek (-3' SeekOrigin.Current);  		} else {  			int tmpMpegID = (tmpFrameHeader [1] >> 3) & 0x03;  			int tmpLayerNum = (tmpFrameHeader [1] >> 1) & 0x03;  			int tmpFrequency = GetFrequency ((MpegVersion)tmpMpegID' (tmpFrameHeader [2] >> 2) & 0x03);  			// Check for invalid frequency  			if (tmpFrequency == 0) {  				stream.Seek (-3' SeekOrigin.Current);  				continue;  			}  			int tmpSamplesPerFrame = GetSamplesPerFrame ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum);  			int tmpUsesPadding = (tmpFrameHeader [2] >> 1) & 0x01;  			double tmpFrameSizeConst = 125.0 * tmpSamplesPerFrame / tmpFrequency;  			int tmpPaddingSize = (tmpLayerNum == 3 ? 4 : 1);  			int tmpBitrateIndex = tmpFrameHeader [2] >> 4;  			// Check for invalid values  			if (tmpBitrateIndex < 1 || tmpBitrateIndex > 14 || tmpLayerNum == 0) {  				stream.Seek (-3' SeekOrigin.Current);  				continue;  			}  			int tmpFrameBitrate = GetBitrate ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum' tmpBitrateIndex);  			int tmpFrameSize = (int)(tmpFrameBitrate * tmpFrameSizeConst) + (tmpUsesPadding * tmpPaddingSize);  			_headerOffset = stream.Position - 4;  			if (tmpFrameSize < 8) {  				stream.Seek (-3' SeekOrigin.Current);  				continue;  			}  			// 7/21/05 - Check for 0x00 or 0xFF at end of last frame  			// this sucks for tracks that start with silence  			if (_headerOffset >= 1 && !acceptNullSamples)// if (ftell(fp) >= 5)  			 {  				stream.Seek (-5' SeekOrigin.Current);  				byte tmpLastByte = stream.Read1 ();  				stream.Seek (4' SeekOrigin.Current);  				if (tmpFrameBitrate != 320 && (tmpLastByte == 0x00 || tmpLastByte == 0xFF)) {  					// 7/31/05  					// may be a valid frame - skip its contents to prevent false sync  					long tmpNewPosition = _headerOffset + tmpFrameSize;  					if (tmpFrameSize == 0)  						tmpNewPosition++;  					stream.Seek (tmpNewPosition' SeekOrigin.Begin);  					continue;  				}  			}  			/*if (BR == 0 || FrameSizeConst == 0)                         {                             startpos = HeaderOffset+1;                             fseek(fp' startpos' SEEK_SET);                             continue;                         }*/stream.Seek (_headerOffset + tmpFrameSize' SeekOrigin.Begin);  			if (stream.Read1 () == 0xFF) {  				fh1 = stream.Read1 ();  				fh2 = stream.Read1 ();  				if (tmpFrameHeader [1] == fh1 && (tmpFrameHeader [2] & 0x0D) == (fh2 & 0x0D)) {  					// header found  					break;  				}  			}  			stream.Seek (_headerOffset + 1' SeekOrigin.Begin);  			continue;  		}  	}  	_mpegVersion = (MpegVersion)((tmpFrameHeader [1] >> 3) & 0x03);  	_mpegLayer = (MpegLayer)((tmpFrameHeader [1] >> 1) & 0x03);  	_frequency = GetFrequency (_mpegVersion' (tmpFrameHeader [2] >> 2) & 0x03);  	if (_frequency == 0) {  		throw new InvalidDataException (String.Format ("'{0}'; cannot determine frequency"' path));  	}  	_isPrivate = ((tmpFrameHeader [2] & 0x01) == 0x01);  	_samplesPerFrame = GetSamplesPerFrame (_mpegVersion' _mpegLayer);  	_frameSizeConst = 125.0 * _samplesPerFrame / _frequency;  	_paddingSizeConst = (_mpegLayer == MpegLayer.Layer1 ? 4 : 1);  	_isCopyright = (((tmpFrameHeader [3] >> 3) & 0x01) == 0x01);  	_isOriginal = (((tmpFrameHeader [3] >> 2) & 0x01) == 0x01);  	//tmpModeExtension = (FH[3] >> 4) & 0x03; // not interested' only used in joint-stereo  	//_mpegEmphasis = (MpegEmphasis)(tmpFrameHeader[3] & 0x03);  	if ((tmpFrameHeader [3] >> 6) == 3)  		_channels = 1;  	// Single Channel  	else  		_channels = 2;  	// Read LAME Info Tag  	bool tmpHasLameInfoTag = false;  	stream.Seek (tmpID3v2TagSize + 36' SeekOrigin.Begin);  	Byte[] buf = stream.Read (4);  	if (ByteUtils.Compare (buf' INFO_MARKER))// CBR  	 {  		tmpHasLameInfoTag = true;  		_isVBR = false;  	} else if (ByteUtils.Compare (buf' XING_MARKER))// VBR  	 {  		tmpHasLameInfoTag = true;  		_isVBR = true;  	}  	if (tmpHasLameInfoTag) {  		stream.Seek (4' SeekOrigin.Current);  		int tmpFrames = stream.ReadInt32 ();  		uint tmpBytes = (uint)stream.ReadInt32 ();  		if (tmpFrames > 256 && tmpBytes > 50000) {  			decimal tmpBitrate = tmpBytes / 125.0m / (tmpFrames * _samplesPerFrame / (decimal)_frequency);  			if (tmpBitrate <= 320 && tmpBitrate >= 32) {  				_frames = tmpFrames;  				_bitrate = tmpBitrate;  				_totalSeconds = (tmpBytes / 125.0m) / _bitrate;  			}  		}  	}  	// TODO: Take these 2 lines out  	/*fs.Position = 0;                 CalculateBitrate(fs' null);*/if (calculateBitrate) {  		if (_bitrate == 0 || _isVBR == null || _frames == 0 || _totalSeconds == 0) {  			stream.Position = 0;  			CalculateBitrate (stream' null);  		}  	}  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: using (FileStream stream = File.Open (path' FileMode.Open' FileAccess.Read' FileShare.Read)) {  	int tmpID3v2TagSize = ID3v2.GetTagSize (stream);  	stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  	byte[] tmpFrameHeader = new byte[4];  	bool acceptNullSamples = false;  	while (true) {  		int tmpByte = stream.ReadByte ();  		// keep as ReadByte  		while (tmpByte != 0xFF && tmpByte != -1) {  			tmpByte = stream.ReadByte ();  			// keep as ReadByte  		}  		if (tmpByte == -1) {  			if (acceptNullSamples) {  				throw new InvalidDataException (string.Format ("'{0}': Can't find frame sync"' path));  			}  			stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  			acceptNullSamples = true;  			continue;  		}  		tmpFrameHeader [0] = (byte)tmpByte;  		// Get frame header  		if (stream.Read (tmpFrameHeader' 1' 3) != 3) {  			throw new InvalidDataException (string.Format ("'{0}': Invalid MPEG file; end of stream reached"' path));  		}  		// No sync  		if ((tmpFrameHeader [1] >> 5) != 0x07 || ((tmpFrameHeader [1] >> 1) & 0x03) == 0)// 2/18/05 - ignore reserved layer  		 {  			stream.Seek (-3' SeekOrigin.Current);  		} else if (tmpFrameHeader [1] == 0xFF || ((tmpFrameHeader [1] >> 3) & 0x03) == 1)// 2/19/05 - more bad data  		 {  			stream.Seek (-3' SeekOrigin.Current);  		} else {  			int tmpMpegID = (tmpFrameHeader [1] >> 3) & 0x03;  			int tmpLayerNum = (tmpFrameHeader [1] >> 1) & 0x03;  			int tmpFrequency = GetFrequency ((MpegVersion)tmpMpegID' (tmpFrameHeader [2] >> 2) & 0x03);  			// Check for invalid frequency  			if (tmpFrequency == 0) {  				stream.Seek (-3' SeekOrigin.Current);  				continue;  			}  			int tmpSamplesPerFrame = GetSamplesPerFrame ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum);  			int tmpUsesPadding = (tmpFrameHeader [2] >> 1) & 0x01;  			double tmpFrameSizeConst = 125.0 * tmpSamplesPerFrame / tmpFrequency;  			int tmpPaddingSize = (tmpLayerNum == 3 ? 4 : 1);  			int tmpBitrateIndex = tmpFrameHeader [2] >> 4;  			// Check for invalid values  			if (tmpBitrateIndex < 1 || tmpBitrateIndex > 14 || tmpLayerNum == 0) {  				stream.Seek (-3' SeekOrigin.Current);  				continue;  			}  			int tmpFrameBitrate = GetBitrate ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum' tmpBitrateIndex);  			int tmpFrameSize = (int)(tmpFrameBitrate * tmpFrameSizeConst) + (tmpUsesPadding * tmpPaddingSize);  			_headerOffset = stream.Position - 4;  			if (tmpFrameSize < 8) {  				stream.Seek (-3' SeekOrigin.Current);  				continue;  			}  			// 7/21/05 - Check for 0x00 or 0xFF at end of last frame  			// this sucks for tracks that start with silence  			if (_headerOffset >= 1 && !acceptNullSamples)// if (ftell(fp) >= 5)  			 {  				stream.Seek (-5' SeekOrigin.Current);  				byte tmpLastByte = stream.Read1 ();  				stream.Seek (4' SeekOrigin.Current);  				if (tmpFrameBitrate != 320 && (tmpLastByte == 0x00 || tmpLastByte == 0xFF)) {  					// 7/31/05  					// may be a valid frame - skip its contents to prevent false sync  					long tmpNewPosition = _headerOffset + tmpFrameSize;  					if (tmpFrameSize == 0)  						tmpNewPosition++;  					stream.Seek (tmpNewPosition' SeekOrigin.Begin);  					continue;  				}  			}  			/*if (BR == 0 || FrameSizeConst == 0)                         {                             startpos = HeaderOffset+1;                             fseek(fp' startpos' SEEK_SET);                             continue;                         }*/stream.Seek (_headerOffset + tmpFrameSize' SeekOrigin.Begin);  			if (stream.Read1 () == 0xFF) {  				fh1 = stream.Read1 ();  				fh2 = stream.Read1 ();  				if (tmpFrameHeader [1] == fh1 && (tmpFrameHeader [2] & 0x0D) == (fh2 & 0x0D)) {  					// header found  					break;  				}  			}  			stream.Seek (_headerOffset + 1' SeekOrigin.Begin);  			continue;  		}  	}  	_mpegVersion = (MpegVersion)((tmpFrameHeader [1] >> 3) & 0x03);  	_mpegLayer = (MpegLayer)((tmpFrameHeader [1] >> 1) & 0x03);  	_frequency = GetFrequency (_mpegVersion' (tmpFrameHeader [2] >> 2) & 0x03);  	if (_frequency == 0) {  		throw new InvalidDataException (String.Format ("'{0}'; cannot determine frequency"' path));  	}  	_isPrivate = ((tmpFrameHeader [2] & 0x01) == 0x01);  	_samplesPerFrame = GetSamplesPerFrame (_mpegVersion' _mpegLayer);  	_frameSizeConst = 125.0 * _samplesPerFrame / _frequency;  	_paddingSizeConst = (_mpegLayer == MpegLayer.Layer1 ? 4 : 1);  	_isCopyright = (((tmpFrameHeader [3] >> 3) & 0x01) == 0x01);  	_isOriginal = (((tmpFrameHeader [3] >> 2) & 0x01) == 0x01);  	//tmpModeExtension = (FH[3] >> 4) & 0x03; // not interested' only used in joint-stereo  	//_mpegEmphasis = (MpegEmphasis)(tmpFrameHeader[3] & 0x03);  	if ((tmpFrameHeader [3] >> 6) == 3)  		_channels = 1;  	// Single Channel  	else  		_channels = 2;  	// Read LAME Info Tag  	bool tmpHasLameInfoTag = false;  	stream.Seek (tmpID3v2TagSize + 36' SeekOrigin.Begin);  	Byte[] buf = stream.Read (4);  	if (ByteUtils.Compare (buf' INFO_MARKER))// CBR  	 {  		tmpHasLameInfoTag = true;  		_isVBR = false;  	} else if (ByteUtils.Compare (buf' XING_MARKER))// VBR  	 {  		tmpHasLameInfoTag = true;  		_isVBR = true;  	}  	if (tmpHasLameInfoTag) {  		stream.Seek (4' SeekOrigin.Current);  		int tmpFrames = stream.ReadInt32 ();  		uint tmpBytes = (uint)stream.ReadInt32 ();  		if (tmpFrames > 256 && tmpBytes > 50000) {  			decimal tmpBitrate = tmpBytes / 125.0m / (tmpFrames * _samplesPerFrame / (decimal)_frequency);  			if (tmpBitrate <= 320 && tmpBitrate >= 32) {  				_frames = tmpFrames;  				_bitrate = tmpBitrate;  				_totalSeconds = (tmpBytes / 125.0m) / _bitrate;  			}  		}  	}  	// TODO: Take these 2 lines out  	/*fs.Position = 0;                 CalculateBitrate(fs' null);*/if (calculateBitrate) {  		if (_bitrate == 0 || _isVBR == null || _frames == 0 || _totalSeconds == 0) {  			stream.Position = 0;  			CalculateBitrate (stream' null);  		}  	}  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: using (FileStream stream = File.Open (path' FileMode.Open' FileAccess.Read' FileShare.Read)) {  	int tmpID3v2TagSize = ID3v2.GetTagSize (stream);  	stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  	byte[] tmpFrameHeader = new byte[4];  	bool acceptNullSamples = false;  	while (true) {  		int tmpByte = stream.ReadByte ();  		// keep as ReadByte  		while (tmpByte != 0xFF && tmpByte != -1) {  			tmpByte = stream.ReadByte ();  			// keep as ReadByte  		}  		if (tmpByte == -1) {  			if (acceptNullSamples) {  				throw new InvalidDataException (string.Format ("'{0}': Can't find frame sync"' path));  			}  			stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  			acceptNullSamples = true;  			continue;  		}  		tmpFrameHeader [0] = (byte)tmpByte;  		// Get frame header  		if (stream.Read (tmpFrameHeader' 1' 3) != 3) {  			throw new InvalidDataException (string.Format ("'{0}': Invalid MPEG file; end of stream reached"' path));  		}  		// No sync  		if ((tmpFrameHeader [1] >> 5) != 0x07 || ((tmpFrameHeader [1] >> 1) & 0x03) == 0)// 2/18/05 - ignore reserved layer  		 {  			stream.Seek (-3' SeekOrigin.Current);  		} else if (tmpFrameHeader [1] == 0xFF || ((tmpFrameHeader [1] >> 3) & 0x03) == 1)// 2/19/05 - more bad data  		 {  			stream.Seek (-3' SeekOrigin.Current);  		} else {  			int tmpMpegID = (tmpFrameHeader [1] >> 3) & 0x03;  			int tmpLayerNum = (tmpFrameHeader [1] >> 1) & 0x03;  			int tmpFrequency = GetFrequency ((MpegVersion)tmpMpegID' (tmpFrameHeader [2] >> 2) & 0x03);  			// Check for invalid frequency  			if (tmpFrequency == 0) {  				stream.Seek (-3' SeekOrigin.Current);  				continue;  			}  			int tmpSamplesPerFrame = GetSamplesPerFrame ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum);  			int tmpUsesPadding = (tmpFrameHeader [2] >> 1) & 0x01;  			double tmpFrameSizeConst = 125.0 * tmpSamplesPerFrame / tmpFrequency;  			int tmpPaddingSize = (tmpLayerNum == 3 ? 4 : 1);  			int tmpBitrateIndex = tmpFrameHeader [2] >> 4;  			// Check for invalid values  			if (tmpBitrateIndex < 1 || tmpBitrateIndex > 14 || tmpLayerNum == 0) {  				stream.Seek (-3' SeekOrigin.Current);  				continue;  			}  			int tmpFrameBitrate = GetBitrate ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum' tmpBitrateIndex);  			int tmpFrameSize = (int)(tmpFrameBitrate * tmpFrameSizeConst) + (tmpUsesPadding * tmpPaddingSize);  			_headerOffset = stream.Position - 4;  			if (tmpFrameSize < 8) {  				stream.Seek (-3' SeekOrigin.Current);  				continue;  			}  			// 7/21/05 - Check for 0x00 or 0xFF at end of last frame  			// this sucks for tracks that start with silence  			if (_headerOffset >= 1 && !acceptNullSamples)// if (ftell(fp) >= 5)  			 {  				stream.Seek (-5' SeekOrigin.Current);  				byte tmpLastByte = stream.Read1 ();  				stream.Seek (4' SeekOrigin.Current);  				if (tmpFrameBitrate != 320 && (tmpLastByte == 0x00 || tmpLastByte == 0xFF)) {  					// 7/31/05  					// may be a valid frame - skip its contents to prevent false sync  					long tmpNewPosition = _headerOffset + tmpFrameSize;  					if (tmpFrameSize == 0)  						tmpNewPosition++;  					stream.Seek (tmpNewPosition' SeekOrigin.Begin);  					continue;  				}  			}  			/*if (BR == 0 || FrameSizeConst == 0)                         {                             startpos = HeaderOffset+1;                             fseek(fp' startpos' SEEK_SET);                             continue;                         }*/stream.Seek (_headerOffset + tmpFrameSize' SeekOrigin.Begin);  			if (stream.Read1 () == 0xFF) {  				fh1 = stream.Read1 ();  				fh2 = stream.Read1 ();  				if (tmpFrameHeader [1] == fh1 && (tmpFrameHeader [2] & 0x0D) == (fh2 & 0x0D)) {  					// header found  					break;  				}  			}  			stream.Seek (_headerOffset + 1' SeekOrigin.Begin);  			continue;  		}  	}  	_mpegVersion = (MpegVersion)((tmpFrameHeader [1] >> 3) & 0x03);  	_mpegLayer = (MpegLayer)((tmpFrameHeader [1] >> 1) & 0x03);  	_frequency = GetFrequency (_mpegVersion' (tmpFrameHeader [2] >> 2) & 0x03);  	if (_frequency == 0) {  		throw new InvalidDataException (String.Format ("'{0}'; cannot determine frequency"' path));  	}  	_isPrivate = ((tmpFrameHeader [2] & 0x01) == 0x01);  	_samplesPerFrame = GetSamplesPerFrame (_mpegVersion' _mpegLayer);  	_frameSizeConst = 125.0 * _samplesPerFrame / _frequency;  	_paddingSizeConst = (_mpegLayer == MpegLayer.Layer1 ? 4 : 1);  	_isCopyright = (((tmpFrameHeader [3] >> 3) & 0x01) == 0x01);  	_isOriginal = (((tmpFrameHeader [3] >> 2) & 0x01) == 0x01);  	//tmpModeExtension = (FH[3] >> 4) & 0x03; // not interested' only used in joint-stereo  	//_mpegEmphasis = (MpegEmphasis)(tmpFrameHeader[3] & 0x03);  	if ((tmpFrameHeader [3] >> 6) == 3)  		_channels = 1;  	// Single Channel  	else  		_channels = 2;  	// Read LAME Info Tag  	bool tmpHasLameInfoTag = false;  	stream.Seek (tmpID3v2TagSize + 36' SeekOrigin.Begin);  	Byte[] buf = stream.Read (4);  	if (ByteUtils.Compare (buf' INFO_MARKER))// CBR  	 {  		tmpHasLameInfoTag = true;  		_isVBR = false;  	} else if (ByteUtils.Compare (buf' XING_MARKER))// VBR  	 {  		tmpHasLameInfoTag = true;  		_isVBR = true;  	}  	if (tmpHasLameInfoTag) {  		stream.Seek (4' SeekOrigin.Current);  		int tmpFrames = stream.ReadInt32 ();  		uint tmpBytes = (uint)stream.ReadInt32 ();  		if (tmpFrames > 256 && tmpBytes > 50000) {  			decimal tmpBitrate = tmpBytes / 125.0m / (tmpFrames * _samplesPerFrame / (decimal)_frequency);  			if (tmpBitrate <= 320 && tmpBitrate >= 32) {  				_frames = tmpFrames;  				_bitrate = tmpBitrate;  				_totalSeconds = (tmpBytes / 125.0m) / _bitrate;  			}  		}  	}  	// TODO: Take these 2 lines out  	/*fs.Position = 0;                 CalculateBitrate(fs' null);*/if (calculateBitrate) {  		if (_bitrate == 0 || _isVBR == null || _frames == 0 || _totalSeconds == 0) {  			stream.Position = 0;  			CalculateBitrate (stream' null);  		}  	}  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: using (FileStream stream = File.Open (path' FileMode.Open' FileAccess.Read' FileShare.Read)) {  	int tmpID3v2TagSize = ID3v2.GetTagSize (stream);  	stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  	byte[] tmpFrameHeader = new byte[4];  	bool acceptNullSamples = false;  	while (true) {  		int tmpByte = stream.ReadByte ();  		// keep as ReadByte  		while (tmpByte != 0xFF && tmpByte != -1) {  			tmpByte = stream.ReadByte ();  			// keep as ReadByte  		}  		if (tmpByte == -1) {  			if (acceptNullSamples) {  				throw new InvalidDataException (string.Format ("'{0}': Can't find frame sync"' path));  			}  			stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  			acceptNullSamples = true;  			continue;  		}  		tmpFrameHeader [0] = (byte)tmpByte;  		// Get frame header  		if (stream.Read (tmpFrameHeader' 1' 3) != 3) {  			throw new InvalidDataException (string.Format ("'{0}': Invalid MPEG file; end of stream reached"' path));  		}  		// No sync  		if ((tmpFrameHeader [1] >> 5) != 0x07 || ((tmpFrameHeader [1] >> 1) & 0x03) == 0)// 2/18/05 - ignore reserved layer  		 {  			stream.Seek (-3' SeekOrigin.Current);  		} else if (tmpFrameHeader [1] == 0xFF || ((tmpFrameHeader [1] >> 3) & 0x03) == 1)// 2/19/05 - more bad data  		 {  			stream.Seek (-3' SeekOrigin.Current);  		} else {  			int tmpMpegID = (tmpFrameHeader [1] >> 3) & 0x03;  			int tmpLayerNum = (tmpFrameHeader [1] >> 1) & 0x03;  			int tmpFrequency = GetFrequency ((MpegVersion)tmpMpegID' (tmpFrameHeader [2] >> 2) & 0x03);  			// Check for invalid frequency  			if (tmpFrequency == 0) {  				stream.Seek (-3' SeekOrigin.Current);  				continue;  			}  			int tmpSamplesPerFrame = GetSamplesPerFrame ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum);  			int tmpUsesPadding = (tmpFrameHeader [2] >> 1) & 0x01;  			double tmpFrameSizeConst = 125.0 * tmpSamplesPerFrame / tmpFrequency;  			int tmpPaddingSize = (tmpLayerNum == 3 ? 4 : 1);  			int tmpBitrateIndex = tmpFrameHeader [2] >> 4;  			// Check for invalid values  			if (tmpBitrateIndex < 1 || tmpBitrateIndex > 14 || tmpLayerNum == 0) {  				stream.Seek (-3' SeekOrigin.Current);  				continue;  			}  			int tmpFrameBitrate = GetBitrate ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum' tmpBitrateIndex);  			int tmpFrameSize = (int)(tmpFrameBitrate * tmpFrameSizeConst) + (tmpUsesPadding * tmpPaddingSize);  			_headerOffset = stream.Position - 4;  			if (tmpFrameSize < 8) {  				stream.Seek (-3' SeekOrigin.Current);  				continue;  			}  			// 7/21/05 - Check for 0x00 or 0xFF at end of last frame  			// this sucks for tracks that start with silence  			if (_headerOffset >= 1 && !acceptNullSamples)// if (ftell(fp) >= 5)  			 {  				stream.Seek (-5' SeekOrigin.Current);  				byte tmpLastByte = stream.Read1 ();  				stream.Seek (4' SeekOrigin.Current);  				if (tmpFrameBitrate != 320 && (tmpLastByte == 0x00 || tmpLastByte == 0xFF)) {  					// 7/31/05  					// may be a valid frame - skip its contents to prevent false sync  					long tmpNewPosition = _headerOffset + tmpFrameSize;  					if (tmpFrameSize == 0)  						tmpNewPosition++;  					stream.Seek (tmpNewPosition' SeekOrigin.Begin);  					continue;  				}  			}  			/*if (BR == 0 || FrameSizeConst == 0)                         {                             startpos = HeaderOffset+1;                             fseek(fp' startpos' SEEK_SET);                             continue;                         }*/stream.Seek (_headerOffset + tmpFrameSize' SeekOrigin.Begin);  			if (stream.Read1 () == 0xFF) {  				fh1 = stream.Read1 ();  				fh2 = stream.Read1 ();  				if (tmpFrameHeader [1] == fh1 && (tmpFrameHeader [2] & 0x0D) == (fh2 & 0x0D)) {  					// header found  					break;  				}  			}  			stream.Seek (_headerOffset + 1' SeekOrigin.Begin);  			continue;  		}  	}  	_mpegVersion = (MpegVersion)((tmpFrameHeader [1] >> 3) & 0x03);  	_mpegLayer = (MpegLayer)((tmpFrameHeader [1] >> 1) & 0x03);  	_frequency = GetFrequency (_mpegVersion' (tmpFrameHeader [2] >> 2) & 0x03);  	if (_frequency == 0) {  		throw new InvalidDataException (String.Format ("'{0}'; cannot determine frequency"' path));  	}  	_isPrivate = ((tmpFrameHeader [2] & 0x01) == 0x01);  	_samplesPerFrame = GetSamplesPerFrame (_mpegVersion' _mpegLayer);  	_frameSizeConst = 125.0 * _samplesPerFrame / _frequency;  	_paddingSizeConst = (_mpegLayer == MpegLayer.Layer1 ? 4 : 1);  	_isCopyright = (((tmpFrameHeader [3] >> 3) & 0x01) == 0x01);  	_isOriginal = (((tmpFrameHeader [3] >> 2) & 0x01) == 0x01);  	//tmpModeExtension = (FH[3] >> 4) & 0x03; // not interested' only used in joint-stereo  	//_mpegEmphasis = (MpegEmphasis)(tmpFrameHeader[3] & 0x03);  	if ((tmpFrameHeader [3] >> 6) == 3)  		_channels = 1;  	// Single Channel  	else  		_channels = 2;  	// Read LAME Info Tag  	bool tmpHasLameInfoTag = false;  	stream.Seek (tmpID3v2TagSize + 36' SeekOrigin.Begin);  	Byte[] buf = stream.Read (4);  	if (ByteUtils.Compare (buf' INFO_MARKER))// CBR  	 {  		tmpHasLameInfoTag = true;  		_isVBR = false;  	} else if (ByteUtils.Compare (buf' XING_MARKER))// VBR  	 {  		tmpHasLameInfoTag = true;  		_isVBR = true;  	}  	if (tmpHasLameInfoTag) {  		stream.Seek (4' SeekOrigin.Current);  		int tmpFrames = stream.ReadInt32 ();  		uint tmpBytes = (uint)stream.ReadInt32 ();  		if (tmpFrames > 256 && tmpBytes > 50000) {  			decimal tmpBitrate = tmpBytes / 125.0m / (tmpFrames * _samplesPerFrame / (decimal)_frequency);  			if (tmpBitrate <= 320 && tmpBitrate >= 32) {  				_frames = tmpFrames;  				_bitrate = tmpBitrate;  				_totalSeconds = (tmpBytes / 125.0m) / _bitrate;  			}  		}  	}  	// TODO: Take these 2 lines out  	/*fs.Position = 0;                 CalculateBitrate(fs' null);*/if (calculateBitrate) {  		if (_bitrate == 0 || _isVBR == null || _frames == 0 || _totalSeconds == 0) {  			stream.Position = 0;  			CalculateBitrate (stream' null);  		}  	}  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: using (FileStream stream = File.Open (path' FileMode.Open' FileAccess.Read' FileShare.Read)) {  	int tmpID3v2TagSize = ID3v2.GetTagSize (stream);  	stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  	byte[] tmpFrameHeader = new byte[4];  	bool acceptNullSamples = false;  	while (true) {  		int tmpByte = stream.ReadByte ();  		// keep as ReadByte  		while (tmpByte != 0xFF && tmpByte != -1) {  			tmpByte = stream.ReadByte ();  			// keep as ReadByte  		}  		if (tmpByte == -1) {  			if (acceptNullSamples) {  				throw new InvalidDataException (string.Format ("'{0}': Can't find frame sync"' path));  			}  			stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  			acceptNullSamples = true;  			continue;  		}  		tmpFrameHeader [0] = (byte)tmpByte;  		// Get frame header  		if (stream.Read (tmpFrameHeader' 1' 3) != 3) {  			throw new InvalidDataException (string.Format ("'{0}': Invalid MPEG file; end of stream reached"' path));  		}  		// No sync  		if ((tmpFrameHeader [1] >> 5) != 0x07 || ((tmpFrameHeader [1] >> 1) & 0x03) == 0)// 2/18/05 - ignore reserved layer  		 {  			stream.Seek (-3' SeekOrigin.Current);  		} else if (tmpFrameHeader [1] == 0xFF || ((tmpFrameHeader [1] >> 3) & 0x03) == 1)// 2/19/05 - more bad data  		 {  			stream.Seek (-3' SeekOrigin.Current);  		} else {  			int tmpMpegID = (tmpFrameHeader [1] >> 3) & 0x03;  			int tmpLayerNum = (tmpFrameHeader [1] >> 1) & 0x03;  			int tmpFrequency = GetFrequency ((MpegVersion)tmpMpegID' (tmpFrameHeader [2] >> 2) & 0x03);  			// Check for invalid frequency  			if (tmpFrequency == 0) {  				stream.Seek (-3' SeekOrigin.Current);  				continue;  			}  			int tmpSamplesPerFrame = GetSamplesPerFrame ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum);  			int tmpUsesPadding = (tmpFrameHeader [2] >> 1) & 0x01;  			double tmpFrameSizeConst = 125.0 * tmpSamplesPerFrame / tmpFrequency;  			int tmpPaddingSize = (tmpLayerNum == 3 ? 4 : 1);  			int tmpBitrateIndex = tmpFrameHeader [2] >> 4;  			// Check for invalid values  			if (tmpBitrateIndex < 1 || tmpBitrateIndex > 14 || tmpLayerNum == 0) {  				stream.Seek (-3' SeekOrigin.Current);  				continue;  			}  			int tmpFrameBitrate = GetBitrate ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum' tmpBitrateIndex);  			int tmpFrameSize = (int)(tmpFrameBitrate * tmpFrameSizeConst) + (tmpUsesPadding * tmpPaddingSize);  			_headerOffset = stream.Position - 4;  			if (tmpFrameSize < 8) {  				stream.Seek (-3' SeekOrigin.Current);  				continue;  			}  			// 7/21/05 - Check for 0x00 or 0xFF at end of last frame  			// this sucks for tracks that start with silence  			if (_headerOffset >= 1 && !acceptNullSamples)// if (ftell(fp) >= 5)  			 {  				stream.Seek (-5' SeekOrigin.Current);  				byte tmpLastByte = stream.Read1 ();  				stream.Seek (4' SeekOrigin.Current);  				if (tmpFrameBitrate != 320 && (tmpLastByte == 0x00 || tmpLastByte == 0xFF)) {  					// 7/31/05  					// may be a valid frame - skip its contents to prevent false sync  					long tmpNewPosition = _headerOffset + tmpFrameSize;  					if (tmpFrameSize == 0)  						tmpNewPosition++;  					stream.Seek (tmpNewPosition' SeekOrigin.Begin);  					continue;  				}  			}  			/*if (BR == 0 || FrameSizeConst == 0)                         {                             startpos = HeaderOffset+1;                             fseek(fp' startpos' SEEK_SET);                             continue;                         }*/stream.Seek (_headerOffset + tmpFrameSize' SeekOrigin.Begin);  			if (stream.Read1 () == 0xFF) {  				fh1 = stream.Read1 ();  				fh2 = stream.Read1 ();  				if (tmpFrameHeader [1] == fh1 && (tmpFrameHeader [2] & 0x0D) == (fh2 & 0x0D)) {  					// header found  					break;  				}  			}  			stream.Seek (_headerOffset + 1' SeekOrigin.Begin);  			continue;  		}  	}  	_mpegVersion = (MpegVersion)((tmpFrameHeader [1] >> 3) & 0x03);  	_mpegLayer = (MpegLayer)((tmpFrameHeader [1] >> 1) & 0x03);  	_frequency = GetFrequency (_mpegVersion' (tmpFrameHeader [2] >> 2) & 0x03);  	if (_frequency == 0) {  		throw new InvalidDataException (String.Format ("'{0}'; cannot determine frequency"' path));  	}  	_isPrivate = ((tmpFrameHeader [2] & 0x01) == 0x01);  	_samplesPerFrame = GetSamplesPerFrame (_mpegVersion' _mpegLayer);  	_frameSizeConst = 125.0 * _samplesPerFrame / _frequency;  	_paddingSizeConst = (_mpegLayer == MpegLayer.Layer1 ? 4 : 1);  	_isCopyright = (((tmpFrameHeader [3] >> 3) & 0x01) == 0x01);  	_isOriginal = (((tmpFrameHeader [3] >> 2) & 0x01) == 0x01);  	//tmpModeExtension = (FH[3] >> 4) & 0x03; // not interested' only used in joint-stereo  	//_mpegEmphasis = (MpegEmphasis)(tmpFrameHeader[3] & 0x03);  	if ((tmpFrameHeader [3] >> 6) == 3)  		_channels = 1;  	// Single Channel  	else  		_channels = 2;  	// Read LAME Info Tag  	bool tmpHasLameInfoTag = false;  	stream.Seek (tmpID3v2TagSize + 36' SeekOrigin.Begin);  	Byte[] buf = stream.Read (4);  	if (ByteUtils.Compare (buf' INFO_MARKER))// CBR  	 {  		tmpHasLameInfoTag = true;  		_isVBR = false;  	} else if (ByteUtils.Compare (buf' XING_MARKER))// VBR  	 {  		tmpHasLameInfoTag = true;  		_isVBR = true;  	}  	if (tmpHasLameInfoTag) {  		stream.Seek (4' SeekOrigin.Current);  		int tmpFrames = stream.ReadInt32 ();  		uint tmpBytes = (uint)stream.ReadInt32 ();  		if (tmpFrames > 256 && tmpBytes > 50000) {  			decimal tmpBitrate = tmpBytes / 125.0m / (tmpFrames * _samplesPerFrame / (decimal)_frequency);  			if (tmpBitrate <= 320 && tmpBitrate >= 32) {  				_frames = tmpFrames;  				_bitrate = tmpBitrate;  				_totalSeconds = (tmpBytes / 125.0m) / _bitrate;  			}  		}  	}  	// TODO: Take these 2 lines out  	/*fs.Position = 0;                 CalculateBitrate(fs' null);*/if (calculateBitrate) {  		if (_bitrate == 0 || _isVBR == null || _frames == 0 || _totalSeconds == 0) {  			stream.Position = 0;  			CalculateBitrate (stream' null);  		}  	}  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: using (FileStream stream = File.Open (path' FileMode.Open' FileAccess.Read' FileShare.Read)) {  	int tmpID3v2TagSize = ID3v2.GetTagSize (stream);  	stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  	byte[] tmpFrameHeader = new byte[4];  	bool acceptNullSamples = false;  	while (true) {  		int tmpByte = stream.ReadByte ();  		// keep as ReadByte  		while (tmpByte != 0xFF && tmpByte != -1) {  			tmpByte = stream.ReadByte ();  			// keep as ReadByte  		}  		if (tmpByte == -1) {  			if (acceptNullSamples) {  				throw new InvalidDataException (string.Format ("'{0}': Can't find frame sync"' path));  			}  			stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  			acceptNullSamples = true;  			continue;  		}  		tmpFrameHeader [0] = (byte)tmpByte;  		// Get frame header  		if (stream.Read (tmpFrameHeader' 1' 3) != 3) {  			throw new InvalidDataException (string.Format ("'{0}': Invalid MPEG file; end of stream reached"' path));  		}  		// No sync  		if ((tmpFrameHeader [1] >> 5) != 0x07 || ((tmpFrameHeader [1] >> 1) & 0x03) == 0)// 2/18/05 - ignore reserved layer  		 {  			stream.Seek (-3' SeekOrigin.Current);  		} else if (tmpFrameHeader [1] == 0xFF || ((tmpFrameHeader [1] >> 3) & 0x03) == 1)// 2/19/05 - more bad data  		 {  			stream.Seek (-3' SeekOrigin.Current);  		} else {  			int tmpMpegID = (tmpFrameHeader [1] >> 3) & 0x03;  			int tmpLayerNum = (tmpFrameHeader [1] >> 1) & 0x03;  			int tmpFrequency = GetFrequency ((MpegVersion)tmpMpegID' (tmpFrameHeader [2] >> 2) & 0x03);  			// Check for invalid frequency  			if (tmpFrequency == 0) {  				stream.Seek (-3' SeekOrigin.Current);  				continue;  			}  			int tmpSamplesPerFrame = GetSamplesPerFrame ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum);  			int tmpUsesPadding = (tmpFrameHeader [2] >> 1) & 0x01;  			double tmpFrameSizeConst = 125.0 * tmpSamplesPerFrame / tmpFrequency;  			int tmpPaddingSize = (tmpLayerNum == 3 ? 4 : 1);  			int tmpBitrateIndex = tmpFrameHeader [2] >> 4;  			// Check for invalid values  			if (tmpBitrateIndex < 1 || tmpBitrateIndex > 14 || tmpLayerNum == 0) {  				stream.Seek (-3' SeekOrigin.Current);  				continue;  			}  			int tmpFrameBitrate = GetBitrate ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum' tmpBitrateIndex);  			int tmpFrameSize = (int)(tmpFrameBitrate * tmpFrameSizeConst) + (tmpUsesPadding * tmpPaddingSize);  			_headerOffset = stream.Position - 4;  			if (tmpFrameSize < 8) {  				stream.Seek (-3' SeekOrigin.Current);  				continue;  			}  			// 7/21/05 - Check for 0x00 or 0xFF at end of last frame  			// this sucks for tracks that start with silence  			if (_headerOffset >= 1 && !acceptNullSamples)// if (ftell(fp) >= 5)  			 {  				stream.Seek (-5' SeekOrigin.Current);  				byte tmpLastByte = stream.Read1 ();  				stream.Seek (4' SeekOrigin.Current);  				if (tmpFrameBitrate != 320 && (tmpLastByte == 0x00 || tmpLastByte == 0xFF)) {  					// 7/31/05  					// may be a valid frame - skip its contents to prevent false sync  					long tmpNewPosition = _headerOffset + tmpFrameSize;  					if (tmpFrameSize == 0)  						tmpNewPosition++;  					stream.Seek (tmpNewPosition' SeekOrigin.Begin);  					continue;  				}  			}  			/*if (BR == 0 || FrameSizeConst == 0)                         {                             startpos = HeaderOffset+1;                             fseek(fp' startpos' SEEK_SET);                             continue;                         }*/stream.Seek (_headerOffset + tmpFrameSize' SeekOrigin.Begin);  			if (stream.Read1 () == 0xFF) {  				fh1 = stream.Read1 ();  				fh2 = stream.Read1 ();  				if (tmpFrameHeader [1] == fh1 && (tmpFrameHeader [2] & 0x0D) == (fh2 & 0x0D)) {  					// header found  					break;  				}  			}  			stream.Seek (_headerOffset + 1' SeekOrigin.Begin);  			continue;  		}  	}  	_mpegVersion = (MpegVersion)((tmpFrameHeader [1] >> 3) & 0x03);  	_mpegLayer = (MpegLayer)((tmpFrameHeader [1] >> 1) & 0x03);  	_frequency = GetFrequency (_mpegVersion' (tmpFrameHeader [2] >> 2) & 0x03);  	if (_frequency == 0) {  		throw new InvalidDataException (String.Format ("'{0}'; cannot determine frequency"' path));  	}  	_isPrivate = ((tmpFrameHeader [2] & 0x01) == 0x01);  	_samplesPerFrame = GetSamplesPerFrame (_mpegVersion' _mpegLayer);  	_frameSizeConst = 125.0 * _samplesPerFrame / _frequency;  	_paddingSizeConst = (_mpegLayer == MpegLayer.Layer1 ? 4 : 1);  	_isCopyright = (((tmpFrameHeader [3] >> 3) & 0x01) == 0x01);  	_isOriginal = (((tmpFrameHeader [3] >> 2) & 0x01) == 0x01);  	//tmpModeExtension = (FH[3] >> 4) & 0x03; // not interested' only used in joint-stereo  	//_mpegEmphasis = (MpegEmphasis)(tmpFrameHeader[3] & 0x03);  	if ((tmpFrameHeader [3] >> 6) == 3)  		_channels = 1;  	// Single Channel  	else  		_channels = 2;  	// Read LAME Info Tag  	bool tmpHasLameInfoTag = false;  	stream.Seek (tmpID3v2TagSize + 36' SeekOrigin.Begin);  	Byte[] buf = stream.Read (4);  	if (ByteUtils.Compare (buf' INFO_MARKER))// CBR  	 {  		tmpHasLameInfoTag = true;  		_isVBR = false;  	} else if (ByteUtils.Compare (buf' XING_MARKER))// VBR  	 {  		tmpHasLameInfoTag = true;  		_isVBR = true;  	}  	if (tmpHasLameInfoTag) {  		stream.Seek (4' SeekOrigin.Current);  		int tmpFrames = stream.ReadInt32 ();  		uint tmpBytes = (uint)stream.ReadInt32 ();  		if (tmpFrames > 256 && tmpBytes > 50000) {  			decimal tmpBitrate = tmpBytes / 125.0m / (tmpFrames * _samplesPerFrame / (decimal)_frequency);  			if (tmpBitrate <= 320 && tmpBitrate >= 32) {  				_frames = tmpFrames;  				_bitrate = tmpBitrate;  				_totalSeconds = (tmpBytes / 125.0m) / _bitrate;  			}  		}  	}  	// TODO: Take these 2 lines out  	/*fs.Position = 0;                 CalculateBitrate(fs' null);*/if (calculateBitrate) {  		if (_bitrate == 0 || _isVBR == null || _frames == 0 || _totalSeconds == 0) {  			stream.Position = 0;  			CalculateBitrate (stream' null);  		}  	}  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: using (FileStream stream = File.Open (path' FileMode.Open' FileAccess.Read' FileShare.Read)) {  	int tmpID3v2TagSize = ID3v2.GetTagSize (stream);  	stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  	byte[] tmpFrameHeader = new byte[4];  	bool acceptNullSamples = false;  	while (true) {  		int tmpByte = stream.ReadByte ();  		// keep as ReadByte  		while (tmpByte != 0xFF && tmpByte != -1) {  			tmpByte = stream.ReadByte ();  			// keep as ReadByte  		}  		if (tmpByte == -1) {  			if (acceptNullSamples) {  				throw new InvalidDataException (string.Format ("'{0}': Can't find frame sync"' path));  			}  			stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  			acceptNullSamples = true;  			continue;  		}  		tmpFrameHeader [0] = (byte)tmpByte;  		// Get frame header  		if (stream.Read (tmpFrameHeader' 1' 3) != 3) {  			throw new InvalidDataException (string.Format ("'{0}': Invalid MPEG file; end of stream reached"' path));  		}  		// No sync  		if ((tmpFrameHeader [1] >> 5) != 0x07 || ((tmpFrameHeader [1] >> 1) & 0x03) == 0)// 2/18/05 - ignore reserved layer  		 {  			stream.Seek (-3' SeekOrigin.Current);  		} else if (tmpFrameHeader [1] == 0xFF || ((tmpFrameHeader [1] >> 3) & 0x03) == 1)// 2/19/05 - more bad data  		 {  			stream.Seek (-3' SeekOrigin.Current);  		} else {  			int tmpMpegID = (tmpFrameHeader [1] >> 3) & 0x03;  			int tmpLayerNum = (tmpFrameHeader [1] >> 1) & 0x03;  			int tmpFrequency = GetFrequency ((MpegVersion)tmpMpegID' (tmpFrameHeader [2] >> 2) & 0x03);  			// Check for invalid frequency  			if (tmpFrequency == 0) {  				stream.Seek (-3' SeekOrigin.Current);  				continue;  			}  			int tmpSamplesPerFrame = GetSamplesPerFrame ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum);  			int tmpUsesPadding = (tmpFrameHeader [2] >> 1) & 0x01;  			double tmpFrameSizeConst = 125.0 * tmpSamplesPerFrame / tmpFrequency;  			int tmpPaddingSize = (tmpLayerNum == 3 ? 4 : 1);  			int tmpBitrateIndex = tmpFrameHeader [2] >> 4;  			// Check for invalid values  			if (tmpBitrateIndex < 1 || tmpBitrateIndex > 14 || tmpLayerNum == 0) {  				stream.Seek (-3' SeekOrigin.Current);  				continue;  			}  			int tmpFrameBitrate = GetBitrate ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum' tmpBitrateIndex);  			int tmpFrameSize = (int)(tmpFrameBitrate * tmpFrameSizeConst) + (tmpUsesPadding * tmpPaddingSize);  			_headerOffset = stream.Position - 4;  			if (tmpFrameSize < 8) {  				stream.Seek (-3' SeekOrigin.Current);  				continue;  			}  			// 7/21/05 - Check for 0x00 or 0xFF at end of last frame  			// this sucks for tracks that start with silence  			if (_headerOffset >= 1 && !acceptNullSamples)// if (ftell(fp) >= 5)  			 {  				stream.Seek (-5' SeekOrigin.Current);  				byte tmpLastByte = stream.Read1 ();  				stream.Seek (4' SeekOrigin.Current);  				if (tmpFrameBitrate != 320 && (tmpLastByte == 0x00 || tmpLastByte == 0xFF)) {  					// 7/31/05  					// may be a valid frame - skip its contents to prevent false sync  					long tmpNewPosition = _headerOffset + tmpFrameSize;  					if (tmpFrameSize == 0)  						tmpNewPosition++;  					stream.Seek (tmpNewPosition' SeekOrigin.Begin);  					continue;  				}  			}  			/*if (BR == 0 || FrameSizeConst == 0)                         {                             startpos = HeaderOffset+1;                             fseek(fp' startpos' SEEK_SET);                             continue;                         }*/stream.Seek (_headerOffset + tmpFrameSize' SeekOrigin.Begin);  			if (stream.Read1 () == 0xFF) {  				fh1 = stream.Read1 ();  				fh2 = stream.Read1 ();  				if (tmpFrameHeader [1] == fh1 && (tmpFrameHeader [2] & 0x0D) == (fh2 & 0x0D)) {  					// header found  					break;  				}  			}  			stream.Seek (_headerOffset + 1' SeekOrigin.Begin);  			continue;  		}  	}  	_mpegVersion = (MpegVersion)((tmpFrameHeader [1] >> 3) & 0x03);  	_mpegLayer = (MpegLayer)((tmpFrameHeader [1] >> 1) & 0x03);  	_frequency = GetFrequency (_mpegVersion' (tmpFrameHeader [2] >> 2) & 0x03);  	if (_frequency == 0) {  		throw new InvalidDataException (String.Format ("'{0}'; cannot determine frequency"' path));  	}  	_isPrivate = ((tmpFrameHeader [2] & 0x01) == 0x01);  	_samplesPerFrame = GetSamplesPerFrame (_mpegVersion' _mpegLayer);  	_frameSizeConst = 125.0 * _samplesPerFrame / _frequency;  	_paddingSizeConst = (_mpegLayer == MpegLayer.Layer1 ? 4 : 1);  	_isCopyright = (((tmpFrameHeader [3] >> 3) & 0x01) == 0x01);  	_isOriginal = (((tmpFrameHeader [3] >> 2) & 0x01) == 0x01);  	//tmpModeExtension = (FH[3] >> 4) & 0x03; // not interested' only used in joint-stereo  	//_mpegEmphasis = (MpegEmphasis)(tmpFrameHeader[3] & 0x03);  	if ((tmpFrameHeader [3] >> 6) == 3)  		_channels = 1;  	// Single Channel  	else  		_channels = 2;  	// Read LAME Info Tag  	bool tmpHasLameInfoTag = false;  	stream.Seek (tmpID3v2TagSize + 36' SeekOrigin.Begin);  	Byte[] buf = stream.Read (4);  	if (ByteUtils.Compare (buf' INFO_MARKER))// CBR  	 {  		tmpHasLameInfoTag = true;  		_isVBR = false;  	} else if (ByteUtils.Compare (buf' XING_MARKER))// VBR  	 {  		tmpHasLameInfoTag = true;  		_isVBR = true;  	}  	if (tmpHasLameInfoTag) {  		stream.Seek (4' SeekOrigin.Current);  		int tmpFrames = stream.ReadInt32 ();  		uint tmpBytes = (uint)stream.ReadInt32 ();  		if (tmpFrames > 256 && tmpBytes > 50000) {  			decimal tmpBitrate = tmpBytes / 125.0m / (tmpFrames * _samplesPerFrame / (decimal)_frequency);  			if (tmpBitrate <= 320 && tmpBitrate >= 32) {  				_frames = tmpFrames;  				_bitrate = tmpBitrate;  				_totalSeconds = (tmpBytes / 125.0m) / _bitrate;  			}  		}  	}  	// TODO: Take these 2 lines out  	/*fs.Position = 0;                 CalculateBitrate(fs' null);*/if (calculateBitrate) {  		if (_bitrate == 0 || _isVBR == null || _frames == 0 || _totalSeconds == 0) {  			stream.Position = 0;  			CalculateBitrate (stream' null);  		}  	}  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: using (FileStream stream = File.Open (path' FileMode.Open' FileAccess.Read' FileShare.Read)) {  	int tmpID3v2TagSize = ID3v2.GetTagSize (stream);  	stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  	byte[] tmpFrameHeader = new byte[4];  	bool acceptNullSamples = false;  	while (true) {  		int tmpByte = stream.ReadByte ();  		// keep as ReadByte  		while (tmpByte != 0xFF && tmpByte != -1) {  			tmpByte = stream.ReadByte ();  			// keep as ReadByte  		}  		if (tmpByte == -1) {  			if (acceptNullSamples) {  				throw new InvalidDataException (string.Format ("'{0}': Can't find frame sync"' path));  			}  			stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  			acceptNullSamples = true;  			continue;  		}  		tmpFrameHeader [0] = (byte)tmpByte;  		// Get frame header  		if (stream.Read (tmpFrameHeader' 1' 3) != 3) {  			throw new InvalidDataException (string.Format ("'{0}': Invalid MPEG file; end of stream reached"' path));  		}  		// No sync  		if ((tmpFrameHeader [1] >> 5) != 0x07 || ((tmpFrameHeader [1] >> 1) & 0x03) == 0)// 2/18/05 - ignore reserved layer  		 {  			stream.Seek (-3' SeekOrigin.Current);  		} else if (tmpFrameHeader [1] == 0xFF || ((tmpFrameHeader [1] >> 3) & 0x03) == 1)// 2/19/05 - more bad data  		 {  			stream.Seek (-3' SeekOrigin.Current);  		} else {  			int tmpMpegID = (tmpFrameHeader [1] >> 3) & 0x03;  			int tmpLayerNum = (tmpFrameHeader [1] >> 1) & 0x03;  			int tmpFrequency = GetFrequency ((MpegVersion)tmpMpegID' (tmpFrameHeader [2] >> 2) & 0x03);  			// Check for invalid frequency  			if (tmpFrequency == 0) {  				stream.Seek (-3' SeekOrigin.Current);  				continue;  			}  			int tmpSamplesPerFrame = GetSamplesPerFrame ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum);  			int tmpUsesPadding = (tmpFrameHeader [2] >> 1) & 0x01;  			double tmpFrameSizeConst = 125.0 * tmpSamplesPerFrame / tmpFrequency;  			int tmpPaddingSize = (tmpLayerNum == 3 ? 4 : 1);  			int tmpBitrateIndex = tmpFrameHeader [2] >> 4;  			// Check for invalid values  			if (tmpBitrateIndex < 1 || tmpBitrateIndex > 14 || tmpLayerNum == 0) {  				stream.Seek (-3' SeekOrigin.Current);  				continue;  			}  			int tmpFrameBitrate = GetBitrate ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum' tmpBitrateIndex);  			int tmpFrameSize = (int)(tmpFrameBitrate * tmpFrameSizeConst) + (tmpUsesPadding * tmpPaddingSize);  			_headerOffset = stream.Position - 4;  			if (tmpFrameSize < 8) {  				stream.Seek (-3' SeekOrigin.Current);  				continue;  			}  			// 7/21/05 - Check for 0x00 or 0xFF at end of last frame  			// this sucks for tracks that start with silence  			if (_headerOffset >= 1 && !acceptNullSamples)// if (ftell(fp) >= 5)  			 {  				stream.Seek (-5' SeekOrigin.Current);  				byte tmpLastByte = stream.Read1 ();  				stream.Seek (4' SeekOrigin.Current);  				if (tmpFrameBitrate != 320 && (tmpLastByte == 0x00 || tmpLastByte == 0xFF)) {  					// 7/31/05  					// may be a valid frame - skip its contents to prevent false sync  					long tmpNewPosition = _headerOffset + tmpFrameSize;  					if (tmpFrameSize == 0)  						tmpNewPosition++;  					stream.Seek (tmpNewPosition' SeekOrigin.Begin);  					continue;  				}  			}  			/*if (BR == 0 || FrameSizeConst == 0)                         {                             startpos = HeaderOffset+1;                             fseek(fp' startpos' SEEK_SET);                             continue;                         }*/stream.Seek (_headerOffset + tmpFrameSize' SeekOrigin.Begin);  			if (stream.Read1 () == 0xFF) {  				fh1 = stream.Read1 ();  				fh2 = stream.Read1 ();  				if (tmpFrameHeader [1] == fh1 && (tmpFrameHeader [2] & 0x0D) == (fh2 & 0x0D)) {  					// header found  					break;  				}  			}  			stream.Seek (_headerOffset + 1' SeekOrigin.Begin);  			continue;  		}  	}  	_mpegVersion = (MpegVersion)((tmpFrameHeader [1] >> 3) & 0x03);  	_mpegLayer = (MpegLayer)((tmpFrameHeader [1] >> 1) & 0x03);  	_frequency = GetFrequency (_mpegVersion' (tmpFrameHeader [2] >> 2) & 0x03);  	if (_frequency == 0) {  		throw new InvalidDataException (String.Format ("'{0}'; cannot determine frequency"' path));  	}  	_isPrivate = ((tmpFrameHeader [2] & 0x01) == 0x01);  	_samplesPerFrame = GetSamplesPerFrame (_mpegVersion' _mpegLayer);  	_frameSizeConst = 125.0 * _samplesPerFrame / _frequency;  	_paddingSizeConst = (_mpegLayer == MpegLayer.Layer1 ? 4 : 1);  	_isCopyright = (((tmpFrameHeader [3] >> 3) & 0x01) == 0x01);  	_isOriginal = (((tmpFrameHeader [3] >> 2) & 0x01) == 0x01);  	//tmpModeExtension = (FH[3] >> 4) & 0x03; // not interested' only used in joint-stereo  	//_mpegEmphasis = (MpegEmphasis)(tmpFrameHeader[3] & 0x03);  	if ((tmpFrameHeader [3] >> 6) == 3)  		_channels = 1;  	// Single Channel  	else  		_channels = 2;  	// Read LAME Info Tag  	bool tmpHasLameInfoTag = false;  	stream.Seek (tmpID3v2TagSize + 36' SeekOrigin.Begin);  	Byte[] buf = stream.Read (4);  	if (ByteUtils.Compare (buf' INFO_MARKER))// CBR  	 {  		tmpHasLameInfoTag = true;  		_isVBR = false;  	} else if (ByteUtils.Compare (buf' XING_MARKER))// VBR  	 {  		tmpHasLameInfoTag = true;  		_isVBR = true;  	}  	if (tmpHasLameInfoTag) {  		stream.Seek (4' SeekOrigin.Current);  		int tmpFrames = stream.ReadInt32 ();  		uint tmpBytes = (uint)stream.ReadInt32 ();  		if (tmpFrames > 256 && tmpBytes > 50000) {  			decimal tmpBitrate = tmpBytes / 125.0m / (tmpFrames * _samplesPerFrame / (decimal)_frequency);  			if (tmpBitrate <= 320 && tmpBitrate >= 32) {  				_frames = tmpFrames;  				_bitrate = tmpBitrate;  				_totalSeconds = (tmpBytes / 125.0m) / _bitrate;  			}  		}  	}  	// TODO: Take these 2 lines out  	/*fs.Position = 0;                 CalculateBitrate(fs' null);*/if (calculateBitrate) {  		if (_bitrate == 0 || _isVBR == null || _frames == 0 || _totalSeconds == 0) {  			stream.Position = 0;  			CalculateBitrate (stream' null);  		}  	}  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: using (FileStream stream = File.Open (path' FileMode.Open' FileAccess.Read' FileShare.Read)) {  	int tmpID3v2TagSize = ID3v2.GetTagSize (stream);  	stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  	byte[] tmpFrameHeader = new byte[4];  	bool acceptNullSamples = false;  	while (true) {  		int tmpByte = stream.ReadByte ();  		// keep as ReadByte  		while (tmpByte != 0xFF && tmpByte != -1) {  			tmpByte = stream.ReadByte ();  			// keep as ReadByte  		}  		if (tmpByte == -1) {  			if (acceptNullSamples) {  				throw new InvalidDataException (string.Format ("'{0}': Can't find frame sync"' path));  			}  			stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  			acceptNullSamples = true;  			continue;  		}  		tmpFrameHeader [0] = (byte)tmpByte;  		// Get frame header  		if (stream.Read (tmpFrameHeader' 1' 3) != 3) {  			throw new InvalidDataException (string.Format ("'{0}': Invalid MPEG file; end of stream reached"' path));  		}  		// No sync  		if ((tmpFrameHeader [1] >> 5) != 0x07 || ((tmpFrameHeader [1] >> 1) & 0x03) == 0)// 2/18/05 - ignore reserved layer  		 {  			stream.Seek (-3' SeekOrigin.Current);  		} else if (tmpFrameHeader [1] == 0xFF || ((tmpFrameHeader [1] >> 3) & 0x03) == 1)// 2/19/05 - more bad data  		 {  			stream.Seek (-3' SeekOrigin.Current);  		} else {  			int tmpMpegID = (tmpFrameHeader [1] >> 3) & 0x03;  			int tmpLayerNum = (tmpFrameHeader [1] >> 1) & 0x03;  			int tmpFrequency = GetFrequency ((MpegVersion)tmpMpegID' (tmpFrameHeader [2] >> 2) & 0x03);  			// Check for invalid frequency  			if (tmpFrequency == 0) {  				stream.Seek (-3' SeekOrigin.Current);  				continue;  			}  			int tmpSamplesPerFrame = GetSamplesPerFrame ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum);  			int tmpUsesPadding = (tmpFrameHeader [2] >> 1) & 0x01;  			double tmpFrameSizeConst = 125.0 * tmpSamplesPerFrame / tmpFrequency;  			int tmpPaddingSize = (tmpLayerNum == 3 ? 4 : 1);  			int tmpBitrateIndex = tmpFrameHeader [2] >> 4;  			// Check for invalid values  			if (tmpBitrateIndex < 1 || tmpBitrateIndex > 14 || tmpLayerNum == 0) {  				stream.Seek (-3' SeekOrigin.Current);  				continue;  			}  			int tmpFrameBitrate = GetBitrate ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum' tmpBitrateIndex);  			int tmpFrameSize = (int)(tmpFrameBitrate * tmpFrameSizeConst) + (tmpUsesPadding * tmpPaddingSize);  			_headerOffset = stream.Position - 4;  			if (tmpFrameSize < 8) {  				stream.Seek (-3' SeekOrigin.Current);  				continue;  			}  			// 7/21/05 - Check for 0x00 or 0xFF at end of last frame  			// this sucks for tracks that start with silence  			if (_headerOffset >= 1 && !acceptNullSamples)// if (ftell(fp) >= 5)  			 {  				stream.Seek (-5' SeekOrigin.Current);  				byte tmpLastByte = stream.Read1 ();  				stream.Seek (4' SeekOrigin.Current);  				if (tmpFrameBitrate != 320 && (tmpLastByte == 0x00 || tmpLastByte == 0xFF)) {  					// 7/31/05  					// may be a valid frame - skip its contents to prevent false sync  					long tmpNewPosition = _headerOffset + tmpFrameSize;  					if (tmpFrameSize == 0)  						tmpNewPosition++;  					stream.Seek (tmpNewPosition' SeekOrigin.Begin);  					continue;  				}  			}  			/*if (BR == 0 || FrameSizeConst == 0)                         {                             startpos = HeaderOffset+1;                             fseek(fp' startpos' SEEK_SET);                             continue;                         }*/stream.Seek (_headerOffset + tmpFrameSize' SeekOrigin.Begin);  			if (stream.Read1 () == 0xFF) {  				fh1 = stream.Read1 ();  				fh2 = stream.Read1 ();  				if (tmpFrameHeader [1] == fh1 && (tmpFrameHeader [2] & 0x0D) == (fh2 & 0x0D)) {  					// header found  					break;  				}  			}  			stream.Seek (_headerOffset + 1' SeekOrigin.Begin);  			continue;  		}  	}  	_mpegVersion = (MpegVersion)((tmpFrameHeader [1] >> 3) & 0x03);  	_mpegLayer = (MpegLayer)((tmpFrameHeader [1] >> 1) & 0x03);  	_frequency = GetFrequency (_mpegVersion' (tmpFrameHeader [2] >> 2) & 0x03);  	if (_frequency == 0) {  		throw new InvalidDataException (String.Format ("'{0}'; cannot determine frequency"' path));  	}  	_isPrivate = ((tmpFrameHeader [2] & 0x01) == 0x01);  	_samplesPerFrame = GetSamplesPerFrame (_mpegVersion' _mpegLayer);  	_frameSizeConst = 125.0 * _samplesPerFrame / _frequency;  	_paddingSizeConst = (_mpegLayer == MpegLayer.Layer1 ? 4 : 1);  	_isCopyright = (((tmpFrameHeader [3] >> 3) & 0x01) == 0x01);  	_isOriginal = (((tmpFrameHeader [3] >> 2) & 0x01) == 0x01);  	//tmpModeExtension = (FH[3] >> 4) & 0x03; // not interested' only used in joint-stereo  	//_mpegEmphasis = (MpegEmphasis)(tmpFrameHeader[3] & 0x03);  	if ((tmpFrameHeader [3] >> 6) == 3)  		_channels = 1;  	// Single Channel  	else  		_channels = 2;  	// Read LAME Info Tag  	bool tmpHasLameInfoTag = false;  	stream.Seek (tmpID3v2TagSize + 36' SeekOrigin.Begin);  	Byte[] buf = stream.Read (4);  	if (ByteUtils.Compare (buf' INFO_MARKER))// CBR  	 {  		tmpHasLameInfoTag = true;  		_isVBR = false;  	} else if (ByteUtils.Compare (buf' XING_MARKER))// VBR  	 {  		tmpHasLameInfoTag = true;  		_isVBR = true;  	}  	if (tmpHasLameInfoTag) {  		stream.Seek (4' SeekOrigin.Current);  		int tmpFrames = stream.ReadInt32 ();  		uint tmpBytes = (uint)stream.ReadInt32 ();  		if (tmpFrames > 256 && tmpBytes > 50000) {  			decimal tmpBitrate = tmpBytes / 125.0m / (tmpFrames * _samplesPerFrame / (decimal)_frequency);  			if (tmpBitrate <= 320 && tmpBitrate >= 32) {  				_frames = tmpFrames;  				_bitrate = tmpBitrate;  				_totalSeconds = (tmpBytes / 125.0m) / _bitrate;  			}  		}  	}  	// TODO: Take these 2 lines out  	/*fs.Position = 0;                 CalculateBitrate(fs' null);*/if (calculateBitrate) {  		if (_bitrate == 0 || _isVBR == null || _frames == 0 || _totalSeconds == 0) {  			stream.Position = 0;  			CalculateBitrate (stream' null);  		}  	}  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: using (FileStream stream = File.Open (path' FileMode.Open' FileAccess.Read' FileShare.Read)) {  	int tmpID3v2TagSize = ID3v2.GetTagSize (stream);  	stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  	byte[] tmpFrameHeader = new byte[4];  	bool acceptNullSamples = false;  	while (true) {  		int tmpByte = stream.ReadByte ();  		// keep as ReadByte  		while (tmpByte != 0xFF && tmpByte != -1) {  			tmpByte = stream.ReadByte ();  			// keep as ReadByte  		}  		if (tmpByte == -1) {  			if (acceptNullSamples) {  				throw new InvalidDataException (string.Format ("'{0}': Can't find frame sync"' path));  			}  			stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  			acceptNullSamples = true;  			continue;  		}  		tmpFrameHeader [0] = (byte)tmpByte;  		// Get frame header  		if (stream.Read (tmpFrameHeader' 1' 3) != 3) {  			throw new InvalidDataException (string.Format ("'{0}': Invalid MPEG file; end of stream reached"' path));  		}  		// No sync  		if ((tmpFrameHeader [1] >> 5) != 0x07 || ((tmpFrameHeader [1] >> 1) & 0x03) == 0)// 2/18/05 - ignore reserved layer  		 {  			stream.Seek (-3' SeekOrigin.Current);  		} else if (tmpFrameHeader [1] == 0xFF || ((tmpFrameHeader [1] >> 3) & 0x03) == 1)// 2/19/05 - more bad data  		 {  			stream.Seek (-3' SeekOrigin.Current);  		} else {  			int tmpMpegID = (tmpFrameHeader [1] >> 3) & 0x03;  			int tmpLayerNum = (tmpFrameHeader [1] >> 1) & 0x03;  			int tmpFrequency = GetFrequency ((MpegVersion)tmpMpegID' (tmpFrameHeader [2] >> 2) & 0x03);  			// Check for invalid frequency  			if (tmpFrequency == 0) {  				stream.Seek (-3' SeekOrigin.Current);  				continue;  			}  			int tmpSamplesPerFrame = GetSamplesPerFrame ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum);  			int tmpUsesPadding = (tmpFrameHeader [2] >> 1) & 0x01;  			double tmpFrameSizeConst = 125.0 * tmpSamplesPerFrame / tmpFrequency;  			int tmpPaddingSize = (tmpLayerNum == 3 ? 4 : 1);  			int tmpBitrateIndex = tmpFrameHeader [2] >> 4;  			// Check for invalid values  			if (tmpBitrateIndex < 1 || tmpBitrateIndex > 14 || tmpLayerNum == 0) {  				stream.Seek (-3' SeekOrigin.Current);  				continue;  			}  			int tmpFrameBitrate = GetBitrate ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum' tmpBitrateIndex);  			int tmpFrameSize = (int)(tmpFrameBitrate * tmpFrameSizeConst) + (tmpUsesPadding * tmpPaddingSize);  			_headerOffset = stream.Position - 4;  			if (tmpFrameSize < 8) {  				stream.Seek (-3' SeekOrigin.Current);  				continue;  			}  			// 7/21/05 - Check for 0x00 or 0xFF at end of last frame  			// this sucks for tracks that start with silence  			if (_headerOffset >= 1 && !acceptNullSamples)// if (ftell(fp) >= 5)  			 {  				stream.Seek (-5' SeekOrigin.Current);  				byte tmpLastByte = stream.Read1 ();  				stream.Seek (4' SeekOrigin.Current);  				if (tmpFrameBitrate != 320 && (tmpLastByte == 0x00 || tmpLastByte == 0xFF)) {  					// 7/31/05  					// may be a valid frame - skip its contents to prevent false sync  					long tmpNewPosition = _headerOffset + tmpFrameSize;  					if (tmpFrameSize == 0)  						tmpNewPosition++;  					stream.Seek (tmpNewPosition' SeekOrigin.Begin);  					continue;  				}  			}  			/*if (BR == 0 || FrameSizeConst == 0)                         {                             startpos = HeaderOffset+1;                             fseek(fp' startpos' SEEK_SET);                             continue;                         }*/stream.Seek (_headerOffset + tmpFrameSize' SeekOrigin.Begin);  			if (stream.Read1 () == 0xFF) {  				fh1 = stream.Read1 ();  				fh2 = stream.Read1 ();  				if (tmpFrameHeader [1] == fh1 && (tmpFrameHeader [2] & 0x0D) == (fh2 & 0x0D)) {  					// header found  					break;  				}  			}  			stream.Seek (_headerOffset + 1' SeekOrigin.Begin);  			continue;  		}  	}  	_mpegVersion = (MpegVersion)((tmpFrameHeader [1] >> 3) & 0x03);  	_mpegLayer = (MpegLayer)((tmpFrameHeader [1] >> 1) & 0x03);  	_frequency = GetFrequency (_mpegVersion' (tmpFrameHeader [2] >> 2) & 0x03);  	if (_frequency == 0) {  		throw new InvalidDataException (String.Format ("'{0}'; cannot determine frequency"' path));  	}  	_isPrivate = ((tmpFrameHeader [2] & 0x01) == 0x01);  	_samplesPerFrame = GetSamplesPerFrame (_mpegVersion' _mpegLayer);  	_frameSizeConst = 125.0 * _samplesPerFrame / _frequency;  	_paddingSizeConst = (_mpegLayer == MpegLayer.Layer1 ? 4 : 1);  	_isCopyright = (((tmpFrameHeader [3] >> 3) & 0x01) == 0x01);  	_isOriginal = (((tmpFrameHeader [3] >> 2) & 0x01) == 0x01);  	//tmpModeExtension = (FH[3] >> 4) & 0x03; // not interested' only used in joint-stereo  	//_mpegEmphasis = (MpegEmphasis)(tmpFrameHeader[3] & 0x03);  	if ((tmpFrameHeader [3] >> 6) == 3)  		_channels = 1;  	// Single Channel  	else  		_channels = 2;  	// Read LAME Info Tag  	bool tmpHasLameInfoTag = false;  	stream.Seek (tmpID3v2TagSize + 36' SeekOrigin.Begin);  	Byte[] buf = stream.Read (4);  	if (ByteUtils.Compare (buf' INFO_MARKER))// CBR  	 {  		tmpHasLameInfoTag = true;  		_isVBR = false;  	} else if (ByteUtils.Compare (buf' XING_MARKER))// VBR  	 {  		tmpHasLameInfoTag = true;  		_isVBR = true;  	}  	if (tmpHasLameInfoTag) {  		stream.Seek (4' SeekOrigin.Current);  		int tmpFrames = stream.ReadInt32 ();  		uint tmpBytes = (uint)stream.ReadInt32 ();  		if (tmpFrames > 256 && tmpBytes > 50000) {  			decimal tmpBitrate = tmpBytes / 125.0m / (tmpFrames * _samplesPerFrame / (decimal)_frequency);  			if (tmpBitrate <= 320 && tmpBitrate >= 32) {  				_frames = tmpFrames;  				_bitrate = tmpBitrate;  				_totalSeconds = (tmpBytes / 125.0m) / _bitrate;  			}  		}  	}  	// TODO: Take these 2 lines out  	/*fs.Position = 0;                 CalculateBitrate(fs' null);*/if (calculateBitrate) {  		if (_bitrate == 0 || _isVBR == null || _frames == 0 || _totalSeconds == 0) {  			stream.Position = 0;  			CalculateBitrate (stream' null);  		}  	}  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: using (FileStream stream = File.Open (path' FileMode.Open' FileAccess.Read' FileShare.Read)) {  	int tmpID3v2TagSize = ID3v2.GetTagSize (stream);  	stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  	byte[] tmpFrameHeader = new byte[4];  	bool acceptNullSamples = false;  	while (true) {  		int tmpByte = stream.ReadByte ();  		// keep as ReadByte  		while (tmpByte != 0xFF && tmpByte != -1) {  			tmpByte = stream.ReadByte ();  			// keep as ReadByte  		}  		if (tmpByte == -1) {  			if (acceptNullSamples) {  				throw new InvalidDataException (string.Format ("'{0}': Can't find frame sync"' path));  			}  			stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  			acceptNullSamples = true;  			continue;  		}  		tmpFrameHeader [0] = (byte)tmpByte;  		// Get frame header  		if (stream.Read (tmpFrameHeader' 1' 3) != 3) {  			throw new InvalidDataException (string.Format ("'{0}': Invalid MPEG file; end of stream reached"' path));  		}  		// No sync  		if ((tmpFrameHeader [1] >> 5) != 0x07 || ((tmpFrameHeader [1] >> 1) & 0x03) == 0)// 2/18/05 - ignore reserved layer  		 {  			stream.Seek (-3' SeekOrigin.Current);  		} else if (tmpFrameHeader [1] == 0xFF || ((tmpFrameHeader [1] >> 3) & 0x03) == 1)// 2/19/05 - more bad data  		 {  			stream.Seek (-3' SeekOrigin.Current);  		} else {  			int tmpMpegID = (tmpFrameHeader [1] >> 3) & 0x03;  			int tmpLayerNum = (tmpFrameHeader [1] >> 1) & 0x03;  			int tmpFrequency = GetFrequency ((MpegVersion)tmpMpegID' (tmpFrameHeader [2] >> 2) & 0x03);  			// Check for invalid frequency  			if (tmpFrequency == 0) {  				stream.Seek (-3' SeekOrigin.Current);  				continue;  			}  			int tmpSamplesPerFrame = GetSamplesPerFrame ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum);  			int tmpUsesPadding = (tmpFrameHeader [2] >> 1) & 0x01;  			double tmpFrameSizeConst = 125.0 * tmpSamplesPerFrame / tmpFrequency;  			int tmpPaddingSize = (tmpLayerNum == 3 ? 4 : 1);  			int tmpBitrateIndex = tmpFrameHeader [2] >> 4;  			// Check for invalid values  			if (tmpBitrateIndex < 1 || tmpBitrateIndex > 14 || tmpLayerNum == 0) {  				stream.Seek (-3' SeekOrigin.Current);  				continue;  			}  			int tmpFrameBitrate = GetBitrate ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum' tmpBitrateIndex);  			int tmpFrameSize = (int)(tmpFrameBitrate * tmpFrameSizeConst) + (tmpUsesPadding * tmpPaddingSize);  			_headerOffset = stream.Position - 4;  			if (tmpFrameSize < 8) {  				stream.Seek (-3' SeekOrigin.Current);  				continue;  			}  			// 7/21/05 - Check for 0x00 or 0xFF at end of last frame  			// this sucks for tracks that start with silence  			if (_headerOffset >= 1 && !acceptNullSamples)// if (ftell(fp) >= 5)  			 {  				stream.Seek (-5' SeekOrigin.Current);  				byte tmpLastByte = stream.Read1 ();  				stream.Seek (4' SeekOrigin.Current);  				if (tmpFrameBitrate != 320 && (tmpLastByte == 0x00 || tmpLastByte == 0xFF)) {  					// 7/31/05  					// may be a valid frame - skip its contents to prevent false sync  					long tmpNewPosition = _headerOffset + tmpFrameSize;  					if (tmpFrameSize == 0)  						tmpNewPosition++;  					stream.Seek (tmpNewPosition' SeekOrigin.Begin);  					continue;  				}  			}  			/*if (BR == 0 || FrameSizeConst == 0)                         {                             startpos = HeaderOffset+1;                             fseek(fp' startpos' SEEK_SET);                             continue;                         }*/stream.Seek (_headerOffset + tmpFrameSize' SeekOrigin.Begin);  			if (stream.Read1 () == 0xFF) {  				fh1 = stream.Read1 ();  				fh2 = stream.Read1 ();  				if (tmpFrameHeader [1] == fh1 && (tmpFrameHeader [2] & 0x0D) == (fh2 & 0x0D)) {  					// header found  					break;  				}  			}  			stream.Seek (_headerOffset + 1' SeekOrigin.Begin);  			continue;  		}  	}  	_mpegVersion = (MpegVersion)((tmpFrameHeader [1] >> 3) & 0x03);  	_mpegLayer = (MpegLayer)((tmpFrameHeader [1] >> 1) & 0x03);  	_frequency = GetFrequency (_mpegVersion' (tmpFrameHeader [2] >> 2) & 0x03);  	if (_frequency == 0) {  		throw new InvalidDataException (String.Format ("'{0}'; cannot determine frequency"' path));  	}  	_isPrivate = ((tmpFrameHeader [2] & 0x01) == 0x01);  	_samplesPerFrame = GetSamplesPerFrame (_mpegVersion' _mpegLayer);  	_frameSizeConst = 125.0 * _samplesPerFrame / _frequency;  	_paddingSizeConst = (_mpegLayer == MpegLayer.Layer1 ? 4 : 1);  	_isCopyright = (((tmpFrameHeader [3] >> 3) & 0x01) == 0x01);  	_isOriginal = (((tmpFrameHeader [3] >> 2) & 0x01) == 0x01);  	//tmpModeExtension = (FH[3] >> 4) & 0x03; // not interested' only used in joint-stereo  	//_mpegEmphasis = (MpegEmphasis)(tmpFrameHeader[3] & 0x03);  	if ((tmpFrameHeader [3] >> 6) == 3)  		_channels = 1;  	// Single Channel  	else  		_channels = 2;  	// Read LAME Info Tag  	bool tmpHasLameInfoTag = false;  	stream.Seek (tmpID3v2TagSize + 36' SeekOrigin.Begin);  	Byte[] buf = stream.Read (4);  	if (ByteUtils.Compare (buf' INFO_MARKER))// CBR  	 {  		tmpHasLameInfoTag = true;  		_isVBR = false;  	} else if (ByteUtils.Compare (buf' XING_MARKER))// VBR  	 {  		tmpHasLameInfoTag = true;  		_isVBR = true;  	}  	if (tmpHasLameInfoTag) {  		stream.Seek (4' SeekOrigin.Current);  		int tmpFrames = stream.ReadInt32 ();  		uint tmpBytes = (uint)stream.ReadInt32 ();  		if (tmpFrames > 256 && tmpBytes > 50000) {  			decimal tmpBitrate = tmpBytes / 125.0m / (tmpFrames * _samplesPerFrame / (decimal)_frequency);  			if (tmpBitrate <= 320 && tmpBitrate >= 32) {  				_frames = tmpFrames;  				_bitrate = tmpBitrate;  				_totalSeconds = (tmpBytes / 125.0m) / _bitrate;  			}  		}  	}  	// TODO: Take these 2 lines out  	/*fs.Position = 0;                 CalculateBitrate(fs' null);*/if (calculateBitrate) {  		if (_bitrate == 0 || _isVBR == null || _frames == 0 || _totalSeconds == 0) {  			stream.Position = 0;  			CalculateBitrate (stream' null);  		}  	}  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: using (FileStream stream = File.Open (path' FileMode.Open' FileAccess.Read' FileShare.Read)) {  	int tmpID3v2TagSize = ID3v2.GetTagSize (stream);  	stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  	byte[] tmpFrameHeader = new byte[4];  	bool acceptNullSamples = false;  	while (true) {  		int tmpByte = stream.ReadByte ();  		// keep as ReadByte  		while (tmpByte != 0xFF && tmpByte != -1) {  			tmpByte = stream.ReadByte ();  			// keep as ReadByte  		}  		if (tmpByte == -1) {  			if (acceptNullSamples) {  				throw new InvalidDataException (string.Format ("'{0}': Can't find frame sync"' path));  			}  			stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  			acceptNullSamples = true;  			continue;  		}  		tmpFrameHeader [0] = (byte)tmpByte;  		// Get frame header  		if (stream.Read (tmpFrameHeader' 1' 3) != 3) {  			throw new InvalidDataException (string.Format ("'{0}': Invalid MPEG file; end of stream reached"' path));  		}  		// No sync  		if ((tmpFrameHeader [1] >> 5) != 0x07 || ((tmpFrameHeader [1] >> 1) & 0x03) == 0)// 2/18/05 - ignore reserved layer  		 {  			stream.Seek (-3' SeekOrigin.Current);  		} else if (tmpFrameHeader [1] == 0xFF || ((tmpFrameHeader [1] >> 3) & 0x03) == 1)// 2/19/05 - more bad data  		 {  			stream.Seek (-3' SeekOrigin.Current);  		} else {  			int tmpMpegID = (tmpFrameHeader [1] >> 3) & 0x03;  			int tmpLayerNum = (tmpFrameHeader [1] >> 1) & 0x03;  			int tmpFrequency = GetFrequency ((MpegVersion)tmpMpegID' (tmpFrameHeader [2] >> 2) & 0x03);  			// Check for invalid frequency  			if (tmpFrequency == 0) {  				stream.Seek (-3' SeekOrigin.Current);  				continue;  			}  			int tmpSamplesPerFrame = GetSamplesPerFrame ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum);  			int tmpUsesPadding = (tmpFrameHeader [2] >> 1) & 0x01;  			double tmpFrameSizeConst = 125.0 * tmpSamplesPerFrame / tmpFrequency;  			int tmpPaddingSize = (tmpLayerNum == 3 ? 4 : 1);  			int tmpBitrateIndex = tmpFrameHeader [2] >> 4;  			// Check for invalid values  			if (tmpBitrateIndex < 1 || tmpBitrateIndex > 14 || tmpLayerNum == 0) {  				stream.Seek (-3' SeekOrigin.Current);  				continue;  			}  			int tmpFrameBitrate = GetBitrate ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum' tmpBitrateIndex);  			int tmpFrameSize = (int)(tmpFrameBitrate * tmpFrameSizeConst) + (tmpUsesPadding * tmpPaddingSize);  			_headerOffset = stream.Position - 4;  			if (tmpFrameSize < 8) {  				stream.Seek (-3' SeekOrigin.Current);  				continue;  			}  			// 7/21/05 - Check for 0x00 or 0xFF at end of last frame  			// this sucks for tracks that start with silence  			if (_headerOffset >= 1 && !acceptNullSamples)// if (ftell(fp) >= 5)  			 {  				stream.Seek (-5' SeekOrigin.Current);  				byte tmpLastByte = stream.Read1 ();  				stream.Seek (4' SeekOrigin.Current);  				if (tmpFrameBitrate != 320 && (tmpLastByte == 0x00 || tmpLastByte == 0xFF)) {  					// 7/31/05  					// may be a valid frame - skip its contents to prevent false sync  					long tmpNewPosition = _headerOffset + tmpFrameSize;  					if (tmpFrameSize == 0)  						tmpNewPosition++;  					stream.Seek (tmpNewPosition' SeekOrigin.Begin);  					continue;  				}  			}  			/*if (BR == 0 || FrameSizeConst == 0)                         {                             startpos = HeaderOffset+1;                             fseek(fp' startpos' SEEK_SET);                             continue;                         }*/stream.Seek (_headerOffset + tmpFrameSize' SeekOrigin.Begin);  			if (stream.Read1 () == 0xFF) {  				fh1 = stream.Read1 ();  				fh2 = stream.Read1 ();  				if (tmpFrameHeader [1] == fh1 && (tmpFrameHeader [2] & 0x0D) == (fh2 & 0x0D)) {  					// header found  					break;  				}  			}  			stream.Seek (_headerOffset + 1' SeekOrigin.Begin);  			continue;  		}  	}  	_mpegVersion = (MpegVersion)((tmpFrameHeader [1] >> 3) & 0x03);  	_mpegLayer = (MpegLayer)((tmpFrameHeader [1] >> 1) & 0x03);  	_frequency = GetFrequency (_mpegVersion' (tmpFrameHeader [2] >> 2) & 0x03);  	if (_frequency == 0) {  		throw new InvalidDataException (String.Format ("'{0}'; cannot determine frequency"' path));  	}  	_isPrivate = ((tmpFrameHeader [2] & 0x01) == 0x01);  	_samplesPerFrame = GetSamplesPerFrame (_mpegVersion' _mpegLayer);  	_frameSizeConst = 125.0 * _samplesPerFrame / _frequency;  	_paddingSizeConst = (_mpegLayer == MpegLayer.Layer1 ? 4 : 1);  	_isCopyright = (((tmpFrameHeader [3] >> 3) & 0x01) == 0x01);  	_isOriginal = (((tmpFrameHeader [3] >> 2) & 0x01) == 0x01);  	//tmpModeExtension = (FH[3] >> 4) & 0x03; // not interested' only used in joint-stereo  	//_mpegEmphasis = (MpegEmphasis)(tmpFrameHeader[3] & 0x03);  	if ((tmpFrameHeader [3] >> 6) == 3)  		_channels = 1;  	// Single Channel  	else  		_channels = 2;  	// Read LAME Info Tag  	bool tmpHasLameInfoTag = false;  	stream.Seek (tmpID3v2TagSize + 36' SeekOrigin.Begin);  	Byte[] buf = stream.Read (4);  	if (ByteUtils.Compare (buf' INFO_MARKER))// CBR  	 {  		tmpHasLameInfoTag = true;  		_isVBR = false;  	} else if (ByteUtils.Compare (buf' XING_MARKER))// VBR  	 {  		tmpHasLameInfoTag = true;  		_isVBR = true;  	}  	if (tmpHasLameInfoTag) {  		stream.Seek (4' SeekOrigin.Current);  		int tmpFrames = stream.ReadInt32 ();  		uint tmpBytes = (uint)stream.ReadInt32 ();  		if (tmpFrames > 256 && tmpBytes > 50000) {  			decimal tmpBitrate = tmpBytes / 125.0m / (tmpFrames * _samplesPerFrame / (decimal)_frequency);  			if (tmpBitrate <= 320 && tmpBitrate >= 32) {  				_frames = tmpFrames;  				_bitrate = tmpBitrate;  				_totalSeconds = (tmpBytes / 125.0m) / _bitrate;  			}  		}  	}  	// TODO: Take these 2 lines out  	/*fs.Position = 0;                 CalculateBitrate(fs' null);*/if (calculateBitrate) {  		if (_bitrate == 0 || _isVBR == null || _frames == 0 || _totalSeconds == 0) {  			stream.Position = 0;  			CalculateBitrate (stream' null);  		}  	}  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: using (FileStream stream = File.Open (path' FileMode.Open' FileAccess.Read' FileShare.Read)) {  	int tmpID3v2TagSize = ID3v2.GetTagSize (stream);  	stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  	byte[] tmpFrameHeader = new byte[4];  	bool acceptNullSamples = false;  	while (true) {  		int tmpByte = stream.ReadByte ();  		// keep as ReadByte  		while (tmpByte != 0xFF && tmpByte != -1) {  			tmpByte = stream.ReadByte ();  			// keep as ReadByte  		}  		if (tmpByte == -1) {  			if (acceptNullSamples) {  				throw new InvalidDataException (string.Format ("'{0}': Can't find frame sync"' path));  			}  			stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  			acceptNullSamples = true;  			continue;  		}  		tmpFrameHeader [0] = (byte)tmpByte;  		// Get frame header  		if (stream.Read (tmpFrameHeader' 1' 3) != 3) {  			throw new InvalidDataException (string.Format ("'{0}': Invalid MPEG file; end of stream reached"' path));  		}  		// No sync  		if ((tmpFrameHeader [1] >> 5) != 0x07 || ((tmpFrameHeader [1] >> 1) & 0x03) == 0)// 2/18/05 - ignore reserved layer  		 {  			stream.Seek (-3' SeekOrigin.Current);  		} else if (tmpFrameHeader [1] == 0xFF || ((tmpFrameHeader [1] >> 3) & 0x03) == 1)// 2/19/05 - more bad data  		 {  			stream.Seek (-3' SeekOrigin.Current);  		} else {  			int tmpMpegID = (tmpFrameHeader [1] >> 3) & 0x03;  			int tmpLayerNum = (tmpFrameHeader [1] >> 1) & 0x03;  			int tmpFrequency = GetFrequency ((MpegVersion)tmpMpegID' (tmpFrameHeader [2] >> 2) & 0x03);  			// Check for invalid frequency  			if (tmpFrequency == 0) {  				stream.Seek (-3' SeekOrigin.Current);  				continue;  			}  			int tmpSamplesPerFrame = GetSamplesPerFrame ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum);  			int tmpUsesPadding = (tmpFrameHeader [2] >> 1) & 0x01;  			double tmpFrameSizeConst = 125.0 * tmpSamplesPerFrame / tmpFrequency;  			int tmpPaddingSize = (tmpLayerNum == 3 ? 4 : 1);  			int tmpBitrateIndex = tmpFrameHeader [2] >> 4;  			// Check for invalid values  			if (tmpBitrateIndex < 1 || tmpBitrateIndex > 14 || tmpLayerNum == 0) {  				stream.Seek (-3' SeekOrigin.Current);  				continue;  			}  			int tmpFrameBitrate = GetBitrate ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum' tmpBitrateIndex);  			int tmpFrameSize = (int)(tmpFrameBitrate * tmpFrameSizeConst) + (tmpUsesPadding * tmpPaddingSize);  			_headerOffset = stream.Position - 4;  			if (tmpFrameSize < 8) {  				stream.Seek (-3' SeekOrigin.Current);  				continue;  			}  			// 7/21/05 - Check for 0x00 or 0xFF at end of last frame  			// this sucks for tracks that start with silence  			if (_headerOffset >= 1 && !acceptNullSamples)// if (ftell(fp) >= 5)  			 {  				stream.Seek (-5' SeekOrigin.Current);  				byte tmpLastByte = stream.Read1 ();  				stream.Seek (4' SeekOrigin.Current);  				if (tmpFrameBitrate != 320 && (tmpLastByte == 0x00 || tmpLastByte == 0xFF)) {  					// 7/31/05  					// may be a valid frame - skip its contents to prevent false sync  					long tmpNewPosition = _headerOffset + tmpFrameSize;  					if (tmpFrameSize == 0)  						tmpNewPosition++;  					stream.Seek (tmpNewPosition' SeekOrigin.Begin);  					continue;  				}  			}  			/*if (BR == 0 || FrameSizeConst == 0)                         {                             startpos = HeaderOffset+1;                             fseek(fp' startpos' SEEK_SET);                             continue;                         }*/stream.Seek (_headerOffset + tmpFrameSize' SeekOrigin.Begin);  			if (stream.Read1 () == 0xFF) {  				fh1 = stream.Read1 ();  				fh2 = stream.Read1 ();  				if (tmpFrameHeader [1] == fh1 && (tmpFrameHeader [2] & 0x0D) == (fh2 & 0x0D)) {  					// header found  					break;  				}  			}  			stream.Seek (_headerOffset + 1' SeekOrigin.Begin);  			continue;  		}  	}  	_mpegVersion = (MpegVersion)((tmpFrameHeader [1] >> 3) & 0x03);  	_mpegLayer = (MpegLayer)((tmpFrameHeader [1] >> 1) & 0x03);  	_frequency = GetFrequency (_mpegVersion' (tmpFrameHeader [2] >> 2) & 0x03);  	if (_frequency == 0) {  		throw new InvalidDataException (String.Format ("'{0}'; cannot determine frequency"' path));  	}  	_isPrivate = ((tmpFrameHeader [2] & 0x01) == 0x01);  	_samplesPerFrame = GetSamplesPerFrame (_mpegVersion' _mpegLayer);  	_frameSizeConst = 125.0 * _samplesPerFrame / _frequency;  	_paddingSizeConst = (_mpegLayer == MpegLayer.Layer1 ? 4 : 1);  	_isCopyright = (((tmpFrameHeader [3] >> 3) & 0x01) == 0x01);  	_isOriginal = (((tmpFrameHeader [3] >> 2) & 0x01) == 0x01);  	//tmpModeExtension = (FH[3] >> 4) & 0x03; // not interested' only used in joint-stereo  	//_mpegEmphasis = (MpegEmphasis)(tmpFrameHeader[3] & 0x03);  	if ((tmpFrameHeader [3] >> 6) == 3)  		_channels = 1;  	// Single Channel  	else  		_channels = 2;  	// Read LAME Info Tag  	bool tmpHasLameInfoTag = false;  	stream.Seek (tmpID3v2TagSize + 36' SeekOrigin.Begin);  	Byte[] buf = stream.Read (4);  	if (ByteUtils.Compare (buf' INFO_MARKER))// CBR  	 {  		tmpHasLameInfoTag = true;  		_isVBR = false;  	} else if (ByteUtils.Compare (buf' XING_MARKER))// VBR  	 {  		tmpHasLameInfoTag = true;  		_isVBR = true;  	}  	if (tmpHasLameInfoTag) {  		stream.Seek (4' SeekOrigin.Current);  		int tmpFrames = stream.ReadInt32 ();  		uint tmpBytes = (uint)stream.ReadInt32 ();  		if (tmpFrames > 256 && tmpBytes > 50000) {  			decimal tmpBitrate = tmpBytes / 125.0m / (tmpFrames * _samplesPerFrame / (decimal)_frequency);  			if (tmpBitrate <= 320 && tmpBitrate >= 32) {  				_frames = tmpFrames;  				_bitrate = tmpBitrate;  				_totalSeconds = (tmpBytes / 125.0m) / _bitrate;  			}  		}  	}  	// TODO: Take these 2 lines out  	/*fs.Position = 0;                 CalculateBitrate(fs' null);*/if (calculateBitrate) {  		if (_bitrate == 0 || _isVBR == null || _frames == 0 || _totalSeconds == 0) {  			stream.Position = 0;  			CalculateBitrate (stream' null);  		}  	}  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: using (FileStream stream = File.Open (path' FileMode.Open' FileAccess.Read' FileShare.Read)) {  	int tmpID3v2TagSize = ID3v2.GetTagSize (stream);  	stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  	byte[] tmpFrameHeader = new byte[4];  	bool acceptNullSamples = false;  	while (true) {  		int tmpByte = stream.ReadByte ();  		// keep as ReadByte  		while (tmpByte != 0xFF && tmpByte != -1) {  			tmpByte = stream.ReadByte ();  			// keep as ReadByte  		}  		if (tmpByte == -1) {  			if (acceptNullSamples) {  				throw new InvalidDataException (string.Format ("'{0}': Can't find frame sync"' path));  			}  			stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  			acceptNullSamples = true;  			continue;  		}  		tmpFrameHeader [0] = (byte)tmpByte;  		// Get frame header  		if (stream.Read (tmpFrameHeader' 1' 3) != 3) {  			throw new InvalidDataException (string.Format ("'{0}': Invalid MPEG file; end of stream reached"' path));  		}  		// No sync  		if ((tmpFrameHeader [1] >> 5) != 0x07 || ((tmpFrameHeader [1] >> 1) & 0x03) == 0)// 2/18/05 - ignore reserved layer  		 {  			stream.Seek (-3' SeekOrigin.Current);  		} else if (tmpFrameHeader [1] == 0xFF || ((tmpFrameHeader [1] >> 3) & 0x03) == 1)// 2/19/05 - more bad data  		 {  			stream.Seek (-3' SeekOrigin.Current);  		} else {  			int tmpMpegID = (tmpFrameHeader [1] >> 3) & 0x03;  			int tmpLayerNum = (tmpFrameHeader [1] >> 1) & 0x03;  			int tmpFrequency = GetFrequency ((MpegVersion)tmpMpegID' (tmpFrameHeader [2] >> 2) & 0x03);  			// Check for invalid frequency  			if (tmpFrequency == 0) {  				stream.Seek (-3' SeekOrigin.Current);  				continue;  			}  			int tmpSamplesPerFrame = GetSamplesPerFrame ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum);  			int tmpUsesPadding = (tmpFrameHeader [2] >> 1) & 0x01;  			double tmpFrameSizeConst = 125.0 * tmpSamplesPerFrame / tmpFrequency;  			int tmpPaddingSize = (tmpLayerNum == 3 ? 4 : 1);  			int tmpBitrateIndex = tmpFrameHeader [2] >> 4;  			// Check for invalid values  			if (tmpBitrateIndex < 1 || tmpBitrateIndex > 14 || tmpLayerNum == 0) {  				stream.Seek (-3' SeekOrigin.Current);  				continue;  			}  			int tmpFrameBitrate = GetBitrate ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum' tmpBitrateIndex);  			int tmpFrameSize = (int)(tmpFrameBitrate * tmpFrameSizeConst) + (tmpUsesPadding * tmpPaddingSize);  			_headerOffset = stream.Position - 4;  			if (tmpFrameSize < 8) {  				stream.Seek (-3' SeekOrigin.Current);  				continue;  			}  			// 7/21/05 - Check for 0x00 or 0xFF at end of last frame  			// this sucks for tracks that start with silence  			if (_headerOffset >= 1 && !acceptNullSamples)// if (ftell(fp) >= 5)  			 {  				stream.Seek (-5' SeekOrigin.Current);  				byte tmpLastByte = stream.Read1 ();  				stream.Seek (4' SeekOrigin.Current);  				if (tmpFrameBitrate != 320 && (tmpLastByte == 0x00 || tmpLastByte == 0xFF)) {  					// 7/31/05  					// may be a valid frame - skip its contents to prevent false sync  					long tmpNewPosition = _headerOffset + tmpFrameSize;  					if (tmpFrameSize == 0)  						tmpNewPosition++;  					stream.Seek (tmpNewPosition' SeekOrigin.Begin);  					continue;  				}  			}  			/*if (BR == 0 || FrameSizeConst == 0)                         {                             startpos = HeaderOffset+1;                             fseek(fp' startpos' SEEK_SET);                             continue;                         }*/stream.Seek (_headerOffset + tmpFrameSize' SeekOrigin.Begin);  			if (stream.Read1 () == 0xFF) {  				fh1 = stream.Read1 ();  				fh2 = stream.Read1 ();  				if (tmpFrameHeader [1] == fh1 && (tmpFrameHeader [2] & 0x0D) == (fh2 & 0x0D)) {  					// header found  					break;  				}  			}  			stream.Seek (_headerOffset + 1' SeekOrigin.Begin);  			continue;  		}  	}  	_mpegVersion = (MpegVersion)((tmpFrameHeader [1] >> 3) & 0x03);  	_mpegLayer = (MpegLayer)((tmpFrameHeader [1] >> 1) & 0x03);  	_frequency = GetFrequency (_mpegVersion' (tmpFrameHeader [2] >> 2) & 0x03);  	if (_frequency == 0) {  		throw new InvalidDataException (String.Format ("'{0}'; cannot determine frequency"' path));  	}  	_isPrivate = ((tmpFrameHeader [2] & 0x01) == 0x01);  	_samplesPerFrame = GetSamplesPerFrame (_mpegVersion' _mpegLayer);  	_frameSizeConst = 125.0 * _samplesPerFrame / _frequency;  	_paddingSizeConst = (_mpegLayer == MpegLayer.Layer1 ? 4 : 1);  	_isCopyright = (((tmpFrameHeader [3] >> 3) & 0x01) == 0x01);  	_isOriginal = (((tmpFrameHeader [3] >> 2) & 0x01) == 0x01);  	//tmpModeExtension = (FH[3] >> 4) & 0x03; // not interested' only used in joint-stereo  	//_mpegEmphasis = (MpegEmphasis)(tmpFrameHeader[3] & 0x03);  	if ((tmpFrameHeader [3] >> 6) == 3)  		_channels = 1;  	// Single Channel  	else  		_channels = 2;  	// Read LAME Info Tag  	bool tmpHasLameInfoTag = false;  	stream.Seek (tmpID3v2TagSize + 36' SeekOrigin.Begin);  	Byte[] buf = stream.Read (4);  	if (ByteUtils.Compare (buf' INFO_MARKER))// CBR  	 {  		tmpHasLameInfoTag = true;  		_isVBR = false;  	} else if (ByteUtils.Compare (buf' XING_MARKER))// VBR  	 {  		tmpHasLameInfoTag = true;  		_isVBR = true;  	}  	if (tmpHasLameInfoTag) {  		stream.Seek (4' SeekOrigin.Current);  		int tmpFrames = stream.ReadInt32 ();  		uint tmpBytes = (uint)stream.ReadInt32 ();  		if (tmpFrames > 256 && tmpBytes > 50000) {  			decimal tmpBitrate = tmpBytes / 125.0m / (tmpFrames * _samplesPerFrame / (decimal)_frequency);  			if (tmpBitrate <= 320 && tmpBitrate >= 32) {  				_frames = tmpFrames;  				_bitrate = tmpBitrate;  				_totalSeconds = (tmpBytes / 125.0m) / _bitrate;  			}  		}  	}  	// TODO: Take these 2 lines out  	/*fs.Position = 0;                 CalculateBitrate(fs' null);*/if (calculateBitrate) {  		if (_bitrate == 0 || _isVBR == null || _frames == 0 || _totalSeconds == 0) {  			stream.Position = 0;  			CalculateBitrate (stream' null);  		}  	}  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: using (FileStream stream = File.Open (path' FileMode.Open' FileAccess.Read' FileShare.Read)) {  	int tmpID3v2TagSize = ID3v2.GetTagSize (stream);  	stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  	byte[] tmpFrameHeader = new byte[4];  	bool acceptNullSamples = false;  	while (true) {  		int tmpByte = stream.ReadByte ();  		// keep as ReadByte  		while (tmpByte != 0xFF && tmpByte != -1) {  			tmpByte = stream.ReadByte ();  			// keep as ReadByte  		}  		if (tmpByte == -1) {  			if (acceptNullSamples) {  				throw new InvalidDataException (string.Format ("'{0}': Can't find frame sync"' path));  			}  			stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  			acceptNullSamples = true;  			continue;  		}  		tmpFrameHeader [0] = (byte)tmpByte;  		// Get frame header  		if (stream.Read (tmpFrameHeader' 1' 3) != 3) {  			throw new InvalidDataException (string.Format ("'{0}': Invalid MPEG file; end of stream reached"' path));  		}  		// No sync  		if ((tmpFrameHeader [1] >> 5) != 0x07 || ((tmpFrameHeader [1] >> 1) & 0x03) == 0)// 2/18/05 - ignore reserved layer  		 {  			stream.Seek (-3' SeekOrigin.Current);  		} else if (tmpFrameHeader [1] == 0xFF || ((tmpFrameHeader [1] >> 3) & 0x03) == 1)// 2/19/05 - more bad data  		 {  			stream.Seek (-3' SeekOrigin.Current);  		} else {  			int tmpMpegID = (tmpFrameHeader [1] >> 3) & 0x03;  			int tmpLayerNum = (tmpFrameHeader [1] >> 1) & 0x03;  			int tmpFrequency = GetFrequency ((MpegVersion)tmpMpegID' (tmpFrameHeader [2] >> 2) & 0x03);  			// Check for invalid frequency  			if (tmpFrequency == 0) {  				stream.Seek (-3' SeekOrigin.Current);  				continue;  			}  			int tmpSamplesPerFrame = GetSamplesPerFrame ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum);  			int tmpUsesPadding = (tmpFrameHeader [2] >> 1) & 0x01;  			double tmpFrameSizeConst = 125.0 * tmpSamplesPerFrame / tmpFrequency;  			int tmpPaddingSize = (tmpLayerNum == 3 ? 4 : 1);  			int tmpBitrateIndex = tmpFrameHeader [2] >> 4;  			// Check for invalid values  			if (tmpBitrateIndex < 1 || tmpBitrateIndex > 14 || tmpLayerNum == 0) {  				stream.Seek (-3' SeekOrigin.Current);  				continue;  			}  			int tmpFrameBitrate = GetBitrate ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum' tmpBitrateIndex);  			int tmpFrameSize = (int)(tmpFrameBitrate * tmpFrameSizeConst) + (tmpUsesPadding * tmpPaddingSize);  			_headerOffset = stream.Position - 4;  			if (tmpFrameSize < 8) {  				stream.Seek (-3' SeekOrigin.Current);  				continue;  			}  			// 7/21/05 - Check for 0x00 or 0xFF at end of last frame  			// this sucks for tracks that start with silence  			if (_headerOffset >= 1 && !acceptNullSamples)// if (ftell(fp) >= 5)  			 {  				stream.Seek (-5' SeekOrigin.Current);  				byte tmpLastByte = stream.Read1 ();  				stream.Seek (4' SeekOrigin.Current);  				if (tmpFrameBitrate != 320 && (tmpLastByte == 0x00 || tmpLastByte == 0xFF)) {  					// 7/31/05  					// may be a valid frame - skip its contents to prevent false sync  					long tmpNewPosition = _headerOffset + tmpFrameSize;  					if (tmpFrameSize == 0)  						tmpNewPosition++;  					stream.Seek (tmpNewPosition' SeekOrigin.Begin);  					continue;  				}  			}  			/*if (BR == 0 || FrameSizeConst == 0)                         {                             startpos = HeaderOffset+1;                             fseek(fp' startpos' SEEK_SET);                             continue;                         }*/stream.Seek (_headerOffset + tmpFrameSize' SeekOrigin.Begin);  			if (stream.Read1 () == 0xFF) {  				fh1 = stream.Read1 ();  				fh2 = stream.Read1 ();  				if (tmpFrameHeader [1] == fh1 && (tmpFrameHeader [2] & 0x0D) == (fh2 & 0x0D)) {  					// header found  					break;  				}  			}  			stream.Seek (_headerOffset + 1' SeekOrigin.Begin);  			continue;  		}  	}  	_mpegVersion = (MpegVersion)((tmpFrameHeader [1] >> 3) & 0x03);  	_mpegLayer = (MpegLayer)((tmpFrameHeader [1] >> 1) & 0x03);  	_frequency = GetFrequency (_mpegVersion' (tmpFrameHeader [2] >> 2) & 0x03);  	if (_frequency == 0) {  		throw new InvalidDataException (String.Format ("'{0}'; cannot determine frequency"' path));  	}  	_isPrivate = ((tmpFrameHeader [2] & 0x01) == 0x01);  	_samplesPerFrame = GetSamplesPerFrame (_mpegVersion' _mpegLayer);  	_frameSizeConst = 125.0 * _samplesPerFrame / _frequency;  	_paddingSizeConst = (_mpegLayer == MpegLayer.Layer1 ? 4 : 1);  	_isCopyright = (((tmpFrameHeader [3] >> 3) & 0x01) == 0x01);  	_isOriginal = (((tmpFrameHeader [3] >> 2) & 0x01) == 0x01);  	//tmpModeExtension = (FH[3] >> 4) & 0x03; // not interested' only used in joint-stereo  	//_mpegEmphasis = (MpegEmphasis)(tmpFrameHeader[3] & 0x03);  	if ((tmpFrameHeader [3] >> 6) == 3)  		_channels = 1;  	// Single Channel  	else  		_channels = 2;  	// Read LAME Info Tag  	bool tmpHasLameInfoTag = false;  	stream.Seek (tmpID3v2TagSize + 36' SeekOrigin.Begin);  	Byte[] buf = stream.Read (4);  	if (ByteUtils.Compare (buf' INFO_MARKER))// CBR  	 {  		tmpHasLameInfoTag = true;  		_isVBR = false;  	} else if (ByteUtils.Compare (buf' XING_MARKER))// VBR  	 {  		tmpHasLameInfoTag = true;  		_isVBR = true;  	}  	if (tmpHasLameInfoTag) {  		stream.Seek (4' SeekOrigin.Current);  		int tmpFrames = stream.ReadInt32 ();  		uint tmpBytes = (uint)stream.ReadInt32 ();  		if (tmpFrames > 256 && tmpBytes > 50000) {  			decimal tmpBitrate = tmpBytes / 125.0m / (tmpFrames * _samplesPerFrame / (decimal)_frequency);  			if (tmpBitrate <= 320 && tmpBitrate >= 32) {  				_frames = tmpFrames;  				_bitrate = tmpBitrate;  				_totalSeconds = (tmpBytes / 125.0m) / _bitrate;  			}  		}  	}  	// TODO: Take these 2 lines out  	/*fs.Position = 0;                 CalculateBitrate(fs' null);*/if (calculateBitrate) {  		if (_bitrate == 0 || _isVBR == null || _frames == 0 || _totalSeconds == 0) {  			stream.Position = 0;  			CalculateBitrate (stream' null);  		}  	}  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: using (FileStream stream = File.Open (path' FileMode.Open' FileAccess.Read' FileShare.Read)) {  	int tmpID3v2TagSize = ID3v2.GetTagSize (stream);  	stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  	byte[] tmpFrameHeader = new byte[4];  	bool acceptNullSamples = false;  	while (true) {  		int tmpByte = stream.ReadByte ();  		// keep as ReadByte  		while (tmpByte != 0xFF && tmpByte != -1) {  			tmpByte = stream.ReadByte ();  			// keep as ReadByte  		}  		if (tmpByte == -1) {  			if (acceptNullSamples) {  				throw new InvalidDataException (string.Format ("'{0}': Can't find frame sync"' path));  			}  			stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  			acceptNullSamples = true;  			continue;  		}  		tmpFrameHeader [0] = (byte)tmpByte;  		// Get frame header  		if (stream.Read (tmpFrameHeader' 1' 3) != 3) {  			throw new InvalidDataException (string.Format ("'{0}': Invalid MPEG file; end of stream reached"' path));  		}  		// No sync  		if ((tmpFrameHeader [1] >> 5) != 0x07 || ((tmpFrameHeader [1] >> 1) & 0x03) == 0)// 2/18/05 - ignore reserved layer  		 {  			stream.Seek (-3' SeekOrigin.Current);  		} else if (tmpFrameHeader [1] == 0xFF || ((tmpFrameHeader [1] >> 3) & 0x03) == 1)// 2/19/05 - more bad data  		 {  			stream.Seek (-3' SeekOrigin.Current);  		} else {  			int tmpMpegID = (tmpFrameHeader [1] >> 3) & 0x03;  			int tmpLayerNum = (tmpFrameHeader [1] >> 1) & 0x03;  			int tmpFrequency = GetFrequency ((MpegVersion)tmpMpegID' (tmpFrameHeader [2] >> 2) & 0x03);  			// Check for invalid frequency  			if (tmpFrequency == 0) {  				stream.Seek (-3' SeekOrigin.Current);  				continue;  			}  			int tmpSamplesPerFrame = GetSamplesPerFrame ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum);  			int tmpUsesPadding = (tmpFrameHeader [2] >> 1) & 0x01;  			double tmpFrameSizeConst = 125.0 * tmpSamplesPerFrame / tmpFrequency;  			int tmpPaddingSize = (tmpLayerNum == 3 ? 4 : 1);  			int tmpBitrateIndex = tmpFrameHeader [2] >> 4;  			// Check for invalid values  			if (tmpBitrateIndex < 1 || tmpBitrateIndex > 14 || tmpLayerNum == 0) {  				stream.Seek (-3' SeekOrigin.Current);  				continue;  			}  			int tmpFrameBitrate = GetBitrate ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum' tmpBitrateIndex);  			int tmpFrameSize = (int)(tmpFrameBitrate * tmpFrameSizeConst) + (tmpUsesPadding * tmpPaddingSize);  			_headerOffset = stream.Position - 4;  			if (tmpFrameSize < 8) {  				stream.Seek (-3' SeekOrigin.Current);  				continue;  			}  			// 7/21/05 - Check for 0x00 or 0xFF at end of last frame  			// this sucks for tracks that start with silence  			if (_headerOffset >= 1 && !acceptNullSamples)// if (ftell(fp) >= 5)  			 {  				stream.Seek (-5' SeekOrigin.Current);  				byte tmpLastByte = stream.Read1 ();  				stream.Seek (4' SeekOrigin.Current);  				if (tmpFrameBitrate != 320 && (tmpLastByte == 0x00 || tmpLastByte == 0xFF)) {  					// 7/31/05  					// may be a valid frame - skip its contents to prevent false sync  					long tmpNewPosition = _headerOffset + tmpFrameSize;  					if (tmpFrameSize == 0)  						tmpNewPosition++;  					stream.Seek (tmpNewPosition' SeekOrigin.Begin);  					continue;  				}  			}  			/*if (BR == 0 || FrameSizeConst == 0)                         {                             startpos = HeaderOffset+1;                             fseek(fp' startpos' SEEK_SET);                             continue;                         }*/stream.Seek (_headerOffset + tmpFrameSize' SeekOrigin.Begin);  			if (stream.Read1 () == 0xFF) {  				fh1 = stream.Read1 ();  				fh2 = stream.Read1 ();  				if (tmpFrameHeader [1] == fh1 && (tmpFrameHeader [2] & 0x0D) == (fh2 & 0x0D)) {  					// header found  					break;  				}  			}  			stream.Seek (_headerOffset + 1' SeekOrigin.Begin);  			continue;  		}  	}  	_mpegVersion = (MpegVersion)((tmpFrameHeader [1] >> 3) & 0x03);  	_mpegLayer = (MpegLayer)((tmpFrameHeader [1] >> 1) & 0x03);  	_frequency = GetFrequency (_mpegVersion' (tmpFrameHeader [2] >> 2) & 0x03);  	if (_frequency == 0) {  		throw new InvalidDataException (String.Format ("'{0}'; cannot determine frequency"' path));  	}  	_isPrivate = ((tmpFrameHeader [2] & 0x01) == 0x01);  	_samplesPerFrame = GetSamplesPerFrame (_mpegVersion' _mpegLayer);  	_frameSizeConst = 125.0 * _samplesPerFrame / _frequency;  	_paddingSizeConst = (_mpegLayer == MpegLayer.Layer1 ? 4 : 1);  	_isCopyright = (((tmpFrameHeader [3] >> 3) & 0x01) == 0x01);  	_isOriginal = (((tmpFrameHeader [3] >> 2) & 0x01) == 0x01);  	//tmpModeExtension = (FH[3] >> 4) & 0x03; // not interested' only used in joint-stereo  	//_mpegEmphasis = (MpegEmphasis)(tmpFrameHeader[3] & 0x03);  	if ((tmpFrameHeader [3] >> 6) == 3)  		_channels = 1;  	// Single Channel  	else  		_channels = 2;  	// Read LAME Info Tag  	bool tmpHasLameInfoTag = false;  	stream.Seek (tmpID3v2TagSize + 36' SeekOrigin.Begin);  	Byte[] buf = stream.Read (4);  	if (ByteUtils.Compare (buf' INFO_MARKER))// CBR  	 {  		tmpHasLameInfoTag = true;  		_isVBR = false;  	} else if (ByteUtils.Compare (buf' XING_MARKER))// VBR  	 {  		tmpHasLameInfoTag = true;  		_isVBR = true;  	}  	if (tmpHasLameInfoTag) {  		stream.Seek (4' SeekOrigin.Current);  		int tmpFrames = stream.ReadInt32 ();  		uint tmpBytes = (uint)stream.ReadInt32 ();  		if (tmpFrames > 256 && tmpBytes > 50000) {  			decimal tmpBitrate = tmpBytes / 125.0m / (tmpFrames * _samplesPerFrame / (decimal)_frequency);  			if (tmpBitrate <= 320 && tmpBitrate >= 32) {  				_frames = tmpFrames;  				_bitrate = tmpBitrate;  				_totalSeconds = (tmpBytes / 125.0m) / _bitrate;  			}  		}  	}  	// TODO: Take these 2 lines out  	/*fs.Position = 0;                 CalculateBitrate(fs' null);*/if (calculateBitrate) {  		if (_bitrate == 0 || _isVBR == null || _frames == 0 || _totalSeconds == 0) {  			stream.Position = 0;  			CalculateBitrate (stream' null);  		}  	}  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: using (FileStream stream = File.Open (path' FileMode.Open' FileAccess.Read' FileShare.Read)) {  	int tmpID3v2TagSize = ID3v2.GetTagSize (stream);  	stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  	byte[] tmpFrameHeader = new byte[4];  	bool acceptNullSamples = false;  	while (true) {  		int tmpByte = stream.ReadByte ();  		// keep as ReadByte  		while (tmpByte != 0xFF && tmpByte != -1) {  			tmpByte = stream.ReadByte ();  			// keep as ReadByte  		}  		if (tmpByte == -1) {  			if (acceptNullSamples) {  				throw new InvalidDataException (string.Format ("'{0}': Can't find frame sync"' path));  			}  			stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  			acceptNullSamples = true;  			continue;  		}  		tmpFrameHeader [0] = (byte)tmpByte;  		// Get frame header  		if (stream.Read (tmpFrameHeader' 1' 3) != 3) {  			throw new InvalidDataException (string.Format ("'{0}': Invalid MPEG file; end of stream reached"' path));  		}  		// No sync  		if ((tmpFrameHeader [1] >> 5) != 0x07 || ((tmpFrameHeader [1] >> 1) & 0x03) == 0)// 2/18/05 - ignore reserved layer  		 {  			stream.Seek (-3' SeekOrigin.Current);  		} else if (tmpFrameHeader [1] == 0xFF || ((tmpFrameHeader [1] >> 3) & 0x03) == 1)// 2/19/05 - more bad data  		 {  			stream.Seek (-3' SeekOrigin.Current);  		} else {  			int tmpMpegID = (tmpFrameHeader [1] >> 3) & 0x03;  			int tmpLayerNum = (tmpFrameHeader [1] >> 1) & 0x03;  			int tmpFrequency = GetFrequency ((MpegVersion)tmpMpegID' (tmpFrameHeader [2] >> 2) & 0x03);  			// Check for invalid frequency  			if (tmpFrequency == 0) {  				stream.Seek (-3' SeekOrigin.Current);  				continue;  			}  			int tmpSamplesPerFrame = GetSamplesPerFrame ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum);  			int tmpUsesPadding = (tmpFrameHeader [2] >> 1) & 0x01;  			double tmpFrameSizeConst = 125.0 * tmpSamplesPerFrame / tmpFrequency;  			int tmpPaddingSize = (tmpLayerNum == 3 ? 4 : 1);  			int tmpBitrateIndex = tmpFrameHeader [2] >> 4;  			// Check for invalid values  			if (tmpBitrateIndex < 1 || tmpBitrateIndex > 14 || tmpLayerNum == 0) {  				stream.Seek (-3' SeekOrigin.Current);  				continue;  			}  			int tmpFrameBitrate = GetBitrate ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum' tmpBitrateIndex);  			int tmpFrameSize = (int)(tmpFrameBitrate * tmpFrameSizeConst) + (tmpUsesPadding * tmpPaddingSize);  			_headerOffset = stream.Position - 4;  			if (tmpFrameSize < 8) {  				stream.Seek (-3' SeekOrigin.Current);  				continue;  			}  			// 7/21/05 - Check for 0x00 or 0xFF at end of last frame  			// this sucks for tracks that start with silence  			if (_headerOffset >= 1 && !acceptNullSamples)// if (ftell(fp) >= 5)  			 {  				stream.Seek (-5' SeekOrigin.Current);  				byte tmpLastByte = stream.Read1 ();  				stream.Seek (4' SeekOrigin.Current);  				if (tmpFrameBitrate != 320 && (tmpLastByte == 0x00 || tmpLastByte == 0xFF)) {  					// 7/31/05  					// may be a valid frame - skip its contents to prevent false sync  					long tmpNewPosition = _headerOffset + tmpFrameSize;  					if (tmpFrameSize == 0)  						tmpNewPosition++;  					stream.Seek (tmpNewPosition' SeekOrigin.Begin);  					continue;  				}  			}  			/*if (BR == 0 || FrameSizeConst == 0)                         {                             startpos = HeaderOffset+1;                             fseek(fp' startpos' SEEK_SET);                             continue;                         }*/stream.Seek (_headerOffset + tmpFrameSize' SeekOrigin.Begin);  			if (stream.Read1 () == 0xFF) {  				fh1 = stream.Read1 ();  				fh2 = stream.Read1 ();  				if (tmpFrameHeader [1] == fh1 && (tmpFrameHeader [2] & 0x0D) == (fh2 & 0x0D)) {  					// header found  					break;  				}  			}  			stream.Seek (_headerOffset + 1' SeekOrigin.Begin);  			continue;  		}  	}  	_mpegVersion = (MpegVersion)((tmpFrameHeader [1] >> 3) & 0x03);  	_mpegLayer = (MpegLayer)((tmpFrameHeader [1] >> 1) & 0x03);  	_frequency = GetFrequency (_mpegVersion' (tmpFrameHeader [2] >> 2) & 0x03);  	if (_frequency == 0) {  		throw new InvalidDataException (String.Format ("'{0}'; cannot determine frequency"' path));  	}  	_isPrivate = ((tmpFrameHeader [2] & 0x01) == 0x01);  	_samplesPerFrame = GetSamplesPerFrame (_mpegVersion' _mpegLayer);  	_frameSizeConst = 125.0 * _samplesPerFrame / _frequency;  	_paddingSizeConst = (_mpegLayer == MpegLayer.Layer1 ? 4 : 1);  	_isCopyright = (((tmpFrameHeader [3] >> 3) & 0x01) == 0x01);  	_isOriginal = (((tmpFrameHeader [3] >> 2) & 0x01) == 0x01);  	//tmpModeExtension = (FH[3] >> 4) & 0x03; // not interested' only used in joint-stereo  	//_mpegEmphasis = (MpegEmphasis)(tmpFrameHeader[3] & 0x03);  	if ((tmpFrameHeader [3] >> 6) == 3)  		_channels = 1;  	// Single Channel  	else  		_channels = 2;  	// Read LAME Info Tag  	bool tmpHasLameInfoTag = false;  	stream.Seek (tmpID3v2TagSize + 36' SeekOrigin.Begin);  	Byte[] buf = stream.Read (4);  	if (ByteUtils.Compare (buf' INFO_MARKER))// CBR  	 {  		tmpHasLameInfoTag = true;  		_isVBR = false;  	} else if (ByteUtils.Compare (buf' XING_MARKER))// VBR  	 {  		tmpHasLameInfoTag = true;  		_isVBR = true;  	}  	if (tmpHasLameInfoTag) {  		stream.Seek (4' SeekOrigin.Current);  		int tmpFrames = stream.ReadInt32 ();  		uint tmpBytes = (uint)stream.ReadInt32 ();  		if (tmpFrames > 256 && tmpBytes > 50000) {  			decimal tmpBitrate = tmpBytes / 125.0m / (tmpFrames * _samplesPerFrame / (decimal)_frequency);  			if (tmpBitrate <= 320 && tmpBitrate >= 32) {  				_frames = tmpFrames;  				_bitrate = tmpBitrate;  				_totalSeconds = (tmpBytes / 125.0m) / _bitrate;  			}  		}  	}  	// TODO: Take these 2 lines out  	/*fs.Position = 0;                 CalculateBitrate(fs' null);*/if (calculateBitrate) {  		if (_bitrate == 0 || _isVBR == null || _frames == 0 || _totalSeconds == 0) {  			stream.Position = 0;  			CalculateBitrate (stream' null);  		}  	}  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: using (FileStream stream = File.Open (path' FileMode.Open' FileAccess.Read' FileShare.Read)) {  	int tmpID3v2TagSize = ID3v2.GetTagSize (stream);  	stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  	byte[] tmpFrameHeader = new byte[4];  	bool acceptNullSamples = false;  	while (true) {  		int tmpByte = stream.ReadByte ();  		// keep as ReadByte  		while (tmpByte != 0xFF && tmpByte != -1) {  			tmpByte = stream.ReadByte ();  			// keep as ReadByte  		}  		if (tmpByte == -1) {  			if (acceptNullSamples) {  				throw new InvalidDataException (string.Format ("'{0}': Can't find frame sync"' path));  			}  			stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  			acceptNullSamples = true;  			continue;  		}  		tmpFrameHeader [0] = (byte)tmpByte;  		// Get frame header  		if (stream.Read (tmpFrameHeader' 1' 3) != 3) {  			throw new InvalidDataException (string.Format ("'{0}': Invalid MPEG file; end of stream reached"' path));  		}  		// No sync  		if ((tmpFrameHeader [1] >> 5) != 0x07 || ((tmpFrameHeader [1] >> 1) & 0x03) == 0)// 2/18/05 - ignore reserved layer  		 {  			stream.Seek (-3' SeekOrigin.Current);  		} else if (tmpFrameHeader [1] == 0xFF || ((tmpFrameHeader [1] >> 3) & 0x03) == 1)// 2/19/05 - more bad data  		 {  			stream.Seek (-3' SeekOrigin.Current);  		} else {  			int tmpMpegID = (tmpFrameHeader [1] >> 3) & 0x03;  			int tmpLayerNum = (tmpFrameHeader [1] >> 1) & 0x03;  			int tmpFrequency = GetFrequency ((MpegVersion)tmpMpegID' (tmpFrameHeader [2] >> 2) & 0x03);  			// Check for invalid frequency  			if (tmpFrequency == 0) {  				stream.Seek (-3' SeekOrigin.Current);  				continue;  			}  			int tmpSamplesPerFrame = GetSamplesPerFrame ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum);  			int tmpUsesPadding = (tmpFrameHeader [2] >> 1) & 0x01;  			double tmpFrameSizeConst = 125.0 * tmpSamplesPerFrame / tmpFrequency;  			int tmpPaddingSize = (tmpLayerNum == 3 ? 4 : 1);  			int tmpBitrateIndex = tmpFrameHeader [2] >> 4;  			// Check for invalid values  			if (tmpBitrateIndex < 1 || tmpBitrateIndex > 14 || tmpLayerNum == 0) {  				stream.Seek (-3' SeekOrigin.Current);  				continue;  			}  			int tmpFrameBitrate = GetBitrate ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum' tmpBitrateIndex);  			int tmpFrameSize = (int)(tmpFrameBitrate * tmpFrameSizeConst) + (tmpUsesPadding * tmpPaddingSize);  			_headerOffset = stream.Position - 4;  			if (tmpFrameSize < 8) {  				stream.Seek (-3' SeekOrigin.Current);  				continue;  			}  			// 7/21/05 - Check for 0x00 or 0xFF at end of last frame  			// this sucks for tracks that start with silence  			if (_headerOffset >= 1 && !acceptNullSamples)// if (ftell(fp) >= 5)  			 {  				stream.Seek (-5' SeekOrigin.Current);  				byte tmpLastByte = stream.Read1 ();  				stream.Seek (4' SeekOrigin.Current);  				if (tmpFrameBitrate != 320 && (tmpLastByte == 0x00 || tmpLastByte == 0xFF)) {  					// 7/31/05  					// may be a valid frame - skip its contents to prevent false sync  					long tmpNewPosition = _headerOffset + tmpFrameSize;  					if (tmpFrameSize == 0)  						tmpNewPosition++;  					stream.Seek (tmpNewPosition' SeekOrigin.Begin);  					continue;  				}  			}  			/*if (BR == 0 || FrameSizeConst == 0)                         {                             startpos = HeaderOffset+1;                             fseek(fp' startpos' SEEK_SET);                             continue;                         }*/stream.Seek (_headerOffset + tmpFrameSize' SeekOrigin.Begin);  			if (stream.Read1 () == 0xFF) {  				fh1 = stream.Read1 ();  				fh2 = stream.Read1 ();  				if (tmpFrameHeader [1] == fh1 && (tmpFrameHeader [2] & 0x0D) == (fh2 & 0x0D)) {  					// header found  					break;  				}  			}  			stream.Seek (_headerOffset + 1' SeekOrigin.Begin);  			continue;  		}  	}  	_mpegVersion = (MpegVersion)((tmpFrameHeader [1] >> 3) & 0x03);  	_mpegLayer = (MpegLayer)((tmpFrameHeader [1] >> 1) & 0x03);  	_frequency = GetFrequency (_mpegVersion' (tmpFrameHeader [2] >> 2) & 0x03);  	if (_frequency == 0) {  		throw new InvalidDataException (String.Format ("'{0}'; cannot determine frequency"' path));  	}  	_isPrivate = ((tmpFrameHeader [2] & 0x01) == 0x01);  	_samplesPerFrame = GetSamplesPerFrame (_mpegVersion' _mpegLayer);  	_frameSizeConst = 125.0 * _samplesPerFrame / _frequency;  	_paddingSizeConst = (_mpegLayer == MpegLayer.Layer1 ? 4 : 1);  	_isCopyright = (((tmpFrameHeader [3] >> 3) & 0x01) == 0x01);  	_isOriginal = (((tmpFrameHeader [3] >> 2) & 0x01) == 0x01);  	//tmpModeExtension = (FH[3] >> 4) & 0x03; // not interested' only used in joint-stereo  	//_mpegEmphasis = (MpegEmphasis)(tmpFrameHeader[3] & 0x03);  	if ((tmpFrameHeader [3] >> 6) == 3)  		_channels = 1;  	// Single Channel  	else  		_channels = 2;  	// Read LAME Info Tag  	bool tmpHasLameInfoTag = false;  	stream.Seek (tmpID3v2TagSize + 36' SeekOrigin.Begin);  	Byte[] buf = stream.Read (4);  	if (ByteUtils.Compare (buf' INFO_MARKER))// CBR  	 {  		tmpHasLameInfoTag = true;  		_isVBR = false;  	} else if (ByteUtils.Compare (buf' XING_MARKER))// VBR  	 {  		tmpHasLameInfoTag = true;  		_isVBR = true;  	}  	if (tmpHasLameInfoTag) {  		stream.Seek (4' SeekOrigin.Current);  		int tmpFrames = stream.ReadInt32 ();  		uint tmpBytes = (uint)stream.ReadInt32 ();  		if (tmpFrames > 256 && tmpBytes > 50000) {  			decimal tmpBitrate = tmpBytes / 125.0m / (tmpFrames * _samplesPerFrame / (decimal)_frequency);  			if (tmpBitrate <= 320 && tmpBitrate >= 32) {  				_frames = tmpFrames;  				_bitrate = tmpBitrate;  				_totalSeconds = (tmpBytes / 125.0m) / _bitrate;  			}  		}  	}  	// TODO: Take these 2 lines out  	/*fs.Position = 0;                 CalculateBitrate(fs' null);*/if (calculateBitrate) {  		if (_bitrate == 0 || _isVBR == null || _frames == 0 || _totalSeconds == 0) {  			stream.Position = 0;  			CalculateBitrate (stream' null);  		}  	}  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: using (FileStream stream = File.Open (path' FileMode.Open' FileAccess.Read' FileShare.Read)) {  	int tmpID3v2TagSize = ID3v2.GetTagSize (stream);  	stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  	byte[] tmpFrameHeader = new byte[4];  	bool acceptNullSamples = false;  	while (true) {  		int tmpByte = stream.ReadByte ();  		// keep as ReadByte  		while (tmpByte != 0xFF && tmpByte != -1) {  			tmpByte = stream.ReadByte ();  			// keep as ReadByte  		}  		if (tmpByte == -1) {  			if (acceptNullSamples) {  				throw new InvalidDataException (string.Format ("'{0}': Can't find frame sync"' path));  			}  			stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  			acceptNullSamples = true;  			continue;  		}  		tmpFrameHeader [0] = (byte)tmpByte;  		// Get frame header  		if (stream.Read (tmpFrameHeader' 1' 3) != 3) {  			throw new InvalidDataException (string.Format ("'{0}': Invalid MPEG file; end of stream reached"' path));  		}  		// No sync  		if ((tmpFrameHeader [1] >> 5) != 0x07 || ((tmpFrameHeader [1] >> 1) & 0x03) == 0)// 2/18/05 - ignore reserved layer  		 {  			stream.Seek (-3' SeekOrigin.Current);  		} else if (tmpFrameHeader [1] == 0xFF || ((tmpFrameHeader [1] >> 3) & 0x03) == 1)// 2/19/05 - more bad data  		 {  			stream.Seek (-3' SeekOrigin.Current);  		} else {  			int tmpMpegID = (tmpFrameHeader [1] >> 3) & 0x03;  			int tmpLayerNum = (tmpFrameHeader [1] >> 1) & 0x03;  			int tmpFrequency = GetFrequency ((MpegVersion)tmpMpegID' (tmpFrameHeader [2] >> 2) & 0x03);  			// Check for invalid frequency  			if (tmpFrequency == 0) {  				stream.Seek (-3' SeekOrigin.Current);  				continue;  			}  			int tmpSamplesPerFrame = GetSamplesPerFrame ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum);  			int tmpUsesPadding = (tmpFrameHeader [2] >> 1) & 0x01;  			double tmpFrameSizeConst = 125.0 * tmpSamplesPerFrame / tmpFrequency;  			int tmpPaddingSize = (tmpLayerNum == 3 ? 4 : 1);  			int tmpBitrateIndex = tmpFrameHeader [2] >> 4;  			// Check for invalid values  			if (tmpBitrateIndex < 1 || tmpBitrateIndex > 14 || tmpLayerNum == 0) {  				stream.Seek (-3' SeekOrigin.Current);  				continue;  			}  			int tmpFrameBitrate = GetBitrate ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum' tmpBitrateIndex);  			int tmpFrameSize = (int)(tmpFrameBitrate * tmpFrameSizeConst) + (tmpUsesPadding * tmpPaddingSize);  			_headerOffset = stream.Position - 4;  			if (tmpFrameSize < 8) {  				stream.Seek (-3' SeekOrigin.Current);  				continue;  			}  			// 7/21/05 - Check for 0x00 or 0xFF at end of last frame  			// this sucks for tracks that start with silence  			if (_headerOffset >= 1 && !acceptNullSamples)// if (ftell(fp) >= 5)  			 {  				stream.Seek (-5' SeekOrigin.Current);  				byte tmpLastByte = stream.Read1 ();  				stream.Seek (4' SeekOrigin.Current);  				if (tmpFrameBitrate != 320 && (tmpLastByte == 0x00 || tmpLastByte == 0xFF)) {  					// 7/31/05  					// may be a valid frame - skip its contents to prevent false sync  					long tmpNewPosition = _headerOffset + tmpFrameSize;  					if (tmpFrameSize == 0)  						tmpNewPosition++;  					stream.Seek (tmpNewPosition' SeekOrigin.Begin);  					continue;  				}  			}  			/*if (BR == 0 || FrameSizeConst == 0)                         {                             startpos = HeaderOffset+1;                             fseek(fp' startpos' SEEK_SET);                             continue;                         }*/stream.Seek (_headerOffset + tmpFrameSize' SeekOrigin.Begin);  			if (stream.Read1 () == 0xFF) {  				fh1 = stream.Read1 ();  				fh2 = stream.Read1 ();  				if (tmpFrameHeader [1] == fh1 && (tmpFrameHeader [2] & 0x0D) == (fh2 & 0x0D)) {  					// header found  					break;  				}  			}  			stream.Seek (_headerOffset + 1' SeekOrigin.Begin);  			continue;  		}  	}  	_mpegVersion = (MpegVersion)((tmpFrameHeader [1] >> 3) & 0x03);  	_mpegLayer = (MpegLayer)((tmpFrameHeader [1] >> 1) & 0x03);  	_frequency = GetFrequency (_mpegVersion' (tmpFrameHeader [2] >> 2) & 0x03);  	if (_frequency == 0) {  		throw new InvalidDataException (String.Format ("'{0}'; cannot determine frequency"' path));  	}  	_isPrivate = ((tmpFrameHeader [2] & 0x01) == 0x01);  	_samplesPerFrame = GetSamplesPerFrame (_mpegVersion' _mpegLayer);  	_frameSizeConst = 125.0 * _samplesPerFrame / _frequency;  	_paddingSizeConst = (_mpegLayer == MpegLayer.Layer1 ? 4 : 1);  	_isCopyright = (((tmpFrameHeader [3] >> 3) & 0x01) == 0x01);  	_isOriginal = (((tmpFrameHeader [3] >> 2) & 0x01) == 0x01);  	//tmpModeExtension = (FH[3] >> 4) & 0x03; // not interested' only used in joint-stereo  	//_mpegEmphasis = (MpegEmphasis)(tmpFrameHeader[3] & 0x03);  	if ((tmpFrameHeader [3] >> 6) == 3)  		_channels = 1;  	// Single Channel  	else  		_channels = 2;  	// Read LAME Info Tag  	bool tmpHasLameInfoTag = false;  	stream.Seek (tmpID3v2TagSize + 36' SeekOrigin.Begin);  	Byte[] buf = stream.Read (4);  	if (ByteUtils.Compare (buf' INFO_MARKER))// CBR  	 {  		tmpHasLameInfoTag = true;  		_isVBR = false;  	} else if (ByteUtils.Compare (buf' XING_MARKER))// VBR  	 {  		tmpHasLameInfoTag = true;  		_isVBR = true;  	}  	if (tmpHasLameInfoTag) {  		stream.Seek (4' SeekOrigin.Current);  		int tmpFrames = stream.ReadInt32 ();  		uint tmpBytes = (uint)stream.ReadInt32 ();  		if (tmpFrames > 256 && tmpBytes > 50000) {  			decimal tmpBitrate = tmpBytes / 125.0m / (tmpFrames * _samplesPerFrame / (decimal)_frequency);  			if (tmpBitrate <= 320 && tmpBitrate >= 32) {  				_frames = tmpFrames;  				_bitrate = tmpBitrate;  				_totalSeconds = (tmpBytes / 125.0m) / _bitrate;  			}  		}  	}  	// TODO: Take these 2 lines out  	/*fs.Position = 0;                 CalculateBitrate(fs' null);*/if (calculateBitrate) {  		if (_bitrate == 0 || _isVBR == null || _frames == 0 || _totalSeconds == 0) {  			stream.Position = 0;  			CalculateBitrate (stream' null);  		}  	}  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: using (FileStream stream = File.Open (path' FileMode.Open' FileAccess.Read' FileShare.Read)) {  	int tmpID3v2TagSize = ID3v2.GetTagSize (stream);  	stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  	byte[] tmpFrameHeader = new byte[4];  	bool acceptNullSamples = false;  	while (true) {  		int tmpByte = stream.ReadByte ();  		// keep as ReadByte  		while (tmpByte != 0xFF && tmpByte != -1) {  			tmpByte = stream.ReadByte ();  			// keep as ReadByte  		}  		if (tmpByte == -1) {  			if (acceptNullSamples) {  				throw new InvalidDataException (string.Format ("'{0}': Can't find frame sync"' path));  			}  			stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  			acceptNullSamples = true;  			continue;  		}  		tmpFrameHeader [0] = (byte)tmpByte;  		// Get frame header  		if (stream.Read (tmpFrameHeader' 1' 3) != 3) {  			throw new InvalidDataException (string.Format ("'{0}': Invalid MPEG file; end of stream reached"' path));  		}  		// No sync  		if ((tmpFrameHeader [1] >> 5) != 0x07 || ((tmpFrameHeader [1] >> 1) & 0x03) == 0)// 2/18/05 - ignore reserved layer  		 {  			stream.Seek (-3' SeekOrigin.Current);  		} else if (tmpFrameHeader [1] == 0xFF || ((tmpFrameHeader [1] >> 3) & 0x03) == 1)// 2/19/05 - more bad data  		 {  			stream.Seek (-3' SeekOrigin.Current);  		} else {  			int tmpMpegID = (tmpFrameHeader [1] >> 3) & 0x03;  			int tmpLayerNum = (tmpFrameHeader [1] >> 1) & 0x03;  			int tmpFrequency = GetFrequency ((MpegVersion)tmpMpegID' (tmpFrameHeader [2] >> 2) & 0x03);  			// Check for invalid frequency  			if (tmpFrequency == 0) {  				stream.Seek (-3' SeekOrigin.Current);  				continue;  			}  			int tmpSamplesPerFrame = GetSamplesPerFrame ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum);  			int tmpUsesPadding = (tmpFrameHeader [2] >> 1) & 0x01;  			double tmpFrameSizeConst = 125.0 * tmpSamplesPerFrame / tmpFrequency;  			int tmpPaddingSize = (tmpLayerNum == 3 ? 4 : 1);  			int tmpBitrateIndex = tmpFrameHeader [2] >> 4;  			// Check for invalid values  			if (tmpBitrateIndex < 1 || tmpBitrateIndex > 14 || tmpLayerNum == 0) {  				stream.Seek (-3' SeekOrigin.Current);  				continue;  			}  			int tmpFrameBitrate = GetBitrate ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum' tmpBitrateIndex);  			int tmpFrameSize = (int)(tmpFrameBitrate * tmpFrameSizeConst) + (tmpUsesPadding * tmpPaddingSize);  			_headerOffset = stream.Position - 4;  			if (tmpFrameSize < 8) {  				stream.Seek (-3' SeekOrigin.Current);  				continue;  			}  			// 7/21/05 - Check for 0x00 or 0xFF at end of last frame  			// this sucks for tracks that start with silence  			if (_headerOffset >= 1 && !acceptNullSamples)// if (ftell(fp) >= 5)  			 {  				stream.Seek (-5' SeekOrigin.Current);  				byte tmpLastByte = stream.Read1 ();  				stream.Seek (4' SeekOrigin.Current);  				if (tmpFrameBitrate != 320 && (tmpLastByte == 0x00 || tmpLastByte == 0xFF)) {  					// 7/31/05  					// may be a valid frame - skip its contents to prevent false sync  					long tmpNewPosition = _headerOffset + tmpFrameSize;  					if (tmpFrameSize == 0)  						tmpNewPosition++;  					stream.Seek (tmpNewPosition' SeekOrigin.Begin);  					continue;  				}  			}  			/*if (BR == 0 || FrameSizeConst == 0)                         {                             startpos = HeaderOffset+1;                             fseek(fp' startpos' SEEK_SET);                             continue;                         }*/stream.Seek (_headerOffset + tmpFrameSize' SeekOrigin.Begin);  			if (stream.Read1 () == 0xFF) {  				fh1 = stream.Read1 ();  				fh2 = stream.Read1 ();  				if (tmpFrameHeader [1] == fh1 && (tmpFrameHeader [2] & 0x0D) == (fh2 & 0x0D)) {  					// header found  					break;  				}  			}  			stream.Seek (_headerOffset + 1' SeekOrigin.Begin);  			continue;  		}  	}  	_mpegVersion = (MpegVersion)((tmpFrameHeader [1] >> 3) & 0x03);  	_mpegLayer = (MpegLayer)((tmpFrameHeader [1] >> 1) & 0x03);  	_frequency = GetFrequency (_mpegVersion' (tmpFrameHeader [2] >> 2) & 0x03);  	if (_frequency == 0) {  		throw new InvalidDataException (String.Format ("'{0}'; cannot determine frequency"' path));  	}  	_isPrivate = ((tmpFrameHeader [2] & 0x01) == 0x01);  	_samplesPerFrame = GetSamplesPerFrame (_mpegVersion' _mpegLayer);  	_frameSizeConst = 125.0 * _samplesPerFrame / _frequency;  	_paddingSizeConst = (_mpegLayer == MpegLayer.Layer1 ? 4 : 1);  	_isCopyright = (((tmpFrameHeader [3] >> 3) & 0x01) == 0x01);  	_isOriginal = (((tmpFrameHeader [3] >> 2) & 0x01) == 0x01);  	//tmpModeExtension = (FH[3] >> 4) & 0x03; // not interested' only used in joint-stereo  	//_mpegEmphasis = (MpegEmphasis)(tmpFrameHeader[3] & 0x03);  	if ((tmpFrameHeader [3] >> 6) == 3)  		_channels = 1;  	// Single Channel  	else  		_channels = 2;  	// Read LAME Info Tag  	bool tmpHasLameInfoTag = false;  	stream.Seek (tmpID3v2TagSize + 36' SeekOrigin.Begin);  	Byte[] buf = stream.Read (4);  	if (ByteUtils.Compare (buf' INFO_MARKER))// CBR  	 {  		tmpHasLameInfoTag = true;  		_isVBR = false;  	} else if (ByteUtils.Compare (buf' XING_MARKER))// VBR  	 {  		tmpHasLameInfoTag = true;  		_isVBR = true;  	}  	if (tmpHasLameInfoTag) {  		stream.Seek (4' SeekOrigin.Current);  		int tmpFrames = stream.ReadInt32 ();  		uint tmpBytes = (uint)stream.ReadInt32 ();  		if (tmpFrames > 256 && tmpBytes > 50000) {  			decimal tmpBitrate = tmpBytes / 125.0m / (tmpFrames * _samplesPerFrame / (decimal)_frequency);  			if (tmpBitrate <= 320 && tmpBitrate >= 32) {  				_frames = tmpFrames;  				_bitrate = tmpBitrate;  				_totalSeconds = (tmpBytes / 125.0m) / _bitrate;  			}  		}  	}  	// TODO: Take these 2 lines out  	/*fs.Position = 0;                 CalculateBitrate(fs' null);*/if (calculateBitrate) {  		if (_bitrate == 0 || _isVBR == null || _frames == 0 || _totalSeconds == 0) {  			stream.Position = 0;  			CalculateBitrate (stream' null);  		}  	}  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: using (FileStream stream = File.Open (path' FileMode.Open' FileAccess.Read' FileShare.Read)) {  	int tmpID3v2TagSize = ID3v2.GetTagSize (stream);  	stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  	byte[] tmpFrameHeader = new byte[4];  	bool acceptNullSamples = false;  	while (true) {  		int tmpByte = stream.ReadByte ();  		// keep as ReadByte  		while (tmpByte != 0xFF && tmpByte != -1) {  			tmpByte = stream.ReadByte ();  			// keep as ReadByte  		}  		if (tmpByte == -1) {  			if (acceptNullSamples) {  				throw new InvalidDataException (string.Format ("'{0}': Can't find frame sync"' path));  			}  			stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  			acceptNullSamples = true;  			continue;  		}  		tmpFrameHeader [0] = (byte)tmpByte;  		// Get frame header  		if (stream.Read (tmpFrameHeader' 1' 3) != 3) {  			throw new InvalidDataException (string.Format ("'{0}': Invalid MPEG file; end of stream reached"' path));  		}  		// No sync  		if ((tmpFrameHeader [1] >> 5) != 0x07 || ((tmpFrameHeader [1] >> 1) & 0x03) == 0)// 2/18/05 - ignore reserved layer  		 {  			stream.Seek (-3' SeekOrigin.Current);  		} else if (tmpFrameHeader [1] == 0xFF || ((tmpFrameHeader [1] >> 3) & 0x03) == 1)// 2/19/05 - more bad data  		 {  			stream.Seek (-3' SeekOrigin.Current);  		} else {  			int tmpMpegID = (tmpFrameHeader [1] >> 3) & 0x03;  			int tmpLayerNum = (tmpFrameHeader [1] >> 1) & 0x03;  			int tmpFrequency = GetFrequency ((MpegVersion)tmpMpegID' (tmpFrameHeader [2] >> 2) & 0x03);  			// Check for invalid frequency  			if (tmpFrequency == 0) {  				stream.Seek (-3' SeekOrigin.Current);  				continue;  			}  			int tmpSamplesPerFrame = GetSamplesPerFrame ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum);  			int tmpUsesPadding = (tmpFrameHeader [2] >> 1) & 0x01;  			double tmpFrameSizeConst = 125.0 * tmpSamplesPerFrame / tmpFrequency;  			int tmpPaddingSize = (tmpLayerNum == 3 ? 4 : 1);  			int tmpBitrateIndex = tmpFrameHeader [2] >> 4;  			// Check for invalid values  			if (tmpBitrateIndex < 1 || tmpBitrateIndex > 14 || tmpLayerNum == 0) {  				stream.Seek (-3' SeekOrigin.Current);  				continue;  			}  			int tmpFrameBitrate = GetBitrate ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum' tmpBitrateIndex);  			int tmpFrameSize = (int)(tmpFrameBitrate * tmpFrameSizeConst) + (tmpUsesPadding * tmpPaddingSize);  			_headerOffset = stream.Position - 4;  			if (tmpFrameSize < 8) {  				stream.Seek (-3' SeekOrigin.Current);  				continue;  			}  			// 7/21/05 - Check for 0x00 or 0xFF at end of last frame  			// this sucks for tracks that start with silence  			if (_headerOffset >= 1 && !acceptNullSamples)// if (ftell(fp) >= 5)  			 {  				stream.Seek (-5' SeekOrigin.Current);  				byte tmpLastByte = stream.Read1 ();  				stream.Seek (4' SeekOrigin.Current);  				if (tmpFrameBitrate != 320 && (tmpLastByte == 0x00 || tmpLastByte == 0xFF)) {  					// 7/31/05  					// may be a valid frame - skip its contents to prevent false sync  					long tmpNewPosition = _headerOffset + tmpFrameSize;  					if (tmpFrameSize == 0)  						tmpNewPosition++;  					stream.Seek (tmpNewPosition' SeekOrigin.Begin);  					continue;  				}  			}  			/*if (BR == 0 || FrameSizeConst == 0)                         {                             startpos = HeaderOffset+1;                             fseek(fp' startpos' SEEK_SET);                             continue;                         }*/stream.Seek (_headerOffset + tmpFrameSize' SeekOrigin.Begin);  			if (stream.Read1 () == 0xFF) {  				fh1 = stream.Read1 ();  				fh2 = stream.Read1 ();  				if (tmpFrameHeader [1] == fh1 && (tmpFrameHeader [2] & 0x0D) == (fh2 & 0x0D)) {  					// header found  					break;  				}  			}  			stream.Seek (_headerOffset + 1' SeekOrigin.Begin);  			continue;  		}  	}  	_mpegVersion = (MpegVersion)((tmpFrameHeader [1] >> 3) & 0x03);  	_mpegLayer = (MpegLayer)((tmpFrameHeader [1] >> 1) & 0x03);  	_frequency = GetFrequency (_mpegVersion' (tmpFrameHeader [2] >> 2) & 0x03);  	if (_frequency == 0) {  		throw new InvalidDataException (String.Format ("'{0}'; cannot determine frequency"' path));  	}  	_isPrivate = ((tmpFrameHeader [2] & 0x01) == 0x01);  	_samplesPerFrame = GetSamplesPerFrame (_mpegVersion' _mpegLayer);  	_frameSizeConst = 125.0 * _samplesPerFrame / _frequency;  	_paddingSizeConst = (_mpegLayer == MpegLayer.Layer1 ? 4 : 1);  	_isCopyright = (((tmpFrameHeader [3] >> 3) & 0x01) == 0x01);  	_isOriginal = (((tmpFrameHeader [3] >> 2) & 0x01) == 0x01);  	//tmpModeExtension = (FH[3] >> 4) & 0x03; // not interested' only used in joint-stereo  	//_mpegEmphasis = (MpegEmphasis)(tmpFrameHeader[3] & 0x03);  	if ((tmpFrameHeader [3] >> 6) == 3)  		_channels = 1;  	// Single Channel  	else  		_channels = 2;  	// Read LAME Info Tag  	bool tmpHasLameInfoTag = false;  	stream.Seek (tmpID3v2TagSize + 36' SeekOrigin.Begin);  	Byte[] buf = stream.Read (4);  	if (ByteUtils.Compare (buf' INFO_MARKER))// CBR  	 {  		tmpHasLameInfoTag = true;  		_isVBR = false;  	} else if (ByteUtils.Compare (buf' XING_MARKER))// VBR  	 {  		tmpHasLameInfoTag = true;  		_isVBR = true;  	}  	if (tmpHasLameInfoTag) {  		stream.Seek (4' SeekOrigin.Current);  		int tmpFrames = stream.ReadInt32 ();  		uint tmpBytes = (uint)stream.ReadInt32 ();  		if (tmpFrames > 256 && tmpBytes > 50000) {  			decimal tmpBitrate = tmpBytes / 125.0m / (tmpFrames * _samplesPerFrame / (decimal)_frequency);  			if (tmpBitrate <= 320 && tmpBitrate >= 32) {  				_frames = tmpFrames;  				_bitrate = tmpBitrate;  				_totalSeconds = (tmpBytes / 125.0m) / _bitrate;  			}  		}  	}  	// TODO: Take these 2 lines out  	/*fs.Position = 0;                 CalculateBitrate(fs' null);*/if (calculateBitrate) {  		if (_bitrate == 0 || _isVBR == null || _frames == 0 || _totalSeconds == 0) {  			stream.Position = 0;  			CalculateBitrate (stream' null);  		}  	}  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: using (FileStream stream = File.Open (path' FileMode.Open' FileAccess.Read' FileShare.Read)) {  	int tmpID3v2TagSize = ID3v2.GetTagSize (stream);  	stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  	byte[] tmpFrameHeader = new byte[4];  	bool acceptNullSamples = false;  	while (true) {  		int tmpByte = stream.ReadByte ();  		// keep as ReadByte  		while (tmpByte != 0xFF && tmpByte != -1) {  			tmpByte = stream.ReadByte ();  			// keep as ReadByte  		}  		if (tmpByte == -1) {  			if (acceptNullSamples) {  				throw new InvalidDataException (string.Format ("'{0}': Can't find frame sync"' path));  			}  			stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  			acceptNullSamples = true;  			continue;  		}  		tmpFrameHeader [0] = (byte)tmpByte;  		// Get frame header  		if (stream.Read (tmpFrameHeader' 1' 3) != 3) {  			throw new InvalidDataException (string.Format ("'{0}': Invalid MPEG file; end of stream reached"' path));  		}  		// No sync  		if ((tmpFrameHeader [1] >> 5) != 0x07 || ((tmpFrameHeader [1] >> 1) & 0x03) == 0)// 2/18/05 - ignore reserved layer  		 {  			stream.Seek (-3' SeekOrigin.Current);  		} else if (tmpFrameHeader [1] == 0xFF || ((tmpFrameHeader [1] >> 3) & 0x03) == 1)// 2/19/05 - more bad data  		 {  			stream.Seek (-3' SeekOrigin.Current);  		} else {  			int tmpMpegID = (tmpFrameHeader [1] >> 3) & 0x03;  			int tmpLayerNum = (tmpFrameHeader [1] >> 1) & 0x03;  			int tmpFrequency = GetFrequency ((MpegVersion)tmpMpegID' (tmpFrameHeader [2] >> 2) & 0x03);  			// Check for invalid frequency  			if (tmpFrequency == 0) {  				stream.Seek (-3' SeekOrigin.Current);  				continue;  			}  			int tmpSamplesPerFrame = GetSamplesPerFrame ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum);  			int tmpUsesPadding = (tmpFrameHeader [2] >> 1) & 0x01;  			double tmpFrameSizeConst = 125.0 * tmpSamplesPerFrame / tmpFrequency;  			int tmpPaddingSize = (tmpLayerNum == 3 ? 4 : 1);  			int tmpBitrateIndex = tmpFrameHeader [2] >> 4;  			// Check for invalid values  			if (tmpBitrateIndex < 1 || tmpBitrateIndex > 14 || tmpLayerNum == 0) {  				stream.Seek (-3' SeekOrigin.Current);  				continue;  			}  			int tmpFrameBitrate = GetBitrate ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum' tmpBitrateIndex);  			int tmpFrameSize = (int)(tmpFrameBitrate * tmpFrameSizeConst) + (tmpUsesPadding * tmpPaddingSize);  			_headerOffset = stream.Position - 4;  			if (tmpFrameSize < 8) {  				stream.Seek (-3' SeekOrigin.Current);  				continue;  			}  			// 7/21/05 - Check for 0x00 or 0xFF at end of last frame  			// this sucks for tracks that start with silence  			if (_headerOffset >= 1 && !acceptNullSamples)// if (ftell(fp) >= 5)  			 {  				stream.Seek (-5' SeekOrigin.Current);  				byte tmpLastByte = stream.Read1 ();  				stream.Seek (4' SeekOrigin.Current);  				if (tmpFrameBitrate != 320 && (tmpLastByte == 0x00 || tmpLastByte == 0xFF)) {  					// 7/31/05  					// may be a valid frame - skip its contents to prevent false sync  					long tmpNewPosition = _headerOffset + tmpFrameSize;  					if (tmpFrameSize == 0)  						tmpNewPosition++;  					stream.Seek (tmpNewPosition' SeekOrigin.Begin);  					continue;  				}  			}  			/*if (BR == 0 || FrameSizeConst == 0)                         {                             startpos = HeaderOffset+1;                             fseek(fp' startpos' SEEK_SET);                             continue;                         }*/stream.Seek (_headerOffset + tmpFrameSize' SeekOrigin.Begin);  			if (stream.Read1 () == 0xFF) {  				fh1 = stream.Read1 ();  				fh2 = stream.Read1 ();  				if (tmpFrameHeader [1] == fh1 && (tmpFrameHeader [2] & 0x0D) == (fh2 & 0x0D)) {  					// header found  					break;  				}  			}  			stream.Seek (_headerOffset + 1' SeekOrigin.Begin);  			continue;  		}  	}  	_mpegVersion = (MpegVersion)((tmpFrameHeader [1] >> 3) & 0x03);  	_mpegLayer = (MpegLayer)((tmpFrameHeader [1] >> 1) & 0x03);  	_frequency = GetFrequency (_mpegVersion' (tmpFrameHeader [2] >> 2) & 0x03);  	if (_frequency == 0) {  		throw new InvalidDataException (String.Format ("'{0}'; cannot determine frequency"' path));  	}  	_isPrivate = ((tmpFrameHeader [2] & 0x01) == 0x01);  	_samplesPerFrame = GetSamplesPerFrame (_mpegVersion' _mpegLayer);  	_frameSizeConst = 125.0 * _samplesPerFrame / _frequency;  	_paddingSizeConst = (_mpegLayer == MpegLayer.Layer1 ? 4 : 1);  	_isCopyright = (((tmpFrameHeader [3] >> 3) & 0x01) == 0x01);  	_isOriginal = (((tmpFrameHeader [3] >> 2) & 0x01) == 0x01);  	//tmpModeExtension = (FH[3] >> 4) & 0x03; // not interested' only used in joint-stereo  	//_mpegEmphasis = (MpegEmphasis)(tmpFrameHeader[3] & 0x03);  	if ((tmpFrameHeader [3] >> 6) == 3)  		_channels = 1;  	// Single Channel  	else  		_channels = 2;  	// Read LAME Info Tag  	bool tmpHasLameInfoTag = false;  	stream.Seek (tmpID3v2TagSize + 36' SeekOrigin.Begin);  	Byte[] buf = stream.Read (4);  	if (ByteUtils.Compare (buf' INFO_MARKER))// CBR  	 {  		tmpHasLameInfoTag = true;  		_isVBR = false;  	} else if (ByteUtils.Compare (buf' XING_MARKER))// VBR  	 {  		tmpHasLameInfoTag = true;  		_isVBR = true;  	}  	if (tmpHasLameInfoTag) {  		stream.Seek (4' SeekOrigin.Current);  		int tmpFrames = stream.ReadInt32 ();  		uint tmpBytes = (uint)stream.ReadInt32 ();  		if (tmpFrames > 256 && tmpBytes > 50000) {  			decimal tmpBitrate = tmpBytes / 125.0m / (tmpFrames * _samplesPerFrame / (decimal)_frequency);  			if (tmpBitrate <= 320 && tmpBitrate >= 32) {  				_frames = tmpFrames;  				_bitrate = tmpBitrate;  				_totalSeconds = (tmpBytes / 125.0m) / _bitrate;  			}  		}  	}  	// TODO: Take these 2 lines out  	/*fs.Position = 0;                 CalculateBitrate(fs' null);*/if (calculateBitrate) {  		if (_bitrate == 0 || _isVBR == null || _frames == 0 || _totalSeconds == 0) {  			stream.Position = 0;  			CalculateBitrate (stream' null);  		}  	}  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: using (FileStream stream = File.Open (path' FileMode.Open' FileAccess.Read' FileShare.Read)) {  	int tmpID3v2TagSize = ID3v2.GetTagSize (stream);  	stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  	byte[] tmpFrameHeader = new byte[4];  	bool acceptNullSamples = false;  	while (true) {  		int tmpByte = stream.ReadByte ();  		// keep as ReadByte  		while (tmpByte != 0xFF && tmpByte != -1) {  			tmpByte = stream.ReadByte ();  			// keep as ReadByte  		}  		if (tmpByte == -1) {  			if (acceptNullSamples) {  				throw new InvalidDataException (string.Format ("'{0}': Can't find frame sync"' path));  			}  			stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  			acceptNullSamples = true;  			continue;  		}  		tmpFrameHeader [0] = (byte)tmpByte;  		// Get frame header  		if (stream.Read (tmpFrameHeader' 1' 3) != 3) {  			throw new InvalidDataException (string.Format ("'{0}': Invalid MPEG file; end of stream reached"' path));  		}  		// No sync  		if ((tmpFrameHeader [1] >> 5) != 0x07 || ((tmpFrameHeader [1] >> 1) & 0x03) == 0)// 2/18/05 - ignore reserved layer  		 {  			stream.Seek (-3' SeekOrigin.Current);  		} else if (tmpFrameHeader [1] == 0xFF || ((tmpFrameHeader [1] >> 3) & 0x03) == 1)// 2/19/05 - more bad data  		 {  			stream.Seek (-3' SeekOrigin.Current);  		} else {  			int tmpMpegID = (tmpFrameHeader [1] >> 3) & 0x03;  			int tmpLayerNum = (tmpFrameHeader [1] >> 1) & 0x03;  			int tmpFrequency = GetFrequency ((MpegVersion)tmpMpegID' (tmpFrameHeader [2] >> 2) & 0x03);  			// Check for invalid frequency  			if (tmpFrequency == 0) {  				stream.Seek (-3' SeekOrigin.Current);  				continue;  			}  			int tmpSamplesPerFrame = GetSamplesPerFrame ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum);  			int tmpUsesPadding = (tmpFrameHeader [2] >> 1) & 0x01;  			double tmpFrameSizeConst = 125.0 * tmpSamplesPerFrame / tmpFrequency;  			int tmpPaddingSize = (tmpLayerNum == 3 ? 4 : 1);  			int tmpBitrateIndex = tmpFrameHeader [2] >> 4;  			// Check for invalid values  			if (tmpBitrateIndex < 1 || tmpBitrateIndex > 14 || tmpLayerNum == 0) {  				stream.Seek (-3' SeekOrigin.Current);  				continue;  			}  			int tmpFrameBitrate = GetBitrate ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum' tmpBitrateIndex);  			int tmpFrameSize = (int)(tmpFrameBitrate * tmpFrameSizeConst) + (tmpUsesPadding * tmpPaddingSize);  			_headerOffset = stream.Position - 4;  			if (tmpFrameSize < 8) {  				stream.Seek (-3' SeekOrigin.Current);  				continue;  			}  			// 7/21/05 - Check for 0x00 or 0xFF at end of last frame  			// this sucks for tracks that start with silence  			if (_headerOffset >= 1 && !acceptNullSamples)// if (ftell(fp) >= 5)  			 {  				stream.Seek (-5' SeekOrigin.Current);  				byte tmpLastByte = stream.Read1 ();  				stream.Seek (4' SeekOrigin.Current);  				if (tmpFrameBitrate != 320 && (tmpLastByte == 0x00 || tmpLastByte == 0xFF)) {  					// 7/31/05  					// may be a valid frame - skip its contents to prevent false sync  					long tmpNewPosition = _headerOffset + tmpFrameSize;  					if (tmpFrameSize == 0)  						tmpNewPosition++;  					stream.Seek (tmpNewPosition' SeekOrigin.Begin);  					continue;  				}  			}  			/*if (BR == 0 || FrameSizeConst == 0)                         {                             startpos = HeaderOffset+1;                             fseek(fp' startpos' SEEK_SET);                             continue;                         }*/stream.Seek (_headerOffset + tmpFrameSize' SeekOrigin.Begin);  			if (stream.Read1 () == 0xFF) {  				fh1 = stream.Read1 ();  				fh2 = stream.Read1 ();  				if (tmpFrameHeader [1] == fh1 && (tmpFrameHeader [2] & 0x0D) == (fh2 & 0x0D)) {  					// header found  					break;  				}  			}  			stream.Seek (_headerOffset + 1' SeekOrigin.Begin);  			continue;  		}  	}  	_mpegVersion = (MpegVersion)((tmpFrameHeader [1] >> 3) & 0x03);  	_mpegLayer = (MpegLayer)((tmpFrameHeader [1] >> 1) & 0x03);  	_frequency = GetFrequency (_mpegVersion' (tmpFrameHeader [2] >> 2) & 0x03);  	if (_frequency == 0) {  		throw new InvalidDataException (String.Format ("'{0}'; cannot determine frequency"' path));  	}  	_isPrivate = ((tmpFrameHeader [2] & 0x01) == 0x01);  	_samplesPerFrame = GetSamplesPerFrame (_mpegVersion' _mpegLayer);  	_frameSizeConst = 125.0 * _samplesPerFrame / _frequency;  	_paddingSizeConst = (_mpegLayer == MpegLayer.Layer1 ? 4 : 1);  	_isCopyright = (((tmpFrameHeader [3] >> 3) & 0x01) == 0x01);  	_isOriginal = (((tmpFrameHeader [3] >> 2) & 0x01) == 0x01);  	//tmpModeExtension = (FH[3] >> 4) & 0x03; // not interested' only used in joint-stereo  	//_mpegEmphasis = (MpegEmphasis)(tmpFrameHeader[3] & 0x03);  	if ((tmpFrameHeader [3] >> 6) == 3)  		_channels = 1;  	// Single Channel  	else  		_channels = 2;  	// Read LAME Info Tag  	bool tmpHasLameInfoTag = false;  	stream.Seek (tmpID3v2TagSize + 36' SeekOrigin.Begin);  	Byte[] buf = stream.Read (4);  	if (ByteUtils.Compare (buf' INFO_MARKER))// CBR  	 {  		tmpHasLameInfoTag = true;  		_isVBR = false;  	} else if (ByteUtils.Compare (buf' XING_MARKER))// VBR  	 {  		tmpHasLameInfoTag = true;  		_isVBR = true;  	}  	if (tmpHasLameInfoTag) {  		stream.Seek (4' SeekOrigin.Current);  		int tmpFrames = stream.ReadInt32 ();  		uint tmpBytes = (uint)stream.ReadInt32 ();  		if (tmpFrames > 256 && tmpBytes > 50000) {  			decimal tmpBitrate = tmpBytes / 125.0m / (tmpFrames * _samplesPerFrame / (decimal)_frequency);  			if (tmpBitrate <= 320 && tmpBitrate >= 32) {  				_frames = tmpFrames;  				_bitrate = tmpBitrate;  				_totalSeconds = (tmpBytes / 125.0m) / _bitrate;  			}  		}  	}  	// TODO: Take these 2 lines out  	/*fs.Position = 0;                 CalculateBitrate(fs' null);*/if (calculateBitrate) {  		if (_bitrate == 0 || _isVBR == null || _frames == 0 || _totalSeconds == 0) {  			stream.Position = 0;  			CalculateBitrate (stream' null);  		}  	}  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: using (FileStream stream = File.Open (path' FileMode.Open' FileAccess.Read' FileShare.Read)) {  	int tmpID3v2TagSize = ID3v2.GetTagSize (stream);  	stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  	byte[] tmpFrameHeader = new byte[4];  	bool acceptNullSamples = false;  	while (true) {  		int tmpByte = stream.ReadByte ();  		// keep as ReadByte  		while (tmpByte != 0xFF && tmpByte != -1) {  			tmpByte = stream.ReadByte ();  			// keep as ReadByte  		}  		if (tmpByte == -1) {  			if (acceptNullSamples) {  				throw new InvalidDataException (string.Format ("'{0}': Can't find frame sync"' path));  			}  			stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  			acceptNullSamples = true;  			continue;  		}  		tmpFrameHeader [0] = (byte)tmpByte;  		// Get frame header  		if (stream.Read (tmpFrameHeader' 1' 3) != 3) {  			throw new InvalidDataException (string.Format ("'{0}': Invalid MPEG file; end of stream reached"' path));  		}  		// No sync  		if ((tmpFrameHeader [1] >> 5) != 0x07 || ((tmpFrameHeader [1] >> 1) & 0x03) == 0)// 2/18/05 - ignore reserved layer  		 {  			stream.Seek (-3' SeekOrigin.Current);  		} else if (tmpFrameHeader [1] == 0xFF || ((tmpFrameHeader [1] >> 3) & 0x03) == 1)// 2/19/05 - more bad data  		 {  			stream.Seek (-3' SeekOrigin.Current);  		} else {  			int tmpMpegID = (tmpFrameHeader [1] >> 3) & 0x03;  			int tmpLayerNum = (tmpFrameHeader [1] >> 1) & 0x03;  			int tmpFrequency = GetFrequency ((MpegVersion)tmpMpegID' (tmpFrameHeader [2] >> 2) & 0x03);  			// Check for invalid frequency  			if (tmpFrequency == 0) {  				stream.Seek (-3' SeekOrigin.Current);  				continue;  			}  			int tmpSamplesPerFrame = GetSamplesPerFrame ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum);  			int tmpUsesPadding = (tmpFrameHeader [2] >> 1) & 0x01;  			double tmpFrameSizeConst = 125.0 * tmpSamplesPerFrame / tmpFrequency;  			int tmpPaddingSize = (tmpLayerNum == 3 ? 4 : 1);  			int tmpBitrateIndex = tmpFrameHeader [2] >> 4;  			// Check for invalid values  			if (tmpBitrateIndex < 1 || tmpBitrateIndex > 14 || tmpLayerNum == 0) {  				stream.Seek (-3' SeekOrigin.Current);  				continue;  			}  			int tmpFrameBitrate = GetBitrate ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum' tmpBitrateIndex);  			int tmpFrameSize = (int)(tmpFrameBitrate * tmpFrameSizeConst) + (tmpUsesPadding * tmpPaddingSize);  			_headerOffset = stream.Position - 4;  			if (tmpFrameSize < 8) {  				stream.Seek (-3' SeekOrigin.Current);  				continue;  			}  			// 7/21/05 - Check for 0x00 or 0xFF at end of last frame  			// this sucks for tracks that start with silence  			if (_headerOffset >= 1 && !acceptNullSamples)// if (ftell(fp) >= 5)  			 {  				stream.Seek (-5' SeekOrigin.Current);  				byte tmpLastByte = stream.Read1 ();  				stream.Seek (4' SeekOrigin.Current);  				if (tmpFrameBitrate != 320 && (tmpLastByte == 0x00 || tmpLastByte == 0xFF)) {  					// 7/31/05  					// may be a valid frame - skip its contents to prevent false sync  					long tmpNewPosition = _headerOffset + tmpFrameSize;  					if (tmpFrameSize == 0)  						tmpNewPosition++;  					stream.Seek (tmpNewPosition' SeekOrigin.Begin);  					continue;  				}  			}  			/*if (BR == 0 || FrameSizeConst == 0)                         {                             startpos = HeaderOffset+1;                             fseek(fp' startpos' SEEK_SET);                             continue;                         }*/stream.Seek (_headerOffset + tmpFrameSize' SeekOrigin.Begin);  			if (stream.Read1 () == 0xFF) {  				fh1 = stream.Read1 ();  				fh2 = stream.Read1 ();  				if (tmpFrameHeader [1] == fh1 && (tmpFrameHeader [2] & 0x0D) == (fh2 & 0x0D)) {  					// header found  					break;  				}  			}  			stream.Seek (_headerOffset + 1' SeekOrigin.Begin);  			continue;  		}  	}  	_mpegVersion = (MpegVersion)((tmpFrameHeader [1] >> 3) & 0x03);  	_mpegLayer = (MpegLayer)((tmpFrameHeader [1] >> 1) & 0x03);  	_frequency = GetFrequency (_mpegVersion' (tmpFrameHeader [2] >> 2) & 0x03);  	if (_frequency == 0) {  		throw new InvalidDataException (String.Format ("'{0}'; cannot determine frequency"' path));  	}  	_isPrivate = ((tmpFrameHeader [2] & 0x01) == 0x01);  	_samplesPerFrame = GetSamplesPerFrame (_mpegVersion' _mpegLayer);  	_frameSizeConst = 125.0 * _samplesPerFrame / _frequency;  	_paddingSizeConst = (_mpegLayer == MpegLayer.Layer1 ? 4 : 1);  	_isCopyright = (((tmpFrameHeader [3] >> 3) & 0x01) == 0x01);  	_isOriginal = (((tmpFrameHeader [3] >> 2) & 0x01) == 0x01);  	//tmpModeExtension = (FH[3] >> 4) & 0x03; // not interested' only used in joint-stereo  	//_mpegEmphasis = (MpegEmphasis)(tmpFrameHeader[3] & 0x03);  	if ((tmpFrameHeader [3] >> 6) == 3)  		_channels = 1;  	// Single Channel  	else  		_channels = 2;  	// Read LAME Info Tag  	bool tmpHasLameInfoTag = false;  	stream.Seek (tmpID3v2TagSize + 36' SeekOrigin.Begin);  	Byte[] buf = stream.Read (4);  	if (ByteUtils.Compare (buf' INFO_MARKER))// CBR  	 {  		tmpHasLameInfoTag = true;  		_isVBR = false;  	} else if (ByteUtils.Compare (buf' XING_MARKER))// VBR  	 {  		tmpHasLameInfoTag = true;  		_isVBR = true;  	}  	if (tmpHasLameInfoTag) {  		stream.Seek (4' SeekOrigin.Current);  		int tmpFrames = stream.ReadInt32 ();  		uint tmpBytes = (uint)stream.ReadInt32 ();  		if (tmpFrames > 256 && tmpBytes > 50000) {  			decimal tmpBitrate = tmpBytes / 125.0m / (tmpFrames * _samplesPerFrame / (decimal)_frequency);  			if (tmpBitrate <= 320 && tmpBitrate >= 32) {  				_frames = tmpFrames;  				_bitrate = tmpBitrate;  				_totalSeconds = (tmpBytes / 125.0m) / _bitrate;  			}  		}  	}  	// TODO: Take these 2 lines out  	/*fs.Position = 0;                 CalculateBitrate(fs' null);*/if (calculateBitrate) {  		if (_bitrate == 0 || _isVBR == null || _frames == 0 || _totalSeconds == 0) {  			stream.Position = 0;  			CalculateBitrate (stream' null);  		}  	}  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: using (FileStream stream = File.Open (path' FileMode.Open' FileAccess.Read' FileShare.Read)) {  	int tmpID3v2TagSize = ID3v2.GetTagSize (stream);  	stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  	byte[] tmpFrameHeader = new byte[4];  	bool acceptNullSamples = false;  	while (true) {  		int tmpByte = stream.ReadByte ();  		// keep as ReadByte  		while (tmpByte != 0xFF && tmpByte != -1) {  			tmpByte = stream.ReadByte ();  			// keep as ReadByte  		}  		if (tmpByte == -1) {  			if (acceptNullSamples) {  				throw new InvalidDataException (string.Format ("'{0}': Can't find frame sync"' path));  			}  			stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  			acceptNullSamples = true;  			continue;  		}  		tmpFrameHeader [0] = (byte)tmpByte;  		// Get frame header  		if (stream.Read (tmpFrameHeader' 1' 3) != 3) {  			throw new InvalidDataException (string.Format ("'{0}': Invalid MPEG file; end of stream reached"' path));  		}  		// No sync  		if ((tmpFrameHeader [1] >> 5) != 0x07 || ((tmpFrameHeader [1] >> 1) & 0x03) == 0)// 2/18/05 - ignore reserved layer  		 {  			stream.Seek (-3' SeekOrigin.Current);  		} else if (tmpFrameHeader [1] == 0xFF || ((tmpFrameHeader [1] >> 3) & 0x03) == 1)// 2/19/05 - more bad data  		 {  			stream.Seek (-3' SeekOrigin.Current);  		} else {  			int tmpMpegID = (tmpFrameHeader [1] >> 3) & 0x03;  			int tmpLayerNum = (tmpFrameHeader [1] >> 1) & 0x03;  			int tmpFrequency = GetFrequency ((MpegVersion)tmpMpegID' (tmpFrameHeader [2] >> 2) & 0x03);  			// Check for invalid frequency  			if (tmpFrequency == 0) {  				stream.Seek (-3' SeekOrigin.Current);  				continue;  			}  			int tmpSamplesPerFrame = GetSamplesPerFrame ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum);  			int tmpUsesPadding = (tmpFrameHeader [2] >> 1) & 0x01;  			double tmpFrameSizeConst = 125.0 * tmpSamplesPerFrame / tmpFrequency;  			int tmpPaddingSize = (tmpLayerNum == 3 ? 4 : 1);  			int tmpBitrateIndex = tmpFrameHeader [2] >> 4;  			// Check for invalid values  			if (tmpBitrateIndex < 1 || tmpBitrateIndex > 14 || tmpLayerNum == 0) {  				stream.Seek (-3' SeekOrigin.Current);  				continue;  			}  			int tmpFrameBitrate = GetBitrate ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum' tmpBitrateIndex);  			int tmpFrameSize = (int)(tmpFrameBitrate * tmpFrameSizeConst) + (tmpUsesPadding * tmpPaddingSize);  			_headerOffset = stream.Position - 4;  			if (tmpFrameSize < 8) {  				stream.Seek (-3' SeekOrigin.Current);  				continue;  			}  			// 7/21/05 - Check for 0x00 or 0xFF at end of last frame  			// this sucks for tracks that start with silence  			if (_headerOffset >= 1 && !acceptNullSamples)// if (ftell(fp) >= 5)  			 {  				stream.Seek (-5' SeekOrigin.Current);  				byte tmpLastByte = stream.Read1 ();  				stream.Seek (4' SeekOrigin.Current);  				if (tmpFrameBitrate != 320 && (tmpLastByte == 0x00 || tmpLastByte == 0xFF)) {  					// 7/31/05  					// may be a valid frame - skip its contents to prevent false sync  					long tmpNewPosition = _headerOffset + tmpFrameSize;  					if (tmpFrameSize == 0)  						tmpNewPosition++;  					stream.Seek (tmpNewPosition' SeekOrigin.Begin);  					continue;  				}  			}  			/*if (BR == 0 || FrameSizeConst == 0)                         {                             startpos = HeaderOffset+1;                             fseek(fp' startpos' SEEK_SET);                             continue;                         }*/stream.Seek (_headerOffset + tmpFrameSize' SeekOrigin.Begin);  			if (stream.Read1 () == 0xFF) {  				fh1 = stream.Read1 ();  				fh2 = stream.Read1 ();  				if (tmpFrameHeader [1] == fh1 && (tmpFrameHeader [2] & 0x0D) == (fh2 & 0x0D)) {  					// header found  					break;  				}  			}  			stream.Seek (_headerOffset + 1' SeekOrigin.Begin);  			continue;  		}  	}  	_mpegVersion = (MpegVersion)((tmpFrameHeader [1] >> 3) & 0x03);  	_mpegLayer = (MpegLayer)((tmpFrameHeader [1] >> 1) & 0x03);  	_frequency = GetFrequency (_mpegVersion' (tmpFrameHeader [2] >> 2) & 0x03);  	if (_frequency == 0) {  		throw new InvalidDataException (String.Format ("'{0}'; cannot determine frequency"' path));  	}  	_isPrivate = ((tmpFrameHeader [2] & 0x01) == 0x01);  	_samplesPerFrame = GetSamplesPerFrame (_mpegVersion' _mpegLayer);  	_frameSizeConst = 125.0 * _samplesPerFrame / _frequency;  	_paddingSizeConst = (_mpegLayer == MpegLayer.Layer1 ? 4 : 1);  	_isCopyright = (((tmpFrameHeader [3] >> 3) & 0x01) == 0x01);  	_isOriginal = (((tmpFrameHeader [3] >> 2) & 0x01) == 0x01);  	//tmpModeExtension = (FH[3] >> 4) & 0x03; // not interested' only used in joint-stereo  	//_mpegEmphasis = (MpegEmphasis)(tmpFrameHeader[3] & 0x03);  	if ((tmpFrameHeader [3] >> 6) == 3)  		_channels = 1;  	// Single Channel  	else  		_channels = 2;  	// Read LAME Info Tag  	bool tmpHasLameInfoTag = false;  	stream.Seek (tmpID3v2TagSize + 36' SeekOrigin.Begin);  	Byte[] buf = stream.Read (4);  	if (ByteUtils.Compare (buf' INFO_MARKER))// CBR  	 {  		tmpHasLameInfoTag = true;  		_isVBR = false;  	} else if (ByteUtils.Compare (buf' XING_MARKER))// VBR  	 {  		tmpHasLameInfoTag = true;  		_isVBR = true;  	}  	if (tmpHasLameInfoTag) {  		stream.Seek (4' SeekOrigin.Current);  		int tmpFrames = stream.ReadInt32 ();  		uint tmpBytes = (uint)stream.ReadInt32 ();  		if (tmpFrames > 256 && tmpBytes > 50000) {  			decimal tmpBitrate = tmpBytes / 125.0m / (tmpFrames * _samplesPerFrame / (decimal)_frequency);  			if (tmpBitrate <= 320 && tmpBitrate >= 32) {  				_frames = tmpFrames;  				_bitrate = tmpBitrate;  				_totalSeconds = (tmpBytes / 125.0m) / _bitrate;  			}  		}  	}  	// TODO: Take these 2 lines out  	/*fs.Position = 0;                 CalculateBitrate(fs' null);*/if (calculateBitrate) {  		if (_bitrate == 0 || _isVBR == null || _frames == 0 || _totalSeconds == 0) {  			stream.Position = 0;  			CalculateBitrate (stream' null);  		}  	}  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: using (FileStream stream = File.Open (path' FileMode.Open' FileAccess.Read' FileShare.Read)) {  	int tmpID3v2TagSize = ID3v2.GetTagSize (stream);  	stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  	byte[] tmpFrameHeader = new byte[4];  	bool acceptNullSamples = false;  	while (true) {  		int tmpByte = stream.ReadByte ();  		// keep as ReadByte  		while (tmpByte != 0xFF && tmpByte != -1) {  			tmpByte = stream.ReadByte ();  			// keep as ReadByte  		}  		if (tmpByte == -1) {  			if (acceptNullSamples) {  				throw new InvalidDataException (string.Format ("'{0}': Can't find frame sync"' path));  			}  			stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  			acceptNullSamples = true;  			continue;  		}  		tmpFrameHeader [0] = (byte)tmpByte;  		// Get frame header  		if (stream.Read (tmpFrameHeader' 1' 3) != 3) {  			throw new InvalidDataException (string.Format ("'{0}': Invalid MPEG file; end of stream reached"' path));  		}  		// No sync  		if ((tmpFrameHeader [1] >> 5) != 0x07 || ((tmpFrameHeader [1] >> 1) & 0x03) == 0)// 2/18/05 - ignore reserved layer  		 {  			stream.Seek (-3' SeekOrigin.Current);  		} else if (tmpFrameHeader [1] == 0xFF || ((tmpFrameHeader [1] >> 3) & 0x03) == 1)// 2/19/05 - more bad data  		 {  			stream.Seek (-3' SeekOrigin.Current);  		} else {  			int tmpMpegID = (tmpFrameHeader [1] >> 3) & 0x03;  			int tmpLayerNum = (tmpFrameHeader [1] >> 1) & 0x03;  			int tmpFrequency = GetFrequency ((MpegVersion)tmpMpegID' (tmpFrameHeader [2] >> 2) & 0x03);  			// Check for invalid frequency  			if (tmpFrequency == 0) {  				stream.Seek (-3' SeekOrigin.Current);  				continue;  			}  			int tmpSamplesPerFrame = GetSamplesPerFrame ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum);  			int tmpUsesPadding = (tmpFrameHeader [2] >> 1) & 0x01;  			double tmpFrameSizeConst = 125.0 * tmpSamplesPerFrame / tmpFrequency;  			int tmpPaddingSize = (tmpLayerNum == 3 ? 4 : 1);  			int tmpBitrateIndex = tmpFrameHeader [2] >> 4;  			// Check for invalid values  			if (tmpBitrateIndex < 1 || tmpBitrateIndex > 14 || tmpLayerNum == 0) {  				stream.Seek (-3' SeekOrigin.Current);  				continue;  			}  			int tmpFrameBitrate = GetBitrate ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum' tmpBitrateIndex);  			int tmpFrameSize = (int)(tmpFrameBitrate * tmpFrameSizeConst) + (tmpUsesPadding * tmpPaddingSize);  			_headerOffset = stream.Position - 4;  			if (tmpFrameSize < 8) {  				stream.Seek (-3' SeekOrigin.Current);  				continue;  			}  			// 7/21/05 - Check for 0x00 or 0xFF at end of last frame  			// this sucks for tracks that start with silence  			if (_headerOffset >= 1 && !acceptNullSamples)// if (ftell(fp) >= 5)  			 {  				stream.Seek (-5' SeekOrigin.Current);  				byte tmpLastByte = stream.Read1 ();  				stream.Seek (4' SeekOrigin.Current);  				if (tmpFrameBitrate != 320 && (tmpLastByte == 0x00 || tmpLastByte == 0xFF)) {  					// 7/31/05  					// may be a valid frame - skip its contents to prevent false sync  					long tmpNewPosition = _headerOffset + tmpFrameSize;  					if (tmpFrameSize == 0)  						tmpNewPosition++;  					stream.Seek (tmpNewPosition' SeekOrigin.Begin);  					continue;  				}  			}  			/*if (BR == 0 || FrameSizeConst == 0)                         {                             startpos = HeaderOffset+1;                             fseek(fp' startpos' SEEK_SET);                             continue;                         }*/stream.Seek (_headerOffset + tmpFrameSize' SeekOrigin.Begin);  			if (stream.Read1 () == 0xFF) {  				fh1 = stream.Read1 ();  				fh2 = stream.Read1 ();  				if (tmpFrameHeader [1] == fh1 && (tmpFrameHeader [2] & 0x0D) == (fh2 & 0x0D)) {  					// header found  					break;  				}  			}  			stream.Seek (_headerOffset + 1' SeekOrigin.Begin);  			continue;  		}  	}  	_mpegVersion = (MpegVersion)((tmpFrameHeader [1] >> 3) & 0x03);  	_mpegLayer = (MpegLayer)((tmpFrameHeader [1] >> 1) & 0x03);  	_frequency = GetFrequency (_mpegVersion' (tmpFrameHeader [2] >> 2) & 0x03);  	if (_frequency == 0) {  		throw new InvalidDataException (String.Format ("'{0}'; cannot determine frequency"' path));  	}  	_isPrivate = ((tmpFrameHeader [2] & 0x01) == 0x01);  	_samplesPerFrame = GetSamplesPerFrame (_mpegVersion' _mpegLayer);  	_frameSizeConst = 125.0 * _samplesPerFrame / _frequency;  	_paddingSizeConst = (_mpegLayer == MpegLayer.Layer1 ? 4 : 1);  	_isCopyright = (((tmpFrameHeader [3] >> 3) & 0x01) == 0x01);  	_isOriginal = (((tmpFrameHeader [3] >> 2) & 0x01) == 0x01);  	//tmpModeExtension = (FH[3] >> 4) & 0x03; // not interested' only used in joint-stereo  	//_mpegEmphasis = (MpegEmphasis)(tmpFrameHeader[3] & 0x03);  	if ((tmpFrameHeader [3] >> 6) == 3)  		_channels = 1;  	// Single Channel  	else  		_channels = 2;  	// Read LAME Info Tag  	bool tmpHasLameInfoTag = false;  	stream.Seek (tmpID3v2TagSize + 36' SeekOrigin.Begin);  	Byte[] buf = stream.Read (4);  	if (ByteUtils.Compare (buf' INFO_MARKER))// CBR  	 {  		tmpHasLameInfoTag = true;  		_isVBR = false;  	} else if (ByteUtils.Compare (buf' XING_MARKER))// VBR  	 {  		tmpHasLameInfoTag = true;  		_isVBR = true;  	}  	if (tmpHasLameInfoTag) {  		stream.Seek (4' SeekOrigin.Current);  		int tmpFrames = stream.ReadInt32 ();  		uint tmpBytes = (uint)stream.ReadInt32 ();  		if (tmpFrames > 256 && tmpBytes > 50000) {  			decimal tmpBitrate = tmpBytes / 125.0m / (tmpFrames * _samplesPerFrame / (decimal)_frequency);  			if (tmpBitrate <= 320 && tmpBitrate >= 32) {  				_frames = tmpFrames;  				_bitrate = tmpBitrate;  				_totalSeconds = (tmpBytes / 125.0m) / _bitrate;  			}  		}  	}  	// TODO: Take these 2 lines out  	/*fs.Position = 0;                 CalculateBitrate(fs' null);*/if (calculateBitrate) {  		if (_bitrate == 0 || _isVBR == null || _frames == 0 || _totalSeconds == 0) {  			stream.Position = 0;  			CalculateBitrate (stream' null);  		}  	}  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: using (FileStream stream = File.Open (path' FileMode.Open' FileAccess.Read' FileShare.Read)) {  	int tmpID3v2TagSize = ID3v2.GetTagSize (stream);  	stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  	byte[] tmpFrameHeader = new byte[4];  	bool acceptNullSamples = false;  	while (true) {  		int tmpByte = stream.ReadByte ();  		// keep as ReadByte  		while (tmpByte != 0xFF && tmpByte != -1) {  			tmpByte = stream.ReadByte ();  			// keep as ReadByte  		}  		if (tmpByte == -1) {  			if (acceptNullSamples) {  				throw new InvalidDataException (string.Format ("'{0}': Can't find frame sync"' path));  			}  			stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  			acceptNullSamples = true;  			continue;  		}  		tmpFrameHeader [0] = (byte)tmpByte;  		// Get frame header  		if (stream.Read (tmpFrameHeader' 1' 3) != 3) {  			throw new InvalidDataException (string.Format ("'{0}': Invalid MPEG file; end of stream reached"' path));  		}  		// No sync  		if ((tmpFrameHeader [1] >> 5) != 0x07 || ((tmpFrameHeader [1] >> 1) & 0x03) == 0)// 2/18/05 - ignore reserved layer  		 {  			stream.Seek (-3' SeekOrigin.Current);  		} else if (tmpFrameHeader [1] == 0xFF || ((tmpFrameHeader [1] >> 3) & 0x03) == 1)// 2/19/05 - more bad data  		 {  			stream.Seek (-3' SeekOrigin.Current);  		} else {  			int tmpMpegID = (tmpFrameHeader [1] >> 3) & 0x03;  			int tmpLayerNum = (tmpFrameHeader [1] >> 1) & 0x03;  			int tmpFrequency = GetFrequency ((MpegVersion)tmpMpegID' (tmpFrameHeader [2] >> 2) & 0x03);  			// Check for invalid frequency  			if (tmpFrequency == 0) {  				stream.Seek (-3' SeekOrigin.Current);  				continue;  			}  			int tmpSamplesPerFrame = GetSamplesPerFrame ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum);  			int tmpUsesPadding = (tmpFrameHeader [2] >> 1) & 0x01;  			double tmpFrameSizeConst = 125.0 * tmpSamplesPerFrame / tmpFrequency;  			int tmpPaddingSize = (tmpLayerNum == 3 ? 4 : 1);  			int tmpBitrateIndex = tmpFrameHeader [2] >> 4;  			// Check for invalid values  			if (tmpBitrateIndex < 1 || tmpBitrateIndex > 14 || tmpLayerNum == 0) {  				stream.Seek (-3' SeekOrigin.Current);  				continue;  			}  			int tmpFrameBitrate = GetBitrate ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum' tmpBitrateIndex);  			int tmpFrameSize = (int)(tmpFrameBitrate * tmpFrameSizeConst) + (tmpUsesPadding * tmpPaddingSize);  			_headerOffset = stream.Position - 4;  			if (tmpFrameSize < 8) {  				stream.Seek (-3' SeekOrigin.Current);  				continue;  			}  			// 7/21/05 - Check for 0x00 or 0xFF at end of last frame  			// this sucks for tracks that start with silence  			if (_headerOffset >= 1 && !acceptNullSamples)// if (ftell(fp) >= 5)  			 {  				stream.Seek (-5' SeekOrigin.Current);  				byte tmpLastByte = stream.Read1 ();  				stream.Seek (4' SeekOrigin.Current);  				if (tmpFrameBitrate != 320 && (tmpLastByte == 0x00 || tmpLastByte == 0xFF)) {  					// 7/31/05  					// may be a valid frame - skip its contents to prevent false sync  					long tmpNewPosition = _headerOffset + tmpFrameSize;  					if (tmpFrameSize == 0)  						tmpNewPosition++;  					stream.Seek (tmpNewPosition' SeekOrigin.Begin);  					continue;  				}  			}  			/*if (BR == 0 || FrameSizeConst == 0)                         {                             startpos = HeaderOffset+1;                             fseek(fp' startpos' SEEK_SET);                             continue;                         }*/stream.Seek (_headerOffset + tmpFrameSize' SeekOrigin.Begin);  			if (stream.Read1 () == 0xFF) {  				fh1 = stream.Read1 ();  				fh2 = stream.Read1 ();  				if (tmpFrameHeader [1] == fh1 && (tmpFrameHeader [2] & 0x0D) == (fh2 & 0x0D)) {  					// header found  					break;  				}  			}  			stream.Seek (_headerOffset + 1' SeekOrigin.Begin);  			continue;  		}  	}  	_mpegVersion = (MpegVersion)((tmpFrameHeader [1] >> 3) & 0x03);  	_mpegLayer = (MpegLayer)((tmpFrameHeader [1] >> 1) & 0x03);  	_frequency = GetFrequency (_mpegVersion' (tmpFrameHeader [2] >> 2) & 0x03);  	if (_frequency == 0) {  		throw new InvalidDataException (String.Format ("'{0}'; cannot determine frequency"' path));  	}  	_isPrivate = ((tmpFrameHeader [2] & 0x01) == 0x01);  	_samplesPerFrame = GetSamplesPerFrame (_mpegVersion' _mpegLayer);  	_frameSizeConst = 125.0 * _samplesPerFrame / _frequency;  	_paddingSizeConst = (_mpegLayer == MpegLayer.Layer1 ? 4 : 1);  	_isCopyright = (((tmpFrameHeader [3] >> 3) & 0x01) == 0x01);  	_isOriginal = (((tmpFrameHeader [3] >> 2) & 0x01) == 0x01);  	//tmpModeExtension = (FH[3] >> 4) & 0x03; // not interested' only used in joint-stereo  	//_mpegEmphasis = (MpegEmphasis)(tmpFrameHeader[3] & 0x03);  	if ((tmpFrameHeader [3] >> 6) == 3)  		_channels = 1;  	// Single Channel  	else  		_channels = 2;  	// Read LAME Info Tag  	bool tmpHasLameInfoTag = false;  	stream.Seek (tmpID3v2TagSize + 36' SeekOrigin.Begin);  	Byte[] buf = stream.Read (4);  	if (ByteUtils.Compare (buf' INFO_MARKER))// CBR  	 {  		tmpHasLameInfoTag = true;  		_isVBR = false;  	} else if (ByteUtils.Compare (buf' XING_MARKER))// VBR  	 {  		tmpHasLameInfoTag = true;  		_isVBR = true;  	}  	if (tmpHasLameInfoTag) {  		stream.Seek (4' SeekOrigin.Current);  		int tmpFrames = stream.ReadInt32 ();  		uint tmpBytes = (uint)stream.ReadInt32 ();  		if (tmpFrames > 256 && tmpBytes > 50000) {  			decimal tmpBitrate = tmpBytes / 125.0m / (tmpFrames * _samplesPerFrame / (decimal)_frequency);  			if (tmpBitrate <= 320 && tmpBitrate >= 32) {  				_frames = tmpFrames;  				_bitrate = tmpBitrate;  				_totalSeconds = (tmpBytes / 125.0m) / _bitrate;  			}  		}  	}  	// TODO: Take these 2 lines out  	/*fs.Position = 0;                 CalculateBitrate(fs' null);*/if (calculateBitrate) {  		if (_bitrate == 0 || _isVBR == null || _frames == 0 || _totalSeconds == 0) {  			stream.Position = 0;  			CalculateBitrate (stream' null);  		}  	}  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: using (FileStream stream = File.Open (path' FileMode.Open' FileAccess.Read' FileShare.Read)) {  	int tmpID3v2TagSize = ID3v2.GetTagSize (stream);  	stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  	byte[] tmpFrameHeader = new byte[4];  	bool acceptNullSamples = false;  	while (true) {  		int tmpByte = stream.ReadByte ();  		// keep as ReadByte  		while (tmpByte != 0xFF && tmpByte != -1) {  			tmpByte = stream.ReadByte ();  			// keep as ReadByte  		}  		if (tmpByte == -1) {  			if (acceptNullSamples) {  				throw new InvalidDataException (string.Format ("'{0}': Can't find frame sync"' path));  			}  			stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  			acceptNullSamples = true;  			continue;  		}  		tmpFrameHeader [0] = (byte)tmpByte;  		// Get frame header  		if (stream.Read (tmpFrameHeader' 1' 3) != 3) {  			throw new InvalidDataException (string.Format ("'{0}': Invalid MPEG file; end of stream reached"' path));  		}  		// No sync  		if ((tmpFrameHeader [1] >> 5) != 0x07 || ((tmpFrameHeader [1] >> 1) & 0x03) == 0)// 2/18/05 - ignore reserved layer  		 {  			stream.Seek (-3' SeekOrigin.Current);  		} else if (tmpFrameHeader [1] == 0xFF || ((tmpFrameHeader [1] >> 3) & 0x03) == 1)// 2/19/05 - more bad data  		 {  			stream.Seek (-3' SeekOrigin.Current);  		} else {  			int tmpMpegID = (tmpFrameHeader [1] >> 3) & 0x03;  			int tmpLayerNum = (tmpFrameHeader [1] >> 1) & 0x03;  			int tmpFrequency = GetFrequency ((MpegVersion)tmpMpegID' (tmpFrameHeader [2] >> 2) & 0x03);  			// Check for invalid frequency  			if (tmpFrequency == 0) {  				stream.Seek (-3' SeekOrigin.Current);  				continue;  			}  			int tmpSamplesPerFrame = GetSamplesPerFrame ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum);  			int tmpUsesPadding = (tmpFrameHeader [2] >> 1) & 0x01;  			double tmpFrameSizeConst = 125.0 * tmpSamplesPerFrame / tmpFrequency;  			int tmpPaddingSize = (tmpLayerNum == 3 ? 4 : 1);  			int tmpBitrateIndex = tmpFrameHeader [2] >> 4;  			// Check for invalid values  			if (tmpBitrateIndex < 1 || tmpBitrateIndex > 14 || tmpLayerNum == 0) {  				stream.Seek (-3' SeekOrigin.Current);  				continue;  			}  			int tmpFrameBitrate = GetBitrate ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum' tmpBitrateIndex);  			int tmpFrameSize = (int)(tmpFrameBitrate * tmpFrameSizeConst) + (tmpUsesPadding * tmpPaddingSize);  			_headerOffset = stream.Position - 4;  			if (tmpFrameSize < 8) {  				stream.Seek (-3' SeekOrigin.Current);  				continue;  			}  			// 7/21/05 - Check for 0x00 or 0xFF at end of last frame  			// this sucks for tracks that start with silence  			if (_headerOffset >= 1 && !acceptNullSamples)// if (ftell(fp) >= 5)  			 {  				stream.Seek (-5' SeekOrigin.Current);  				byte tmpLastByte = stream.Read1 ();  				stream.Seek (4' SeekOrigin.Current);  				if (tmpFrameBitrate != 320 && (tmpLastByte == 0x00 || tmpLastByte == 0xFF)) {  					// 7/31/05  					// may be a valid frame - skip its contents to prevent false sync  					long tmpNewPosition = _headerOffset + tmpFrameSize;  					if (tmpFrameSize == 0)  						tmpNewPosition++;  					stream.Seek (tmpNewPosition' SeekOrigin.Begin);  					continue;  				}  			}  			/*if (BR == 0 || FrameSizeConst == 0)                         {                             startpos = HeaderOffset+1;                             fseek(fp' startpos' SEEK_SET);                             continue;                         }*/stream.Seek (_headerOffset + tmpFrameSize' SeekOrigin.Begin);  			if (stream.Read1 () == 0xFF) {  				fh1 = stream.Read1 ();  				fh2 = stream.Read1 ();  				if (tmpFrameHeader [1] == fh1 && (tmpFrameHeader [2] & 0x0D) == (fh2 & 0x0D)) {  					// header found  					break;  				}  			}  			stream.Seek (_headerOffset + 1' SeekOrigin.Begin);  			continue;  		}  	}  	_mpegVersion = (MpegVersion)((tmpFrameHeader [1] >> 3) & 0x03);  	_mpegLayer = (MpegLayer)((tmpFrameHeader [1] >> 1) & 0x03);  	_frequency = GetFrequency (_mpegVersion' (tmpFrameHeader [2] >> 2) & 0x03);  	if (_frequency == 0) {  		throw new InvalidDataException (String.Format ("'{0}'; cannot determine frequency"' path));  	}  	_isPrivate = ((tmpFrameHeader [2] & 0x01) == 0x01);  	_samplesPerFrame = GetSamplesPerFrame (_mpegVersion' _mpegLayer);  	_frameSizeConst = 125.0 * _samplesPerFrame / _frequency;  	_paddingSizeConst = (_mpegLayer == MpegLayer.Layer1 ? 4 : 1);  	_isCopyright = (((tmpFrameHeader [3] >> 3) & 0x01) == 0x01);  	_isOriginal = (((tmpFrameHeader [3] >> 2) & 0x01) == 0x01);  	//tmpModeExtension = (FH[3] >> 4) & 0x03; // not interested' only used in joint-stereo  	//_mpegEmphasis = (MpegEmphasis)(tmpFrameHeader[3] & 0x03);  	if ((tmpFrameHeader [3] >> 6) == 3)  		_channels = 1;  	// Single Channel  	else  		_channels = 2;  	// Read LAME Info Tag  	bool tmpHasLameInfoTag = false;  	stream.Seek (tmpID3v2TagSize + 36' SeekOrigin.Begin);  	Byte[] buf = stream.Read (4);  	if (ByteUtils.Compare (buf' INFO_MARKER))// CBR  	 {  		tmpHasLameInfoTag = true;  		_isVBR = false;  	} else if (ByteUtils.Compare (buf' XING_MARKER))// VBR  	 {  		tmpHasLameInfoTag = true;  		_isVBR = true;  	}  	if (tmpHasLameInfoTag) {  		stream.Seek (4' SeekOrigin.Current);  		int tmpFrames = stream.ReadInt32 ();  		uint tmpBytes = (uint)stream.ReadInt32 ();  		if (tmpFrames > 256 && tmpBytes > 50000) {  			decimal tmpBitrate = tmpBytes / 125.0m / (tmpFrames * _samplesPerFrame / (decimal)_frequency);  			if (tmpBitrate <= 320 && tmpBitrate >= 32) {  				_frames = tmpFrames;  				_bitrate = tmpBitrate;  				_totalSeconds = (tmpBytes / 125.0m) / _bitrate;  			}  		}  	}  	// TODO: Take these 2 lines out  	/*fs.Position = 0;                 CalculateBitrate(fs' null);*/if (calculateBitrate) {  		if (_bitrate == 0 || _isVBR == null || _frames == 0 || _totalSeconds == 0) {  			stream.Position = 0;  			CalculateBitrate (stream' null);  		}  	}  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: using (FileStream stream = File.Open (path' FileMode.Open' FileAccess.Read' FileShare.Read)) {  	int tmpID3v2TagSize = ID3v2.GetTagSize (stream);  	stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  	byte[] tmpFrameHeader = new byte[4];  	bool acceptNullSamples = false;  	while (true) {  		int tmpByte = stream.ReadByte ();  		// keep as ReadByte  		while (tmpByte != 0xFF && tmpByte != -1) {  			tmpByte = stream.ReadByte ();  			// keep as ReadByte  		}  		if (tmpByte == -1) {  			if (acceptNullSamples) {  				throw new InvalidDataException (string.Format ("'{0}': Can't find frame sync"' path));  			}  			stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  			acceptNullSamples = true;  			continue;  		}  		tmpFrameHeader [0] = (byte)tmpByte;  		// Get frame header  		if (stream.Read (tmpFrameHeader' 1' 3) != 3) {  			throw new InvalidDataException (string.Format ("'{0}': Invalid MPEG file; end of stream reached"' path));  		}  		// No sync  		if ((tmpFrameHeader [1] >> 5) != 0x07 || ((tmpFrameHeader [1] >> 1) & 0x03) == 0)// 2/18/05 - ignore reserved layer  		 {  			stream.Seek (-3' SeekOrigin.Current);  		} else if (tmpFrameHeader [1] == 0xFF || ((tmpFrameHeader [1] >> 3) & 0x03) == 1)// 2/19/05 - more bad data  		 {  			stream.Seek (-3' SeekOrigin.Current);  		} else {  			int tmpMpegID = (tmpFrameHeader [1] >> 3) & 0x03;  			int tmpLayerNum = (tmpFrameHeader [1] >> 1) & 0x03;  			int tmpFrequency = GetFrequency ((MpegVersion)tmpMpegID' (tmpFrameHeader [2] >> 2) & 0x03);  			// Check for invalid frequency  			if (tmpFrequency == 0) {  				stream.Seek (-3' SeekOrigin.Current);  				continue;  			}  			int tmpSamplesPerFrame = GetSamplesPerFrame ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum);  			int tmpUsesPadding = (tmpFrameHeader [2] >> 1) & 0x01;  			double tmpFrameSizeConst = 125.0 * tmpSamplesPerFrame / tmpFrequency;  			int tmpPaddingSize = (tmpLayerNum == 3 ? 4 : 1);  			int tmpBitrateIndex = tmpFrameHeader [2] >> 4;  			// Check for invalid values  			if (tmpBitrateIndex < 1 || tmpBitrateIndex > 14 || tmpLayerNum == 0) {  				stream.Seek (-3' SeekOrigin.Current);  				continue;  			}  			int tmpFrameBitrate = GetBitrate ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum' tmpBitrateIndex);  			int tmpFrameSize = (int)(tmpFrameBitrate * tmpFrameSizeConst) + (tmpUsesPadding * tmpPaddingSize);  			_headerOffset = stream.Position - 4;  			if (tmpFrameSize < 8) {  				stream.Seek (-3' SeekOrigin.Current);  				continue;  			}  			// 7/21/05 - Check for 0x00 or 0xFF at end of last frame  			// this sucks for tracks that start with silence  			if (_headerOffset >= 1 && !acceptNullSamples)// if (ftell(fp) >= 5)  			 {  				stream.Seek (-5' SeekOrigin.Current);  				byte tmpLastByte = stream.Read1 ();  				stream.Seek (4' SeekOrigin.Current);  				if (tmpFrameBitrate != 320 && (tmpLastByte == 0x00 || tmpLastByte == 0xFF)) {  					// 7/31/05  					// may be a valid frame - skip its contents to prevent false sync  					long tmpNewPosition = _headerOffset + tmpFrameSize;  					if (tmpFrameSize == 0)  						tmpNewPosition++;  					stream.Seek (tmpNewPosition' SeekOrigin.Begin);  					continue;  				}  			}  			/*if (BR == 0 || FrameSizeConst == 0)                         {                             startpos = HeaderOffset+1;                             fseek(fp' startpos' SEEK_SET);                             continue;                         }*/stream.Seek (_headerOffset + tmpFrameSize' SeekOrigin.Begin);  			if (stream.Read1 () == 0xFF) {  				fh1 = stream.Read1 ();  				fh2 = stream.Read1 ();  				if (tmpFrameHeader [1] == fh1 && (tmpFrameHeader [2] & 0x0D) == (fh2 & 0x0D)) {  					// header found  					break;  				}  			}  			stream.Seek (_headerOffset + 1' SeekOrigin.Begin);  			continue;  		}  	}  	_mpegVersion = (MpegVersion)((tmpFrameHeader [1] >> 3) & 0x03);  	_mpegLayer = (MpegLayer)((tmpFrameHeader [1] >> 1) & 0x03);  	_frequency = GetFrequency (_mpegVersion' (tmpFrameHeader [2] >> 2) & 0x03);  	if (_frequency == 0) {  		throw new InvalidDataException (String.Format ("'{0}'; cannot determine frequency"' path));  	}  	_isPrivate = ((tmpFrameHeader [2] & 0x01) == 0x01);  	_samplesPerFrame = GetSamplesPerFrame (_mpegVersion' _mpegLayer);  	_frameSizeConst = 125.0 * _samplesPerFrame / _frequency;  	_paddingSizeConst = (_mpegLayer == MpegLayer.Layer1 ? 4 : 1);  	_isCopyright = (((tmpFrameHeader [3] >> 3) & 0x01) == 0x01);  	_isOriginal = (((tmpFrameHeader [3] >> 2) & 0x01) == 0x01);  	//tmpModeExtension = (FH[3] >> 4) & 0x03; // not interested' only used in joint-stereo  	//_mpegEmphasis = (MpegEmphasis)(tmpFrameHeader[3] & 0x03);  	if ((tmpFrameHeader [3] >> 6) == 3)  		_channels = 1;  	// Single Channel  	else  		_channels = 2;  	// Read LAME Info Tag  	bool tmpHasLameInfoTag = false;  	stream.Seek (tmpID3v2TagSize + 36' SeekOrigin.Begin);  	Byte[] buf = stream.Read (4);  	if (ByteUtils.Compare (buf' INFO_MARKER))// CBR  	 {  		tmpHasLameInfoTag = true;  		_isVBR = false;  	} else if (ByteUtils.Compare (buf' XING_MARKER))// VBR  	 {  		tmpHasLameInfoTag = true;  		_isVBR = true;  	}  	if (tmpHasLameInfoTag) {  		stream.Seek (4' SeekOrigin.Current);  		int tmpFrames = stream.ReadInt32 ();  		uint tmpBytes = (uint)stream.ReadInt32 ();  		if (tmpFrames > 256 && tmpBytes > 50000) {  			decimal tmpBitrate = tmpBytes / 125.0m / (tmpFrames * _samplesPerFrame / (decimal)_frequency);  			if (tmpBitrate <= 320 && tmpBitrate >= 32) {  				_frames = tmpFrames;  				_bitrate = tmpBitrate;  				_totalSeconds = (tmpBytes / 125.0m) / _bitrate;  			}  		}  	}  	// TODO: Take these 2 lines out  	/*fs.Position = 0;                 CalculateBitrate(fs' null);*/if (calculateBitrate) {  		if (_bitrate == 0 || _isVBR == null || _frames == 0 || _totalSeconds == 0) {  			stream.Position = 0;  			CalculateBitrate (stream' null);  		}  	}  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: using (FileStream stream = File.Open (path' FileMode.Open' FileAccess.Read' FileShare.Read)) {  	int tmpID3v2TagSize = ID3v2.GetTagSize (stream);  	stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  	byte[] tmpFrameHeader = new byte[4];  	bool acceptNullSamples = false;  	while (true) {  		int tmpByte = stream.ReadByte ();  		// keep as ReadByte  		while (tmpByte != 0xFF && tmpByte != -1) {  			tmpByte = stream.ReadByte ();  			// keep as ReadByte  		}  		if (tmpByte == -1) {  			if (acceptNullSamples) {  				throw new InvalidDataException (string.Format ("'{0}': Can't find frame sync"' path));  			}  			stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  			acceptNullSamples = true;  			continue;  		}  		tmpFrameHeader [0] = (byte)tmpByte;  		// Get frame header  		if (stream.Read (tmpFrameHeader' 1' 3) != 3) {  			throw new InvalidDataException (string.Format ("'{0}': Invalid MPEG file; end of stream reached"' path));  		}  		// No sync  		if ((tmpFrameHeader [1] >> 5) != 0x07 || ((tmpFrameHeader [1] >> 1) & 0x03) == 0)// 2/18/05 - ignore reserved layer  		 {  			stream.Seek (-3' SeekOrigin.Current);  		} else if (tmpFrameHeader [1] == 0xFF || ((tmpFrameHeader [1] >> 3) & 0x03) == 1)// 2/19/05 - more bad data  		 {  			stream.Seek (-3' SeekOrigin.Current);  		} else {  			int tmpMpegID = (tmpFrameHeader [1] >> 3) & 0x03;  			int tmpLayerNum = (tmpFrameHeader [1] >> 1) & 0x03;  			int tmpFrequency = GetFrequency ((MpegVersion)tmpMpegID' (tmpFrameHeader [2] >> 2) & 0x03);  			// Check for invalid frequency  			if (tmpFrequency == 0) {  				stream.Seek (-3' SeekOrigin.Current);  				continue;  			}  			int tmpSamplesPerFrame = GetSamplesPerFrame ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum);  			int tmpUsesPadding = (tmpFrameHeader [2] >> 1) & 0x01;  			double tmpFrameSizeConst = 125.0 * tmpSamplesPerFrame / tmpFrequency;  			int tmpPaddingSize = (tmpLayerNum == 3 ? 4 : 1);  			int tmpBitrateIndex = tmpFrameHeader [2] >> 4;  			// Check for invalid values  			if (tmpBitrateIndex < 1 || tmpBitrateIndex > 14 || tmpLayerNum == 0) {  				stream.Seek (-3' SeekOrigin.Current);  				continue;  			}  			int tmpFrameBitrate = GetBitrate ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum' tmpBitrateIndex);  			int tmpFrameSize = (int)(tmpFrameBitrate * tmpFrameSizeConst) + (tmpUsesPadding * tmpPaddingSize);  			_headerOffset = stream.Position - 4;  			if (tmpFrameSize < 8) {  				stream.Seek (-3' SeekOrigin.Current);  				continue;  			}  			// 7/21/05 - Check for 0x00 or 0xFF at end of last frame  			// this sucks for tracks that start with silence  			if (_headerOffset >= 1 && !acceptNullSamples)// if (ftell(fp) >= 5)  			 {  				stream.Seek (-5' SeekOrigin.Current);  				byte tmpLastByte = stream.Read1 ();  				stream.Seek (4' SeekOrigin.Current);  				if (tmpFrameBitrate != 320 && (tmpLastByte == 0x00 || tmpLastByte == 0xFF)) {  					// 7/31/05  					// may be a valid frame - skip its contents to prevent false sync  					long tmpNewPosition = _headerOffset + tmpFrameSize;  					if (tmpFrameSize == 0)  						tmpNewPosition++;  					stream.Seek (tmpNewPosition' SeekOrigin.Begin);  					continue;  				}  			}  			/*if (BR == 0 || FrameSizeConst == 0)                         {                             startpos = HeaderOffset+1;                             fseek(fp' startpos' SEEK_SET);                             continue;                         }*/stream.Seek (_headerOffset + tmpFrameSize' SeekOrigin.Begin);  			if (stream.Read1 () == 0xFF) {  				fh1 = stream.Read1 ();  				fh2 = stream.Read1 ();  				if (tmpFrameHeader [1] == fh1 && (tmpFrameHeader [2] & 0x0D) == (fh2 & 0x0D)) {  					// header found  					break;  				}  			}  			stream.Seek (_headerOffset + 1' SeekOrigin.Begin);  			continue;  		}  	}  	_mpegVersion = (MpegVersion)((tmpFrameHeader [1] >> 3) & 0x03);  	_mpegLayer = (MpegLayer)((tmpFrameHeader [1] >> 1) & 0x03);  	_frequency = GetFrequency (_mpegVersion' (tmpFrameHeader [2] >> 2) & 0x03);  	if (_frequency == 0) {  		throw new InvalidDataException (String.Format ("'{0}'; cannot determine frequency"' path));  	}  	_isPrivate = ((tmpFrameHeader [2] & 0x01) == 0x01);  	_samplesPerFrame = GetSamplesPerFrame (_mpegVersion' _mpegLayer);  	_frameSizeConst = 125.0 * _samplesPerFrame / _frequency;  	_paddingSizeConst = (_mpegLayer == MpegLayer.Layer1 ? 4 : 1);  	_isCopyright = (((tmpFrameHeader [3] >> 3) & 0x01) == 0x01);  	_isOriginal = (((tmpFrameHeader [3] >> 2) & 0x01) == 0x01);  	//tmpModeExtension = (FH[3] >> 4) & 0x03; // not interested' only used in joint-stereo  	//_mpegEmphasis = (MpegEmphasis)(tmpFrameHeader[3] & 0x03);  	if ((tmpFrameHeader [3] >> 6) == 3)  		_channels = 1;  	// Single Channel  	else  		_channels = 2;  	// Read LAME Info Tag  	bool tmpHasLameInfoTag = false;  	stream.Seek (tmpID3v2TagSize + 36' SeekOrigin.Begin);  	Byte[] buf = stream.Read (4);  	if (ByteUtils.Compare (buf' INFO_MARKER))// CBR  	 {  		tmpHasLameInfoTag = true;  		_isVBR = false;  	} else if (ByteUtils.Compare (buf' XING_MARKER))// VBR  	 {  		tmpHasLameInfoTag = true;  		_isVBR = true;  	}  	if (tmpHasLameInfoTag) {  		stream.Seek (4' SeekOrigin.Current);  		int tmpFrames = stream.ReadInt32 ();  		uint tmpBytes = (uint)stream.ReadInt32 ();  		if (tmpFrames > 256 && tmpBytes > 50000) {  			decimal tmpBitrate = tmpBytes / 125.0m / (tmpFrames * _samplesPerFrame / (decimal)_frequency);  			if (tmpBitrate <= 320 && tmpBitrate >= 32) {  				_frames = tmpFrames;  				_bitrate = tmpBitrate;  				_totalSeconds = (tmpBytes / 125.0m) / _bitrate;  			}  		}  	}  	// TODO: Take these 2 lines out  	/*fs.Position = 0;                 CalculateBitrate(fs' null);*/if (calculateBitrate) {  		if (_bitrate == 0 || _isVBR == null || _frames == 0 || _totalSeconds == 0) {  			stream.Position = 0;  			CalculateBitrate (stream' null);  		}  	}  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: using (FileStream stream = File.Open (path' FileMode.Open' FileAccess.Read' FileShare.Read)) {  	int tmpID3v2TagSize = ID3v2.GetTagSize (stream);  	stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  	byte[] tmpFrameHeader = new byte[4];  	bool acceptNullSamples = false;  	while (true) {  		int tmpByte = stream.ReadByte ();  		// keep as ReadByte  		while (tmpByte != 0xFF && tmpByte != -1) {  			tmpByte = stream.ReadByte ();  			// keep as ReadByte  		}  		if (tmpByte == -1) {  			if (acceptNullSamples) {  				throw new InvalidDataException (string.Format ("'{0}': Can't find frame sync"' path));  			}  			stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  			acceptNullSamples = true;  			continue;  		}  		tmpFrameHeader [0] = (byte)tmpByte;  		// Get frame header  		if (stream.Read (tmpFrameHeader' 1' 3) != 3) {  			throw new InvalidDataException (string.Format ("'{0}': Invalid MPEG file; end of stream reached"' path));  		}  		// No sync  		if ((tmpFrameHeader [1] >> 5) != 0x07 || ((tmpFrameHeader [1] >> 1) & 0x03) == 0)// 2/18/05 - ignore reserved layer  		 {  			stream.Seek (-3' SeekOrigin.Current);  		} else if (tmpFrameHeader [1] == 0xFF || ((tmpFrameHeader [1] >> 3) & 0x03) == 1)// 2/19/05 - more bad data  		 {  			stream.Seek (-3' SeekOrigin.Current);  		} else {  			int tmpMpegID = (tmpFrameHeader [1] >> 3) & 0x03;  			int tmpLayerNum = (tmpFrameHeader [1] >> 1) & 0x03;  			int tmpFrequency = GetFrequency ((MpegVersion)tmpMpegID' (tmpFrameHeader [2] >> 2) & 0x03);  			// Check for invalid frequency  			if (tmpFrequency == 0) {  				stream.Seek (-3' SeekOrigin.Current);  				continue;  			}  			int tmpSamplesPerFrame = GetSamplesPerFrame ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum);  			int tmpUsesPadding = (tmpFrameHeader [2] >> 1) & 0x01;  			double tmpFrameSizeConst = 125.0 * tmpSamplesPerFrame / tmpFrequency;  			int tmpPaddingSize = (tmpLayerNum == 3 ? 4 : 1);  			int tmpBitrateIndex = tmpFrameHeader [2] >> 4;  			// Check for invalid values  			if (tmpBitrateIndex < 1 || tmpBitrateIndex > 14 || tmpLayerNum == 0) {  				stream.Seek (-3' SeekOrigin.Current);  				continue;  			}  			int tmpFrameBitrate = GetBitrate ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum' tmpBitrateIndex);  			int tmpFrameSize = (int)(tmpFrameBitrate * tmpFrameSizeConst) + (tmpUsesPadding * tmpPaddingSize);  			_headerOffset = stream.Position - 4;  			if (tmpFrameSize < 8) {  				stream.Seek (-3' SeekOrigin.Current);  				continue;  			}  			// 7/21/05 - Check for 0x00 or 0xFF at end of last frame  			// this sucks for tracks that start with silence  			if (_headerOffset >= 1 && !acceptNullSamples)// if (ftell(fp) >= 5)  			 {  				stream.Seek (-5' SeekOrigin.Current);  				byte tmpLastByte = stream.Read1 ();  				stream.Seek (4' SeekOrigin.Current);  				if (tmpFrameBitrate != 320 && (tmpLastByte == 0x00 || tmpLastByte == 0xFF)) {  					// 7/31/05  					// may be a valid frame - skip its contents to prevent false sync  					long tmpNewPosition = _headerOffset + tmpFrameSize;  					if (tmpFrameSize == 0)  						tmpNewPosition++;  					stream.Seek (tmpNewPosition' SeekOrigin.Begin);  					continue;  				}  			}  			/*if (BR == 0 || FrameSizeConst == 0)                         {                             startpos = HeaderOffset+1;                             fseek(fp' startpos' SEEK_SET);                             continue;                         }*/stream.Seek (_headerOffset + tmpFrameSize' SeekOrigin.Begin);  			if (stream.Read1 () == 0xFF) {  				fh1 = stream.Read1 ();  				fh2 = stream.Read1 ();  				if (tmpFrameHeader [1] == fh1 && (tmpFrameHeader [2] & 0x0D) == (fh2 & 0x0D)) {  					// header found  					break;  				}  			}  			stream.Seek (_headerOffset + 1' SeekOrigin.Begin);  			continue;  		}  	}  	_mpegVersion = (MpegVersion)((tmpFrameHeader [1] >> 3) & 0x03);  	_mpegLayer = (MpegLayer)((tmpFrameHeader [1] >> 1) & 0x03);  	_frequency = GetFrequency (_mpegVersion' (tmpFrameHeader [2] >> 2) & 0x03);  	if (_frequency == 0) {  		throw new InvalidDataException (String.Format ("'{0}'; cannot determine frequency"' path));  	}  	_isPrivate = ((tmpFrameHeader [2] & 0x01) == 0x01);  	_samplesPerFrame = GetSamplesPerFrame (_mpegVersion' _mpegLayer);  	_frameSizeConst = 125.0 * _samplesPerFrame / _frequency;  	_paddingSizeConst = (_mpegLayer == MpegLayer.Layer1 ? 4 : 1);  	_isCopyright = (((tmpFrameHeader [3] >> 3) & 0x01) == 0x01);  	_isOriginal = (((tmpFrameHeader [3] >> 2) & 0x01) == 0x01);  	//tmpModeExtension = (FH[3] >> 4) & 0x03; // not interested' only used in joint-stereo  	//_mpegEmphasis = (MpegEmphasis)(tmpFrameHeader[3] & 0x03);  	if ((tmpFrameHeader [3] >> 6) == 3)  		_channels = 1;  	// Single Channel  	else  		_channels = 2;  	// Read LAME Info Tag  	bool tmpHasLameInfoTag = false;  	stream.Seek (tmpID3v2TagSize + 36' SeekOrigin.Begin);  	Byte[] buf = stream.Read (4);  	if (ByteUtils.Compare (buf' INFO_MARKER))// CBR  	 {  		tmpHasLameInfoTag = true;  		_isVBR = false;  	} else if (ByteUtils.Compare (buf' XING_MARKER))// VBR  	 {  		tmpHasLameInfoTag = true;  		_isVBR = true;  	}  	if (tmpHasLameInfoTag) {  		stream.Seek (4' SeekOrigin.Current);  		int tmpFrames = stream.ReadInt32 ();  		uint tmpBytes = (uint)stream.ReadInt32 ();  		if (tmpFrames > 256 && tmpBytes > 50000) {  			decimal tmpBitrate = tmpBytes / 125.0m / (tmpFrames * _samplesPerFrame / (decimal)_frequency);  			if (tmpBitrate <= 320 && tmpBitrate >= 32) {  				_frames = tmpFrames;  				_bitrate = tmpBitrate;  				_totalSeconds = (tmpBytes / 125.0m) / _bitrate;  			}  		}  	}  	// TODO: Take these 2 lines out  	/*fs.Position = 0;                 CalculateBitrate(fs' null);*/if (calculateBitrate) {  		if (_bitrate == 0 || _isVBR == null || _frames == 0 || _totalSeconds == 0) {  			stream.Position = 0;  			CalculateBitrate (stream' null);  		}  	}  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: using (FileStream stream = File.Open (path' FileMode.Open' FileAccess.Read' FileShare.Read)) {  	int tmpID3v2TagSize = ID3v2.GetTagSize (stream);  	stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  	byte[] tmpFrameHeader = new byte[4];  	bool acceptNullSamples = false;  	while (true) {  		int tmpByte = stream.ReadByte ();  		// keep as ReadByte  		while (tmpByte != 0xFF && tmpByte != -1) {  			tmpByte = stream.ReadByte ();  			// keep as ReadByte  		}  		if (tmpByte == -1) {  			if (acceptNullSamples) {  				throw new InvalidDataException (string.Format ("'{0}': Can't find frame sync"' path));  			}  			stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  			acceptNullSamples = true;  			continue;  		}  		tmpFrameHeader [0] = (byte)tmpByte;  		// Get frame header  		if (stream.Read (tmpFrameHeader' 1' 3) != 3) {  			throw new InvalidDataException (string.Format ("'{0}': Invalid MPEG file; end of stream reached"' path));  		}  		// No sync  		if ((tmpFrameHeader [1] >> 5) != 0x07 || ((tmpFrameHeader [1] >> 1) & 0x03) == 0)// 2/18/05 - ignore reserved layer  		 {  			stream.Seek (-3' SeekOrigin.Current);  		} else if (tmpFrameHeader [1] == 0xFF || ((tmpFrameHeader [1] >> 3) & 0x03) == 1)// 2/19/05 - more bad data  		 {  			stream.Seek (-3' SeekOrigin.Current);  		} else {  			int tmpMpegID = (tmpFrameHeader [1] >> 3) & 0x03;  			int tmpLayerNum = (tmpFrameHeader [1] >> 1) & 0x03;  			int tmpFrequency = GetFrequency ((MpegVersion)tmpMpegID' (tmpFrameHeader [2] >> 2) & 0x03);  			// Check for invalid frequency  			if (tmpFrequency == 0) {  				stream.Seek (-3' SeekOrigin.Current);  				continue;  			}  			int tmpSamplesPerFrame = GetSamplesPerFrame ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum);  			int tmpUsesPadding = (tmpFrameHeader [2] >> 1) & 0x01;  			double tmpFrameSizeConst = 125.0 * tmpSamplesPerFrame / tmpFrequency;  			int tmpPaddingSize = (tmpLayerNum == 3 ? 4 : 1);  			int tmpBitrateIndex = tmpFrameHeader [2] >> 4;  			// Check for invalid values  			if (tmpBitrateIndex < 1 || tmpBitrateIndex > 14 || tmpLayerNum == 0) {  				stream.Seek (-3' SeekOrigin.Current);  				continue;  			}  			int tmpFrameBitrate = GetBitrate ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum' tmpBitrateIndex);  			int tmpFrameSize = (int)(tmpFrameBitrate * tmpFrameSizeConst) + (tmpUsesPadding * tmpPaddingSize);  			_headerOffset = stream.Position - 4;  			if (tmpFrameSize < 8) {  				stream.Seek (-3' SeekOrigin.Current);  				continue;  			}  			// 7/21/05 - Check for 0x00 or 0xFF at end of last frame  			// this sucks for tracks that start with silence  			if (_headerOffset >= 1 && !acceptNullSamples)// if (ftell(fp) >= 5)  			 {  				stream.Seek (-5' SeekOrigin.Current);  				byte tmpLastByte = stream.Read1 ();  				stream.Seek (4' SeekOrigin.Current);  				if (tmpFrameBitrate != 320 && (tmpLastByte == 0x00 || tmpLastByte == 0xFF)) {  					// 7/31/05  					// may be a valid frame - skip its contents to prevent false sync  					long tmpNewPosition = _headerOffset + tmpFrameSize;  					if (tmpFrameSize == 0)  						tmpNewPosition++;  					stream.Seek (tmpNewPosition' SeekOrigin.Begin);  					continue;  				}  			}  			/*if (BR == 0 || FrameSizeConst == 0)                         {                             startpos = HeaderOffset+1;                             fseek(fp' startpos' SEEK_SET);                             continue;                         }*/stream.Seek (_headerOffset + tmpFrameSize' SeekOrigin.Begin);  			if (stream.Read1 () == 0xFF) {  				fh1 = stream.Read1 ();  				fh2 = stream.Read1 ();  				if (tmpFrameHeader [1] == fh1 && (tmpFrameHeader [2] & 0x0D) == (fh2 & 0x0D)) {  					// header found  					break;  				}  			}  			stream.Seek (_headerOffset + 1' SeekOrigin.Begin);  			continue;  		}  	}  	_mpegVersion = (MpegVersion)((tmpFrameHeader [1] >> 3) & 0x03);  	_mpegLayer = (MpegLayer)((tmpFrameHeader [1] >> 1) & 0x03);  	_frequency = GetFrequency (_mpegVersion' (tmpFrameHeader [2] >> 2) & 0x03);  	if (_frequency == 0) {  		throw new InvalidDataException (String.Format ("'{0}'; cannot determine frequency"' path));  	}  	_isPrivate = ((tmpFrameHeader [2] & 0x01) == 0x01);  	_samplesPerFrame = GetSamplesPerFrame (_mpegVersion' _mpegLayer);  	_frameSizeConst = 125.0 * _samplesPerFrame / _frequency;  	_paddingSizeConst = (_mpegLayer == MpegLayer.Layer1 ? 4 : 1);  	_isCopyright = (((tmpFrameHeader [3] >> 3) & 0x01) == 0x01);  	_isOriginal = (((tmpFrameHeader [3] >> 2) & 0x01) == 0x01);  	//tmpModeExtension = (FH[3] >> 4) & 0x03; // not interested' only used in joint-stereo  	//_mpegEmphasis = (MpegEmphasis)(tmpFrameHeader[3] & 0x03);  	if ((tmpFrameHeader [3] >> 6) == 3)  		_channels = 1;  	// Single Channel  	else  		_channels = 2;  	// Read LAME Info Tag  	bool tmpHasLameInfoTag = false;  	stream.Seek (tmpID3v2TagSize + 36' SeekOrigin.Begin);  	Byte[] buf = stream.Read (4);  	if (ByteUtils.Compare (buf' INFO_MARKER))// CBR  	 {  		tmpHasLameInfoTag = true;  		_isVBR = false;  	} else if (ByteUtils.Compare (buf' XING_MARKER))// VBR  	 {  		tmpHasLameInfoTag = true;  		_isVBR = true;  	}  	if (tmpHasLameInfoTag) {  		stream.Seek (4' SeekOrigin.Current);  		int tmpFrames = stream.ReadInt32 ();  		uint tmpBytes = (uint)stream.ReadInt32 ();  		if (tmpFrames > 256 && tmpBytes > 50000) {  			decimal tmpBitrate = tmpBytes / 125.0m / (tmpFrames * _samplesPerFrame / (decimal)_frequency);  			if (tmpBitrate <= 320 && tmpBitrate >= 32) {  				_frames = tmpFrames;  				_bitrate = tmpBitrate;  				_totalSeconds = (tmpBytes / 125.0m) / _bitrate;  			}  		}  	}  	// TODO: Take these 2 lines out  	/*fs.Position = 0;                 CalculateBitrate(fs' null);*/if (calculateBitrate) {  		if (_bitrate == 0 || _isVBR == null || _frames == 0 || _totalSeconds == 0) {  			stream.Position = 0;  			CalculateBitrate (stream' null);  		}  	}  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: using (FileStream stream = File.Open (path' FileMode.Open' FileAccess.Read' FileShare.Read)) {  	int tmpID3v2TagSize = ID3v2.GetTagSize (stream);  	stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  	byte[] tmpFrameHeader = new byte[4];  	bool acceptNullSamples = false;  	while (true) {  		int tmpByte = stream.ReadByte ();  		// keep as ReadByte  		while (tmpByte != 0xFF && tmpByte != -1) {  			tmpByte = stream.ReadByte ();  			// keep as ReadByte  		}  		if (tmpByte == -1) {  			if (acceptNullSamples) {  				throw new InvalidDataException (string.Format ("'{0}': Can't find frame sync"' path));  			}  			stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  			acceptNullSamples = true;  			continue;  		}  		tmpFrameHeader [0] = (byte)tmpByte;  		// Get frame header  		if (stream.Read (tmpFrameHeader' 1' 3) != 3) {  			throw new InvalidDataException (string.Format ("'{0}': Invalid MPEG file; end of stream reached"' path));  		}  		// No sync  		if ((tmpFrameHeader [1] >> 5) != 0x07 || ((tmpFrameHeader [1] >> 1) & 0x03) == 0)// 2/18/05 - ignore reserved layer  		 {  			stream.Seek (-3' SeekOrigin.Current);  		} else if (tmpFrameHeader [1] == 0xFF || ((tmpFrameHeader [1] >> 3) & 0x03) == 1)// 2/19/05 - more bad data  		 {  			stream.Seek (-3' SeekOrigin.Current);  		} else {  			int tmpMpegID = (tmpFrameHeader [1] >> 3) & 0x03;  			int tmpLayerNum = (tmpFrameHeader [1] >> 1) & 0x03;  			int tmpFrequency = GetFrequency ((MpegVersion)tmpMpegID' (tmpFrameHeader [2] >> 2) & 0x03);  			// Check for invalid frequency  			if (tmpFrequency == 0) {  				stream.Seek (-3' SeekOrigin.Current);  				continue;  			}  			int tmpSamplesPerFrame = GetSamplesPerFrame ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum);  			int tmpUsesPadding = (tmpFrameHeader [2] >> 1) & 0x01;  			double tmpFrameSizeConst = 125.0 * tmpSamplesPerFrame / tmpFrequency;  			int tmpPaddingSize = (tmpLayerNum == 3 ? 4 : 1);  			int tmpBitrateIndex = tmpFrameHeader [2] >> 4;  			// Check for invalid values  			if (tmpBitrateIndex < 1 || tmpBitrateIndex > 14 || tmpLayerNum == 0) {  				stream.Seek (-3' SeekOrigin.Current);  				continue;  			}  			int tmpFrameBitrate = GetBitrate ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum' tmpBitrateIndex);  			int tmpFrameSize = (int)(tmpFrameBitrate * tmpFrameSizeConst) + (tmpUsesPadding * tmpPaddingSize);  			_headerOffset = stream.Position - 4;  			if (tmpFrameSize < 8) {  				stream.Seek (-3' SeekOrigin.Current);  				continue;  			}  			// 7/21/05 - Check for 0x00 or 0xFF at end of last frame  			// this sucks for tracks that start with silence  			if (_headerOffset >= 1 && !acceptNullSamples)// if (ftell(fp) >= 5)  			 {  				stream.Seek (-5' SeekOrigin.Current);  				byte tmpLastByte = stream.Read1 ();  				stream.Seek (4' SeekOrigin.Current);  				if (tmpFrameBitrate != 320 && (tmpLastByte == 0x00 || tmpLastByte == 0xFF)) {  					// 7/31/05  					// may be a valid frame - skip its contents to prevent false sync  					long tmpNewPosition = _headerOffset + tmpFrameSize;  					if (tmpFrameSize == 0)  						tmpNewPosition++;  					stream.Seek (tmpNewPosition' SeekOrigin.Begin);  					continue;  				}  			}  			/*if (BR == 0 || FrameSizeConst == 0)                         {                             startpos = HeaderOffset+1;                             fseek(fp' startpos' SEEK_SET);                             continue;                         }*/stream.Seek (_headerOffset + tmpFrameSize' SeekOrigin.Begin);  			if (stream.Read1 () == 0xFF) {  				fh1 = stream.Read1 ();  				fh2 = stream.Read1 ();  				if (tmpFrameHeader [1] == fh1 && (tmpFrameHeader [2] & 0x0D) == (fh2 & 0x0D)) {  					// header found  					break;  				}  			}  			stream.Seek (_headerOffset + 1' SeekOrigin.Begin);  			continue;  		}  	}  	_mpegVersion = (MpegVersion)((tmpFrameHeader [1] >> 3) & 0x03);  	_mpegLayer = (MpegLayer)((tmpFrameHeader [1] >> 1) & 0x03);  	_frequency = GetFrequency (_mpegVersion' (tmpFrameHeader [2] >> 2) & 0x03);  	if (_frequency == 0) {  		throw new InvalidDataException (String.Format ("'{0}'; cannot determine frequency"' path));  	}  	_isPrivate = ((tmpFrameHeader [2] & 0x01) == 0x01);  	_samplesPerFrame = GetSamplesPerFrame (_mpegVersion' _mpegLayer);  	_frameSizeConst = 125.0 * _samplesPerFrame / _frequency;  	_paddingSizeConst = (_mpegLayer == MpegLayer.Layer1 ? 4 : 1);  	_isCopyright = (((tmpFrameHeader [3] >> 3) & 0x01) == 0x01);  	_isOriginal = (((tmpFrameHeader [3] >> 2) & 0x01) == 0x01);  	//tmpModeExtension = (FH[3] >> 4) & 0x03; // not interested' only used in joint-stereo  	//_mpegEmphasis = (MpegEmphasis)(tmpFrameHeader[3] & 0x03);  	if ((tmpFrameHeader [3] >> 6) == 3)  		_channels = 1;  	// Single Channel  	else  		_channels = 2;  	// Read LAME Info Tag  	bool tmpHasLameInfoTag = false;  	stream.Seek (tmpID3v2TagSize + 36' SeekOrigin.Begin);  	Byte[] buf = stream.Read (4);  	if (ByteUtils.Compare (buf' INFO_MARKER))// CBR  	 {  		tmpHasLameInfoTag = true;  		_isVBR = false;  	} else if (ByteUtils.Compare (buf' XING_MARKER))// VBR  	 {  		tmpHasLameInfoTag = true;  		_isVBR = true;  	}  	if (tmpHasLameInfoTag) {  		stream.Seek (4' SeekOrigin.Current);  		int tmpFrames = stream.ReadInt32 ();  		uint tmpBytes = (uint)stream.ReadInt32 ();  		if (tmpFrames > 256 && tmpBytes > 50000) {  			decimal tmpBitrate = tmpBytes / 125.0m / (tmpFrames * _samplesPerFrame / (decimal)_frequency);  			if (tmpBitrate <= 320 && tmpBitrate >= 32) {  				_frames = tmpFrames;  				_bitrate = tmpBitrate;  				_totalSeconds = (tmpBytes / 125.0m) / _bitrate;  			}  		}  	}  	// TODO: Take these 2 lines out  	/*fs.Position = 0;                 CalculateBitrate(fs' null);*/if (calculateBitrate) {  		if (_bitrate == 0 || _isVBR == null || _frames == 0 || _totalSeconds == 0) {  			stream.Position = 0;  			CalculateBitrate (stream' null);  		}  	}  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: using (FileStream stream = File.Open (path' FileMode.Open' FileAccess.Read' FileShare.Read)) {  	int tmpID3v2TagSize = ID3v2.GetTagSize (stream);  	stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  	byte[] tmpFrameHeader = new byte[4];  	bool acceptNullSamples = false;  	while (true) {  		int tmpByte = stream.ReadByte ();  		// keep as ReadByte  		while (tmpByte != 0xFF && tmpByte != -1) {  			tmpByte = stream.ReadByte ();  			// keep as ReadByte  		}  		if (tmpByte == -1) {  			if (acceptNullSamples) {  				throw new InvalidDataException (string.Format ("'{0}': Can't find frame sync"' path));  			}  			stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  			acceptNullSamples = true;  			continue;  		}  		tmpFrameHeader [0] = (byte)tmpByte;  		// Get frame header  		if (stream.Read (tmpFrameHeader' 1' 3) != 3) {  			throw new InvalidDataException (string.Format ("'{0}': Invalid MPEG file; end of stream reached"' path));  		}  		// No sync  		if ((tmpFrameHeader [1] >> 5) != 0x07 || ((tmpFrameHeader [1] >> 1) & 0x03) == 0)// 2/18/05 - ignore reserved layer  		 {  			stream.Seek (-3' SeekOrigin.Current);  		} else if (tmpFrameHeader [1] == 0xFF || ((tmpFrameHeader [1] >> 3) & 0x03) == 1)// 2/19/05 - more bad data  		 {  			stream.Seek (-3' SeekOrigin.Current);  		} else {  			int tmpMpegID = (tmpFrameHeader [1] >> 3) & 0x03;  			int tmpLayerNum = (tmpFrameHeader [1] >> 1) & 0x03;  			int tmpFrequency = GetFrequency ((MpegVersion)tmpMpegID' (tmpFrameHeader [2] >> 2) & 0x03);  			// Check for invalid frequency  			if (tmpFrequency == 0) {  				stream.Seek (-3' SeekOrigin.Current);  				continue;  			}  			int tmpSamplesPerFrame = GetSamplesPerFrame ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum);  			int tmpUsesPadding = (tmpFrameHeader [2] >> 1) & 0x01;  			double tmpFrameSizeConst = 125.0 * tmpSamplesPerFrame / tmpFrequency;  			int tmpPaddingSize = (tmpLayerNum == 3 ? 4 : 1);  			int tmpBitrateIndex = tmpFrameHeader [2] >> 4;  			// Check for invalid values  			if (tmpBitrateIndex < 1 || tmpBitrateIndex > 14 || tmpLayerNum == 0) {  				stream.Seek (-3' SeekOrigin.Current);  				continue;  			}  			int tmpFrameBitrate = GetBitrate ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum' tmpBitrateIndex);  			int tmpFrameSize = (int)(tmpFrameBitrate * tmpFrameSizeConst) + (tmpUsesPadding * tmpPaddingSize);  			_headerOffset = stream.Position - 4;  			if (tmpFrameSize < 8) {  				stream.Seek (-3' SeekOrigin.Current);  				continue;  			}  			// 7/21/05 - Check for 0x00 or 0xFF at end of last frame  			// this sucks for tracks that start with silence  			if (_headerOffset >= 1 && !acceptNullSamples)// if (ftell(fp) >= 5)  			 {  				stream.Seek (-5' SeekOrigin.Current);  				byte tmpLastByte = stream.Read1 ();  				stream.Seek (4' SeekOrigin.Current);  				if (tmpFrameBitrate != 320 && (tmpLastByte == 0x00 || tmpLastByte == 0xFF)) {  					// 7/31/05  					// may be a valid frame - skip its contents to prevent false sync  					long tmpNewPosition = _headerOffset + tmpFrameSize;  					if (tmpFrameSize == 0)  						tmpNewPosition++;  					stream.Seek (tmpNewPosition' SeekOrigin.Begin);  					continue;  				}  			}  			/*if (BR == 0 || FrameSizeConst == 0)                         {                             startpos = HeaderOffset+1;                             fseek(fp' startpos' SEEK_SET);                             continue;                         }*/stream.Seek (_headerOffset + tmpFrameSize' SeekOrigin.Begin);  			if (stream.Read1 () == 0xFF) {  				fh1 = stream.Read1 ();  				fh2 = stream.Read1 ();  				if (tmpFrameHeader [1] == fh1 && (tmpFrameHeader [2] & 0x0D) == (fh2 & 0x0D)) {  					// header found  					break;  				}  			}  			stream.Seek (_headerOffset + 1' SeekOrigin.Begin);  			continue;  		}  	}  	_mpegVersion = (MpegVersion)((tmpFrameHeader [1] >> 3) & 0x03);  	_mpegLayer = (MpegLayer)((tmpFrameHeader [1] >> 1) & 0x03);  	_frequency = GetFrequency (_mpegVersion' (tmpFrameHeader [2] >> 2) & 0x03);  	if (_frequency == 0) {  		throw new InvalidDataException (String.Format ("'{0}'; cannot determine frequency"' path));  	}  	_isPrivate = ((tmpFrameHeader [2] & 0x01) == 0x01);  	_samplesPerFrame = GetSamplesPerFrame (_mpegVersion' _mpegLayer);  	_frameSizeConst = 125.0 * _samplesPerFrame / _frequency;  	_paddingSizeConst = (_mpegLayer == MpegLayer.Layer1 ? 4 : 1);  	_isCopyright = (((tmpFrameHeader [3] >> 3) & 0x01) == 0x01);  	_isOriginal = (((tmpFrameHeader [3] >> 2) & 0x01) == 0x01);  	//tmpModeExtension = (FH[3] >> 4) & 0x03; // not interested' only used in joint-stereo  	//_mpegEmphasis = (MpegEmphasis)(tmpFrameHeader[3] & 0x03);  	if ((tmpFrameHeader [3] >> 6) == 3)  		_channels = 1;  	// Single Channel  	else  		_channels = 2;  	// Read LAME Info Tag  	bool tmpHasLameInfoTag = false;  	stream.Seek (tmpID3v2TagSize + 36' SeekOrigin.Begin);  	Byte[] buf = stream.Read (4);  	if (ByteUtils.Compare (buf' INFO_MARKER))// CBR  	 {  		tmpHasLameInfoTag = true;  		_isVBR = false;  	} else if (ByteUtils.Compare (buf' XING_MARKER))// VBR  	 {  		tmpHasLameInfoTag = true;  		_isVBR = true;  	}  	if (tmpHasLameInfoTag) {  		stream.Seek (4' SeekOrigin.Current);  		int tmpFrames = stream.ReadInt32 ();  		uint tmpBytes = (uint)stream.ReadInt32 ();  		if (tmpFrames > 256 && tmpBytes > 50000) {  			decimal tmpBitrate = tmpBytes / 125.0m / (tmpFrames * _samplesPerFrame / (decimal)_frequency);  			if (tmpBitrate <= 320 && tmpBitrate >= 32) {  				_frames = tmpFrames;  				_bitrate = tmpBitrate;  				_totalSeconds = (tmpBytes / 125.0m) / _bitrate;  			}  		}  	}  	// TODO: Take these 2 lines out  	/*fs.Position = 0;                 CalculateBitrate(fs' null);*/if (calculateBitrate) {  		if (_bitrate == 0 || _isVBR == null || _frames == 0 || _totalSeconds == 0) {  			stream.Position = 0;  			CalculateBitrate (stream' null);  		}  	}  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: using (FileStream stream = File.Open (path' FileMode.Open' FileAccess.Read' FileShare.Read)) {  	int tmpID3v2TagSize = ID3v2.GetTagSize (stream);  	stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  	byte[] tmpFrameHeader = new byte[4];  	bool acceptNullSamples = false;  	while (true) {  		int tmpByte = stream.ReadByte ();  		// keep as ReadByte  		while (tmpByte != 0xFF && tmpByte != -1) {  			tmpByte = stream.ReadByte ();  			// keep as ReadByte  		}  		if (tmpByte == -1) {  			if (acceptNullSamples) {  				throw new InvalidDataException (string.Format ("'{0}': Can't find frame sync"' path));  			}  			stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  			acceptNullSamples = true;  			continue;  		}  		tmpFrameHeader [0] = (byte)tmpByte;  		// Get frame header  		if (stream.Read (tmpFrameHeader' 1' 3) != 3) {  			throw new InvalidDataException (string.Format ("'{0}': Invalid MPEG file; end of stream reached"' path));  		}  		// No sync  		if ((tmpFrameHeader [1] >> 5) != 0x07 || ((tmpFrameHeader [1] >> 1) & 0x03) == 0)// 2/18/05 - ignore reserved layer  		 {  			stream.Seek (-3' SeekOrigin.Current);  		} else if (tmpFrameHeader [1] == 0xFF || ((tmpFrameHeader [1] >> 3) & 0x03) == 1)// 2/19/05 - more bad data  		 {  			stream.Seek (-3' SeekOrigin.Current);  		} else {  			int tmpMpegID = (tmpFrameHeader [1] >> 3) & 0x03;  			int tmpLayerNum = (tmpFrameHeader [1] >> 1) & 0x03;  			int tmpFrequency = GetFrequency ((MpegVersion)tmpMpegID' (tmpFrameHeader [2] >> 2) & 0x03);  			// Check for invalid frequency  			if (tmpFrequency == 0) {  				stream.Seek (-3' SeekOrigin.Current);  				continue;  			}  			int tmpSamplesPerFrame = GetSamplesPerFrame ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum);  			int tmpUsesPadding = (tmpFrameHeader [2] >> 1) & 0x01;  			double tmpFrameSizeConst = 125.0 * tmpSamplesPerFrame / tmpFrequency;  			int tmpPaddingSize = (tmpLayerNum == 3 ? 4 : 1);  			int tmpBitrateIndex = tmpFrameHeader [2] >> 4;  			// Check for invalid values  			if (tmpBitrateIndex < 1 || tmpBitrateIndex > 14 || tmpLayerNum == 0) {  				stream.Seek (-3' SeekOrigin.Current);  				continue;  			}  			int tmpFrameBitrate = GetBitrate ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum' tmpBitrateIndex);  			int tmpFrameSize = (int)(tmpFrameBitrate * tmpFrameSizeConst) + (tmpUsesPadding * tmpPaddingSize);  			_headerOffset = stream.Position - 4;  			if (tmpFrameSize < 8) {  				stream.Seek (-3' SeekOrigin.Current);  				continue;  			}  			// 7/21/05 - Check for 0x00 or 0xFF at end of last frame  			// this sucks for tracks that start with silence  			if (_headerOffset >= 1 && !acceptNullSamples)// if (ftell(fp) >= 5)  			 {  				stream.Seek (-5' SeekOrigin.Current);  				byte tmpLastByte = stream.Read1 ();  				stream.Seek (4' SeekOrigin.Current);  				if (tmpFrameBitrate != 320 && (tmpLastByte == 0x00 || tmpLastByte == 0xFF)) {  					// 7/31/05  					// may be a valid frame - skip its contents to prevent false sync  					long tmpNewPosition = _headerOffset + tmpFrameSize;  					if (tmpFrameSize == 0)  						tmpNewPosition++;  					stream.Seek (tmpNewPosition' SeekOrigin.Begin);  					continue;  				}  			}  			/*if (BR == 0 || FrameSizeConst == 0)                         {                             startpos = HeaderOffset+1;                             fseek(fp' startpos' SEEK_SET);                             continue;                         }*/stream.Seek (_headerOffset + tmpFrameSize' SeekOrigin.Begin);  			if (stream.Read1 () == 0xFF) {  				fh1 = stream.Read1 ();  				fh2 = stream.Read1 ();  				if (tmpFrameHeader [1] == fh1 && (tmpFrameHeader [2] & 0x0D) == (fh2 & 0x0D)) {  					// header found  					break;  				}  			}  			stream.Seek (_headerOffset + 1' SeekOrigin.Begin);  			continue;  		}  	}  	_mpegVersion = (MpegVersion)((tmpFrameHeader [1] >> 3) & 0x03);  	_mpegLayer = (MpegLayer)((tmpFrameHeader [1] >> 1) & 0x03);  	_frequency = GetFrequency (_mpegVersion' (tmpFrameHeader [2] >> 2) & 0x03);  	if (_frequency == 0) {  		throw new InvalidDataException (String.Format ("'{0}'; cannot determine frequency"' path));  	}  	_isPrivate = ((tmpFrameHeader [2] & 0x01) == 0x01);  	_samplesPerFrame = GetSamplesPerFrame (_mpegVersion' _mpegLayer);  	_frameSizeConst = 125.0 * _samplesPerFrame / _frequency;  	_paddingSizeConst = (_mpegLayer == MpegLayer.Layer1 ? 4 : 1);  	_isCopyright = (((tmpFrameHeader [3] >> 3) & 0x01) == 0x01);  	_isOriginal = (((tmpFrameHeader [3] >> 2) & 0x01) == 0x01);  	//tmpModeExtension = (FH[3] >> 4) & 0x03; // not interested' only used in joint-stereo  	//_mpegEmphasis = (MpegEmphasis)(tmpFrameHeader[3] & 0x03);  	if ((tmpFrameHeader [3] >> 6) == 3)  		_channels = 1;  	// Single Channel  	else  		_channels = 2;  	// Read LAME Info Tag  	bool tmpHasLameInfoTag = false;  	stream.Seek (tmpID3v2TagSize + 36' SeekOrigin.Begin);  	Byte[] buf = stream.Read (4);  	if (ByteUtils.Compare (buf' INFO_MARKER))// CBR  	 {  		tmpHasLameInfoTag = true;  		_isVBR = false;  	} else if (ByteUtils.Compare (buf' XING_MARKER))// VBR  	 {  		tmpHasLameInfoTag = true;  		_isVBR = true;  	}  	if (tmpHasLameInfoTag) {  		stream.Seek (4' SeekOrigin.Current);  		int tmpFrames = stream.ReadInt32 ();  		uint tmpBytes = (uint)stream.ReadInt32 ();  		if (tmpFrames > 256 && tmpBytes > 50000) {  			decimal tmpBitrate = tmpBytes / 125.0m / (tmpFrames * _samplesPerFrame / (decimal)_frequency);  			if (tmpBitrate <= 320 && tmpBitrate >= 32) {  				_frames = tmpFrames;  				_bitrate = tmpBitrate;  				_totalSeconds = (tmpBytes / 125.0m) / _bitrate;  			}  		}  	}  	// TODO: Take these 2 lines out  	/*fs.Position = 0;                 CalculateBitrate(fs' null);*/if (calculateBitrate) {  		if (_bitrate == 0 || _isVBR == null || _frames == 0 || _totalSeconds == 0) {  			stream.Position = 0;  			CalculateBitrate (stream' null);  		}  	}  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: using (FileStream stream = File.Open (path' FileMode.Open' FileAccess.Read' FileShare.Read)) {  	int tmpID3v2TagSize = ID3v2.GetTagSize (stream);  	stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  	byte[] tmpFrameHeader = new byte[4];  	bool acceptNullSamples = false;  	while (true) {  		int tmpByte = stream.ReadByte ();  		// keep as ReadByte  		while (tmpByte != 0xFF && tmpByte != -1) {  			tmpByte = stream.ReadByte ();  			// keep as ReadByte  		}  		if (tmpByte == -1) {  			if (acceptNullSamples) {  				throw new InvalidDataException (string.Format ("'{0}': Can't find frame sync"' path));  			}  			stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  			acceptNullSamples = true;  			continue;  		}  		tmpFrameHeader [0] = (byte)tmpByte;  		// Get frame header  		if (stream.Read (tmpFrameHeader' 1' 3) != 3) {  			throw new InvalidDataException (string.Format ("'{0}': Invalid MPEG file; end of stream reached"' path));  		}  		// No sync  		if ((tmpFrameHeader [1] >> 5) != 0x07 || ((tmpFrameHeader [1] >> 1) & 0x03) == 0)// 2/18/05 - ignore reserved layer  		 {  			stream.Seek (-3' SeekOrigin.Current);  		} else if (tmpFrameHeader [1] == 0xFF || ((tmpFrameHeader [1] >> 3) & 0x03) == 1)// 2/19/05 - more bad data  		 {  			stream.Seek (-3' SeekOrigin.Current);  		} else {  			int tmpMpegID = (tmpFrameHeader [1] >> 3) & 0x03;  			int tmpLayerNum = (tmpFrameHeader [1] >> 1) & 0x03;  			int tmpFrequency = GetFrequency ((MpegVersion)tmpMpegID' (tmpFrameHeader [2] >> 2) & 0x03);  			// Check for invalid frequency  			if (tmpFrequency == 0) {  				stream.Seek (-3' SeekOrigin.Current);  				continue;  			}  			int tmpSamplesPerFrame = GetSamplesPerFrame ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum);  			int tmpUsesPadding = (tmpFrameHeader [2] >> 1) & 0x01;  			double tmpFrameSizeConst = 125.0 * tmpSamplesPerFrame / tmpFrequency;  			int tmpPaddingSize = (tmpLayerNum == 3 ? 4 : 1);  			int tmpBitrateIndex = tmpFrameHeader [2] >> 4;  			// Check for invalid values  			if (tmpBitrateIndex < 1 || tmpBitrateIndex > 14 || tmpLayerNum == 0) {  				stream.Seek (-3' SeekOrigin.Current);  				continue;  			}  			int tmpFrameBitrate = GetBitrate ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum' tmpBitrateIndex);  			int tmpFrameSize = (int)(tmpFrameBitrate * tmpFrameSizeConst) + (tmpUsesPadding * tmpPaddingSize);  			_headerOffset = stream.Position - 4;  			if (tmpFrameSize < 8) {  				stream.Seek (-3' SeekOrigin.Current);  				continue;  			}  			// 7/21/05 - Check for 0x00 or 0xFF at end of last frame  			// this sucks for tracks that start with silence  			if (_headerOffset >= 1 && !acceptNullSamples)// if (ftell(fp) >= 5)  			 {  				stream.Seek (-5' SeekOrigin.Current);  				byte tmpLastByte = stream.Read1 ();  				stream.Seek (4' SeekOrigin.Current);  				if (tmpFrameBitrate != 320 && (tmpLastByte == 0x00 || tmpLastByte == 0xFF)) {  					// 7/31/05  					// may be a valid frame - skip its contents to prevent false sync  					long tmpNewPosition = _headerOffset + tmpFrameSize;  					if (tmpFrameSize == 0)  						tmpNewPosition++;  					stream.Seek (tmpNewPosition' SeekOrigin.Begin);  					continue;  				}  			}  			/*if (BR == 0 || FrameSizeConst == 0)                         {                             startpos = HeaderOffset+1;                             fseek(fp' startpos' SEEK_SET);                             continue;                         }*/stream.Seek (_headerOffset + tmpFrameSize' SeekOrigin.Begin);  			if (stream.Read1 () == 0xFF) {  				fh1 = stream.Read1 ();  				fh2 = stream.Read1 ();  				if (tmpFrameHeader [1] == fh1 && (tmpFrameHeader [2] & 0x0D) == (fh2 & 0x0D)) {  					// header found  					break;  				}  			}  			stream.Seek (_headerOffset + 1' SeekOrigin.Begin);  			continue;  		}  	}  	_mpegVersion = (MpegVersion)((tmpFrameHeader [1] >> 3) & 0x03);  	_mpegLayer = (MpegLayer)((tmpFrameHeader [1] >> 1) & 0x03);  	_frequency = GetFrequency (_mpegVersion' (tmpFrameHeader [2] >> 2) & 0x03);  	if (_frequency == 0) {  		throw new InvalidDataException (String.Format ("'{0}'; cannot determine frequency"' path));  	}  	_isPrivate = ((tmpFrameHeader [2] & 0x01) == 0x01);  	_samplesPerFrame = GetSamplesPerFrame (_mpegVersion' _mpegLayer);  	_frameSizeConst = 125.0 * _samplesPerFrame / _frequency;  	_paddingSizeConst = (_mpegLayer == MpegLayer.Layer1 ? 4 : 1);  	_isCopyright = (((tmpFrameHeader [3] >> 3) & 0x01) == 0x01);  	_isOriginal = (((tmpFrameHeader [3] >> 2) & 0x01) == 0x01);  	//tmpModeExtension = (FH[3] >> 4) & 0x03; // not interested' only used in joint-stereo  	//_mpegEmphasis = (MpegEmphasis)(tmpFrameHeader[3] & 0x03);  	if ((tmpFrameHeader [3] >> 6) == 3)  		_channels = 1;  	// Single Channel  	else  		_channels = 2;  	// Read LAME Info Tag  	bool tmpHasLameInfoTag = false;  	stream.Seek (tmpID3v2TagSize + 36' SeekOrigin.Begin);  	Byte[] buf = stream.Read (4);  	if (ByteUtils.Compare (buf' INFO_MARKER))// CBR  	 {  		tmpHasLameInfoTag = true;  		_isVBR = false;  	} else if (ByteUtils.Compare (buf' XING_MARKER))// VBR  	 {  		tmpHasLameInfoTag = true;  		_isVBR = true;  	}  	if (tmpHasLameInfoTag) {  		stream.Seek (4' SeekOrigin.Current);  		int tmpFrames = stream.ReadInt32 ();  		uint tmpBytes = (uint)stream.ReadInt32 ();  		if (tmpFrames > 256 && tmpBytes > 50000) {  			decimal tmpBitrate = tmpBytes / 125.0m / (tmpFrames * _samplesPerFrame / (decimal)_frequency);  			if (tmpBitrate <= 320 && tmpBitrate >= 32) {  				_frames = tmpFrames;  				_bitrate = tmpBitrate;  				_totalSeconds = (tmpBytes / 125.0m) / _bitrate;  			}  		}  	}  	// TODO: Take these 2 lines out  	/*fs.Position = 0;                 CalculateBitrate(fs' null);*/if (calculateBitrate) {  		if (_bitrate == 0 || _isVBR == null || _frames == 0 || _totalSeconds == 0) {  			stream.Position = 0;  			CalculateBitrate (stream' null);  		}  	}  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: using (FileStream stream = File.Open (path' FileMode.Open' FileAccess.Read' FileShare.Read)) {  	int tmpID3v2TagSize = ID3v2.GetTagSize (stream);  	stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  	byte[] tmpFrameHeader = new byte[4];  	bool acceptNullSamples = false;  	while (true) {  		int tmpByte = stream.ReadByte ();  		// keep as ReadByte  		while (tmpByte != 0xFF && tmpByte != -1) {  			tmpByte = stream.ReadByte ();  			// keep as ReadByte  		}  		if (tmpByte == -1) {  			if (acceptNullSamples) {  				throw new InvalidDataException (string.Format ("'{0}': Can't find frame sync"' path));  			}  			stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  			acceptNullSamples = true;  			continue;  		}  		tmpFrameHeader [0] = (byte)tmpByte;  		// Get frame header  		if (stream.Read (tmpFrameHeader' 1' 3) != 3) {  			throw new InvalidDataException (string.Format ("'{0}': Invalid MPEG file; end of stream reached"' path));  		}  		// No sync  		if ((tmpFrameHeader [1] >> 5) != 0x07 || ((tmpFrameHeader [1] >> 1) & 0x03) == 0)// 2/18/05 - ignore reserved layer  		 {  			stream.Seek (-3' SeekOrigin.Current);  		} else if (tmpFrameHeader [1] == 0xFF || ((tmpFrameHeader [1] >> 3) & 0x03) == 1)// 2/19/05 - more bad data  		 {  			stream.Seek (-3' SeekOrigin.Current);  		} else {  			int tmpMpegID = (tmpFrameHeader [1] >> 3) & 0x03;  			int tmpLayerNum = (tmpFrameHeader [1] >> 1) & 0x03;  			int tmpFrequency = GetFrequency ((MpegVersion)tmpMpegID' (tmpFrameHeader [2] >> 2) & 0x03);  			// Check for invalid frequency  			if (tmpFrequency == 0) {  				stream.Seek (-3' SeekOrigin.Current);  				continue;  			}  			int tmpSamplesPerFrame = GetSamplesPerFrame ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum);  			int tmpUsesPadding = (tmpFrameHeader [2] >> 1) & 0x01;  			double tmpFrameSizeConst = 125.0 * tmpSamplesPerFrame / tmpFrequency;  			int tmpPaddingSize = (tmpLayerNum == 3 ? 4 : 1);  			int tmpBitrateIndex = tmpFrameHeader [2] >> 4;  			// Check for invalid values  			if (tmpBitrateIndex < 1 || tmpBitrateIndex > 14 || tmpLayerNum == 0) {  				stream.Seek (-3' SeekOrigin.Current);  				continue;  			}  			int tmpFrameBitrate = GetBitrate ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum' tmpBitrateIndex);  			int tmpFrameSize = (int)(tmpFrameBitrate * tmpFrameSizeConst) + (tmpUsesPadding * tmpPaddingSize);  			_headerOffset = stream.Position - 4;  			if (tmpFrameSize < 8) {  				stream.Seek (-3' SeekOrigin.Current);  				continue;  			}  			// 7/21/05 - Check for 0x00 or 0xFF at end of last frame  			// this sucks for tracks that start with silence  			if (_headerOffset >= 1 && !acceptNullSamples)// if (ftell(fp) >= 5)  			 {  				stream.Seek (-5' SeekOrigin.Current);  				byte tmpLastByte = stream.Read1 ();  				stream.Seek (4' SeekOrigin.Current);  				if (tmpFrameBitrate != 320 && (tmpLastByte == 0x00 || tmpLastByte == 0xFF)) {  					// 7/31/05  					// may be a valid frame - skip its contents to prevent false sync  					long tmpNewPosition = _headerOffset + tmpFrameSize;  					if (tmpFrameSize == 0)  						tmpNewPosition++;  					stream.Seek (tmpNewPosition' SeekOrigin.Begin);  					continue;  				}  			}  			/*if (BR == 0 || FrameSizeConst == 0)                         {                             startpos = HeaderOffset+1;                             fseek(fp' startpos' SEEK_SET);                             continue;                         }*/stream.Seek (_headerOffset + tmpFrameSize' SeekOrigin.Begin);  			if (stream.Read1 () == 0xFF) {  				fh1 = stream.Read1 ();  				fh2 = stream.Read1 ();  				if (tmpFrameHeader [1] == fh1 && (tmpFrameHeader [2] & 0x0D) == (fh2 & 0x0D)) {  					// header found  					break;  				}  			}  			stream.Seek (_headerOffset + 1' SeekOrigin.Begin);  			continue;  		}  	}  	_mpegVersion = (MpegVersion)((tmpFrameHeader [1] >> 3) & 0x03);  	_mpegLayer = (MpegLayer)((tmpFrameHeader [1] >> 1) & 0x03);  	_frequency = GetFrequency (_mpegVersion' (tmpFrameHeader [2] >> 2) & 0x03);  	if (_frequency == 0) {  		throw new InvalidDataException (String.Format ("'{0}'; cannot determine frequency"' path));  	}  	_isPrivate = ((tmpFrameHeader [2] & 0x01) == 0x01);  	_samplesPerFrame = GetSamplesPerFrame (_mpegVersion' _mpegLayer);  	_frameSizeConst = 125.0 * _samplesPerFrame / _frequency;  	_paddingSizeConst = (_mpegLayer == MpegLayer.Layer1 ? 4 : 1);  	_isCopyright = (((tmpFrameHeader [3] >> 3) & 0x01) == 0x01);  	_isOriginal = (((tmpFrameHeader [3] >> 2) & 0x01) == 0x01);  	//tmpModeExtension = (FH[3] >> 4) & 0x03; // not interested' only used in joint-stereo  	//_mpegEmphasis = (MpegEmphasis)(tmpFrameHeader[3] & 0x03);  	if ((tmpFrameHeader [3] >> 6) == 3)  		_channels = 1;  	// Single Channel  	else  		_channels = 2;  	// Read LAME Info Tag  	bool tmpHasLameInfoTag = false;  	stream.Seek (tmpID3v2TagSize + 36' SeekOrigin.Begin);  	Byte[] buf = stream.Read (4);  	if (ByteUtils.Compare (buf' INFO_MARKER))// CBR  	 {  		tmpHasLameInfoTag = true;  		_isVBR = false;  	} else if (ByteUtils.Compare (buf' XING_MARKER))// VBR  	 {  		tmpHasLameInfoTag = true;  		_isVBR = true;  	}  	if (tmpHasLameInfoTag) {  		stream.Seek (4' SeekOrigin.Current);  		int tmpFrames = stream.ReadInt32 ();  		uint tmpBytes = (uint)stream.ReadInt32 ();  		if (tmpFrames > 256 && tmpBytes > 50000) {  			decimal tmpBitrate = tmpBytes / 125.0m / (tmpFrames * _samplesPerFrame / (decimal)_frequency);  			if (tmpBitrate <= 320 && tmpBitrate >= 32) {  				_frames = tmpFrames;  				_bitrate = tmpBitrate;  				_totalSeconds = (tmpBytes / 125.0m) / _bitrate;  			}  		}  	}  	// TODO: Take these 2 lines out  	/*fs.Position = 0;                 CalculateBitrate(fs' null);*/if (calculateBitrate) {  		if (_bitrate == 0 || _isVBR == null || _frames == 0 || _totalSeconds == 0) {  			stream.Position = 0;  			CalculateBitrate (stream' null);  		}  	}  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: using (FileStream stream = File.Open (path' FileMode.Open' FileAccess.Read' FileShare.Read)) {  	int tmpID3v2TagSize = ID3v2.GetTagSize (stream);  	stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  	byte[] tmpFrameHeader = new byte[4];  	bool acceptNullSamples = false;  	while (true) {  		int tmpByte = stream.ReadByte ();  		// keep as ReadByte  		while (tmpByte != 0xFF && tmpByte != -1) {  			tmpByte = stream.ReadByte ();  			// keep as ReadByte  		}  		if (tmpByte == -1) {  			if (acceptNullSamples) {  				throw new InvalidDataException (string.Format ("'{0}': Can't find frame sync"' path));  			}  			stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  			acceptNullSamples = true;  			continue;  		}  		tmpFrameHeader [0] = (byte)tmpByte;  		// Get frame header  		if (stream.Read (tmpFrameHeader' 1' 3) != 3) {  			throw new InvalidDataException (string.Format ("'{0}': Invalid MPEG file; end of stream reached"' path));  		}  		// No sync  		if ((tmpFrameHeader [1] >> 5) != 0x07 || ((tmpFrameHeader [1] >> 1) & 0x03) == 0)// 2/18/05 - ignore reserved layer  		 {  			stream.Seek (-3' SeekOrigin.Current);  		} else if (tmpFrameHeader [1] == 0xFF || ((tmpFrameHeader [1] >> 3) & 0x03) == 1)// 2/19/05 - more bad data  		 {  			stream.Seek (-3' SeekOrigin.Current);  		} else {  			int tmpMpegID = (tmpFrameHeader [1] >> 3) & 0x03;  			int tmpLayerNum = (tmpFrameHeader [1] >> 1) & 0x03;  			int tmpFrequency = GetFrequency ((MpegVersion)tmpMpegID' (tmpFrameHeader [2] >> 2) & 0x03);  			// Check for invalid frequency  			if (tmpFrequency == 0) {  				stream.Seek (-3' SeekOrigin.Current);  				continue;  			}  			int tmpSamplesPerFrame = GetSamplesPerFrame ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum);  			int tmpUsesPadding = (tmpFrameHeader [2] >> 1) & 0x01;  			double tmpFrameSizeConst = 125.0 * tmpSamplesPerFrame / tmpFrequency;  			int tmpPaddingSize = (tmpLayerNum == 3 ? 4 : 1);  			int tmpBitrateIndex = tmpFrameHeader [2] >> 4;  			// Check for invalid values  			if (tmpBitrateIndex < 1 || tmpBitrateIndex > 14 || tmpLayerNum == 0) {  				stream.Seek (-3' SeekOrigin.Current);  				continue;  			}  			int tmpFrameBitrate = GetBitrate ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum' tmpBitrateIndex);  			int tmpFrameSize = (int)(tmpFrameBitrate * tmpFrameSizeConst) + (tmpUsesPadding * tmpPaddingSize);  			_headerOffset = stream.Position - 4;  			if (tmpFrameSize < 8) {  				stream.Seek (-3' SeekOrigin.Current);  				continue;  			}  			// 7/21/05 - Check for 0x00 or 0xFF at end of last frame  			// this sucks for tracks that start with silence  			if (_headerOffset >= 1 && !acceptNullSamples)// if (ftell(fp) >= 5)  			 {  				stream.Seek (-5' SeekOrigin.Current);  				byte tmpLastByte = stream.Read1 ();  				stream.Seek (4' SeekOrigin.Current);  				if (tmpFrameBitrate != 320 && (tmpLastByte == 0x00 || tmpLastByte == 0xFF)) {  					// 7/31/05  					// may be a valid frame - skip its contents to prevent false sync  					long tmpNewPosition = _headerOffset + tmpFrameSize;  					if (tmpFrameSize == 0)  						tmpNewPosition++;  					stream.Seek (tmpNewPosition' SeekOrigin.Begin);  					continue;  				}  			}  			/*if (BR == 0 || FrameSizeConst == 0)                         {                             startpos = HeaderOffset+1;                             fseek(fp' startpos' SEEK_SET);                             continue;                         }*/stream.Seek (_headerOffset + tmpFrameSize' SeekOrigin.Begin);  			if (stream.Read1 () == 0xFF) {  				fh1 = stream.Read1 ();  				fh2 = stream.Read1 ();  				if (tmpFrameHeader [1] == fh1 && (tmpFrameHeader [2] & 0x0D) == (fh2 & 0x0D)) {  					// header found  					break;  				}  			}  			stream.Seek (_headerOffset + 1' SeekOrigin.Begin);  			continue;  		}  	}  	_mpegVersion = (MpegVersion)((tmpFrameHeader [1] >> 3) & 0x03);  	_mpegLayer = (MpegLayer)((tmpFrameHeader [1] >> 1) & 0x03);  	_frequency = GetFrequency (_mpegVersion' (tmpFrameHeader [2] >> 2) & 0x03);  	if (_frequency == 0) {  		throw new InvalidDataException (String.Format ("'{0}'; cannot determine frequency"' path));  	}  	_isPrivate = ((tmpFrameHeader [2] & 0x01) == 0x01);  	_samplesPerFrame = GetSamplesPerFrame (_mpegVersion' _mpegLayer);  	_frameSizeConst = 125.0 * _samplesPerFrame / _frequency;  	_paddingSizeConst = (_mpegLayer == MpegLayer.Layer1 ? 4 : 1);  	_isCopyright = (((tmpFrameHeader [3] >> 3) & 0x01) == 0x01);  	_isOriginal = (((tmpFrameHeader [3] >> 2) & 0x01) == 0x01);  	//tmpModeExtension = (FH[3] >> 4) & 0x03; // not interested' only used in joint-stereo  	//_mpegEmphasis = (MpegEmphasis)(tmpFrameHeader[3] & 0x03);  	if ((tmpFrameHeader [3] >> 6) == 3)  		_channels = 1;  	// Single Channel  	else  		_channels = 2;  	// Read LAME Info Tag  	bool tmpHasLameInfoTag = false;  	stream.Seek (tmpID3v2TagSize + 36' SeekOrigin.Begin);  	Byte[] buf = stream.Read (4);  	if (ByteUtils.Compare (buf' INFO_MARKER))// CBR  	 {  		tmpHasLameInfoTag = true;  		_isVBR = false;  	} else if (ByteUtils.Compare (buf' XING_MARKER))// VBR  	 {  		tmpHasLameInfoTag = true;  		_isVBR = true;  	}  	if (tmpHasLameInfoTag) {  		stream.Seek (4' SeekOrigin.Current);  		int tmpFrames = stream.ReadInt32 ();  		uint tmpBytes = (uint)stream.ReadInt32 ();  		if (tmpFrames > 256 && tmpBytes > 50000) {  			decimal tmpBitrate = tmpBytes / 125.0m / (tmpFrames * _samplesPerFrame / (decimal)_frequency);  			if (tmpBitrate <= 320 && tmpBitrate >= 32) {  				_frames = tmpFrames;  				_bitrate = tmpBitrate;  				_totalSeconds = (tmpBytes / 125.0m) / _bitrate;  			}  		}  	}  	// TODO: Take these 2 lines out  	/*fs.Position = 0;                 CalculateBitrate(fs' null);*/if (calculateBitrate) {  		if (_bitrate == 0 || _isVBR == null || _frames == 0 || _totalSeconds == 0) {  			stream.Position = 0;  			CalculateBitrate (stream' null);  		}  	}  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: using (FileStream stream = File.Open (path' FileMode.Open' FileAccess.Read' FileShare.Read)) {  	int tmpID3v2TagSize = ID3v2.GetTagSize (stream);  	stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  	byte[] tmpFrameHeader = new byte[4];  	bool acceptNullSamples = false;  	while (true) {  		int tmpByte = stream.ReadByte ();  		// keep as ReadByte  		while (tmpByte != 0xFF && tmpByte != -1) {  			tmpByte = stream.ReadByte ();  			// keep as ReadByte  		}  		if (tmpByte == -1) {  			if (acceptNullSamples) {  				throw new InvalidDataException (string.Format ("'{0}': Can't find frame sync"' path));  			}  			stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  			acceptNullSamples = true;  			continue;  		}  		tmpFrameHeader [0] = (byte)tmpByte;  		// Get frame header  		if (stream.Read (tmpFrameHeader' 1' 3) != 3) {  			throw new InvalidDataException (string.Format ("'{0}': Invalid MPEG file; end of stream reached"' path));  		}  		// No sync  		if ((tmpFrameHeader [1] >> 5) != 0x07 || ((tmpFrameHeader [1] >> 1) & 0x03) == 0)// 2/18/05 - ignore reserved layer  		 {  			stream.Seek (-3' SeekOrigin.Current);  		} else if (tmpFrameHeader [1] == 0xFF || ((tmpFrameHeader [1] >> 3) & 0x03) == 1)// 2/19/05 - more bad data  		 {  			stream.Seek (-3' SeekOrigin.Current);  		} else {  			int tmpMpegID = (tmpFrameHeader [1] >> 3) & 0x03;  			int tmpLayerNum = (tmpFrameHeader [1] >> 1) & 0x03;  			int tmpFrequency = GetFrequency ((MpegVersion)tmpMpegID' (tmpFrameHeader [2] >> 2) & 0x03);  			// Check for invalid frequency  			if (tmpFrequency == 0) {  				stream.Seek (-3' SeekOrigin.Current);  				continue;  			}  			int tmpSamplesPerFrame = GetSamplesPerFrame ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum);  			int tmpUsesPadding = (tmpFrameHeader [2] >> 1) & 0x01;  			double tmpFrameSizeConst = 125.0 * tmpSamplesPerFrame / tmpFrequency;  			int tmpPaddingSize = (tmpLayerNum == 3 ? 4 : 1);  			int tmpBitrateIndex = tmpFrameHeader [2] >> 4;  			// Check for invalid values  			if (tmpBitrateIndex < 1 || tmpBitrateIndex > 14 || tmpLayerNum == 0) {  				stream.Seek (-3' SeekOrigin.Current);  				continue;  			}  			int tmpFrameBitrate = GetBitrate ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum' tmpBitrateIndex);  			int tmpFrameSize = (int)(tmpFrameBitrate * tmpFrameSizeConst) + (tmpUsesPadding * tmpPaddingSize);  			_headerOffset = stream.Position - 4;  			if (tmpFrameSize < 8) {  				stream.Seek (-3' SeekOrigin.Current);  				continue;  			}  			// 7/21/05 - Check for 0x00 or 0xFF at end of last frame  			// this sucks for tracks that start with silence  			if (_headerOffset >= 1 && !acceptNullSamples)// if (ftell(fp) >= 5)  			 {  				stream.Seek (-5' SeekOrigin.Current);  				byte tmpLastByte = stream.Read1 ();  				stream.Seek (4' SeekOrigin.Current);  				if (tmpFrameBitrate != 320 && (tmpLastByte == 0x00 || tmpLastByte == 0xFF)) {  					// 7/31/05  					// may be a valid frame - skip its contents to prevent false sync  					long tmpNewPosition = _headerOffset + tmpFrameSize;  					if (tmpFrameSize == 0)  						tmpNewPosition++;  					stream.Seek (tmpNewPosition' SeekOrigin.Begin);  					continue;  				}  			}  			/*if (BR == 0 || FrameSizeConst == 0)                         {                             startpos = HeaderOffset+1;                             fseek(fp' startpos' SEEK_SET);                             continue;                         }*/stream.Seek (_headerOffset + tmpFrameSize' SeekOrigin.Begin);  			if (stream.Read1 () == 0xFF) {  				fh1 = stream.Read1 ();  				fh2 = stream.Read1 ();  				if (tmpFrameHeader [1] == fh1 && (tmpFrameHeader [2] & 0x0D) == (fh2 & 0x0D)) {  					// header found  					break;  				}  			}  			stream.Seek (_headerOffset + 1' SeekOrigin.Begin);  			continue;  		}  	}  	_mpegVersion = (MpegVersion)((tmpFrameHeader [1] >> 3) & 0x03);  	_mpegLayer = (MpegLayer)((tmpFrameHeader [1] >> 1) & 0x03);  	_frequency = GetFrequency (_mpegVersion' (tmpFrameHeader [2] >> 2) & 0x03);  	if (_frequency == 0) {  		throw new InvalidDataException (String.Format ("'{0}'; cannot determine frequency"' path));  	}  	_isPrivate = ((tmpFrameHeader [2] & 0x01) == 0x01);  	_samplesPerFrame = GetSamplesPerFrame (_mpegVersion' _mpegLayer);  	_frameSizeConst = 125.0 * _samplesPerFrame / _frequency;  	_paddingSizeConst = (_mpegLayer == MpegLayer.Layer1 ? 4 : 1);  	_isCopyright = (((tmpFrameHeader [3] >> 3) & 0x01) == 0x01);  	_isOriginal = (((tmpFrameHeader [3] >> 2) & 0x01) == 0x01);  	//tmpModeExtension = (FH[3] >> 4) & 0x03; // not interested' only used in joint-stereo  	//_mpegEmphasis = (MpegEmphasis)(tmpFrameHeader[3] & 0x03);  	if ((tmpFrameHeader [3] >> 6) == 3)  		_channels = 1;  	// Single Channel  	else  		_channels = 2;  	// Read LAME Info Tag  	bool tmpHasLameInfoTag = false;  	stream.Seek (tmpID3v2TagSize + 36' SeekOrigin.Begin);  	Byte[] buf = stream.Read (4);  	if (ByteUtils.Compare (buf' INFO_MARKER))// CBR  	 {  		tmpHasLameInfoTag = true;  		_isVBR = false;  	} else if (ByteUtils.Compare (buf' XING_MARKER))// VBR  	 {  		tmpHasLameInfoTag = true;  		_isVBR = true;  	}  	if (tmpHasLameInfoTag) {  		stream.Seek (4' SeekOrigin.Current);  		int tmpFrames = stream.ReadInt32 ();  		uint tmpBytes = (uint)stream.ReadInt32 ();  		if (tmpFrames > 256 && tmpBytes > 50000) {  			decimal tmpBitrate = tmpBytes / 125.0m / (tmpFrames * _samplesPerFrame / (decimal)_frequency);  			if (tmpBitrate <= 320 && tmpBitrate >= 32) {  				_frames = tmpFrames;  				_bitrate = tmpBitrate;  				_totalSeconds = (tmpBytes / 125.0m) / _bitrate;  			}  		}  	}  	// TODO: Take these 2 lines out  	/*fs.Position = 0;                 CalculateBitrate(fs' null);*/if (calculateBitrate) {  		if (_bitrate == 0 || _isVBR == null || _frames == 0 || _totalSeconds == 0) {  			stream.Position = 0;  			CalculateBitrate (stream' null);  		}  	}  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: while (true) {  	int tmpByte = stream.ReadByte ();  	// keep as ReadByte  	while (tmpByte != 0xFF && tmpByte != -1) {  		tmpByte = stream.ReadByte ();  		// keep as ReadByte  	}  	if (tmpByte == -1) {  		if (acceptNullSamples) {  			throw new InvalidDataException (string.Format ("'{0}': Can't find frame sync"' path));  		}  		stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  		acceptNullSamples = true;  		continue;  	}  	tmpFrameHeader [0] = (byte)tmpByte;  	// Get frame header  	if (stream.Read (tmpFrameHeader' 1' 3) != 3) {  		throw new InvalidDataException (string.Format ("'{0}': Invalid MPEG file; end of stream reached"' path));  	}  	// No sync  	if ((tmpFrameHeader [1] >> 5) != 0x07 || ((tmpFrameHeader [1] >> 1) & 0x03) == 0)// 2/18/05 - ignore reserved layer  	 {  		stream.Seek (-3' SeekOrigin.Current);  	} else if (tmpFrameHeader [1] == 0xFF || ((tmpFrameHeader [1] >> 3) & 0x03) == 1)// 2/19/05 - more bad data  	 {  		stream.Seek (-3' SeekOrigin.Current);  	} else {  		int tmpMpegID = (tmpFrameHeader [1] >> 3) & 0x03;  		int tmpLayerNum = (tmpFrameHeader [1] >> 1) & 0x03;  		int tmpFrequency = GetFrequency ((MpegVersion)tmpMpegID' (tmpFrameHeader [2] >> 2) & 0x03);  		// Check for invalid frequency  		if (tmpFrequency == 0) {  			stream.Seek (-3' SeekOrigin.Current);  			continue;  		}  		int tmpSamplesPerFrame = GetSamplesPerFrame ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum);  		int tmpUsesPadding = (tmpFrameHeader [2] >> 1) & 0x01;  		double tmpFrameSizeConst = 125.0 * tmpSamplesPerFrame / tmpFrequency;  		int tmpPaddingSize = (tmpLayerNum == 3 ? 4 : 1);  		int tmpBitrateIndex = tmpFrameHeader [2] >> 4;  		// Check for invalid values  		if (tmpBitrateIndex < 1 || tmpBitrateIndex > 14 || tmpLayerNum == 0) {  			stream.Seek (-3' SeekOrigin.Current);  			continue;  		}  		int tmpFrameBitrate = GetBitrate ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum' tmpBitrateIndex);  		int tmpFrameSize = (int)(tmpFrameBitrate * tmpFrameSizeConst) + (tmpUsesPadding * tmpPaddingSize);  		_headerOffset = stream.Position - 4;  		if (tmpFrameSize < 8) {  			stream.Seek (-3' SeekOrigin.Current);  			continue;  		}  		// 7/21/05 - Check for 0x00 or 0xFF at end of last frame  		// this sucks for tracks that start with silence  		if (_headerOffset >= 1 && !acceptNullSamples)// if (ftell(fp) >= 5)  		 {  			stream.Seek (-5' SeekOrigin.Current);  			byte tmpLastByte = stream.Read1 ();  			stream.Seek (4' SeekOrigin.Current);  			if (tmpFrameBitrate != 320 && (tmpLastByte == 0x00 || tmpLastByte == 0xFF)) {  				// 7/31/05  				// may be a valid frame - skip its contents to prevent false sync  				long tmpNewPosition = _headerOffset + tmpFrameSize;  				if (tmpFrameSize == 0)  					tmpNewPosition++;  				stream.Seek (tmpNewPosition' SeekOrigin.Begin);  				continue;  			}  		}  		/*if (BR == 0 || FrameSizeConst == 0)                         {                             startpos = HeaderOffset+1;                             fseek(fp' startpos' SEEK_SET);                             continue;                         }*/stream.Seek (_headerOffset + tmpFrameSize' SeekOrigin.Begin);  		if (stream.Read1 () == 0xFF) {  			fh1 = stream.Read1 ();  			fh2 = stream.Read1 ();  			if (tmpFrameHeader [1] == fh1 && (tmpFrameHeader [2] & 0x0D) == (fh2 & 0x0D)) {  				// header found  				break;  			}  		}  		stream.Seek (_headerOffset + 1' SeekOrigin.Begin);  		continue;  	}  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: while (true) {  	int tmpByte = stream.ReadByte ();  	// keep as ReadByte  	while (tmpByte != 0xFF && tmpByte != -1) {  		tmpByte = stream.ReadByte ();  		// keep as ReadByte  	}  	if (tmpByte == -1) {  		if (acceptNullSamples) {  			throw new InvalidDataException (string.Format ("'{0}': Can't find frame sync"' path));  		}  		stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  		acceptNullSamples = true;  		continue;  	}  	tmpFrameHeader [0] = (byte)tmpByte;  	// Get frame header  	if (stream.Read (tmpFrameHeader' 1' 3) != 3) {  		throw new InvalidDataException (string.Format ("'{0}': Invalid MPEG file; end of stream reached"' path));  	}  	// No sync  	if ((tmpFrameHeader [1] >> 5) != 0x07 || ((tmpFrameHeader [1] >> 1) & 0x03) == 0)// 2/18/05 - ignore reserved layer  	 {  		stream.Seek (-3' SeekOrigin.Current);  	} else if (tmpFrameHeader [1] == 0xFF || ((tmpFrameHeader [1] >> 3) & 0x03) == 1)// 2/19/05 - more bad data  	 {  		stream.Seek (-3' SeekOrigin.Current);  	} else {  		int tmpMpegID = (tmpFrameHeader [1] >> 3) & 0x03;  		int tmpLayerNum = (tmpFrameHeader [1] >> 1) & 0x03;  		int tmpFrequency = GetFrequency ((MpegVersion)tmpMpegID' (tmpFrameHeader [2] >> 2) & 0x03);  		// Check for invalid frequency  		if (tmpFrequency == 0) {  			stream.Seek (-3' SeekOrigin.Current);  			continue;  		}  		int tmpSamplesPerFrame = GetSamplesPerFrame ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum);  		int tmpUsesPadding = (tmpFrameHeader [2] >> 1) & 0x01;  		double tmpFrameSizeConst = 125.0 * tmpSamplesPerFrame / tmpFrequency;  		int tmpPaddingSize = (tmpLayerNum == 3 ? 4 : 1);  		int tmpBitrateIndex = tmpFrameHeader [2] >> 4;  		// Check for invalid values  		if (tmpBitrateIndex < 1 || tmpBitrateIndex > 14 || tmpLayerNum == 0) {  			stream.Seek (-3' SeekOrigin.Current);  			continue;  		}  		int tmpFrameBitrate = GetBitrate ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum' tmpBitrateIndex);  		int tmpFrameSize = (int)(tmpFrameBitrate * tmpFrameSizeConst) + (tmpUsesPadding * tmpPaddingSize);  		_headerOffset = stream.Position - 4;  		if (tmpFrameSize < 8) {  			stream.Seek (-3' SeekOrigin.Current);  			continue;  		}  		// 7/21/05 - Check for 0x00 or 0xFF at end of last frame  		// this sucks for tracks that start with silence  		if (_headerOffset >= 1 && !acceptNullSamples)// if (ftell(fp) >= 5)  		 {  			stream.Seek (-5' SeekOrigin.Current);  			byte tmpLastByte = stream.Read1 ();  			stream.Seek (4' SeekOrigin.Current);  			if (tmpFrameBitrate != 320 && (tmpLastByte == 0x00 || tmpLastByte == 0xFF)) {  				// 7/31/05  				// may be a valid frame - skip its contents to prevent false sync  				long tmpNewPosition = _headerOffset + tmpFrameSize;  				if (tmpFrameSize == 0)  					tmpNewPosition++;  				stream.Seek (tmpNewPosition' SeekOrigin.Begin);  				continue;  			}  		}  		/*if (BR == 0 || FrameSizeConst == 0)                         {                             startpos = HeaderOffset+1;                             fseek(fp' startpos' SEEK_SET);                             continue;                         }*/stream.Seek (_headerOffset + tmpFrameSize' SeekOrigin.Begin);  		if (stream.Read1 () == 0xFF) {  			fh1 = stream.Read1 ();  			fh2 = stream.Read1 ();  			if (tmpFrameHeader [1] == fh1 && (tmpFrameHeader [2] & 0x0D) == (fh2 & 0x0D)) {  				// header found  				break;  			}  		}  		stream.Seek (_headerOffset + 1' SeekOrigin.Begin);  		continue;  	}  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: while (true) {  	int tmpByte = stream.ReadByte ();  	// keep as ReadByte  	while (tmpByte != 0xFF && tmpByte != -1) {  		tmpByte = stream.ReadByte ();  		// keep as ReadByte  	}  	if (tmpByte == -1) {  		if (acceptNullSamples) {  			throw new InvalidDataException (string.Format ("'{0}': Can't find frame sync"' path));  		}  		stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  		acceptNullSamples = true;  		continue;  	}  	tmpFrameHeader [0] = (byte)tmpByte;  	// Get frame header  	if (stream.Read (tmpFrameHeader' 1' 3) != 3) {  		throw new InvalidDataException (string.Format ("'{0}': Invalid MPEG file; end of stream reached"' path));  	}  	// No sync  	if ((tmpFrameHeader [1] >> 5) != 0x07 || ((tmpFrameHeader [1] >> 1) & 0x03) == 0)// 2/18/05 - ignore reserved layer  	 {  		stream.Seek (-3' SeekOrigin.Current);  	} else if (tmpFrameHeader [1] == 0xFF || ((tmpFrameHeader [1] >> 3) & 0x03) == 1)// 2/19/05 - more bad data  	 {  		stream.Seek (-3' SeekOrigin.Current);  	} else {  		int tmpMpegID = (tmpFrameHeader [1] >> 3) & 0x03;  		int tmpLayerNum = (tmpFrameHeader [1] >> 1) & 0x03;  		int tmpFrequency = GetFrequency ((MpegVersion)tmpMpegID' (tmpFrameHeader [2] >> 2) & 0x03);  		// Check for invalid frequency  		if (tmpFrequency == 0) {  			stream.Seek (-3' SeekOrigin.Current);  			continue;  		}  		int tmpSamplesPerFrame = GetSamplesPerFrame ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum);  		int tmpUsesPadding = (tmpFrameHeader [2] >> 1) & 0x01;  		double tmpFrameSizeConst = 125.0 * tmpSamplesPerFrame / tmpFrequency;  		int tmpPaddingSize = (tmpLayerNum == 3 ? 4 : 1);  		int tmpBitrateIndex = tmpFrameHeader [2] >> 4;  		// Check for invalid values  		if (tmpBitrateIndex < 1 || tmpBitrateIndex > 14 || tmpLayerNum == 0) {  			stream.Seek (-3' SeekOrigin.Current);  			continue;  		}  		int tmpFrameBitrate = GetBitrate ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum' tmpBitrateIndex);  		int tmpFrameSize = (int)(tmpFrameBitrate * tmpFrameSizeConst) + (tmpUsesPadding * tmpPaddingSize);  		_headerOffset = stream.Position - 4;  		if (tmpFrameSize < 8) {  			stream.Seek (-3' SeekOrigin.Current);  			continue;  		}  		// 7/21/05 - Check for 0x00 or 0xFF at end of last frame  		// this sucks for tracks that start with silence  		if (_headerOffset >= 1 && !acceptNullSamples)// if (ftell(fp) >= 5)  		 {  			stream.Seek (-5' SeekOrigin.Current);  			byte tmpLastByte = stream.Read1 ();  			stream.Seek (4' SeekOrigin.Current);  			if (tmpFrameBitrate != 320 && (tmpLastByte == 0x00 || tmpLastByte == 0xFF)) {  				// 7/31/05  				// may be a valid frame - skip its contents to prevent false sync  				long tmpNewPosition = _headerOffset + tmpFrameSize;  				if (tmpFrameSize == 0)  					tmpNewPosition++;  				stream.Seek (tmpNewPosition' SeekOrigin.Begin);  				continue;  			}  		}  		/*if (BR == 0 || FrameSizeConst == 0)                         {                             startpos = HeaderOffset+1;                             fseek(fp' startpos' SEEK_SET);                             continue;                         }*/stream.Seek (_headerOffset + tmpFrameSize' SeekOrigin.Begin);  		if (stream.Read1 () == 0xFF) {  			fh1 = stream.Read1 ();  			fh2 = stream.Read1 ();  			if (tmpFrameHeader [1] == fh1 && (tmpFrameHeader [2] & 0x0D) == (fh2 & 0x0D)) {  				// header found  				break;  			}  		}  		stream.Seek (_headerOffset + 1' SeekOrigin.Begin);  		continue;  	}  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: while (true) {  	int tmpByte = stream.ReadByte ();  	// keep as ReadByte  	while (tmpByte != 0xFF && tmpByte != -1) {  		tmpByte = stream.ReadByte ();  		// keep as ReadByte  	}  	if (tmpByte == -1) {  		if (acceptNullSamples) {  			throw new InvalidDataException (string.Format ("'{0}': Can't find frame sync"' path));  		}  		stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  		acceptNullSamples = true;  		continue;  	}  	tmpFrameHeader [0] = (byte)tmpByte;  	// Get frame header  	if (stream.Read (tmpFrameHeader' 1' 3) != 3) {  		throw new InvalidDataException (string.Format ("'{0}': Invalid MPEG file; end of stream reached"' path));  	}  	// No sync  	if ((tmpFrameHeader [1] >> 5) != 0x07 || ((tmpFrameHeader [1] >> 1) & 0x03) == 0)// 2/18/05 - ignore reserved layer  	 {  		stream.Seek (-3' SeekOrigin.Current);  	} else if (tmpFrameHeader [1] == 0xFF || ((tmpFrameHeader [1] >> 3) & 0x03) == 1)// 2/19/05 - more bad data  	 {  		stream.Seek (-3' SeekOrigin.Current);  	} else {  		int tmpMpegID = (tmpFrameHeader [1] >> 3) & 0x03;  		int tmpLayerNum = (tmpFrameHeader [1] >> 1) & 0x03;  		int tmpFrequency = GetFrequency ((MpegVersion)tmpMpegID' (tmpFrameHeader [2] >> 2) & 0x03);  		// Check for invalid frequency  		if (tmpFrequency == 0) {  			stream.Seek (-3' SeekOrigin.Current);  			continue;  		}  		int tmpSamplesPerFrame = GetSamplesPerFrame ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum);  		int tmpUsesPadding = (tmpFrameHeader [2] >> 1) & 0x01;  		double tmpFrameSizeConst = 125.0 * tmpSamplesPerFrame / tmpFrequency;  		int tmpPaddingSize = (tmpLayerNum == 3 ? 4 : 1);  		int tmpBitrateIndex = tmpFrameHeader [2] >> 4;  		// Check for invalid values  		if (tmpBitrateIndex < 1 || tmpBitrateIndex > 14 || tmpLayerNum == 0) {  			stream.Seek (-3' SeekOrigin.Current);  			continue;  		}  		int tmpFrameBitrate = GetBitrate ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum' tmpBitrateIndex);  		int tmpFrameSize = (int)(tmpFrameBitrate * tmpFrameSizeConst) + (tmpUsesPadding * tmpPaddingSize);  		_headerOffset = stream.Position - 4;  		if (tmpFrameSize < 8) {  			stream.Seek (-3' SeekOrigin.Current);  			continue;  		}  		// 7/21/05 - Check for 0x00 or 0xFF at end of last frame  		// this sucks for tracks that start with silence  		if (_headerOffset >= 1 && !acceptNullSamples)// if (ftell(fp) >= 5)  		 {  			stream.Seek (-5' SeekOrigin.Current);  			byte tmpLastByte = stream.Read1 ();  			stream.Seek (4' SeekOrigin.Current);  			if (tmpFrameBitrate != 320 && (tmpLastByte == 0x00 || tmpLastByte == 0xFF)) {  				// 7/31/05  				// may be a valid frame - skip its contents to prevent false sync  				long tmpNewPosition = _headerOffset + tmpFrameSize;  				if (tmpFrameSize == 0)  					tmpNewPosition++;  				stream.Seek (tmpNewPosition' SeekOrigin.Begin);  				continue;  			}  		}  		/*if (BR == 0 || FrameSizeConst == 0)                         {                             startpos = HeaderOffset+1;                             fseek(fp' startpos' SEEK_SET);                             continue;                         }*/stream.Seek (_headerOffset + tmpFrameSize' SeekOrigin.Begin);  		if (stream.Read1 () == 0xFF) {  			fh1 = stream.Read1 ();  			fh2 = stream.Read1 ();  			if (tmpFrameHeader [1] == fh1 && (tmpFrameHeader [2] & 0x0D) == (fh2 & 0x0D)) {  				// header found  				break;  			}  		}  		stream.Seek (_headerOffset + 1' SeekOrigin.Begin);  		continue;  	}  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: while (true) {  	int tmpByte = stream.ReadByte ();  	// keep as ReadByte  	while (tmpByte != 0xFF && tmpByte != -1) {  		tmpByte = stream.ReadByte ();  		// keep as ReadByte  	}  	if (tmpByte == -1) {  		if (acceptNullSamples) {  			throw new InvalidDataException (string.Format ("'{0}': Can't find frame sync"' path));  		}  		stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  		acceptNullSamples = true;  		continue;  	}  	tmpFrameHeader [0] = (byte)tmpByte;  	// Get frame header  	if (stream.Read (tmpFrameHeader' 1' 3) != 3) {  		throw new InvalidDataException (string.Format ("'{0}': Invalid MPEG file; end of stream reached"' path));  	}  	// No sync  	if ((tmpFrameHeader [1] >> 5) != 0x07 || ((tmpFrameHeader [1] >> 1) & 0x03) == 0)// 2/18/05 - ignore reserved layer  	 {  		stream.Seek (-3' SeekOrigin.Current);  	} else if (tmpFrameHeader [1] == 0xFF || ((tmpFrameHeader [1] >> 3) & 0x03) == 1)// 2/19/05 - more bad data  	 {  		stream.Seek (-3' SeekOrigin.Current);  	} else {  		int tmpMpegID = (tmpFrameHeader [1] >> 3) & 0x03;  		int tmpLayerNum = (tmpFrameHeader [1] >> 1) & 0x03;  		int tmpFrequency = GetFrequency ((MpegVersion)tmpMpegID' (tmpFrameHeader [2] >> 2) & 0x03);  		// Check for invalid frequency  		if (tmpFrequency == 0) {  			stream.Seek (-3' SeekOrigin.Current);  			continue;  		}  		int tmpSamplesPerFrame = GetSamplesPerFrame ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum);  		int tmpUsesPadding = (tmpFrameHeader [2] >> 1) & 0x01;  		double tmpFrameSizeConst = 125.0 * tmpSamplesPerFrame / tmpFrequency;  		int tmpPaddingSize = (tmpLayerNum == 3 ? 4 : 1);  		int tmpBitrateIndex = tmpFrameHeader [2] >> 4;  		// Check for invalid values  		if (tmpBitrateIndex < 1 || tmpBitrateIndex > 14 || tmpLayerNum == 0) {  			stream.Seek (-3' SeekOrigin.Current);  			continue;  		}  		int tmpFrameBitrate = GetBitrate ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum' tmpBitrateIndex);  		int tmpFrameSize = (int)(tmpFrameBitrate * tmpFrameSizeConst) + (tmpUsesPadding * tmpPaddingSize);  		_headerOffset = stream.Position - 4;  		if (tmpFrameSize < 8) {  			stream.Seek (-3' SeekOrigin.Current);  			continue;  		}  		// 7/21/05 - Check for 0x00 or 0xFF at end of last frame  		// this sucks for tracks that start with silence  		if (_headerOffset >= 1 && !acceptNullSamples)// if (ftell(fp) >= 5)  		 {  			stream.Seek (-5' SeekOrigin.Current);  			byte tmpLastByte = stream.Read1 ();  			stream.Seek (4' SeekOrigin.Current);  			if (tmpFrameBitrate != 320 && (tmpLastByte == 0x00 || tmpLastByte == 0xFF)) {  				// 7/31/05  				// may be a valid frame - skip its contents to prevent false sync  				long tmpNewPosition = _headerOffset + tmpFrameSize;  				if (tmpFrameSize == 0)  					tmpNewPosition++;  				stream.Seek (tmpNewPosition' SeekOrigin.Begin);  				continue;  			}  		}  		/*if (BR == 0 || FrameSizeConst == 0)                         {                             startpos = HeaderOffset+1;                             fseek(fp' startpos' SEEK_SET);                             continue;                         }*/stream.Seek (_headerOffset + tmpFrameSize' SeekOrigin.Begin);  		if (stream.Read1 () == 0xFF) {  			fh1 = stream.Read1 ();  			fh2 = stream.Read1 ();  			if (tmpFrameHeader [1] == fh1 && (tmpFrameHeader [2] & 0x0D) == (fh2 & 0x0D)) {  				// header found  				break;  			}  		}  		stream.Seek (_headerOffset + 1' SeekOrigin.Begin);  		continue;  	}  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: while (true) {  	int tmpByte = stream.ReadByte ();  	// keep as ReadByte  	while (tmpByte != 0xFF && tmpByte != -1) {  		tmpByte = stream.ReadByte ();  		// keep as ReadByte  	}  	if (tmpByte == -1) {  		if (acceptNullSamples) {  			throw new InvalidDataException (string.Format ("'{0}': Can't find frame sync"' path));  		}  		stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  		acceptNullSamples = true;  		continue;  	}  	tmpFrameHeader [0] = (byte)tmpByte;  	// Get frame header  	if (stream.Read (tmpFrameHeader' 1' 3) != 3) {  		throw new InvalidDataException (string.Format ("'{0}': Invalid MPEG file; end of stream reached"' path));  	}  	// No sync  	if ((tmpFrameHeader [1] >> 5) != 0x07 || ((tmpFrameHeader [1] >> 1) & 0x03) == 0)// 2/18/05 - ignore reserved layer  	 {  		stream.Seek (-3' SeekOrigin.Current);  	} else if (tmpFrameHeader [1] == 0xFF || ((tmpFrameHeader [1] >> 3) & 0x03) == 1)// 2/19/05 - more bad data  	 {  		stream.Seek (-3' SeekOrigin.Current);  	} else {  		int tmpMpegID = (tmpFrameHeader [1] >> 3) & 0x03;  		int tmpLayerNum = (tmpFrameHeader [1] >> 1) & 0x03;  		int tmpFrequency = GetFrequency ((MpegVersion)tmpMpegID' (tmpFrameHeader [2] >> 2) & 0x03);  		// Check for invalid frequency  		if (tmpFrequency == 0) {  			stream.Seek (-3' SeekOrigin.Current);  			continue;  		}  		int tmpSamplesPerFrame = GetSamplesPerFrame ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum);  		int tmpUsesPadding = (tmpFrameHeader [2] >> 1) & 0x01;  		double tmpFrameSizeConst = 125.0 * tmpSamplesPerFrame / tmpFrequency;  		int tmpPaddingSize = (tmpLayerNum == 3 ? 4 : 1);  		int tmpBitrateIndex = tmpFrameHeader [2] >> 4;  		// Check for invalid values  		if (tmpBitrateIndex < 1 || tmpBitrateIndex > 14 || tmpLayerNum == 0) {  			stream.Seek (-3' SeekOrigin.Current);  			continue;  		}  		int tmpFrameBitrate = GetBitrate ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum' tmpBitrateIndex);  		int tmpFrameSize = (int)(tmpFrameBitrate * tmpFrameSizeConst) + (tmpUsesPadding * tmpPaddingSize);  		_headerOffset = stream.Position - 4;  		if (tmpFrameSize < 8) {  			stream.Seek (-3' SeekOrigin.Current);  			continue;  		}  		// 7/21/05 - Check for 0x00 or 0xFF at end of last frame  		// this sucks for tracks that start with silence  		if (_headerOffset >= 1 && !acceptNullSamples)// if (ftell(fp) >= 5)  		 {  			stream.Seek (-5' SeekOrigin.Current);  			byte tmpLastByte = stream.Read1 ();  			stream.Seek (4' SeekOrigin.Current);  			if (tmpFrameBitrate != 320 && (tmpLastByte == 0x00 || tmpLastByte == 0xFF)) {  				// 7/31/05  				// may be a valid frame - skip its contents to prevent false sync  				long tmpNewPosition = _headerOffset + tmpFrameSize;  				if (tmpFrameSize == 0)  					tmpNewPosition++;  				stream.Seek (tmpNewPosition' SeekOrigin.Begin);  				continue;  			}  		}  		/*if (BR == 0 || FrameSizeConst == 0)                         {                             startpos = HeaderOffset+1;                             fseek(fp' startpos' SEEK_SET);                             continue;                         }*/stream.Seek (_headerOffset + tmpFrameSize' SeekOrigin.Begin);  		if (stream.Read1 () == 0xFF) {  			fh1 = stream.Read1 ();  			fh2 = stream.Read1 ();  			if (tmpFrameHeader [1] == fh1 && (tmpFrameHeader [2] & 0x0D) == (fh2 & 0x0D)) {  				// header found  				break;  			}  		}  		stream.Seek (_headerOffset + 1' SeekOrigin.Begin);  		continue;  	}  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: while (true) {  	int tmpByte = stream.ReadByte ();  	// keep as ReadByte  	while (tmpByte != 0xFF && tmpByte != -1) {  		tmpByte = stream.ReadByte ();  		// keep as ReadByte  	}  	if (tmpByte == -1) {  		if (acceptNullSamples) {  			throw new InvalidDataException (string.Format ("'{0}': Can't find frame sync"' path));  		}  		stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  		acceptNullSamples = true;  		continue;  	}  	tmpFrameHeader [0] = (byte)tmpByte;  	// Get frame header  	if (stream.Read (tmpFrameHeader' 1' 3) != 3) {  		throw new InvalidDataException (string.Format ("'{0}': Invalid MPEG file; end of stream reached"' path));  	}  	// No sync  	if ((tmpFrameHeader [1] >> 5) != 0x07 || ((tmpFrameHeader [1] >> 1) & 0x03) == 0)// 2/18/05 - ignore reserved layer  	 {  		stream.Seek (-3' SeekOrigin.Current);  	} else if (tmpFrameHeader [1] == 0xFF || ((tmpFrameHeader [1] >> 3) & 0x03) == 1)// 2/19/05 - more bad data  	 {  		stream.Seek (-3' SeekOrigin.Current);  	} else {  		int tmpMpegID = (tmpFrameHeader [1] >> 3) & 0x03;  		int tmpLayerNum = (tmpFrameHeader [1] >> 1) & 0x03;  		int tmpFrequency = GetFrequency ((MpegVersion)tmpMpegID' (tmpFrameHeader [2] >> 2) & 0x03);  		// Check for invalid frequency  		if (tmpFrequency == 0) {  			stream.Seek (-3' SeekOrigin.Current);  			continue;  		}  		int tmpSamplesPerFrame = GetSamplesPerFrame ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum);  		int tmpUsesPadding = (tmpFrameHeader [2] >> 1) & 0x01;  		double tmpFrameSizeConst = 125.0 * tmpSamplesPerFrame / tmpFrequency;  		int tmpPaddingSize = (tmpLayerNum == 3 ? 4 : 1);  		int tmpBitrateIndex = tmpFrameHeader [2] >> 4;  		// Check for invalid values  		if (tmpBitrateIndex < 1 || tmpBitrateIndex > 14 || tmpLayerNum == 0) {  			stream.Seek (-3' SeekOrigin.Current);  			continue;  		}  		int tmpFrameBitrate = GetBitrate ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum' tmpBitrateIndex);  		int tmpFrameSize = (int)(tmpFrameBitrate * tmpFrameSizeConst) + (tmpUsesPadding * tmpPaddingSize);  		_headerOffset = stream.Position - 4;  		if (tmpFrameSize < 8) {  			stream.Seek (-3' SeekOrigin.Current);  			continue;  		}  		// 7/21/05 - Check for 0x00 or 0xFF at end of last frame  		// this sucks for tracks that start with silence  		if (_headerOffset >= 1 && !acceptNullSamples)// if (ftell(fp) >= 5)  		 {  			stream.Seek (-5' SeekOrigin.Current);  			byte tmpLastByte = stream.Read1 ();  			stream.Seek (4' SeekOrigin.Current);  			if (tmpFrameBitrate != 320 && (tmpLastByte == 0x00 || tmpLastByte == 0xFF)) {  				// 7/31/05  				// may be a valid frame - skip its contents to prevent false sync  				long tmpNewPosition = _headerOffset + tmpFrameSize;  				if (tmpFrameSize == 0)  					tmpNewPosition++;  				stream.Seek (tmpNewPosition' SeekOrigin.Begin);  				continue;  			}  		}  		/*if (BR == 0 || FrameSizeConst == 0)                         {                             startpos = HeaderOffset+1;                             fseek(fp' startpos' SEEK_SET);                             continue;                         }*/stream.Seek (_headerOffset + tmpFrameSize' SeekOrigin.Begin);  		if (stream.Read1 () == 0xFF) {  			fh1 = stream.Read1 ();  			fh2 = stream.Read1 ();  			if (tmpFrameHeader [1] == fh1 && (tmpFrameHeader [2] & 0x0D) == (fh2 & 0x0D)) {  				// header found  				break;  			}  		}  		stream.Seek (_headerOffset + 1' SeekOrigin.Begin);  		continue;  	}  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: while (true) {  	int tmpByte = stream.ReadByte ();  	// keep as ReadByte  	while (tmpByte != 0xFF && tmpByte != -1) {  		tmpByte = stream.ReadByte ();  		// keep as ReadByte  	}  	if (tmpByte == -1) {  		if (acceptNullSamples) {  			throw new InvalidDataException (string.Format ("'{0}': Can't find frame sync"' path));  		}  		stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  		acceptNullSamples = true;  		continue;  	}  	tmpFrameHeader [0] = (byte)tmpByte;  	// Get frame header  	if (stream.Read (tmpFrameHeader' 1' 3) != 3) {  		throw new InvalidDataException (string.Format ("'{0}': Invalid MPEG file; end of stream reached"' path));  	}  	// No sync  	if ((tmpFrameHeader [1] >> 5) != 0x07 || ((tmpFrameHeader [1] >> 1) & 0x03) == 0)// 2/18/05 - ignore reserved layer  	 {  		stream.Seek (-3' SeekOrigin.Current);  	} else if (tmpFrameHeader [1] == 0xFF || ((tmpFrameHeader [1] >> 3) & 0x03) == 1)// 2/19/05 - more bad data  	 {  		stream.Seek (-3' SeekOrigin.Current);  	} else {  		int tmpMpegID = (tmpFrameHeader [1] >> 3) & 0x03;  		int tmpLayerNum = (tmpFrameHeader [1] >> 1) & 0x03;  		int tmpFrequency = GetFrequency ((MpegVersion)tmpMpegID' (tmpFrameHeader [2] >> 2) & 0x03);  		// Check for invalid frequency  		if (tmpFrequency == 0) {  			stream.Seek (-3' SeekOrigin.Current);  			continue;  		}  		int tmpSamplesPerFrame = GetSamplesPerFrame ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum);  		int tmpUsesPadding = (tmpFrameHeader [2] >> 1) & 0x01;  		double tmpFrameSizeConst = 125.0 * tmpSamplesPerFrame / tmpFrequency;  		int tmpPaddingSize = (tmpLayerNum == 3 ? 4 : 1);  		int tmpBitrateIndex = tmpFrameHeader [2] >> 4;  		// Check for invalid values  		if (tmpBitrateIndex < 1 || tmpBitrateIndex > 14 || tmpLayerNum == 0) {  			stream.Seek (-3' SeekOrigin.Current);  			continue;  		}  		int tmpFrameBitrate = GetBitrate ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum' tmpBitrateIndex);  		int tmpFrameSize = (int)(tmpFrameBitrate * tmpFrameSizeConst) + (tmpUsesPadding * tmpPaddingSize);  		_headerOffset = stream.Position - 4;  		if (tmpFrameSize < 8) {  			stream.Seek (-3' SeekOrigin.Current);  			continue;  		}  		// 7/21/05 - Check for 0x00 or 0xFF at end of last frame  		// this sucks for tracks that start with silence  		if (_headerOffset >= 1 && !acceptNullSamples)// if (ftell(fp) >= 5)  		 {  			stream.Seek (-5' SeekOrigin.Current);  			byte tmpLastByte = stream.Read1 ();  			stream.Seek (4' SeekOrigin.Current);  			if (tmpFrameBitrate != 320 && (tmpLastByte == 0x00 || tmpLastByte == 0xFF)) {  				// 7/31/05  				// may be a valid frame - skip its contents to prevent false sync  				long tmpNewPosition = _headerOffset + tmpFrameSize;  				if (tmpFrameSize == 0)  					tmpNewPosition++;  				stream.Seek (tmpNewPosition' SeekOrigin.Begin);  				continue;  			}  		}  		/*if (BR == 0 || FrameSizeConst == 0)                         {                             startpos = HeaderOffset+1;                             fseek(fp' startpos' SEEK_SET);                             continue;                         }*/stream.Seek (_headerOffset + tmpFrameSize' SeekOrigin.Begin);  		if (stream.Read1 () == 0xFF) {  			fh1 = stream.Read1 ();  			fh2 = stream.Read1 ();  			if (tmpFrameHeader [1] == fh1 && (tmpFrameHeader [2] & 0x0D) == (fh2 & 0x0D)) {  				// header found  				break;  			}  		}  		stream.Seek (_headerOffset + 1' SeekOrigin.Begin);  		continue;  	}  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: while (true) {  	int tmpByte = stream.ReadByte ();  	// keep as ReadByte  	while (tmpByte != 0xFF && tmpByte != -1) {  		tmpByte = stream.ReadByte ();  		// keep as ReadByte  	}  	if (tmpByte == -1) {  		if (acceptNullSamples) {  			throw new InvalidDataException (string.Format ("'{0}': Can't find frame sync"' path));  		}  		stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  		acceptNullSamples = true;  		continue;  	}  	tmpFrameHeader [0] = (byte)tmpByte;  	// Get frame header  	if (stream.Read (tmpFrameHeader' 1' 3) != 3) {  		throw new InvalidDataException (string.Format ("'{0}': Invalid MPEG file; end of stream reached"' path));  	}  	// No sync  	if ((tmpFrameHeader [1] >> 5) != 0x07 || ((tmpFrameHeader [1] >> 1) & 0x03) == 0)// 2/18/05 - ignore reserved layer  	 {  		stream.Seek (-3' SeekOrigin.Current);  	} else if (tmpFrameHeader [1] == 0xFF || ((tmpFrameHeader [1] >> 3) & 0x03) == 1)// 2/19/05 - more bad data  	 {  		stream.Seek (-3' SeekOrigin.Current);  	} else {  		int tmpMpegID = (tmpFrameHeader [1] >> 3) & 0x03;  		int tmpLayerNum = (tmpFrameHeader [1] >> 1) & 0x03;  		int tmpFrequency = GetFrequency ((MpegVersion)tmpMpegID' (tmpFrameHeader [2] >> 2) & 0x03);  		// Check for invalid frequency  		if (tmpFrequency == 0) {  			stream.Seek (-3' SeekOrigin.Current);  			continue;  		}  		int tmpSamplesPerFrame = GetSamplesPerFrame ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum);  		int tmpUsesPadding = (tmpFrameHeader [2] >> 1) & 0x01;  		double tmpFrameSizeConst = 125.0 * tmpSamplesPerFrame / tmpFrequency;  		int tmpPaddingSize = (tmpLayerNum == 3 ? 4 : 1);  		int tmpBitrateIndex = tmpFrameHeader [2] >> 4;  		// Check for invalid values  		if (tmpBitrateIndex < 1 || tmpBitrateIndex > 14 || tmpLayerNum == 0) {  			stream.Seek (-3' SeekOrigin.Current);  			continue;  		}  		int tmpFrameBitrate = GetBitrate ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum' tmpBitrateIndex);  		int tmpFrameSize = (int)(tmpFrameBitrate * tmpFrameSizeConst) + (tmpUsesPadding * tmpPaddingSize);  		_headerOffset = stream.Position - 4;  		if (tmpFrameSize < 8) {  			stream.Seek (-3' SeekOrigin.Current);  			continue;  		}  		// 7/21/05 - Check for 0x00 or 0xFF at end of last frame  		// this sucks for tracks that start with silence  		if (_headerOffset >= 1 && !acceptNullSamples)// if (ftell(fp) >= 5)  		 {  			stream.Seek (-5' SeekOrigin.Current);  			byte tmpLastByte = stream.Read1 ();  			stream.Seek (4' SeekOrigin.Current);  			if (tmpFrameBitrate != 320 && (tmpLastByte == 0x00 || tmpLastByte == 0xFF)) {  				// 7/31/05  				// may be a valid frame - skip its contents to prevent false sync  				long tmpNewPosition = _headerOffset + tmpFrameSize;  				if (tmpFrameSize == 0)  					tmpNewPosition++;  				stream.Seek (tmpNewPosition' SeekOrigin.Begin);  				continue;  			}  		}  		/*if (BR == 0 || FrameSizeConst == 0)                         {                             startpos = HeaderOffset+1;                             fseek(fp' startpos' SEEK_SET);                             continue;                         }*/stream.Seek (_headerOffset + tmpFrameSize' SeekOrigin.Begin);  		if (stream.Read1 () == 0xFF) {  			fh1 = stream.Read1 ();  			fh2 = stream.Read1 ();  			if (tmpFrameHeader [1] == fh1 && (tmpFrameHeader [2] & 0x0D) == (fh2 & 0x0D)) {  				// header found  				break;  			}  		}  		stream.Seek (_headerOffset + 1' SeekOrigin.Begin);  		continue;  	}  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: while (true) {  	int tmpByte = stream.ReadByte ();  	// keep as ReadByte  	while (tmpByte != 0xFF && tmpByte != -1) {  		tmpByte = stream.ReadByte ();  		// keep as ReadByte  	}  	if (tmpByte == -1) {  		if (acceptNullSamples) {  			throw new InvalidDataException (string.Format ("'{0}': Can't find frame sync"' path));  		}  		stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  		acceptNullSamples = true;  		continue;  	}  	tmpFrameHeader [0] = (byte)tmpByte;  	// Get frame header  	if (stream.Read (tmpFrameHeader' 1' 3) != 3) {  		throw new InvalidDataException (string.Format ("'{0}': Invalid MPEG file; end of stream reached"' path));  	}  	// No sync  	if ((tmpFrameHeader [1] >> 5) != 0x07 || ((tmpFrameHeader [1] >> 1) & 0x03) == 0)// 2/18/05 - ignore reserved layer  	 {  		stream.Seek (-3' SeekOrigin.Current);  	} else if (tmpFrameHeader [1] == 0xFF || ((tmpFrameHeader [1] >> 3) & 0x03) == 1)// 2/19/05 - more bad data  	 {  		stream.Seek (-3' SeekOrigin.Current);  	} else {  		int tmpMpegID = (tmpFrameHeader [1] >> 3) & 0x03;  		int tmpLayerNum = (tmpFrameHeader [1] >> 1) & 0x03;  		int tmpFrequency = GetFrequency ((MpegVersion)tmpMpegID' (tmpFrameHeader [2] >> 2) & 0x03);  		// Check for invalid frequency  		if (tmpFrequency == 0) {  			stream.Seek (-3' SeekOrigin.Current);  			continue;  		}  		int tmpSamplesPerFrame = GetSamplesPerFrame ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum);  		int tmpUsesPadding = (tmpFrameHeader [2] >> 1) & 0x01;  		double tmpFrameSizeConst = 125.0 * tmpSamplesPerFrame / tmpFrequency;  		int tmpPaddingSize = (tmpLayerNum == 3 ? 4 : 1);  		int tmpBitrateIndex = tmpFrameHeader [2] >> 4;  		// Check for invalid values  		if (tmpBitrateIndex < 1 || tmpBitrateIndex > 14 || tmpLayerNum == 0) {  			stream.Seek (-3' SeekOrigin.Current);  			continue;  		}  		int tmpFrameBitrate = GetBitrate ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum' tmpBitrateIndex);  		int tmpFrameSize = (int)(tmpFrameBitrate * tmpFrameSizeConst) + (tmpUsesPadding * tmpPaddingSize);  		_headerOffset = stream.Position - 4;  		if (tmpFrameSize < 8) {  			stream.Seek (-3' SeekOrigin.Current);  			continue;  		}  		// 7/21/05 - Check for 0x00 or 0xFF at end of last frame  		// this sucks for tracks that start with silence  		if (_headerOffset >= 1 && !acceptNullSamples)// if (ftell(fp) >= 5)  		 {  			stream.Seek (-5' SeekOrigin.Current);  			byte tmpLastByte = stream.Read1 ();  			stream.Seek (4' SeekOrigin.Current);  			if (tmpFrameBitrate != 320 && (tmpLastByte == 0x00 || tmpLastByte == 0xFF)) {  				// 7/31/05  				// may be a valid frame - skip its contents to prevent false sync  				long tmpNewPosition = _headerOffset + tmpFrameSize;  				if (tmpFrameSize == 0)  					tmpNewPosition++;  				stream.Seek (tmpNewPosition' SeekOrigin.Begin);  				continue;  			}  		}  		/*if (BR == 0 || FrameSizeConst == 0)                         {                             startpos = HeaderOffset+1;                             fseek(fp' startpos' SEEK_SET);                             continue;                         }*/stream.Seek (_headerOffset + tmpFrameSize' SeekOrigin.Begin);  		if (stream.Read1 () == 0xFF) {  			fh1 = stream.Read1 ();  			fh2 = stream.Read1 ();  			if (tmpFrameHeader [1] == fh1 && (tmpFrameHeader [2] & 0x0D) == (fh2 & 0x0D)) {  				// header found  				break;  			}  		}  		stream.Seek (_headerOffset + 1' SeekOrigin.Begin);  		continue;  	}  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: while (true) {  	int tmpByte = stream.ReadByte ();  	// keep as ReadByte  	while (tmpByte != 0xFF && tmpByte != -1) {  		tmpByte = stream.ReadByte ();  		// keep as ReadByte  	}  	if (tmpByte == -1) {  		if (acceptNullSamples) {  			throw new InvalidDataException (string.Format ("'{0}': Can't find frame sync"' path));  		}  		stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  		acceptNullSamples = true;  		continue;  	}  	tmpFrameHeader [0] = (byte)tmpByte;  	// Get frame header  	if (stream.Read (tmpFrameHeader' 1' 3) != 3) {  		throw new InvalidDataException (string.Format ("'{0}': Invalid MPEG file; end of stream reached"' path));  	}  	// No sync  	if ((tmpFrameHeader [1] >> 5) != 0x07 || ((tmpFrameHeader [1] >> 1) & 0x03) == 0)// 2/18/05 - ignore reserved layer  	 {  		stream.Seek (-3' SeekOrigin.Current);  	} else if (tmpFrameHeader [1] == 0xFF || ((tmpFrameHeader [1] >> 3) & 0x03) == 1)// 2/19/05 - more bad data  	 {  		stream.Seek (-3' SeekOrigin.Current);  	} else {  		int tmpMpegID = (tmpFrameHeader [1] >> 3) & 0x03;  		int tmpLayerNum = (tmpFrameHeader [1] >> 1) & 0x03;  		int tmpFrequency = GetFrequency ((MpegVersion)tmpMpegID' (tmpFrameHeader [2] >> 2) & 0x03);  		// Check for invalid frequency  		if (tmpFrequency == 0) {  			stream.Seek (-3' SeekOrigin.Current);  			continue;  		}  		int tmpSamplesPerFrame = GetSamplesPerFrame ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum);  		int tmpUsesPadding = (tmpFrameHeader [2] >> 1) & 0x01;  		double tmpFrameSizeConst = 125.0 * tmpSamplesPerFrame / tmpFrequency;  		int tmpPaddingSize = (tmpLayerNum == 3 ? 4 : 1);  		int tmpBitrateIndex = tmpFrameHeader [2] >> 4;  		// Check for invalid values  		if (tmpBitrateIndex < 1 || tmpBitrateIndex > 14 || tmpLayerNum == 0) {  			stream.Seek (-3' SeekOrigin.Current);  			continue;  		}  		int tmpFrameBitrate = GetBitrate ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum' tmpBitrateIndex);  		int tmpFrameSize = (int)(tmpFrameBitrate * tmpFrameSizeConst) + (tmpUsesPadding * tmpPaddingSize);  		_headerOffset = stream.Position - 4;  		if (tmpFrameSize < 8) {  			stream.Seek (-3' SeekOrigin.Current);  			continue;  		}  		// 7/21/05 - Check for 0x00 or 0xFF at end of last frame  		// this sucks for tracks that start with silence  		if (_headerOffset >= 1 && !acceptNullSamples)// if (ftell(fp) >= 5)  		 {  			stream.Seek (-5' SeekOrigin.Current);  			byte tmpLastByte = stream.Read1 ();  			stream.Seek (4' SeekOrigin.Current);  			if (tmpFrameBitrate != 320 && (tmpLastByte == 0x00 || tmpLastByte == 0xFF)) {  				// 7/31/05  				// may be a valid frame - skip its contents to prevent false sync  				long tmpNewPosition = _headerOffset + tmpFrameSize;  				if (tmpFrameSize == 0)  					tmpNewPosition++;  				stream.Seek (tmpNewPosition' SeekOrigin.Begin);  				continue;  			}  		}  		/*if (BR == 0 || FrameSizeConst == 0)                         {                             startpos = HeaderOffset+1;                             fseek(fp' startpos' SEEK_SET);                             continue;                         }*/stream.Seek (_headerOffset + tmpFrameSize' SeekOrigin.Begin);  		if (stream.Read1 () == 0xFF) {  			fh1 = stream.Read1 ();  			fh2 = stream.Read1 ();  			if (tmpFrameHeader [1] == fh1 && (tmpFrameHeader [2] & 0x0D) == (fh2 & 0x0D)) {  				// header found  				break;  			}  		}  		stream.Seek (_headerOffset + 1' SeekOrigin.Begin);  		continue;  	}  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: while (true) {  	int tmpByte = stream.ReadByte ();  	// keep as ReadByte  	while (tmpByte != 0xFF && tmpByte != -1) {  		tmpByte = stream.ReadByte ();  		// keep as ReadByte  	}  	if (tmpByte == -1) {  		if (acceptNullSamples) {  			throw new InvalidDataException (string.Format ("'{0}': Can't find frame sync"' path));  		}  		stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  		acceptNullSamples = true;  		continue;  	}  	tmpFrameHeader [0] = (byte)tmpByte;  	// Get frame header  	if (stream.Read (tmpFrameHeader' 1' 3) != 3) {  		throw new InvalidDataException (string.Format ("'{0}': Invalid MPEG file; end of stream reached"' path));  	}  	// No sync  	if ((tmpFrameHeader [1] >> 5) != 0x07 || ((tmpFrameHeader [1] >> 1) & 0x03) == 0)// 2/18/05 - ignore reserved layer  	 {  		stream.Seek (-3' SeekOrigin.Current);  	} else if (tmpFrameHeader [1] == 0xFF || ((tmpFrameHeader [1] >> 3) & 0x03) == 1)// 2/19/05 - more bad data  	 {  		stream.Seek (-3' SeekOrigin.Current);  	} else {  		int tmpMpegID = (tmpFrameHeader [1] >> 3) & 0x03;  		int tmpLayerNum = (tmpFrameHeader [1] >> 1) & 0x03;  		int tmpFrequency = GetFrequency ((MpegVersion)tmpMpegID' (tmpFrameHeader [2] >> 2) & 0x03);  		// Check for invalid frequency  		if (tmpFrequency == 0) {  			stream.Seek (-3' SeekOrigin.Current);  			continue;  		}  		int tmpSamplesPerFrame = GetSamplesPerFrame ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum);  		int tmpUsesPadding = (tmpFrameHeader [2] >> 1) & 0x01;  		double tmpFrameSizeConst = 125.0 * tmpSamplesPerFrame / tmpFrequency;  		int tmpPaddingSize = (tmpLayerNum == 3 ? 4 : 1);  		int tmpBitrateIndex = tmpFrameHeader [2] >> 4;  		// Check for invalid values  		if (tmpBitrateIndex < 1 || tmpBitrateIndex > 14 || tmpLayerNum == 0) {  			stream.Seek (-3' SeekOrigin.Current);  			continue;  		}  		int tmpFrameBitrate = GetBitrate ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum' tmpBitrateIndex);  		int tmpFrameSize = (int)(tmpFrameBitrate * tmpFrameSizeConst) + (tmpUsesPadding * tmpPaddingSize);  		_headerOffset = stream.Position - 4;  		if (tmpFrameSize < 8) {  			stream.Seek (-3' SeekOrigin.Current);  			continue;  		}  		// 7/21/05 - Check for 0x00 or 0xFF at end of last frame  		// this sucks for tracks that start with silence  		if (_headerOffset >= 1 && !acceptNullSamples)// if (ftell(fp) >= 5)  		 {  			stream.Seek (-5' SeekOrigin.Current);  			byte tmpLastByte = stream.Read1 ();  			stream.Seek (4' SeekOrigin.Current);  			if (tmpFrameBitrate != 320 && (tmpLastByte == 0x00 || tmpLastByte == 0xFF)) {  				// 7/31/05  				// may be a valid frame - skip its contents to prevent false sync  				long tmpNewPosition = _headerOffset + tmpFrameSize;  				if (tmpFrameSize == 0)  					tmpNewPosition++;  				stream.Seek (tmpNewPosition' SeekOrigin.Begin);  				continue;  			}  		}  		/*if (BR == 0 || FrameSizeConst == 0)                         {                             startpos = HeaderOffset+1;                             fseek(fp' startpos' SEEK_SET);                             continue;                         }*/stream.Seek (_headerOffset + tmpFrameSize' SeekOrigin.Begin);  		if (stream.Read1 () == 0xFF) {  			fh1 = stream.Read1 ();  			fh2 = stream.Read1 ();  			if (tmpFrameHeader [1] == fh1 && (tmpFrameHeader [2] & 0x0D) == (fh2 & 0x0D)) {  				// header found  				break;  			}  		}  		stream.Seek (_headerOffset + 1' SeekOrigin.Begin);  		continue;  	}  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: while (true) {  	int tmpByte = stream.ReadByte ();  	// keep as ReadByte  	while (tmpByte != 0xFF && tmpByte != -1) {  		tmpByte = stream.ReadByte ();  		// keep as ReadByte  	}  	if (tmpByte == -1) {  		if (acceptNullSamples) {  			throw new InvalidDataException (string.Format ("'{0}': Can't find frame sync"' path));  		}  		stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  		acceptNullSamples = true;  		continue;  	}  	tmpFrameHeader [0] = (byte)tmpByte;  	// Get frame header  	if (stream.Read (tmpFrameHeader' 1' 3) != 3) {  		throw new InvalidDataException (string.Format ("'{0}': Invalid MPEG file; end of stream reached"' path));  	}  	// No sync  	if ((tmpFrameHeader [1] >> 5) != 0x07 || ((tmpFrameHeader [1] >> 1) & 0x03) == 0)// 2/18/05 - ignore reserved layer  	 {  		stream.Seek (-3' SeekOrigin.Current);  	} else if (tmpFrameHeader [1] == 0xFF || ((tmpFrameHeader [1] >> 3) & 0x03) == 1)// 2/19/05 - more bad data  	 {  		stream.Seek (-3' SeekOrigin.Current);  	} else {  		int tmpMpegID = (tmpFrameHeader [1] >> 3) & 0x03;  		int tmpLayerNum = (tmpFrameHeader [1] >> 1) & 0x03;  		int tmpFrequency = GetFrequency ((MpegVersion)tmpMpegID' (tmpFrameHeader [2] >> 2) & 0x03);  		// Check for invalid frequency  		if (tmpFrequency == 0) {  			stream.Seek (-3' SeekOrigin.Current);  			continue;  		}  		int tmpSamplesPerFrame = GetSamplesPerFrame ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum);  		int tmpUsesPadding = (tmpFrameHeader [2] >> 1) & 0x01;  		double tmpFrameSizeConst = 125.0 * tmpSamplesPerFrame / tmpFrequency;  		int tmpPaddingSize = (tmpLayerNum == 3 ? 4 : 1);  		int tmpBitrateIndex = tmpFrameHeader [2] >> 4;  		// Check for invalid values  		if (tmpBitrateIndex < 1 || tmpBitrateIndex > 14 || tmpLayerNum == 0) {  			stream.Seek (-3' SeekOrigin.Current);  			continue;  		}  		int tmpFrameBitrate = GetBitrate ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum' tmpBitrateIndex);  		int tmpFrameSize = (int)(tmpFrameBitrate * tmpFrameSizeConst) + (tmpUsesPadding * tmpPaddingSize);  		_headerOffset = stream.Position - 4;  		if (tmpFrameSize < 8) {  			stream.Seek (-3' SeekOrigin.Current);  			continue;  		}  		// 7/21/05 - Check for 0x00 or 0xFF at end of last frame  		// this sucks for tracks that start with silence  		if (_headerOffset >= 1 && !acceptNullSamples)// if (ftell(fp) >= 5)  		 {  			stream.Seek (-5' SeekOrigin.Current);  			byte tmpLastByte = stream.Read1 ();  			stream.Seek (4' SeekOrigin.Current);  			if (tmpFrameBitrate != 320 && (tmpLastByte == 0x00 || tmpLastByte == 0xFF)) {  				// 7/31/05  				// may be a valid frame - skip its contents to prevent false sync  				long tmpNewPosition = _headerOffset + tmpFrameSize;  				if (tmpFrameSize == 0)  					tmpNewPosition++;  				stream.Seek (tmpNewPosition' SeekOrigin.Begin);  				continue;  			}  		}  		/*if (BR == 0 || FrameSizeConst == 0)                         {                             startpos = HeaderOffset+1;                             fseek(fp' startpos' SEEK_SET);                             continue;                         }*/stream.Seek (_headerOffset + tmpFrameSize' SeekOrigin.Begin);  		if (stream.Read1 () == 0xFF) {  			fh1 = stream.Read1 ();  			fh2 = stream.Read1 ();  			if (tmpFrameHeader [1] == fh1 && (tmpFrameHeader [2] & 0x0D) == (fh2 & 0x0D)) {  				// header found  				break;  			}  		}  		stream.Seek (_headerOffset + 1' SeekOrigin.Begin);  		continue;  	}  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: while (true) {  	int tmpByte = stream.ReadByte ();  	// keep as ReadByte  	while (tmpByte != 0xFF && tmpByte != -1) {  		tmpByte = stream.ReadByte ();  		// keep as ReadByte  	}  	if (tmpByte == -1) {  		if (acceptNullSamples) {  			throw new InvalidDataException (string.Format ("'{0}': Can't find frame sync"' path));  		}  		stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  		acceptNullSamples = true;  		continue;  	}  	tmpFrameHeader [0] = (byte)tmpByte;  	// Get frame header  	if (stream.Read (tmpFrameHeader' 1' 3) != 3) {  		throw new InvalidDataException (string.Format ("'{0}': Invalid MPEG file; end of stream reached"' path));  	}  	// No sync  	if ((tmpFrameHeader [1] >> 5) != 0x07 || ((tmpFrameHeader [1] >> 1) & 0x03) == 0)// 2/18/05 - ignore reserved layer  	 {  		stream.Seek (-3' SeekOrigin.Current);  	} else if (tmpFrameHeader [1] == 0xFF || ((tmpFrameHeader [1] >> 3) & 0x03) == 1)// 2/19/05 - more bad data  	 {  		stream.Seek (-3' SeekOrigin.Current);  	} else {  		int tmpMpegID = (tmpFrameHeader [1] >> 3) & 0x03;  		int tmpLayerNum = (tmpFrameHeader [1] >> 1) & 0x03;  		int tmpFrequency = GetFrequency ((MpegVersion)tmpMpegID' (tmpFrameHeader [2] >> 2) & 0x03);  		// Check for invalid frequency  		if (tmpFrequency == 0) {  			stream.Seek (-3' SeekOrigin.Current);  			continue;  		}  		int tmpSamplesPerFrame = GetSamplesPerFrame ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum);  		int tmpUsesPadding = (tmpFrameHeader [2] >> 1) & 0x01;  		double tmpFrameSizeConst = 125.0 * tmpSamplesPerFrame / tmpFrequency;  		int tmpPaddingSize = (tmpLayerNum == 3 ? 4 : 1);  		int tmpBitrateIndex = tmpFrameHeader [2] >> 4;  		// Check for invalid values  		if (tmpBitrateIndex < 1 || tmpBitrateIndex > 14 || tmpLayerNum == 0) {  			stream.Seek (-3' SeekOrigin.Current);  			continue;  		}  		int tmpFrameBitrate = GetBitrate ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum' tmpBitrateIndex);  		int tmpFrameSize = (int)(tmpFrameBitrate * tmpFrameSizeConst) + (tmpUsesPadding * tmpPaddingSize);  		_headerOffset = stream.Position - 4;  		if (tmpFrameSize < 8) {  			stream.Seek (-3' SeekOrigin.Current);  			continue;  		}  		// 7/21/05 - Check for 0x00 or 0xFF at end of last frame  		// this sucks for tracks that start with silence  		if (_headerOffset >= 1 && !acceptNullSamples)// if (ftell(fp) >= 5)  		 {  			stream.Seek (-5' SeekOrigin.Current);  			byte tmpLastByte = stream.Read1 ();  			stream.Seek (4' SeekOrigin.Current);  			if (tmpFrameBitrate != 320 && (tmpLastByte == 0x00 || tmpLastByte == 0xFF)) {  				// 7/31/05  				// may be a valid frame - skip its contents to prevent false sync  				long tmpNewPosition = _headerOffset + tmpFrameSize;  				if (tmpFrameSize == 0)  					tmpNewPosition++;  				stream.Seek (tmpNewPosition' SeekOrigin.Begin);  				continue;  			}  		}  		/*if (BR == 0 || FrameSizeConst == 0)                         {                             startpos = HeaderOffset+1;                             fseek(fp' startpos' SEEK_SET);                             continue;                         }*/stream.Seek (_headerOffset + tmpFrameSize' SeekOrigin.Begin);  		if (stream.Read1 () == 0xFF) {  			fh1 = stream.Read1 ();  			fh2 = stream.Read1 ();  			if (tmpFrameHeader [1] == fh1 && (tmpFrameHeader [2] & 0x0D) == (fh2 & 0x0D)) {  				// header found  				break;  			}  		}  		stream.Seek (_headerOffset + 1' SeekOrigin.Begin);  		continue;  	}  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: while (true) {  	int tmpByte = stream.ReadByte ();  	// keep as ReadByte  	while (tmpByte != 0xFF && tmpByte != -1) {  		tmpByte = stream.ReadByte ();  		// keep as ReadByte  	}  	if (tmpByte == -1) {  		if (acceptNullSamples) {  			throw new InvalidDataException (string.Format ("'{0}': Can't find frame sync"' path));  		}  		stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  		acceptNullSamples = true;  		continue;  	}  	tmpFrameHeader [0] = (byte)tmpByte;  	// Get frame header  	if (stream.Read (tmpFrameHeader' 1' 3) != 3) {  		throw new InvalidDataException (string.Format ("'{0}': Invalid MPEG file; end of stream reached"' path));  	}  	// No sync  	if ((tmpFrameHeader [1] >> 5) != 0x07 || ((tmpFrameHeader [1] >> 1) & 0x03) == 0)// 2/18/05 - ignore reserved layer  	 {  		stream.Seek (-3' SeekOrigin.Current);  	} else if (tmpFrameHeader [1] == 0xFF || ((tmpFrameHeader [1] >> 3) & 0x03) == 1)// 2/19/05 - more bad data  	 {  		stream.Seek (-3' SeekOrigin.Current);  	} else {  		int tmpMpegID = (tmpFrameHeader [1] >> 3) & 0x03;  		int tmpLayerNum = (tmpFrameHeader [1] >> 1) & 0x03;  		int tmpFrequency = GetFrequency ((MpegVersion)tmpMpegID' (tmpFrameHeader [2] >> 2) & 0x03);  		// Check for invalid frequency  		if (tmpFrequency == 0) {  			stream.Seek (-3' SeekOrigin.Current);  			continue;  		}  		int tmpSamplesPerFrame = GetSamplesPerFrame ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum);  		int tmpUsesPadding = (tmpFrameHeader [2] >> 1) & 0x01;  		double tmpFrameSizeConst = 125.0 * tmpSamplesPerFrame / tmpFrequency;  		int tmpPaddingSize = (tmpLayerNum == 3 ? 4 : 1);  		int tmpBitrateIndex = tmpFrameHeader [2] >> 4;  		// Check for invalid values  		if (tmpBitrateIndex < 1 || tmpBitrateIndex > 14 || tmpLayerNum == 0) {  			stream.Seek (-3' SeekOrigin.Current);  			continue;  		}  		int tmpFrameBitrate = GetBitrate ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum' tmpBitrateIndex);  		int tmpFrameSize = (int)(tmpFrameBitrate * tmpFrameSizeConst) + (tmpUsesPadding * tmpPaddingSize);  		_headerOffset = stream.Position - 4;  		if (tmpFrameSize < 8) {  			stream.Seek (-3' SeekOrigin.Current);  			continue;  		}  		// 7/21/05 - Check for 0x00 or 0xFF at end of last frame  		// this sucks for tracks that start with silence  		if (_headerOffset >= 1 && !acceptNullSamples)// if (ftell(fp) >= 5)  		 {  			stream.Seek (-5' SeekOrigin.Current);  			byte tmpLastByte = stream.Read1 ();  			stream.Seek (4' SeekOrigin.Current);  			if (tmpFrameBitrate != 320 && (tmpLastByte == 0x00 || tmpLastByte == 0xFF)) {  				// 7/31/05  				// may be a valid frame - skip its contents to prevent false sync  				long tmpNewPosition = _headerOffset + tmpFrameSize;  				if (tmpFrameSize == 0)  					tmpNewPosition++;  				stream.Seek (tmpNewPosition' SeekOrigin.Begin);  				continue;  			}  		}  		/*if (BR == 0 || FrameSizeConst == 0)                         {                             startpos = HeaderOffset+1;                             fseek(fp' startpos' SEEK_SET);                             continue;                         }*/stream.Seek (_headerOffset + tmpFrameSize' SeekOrigin.Begin);  		if (stream.Read1 () == 0xFF) {  			fh1 = stream.Read1 ();  			fh2 = stream.Read1 ();  			if (tmpFrameHeader [1] == fh1 && (tmpFrameHeader [2] & 0x0D) == (fh2 & 0x0D)) {  				// header found  				break;  			}  		}  		stream.Seek (_headerOffset + 1' SeekOrigin.Begin);  		continue;  	}  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: while (true) {  	int tmpByte = stream.ReadByte ();  	// keep as ReadByte  	while (tmpByte != 0xFF && tmpByte != -1) {  		tmpByte = stream.ReadByte ();  		// keep as ReadByte  	}  	if (tmpByte == -1) {  		if (acceptNullSamples) {  			throw new InvalidDataException (string.Format ("'{0}': Can't find frame sync"' path));  		}  		stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  		acceptNullSamples = true;  		continue;  	}  	tmpFrameHeader [0] = (byte)tmpByte;  	// Get frame header  	if (stream.Read (tmpFrameHeader' 1' 3) != 3) {  		throw new InvalidDataException (string.Format ("'{0}': Invalid MPEG file; end of stream reached"' path));  	}  	// No sync  	if ((tmpFrameHeader [1] >> 5) != 0x07 || ((tmpFrameHeader [1] >> 1) & 0x03) == 0)// 2/18/05 - ignore reserved layer  	 {  		stream.Seek (-3' SeekOrigin.Current);  	} else if (tmpFrameHeader [1] == 0xFF || ((tmpFrameHeader [1] >> 3) & 0x03) == 1)// 2/19/05 - more bad data  	 {  		stream.Seek (-3' SeekOrigin.Current);  	} else {  		int tmpMpegID = (tmpFrameHeader [1] >> 3) & 0x03;  		int tmpLayerNum = (tmpFrameHeader [1] >> 1) & 0x03;  		int tmpFrequency = GetFrequency ((MpegVersion)tmpMpegID' (tmpFrameHeader [2] >> 2) & 0x03);  		// Check for invalid frequency  		if (tmpFrequency == 0) {  			stream.Seek (-3' SeekOrigin.Current);  			continue;  		}  		int tmpSamplesPerFrame = GetSamplesPerFrame ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum);  		int tmpUsesPadding = (tmpFrameHeader [2] >> 1) & 0x01;  		double tmpFrameSizeConst = 125.0 * tmpSamplesPerFrame / tmpFrequency;  		int tmpPaddingSize = (tmpLayerNum == 3 ? 4 : 1);  		int tmpBitrateIndex = tmpFrameHeader [2] >> 4;  		// Check for invalid values  		if (tmpBitrateIndex < 1 || tmpBitrateIndex > 14 || tmpLayerNum == 0) {  			stream.Seek (-3' SeekOrigin.Current);  			continue;  		}  		int tmpFrameBitrate = GetBitrate ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum' tmpBitrateIndex);  		int tmpFrameSize = (int)(tmpFrameBitrate * tmpFrameSizeConst) + (tmpUsesPadding * tmpPaddingSize);  		_headerOffset = stream.Position - 4;  		if (tmpFrameSize < 8) {  			stream.Seek (-3' SeekOrigin.Current);  			continue;  		}  		// 7/21/05 - Check for 0x00 or 0xFF at end of last frame  		// this sucks for tracks that start with silence  		if (_headerOffset >= 1 && !acceptNullSamples)// if (ftell(fp) >= 5)  		 {  			stream.Seek (-5' SeekOrigin.Current);  			byte tmpLastByte = stream.Read1 ();  			stream.Seek (4' SeekOrigin.Current);  			if (tmpFrameBitrate != 320 && (tmpLastByte == 0x00 || tmpLastByte == 0xFF)) {  				// 7/31/05  				// may be a valid frame - skip its contents to prevent false sync  				long tmpNewPosition = _headerOffset + tmpFrameSize;  				if (tmpFrameSize == 0)  					tmpNewPosition++;  				stream.Seek (tmpNewPosition' SeekOrigin.Begin);  				continue;  			}  		}  		/*if (BR == 0 || FrameSizeConst == 0)                         {                             startpos = HeaderOffset+1;                             fseek(fp' startpos' SEEK_SET);                             continue;                         }*/stream.Seek (_headerOffset + tmpFrameSize' SeekOrigin.Begin);  		if (stream.Read1 () == 0xFF) {  			fh1 = stream.Read1 ();  			fh2 = stream.Read1 ();  			if (tmpFrameHeader [1] == fh1 && (tmpFrameHeader [2] & 0x0D) == (fh2 & 0x0D)) {  				// header found  				break;  			}  		}  		stream.Seek (_headerOffset + 1' SeekOrigin.Begin);  		continue;  	}  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: while (true) {  	int tmpByte = stream.ReadByte ();  	// keep as ReadByte  	while (tmpByte != 0xFF && tmpByte != -1) {  		tmpByte = stream.ReadByte ();  		// keep as ReadByte  	}  	if (tmpByte == -1) {  		if (acceptNullSamples) {  			throw new InvalidDataException (string.Format ("'{0}': Can't find frame sync"' path));  		}  		stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  		acceptNullSamples = true;  		continue;  	}  	tmpFrameHeader [0] = (byte)tmpByte;  	// Get frame header  	if (stream.Read (tmpFrameHeader' 1' 3) != 3) {  		throw new InvalidDataException (string.Format ("'{0}': Invalid MPEG file; end of stream reached"' path));  	}  	// No sync  	if ((tmpFrameHeader [1] >> 5) != 0x07 || ((tmpFrameHeader [1] >> 1) & 0x03) == 0)// 2/18/05 - ignore reserved layer  	 {  		stream.Seek (-3' SeekOrigin.Current);  	} else if (tmpFrameHeader [1] == 0xFF || ((tmpFrameHeader [1] >> 3) & 0x03) == 1)// 2/19/05 - more bad data  	 {  		stream.Seek (-3' SeekOrigin.Current);  	} else {  		int tmpMpegID = (tmpFrameHeader [1] >> 3) & 0x03;  		int tmpLayerNum = (tmpFrameHeader [1] >> 1) & 0x03;  		int tmpFrequency = GetFrequency ((MpegVersion)tmpMpegID' (tmpFrameHeader [2] >> 2) & 0x03);  		// Check for invalid frequency  		if (tmpFrequency == 0) {  			stream.Seek (-3' SeekOrigin.Current);  			continue;  		}  		int tmpSamplesPerFrame = GetSamplesPerFrame ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum);  		int tmpUsesPadding = (tmpFrameHeader [2] >> 1) & 0x01;  		double tmpFrameSizeConst = 125.0 * tmpSamplesPerFrame / tmpFrequency;  		int tmpPaddingSize = (tmpLayerNum == 3 ? 4 : 1);  		int tmpBitrateIndex = tmpFrameHeader [2] >> 4;  		// Check for invalid values  		if (tmpBitrateIndex < 1 || tmpBitrateIndex > 14 || tmpLayerNum == 0) {  			stream.Seek (-3' SeekOrigin.Current);  			continue;  		}  		int tmpFrameBitrate = GetBitrate ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum' tmpBitrateIndex);  		int tmpFrameSize = (int)(tmpFrameBitrate * tmpFrameSizeConst) + (tmpUsesPadding * tmpPaddingSize);  		_headerOffset = stream.Position - 4;  		if (tmpFrameSize < 8) {  			stream.Seek (-3' SeekOrigin.Current);  			continue;  		}  		// 7/21/05 - Check for 0x00 or 0xFF at end of last frame  		// this sucks for tracks that start with silence  		if (_headerOffset >= 1 && !acceptNullSamples)// if (ftell(fp) >= 5)  		 {  			stream.Seek (-5' SeekOrigin.Current);  			byte tmpLastByte = stream.Read1 ();  			stream.Seek (4' SeekOrigin.Current);  			if (tmpFrameBitrate != 320 && (tmpLastByte == 0x00 || tmpLastByte == 0xFF)) {  				// 7/31/05  				// may be a valid frame - skip its contents to prevent false sync  				long tmpNewPosition = _headerOffset + tmpFrameSize;  				if (tmpFrameSize == 0)  					tmpNewPosition++;  				stream.Seek (tmpNewPosition' SeekOrigin.Begin);  				continue;  			}  		}  		/*if (BR == 0 || FrameSizeConst == 0)                         {                             startpos = HeaderOffset+1;                             fseek(fp' startpos' SEEK_SET);                             continue;                         }*/stream.Seek (_headerOffset + tmpFrameSize' SeekOrigin.Begin);  		if (stream.Read1 () == 0xFF) {  			fh1 = stream.Read1 ();  			fh2 = stream.Read1 ();  			if (tmpFrameHeader [1] == fh1 && (tmpFrameHeader [2] & 0x0D) == (fh2 & 0x0D)) {  				// header found  				break;  			}  		}  		stream.Seek (_headerOffset + 1' SeekOrigin.Begin);  		continue;  	}  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: while (true) {  	int tmpByte = stream.ReadByte ();  	// keep as ReadByte  	while (tmpByte != 0xFF && tmpByte != -1) {  		tmpByte = stream.ReadByte ();  		// keep as ReadByte  	}  	if (tmpByte == -1) {  		if (acceptNullSamples) {  			throw new InvalidDataException (string.Format ("'{0}': Can't find frame sync"' path));  		}  		stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  		acceptNullSamples = true;  		continue;  	}  	tmpFrameHeader [0] = (byte)tmpByte;  	// Get frame header  	if (stream.Read (tmpFrameHeader' 1' 3) != 3) {  		throw new InvalidDataException (string.Format ("'{0}': Invalid MPEG file; end of stream reached"' path));  	}  	// No sync  	if ((tmpFrameHeader [1] >> 5) != 0x07 || ((tmpFrameHeader [1] >> 1) & 0x03) == 0)// 2/18/05 - ignore reserved layer  	 {  		stream.Seek (-3' SeekOrigin.Current);  	} else if (tmpFrameHeader [1] == 0xFF || ((tmpFrameHeader [1] >> 3) & 0x03) == 1)// 2/19/05 - more bad data  	 {  		stream.Seek (-3' SeekOrigin.Current);  	} else {  		int tmpMpegID = (tmpFrameHeader [1] >> 3) & 0x03;  		int tmpLayerNum = (tmpFrameHeader [1] >> 1) & 0x03;  		int tmpFrequency = GetFrequency ((MpegVersion)tmpMpegID' (tmpFrameHeader [2] >> 2) & 0x03);  		// Check for invalid frequency  		if (tmpFrequency == 0) {  			stream.Seek (-3' SeekOrigin.Current);  			continue;  		}  		int tmpSamplesPerFrame = GetSamplesPerFrame ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum);  		int tmpUsesPadding = (tmpFrameHeader [2] >> 1) & 0x01;  		double tmpFrameSizeConst = 125.0 * tmpSamplesPerFrame / tmpFrequency;  		int tmpPaddingSize = (tmpLayerNum == 3 ? 4 : 1);  		int tmpBitrateIndex = tmpFrameHeader [2] >> 4;  		// Check for invalid values  		if (tmpBitrateIndex < 1 || tmpBitrateIndex > 14 || tmpLayerNum == 0) {  			stream.Seek (-3' SeekOrigin.Current);  			continue;  		}  		int tmpFrameBitrate = GetBitrate ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum' tmpBitrateIndex);  		int tmpFrameSize = (int)(tmpFrameBitrate * tmpFrameSizeConst) + (tmpUsesPadding * tmpPaddingSize);  		_headerOffset = stream.Position - 4;  		if (tmpFrameSize < 8) {  			stream.Seek (-3' SeekOrigin.Current);  			continue;  		}  		// 7/21/05 - Check for 0x00 or 0xFF at end of last frame  		// this sucks for tracks that start with silence  		if (_headerOffset >= 1 && !acceptNullSamples)// if (ftell(fp) >= 5)  		 {  			stream.Seek (-5' SeekOrigin.Current);  			byte tmpLastByte = stream.Read1 ();  			stream.Seek (4' SeekOrigin.Current);  			if (tmpFrameBitrate != 320 && (tmpLastByte == 0x00 || tmpLastByte == 0xFF)) {  				// 7/31/05  				// may be a valid frame - skip its contents to prevent false sync  				long tmpNewPosition = _headerOffset + tmpFrameSize;  				if (tmpFrameSize == 0)  					tmpNewPosition++;  				stream.Seek (tmpNewPosition' SeekOrigin.Begin);  				continue;  			}  		}  		/*if (BR == 0 || FrameSizeConst == 0)                         {                             startpos = HeaderOffset+1;                             fseek(fp' startpos' SEEK_SET);                             continue;                         }*/stream.Seek (_headerOffset + tmpFrameSize' SeekOrigin.Begin);  		if (stream.Read1 () == 0xFF) {  			fh1 = stream.Read1 ();  			fh2 = stream.Read1 ();  			if (tmpFrameHeader [1] == fh1 && (tmpFrameHeader [2] & 0x0D) == (fh2 & 0x0D)) {  				// header found  				break;  			}  		}  		stream.Seek (_headerOffset + 1' SeekOrigin.Begin);  		continue;  	}  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: while (true) {  	int tmpByte = stream.ReadByte ();  	// keep as ReadByte  	while (tmpByte != 0xFF && tmpByte != -1) {  		tmpByte = stream.ReadByte ();  		// keep as ReadByte  	}  	if (tmpByte == -1) {  		if (acceptNullSamples) {  			throw new InvalidDataException (string.Format ("'{0}': Can't find frame sync"' path));  		}  		stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  		acceptNullSamples = true;  		continue;  	}  	tmpFrameHeader [0] = (byte)tmpByte;  	// Get frame header  	if (stream.Read (tmpFrameHeader' 1' 3) != 3) {  		throw new InvalidDataException (string.Format ("'{0}': Invalid MPEG file; end of stream reached"' path));  	}  	// No sync  	if ((tmpFrameHeader [1] >> 5) != 0x07 || ((tmpFrameHeader [1] >> 1) & 0x03) == 0)// 2/18/05 - ignore reserved layer  	 {  		stream.Seek (-3' SeekOrigin.Current);  	} else if (tmpFrameHeader [1] == 0xFF || ((tmpFrameHeader [1] >> 3) & 0x03) == 1)// 2/19/05 - more bad data  	 {  		stream.Seek (-3' SeekOrigin.Current);  	} else {  		int tmpMpegID = (tmpFrameHeader [1] >> 3) & 0x03;  		int tmpLayerNum = (tmpFrameHeader [1] >> 1) & 0x03;  		int tmpFrequency = GetFrequency ((MpegVersion)tmpMpegID' (tmpFrameHeader [2] >> 2) & 0x03);  		// Check for invalid frequency  		if (tmpFrequency == 0) {  			stream.Seek (-3' SeekOrigin.Current);  			continue;  		}  		int tmpSamplesPerFrame = GetSamplesPerFrame ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum);  		int tmpUsesPadding = (tmpFrameHeader [2] >> 1) & 0x01;  		double tmpFrameSizeConst = 125.0 * tmpSamplesPerFrame / tmpFrequency;  		int tmpPaddingSize = (tmpLayerNum == 3 ? 4 : 1);  		int tmpBitrateIndex = tmpFrameHeader [2] >> 4;  		// Check for invalid values  		if (tmpBitrateIndex < 1 || tmpBitrateIndex > 14 || tmpLayerNum == 0) {  			stream.Seek (-3' SeekOrigin.Current);  			continue;  		}  		int tmpFrameBitrate = GetBitrate ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum' tmpBitrateIndex);  		int tmpFrameSize = (int)(tmpFrameBitrate * tmpFrameSizeConst) + (tmpUsesPadding * tmpPaddingSize);  		_headerOffset = stream.Position - 4;  		if (tmpFrameSize < 8) {  			stream.Seek (-3' SeekOrigin.Current);  			continue;  		}  		// 7/21/05 - Check for 0x00 or 0xFF at end of last frame  		// this sucks for tracks that start with silence  		if (_headerOffset >= 1 && !acceptNullSamples)// if (ftell(fp) >= 5)  		 {  			stream.Seek (-5' SeekOrigin.Current);  			byte tmpLastByte = stream.Read1 ();  			stream.Seek (4' SeekOrigin.Current);  			if (tmpFrameBitrate != 320 && (tmpLastByte == 0x00 || tmpLastByte == 0xFF)) {  				// 7/31/05  				// may be a valid frame - skip its contents to prevent false sync  				long tmpNewPosition = _headerOffset + tmpFrameSize;  				if (tmpFrameSize == 0)  					tmpNewPosition++;  				stream.Seek (tmpNewPosition' SeekOrigin.Begin);  				continue;  			}  		}  		/*if (BR == 0 || FrameSizeConst == 0)                         {                             startpos = HeaderOffset+1;                             fseek(fp' startpos' SEEK_SET);                             continue;                         }*/stream.Seek (_headerOffset + tmpFrameSize' SeekOrigin.Begin);  		if (stream.Read1 () == 0xFF) {  			fh1 = stream.Read1 ();  			fh2 = stream.Read1 ();  			if (tmpFrameHeader [1] == fh1 && (tmpFrameHeader [2] & 0x0D) == (fh2 & 0x0D)) {  				// header found  				break;  			}  		}  		stream.Seek (_headerOffset + 1' SeekOrigin.Begin);  		continue;  	}  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: while (true) {  	int tmpByte = stream.ReadByte ();  	// keep as ReadByte  	while (tmpByte != 0xFF && tmpByte != -1) {  		tmpByte = stream.ReadByte ();  		// keep as ReadByte  	}  	if (tmpByte == -1) {  		if (acceptNullSamples) {  			throw new InvalidDataException (string.Format ("'{0}': Can't find frame sync"' path));  		}  		stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  		acceptNullSamples = true;  		continue;  	}  	tmpFrameHeader [0] = (byte)tmpByte;  	// Get frame header  	if (stream.Read (tmpFrameHeader' 1' 3) != 3) {  		throw new InvalidDataException (string.Format ("'{0}': Invalid MPEG file; end of stream reached"' path));  	}  	// No sync  	if ((tmpFrameHeader [1] >> 5) != 0x07 || ((tmpFrameHeader [1] >> 1) & 0x03) == 0)// 2/18/05 - ignore reserved layer  	 {  		stream.Seek (-3' SeekOrigin.Current);  	} else if (tmpFrameHeader [1] == 0xFF || ((tmpFrameHeader [1] >> 3) & 0x03) == 1)// 2/19/05 - more bad data  	 {  		stream.Seek (-3' SeekOrigin.Current);  	} else {  		int tmpMpegID = (tmpFrameHeader [1] >> 3) & 0x03;  		int tmpLayerNum = (tmpFrameHeader [1] >> 1) & 0x03;  		int tmpFrequency = GetFrequency ((MpegVersion)tmpMpegID' (tmpFrameHeader [2] >> 2) & 0x03);  		// Check for invalid frequency  		if (tmpFrequency == 0) {  			stream.Seek (-3' SeekOrigin.Current);  			continue;  		}  		int tmpSamplesPerFrame = GetSamplesPerFrame ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum);  		int tmpUsesPadding = (tmpFrameHeader [2] >> 1) & 0x01;  		double tmpFrameSizeConst = 125.0 * tmpSamplesPerFrame / tmpFrequency;  		int tmpPaddingSize = (tmpLayerNum == 3 ? 4 : 1);  		int tmpBitrateIndex = tmpFrameHeader [2] >> 4;  		// Check for invalid values  		if (tmpBitrateIndex < 1 || tmpBitrateIndex > 14 || tmpLayerNum == 0) {  			stream.Seek (-3' SeekOrigin.Current);  			continue;  		}  		int tmpFrameBitrate = GetBitrate ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum' tmpBitrateIndex);  		int tmpFrameSize = (int)(tmpFrameBitrate * tmpFrameSizeConst) + (tmpUsesPadding * tmpPaddingSize);  		_headerOffset = stream.Position - 4;  		if (tmpFrameSize < 8) {  			stream.Seek (-3' SeekOrigin.Current);  			continue;  		}  		// 7/21/05 - Check for 0x00 or 0xFF at end of last frame  		// this sucks for tracks that start with silence  		if (_headerOffset >= 1 && !acceptNullSamples)// if (ftell(fp) >= 5)  		 {  			stream.Seek (-5' SeekOrigin.Current);  			byte tmpLastByte = stream.Read1 ();  			stream.Seek (4' SeekOrigin.Current);  			if (tmpFrameBitrate != 320 && (tmpLastByte == 0x00 || tmpLastByte == 0xFF)) {  				// 7/31/05  				// may be a valid frame - skip its contents to prevent false sync  				long tmpNewPosition = _headerOffset + tmpFrameSize;  				if (tmpFrameSize == 0)  					tmpNewPosition++;  				stream.Seek (tmpNewPosition' SeekOrigin.Begin);  				continue;  			}  		}  		/*if (BR == 0 || FrameSizeConst == 0)                         {                             startpos = HeaderOffset+1;                             fseek(fp' startpos' SEEK_SET);                             continue;                         }*/stream.Seek (_headerOffset + tmpFrameSize' SeekOrigin.Begin);  		if (stream.Read1 () == 0xFF) {  			fh1 = stream.Read1 ();  			fh2 = stream.Read1 ();  			if (tmpFrameHeader [1] == fh1 && (tmpFrameHeader [2] & 0x0D) == (fh2 & 0x0D)) {  				// header found  				break;  			}  		}  		stream.Seek (_headerOffset + 1' SeekOrigin.Begin);  		continue;  	}  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: while (true) {  	int tmpByte = stream.ReadByte ();  	// keep as ReadByte  	while (tmpByte != 0xFF && tmpByte != -1) {  		tmpByte = stream.ReadByte ();  		// keep as ReadByte  	}  	if (tmpByte == -1) {  		if (acceptNullSamples) {  			throw new InvalidDataException (string.Format ("'{0}': Can't find frame sync"' path));  		}  		stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  		acceptNullSamples = true;  		continue;  	}  	tmpFrameHeader [0] = (byte)tmpByte;  	// Get frame header  	if (stream.Read (tmpFrameHeader' 1' 3) != 3) {  		throw new InvalidDataException (string.Format ("'{0}': Invalid MPEG file; end of stream reached"' path));  	}  	// No sync  	if ((tmpFrameHeader [1] >> 5) != 0x07 || ((tmpFrameHeader [1] >> 1) & 0x03) == 0)// 2/18/05 - ignore reserved layer  	 {  		stream.Seek (-3' SeekOrigin.Current);  	} else if (tmpFrameHeader [1] == 0xFF || ((tmpFrameHeader [1] >> 3) & 0x03) == 1)// 2/19/05 - more bad data  	 {  		stream.Seek (-3' SeekOrigin.Current);  	} else {  		int tmpMpegID = (tmpFrameHeader [1] >> 3) & 0x03;  		int tmpLayerNum = (tmpFrameHeader [1] >> 1) & 0x03;  		int tmpFrequency = GetFrequency ((MpegVersion)tmpMpegID' (tmpFrameHeader [2] >> 2) & 0x03);  		// Check for invalid frequency  		if (tmpFrequency == 0) {  			stream.Seek (-3' SeekOrigin.Current);  			continue;  		}  		int tmpSamplesPerFrame = GetSamplesPerFrame ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum);  		int tmpUsesPadding = (tmpFrameHeader [2] >> 1) & 0x01;  		double tmpFrameSizeConst = 125.0 * tmpSamplesPerFrame / tmpFrequency;  		int tmpPaddingSize = (tmpLayerNum == 3 ? 4 : 1);  		int tmpBitrateIndex = tmpFrameHeader [2] >> 4;  		// Check for invalid values  		if (tmpBitrateIndex < 1 || tmpBitrateIndex > 14 || tmpLayerNum == 0) {  			stream.Seek (-3' SeekOrigin.Current);  			continue;  		}  		int tmpFrameBitrate = GetBitrate ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum' tmpBitrateIndex);  		int tmpFrameSize = (int)(tmpFrameBitrate * tmpFrameSizeConst) + (tmpUsesPadding * tmpPaddingSize);  		_headerOffset = stream.Position - 4;  		if (tmpFrameSize < 8) {  			stream.Seek (-3' SeekOrigin.Current);  			continue;  		}  		// 7/21/05 - Check for 0x00 or 0xFF at end of last frame  		// this sucks for tracks that start with silence  		if (_headerOffset >= 1 && !acceptNullSamples)// if (ftell(fp) >= 5)  		 {  			stream.Seek (-5' SeekOrigin.Current);  			byte tmpLastByte = stream.Read1 ();  			stream.Seek (4' SeekOrigin.Current);  			if (tmpFrameBitrate != 320 && (tmpLastByte == 0x00 || tmpLastByte == 0xFF)) {  				// 7/31/05  				// may be a valid frame - skip its contents to prevent false sync  				long tmpNewPosition = _headerOffset + tmpFrameSize;  				if (tmpFrameSize == 0)  					tmpNewPosition++;  				stream.Seek (tmpNewPosition' SeekOrigin.Begin);  				continue;  			}  		}  		/*if (BR == 0 || FrameSizeConst == 0)                         {                             startpos = HeaderOffset+1;                             fseek(fp' startpos' SEEK_SET);                             continue;                         }*/stream.Seek (_headerOffset + tmpFrameSize' SeekOrigin.Begin);  		if (stream.Read1 () == 0xFF) {  			fh1 = stream.Read1 ();  			fh2 = stream.Read1 ();  			if (tmpFrameHeader [1] == fh1 && (tmpFrameHeader [2] & 0x0D) == (fh2 & 0x0D)) {  				// header found  				break;  			}  		}  		stream.Seek (_headerOffset + 1' SeekOrigin.Begin);  		continue;  	}  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: while (true) {  	int tmpByte = stream.ReadByte ();  	// keep as ReadByte  	while (tmpByte != 0xFF && tmpByte != -1) {  		tmpByte = stream.ReadByte ();  		// keep as ReadByte  	}  	if (tmpByte == -1) {  		if (acceptNullSamples) {  			throw new InvalidDataException (string.Format ("'{0}': Can't find frame sync"' path));  		}  		stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  		acceptNullSamples = true;  		continue;  	}  	tmpFrameHeader [0] = (byte)tmpByte;  	// Get frame header  	if (stream.Read (tmpFrameHeader' 1' 3) != 3) {  		throw new InvalidDataException (string.Format ("'{0}': Invalid MPEG file; end of stream reached"' path));  	}  	// No sync  	if ((tmpFrameHeader [1] >> 5) != 0x07 || ((tmpFrameHeader [1] >> 1) & 0x03) == 0)// 2/18/05 - ignore reserved layer  	 {  		stream.Seek (-3' SeekOrigin.Current);  	} else if (tmpFrameHeader [1] == 0xFF || ((tmpFrameHeader [1] >> 3) & 0x03) == 1)// 2/19/05 - more bad data  	 {  		stream.Seek (-3' SeekOrigin.Current);  	} else {  		int tmpMpegID = (tmpFrameHeader [1] >> 3) & 0x03;  		int tmpLayerNum = (tmpFrameHeader [1] >> 1) & 0x03;  		int tmpFrequency = GetFrequency ((MpegVersion)tmpMpegID' (tmpFrameHeader [2] >> 2) & 0x03);  		// Check for invalid frequency  		if (tmpFrequency == 0) {  			stream.Seek (-3' SeekOrigin.Current);  			continue;  		}  		int tmpSamplesPerFrame = GetSamplesPerFrame ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum);  		int tmpUsesPadding = (tmpFrameHeader [2] >> 1) & 0x01;  		double tmpFrameSizeConst = 125.0 * tmpSamplesPerFrame / tmpFrequency;  		int tmpPaddingSize = (tmpLayerNum == 3 ? 4 : 1);  		int tmpBitrateIndex = tmpFrameHeader [2] >> 4;  		// Check for invalid values  		if (tmpBitrateIndex < 1 || tmpBitrateIndex > 14 || tmpLayerNum == 0) {  			stream.Seek (-3' SeekOrigin.Current);  			continue;  		}  		int tmpFrameBitrate = GetBitrate ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum' tmpBitrateIndex);  		int tmpFrameSize = (int)(tmpFrameBitrate * tmpFrameSizeConst) + (tmpUsesPadding * tmpPaddingSize);  		_headerOffset = stream.Position - 4;  		if (tmpFrameSize < 8) {  			stream.Seek (-3' SeekOrigin.Current);  			continue;  		}  		// 7/21/05 - Check for 0x00 or 0xFF at end of last frame  		// this sucks for tracks that start with silence  		if (_headerOffset >= 1 && !acceptNullSamples)// if (ftell(fp) >= 5)  		 {  			stream.Seek (-5' SeekOrigin.Current);  			byte tmpLastByte = stream.Read1 ();  			stream.Seek (4' SeekOrigin.Current);  			if (tmpFrameBitrate != 320 && (tmpLastByte == 0x00 || tmpLastByte == 0xFF)) {  				// 7/31/05  				// may be a valid frame - skip its contents to prevent false sync  				long tmpNewPosition = _headerOffset + tmpFrameSize;  				if (tmpFrameSize == 0)  					tmpNewPosition++;  				stream.Seek (tmpNewPosition' SeekOrigin.Begin);  				continue;  			}  		}  		/*if (BR == 0 || FrameSizeConst == 0)                         {                             startpos = HeaderOffset+1;                             fseek(fp' startpos' SEEK_SET);                             continue;                         }*/stream.Seek (_headerOffset + tmpFrameSize' SeekOrigin.Begin);  		if (stream.Read1 () == 0xFF) {  			fh1 = stream.Read1 ();  			fh2 = stream.Read1 ();  			if (tmpFrameHeader [1] == fh1 && (tmpFrameHeader [2] & 0x0D) == (fh2 & 0x0D)) {  				// header found  				break;  			}  		}  		stream.Seek (_headerOffset + 1' SeekOrigin.Begin);  		continue;  	}  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: while (true) {  	int tmpByte = stream.ReadByte ();  	// keep as ReadByte  	while (tmpByte != 0xFF && tmpByte != -1) {  		tmpByte = stream.ReadByte ();  		// keep as ReadByte  	}  	if (tmpByte == -1) {  		if (acceptNullSamples) {  			throw new InvalidDataException (string.Format ("'{0}': Can't find frame sync"' path));  		}  		stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  		acceptNullSamples = true;  		continue;  	}  	tmpFrameHeader [0] = (byte)tmpByte;  	// Get frame header  	if (stream.Read (tmpFrameHeader' 1' 3) != 3) {  		throw new InvalidDataException (string.Format ("'{0}': Invalid MPEG file; end of stream reached"' path));  	}  	// No sync  	if ((tmpFrameHeader [1] >> 5) != 0x07 || ((tmpFrameHeader [1] >> 1) & 0x03) == 0)// 2/18/05 - ignore reserved layer  	 {  		stream.Seek (-3' SeekOrigin.Current);  	} else if (tmpFrameHeader [1] == 0xFF || ((tmpFrameHeader [1] >> 3) & 0x03) == 1)// 2/19/05 - more bad data  	 {  		stream.Seek (-3' SeekOrigin.Current);  	} else {  		int tmpMpegID = (tmpFrameHeader [1] >> 3) & 0x03;  		int tmpLayerNum = (tmpFrameHeader [1] >> 1) & 0x03;  		int tmpFrequency = GetFrequency ((MpegVersion)tmpMpegID' (tmpFrameHeader [2] >> 2) & 0x03);  		// Check for invalid frequency  		if (tmpFrequency == 0) {  			stream.Seek (-3' SeekOrigin.Current);  			continue;  		}  		int tmpSamplesPerFrame = GetSamplesPerFrame ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum);  		int tmpUsesPadding = (tmpFrameHeader [2] >> 1) & 0x01;  		double tmpFrameSizeConst = 125.0 * tmpSamplesPerFrame / tmpFrequency;  		int tmpPaddingSize = (tmpLayerNum == 3 ? 4 : 1);  		int tmpBitrateIndex = tmpFrameHeader [2] >> 4;  		// Check for invalid values  		if (tmpBitrateIndex < 1 || tmpBitrateIndex > 14 || tmpLayerNum == 0) {  			stream.Seek (-3' SeekOrigin.Current);  			continue;  		}  		int tmpFrameBitrate = GetBitrate ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum' tmpBitrateIndex);  		int tmpFrameSize = (int)(tmpFrameBitrate * tmpFrameSizeConst) + (tmpUsesPadding * tmpPaddingSize);  		_headerOffset = stream.Position - 4;  		if (tmpFrameSize < 8) {  			stream.Seek (-3' SeekOrigin.Current);  			continue;  		}  		// 7/21/05 - Check for 0x00 or 0xFF at end of last frame  		// this sucks for tracks that start with silence  		if (_headerOffset >= 1 && !acceptNullSamples)// if (ftell(fp) >= 5)  		 {  			stream.Seek (-5' SeekOrigin.Current);  			byte tmpLastByte = stream.Read1 ();  			stream.Seek (4' SeekOrigin.Current);  			if (tmpFrameBitrate != 320 && (tmpLastByte == 0x00 || tmpLastByte == 0xFF)) {  				// 7/31/05  				// may be a valid frame - skip its contents to prevent false sync  				long tmpNewPosition = _headerOffset + tmpFrameSize;  				if (tmpFrameSize == 0)  					tmpNewPosition++;  				stream.Seek (tmpNewPosition' SeekOrigin.Begin);  				continue;  			}  		}  		/*if (BR == 0 || FrameSizeConst == 0)                         {                             startpos = HeaderOffset+1;                             fseek(fp' startpos' SEEK_SET);                             continue;                         }*/stream.Seek (_headerOffset + tmpFrameSize' SeekOrigin.Begin);  		if (stream.Read1 () == 0xFF) {  			fh1 = stream.Read1 ();  			fh2 = stream.Read1 ();  			if (tmpFrameHeader [1] == fh1 && (tmpFrameHeader [2] & 0x0D) == (fh2 & 0x0D)) {  				// header found  				break;  			}  		}  		stream.Seek (_headerOffset + 1' SeekOrigin.Begin);  		continue;  	}  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: while (true) {  	int tmpByte = stream.ReadByte ();  	// keep as ReadByte  	while (tmpByte != 0xFF && tmpByte != -1) {  		tmpByte = stream.ReadByte ();  		// keep as ReadByte  	}  	if (tmpByte == -1) {  		if (acceptNullSamples) {  			throw new InvalidDataException (string.Format ("'{0}': Can't find frame sync"' path));  		}  		stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  		acceptNullSamples = true;  		continue;  	}  	tmpFrameHeader [0] = (byte)tmpByte;  	// Get frame header  	if (stream.Read (tmpFrameHeader' 1' 3) != 3) {  		throw new InvalidDataException (string.Format ("'{0}': Invalid MPEG file; end of stream reached"' path));  	}  	// No sync  	if ((tmpFrameHeader [1] >> 5) != 0x07 || ((tmpFrameHeader [1] >> 1) & 0x03) == 0)// 2/18/05 - ignore reserved layer  	 {  		stream.Seek (-3' SeekOrigin.Current);  	} else if (tmpFrameHeader [1] == 0xFF || ((tmpFrameHeader [1] >> 3) & 0x03) == 1)// 2/19/05 - more bad data  	 {  		stream.Seek (-3' SeekOrigin.Current);  	} else {  		int tmpMpegID = (tmpFrameHeader [1] >> 3) & 0x03;  		int tmpLayerNum = (tmpFrameHeader [1] >> 1) & 0x03;  		int tmpFrequency = GetFrequency ((MpegVersion)tmpMpegID' (tmpFrameHeader [2] >> 2) & 0x03);  		// Check for invalid frequency  		if (tmpFrequency == 0) {  			stream.Seek (-3' SeekOrigin.Current);  			continue;  		}  		int tmpSamplesPerFrame = GetSamplesPerFrame ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum);  		int tmpUsesPadding = (tmpFrameHeader [2] >> 1) & 0x01;  		double tmpFrameSizeConst = 125.0 * tmpSamplesPerFrame / tmpFrequency;  		int tmpPaddingSize = (tmpLayerNum == 3 ? 4 : 1);  		int tmpBitrateIndex = tmpFrameHeader [2] >> 4;  		// Check for invalid values  		if (tmpBitrateIndex < 1 || tmpBitrateIndex > 14 || tmpLayerNum == 0) {  			stream.Seek (-3' SeekOrigin.Current);  			continue;  		}  		int tmpFrameBitrate = GetBitrate ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum' tmpBitrateIndex);  		int tmpFrameSize = (int)(tmpFrameBitrate * tmpFrameSizeConst) + (tmpUsesPadding * tmpPaddingSize);  		_headerOffset = stream.Position - 4;  		if (tmpFrameSize < 8) {  			stream.Seek (-3' SeekOrigin.Current);  			continue;  		}  		// 7/21/05 - Check for 0x00 or 0xFF at end of last frame  		// this sucks for tracks that start with silence  		if (_headerOffset >= 1 && !acceptNullSamples)// if (ftell(fp) >= 5)  		 {  			stream.Seek (-5' SeekOrigin.Current);  			byte tmpLastByte = stream.Read1 ();  			stream.Seek (4' SeekOrigin.Current);  			if (tmpFrameBitrate != 320 && (tmpLastByte == 0x00 || tmpLastByte == 0xFF)) {  				// 7/31/05  				// may be a valid frame - skip its contents to prevent false sync  				long tmpNewPosition = _headerOffset + tmpFrameSize;  				if (tmpFrameSize == 0)  					tmpNewPosition++;  				stream.Seek (tmpNewPosition' SeekOrigin.Begin);  				continue;  			}  		}  		/*if (BR == 0 || FrameSizeConst == 0)                         {                             startpos = HeaderOffset+1;                             fseek(fp' startpos' SEEK_SET);                             continue;                         }*/stream.Seek (_headerOffset + tmpFrameSize' SeekOrigin.Begin);  		if (stream.Read1 () == 0xFF) {  			fh1 = stream.Read1 ();  			fh2 = stream.Read1 ();  			if (tmpFrameHeader [1] == fh1 && (tmpFrameHeader [2] & 0x0D) == (fh2 & 0x0D)) {  				// header found  				break;  			}  		}  		stream.Seek (_headerOffset + 1' SeekOrigin.Begin);  		continue;  	}  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: while (true) {  	int tmpByte = stream.ReadByte ();  	// keep as ReadByte  	while (tmpByte != 0xFF && tmpByte != -1) {  		tmpByte = stream.ReadByte ();  		// keep as ReadByte  	}  	if (tmpByte == -1) {  		if (acceptNullSamples) {  			throw new InvalidDataException (string.Format ("'{0}': Can't find frame sync"' path));  		}  		stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  		acceptNullSamples = true;  		continue;  	}  	tmpFrameHeader [0] = (byte)tmpByte;  	// Get frame header  	if (stream.Read (tmpFrameHeader' 1' 3) != 3) {  		throw new InvalidDataException (string.Format ("'{0}': Invalid MPEG file; end of stream reached"' path));  	}  	// No sync  	if ((tmpFrameHeader [1] >> 5) != 0x07 || ((tmpFrameHeader [1] >> 1) & 0x03) == 0)// 2/18/05 - ignore reserved layer  	 {  		stream.Seek (-3' SeekOrigin.Current);  	} else if (tmpFrameHeader [1] == 0xFF || ((tmpFrameHeader [1] >> 3) & 0x03) == 1)// 2/19/05 - more bad data  	 {  		stream.Seek (-3' SeekOrigin.Current);  	} else {  		int tmpMpegID = (tmpFrameHeader [1] >> 3) & 0x03;  		int tmpLayerNum = (tmpFrameHeader [1] >> 1) & 0x03;  		int tmpFrequency = GetFrequency ((MpegVersion)tmpMpegID' (tmpFrameHeader [2] >> 2) & 0x03);  		// Check for invalid frequency  		if (tmpFrequency == 0) {  			stream.Seek (-3' SeekOrigin.Current);  			continue;  		}  		int tmpSamplesPerFrame = GetSamplesPerFrame ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum);  		int tmpUsesPadding = (tmpFrameHeader [2] >> 1) & 0x01;  		double tmpFrameSizeConst = 125.0 * tmpSamplesPerFrame / tmpFrequency;  		int tmpPaddingSize = (tmpLayerNum == 3 ? 4 : 1);  		int tmpBitrateIndex = tmpFrameHeader [2] >> 4;  		// Check for invalid values  		if (tmpBitrateIndex < 1 || tmpBitrateIndex > 14 || tmpLayerNum == 0) {  			stream.Seek (-3' SeekOrigin.Current);  			continue;  		}  		int tmpFrameBitrate = GetBitrate ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum' tmpBitrateIndex);  		int tmpFrameSize = (int)(tmpFrameBitrate * tmpFrameSizeConst) + (tmpUsesPadding * tmpPaddingSize);  		_headerOffset = stream.Position - 4;  		if (tmpFrameSize < 8) {  			stream.Seek (-3' SeekOrigin.Current);  			continue;  		}  		// 7/21/05 - Check for 0x00 or 0xFF at end of last frame  		// this sucks for tracks that start with silence  		if (_headerOffset >= 1 && !acceptNullSamples)// if (ftell(fp) >= 5)  		 {  			stream.Seek (-5' SeekOrigin.Current);  			byte tmpLastByte = stream.Read1 ();  			stream.Seek (4' SeekOrigin.Current);  			if (tmpFrameBitrate != 320 && (tmpLastByte == 0x00 || tmpLastByte == 0xFF)) {  				// 7/31/05  				// may be a valid frame - skip its contents to prevent false sync  				long tmpNewPosition = _headerOffset + tmpFrameSize;  				if (tmpFrameSize == 0)  					tmpNewPosition++;  				stream.Seek (tmpNewPosition' SeekOrigin.Begin);  				continue;  			}  		}  		/*if (BR == 0 || FrameSizeConst == 0)                         {                             startpos = HeaderOffset+1;                             fseek(fp' startpos' SEEK_SET);                             continue;                         }*/stream.Seek (_headerOffset + tmpFrameSize' SeekOrigin.Begin);  		if (stream.Read1 () == 0xFF) {  			fh1 = stream.Read1 ();  			fh2 = stream.Read1 ();  			if (tmpFrameHeader [1] == fh1 && (tmpFrameHeader [2] & 0x0D) == (fh2 & 0x0D)) {  				// header found  				break;  			}  		}  		stream.Seek (_headerOffset + 1' SeekOrigin.Begin);  		continue;  	}  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: if (stream.Read (tmpFrameHeader' 1' 3) != 3) {  	throw new InvalidDataException (string.Format ("'{0}': Invalid MPEG file; end of stream reached"' path));  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: if (stream.Read (tmpFrameHeader' 1' 3) != 3) {  	throw new InvalidDataException (string.Format ("'{0}': Invalid MPEG file; end of stream reached"' path));  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: if ((tmpFrameHeader [1] >> 5) != 0x07 || ((tmpFrameHeader [1] >> 1) & 0x03) == 0)// 2/18/05 - ignore reserved layer   {  	stream.Seek (-3' SeekOrigin.Current);  } else if (tmpFrameHeader [1] == 0xFF || ((tmpFrameHeader [1] >> 3) & 0x03) == 1)// 2/19/05 - more bad data   {  	stream.Seek (-3' SeekOrigin.Current);  } else {  	int tmpMpegID = (tmpFrameHeader [1] >> 3) & 0x03;  	int tmpLayerNum = (tmpFrameHeader [1] >> 1) & 0x03;  	int tmpFrequency = GetFrequency ((MpegVersion)tmpMpegID' (tmpFrameHeader [2] >> 2) & 0x03);  	// Check for invalid frequency  	if (tmpFrequency == 0) {  		stream.Seek (-3' SeekOrigin.Current);  		continue;  	}  	int tmpSamplesPerFrame = GetSamplesPerFrame ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum);  	int tmpUsesPadding = (tmpFrameHeader [2] >> 1) & 0x01;  	double tmpFrameSizeConst = 125.0 * tmpSamplesPerFrame / tmpFrequency;  	int tmpPaddingSize = (tmpLayerNum == 3 ? 4 : 1);  	int tmpBitrateIndex = tmpFrameHeader [2] >> 4;  	// Check for invalid values  	if (tmpBitrateIndex < 1 || tmpBitrateIndex > 14 || tmpLayerNum == 0) {  		stream.Seek (-3' SeekOrigin.Current);  		continue;  	}  	int tmpFrameBitrate = GetBitrate ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum' tmpBitrateIndex);  	int tmpFrameSize = (int)(tmpFrameBitrate * tmpFrameSizeConst) + (tmpUsesPadding * tmpPaddingSize);  	_headerOffset = stream.Position - 4;  	if (tmpFrameSize < 8) {  		stream.Seek (-3' SeekOrigin.Current);  		continue;  	}  	// 7/21/05 - Check for 0x00 or 0xFF at end of last frame  	// this sucks for tracks that start with silence  	if (_headerOffset >= 1 && !acceptNullSamples)// if (ftell(fp) >= 5)  	 {  		stream.Seek (-5' SeekOrigin.Current);  		byte tmpLastByte = stream.Read1 ();  		stream.Seek (4' SeekOrigin.Current);  		if (tmpFrameBitrate != 320 && (tmpLastByte == 0x00 || tmpLastByte == 0xFF)) {  			// 7/31/05  			// may be a valid frame - skip its contents to prevent false sync  			long tmpNewPosition = _headerOffset + tmpFrameSize;  			if (tmpFrameSize == 0)  				tmpNewPosition++;  			stream.Seek (tmpNewPosition' SeekOrigin.Begin);  			continue;  		}  	}  	/*if (BR == 0 || FrameSizeConst == 0)                         {                             startpos = HeaderOffset+1;                             fseek(fp' startpos' SEEK_SET);                             continue;                         }*/stream.Seek (_headerOffset + tmpFrameSize' SeekOrigin.Begin);  	if (stream.Read1 () == 0xFF) {  		fh1 = stream.Read1 ();  		fh2 = stream.Read1 ();  		if (tmpFrameHeader [1] == fh1 && (tmpFrameHeader [2] & 0x0D) == (fh2 & 0x0D)) {  			// header found  			break;  		}  	}  	stream.Seek (_headerOffset + 1' SeekOrigin.Begin);  	continue;  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: if ((tmpFrameHeader [1] >> 5) != 0x07 || ((tmpFrameHeader [1] >> 1) & 0x03) == 0)// 2/18/05 - ignore reserved layer   {  	stream.Seek (-3' SeekOrigin.Current);  } else if (tmpFrameHeader [1] == 0xFF || ((tmpFrameHeader [1] >> 3) & 0x03) == 1)// 2/19/05 - more bad data   {  	stream.Seek (-3' SeekOrigin.Current);  } else {  	int tmpMpegID = (tmpFrameHeader [1] >> 3) & 0x03;  	int tmpLayerNum = (tmpFrameHeader [1] >> 1) & 0x03;  	int tmpFrequency = GetFrequency ((MpegVersion)tmpMpegID' (tmpFrameHeader [2] >> 2) & 0x03);  	// Check for invalid frequency  	if (tmpFrequency == 0) {  		stream.Seek (-3' SeekOrigin.Current);  		continue;  	}  	int tmpSamplesPerFrame = GetSamplesPerFrame ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum);  	int tmpUsesPadding = (tmpFrameHeader [2] >> 1) & 0x01;  	double tmpFrameSizeConst = 125.0 * tmpSamplesPerFrame / tmpFrequency;  	int tmpPaddingSize = (tmpLayerNum == 3 ? 4 : 1);  	int tmpBitrateIndex = tmpFrameHeader [2] >> 4;  	// Check for invalid values  	if (tmpBitrateIndex < 1 || tmpBitrateIndex > 14 || tmpLayerNum == 0) {  		stream.Seek (-3' SeekOrigin.Current);  		continue;  	}  	int tmpFrameBitrate = GetBitrate ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum' tmpBitrateIndex);  	int tmpFrameSize = (int)(tmpFrameBitrate * tmpFrameSizeConst) + (tmpUsesPadding * tmpPaddingSize);  	_headerOffset = stream.Position - 4;  	if (tmpFrameSize < 8) {  		stream.Seek (-3' SeekOrigin.Current);  		continue;  	}  	// 7/21/05 - Check for 0x00 or 0xFF at end of last frame  	// this sucks for tracks that start with silence  	if (_headerOffset >= 1 && !acceptNullSamples)// if (ftell(fp) >= 5)  	 {  		stream.Seek (-5' SeekOrigin.Current);  		byte tmpLastByte = stream.Read1 ();  		stream.Seek (4' SeekOrigin.Current);  		if (tmpFrameBitrate != 320 && (tmpLastByte == 0x00 || tmpLastByte == 0xFF)) {  			// 7/31/05  			// may be a valid frame - skip its contents to prevent false sync  			long tmpNewPosition = _headerOffset + tmpFrameSize;  			if (tmpFrameSize == 0)  				tmpNewPosition++;  			stream.Seek (tmpNewPosition' SeekOrigin.Begin);  			continue;  		}  	}  	/*if (BR == 0 || FrameSizeConst == 0)                         {                             startpos = HeaderOffset+1;                             fseek(fp' startpos' SEEK_SET);                             continue;                         }*/stream.Seek (_headerOffset + tmpFrameSize' SeekOrigin.Begin);  	if (stream.Read1 () == 0xFF) {  		fh1 = stream.Read1 ();  		fh2 = stream.Read1 ();  		if (tmpFrameHeader [1] == fh1 && (tmpFrameHeader [2] & 0x0D) == (fh2 & 0x0D)) {  			// header found  			break;  		}  	}  	stream.Seek (_headerOffset + 1' SeekOrigin.Begin);  	continue;  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: if ((tmpFrameHeader [1] >> 5) != 0x07 || ((tmpFrameHeader [1] >> 1) & 0x03) == 0)// 2/18/05 - ignore reserved layer   {  	stream.Seek (-3' SeekOrigin.Current);  } else if (tmpFrameHeader [1] == 0xFF || ((tmpFrameHeader [1] >> 3) & 0x03) == 1)// 2/19/05 - more bad data   {  	stream.Seek (-3' SeekOrigin.Current);  } else {  	int tmpMpegID = (tmpFrameHeader [1] >> 3) & 0x03;  	int tmpLayerNum = (tmpFrameHeader [1] >> 1) & 0x03;  	int tmpFrequency = GetFrequency ((MpegVersion)tmpMpegID' (tmpFrameHeader [2] >> 2) & 0x03);  	// Check for invalid frequency  	if (tmpFrequency == 0) {  		stream.Seek (-3' SeekOrigin.Current);  		continue;  	}  	int tmpSamplesPerFrame = GetSamplesPerFrame ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum);  	int tmpUsesPadding = (tmpFrameHeader [2] >> 1) & 0x01;  	double tmpFrameSizeConst = 125.0 * tmpSamplesPerFrame / tmpFrequency;  	int tmpPaddingSize = (tmpLayerNum == 3 ? 4 : 1);  	int tmpBitrateIndex = tmpFrameHeader [2] >> 4;  	// Check for invalid values  	if (tmpBitrateIndex < 1 || tmpBitrateIndex > 14 || tmpLayerNum == 0) {  		stream.Seek (-3' SeekOrigin.Current);  		continue;  	}  	int tmpFrameBitrate = GetBitrate ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum' tmpBitrateIndex);  	int tmpFrameSize = (int)(tmpFrameBitrate * tmpFrameSizeConst) + (tmpUsesPadding * tmpPaddingSize);  	_headerOffset = stream.Position - 4;  	if (tmpFrameSize < 8) {  		stream.Seek (-3' SeekOrigin.Current);  		continue;  	}  	// 7/21/05 - Check for 0x00 or 0xFF at end of last frame  	// this sucks for tracks that start with silence  	if (_headerOffset >= 1 && !acceptNullSamples)// if (ftell(fp) >= 5)  	 {  		stream.Seek (-5' SeekOrigin.Current);  		byte tmpLastByte = stream.Read1 ();  		stream.Seek (4' SeekOrigin.Current);  		if (tmpFrameBitrate != 320 && (tmpLastByte == 0x00 || tmpLastByte == 0xFF)) {  			// 7/31/05  			// may be a valid frame - skip its contents to prevent false sync  			long tmpNewPosition = _headerOffset + tmpFrameSize;  			if (tmpFrameSize == 0)  				tmpNewPosition++;  			stream.Seek (tmpNewPosition' SeekOrigin.Begin);  			continue;  		}  	}  	/*if (BR == 0 || FrameSizeConst == 0)                         {                             startpos = HeaderOffset+1;                             fseek(fp' startpos' SEEK_SET);                             continue;                         }*/stream.Seek (_headerOffset + tmpFrameSize' SeekOrigin.Begin);  	if (stream.Read1 () == 0xFF) {  		fh1 = stream.Read1 ();  		fh2 = stream.Read1 ();  		if (tmpFrameHeader [1] == fh1 && (tmpFrameHeader [2] & 0x0D) == (fh2 & 0x0D)) {  			// header found  			break;  		}  	}  	stream.Seek (_headerOffset + 1' SeekOrigin.Begin);  	continue;  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: if ((tmpFrameHeader [1] >> 5) != 0x07 || ((tmpFrameHeader [1] >> 1) & 0x03) == 0)// 2/18/05 - ignore reserved layer   {  	stream.Seek (-3' SeekOrigin.Current);  } else if (tmpFrameHeader [1] == 0xFF || ((tmpFrameHeader [1] >> 3) & 0x03) == 1)// 2/19/05 - more bad data   {  	stream.Seek (-3' SeekOrigin.Current);  } else {  	int tmpMpegID = (tmpFrameHeader [1] >> 3) & 0x03;  	int tmpLayerNum = (tmpFrameHeader [1] >> 1) & 0x03;  	int tmpFrequency = GetFrequency ((MpegVersion)tmpMpegID' (tmpFrameHeader [2] >> 2) & 0x03);  	// Check for invalid frequency  	if (tmpFrequency == 0) {  		stream.Seek (-3' SeekOrigin.Current);  		continue;  	}  	int tmpSamplesPerFrame = GetSamplesPerFrame ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum);  	int tmpUsesPadding = (tmpFrameHeader [2] >> 1) & 0x01;  	double tmpFrameSizeConst = 125.0 * tmpSamplesPerFrame / tmpFrequency;  	int tmpPaddingSize = (tmpLayerNum == 3 ? 4 : 1);  	int tmpBitrateIndex = tmpFrameHeader [2] >> 4;  	// Check for invalid values  	if (tmpBitrateIndex < 1 || tmpBitrateIndex > 14 || tmpLayerNum == 0) {  		stream.Seek (-3' SeekOrigin.Current);  		continue;  	}  	int tmpFrameBitrate = GetBitrate ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum' tmpBitrateIndex);  	int tmpFrameSize = (int)(tmpFrameBitrate * tmpFrameSizeConst) + (tmpUsesPadding * tmpPaddingSize);  	_headerOffset = stream.Position - 4;  	if (tmpFrameSize < 8) {  		stream.Seek (-3' SeekOrigin.Current);  		continue;  	}  	// 7/21/05 - Check for 0x00 or 0xFF at end of last frame  	// this sucks for tracks that start with silence  	if (_headerOffset >= 1 && !acceptNullSamples)// if (ftell(fp) >= 5)  	 {  		stream.Seek (-5' SeekOrigin.Current);  		byte tmpLastByte = stream.Read1 ();  		stream.Seek (4' SeekOrigin.Current);  		if (tmpFrameBitrate != 320 && (tmpLastByte == 0x00 || tmpLastByte == 0xFF)) {  			// 7/31/05  			// may be a valid frame - skip its contents to prevent false sync  			long tmpNewPosition = _headerOffset + tmpFrameSize;  			if (tmpFrameSize == 0)  				tmpNewPosition++;  			stream.Seek (tmpNewPosition' SeekOrigin.Begin);  			continue;  		}  	}  	/*if (BR == 0 || FrameSizeConst == 0)                         {                             startpos = HeaderOffset+1;                             fseek(fp' startpos' SEEK_SET);                             continue;                         }*/stream.Seek (_headerOffset + tmpFrameSize' SeekOrigin.Begin);  	if (stream.Read1 () == 0xFF) {  		fh1 = stream.Read1 ();  		fh2 = stream.Read1 ();  		if (tmpFrameHeader [1] == fh1 && (tmpFrameHeader [2] & 0x0D) == (fh2 & 0x0D)) {  			// header found  			break;  		}  	}  	stream.Seek (_headerOffset + 1' SeekOrigin.Begin);  	continue;  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: if ((tmpFrameHeader [1] >> 5) != 0x07 || ((tmpFrameHeader [1] >> 1) & 0x03) == 0)// 2/18/05 - ignore reserved layer   {  	stream.Seek (-3' SeekOrigin.Current);  } else if (tmpFrameHeader [1] == 0xFF || ((tmpFrameHeader [1] >> 3) & 0x03) == 1)// 2/19/05 - more bad data   {  	stream.Seek (-3' SeekOrigin.Current);  } else {  	int tmpMpegID = (tmpFrameHeader [1] >> 3) & 0x03;  	int tmpLayerNum = (tmpFrameHeader [1] >> 1) & 0x03;  	int tmpFrequency = GetFrequency ((MpegVersion)tmpMpegID' (tmpFrameHeader [2] >> 2) & 0x03);  	// Check for invalid frequency  	if (tmpFrequency == 0) {  		stream.Seek (-3' SeekOrigin.Current);  		continue;  	}  	int tmpSamplesPerFrame = GetSamplesPerFrame ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum);  	int tmpUsesPadding = (tmpFrameHeader [2] >> 1) & 0x01;  	double tmpFrameSizeConst = 125.0 * tmpSamplesPerFrame / tmpFrequency;  	int tmpPaddingSize = (tmpLayerNum == 3 ? 4 : 1);  	int tmpBitrateIndex = tmpFrameHeader [2] >> 4;  	// Check for invalid values  	if (tmpBitrateIndex < 1 || tmpBitrateIndex > 14 || tmpLayerNum == 0) {  		stream.Seek (-3' SeekOrigin.Current);  		continue;  	}  	int tmpFrameBitrate = GetBitrate ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum' tmpBitrateIndex);  	int tmpFrameSize = (int)(tmpFrameBitrate * tmpFrameSizeConst) + (tmpUsesPadding * tmpPaddingSize);  	_headerOffset = stream.Position - 4;  	if (tmpFrameSize < 8) {  		stream.Seek (-3' SeekOrigin.Current);  		continue;  	}  	// 7/21/05 - Check for 0x00 or 0xFF at end of last frame  	// this sucks for tracks that start with silence  	if (_headerOffset >= 1 && !acceptNullSamples)// if (ftell(fp) >= 5)  	 {  		stream.Seek (-5' SeekOrigin.Current);  		byte tmpLastByte = stream.Read1 ();  		stream.Seek (4' SeekOrigin.Current);  		if (tmpFrameBitrate != 320 && (tmpLastByte == 0x00 || tmpLastByte == 0xFF)) {  			// 7/31/05  			// may be a valid frame - skip its contents to prevent false sync  			long tmpNewPosition = _headerOffset + tmpFrameSize;  			if (tmpFrameSize == 0)  				tmpNewPosition++;  			stream.Seek (tmpNewPosition' SeekOrigin.Begin);  			continue;  		}  	}  	/*if (BR == 0 || FrameSizeConst == 0)                         {                             startpos = HeaderOffset+1;                             fseek(fp' startpos' SEEK_SET);                             continue;                         }*/stream.Seek (_headerOffset + tmpFrameSize' SeekOrigin.Begin);  	if (stream.Read1 () == 0xFF) {  		fh1 = stream.Read1 ();  		fh2 = stream.Read1 ();  		if (tmpFrameHeader [1] == fh1 && (tmpFrameHeader [2] & 0x0D) == (fh2 & 0x0D)) {  			// header found  			break;  		}  	}  	stream.Seek (_headerOffset + 1' SeekOrigin.Begin);  	continue;  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: if ((tmpFrameHeader [1] >> 5) != 0x07 || ((tmpFrameHeader [1] >> 1) & 0x03) == 0)// 2/18/05 - ignore reserved layer   {  	stream.Seek (-3' SeekOrigin.Current);  } else if (tmpFrameHeader [1] == 0xFF || ((tmpFrameHeader [1] >> 3) & 0x03) == 1)// 2/19/05 - more bad data   {  	stream.Seek (-3' SeekOrigin.Current);  } else {  	int tmpMpegID = (tmpFrameHeader [1] >> 3) & 0x03;  	int tmpLayerNum = (tmpFrameHeader [1] >> 1) & 0x03;  	int tmpFrequency = GetFrequency ((MpegVersion)tmpMpegID' (tmpFrameHeader [2] >> 2) & 0x03);  	// Check for invalid frequency  	if (tmpFrequency == 0) {  		stream.Seek (-3' SeekOrigin.Current);  		continue;  	}  	int tmpSamplesPerFrame = GetSamplesPerFrame ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum);  	int tmpUsesPadding = (tmpFrameHeader [2] >> 1) & 0x01;  	double tmpFrameSizeConst = 125.0 * tmpSamplesPerFrame / tmpFrequency;  	int tmpPaddingSize = (tmpLayerNum == 3 ? 4 : 1);  	int tmpBitrateIndex = tmpFrameHeader [2] >> 4;  	// Check for invalid values  	if (tmpBitrateIndex < 1 || tmpBitrateIndex > 14 || tmpLayerNum == 0) {  		stream.Seek (-3' SeekOrigin.Current);  		continue;  	}  	int tmpFrameBitrate = GetBitrate ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum' tmpBitrateIndex);  	int tmpFrameSize = (int)(tmpFrameBitrate * tmpFrameSizeConst) + (tmpUsesPadding * tmpPaddingSize);  	_headerOffset = stream.Position - 4;  	if (tmpFrameSize < 8) {  		stream.Seek (-3' SeekOrigin.Current);  		continue;  	}  	// 7/21/05 - Check for 0x00 or 0xFF at end of last frame  	// this sucks for tracks that start with silence  	if (_headerOffset >= 1 && !acceptNullSamples)// if (ftell(fp) >= 5)  	 {  		stream.Seek (-5' SeekOrigin.Current);  		byte tmpLastByte = stream.Read1 ();  		stream.Seek (4' SeekOrigin.Current);  		if (tmpFrameBitrate != 320 && (tmpLastByte == 0x00 || tmpLastByte == 0xFF)) {  			// 7/31/05  			// may be a valid frame - skip its contents to prevent false sync  			long tmpNewPosition = _headerOffset + tmpFrameSize;  			if (tmpFrameSize == 0)  				tmpNewPosition++;  			stream.Seek (tmpNewPosition' SeekOrigin.Begin);  			continue;  		}  	}  	/*if (BR == 0 || FrameSizeConst == 0)                         {                             startpos = HeaderOffset+1;                             fseek(fp' startpos' SEEK_SET);                             continue;                         }*/stream.Seek (_headerOffset + tmpFrameSize' SeekOrigin.Begin);  	if (stream.Read1 () == 0xFF) {  		fh1 = stream.Read1 ();  		fh2 = stream.Read1 ();  		if (tmpFrameHeader [1] == fh1 && (tmpFrameHeader [2] & 0x0D) == (fh2 & 0x0D)) {  			// header found  			break;  		}  	}  	stream.Seek (_headerOffset + 1' SeekOrigin.Begin);  	continue;  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: if ((tmpFrameHeader [1] >> 5) != 0x07 || ((tmpFrameHeader [1] >> 1) & 0x03) == 0)// 2/18/05 - ignore reserved layer   {  	stream.Seek (-3' SeekOrigin.Current);  } else if (tmpFrameHeader [1] == 0xFF || ((tmpFrameHeader [1] >> 3) & 0x03) == 1)// 2/19/05 - more bad data   {  	stream.Seek (-3' SeekOrigin.Current);  } else {  	int tmpMpegID = (tmpFrameHeader [1] >> 3) & 0x03;  	int tmpLayerNum = (tmpFrameHeader [1] >> 1) & 0x03;  	int tmpFrequency = GetFrequency ((MpegVersion)tmpMpegID' (tmpFrameHeader [2] >> 2) & 0x03);  	// Check for invalid frequency  	if (tmpFrequency == 0) {  		stream.Seek (-3' SeekOrigin.Current);  		continue;  	}  	int tmpSamplesPerFrame = GetSamplesPerFrame ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum);  	int tmpUsesPadding = (tmpFrameHeader [2] >> 1) & 0x01;  	double tmpFrameSizeConst = 125.0 * tmpSamplesPerFrame / tmpFrequency;  	int tmpPaddingSize = (tmpLayerNum == 3 ? 4 : 1);  	int tmpBitrateIndex = tmpFrameHeader [2] >> 4;  	// Check for invalid values  	if (tmpBitrateIndex < 1 || tmpBitrateIndex > 14 || tmpLayerNum == 0) {  		stream.Seek (-3' SeekOrigin.Current);  		continue;  	}  	int tmpFrameBitrate = GetBitrate ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum' tmpBitrateIndex);  	int tmpFrameSize = (int)(tmpFrameBitrate * tmpFrameSizeConst) + (tmpUsesPadding * tmpPaddingSize);  	_headerOffset = stream.Position - 4;  	if (tmpFrameSize < 8) {  		stream.Seek (-3' SeekOrigin.Current);  		continue;  	}  	// 7/21/05 - Check for 0x00 or 0xFF at end of last frame  	// this sucks for tracks that start with silence  	if (_headerOffset >= 1 && !acceptNullSamples)// if (ftell(fp) >= 5)  	 {  		stream.Seek (-5' SeekOrigin.Current);  		byte tmpLastByte = stream.Read1 ();  		stream.Seek (4' SeekOrigin.Current);  		if (tmpFrameBitrate != 320 && (tmpLastByte == 0x00 || tmpLastByte == 0xFF)) {  			// 7/31/05  			// may be a valid frame - skip its contents to prevent false sync  			long tmpNewPosition = _headerOffset + tmpFrameSize;  			if (tmpFrameSize == 0)  				tmpNewPosition++;  			stream.Seek (tmpNewPosition' SeekOrigin.Begin);  			continue;  		}  	}  	/*if (BR == 0 || FrameSizeConst == 0)                         {                             startpos = HeaderOffset+1;                             fseek(fp' startpos' SEEK_SET);                             continue;                         }*/stream.Seek (_headerOffset + tmpFrameSize' SeekOrigin.Begin);  	if (stream.Read1 () == 0xFF) {  		fh1 = stream.Read1 ();  		fh2 = stream.Read1 ();  		if (tmpFrameHeader [1] == fh1 && (tmpFrameHeader [2] & 0x0D) == (fh2 & 0x0D)) {  			// header found  			break;  		}  	}  	stream.Seek (_headerOffset + 1' SeekOrigin.Begin);  	continue;  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: if ((tmpFrameHeader [1] >> 5) != 0x07 || ((tmpFrameHeader [1] >> 1) & 0x03) == 0)// 2/18/05 - ignore reserved layer   {  	stream.Seek (-3' SeekOrigin.Current);  } else if (tmpFrameHeader [1] == 0xFF || ((tmpFrameHeader [1] >> 3) & 0x03) == 1)// 2/19/05 - more bad data   {  	stream.Seek (-3' SeekOrigin.Current);  } else {  	int tmpMpegID = (tmpFrameHeader [1] >> 3) & 0x03;  	int tmpLayerNum = (tmpFrameHeader [1] >> 1) & 0x03;  	int tmpFrequency = GetFrequency ((MpegVersion)tmpMpegID' (tmpFrameHeader [2] >> 2) & 0x03);  	// Check for invalid frequency  	if (tmpFrequency == 0) {  		stream.Seek (-3' SeekOrigin.Current);  		continue;  	}  	int tmpSamplesPerFrame = GetSamplesPerFrame ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum);  	int tmpUsesPadding = (tmpFrameHeader [2] >> 1) & 0x01;  	double tmpFrameSizeConst = 125.0 * tmpSamplesPerFrame / tmpFrequency;  	int tmpPaddingSize = (tmpLayerNum == 3 ? 4 : 1);  	int tmpBitrateIndex = tmpFrameHeader [2] >> 4;  	// Check for invalid values  	if (tmpBitrateIndex < 1 || tmpBitrateIndex > 14 || tmpLayerNum == 0) {  		stream.Seek (-3' SeekOrigin.Current);  		continue;  	}  	int tmpFrameBitrate = GetBitrate ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum' tmpBitrateIndex);  	int tmpFrameSize = (int)(tmpFrameBitrate * tmpFrameSizeConst) + (tmpUsesPadding * tmpPaddingSize);  	_headerOffset = stream.Position - 4;  	if (tmpFrameSize < 8) {  		stream.Seek (-3' SeekOrigin.Current);  		continue;  	}  	// 7/21/05 - Check for 0x00 or 0xFF at end of last frame  	// this sucks for tracks that start with silence  	if (_headerOffset >= 1 && !acceptNullSamples)// if (ftell(fp) >= 5)  	 {  		stream.Seek (-5' SeekOrigin.Current);  		byte tmpLastByte = stream.Read1 ();  		stream.Seek (4' SeekOrigin.Current);  		if (tmpFrameBitrate != 320 && (tmpLastByte == 0x00 || tmpLastByte == 0xFF)) {  			// 7/31/05  			// may be a valid frame - skip its contents to prevent false sync  			long tmpNewPosition = _headerOffset + tmpFrameSize;  			if (tmpFrameSize == 0)  				tmpNewPosition++;  			stream.Seek (tmpNewPosition' SeekOrigin.Begin);  			continue;  		}  	}  	/*if (BR == 0 || FrameSizeConst == 0)                         {                             startpos = HeaderOffset+1;                             fseek(fp' startpos' SEEK_SET);                             continue;                         }*/stream.Seek (_headerOffset + tmpFrameSize' SeekOrigin.Begin);  	if (stream.Read1 () == 0xFF) {  		fh1 = stream.Read1 ();  		fh2 = stream.Read1 ();  		if (tmpFrameHeader [1] == fh1 && (tmpFrameHeader [2] & 0x0D) == (fh2 & 0x0D)) {  			// header found  			break;  		}  	}  	stream.Seek (_headerOffset + 1' SeekOrigin.Begin);  	continue;  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: if ((tmpFrameHeader [1] >> 5) != 0x07 || ((tmpFrameHeader [1] >> 1) & 0x03) == 0)// 2/18/05 - ignore reserved layer   {  	stream.Seek (-3' SeekOrigin.Current);  } else if (tmpFrameHeader [1] == 0xFF || ((tmpFrameHeader [1] >> 3) & 0x03) == 1)// 2/19/05 - more bad data   {  	stream.Seek (-3' SeekOrigin.Current);  } else {  	int tmpMpegID = (tmpFrameHeader [1] >> 3) & 0x03;  	int tmpLayerNum = (tmpFrameHeader [1] >> 1) & 0x03;  	int tmpFrequency = GetFrequency ((MpegVersion)tmpMpegID' (tmpFrameHeader [2] >> 2) & 0x03);  	// Check for invalid frequency  	if (tmpFrequency == 0) {  		stream.Seek (-3' SeekOrigin.Current);  		continue;  	}  	int tmpSamplesPerFrame = GetSamplesPerFrame ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum);  	int tmpUsesPadding = (tmpFrameHeader [2] >> 1) & 0x01;  	double tmpFrameSizeConst = 125.0 * tmpSamplesPerFrame / tmpFrequency;  	int tmpPaddingSize = (tmpLayerNum == 3 ? 4 : 1);  	int tmpBitrateIndex = tmpFrameHeader [2] >> 4;  	// Check for invalid values  	if (tmpBitrateIndex < 1 || tmpBitrateIndex > 14 || tmpLayerNum == 0) {  		stream.Seek (-3' SeekOrigin.Current);  		continue;  	}  	int tmpFrameBitrate = GetBitrate ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum' tmpBitrateIndex);  	int tmpFrameSize = (int)(tmpFrameBitrate * tmpFrameSizeConst) + (tmpUsesPadding * tmpPaddingSize);  	_headerOffset = stream.Position - 4;  	if (tmpFrameSize < 8) {  		stream.Seek (-3' SeekOrigin.Current);  		continue;  	}  	// 7/21/05 - Check for 0x00 or 0xFF at end of last frame  	// this sucks for tracks that start with silence  	if (_headerOffset >= 1 && !acceptNullSamples)// if (ftell(fp) >= 5)  	 {  		stream.Seek (-5' SeekOrigin.Current);  		byte tmpLastByte = stream.Read1 ();  		stream.Seek (4' SeekOrigin.Current);  		if (tmpFrameBitrate != 320 && (tmpLastByte == 0x00 || tmpLastByte == 0xFF)) {  			// 7/31/05  			// may be a valid frame - skip its contents to prevent false sync  			long tmpNewPosition = _headerOffset + tmpFrameSize;  			if (tmpFrameSize == 0)  				tmpNewPosition++;  			stream.Seek (tmpNewPosition' SeekOrigin.Begin);  			continue;  		}  	}  	/*if (BR == 0 || FrameSizeConst == 0)                         {                             startpos = HeaderOffset+1;                             fseek(fp' startpos' SEEK_SET);                             continue;                         }*/stream.Seek (_headerOffset + tmpFrameSize' SeekOrigin.Begin);  	if (stream.Read1 () == 0xFF) {  		fh1 = stream.Read1 ();  		fh2 = stream.Read1 ();  		if (tmpFrameHeader [1] == fh1 && (tmpFrameHeader [2] & 0x0D) == (fh2 & 0x0D)) {  			// header found  			break;  		}  	}  	stream.Seek (_headerOffset + 1' SeekOrigin.Begin);  	continue;  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: if ((tmpFrameHeader [1] >> 5) != 0x07 || ((tmpFrameHeader [1] >> 1) & 0x03) == 0)// 2/18/05 - ignore reserved layer   {  	stream.Seek (-3' SeekOrigin.Current);  } else if (tmpFrameHeader [1] == 0xFF || ((tmpFrameHeader [1] >> 3) & 0x03) == 1)// 2/19/05 - more bad data   {  	stream.Seek (-3' SeekOrigin.Current);  } else {  	int tmpMpegID = (tmpFrameHeader [1] >> 3) & 0x03;  	int tmpLayerNum = (tmpFrameHeader [1] >> 1) & 0x03;  	int tmpFrequency = GetFrequency ((MpegVersion)tmpMpegID' (tmpFrameHeader [2] >> 2) & 0x03);  	// Check for invalid frequency  	if (tmpFrequency == 0) {  		stream.Seek (-3' SeekOrigin.Current);  		continue;  	}  	int tmpSamplesPerFrame = GetSamplesPerFrame ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum);  	int tmpUsesPadding = (tmpFrameHeader [2] >> 1) & 0x01;  	double tmpFrameSizeConst = 125.0 * tmpSamplesPerFrame / tmpFrequency;  	int tmpPaddingSize = (tmpLayerNum == 3 ? 4 : 1);  	int tmpBitrateIndex = tmpFrameHeader [2] >> 4;  	// Check for invalid values  	if (tmpBitrateIndex < 1 || tmpBitrateIndex > 14 || tmpLayerNum == 0) {  		stream.Seek (-3' SeekOrigin.Current);  		continue;  	}  	int tmpFrameBitrate = GetBitrate ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum' tmpBitrateIndex);  	int tmpFrameSize = (int)(tmpFrameBitrate * tmpFrameSizeConst) + (tmpUsesPadding * tmpPaddingSize);  	_headerOffset = stream.Position - 4;  	if (tmpFrameSize < 8) {  		stream.Seek (-3' SeekOrigin.Current);  		continue;  	}  	// 7/21/05 - Check for 0x00 or 0xFF at end of last frame  	// this sucks for tracks that start with silence  	if (_headerOffset >= 1 && !acceptNullSamples)// if (ftell(fp) >= 5)  	 {  		stream.Seek (-5' SeekOrigin.Current);  		byte tmpLastByte = stream.Read1 ();  		stream.Seek (4' SeekOrigin.Current);  		if (tmpFrameBitrate != 320 && (tmpLastByte == 0x00 || tmpLastByte == 0xFF)) {  			// 7/31/05  			// may be a valid frame - skip its contents to prevent false sync  			long tmpNewPosition = _headerOffset + tmpFrameSize;  			if (tmpFrameSize == 0)  				tmpNewPosition++;  			stream.Seek (tmpNewPosition' SeekOrigin.Begin);  			continue;  		}  	}  	/*if (BR == 0 || FrameSizeConst == 0)                         {                             startpos = HeaderOffset+1;                             fseek(fp' startpos' SEEK_SET);                             continue;                         }*/stream.Seek (_headerOffset + tmpFrameSize' SeekOrigin.Begin);  	if (stream.Read1 () == 0xFF) {  		fh1 = stream.Read1 ();  		fh2 = stream.Read1 ();  		if (tmpFrameHeader [1] == fh1 && (tmpFrameHeader [2] & 0x0D) == (fh2 & 0x0D)) {  			// header found  			break;  		}  	}  	stream.Seek (_headerOffset + 1' SeekOrigin.Begin);  	continue;  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: if ((tmpFrameHeader [1] >> 5) != 0x07 || ((tmpFrameHeader [1] >> 1) & 0x03) == 0)// 2/18/05 - ignore reserved layer   {  	stream.Seek (-3' SeekOrigin.Current);  } else if (tmpFrameHeader [1] == 0xFF || ((tmpFrameHeader [1] >> 3) & 0x03) == 1)// 2/19/05 - more bad data   {  	stream.Seek (-3' SeekOrigin.Current);  } else {  	int tmpMpegID = (tmpFrameHeader [1] >> 3) & 0x03;  	int tmpLayerNum = (tmpFrameHeader [1] >> 1) & 0x03;  	int tmpFrequency = GetFrequency ((MpegVersion)tmpMpegID' (tmpFrameHeader [2] >> 2) & 0x03);  	// Check for invalid frequency  	if (tmpFrequency == 0) {  		stream.Seek (-3' SeekOrigin.Current);  		continue;  	}  	int tmpSamplesPerFrame = GetSamplesPerFrame ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum);  	int tmpUsesPadding = (tmpFrameHeader [2] >> 1) & 0x01;  	double tmpFrameSizeConst = 125.0 * tmpSamplesPerFrame / tmpFrequency;  	int tmpPaddingSize = (tmpLayerNum == 3 ? 4 : 1);  	int tmpBitrateIndex = tmpFrameHeader [2] >> 4;  	// Check for invalid values  	if (tmpBitrateIndex < 1 || tmpBitrateIndex > 14 || tmpLayerNum == 0) {  		stream.Seek (-3' SeekOrigin.Current);  		continue;  	}  	int tmpFrameBitrate = GetBitrate ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum' tmpBitrateIndex);  	int tmpFrameSize = (int)(tmpFrameBitrate * tmpFrameSizeConst) + (tmpUsesPadding * tmpPaddingSize);  	_headerOffset = stream.Position - 4;  	if (tmpFrameSize < 8) {  		stream.Seek (-3' SeekOrigin.Current);  		continue;  	}  	// 7/21/05 - Check for 0x00 or 0xFF at end of last frame  	// this sucks for tracks that start with silence  	if (_headerOffset >= 1 && !acceptNullSamples)// if (ftell(fp) >= 5)  	 {  		stream.Seek (-5' SeekOrigin.Current);  		byte tmpLastByte = stream.Read1 ();  		stream.Seek (4' SeekOrigin.Current);  		if (tmpFrameBitrate != 320 && (tmpLastByte == 0x00 || tmpLastByte == 0xFF)) {  			// 7/31/05  			// may be a valid frame - skip its contents to prevent false sync  			long tmpNewPosition = _headerOffset + tmpFrameSize;  			if (tmpFrameSize == 0)  				tmpNewPosition++;  			stream.Seek (tmpNewPosition' SeekOrigin.Begin);  			continue;  		}  	}  	/*if (BR == 0 || FrameSizeConst == 0)                         {                             startpos = HeaderOffset+1;                             fseek(fp' startpos' SEEK_SET);                             continue;                         }*/stream.Seek (_headerOffset + tmpFrameSize' SeekOrigin.Begin);  	if (stream.Read1 () == 0xFF) {  		fh1 = stream.Read1 ();  		fh2 = stream.Read1 ();  		if (tmpFrameHeader [1] == fh1 && (tmpFrameHeader [2] & 0x0D) == (fh2 & 0x0D)) {  			// header found  			break;  		}  	}  	stream.Seek (_headerOffset + 1' SeekOrigin.Begin);  	continue;  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: if ((tmpFrameHeader [1] >> 5) != 0x07 || ((tmpFrameHeader [1] >> 1) & 0x03) == 0)// 2/18/05 - ignore reserved layer   {  	stream.Seek (-3' SeekOrigin.Current);  } else if (tmpFrameHeader [1] == 0xFF || ((tmpFrameHeader [1] >> 3) & 0x03) == 1)// 2/19/05 - more bad data   {  	stream.Seek (-3' SeekOrigin.Current);  } else {  	int tmpMpegID = (tmpFrameHeader [1] >> 3) & 0x03;  	int tmpLayerNum = (tmpFrameHeader [1] >> 1) & 0x03;  	int tmpFrequency = GetFrequency ((MpegVersion)tmpMpegID' (tmpFrameHeader [2] >> 2) & 0x03);  	// Check for invalid frequency  	if (tmpFrequency == 0) {  		stream.Seek (-3' SeekOrigin.Current);  		continue;  	}  	int tmpSamplesPerFrame = GetSamplesPerFrame ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum);  	int tmpUsesPadding = (tmpFrameHeader [2] >> 1) & 0x01;  	double tmpFrameSizeConst = 125.0 * tmpSamplesPerFrame / tmpFrequency;  	int tmpPaddingSize = (tmpLayerNum == 3 ? 4 : 1);  	int tmpBitrateIndex = tmpFrameHeader [2] >> 4;  	// Check for invalid values  	if (tmpBitrateIndex < 1 || tmpBitrateIndex > 14 || tmpLayerNum == 0) {  		stream.Seek (-3' SeekOrigin.Current);  		continue;  	}  	int tmpFrameBitrate = GetBitrate ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum' tmpBitrateIndex);  	int tmpFrameSize = (int)(tmpFrameBitrate * tmpFrameSizeConst) + (tmpUsesPadding * tmpPaddingSize);  	_headerOffset = stream.Position - 4;  	if (tmpFrameSize < 8) {  		stream.Seek (-3' SeekOrigin.Current);  		continue;  	}  	// 7/21/05 - Check for 0x00 or 0xFF at end of last frame  	// this sucks for tracks that start with silence  	if (_headerOffset >= 1 && !acceptNullSamples)// if (ftell(fp) >= 5)  	 {  		stream.Seek (-5' SeekOrigin.Current);  		byte tmpLastByte = stream.Read1 ();  		stream.Seek (4' SeekOrigin.Current);  		if (tmpFrameBitrate != 320 && (tmpLastByte == 0x00 || tmpLastByte == 0xFF)) {  			// 7/31/05  			// may be a valid frame - skip its contents to prevent false sync  			long tmpNewPosition = _headerOffset + tmpFrameSize;  			if (tmpFrameSize == 0)  				tmpNewPosition++;  			stream.Seek (tmpNewPosition' SeekOrigin.Begin);  			continue;  		}  	}  	/*if (BR == 0 || FrameSizeConst == 0)                         {                             startpos = HeaderOffset+1;                             fseek(fp' startpos' SEEK_SET);                             continue;                         }*/stream.Seek (_headerOffset + tmpFrameSize' SeekOrigin.Begin);  	if (stream.Read1 () == 0xFF) {  		fh1 = stream.Read1 ();  		fh2 = stream.Read1 ();  		if (tmpFrameHeader [1] == fh1 && (tmpFrameHeader [2] & 0x0D) == (fh2 & 0x0D)) {  			// header found  			break;  		}  	}  	stream.Seek (_headerOffset + 1' SeekOrigin.Begin);  	continue;  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: if ((tmpFrameHeader [1] >> 5) != 0x07 || ((tmpFrameHeader [1] >> 1) & 0x03) == 0)// 2/18/05 - ignore reserved layer   {  	stream.Seek (-3' SeekOrigin.Current);  } else if (tmpFrameHeader [1] == 0xFF || ((tmpFrameHeader [1] >> 3) & 0x03) == 1)// 2/19/05 - more bad data   {  	stream.Seek (-3' SeekOrigin.Current);  } else {  	int tmpMpegID = (tmpFrameHeader [1] >> 3) & 0x03;  	int tmpLayerNum = (tmpFrameHeader [1] >> 1) & 0x03;  	int tmpFrequency = GetFrequency ((MpegVersion)tmpMpegID' (tmpFrameHeader [2] >> 2) & 0x03);  	// Check for invalid frequency  	if (tmpFrequency == 0) {  		stream.Seek (-3' SeekOrigin.Current);  		continue;  	}  	int tmpSamplesPerFrame = GetSamplesPerFrame ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum);  	int tmpUsesPadding = (tmpFrameHeader [2] >> 1) & 0x01;  	double tmpFrameSizeConst = 125.0 * tmpSamplesPerFrame / tmpFrequency;  	int tmpPaddingSize = (tmpLayerNum == 3 ? 4 : 1);  	int tmpBitrateIndex = tmpFrameHeader [2] >> 4;  	// Check for invalid values  	if (tmpBitrateIndex < 1 || tmpBitrateIndex > 14 || tmpLayerNum == 0) {  		stream.Seek (-3' SeekOrigin.Current);  		continue;  	}  	int tmpFrameBitrate = GetBitrate ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum' tmpBitrateIndex);  	int tmpFrameSize = (int)(tmpFrameBitrate * tmpFrameSizeConst) + (tmpUsesPadding * tmpPaddingSize);  	_headerOffset = stream.Position - 4;  	if (tmpFrameSize < 8) {  		stream.Seek (-3' SeekOrigin.Current);  		continue;  	}  	// 7/21/05 - Check for 0x00 or 0xFF at end of last frame  	// this sucks for tracks that start with silence  	if (_headerOffset >= 1 && !acceptNullSamples)// if (ftell(fp) >= 5)  	 {  		stream.Seek (-5' SeekOrigin.Current);  		byte tmpLastByte = stream.Read1 ();  		stream.Seek (4' SeekOrigin.Current);  		if (tmpFrameBitrate != 320 && (tmpLastByte == 0x00 || tmpLastByte == 0xFF)) {  			// 7/31/05  			// may be a valid frame - skip its contents to prevent false sync  			long tmpNewPosition = _headerOffset + tmpFrameSize;  			if (tmpFrameSize == 0)  				tmpNewPosition++;  			stream.Seek (tmpNewPosition' SeekOrigin.Begin);  			continue;  		}  	}  	/*if (BR == 0 || FrameSizeConst == 0)                         {                             startpos = HeaderOffset+1;                             fseek(fp' startpos' SEEK_SET);                             continue;                         }*/stream.Seek (_headerOffset + tmpFrameSize' SeekOrigin.Begin);  	if (stream.Read1 () == 0xFF) {  		fh1 = stream.Read1 ();  		fh2 = stream.Read1 ();  		if (tmpFrameHeader [1] == fh1 && (tmpFrameHeader [2] & 0x0D) == (fh2 & 0x0D)) {  			// header found  			break;  		}  	}  	stream.Seek (_headerOffset + 1' SeekOrigin.Begin);  	continue;  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: if ((tmpFrameHeader [1] >> 5) != 0x07 || ((tmpFrameHeader [1] >> 1) & 0x03) == 0)// 2/18/05 - ignore reserved layer   {  	stream.Seek (-3' SeekOrigin.Current);  } else if (tmpFrameHeader [1] == 0xFF || ((tmpFrameHeader [1] >> 3) & 0x03) == 1)// 2/19/05 - more bad data   {  	stream.Seek (-3' SeekOrigin.Current);  } else {  	int tmpMpegID = (tmpFrameHeader [1] >> 3) & 0x03;  	int tmpLayerNum = (tmpFrameHeader [1] >> 1) & 0x03;  	int tmpFrequency = GetFrequency ((MpegVersion)tmpMpegID' (tmpFrameHeader [2] >> 2) & 0x03);  	// Check for invalid frequency  	if (tmpFrequency == 0) {  		stream.Seek (-3' SeekOrigin.Current);  		continue;  	}  	int tmpSamplesPerFrame = GetSamplesPerFrame ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum);  	int tmpUsesPadding = (tmpFrameHeader [2] >> 1) & 0x01;  	double tmpFrameSizeConst = 125.0 * tmpSamplesPerFrame / tmpFrequency;  	int tmpPaddingSize = (tmpLayerNum == 3 ? 4 : 1);  	int tmpBitrateIndex = tmpFrameHeader [2] >> 4;  	// Check for invalid values  	if (tmpBitrateIndex < 1 || tmpBitrateIndex > 14 || tmpLayerNum == 0) {  		stream.Seek (-3' SeekOrigin.Current);  		continue;  	}  	int tmpFrameBitrate = GetBitrate ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum' tmpBitrateIndex);  	int tmpFrameSize = (int)(tmpFrameBitrate * tmpFrameSizeConst) + (tmpUsesPadding * tmpPaddingSize);  	_headerOffset = stream.Position - 4;  	if (tmpFrameSize < 8) {  		stream.Seek (-3' SeekOrigin.Current);  		continue;  	}  	// 7/21/05 - Check for 0x00 or 0xFF at end of last frame  	// this sucks for tracks that start with silence  	if (_headerOffset >= 1 && !acceptNullSamples)// if (ftell(fp) >= 5)  	 {  		stream.Seek (-5' SeekOrigin.Current);  		byte tmpLastByte = stream.Read1 ();  		stream.Seek (4' SeekOrigin.Current);  		if (tmpFrameBitrate != 320 && (tmpLastByte == 0x00 || tmpLastByte == 0xFF)) {  			// 7/31/05  			// may be a valid frame - skip its contents to prevent false sync  			long tmpNewPosition = _headerOffset + tmpFrameSize;  			if (tmpFrameSize == 0)  				tmpNewPosition++;  			stream.Seek (tmpNewPosition' SeekOrigin.Begin);  			continue;  		}  	}  	/*if (BR == 0 || FrameSizeConst == 0)                         {                             startpos = HeaderOffset+1;                             fseek(fp' startpos' SEEK_SET);                             continue;                         }*/stream.Seek (_headerOffset + tmpFrameSize' SeekOrigin.Begin);  	if (stream.Read1 () == 0xFF) {  		fh1 = stream.Read1 ();  		fh2 = stream.Read1 ();  		if (tmpFrameHeader [1] == fh1 && (tmpFrameHeader [2] & 0x0D) == (fh2 & 0x0D)) {  			// header found  			break;  		}  	}  	stream.Seek (_headerOffset + 1' SeekOrigin.Begin);  	continue;  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: if ((tmpFrameHeader [1] >> 5) != 0x07 || ((tmpFrameHeader [1] >> 1) & 0x03) == 0)// 2/18/05 - ignore reserved layer   {  	stream.Seek (-3' SeekOrigin.Current);  } else if (tmpFrameHeader [1] == 0xFF || ((tmpFrameHeader [1] >> 3) & 0x03) == 1)// 2/19/05 - more bad data   {  	stream.Seek (-3' SeekOrigin.Current);  } else {  	int tmpMpegID = (tmpFrameHeader [1] >> 3) & 0x03;  	int tmpLayerNum = (tmpFrameHeader [1] >> 1) & 0x03;  	int tmpFrequency = GetFrequency ((MpegVersion)tmpMpegID' (tmpFrameHeader [2] >> 2) & 0x03);  	// Check for invalid frequency  	if (tmpFrequency == 0) {  		stream.Seek (-3' SeekOrigin.Current);  		continue;  	}  	int tmpSamplesPerFrame = GetSamplesPerFrame ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum);  	int tmpUsesPadding = (tmpFrameHeader [2] >> 1) & 0x01;  	double tmpFrameSizeConst = 125.0 * tmpSamplesPerFrame / tmpFrequency;  	int tmpPaddingSize = (tmpLayerNum == 3 ? 4 : 1);  	int tmpBitrateIndex = tmpFrameHeader [2] >> 4;  	// Check for invalid values  	if (tmpBitrateIndex < 1 || tmpBitrateIndex > 14 || tmpLayerNum == 0) {  		stream.Seek (-3' SeekOrigin.Current);  		continue;  	}  	int tmpFrameBitrate = GetBitrate ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum' tmpBitrateIndex);  	int tmpFrameSize = (int)(tmpFrameBitrate * tmpFrameSizeConst) + (tmpUsesPadding * tmpPaddingSize);  	_headerOffset = stream.Position - 4;  	if (tmpFrameSize < 8) {  		stream.Seek (-3' SeekOrigin.Current);  		continue;  	}  	// 7/21/05 - Check for 0x00 or 0xFF at end of last frame  	// this sucks for tracks that start with silence  	if (_headerOffset >= 1 && !acceptNullSamples)// if (ftell(fp) >= 5)  	 {  		stream.Seek (-5' SeekOrigin.Current);  		byte tmpLastByte = stream.Read1 ();  		stream.Seek (4' SeekOrigin.Current);  		if (tmpFrameBitrate != 320 && (tmpLastByte == 0x00 || tmpLastByte == 0xFF)) {  			// 7/31/05  			// may be a valid frame - skip its contents to prevent false sync  			long tmpNewPosition = _headerOffset + tmpFrameSize;  			if (tmpFrameSize == 0)  				tmpNewPosition++;  			stream.Seek (tmpNewPosition' SeekOrigin.Begin);  			continue;  		}  	}  	/*if (BR == 0 || FrameSizeConst == 0)                         {                             startpos = HeaderOffset+1;                             fseek(fp' startpos' SEEK_SET);                             continue;                         }*/stream.Seek (_headerOffset + tmpFrameSize' SeekOrigin.Begin);  	if (stream.Read1 () == 0xFF) {  		fh1 = stream.Read1 ();  		fh2 = stream.Read1 ();  		if (tmpFrameHeader [1] == fh1 && (tmpFrameHeader [2] & 0x0D) == (fh2 & 0x0D)) {  			// header found  			break;  		}  	}  	stream.Seek (_headerOffset + 1' SeekOrigin.Begin);  	continue;  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: if ((tmpFrameHeader [1] >> 5) != 0x07 || ((tmpFrameHeader [1] >> 1) & 0x03) == 0)// 2/18/05 - ignore reserved layer   {  	stream.Seek (-3' SeekOrigin.Current);  } else if (tmpFrameHeader [1] == 0xFF || ((tmpFrameHeader [1] >> 3) & 0x03) == 1)// 2/19/05 - more bad data   {  	stream.Seek (-3' SeekOrigin.Current);  } else {  	int tmpMpegID = (tmpFrameHeader [1] >> 3) & 0x03;  	int tmpLayerNum = (tmpFrameHeader [1] >> 1) & 0x03;  	int tmpFrequency = GetFrequency ((MpegVersion)tmpMpegID' (tmpFrameHeader [2] >> 2) & 0x03);  	// Check for invalid frequency  	if (tmpFrequency == 0) {  		stream.Seek (-3' SeekOrigin.Current);  		continue;  	}  	int tmpSamplesPerFrame = GetSamplesPerFrame ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum);  	int tmpUsesPadding = (tmpFrameHeader [2] >> 1) & 0x01;  	double tmpFrameSizeConst = 125.0 * tmpSamplesPerFrame / tmpFrequency;  	int tmpPaddingSize = (tmpLayerNum == 3 ? 4 : 1);  	int tmpBitrateIndex = tmpFrameHeader [2] >> 4;  	// Check for invalid values  	if (tmpBitrateIndex < 1 || tmpBitrateIndex > 14 || tmpLayerNum == 0) {  		stream.Seek (-3' SeekOrigin.Current);  		continue;  	}  	int tmpFrameBitrate = GetBitrate ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum' tmpBitrateIndex);  	int tmpFrameSize = (int)(tmpFrameBitrate * tmpFrameSizeConst) + (tmpUsesPadding * tmpPaddingSize);  	_headerOffset = stream.Position - 4;  	if (tmpFrameSize < 8) {  		stream.Seek (-3' SeekOrigin.Current);  		continue;  	}  	// 7/21/05 - Check for 0x00 or 0xFF at end of last frame  	// this sucks for tracks that start with silence  	if (_headerOffset >= 1 && !acceptNullSamples)// if (ftell(fp) >= 5)  	 {  		stream.Seek (-5' SeekOrigin.Current);  		byte tmpLastByte = stream.Read1 ();  		stream.Seek (4' SeekOrigin.Current);  		if (tmpFrameBitrate != 320 && (tmpLastByte == 0x00 || tmpLastByte == 0xFF)) {  			// 7/31/05  			// may be a valid frame - skip its contents to prevent false sync  			long tmpNewPosition = _headerOffset + tmpFrameSize;  			if (tmpFrameSize == 0)  				tmpNewPosition++;  			stream.Seek (tmpNewPosition' SeekOrigin.Begin);  			continue;  		}  	}  	/*if (BR == 0 || FrameSizeConst == 0)                         {                             startpos = HeaderOffset+1;                             fseek(fp' startpos' SEEK_SET);                             continue;                         }*/stream.Seek (_headerOffset + tmpFrameSize' SeekOrigin.Begin);  	if (stream.Read1 () == 0xFF) {  		fh1 = stream.Read1 ();  		fh2 = stream.Read1 ();  		if (tmpFrameHeader [1] == fh1 && (tmpFrameHeader [2] & 0x0D) == (fh2 & 0x0D)) {  			// header found  			break;  		}  	}  	stream.Seek (_headerOffset + 1' SeekOrigin.Begin);  	continue;  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: if ((tmpFrameHeader [1] >> 5) != 0x07 || ((tmpFrameHeader [1] >> 1) & 0x03) == 0)// 2/18/05 - ignore reserved layer   {  	stream.Seek (-3' SeekOrigin.Current);  } else if (tmpFrameHeader [1] == 0xFF || ((tmpFrameHeader [1] >> 3) & 0x03) == 1)// 2/19/05 - more bad data   {  	stream.Seek (-3' SeekOrigin.Current);  } else {  	int tmpMpegID = (tmpFrameHeader [1] >> 3) & 0x03;  	int tmpLayerNum = (tmpFrameHeader [1] >> 1) & 0x03;  	int tmpFrequency = GetFrequency ((MpegVersion)tmpMpegID' (tmpFrameHeader [2] >> 2) & 0x03);  	// Check for invalid frequency  	if (tmpFrequency == 0) {  		stream.Seek (-3' SeekOrigin.Current);  		continue;  	}  	int tmpSamplesPerFrame = GetSamplesPerFrame ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum);  	int tmpUsesPadding = (tmpFrameHeader [2] >> 1) & 0x01;  	double tmpFrameSizeConst = 125.0 * tmpSamplesPerFrame / tmpFrequency;  	int tmpPaddingSize = (tmpLayerNum == 3 ? 4 : 1);  	int tmpBitrateIndex = tmpFrameHeader [2] >> 4;  	// Check for invalid values  	if (tmpBitrateIndex < 1 || tmpBitrateIndex > 14 || tmpLayerNum == 0) {  		stream.Seek (-3' SeekOrigin.Current);  		continue;  	}  	int tmpFrameBitrate = GetBitrate ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum' tmpBitrateIndex);  	int tmpFrameSize = (int)(tmpFrameBitrate * tmpFrameSizeConst) + (tmpUsesPadding * tmpPaddingSize);  	_headerOffset = stream.Position - 4;  	if (tmpFrameSize < 8) {  		stream.Seek (-3' SeekOrigin.Current);  		continue;  	}  	// 7/21/05 - Check for 0x00 or 0xFF at end of last frame  	// this sucks for tracks that start with silence  	if (_headerOffset >= 1 && !acceptNullSamples)// if (ftell(fp) >= 5)  	 {  		stream.Seek (-5' SeekOrigin.Current);  		byte tmpLastByte = stream.Read1 ();  		stream.Seek (4' SeekOrigin.Current);  		if (tmpFrameBitrate != 320 && (tmpLastByte == 0x00 || tmpLastByte == 0xFF)) {  			// 7/31/05  			// may be a valid frame - skip its contents to prevent false sync  			long tmpNewPosition = _headerOffset + tmpFrameSize;  			if (tmpFrameSize == 0)  				tmpNewPosition++;  			stream.Seek (tmpNewPosition' SeekOrigin.Begin);  			continue;  		}  	}  	/*if (BR == 0 || FrameSizeConst == 0)                         {                             startpos = HeaderOffset+1;                             fseek(fp' startpos' SEEK_SET);                             continue;                         }*/stream.Seek (_headerOffset + tmpFrameSize' SeekOrigin.Begin);  	if (stream.Read1 () == 0xFF) {  		fh1 = stream.Read1 ();  		fh2 = stream.Read1 ();  		if (tmpFrameHeader [1] == fh1 && (tmpFrameHeader [2] & 0x0D) == (fh2 & 0x0D)) {  			// header found  			break;  		}  	}  	stream.Seek (_headerOffset + 1' SeekOrigin.Begin);  	continue;  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: if ((tmpFrameHeader [1] >> 5) != 0x07 || ((tmpFrameHeader [1] >> 1) & 0x03) == 0)// 2/18/05 - ignore reserved layer   {  	stream.Seek (-3' SeekOrigin.Current);  } else if (tmpFrameHeader [1] == 0xFF || ((tmpFrameHeader [1] >> 3) & 0x03) == 1)// 2/19/05 - more bad data   {  	stream.Seek (-3' SeekOrigin.Current);  } else {  	int tmpMpegID = (tmpFrameHeader [1] >> 3) & 0x03;  	int tmpLayerNum = (tmpFrameHeader [1] >> 1) & 0x03;  	int tmpFrequency = GetFrequency ((MpegVersion)tmpMpegID' (tmpFrameHeader [2] >> 2) & 0x03);  	// Check for invalid frequency  	if (tmpFrequency == 0) {  		stream.Seek (-3' SeekOrigin.Current);  		continue;  	}  	int tmpSamplesPerFrame = GetSamplesPerFrame ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum);  	int tmpUsesPadding = (tmpFrameHeader [2] >> 1) & 0x01;  	double tmpFrameSizeConst = 125.0 * tmpSamplesPerFrame / tmpFrequency;  	int tmpPaddingSize = (tmpLayerNum == 3 ? 4 : 1);  	int tmpBitrateIndex = tmpFrameHeader [2] >> 4;  	// Check for invalid values  	if (tmpBitrateIndex < 1 || tmpBitrateIndex > 14 || tmpLayerNum == 0) {  		stream.Seek (-3' SeekOrigin.Current);  		continue;  	}  	int tmpFrameBitrate = GetBitrate ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum' tmpBitrateIndex);  	int tmpFrameSize = (int)(tmpFrameBitrate * tmpFrameSizeConst) + (tmpUsesPadding * tmpPaddingSize);  	_headerOffset = stream.Position - 4;  	if (tmpFrameSize < 8) {  		stream.Seek (-3' SeekOrigin.Current);  		continue;  	}  	// 7/21/05 - Check for 0x00 or 0xFF at end of last frame  	// this sucks for tracks that start with silence  	if (_headerOffset >= 1 && !acceptNullSamples)// if (ftell(fp) >= 5)  	 {  		stream.Seek (-5' SeekOrigin.Current);  		byte tmpLastByte = stream.Read1 ();  		stream.Seek (4' SeekOrigin.Current);  		if (tmpFrameBitrate != 320 && (tmpLastByte == 0x00 || tmpLastByte == 0xFF)) {  			// 7/31/05  			// may be a valid frame - skip its contents to prevent false sync  			long tmpNewPosition = _headerOffset + tmpFrameSize;  			if (tmpFrameSize == 0)  				tmpNewPosition++;  			stream.Seek (tmpNewPosition' SeekOrigin.Begin);  			continue;  		}  	}  	/*if (BR == 0 || FrameSizeConst == 0)                         {                             startpos = HeaderOffset+1;                             fseek(fp' startpos' SEEK_SET);                             continue;                         }*/stream.Seek (_headerOffset + tmpFrameSize' SeekOrigin.Begin);  	if (stream.Read1 () == 0xFF) {  		fh1 = stream.Read1 ();  		fh2 = stream.Read1 ();  		if (tmpFrameHeader [1] == fh1 && (tmpFrameHeader [2] & 0x0D) == (fh2 & 0x0D)) {  			// header found  			break;  		}  	}  	stream.Seek (_headerOffset + 1' SeekOrigin.Begin);  	continue;  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: if ((tmpFrameHeader [1] >> 5) != 0x07 || ((tmpFrameHeader [1] >> 1) & 0x03) == 0)// 2/18/05 - ignore reserved layer   {  	stream.Seek (-3' SeekOrigin.Current);  } else if (tmpFrameHeader [1] == 0xFF || ((tmpFrameHeader [1] >> 3) & 0x03) == 1)// 2/19/05 - more bad data   {  	stream.Seek (-3' SeekOrigin.Current);  } else {  	int tmpMpegID = (tmpFrameHeader [1] >> 3) & 0x03;  	int tmpLayerNum = (tmpFrameHeader [1] >> 1) & 0x03;  	int tmpFrequency = GetFrequency ((MpegVersion)tmpMpegID' (tmpFrameHeader [2] >> 2) & 0x03);  	// Check for invalid frequency  	if (tmpFrequency == 0) {  		stream.Seek (-3' SeekOrigin.Current);  		continue;  	}  	int tmpSamplesPerFrame = GetSamplesPerFrame ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum);  	int tmpUsesPadding = (tmpFrameHeader [2] >> 1) & 0x01;  	double tmpFrameSizeConst = 125.0 * tmpSamplesPerFrame / tmpFrequency;  	int tmpPaddingSize = (tmpLayerNum == 3 ? 4 : 1);  	int tmpBitrateIndex = tmpFrameHeader [2] >> 4;  	// Check for invalid values  	if (tmpBitrateIndex < 1 || tmpBitrateIndex > 14 || tmpLayerNum == 0) {  		stream.Seek (-3' SeekOrigin.Current);  		continue;  	}  	int tmpFrameBitrate = GetBitrate ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum' tmpBitrateIndex);  	int tmpFrameSize = (int)(tmpFrameBitrate * tmpFrameSizeConst) + (tmpUsesPadding * tmpPaddingSize);  	_headerOffset = stream.Position - 4;  	if (tmpFrameSize < 8) {  		stream.Seek (-3' SeekOrigin.Current);  		continue;  	}  	// 7/21/05 - Check for 0x00 or 0xFF at end of last frame  	// this sucks for tracks that start with silence  	if (_headerOffset >= 1 && !acceptNullSamples)// if (ftell(fp) >= 5)  	 {  		stream.Seek (-5' SeekOrigin.Current);  		byte tmpLastByte = stream.Read1 ();  		stream.Seek (4' SeekOrigin.Current);  		if (tmpFrameBitrate != 320 && (tmpLastByte == 0x00 || tmpLastByte == 0xFF)) {  			// 7/31/05  			// may be a valid frame - skip its contents to prevent false sync  			long tmpNewPosition = _headerOffset + tmpFrameSize;  			if (tmpFrameSize == 0)  				tmpNewPosition++;  			stream.Seek (tmpNewPosition' SeekOrigin.Begin);  			continue;  		}  	}  	/*if (BR == 0 || FrameSizeConst == 0)                         {                             startpos = HeaderOffset+1;                             fseek(fp' startpos' SEEK_SET);                             continue;                         }*/stream.Seek (_headerOffset + tmpFrameSize' SeekOrigin.Begin);  	if (stream.Read1 () == 0xFF) {  		fh1 = stream.Read1 ();  		fh2 = stream.Read1 ();  		if (tmpFrameHeader [1] == fh1 && (tmpFrameHeader [2] & 0x0D) == (fh2 & 0x0D)) {  			// header found  			break;  		}  	}  	stream.Seek (_headerOffset + 1' SeekOrigin.Begin);  	continue;  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: if ((tmpFrameHeader [1] >> 5) != 0x07 || ((tmpFrameHeader [1] >> 1) & 0x03) == 0)// 2/18/05 - ignore reserved layer   {  	stream.Seek (-3' SeekOrigin.Current);  } else if (tmpFrameHeader [1] == 0xFF || ((tmpFrameHeader [1] >> 3) & 0x03) == 1)// 2/19/05 - more bad data   {  	stream.Seek (-3' SeekOrigin.Current);  } else {  	int tmpMpegID = (tmpFrameHeader [1] >> 3) & 0x03;  	int tmpLayerNum = (tmpFrameHeader [1] >> 1) & 0x03;  	int tmpFrequency = GetFrequency ((MpegVersion)tmpMpegID' (tmpFrameHeader [2] >> 2) & 0x03);  	// Check for invalid frequency  	if (tmpFrequency == 0) {  		stream.Seek (-3' SeekOrigin.Current);  		continue;  	}  	int tmpSamplesPerFrame = GetSamplesPerFrame ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum);  	int tmpUsesPadding = (tmpFrameHeader [2] >> 1) & 0x01;  	double tmpFrameSizeConst = 125.0 * tmpSamplesPerFrame / tmpFrequency;  	int tmpPaddingSize = (tmpLayerNum == 3 ? 4 : 1);  	int tmpBitrateIndex = tmpFrameHeader [2] >> 4;  	// Check for invalid values  	if (tmpBitrateIndex < 1 || tmpBitrateIndex > 14 || tmpLayerNum == 0) {  		stream.Seek (-3' SeekOrigin.Current);  		continue;  	}  	int tmpFrameBitrate = GetBitrate ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum' tmpBitrateIndex);  	int tmpFrameSize = (int)(tmpFrameBitrate * tmpFrameSizeConst) + (tmpUsesPadding * tmpPaddingSize);  	_headerOffset = stream.Position - 4;  	if (tmpFrameSize < 8) {  		stream.Seek (-3' SeekOrigin.Current);  		continue;  	}  	// 7/21/05 - Check for 0x00 or 0xFF at end of last frame  	// this sucks for tracks that start with silence  	if (_headerOffset >= 1 && !acceptNullSamples)// if (ftell(fp) >= 5)  	 {  		stream.Seek (-5' SeekOrigin.Current);  		byte tmpLastByte = stream.Read1 ();  		stream.Seek (4' SeekOrigin.Current);  		if (tmpFrameBitrate != 320 && (tmpLastByte == 0x00 || tmpLastByte == 0xFF)) {  			// 7/31/05  			// may be a valid frame - skip its contents to prevent false sync  			long tmpNewPosition = _headerOffset + tmpFrameSize;  			if (tmpFrameSize == 0)  				tmpNewPosition++;  			stream.Seek (tmpNewPosition' SeekOrigin.Begin);  			continue;  		}  	}  	/*if (BR == 0 || FrameSizeConst == 0)                         {                             startpos = HeaderOffset+1;                             fseek(fp' startpos' SEEK_SET);                             continue;                         }*/stream.Seek (_headerOffset + tmpFrameSize' SeekOrigin.Begin);  	if (stream.Read1 () == 0xFF) {  		fh1 = stream.Read1 ();  		fh2 = stream.Read1 ();  		if (tmpFrameHeader [1] == fh1 && (tmpFrameHeader [2] & 0x0D) == (fh2 & 0x0D)) {  			// header found  			break;  		}  	}  	stream.Seek (_headerOffset + 1' SeekOrigin.Begin);  	continue;  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: if ((tmpFrameHeader [1] >> 5) != 0x07 || ((tmpFrameHeader [1] >> 1) & 0x03) == 0)// 2/18/05 - ignore reserved layer   {  	stream.Seek (-3' SeekOrigin.Current);  } else if (tmpFrameHeader [1] == 0xFF || ((tmpFrameHeader [1] >> 3) & 0x03) == 1)// 2/19/05 - more bad data   {  	stream.Seek (-3' SeekOrigin.Current);  } else {  	int tmpMpegID = (tmpFrameHeader [1] >> 3) & 0x03;  	int tmpLayerNum = (tmpFrameHeader [1] >> 1) & 0x03;  	int tmpFrequency = GetFrequency ((MpegVersion)tmpMpegID' (tmpFrameHeader [2] >> 2) & 0x03);  	// Check for invalid frequency  	if (tmpFrequency == 0) {  		stream.Seek (-3' SeekOrigin.Current);  		continue;  	}  	int tmpSamplesPerFrame = GetSamplesPerFrame ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum);  	int tmpUsesPadding = (tmpFrameHeader [2] >> 1) & 0x01;  	double tmpFrameSizeConst = 125.0 * tmpSamplesPerFrame / tmpFrequency;  	int tmpPaddingSize = (tmpLayerNum == 3 ? 4 : 1);  	int tmpBitrateIndex = tmpFrameHeader [2] >> 4;  	// Check for invalid values  	if (tmpBitrateIndex < 1 || tmpBitrateIndex > 14 || tmpLayerNum == 0) {  		stream.Seek (-3' SeekOrigin.Current);  		continue;  	}  	int tmpFrameBitrate = GetBitrate ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum' tmpBitrateIndex);  	int tmpFrameSize = (int)(tmpFrameBitrate * tmpFrameSizeConst) + (tmpUsesPadding * tmpPaddingSize);  	_headerOffset = stream.Position - 4;  	if (tmpFrameSize < 8) {  		stream.Seek (-3' SeekOrigin.Current);  		continue;  	}  	// 7/21/05 - Check for 0x00 or 0xFF at end of last frame  	// this sucks for tracks that start with silence  	if (_headerOffset >= 1 && !acceptNullSamples)// if (ftell(fp) >= 5)  	 {  		stream.Seek (-5' SeekOrigin.Current);  		byte tmpLastByte = stream.Read1 ();  		stream.Seek (4' SeekOrigin.Current);  		if (tmpFrameBitrate != 320 && (tmpLastByte == 0x00 || tmpLastByte == 0xFF)) {  			// 7/31/05  			// may be a valid frame - skip its contents to prevent false sync  			long tmpNewPosition = _headerOffset + tmpFrameSize;  			if (tmpFrameSize == 0)  				tmpNewPosition++;  			stream.Seek (tmpNewPosition' SeekOrigin.Begin);  			continue;  		}  	}  	/*if (BR == 0 || FrameSizeConst == 0)                         {                             startpos = HeaderOffset+1;                             fseek(fp' startpos' SEEK_SET);                             continue;                         }*/stream.Seek (_headerOffset + tmpFrameSize' SeekOrigin.Begin);  	if (stream.Read1 () == 0xFF) {  		fh1 = stream.Read1 ();  		fh2 = stream.Read1 ();  		if (tmpFrameHeader [1] == fh1 && (tmpFrameHeader [2] & 0x0D) == (fh2 & 0x0D)) {  			// header found  			break;  		}  	}  	stream.Seek (_headerOffset + 1' SeekOrigin.Begin);  	continue;  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: if ((tmpFrameHeader [1] >> 5) != 0x07 || ((tmpFrameHeader [1] >> 1) & 0x03) == 0)// 2/18/05 - ignore reserved layer   {  	stream.Seek (-3' SeekOrigin.Current);  } else if (tmpFrameHeader [1] == 0xFF || ((tmpFrameHeader [1] >> 3) & 0x03) == 1)// 2/19/05 - more bad data   {  	stream.Seek (-3' SeekOrigin.Current);  } else {  	int tmpMpegID = (tmpFrameHeader [1] >> 3) & 0x03;  	int tmpLayerNum = (tmpFrameHeader [1] >> 1) & 0x03;  	int tmpFrequency = GetFrequency ((MpegVersion)tmpMpegID' (tmpFrameHeader [2] >> 2) & 0x03);  	// Check for invalid frequency  	if (tmpFrequency == 0) {  		stream.Seek (-3' SeekOrigin.Current);  		continue;  	}  	int tmpSamplesPerFrame = GetSamplesPerFrame ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum);  	int tmpUsesPadding = (tmpFrameHeader [2] >> 1) & 0x01;  	double tmpFrameSizeConst = 125.0 * tmpSamplesPerFrame / tmpFrequency;  	int tmpPaddingSize = (tmpLayerNum == 3 ? 4 : 1);  	int tmpBitrateIndex = tmpFrameHeader [2] >> 4;  	// Check for invalid values  	if (tmpBitrateIndex < 1 || tmpBitrateIndex > 14 || tmpLayerNum == 0) {  		stream.Seek (-3' SeekOrigin.Current);  		continue;  	}  	int tmpFrameBitrate = GetBitrate ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum' tmpBitrateIndex);  	int tmpFrameSize = (int)(tmpFrameBitrate * tmpFrameSizeConst) + (tmpUsesPadding * tmpPaddingSize);  	_headerOffset = stream.Position - 4;  	if (tmpFrameSize < 8) {  		stream.Seek (-3' SeekOrigin.Current);  		continue;  	}  	// 7/21/05 - Check for 0x00 or 0xFF at end of last frame  	// this sucks for tracks that start with silence  	if (_headerOffset >= 1 && !acceptNullSamples)// if (ftell(fp) >= 5)  	 {  		stream.Seek (-5' SeekOrigin.Current);  		byte tmpLastByte = stream.Read1 ();  		stream.Seek (4' SeekOrigin.Current);  		if (tmpFrameBitrate != 320 && (tmpLastByte == 0x00 || tmpLastByte == 0xFF)) {  			// 7/31/05  			// may be a valid frame - skip its contents to prevent false sync  			long tmpNewPosition = _headerOffset + tmpFrameSize;  			if (tmpFrameSize == 0)  				tmpNewPosition++;  			stream.Seek (tmpNewPosition' SeekOrigin.Begin);  			continue;  		}  	}  	/*if (BR == 0 || FrameSizeConst == 0)                         {                             startpos = HeaderOffset+1;                             fseek(fp' startpos' SEEK_SET);                             continue;                         }*/stream.Seek (_headerOffset + tmpFrameSize' SeekOrigin.Begin);  	if (stream.Read1 () == 0xFF) {  		fh1 = stream.Read1 ();  		fh2 = stream.Read1 ();  		if (tmpFrameHeader [1] == fh1 && (tmpFrameHeader [2] & 0x0D) == (fh2 & 0x0D)) {  			// header found  			break;  		}  	}  	stream.Seek (_headerOffset + 1' SeekOrigin.Begin);  	continue;  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: if ((tmpFrameHeader [1] >> 5) != 0x07 || ((tmpFrameHeader [1] >> 1) & 0x03) == 0)// 2/18/05 - ignore reserved layer   {  	stream.Seek (-3' SeekOrigin.Current);  } else if (tmpFrameHeader [1] == 0xFF || ((tmpFrameHeader [1] >> 3) & 0x03) == 1)// 2/19/05 - more bad data   {  	stream.Seek (-3' SeekOrigin.Current);  } else {  	int tmpMpegID = (tmpFrameHeader [1] >> 3) & 0x03;  	int tmpLayerNum = (tmpFrameHeader [1] >> 1) & 0x03;  	int tmpFrequency = GetFrequency ((MpegVersion)tmpMpegID' (tmpFrameHeader [2] >> 2) & 0x03);  	// Check for invalid frequency  	if (tmpFrequency == 0) {  		stream.Seek (-3' SeekOrigin.Current);  		continue;  	}  	int tmpSamplesPerFrame = GetSamplesPerFrame ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum);  	int tmpUsesPadding = (tmpFrameHeader [2] >> 1) & 0x01;  	double tmpFrameSizeConst = 125.0 * tmpSamplesPerFrame / tmpFrequency;  	int tmpPaddingSize = (tmpLayerNum == 3 ? 4 : 1);  	int tmpBitrateIndex = tmpFrameHeader [2] >> 4;  	// Check for invalid values  	if (tmpBitrateIndex < 1 || tmpBitrateIndex > 14 || tmpLayerNum == 0) {  		stream.Seek (-3' SeekOrigin.Current);  		continue;  	}  	int tmpFrameBitrate = GetBitrate ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum' tmpBitrateIndex);  	int tmpFrameSize = (int)(tmpFrameBitrate * tmpFrameSizeConst) + (tmpUsesPadding * tmpPaddingSize);  	_headerOffset = stream.Position - 4;  	if (tmpFrameSize < 8) {  		stream.Seek (-3' SeekOrigin.Current);  		continue;  	}  	// 7/21/05 - Check for 0x00 or 0xFF at end of last frame  	// this sucks for tracks that start with silence  	if (_headerOffset >= 1 && !acceptNullSamples)// if (ftell(fp) >= 5)  	 {  		stream.Seek (-5' SeekOrigin.Current);  		byte tmpLastByte = stream.Read1 ();  		stream.Seek (4' SeekOrigin.Current);  		if (tmpFrameBitrate != 320 && (tmpLastByte == 0x00 || tmpLastByte == 0xFF)) {  			// 7/31/05  			// may be a valid frame - skip its contents to prevent false sync  			long tmpNewPosition = _headerOffset + tmpFrameSize;  			if (tmpFrameSize == 0)  				tmpNewPosition++;  			stream.Seek (tmpNewPosition' SeekOrigin.Begin);  			continue;  		}  	}  	/*if (BR == 0 || FrameSizeConst == 0)                         {                             startpos = HeaderOffset+1;                             fseek(fp' startpos' SEEK_SET);                             continue;                         }*/stream.Seek (_headerOffset + tmpFrameSize' SeekOrigin.Begin);  	if (stream.Read1 () == 0xFF) {  		fh1 = stream.Read1 ();  		fh2 = stream.Read1 ();  		if (tmpFrameHeader [1] == fh1 && (tmpFrameHeader [2] & 0x0D) == (fh2 & 0x0D)) {  			// header found  			break;  		}  	}  	stream.Seek (_headerOffset + 1' SeekOrigin.Begin);  	continue;  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: stream.Seek (-3' SeekOrigin.Current);  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: if (tmpFrameHeader [1] == 0xFF || ((tmpFrameHeader [1] >> 3) & 0x03) == 1)// 2/19/05 - more bad data   {  	stream.Seek (-3' SeekOrigin.Current);  } else {  	int tmpMpegID = (tmpFrameHeader [1] >> 3) & 0x03;  	int tmpLayerNum = (tmpFrameHeader [1] >> 1) & 0x03;  	int tmpFrequency = GetFrequency ((MpegVersion)tmpMpegID' (tmpFrameHeader [2] >> 2) & 0x03);  	// Check for invalid frequency  	if (tmpFrequency == 0) {  		stream.Seek (-3' SeekOrigin.Current);  		continue;  	}  	int tmpSamplesPerFrame = GetSamplesPerFrame ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum);  	int tmpUsesPadding = (tmpFrameHeader [2] >> 1) & 0x01;  	double tmpFrameSizeConst = 125.0 * tmpSamplesPerFrame / tmpFrequency;  	int tmpPaddingSize = (tmpLayerNum == 3 ? 4 : 1);  	int tmpBitrateIndex = tmpFrameHeader [2] >> 4;  	// Check for invalid values  	if (tmpBitrateIndex < 1 || tmpBitrateIndex > 14 || tmpLayerNum == 0) {  		stream.Seek (-3' SeekOrigin.Current);  		continue;  	}  	int tmpFrameBitrate = GetBitrate ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum' tmpBitrateIndex);  	int tmpFrameSize = (int)(tmpFrameBitrate * tmpFrameSizeConst) + (tmpUsesPadding * tmpPaddingSize);  	_headerOffset = stream.Position - 4;  	if (tmpFrameSize < 8) {  		stream.Seek (-3' SeekOrigin.Current);  		continue;  	}  	// 7/21/05 - Check for 0x00 or 0xFF at end of last frame  	// this sucks for tracks that start with silence  	if (_headerOffset >= 1 && !acceptNullSamples)// if (ftell(fp) >= 5)  	 {  		stream.Seek (-5' SeekOrigin.Current);  		byte tmpLastByte = stream.Read1 ();  		stream.Seek (4' SeekOrigin.Current);  		if (tmpFrameBitrate != 320 && (tmpLastByte == 0x00 || tmpLastByte == 0xFF)) {  			// 7/31/05  			// may be a valid frame - skip its contents to prevent false sync  			long tmpNewPosition = _headerOffset + tmpFrameSize;  			if (tmpFrameSize == 0)  				tmpNewPosition++;  			stream.Seek (tmpNewPosition' SeekOrigin.Begin);  			continue;  		}  	}  	/*if (BR == 0 || FrameSizeConst == 0)                         {                             startpos = HeaderOffset+1;                             fseek(fp' startpos' SEEK_SET);                             continue;                         }*/stream.Seek (_headerOffset + tmpFrameSize' SeekOrigin.Begin);  	if (stream.Read1 () == 0xFF) {  		fh1 = stream.Read1 ();  		fh2 = stream.Read1 ();  		if (tmpFrameHeader [1] == fh1 && (tmpFrameHeader [2] & 0x0D) == (fh2 & 0x0D)) {  			// header found  			break;  		}  	}  	stream.Seek (_headerOffset + 1' SeekOrigin.Begin);  	continue;  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: if (tmpFrameHeader [1] == 0xFF || ((tmpFrameHeader [1] >> 3) & 0x03) == 1)// 2/19/05 - more bad data   {  	stream.Seek (-3' SeekOrigin.Current);  } else {  	int tmpMpegID = (tmpFrameHeader [1] >> 3) & 0x03;  	int tmpLayerNum = (tmpFrameHeader [1] >> 1) & 0x03;  	int tmpFrequency = GetFrequency ((MpegVersion)tmpMpegID' (tmpFrameHeader [2] >> 2) & 0x03);  	// Check for invalid frequency  	if (tmpFrequency == 0) {  		stream.Seek (-3' SeekOrigin.Current);  		continue;  	}  	int tmpSamplesPerFrame = GetSamplesPerFrame ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum);  	int tmpUsesPadding = (tmpFrameHeader [2] >> 1) & 0x01;  	double tmpFrameSizeConst = 125.0 * tmpSamplesPerFrame / tmpFrequency;  	int tmpPaddingSize = (tmpLayerNum == 3 ? 4 : 1);  	int tmpBitrateIndex = tmpFrameHeader [2] >> 4;  	// Check for invalid values  	if (tmpBitrateIndex < 1 || tmpBitrateIndex > 14 || tmpLayerNum == 0) {  		stream.Seek (-3' SeekOrigin.Current);  		continue;  	}  	int tmpFrameBitrate = GetBitrate ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum' tmpBitrateIndex);  	int tmpFrameSize = (int)(tmpFrameBitrate * tmpFrameSizeConst) + (tmpUsesPadding * tmpPaddingSize);  	_headerOffset = stream.Position - 4;  	if (tmpFrameSize < 8) {  		stream.Seek (-3' SeekOrigin.Current);  		continue;  	}  	// 7/21/05 - Check for 0x00 or 0xFF at end of last frame  	// this sucks for tracks that start with silence  	if (_headerOffset >= 1 && !acceptNullSamples)// if (ftell(fp) >= 5)  	 {  		stream.Seek (-5' SeekOrigin.Current);  		byte tmpLastByte = stream.Read1 ();  		stream.Seek (4' SeekOrigin.Current);  		if (tmpFrameBitrate != 320 && (tmpLastByte == 0x00 || tmpLastByte == 0xFF)) {  			// 7/31/05  			// may be a valid frame - skip its contents to prevent false sync  			long tmpNewPosition = _headerOffset + tmpFrameSize;  			if (tmpFrameSize == 0)  				tmpNewPosition++;  			stream.Seek (tmpNewPosition' SeekOrigin.Begin);  			continue;  		}  	}  	/*if (BR == 0 || FrameSizeConst == 0)                         {                             startpos = HeaderOffset+1;                             fseek(fp' startpos' SEEK_SET);                             continue;                         }*/stream.Seek (_headerOffset + tmpFrameSize' SeekOrigin.Begin);  	if (stream.Read1 () == 0xFF) {  		fh1 = stream.Read1 ();  		fh2 = stream.Read1 ();  		if (tmpFrameHeader [1] == fh1 && (tmpFrameHeader [2] & 0x0D) == (fh2 & 0x0D)) {  			// header found  			break;  		}  	}  	stream.Seek (_headerOffset + 1' SeekOrigin.Begin);  	continue;  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: if (tmpFrameHeader [1] == 0xFF || ((tmpFrameHeader [1] >> 3) & 0x03) == 1)// 2/19/05 - more bad data   {  	stream.Seek (-3' SeekOrigin.Current);  } else {  	int tmpMpegID = (tmpFrameHeader [1] >> 3) & 0x03;  	int tmpLayerNum = (tmpFrameHeader [1] >> 1) & 0x03;  	int tmpFrequency = GetFrequency ((MpegVersion)tmpMpegID' (tmpFrameHeader [2] >> 2) & 0x03);  	// Check for invalid frequency  	if (tmpFrequency == 0) {  		stream.Seek (-3' SeekOrigin.Current);  		continue;  	}  	int tmpSamplesPerFrame = GetSamplesPerFrame ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum);  	int tmpUsesPadding = (tmpFrameHeader [2] >> 1) & 0x01;  	double tmpFrameSizeConst = 125.0 * tmpSamplesPerFrame / tmpFrequency;  	int tmpPaddingSize = (tmpLayerNum == 3 ? 4 : 1);  	int tmpBitrateIndex = tmpFrameHeader [2] >> 4;  	// Check for invalid values  	if (tmpBitrateIndex < 1 || tmpBitrateIndex > 14 || tmpLayerNum == 0) {  		stream.Seek (-3' SeekOrigin.Current);  		continue;  	}  	int tmpFrameBitrate = GetBitrate ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum' tmpBitrateIndex);  	int tmpFrameSize = (int)(tmpFrameBitrate * tmpFrameSizeConst) + (tmpUsesPadding * tmpPaddingSize);  	_headerOffset = stream.Position - 4;  	if (tmpFrameSize < 8) {  		stream.Seek (-3' SeekOrigin.Current);  		continue;  	}  	// 7/21/05 - Check for 0x00 or 0xFF at end of last frame  	// this sucks for tracks that start with silence  	if (_headerOffset >= 1 && !acceptNullSamples)// if (ftell(fp) >= 5)  	 {  		stream.Seek (-5' SeekOrigin.Current);  		byte tmpLastByte = stream.Read1 ();  		stream.Seek (4' SeekOrigin.Current);  		if (tmpFrameBitrate != 320 && (tmpLastByte == 0x00 || tmpLastByte == 0xFF)) {  			// 7/31/05  			// may be a valid frame - skip its contents to prevent false sync  			long tmpNewPosition = _headerOffset + tmpFrameSize;  			if (tmpFrameSize == 0)  				tmpNewPosition++;  			stream.Seek (tmpNewPosition' SeekOrigin.Begin);  			continue;  		}  	}  	/*if (BR == 0 || FrameSizeConst == 0)                         {                             startpos = HeaderOffset+1;                             fseek(fp' startpos' SEEK_SET);                             continue;                         }*/stream.Seek (_headerOffset + tmpFrameSize' SeekOrigin.Begin);  	if (stream.Read1 () == 0xFF) {  		fh1 = stream.Read1 ();  		fh2 = stream.Read1 ();  		if (tmpFrameHeader [1] == fh1 && (tmpFrameHeader [2] & 0x0D) == (fh2 & 0x0D)) {  			// header found  			break;  		}  	}  	stream.Seek (_headerOffset + 1' SeekOrigin.Begin);  	continue;  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: if (tmpFrameHeader [1] == 0xFF || ((tmpFrameHeader [1] >> 3) & 0x03) == 1)// 2/19/05 - more bad data   {  	stream.Seek (-3' SeekOrigin.Current);  } else {  	int tmpMpegID = (tmpFrameHeader [1] >> 3) & 0x03;  	int tmpLayerNum = (tmpFrameHeader [1] >> 1) & 0x03;  	int tmpFrequency = GetFrequency ((MpegVersion)tmpMpegID' (tmpFrameHeader [2] >> 2) & 0x03);  	// Check for invalid frequency  	if (tmpFrequency == 0) {  		stream.Seek (-3' SeekOrigin.Current);  		continue;  	}  	int tmpSamplesPerFrame = GetSamplesPerFrame ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum);  	int tmpUsesPadding = (tmpFrameHeader [2] >> 1) & 0x01;  	double tmpFrameSizeConst = 125.0 * tmpSamplesPerFrame / tmpFrequency;  	int tmpPaddingSize = (tmpLayerNum == 3 ? 4 : 1);  	int tmpBitrateIndex = tmpFrameHeader [2] >> 4;  	// Check for invalid values  	if (tmpBitrateIndex < 1 || tmpBitrateIndex > 14 || tmpLayerNum == 0) {  		stream.Seek (-3' SeekOrigin.Current);  		continue;  	}  	int tmpFrameBitrate = GetBitrate ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum' tmpBitrateIndex);  	int tmpFrameSize = (int)(tmpFrameBitrate * tmpFrameSizeConst) + (tmpUsesPadding * tmpPaddingSize);  	_headerOffset = stream.Position - 4;  	if (tmpFrameSize < 8) {  		stream.Seek (-3' SeekOrigin.Current);  		continue;  	}  	// 7/21/05 - Check for 0x00 or 0xFF at end of last frame  	// this sucks for tracks that start with silence  	if (_headerOffset >= 1 && !acceptNullSamples)// if (ftell(fp) >= 5)  	 {  		stream.Seek (-5' SeekOrigin.Current);  		byte tmpLastByte = stream.Read1 ();  		stream.Seek (4' SeekOrigin.Current);  		if (tmpFrameBitrate != 320 && (tmpLastByte == 0x00 || tmpLastByte == 0xFF)) {  			// 7/31/05  			// may be a valid frame - skip its contents to prevent false sync  			long tmpNewPosition = _headerOffset + tmpFrameSize;  			if (tmpFrameSize == 0)  				tmpNewPosition++;  			stream.Seek (tmpNewPosition' SeekOrigin.Begin);  			continue;  		}  	}  	/*if (BR == 0 || FrameSizeConst == 0)                         {                             startpos = HeaderOffset+1;                             fseek(fp' startpos' SEEK_SET);                             continue;                         }*/stream.Seek (_headerOffset + tmpFrameSize' SeekOrigin.Begin);  	if (stream.Read1 () == 0xFF) {  		fh1 = stream.Read1 ();  		fh2 = stream.Read1 ();  		if (tmpFrameHeader [1] == fh1 && (tmpFrameHeader [2] & 0x0D) == (fh2 & 0x0D)) {  			// header found  			break;  		}  	}  	stream.Seek (_headerOffset + 1' SeekOrigin.Begin);  	continue;  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: if (tmpFrameHeader [1] == 0xFF || ((tmpFrameHeader [1] >> 3) & 0x03) == 1)// 2/19/05 - more bad data   {  	stream.Seek (-3' SeekOrigin.Current);  } else {  	int tmpMpegID = (tmpFrameHeader [1] >> 3) & 0x03;  	int tmpLayerNum = (tmpFrameHeader [1] >> 1) & 0x03;  	int tmpFrequency = GetFrequency ((MpegVersion)tmpMpegID' (tmpFrameHeader [2] >> 2) & 0x03);  	// Check for invalid frequency  	if (tmpFrequency == 0) {  		stream.Seek (-3' SeekOrigin.Current);  		continue;  	}  	int tmpSamplesPerFrame = GetSamplesPerFrame ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum);  	int tmpUsesPadding = (tmpFrameHeader [2] >> 1) & 0x01;  	double tmpFrameSizeConst = 125.0 * tmpSamplesPerFrame / tmpFrequency;  	int tmpPaddingSize = (tmpLayerNum == 3 ? 4 : 1);  	int tmpBitrateIndex = tmpFrameHeader [2] >> 4;  	// Check for invalid values  	if (tmpBitrateIndex < 1 || tmpBitrateIndex > 14 || tmpLayerNum == 0) {  		stream.Seek (-3' SeekOrigin.Current);  		continue;  	}  	int tmpFrameBitrate = GetBitrate ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum' tmpBitrateIndex);  	int tmpFrameSize = (int)(tmpFrameBitrate * tmpFrameSizeConst) + (tmpUsesPadding * tmpPaddingSize);  	_headerOffset = stream.Position - 4;  	if (tmpFrameSize < 8) {  		stream.Seek (-3' SeekOrigin.Current);  		continue;  	}  	// 7/21/05 - Check for 0x00 or 0xFF at end of last frame  	// this sucks for tracks that start with silence  	if (_headerOffset >= 1 && !acceptNullSamples)// if (ftell(fp) >= 5)  	 {  		stream.Seek (-5' SeekOrigin.Current);  		byte tmpLastByte = stream.Read1 ();  		stream.Seek (4' SeekOrigin.Current);  		if (tmpFrameBitrate != 320 && (tmpLastByte == 0x00 || tmpLastByte == 0xFF)) {  			// 7/31/05  			// may be a valid frame - skip its contents to prevent false sync  			long tmpNewPosition = _headerOffset + tmpFrameSize;  			if (tmpFrameSize == 0)  				tmpNewPosition++;  			stream.Seek (tmpNewPosition' SeekOrigin.Begin);  			continue;  		}  	}  	/*if (BR == 0 || FrameSizeConst == 0)                         {                             startpos = HeaderOffset+1;                             fseek(fp' startpos' SEEK_SET);                             continue;                         }*/stream.Seek (_headerOffset + tmpFrameSize' SeekOrigin.Begin);  	if (stream.Read1 () == 0xFF) {  		fh1 = stream.Read1 ();  		fh2 = stream.Read1 ();  		if (tmpFrameHeader [1] == fh1 && (tmpFrameHeader [2] & 0x0D) == (fh2 & 0x0D)) {  			// header found  			break;  		}  	}  	stream.Seek (_headerOffset + 1' SeekOrigin.Begin);  	continue;  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: if (tmpFrameHeader [1] == 0xFF || ((tmpFrameHeader [1] >> 3) & 0x03) == 1)// 2/19/05 - more bad data   {  	stream.Seek (-3' SeekOrigin.Current);  } else {  	int tmpMpegID = (tmpFrameHeader [1] >> 3) & 0x03;  	int tmpLayerNum = (tmpFrameHeader [1] >> 1) & 0x03;  	int tmpFrequency = GetFrequency ((MpegVersion)tmpMpegID' (tmpFrameHeader [2] >> 2) & 0x03);  	// Check for invalid frequency  	if (tmpFrequency == 0) {  		stream.Seek (-3' SeekOrigin.Current);  		continue;  	}  	int tmpSamplesPerFrame = GetSamplesPerFrame ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum);  	int tmpUsesPadding = (tmpFrameHeader [2] >> 1) & 0x01;  	double tmpFrameSizeConst = 125.0 * tmpSamplesPerFrame / tmpFrequency;  	int tmpPaddingSize = (tmpLayerNum == 3 ? 4 : 1);  	int tmpBitrateIndex = tmpFrameHeader [2] >> 4;  	// Check for invalid values  	if (tmpBitrateIndex < 1 || tmpBitrateIndex > 14 || tmpLayerNum == 0) {  		stream.Seek (-3' SeekOrigin.Current);  		continue;  	}  	int tmpFrameBitrate = GetBitrate ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum' tmpBitrateIndex);  	int tmpFrameSize = (int)(tmpFrameBitrate * tmpFrameSizeConst) + (tmpUsesPadding * tmpPaddingSize);  	_headerOffset = stream.Position - 4;  	if (tmpFrameSize < 8) {  		stream.Seek (-3' SeekOrigin.Current);  		continue;  	}  	// 7/21/05 - Check for 0x00 or 0xFF at end of last frame  	// this sucks for tracks that start with silence  	if (_headerOffset >= 1 && !acceptNullSamples)// if (ftell(fp) >= 5)  	 {  		stream.Seek (-5' SeekOrigin.Current);  		byte tmpLastByte = stream.Read1 ();  		stream.Seek (4' SeekOrigin.Current);  		if (tmpFrameBitrate != 320 && (tmpLastByte == 0x00 || tmpLastByte == 0xFF)) {  			// 7/31/05  			// may be a valid frame - skip its contents to prevent false sync  			long tmpNewPosition = _headerOffset + tmpFrameSize;  			if (tmpFrameSize == 0)  				tmpNewPosition++;  			stream.Seek (tmpNewPosition' SeekOrigin.Begin);  			continue;  		}  	}  	/*if (BR == 0 || FrameSizeConst == 0)                         {                             startpos = HeaderOffset+1;                             fseek(fp' startpos' SEEK_SET);                             continue;                         }*/stream.Seek (_headerOffset + tmpFrameSize' SeekOrigin.Begin);  	if (stream.Read1 () == 0xFF) {  		fh1 = stream.Read1 ();  		fh2 = stream.Read1 ();  		if (tmpFrameHeader [1] == fh1 && (tmpFrameHeader [2] & 0x0D) == (fh2 & 0x0D)) {  			// header found  			break;  		}  	}  	stream.Seek (_headerOffset + 1' SeekOrigin.Begin);  	continue;  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: if (tmpFrameHeader [1] == 0xFF || ((tmpFrameHeader [1] >> 3) & 0x03) == 1)// 2/19/05 - more bad data   {  	stream.Seek (-3' SeekOrigin.Current);  } else {  	int tmpMpegID = (tmpFrameHeader [1] >> 3) & 0x03;  	int tmpLayerNum = (tmpFrameHeader [1] >> 1) & 0x03;  	int tmpFrequency = GetFrequency ((MpegVersion)tmpMpegID' (tmpFrameHeader [2] >> 2) & 0x03);  	// Check for invalid frequency  	if (tmpFrequency == 0) {  		stream.Seek (-3' SeekOrigin.Current);  		continue;  	}  	int tmpSamplesPerFrame = GetSamplesPerFrame ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum);  	int tmpUsesPadding = (tmpFrameHeader [2] >> 1) & 0x01;  	double tmpFrameSizeConst = 125.0 * tmpSamplesPerFrame / tmpFrequency;  	int tmpPaddingSize = (tmpLayerNum == 3 ? 4 : 1);  	int tmpBitrateIndex = tmpFrameHeader [2] >> 4;  	// Check for invalid values  	if (tmpBitrateIndex < 1 || tmpBitrateIndex > 14 || tmpLayerNum == 0) {  		stream.Seek (-3' SeekOrigin.Current);  		continue;  	}  	int tmpFrameBitrate = GetBitrate ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum' tmpBitrateIndex);  	int tmpFrameSize = (int)(tmpFrameBitrate * tmpFrameSizeConst) + (tmpUsesPadding * tmpPaddingSize);  	_headerOffset = stream.Position - 4;  	if (tmpFrameSize < 8) {  		stream.Seek (-3' SeekOrigin.Current);  		continue;  	}  	// 7/21/05 - Check for 0x00 or 0xFF at end of last frame  	// this sucks for tracks that start with silence  	if (_headerOffset >= 1 && !acceptNullSamples)// if (ftell(fp) >= 5)  	 {  		stream.Seek (-5' SeekOrigin.Current);  		byte tmpLastByte = stream.Read1 ();  		stream.Seek (4' SeekOrigin.Current);  		if (tmpFrameBitrate != 320 && (tmpLastByte == 0x00 || tmpLastByte == 0xFF)) {  			// 7/31/05  			// may be a valid frame - skip its contents to prevent false sync  			long tmpNewPosition = _headerOffset + tmpFrameSize;  			if (tmpFrameSize == 0)  				tmpNewPosition++;  			stream.Seek (tmpNewPosition' SeekOrigin.Begin);  			continue;  		}  	}  	/*if (BR == 0 || FrameSizeConst == 0)                         {                             startpos = HeaderOffset+1;                             fseek(fp' startpos' SEEK_SET);                             continue;                         }*/stream.Seek (_headerOffset + tmpFrameSize' SeekOrigin.Begin);  	if (stream.Read1 () == 0xFF) {  		fh1 = stream.Read1 ();  		fh2 = stream.Read1 ();  		if (tmpFrameHeader [1] == fh1 && (tmpFrameHeader [2] & 0x0D) == (fh2 & 0x0D)) {  			// header found  			break;  		}  	}  	stream.Seek (_headerOffset + 1' SeekOrigin.Begin);  	continue;  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: if (tmpFrameHeader [1] == 0xFF || ((tmpFrameHeader [1] >> 3) & 0x03) == 1)// 2/19/05 - more bad data   {  	stream.Seek (-3' SeekOrigin.Current);  } else {  	int tmpMpegID = (tmpFrameHeader [1] >> 3) & 0x03;  	int tmpLayerNum = (tmpFrameHeader [1] >> 1) & 0x03;  	int tmpFrequency = GetFrequency ((MpegVersion)tmpMpegID' (tmpFrameHeader [2] >> 2) & 0x03);  	// Check for invalid frequency  	if (tmpFrequency == 0) {  		stream.Seek (-3' SeekOrigin.Current);  		continue;  	}  	int tmpSamplesPerFrame = GetSamplesPerFrame ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum);  	int tmpUsesPadding = (tmpFrameHeader [2] >> 1) & 0x01;  	double tmpFrameSizeConst = 125.0 * tmpSamplesPerFrame / tmpFrequency;  	int tmpPaddingSize = (tmpLayerNum == 3 ? 4 : 1);  	int tmpBitrateIndex = tmpFrameHeader [2] >> 4;  	// Check for invalid values  	if (tmpBitrateIndex < 1 || tmpBitrateIndex > 14 || tmpLayerNum == 0) {  		stream.Seek (-3' SeekOrigin.Current);  		continue;  	}  	int tmpFrameBitrate = GetBitrate ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum' tmpBitrateIndex);  	int tmpFrameSize = (int)(tmpFrameBitrate * tmpFrameSizeConst) + (tmpUsesPadding * tmpPaddingSize);  	_headerOffset = stream.Position - 4;  	if (tmpFrameSize < 8) {  		stream.Seek (-3' SeekOrigin.Current);  		continue;  	}  	// 7/21/05 - Check for 0x00 or 0xFF at end of last frame  	// this sucks for tracks that start with silence  	if (_headerOffset >= 1 && !acceptNullSamples)// if (ftell(fp) >= 5)  	 {  		stream.Seek (-5' SeekOrigin.Current);  		byte tmpLastByte = stream.Read1 ();  		stream.Seek (4' SeekOrigin.Current);  		if (tmpFrameBitrate != 320 && (tmpLastByte == 0x00 || tmpLastByte == 0xFF)) {  			// 7/31/05  			// may be a valid frame - skip its contents to prevent false sync  			long tmpNewPosition = _headerOffset + tmpFrameSize;  			if (tmpFrameSize == 0)  				tmpNewPosition++;  			stream.Seek (tmpNewPosition' SeekOrigin.Begin);  			continue;  		}  	}  	/*if (BR == 0 || FrameSizeConst == 0)                         {                             startpos = HeaderOffset+1;                             fseek(fp' startpos' SEEK_SET);                             continue;                         }*/stream.Seek (_headerOffset + tmpFrameSize' SeekOrigin.Begin);  	if (stream.Read1 () == 0xFF) {  		fh1 = stream.Read1 ();  		fh2 = stream.Read1 ();  		if (tmpFrameHeader [1] == fh1 && (tmpFrameHeader [2] & 0x0D) == (fh2 & 0x0D)) {  			// header found  			break;  		}  	}  	stream.Seek (_headerOffset + 1' SeekOrigin.Begin);  	continue;  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: if (tmpFrameHeader [1] == 0xFF || ((tmpFrameHeader [1] >> 3) & 0x03) == 1)// 2/19/05 - more bad data   {  	stream.Seek (-3' SeekOrigin.Current);  } else {  	int tmpMpegID = (tmpFrameHeader [1] >> 3) & 0x03;  	int tmpLayerNum = (tmpFrameHeader [1] >> 1) & 0x03;  	int tmpFrequency = GetFrequency ((MpegVersion)tmpMpegID' (tmpFrameHeader [2] >> 2) & 0x03);  	// Check for invalid frequency  	if (tmpFrequency == 0) {  		stream.Seek (-3' SeekOrigin.Current);  		continue;  	}  	int tmpSamplesPerFrame = GetSamplesPerFrame ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum);  	int tmpUsesPadding = (tmpFrameHeader [2] >> 1) & 0x01;  	double tmpFrameSizeConst = 125.0 * tmpSamplesPerFrame / tmpFrequency;  	int tmpPaddingSize = (tmpLayerNum == 3 ? 4 : 1);  	int tmpBitrateIndex = tmpFrameHeader [2] >> 4;  	// Check for invalid values  	if (tmpBitrateIndex < 1 || tmpBitrateIndex > 14 || tmpLayerNum == 0) {  		stream.Seek (-3' SeekOrigin.Current);  		continue;  	}  	int tmpFrameBitrate = GetBitrate ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum' tmpBitrateIndex);  	int tmpFrameSize = (int)(tmpFrameBitrate * tmpFrameSizeConst) + (tmpUsesPadding * tmpPaddingSize);  	_headerOffset = stream.Position - 4;  	if (tmpFrameSize < 8) {  		stream.Seek (-3' SeekOrigin.Current);  		continue;  	}  	// 7/21/05 - Check for 0x00 or 0xFF at end of last frame  	// this sucks for tracks that start with silence  	if (_headerOffset >= 1 && !acceptNullSamples)// if (ftell(fp) >= 5)  	 {  		stream.Seek (-5' SeekOrigin.Current);  		byte tmpLastByte = stream.Read1 ();  		stream.Seek (4' SeekOrigin.Current);  		if (tmpFrameBitrate != 320 && (tmpLastByte == 0x00 || tmpLastByte == 0xFF)) {  			// 7/31/05  			// may be a valid frame - skip its contents to prevent false sync  			long tmpNewPosition = _headerOffset + tmpFrameSize;  			if (tmpFrameSize == 0)  				tmpNewPosition++;  			stream.Seek (tmpNewPosition' SeekOrigin.Begin);  			continue;  		}  	}  	/*if (BR == 0 || FrameSizeConst == 0)                         {                             startpos = HeaderOffset+1;                             fseek(fp' startpos' SEEK_SET);                             continue;                         }*/stream.Seek (_headerOffset + tmpFrameSize' SeekOrigin.Begin);  	if (stream.Read1 () == 0xFF) {  		fh1 = stream.Read1 ();  		fh2 = stream.Read1 ();  		if (tmpFrameHeader [1] == fh1 && (tmpFrameHeader [2] & 0x0D) == (fh2 & 0x0D)) {  			// header found  			break;  		}  	}  	stream.Seek (_headerOffset + 1' SeekOrigin.Begin);  	continue;  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: if (tmpFrameHeader [1] == 0xFF || ((tmpFrameHeader [1] >> 3) & 0x03) == 1)// 2/19/05 - more bad data   {  	stream.Seek (-3' SeekOrigin.Current);  } else {  	int tmpMpegID = (tmpFrameHeader [1] >> 3) & 0x03;  	int tmpLayerNum = (tmpFrameHeader [1] >> 1) & 0x03;  	int tmpFrequency = GetFrequency ((MpegVersion)tmpMpegID' (tmpFrameHeader [2] >> 2) & 0x03);  	// Check for invalid frequency  	if (tmpFrequency == 0) {  		stream.Seek (-3' SeekOrigin.Current);  		continue;  	}  	int tmpSamplesPerFrame = GetSamplesPerFrame ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum);  	int tmpUsesPadding = (tmpFrameHeader [2] >> 1) & 0x01;  	double tmpFrameSizeConst = 125.0 * tmpSamplesPerFrame / tmpFrequency;  	int tmpPaddingSize = (tmpLayerNum == 3 ? 4 : 1);  	int tmpBitrateIndex = tmpFrameHeader [2] >> 4;  	// Check for invalid values  	if (tmpBitrateIndex < 1 || tmpBitrateIndex > 14 || tmpLayerNum == 0) {  		stream.Seek (-3' SeekOrigin.Current);  		continue;  	}  	int tmpFrameBitrate = GetBitrate ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum' tmpBitrateIndex);  	int tmpFrameSize = (int)(tmpFrameBitrate * tmpFrameSizeConst) + (tmpUsesPadding * tmpPaddingSize);  	_headerOffset = stream.Position - 4;  	if (tmpFrameSize < 8) {  		stream.Seek (-3' SeekOrigin.Current);  		continue;  	}  	// 7/21/05 - Check for 0x00 or 0xFF at end of last frame  	// this sucks for tracks that start with silence  	if (_headerOffset >= 1 && !acceptNullSamples)// if (ftell(fp) >= 5)  	 {  		stream.Seek (-5' SeekOrigin.Current);  		byte tmpLastByte = stream.Read1 ();  		stream.Seek (4' SeekOrigin.Current);  		if (tmpFrameBitrate != 320 && (tmpLastByte == 0x00 || tmpLastByte == 0xFF)) {  			// 7/31/05  			// may be a valid frame - skip its contents to prevent false sync  			long tmpNewPosition = _headerOffset + tmpFrameSize;  			if (tmpFrameSize == 0)  				tmpNewPosition++;  			stream.Seek (tmpNewPosition' SeekOrigin.Begin);  			continue;  		}  	}  	/*if (BR == 0 || FrameSizeConst == 0)                         {                             startpos = HeaderOffset+1;                             fseek(fp' startpos' SEEK_SET);                             continue;                         }*/stream.Seek (_headerOffset + tmpFrameSize' SeekOrigin.Begin);  	if (stream.Read1 () == 0xFF) {  		fh1 = stream.Read1 ();  		fh2 = stream.Read1 ();  		if (tmpFrameHeader [1] == fh1 && (tmpFrameHeader [2] & 0x0D) == (fh2 & 0x0D)) {  			// header found  			break;  		}  	}  	stream.Seek (_headerOffset + 1' SeekOrigin.Begin);  	continue;  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: if (tmpFrameHeader [1] == 0xFF || ((tmpFrameHeader [1] >> 3) & 0x03) == 1)// 2/19/05 - more bad data   {  	stream.Seek (-3' SeekOrigin.Current);  } else {  	int tmpMpegID = (tmpFrameHeader [1] >> 3) & 0x03;  	int tmpLayerNum = (tmpFrameHeader [1] >> 1) & 0x03;  	int tmpFrequency = GetFrequency ((MpegVersion)tmpMpegID' (tmpFrameHeader [2] >> 2) & 0x03);  	// Check for invalid frequency  	if (tmpFrequency == 0) {  		stream.Seek (-3' SeekOrigin.Current);  		continue;  	}  	int tmpSamplesPerFrame = GetSamplesPerFrame ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum);  	int tmpUsesPadding = (tmpFrameHeader [2] >> 1) & 0x01;  	double tmpFrameSizeConst = 125.0 * tmpSamplesPerFrame / tmpFrequency;  	int tmpPaddingSize = (tmpLayerNum == 3 ? 4 : 1);  	int tmpBitrateIndex = tmpFrameHeader [2] >> 4;  	// Check for invalid values  	if (tmpBitrateIndex < 1 || tmpBitrateIndex > 14 || tmpLayerNum == 0) {  		stream.Seek (-3' SeekOrigin.Current);  		continue;  	}  	int tmpFrameBitrate = GetBitrate ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum' tmpBitrateIndex);  	int tmpFrameSize = (int)(tmpFrameBitrate * tmpFrameSizeConst) + (tmpUsesPadding * tmpPaddingSize);  	_headerOffset = stream.Position - 4;  	if (tmpFrameSize < 8) {  		stream.Seek (-3' SeekOrigin.Current);  		continue;  	}  	// 7/21/05 - Check for 0x00 or 0xFF at end of last frame  	// this sucks for tracks that start with silence  	if (_headerOffset >= 1 && !acceptNullSamples)// if (ftell(fp) >= 5)  	 {  		stream.Seek (-5' SeekOrigin.Current);  		byte tmpLastByte = stream.Read1 ();  		stream.Seek (4' SeekOrigin.Current);  		if (tmpFrameBitrate != 320 && (tmpLastByte == 0x00 || tmpLastByte == 0xFF)) {  			// 7/31/05  			// may be a valid frame - skip its contents to prevent false sync  			long tmpNewPosition = _headerOffset + tmpFrameSize;  			if (tmpFrameSize == 0)  				tmpNewPosition++;  			stream.Seek (tmpNewPosition' SeekOrigin.Begin);  			continue;  		}  	}  	/*if (BR == 0 || FrameSizeConst == 0)                         {                             startpos = HeaderOffset+1;                             fseek(fp' startpos' SEEK_SET);                             continue;                         }*/stream.Seek (_headerOffset + tmpFrameSize' SeekOrigin.Begin);  	if (stream.Read1 () == 0xFF) {  		fh1 = stream.Read1 ();  		fh2 = stream.Read1 ();  		if (tmpFrameHeader [1] == fh1 && (tmpFrameHeader [2] & 0x0D) == (fh2 & 0x0D)) {  			// header found  			break;  		}  	}  	stream.Seek (_headerOffset + 1' SeekOrigin.Begin);  	continue;  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: if (tmpFrameHeader [1] == 0xFF || ((tmpFrameHeader [1] >> 3) & 0x03) == 1)// 2/19/05 - more bad data   {  	stream.Seek (-3' SeekOrigin.Current);  } else {  	int tmpMpegID = (tmpFrameHeader [1] >> 3) & 0x03;  	int tmpLayerNum = (tmpFrameHeader [1] >> 1) & 0x03;  	int tmpFrequency = GetFrequency ((MpegVersion)tmpMpegID' (tmpFrameHeader [2] >> 2) & 0x03);  	// Check for invalid frequency  	if (tmpFrequency == 0) {  		stream.Seek (-3' SeekOrigin.Current);  		continue;  	}  	int tmpSamplesPerFrame = GetSamplesPerFrame ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum);  	int tmpUsesPadding = (tmpFrameHeader [2] >> 1) & 0x01;  	double tmpFrameSizeConst = 125.0 * tmpSamplesPerFrame / tmpFrequency;  	int tmpPaddingSize = (tmpLayerNum == 3 ? 4 : 1);  	int tmpBitrateIndex = tmpFrameHeader [2] >> 4;  	// Check for invalid values  	if (tmpBitrateIndex < 1 || tmpBitrateIndex > 14 || tmpLayerNum == 0) {  		stream.Seek (-3' SeekOrigin.Current);  		continue;  	}  	int tmpFrameBitrate = GetBitrate ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum' tmpBitrateIndex);  	int tmpFrameSize = (int)(tmpFrameBitrate * tmpFrameSizeConst) + (tmpUsesPadding * tmpPaddingSize);  	_headerOffset = stream.Position - 4;  	if (tmpFrameSize < 8) {  		stream.Seek (-3' SeekOrigin.Current);  		continue;  	}  	// 7/21/05 - Check for 0x00 or 0xFF at end of last frame  	// this sucks for tracks that start with silence  	if (_headerOffset >= 1 && !acceptNullSamples)// if (ftell(fp) >= 5)  	 {  		stream.Seek (-5' SeekOrigin.Current);  		byte tmpLastByte = stream.Read1 ();  		stream.Seek (4' SeekOrigin.Current);  		if (tmpFrameBitrate != 320 && (tmpLastByte == 0x00 || tmpLastByte == 0xFF)) {  			// 7/31/05  			// may be a valid frame - skip its contents to prevent false sync  			long tmpNewPosition = _headerOffset + tmpFrameSize;  			if (tmpFrameSize == 0)  				tmpNewPosition++;  			stream.Seek (tmpNewPosition' SeekOrigin.Begin);  			continue;  		}  	}  	/*if (BR == 0 || FrameSizeConst == 0)                         {                             startpos = HeaderOffset+1;                             fseek(fp' startpos' SEEK_SET);                             continue;                         }*/stream.Seek (_headerOffset + tmpFrameSize' SeekOrigin.Begin);  	if (stream.Read1 () == 0xFF) {  		fh1 = stream.Read1 ();  		fh2 = stream.Read1 ();  		if (tmpFrameHeader [1] == fh1 && (tmpFrameHeader [2] & 0x0D) == (fh2 & 0x0D)) {  			// header found  			break;  		}  	}  	stream.Seek (_headerOffset + 1' SeekOrigin.Begin);  	continue;  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: if (tmpFrameHeader [1] == 0xFF || ((tmpFrameHeader [1] >> 3) & 0x03) == 1)// 2/19/05 - more bad data   {  	stream.Seek (-3' SeekOrigin.Current);  } else {  	int tmpMpegID = (tmpFrameHeader [1] >> 3) & 0x03;  	int tmpLayerNum = (tmpFrameHeader [1] >> 1) & 0x03;  	int tmpFrequency = GetFrequency ((MpegVersion)tmpMpegID' (tmpFrameHeader [2] >> 2) & 0x03);  	// Check for invalid frequency  	if (tmpFrequency == 0) {  		stream.Seek (-3' SeekOrigin.Current);  		continue;  	}  	int tmpSamplesPerFrame = GetSamplesPerFrame ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum);  	int tmpUsesPadding = (tmpFrameHeader [2] >> 1) & 0x01;  	double tmpFrameSizeConst = 125.0 * tmpSamplesPerFrame / tmpFrequency;  	int tmpPaddingSize = (tmpLayerNum == 3 ? 4 : 1);  	int tmpBitrateIndex = tmpFrameHeader [2] >> 4;  	// Check for invalid values  	if (tmpBitrateIndex < 1 || tmpBitrateIndex > 14 || tmpLayerNum == 0) {  		stream.Seek (-3' SeekOrigin.Current);  		continue;  	}  	int tmpFrameBitrate = GetBitrate ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum' tmpBitrateIndex);  	int tmpFrameSize = (int)(tmpFrameBitrate * tmpFrameSizeConst) + (tmpUsesPadding * tmpPaddingSize);  	_headerOffset = stream.Position - 4;  	if (tmpFrameSize < 8) {  		stream.Seek (-3' SeekOrigin.Current);  		continue;  	}  	// 7/21/05 - Check for 0x00 or 0xFF at end of last frame  	// this sucks for tracks that start with silence  	if (_headerOffset >= 1 && !acceptNullSamples)// if (ftell(fp) >= 5)  	 {  		stream.Seek (-5' SeekOrigin.Current);  		byte tmpLastByte = stream.Read1 ();  		stream.Seek (4' SeekOrigin.Current);  		if (tmpFrameBitrate != 320 && (tmpLastByte == 0x00 || tmpLastByte == 0xFF)) {  			// 7/31/05  			// may be a valid frame - skip its contents to prevent false sync  			long tmpNewPosition = _headerOffset + tmpFrameSize;  			if (tmpFrameSize == 0)  				tmpNewPosition++;  			stream.Seek (tmpNewPosition' SeekOrigin.Begin);  			continue;  		}  	}  	/*if (BR == 0 || FrameSizeConst == 0)                         {                             startpos = HeaderOffset+1;                             fseek(fp' startpos' SEEK_SET);                             continue;                         }*/stream.Seek (_headerOffset + tmpFrameSize' SeekOrigin.Begin);  	if (stream.Read1 () == 0xFF) {  		fh1 = stream.Read1 ();  		fh2 = stream.Read1 ();  		if (tmpFrameHeader [1] == fh1 && (tmpFrameHeader [2] & 0x0D) == (fh2 & 0x0D)) {  			// header found  			break;  		}  	}  	stream.Seek (_headerOffset + 1' SeekOrigin.Begin);  	continue;  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: if (tmpFrameHeader [1] == 0xFF || ((tmpFrameHeader [1] >> 3) & 0x03) == 1)// 2/19/05 - more bad data   {  	stream.Seek (-3' SeekOrigin.Current);  } else {  	int tmpMpegID = (tmpFrameHeader [1] >> 3) & 0x03;  	int tmpLayerNum = (tmpFrameHeader [1] >> 1) & 0x03;  	int tmpFrequency = GetFrequency ((MpegVersion)tmpMpegID' (tmpFrameHeader [2] >> 2) & 0x03);  	// Check for invalid frequency  	if (tmpFrequency == 0) {  		stream.Seek (-3' SeekOrigin.Current);  		continue;  	}  	int tmpSamplesPerFrame = GetSamplesPerFrame ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum);  	int tmpUsesPadding = (tmpFrameHeader [2] >> 1) & 0x01;  	double tmpFrameSizeConst = 125.0 * tmpSamplesPerFrame / tmpFrequency;  	int tmpPaddingSize = (tmpLayerNum == 3 ? 4 : 1);  	int tmpBitrateIndex = tmpFrameHeader [2] >> 4;  	// Check for invalid values  	if (tmpBitrateIndex < 1 || tmpBitrateIndex > 14 || tmpLayerNum == 0) {  		stream.Seek (-3' SeekOrigin.Current);  		continue;  	}  	int tmpFrameBitrate = GetBitrate ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum' tmpBitrateIndex);  	int tmpFrameSize = (int)(tmpFrameBitrate * tmpFrameSizeConst) + (tmpUsesPadding * tmpPaddingSize);  	_headerOffset = stream.Position - 4;  	if (tmpFrameSize < 8) {  		stream.Seek (-3' SeekOrigin.Current);  		continue;  	}  	// 7/21/05 - Check for 0x00 or 0xFF at end of last frame  	// this sucks for tracks that start with silence  	if (_headerOffset >= 1 && !acceptNullSamples)// if (ftell(fp) >= 5)  	 {  		stream.Seek (-5' SeekOrigin.Current);  		byte tmpLastByte = stream.Read1 ();  		stream.Seek (4' SeekOrigin.Current);  		if (tmpFrameBitrate != 320 && (tmpLastByte == 0x00 || tmpLastByte == 0xFF)) {  			// 7/31/05  			// may be a valid frame - skip its contents to prevent false sync  			long tmpNewPosition = _headerOffset + tmpFrameSize;  			if (tmpFrameSize == 0)  				tmpNewPosition++;  			stream.Seek (tmpNewPosition' SeekOrigin.Begin);  			continue;  		}  	}  	/*if (BR == 0 || FrameSizeConst == 0)                         {                             startpos = HeaderOffset+1;                             fseek(fp' startpos' SEEK_SET);                             continue;                         }*/stream.Seek (_headerOffset + tmpFrameSize' SeekOrigin.Begin);  	if (stream.Read1 () == 0xFF) {  		fh1 = stream.Read1 ();  		fh2 = stream.Read1 ();  		if (tmpFrameHeader [1] == fh1 && (tmpFrameHeader [2] & 0x0D) == (fh2 & 0x0D)) {  			// header found  			break;  		}  	}  	stream.Seek (_headerOffset + 1' SeekOrigin.Begin);  	continue;  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: if (tmpFrameHeader [1] == 0xFF || ((tmpFrameHeader [1] >> 3) & 0x03) == 1)// 2/19/05 - more bad data   {  	stream.Seek (-3' SeekOrigin.Current);  } else {  	int tmpMpegID = (tmpFrameHeader [1] >> 3) & 0x03;  	int tmpLayerNum = (tmpFrameHeader [1] >> 1) & 0x03;  	int tmpFrequency = GetFrequency ((MpegVersion)tmpMpegID' (tmpFrameHeader [2] >> 2) & 0x03);  	// Check for invalid frequency  	if (tmpFrequency == 0) {  		stream.Seek (-3' SeekOrigin.Current);  		continue;  	}  	int tmpSamplesPerFrame = GetSamplesPerFrame ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum);  	int tmpUsesPadding = (tmpFrameHeader [2] >> 1) & 0x01;  	double tmpFrameSizeConst = 125.0 * tmpSamplesPerFrame / tmpFrequency;  	int tmpPaddingSize = (tmpLayerNum == 3 ? 4 : 1);  	int tmpBitrateIndex = tmpFrameHeader [2] >> 4;  	// Check for invalid values  	if (tmpBitrateIndex < 1 || tmpBitrateIndex > 14 || tmpLayerNum == 0) {  		stream.Seek (-3' SeekOrigin.Current);  		continue;  	}  	int tmpFrameBitrate = GetBitrate ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum' tmpBitrateIndex);  	int tmpFrameSize = (int)(tmpFrameBitrate * tmpFrameSizeConst) + (tmpUsesPadding * tmpPaddingSize);  	_headerOffset = stream.Position - 4;  	if (tmpFrameSize < 8) {  		stream.Seek (-3' SeekOrigin.Current);  		continue;  	}  	// 7/21/05 - Check for 0x00 or 0xFF at end of last frame  	// this sucks for tracks that start with silence  	if (_headerOffset >= 1 && !acceptNullSamples)// if (ftell(fp) >= 5)  	 {  		stream.Seek (-5' SeekOrigin.Current);  		byte tmpLastByte = stream.Read1 ();  		stream.Seek (4' SeekOrigin.Current);  		if (tmpFrameBitrate != 320 && (tmpLastByte == 0x00 || tmpLastByte == 0xFF)) {  			// 7/31/05  			// may be a valid frame - skip its contents to prevent false sync  			long tmpNewPosition = _headerOffset + tmpFrameSize;  			if (tmpFrameSize == 0)  				tmpNewPosition++;  			stream.Seek (tmpNewPosition' SeekOrigin.Begin);  			continue;  		}  	}  	/*if (BR == 0 || FrameSizeConst == 0)                         {                             startpos = HeaderOffset+1;                             fseek(fp' startpos' SEEK_SET);                             continue;                         }*/stream.Seek (_headerOffset + tmpFrameSize' SeekOrigin.Begin);  	if (stream.Read1 () == 0xFF) {  		fh1 = stream.Read1 ();  		fh2 = stream.Read1 ();  		if (tmpFrameHeader [1] == fh1 && (tmpFrameHeader [2] & 0x0D) == (fh2 & 0x0D)) {  			// header found  			break;  		}  	}  	stream.Seek (_headerOffset + 1' SeekOrigin.Begin);  	continue;  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: if (tmpFrameHeader [1] == 0xFF || ((tmpFrameHeader [1] >> 3) & 0x03) == 1)// 2/19/05 - more bad data   {  	stream.Seek (-3' SeekOrigin.Current);  } else {  	int tmpMpegID = (tmpFrameHeader [1] >> 3) & 0x03;  	int tmpLayerNum = (tmpFrameHeader [1] >> 1) & 0x03;  	int tmpFrequency = GetFrequency ((MpegVersion)tmpMpegID' (tmpFrameHeader [2] >> 2) & 0x03);  	// Check for invalid frequency  	if (tmpFrequency == 0) {  		stream.Seek (-3' SeekOrigin.Current);  		continue;  	}  	int tmpSamplesPerFrame = GetSamplesPerFrame ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum);  	int tmpUsesPadding = (tmpFrameHeader [2] >> 1) & 0x01;  	double tmpFrameSizeConst = 125.0 * tmpSamplesPerFrame / tmpFrequency;  	int tmpPaddingSize = (tmpLayerNum == 3 ? 4 : 1);  	int tmpBitrateIndex = tmpFrameHeader [2] >> 4;  	// Check for invalid values  	if (tmpBitrateIndex < 1 || tmpBitrateIndex > 14 || tmpLayerNum == 0) {  		stream.Seek (-3' SeekOrigin.Current);  		continue;  	}  	int tmpFrameBitrate = GetBitrate ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum' tmpBitrateIndex);  	int tmpFrameSize = (int)(tmpFrameBitrate * tmpFrameSizeConst) + (tmpUsesPadding * tmpPaddingSize);  	_headerOffset = stream.Position - 4;  	if (tmpFrameSize < 8) {  		stream.Seek (-3' SeekOrigin.Current);  		continue;  	}  	// 7/21/05 - Check for 0x00 or 0xFF at end of last frame  	// this sucks for tracks that start with silence  	if (_headerOffset >= 1 && !acceptNullSamples)// if (ftell(fp) >= 5)  	 {  		stream.Seek (-5' SeekOrigin.Current);  		byte tmpLastByte = stream.Read1 ();  		stream.Seek (4' SeekOrigin.Current);  		if (tmpFrameBitrate != 320 && (tmpLastByte == 0x00 || tmpLastByte == 0xFF)) {  			// 7/31/05  			// may be a valid frame - skip its contents to prevent false sync  			long tmpNewPosition = _headerOffset + tmpFrameSize;  			if (tmpFrameSize == 0)  				tmpNewPosition++;  			stream.Seek (tmpNewPosition' SeekOrigin.Begin);  			continue;  		}  	}  	/*if (BR == 0 || FrameSizeConst == 0)                         {                             startpos = HeaderOffset+1;                             fseek(fp' startpos' SEEK_SET);                             continue;                         }*/stream.Seek (_headerOffset + tmpFrameSize' SeekOrigin.Begin);  	if (stream.Read1 () == 0xFF) {  		fh1 = stream.Read1 ();  		fh2 = stream.Read1 ();  		if (tmpFrameHeader [1] == fh1 && (tmpFrameHeader [2] & 0x0D) == (fh2 & 0x0D)) {  			// header found  			break;  		}  	}  	stream.Seek (_headerOffset + 1' SeekOrigin.Begin);  	continue;  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: if (tmpFrameHeader [1] == 0xFF || ((tmpFrameHeader [1] >> 3) & 0x03) == 1)// 2/19/05 - more bad data   {  	stream.Seek (-3' SeekOrigin.Current);  } else {  	int tmpMpegID = (tmpFrameHeader [1] >> 3) & 0x03;  	int tmpLayerNum = (tmpFrameHeader [1] >> 1) & 0x03;  	int tmpFrequency = GetFrequency ((MpegVersion)tmpMpegID' (tmpFrameHeader [2] >> 2) & 0x03);  	// Check for invalid frequency  	if (tmpFrequency == 0) {  		stream.Seek (-3' SeekOrigin.Current);  		continue;  	}  	int tmpSamplesPerFrame = GetSamplesPerFrame ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum);  	int tmpUsesPadding = (tmpFrameHeader [2] >> 1) & 0x01;  	double tmpFrameSizeConst = 125.0 * tmpSamplesPerFrame / tmpFrequency;  	int tmpPaddingSize = (tmpLayerNum == 3 ? 4 : 1);  	int tmpBitrateIndex = tmpFrameHeader [2] >> 4;  	// Check for invalid values  	if (tmpBitrateIndex < 1 || tmpBitrateIndex > 14 || tmpLayerNum == 0) {  		stream.Seek (-3' SeekOrigin.Current);  		continue;  	}  	int tmpFrameBitrate = GetBitrate ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum' tmpBitrateIndex);  	int tmpFrameSize = (int)(tmpFrameBitrate * tmpFrameSizeConst) + (tmpUsesPadding * tmpPaddingSize);  	_headerOffset = stream.Position - 4;  	if (tmpFrameSize < 8) {  		stream.Seek (-3' SeekOrigin.Current);  		continue;  	}  	// 7/21/05 - Check for 0x00 or 0xFF at end of last frame  	// this sucks for tracks that start with silence  	if (_headerOffset >= 1 && !acceptNullSamples)// if (ftell(fp) >= 5)  	 {  		stream.Seek (-5' SeekOrigin.Current);  		byte tmpLastByte = stream.Read1 ();  		stream.Seek (4' SeekOrigin.Current);  		if (tmpFrameBitrate != 320 && (tmpLastByte == 0x00 || tmpLastByte == 0xFF)) {  			// 7/31/05  			// may be a valid frame - skip its contents to prevent false sync  			long tmpNewPosition = _headerOffset + tmpFrameSize;  			if (tmpFrameSize == 0)  				tmpNewPosition++;  			stream.Seek (tmpNewPosition' SeekOrigin.Begin);  			continue;  		}  	}  	/*if (BR == 0 || FrameSizeConst == 0)                         {                             startpos = HeaderOffset+1;                             fseek(fp' startpos' SEEK_SET);                             continue;                         }*/stream.Seek (_headerOffset + tmpFrameSize' SeekOrigin.Begin);  	if (stream.Read1 () == 0xFF) {  		fh1 = stream.Read1 ();  		fh2 = stream.Read1 ();  		if (tmpFrameHeader [1] == fh1 && (tmpFrameHeader [2] & 0x0D) == (fh2 & 0x0D)) {  			// header found  			break;  		}  	}  	stream.Seek (_headerOffset + 1' SeekOrigin.Begin);  	continue;  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: if (tmpFrameHeader [1] == 0xFF || ((tmpFrameHeader [1] >> 3) & 0x03) == 1)// 2/19/05 - more bad data   {  	stream.Seek (-3' SeekOrigin.Current);  } else {  	int tmpMpegID = (tmpFrameHeader [1] >> 3) & 0x03;  	int tmpLayerNum = (tmpFrameHeader [1] >> 1) & 0x03;  	int tmpFrequency = GetFrequency ((MpegVersion)tmpMpegID' (tmpFrameHeader [2] >> 2) & 0x03);  	// Check for invalid frequency  	if (tmpFrequency == 0) {  		stream.Seek (-3' SeekOrigin.Current);  		continue;  	}  	int tmpSamplesPerFrame = GetSamplesPerFrame ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum);  	int tmpUsesPadding = (tmpFrameHeader [2] >> 1) & 0x01;  	double tmpFrameSizeConst = 125.0 * tmpSamplesPerFrame / tmpFrequency;  	int tmpPaddingSize = (tmpLayerNum == 3 ? 4 : 1);  	int tmpBitrateIndex = tmpFrameHeader [2] >> 4;  	// Check for invalid values  	if (tmpBitrateIndex < 1 || tmpBitrateIndex > 14 || tmpLayerNum == 0) {  		stream.Seek (-3' SeekOrigin.Current);  		continue;  	}  	int tmpFrameBitrate = GetBitrate ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum' tmpBitrateIndex);  	int tmpFrameSize = (int)(tmpFrameBitrate * tmpFrameSizeConst) + (tmpUsesPadding * tmpPaddingSize);  	_headerOffset = stream.Position - 4;  	if (tmpFrameSize < 8) {  		stream.Seek (-3' SeekOrigin.Current);  		continue;  	}  	// 7/21/05 - Check for 0x00 or 0xFF at end of last frame  	// this sucks for tracks that start with silence  	if (_headerOffset >= 1 && !acceptNullSamples)// if (ftell(fp) >= 5)  	 {  		stream.Seek (-5' SeekOrigin.Current);  		byte tmpLastByte = stream.Read1 ();  		stream.Seek (4' SeekOrigin.Current);  		if (tmpFrameBitrate != 320 && (tmpLastByte == 0x00 || tmpLastByte == 0xFF)) {  			// 7/31/05  			// may be a valid frame - skip its contents to prevent false sync  			long tmpNewPosition = _headerOffset + tmpFrameSize;  			if (tmpFrameSize == 0)  				tmpNewPosition++;  			stream.Seek (tmpNewPosition' SeekOrigin.Begin);  			continue;  		}  	}  	/*if (BR == 0 || FrameSizeConst == 0)                         {                             startpos = HeaderOffset+1;                             fseek(fp' startpos' SEEK_SET);                             continue;                         }*/stream.Seek (_headerOffset + tmpFrameSize' SeekOrigin.Begin);  	if (stream.Read1 () == 0xFF) {  		fh1 = stream.Read1 ();  		fh2 = stream.Read1 ();  		if (tmpFrameHeader [1] == fh1 && (tmpFrameHeader [2] & 0x0D) == (fh2 & 0x0D)) {  			// header found  			break;  		}  	}  	stream.Seek (_headerOffset + 1' SeekOrigin.Begin);  	continue;  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: if (tmpFrameHeader [1] == 0xFF || ((tmpFrameHeader [1] >> 3) & 0x03) == 1)// 2/19/05 - more bad data   {  	stream.Seek (-3' SeekOrigin.Current);  } else {  	int tmpMpegID = (tmpFrameHeader [1] >> 3) & 0x03;  	int tmpLayerNum = (tmpFrameHeader [1] >> 1) & 0x03;  	int tmpFrequency = GetFrequency ((MpegVersion)tmpMpegID' (tmpFrameHeader [2] >> 2) & 0x03);  	// Check for invalid frequency  	if (tmpFrequency == 0) {  		stream.Seek (-3' SeekOrigin.Current);  		continue;  	}  	int tmpSamplesPerFrame = GetSamplesPerFrame ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum);  	int tmpUsesPadding = (tmpFrameHeader [2] >> 1) & 0x01;  	double tmpFrameSizeConst = 125.0 * tmpSamplesPerFrame / tmpFrequency;  	int tmpPaddingSize = (tmpLayerNum == 3 ? 4 : 1);  	int tmpBitrateIndex = tmpFrameHeader [2] >> 4;  	// Check for invalid values  	if (tmpBitrateIndex < 1 || tmpBitrateIndex > 14 || tmpLayerNum == 0) {  		stream.Seek (-3' SeekOrigin.Current);  		continue;  	}  	int tmpFrameBitrate = GetBitrate ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum' tmpBitrateIndex);  	int tmpFrameSize = (int)(tmpFrameBitrate * tmpFrameSizeConst) + (tmpUsesPadding * tmpPaddingSize);  	_headerOffset = stream.Position - 4;  	if (tmpFrameSize < 8) {  		stream.Seek (-3' SeekOrigin.Current);  		continue;  	}  	// 7/21/05 - Check for 0x00 or 0xFF at end of last frame  	// this sucks for tracks that start with silence  	if (_headerOffset >= 1 && !acceptNullSamples)// if (ftell(fp) >= 5)  	 {  		stream.Seek (-5' SeekOrigin.Current);  		byte tmpLastByte = stream.Read1 ();  		stream.Seek (4' SeekOrigin.Current);  		if (tmpFrameBitrate != 320 && (tmpLastByte == 0x00 || tmpLastByte == 0xFF)) {  			// 7/31/05  			// may be a valid frame - skip its contents to prevent false sync  			long tmpNewPosition = _headerOffset + tmpFrameSize;  			if (tmpFrameSize == 0)  				tmpNewPosition++;  			stream.Seek (tmpNewPosition' SeekOrigin.Begin);  			continue;  		}  	}  	/*if (BR == 0 || FrameSizeConst == 0)                         {                             startpos = HeaderOffset+1;                             fseek(fp' startpos' SEEK_SET);                             continue;                         }*/stream.Seek (_headerOffset + tmpFrameSize' SeekOrigin.Begin);  	if (stream.Read1 () == 0xFF) {  		fh1 = stream.Read1 ();  		fh2 = stream.Read1 ();  		if (tmpFrameHeader [1] == fh1 && (tmpFrameHeader [2] & 0x0D) == (fh2 & 0x0D)) {  			// header found  			break;  		}  	}  	stream.Seek (_headerOffset + 1' SeekOrigin.Begin);  	continue;  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: if (tmpFrameHeader [1] == 0xFF || ((tmpFrameHeader [1] >> 3) & 0x03) == 1)// 2/19/05 - more bad data   {  	stream.Seek (-3' SeekOrigin.Current);  } else {  	int tmpMpegID = (tmpFrameHeader [1] >> 3) & 0x03;  	int tmpLayerNum = (tmpFrameHeader [1] >> 1) & 0x03;  	int tmpFrequency = GetFrequency ((MpegVersion)tmpMpegID' (tmpFrameHeader [2] >> 2) & 0x03);  	// Check for invalid frequency  	if (tmpFrequency == 0) {  		stream.Seek (-3' SeekOrigin.Current);  		continue;  	}  	int tmpSamplesPerFrame = GetSamplesPerFrame ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum);  	int tmpUsesPadding = (tmpFrameHeader [2] >> 1) & 0x01;  	double tmpFrameSizeConst = 125.0 * tmpSamplesPerFrame / tmpFrequency;  	int tmpPaddingSize = (tmpLayerNum == 3 ? 4 : 1);  	int tmpBitrateIndex = tmpFrameHeader [2] >> 4;  	// Check for invalid values  	if (tmpBitrateIndex < 1 || tmpBitrateIndex > 14 || tmpLayerNum == 0) {  		stream.Seek (-3' SeekOrigin.Current);  		continue;  	}  	int tmpFrameBitrate = GetBitrate ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum' tmpBitrateIndex);  	int tmpFrameSize = (int)(tmpFrameBitrate * tmpFrameSizeConst) + (tmpUsesPadding * tmpPaddingSize);  	_headerOffset = stream.Position - 4;  	if (tmpFrameSize < 8) {  		stream.Seek (-3' SeekOrigin.Current);  		continue;  	}  	// 7/21/05 - Check for 0x00 or 0xFF at end of last frame  	// this sucks for tracks that start with silence  	if (_headerOffset >= 1 && !acceptNullSamples)// if (ftell(fp) >= 5)  	 {  		stream.Seek (-5' SeekOrigin.Current);  		byte tmpLastByte = stream.Read1 ();  		stream.Seek (4' SeekOrigin.Current);  		if (tmpFrameBitrate != 320 && (tmpLastByte == 0x00 || tmpLastByte == 0xFF)) {  			// 7/31/05  			// may be a valid frame - skip its contents to prevent false sync  			long tmpNewPosition = _headerOffset + tmpFrameSize;  			if (tmpFrameSize == 0)  				tmpNewPosition++;  			stream.Seek (tmpNewPosition' SeekOrigin.Begin);  			continue;  		}  	}  	/*if (BR == 0 || FrameSizeConst == 0)                         {                             startpos = HeaderOffset+1;                             fseek(fp' startpos' SEEK_SET);                             continue;                         }*/stream.Seek (_headerOffset + tmpFrameSize' SeekOrigin.Begin);  	if (stream.Read1 () == 0xFF) {  		fh1 = stream.Read1 ();  		fh2 = stream.Read1 ();  		if (tmpFrameHeader [1] == fh1 && (tmpFrameHeader [2] & 0x0D) == (fh2 & 0x0D)) {  			// header found  			break;  		}  	}  	stream.Seek (_headerOffset + 1' SeekOrigin.Begin);  	continue;  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: if (tmpFrameHeader [1] == 0xFF || ((tmpFrameHeader [1] >> 3) & 0x03) == 1)// 2/19/05 - more bad data   {  	stream.Seek (-3' SeekOrigin.Current);  } else {  	int tmpMpegID = (tmpFrameHeader [1] >> 3) & 0x03;  	int tmpLayerNum = (tmpFrameHeader [1] >> 1) & 0x03;  	int tmpFrequency = GetFrequency ((MpegVersion)tmpMpegID' (tmpFrameHeader [2] >> 2) & 0x03);  	// Check for invalid frequency  	if (tmpFrequency == 0) {  		stream.Seek (-3' SeekOrigin.Current);  		continue;  	}  	int tmpSamplesPerFrame = GetSamplesPerFrame ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum);  	int tmpUsesPadding = (tmpFrameHeader [2] >> 1) & 0x01;  	double tmpFrameSizeConst = 125.0 * tmpSamplesPerFrame / tmpFrequency;  	int tmpPaddingSize = (tmpLayerNum == 3 ? 4 : 1);  	int tmpBitrateIndex = tmpFrameHeader [2] >> 4;  	// Check for invalid values  	if (tmpBitrateIndex < 1 || tmpBitrateIndex > 14 || tmpLayerNum == 0) {  		stream.Seek (-3' SeekOrigin.Current);  		continue;  	}  	int tmpFrameBitrate = GetBitrate ((MpegVersion)tmpMpegID' (MpegLayer)tmpLayerNum' tmpBitrateIndex);  	int tmpFrameSize = (int)(tmpFrameBitrate * tmpFrameSizeConst) + (tmpUsesPadding * tmpPaddingSize);  	_headerOffset = stream.Position - 4;  	if (tmpFrameSize < 8) {  		stream.Seek (-3' SeekOrigin.Current);  		continue;  	}  	// 7/21/05 - Check for 0x00 or 0xFF at end of last frame  	// this sucks for tracks that start with silence  	if (_headerOffset >= 1 && !acceptNullSamples)// if (ftell(fp) >= 5)  	 {  		stream.Seek (-5' SeekOrigin.Current);  		byte tmpLastByte = stream.Read1 ();  		stream.Seek (4' SeekOrigin.Current);  		if (tmpFrameBitrate != 320 && (tmpLastByte == 0x00 || tmpLastByte == 0xFF)) {  			// 7/31/05  			// may be a valid frame - skip its contents to prevent false sync  			long tmpNewPosition = _headerOffset + tmpFrameSize;  			if (tmpFrameSize == 0)  				tmpNewPosition++;  			stream.Seek (tmpNewPosition' SeekOrigin.Begin);  			continue;  		}  	}  	/*if (BR == 0 || FrameSizeConst == 0)                         {                             startpos = HeaderOffset+1;                             fseek(fp' startpos' SEEK_SET);                             continue;                         }*/stream.Seek (_headerOffset + tmpFrameSize' SeekOrigin.Begin);  	if (stream.Read1 () == 0xFF) {  		fh1 = stream.Read1 ();  		fh2 = stream.Read1 ();  		if (tmpFrameHeader [1] == fh1 && (tmpFrameHeader [2] & 0x0D) == (fh2 & 0x0D)) {  			// header found  			break;  		}  	}  	stream.Seek (_headerOffset + 1' SeekOrigin.Begin);  	continue;  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: stream.Seek (-3' SeekOrigin.Current);  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: if (tmpFrequency == 0) {  	stream.Seek (-3' SeekOrigin.Current);  	continue;  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: stream.Seek (-3' SeekOrigin.Current);  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: if (tmpBitrateIndex < 1 || tmpBitrateIndex > 14 || tmpLayerNum == 0) {  	stream.Seek (-3' SeekOrigin.Current);  	continue;  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: if (tmpBitrateIndex < 1 || tmpBitrateIndex > 14 || tmpLayerNum == 0) {  	stream.Seek (-3' SeekOrigin.Current);  	continue;  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: stream.Seek (-3' SeekOrigin.Current);  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: _headerOffset = stream.Position - 4;  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: if (tmpFrameSize < 8) {  	stream.Seek (-3' SeekOrigin.Current);  	continue;  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: if (tmpFrameSize < 8) {  	stream.Seek (-3' SeekOrigin.Current);  	continue;  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: stream.Seek (-3' SeekOrigin.Current);  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: if (_headerOffset >= 1 && !acceptNullSamples)// if (ftell(fp) >= 5)   {  	stream.Seek (-5' SeekOrigin.Current);  	byte tmpLastByte = stream.Read1 ();  	stream.Seek (4' SeekOrigin.Current);  	if (tmpFrameBitrate != 320 && (tmpLastByte == 0x00 || tmpLastByte == 0xFF)) {  		// 7/31/05  		// may be a valid frame - skip its contents to prevent false sync  		long tmpNewPosition = _headerOffset + tmpFrameSize;  		if (tmpFrameSize == 0)  			tmpNewPosition++;  		stream.Seek (tmpNewPosition' SeekOrigin.Begin);  		continue;  	}  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: if (_headerOffset >= 1 && !acceptNullSamples)// if (ftell(fp) >= 5)   {  	stream.Seek (-5' SeekOrigin.Current);  	byte tmpLastByte = stream.Read1 ();  	stream.Seek (4' SeekOrigin.Current);  	if (tmpFrameBitrate != 320 && (tmpLastByte == 0x00 || tmpLastByte == 0xFF)) {  		// 7/31/05  		// may be a valid frame - skip its contents to prevent false sync  		long tmpNewPosition = _headerOffset + tmpFrameSize;  		if (tmpFrameSize == 0)  			tmpNewPosition++;  		stream.Seek (tmpNewPosition' SeekOrigin.Begin);  		continue;  	}  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: if (_headerOffset >= 1 && !acceptNullSamples)// if (ftell(fp) >= 5)   {  	stream.Seek (-5' SeekOrigin.Current);  	byte tmpLastByte = stream.Read1 ();  	stream.Seek (4' SeekOrigin.Current);  	if (tmpFrameBitrate != 320 && (tmpLastByte == 0x00 || tmpLastByte == 0xFF)) {  		// 7/31/05  		// may be a valid frame - skip its contents to prevent false sync  		long tmpNewPosition = _headerOffset + tmpFrameSize;  		if (tmpFrameSize == 0)  			tmpNewPosition++;  		stream.Seek (tmpNewPosition' SeekOrigin.Begin);  		continue;  	}  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: stream.Seek (-5' SeekOrigin.Current);  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: stream.Seek (4' SeekOrigin.Current);  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: if (tmpFrameBitrate != 320 && (tmpLastByte == 0x00 || tmpLastByte == 0xFF)) {  	// 7/31/05  	// may be a valid frame - skip its contents to prevent false sync  	long tmpNewPosition = _headerOffset + tmpFrameSize;  	if (tmpFrameSize == 0)  		tmpNewPosition++;  	stream.Seek (tmpNewPosition' SeekOrigin.Begin);  	continue;  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: if (stream.Read1 () == 0xFF) {  	fh1 = stream.Read1 ();  	fh2 = stream.Read1 ();  	if (tmpFrameHeader [1] == fh1 && (tmpFrameHeader [2] & 0x0D) == (fh2 & 0x0D)) {  		// header found  		break;  	}  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: if (tmpFrameHeader [1] == fh1 && (tmpFrameHeader [2] & 0x0D) == (fh2 & 0x0D)) {  	// header found  	break;  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: _mpegVersion = (MpegVersion)((tmpFrameHeader [1] >> 3) & 0x03);  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: _frequency = GetFrequency (_mpegVersion' (tmpFrameHeader [2] >> 2) & 0x03);  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: _frequency = GetFrequency (_mpegVersion' (tmpFrameHeader [2] >> 2) & 0x03);  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: _isPrivate = ((tmpFrameHeader [2] & 0x01) == 0x01);  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: _frameSizeConst = 125.0 * _samplesPerFrame / _frequency;  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: _paddingSizeConst = (_mpegLayer == MpegLayer.Layer1 ? 4 : 1);  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: _isCopyright = (((tmpFrameHeader [3] >> 3) & 0x01) == 0x01);  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: _isCopyright = (((tmpFrameHeader [3] >> 3) & 0x01) == 0x01);  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: _isOriginal = (((tmpFrameHeader [3] >> 2) & 0x01) == 0x01);  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: _isOriginal = (((tmpFrameHeader [3] >> 2) & 0x01) == 0x01);  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: if ((tmpFrameHeader [3] >> 6) == 3)  	_channels = 1;  // Single Channel  else  	_channels = 2;  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: if ((tmpFrameHeader [3] >> 6) == 3)  	_channels = 1;  // Single Channel  else  	_channels = 2;  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: if ((tmpFrameHeader [3] >> 6) == 3)  	_channels = 1;  // Single Channel  else  	_channels = 2;  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: if ((tmpFrameHeader [3] >> 6) == 3)  	_channels = 1;  // Single Channel  else  	_channels = 2;  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: _channels = 2;  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: stream.Seek (tmpID3v2TagSize + 36' SeekOrigin.Begin);  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: if (tmpHasLameInfoTag) {  	stream.Seek (4' SeekOrigin.Current);  	int tmpFrames = stream.ReadInt32 ();  	uint tmpBytes = (uint)stream.ReadInt32 ();  	if (tmpFrames > 256 && tmpBytes > 50000) {  		decimal tmpBitrate = tmpBytes / 125.0m / (tmpFrames * _samplesPerFrame / (decimal)_frequency);  		if (tmpBitrate <= 320 && tmpBitrate >= 32) {  			_frames = tmpFrames;  			_bitrate = tmpBitrate;  			_totalSeconds = (tmpBytes / 125.0m) / _bitrate;  		}  	}  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: if (tmpHasLameInfoTag) {  	stream.Seek (4' SeekOrigin.Current);  	int tmpFrames = stream.ReadInt32 ();  	uint tmpBytes = (uint)stream.ReadInt32 ();  	if (tmpFrames > 256 && tmpBytes > 50000) {  		decimal tmpBitrate = tmpBytes / 125.0m / (tmpFrames * _samplesPerFrame / (decimal)_frequency);  		if (tmpBitrate <= 320 && tmpBitrate >= 32) {  			_frames = tmpFrames;  			_bitrate = tmpBitrate;  			_totalSeconds = (tmpBytes / 125.0m) / _bitrate;  		}  	}  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: if (tmpHasLameInfoTag) {  	stream.Seek (4' SeekOrigin.Current);  	int tmpFrames = stream.ReadInt32 ();  	uint tmpBytes = (uint)stream.ReadInt32 ();  	if (tmpFrames > 256 && tmpBytes > 50000) {  		decimal tmpBitrate = tmpBytes / 125.0m / (tmpFrames * _samplesPerFrame / (decimal)_frequency);  		if (tmpBitrate <= 320 && tmpBitrate >= 32) {  			_frames = tmpFrames;  			_bitrate = tmpBitrate;  			_totalSeconds = (tmpBytes / 125.0m) / _bitrate;  		}  	}  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: if (tmpHasLameInfoTag) {  	stream.Seek (4' SeekOrigin.Current);  	int tmpFrames = stream.ReadInt32 ();  	uint tmpBytes = (uint)stream.ReadInt32 ();  	if (tmpFrames > 256 && tmpBytes > 50000) {  		decimal tmpBitrate = tmpBytes / 125.0m / (tmpFrames * _samplesPerFrame / (decimal)_frequency);  		if (tmpBitrate <= 320 && tmpBitrate >= 32) {  			_frames = tmpFrames;  			_bitrate = tmpBitrate;  			_totalSeconds = (tmpBytes / 125.0m) / _bitrate;  		}  	}  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: if (tmpHasLameInfoTag) {  	stream.Seek (4' SeekOrigin.Current);  	int tmpFrames = stream.ReadInt32 ();  	uint tmpBytes = (uint)stream.ReadInt32 ();  	if (tmpFrames > 256 && tmpBytes > 50000) {  		decimal tmpBitrate = tmpBytes / 125.0m / (tmpFrames * _samplesPerFrame / (decimal)_frequency);  		if (tmpBitrate <= 320 && tmpBitrate >= 32) {  			_frames = tmpFrames;  			_bitrate = tmpBitrate;  			_totalSeconds = (tmpBytes / 125.0m) / _bitrate;  		}  	}  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: stream.Seek (4' SeekOrigin.Current);  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: if (tmpFrames > 256 && tmpBytes > 50000) {  	decimal tmpBitrate = tmpBytes / 125.0m / (tmpFrames * _samplesPerFrame / (decimal)_frequency);  	if (tmpBitrate <= 320 && tmpBitrate >= 32) {  		_frames = tmpFrames;  		_bitrate = tmpBitrate;  		_totalSeconds = (tmpBytes / 125.0m) / _bitrate;  	}  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: if (tmpFrames > 256 && tmpBytes > 50000) {  	decimal tmpBitrate = tmpBytes / 125.0m / (tmpFrames * _samplesPerFrame / (decimal)_frequency);  	if (tmpBitrate <= 320 && tmpBitrate >= 32) {  		_frames = tmpFrames;  		_bitrate = tmpBitrate;  		_totalSeconds = (tmpBytes / 125.0m) / _bitrate;  	}  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: if (tmpFrames > 256 && tmpBytes > 50000) {  	decimal tmpBitrate = tmpBytes / 125.0m / (tmpFrames * _samplesPerFrame / (decimal)_frequency);  	if (tmpBitrate <= 320 && tmpBitrate >= 32) {  		_frames = tmpFrames;  		_bitrate = tmpBitrate;  		_totalSeconds = (tmpBytes / 125.0m) / _bitrate;  	}  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: if (tmpFrames > 256 && tmpBytes > 50000) {  	decimal tmpBitrate = tmpBytes / 125.0m / (tmpFrames * _samplesPerFrame / (decimal)_frequency);  	if (tmpBitrate <= 320 && tmpBitrate >= 32) {  		_frames = tmpFrames;  		_bitrate = tmpBitrate;  		_totalSeconds = (tmpBytes / 125.0m) / _bitrate;  	}  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: if (tmpBitrate <= 320 && tmpBitrate >= 32) {  	_frames = tmpFrames;  	_bitrate = tmpBitrate;  	_totalSeconds = (tmpBytes / 125.0m) / _bitrate;  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The following statement contains a magic number: if (tmpBitrate <= 320 && tmpBitrate >= 32) {  	_frames = tmpFrames;  	_bitrate = tmpBitrate;  	_totalSeconds = (tmpBytes / 125.0m) / _bitrate;  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,CalculateBitrate,The following statement contains a magic number: try {  	int BR' Padding;  	int FrameSize;  	int TotalBR = 0;  	int FrameOffset = 0;  	//Int64 TagOffset = 0;  	bool bTrusting = true;  	bool ignoreall = false;  	Byte[] FH = new Byte[4];  	bool mPerfect = true;  	stream.Position = _headerOffset;  	//                if (_headerOffset > 0)  	//                {  	//                    TagOffset = _headerOffset;  	//                }  	int offset = 0;  	int frameCount = 0;  	int FirstBR = 0;  	int audioDataSize = (int)(stream.Length - _headerOffset);  	Byte[] audioData = new Byte[audioDataSize];  	//Int64 startoffset = stream.Position;  	int BufLen = stream.Read (audioData' 0' audioDataSize);  	while (offset < BufLen - 16 && !ignoreall) {  		bool reservedlayer = false;  		// Find FrameSync  		if (FindFrameSync (FH' audioData' BufLen' ref FrameOffset' ref offset' ref mPerfect' ref ignoreall' ref bTrusting' ref reservedlayer)) {  			FrameOffset = 0;  			int bitrateIndex = FH [2] >> 4;  			if (bitrateIndex <= 0 || bitrateIndex >= 15) {  				offset -= 3;  				continue;  			}  			Padding = (FH [2] >> 1) & 0x01;  			BR = GetBitrate (_mpegVersion' _mpegLayer' bitrateIndex);  			if (BR == 0 || BR % 8 != 0) {  				offset -= 3;  				continue;  			}  			//step = "last good frame @ " + String(startoffset + offset - 4) + "' frame " +  			//       String(_frames + 1);  			// todo: put back later  			/*if (InterestedFrames != NULL)                         {                             if (((_frames + 1) * _samplesperframe / (float)_Frequency) * 75.0 >= InterestedFrames->CurrentFrame())                             {                                 if (_frames == 0 || InterestedFrames->NoAccomodation)                                 {                                     InterestedFrames->SetCurrentByteOffset(startoffset + offset - 4);                                     InterestedFrames->SetCurrentFrameOffset(_frames);                                 }                                 InterestedFrames->SetCurrentByteEndOffset(startoffset + offset - 4);                                 InterestedFrames->Cur += 1;                             }                             else                             {                                 InterestedFrames->SetCurrentByteOffset(startoffset + offset - 4);                                 InterestedFrames->SetCurrentFrameOffset(_frames);                             }                         }*/if (_isVBR != true) {  				if (TotalBR == 0) {  					FirstBR = BR;  				} else if (BR != FirstBR) {  					_isVBR = true;  				}  			}  			TotalBR += BR;  			FrameSize = (int)(BR * _frameSizeConst + Padding * _paddingSizeConst);  			offset += FrameSize - 4;  			frameCount++;  		}  	}  	// end while  	if (frameCount == 0) {  		throw new InvalidDataException (String.Format ("No frames found in {0}"' _fileName));  	}  	_frames = frameCount;  	if (_isVBR == null) {  		_bitrate = FirstBR;  		_isVBR = false;  	} else {  		_bitrate = TotalBR / _frames;  	}  	if (_bitrate == 0) {  		throw new InvalidDataException (String.Format ("Error determining bitrate: {0}"' _fileName));  	}  	_totalSeconds = (audioLength / 125.0m) / _bitrate;  } catch (Exception ex) {  	throw new Exception (String.Format ("Error calculating bitrate; {0}"' step)' ex);  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,CalculateBitrate,The following statement contains a magic number: try {  	int BR' Padding;  	int FrameSize;  	int TotalBR = 0;  	int FrameOffset = 0;  	//Int64 TagOffset = 0;  	bool bTrusting = true;  	bool ignoreall = false;  	Byte[] FH = new Byte[4];  	bool mPerfect = true;  	stream.Position = _headerOffset;  	//                if (_headerOffset > 0)  	//                {  	//                    TagOffset = _headerOffset;  	//                }  	int offset = 0;  	int frameCount = 0;  	int FirstBR = 0;  	int audioDataSize = (int)(stream.Length - _headerOffset);  	Byte[] audioData = new Byte[audioDataSize];  	//Int64 startoffset = stream.Position;  	int BufLen = stream.Read (audioData' 0' audioDataSize);  	while (offset < BufLen - 16 && !ignoreall) {  		bool reservedlayer = false;  		// Find FrameSync  		if (FindFrameSync (FH' audioData' BufLen' ref FrameOffset' ref offset' ref mPerfect' ref ignoreall' ref bTrusting' ref reservedlayer)) {  			FrameOffset = 0;  			int bitrateIndex = FH [2] >> 4;  			if (bitrateIndex <= 0 || bitrateIndex >= 15) {  				offset -= 3;  				continue;  			}  			Padding = (FH [2] >> 1) & 0x01;  			BR = GetBitrate (_mpegVersion' _mpegLayer' bitrateIndex);  			if (BR == 0 || BR % 8 != 0) {  				offset -= 3;  				continue;  			}  			//step = "last good frame @ " + String(startoffset + offset - 4) + "' frame " +  			//       String(_frames + 1);  			// todo: put back later  			/*if (InterestedFrames != NULL)                         {                             if (((_frames + 1) * _samplesperframe / (float)_Frequency) * 75.0 >= InterestedFrames->CurrentFrame())                             {                                 if (_frames == 0 || InterestedFrames->NoAccomodation)                                 {                                     InterestedFrames->SetCurrentByteOffset(startoffset + offset - 4);                                     InterestedFrames->SetCurrentFrameOffset(_frames);                                 }                                 InterestedFrames->SetCurrentByteEndOffset(startoffset + offset - 4);                                 InterestedFrames->Cur += 1;                             }                             else                             {                                 InterestedFrames->SetCurrentByteOffset(startoffset + offset - 4);                                 InterestedFrames->SetCurrentFrameOffset(_frames);                             }                         }*/if (_isVBR != true) {  				if (TotalBR == 0) {  					FirstBR = BR;  				} else if (BR != FirstBR) {  					_isVBR = true;  				}  			}  			TotalBR += BR;  			FrameSize = (int)(BR * _frameSizeConst + Padding * _paddingSizeConst);  			offset += FrameSize - 4;  			frameCount++;  		}  	}  	// end while  	if (frameCount == 0) {  		throw new InvalidDataException (String.Format ("No frames found in {0}"' _fileName));  	}  	_frames = frameCount;  	if (_isVBR == null) {  		_bitrate = FirstBR;  		_isVBR = false;  	} else {  		_bitrate = TotalBR / _frames;  	}  	if (_bitrate == 0) {  		throw new InvalidDataException (String.Format ("Error determining bitrate: {0}"' _fileName));  	}  	_totalSeconds = (audioLength / 125.0m) / _bitrate;  } catch (Exception ex) {  	throw new Exception (String.Format ("Error calculating bitrate; {0}"' step)' ex);  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,CalculateBitrate,The following statement contains a magic number: try {  	int BR' Padding;  	int FrameSize;  	int TotalBR = 0;  	int FrameOffset = 0;  	//Int64 TagOffset = 0;  	bool bTrusting = true;  	bool ignoreall = false;  	Byte[] FH = new Byte[4];  	bool mPerfect = true;  	stream.Position = _headerOffset;  	//                if (_headerOffset > 0)  	//                {  	//                    TagOffset = _headerOffset;  	//                }  	int offset = 0;  	int frameCount = 0;  	int FirstBR = 0;  	int audioDataSize = (int)(stream.Length - _headerOffset);  	Byte[] audioData = new Byte[audioDataSize];  	//Int64 startoffset = stream.Position;  	int BufLen = stream.Read (audioData' 0' audioDataSize);  	while (offset < BufLen - 16 && !ignoreall) {  		bool reservedlayer = false;  		// Find FrameSync  		if (FindFrameSync (FH' audioData' BufLen' ref FrameOffset' ref offset' ref mPerfect' ref ignoreall' ref bTrusting' ref reservedlayer)) {  			FrameOffset = 0;  			int bitrateIndex = FH [2] >> 4;  			if (bitrateIndex <= 0 || bitrateIndex >= 15) {  				offset -= 3;  				continue;  			}  			Padding = (FH [2] >> 1) & 0x01;  			BR = GetBitrate (_mpegVersion' _mpegLayer' bitrateIndex);  			if (BR == 0 || BR % 8 != 0) {  				offset -= 3;  				continue;  			}  			//step = "last good frame @ " + String(startoffset + offset - 4) + "' frame " +  			//       String(_frames + 1);  			// todo: put back later  			/*if (InterestedFrames != NULL)                         {                             if (((_frames + 1) * _samplesperframe / (float)_Frequency) * 75.0 >= InterestedFrames->CurrentFrame())                             {                                 if (_frames == 0 || InterestedFrames->NoAccomodation)                                 {                                     InterestedFrames->SetCurrentByteOffset(startoffset + offset - 4);                                     InterestedFrames->SetCurrentFrameOffset(_frames);                                 }                                 InterestedFrames->SetCurrentByteEndOffset(startoffset + offset - 4);                                 InterestedFrames->Cur += 1;                             }                             else                             {                                 InterestedFrames->SetCurrentByteOffset(startoffset + offset - 4);                                 InterestedFrames->SetCurrentFrameOffset(_frames);                             }                         }*/if (_isVBR != true) {  				if (TotalBR == 0) {  					FirstBR = BR;  				} else if (BR != FirstBR) {  					_isVBR = true;  				}  			}  			TotalBR += BR;  			FrameSize = (int)(BR * _frameSizeConst + Padding * _paddingSizeConst);  			offset += FrameSize - 4;  			frameCount++;  		}  	}  	// end while  	if (frameCount == 0) {  		throw new InvalidDataException (String.Format ("No frames found in {0}"' _fileName));  	}  	_frames = frameCount;  	if (_isVBR == null) {  		_bitrate = FirstBR;  		_isVBR = false;  	} else {  		_bitrate = TotalBR / _frames;  	}  	if (_bitrate == 0) {  		throw new InvalidDataException (String.Format ("Error determining bitrate: {0}"' _fileName));  	}  	_totalSeconds = (audioLength / 125.0m) / _bitrate;  } catch (Exception ex) {  	throw new Exception (String.Format ("Error calculating bitrate; {0}"' step)' ex);  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,CalculateBitrate,The following statement contains a magic number: try {  	int BR' Padding;  	int FrameSize;  	int TotalBR = 0;  	int FrameOffset = 0;  	//Int64 TagOffset = 0;  	bool bTrusting = true;  	bool ignoreall = false;  	Byte[] FH = new Byte[4];  	bool mPerfect = true;  	stream.Position = _headerOffset;  	//                if (_headerOffset > 0)  	//                {  	//                    TagOffset = _headerOffset;  	//                }  	int offset = 0;  	int frameCount = 0;  	int FirstBR = 0;  	int audioDataSize = (int)(stream.Length - _headerOffset);  	Byte[] audioData = new Byte[audioDataSize];  	//Int64 startoffset = stream.Position;  	int BufLen = stream.Read (audioData' 0' audioDataSize);  	while (offset < BufLen - 16 && !ignoreall) {  		bool reservedlayer = false;  		// Find FrameSync  		if (FindFrameSync (FH' audioData' BufLen' ref FrameOffset' ref offset' ref mPerfect' ref ignoreall' ref bTrusting' ref reservedlayer)) {  			FrameOffset = 0;  			int bitrateIndex = FH [2] >> 4;  			if (bitrateIndex <= 0 || bitrateIndex >= 15) {  				offset -= 3;  				continue;  			}  			Padding = (FH [2] >> 1) & 0x01;  			BR = GetBitrate (_mpegVersion' _mpegLayer' bitrateIndex);  			if (BR == 0 || BR % 8 != 0) {  				offset -= 3;  				continue;  			}  			//step = "last good frame @ " + String(startoffset + offset - 4) + "' frame " +  			//       String(_frames + 1);  			// todo: put back later  			/*if (InterestedFrames != NULL)                         {                             if (((_frames + 1) * _samplesperframe / (float)_Frequency) * 75.0 >= InterestedFrames->CurrentFrame())                             {                                 if (_frames == 0 || InterestedFrames->NoAccomodation)                                 {                                     InterestedFrames->SetCurrentByteOffset(startoffset + offset - 4);                                     InterestedFrames->SetCurrentFrameOffset(_frames);                                 }                                 InterestedFrames->SetCurrentByteEndOffset(startoffset + offset - 4);                                 InterestedFrames->Cur += 1;                             }                             else                             {                                 InterestedFrames->SetCurrentByteOffset(startoffset + offset - 4);                                 InterestedFrames->SetCurrentFrameOffset(_frames);                             }                         }*/if (_isVBR != true) {  				if (TotalBR == 0) {  					FirstBR = BR;  				} else if (BR != FirstBR) {  					_isVBR = true;  				}  			}  			TotalBR += BR;  			FrameSize = (int)(BR * _frameSizeConst + Padding * _paddingSizeConst);  			offset += FrameSize - 4;  			frameCount++;  		}  	}  	// end while  	if (frameCount == 0) {  		throw new InvalidDataException (String.Format ("No frames found in {0}"' _fileName));  	}  	_frames = frameCount;  	if (_isVBR == null) {  		_bitrate = FirstBR;  		_isVBR = false;  	} else {  		_bitrate = TotalBR / _frames;  	}  	if (_bitrate == 0) {  		throw new InvalidDataException (String.Format ("Error determining bitrate: {0}"' _fileName));  	}  	_totalSeconds = (audioLength / 125.0m) / _bitrate;  } catch (Exception ex) {  	throw new Exception (String.Format ("Error calculating bitrate; {0}"' step)' ex);  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,CalculateBitrate,The following statement contains a magic number: try {  	int BR' Padding;  	int FrameSize;  	int TotalBR = 0;  	int FrameOffset = 0;  	//Int64 TagOffset = 0;  	bool bTrusting = true;  	bool ignoreall = false;  	Byte[] FH = new Byte[4];  	bool mPerfect = true;  	stream.Position = _headerOffset;  	//                if (_headerOffset > 0)  	//                {  	//                    TagOffset = _headerOffset;  	//                }  	int offset = 0;  	int frameCount = 0;  	int FirstBR = 0;  	int audioDataSize = (int)(stream.Length - _headerOffset);  	Byte[] audioData = new Byte[audioDataSize];  	//Int64 startoffset = stream.Position;  	int BufLen = stream.Read (audioData' 0' audioDataSize);  	while (offset < BufLen - 16 && !ignoreall) {  		bool reservedlayer = false;  		// Find FrameSync  		if (FindFrameSync (FH' audioData' BufLen' ref FrameOffset' ref offset' ref mPerfect' ref ignoreall' ref bTrusting' ref reservedlayer)) {  			FrameOffset = 0;  			int bitrateIndex = FH [2] >> 4;  			if (bitrateIndex <= 0 || bitrateIndex >= 15) {  				offset -= 3;  				continue;  			}  			Padding = (FH [2] >> 1) & 0x01;  			BR = GetBitrate (_mpegVersion' _mpegLayer' bitrateIndex);  			if (BR == 0 || BR % 8 != 0) {  				offset -= 3;  				continue;  			}  			//step = "last good frame @ " + String(startoffset + offset - 4) + "' frame " +  			//       String(_frames + 1);  			// todo: put back later  			/*if (InterestedFrames != NULL)                         {                             if (((_frames + 1) * _samplesperframe / (float)_Frequency) * 75.0 >= InterestedFrames->CurrentFrame())                             {                                 if (_frames == 0 || InterestedFrames->NoAccomodation)                                 {                                     InterestedFrames->SetCurrentByteOffset(startoffset + offset - 4);                                     InterestedFrames->SetCurrentFrameOffset(_frames);                                 }                                 InterestedFrames->SetCurrentByteEndOffset(startoffset + offset - 4);                                 InterestedFrames->Cur += 1;                             }                             else                             {                                 InterestedFrames->SetCurrentByteOffset(startoffset + offset - 4);                                 InterestedFrames->SetCurrentFrameOffset(_frames);                             }                         }*/if (_isVBR != true) {  				if (TotalBR == 0) {  					FirstBR = BR;  				} else if (BR != FirstBR) {  					_isVBR = true;  				}  			}  			TotalBR += BR;  			FrameSize = (int)(BR * _frameSizeConst + Padding * _paddingSizeConst);  			offset += FrameSize - 4;  			frameCount++;  		}  	}  	// end while  	if (frameCount == 0) {  		throw new InvalidDataException (String.Format ("No frames found in {0}"' _fileName));  	}  	_frames = frameCount;  	if (_isVBR == null) {  		_bitrate = FirstBR;  		_isVBR = false;  	} else {  		_bitrate = TotalBR / _frames;  	}  	if (_bitrate == 0) {  		throw new InvalidDataException (String.Format ("Error determining bitrate: {0}"' _fileName));  	}  	_totalSeconds = (audioLength / 125.0m) / _bitrate;  } catch (Exception ex) {  	throw new Exception (String.Format ("Error calculating bitrate; {0}"' step)' ex);  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,CalculateBitrate,The following statement contains a magic number: try {  	int BR' Padding;  	int FrameSize;  	int TotalBR = 0;  	int FrameOffset = 0;  	//Int64 TagOffset = 0;  	bool bTrusting = true;  	bool ignoreall = false;  	Byte[] FH = new Byte[4];  	bool mPerfect = true;  	stream.Position = _headerOffset;  	//                if (_headerOffset > 0)  	//                {  	//                    TagOffset = _headerOffset;  	//                }  	int offset = 0;  	int frameCount = 0;  	int FirstBR = 0;  	int audioDataSize = (int)(stream.Length - _headerOffset);  	Byte[] audioData = new Byte[audioDataSize];  	//Int64 startoffset = stream.Position;  	int BufLen = stream.Read (audioData' 0' audioDataSize);  	while (offset < BufLen - 16 && !ignoreall) {  		bool reservedlayer = false;  		// Find FrameSync  		if (FindFrameSync (FH' audioData' BufLen' ref FrameOffset' ref offset' ref mPerfect' ref ignoreall' ref bTrusting' ref reservedlayer)) {  			FrameOffset = 0;  			int bitrateIndex = FH [2] >> 4;  			if (bitrateIndex <= 0 || bitrateIndex >= 15) {  				offset -= 3;  				continue;  			}  			Padding = (FH [2] >> 1) & 0x01;  			BR = GetBitrate (_mpegVersion' _mpegLayer' bitrateIndex);  			if (BR == 0 || BR % 8 != 0) {  				offset -= 3;  				continue;  			}  			//step = "last good frame @ " + String(startoffset + offset - 4) + "' frame " +  			//       String(_frames + 1);  			// todo: put back later  			/*if (InterestedFrames != NULL)                         {                             if (((_frames + 1) * _samplesperframe / (float)_Frequency) * 75.0 >= InterestedFrames->CurrentFrame())                             {                                 if (_frames == 0 || InterestedFrames->NoAccomodation)                                 {                                     InterestedFrames->SetCurrentByteOffset(startoffset + offset - 4);                                     InterestedFrames->SetCurrentFrameOffset(_frames);                                 }                                 InterestedFrames->SetCurrentByteEndOffset(startoffset + offset - 4);                                 InterestedFrames->Cur += 1;                             }                             else                             {                                 InterestedFrames->SetCurrentByteOffset(startoffset + offset - 4);                                 InterestedFrames->SetCurrentFrameOffset(_frames);                             }                         }*/if (_isVBR != true) {  				if (TotalBR == 0) {  					FirstBR = BR;  				} else if (BR != FirstBR) {  					_isVBR = true;  				}  			}  			TotalBR += BR;  			FrameSize = (int)(BR * _frameSizeConst + Padding * _paddingSizeConst);  			offset += FrameSize - 4;  			frameCount++;  		}  	}  	// end while  	if (frameCount == 0) {  		throw new InvalidDataException (String.Format ("No frames found in {0}"' _fileName));  	}  	_frames = frameCount;  	if (_isVBR == null) {  		_bitrate = FirstBR;  		_isVBR = false;  	} else {  		_bitrate = TotalBR / _frames;  	}  	if (_bitrate == 0) {  		throw new InvalidDataException (String.Format ("Error determining bitrate: {0}"' _fileName));  	}  	_totalSeconds = (audioLength / 125.0m) / _bitrate;  } catch (Exception ex) {  	throw new Exception (String.Format ("Error calculating bitrate; {0}"' step)' ex);  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,CalculateBitrate,The following statement contains a magic number: try {  	int BR' Padding;  	int FrameSize;  	int TotalBR = 0;  	int FrameOffset = 0;  	//Int64 TagOffset = 0;  	bool bTrusting = true;  	bool ignoreall = false;  	Byte[] FH = new Byte[4];  	bool mPerfect = true;  	stream.Position = _headerOffset;  	//                if (_headerOffset > 0)  	//                {  	//                    TagOffset = _headerOffset;  	//                }  	int offset = 0;  	int frameCount = 0;  	int FirstBR = 0;  	int audioDataSize = (int)(stream.Length - _headerOffset);  	Byte[] audioData = new Byte[audioDataSize];  	//Int64 startoffset = stream.Position;  	int BufLen = stream.Read (audioData' 0' audioDataSize);  	while (offset < BufLen - 16 && !ignoreall) {  		bool reservedlayer = false;  		// Find FrameSync  		if (FindFrameSync (FH' audioData' BufLen' ref FrameOffset' ref offset' ref mPerfect' ref ignoreall' ref bTrusting' ref reservedlayer)) {  			FrameOffset = 0;  			int bitrateIndex = FH [2] >> 4;  			if (bitrateIndex <= 0 || bitrateIndex >= 15) {  				offset -= 3;  				continue;  			}  			Padding = (FH [2] >> 1) & 0x01;  			BR = GetBitrate (_mpegVersion' _mpegLayer' bitrateIndex);  			if (BR == 0 || BR % 8 != 0) {  				offset -= 3;  				continue;  			}  			//step = "last good frame @ " + String(startoffset + offset - 4) + "' frame " +  			//       String(_frames + 1);  			// todo: put back later  			/*if (InterestedFrames != NULL)                         {                             if (((_frames + 1) * _samplesperframe / (float)_Frequency) * 75.0 >= InterestedFrames->CurrentFrame())                             {                                 if (_frames == 0 || InterestedFrames->NoAccomodation)                                 {                                     InterestedFrames->SetCurrentByteOffset(startoffset + offset - 4);                                     InterestedFrames->SetCurrentFrameOffset(_frames);                                 }                                 InterestedFrames->SetCurrentByteEndOffset(startoffset + offset - 4);                                 InterestedFrames->Cur += 1;                             }                             else                             {                                 InterestedFrames->SetCurrentByteOffset(startoffset + offset - 4);                                 InterestedFrames->SetCurrentFrameOffset(_frames);                             }                         }*/if (_isVBR != true) {  				if (TotalBR == 0) {  					FirstBR = BR;  				} else if (BR != FirstBR) {  					_isVBR = true;  				}  			}  			TotalBR += BR;  			FrameSize = (int)(BR * _frameSizeConst + Padding * _paddingSizeConst);  			offset += FrameSize - 4;  			frameCount++;  		}  	}  	// end while  	if (frameCount == 0) {  		throw new InvalidDataException (String.Format ("No frames found in {0}"' _fileName));  	}  	_frames = frameCount;  	if (_isVBR == null) {  		_bitrate = FirstBR;  		_isVBR = false;  	} else {  		_bitrate = TotalBR / _frames;  	}  	if (_bitrate == 0) {  		throw new InvalidDataException (String.Format ("Error determining bitrate: {0}"' _fileName));  	}  	_totalSeconds = (audioLength / 125.0m) / _bitrate;  } catch (Exception ex) {  	throw new Exception (String.Format ("Error calculating bitrate; {0}"' step)' ex);  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,CalculateBitrate,The following statement contains a magic number: try {  	int BR' Padding;  	int FrameSize;  	int TotalBR = 0;  	int FrameOffset = 0;  	//Int64 TagOffset = 0;  	bool bTrusting = true;  	bool ignoreall = false;  	Byte[] FH = new Byte[4];  	bool mPerfect = true;  	stream.Position = _headerOffset;  	//                if (_headerOffset > 0)  	//                {  	//                    TagOffset = _headerOffset;  	//                }  	int offset = 0;  	int frameCount = 0;  	int FirstBR = 0;  	int audioDataSize = (int)(stream.Length - _headerOffset);  	Byte[] audioData = new Byte[audioDataSize];  	//Int64 startoffset = stream.Position;  	int BufLen = stream.Read (audioData' 0' audioDataSize);  	while (offset < BufLen - 16 && !ignoreall) {  		bool reservedlayer = false;  		// Find FrameSync  		if (FindFrameSync (FH' audioData' BufLen' ref FrameOffset' ref offset' ref mPerfect' ref ignoreall' ref bTrusting' ref reservedlayer)) {  			FrameOffset = 0;  			int bitrateIndex = FH [2] >> 4;  			if (bitrateIndex <= 0 || bitrateIndex >= 15) {  				offset -= 3;  				continue;  			}  			Padding = (FH [2] >> 1) & 0x01;  			BR = GetBitrate (_mpegVersion' _mpegLayer' bitrateIndex);  			if (BR == 0 || BR % 8 != 0) {  				offset -= 3;  				continue;  			}  			//step = "last good frame @ " + String(startoffset + offset - 4) + "' frame " +  			//       String(_frames + 1);  			// todo: put back later  			/*if (InterestedFrames != NULL)                         {                             if (((_frames + 1) * _samplesperframe / (float)_Frequency) * 75.0 >= InterestedFrames->CurrentFrame())                             {                                 if (_frames == 0 || InterestedFrames->NoAccomodation)                                 {                                     InterestedFrames->SetCurrentByteOffset(startoffset + offset - 4);                                     InterestedFrames->SetCurrentFrameOffset(_frames);                                 }                                 InterestedFrames->SetCurrentByteEndOffset(startoffset + offset - 4);                                 InterestedFrames->Cur += 1;                             }                             else                             {                                 InterestedFrames->SetCurrentByteOffset(startoffset + offset - 4);                                 InterestedFrames->SetCurrentFrameOffset(_frames);                             }                         }*/if (_isVBR != true) {  				if (TotalBR == 0) {  					FirstBR = BR;  				} else if (BR != FirstBR) {  					_isVBR = true;  				}  			}  			TotalBR += BR;  			FrameSize = (int)(BR * _frameSizeConst + Padding * _paddingSizeConst);  			offset += FrameSize - 4;  			frameCount++;  		}  	}  	// end while  	if (frameCount == 0) {  		throw new InvalidDataException (String.Format ("No frames found in {0}"' _fileName));  	}  	_frames = frameCount;  	if (_isVBR == null) {  		_bitrate = FirstBR;  		_isVBR = false;  	} else {  		_bitrate = TotalBR / _frames;  	}  	if (_bitrate == 0) {  		throw new InvalidDataException (String.Format ("Error determining bitrate: {0}"' _fileName));  	}  	_totalSeconds = (audioLength / 125.0m) / _bitrate;  } catch (Exception ex) {  	throw new Exception (String.Format ("Error calculating bitrate; {0}"' step)' ex);  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,CalculateBitrate,The following statement contains a magic number: try {  	int BR' Padding;  	int FrameSize;  	int TotalBR = 0;  	int FrameOffset = 0;  	//Int64 TagOffset = 0;  	bool bTrusting = true;  	bool ignoreall = false;  	Byte[] FH = new Byte[4];  	bool mPerfect = true;  	stream.Position = _headerOffset;  	//                if (_headerOffset > 0)  	//                {  	//                    TagOffset = _headerOffset;  	//                }  	int offset = 0;  	int frameCount = 0;  	int FirstBR = 0;  	int audioDataSize = (int)(stream.Length - _headerOffset);  	Byte[] audioData = new Byte[audioDataSize];  	//Int64 startoffset = stream.Position;  	int BufLen = stream.Read (audioData' 0' audioDataSize);  	while (offset < BufLen - 16 && !ignoreall) {  		bool reservedlayer = false;  		// Find FrameSync  		if (FindFrameSync (FH' audioData' BufLen' ref FrameOffset' ref offset' ref mPerfect' ref ignoreall' ref bTrusting' ref reservedlayer)) {  			FrameOffset = 0;  			int bitrateIndex = FH [2] >> 4;  			if (bitrateIndex <= 0 || bitrateIndex >= 15) {  				offset -= 3;  				continue;  			}  			Padding = (FH [2] >> 1) & 0x01;  			BR = GetBitrate (_mpegVersion' _mpegLayer' bitrateIndex);  			if (BR == 0 || BR % 8 != 0) {  				offset -= 3;  				continue;  			}  			//step = "last good frame @ " + String(startoffset + offset - 4) + "' frame " +  			//       String(_frames + 1);  			// todo: put back later  			/*if (InterestedFrames != NULL)                         {                             if (((_frames + 1) * _samplesperframe / (float)_Frequency) * 75.0 >= InterestedFrames->CurrentFrame())                             {                                 if (_frames == 0 || InterestedFrames->NoAccomodation)                                 {                                     InterestedFrames->SetCurrentByteOffset(startoffset + offset - 4);                                     InterestedFrames->SetCurrentFrameOffset(_frames);                                 }                                 InterestedFrames->SetCurrentByteEndOffset(startoffset + offset - 4);                                 InterestedFrames->Cur += 1;                             }                             else                             {                                 InterestedFrames->SetCurrentByteOffset(startoffset + offset - 4);                                 InterestedFrames->SetCurrentFrameOffset(_frames);                             }                         }*/if (_isVBR != true) {  				if (TotalBR == 0) {  					FirstBR = BR;  				} else if (BR != FirstBR) {  					_isVBR = true;  				}  			}  			TotalBR += BR;  			FrameSize = (int)(BR * _frameSizeConst + Padding * _paddingSizeConst);  			offset += FrameSize - 4;  			frameCount++;  		}  	}  	// end while  	if (frameCount == 0) {  		throw new InvalidDataException (String.Format ("No frames found in {0}"' _fileName));  	}  	_frames = frameCount;  	if (_isVBR == null) {  		_bitrate = FirstBR;  		_isVBR = false;  	} else {  		_bitrate = TotalBR / _frames;  	}  	if (_bitrate == 0) {  		throw new InvalidDataException (String.Format ("Error determining bitrate: {0}"' _fileName));  	}  	_totalSeconds = (audioLength / 125.0m) / _bitrate;  } catch (Exception ex) {  	throw new Exception (String.Format ("Error calculating bitrate; {0}"' step)' ex);  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,CalculateBitrate,The following statement contains a magic number: try {  	int BR' Padding;  	int FrameSize;  	int TotalBR = 0;  	int FrameOffset = 0;  	//Int64 TagOffset = 0;  	bool bTrusting = true;  	bool ignoreall = false;  	Byte[] FH = new Byte[4];  	bool mPerfect = true;  	stream.Position = _headerOffset;  	//                if (_headerOffset > 0)  	//                {  	//                    TagOffset = _headerOffset;  	//                }  	int offset = 0;  	int frameCount = 0;  	int FirstBR = 0;  	int audioDataSize = (int)(stream.Length - _headerOffset);  	Byte[] audioData = new Byte[audioDataSize];  	//Int64 startoffset = stream.Position;  	int BufLen = stream.Read (audioData' 0' audioDataSize);  	while (offset < BufLen - 16 && !ignoreall) {  		bool reservedlayer = false;  		// Find FrameSync  		if (FindFrameSync (FH' audioData' BufLen' ref FrameOffset' ref offset' ref mPerfect' ref ignoreall' ref bTrusting' ref reservedlayer)) {  			FrameOffset = 0;  			int bitrateIndex = FH [2] >> 4;  			if (bitrateIndex <= 0 || bitrateIndex >= 15) {  				offset -= 3;  				continue;  			}  			Padding = (FH [2] >> 1) & 0x01;  			BR = GetBitrate (_mpegVersion' _mpegLayer' bitrateIndex);  			if (BR == 0 || BR % 8 != 0) {  				offset -= 3;  				continue;  			}  			//step = "last good frame @ " + String(startoffset + offset - 4) + "' frame " +  			//       String(_frames + 1);  			// todo: put back later  			/*if (InterestedFrames != NULL)                         {                             if (((_frames + 1) * _samplesperframe / (float)_Frequency) * 75.0 >= InterestedFrames->CurrentFrame())                             {                                 if (_frames == 0 || InterestedFrames->NoAccomodation)                                 {                                     InterestedFrames->SetCurrentByteOffset(startoffset + offset - 4);                                     InterestedFrames->SetCurrentFrameOffset(_frames);                                 }                                 InterestedFrames->SetCurrentByteEndOffset(startoffset + offset - 4);                                 InterestedFrames->Cur += 1;                             }                             else                             {                                 InterestedFrames->SetCurrentByteOffset(startoffset + offset - 4);                                 InterestedFrames->SetCurrentFrameOffset(_frames);                             }                         }*/if (_isVBR != true) {  				if (TotalBR == 0) {  					FirstBR = BR;  				} else if (BR != FirstBR) {  					_isVBR = true;  				}  			}  			TotalBR += BR;  			FrameSize = (int)(BR * _frameSizeConst + Padding * _paddingSizeConst);  			offset += FrameSize - 4;  			frameCount++;  		}  	}  	// end while  	if (frameCount == 0) {  		throw new InvalidDataException (String.Format ("No frames found in {0}"' _fileName));  	}  	_frames = frameCount;  	if (_isVBR == null) {  		_bitrate = FirstBR;  		_isVBR = false;  	} else {  		_bitrate = TotalBR / _frames;  	}  	if (_bitrate == 0) {  		throw new InvalidDataException (String.Format ("Error determining bitrate: {0}"' _fileName));  	}  	_totalSeconds = (audioLength / 125.0m) / _bitrate;  } catch (Exception ex) {  	throw new Exception (String.Format ("Error calculating bitrate; {0}"' step)' ex);  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,CalculateBitrate,The following statement contains a magic number: while (offset < BufLen - 16 && !ignoreall) {  	bool reservedlayer = false;  	// Find FrameSync  	if (FindFrameSync (FH' audioData' BufLen' ref FrameOffset' ref offset' ref mPerfect' ref ignoreall' ref bTrusting' ref reservedlayer)) {  		FrameOffset = 0;  		int bitrateIndex = FH [2] >> 4;  		if (bitrateIndex <= 0 || bitrateIndex >= 15) {  			offset -= 3;  			continue;  		}  		Padding = (FH [2] >> 1) & 0x01;  		BR = GetBitrate (_mpegVersion' _mpegLayer' bitrateIndex);  		if (BR == 0 || BR % 8 != 0) {  			offset -= 3;  			continue;  		}  		//step = "last good frame @ " + String(startoffset + offset - 4) + "' frame " +  		//       String(_frames + 1);  		// todo: put back later  		/*if (InterestedFrames != NULL)                         {                             if (((_frames + 1) * _samplesperframe / (float)_Frequency) * 75.0 >= InterestedFrames->CurrentFrame())                             {                                 if (_frames == 0 || InterestedFrames->NoAccomodation)                                 {                                     InterestedFrames->SetCurrentByteOffset(startoffset + offset - 4);                                     InterestedFrames->SetCurrentFrameOffset(_frames);                                 }                                 InterestedFrames->SetCurrentByteEndOffset(startoffset + offset - 4);                                 InterestedFrames->Cur += 1;                             }                             else                             {                                 InterestedFrames->SetCurrentByteOffset(startoffset + offset - 4);                                 InterestedFrames->SetCurrentFrameOffset(_frames);                             }                         }*/if (_isVBR != true) {  			if (TotalBR == 0) {  				FirstBR = BR;  			} else if (BR != FirstBR) {  				_isVBR = true;  			}  		}  		TotalBR += BR;  		FrameSize = (int)(BR * _frameSizeConst + Padding * _paddingSizeConst);  		offset += FrameSize - 4;  		frameCount++;  	}  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,CalculateBitrate,The following statement contains a magic number: while (offset < BufLen - 16 && !ignoreall) {  	bool reservedlayer = false;  	// Find FrameSync  	if (FindFrameSync (FH' audioData' BufLen' ref FrameOffset' ref offset' ref mPerfect' ref ignoreall' ref bTrusting' ref reservedlayer)) {  		FrameOffset = 0;  		int bitrateIndex = FH [2] >> 4;  		if (bitrateIndex <= 0 || bitrateIndex >= 15) {  			offset -= 3;  			continue;  		}  		Padding = (FH [2] >> 1) & 0x01;  		BR = GetBitrate (_mpegVersion' _mpegLayer' bitrateIndex);  		if (BR == 0 || BR % 8 != 0) {  			offset -= 3;  			continue;  		}  		//step = "last good frame @ " + String(startoffset + offset - 4) + "' frame " +  		//       String(_frames + 1);  		// todo: put back later  		/*if (InterestedFrames != NULL)                         {                             if (((_frames + 1) * _samplesperframe / (float)_Frequency) * 75.0 >= InterestedFrames->CurrentFrame())                             {                                 if (_frames == 0 || InterestedFrames->NoAccomodation)                                 {                                     InterestedFrames->SetCurrentByteOffset(startoffset + offset - 4);                                     InterestedFrames->SetCurrentFrameOffset(_frames);                                 }                                 InterestedFrames->SetCurrentByteEndOffset(startoffset + offset - 4);                                 InterestedFrames->Cur += 1;                             }                             else                             {                                 InterestedFrames->SetCurrentByteOffset(startoffset + offset - 4);                                 InterestedFrames->SetCurrentFrameOffset(_frames);                             }                         }*/if (_isVBR != true) {  			if (TotalBR == 0) {  				FirstBR = BR;  			} else if (BR != FirstBR) {  				_isVBR = true;  			}  		}  		TotalBR += BR;  		FrameSize = (int)(BR * _frameSizeConst + Padding * _paddingSizeConst);  		offset += FrameSize - 4;  		frameCount++;  	}  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,CalculateBitrate,The following statement contains a magic number: while (offset < BufLen - 16 && !ignoreall) {  	bool reservedlayer = false;  	// Find FrameSync  	if (FindFrameSync (FH' audioData' BufLen' ref FrameOffset' ref offset' ref mPerfect' ref ignoreall' ref bTrusting' ref reservedlayer)) {  		FrameOffset = 0;  		int bitrateIndex = FH [2] >> 4;  		if (bitrateIndex <= 0 || bitrateIndex >= 15) {  			offset -= 3;  			continue;  		}  		Padding = (FH [2] >> 1) & 0x01;  		BR = GetBitrate (_mpegVersion' _mpegLayer' bitrateIndex);  		if (BR == 0 || BR % 8 != 0) {  			offset -= 3;  			continue;  		}  		//step = "last good frame @ " + String(startoffset + offset - 4) + "' frame " +  		//       String(_frames + 1);  		// todo: put back later  		/*if (InterestedFrames != NULL)                         {                             if (((_frames + 1) * _samplesperframe / (float)_Frequency) * 75.0 >= InterestedFrames->CurrentFrame())                             {                                 if (_frames == 0 || InterestedFrames->NoAccomodation)                                 {                                     InterestedFrames->SetCurrentByteOffset(startoffset + offset - 4);                                     InterestedFrames->SetCurrentFrameOffset(_frames);                                 }                                 InterestedFrames->SetCurrentByteEndOffset(startoffset + offset - 4);                                 InterestedFrames->Cur += 1;                             }                             else                             {                                 InterestedFrames->SetCurrentByteOffset(startoffset + offset - 4);                                 InterestedFrames->SetCurrentFrameOffset(_frames);                             }                         }*/if (_isVBR != true) {  			if (TotalBR == 0) {  				FirstBR = BR;  			} else if (BR != FirstBR) {  				_isVBR = true;  			}  		}  		TotalBR += BR;  		FrameSize = (int)(BR * _frameSizeConst + Padding * _paddingSizeConst);  		offset += FrameSize - 4;  		frameCount++;  	}  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,CalculateBitrate,The following statement contains a magic number: while (offset < BufLen - 16 && !ignoreall) {  	bool reservedlayer = false;  	// Find FrameSync  	if (FindFrameSync (FH' audioData' BufLen' ref FrameOffset' ref offset' ref mPerfect' ref ignoreall' ref bTrusting' ref reservedlayer)) {  		FrameOffset = 0;  		int bitrateIndex = FH [2] >> 4;  		if (bitrateIndex <= 0 || bitrateIndex >= 15) {  			offset -= 3;  			continue;  		}  		Padding = (FH [2] >> 1) & 0x01;  		BR = GetBitrate (_mpegVersion' _mpegLayer' bitrateIndex);  		if (BR == 0 || BR % 8 != 0) {  			offset -= 3;  			continue;  		}  		//step = "last good frame @ " + String(startoffset + offset - 4) + "' frame " +  		//       String(_frames + 1);  		// todo: put back later  		/*if (InterestedFrames != NULL)                         {                             if (((_frames + 1) * _samplesperframe / (float)_Frequency) * 75.0 >= InterestedFrames->CurrentFrame())                             {                                 if (_frames == 0 || InterestedFrames->NoAccomodation)                                 {                                     InterestedFrames->SetCurrentByteOffset(startoffset + offset - 4);                                     InterestedFrames->SetCurrentFrameOffset(_frames);                                 }                                 InterestedFrames->SetCurrentByteEndOffset(startoffset + offset - 4);                                 InterestedFrames->Cur += 1;                             }                             else                             {                                 InterestedFrames->SetCurrentByteOffset(startoffset + offset - 4);                                 InterestedFrames->SetCurrentFrameOffset(_frames);                             }                         }*/if (_isVBR != true) {  			if (TotalBR == 0) {  				FirstBR = BR;  			} else if (BR != FirstBR) {  				_isVBR = true;  			}  		}  		TotalBR += BR;  		FrameSize = (int)(BR * _frameSizeConst + Padding * _paddingSizeConst);  		offset += FrameSize - 4;  		frameCount++;  	}  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,CalculateBitrate,The following statement contains a magic number: while (offset < BufLen - 16 && !ignoreall) {  	bool reservedlayer = false;  	// Find FrameSync  	if (FindFrameSync (FH' audioData' BufLen' ref FrameOffset' ref offset' ref mPerfect' ref ignoreall' ref bTrusting' ref reservedlayer)) {  		FrameOffset = 0;  		int bitrateIndex = FH [2] >> 4;  		if (bitrateIndex <= 0 || bitrateIndex >= 15) {  			offset -= 3;  			continue;  		}  		Padding = (FH [2] >> 1) & 0x01;  		BR = GetBitrate (_mpegVersion' _mpegLayer' bitrateIndex);  		if (BR == 0 || BR % 8 != 0) {  			offset -= 3;  			continue;  		}  		//step = "last good frame @ " + String(startoffset + offset - 4) + "' frame " +  		//       String(_frames + 1);  		// todo: put back later  		/*if (InterestedFrames != NULL)                         {                             if (((_frames + 1) * _samplesperframe / (float)_Frequency) * 75.0 >= InterestedFrames->CurrentFrame())                             {                                 if (_frames == 0 || InterestedFrames->NoAccomodation)                                 {                                     InterestedFrames->SetCurrentByteOffset(startoffset + offset - 4);                                     InterestedFrames->SetCurrentFrameOffset(_frames);                                 }                                 InterestedFrames->SetCurrentByteEndOffset(startoffset + offset - 4);                                 InterestedFrames->Cur += 1;                             }                             else                             {                                 InterestedFrames->SetCurrentByteOffset(startoffset + offset - 4);                                 InterestedFrames->SetCurrentFrameOffset(_frames);                             }                         }*/if (_isVBR != true) {  			if (TotalBR == 0) {  				FirstBR = BR;  			} else if (BR != FirstBR) {  				_isVBR = true;  			}  		}  		TotalBR += BR;  		FrameSize = (int)(BR * _frameSizeConst + Padding * _paddingSizeConst);  		offset += FrameSize - 4;  		frameCount++;  	}  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,CalculateBitrate,The following statement contains a magic number: while (offset < BufLen - 16 && !ignoreall) {  	bool reservedlayer = false;  	// Find FrameSync  	if (FindFrameSync (FH' audioData' BufLen' ref FrameOffset' ref offset' ref mPerfect' ref ignoreall' ref bTrusting' ref reservedlayer)) {  		FrameOffset = 0;  		int bitrateIndex = FH [2] >> 4;  		if (bitrateIndex <= 0 || bitrateIndex >= 15) {  			offset -= 3;  			continue;  		}  		Padding = (FH [2] >> 1) & 0x01;  		BR = GetBitrate (_mpegVersion' _mpegLayer' bitrateIndex);  		if (BR == 0 || BR % 8 != 0) {  			offset -= 3;  			continue;  		}  		//step = "last good frame @ " + String(startoffset + offset - 4) + "' frame " +  		//       String(_frames + 1);  		// todo: put back later  		/*if (InterestedFrames != NULL)                         {                             if (((_frames + 1) * _samplesperframe / (float)_Frequency) * 75.0 >= InterestedFrames->CurrentFrame())                             {                                 if (_frames == 0 || InterestedFrames->NoAccomodation)                                 {                                     InterestedFrames->SetCurrentByteOffset(startoffset + offset - 4);                                     InterestedFrames->SetCurrentFrameOffset(_frames);                                 }                                 InterestedFrames->SetCurrentByteEndOffset(startoffset + offset - 4);                                 InterestedFrames->Cur += 1;                             }                             else                             {                                 InterestedFrames->SetCurrentByteOffset(startoffset + offset - 4);                                 InterestedFrames->SetCurrentFrameOffset(_frames);                             }                         }*/if (_isVBR != true) {  			if (TotalBR == 0) {  				FirstBR = BR;  			} else if (BR != FirstBR) {  				_isVBR = true;  			}  		}  		TotalBR += BR;  		FrameSize = (int)(BR * _frameSizeConst + Padding * _paddingSizeConst);  		offset += FrameSize - 4;  		frameCount++;  	}  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,CalculateBitrate,The following statement contains a magic number: while (offset < BufLen - 16 && !ignoreall) {  	bool reservedlayer = false;  	// Find FrameSync  	if (FindFrameSync (FH' audioData' BufLen' ref FrameOffset' ref offset' ref mPerfect' ref ignoreall' ref bTrusting' ref reservedlayer)) {  		FrameOffset = 0;  		int bitrateIndex = FH [2] >> 4;  		if (bitrateIndex <= 0 || bitrateIndex >= 15) {  			offset -= 3;  			continue;  		}  		Padding = (FH [2] >> 1) & 0x01;  		BR = GetBitrate (_mpegVersion' _mpegLayer' bitrateIndex);  		if (BR == 0 || BR % 8 != 0) {  			offset -= 3;  			continue;  		}  		//step = "last good frame @ " + String(startoffset + offset - 4) + "' frame " +  		//       String(_frames + 1);  		// todo: put back later  		/*if (InterestedFrames != NULL)                         {                             if (((_frames + 1) * _samplesperframe / (float)_Frequency) * 75.0 >= InterestedFrames->CurrentFrame())                             {                                 if (_frames == 0 || InterestedFrames->NoAccomodation)                                 {                                     InterestedFrames->SetCurrentByteOffset(startoffset + offset - 4);                                     InterestedFrames->SetCurrentFrameOffset(_frames);                                 }                                 InterestedFrames->SetCurrentByteEndOffset(startoffset + offset - 4);                                 InterestedFrames->Cur += 1;                             }                             else                             {                                 InterestedFrames->SetCurrentByteOffset(startoffset + offset - 4);                                 InterestedFrames->SetCurrentFrameOffset(_frames);                             }                         }*/if (_isVBR != true) {  			if (TotalBR == 0) {  				FirstBR = BR;  			} else if (BR != FirstBR) {  				_isVBR = true;  			}  		}  		TotalBR += BR;  		FrameSize = (int)(BR * _frameSizeConst + Padding * _paddingSizeConst);  		offset += FrameSize - 4;  		frameCount++;  	}  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,CalculateBitrate,The following statement contains a magic number: while (offset < BufLen - 16 && !ignoreall) {  	bool reservedlayer = false;  	// Find FrameSync  	if (FindFrameSync (FH' audioData' BufLen' ref FrameOffset' ref offset' ref mPerfect' ref ignoreall' ref bTrusting' ref reservedlayer)) {  		FrameOffset = 0;  		int bitrateIndex = FH [2] >> 4;  		if (bitrateIndex <= 0 || bitrateIndex >= 15) {  			offset -= 3;  			continue;  		}  		Padding = (FH [2] >> 1) & 0x01;  		BR = GetBitrate (_mpegVersion' _mpegLayer' bitrateIndex);  		if (BR == 0 || BR % 8 != 0) {  			offset -= 3;  			continue;  		}  		//step = "last good frame @ " + String(startoffset + offset - 4) + "' frame " +  		//       String(_frames + 1);  		// todo: put back later  		/*if (InterestedFrames != NULL)                         {                             if (((_frames + 1) * _samplesperframe / (float)_Frequency) * 75.0 >= InterestedFrames->CurrentFrame())                             {                                 if (_frames == 0 || InterestedFrames->NoAccomodation)                                 {                                     InterestedFrames->SetCurrentByteOffset(startoffset + offset - 4);                                     InterestedFrames->SetCurrentFrameOffset(_frames);                                 }                                 InterestedFrames->SetCurrentByteEndOffset(startoffset + offset - 4);                                 InterestedFrames->Cur += 1;                             }                             else                             {                                 InterestedFrames->SetCurrentByteOffset(startoffset + offset - 4);                                 InterestedFrames->SetCurrentFrameOffset(_frames);                             }                         }*/if (_isVBR != true) {  			if (TotalBR == 0) {  				FirstBR = BR;  			} else if (BR != FirstBR) {  				_isVBR = true;  			}  		}  		TotalBR += BR;  		FrameSize = (int)(BR * _frameSizeConst + Padding * _paddingSizeConst);  		offset += FrameSize - 4;  		frameCount++;  	}  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,CalculateBitrate,The following statement contains a magic number: while (offset < BufLen - 16 && !ignoreall) {  	bool reservedlayer = false;  	// Find FrameSync  	if (FindFrameSync (FH' audioData' BufLen' ref FrameOffset' ref offset' ref mPerfect' ref ignoreall' ref bTrusting' ref reservedlayer)) {  		FrameOffset = 0;  		int bitrateIndex = FH [2] >> 4;  		if (bitrateIndex <= 0 || bitrateIndex >= 15) {  			offset -= 3;  			continue;  		}  		Padding = (FH [2] >> 1) & 0x01;  		BR = GetBitrate (_mpegVersion' _mpegLayer' bitrateIndex);  		if (BR == 0 || BR % 8 != 0) {  			offset -= 3;  			continue;  		}  		//step = "last good frame @ " + String(startoffset + offset - 4) + "' frame " +  		//       String(_frames + 1);  		// todo: put back later  		/*if (InterestedFrames != NULL)                         {                             if (((_frames + 1) * _samplesperframe / (float)_Frequency) * 75.0 >= InterestedFrames->CurrentFrame())                             {                                 if (_frames == 0 || InterestedFrames->NoAccomodation)                                 {                                     InterestedFrames->SetCurrentByteOffset(startoffset + offset - 4);                                     InterestedFrames->SetCurrentFrameOffset(_frames);                                 }                                 InterestedFrames->SetCurrentByteEndOffset(startoffset + offset - 4);                                 InterestedFrames->Cur += 1;                             }                             else                             {                                 InterestedFrames->SetCurrentByteOffset(startoffset + offset - 4);                                 InterestedFrames->SetCurrentFrameOffset(_frames);                             }                         }*/if (_isVBR != true) {  			if (TotalBR == 0) {  				FirstBR = BR;  			} else if (BR != FirstBR) {  				_isVBR = true;  			}  		}  		TotalBR += BR;  		FrameSize = (int)(BR * _frameSizeConst + Padding * _paddingSizeConst);  		offset += FrameSize - 4;  		frameCount++;  	}  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,CalculateBitrate,The following statement contains a magic number: if (FindFrameSync (FH' audioData' BufLen' ref FrameOffset' ref offset' ref mPerfect' ref ignoreall' ref bTrusting' ref reservedlayer)) {  	FrameOffset = 0;  	int bitrateIndex = FH [2] >> 4;  	if (bitrateIndex <= 0 || bitrateIndex >= 15) {  		offset -= 3;  		continue;  	}  	Padding = (FH [2] >> 1) & 0x01;  	BR = GetBitrate (_mpegVersion' _mpegLayer' bitrateIndex);  	if (BR == 0 || BR % 8 != 0) {  		offset -= 3;  		continue;  	}  	//step = "last good frame @ " + String(startoffset + offset - 4) + "' frame " +  	//       String(_frames + 1);  	// todo: put back later  	/*if (InterestedFrames != NULL)                         {                             if (((_frames + 1) * _samplesperframe / (float)_Frequency) * 75.0 >= InterestedFrames->CurrentFrame())                             {                                 if (_frames == 0 || InterestedFrames->NoAccomodation)                                 {                                     InterestedFrames->SetCurrentByteOffset(startoffset + offset - 4);                                     InterestedFrames->SetCurrentFrameOffset(_frames);                                 }                                 InterestedFrames->SetCurrentByteEndOffset(startoffset + offset - 4);                                 InterestedFrames->Cur += 1;                             }                             else                             {                                 InterestedFrames->SetCurrentByteOffset(startoffset + offset - 4);                                 InterestedFrames->SetCurrentFrameOffset(_frames);                             }                         }*/if (_isVBR != true) {  		if (TotalBR == 0) {  			FirstBR = BR;  		} else if (BR != FirstBR) {  			_isVBR = true;  		}  	}  	TotalBR += BR;  	FrameSize = (int)(BR * _frameSizeConst + Padding * _paddingSizeConst);  	offset += FrameSize - 4;  	frameCount++;  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,CalculateBitrate,The following statement contains a magic number: if (FindFrameSync (FH' audioData' BufLen' ref FrameOffset' ref offset' ref mPerfect' ref ignoreall' ref bTrusting' ref reservedlayer)) {  	FrameOffset = 0;  	int bitrateIndex = FH [2] >> 4;  	if (bitrateIndex <= 0 || bitrateIndex >= 15) {  		offset -= 3;  		continue;  	}  	Padding = (FH [2] >> 1) & 0x01;  	BR = GetBitrate (_mpegVersion' _mpegLayer' bitrateIndex);  	if (BR == 0 || BR % 8 != 0) {  		offset -= 3;  		continue;  	}  	//step = "last good frame @ " + String(startoffset + offset - 4) + "' frame " +  	//       String(_frames + 1);  	// todo: put back later  	/*if (InterestedFrames != NULL)                         {                             if (((_frames + 1) * _samplesperframe / (float)_Frequency) * 75.0 >= InterestedFrames->CurrentFrame())                             {                                 if (_frames == 0 || InterestedFrames->NoAccomodation)                                 {                                     InterestedFrames->SetCurrentByteOffset(startoffset + offset - 4);                                     InterestedFrames->SetCurrentFrameOffset(_frames);                                 }                                 InterestedFrames->SetCurrentByteEndOffset(startoffset + offset - 4);                                 InterestedFrames->Cur += 1;                             }                             else                             {                                 InterestedFrames->SetCurrentByteOffset(startoffset + offset - 4);                                 InterestedFrames->SetCurrentFrameOffset(_frames);                             }                         }*/if (_isVBR != true) {  		if (TotalBR == 0) {  			FirstBR = BR;  		} else if (BR != FirstBR) {  			_isVBR = true;  		}  	}  	TotalBR += BR;  	FrameSize = (int)(BR * _frameSizeConst + Padding * _paddingSizeConst);  	offset += FrameSize - 4;  	frameCount++;  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,CalculateBitrate,The following statement contains a magic number: if (FindFrameSync (FH' audioData' BufLen' ref FrameOffset' ref offset' ref mPerfect' ref ignoreall' ref bTrusting' ref reservedlayer)) {  	FrameOffset = 0;  	int bitrateIndex = FH [2] >> 4;  	if (bitrateIndex <= 0 || bitrateIndex >= 15) {  		offset -= 3;  		continue;  	}  	Padding = (FH [2] >> 1) & 0x01;  	BR = GetBitrate (_mpegVersion' _mpegLayer' bitrateIndex);  	if (BR == 0 || BR % 8 != 0) {  		offset -= 3;  		continue;  	}  	//step = "last good frame @ " + String(startoffset + offset - 4) + "' frame " +  	//       String(_frames + 1);  	// todo: put back later  	/*if (InterestedFrames != NULL)                         {                             if (((_frames + 1) * _samplesperframe / (float)_Frequency) * 75.0 >= InterestedFrames->CurrentFrame())                             {                                 if (_frames == 0 || InterestedFrames->NoAccomodation)                                 {                                     InterestedFrames->SetCurrentByteOffset(startoffset + offset - 4);                                     InterestedFrames->SetCurrentFrameOffset(_frames);                                 }                                 InterestedFrames->SetCurrentByteEndOffset(startoffset + offset - 4);                                 InterestedFrames->Cur += 1;                             }                             else                             {                                 InterestedFrames->SetCurrentByteOffset(startoffset + offset - 4);                                 InterestedFrames->SetCurrentFrameOffset(_frames);                             }                         }*/if (_isVBR != true) {  		if (TotalBR == 0) {  			FirstBR = BR;  		} else if (BR != FirstBR) {  			_isVBR = true;  		}  	}  	TotalBR += BR;  	FrameSize = (int)(BR * _frameSizeConst + Padding * _paddingSizeConst);  	offset += FrameSize - 4;  	frameCount++;  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,CalculateBitrate,The following statement contains a magic number: if (FindFrameSync (FH' audioData' BufLen' ref FrameOffset' ref offset' ref mPerfect' ref ignoreall' ref bTrusting' ref reservedlayer)) {  	FrameOffset = 0;  	int bitrateIndex = FH [2] >> 4;  	if (bitrateIndex <= 0 || bitrateIndex >= 15) {  		offset -= 3;  		continue;  	}  	Padding = (FH [2] >> 1) & 0x01;  	BR = GetBitrate (_mpegVersion' _mpegLayer' bitrateIndex);  	if (BR == 0 || BR % 8 != 0) {  		offset -= 3;  		continue;  	}  	//step = "last good frame @ " + String(startoffset + offset - 4) + "' frame " +  	//       String(_frames + 1);  	// todo: put back later  	/*if (InterestedFrames != NULL)                         {                             if (((_frames + 1) * _samplesperframe / (float)_Frequency) * 75.0 >= InterestedFrames->CurrentFrame())                             {                                 if (_frames == 0 || InterestedFrames->NoAccomodation)                                 {                                     InterestedFrames->SetCurrentByteOffset(startoffset + offset - 4);                                     InterestedFrames->SetCurrentFrameOffset(_frames);                                 }                                 InterestedFrames->SetCurrentByteEndOffset(startoffset + offset - 4);                                 InterestedFrames->Cur += 1;                             }                             else                             {                                 InterestedFrames->SetCurrentByteOffset(startoffset + offset - 4);                                 InterestedFrames->SetCurrentFrameOffset(_frames);                             }                         }*/if (_isVBR != true) {  		if (TotalBR == 0) {  			FirstBR = BR;  		} else if (BR != FirstBR) {  			_isVBR = true;  		}  	}  	TotalBR += BR;  	FrameSize = (int)(BR * _frameSizeConst + Padding * _paddingSizeConst);  	offset += FrameSize - 4;  	frameCount++;  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,CalculateBitrate,The following statement contains a magic number: if (FindFrameSync (FH' audioData' BufLen' ref FrameOffset' ref offset' ref mPerfect' ref ignoreall' ref bTrusting' ref reservedlayer)) {  	FrameOffset = 0;  	int bitrateIndex = FH [2] >> 4;  	if (bitrateIndex <= 0 || bitrateIndex >= 15) {  		offset -= 3;  		continue;  	}  	Padding = (FH [2] >> 1) & 0x01;  	BR = GetBitrate (_mpegVersion' _mpegLayer' bitrateIndex);  	if (BR == 0 || BR % 8 != 0) {  		offset -= 3;  		continue;  	}  	//step = "last good frame @ " + String(startoffset + offset - 4) + "' frame " +  	//       String(_frames + 1);  	// todo: put back later  	/*if (InterestedFrames != NULL)                         {                             if (((_frames + 1) * _samplesperframe / (float)_Frequency) * 75.0 >= InterestedFrames->CurrentFrame())                             {                                 if (_frames == 0 || InterestedFrames->NoAccomodation)                                 {                                     InterestedFrames->SetCurrentByteOffset(startoffset + offset - 4);                                     InterestedFrames->SetCurrentFrameOffset(_frames);                                 }                                 InterestedFrames->SetCurrentByteEndOffset(startoffset + offset - 4);                                 InterestedFrames->Cur += 1;                             }                             else                             {                                 InterestedFrames->SetCurrentByteOffset(startoffset + offset - 4);                                 InterestedFrames->SetCurrentFrameOffset(_frames);                             }                         }*/if (_isVBR != true) {  		if (TotalBR == 0) {  			FirstBR = BR;  		} else if (BR != FirstBR) {  			_isVBR = true;  		}  	}  	TotalBR += BR;  	FrameSize = (int)(BR * _frameSizeConst + Padding * _paddingSizeConst);  	offset += FrameSize - 4;  	frameCount++;  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,CalculateBitrate,The following statement contains a magic number: if (FindFrameSync (FH' audioData' BufLen' ref FrameOffset' ref offset' ref mPerfect' ref ignoreall' ref bTrusting' ref reservedlayer)) {  	FrameOffset = 0;  	int bitrateIndex = FH [2] >> 4;  	if (bitrateIndex <= 0 || bitrateIndex >= 15) {  		offset -= 3;  		continue;  	}  	Padding = (FH [2] >> 1) & 0x01;  	BR = GetBitrate (_mpegVersion' _mpegLayer' bitrateIndex);  	if (BR == 0 || BR % 8 != 0) {  		offset -= 3;  		continue;  	}  	//step = "last good frame @ " + String(startoffset + offset - 4) + "' frame " +  	//       String(_frames + 1);  	// todo: put back later  	/*if (InterestedFrames != NULL)                         {                             if (((_frames + 1) * _samplesperframe / (float)_Frequency) * 75.0 >= InterestedFrames->CurrentFrame())                             {                                 if (_frames == 0 || InterestedFrames->NoAccomodation)                                 {                                     InterestedFrames->SetCurrentByteOffset(startoffset + offset - 4);                                     InterestedFrames->SetCurrentFrameOffset(_frames);                                 }                                 InterestedFrames->SetCurrentByteEndOffset(startoffset + offset - 4);                                 InterestedFrames->Cur += 1;                             }                             else                             {                                 InterestedFrames->SetCurrentByteOffset(startoffset + offset - 4);                                 InterestedFrames->SetCurrentFrameOffset(_frames);                             }                         }*/if (_isVBR != true) {  		if (TotalBR == 0) {  			FirstBR = BR;  		} else if (BR != FirstBR) {  			_isVBR = true;  		}  	}  	TotalBR += BR;  	FrameSize = (int)(BR * _frameSizeConst + Padding * _paddingSizeConst);  	offset += FrameSize - 4;  	frameCount++;  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,CalculateBitrate,The following statement contains a magic number: if (FindFrameSync (FH' audioData' BufLen' ref FrameOffset' ref offset' ref mPerfect' ref ignoreall' ref bTrusting' ref reservedlayer)) {  	FrameOffset = 0;  	int bitrateIndex = FH [2] >> 4;  	if (bitrateIndex <= 0 || bitrateIndex >= 15) {  		offset -= 3;  		continue;  	}  	Padding = (FH [2] >> 1) & 0x01;  	BR = GetBitrate (_mpegVersion' _mpegLayer' bitrateIndex);  	if (BR == 0 || BR % 8 != 0) {  		offset -= 3;  		continue;  	}  	//step = "last good frame @ " + String(startoffset + offset - 4) + "' frame " +  	//       String(_frames + 1);  	// todo: put back later  	/*if (InterestedFrames != NULL)                         {                             if (((_frames + 1) * _samplesperframe / (float)_Frequency) * 75.0 >= InterestedFrames->CurrentFrame())                             {                                 if (_frames == 0 || InterestedFrames->NoAccomodation)                                 {                                     InterestedFrames->SetCurrentByteOffset(startoffset + offset - 4);                                     InterestedFrames->SetCurrentFrameOffset(_frames);                                 }                                 InterestedFrames->SetCurrentByteEndOffset(startoffset + offset - 4);                                 InterestedFrames->Cur += 1;                             }                             else                             {                                 InterestedFrames->SetCurrentByteOffset(startoffset + offset - 4);                                 InterestedFrames->SetCurrentFrameOffset(_frames);                             }                         }*/if (_isVBR != true) {  		if (TotalBR == 0) {  			FirstBR = BR;  		} else if (BR != FirstBR) {  			_isVBR = true;  		}  	}  	TotalBR += BR;  	FrameSize = (int)(BR * _frameSizeConst + Padding * _paddingSizeConst);  	offset += FrameSize - 4;  	frameCount++;  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,CalculateBitrate,The following statement contains a magic number: if (FindFrameSync (FH' audioData' BufLen' ref FrameOffset' ref offset' ref mPerfect' ref ignoreall' ref bTrusting' ref reservedlayer)) {  	FrameOffset = 0;  	int bitrateIndex = FH [2] >> 4;  	if (bitrateIndex <= 0 || bitrateIndex >= 15) {  		offset -= 3;  		continue;  	}  	Padding = (FH [2] >> 1) & 0x01;  	BR = GetBitrate (_mpegVersion' _mpegLayer' bitrateIndex);  	if (BR == 0 || BR % 8 != 0) {  		offset -= 3;  		continue;  	}  	//step = "last good frame @ " + String(startoffset + offset - 4) + "' frame " +  	//       String(_frames + 1);  	// todo: put back later  	/*if (InterestedFrames != NULL)                         {                             if (((_frames + 1) * _samplesperframe / (float)_Frequency) * 75.0 >= InterestedFrames->CurrentFrame())                             {                                 if (_frames == 0 || InterestedFrames->NoAccomodation)                                 {                                     InterestedFrames->SetCurrentByteOffset(startoffset + offset - 4);                                     InterestedFrames->SetCurrentFrameOffset(_frames);                                 }                                 InterestedFrames->SetCurrentByteEndOffset(startoffset + offset - 4);                                 InterestedFrames->Cur += 1;                             }                             else                             {                                 InterestedFrames->SetCurrentByteOffset(startoffset + offset - 4);                                 InterestedFrames->SetCurrentFrameOffset(_frames);                             }                         }*/if (_isVBR != true) {  		if (TotalBR == 0) {  			FirstBR = BR;  		} else if (BR != FirstBR) {  			_isVBR = true;  		}  	}  	TotalBR += BR;  	FrameSize = (int)(BR * _frameSizeConst + Padding * _paddingSizeConst);  	offset += FrameSize - 4;  	frameCount++;  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,CalculateBitrate,The following statement contains a magic number: if (bitrateIndex <= 0 || bitrateIndex >= 15) {  	offset -= 3;  	continue;  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,CalculateBitrate,The following statement contains a magic number: if (bitrateIndex <= 0 || bitrateIndex >= 15) {  	offset -= 3;  	continue;  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,CalculateBitrate,The following statement contains a magic number: offset -= 3;  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,CalculateBitrate,The following statement contains a magic number: Padding = (FH [2] >> 1) & 0x01;  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,CalculateBitrate,The following statement contains a magic number: if (BR == 0 || BR % 8 != 0) {  	offset -= 3;  	continue;  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,CalculateBitrate,The following statement contains a magic number: if (BR == 0 || BR % 8 != 0) {  	offset -= 3;  	continue;  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,CalculateBitrate,The following statement contains a magic number: offset -= 3;  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,CalculateBitrate,The following statement contains a magic number: offset += FrameSize - 4;  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,FindFrameSync,The following statement contains a magic number: while (true) {  	if (FrameOffset == 0) {  		if (offset >= BufLen - 8) {  			return false;  		}  		FH [0] = audioData [offset++];  		while (FH [0] != 0xFF && offset < BufLen) {  			// Leading 0's  			if (offset - 1 == 0 && FH [0] == 0) {  				mPerfect = false;  				do {  					FH [0] = audioData [offset++];  				} while (FH [0] == 0 && offset < BufLen);  				continue;  			}  			if (FH [0] == 'L' && audioData [offset] == 'Y' && audioData [offset + 1] == 'R') {  				// todo: don't want to return' just stop reading data  				ignoreall = true;  				return false;  			}  			if (FH [0] == 'T' && audioData [offset] == 'A' && audioData [offset + 1] == 'G') {  				// todo: don't want to return' just stop reading data  				ignoreall = true;  				return false;  			}  			if (FH [0] == 'A' && audioData [offset] == 'P' && audioData [offset + 1] == 'E') {  				// todo: don't want to return' just stop reading data  				ignoreall = true;  				return false;  			}  			// ignore cut off frames  			// todo: eh.. is this really important?  			/*if (BufLen < cuiReadBufSize)                         {                             if (BufLen - offset < TagContainer->Lyrics3ExistingOffset + 128)                             {                                 ignoreall = true;                                 mPerfect = false;                                 return;                             }                         }*/FH [0] = audioData [offset++];  			if (bTrusting == true) {  				mPerfect = false;  				if (!reservedlayer) {  					bTrusting = false;  				}  			}  		}  		if (offset == BufLen) {  			return false;  		}  		FrameOffset = 1;  	}  	// end if (FrameOffset == 0)  	// Get frame header  	int i;  	for (i = FrameOffset; i < 4 && offset != BufLen; i++) {  		FH [i] = audioData [offset++];  	}  	if (i != 4 && offset == BufLen) {  		FrameOffset = i;  		return false;  	}  	// No sync  	if ((FH [1] >> 5) != 0x07 || ((FH [1] >> 1) & 0x03) == 0)// 2/18/05 ignore reserved layer  	 {  		if (((FH [1] >> 1) & 0x03) == 0)  			reservedlayer = true;  		FrameOffset = 0;  		offset -= 3;  		mPerfect = false;  	} else if (FH [1] != fh1 || (FH [2] & 0x0D) != (fh2 & 0x0D)) {  		// sync doesn't match expected type  		//  		FrameOffset = 0;  		offset -= 3;  		mPerfect = false;  	} else {  		break;  	}  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,FindFrameSync,The following statement contains a magic number: while (true) {  	if (FrameOffset == 0) {  		if (offset >= BufLen - 8) {  			return false;  		}  		FH [0] = audioData [offset++];  		while (FH [0] != 0xFF && offset < BufLen) {  			// Leading 0's  			if (offset - 1 == 0 && FH [0] == 0) {  				mPerfect = false;  				do {  					FH [0] = audioData [offset++];  				} while (FH [0] == 0 && offset < BufLen);  				continue;  			}  			if (FH [0] == 'L' && audioData [offset] == 'Y' && audioData [offset + 1] == 'R') {  				// todo: don't want to return' just stop reading data  				ignoreall = true;  				return false;  			}  			if (FH [0] == 'T' && audioData [offset] == 'A' && audioData [offset + 1] == 'G') {  				// todo: don't want to return' just stop reading data  				ignoreall = true;  				return false;  			}  			if (FH [0] == 'A' && audioData [offset] == 'P' && audioData [offset + 1] == 'E') {  				// todo: don't want to return' just stop reading data  				ignoreall = true;  				return false;  			}  			// ignore cut off frames  			// todo: eh.. is this really important?  			/*if (BufLen < cuiReadBufSize)                         {                             if (BufLen - offset < TagContainer->Lyrics3ExistingOffset + 128)                             {                                 ignoreall = true;                                 mPerfect = false;                                 return;                             }                         }*/FH [0] = audioData [offset++];  			if (bTrusting == true) {  				mPerfect = false;  				if (!reservedlayer) {  					bTrusting = false;  				}  			}  		}  		if (offset == BufLen) {  			return false;  		}  		FrameOffset = 1;  	}  	// end if (FrameOffset == 0)  	// Get frame header  	int i;  	for (i = FrameOffset; i < 4 && offset != BufLen; i++) {  		FH [i] = audioData [offset++];  	}  	if (i != 4 && offset == BufLen) {  		FrameOffset = i;  		return false;  	}  	// No sync  	if ((FH [1] >> 5) != 0x07 || ((FH [1] >> 1) & 0x03) == 0)// 2/18/05 ignore reserved layer  	 {  		if (((FH [1] >> 1) & 0x03) == 0)  			reservedlayer = true;  		FrameOffset = 0;  		offset -= 3;  		mPerfect = false;  	} else if (FH [1] != fh1 || (FH [2] & 0x0D) != (fh2 & 0x0D)) {  		// sync doesn't match expected type  		//  		FrameOffset = 0;  		offset -= 3;  		mPerfect = false;  	} else {  		break;  	}  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,FindFrameSync,The following statement contains a magic number: while (true) {  	if (FrameOffset == 0) {  		if (offset >= BufLen - 8) {  			return false;  		}  		FH [0] = audioData [offset++];  		while (FH [0] != 0xFF && offset < BufLen) {  			// Leading 0's  			if (offset - 1 == 0 && FH [0] == 0) {  				mPerfect = false;  				do {  					FH [0] = audioData [offset++];  				} while (FH [0] == 0 && offset < BufLen);  				continue;  			}  			if (FH [0] == 'L' && audioData [offset] == 'Y' && audioData [offset + 1] == 'R') {  				// todo: don't want to return' just stop reading data  				ignoreall = true;  				return false;  			}  			if (FH [0] == 'T' && audioData [offset] == 'A' && audioData [offset + 1] == 'G') {  				// todo: don't want to return' just stop reading data  				ignoreall = true;  				return false;  			}  			if (FH [0] == 'A' && audioData [offset] == 'P' && audioData [offset + 1] == 'E') {  				// todo: don't want to return' just stop reading data  				ignoreall = true;  				return false;  			}  			// ignore cut off frames  			// todo: eh.. is this really important?  			/*if (BufLen < cuiReadBufSize)                         {                             if (BufLen - offset < TagContainer->Lyrics3ExistingOffset + 128)                             {                                 ignoreall = true;                                 mPerfect = false;                                 return;                             }                         }*/FH [0] = audioData [offset++];  			if (bTrusting == true) {  				mPerfect = false;  				if (!reservedlayer) {  					bTrusting = false;  				}  			}  		}  		if (offset == BufLen) {  			return false;  		}  		FrameOffset = 1;  	}  	// end if (FrameOffset == 0)  	// Get frame header  	int i;  	for (i = FrameOffset; i < 4 && offset != BufLen; i++) {  		FH [i] = audioData [offset++];  	}  	if (i != 4 && offset == BufLen) {  		FrameOffset = i;  		return false;  	}  	// No sync  	if ((FH [1] >> 5) != 0x07 || ((FH [1] >> 1) & 0x03) == 0)// 2/18/05 ignore reserved layer  	 {  		if (((FH [1] >> 1) & 0x03) == 0)  			reservedlayer = true;  		FrameOffset = 0;  		offset -= 3;  		mPerfect = false;  	} else if (FH [1] != fh1 || (FH [2] & 0x0D) != (fh2 & 0x0D)) {  		// sync doesn't match expected type  		//  		FrameOffset = 0;  		offset -= 3;  		mPerfect = false;  	} else {  		break;  	}  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,FindFrameSync,The following statement contains a magic number: while (true) {  	if (FrameOffset == 0) {  		if (offset >= BufLen - 8) {  			return false;  		}  		FH [0] = audioData [offset++];  		while (FH [0] != 0xFF && offset < BufLen) {  			// Leading 0's  			if (offset - 1 == 0 && FH [0] == 0) {  				mPerfect = false;  				do {  					FH [0] = audioData [offset++];  				} while (FH [0] == 0 && offset < BufLen);  				continue;  			}  			if (FH [0] == 'L' && audioData [offset] == 'Y' && audioData [offset + 1] == 'R') {  				// todo: don't want to return' just stop reading data  				ignoreall = true;  				return false;  			}  			if (FH [0] == 'T' && audioData [offset] == 'A' && audioData [offset + 1] == 'G') {  				// todo: don't want to return' just stop reading data  				ignoreall = true;  				return false;  			}  			if (FH [0] == 'A' && audioData [offset] == 'P' && audioData [offset + 1] == 'E') {  				// todo: don't want to return' just stop reading data  				ignoreall = true;  				return false;  			}  			// ignore cut off frames  			// todo: eh.. is this really important?  			/*if (BufLen < cuiReadBufSize)                         {                             if (BufLen - offset < TagContainer->Lyrics3ExistingOffset + 128)                             {                                 ignoreall = true;                                 mPerfect = false;                                 return;                             }                         }*/FH [0] = audioData [offset++];  			if (bTrusting == true) {  				mPerfect = false;  				if (!reservedlayer) {  					bTrusting = false;  				}  			}  		}  		if (offset == BufLen) {  			return false;  		}  		FrameOffset = 1;  	}  	// end if (FrameOffset == 0)  	// Get frame header  	int i;  	for (i = FrameOffset; i < 4 && offset != BufLen; i++) {  		FH [i] = audioData [offset++];  	}  	if (i != 4 && offset == BufLen) {  		FrameOffset = i;  		return false;  	}  	// No sync  	if ((FH [1] >> 5) != 0x07 || ((FH [1] >> 1) & 0x03) == 0)// 2/18/05 ignore reserved layer  	 {  		if (((FH [1] >> 1) & 0x03) == 0)  			reservedlayer = true;  		FrameOffset = 0;  		offset -= 3;  		mPerfect = false;  	} else if (FH [1] != fh1 || (FH [2] & 0x0D) != (fh2 & 0x0D)) {  		// sync doesn't match expected type  		//  		FrameOffset = 0;  		offset -= 3;  		mPerfect = false;  	} else {  		break;  	}  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,FindFrameSync,The following statement contains a magic number: while (true) {  	if (FrameOffset == 0) {  		if (offset >= BufLen - 8) {  			return false;  		}  		FH [0] = audioData [offset++];  		while (FH [0] != 0xFF && offset < BufLen) {  			// Leading 0's  			if (offset - 1 == 0 && FH [0] == 0) {  				mPerfect = false;  				do {  					FH [0] = audioData [offset++];  				} while (FH [0] == 0 && offset < BufLen);  				continue;  			}  			if (FH [0] == 'L' && audioData [offset] == 'Y' && audioData [offset + 1] == 'R') {  				// todo: don't want to return' just stop reading data  				ignoreall = true;  				return false;  			}  			if (FH [0] == 'T' && audioData [offset] == 'A' && audioData [offset + 1] == 'G') {  				// todo: don't want to return' just stop reading data  				ignoreall = true;  				return false;  			}  			if (FH [0] == 'A' && audioData [offset] == 'P' && audioData [offset + 1] == 'E') {  				// todo: don't want to return' just stop reading data  				ignoreall = true;  				return false;  			}  			// ignore cut off frames  			// todo: eh.. is this really important?  			/*if (BufLen < cuiReadBufSize)                         {                             if (BufLen - offset < TagContainer->Lyrics3ExistingOffset + 128)                             {                                 ignoreall = true;                                 mPerfect = false;                                 return;                             }                         }*/FH [0] = audioData [offset++];  			if (bTrusting == true) {  				mPerfect = false;  				if (!reservedlayer) {  					bTrusting = false;  				}  			}  		}  		if (offset == BufLen) {  			return false;  		}  		FrameOffset = 1;  	}  	// end if (FrameOffset == 0)  	// Get frame header  	int i;  	for (i = FrameOffset; i < 4 && offset != BufLen; i++) {  		FH [i] = audioData [offset++];  	}  	if (i != 4 && offset == BufLen) {  		FrameOffset = i;  		return false;  	}  	// No sync  	if ((FH [1] >> 5) != 0x07 || ((FH [1] >> 1) & 0x03) == 0)// 2/18/05 ignore reserved layer  	 {  		if (((FH [1] >> 1) & 0x03) == 0)  			reservedlayer = true;  		FrameOffset = 0;  		offset -= 3;  		mPerfect = false;  	} else if (FH [1] != fh1 || (FH [2] & 0x0D) != (fh2 & 0x0D)) {  		// sync doesn't match expected type  		//  		FrameOffset = 0;  		offset -= 3;  		mPerfect = false;  	} else {  		break;  	}  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,FindFrameSync,The following statement contains a magic number: while (true) {  	if (FrameOffset == 0) {  		if (offset >= BufLen - 8) {  			return false;  		}  		FH [0] = audioData [offset++];  		while (FH [0] != 0xFF && offset < BufLen) {  			// Leading 0's  			if (offset - 1 == 0 && FH [0] == 0) {  				mPerfect = false;  				do {  					FH [0] = audioData [offset++];  				} while (FH [0] == 0 && offset < BufLen);  				continue;  			}  			if (FH [0] == 'L' && audioData [offset] == 'Y' && audioData [offset + 1] == 'R') {  				// todo: don't want to return' just stop reading data  				ignoreall = true;  				return false;  			}  			if (FH [0] == 'T' && audioData [offset] == 'A' && audioData [offset + 1] == 'G') {  				// todo: don't want to return' just stop reading data  				ignoreall = true;  				return false;  			}  			if (FH [0] == 'A' && audioData [offset] == 'P' && audioData [offset + 1] == 'E') {  				// todo: don't want to return' just stop reading data  				ignoreall = true;  				return false;  			}  			// ignore cut off frames  			// todo: eh.. is this really important?  			/*if (BufLen < cuiReadBufSize)                         {                             if (BufLen - offset < TagContainer->Lyrics3ExistingOffset + 128)                             {                                 ignoreall = true;                                 mPerfect = false;                                 return;                             }                         }*/FH [0] = audioData [offset++];  			if (bTrusting == true) {  				mPerfect = false;  				if (!reservedlayer) {  					bTrusting = false;  				}  			}  		}  		if (offset == BufLen) {  			return false;  		}  		FrameOffset = 1;  	}  	// end if (FrameOffset == 0)  	// Get frame header  	int i;  	for (i = FrameOffset; i < 4 && offset != BufLen; i++) {  		FH [i] = audioData [offset++];  	}  	if (i != 4 && offset == BufLen) {  		FrameOffset = i;  		return false;  	}  	// No sync  	if ((FH [1] >> 5) != 0x07 || ((FH [1] >> 1) & 0x03) == 0)// 2/18/05 ignore reserved layer  	 {  		if (((FH [1] >> 1) & 0x03) == 0)  			reservedlayer = true;  		FrameOffset = 0;  		offset -= 3;  		mPerfect = false;  	} else if (FH [1] != fh1 || (FH [2] & 0x0D) != (fh2 & 0x0D)) {  		// sync doesn't match expected type  		//  		FrameOffset = 0;  		offset -= 3;  		mPerfect = false;  	} else {  		break;  	}  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,FindFrameSync,The following statement contains a magic number: while (true) {  	if (FrameOffset == 0) {  		if (offset >= BufLen - 8) {  			return false;  		}  		FH [0] = audioData [offset++];  		while (FH [0] != 0xFF && offset < BufLen) {  			// Leading 0's  			if (offset - 1 == 0 && FH [0] == 0) {  				mPerfect = false;  				do {  					FH [0] = audioData [offset++];  				} while (FH [0] == 0 && offset < BufLen);  				continue;  			}  			if (FH [0] == 'L' && audioData [offset] == 'Y' && audioData [offset + 1] == 'R') {  				// todo: don't want to return' just stop reading data  				ignoreall = true;  				return false;  			}  			if (FH [0] == 'T' && audioData [offset] == 'A' && audioData [offset + 1] == 'G') {  				// todo: don't want to return' just stop reading data  				ignoreall = true;  				return false;  			}  			if (FH [0] == 'A' && audioData [offset] == 'P' && audioData [offset + 1] == 'E') {  				// todo: don't want to return' just stop reading data  				ignoreall = true;  				return false;  			}  			// ignore cut off frames  			// todo: eh.. is this really important?  			/*if (BufLen < cuiReadBufSize)                         {                             if (BufLen - offset < TagContainer->Lyrics3ExistingOffset + 128)                             {                                 ignoreall = true;                                 mPerfect = false;                                 return;                             }                         }*/FH [0] = audioData [offset++];  			if (bTrusting == true) {  				mPerfect = false;  				if (!reservedlayer) {  					bTrusting = false;  				}  			}  		}  		if (offset == BufLen) {  			return false;  		}  		FrameOffset = 1;  	}  	// end if (FrameOffset == 0)  	// Get frame header  	int i;  	for (i = FrameOffset; i < 4 && offset != BufLen; i++) {  		FH [i] = audioData [offset++];  	}  	if (i != 4 && offset == BufLen) {  		FrameOffset = i;  		return false;  	}  	// No sync  	if ((FH [1] >> 5) != 0x07 || ((FH [1] >> 1) & 0x03) == 0)// 2/18/05 ignore reserved layer  	 {  		if (((FH [1] >> 1) & 0x03) == 0)  			reservedlayer = true;  		FrameOffset = 0;  		offset -= 3;  		mPerfect = false;  	} else if (FH [1] != fh1 || (FH [2] & 0x0D) != (fh2 & 0x0D)) {  		// sync doesn't match expected type  		//  		FrameOffset = 0;  		offset -= 3;  		mPerfect = false;  	} else {  		break;  	}  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,FindFrameSync,The following statement contains a magic number: if (FrameOffset == 0) {  	if (offset >= BufLen - 8) {  		return false;  	}  	FH [0] = audioData [offset++];  	while (FH [0] != 0xFF && offset < BufLen) {  		// Leading 0's  		if (offset - 1 == 0 && FH [0] == 0) {  			mPerfect = false;  			do {  				FH [0] = audioData [offset++];  			} while (FH [0] == 0 && offset < BufLen);  			continue;  		}  		if (FH [0] == 'L' && audioData [offset] == 'Y' && audioData [offset + 1] == 'R') {  			// todo: don't want to return' just stop reading data  			ignoreall = true;  			return false;  		}  		if (FH [0] == 'T' && audioData [offset] == 'A' && audioData [offset + 1] == 'G') {  			// todo: don't want to return' just stop reading data  			ignoreall = true;  			return false;  		}  		if (FH [0] == 'A' && audioData [offset] == 'P' && audioData [offset + 1] == 'E') {  			// todo: don't want to return' just stop reading data  			ignoreall = true;  			return false;  		}  		// ignore cut off frames  		// todo: eh.. is this really important?  		/*if (BufLen < cuiReadBufSize)                         {                             if (BufLen - offset < TagContainer->Lyrics3ExistingOffset + 128)                             {                                 ignoreall = true;                                 mPerfect = false;                                 return;                             }                         }*/FH [0] = audioData [offset++];  		if (bTrusting == true) {  			mPerfect = false;  			if (!reservedlayer) {  				bTrusting = false;  			}  		}  	}  	if (offset == BufLen) {  		return false;  	}  	FrameOffset = 1;  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,FindFrameSync,The following statement contains a magic number: if (offset >= BufLen - 8) {  	return false;  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,FindFrameSync,The following statement contains a magic number: for (i = FrameOffset; i < 4 && offset != BufLen; i++) {  	FH [i] = audioData [offset++];  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,FindFrameSync,The following statement contains a magic number: if (i != 4 && offset == BufLen) {  	FrameOffset = i;  	return false;  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,FindFrameSync,The following statement contains a magic number: if ((FH [1] >> 5) != 0x07 || ((FH [1] >> 1) & 0x03) == 0)// 2/18/05 ignore reserved layer   {  	if (((FH [1] >> 1) & 0x03) == 0)  		reservedlayer = true;  	FrameOffset = 0;  	offset -= 3;  	mPerfect = false;  } else if (FH [1] != fh1 || (FH [2] & 0x0D) != (fh2 & 0x0D)) {  	// sync doesn't match expected type  	//  	FrameOffset = 0;  	offset -= 3;  	mPerfect = false;  } else {  	break;  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,FindFrameSync,The following statement contains a magic number: if ((FH [1] >> 5) != 0x07 || ((FH [1] >> 1) & 0x03) == 0)// 2/18/05 ignore reserved layer   {  	if (((FH [1] >> 1) & 0x03) == 0)  		reservedlayer = true;  	FrameOffset = 0;  	offset -= 3;  	mPerfect = false;  } else if (FH [1] != fh1 || (FH [2] & 0x0D) != (fh2 & 0x0D)) {  	// sync doesn't match expected type  	//  	FrameOffset = 0;  	offset -= 3;  	mPerfect = false;  } else {  	break;  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,FindFrameSync,The following statement contains a magic number: if ((FH [1] >> 5) != 0x07 || ((FH [1] >> 1) & 0x03) == 0)// 2/18/05 ignore reserved layer   {  	if (((FH [1] >> 1) & 0x03) == 0)  		reservedlayer = true;  	FrameOffset = 0;  	offset -= 3;  	mPerfect = false;  } else if (FH [1] != fh1 || (FH [2] & 0x0D) != (fh2 & 0x0D)) {  	// sync doesn't match expected type  	//  	FrameOffset = 0;  	offset -= 3;  	mPerfect = false;  } else {  	break;  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,FindFrameSync,The following statement contains a magic number: if ((FH [1] >> 5) != 0x07 || ((FH [1] >> 1) & 0x03) == 0)// 2/18/05 ignore reserved layer   {  	if (((FH [1] >> 1) & 0x03) == 0)  		reservedlayer = true;  	FrameOffset = 0;  	offset -= 3;  	mPerfect = false;  } else if (FH [1] != fh1 || (FH [2] & 0x0D) != (fh2 & 0x0D)) {  	// sync doesn't match expected type  	//  	FrameOffset = 0;  	offset -= 3;  	mPerfect = false;  } else {  	break;  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,FindFrameSync,The following statement contains a magic number: offset -= 3;  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,FindFrameSync,The following statement contains a magic number: if (FH [1] != fh1 || (FH [2] & 0x0D) != (fh2 & 0x0D)) {  	// sync doesn't match expected type  	//  	FrameOffset = 0;  	offset -= 3;  	mPerfect = false;  } else {  	break;  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,FindFrameSync,The following statement contains a magic number: if (FH [1] != fh1 || (FH [2] & 0x0D) != (fh2 & 0x0D)) {  	// sync doesn't match expected type  	//  	FrameOffset = 0;  	offset -= 3;  	mPerfect = false;  } else {  	break;  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,FindFrameSync,The following statement contains a magic number: offset -= 3;  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,GetSamplesPerFrame,The following statement contains a magic number: switch (mpegVersion) {  // MPEG-1  case MpegVersion.Mpeg1:  	if (mpegLayer == MpegLayer.Layer1)  		tmpSamplesPerFrame = 384;  	else if (mpegLayer == MpegLayer.Layer2 || mpegLayer == MpegLayer.Layer3)  		tmpSamplesPerFrame = 1152;  	break;  // MPEG-2/2.5  case MpegVersion.Mpeg2:  case MpegVersion.Mpeg25:  	if (mpegLayer == MpegLayer.Layer1)  		tmpSamplesPerFrame = 384;  	else if (mpegLayer == MpegLayer.Layer2)  		tmpSamplesPerFrame = 1152;  	else if (mpegLayer == MpegLayer.Layer3)  		tmpSamplesPerFrame = 576;  	break;  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,GetSamplesPerFrame,The following statement contains a magic number: switch (mpegVersion) {  // MPEG-1  case MpegVersion.Mpeg1:  	if (mpegLayer == MpegLayer.Layer1)  		tmpSamplesPerFrame = 384;  	else if (mpegLayer == MpegLayer.Layer2 || mpegLayer == MpegLayer.Layer3)  		tmpSamplesPerFrame = 1152;  	break;  // MPEG-2/2.5  case MpegVersion.Mpeg2:  case MpegVersion.Mpeg25:  	if (mpegLayer == MpegLayer.Layer1)  		tmpSamplesPerFrame = 384;  	else if (mpegLayer == MpegLayer.Layer2)  		tmpSamplesPerFrame = 1152;  	else if (mpegLayer == MpegLayer.Layer3)  		tmpSamplesPerFrame = 576;  	break;  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,GetSamplesPerFrame,The following statement contains a magic number: switch (mpegVersion) {  // MPEG-1  case MpegVersion.Mpeg1:  	if (mpegLayer == MpegLayer.Layer1)  		tmpSamplesPerFrame = 384;  	else if (mpegLayer == MpegLayer.Layer2 || mpegLayer == MpegLayer.Layer3)  		tmpSamplesPerFrame = 1152;  	break;  // MPEG-2/2.5  case MpegVersion.Mpeg2:  case MpegVersion.Mpeg25:  	if (mpegLayer == MpegLayer.Layer1)  		tmpSamplesPerFrame = 384;  	else if (mpegLayer == MpegLayer.Layer2)  		tmpSamplesPerFrame = 1152;  	else if (mpegLayer == MpegLayer.Layer3)  		tmpSamplesPerFrame = 576;  	break;  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,GetSamplesPerFrame,The following statement contains a magic number: switch (mpegVersion) {  // MPEG-1  case MpegVersion.Mpeg1:  	if (mpegLayer == MpegLayer.Layer1)  		tmpSamplesPerFrame = 384;  	else if (mpegLayer == MpegLayer.Layer2 || mpegLayer == MpegLayer.Layer3)  		tmpSamplesPerFrame = 1152;  	break;  // MPEG-2/2.5  case MpegVersion.Mpeg2:  case MpegVersion.Mpeg25:  	if (mpegLayer == MpegLayer.Layer1)  		tmpSamplesPerFrame = 384;  	else if (mpegLayer == MpegLayer.Layer2)  		tmpSamplesPerFrame = 1152;  	else if (mpegLayer == MpegLayer.Layer3)  		tmpSamplesPerFrame = 576;  	break;  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,GetSamplesPerFrame,The following statement contains a magic number: switch (mpegVersion) {  // MPEG-1  case MpegVersion.Mpeg1:  	if (mpegLayer == MpegLayer.Layer1)  		tmpSamplesPerFrame = 384;  	else if (mpegLayer == MpegLayer.Layer2 || mpegLayer == MpegLayer.Layer3)  		tmpSamplesPerFrame = 1152;  	break;  // MPEG-2/2.5  case MpegVersion.Mpeg2:  case MpegVersion.Mpeg25:  	if (mpegLayer == MpegLayer.Layer1)  		tmpSamplesPerFrame = 384;  	else if (mpegLayer == MpegLayer.Layer2)  		tmpSamplesPerFrame = 1152;  	else if (mpegLayer == MpegLayer.Layer3)  		tmpSamplesPerFrame = 576;  	break;  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,GetSamplesPerFrame,The following statement contains a magic number: if (mpegLayer == MpegLayer.Layer1)  	tmpSamplesPerFrame = 384;  else if (mpegLayer == MpegLayer.Layer2 || mpegLayer == MpegLayer.Layer3)  	tmpSamplesPerFrame = 1152;  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,GetSamplesPerFrame,The following statement contains a magic number: if (mpegLayer == MpegLayer.Layer1)  	tmpSamplesPerFrame = 384;  else if (mpegLayer == MpegLayer.Layer2 || mpegLayer == MpegLayer.Layer3)  	tmpSamplesPerFrame = 1152;  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,GetSamplesPerFrame,The following statement contains a magic number: tmpSamplesPerFrame = 384;  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,GetSamplesPerFrame,The following statement contains a magic number: if (mpegLayer == MpegLayer.Layer2 || mpegLayer == MpegLayer.Layer3)  	tmpSamplesPerFrame = 1152;  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,GetSamplesPerFrame,The following statement contains a magic number: tmpSamplesPerFrame = 1152;  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,GetSamplesPerFrame,The following statement contains a magic number: if (mpegLayer == MpegLayer.Layer1)  	tmpSamplesPerFrame = 384;  else if (mpegLayer == MpegLayer.Layer2)  	tmpSamplesPerFrame = 1152;  else if (mpegLayer == MpegLayer.Layer3)  	tmpSamplesPerFrame = 576;  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,GetSamplesPerFrame,The following statement contains a magic number: if (mpegLayer == MpegLayer.Layer1)  	tmpSamplesPerFrame = 384;  else if (mpegLayer == MpegLayer.Layer2)  	tmpSamplesPerFrame = 1152;  else if (mpegLayer == MpegLayer.Layer3)  	tmpSamplesPerFrame = 576;  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,GetSamplesPerFrame,The following statement contains a magic number: if (mpegLayer == MpegLayer.Layer1)  	tmpSamplesPerFrame = 384;  else if (mpegLayer == MpegLayer.Layer2)  	tmpSamplesPerFrame = 1152;  else if (mpegLayer == MpegLayer.Layer3)  	tmpSamplesPerFrame = 576;  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,GetSamplesPerFrame,The following statement contains a magic number: tmpSamplesPerFrame = 384;  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,GetSamplesPerFrame,The following statement contains a magic number: if (mpegLayer == MpegLayer.Layer2)  	tmpSamplesPerFrame = 1152;  else if (mpegLayer == MpegLayer.Layer3)  	tmpSamplesPerFrame = 576;  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,GetSamplesPerFrame,The following statement contains a magic number: if (mpegLayer == MpegLayer.Layer2)  	tmpSamplesPerFrame = 1152;  else if (mpegLayer == MpegLayer.Layer3)  	tmpSamplesPerFrame = 576;  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,GetSamplesPerFrame,The following statement contains a magic number: tmpSamplesPerFrame = 1152;  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,GetSamplesPerFrame,The following statement contains a magic number: if (mpegLayer == MpegLayer.Layer3)  	tmpSamplesPerFrame = 576;  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,GetSamplesPerFrame,The following statement contains a magic number: tmpSamplesPerFrame = 576;  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,GetFrequency,The following statement contains a magic number: switch (mpegVersion) {  // MPEG-1  case MpegVersion.Mpeg1:  	switch (frequencyID) {  	case 0:  		tmpFrequency = 44100;  		break;  	case 1:  		tmpFrequency = 48000;  		break;  	case 2:  		tmpFrequency = 32000;  		break;  	}  	// end switch (Frequency)  	break;  // MPEG-2  case MpegVersion.Mpeg2:  	switch (frequencyID) {  	case 0:  		tmpFrequency = 22050;  		break;  	case 1:  		tmpFrequency = 24000;  		break;  	case 2:  		tmpFrequency = 16000;  		break;  	}  	// end switch (Frequency)  	break;  // MPEG-2.5  case MpegVersion.Mpeg25:  	switch (frequencyID) {  	case 0:  		tmpFrequency = 11025;  		break;  	case 1:  		tmpFrequency = 12000;  		break;  	case 2:  		tmpFrequency = 8000;  		break;  	}  	// end switch (Frequency)  	break;  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,GetFrequency,The following statement contains a magic number: switch (mpegVersion) {  // MPEG-1  case MpegVersion.Mpeg1:  	switch (frequencyID) {  	case 0:  		tmpFrequency = 44100;  		break;  	case 1:  		tmpFrequency = 48000;  		break;  	case 2:  		tmpFrequency = 32000;  		break;  	}  	// end switch (Frequency)  	break;  // MPEG-2  case MpegVersion.Mpeg2:  	switch (frequencyID) {  	case 0:  		tmpFrequency = 22050;  		break;  	case 1:  		tmpFrequency = 24000;  		break;  	case 2:  		tmpFrequency = 16000;  		break;  	}  	// end switch (Frequency)  	break;  // MPEG-2.5  case MpegVersion.Mpeg25:  	switch (frequencyID) {  	case 0:  		tmpFrequency = 11025;  		break;  	case 1:  		tmpFrequency = 12000;  		break;  	case 2:  		tmpFrequency = 8000;  		break;  	}  	// end switch (Frequency)  	break;  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,GetFrequency,The following statement contains a magic number: switch (mpegVersion) {  // MPEG-1  case MpegVersion.Mpeg1:  	switch (frequencyID) {  	case 0:  		tmpFrequency = 44100;  		break;  	case 1:  		tmpFrequency = 48000;  		break;  	case 2:  		tmpFrequency = 32000;  		break;  	}  	// end switch (Frequency)  	break;  // MPEG-2  case MpegVersion.Mpeg2:  	switch (frequencyID) {  	case 0:  		tmpFrequency = 22050;  		break;  	case 1:  		tmpFrequency = 24000;  		break;  	case 2:  		tmpFrequency = 16000;  		break;  	}  	// end switch (Frequency)  	break;  // MPEG-2.5  case MpegVersion.Mpeg25:  	switch (frequencyID) {  	case 0:  		tmpFrequency = 11025;  		break;  	case 1:  		tmpFrequency = 12000;  		break;  	case 2:  		tmpFrequency = 8000;  		break;  	}  	// end switch (Frequency)  	break;  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,GetFrequency,The following statement contains a magic number: switch (mpegVersion) {  // MPEG-1  case MpegVersion.Mpeg1:  	switch (frequencyID) {  	case 0:  		tmpFrequency = 44100;  		break;  	case 1:  		tmpFrequency = 48000;  		break;  	case 2:  		tmpFrequency = 32000;  		break;  	}  	// end switch (Frequency)  	break;  // MPEG-2  case MpegVersion.Mpeg2:  	switch (frequencyID) {  	case 0:  		tmpFrequency = 22050;  		break;  	case 1:  		tmpFrequency = 24000;  		break;  	case 2:  		tmpFrequency = 16000;  		break;  	}  	// end switch (Frequency)  	break;  // MPEG-2.5  case MpegVersion.Mpeg25:  	switch (frequencyID) {  	case 0:  		tmpFrequency = 11025;  		break;  	case 1:  		tmpFrequency = 12000;  		break;  	case 2:  		tmpFrequency = 8000;  		break;  	}  	// end switch (Frequency)  	break;  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,GetFrequency,The following statement contains a magic number: switch (mpegVersion) {  // MPEG-1  case MpegVersion.Mpeg1:  	switch (frequencyID) {  	case 0:  		tmpFrequency = 44100;  		break;  	case 1:  		tmpFrequency = 48000;  		break;  	case 2:  		tmpFrequency = 32000;  		break;  	}  	// end switch (Frequency)  	break;  // MPEG-2  case MpegVersion.Mpeg2:  	switch (frequencyID) {  	case 0:  		tmpFrequency = 22050;  		break;  	case 1:  		tmpFrequency = 24000;  		break;  	case 2:  		tmpFrequency = 16000;  		break;  	}  	// end switch (Frequency)  	break;  // MPEG-2.5  case MpegVersion.Mpeg25:  	switch (frequencyID) {  	case 0:  		tmpFrequency = 11025;  		break;  	case 1:  		tmpFrequency = 12000;  		break;  	case 2:  		tmpFrequency = 8000;  		break;  	}  	// end switch (Frequency)  	break;  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,GetFrequency,The following statement contains a magic number: switch (mpegVersion) {  // MPEG-1  case MpegVersion.Mpeg1:  	switch (frequencyID) {  	case 0:  		tmpFrequency = 44100;  		break;  	case 1:  		tmpFrequency = 48000;  		break;  	case 2:  		tmpFrequency = 32000;  		break;  	}  	// end switch (Frequency)  	break;  // MPEG-2  case MpegVersion.Mpeg2:  	switch (frequencyID) {  	case 0:  		tmpFrequency = 22050;  		break;  	case 1:  		tmpFrequency = 24000;  		break;  	case 2:  		tmpFrequency = 16000;  		break;  	}  	// end switch (Frequency)  	break;  // MPEG-2.5  case MpegVersion.Mpeg25:  	switch (frequencyID) {  	case 0:  		tmpFrequency = 11025;  		break;  	case 1:  		tmpFrequency = 12000;  		break;  	case 2:  		tmpFrequency = 8000;  		break;  	}  	// end switch (Frequency)  	break;  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,GetFrequency,The following statement contains a magic number: switch (mpegVersion) {  // MPEG-1  case MpegVersion.Mpeg1:  	switch (frequencyID) {  	case 0:  		tmpFrequency = 44100;  		break;  	case 1:  		tmpFrequency = 48000;  		break;  	case 2:  		tmpFrequency = 32000;  		break;  	}  	// end switch (Frequency)  	break;  // MPEG-2  case MpegVersion.Mpeg2:  	switch (frequencyID) {  	case 0:  		tmpFrequency = 22050;  		break;  	case 1:  		tmpFrequency = 24000;  		break;  	case 2:  		tmpFrequency = 16000;  		break;  	}  	// end switch (Frequency)  	break;  // MPEG-2.5  case MpegVersion.Mpeg25:  	switch (frequencyID) {  	case 0:  		tmpFrequency = 11025;  		break;  	case 1:  		tmpFrequency = 12000;  		break;  	case 2:  		tmpFrequency = 8000;  		break;  	}  	// end switch (Frequency)  	break;  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,GetFrequency,The following statement contains a magic number: switch (mpegVersion) {  // MPEG-1  case MpegVersion.Mpeg1:  	switch (frequencyID) {  	case 0:  		tmpFrequency = 44100;  		break;  	case 1:  		tmpFrequency = 48000;  		break;  	case 2:  		tmpFrequency = 32000;  		break;  	}  	// end switch (Frequency)  	break;  // MPEG-2  case MpegVersion.Mpeg2:  	switch (frequencyID) {  	case 0:  		tmpFrequency = 22050;  		break;  	case 1:  		tmpFrequency = 24000;  		break;  	case 2:  		tmpFrequency = 16000;  		break;  	}  	// end switch (Frequency)  	break;  // MPEG-2.5  case MpegVersion.Mpeg25:  	switch (frequencyID) {  	case 0:  		tmpFrequency = 11025;  		break;  	case 1:  		tmpFrequency = 12000;  		break;  	case 2:  		tmpFrequency = 8000;  		break;  	}  	// end switch (Frequency)  	break;  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,GetFrequency,The following statement contains a magic number: switch (mpegVersion) {  // MPEG-1  case MpegVersion.Mpeg1:  	switch (frequencyID) {  	case 0:  		tmpFrequency = 44100;  		break;  	case 1:  		tmpFrequency = 48000;  		break;  	case 2:  		tmpFrequency = 32000;  		break;  	}  	// end switch (Frequency)  	break;  // MPEG-2  case MpegVersion.Mpeg2:  	switch (frequencyID) {  	case 0:  		tmpFrequency = 22050;  		break;  	case 1:  		tmpFrequency = 24000;  		break;  	case 2:  		tmpFrequency = 16000;  		break;  	}  	// end switch (Frequency)  	break;  // MPEG-2.5  case MpegVersion.Mpeg25:  	switch (frequencyID) {  	case 0:  		tmpFrequency = 11025;  		break;  	case 1:  		tmpFrequency = 12000;  		break;  	case 2:  		tmpFrequency = 8000;  		break;  	}  	// end switch (Frequency)  	break;  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,GetFrequency,The following statement contains a magic number: switch (mpegVersion) {  // MPEG-1  case MpegVersion.Mpeg1:  	switch (frequencyID) {  	case 0:  		tmpFrequency = 44100;  		break;  	case 1:  		tmpFrequency = 48000;  		break;  	case 2:  		tmpFrequency = 32000;  		break;  	}  	// end switch (Frequency)  	break;  // MPEG-2  case MpegVersion.Mpeg2:  	switch (frequencyID) {  	case 0:  		tmpFrequency = 22050;  		break;  	case 1:  		tmpFrequency = 24000;  		break;  	case 2:  		tmpFrequency = 16000;  		break;  	}  	// end switch (Frequency)  	break;  // MPEG-2.5  case MpegVersion.Mpeg25:  	switch (frequencyID) {  	case 0:  		tmpFrequency = 11025;  		break;  	case 1:  		tmpFrequency = 12000;  		break;  	case 2:  		tmpFrequency = 8000;  		break;  	}  	// end switch (Frequency)  	break;  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,GetFrequency,The following statement contains a magic number: switch (mpegVersion) {  // MPEG-1  case MpegVersion.Mpeg1:  	switch (frequencyID) {  	case 0:  		tmpFrequency = 44100;  		break;  	case 1:  		tmpFrequency = 48000;  		break;  	case 2:  		tmpFrequency = 32000;  		break;  	}  	// end switch (Frequency)  	break;  // MPEG-2  case MpegVersion.Mpeg2:  	switch (frequencyID) {  	case 0:  		tmpFrequency = 22050;  		break;  	case 1:  		tmpFrequency = 24000;  		break;  	case 2:  		tmpFrequency = 16000;  		break;  	}  	// end switch (Frequency)  	break;  // MPEG-2.5  case MpegVersion.Mpeg25:  	switch (frequencyID) {  	case 0:  		tmpFrequency = 11025;  		break;  	case 1:  		tmpFrequency = 12000;  		break;  	case 2:  		tmpFrequency = 8000;  		break;  	}  	// end switch (Frequency)  	break;  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,GetFrequency,The following statement contains a magic number: switch (mpegVersion) {  // MPEG-1  case MpegVersion.Mpeg1:  	switch (frequencyID) {  	case 0:  		tmpFrequency = 44100;  		break;  	case 1:  		tmpFrequency = 48000;  		break;  	case 2:  		tmpFrequency = 32000;  		break;  	}  	// end switch (Frequency)  	break;  // MPEG-2  case MpegVersion.Mpeg2:  	switch (frequencyID) {  	case 0:  		tmpFrequency = 22050;  		break;  	case 1:  		tmpFrequency = 24000;  		break;  	case 2:  		tmpFrequency = 16000;  		break;  	}  	// end switch (Frequency)  	break;  // MPEG-2.5  case MpegVersion.Mpeg25:  	switch (frequencyID) {  	case 0:  		tmpFrequency = 11025;  		break;  	case 1:  		tmpFrequency = 12000;  		break;  	case 2:  		tmpFrequency = 8000;  		break;  	}  	// end switch (Frequency)  	break;  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,GetFrequency,The following statement contains a magic number: switch (frequencyID) {  case 0:  	tmpFrequency = 44100;  	break;  case 1:  	tmpFrequency = 48000;  	break;  case 2:  	tmpFrequency = 32000;  	break;  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,GetFrequency,The following statement contains a magic number: switch (frequencyID) {  case 0:  	tmpFrequency = 44100;  	break;  case 1:  	tmpFrequency = 48000;  	break;  case 2:  	tmpFrequency = 32000;  	break;  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,GetFrequency,The following statement contains a magic number: switch (frequencyID) {  case 0:  	tmpFrequency = 44100;  	break;  case 1:  	tmpFrequency = 48000;  	break;  case 2:  	tmpFrequency = 32000;  	break;  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,GetFrequency,The following statement contains a magic number: switch (frequencyID) {  case 0:  	tmpFrequency = 44100;  	break;  case 1:  	tmpFrequency = 48000;  	break;  case 2:  	tmpFrequency = 32000;  	break;  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,GetFrequency,The following statement contains a magic number: tmpFrequency = 44100;  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,GetFrequency,The following statement contains a magic number: tmpFrequency = 48000;  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,GetFrequency,The following statement contains a magic number: tmpFrequency = 32000;  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,GetFrequency,The following statement contains a magic number: switch (frequencyID) {  case 0:  	tmpFrequency = 22050;  	break;  case 1:  	tmpFrequency = 24000;  	break;  case 2:  	tmpFrequency = 16000;  	break;  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,GetFrequency,The following statement contains a magic number: switch (frequencyID) {  case 0:  	tmpFrequency = 22050;  	break;  case 1:  	tmpFrequency = 24000;  	break;  case 2:  	tmpFrequency = 16000;  	break;  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,GetFrequency,The following statement contains a magic number: switch (frequencyID) {  case 0:  	tmpFrequency = 22050;  	break;  case 1:  	tmpFrequency = 24000;  	break;  case 2:  	tmpFrequency = 16000;  	break;  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,GetFrequency,The following statement contains a magic number: switch (frequencyID) {  case 0:  	tmpFrequency = 22050;  	break;  case 1:  	tmpFrequency = 24000;  	break;  case 2:  	tmpFrequency = 16000;  	break;  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,GetFrequency,The following statement contains a magic number: tmpFrequency = 22050;  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,GetFrequency,The following statement contains a magic number: tmpFrequency = 24000;  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,GetFrequency,The following statement contains a magic number: tmpFrequency = 16000;  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,GetFrequency,The following statement contains a magic number: switch (frequencyID) {  case 0:  	tmpFrequency = 11025;  	break;  case 1:  	tmpFrequency = 12000;  	break;  case 2:  	tmpFrequency = 8000;  	break;  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,GetFrequency,The following statement contains a magic number: switch (frequencyID) {  case 0:  	tmpFrequency = 11025;  	break;  case 1:  	tmpFrequency = 12000;  	break;  case 2:  	tmpFrequency = 8000;  	break;  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,GetFrequency,The following statement contains a magic number: switch (frequencyID) {  case 0:  	tmpFrequency = 11025;  	break;  case 1:  	tmpFrequency = 12000;  	break;  case 2:  	tmpFrequency = 8000;  	break;  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,GetFrequency,The following statement contains a magic number: switch (frequencyID) {  case 0:  	tmpFrequency = 11025;  	break;  case 1:  	tmpFrequency = 12000;  	break;  case 2:  	tmpFrequency = 8000;  	break;  }  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,GetFrequency,The following statement contains a magic number: tmpFrequency = 11025;  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,GetFrequency,The following statement contains a magic number: tmpFrequency = 12000;  
Magic Number,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,GetFrequency,The following statement contains a magic number: tmpFrequency = 8000;  
Magic Number,IdSharp.AudioInfo,Musepack,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Musepack\Musepack.cs,Musepack,The following statement contains a magic number: using (FileStream stream = File.Open (path' FileMode.Open' FileAccess.Read' FileShare.Read)) {  	// Skip ID3v2 tag  	int tmpID3v2TagSize = ID3v2.GetTagSize (stream);  	int tmpID3v1TagSize = ID3v1.GetTagSize (stream);  	int tmpAPEv2TagSize = APEv2.GetTagSize (stream);  	stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  	_streamVersion = 0;  	byte[] byteArray = stream.Read (32);  	int[] integerArray = new int[8];  	for (int i = 0; i < 8; i++)  		integerArray [i] = (byteArray [i * 4]) + (byteArray [i * 4 + 1] << 8) + (byteArray [i * 4 + 2] << 16) + (byteArray [i * 4 + 3] << 24);  	// Size TODO - ignore Lyrics3  	long audioDataLength = stream.Length - tmpID3v2TagSize - tmpID3v1TagSize - tmpAPEv2TagSize;  	// Stream version  	if (integerArray [0] == STREAM_VERSION_70_ID) {  		_streamVersion = 7;  	} else if (integerArray [0] == STREAM_VERSION_71_ID) {  		_streamVersion = 7.1m;  	} else {  		switch ((byteArray [1] % 32) / 2) {  		case 3:  			_streamVersion = 4;  			break;  		case 7:  			_streamVersion = 5;  			break;  		case 11:  			_streamVersion = 6;  			break;  		}  	}  	if (_streamVersion == 0) {  		throw new InvalidDataException ("Unrecognized MPC stream");  	}  	// Sample rate  	_frequency = _sampleRates [byteArray [10] & 0x03];  	// Channels  	if (_streamVersion == 7 || _streamVersion == 7.1m) {  		if ((byteArray [11] % 128) < 64)  			_mode = "Stereo";  		else  			_mode = "Joint Stereo";  	} else {  		if ((byteArray [2] % 128) == 0)  			_mode = "Stereo";  		else  			_mode = "Joint Stereo";  	}  	// Frames  	if (_streamVersion == 4)  		_frames = integerArray [1] >> 16;  	else  		_frames = integerArray [1];  	_totalSeconds = _frames * 1152 / (decimal)_frequency;  	_bitrate = (audioDataLength / _totalSeconds) / 125.0m;  }  
Magic Number,IdSharp.AudioInfo,Musepack,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Musepack\Musepack.cs,Musepack,The following statement contains a magic number: using (FileStream stream = File.Open (path' FileMode.Open' FileAccess.Read' FileShare.Read)) {  	// Skip ID3v2 tag  	int tmpID3v2TagSize = ID3v2.GetTagSize (stream);  	int tmpID3v1TagSize = ID3v1.GetTagSize (stream);  	int tmpAPEv2TagSize = APEv2.GetTagSize (stream);  	stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  	_streamVersion = 0;  	byte[] byteArray = stream.Read (32);  	int[] integerArray = new int[8];  	for (int i = 0; i < 8; i++)  		integerArray [i] = (byteArray [i * 4]) + (byteArray [i * 4 + 1] << 8) + (byteArray [i * 4 + 2] << 16) + (byteArray [i * 4 + 3] << 24);  	// Size TODO - ignore Lyrics3  	long audioDataLength = stream.Length - tmpID3v2TagSize - tmpID3v1TagSize - tmpAPEv2TagSize;  	// Stream version  	if (integerArray [0] == STREAM_VERSION_70_ID) {  		_streamVersion = 7;  	} else if (integerArray [0] == STREAM_VERSION_71_ID) {  		_streamVersion = 7.1m;  	} else {  		switch ((byteArray [1] % 32) / 2) {  		case 3:  			_streamVersion = 4;  			break;  		case 7:  			_streamVersion = 5;  			break;  		case 11:  			_streamVersion = 6;  			break;  		}  	}  	if (_streamVersion == 0) {  		throw new InvalidDataException ("Unrecognized MPC stream");  	}  	// Sample rate  	_frequency = _sampleRates [byteArray [10] & 0x03];  	// Channels  	if (_streamVersion == 7 || _streamVersion == 7.1m) {  		if ((byteArray [11] % 128) < 64)  			_mode = "Stereo";  		else  			_mode = "Joint Stereo";  	} else {  		if ((byteArray [2] % 128) == 0)  			_mode = "Stereo";  		else  			_mode = "Joint Stereo";  	}  	// Frames  	if (_streamVersion == 4)  		_frames = integerArray [1] >> 16;  	else  		_frames = integerArray [1];  	_totalSeconds = _frames * 1152 / (decimal)_frequency;  	_bitrate = (audioDataLength / _totalSeconds) / 125.0m;  }  
Magic Number,IdSharp.AudioInfo,Musepack,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Musepack\Musepack.cs,Musepack,The following statement contains a magic number: using (FileStream stream = File.Open (path' FileMode.Open' FileAccess.Read' FileShare.Read)) {  	// Skip ID3v2 tag  	int tmpID3v2TagSize = ID3v2.GetTagSize (stream);  	int tmpID3v1TagSize = ID3v1.GetTagSize (stream);  	int tmpAPEv2TagSize = APEv2.GetTagSize (stream);  	stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  	_streamVersion = 0;  	byte[] byteArray = stream.Read (32);  	int[] integerArray = new int[8];  	for (int i = 0; i < 8; i++)  		integerArray [i] = (byteArray [i * 4]) + (byteArray [i * 4 + 1] << 8) + (byteArray [i * 4 + 2] << 16) + (byteArray [i * 4 + 3] << 24);  	// Size TODO - ignore Lyrics3  	long audioDataLength = stream.Length - tmpID3v2TagSize - tmpID3v1TagSize - tmpAPEv2TagSize;  	// Stream version  	if (integerArray [0] == STREAM_VERSION_70_ID) {  		_streamVersion = 7;  	} else if (integerArray [0] == STREAM_VERSION_71_ID) {  		_streamVersion = 7.1m;  	} else {  		switch ((byteArray [1] % 32) / 2) {  		case 3:  			_streamVersion = 4;  			break;  		case 7:  			_streamVersion = 5;  			break;  		case 11:  			_streamVersion = 6;  			break;  		}  	}  	if (_streamVersion == 0) {  		throw new InvalidDataException ("Unrecognized MPC stream");  	}  	// Sample rate  	_frequency = _sampleRates [byteArray [10] & 0x03];  	// Channels  	if (_streamVersion == 7 || _streamVersion == 7.1m) {  		if ((byteArray [11] % 128) < 64)  			_mode = "Stereo";  		else  			_mode = "Joint Stereo";  	} else {  		if ((byteArray [2] % 128) == 0)  			_mode = "Stereo";  		else  			_mode = "Joint Stereo";  	}  	// Frames  	if (_streamVersion == 4)  		_frames = integerArray [1] >> 16;  	else  		_frames = integerArray [1];  	_totalSeconds = _frames * 1152 / (decimal)_frequency;  	_bitrate = (audioDataLength / _totalSeconds) / 125.0m;  }  
Magic Number,IdSharp.AudioInfo,Musepack,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Musepack\Musepack.cs,Musepack,The following statement contains a magic number: using (FileStream stream = File.Open (path' FileMode.Open' FileAccess.Read' FileShare.Read)) {  	// Skip ID3v2 tag  	int tmpID3v2TagSize = ID3v2.GetTagSize (stream);  	int tmpID3v1TagSize = ID3v1.GetTagSize (stream);  	int tmpAPEv2TagSize = APEv2.GetTagSize (stream);  	stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  	_streamVersion = 0;  	byte[] byteArray = stream.Read (32);  	int[] integerArray = new int[8];  	for (int i = 0; i < 8; i++)  		integerArray [i] = (byteArray [i * 4]) + (byteArray [i * 4 + 1] << 8) + (byteArray [i * 4 + 2] << 16) + (byteArray [i * 4 + 3] << 24);  	// Size TODO - ignore Lyrics3  	long audioDataLength = stream.Length - tmpID3v2TagSize - tmpID3v1TagSize - tmpAPEv2TagSize;  	// Stream version  	if (integerArray [0] == STREAM_VERSION_70_ID) {  		_streamVersion = 7;  	} else if (integerArray [0] == STREAM_VERSION_71_ID) {  		_streamVersion = 7.1m;  	} else {  		switch ((byteArray [1] % 32) / 2) {  		case 3:  			_streamVersion = 4;  			break;  		case 7:  			_streamVersion = 5;  			break;  		case 11:  			_streamVersion = 6;  			break;  		}  	}  	if (_streamVersion == 0) {  		throw new InvalidDataException ("Unrecognized MPC stream");  	}  	// Sample rate  	_frequency = _sampleRates [byteArray [10] & 0x03];  	// Channels  	if (_streamVersion == 7 || _streamVersion == 7.1m) {  		if ((byteArray [11] % 128) < 64)  			_mode = "Stereo";  		else  			_mode = "Joint Stereo";  	} else {  		if ((byteArray [2] % 128) == 0)  			_mode = "Stereo";  		else  			_mode = "Joint Stereo";  	}  	// Frames  	if (_streamVersion == 4)  		_frames = integerArray [1] >> 16;  	else  		_frames = integerArray [1];  	_totalSeconds = _frames * 1152 / (decimal)_frequency;  	_bitrate = (audioDataLength / _totalSeconds) / 125.0m;  }  
Magic Number,IdSharp.AudioInfo,Musepack,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Musepack\Musepack.cs,Musepack,The following statement contains a magic number: using (FileStream stream = File.Open (path' FileMode.Open' FileAccess.Read' FileShare.Read)) {  	// Skip ID3v2 tag  	int tmpID3v2TagSize = ID3v2.GetTagSize (stream);  	int tmpID3v1TagSize = ID3v1.GetTagSize (stream);  	int tmpAPEv2TagSize = APEv2.GetTagSize (stream);  	stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  	_streamVersion = 0;  	byte[] byteArray = stream.Read (32);  	int[] integerArray = new int[8];  	for (int i = 0; i < 8; i++)  		integerArray [i] = (byteArray [i * 4]) + (byteArray [i * 4 + 1] << 8) + (byteArray [i * 4 + 2] << 16) + (byteArray [i * 4 + 3] << 24);  	// Size TODO - ignore Lyrics3  	long audioDataLength = stream.Length - tmpID3v2TagSize - tmpID3v1TagSize - tmpAPEv2TagSize;  	// Stream version  	if (integerArray [0] == STREAM_VERSION_70_ID) {  		_streamVersion = 7;  	} else if (integerArray [0] == STREAM_VERSION_71_ID) {  		_streamVersion = 7.1m;  	} else {  		switch ((byteArray [1] % 32) / 2) {  		case 3:  			_streamVersion = 4;  			break;  		case 7:  			_streamVersion = 5;  			break;  		case 11:  			_streamVersion = 6;  			break;  		}  	}  	if (_streamVersion == 0) {  		throw new InvalidDataException ("Unrecognized MPC stream");  	}  	// Sample rate  	_frequency = _sampleRates [byteArray [10] & 0x03];  	// Channels  	if (_streamVersion == 7 || _streamVersion == 7.1m) {  		if ((byteArray [11] % 128) < 64)  			_mode = "Stereo";  		else  			_mode = "Joint Stereo";  	} else {  		if ((byteArray [2] % 128) == 0)  			_mode = "Stereo";  		else  			_mode = "Joint Stereo";  	}  	// Frames  	if (_streamVersion == 4)  		_frames = integerArray [1] >> 16;  	else  		_frames = integerArray [1];  	_totalSeconds = _frames * 1152 / (decimal)_frequency;  	_bitrate = (audioDataLength / _totalSeconds) / 125.0m;  }  
Magic Number,IdSharp.AudioInfo,Musepack,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Musepack\Musepack.cs,Musepack,The following statement contains a magic number: using (FileStream stream = File.Open (path' FileMode.Open' FileAccess.Read' FileShare.Read)) {  	// Skip ID3v2 tag  	int tmpID3v2TagSize = ID3v2.GetTagSize (stream);  	int tmpID3v1TagSize = ID3v1.GetTagSize (stream);  	int tmpAPEv2TagSize = APEv2.GetTagSize (stream);  	stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  	_streamVersion = 0;  	byte[] byteArray = stream.Read (32);  	int[] integerArray = new int[8];  	for (int i = 0; i < 8; i++)  		integerArray [i] = (byteArray [i * 4]) + (byteArray [i * 4 + 1] << 8) + (byteArray [i * 4 + 2] << 16) + (byteArray [i * 4 + 3] << 24);  	// Size TODO - ignore Lyrics3  	long audioDataLength = stream.Length - tmpID3v2TagSize - tmpID3v1TagSize - tmpAPEv2TagSize;  	// Stream version  	if (integerArray [0] == STREAM_VERSION_70_ID) {  		_streamVersion = 7;  	} else if (integerArray [0] == STREAM_VERSION_71_ID) {  		_streamVersion = 7.1m;  	} else {  		switch ((byteArray [1] % 32) / 2) {  		case 3:  			_streamVersion = 4;  			break;  		case 7:  			_streamVersion = 5;  			break;  		case 11:  			_streamVersion = 6;  			break;  		}  	}  	if (_streamVersion == 0) {  		throw new InvalidDataException ("Unrecognized MPC stream");  	}  	// Sample rate  	_frequency = _sampleRates [byteArray [10] & 0x03];  	// Channels  	if (_streamVersion == 7 || _streamVersion == 7.1m) {  		if ((byteArray [11] % 128) < 64)  			_mode = "Stereo";  		else  			_mode = "Joint Stereo";  	} else {  		if ((byteArray [2] % 128) == 0)  			_mode = "Stereo";  		else  			_mode = "Joint Stereo";  	}  	// Frames  	if (_streamVersion == 4)  		_frames = integerArray [1] >> 16;  	else  		_frames = integerArray [1];  	_totalSeconds = _frames * 1152 / (decimal)_frequency;  	_bitrate = (audioDataLength / _totalSeconds) / 125.0m;  }  
Magic Number,IdSharp.AudioInfo,Musepack,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Musepack\Musepack.cs,Musepack,The following statement contains a magic number: using (FileStream stream = File.Open (path' FileMode.Open' FileAccess.Read' FileShare.Read)) {  	// Skip ID3v2 tag  	int tmpID3v2TagSize = ID3v2.GetTagSize (stream);  	int tmpID3v1TagSize = ID3v1.GetTagSize (stream);  	int tmpAPEv2TagSize = APEv2.GetTagSize (stream);  	stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  	_streamVersion = 0;  	byte[] byteArray = stream.Read (32);  	int[] integerArray = new int[8];  	for (int i = 0; i < 8; i++)  		integerArray [i] = (byteArray [i * 4]) + (byteArray [i * 4 + 1] << 8) + (byteArray [i * 4 + 2] << 16) + (byteArray [i * 4 + 3] << 24);  	// Size TODO - ignore Lyrics3  	long audioDataLength = stream.Length - tmpID3v2TagSize - tmpID3v1TagSize - tmpAPEv2TagSize;  	// Stream version  	if (integerArray [0] == STREAM_VERSION_70_ID) {  		_streamVersion = 7;  	} else if (integerArray [0] == STREAM_VERSION_71_ID) {  		_streamVersion = 7.1m;  	} else {  		switch ((byteArray [1] % 32) / 2) {  		case 3:  			_streamVersion = 4;  			break;  		case 7:  			_streamVersion = 5;  			break;  		case 11:  			_streamVersion = 6;  			break;  		}  	}  	if (_streamVersion == 0) {  		throw new InvalidDataException ("Unrecognized MPC stream");  	}  	// Sample rate  	_frequency = _sampleRates [byteArray [10] & 0x03];  	// Channels  	if (_streamVersion == 7 || _streamVersion == 7.1m) {  		if ((byteArray [11] % 128) < 64)  			_mode = "Stereo";  		else  			_mode = "Joint Stereo";  	} else {  		if ((byteArray [2] % 128) == 0)  			_mode = "Stereo";  		else  			_mode = "Joint Stereo";  	}  	// Frames  	if (_streamVersion == 4)  		_frames = integerArray [1] >> 16;  	else  		_frames = integerArray [1];  	_totalSeconds = _frames * 1152 / (decimal)_frequency;  	_bitrate = (audioDataLength / _totalSeconds) / 125.0m;  }  
Magic Number,IdSharp.AudioInfo,Musepack,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Musepack\Musepack.cs,Musepack,The following statement contains a magic number: using (FileStream stream = File.Open (path' FileMode.Open' FileAccess.Read' FileShare.Read)) {  	// Skip ID3v2 tag  	int tmpID3v2TagSize = ID3v2.GetTagSize (stream);  	int tmpID3v1TagSize = ID3v1.GetTagSize (stream);  	int tmpAPEv2TagSize = APEv2.GetTagSize (stream);  	stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  	_streamVersion = 0;  	byte[] byteArray = stream.Read (32);  	int[] integerArray = new int[8];  	for (int i = 0; i < 8; i++)  		integerArray [i] = (byteArray [i * 4]) + (byteArray [i * 4 + 1] << 8) + (byteArray [i * 4 + 2] << 16) + (byteArray [i * 4 + 3] << 24);  	// Size TODO - ignore Lyrics3  	long audioDataLength = stream.Length - tmpID3v2TagSize - tmpID3v1TagSize - tmpAPEv2TagSize;  	// Stream version  	if (integerArray [0] == STREAM_VERSION_70_ID) {  		_streamVersion = 7;  	} else if (integerArray [0] == STREAM_VERSION_71_ID) {  		_streamVersion = 7.1m;  	} else {  		switch ((byteArray [1] % 32) / 2) {  		case 3:  			_streamVersion = 4;  			break;  		case 7:  			_streamVersion = 5;  			break;  		case 11:  			_streamVersion = 6;  			break;  		}  	}  	if (_streamVersion == 0) {  		throw new InvalidDataException ("Unrecognized MPC stream");  	}  	// Sample rate  	_frequency = _sampleRates [byteArray [10] & 0x03];  	// Channels  	if (_streamVersion == 7 || _streamVersion == 7.1m) {  		if ((byteArray [11] % 128) < 64)  			_mode = "Stereo";  		else  			_mode = "Joint Stereo";  	} else {  		if ((byteArray [2] % 128) == 0)  			_mode = "Stereo";  		else  			_mode = "Joint Stereo";  	}  	// Frames  	if (_streamVersion == 4)  		_frames = integerArray [1] >> 16;  	else  		_frames = integerArray [1];  	_totalSeconds = _frames * 1152 / (decimal)_frequency;  	_bitrate = (audioDataLength / _totalSeconds) / 125.0m;  }  
Magic Number,IdSharp.AudioInfo,Musepack,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Musepack\Musepack.cs,Musepack,The following statement contains a magic number: using (FileStream stream = File.Open (path' FileMode.Open' FileAccess.Read' FileShare.Read)) {  	// Skip ID3v2 tag  	int tmpID3v2TagSize = ID3v2.GetTagSize (stream);  	int tmpID3v1TagSize = ID3v1.GetTagSize (stream);  	int tmpAPEv2TagSize = APEv2.GetTagSize (stream);  	stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  	_streamVersion = 0;  	byte[] byteArray = stream.Read (32);  	int[] integerArray = new int[8];  	for (int i = 0; i < 8; i++)  		integerArray [i] = (byteArray [i * 4]) + (byteArray [i * 4 + 1] << 8) + (byteArray [i * 4 + 2] << 16) + (byteArray [i * 4 + 3] << 24);  	// Size TODO - ignore Lyrics3  	long audioDataLength = stream.Length - tmpID3v2TagSize - tmpID3v1TagSize - tmpAPEv2TagSize;  	// Stream version  	if (integerArray [0] == STREAM_VERSION_70_ID) {  		_streamVersion = 7;  	} else if (integerArray [0] == STREAM_VERSION_71_ID) {  		_streamVersion = 7.1m;  	} else {  		switch ((byteArray [1] % 32) / 2) {  		case 3:  			_streamVersion = 4;  			break;  		case 7:  			_streamVersion = 5;  			break;  		case 11:  			_streamVersion = 6;  			break;  		}  	}  	if (_streamVersion == 0) {  		throw new InvalidDataException ("Unrecognized MPC stream");  	}  	// Sample rate  	_frequency = _sampleRates [byteArray [10] & 0x03];  	// Channels  	if (_streamVersion == 7 || _streamVersion == 7.1m) {  		if ((byteArray [11] % 128) < 64)  			_mode = "Stereo";  		else  			_mode = "Joint Stereo";  	} else {  		if ((byteArray [2] % 128) == 0)  			_mode = "Stereo";  		else  			_mode = "Joint Stereo";  	}  	// Frames  	if (_streamVersion == 4)  		_frames = integerArray [1] >> 16;  	else  		_frames = integerArray [1];  	_totalSeconds = _frames * 1152 / (decimal)_frequency;  	_bitrate = (audioDataLength / _totalSeconds) / 125.0m;  }  
Magic Number,IdSharp.AudioInfo,Musepack,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Musepack\Musepack.cs,Musepack,The following statement contains a magic number: using (FileStream stream = File.Open (path' FileMode.Open' FileAccess.Read' FileShare.Read)) {  	// Skip ID3v2 tag  	int tmpID3v2TagSize = ID3v2.GetTagSize (stream);  	int tmpID3v1TagSize = ID3v1.GetTagSize (stream);  	int tmpAPEv2TagSize = APEv2.GetTagSize (stream);  	stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  	_streamVersion = 0;  	byte[] byteArray = stream.Read (32);  	int[] integerArray = new int[8];  	for (int i = 0; i < 8; i++)  		integerArray [i] = (byteArray [i * 4]) + (byteArray [i * 4 + 1] << 8) + (byteArray [i * 4 + 2] << 16) + (byteArray [i * 4 + 3] << 24);  	// Size TODO - ignore Lyrics3  	long audioDataLength = stream.Length - tmpID3v2TagSize - tmpID3v1TagSize - tmpAPEv2TagSize;  	// Stream version  	if (integerArray [0] == STREAM_VERSION_70_ID) {  		_streamVersion = 7;  	} else if (integerArray [0] == STREAM_VERSION_71_ID) {  		_streamVersion = 7.1m;  	} else {  		switch ((byteArray [1] % 32) / 2) {  		case 3:  			_streamVersion = 4;  			break;  		case 7:  			_streamVersion = 5;  			break;  		case 11:  			_streamVersion = 6;  			break;  		}  	}  	if (_streamVersion == 0) {  		throw new InvalidDataException ("Unrecognized MPC stream");  	}  	// Sample rate  	_frequency = _sampleRates [byteArray [10] & 0x03];  	// Channels  	if (_streamVersion == 7 || _streamVersion == 7.1m) {  		if ((byteArray [11] % 128) < 64)  			_mode = "Stereo";  		else  			_mode = "Joint Stereo";  	} else {  		if ((byteArray [2] % 128) == 0)  			_mode = "Stereo";  		else  			_mode = "Joint Stereo";  	}  	// Frames  	if (_streamVersion == 4)  		_frames = integerArray [1] >> 16;  	else  		_frames = integerArray [1];  	_totalSeconds = _frames * 1152 / (decimal)_frequency;  	_bitrate = (audioDataLength / _totalSeconds) / 125.0m;  }  
Magic Number,IdSharp.AudioInfo,Musepack,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Musepack\Musepack.cs,Musepack,The following statement contains a magic number: using (FileStream stream = File.Open (path' FileMode.Open' FileAccess.Read' FileShare.Read)) {  	// Skip ID3v2 tag  	int tmpID3v2TagSize = ID3v2.GetTagSize (stream);  	int tmpID3v1TagSize = ID3v1.GetTagSize (stream);  	int tmpAPEv2TagSize = APEv2.GetTagSize (stream);  	stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  	_streamVersion = 0;  	byte[] byteArray = stream.Read (32);  	int[] integerArray = new int[8];  	for (int i = 0; i < 8; i++)  		integerArray [i] = (byteArray [i * 4]) + (byteArray [i * 4 + 1] << 8) + (byteArray [i * 4 + 2] << 16) + (byteArray [i * 4 + 3] << 24);  	// Size TODO - ignore Lyrics3  	long audioDataLength = stream.Length - tmpID3v2TagSize - tmpID3v1TagSize - tmpAPEv2TagSize;  	// Stream version  	if (integerArray [0] == STREAM_VERSION_70_ID) {  		_streamVersion = 7;  	} else if (integerArray [0] == STREAM_VERSION_71_ID) {  		_streamVersion = 7.1m;  	} else {  		switch ((byteArray [1] % 32) / 2) {  		case 3:  			_streamVersion = 4;  			break;  		case 7:  			_streamVersion = 5;  			break;  		case 11:  			_streamVersion = 6;  			break;  		}  	}  	if (_streamVersion == 0) {  		throw new InvalidDataException ("Unrecognized MPC stream");  	}  	// Sample rate  	_frequency = _sampleRates [byteArray [10] & 0x03];  	// Channels  	if (_streamVersion == 7 || _streamVersion == 7.1m) {  		if ((byteArray [11] % 128) < 64)  			_mode = "Stereo";  		else  			_mode = "Joint Stereo";  	} else {  		if ((byteArray [2] % 128) == 0)  			_mode = "Stereo";  		else  			_mode = "Joint Stereo";  	}  	// Frames  	if (_streamVersion == 4)  		_frames = integerArray [1] >> 16;  	else  		_frames = integerArray [1];  	_totalSeconds = _frames * 1152 / (decimal)_frequency;  	_bitrate = (audioDataLength / _totalSeconds) / 125.0m;  }  
Magic Number,IdSharp.AudioInfo,Musepack,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Musepack\Musepack.cs,Musepack,The following statement contains a magic number: using (FileStream stream = File.Open (path' FileMode.Open' FileAccess.Read' FileShare.Read)) {  	// Skip ID3v2 tag  	int tmpID3v2TagSize = ID3v2.GetTagSize (stream);  	int tmpID3v1TagSize = ID3v1.GetTagSize (stream);  	int tmpAPEv2TagSize = APEv2.GetTagSize (stream);  	stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  	_streamVersion = 0;  	byte[] byteArray = stream.Read (32);  	int[] integerArray = new int[8];  	for (int i = 0; i < 8; i++)  		integerArray [i] = (byteArray [i * 4]) + (byteArray [i * 4 + 1] << 8) + (byteArray [i * 4 + 2] << 16) + (byteArray [i * 4 + 3] << 24);  	// Size TODO - ignore Lyrics3  	long audioDataLength = stream.Length - tmpID3v2TagSize - tmpID3v1TagSize - tmpAPEv2TagSize;  	// Stream version  	if (integerArray [0] == STREAM_VERSION_70_ID) {  		_streamVersion = 7;  	} else if (integerArray [0] == STREAM_VERSION_71_ID) {  		_streamVersion = 7.1m;  	} else {  		switch ((byteArray [1] % 32) / 2) {  		case 3:  			_streamVersion = 4;  			break;  		case 7:  			_streamVersion = 5;  			break;  		case 11:  			_streamVersion = 6;  			break;  		}  	}  	if (_streamVersion == 0) {  		throw new InvalidDataException ("Unrecognized MPC stream");  	}  	// Sample rate  	_frequency = _sampleRates [byteArray [10] & 0x03];  	// Channels  	if (_streamVersion == 7 || _streamVersion == 7.1m) {  		if ((byteArray [11] % 128) < 64)  			_mode = "Stereo";  		else  			_mode = "Joint Stereo";  	} else {  		if ((byteArray [2] % 128) == 0)  			_mode = "Stereo";  		else  			_mode = "Joint Stereo";  	}  	// Frames  	if (_streamVersion == 4)  		_frames = integerArray [1] >> 16;  	else  		_frames = integerArray [1];  	_totalSeconds = _frames * 1152 / (decimal)_frequency;  	_bitrate = (audioDataLength / _totalSeconds) / 125.0m;  }  
Magic Number,IdSharp.AudioInfo,Musepack,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Musepack\Musepack.cs,Musepack,The following statement contains a magic number: using (FileStream stream = File.Open (path' FileMode.Open' FileAccess.Read' FileShare.Read)) {  	// Skip ID3v2 tag  	int tmpID3v2TagSize = ID3v2.GetTagSize (stream);  	int tmpID3v1TagSize = ID3v1.GetTagSize (stream);  	int tmpAPEv2TagSize = APEv2.GetTagSize (stream);  	stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  	_streamVersion = 0;  	byte[] byteArray = stream.Read (32);  	int[] integerArray = new int[8];  	for (int i = 0; i < 8; i++)  		integerArray [i] = (byteArray [i * 4]) + (byteArray [i * 4 + 1] << 8) + (byteArray [i * 4 + 2] << 16) + (byteArray [i * 4 + 3] << 24);  	// Size TODO - ignore Lyrics3  	long audioDataLength = stream.Length - tmpID3v2TagSize - tmpID3v1TagSize - tmpAPEv2TagSize;  	// Stream version  	if (integerArray [0] == STREAM_VERSION_70_ID) {  		_streamVersion = 7;  	} else if (integerArray [0] == STREAM_VERSION_71_ID) {  		_streamVersion = 7.1m;  	} else {  		switch ((byteArray [1] % 32) / 2) {  		case 3:  			_streamVersion = 4;  			break;  		case 7:  			_streamVersion = 5;  			break;  		case 11:  			_streamVersion = 6;  			break;  		}  	}  	if (_streamVersion == 0) {  		throw new InvalidDataException ("Unrecognized MPC stream");  	}  	// Sample rate  	_frequency = _sampleRates [byteArray [10] & 0x03];  	// Channels  	if (_streamVersion == 7 || _streamVersion == 7.1m) {  		if ((byteArray [11] % 128) < 64)  			_mode = "Stereo";  		else  			_mode = "Joint Stereo";  	} else {  		if ((byteArray [2] % 128) == 0)  			_mode = "Stereo";  		else  			_mode = "Joint Stereo";  	}  	// Frames  	if (_streamVersion == 4)  		_frames = integerArray [1] >> 16;  	else  		_frames = integerArray [1];  	_totalSeconds = _frames * 1152 / (decimal)_frequency;  	_bitrate = (audioDataLength / _totalSeconds) / 125.0m;  }  
Magic Number,IdSharp.AudioInfo,Musepack,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Musepack\Musepack.cs,Musepack,The following statement contains a magic number: using (FileStream stream = File.Open (path' FileMode.Open' FileAccess.Read' FileShare.Read)) {  	// Skip ID3v2 tag  	int tmpID3v2TagSize = ID3v2.GetTagSize (stream);  	int tmpID3v1TagSize = ID3v1.GetTagSize (stream);  	int tmpAPEv2TagSize = APEv2.GetTagSize (stream);  	stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  	_streamVersion = 0;  	byte[] byteArray = stream.Read (32);  	int[] integerArray = new int[8];  	for (int i = 0; i < 8; i++)  		integerArray [i] = (byteArray [i * 4]) + (byteArray [i * 4 + 1] << 8) + (byteArray [i * 4 + 2] << 16) + (byteArray [i * 4 + 3] << 24);  	// Size TODO - ignore Lyrics3  	long audioDataLength = stream.Length - tmpID3v2TagSize - tmpID3v1TagSize - tmpAPEv2TagSize;  	// Stream version  	if (integerArray [0] == STREAM_VERSION_70_ID) {  		_streamVersion = 7;  	} else if (integerArray [0] == STREAM_VERSION_71_ID) {  		_streamVersion = 7.1m;  	} else {  		switch ((byteArray [1] % 32) / 2) {  		case 3:  			_streamVersion = 4;  			break;  		case 7:  			_streamVersion = 5;  			break;  		case 11:  			_streamVersion = 6;  			break;  		}  	}  	if (_streamVersion == 0) {  		throw new InvalidDataException ("Unrecognized MPC stream");  	}  	// Sample rate  	_frequency = _sampleRates [byteArray [10] & 0x03];  	// Channels  	if (_streamVersion == 7 || _streamVersion == 7.1m) {  		if ((byteArray [11] % 128) < 64)  			_mode = "Stereo";  		else  			_mode = "Joint Stereo";  	} else {  		if ((byteArray [2] % 128) == 0)  			_mode = "Stereo";  		else  			_mode = "Joint Stereo";  	}  	// Frames  	if (_streamVersion == 4)  		_frames = integerArray [1] >> 16;  	else  		_frames = integerArray [1];  	_totalSeconds = _frames * 1152 / (decimal)_frequency;  	_bitrate = (audioDataLength / _totalSeconds) / 125.0m;  }  
Magic Number,IdSharp.AudioInfo,Musepack,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Musepack\Musepack.cs,Musepack,The following statement contains a magic number: using (FileStream stream = File.Open (path' FileMode.Open' FileAccess.Read' FileShare.Read)) {  	// Skip ID3v2 tag  	int tmpID3v2TagSize = ID3v2.GetTagSize (stream);  	int tmpID3v1TagSize = ID3v1.GetTagSize (stream);  	int tmpAPEv2TagSize = APEv2.GetTagSize (stream);  	stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  	_streamVersion = 0;  	byte[] byteArray = stream.Read (32);  	int[] integerArray = new int[8];  	for (int i = 0; i < 8; i++)  		integerArray [i] = (byteArray [i * 4]) + (byteArray [i * 4 + 1] << 8) + (byteArray [i * 4 + 2] << 16) + (byteArray [i * 4 + 3] << 24);  	// Size TODO - ignore Lyrics3  	long audioDataLength = stream.Length - tmpID3v2TagSize - tmpID3v1TagSize - tmpAPEv2TagSize;  	// Stream version  	if (integerArray [0] == STREAM_VERSION_70_ID) {  		_streamVersion = 7;  	} else if (integerArray [0] == STREAM_VERSION_71_ID) {  		_streamVersion = 7.1m;  	} else {  		switch ((byteArray [1] % 32) / 2) {  		case 3:  			_streamVersion = 4;  			break;  		case 7:  			_streamVersion = 5;  			break;  		case 11:  			_streamVersion = 6;  			break;  		}  	}  	if (_streamVersion == 0) {  		throw new InvalidDataException ("Unrecognized MPC stream");  	}  	// Sample rate  	_frequency = _sampleRates [byteArray [10] & 0x03];  	// Channels  	if (_streamVersion == 7 || _streamVersion == 7.1m) {  		if ((byteArray [11] % 128) < 64)  			_mode = "Stereo";  		else  			_mode = "Joint Stereo";  	} else {  		if ((byteArray [2] % 128) == 0)  			_mode = "Stereo";  		else  			_mode = "Joint Stereo";  	}  	// Frames  	if (_streamVersion == 4)  		_frames = integerArray [1] >> 16;  	else  		_frames = integerArray [1];  	_totalSeconds = _frames * 1152 / (decimal)_frequency;  	_bitrate = (audioDataLength / _totalSeconds) / 125.0m;  }  
Magic Number,IdSharp.AudioInfo,Musepack,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Musepack\Musepack.cs,Musepack,The following statement contains a magic number: using (FileStream stream = File.Open (path' FileMode.Open' FileAccess.Read' FileShare.Read)) {  	// Skip ID3v2 tag  	int tmpID3v2TagSize = ID3v2.GetTagSize (stream);  	int tmpID3v1TagSize = ID3v1.GetTagSize (stream);  	int tmpAPEv2TagSize = APEv2.GetTagSize (stream);  	stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  	_streamVersion = 0;  	byte[] byteArray = stream.Read (32);  	int[] integerArray = new int[8];  	for (int i = 0; i < 8; i++)  		integerArray [i] = (byteArray [i * 4]) + (byteArray [i * 4 + 1] << 8) + (byteArray [i * 4 + 2] << 16) + (byteArray [i * 4 + 3] << 24);  	// Size TODO - ignore Lyrics3  	long audioDataLength = stream.Length - tmpID3v2TagSize - tmpID3v1TagSize - tmpAPEv2TagSize;  	// Stream version  	if (integerArray [0] == STREAM_VERSION_70_ID) {  		_streamVersion = 7;  	} else if (integerArray [0] == STREAM_VERSION_71_ID) {  		_streamVersion = 7.1m;  	} else {  		switch ((byteArray [1] % 32) / 2) {  		case 3:  			_streamVersion = 4;  			break;  		case 7:  			_streamVersion = 5;  			break;  		case 11:  			_streamVersion = 6;  			break;  		}  	}  	if (_streamVersion == 0) {  		throw new InvalidDataException ("Unrecognized MPC stream");  	}  	// Sample rate  	_frequency = _sampleRates [byteArray [10] & 0x03];  	// Channels  	if (_streamVersion == 7 || _streamVersion == 7.1m) {  		if ((byteArray [11] % 128) < 64)  			_mode = "Stereo";  		else  			_mode = "Joint Stereo";  	} else {  		if ((byteArray [2] % 128) == 0)  			_mode = "Stereo";  		else  			_mode = "Joint Stereo";  	}  	// Frames  	if (_streamVersion == 4)  		_frames = integerArray [1] >> 16;  	else  		_frames = integerArray [1];  	_totalSeconds = _frames * 1152 / (decimal)_frequency;  	_bitrate = (audioDataLength / _totalSeconds) / 125.0m;  }  
Magic Number,IdSharp.AudioInfo,Musepack,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Musepack\Musepack.cs,Musepack,The following statement contains a magic number: using (FileStream stream = File.Open (path' FileMode.Open' FileAccess.Read' FileShare.Read)) {  	// Skip ID3v2 tag  	int tmpID3v2TagSize = ID3v2.GetTagSize (stream);  	int tmpID3v1TagSize = ID3v1.GetTagSize (stream);  	int tmpAPEv2TagSize = APEv2.GetTagSize (stream);  	stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  	_streamVersion = 0;  	byte[] byteArray = stream.Read (32);  	int[] integerArray = new int[8];  	for (int i = 0; i < 8; i++)  		integerArray [i] = (byteArray [i * 4]) + (byteArray [i * 4 + 1] << 8) + (byteArray [i * 4 + 2] << 16) + (byteArray [i * 4 + 3] << 24);  	// Size TODO - ignore Lyrics3  	long audioDataLength = stream.Length - tmpID3v2TagSize - tmpID3v1TagSize - tmpAPEv2TagSize;  	// Stream version  	if (integerArray [0] == STREAM_VERSION_70_ID) {  		_streamVersion = 7;  	} else if (integerArray [0] == STREAM_VERSION_71_ID) {  		_streamVersion = 7.1m;  	} else {  		switch ((byteArray [1] % 32) / 2) {  		case 3:  			_streamVersion = 4;  			break;  		case 7:  			_streamVersion = 5;  			break;  		case 11:  			_streamVersion = 6;  			break;  		}  	}  	if (_streamVersion == 0) {  		throw new InvalidDataException ("Unrecognized MPC stream");  	}  	// Sample rate  	_frequency = _sampleRates [byteArray [10] & 0x03];  	// Channels  	if (_streamVersion == 7 || _streamVersion == 7.1m) {  		if ((byteArray [11] % 128) < 64)  			_mode = "Stereo";  		else  			_mode = "Joint Stereo";  	} else {  		if ((byteArray [2] % 128) == 0)  			_mode = "Stereo";  		else  			_mode = "Joint Stereo";  	}  	// Frames  	if (_streamVersion == 4)  		_frames = integerArray [1] >> 16;  	else  		_frames = integerArray [1];  	_totalSeconds = _frames * 1152 / (decimal)_frequency;  	_bitrate = (audioDataLength / _totalSeconds) / 125.0m;  }  
Magic Number,IdSharp.AudioInfo,Musepack,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Musepack\Musepack.cs,Musepack,The following statement contains a magic number: using (FileStream stream = File.Open (path' FileMode.Open' FileAccess.Read' FileShare.Read)) {  	// Skip ID3v2 tag  	int tmpID3v2TagSize = ID3v2.GetTagSize (stream);  	int tmpID3v1TagSize = ID3v1.GetTagSize (stream);  	int tmpAPEv2TagSize = APEv2.GetTagSize (stream);  	stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  	_streamVersion = 0;  	byte[] byteArray = stream.Read (32);  	int[] integerArray = new int[8];  	for (int i = 0; i < 8; i++)  		integerArray [i] = (byteArray [i * 4]) + (byteArray [i * 4 + 1] << 8) + (byteArray [i * 4 + 2] << 16) + (byteArray [i * 4 + 3] << 24);  	// Size TODO - ignore Lyrics3  	long audioDataLength = stream.Length - tmpID3v2TagSize - tmpID3v1TagSize - tmpAPEv2TagSize;  	// Stream version  	if (integerArray [0] == STREAM_VERSION_70_ID) {  		_streamVersion = 7;  	} else if (integerArray [0] == STREAM_VERSION_71_ID) {  		_streamVersion = 7.1m;  	} else {  		switch ((byteArray [1] % 32) / 2) {  		case 3:  			_streamVersion = 4;  			break;  		case 7:  			_streamVersion = 5;  			break;  		case 11:  			_streamVersion = 6;  			break;  		}  	}  	if (_streamVersion == 0) {  		throw new InvalidDataException ("Unrecognized MPC stream");  	}  	// Sample rate  	_frequency = _sampleRates [byteArray [10] & 0x03];  	// Channels  	if (_streamVersion == 7 || _streamVersion == 7.1m) {  		if ((byteArray [11] % 128) < 64)  			_mode = "Stereo";  		else  			_mode = "Joint Stereo";  	} else {  		if ((byteArray [2] % 128) == 0)  			_mode = "Stereo";  		else  			_mode = "Joint Stereo";  	}  	// Frames  	if (_streamVersion == 4)  		_frames = integerArray [1] >> 16;  	else  		_frames = integerArray [1];  	_totalSeconds = _frames * 1152 / (decimal)_frequency;  	_bitrate = (audioDataLength / _totalSeconds) / 125.0m;  }  
Magic Number,IdSharp.AudioInfo,Musepack,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Musepack\Musepack.cs,Musepack,The following statement contains a magic number: using (FileStream stream = File.Open (path' FileMode.Open' FileAccess.Read' FileShare.Read)) {  	// Skip ID3v2 tag  	int tmpID3v2TagSize = ID3v2.GetTagSize (stream);  	int tmpID3v1TagSize = ID3v1.GetTagSize (stream);  	int tmpAPEv2TagSize = APEv2.GetTagSize (stream);  	stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  	_streamVersion = 0;  	byte[] byteArray = stream.Read (32);  	int[] integerArray = new int[8];  	for (int i = 0; i < 8; i++)  		integerArray [i] = (byteArray [i * 4]) + (byteArray [i * 4 + 1] << 8) + (byteArray [i * 4 + 2] << 16) + (byteArray [i * 4 + 3] << 24);  	// Size TODO - ignore Lyrics3  	long audioDataLength = stream.Length - tmpID3v2TagSize - tmpID3v1TagSize - tmpAPEv2TagSize;  	// Stream version  	if (integerArray [0] == STREAM_VERSION_70_ID) {  		_streamVersion = 7;  	} else if (integerArray [0] == STREAM_VERSION_71_ID) {  		_streamVersion = 7.1m;  	} else {  		switch ((byteArray [1] % 32) / 2) {  		case 3:  			_streamVersion = 4;  			break;  		case 7:  			_streamVersion = 5;  			break;  		case 11:  			_streamVersion = 6;  			break;  		}  	}  	if (_streamVersion == 0) {  		throw new InvalidDataException ("Unrecognized MPC stream");  	}  	// Sample rate  	_frequency = _sampleRates [byteArray [10] & 0x03];  	// Channels  	if (_streamVersion == 7 || _streamVersion == 7.1m) {  		if ((byteArray [11] % 128) < 64)  			_mode = "Stereo";  		else  			_mode = "Joint Stereo";  	} else {  		if ((byteArray [2] % 128) == 0)  			_mode = "Stereo";  		else  			_mode = "Joint Stereo";  	}  	// Frames  	if (_streamVersion == 4)  		_frames = integerArray [1] >> 16;  	else  		_frames = integerArray [1];  	_totalSeconds = _frames * 1152 / (decimal)_frequency;  	_bitrate = (audioDataLength / _totalSeconds) / 125.0m;  }  
Magic Number,IdSharp.AudioInfo,Musepack,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Musepack\Musepack.cs,Musepack,The following statement contains a magic number: using (FileStream stream = File.Open (path' FileMode.Open' FileAccess.Read' FileShare.Read)) {  	// Skip ID3v2 tag  	int tmpID3v2TagSize = ID3v2.GetTagSize (stream);  	int tmpID3v1TagSize = ID3v1.GetTagSize (stream);  	int tmpAPEv2TagSize = APEv2.GetTagSize (stream);  	stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  	_streamVersion = 0;  	byte[] byteArray = stream.Read (32);  	int[] integerArray = new int[8];  	for (int i = 0; i < 8; i++)  		integerArray [i] = (byteArray [i * 4]) + (byteArray [i * 4 + 1] << 8) + (byteArray [i * 4 + 2] << 16) + (byteArray [i * 4 + 3] << 24);  	// Size TODO - ignore Lyrics3  	long audioDataLength = stream.Length - tmpID3v2TagSize - tmpID3v1TagSize - tmpAPEv2TagSize;  	// Stream version  	if (integerArray [0] == STREAM_VERSION_70_ID) {  		_streamVersion = 7;  	} else if (integerArray [0] == STREAM_VERSION_71_ID) {  		_streamVersion = 7.1m;  	} else {  		switch ((byteArray [1] % 32) / 2) {  		case 3:  			_streamVersion = 4;  			break;  		case 7:  			_streamVersion = 5;  			break;  		case 11:  			_streamVersion = 6;  			break;  		}  	}  	if (_streamVersion == 0) {  		throw new InvalidDataException ("Unrecognized MPC stream");  	}  	// Sample rate  	_frequency = _sampleRates [byteArray [10] & 0x03];  	// Channels  	if (_streamVersion == 7 || _streamVersion == 7.1m) {  		if ((byteArray [11] % 128) < 64)  			_mode = "Stereo";  		else  			_mode = "Joint Stereo";  	} else {  		if ((byteArray [2] % 128) == 0)  			_mode = "Stereo";  		else  			_mode = "Joint Stereo";  	}  	// Frames  	if (_streamVersion == 4)  		_frames = integerArray [1] >> 16;  	else  		_frames = integerArray [1];  	_totalSeconds = _frames * 1152 / (decimal)_frequency;  	_bitrate = (audioDataLength / _totalSeconds) / 125.0m;  }  
Magic Number,IdSharp.AudioInfo,Musepack,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Musepack\Musepack.cs,Musepack,The following statement contains a magic number: using (FileStream stream = File.Open (path' FileMode.Open' FileAccess.Read' FileShare.Read)) {  	// Skip ID3v2 tag  	int tmpID3v2TagSize = ID3v2.GetTagSize (stream);  	int tmpID3v1TagSize = ID3v1.GetTagSize (stream);  	int tmpAPEv2TagSize = APEv2.GetTagSize (stream);  	stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  	_streamVersion = 0;  	byte[] byteArray = stream.Read (32);  	int[] integerArray = new int[8];  	for (int i = 0; i < 8; i++)  		integerArray [i] = (byteArray [i * 4]) + (byteArray [i * 4 + 1] << 8) + (byteArray [i * 4 + 2] << 16) + (byteArray [i * 4 + 3] << 24);  	// Size TODO - ignore Lyrics3  	long audioDataLength = stream.Length - tmpID3v2TagSize - tmpID3v1TagSize - tmpAPEv2TagSize;  	// Stream version  	if (integerArray [0] == STREAM_VERSION_70_ID) {  		_streamVersion = 7;  	} else if (integerArray [0] == STREAM_VERSION_71_ID) {  		_streamVersion = 7.1m;  	} else {  		switch ((byteArray [1] % 32) / 2) {  		case 3:  			_streamVersion = 4;  			break;  		case 7:  			_streamVersion = 5;  			break;  		case 11:  			_streamVersion = 6;  			break;  		}  	}  	if (_streamVersion == 0) {  		throw new InvalidDataException ("Unrecognized MPC stream");  	}  	// Sample rate  	_frequency = _sampleRates [byteArray [10] & 0x03];  	// Channels  	if (_streamVersion == 7 || _streamVersion == 7.1m) {  		if ((byteArray [11] % 128) < 64)  			_mode = "Stereo";  		else  			_mode = "Joint Stereo";  	} else {  		if ((byteArray [2] % 128) == 0)  			_mode = "Stereo";  		else  			_mode = "Joint Stereo";  	}  	// Frames  	if (_streamVersion == 4)  		_frames = integerArray [1] >> 16;  	else  		_frames = integerArray [1];  	_totalSeconds = _frames * 1152 / (decimal)_frequency;  	_bitrate = (audioDataLength / _totalSeconds) / 125.0m;  }  
Magic Number,IdSharp.AudioInfo,Musepack,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Musepack\Musepack.cs,Musepack,The following statement contains a magic number: using (FileStream stream = File.Open (path' FileMode.Open' FileAccess.Read' FileShare.Read)) {  	// Skip ID3v2 tag  	int tmpID3v2TagSize = ID3v2.GetTagSize (stream);  	int tmpID3v1TagSize = ID3v1.GetTagSize (stream);  	int tmpAPEv2TagSize = APEv2.GetTagSize (stream);  	stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  	_streamVersion = 0;  	byte[] byteArray = stream.Read (32);  	int[] integerArray = new int[8];  	for (int i = 0; i < 8; i++)  		integerArray [i] = (byteArray [i * 4]) + (byteArray [i * 4 + 1] << 8) + (byteArray [i * 4 + 2] << 16) + (byteArray [i * 4 + 3] << 24);  	// Size TODO - ignore Lyrics3  	long audioDataLength = stream.Length - tmpID3v2TagSize - tmpID3v1TagSize - tmpAPEv2TagSize;  	// Stream version  	if (integerArray [0] == STREAM_VERSION_70_ID) {  		_streamVersion = 7;  	} else if (integerArray [0] == STREAM_VERSION_71_ID) {  		_streamVersion = 7.1m;  	} else {  		switch ((byteArray [1] % 32) / 2) {  		case 3:  			_streamVersion = 4;  			break;  		case 7:  			_streamVersion = 5;  			break;  		case 11:  			_streamVersion = 6;  			break;  		}  	}  	if (_streamVersion == 0) {  		throw new InvalidDataException ("Unrecognized MPC stream");  	}  	// Sample rate  	_frequency = _sampleRates [byteArray [10] & 0x03];  	// Channels  	if (_streamVersion == 7 || _streamVersion == 7.1m) {  		if ((byteArray [11] % 128) < 64)  			_mode = "Stereo";  		else  			_mode = "Joint Stereo";  	} else {  		if ((byteArray [2] % 128) == 0)  			_mode = "Stereo";  		else  			_mode = "Joint Stereo";  	}  	// Frames  	if (_streamVersion == 4)  		_frames = integerArray [1] >> 16;  	else  		_frames = integerArray [1];  	_totalSeconds = _frames * 1152 / (decimal)_frequency;  	_bitrate = (audioDataLength / _totalSeconds) / 125.0m;  }  
Magic Number,IdSharp.AudioInfo,Musepack,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Musepack\Musepack.cs,Musepack,The following statement contains a magic number: using (FileStream stream = File.Open (path' FileMode.Open' FileAccess.Read' FileShare.Read)) {  	// Skip ID3v2 tag  	int tmpID3v2TagSize = ID3v2.GetTagSize (stream);  	int tmpID3v1TagSize = ID3v1.GetTagSize (stream);  	int tmpAPEv2TagSize = APEv2.GetTagSize (stream);  	stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  	_streamVersion = 0;  	byte[] byteArray = stream.Read (32);  	int[] integerArray = new int[8];  	for (int i = 0; i < 8; i++)  		integerArray [i] = (byteArray [i * 4]) + (byteArray [i * 4 + 1] << 8) + (byteArray [i * 4 + 2] << 16) + (byteArray [i * 4 + 3] << 24);  	// Size TODO - ignore Lyrics3  	long audioDataLength = stream.Length - tmpID3v2TagSize - tmpID3v1TagSize - tmpAPEv2TagSize;  	// Stream version  	if (integerArray [0] == STREAM_VERSION_70_ID) {  		_streamVersion = 7;  	} else if (integerArray [0] == STREAM_VERSION_71_ID) {  		_streamVersion = 7.1m;  	} else {  		switch ((byteArray [1] % 32) / 2) {  		case 3:  			_streamVersion = 4;  			break;  		case 7:  			_streamVersion = 5;  			break;  		case 11:  			_streamVersion = 6;  			break;  		}  	}  	if (_streamVersion == 0) {  		throw new InvalidDataException ("Unrecognized MPC stream");  	}  	// Sample rate  	_frequency = _sampleRates [byteArray [10] & 0x03];  	// Channels  	if (_streamVersion == 7 || _streamVersion == 7.1m) {  		if ((byteArray [11] % 128) < 64)  			_mode = "Stereo";  		else  			_mode = "Joint Stereo";  	} else {  		if ((byteArray [2] % 128) == 0)  			_mode = "Stereo";  		else  			_mode = "Joint Stereo";  	}  	// Frames  	if (_streamVersion == 4)  		_frames = integerArray [1] >> 16;  	else  		_frames = integerArray [1];  	_totalSeconds = _frames * 1152 / (decimal)_frequency;  	_bitrate = (audioDataLength / _totalSeconds) / 125.0m;  }  
Magic Number,IdSharp.AudioInfo,Musepack,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Musepack\Musepack.cs,Musepack,The following statement contains a magic number: using (FileStream stream = File.Open (path' FileMode.Open' FileAccess.Read' FileShare.Read)) {  	// Skip ID3v2 tag  	int tmpID3v2TagSize = ID3v2.GetTagSize (stream);  	int tmpID3v1TagSize = ID3v1.GetTagSize (stream);  	int tmpAPEv2TagSize = APEv2.GetTagSize (stream);  	stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  	_streamVersion = 0;  	byte[] byteArray = stream.Read (32);  	int[] integerArray = new int[8];  	for (int i = 0; i < 8; i++)  		integerArray [i] = (byteArray [i * 4]) + (byteArray [i * 4 + 1] << 8) + (byteArray [i * 4 + 2] << 16) + (byteArray [i * 4 + 3] << 24);  	// Size TODO - ignore Lyrics3  	long audioDataLength = stream.Length - tmpID3v2TagSize - tmpID3v1TagSize - tmpAPEv2TagSize;  	// Stream version  	if (integerArray [0] == STREAM_VERSION_70_ID) {  		_streamVersion = 7;  	} else if (integerArray [0] == STREAM_VERSION_71_ID) {  		_streamVersion = 7.1m;  	} else {  		switch ((byteArray [1] % 32) / 2) {  		case 3:  			_streamVersion = 4;  			break;  		case 7:  			_streamVersion = 5;  			break;  		case 11:  			_streamVersion = 6;  			break;  		}  	}  	if (_streamVersion == 0) {  		throw new InvalidDataException ("Unrecognized MPC stream");  	}  	// Sample rate  	_frequency = _sampleRates [byteArray [10] & 0x03];  	// Channels  	if (_streamVersion == 7 || _streamVersion == 7.1m) {  		if ((byteArray [11] % 128) < 64)  			_mode = "Stereo";  		else  			_mode = "Joint Stereo";  	} else {  		if ((byteArray [2] % 128) == 0)  			_mode = "Stereo";  		else  			_mode = "Joint Stereo";  	}  	// Frames  	if (_streamVersion == 4)  		_frames = integerArray [1] >> 16;  	else  		_frames = integerArray [1];  	_totalSeconds = _frames * 1152 / (decimal)_frequency;  	_bitrate = (audioDataLength / _totalSeconds) / 125.0m;  }  
Magic Number,IdSharp.AudioInfo,Musepack,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Musepack\Musepack.cs,Musepack,The following statement contains a magic number: using (FileStream stream = File.Open (path' FileMode.Open' FileAccess.Read' FileShare.Read)) {  	// Skip ID3v2 tag  	int tmpID3v2TagSize = ID3v2.GetTagSize (stream);  	int tmpID3v1TagSize = ID3v1.GetTagSize (stream);  	int tmpAPEv2TagSize = APEv2.GetTagSize (stream);  	stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  	_streamVersion = 0;  	byte[] byteArray = stream.Read (32);  	int[] integerArray = new int[8];  	for (int i = 0; i < 8; i++)  		integerArray [i] = (byteArray [i * 4]) + (byteArray [i * 4 + 1] << 8) + (byteArray [i * 4 + 2] << 16) + (byteArray [i * 4 + 3] << 24);  	// Size TODO - ignore Lyrics3  	long audioDataLength = stream.Length - tmpID3v2TagSize - tmpID3v1TagSize - tmpAPEv2TagSize;  	// Stream version  	if (integerArray [0] == STREAM_VERSION_70_ID) {  		_streamVersion = 7;  	} else if (integerArray [0] == STREAM_VERSION_71_ID) {  		_streamVersion = 7.1m;  	} else {  		switch ((byteArray [1] % 32) / 2) {  		case 3:  			_streamVersion = 4;  			break;  		case 7:  			_streamVersion = 5;  			break;  		case 11:  			_streamVersion = 6;  			break;  		}  	}  	if (_streamVersion == 0) {  		throw new InvalidDataException ("Unrecognized MPC stream");  	}  	// Sample rate  	_frequency = _sampleRates [byteArray [10] & 0x03];  	// Channels  	if (_streamVersion == 7 || _streamVersion == 7.1m) {  		if ((byteArray [11] % 128) < 64)  			_mode = "Stereo";  		else  			_mode = "Joint Stereo";  	} else {  		if ((byteArray [2] % 128) == 0)  			_mode = "Stereo";  		else  			_mode = "Joint Stereo";  	}  	// Frames  	if (_streamVersion == 4)  		_frames = integerArray [1] >> 16;  	else  		_frames = integerArray [1];  	_totalSeconds = _frames * 1152 / (decimal)_frequency;  	_bitrate = (audioDataLength / _totalSeconds) / 125.0m;  }  
Magic Number,IdSharp.AudioInfo,Musepack,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Musepack\Musepack.cs,Musepack,The following statement contains a magic number: using (FileStream stream = File.Open (path' FileMode.Open' FileAccess.Read' FileShare.Read)) {  	// Skip ID3v2 tag  	int tmpID3v2TagSize = ID3v2.GetTagSize (stream);  	int tmpID3v1TagSize = ID3v1.GetTagSize (stream);  	int tmpAPEv2TagSize = APEv2.GetTagSize (stream);  	stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  	_streamVersion = 0;  	byte[] byteArray = stream.Read (32);  	int[] integerArray = new int[8];  	for (int i = 0; i < 8; i++)  		integerArray [i] = (byteArray [i * 4]) + (byteArray [i * 4 + 1] << 8) + (byteArray [i * 4 + 2] << 16) + (byteArray [i * 4 + 3] << 24);  	// Size TODO - ignore Lyrics3  	long audioDataLength = stream.Length - tmpID3v2TagSize - tmpID3v1TagSize - tmpAPEv2TagSize;  	// Stream version  	if (integerArray [0] == STREAM_VERSION_70_ID) {  		_streamVersion = 7;  	} else if (integerArray [0] == STREAM_VERSION_71_ID) {  		_streamVersion = 7.1m;  	} else {  		switch ((byteArray [1] % 32) / 2) {  		case 3:  			_streamVersion = 4;  			break;  		case 7:  			_streamVersion = 5;  			break;  		case 11:  			_streamVersion = 6;  			break;  		}  	}  	if (_streamVersion == 0) {  		throw new InvalidDataException ("Unrecognized MPC stream");  	}  	// Sample rate  	_frequency = _sampleRates [byteArray [10] & 0x03];  	// Channels  	if (_streamVersion == 7 || _streamVersion == 7.1m) {  		if ((byteArray [11] % 128) < 64)  			_mode = "Stereo";  		else  			_mode = "Joint Stereo";  	} else {  		if ((byteArray [2] % 128) == 0)  			_mode = "Stereo";  		else  			_mode = "Joint Stereo";  	}  	// Frames  	if (_streamVersion == 4)  		_frames = integerArray [1] >> 16;  	else  		_frames = integerArray [1];  	_totalSeconds = _frames * 1152 / (decimal)_frequency;  	_bitrate = (audioDataLength / _totalSeconds) / 125.0m;  }  
Magic Number,IdSharp.AudioInfo,Musepack,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Musepack\Musepack.cs,Musepack,The following statement contains a magic number: using (FileStream stream = File.Open (path' FileMode.Open' FileAccess.Read' FileShare.Read)) {  	// Skip ID3v2 tag  	int tmpID3v2TagSize = ID3v2.GetTagSize (stream);  	int tmpID3v1TagSize = ID3v1.GetTagSize (stream);  	int tmpAPEv2TagSize = APEv2.GetTagSize (stream);  	stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  	_streamVersion = 0;  	byte[] byteArray = stream.Read (32);  	int[] integerArray = new int[8];  	for (int i = 0; i < 8; i++)  		integerArray [i] = (byteArray [i * 4]) + (byteArray [i * 4 + 1] << 8) + (byteArray [i * 4 + 2] << 16) + (byteArray [i * 4 + 3] << 24);  	// Size TODO - ignore Lyrics3  	long audioDataLength = stream.Length - tmpID3v2TagSize - tmpID3v1TagSize - tmpAPEv2TagSize;  	// Stream version  	if (integerArray [0] == STREAM_VERSION_70_ID) {  		_streamVersion = 7;  	} else if (integerArray [0] == STREAM_VERSION_71_ID) {  		_streamVersion = 7.1m;  	} else {  		switch ((byteArray [1] % 32) / 2) {  		case 3:  			_streamVersion = 4;  			break;  		case 7:  			_streamVersion = 5;  			break;  		case 11:  			_streamVersion = 6;  			break;  		}  	}  	if (_streamVersion == 0) {  		throw new InvalidDataException ("Unrecognized MPC stream");  	}  	// Sample rate  	_frequency = _sampleRates [byteArray [10] & 0x03];  	// Channels  	if (_streamVersion == 7 || _streamVersion == 7.1m) {  		if ((byteArray [11] % 128) < 64)  			_mode = "Stereo";  		else  			_mode = "Joint Stereo";  	} else {  		if ((byteArray [2] % 128) == 0)  			_mode = "Stereo";  		else  			_mode = "Joint Stereo";  	}  	// Frames  	if (_streamVersion == 4)  		_frames = integerArray [1] >> 16;  	else  		_frames = integerArray [1];  	_totalSeconds = _frames * 1152 / (decimal)_frequency;  	_bitrate = (audioDataLength / _totalSeconds) / 125.0m;  }  
Magic Number,IdSharp.AudioInfo,Musepack,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Musepack\Musepack.cs,Musepack,The following statement contains a magic number: using (FileStream stream = File.Open (path' FileMode.Open' FileAccess.Read' FileShare.Read)) {  	// Skip ID3v2 tag  	int tmpID3v2TagSize = ID3v2.GetTagSize (stream);  	int tmpID3v1TagSize = ID3v1.GetTagSize (stream);  	int tmpAPEv2TagSize = APEv2.GetTagSize (stream);  	stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  	_streamVersion = 0;  	byte[] byteArray = stream.Read (32);  	int[] integerArray = new int[8];  	for (int i = 0; i < 8; i++)  		integerArray [i] = (byteArray [i * 4]) + (byteArray [i * 4 + 1] << 8) + (byteArray [i * 4 + 2] << 16) + (byteArray [i * 4 + 3] << 24);  	// Size TODO - ignore Lyrics3  	long audioDataLength = stream.Length - tmpID3v2TagSize - tmpID3v1TagSize - tmpAPEv2TagSize;  	// Stream version  	if (integerArray [0] == STREAM_VERSION_70_ID) {  		_streamVersion = 7;  	} else if (integerArray [0] == STREAM_VERSION_71_ID) {  		_streamVersion = 7.1m;  	} else {  		switch ((byteArray [1] % 32) / 2) {  		case 3:  			_streamVersion = 4;  			break;  		case 7:  			_streamVersion = 5;  			break;  		case 11:  			_streamVersion = 6;  			break;  		}  	}  	if (_streamVersion == 0) {  		throw new InvalidDataException ("Unrecognized MPC stream");  	}  	// Sample rate  	_frequency = _sampleRates [byteArray [10] & 0x03];  	// Channels  	if (_streamVersion == 7 || _streamVersion == 7.1m) {  		if ((byteArray [11] % 128) < 64)  			_mode = "Stereo";  		else  			_mode = "Joint Stereo";  	} else {  		if ((byteArray [2] % 128) == 0)  			_mode = "Stereo";  		else  			_mode = "Joint Stereo";  	}  	// Frames  	if (_streamVersion == 4)  		_frames = integerArray [1] >> 16;  	else  		_frames = integerArray [1];  	_totalSeconds = _frames * 1152 / (decimal)_frequency;  	_bitrate = (audioDataLength / _totalSeconds) / 125.0m;  }  
Magic Number,IdSharp.AudioInfo,Musepack,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Musepack\Musepack.cs,Musepack,The following statement contains a magic number: using (FileStream stream = File.Open (path' FileMode.Open' FileAccess.Read' FileShare.Read)) {  	// Skip ID3v2 tag  	int tmpID3v2TagSize = ID3v2.GetTagSize (stream);  	int tmpID3v1TagSize = ID3v1.GetTagSize (stream);  	int tmpAPEv2TagSize = APEv2.GetTagSize (stream);  	stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  	_streamVersion = 0;  	byte[] byteArray = stream.Read (32);  	int[] integerArray = new int[8];  	for (int i = 0; i < 8; i++)  		integerArray [i] = (byteArray [i * 4]) + (byteArray [i * 4 + 1] << 8) + (byteArray [i * 4 + 2] << 16) + (byteArray [i * 4 + 3] << 24);  	// Size TODO - ignore Lyrics3  	long audioDataLength = stream.Length - tmpID3v2TagSize - tmpID3v1TagSize - tmpAPEv2TagSize;  	// Stream version  	if (integerArray [0] == STREAM_VERSION_70_ID) {  		_streamVersion = 7;  	} else if (integerArray [0] == STREAM_VERSION_71_ID) {  		_streamVersion = 7.1m;  	} else {  		switch ((byteArray [1] % 32) / 2) {  		case 3:  			_streamVersion = 4;  			break;  		case 7:  			_streamVersion = 5;  			break;  		case 11:  			_streamVersion = 6;  			break;  		}  	}  	if (_streamVersion == 0) {  		throw new InvalidDataException ("Unrecognized MPC stream");  	}  	// Sample rate  	_frequency = _sampleRates [byteArray [10] & 0x03];  	// Channels  	if (_streamVersion == 7 || _streamVersion == 7.1m) {  		if ((byteArray [11] % 128) < 64)  			_mode = "Stereo";  		else  			_mode = "Joint Stereo";  	} else {  		if ((byteArray [2] % 128) == 0)  			_mode = "Stereo";  		else  			_mode = "Joint Stereo";  	}  	// Frames  	if (_streamVersion == 4)  		_frames = integerArray [1] >> 16;  	else  		_frames = integerArray [1];  	_totalSeconds = _frames * 1152 / (decimal)_frequency;  	_bitrate = (audioDataLength / _totalSeconds) / 125.0m;  }  
Magic Number,IdSharp.AudioInfo,Musepack,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Musepack\Musepack.cs,Musepack,The following statement contains a magic number: using (FileStream stream = File.Open (path' FileMode.Open' FileAccess.Read' FileShare.Read)) {  	// Skip ID3v2 tag  	int tmpID3v2TagSize = ID3v2.GetTagSize (stream);  	int tmpID3v1TagSize = ID3v1.GetTagSize (stream);  	int tmpAPEv2TagSize = APEv2.GetTagSize (stream);  	stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  	_streamVersion = 0;  	byte[] byteArray = stream.Read (32);  	int[] integerArray = new int[8];  	for (int i = 0; i < 8; i++)  		integerArray [i] = (byteArray [i * 4]) + (byteArray [i * 4 + 1] << 8) + (byteArray [i * 4 + 2] << 16) + (byteArray [i * 4 + 3] << 24);  	// Size TODO - ignore Lyrics3  	long audioDataLength = stream.Length - tmpID3v2TagSize - tmpID3v1TagSize - tmpAPEv2TagSize;  	// Stream version  	if (integerArray [0] == STREAM_VERSION_70_ID) {  		_streamVersion = 7;  	} else if (integerArray [0] == STREAM_VERSION_71_ID) {  		_streamVersion = 7.1m;  	} else {  		switch ((byteArray [1] % 32) / 2) {  		case 3:  			_streamVersion = 4;  			break;  		case 7:  			_streamVersion = 5;  			break;  		case 11:  			_streamVersion = 6;  			break;  		}  	}  	if (_streamVersion == 0) {  		throw new InvalidDataException ("Unrecognized MPC stream");  	}  	// Sample rate  	_frequency = _sampleRates [byteArray [10] & 0x03];  	// Channels  	if (_streamVersion == 7 || _streamVersion == 7.1m) {  		if ((byteArray [11] % 128) < 64)  			_mode = "Stereo";  		else  			_mode = "Joint Stereo";  	} else {  		if ((byteArray [2] % 128) == 0)  			_mode = "Stereo";  		else  			_mode = "Joint Stereo";  	}  	// Frames  	if (_streamVersion == 4)  		_frames = integerArray [1] >> 16;  	else  		_frames = integerArray [1];  	_totalSeconds = _frames * 1152 / (decimal)_frequency;  	_bitrate = (audioDataLength / _totalSeconds) / 125.0m;  }  
Magic Number,IdSharp.AudioInfo,Musepack,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Musepack\Musepack.cs,Musepack,The following statement contains a magic number: using (FileStream stream = File.Open (path' FileMode.Open' FileAccess.Read' FileShare.Read)) {  	// Skip ID3v2 tag  	int tmpID3v2TagSize = ID3v2.GetTagSize (stream);  	int tmpID3v1TagSize = ID3v1.GetTagSize (stream);  	int tmpAPEv2TagSize = APEv2.GetTagSize (stream);  	stream.Seek (tmpID3v2TagSize' SeekOrigin.Begin);  	_streamVersion = 0;  	byte[] byteArray = stream.Read (32);  	int[] integerArray = new int[8];  	for (int i = 0; i < 8; i++)  		integerArray [i] = (byteArray [i * 4]) + (byteArray [i * 4 + 1] << 8) + (byteArray [i * 4 + 2] << 16) + (byteArray [i * 4 + 3] << 24);  	// Size TODO - ignore Lyrics3  	long audioDataLength = stream.Length - tmpID3v2TagSize - tmpID3v1TagSize - tmpAPEv2TagSize;  	// Stream version  	if (integerArray [0] == STREAM_VERSION_70_ID) {  		_streamVersion = 7;  	} else if (integerArray [0] == STREAM_VERSION_71_ID) {  		_streamVersion = 7.1m;  	} else {  		switch ((byteArray [1] % 32) / 2) {  		case 3:  			_streamVersion = 4;  			break;  		case 7:  			_streamVersion = 5;  			break;  		case 11:  			_streamVersion = 6;  			break;  		}  	}  	if (_streamVersion == 0) {  		throw new InvalidDataException ("Unrecognized MPC stream");  	}  	// Sample rate  	_frequency = _sampleRates [byteArray [10] & 0x03];  	// Channels  	if (_streamVersion == 7 || _streamVersion == 7.1m) {  		if ((byteArray [11] % 128) < 64)  			_mode = "Stereo";  		else  			_mode = "Joint Stereo";  	} else {  		if ((byteArray [2] % 128) == 0)  			_mode = "Stereo";  		else  			_mode = "Joint Stereo";  	}  	// Frames  	if (_streamVersion == 4)  		_frames = integerArray [1] >> 16;  	else  		_frames = integerArray [1];  	_totalSeconds = _frames * 1152 / (decimal)_frequency;  	_bitrate = (audioDataLength / _totalSeconds) / 125.0m;  }  
Magic Number,IdSharp.AudioInfo,Musepack,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Musepack\Musepack.cs,Musepack,The following statement contains a magic number: for (int i = 0; i < 8; i++)  	integerArray [i] = (byteArray [i * 4]) + (byteArray [i * 4 + 1] << 8) + (byteArray [i * 4 + 2] << 16) + (byteArray [i * 4 + 3] << 24);  
Magic Number,IdSharp.AudioInfo,Musepack,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Musepack\Musepack.cs,Musepack,The following statement contains a magic number: for (int i = 0; i < 8; i++)  	integerArray [i] = (byteArray [i * 4]) + (byteArray [i * 4 + 1] << 8) + (byteArray [i * 4 + 2] << 16) + (byteArray [i * 4 + 3] << 24);  
Magic Number,IdSharp.AudioInfo,Musepack,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Musepack\Musepack.cs,Musepack,The following statement contains a magic number: for (int i = 0; i < 8; i++)  	integerArray [i] = (byteArray [i * 4]) + (byteArray [i * 4 + 1] << 8) + (byteArray [i * 4 + 2] << 16) + (byteArray [i * 4 + 3] << 24);  
Magic Number,IdSharp.AudioInfo,Musepack,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Musepack\Musepack.cs,Musepack,The following statement contains a magic number: for (int i = 0; i < 8; i++)  	integerArray [i] = (byteArray [i * 4]) + (byteArray [i * 4 + 1] << 8) + (byteArray [i * 4 + 2] << 16) + (byteArray [i * 4 + 3] << 24);  
Magic Number,IdSharp.AudioInfo,Musepack,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Musepack\Musepack.cs,Musepack,The following statement contains a magic number: for (int i = 0; i < 8; i++)  	integerArray [i] = (byteArray [i * 4]) + (byteArray [i * 4 + 1] << 8) + (byteArray [i * 4 + 2] << 16) + (byteArray [i * 4 + 3] << 24);  
Magic Number,IdSharp.AudioInfo,Musepack,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Musepack\Musepack.cs,Musepack,The following statement contains a magic number: for (int i = 0; i < 8; i++)  	integerArray [i] = (byteArray [i * 4]) + (byteArray [i * 4 + 1] << 8) + (byteArray [i * 4 + 2] << 16) + (byteArray [i * 4 + 3] << 24);  
Magic Number,IdSharp.AudioInfo,Musepack,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Musepack\Musepack.cs,Musepack,The following statement contains a magic number: for (int i = 0; i < 8; i++)  	integerArray [i] = (byteArray [i * 4]) + (byteArray [i * 4 + 1] << 8) + (byteArray [i * 4 + 2] << 16) + (byteArray [i * 4 + 3] << 24);  
Magic Number,IdSharp.AudioInfo,Musepack,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Musepack\Musepack.cs,Musepack,The following statement contains a magic number: for (int i = 0; i < 8; i++)  	integerArray [i] = (byteArray [i * 4]) + (byteArray [i * 4 + 1] << 8) + (byteArray [i * 4 + 2] << 16) + (byteArray [i * 4 + 3] << 24);  
Magic Number,IdSharp.AudioInfo,Musepack,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Musepack\Musepack.cs,Musepack,The following statement contains a magic number: for (int i = 0; i < 8; i++)  	integerArray [i] = (byteArray [i * 4]) + (byteArray [i * 4 + 1] << 8) + (byteArray [i * 4 + 2] << 16) + (byteArray [i * 4 + 3] << 24);  
Magic Number,IdSharp.AudioInfo,Musepack,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Musepack\Musepack.cs,Musepack,The following statement contains a magic number: for (int i = 0; i < 8; i++)  	integerArray [i] = (byteArray [i * 4]) + (byteArray [i * 4 + 1] << 8) + (byteArray [i * 4 + 2] << 16) + (byteArray [i * 4 + 3] << 24);  
Magic Number,IdSharp.AudioInfo,Musepack,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Musepack\Musepack.cs,Musepack,The following statement contains a magic number: integerArray [i] = (byteArray [i * 4]) + (byteArray [i * 4 + 1] << 8) + (byteArray [i * 4 + 2] << 16) + (byteArray [i * 4 + 3] << 24);  
Magic Number,IdSharp.AudioInfo,Musepack,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Musepack\Musepack.cs,Musepack,The following statement contains a magic number: integerArray [i] = (byteArray [i * 4]) + (byteArray [i * 4 + 1] << 8) + (byteArray [i * 4 + 2] << 16) + (byteArray [i * 4 + 3] << 24);  
Magic Number,IdSharp.AudioInfo,Musepack,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Musepack\Musepack.cs,Musepack,The following statement contains a magic number: integerArray [i] = (byteArray [i * 4]) + (byteArray [i * 4 + 1] << 8) + (byteArray [i * 4 + 2] << 16) + (byteArray [i * 4 + 3] << 24);  
Magic Number,IdSharp.AudioInfo,Musepack,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Musepack\Musepack.cs,Musepack,The following statement contains a magic number: integerArray [i] = (byteArray [i * 4]) + (byteArray [i * 4 + 1] << 8) + (byteArray [i * 4 + 2] << 16) + (byteArray [i * 4 + 3] << 24);  
Magic Number,IdSharp.AudioInfo,Musepack,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Musepack\Musepack.cs,Musepack,The following statement contains a magic number: integerArray [i] = (byteArray [i * 4]) + (byteArray [i * 4 + 1] << 8) + (byteArray [i * 4 + 2] << 16) + (byteArray [i * 4 + 3] << 24);  
Magic Number,IdSharp.AudioInfo,Musepack,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Musepack\Musepack.cs,Musepack,The following statement contains a magic number: integerArray [i] = (byteArray [i * 4]) + (byteArray [i * 4 + 1] << 8) + (byteArray [i * 4 + 2] << 16) + (byteArray [i * 4 + 3] << 24);  
Magic Number,IdSharp.AudioInfo,Musepack,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Musepack\Musepack.cs,Musepack,The following statement contains a magic number: integerArray [i] = (byteArray [i * 4]) + (byteArray [i * 4 + 1] << 8) + (byteArray [i * 4 + 2] << 16) + (byteArray [i * 4 + 3] << 24);  
Magic Number,IdSharp.AudioInfo,Musepack,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Musepack\Musepack.cs,Musepack,The following statement contains a magic number: integerArray [i] = (byteArray [i * 4]) + (byteArray [i * 4 + 1] << 8) + (byteArray [i * 4 + 2] << 16) + (byteArray [i * 4 + 3] << 24);  
Magic Number,IdSharp.AudioInfo,Musepack,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Musepack\Musepack.cs,Musepack,The following statement contains a magic number: integerArray [i] = (byteArray [i * 4]) + (byteArray [i * 4 + 1] << 8) + (byteArray [i * 4 + 2] << 16) + (byteArray [i * 4 + 3] << 24);  
Magic Number,IdSharp.AudioInfo,Musepack,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Musepack\Musepack.cs,Musepack,The following statement contains a magic number: if (integerArray [0] == STREAM_VERSION_70_ID) {  	_streamVersion = 7;  } else if (integerArray [0] == STREAM_VERSION_71_ID) {  	_streamVersion = 7.1m;  } else {  	switch ((byteArray [1] % 32) / 2) {  	case 3:  		_streamVersion = 4;  		break;  	case 7:  		_streamVersion = 5;  		break;  	case 11:  		_streamVersion = 6;  		break;  	}  }  
Magic Number,IdSharp.AudioInfo,Musepack,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Musepack\Musepack.cs,Musepack,The following statement contains a magic number: if (integerArray [0] == STREAM_VERSION_70_ID) {  	_streamVersion = 7;  } else if (integerArray [0] == STREAM_VERSION_71_ID) {  	_streamVersion = 7.1m;  } else {  	switch ((byteArray [1] % 32) / 2) {  	case 3:  		_streamVersion = 4;  		break;  	case 7:  		_streamVersion = 5;  		break;  	case 11:  		_streamVersion = 6;  		break;  	}  }  
Magic Number,IdSharp.AudioInfo,Musepack,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Musepack\Musepack.cs,Musepack,The following statement contains a magic number: if (integerArray [0] == STREAM_VERSION_70_ID) {  	_streamVersion = 7;  } else if (integerArray [0] == STREAM_VERSION_71_ID) {  	_streamVersion = 7.1m;  } else {  	switch ((byteArray [1] % 32) / 2) {  	case 3:  		_streamVersion = 4;  		break;  	case 7:  		_streamVersion = 5;  		break;  	case 11:  		_streamVersion = 6;  		break;  	}  }  
Magic Number,IdSharp.AudioInfo,Musepack,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Musepack\Musepack.cs,Musepack,The following statement contains a magic number: if (integerArray [0] == STREAM_VERSION_70_ID) {  	_streamVersion = 7;  } else if (integerArray [0] == STREAM_VERSION_71_ID) {  	_streamVersion = 7.1m;  } else {  	switch ((byteArray [1] % 32) / 2) {  	case 3:  		_streamVersion = 4;  		break;  	case 7:  		_streamVersion = 5;  		break;  	case 11:  		_streamVersion = 6;  		break;  	}  }  
Magic Number,IdSharp.AudioInfo,Musepack,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Musepack\Musepack.cs,Musepack,The following statement contains a magic number: if (integerArray [0] == STREAM_VERSION_70_ID) {  	_streamVersion = 7;  } else if (integerArray [0] == STREAM_VERSION_71_ID) {  	_streamVersion = 7.1m;  } else {  	switch ((byteArray [1] % 32) / 2) {  	case 3:  		_streamVersion = 4;  		break;  	case 7:  		_streamVersion = 5;  		break;  	case 11:  		_streamVersion = 6;  		break;  	}  }  
Magic Number,IdSharp.AudioInfo,Musepack,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Musepack\Musepack.cs,Musepack,The following statement contains a magic number: if (integerArray [0] == STREAM_VERSION_70_ID) {  	_streamVersion = 7;  } else if (integerArray [0] == STREAM_VERSION_71_ID) {  	_streamVersion = 7.1m;  } else {  	switch ((byteArray [1] % 32) / 2) {  	case 3:  		_streamVersion = 4;  		break;  	case 7:  		_streamVersion = 5;  		break;  	case 11:  		_streamVersion = 6;  		break;  	}  }  
Magic Number,IdSharp.AudioInfo,Musepack,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Musepack\Musepack.cs,Musepack,The following statement contains a magic number: if (integerArray [0] == STREAM_VERSION_70_ID) {  	_streamVersion = 7;  } else if (integerArray [0] == STREAM_VERSION_71_ID) {  	_streamVersion = 7.1m;  } else {  	switch ((byteArray [1] % 32) / 2) {  	case 3:  		_streamVersion = 4;  		break;  	case 7:  		_streamVersion = 5;  		break;  	case 11:  		_streamVersion = 6;  		break;  	}  }  
Magic Number,IdSharp.AudioInfo,Musepack,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Musepack\Musepack.cs,Musepack,The following statement contains a magic number: if (integerArray [0] == STREAM_VERSION_70_ID) {  	_streamVersion = 7;  } else if (integerArray [0] == STREAM_VERSION_71_ID) {  	_streamVersion = 7.1m;  } else {  	switch ((byteArray [1] % 32) / 2) {  	case 3:  		_streamVersion = 4;  		break;  	case 7:  		_streamVersion = 5;  		break;  	case 11:  		_streamVersion = 6;  		break;  	}  }  
Magic Number,IdSharp.AudioInfo,Musepack,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Musepack\Musepack.cs,Musepack,The following statement contains a magic number: if (integerArray [0] == STREAM_VERSION_70_ID) {  	_streamVersion = 7;  } else if (integerArray [0] == STREAM_VERSION_71_ID) {  	_streamVersion = 7.1m;  } else {  	switch ((byteArray [1] % 32) / 2) {  	case 3:  		_streamVersion = 4;  		break;  	case 7:  		_streamVersion = 5;  		break;  	case 11:  		_streamVersion = 6;  		break;  	}  }  
Magic Number,IdSharp.AudioInfo,Musepack,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Musepack\Musepack.cs,Musepack,The following statement contains a magic number: _streamVersion = 7;  
Magic Number,IdSharp.AudioInfo,Musepack,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Musepack\Musepack.cs,Musepack,The following statement contains a magic number: if (integerArray [0] == STREAM_VERSION_71_ID) {  	_streamVersion = 7.1m;  } else {  	switch ((byteArray [1] % 32) / 2) {  	case 3:  		_streamVersion = 4;  		break;  	case 7:  		_streamVersion = 5;  		break;  	case 11:  		_streamVersion = 6;  		break;  	}  }  
Magic Number,IdSharp.AudioInfo,Musepack,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Musepack\Musepack.cs,Musepack,The following statement contains a magic number: if (integerArray [0] == STREAM_VERSION_71_ID) {  	_streamVersion = 7.1m;  } else {  	switch ((byteArray [1] % 32) / 2) {  	case 3:  		_streamVersion = 4;  		break;  	case 7:  		_streamVersion = 5;  		break;  	case 11:  		_streamVersion = 6;  		break;  	}  }  
Magic Number,IdSharp.AudioInfo,Musepack,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Musepack\Musepack.cs,Musepack,The following statement contains a magic number: if (integerArray [0] == STREAM_VERSION_71_ID) {  	_streamVersion = 7.1m;  } else {  	switch ((byteArray [1] % 32) / 2) {  	case 3:  		_streamVersion = 4;  		break;  	case 7:  		_streamVersion = 5;  		break;  	case 11:  		_streamVersion = 6;  		break;  	}  }  
Magic Number,IdSharp.AudioInfo,Musepack,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Musepack\Musepack.cs,Musepack,The following statement contains a magic number: if (integerArray [0] == STREAM_VERSION_71_ID) {  	_streamVersion = 7.1m;  } else {  	switch ((byteArray [1] % 32) / 2) {  	case 3:  		_streamVersion = 4;  		break;  	case 7:  		_streamVersion = 5;  		break;  	case 11:  		_streamVersion = 6;  		break;  	}  }  
Magic Number,IdSharp.AudioInfo,Musepack,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Musepack\Musepack.cs,Musepack,The following statement contains a magic number: if (integerArray [0] == STREAM_VERSION_71_ID) {  	_streamVersion = 7.1m;  } else {  	switch ((byteArray [1] % 32) / 2) {  	case 3:  		_streamVersion = 4;  		break;  	case 7:  		_streamVersion = 5;  		break;  	case 11:  		_streamVersion = 6;  		break;  	}  }  
Magic Number,IdSharp.AudioInfo,Musepack,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Musepack\Musepack.cs,Musepack,The following statement contains a magic number: if (integerArray [0] == STREAM_VERSION_71_ID) {  	_streamVersion = 7.1m;  } else {  	switch ((byteArray [1] % 32) / 2) {  	case 3:  		_streamVersion = 4;  		break;  	case 7:  		_streamVersion = 5;  		break;  	case 11:  		_streamVersion = 6;  		break;  	}  }  
Magic Number,IdSharp.AudioInfo,Musepack,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Musepack\Musepack.cs,Musepack,The following statement contains a magic number: if (integerArray [0] == STREAM_VERSION_71_ID) {  	_streamVersion = 7.1m;  } else {  	switch ((byteArray [1] % 32) / 2) {  	case 3:  		_streamVersion = 4;  		break;  	case 7:  		_streamVersion = 5;  		break;  	case 11:  		_streamVersion = 6;  		break;  	}  }  
Magic Number,IdSharp.AudioInfo,Musepack,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Musepack\Musepack.cs,Musepack,The following statement contains a magic number: if (integerArray [0] == STREAM_VERSION_71_ID) {  	_streamVersion = 7.1m;  } else {  	switch ((byteArray [1] % 32) / 2) {  	case 3:  		_streamVersion = 4;  		break;  	case 7:  		_streamVersion = 5;  		break;  	case 11:  		_streamVersion = 6;  		break;  	}  }  
Magic Number,IdSharp.AudioInfo,Musepack,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Musepack\Musepack.cs,Musepack,The following statement contains a magic number: switch ((byteArray [1] % 32) / 2) {  case 3:  	_streamVersion = 4;  	break;  case 7:  	_streamVersion = 5;  	break;  case 11:  	_streamVersion = 6;  	break;  }  
Magic Number,IdSharp.AudioInfo,Musepack,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Musepack\Musepack.cs,Musepack,The following statement contains a magic number: switch ((byteArray [1] % 32) / 2) {  case 3:  	_streamVersion = 4;  	break;  case 7:  	_streamVersion = 5;  	break;  case 11:  	_streamVersion = 6;  	break;  }  
Magic Number,IdSharp.AudioInfo,Musepack,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Musepack\Musepack.cs,Musepack,The following statement contains a magic number: switch ((byteArray [1] % 32) / 2) {  case 3:  	_streamVersion = 4;  	break;  case 7:  	_streamVersion = 5;  	break;  case 11:  	_streamVersion = 6;  	break;  }  
Magic Number,IdSharp.AudioInfo,Musepack,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Musepack\Musepack.cs,Musepack,The following statement contains a magic number: switch ((byteArray [1] % 32) / 2) {  case 3:  	_streamVersion = 4;  	break;  case 7:  	_streamVersion = 5;  	break;  case 11:  	_streamVersion = 6;  	break;  }  
Magic Number,IdSharp.AudioInfo,Musepack,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Musepack\Musepack.cs,Musepack,The following statement contains a magic number: switch ((byteArray [1] % 32) / 2) {  case 3:  	_streamVersion = 4;  	break;  case 7:  	_streamVersion = 5;  	break;  case 11:  	_streamVersion = 6;  	break;  }  
Magic Number,IdSharp.AudioInfo,Musepack,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Musepack\Musepack.cs,Musepack,The following statement contains a magic number: switch ((byteArray [1] % 32) / 2) {  case 3:  	_streamVersion = 4;  	break;  case 7:  	_streamVersion = 5;  	break;  case 11:  	_streamVersion = 6;  	break;  }  
Magic Number,IdSharp.AudioInfo,Musepack,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Musepack\Musepack.cs,Musepack,The following statement contains a magic number: switch ((byteArray [1] % 32) / 2) {  case 3:  	_streamVersion = 4;  	break;  case 7:  	_streamVersion = 5;  	break;  case 11:  	_streamVersion = 6;  	break;  }  
Magic Number,IdSharp.AudioInfo,Musepack,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Musepack\Musepack.cs,Musepack,The following statement contains a magic number: switch ((byteArray [1] % 32) / 2) {  case 3:  	_streamVersion = 4;  	break;  case 7:  	_streamVersion = 5;  	break;  case 11:  	_streamVersion = 6;  	break;  }  
Magic Number,IdSharp.AudioInfo,Musepack,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Musepack\Musepack.cs,Musepack,The following statement contains a magic number: _streamVersion = 4;  
Magic Number,IdSharp.AudioInfo,Musepack,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Musepack\Musepack.cs,Musepack,The following statement contains a magic number: _streamVersion = 5;  
Magic Number,IdSharp.AudioInfo,Musepack,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Musepack\Musepack.cs,Musepack,The following statement contains a magic number: _streamVersion = 6;  
Magic Number,IdSharp.AudioInfo,Musepack,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Musepack\Musepack.cs,Musepack,The following statement contains a magic number: _frequency = _sampleRates [byteArray [10] & 0x03];  
Magic Number,IdSharp.AudioInfo,Musepack,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Musepack\Musepack.cs,Musepack,The following statement contains a magic number: if (_streamVersion == 7 || _streamVersion == 7.1m) {  	if ((byteArray [11] % 128) < 64)  		_mode = "Stereo";  	else  		_mode = "Joint Stereo";  } else {  	if ((byteArray [2] % 128) == 0)  		_mode = "Stereo";  	else  		_mode = "Joint Stereo";  }  
Magic Number,IdSharp.AudioInfo,Musepack,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Musepack\Musepack.cs,Musepack,The following statement contains a magic number: if (_streamVersion == 7 || _streamVersion == 7.1m) {  	if ((byteArray [11] % 128) < 64)  		_mode = "Stereo";  	else  		_mode = "Joint Stereo";  } else {  	if ((byteArray [2] % 128) == 0)  		_mode = "Stereo";  	else  		_mode = "Joint Stereo";  }  
Magic Number,IdSharp.AudioInfo,Musepack,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Musepack\Musepack.cs,Musepack,The following statement contains a magic number: if (_streamVersion == 7 || _streamVersion == 7.1m) {  	if ((byteArray [11] % 128) < 64)  		_mode = "Stereo";  	else  		_mode = "Joint Stereo";  } else {  	if ((byteArray [2] % 128) == 0)  		_mode = "Stereo";  	else  		_mode = "Joint Stereo";  }  
Magic Number,IdSharp.AudioInfo,Musepack,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Musepack\Musepack.cs,Musepack,The following statement contains a magic number: if (_streamVersion == 7 || _streamVersion == 7.1m) {  	if ((byteArray [11] % 128) < 64)  		_mode = "Stereo";  	else  		_mode = "Joint Stereo";  } else {  	if ((byteArray [2] % 128) == 0)  		_mode = "Stereo";  	else  		_mode = "Joint Stereo";  }  
Magic Number,IdSharp.AudioInfo,Musepack,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Musepack\Musepack.cs,Musepack,The following statement contains a magic number: if (_streamVersion == 7 || _streamVersion == 7.1m) {  	if ((byteArray [11] % 128) < 64)  		_mode = "Stereo";  	else  		_mode = "Joint Stereo";  } else {  	if ((byteArray [2] % 128) == 0)  		_mode = "Stereo";  	else  		_mode = "Joint Stereo";  }  
Magic Number,IdSharp.AudioInfo,Musepack,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Musepack\Musepack.cs,Musepack,The following statement contains a magic number: if (_streamVersion == 7 || _streamVersion == 7.1m) {  	if ((byteArray [11] % 128) < 64)  		_mode = "Stereo";  	else  		_mode = "Joint Stereo";  } else {  	if ((byteArray [2] % 128) == 0)  		_mode = "Stereo";  	else  		_mode = "Joint Stereo";  }  
Magic Number,IdSharp.AudioInfo,Musepack,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Musepack\Musepack.cs,Musepack,The following statement contains a magic number: if ((byteArray [11] % 128) < 64)  	_mode = "Stereo";  else  	_mode = "Joint Stereo";  
Magic Number,IdSharp.AudioInfo,Musepack,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Musepack\Musepack.cs,Musepack,The following statement contains a magic number: if ((byteArray [11] % 128) < 64)  	_mode = "Stereo";  else  	_mode = "Joint Stereo";  
Magic Number,IdSharp.AudioInfo,Musepack,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Musepack\Musepack.cs,Musepack,The following statement contains a magic number: if ((byteArray [11] % 128) < 64)  	_mode = "Stereo";  else  	_mode = "Joint Stereo";  
Magic Number,IdSharp.AudioInfo,Musepack,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Musepack\Musepack.cs,Musepack,The following statement contains a magic number: if ((byteArray [2] % 128) == 0)  	_mode = "Stereo";  else  	_mode = "Joint Stereo";  
Magic Number,IdSharp.AudioInfo,Musepack,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Musepack\Musepack.cs,Musepack,The following statement contains a magic number: if ((byteArray [2] % 128) == 0)  	_mode = "Stereo";  else  	_mode = "Joint Stereo";  
Magic Number,IdSharp.AudioInfo,Musepack,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Musepack\Musepack.cs,Musepack,The following statement contains a magic number: if (_streamVersion == 4)  	_frames = integerArray [1] >> 16;  else  	_frames = integerArray [1];  
Magic Number,IdSharp.AudioInfo,Musepack,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Musepack\Musepack.cs,Musepack,The following statement contains a magic number: if (_streamVersion == 4)  	_frames = integerArray [1] >> 16;  else  	_frames = integerArray [1];  
Magic Number,IdSharp.AudioInfo,Musepack,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Musepack\Musepack.cs,Musepack,The following statement contains a magic number: _frames = integerArray [1] >> 16;  
Magic Number,IdSharp.AudioInfo,Musepack,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Musepack\Musepack.cs,Musepack,The following statement contains a magic number: _totalSeconds = _frames * 1152 / (decimal)_frequency;  
Magic Number,IdSharp.AudioInfo,OggVorbis,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\OggVorbis\OggVorbis.cs,OggVorbis,The following statement contains a magic number: using (FileStream stream = File.Open (path' FileMode.Open' FileAccess.Read' FileShare.Read)) {  	try {  		int tmpID3v2Size = ID3v2.GetTagSize (stream);  		stream.Seek (tmpID3v2Size' SeekOrigin.Begin);  		byte[] oggMarker = stream.Read (4);  		if (ByteUtils.Compare (oggMarker' OGG_MARKER) == false) {  			throw new InvalidDataException ("OggS marker not found");  		}  		// Skip through Ogg page header to page_segments position  		stream.Seek (22' SeekOrigin.Current);  		// Skip segment_table  		int pageSegments = stream.Read1 ();  		stream.Seek (pageSegments' SeekOrigin.Current);  		// Read vorbis header  		int packetType = stream.Read1 ();  		if (packetType != 0x01) {  			throw new InvalidDataException ("Vorbis identification header not found");  		}  		byte[] vorbisMarker = stream.Read (6);  		if (ByteUtils.Compare (vorbisMarker' VORBIS_MARKER) == false) {  			throw new InvalidDataException ("Vorbis marker not found");  		}  		// Skip vorbis_version  		stream.Seek (4' SeekOrigin.Current);  		_channels = stream.Read1 ();  		_frequency = stream.ReadInt32LittleEndian ();  		byte[] buf = new byte[251];  		long size = stream.Length;  		// Get total number of samples  		_samples = 0;  		for (int index = 1; index <= 50 && _samples == 0; index++) {  			long dataIndex = size - ((251 - 10) * index) - 10;  			stream.Seek (dataIndex' SeekOrigin.Begin);  			stream.Read (buf' 0' 251);  			// Get number of PCM samples from last Ogg packet header  			for (int i = 251 - 10; i >= 0; i--) {  				bool headerFound = true;  				for (int j = 0; j < 4; j++) {  					if (buf [i + j] != OGG_MARKER [j]) {  						headerFound = false;  						break;  					}  				}  				if (headerFound) {  					stream.Seek (dataIndex + i + 6' SeekOrigin.Begin);  					stream.Read (buf' 0' 8);  					for (i = 0; i < 8; i++) {  						_samples += buf [i] << (8 * i);  					}  					break;  				}  			}  		}  		if (_samples == 0) {  			throw new InvalidDataException ("Could not position to last frame");  		}  		_totalSeconds = _samples / (decimal)_frequency;  		_bitrate = (size - tmpID3v2Size) / _totalSeconds / 125.0m;  	} catch (Exception ex) {  		throw new Exception ("Invalid Ogg-Vorbis file; stream may be corrupt"' ex);  	}  }  
Magic Number,IdSharp.AudioInfo,OggVorbis,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\OggVorbis\OggVorbis.cs,OggVorbis,The following statement contains a magic number: using (FileStream stream = File.Open (path' FileMode.Open' FileAccess.Read' FileShare.Read)) {  	try {  		int tmpID3v2Size = ID3v2.GetTagSize (stream);  		stream.Seek (tmpID3v2Size' SeekOrigin.Begin);  		byte[] oggMarker = stream.Read (4);  		if (ByteUtils.Compare (oggMarker' OGG_MARKER) == false) {  			throw new InvalidDataException ("OggS marker not found");  		}  		// Skip through Ogg page header to page_segments position  		stream.Seek (22' SeekOrigin.Current);  		// Skip segment_table  		int pageSegments = stream.Read1 ();  		stream.Seek (pageSegments' SeekOrigin.Current);  		// Read vorbis header  		int packetType = stream.Read1 ();  		if (packetType != 0x01) {  			throw new InvalidDataException ("Vorbis identification header not found");  		}  		byte[] vorbisMarker = stream.Read (6);  		if (ByteUtils.Compare (vorbisMarker' VORBIS_MARKER) == false) {  			throw new InvalidDataException ("Vorbis marker not found");  		}  		// Skip vorbis_version  		stream.Seek (4' SeekOrigin.Current);  		_channels = stream.Read1 ();  		_frequency = stream.ReadInt32LittleEndian ();  		byte[] buf = new byte[251];  		long size = stream.Length;  		// Get total number of samples  		_samples = 0;  		for (int index = 1; index <= 50 && _samples == 0; index++) {  			long dataIndex = size - ((251 - 10) * index) - 10;  			stream.Seek (dataIndex' SeekOrigin.Begin);  			stream.Read (buf' 0' 251);  			// Get number of PCM samples from last Ogg packet header  			for (int i = 251 - 10; i >= 0; i--) {  				bool headerFound = true;  				for (int j = 0; j < 4; j++) {  					if (buf [i + j] != OGG_MARKER [j]) {  						headerFound = false;  						break;  					}  				}  				if (headerFound) {  					stream.Seek (dataIndex + i + 6' SeekOrigin.Begin);  					stream.Read (buf' 0' 8);  					for (i = 0; i < 8; i++) {  						_samples += buf [i] << (8 * i);  					}  					break;  				}  			}  		}  		if (_samples == 0) {  			throw new InvalidDataException ("Could not position to last frame");  		}  		_totalSeconds = _samples / (decimal)_frequency;  		_bitrate = (size - tmpID3v2Size) / _totalSeconds / 125.0m;  	} catch (Exception ex) {  		throw new Exception ("Invalid Ogg-Vorbis file; stream may be corrupt"' ex);  	}  }  
Magic Number,IdSharp.AudioInfo,OggVorbis,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\OggVorbis\OggVorbis.cs,OggVorbis,The following statement contains a magic number: using (FileStream stream = File.Open (path' FileMode.Open' FileAccess.Read' FileShare.Read)) {  	try {  		int tmpID3v2Size = ID3v2.GetTagSize (stream);  		stream.Seek (tmpID3v2Size' SeekOrigin.Begin);  		byte[] oggMarker = stream.Read (4);  		if (ByteUtils.Compare (oggMarker' OGG_MARKER) == false) {  			throw new InvalidDataException ("OggS marker not found");  		}  		// Skip through Ogg page header to page_segments position  		stream.Seek (22' SeekOrigin.Current);  		// Skip segment_table  		int pageSegments = stream.Read1 ();  		stream.Seek (pageSegments' SeekOrigin.Current);  		// Read vorbis header  		int packetType = stream.Read1 ();  		if (packetType != 0x01) {  			throw new InvalidDataException ("Vorbis identification header not found");  		}  		byte[] vorbisMarker = stream.Read (6);  		if (ByteUtils.Compare (vorbisMarker' VORBIS_MARKER) == false) {  			throw new InvalidDataException ("Vorbis marker not found");  		}  		// Skip vorbis_version  		stream.Seek (4' SeekOrigin.Current);  		_channels = stream.Read1 ();  		_frequency = stream.ReadInt32LittleEndian ();  		byte[] buf = new byte[251];  		long size = stream.Length;  		// Get total number of samples  		_samples = 0;  		for (int index = 1; index <= 50 && _samples == 0; index++) {  			long dataIndex = size - ((251 - 10) * index) - 10;  			stream.Seek (dataIndex' SeekOrigin.Begin);  			stream.Read (buf' 0' 251);  			// Get number of PCM samples from last Ogg packet header  			for (int i = 251 - 10; i >= 0; i--) {  				bool headerFound = true;  				for (int j = 0; j < 4; j++) {  					if (buf [i + j] != OGG_MARKER [j]) {  						headerFound = false;  						break;  					}  				}  				if (headerFound) {  					stream.Seek (dataIndex + i + 6' SeekOrigin.Begin);  					stream.Read (buf' 0' 8);  					for (i = 0; i < 8; i++) {  						_samples += buf [i] << (8 * i);  					}  					break;  				}  			}  		}  		if (_samples == 0) {  			throw new InvalidDataException ("Could not position to last frame");  		}  		_totalSeconds = _samples / (decimal)_frequency;  		_bitrate = (size - tmpID3v2Size) / _totalSeconds / 125.0m;  	} catch (Exception ex) {  		throw new Exception ("Invalid Ogg-Vorbis file; stream may be corrupt"' ex);  	}  }  
Magic Number,IdSharp.AudioInfo,OggVorbis,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\OggVorbis\OggVorbis.cs,OggVorbis,The following statement contains a magic number: using (FileStream stream = File.Open (path' FileMode.Open' FileAccess.Read' FileShare.Read)) {  	try {  		int tmpID3v2Size = ID3v2.GetTagSize (stream);  		stream.Seek (tmpID3v2Size' SeekOrigin.Begin);  		byte[] oggMarker = stream.Read (4);  		if (ByteUtils.Compare (oggMarker' OGG_MARKER) == false) {  			throw new InvalidDataException ("OggS marker not found");  		}  		// Skip through Ogg page header to page_segments position  		stream.Seek (22' SeekOrigin.Current);  		// Skip segment_table  		int pageSegments = stream.Read1 ();  		stream.Seek (pageSegments' SeekOrigin.Current);  		// Read vorbis header  		int packetType = stream.Read1 ();  		if (packetType != 0x01) {  			throw new InvalidDataException ("Vorbis identification header not found");  		}  		byte[] vorbisMarker = stream.Read (6);  		if (ByteUtils.Compare (vorbisMarker' VORBIS_MARKER) == false) {  			throw new InvalidDataException ("Vorbis marker not found");  		}  		// Skip vorbis_version  		stream.Seek (4' SeekOrigin.Current);  		_channels = stream.Read1 ();  		_frequency = stream.ReadInt32LittleEndian ();  		byte[] buf = new byte[251];  		long size = stream.Length;  		// Get total number of samples  		_samples = 0;  		for (int index = 1; index <= 50 && _samples == 0; index++) {  			long dataIndex = size - ((251 - 10) * index) - 10;  			stream.Seek (dataIndex' SeekOrigin.Begin);  			stream.Read (buf' 0' 251);  			// Get number of PCM samples from last Ogg packet header  			for (int i = 251 - 10; i >= 0; i--) {  				bool headerFound = true;  				for (int j = 0; j < 4; j++) {  					if (buf [i + j] != OGG_MARKER [j]) {  						headerFound = false;  						break;  					}  				}  				if (headerFound) {  					stream.Seek (dataIndex + i + 6' SeekOrigin.Begin);  					stream.Read (buf' 0' 8);  					for (i = 0; i < 8; i++) {  						_samples += buf [i] << (8 * i);  					}  					break;  				}  			}  		}  		if (_samples == 0) {  			throw new InvalidDataException ("Could not position to last frame");  		}  		_totalSeconds = _samples / (decimal)_frequency;  		_bitrate = (size - tmpID3v2Size) / _totalSeconds / 125.0m;  	} catch (Exception ex) {  		throw new Exception ("Invalid Ogg-Vorbis file; stream may be corrupt"' ex);  	}  }  
Magic Number,IdSharp.AudioInfo,OggVorbis,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\OggVorbis\OggVorbis.cs,OggVorbis,The following statement contains a magic number: using (FileStream stream = File.Open (path' FileMode.Open' FileAccess.Read' FileShare.Read)) {  	try {  		int tmpID3v2Size = ID3v2.GetTagSize (stream);  		stream.Seek (tmpID3v2Size' SeekOrigin.Begin);  		byte[] oggMarker = stream.Read (4);  		if (ByteUtils.Compare (oggMarker' OGG_MARKER) == false) {  			throw new InvalidDataException ("OggS marker not found");  		}  		// Skip through Ogg page header to page_segments position  		stream.Seek (22' SeekOrigin.Current);  		// Skip segment_table  		int pageSegments = stream.Read1 ();  		stream.Seek (pageSegments' SeekOrigin.Current);  		// Read vorbis header  		int packetType = stream.Read1 ();  		if (packetType != 0x01) {  			throw new InvalidDataException ("Vorbis identification header not found");  		}  		byte[] vorbisMarker = stream.Read (6);  		if (ByteUtils.Compare (vorbisMarker' VORBIS_MARKER) == false) {  			throw new InvalidDataException ("Vorbis marker not found");  		}  		// Skip vorbis_version  		stream.Seek (4' SeekOrigin.Current);  		_channels = stream.Read1 ();  		_frequency = stream.ReadInt32LittleEndian ();  		byte[] buf = new byte[251];  		long size = stream.Length;  		// Get total number of samples  		_samples = 0;  		for (int index = 1; index <= 50 && _samples == 0; index++) {  			long dataIndex = size - ((251 - 10) * index) - 10;  			stream.Seek (dataIndex' SeekOrigin.Begin);  			stream.Read (buf' 0' 251);  			// Get number of PCM samples from last Ogg packet header  			for (int i = 251 - 10; i >= 0; i--) {  				bool headerFound = true;  				for (int j = 0; j < 4; j++) {  					if (buf [i + j] != OGG_MARKER [j]) {  						headerFound = false;  						break;  					}  				}  				if (headerFound) {  					stream.Seek (dataIndex + i + 6' SeekOrigin.Begin);  					stream.Read (buf' 0' 8);  					for (i = 0; i < 8; i++) {  						_samples += buf [i] << (8 * i);  					}  					break;  				}  			}  		}  		if (_samples == 0) {  			throw new InvalidDataException ("Could not position to last frame");  		}  		_totalSeconds = _samples / (decimal)_frequency;  		_bitrate = (size - tmpID3v2Size) / _totalSeconds / 125.0m;  	} catch (Exception ex) {  		throw new Exception ("Invalid Ogg-Vorbis file; stream may be corrupt"' ex);  	}  }  
Magic Number,IdSharp.AudioInfo,OggVorbis,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\OggVorbis\OggVorbis.cs,OggVorbis,The following statement contains a magic number: using (FileStream stream = File.Open (path' FileMode.Open' FileAccess.Read' FileShare.Read)) {  	try {  		int tmpID3v2Size = ID3v2.GetTagSize (stream);  		stream.Seek (tmpID3v2Size' SeekOrigin.Begin);  		byte[] oggMarker = stream.Read (4);  		if (ByteUtils.Compare (oggMarker' OGG_MARKER) == false) {  			throw new InvalidDataException ("OggS marker not found");  		}  		// Skip through Ogg page header to page_segments position  		stream.Seek (22' SeekOrigin.Current);  		// Skip segment_table  		int pageSegments = stream.Read1 ();  		stream.Seek (pageSegments' SeekOrigin.Current);  		// Read vorbis header  		int packetType = stream.Read1 ();  		if (packetType != 0x01) {  			throw new InvalidDataException ("Vorbis identification header not found");  		}  		byte[] vorbisMarker = stream.Read (6);  		if (ByteUtils.Compare (vorbisMarker' VORBIS_MARKER) == false) {  			throw new InvalidDataException ("Vorbis marker not found");  		}  		// Skip vorbis_version  		stream.Seek (4' SeekOrigin.Current);  		_channels = stream.Read1 ();  		_frequency = stream.ReadInt32LittleEndian ();  		byte[] buf = new byte[251];  		long size = stream.Length;  		// Get total number of samples  		_samples = 0;  		for (int index = 1; index <= 50 && _samples == 0; index++) {  			long dataIndex = size - ((251 - 10) * index) - 10;  			stream.Seek (dataIndex' SeekOrigin.Begin);  			stream.Read (buf' 0' 251);  			// Get number of PCM samples from last Ogg packet header  			for (int i = 251 - 10; i >= 0; i--) {  				bool headerFound = true;  				for (int j = 0; j < 4; j++) {  					if (buf [i + j] != OGG_MARKER [j]) {  						headerFound = false;  						break;  					}  				}  				if (headerFound) {  					stream.Seek (dataIndex + i + 6' SeekOrigin.Begin);  					stream.Read (buf' 0' 8);  					for (i = 0; i < 8; i++) {  						_samples += buf [i] << (8 * i);  					}  					break;  				}  			}  		}  		if (_samples == 0) {  			throw new InvalidDataException ("Could not position to last frame");  		}  		_totalSeconds = _samples / (decimal)_frequency;  		_bitrate = (size - tmpID3v2Size) / _totalSeconds / 125.0m;  	} catch (Exception ex) {  		throw new Exception ("Invalid Ogg-Vorbis file; stream may be corrupt"' ex);  	}  }  
Magic Number,IdSharp.AudioInfo,OggVorbis,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\OggVorbis\OggVorbis.cs,OggVorbis,The following statement contains a magic number: using (FileStream stream = File.Open (path' FileMode.Open' FileAccess.Read' FileShare.Read)) {  	try {  		int tmpID3v2Size = ID3v2.GetTagSize (stream);  		stream.Seek (tmpID3v2Size' SeekOrigin.Begin);  		byte[] oggMarker = stream.Read (4);  		if (ByteUtils.Compare (oggMarker' OGG_MARKER) == false) {  			throw new InvalidDataException ("OggS marker not found");  		}  		// Skip through Ogg page header to page_segments position  		stream.Seek (22' SeekOrigin.Current);  		// Skip segment_table  		int pageSegments = stream.Read1 ();  		stream.Seek (pageSegments' SeekOrigin.Current);  		// Read vorbis header  		int packetType = stream.Read1 ();  		if (packetType != 0x01) {  			throw new InvalidDataException ("Vorbis identification header not found");  		}  		byte[] vorbisMarker = stream.Read (6);  		if (ByteUtils.Compare (vorbisMarker' VORBIS_MARKER) == false) {  			throw new InvalidDataException ("Vorbis marker not found");  		}  		// Skip vorbis_version  		stream.Seek (4' SeekOrigin.Current);  		_channels = stream.Read1 ();  		_frequency = stream.ReadInt32LittleEndian ();  		byte[] buf = new byte[251];  		long size = stream.Length;  		// Get total number of samples  		_samples = 0;  		for (int index = 1; index <= 50 && _samples == 0; index++) {  			long dataIndex = size - ((251 - 10) * index) - 10;  			stream.Seek (dataIndex' SeekOrigin.Begin);  			stream.Read (buf' 0' 251);  			// Get number of PCM samples from last Ogg packet header  			for (int i = 251 - 10; i >= 0; i--) {  				bool headerFound = true;  				for (int j = 0; j < 4; j++) {  					if (buf [i + j] != OGG_MARKER [j]) {  						headerFound = false;  						break;  					}  				}  				if (headerFound) {  					stream.Seek (dataIndex + i + 6' SeekOrigin.Begin);  					stream.Read (buf' 0' 8);  					for (i = 0; i < 8; i++) {  						_samples += buf [i] << (8 * i);  					}  					break;  				}  			}  		}  		if (_samples == 0) {  			throw new InvalidDataException ("Could not position to last frame");  		}  		_totalSeconds = _samples / (decimal)_frequency;  		_bitrate = (size - tmpID3v2Size) / _totalSeconds / 125.0m;  	} catch (Exception ex) {  		throw new Exception ("Invalid Ogg-Vorbis file; stream may be corrupt"' ex);  	}  }  
Magic Number,IdSharp.AudioInfo,OggVorbis,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\OggVorbis\OggVorbis.cs,OggVorbis,The following statement contains a magic number: using (FileStream stream = File.Open (path' FileMode.Open' FileAccess.Read' FileShare.Read)) {  	try {  		int tmpID3v2Size = ID3v2.GetTagSize (stream);  		stream.Seek (tmpID3v2Size' SeekOrigin.Begin);  		byte[] oggMarker = stream.Read (4);  		if (ByteUtils.Compare (oggMarker' OGG_MARKER) == false) {  			throw new InvalidDataException ("OggS marker not found");  		}  		// Skip through Ogg page header to page_segments position  		stream.Seek (22' SeekOrigin.Current);  		// Skip segment_table  		int pageSegments = stream.Read1 ();  		stream.Seek (pageSegments' SeekOrigin.Current);  		// Read vorbis header  		int packetType = stream.Read1 ();  		if (packetType != 0x01) {  			throw new InvalidDataException ("Vorbis identification header not found");  		}  		byte[] vorbisMarker = stream.Read (6);  		if (ByteUtils.Compare (vorbisMarker' VORBIS_MARKER) == false) {  			throw new InvalidDataException ("Vorbis marker not found");  		}  		// Skip vorbis_version  		stream.Seek (4' SeekOrigin.Current);  		_channels = stream.Read1 ();  		_frequency = stream.ReadInt32LittleEndian ();  		byte[] buf = new byte[251];  		long size = stream.Length;  		// Get total number of samples  		_samples = 0;  		for (int index = 1; index <= 50 && _samples == 0; index++) {  			long dataIndex = size - ((251 - 10) * index) - 10;  			stream.Seek (dataIndex' SeekOrigin.Begin);  			stream.Read (buf' 0' 251);  			// Get number of PCM samples from last Ogg packet header  			for (int i = 251 - 10; i >= 0; i--) {  				bool headerFound = true;  				for (int j = 0; j < 4; j++) {  					if (buf [i + j] != OGG_MARKER [j]) {  						headerFound = false;  						break;  					}  				}  				if (headerFound) {  					stream.Seek (dataIndex + i + 6' SeekOrigin.Begin);  					stream.Read (buf' 0' 8);  					for (i = 0; i < 8; i++) {  						_samples += buf [i] << (8 * i);  					}  					break;  				}  			}  		}  		if (_samples == 0) {  			throw new InvalidDataException ("Could not position to last frame");  		}  		_totalSeconds = _samples / (decimal)_frequency;  		_bitrate = (size - tmpID3v2Size) / _totalSeconds / 125.0m;  	} catch (Exception ex) {  		throw new Exception ("Invalid Ogg-Vorbis file; stream may be corrupt"' ex);  	}  }  
Magic Number,IdSharp.AudioInfo,OggVorbis,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\OggVorbis\OggVorbis.cs,OggVorbis,The following statement contains a magic number: using (FileStream stream = File.Open (path' FileMode.Open' FileAccess.Read' FileShare.Read)) {  	try {  		int tmpID3v2Size = ID3v2.GetTagSize (stream);  		stream.Seek (tmpID3v2Size' SeekOrigin.Begin);  		byte[] oggMarker = stream.Read (4);  		if (ByteUtils.Compare (oggMarker' OGG_MARKER) == false) {  			throw new InvalidDataException ("OggS marker not found");  		}  		// Skip through Ogg page header to page_segments position  		stream.Seek (22' SeekOrigin.Current);  		// Skip segment_table  		int pageSegments = stream.Read1 ();  		stream.Seek (pageSegments' SeekOrigin.Current);  		// Read vorbis header  		int packetType = stream.Read1 ();  		if (packetType != 0x01) {  			throw new InvalidDataException ("Vorbis identification header not found");  		}  		byte[] vorbisMarker = stream.Read (6);  		if (ByteUtils.Compare (vorbisMarker' VORBIS_MARKER) == false) {  			throw new InvalidDataException ("Vorbis marker not found");  		}  		// Skip vorbis_version  		stream.Seek (4' SeekOrigin.Current);  		_channels = stream.Read1 ();  		_frequency = stream.ReadInt32LittleEndian ();  		byte[] buf = new byte[251];  		long size = stream.Length;  		// Get total number of samples  		_samples = 0;  		for (int index = 1; index <= 50 && _samples == 0; index++) {  			long dataIndex = size - ((251 - 10) * index) - 10;  			stream.Seek (dataIndex' SeekOrigin.Begin);  			stream.Read (buf' 0' 251);  			// Get number of PCM samples from last Ogg packet header  			for (int i = 251 - 10; i >= 0; i--) {  				bool headerFound = true;  				for (int j = 0; j < 4; j++) {  					if (buf [i + j] != OGG_MARKER [j]) {  						headerFound = false;  						break;  					}  				}  				if (headerFound) {  					stream.Seek (dataIndex + i + 6' SeekOrigin.Begin);  					stream.Read (buf' 0' 8);  					for (i = 0; i < 8; i++) {  						_samples += buf [i] << (8 * i);  					}  					break;  				}  			}  		}  		if (_samples == 0) {  			throw new InvalidDataException ("Could not position to last frame");  		}  		_totalSeconds = _samples / (decimal)_frequency;  		_bitrate = (size - tmpID3v2Size) / _totalSeconds / 125.0m;  	} catch (Exception ex) {  		throw new Exception ("Invalid Ogg-Vorbis file; stream may be corrupt"' ex);  	}  }  
Magic Number,IdSharp.AudioInfo,OggVorbis,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\OggVorbis\OggVorbis.cs,OggVorbis,The following statement contains a magic number: using (FileStream stream = File.Open (path' FileMode.Open' FileAccess.Read' FileShare.Read)) {  	try {  		int tmpID3v2Size = ID3v2.GetTagSize (stream);  		stream.Seek (tmpID3v2Size' SeekOrigin.Begin);  		byte[] oggMarker = stream.Read (4);  		if (ByteUtils.Compare (oggMarker' OGG_MARKER) == false) {  			throw new InvalidDataException ("OggS marker not found");  		}  		// Skip through Ogg page header to page_segments position  		stream.Seek (22' SeekOrigin.Current);  		// Skip segment_table  		int pageSegments = stream.Read1 ();  		stream.Seek (pageSegments' SeekOrigin.Current);  		// Read vorbis header  		int packetType = stream.Read1 ();  		if (packetType != 0x01) {  			throw new InvalidDataException ("Vorbis identification header not found");  		}  		byte[] vorbisMarker = stream.Read (6);  		if (ByteUtils.Compare (vorbisMarker' VORBIS_MARKER) == false) {  			throw new InvalidDataException ("Vorbis marker not found");  		}  		// Skip vorbis_version  		stream.Seek (4' SeekOrigin.Current);  		_channels = stream.Read1 ();  		_frequency = stream.ReadInt32LittleEndian ();  		byte[] buf = new byte[251];  		long size = stream.Length;  		// Get total number of samples  		_samples = 0;  		for (int index = 1; index <= 50 && _samples == 0; index++) {  			long dataIndex = size - ((251 - 10) * index) - 10;  			stream.Seek (dataIndex' SeekOrigin.Begin);  			stream.Read (buf' 0' 251);  			// Get number of PCM samples from last Ogg packet header  			for (int i = 251 - 10; i >= 0; i--) {  				bool headerFound = true;  				for (int j = 0; j < 4; j++) {  					if (buf [i + j] != OGG_MARKER [j]) {  						headerFound = false;  						break;  					}  				}  				if (headerFound) {  					stream.Seek (dataIndex + i + 6' SeekOrigin.Begin);  					stream.Read (buf' 0' 8);  					for (i = 0; i < 8; i++) {  						_samples += buf [i] << (8 * i);  					}  					break;  				}  			}  		}  		if (_samples == 0) {  			throw new InvalidDataException ("Could not position to last frame");  		}  		_totalSeconds = _samples / (decimal)_frequency;  		_bitrate = (size - tmpID3v2Size) / _totalSeconds / 125.0m;  	} catch (Exception ex) {  		throw new Exception ("Invalid Ogg-Vorbis file; stream may be corrupt"' ex);  	}  }  
Magic Number,IdSharp.AudioInfo,OggVorbis,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\OggVorbis\OggVorbis.cs,OggVorbis,The following statement contains a magic number: using (FileStream stream = File.Open (path' FileMode.Open' FileAccess.Read' FileShare.Read)) {  	try {  		int tmpID3v2Size = ID3v2.GetTagSize (stream);  		stream.Seek (tmpID3v2Size' SeekOrigin.Begin);  		byte[] oggMarker = stream.Read (4);  		if (ByteUtils.Compare (oggMarker' OGG_MARKER) == false) {  			throw new InvalidDataException ("OggS marker not found");  		}  		// Skip through Ogg page header to page_segments position  		stream.Seek (22' SeekOrigin.Current);  		// Skip segment_table  		int pageSegments = stream.Read1 ();  		stream.Seek (pageSegments' SeekOrigin.Current);  		// Read vorbis header  		int packetType = stream.Read1 ();  		if (packetType != 0x01) {  			throw new InvalidDataException ("Vorbis identification header not found");  		}  		byte[] vorbisMarker = stream.Read (6);  		if (ByteUtils.Compare (vorbisMarker' VORBIS_MARKER) == false) {  			throw new InvalidDataException ("Vorbis marker not found");  		}  		// Skip vorbis_version  		stream.Seek (4' SeekOrigin.Current);  		_channels = stream.Read1 ();  		_frequency = stream.ReadInt32LittleEndian ();  		byte[] buf = new byte[251];  		long size = stream.Length;  		// Get total number of samples  		_samples = 0;  		for (int index = 1; index <= 50 && _samples == 0; index++) {  			long dataIndex = size - ((251 - 10) * index) - 10;  			stream.Seek (dataIndex' SeekOrigin.Begin);  			stream.Read (buf' 0' 251);  			// Get number of PCM samples from last Ogg packet header  			for (int i = 251 - 10; i >= 0; i--) {  				bool headerFound = true;  				for (int j = 0; j < 4; j++) {  					if (buf [i + j] != OGG_MARKER [j]) {  						headerFound = false;  						break;  					}  				}  				if (headerFound) {  					stream.Seek (dataIndex + i + 6' SeekOrigin.Begin);  					stream.Read (buf' 0' 8);  					for (i = 0; i < 8; i++) {  						_samples += buf [i] << (8 * i);  					}  					break;  				}  			}  		}  		if (_samples == 0) {  			throw new InvalidDataException ("Could not position to last frame");  		}  		_totalSeconds = _samples / (decimal)_frequency;  		_bitrate = (size - tmpID3v2Size) / _totalSeconds / 125.0m;  	} catch (Exception ex) {  		throw new Exception ("Invalid Ogg-Vorbis file; stream may be corrupt"' ex);  	}  }  
Magic Number,IdSharp.AudioInfo,OggVorbis,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\OggVorbis\OggVorbis.cs,OggVorbis,The following statement contains a magic number: using (FileStream stream = File.Open (path' FileMode.Open' FileAccess.Read' FileShare.Read)) {  	try {  		int tmpID3v2Size = ID3v2.GetTagSize (stream);  		stream.Seek (tmpID3v2Size' SeekOrigin.Begin);  		byte[] oggMarker = stream.Read (4);  		if (ByteUtils.Compare (oggMarker' OGG_MARKER) == false) {  			throw new InvalidDataException ("OggS marker not found");  		}  		// Skip through Ogg page header to page_segments position  		stream.Seek (22' SeekOrigin.Current);  		// Skip segment_table  		int pageSegments = stream.Read1 ();  		stream.Seek (pageSegments' SeekOrigin.Current);  		// Read vorbis header  		int packetType = stream.Read1 ();  		if (packetType != 0x01) {  			throw new InvalidDataException ("Vorbis identification header not found");  		}  		byte[] vorbisMarker = stream.Read (6);  		if (ByteUtils.Compare (vorbisMarker' VORBIS_MARKER) == false) {  			throw new InvalidDataException ("Vorbis marker not found");  		}  		// Skip vorbis_version  		stream.Seek (4' SeekOrigin.Current);  		_channels = stream.Read1 ();  		_frequency = stream.ReadInt32LittleEndian ();  		byte[] buf = new byte[251];  		long size = stream.Length;  		// Get total number of samples  		_samples = 0;  		for (int index = 1; index <= 50 && _samples == 0; index++) {  			long dataIndex = size - ((251 - 10) * index) - 10;  			stream.Seek (dataIndex' SeekOrigin.Begin);  			stream.Read (buf' 0' 251);  			// Get number of PCM samples from last Ogg packet header  			for (int i = 251 - 10; i >= 0; i--) {  				bool headerFound = true;  				for (int j = 0; j < 4; j++) {  					if (buf [i + j] != OGG_MARKER [j]) {  						headerFound = false;  						break;  					}  				}  				if (headerFound) {  					stream.Seek (dataIndex + i + 6' SeekOrigin.Begin);  					stream.Read (buf' 0' 8);  					for (i = 0; i < 8; i++) {  						_samples += buf [i] << (8 * i);  					}  					break;  				}  			}  		}  		if (_samples == 0) {  			throw new InvalidDataException ("Could not position to last frame");  		}  		_totalSeconds = _samples / (decimal)_frequency;  		_bitrate = (size - tmpID3v2Size) / _totalSeconds / 125.0m;  	} catch (Exception ex) {  		throw new Exception ("Invalid Ogg-Vorbis file; stream may be corrupt"' ex);  	}  }  
Magic Number,IdSharp.AudioInfo,OggVorbis,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\OggVorbis\OggVorbis.cs,OggVorbis,The following statement contains a magic number: using (FileStream stream = File.Open (path' FileMode.Open' FileAccess.Read' FileShare.Read)) {  	try {  		int tmpID3v2Size = ID3v2.GetTagSize (stream);  		stream.Seek (tmpID3v2Size' SeekOrigin.Begin);  		byte[] oggMarker = stream.Read (4);  		if (ByteUtils.Compare (oggMarker' OGG_MARKER) == false) {  			throw new InvalidDataException ("OggS marker not found");  		}  		// Skip through Ogg page header to page_segments position  		stream.Seek (22' SeekOrigin.Current);  		// Skip segment_table  		int pageSegments = stream.Read1 ();  		stream.Seek (pageSegments' SeekOrigin.Current);  		// Read vorbis header  		int packetType = stream.Read1 ();  		if (packetType != 0x01) {  			throw new InvalidDataException ("Vorbis identification header not found");  		}  		byte[] vorbisMarker = stream.Read (6);  		if (ByteUtils.Compare (vorbisMarker' VORBIS_MARKER) == false) {  			throw new InvalidDataException ("Vorbis marker not found");  		}  		// Skip vorbis_version  		stream.Seek (4' SeekOrigin.Current);  		_channels = stream.Read1 ();  		_frequency = stream.ReadInt32LittleEndian ();  		byte[] buf = new byte[251];  		long size = stream.Length;  		// Get total number of samples  		_samples = 0;  		for (int index = 1; index <= 50 && _samples == 0; index++) {  			long dataIndex = size - ((251 - 10) * index) - 10;  			stream.Seek (dataIndex' SeekOrigin.Begin);  			stream.Read (buf' 0' 251);  			// Get number of PCM samples from last Ogg packet header  			for (int i = 251 - 10; i >= 0; i--) {  				bool headerFound = true;  				for (int j = 0; j < 4; j++) {  					if (buf [i + j] != OGG_MARKER [j]) {  						headerFound = false;  						break;  					}  				}  				if (headerFound) {  					stream.Seek (dataIndex + i + 6' SeekOrigin.Begin);  					stream.Read (buf' 0' 8);  					for (i = 0; i < 8; i++) {  						_samples += buf [i] << (8 * i);  					}  					break;  				}  			}  		}  		if (_samples == 0) {  			throw new InvalidDataException ("Could not position to last frame");  		}  		_totalSeconds = _samples / (decimal)_frequency;  		_bitrate = (size - tmpID3v2Size) / _totalSeconds / 125.0m;  	} catch (Exception ex) {  		throw new Exception ("Invalid Ogg-Vorbis file; stream may be corrupt"' ex);  	}  }  
Magic Number,IdSharp.AudioInfo,OggVorbis,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\OggVorbis\OggVorbis.cs,OggVorbis,The following statement contains a magic number: using (FileStream stream = File.Open (path' FileMode.Open' FileAccess.Read' FileShare.Read)) {  	try {  		int tmpID3v2Size = ID3v2.GetTagSize (stream);  		stream.Seek (tmpID3v2Size' SeekOrigin.Begin);  		byte[] oggMarker = stream.Read (4);  		if (ByteUtils.Compare (oggMarker' OGG_MARKER) == false) {  			throw new InvalidDataException ("OggS marker not found");  		}  		// Skip through Ogg page header to page_segments position  		stream.Seek (22' SeekOrigin.Current);  		// Skip segment_table  		int pageSegments = stream.Read1 ();  		stream.Seek (pageSegments' SeekOrigin.Current);  		// Read vorbis header  		int packetType = stream.Read1 ();  		if (packetType != 0x01) {  			throw new InvalidDataException ("Vorbis identification header not found");  		}  		byte[] vorbisMarker = stream.Read (6);  		if (ByteUtils.Compare (vorbisMarker' VORBIS_MARKER) == false) {  			throw new InvalidDataException ("Vorbis marker not found");  		}  		// Skip vorbis_version  		stream.Seek (4' SeekOrigin.Current);  		_channels = stream.Read1 ();  		_frequency = stream.ReadInt32LittleEndian ();  		byte[] buf = new byte[251];  		long size = stream.Length;  		// Get total number of samples  		_samples = 0;  		for (int index = 1; index <= 50 && _samples == 0; index++) {  			long dataIndex = size - ((251 - 10) * index) - 10;  			stream.Seek (dataIndex' SeekOrigin.Begin);  			stream.Read (buf' 0' 251);  			// Get number of PCM samples from last Ogg packet header  			for (int i = 251 - 10; i >= 0; i--) {  				bool headerFound = true;  				for (int j = 0; j < 4; j++) {  					if (buf [i + j] != OGG_MARKER [j]) {  						headerFound = false;  						break;  					}  				}  				if (headerFound) {  					stream.Seek (dataIndex + i + 6' SeekOrigin.Begin);  					stream.Read (buf' 0' 8);  					for (i = 0; i < 8; i++) {  						_samples += buf [i] << (8 * i);  					}  					break;  				}  			}  		}  		if (_samples == 0) {  			throw new InvalidDataException ("Could not position to last frame");  		}  		_totalSeconds = _samples / (decimal)_frequency;  		_bitrate = (size - tmpID3v2Size) / _totalSeconds / 125.0m;  	} catch (Exception ex) {  		throw new Exception ("Invalid Ogg-Vorbis file; stream may be corrupt"' ex);  	}  }  
Magic Number,IdSharp.AudioInfo,OggVorbis,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\OggVorbis\OggVorbis.cs,OggVorbis,The following statement contains a magic number: using (FileStream stream = File.Open (path' FileMode.Open' FileAccess.Read' FileShare.Read)) {  	try {  		int tmpID3v2Size = ID3v2.GetTagSize (stream);  		stream.Seek (tmpID3v2Size' SeekOrigin.Begin);  		byte[] oggMarker = stream.Read (4);  		if (ByteUtils.Compare (oggMarker' OGG_MARKER) == false) {  			throw new InvalidDataException ("OggS marker not found");  		}  		// Skip through Ogg page header to page_segments position  		stream.Seek (22' SeekOrigin.Current);  		// Skip segment_table  		int pageSegments = stream.Read1 ();  		stream.Seek (pageSegments' SeekOrigin.Current);  		// Read vorbis header  		int packetType = stream.Read1 ();  		if (packetType != 0x01) {  			throw new InvalidDataException ("Vorbis identification header not found");  		}  		byte[] vorbisMarker = stream.Read (6);  		if (ByteUtils.Compare (vorbisMarker' VORBIS_MARKER) == false) {  			throw new InvalidDataException ("Vorbis marker not found");  		}  		// Skip vorbis_version  		stream.Seek (4' SeekOrigin.Current);  		_channels = stream.Read1 ();  		_frequency = stream.ReadInt32LittleEndian ();  		byte[] buf = new byte[251];  		long size = stream.Length;  		// Get total number of samples  		_samples = 0;  		for (int index = 1; index <= 50 && _samples == 0; index++) {  			long dataIndex = size - ((251 - 10) * index) - 10;  			stream.Seek (dataIndex' SeekOrigin.Begin);  			stream.Read (buf' 0' 251);  			// Get number of PCM samples from last Ogg packet header  			for (int i = 251 - 10; i >= 0; i--) {  				bool headerFound = true;  				for (int j = 0; j < 4; j++) {  					if (buf [i + j] != OGG_MARKER [j]) {  						headerFound = false;  						break;  					}  				}  				if (headerFound) {  					stream.Seek (dataIndex + i + 6' SeekOrigin.Begin);  					stream.Read (buf' 0' 8);  					for (i = 0; i < 8; i++) {  						_samples += buf [i] << (8 * i);  					}  					break;  				}  			}  		}  		if (_samples == 0) {  			throw new InvalidDataException ("Could not position to last frame");  		}  		_totalSeconds = _samples / (decimal)_frequency;  		_bitrate = (size - tmpID3v2Size) / _totalSeconds / 125.0m;  	} catch (Exception ex) {  		throw new Exception ("Invalid Ogg-Vorbis file; stream may be corrupt"' ex);  	}  }  
Magic Number,IdSharp.AudioInfo,OggVorbis,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\OggVorbis\OggVorbis.cs,OggVorbis,The following statement contains a magic number: using (FileStream stream = File.Open (path' FileMode.Open' FileAccess.Read' FileShare.Read)) {  	try {  		int tmpID3v2Size = ID3v2.GetTagSize (stream);  		stream.Seek (tmpID3v2Size' SeekOrigin.Begin);  		byte[] oggMarker = stream.Read (4);  		if (ByteUtils.Compare (oggMarker' OGG_MARKER) == false) {  			throw new InvalidDataException ("OggS marker not found");  		}  		// Skip through Ogg page header to page_segments position  		stream.Seek (22' SeekOrigin.Current);  		// Skip segment_table  		int pageSegments = stream.Read1 ();  		stream.Seek (pageSegments' SeekOrigin.Current);  		// Read vorbis header  		int packetType = stream.Read1 ();  		if (packetType != 0x01) {  			throw new InvalidDataException ("Vorbis identification header not found");  		}  		byte[] vorbisMarker = stream.Read (6);  		if (ByteUtils.Compare (vorbisMarker' VORBIS_MARKER) == false) {  			throw new InvalidDataException ("Vorbis marker not found");  		}  		// Skip vorbis_version  		stream.Seek (4' SeekOrigin.Current);  		_channels = stream.Read1 ();  		_frequency = stream.ReadInt32LittleEndian ();  		byte[] buf = new byte[251];  		long size = stream.Length;  		// Get total number of samples  		_samples = 0;  		for (int index = 1; index <= 50 && _samples == 0; index++) {  			long dataIndex = size - ((251 - 10) * index) - 10;  			stream.Seek (dataIndex' SeekOrigin.Begin);  			stream.Read (buf' 0' 251);  			// Get number of PCM samples from last Ogg packet header  			for (int i = 251 - 10; i >= 0; i--) {  				bool headerFound = true;  				for (int j = 0; j < 4; j++) {  					if (buf [i + j] != OGG_MARKER [j]) {  						headerFound = false;  						break;  					}  				}  				if (headerFound) {  					stream.Seek (dataIndex + i + 6' SeekOrigin.Begin);  					stream.Read (buf' 0' 8);  					for (i = 0; i < 8; i++) {  						_samples += buf [i] << (8 * i);  					}  					break;  				}  			}  		}  		if (_samples == 0) {  			throw new InvalidDataException ("Could not position to last frame");  		}  		_totalSeconds = _samples / (decimal)_frequency;  		_bitrate = (size - tmpID3v2Size) / _totalSeconds / 125.0m;  	} catch (Exception ex) {  		throw new Exception ("Invalid Ogg-Vorbis file; stream may be corrupt"' ex);  	}  }  
Magic Number,IdSharp.AudioInfo,OggVorbis,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\OggVorbis\OggVorbis.cs,OggVorbis,The following statement contains a magic number: using (FileStream stream = File.Open (path' FileMode.Open' FileAccess.Read' FileShare.Read)) {  	try {  		int tmpID3v2Size = ID3v2.GetTagSize (stream);  		stream.Seek (tmpID3v2Size' SeekOrigin.Begin);  		byte[] oggMarker = stream.Read (4);  		if (ByteUtils.Compare (oggMarker' OGG_MARKER) == false) {  			throw new InvalidDataException ("OggS marker not found");  		}  		// Skip through Ogg page header to page_segments position  		stream.Seek (22' SeekOrigin.Current);  		// Skip segment_table  		int pageSegments = stream.Read1 ();  		stream.Seek (pageSegments' SeekOrigin.Current);  		// Read vorbis header  		int packetType = stream.Read1 ();  		if (packetType != 0x01) {  			throw new InvalidDataException ("Vorbis identification header not found");  		}  		byte[] vorbisMarker = stream.Read (6);  		if (ByteUtils.Compare (vorbisMarker' VORBIS_MARKER) == false) {  			throw new InvalidDataException ("Vorbis marker not found");  		}  		// Skip vorbis_version  		stream.Seek (4' SeekOrigin.Current);  		_channels = stream.Read1 ();  		_frequency = stream.ReadInt32LittleEndian ();  		byte[] buf = new byte[251];  		long size = stream.Length;  		// Get total number of samples  		_samples = 0;  		for (int index = 1; index <= 50 && _samples == 0; index++) {  			long dataIndex = size - ((251 - 10) * index) - 10;  			stream.Seek (dataIndex' SeekOrigin.Begin);  			stream.Read (buf' 0' 251);  			// Get number of PCM samples from last Ogg packet header  			for (int i = 251 - 10; i >= 0; i--) {  				bool headerFound = true;  				for (int j = 0; j < 4; j++) {  					if (buf [i + j] != OGG_MARKER [j]) {  						headerFound = false;  						break;  					}  				}  				if (headerFound) {  					stream.Seek (dataIndex + i + 6' SeekOrigin.Begin);  					stream.Read (buf' 0' 8);  					for (i = 0; i < 8; i++) {  						_samples += buf [i] << (8 * i);  					}  					break;  				}  			}  		}  		if (_samples == 0) {  			throw new InvalidDataException ("Could not position to last frame");  		}  		_totalSeconds = _samples / (decimal)_frequency;  		_bitrate = (size - tmpID3v2Size) / _totalSeconds / 125.0m;  	} catch (Exception ex) {  		throw new Exception ("Invalid Ogg-Vorbis file; stream may be corrupt"' ex);  	}  }  
Magic Number,IdSharp.AudioInfo,OggVorbis,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\OggVorbis\OggVorbis.cs,OggVorbis,The following statement contains a magic number: try {  	int tmpID3v2Size = ID3v2.GetTagSize (stream);  	stream.Seek (tmpID3v2Size' SeekOrigin.Begin);  	byte[] oggMarker = stream.Read (4);  	if (ByteUtils.Compare (oggMarker' OGG_MARKER) == false) {  		throw new InvalidDataException ("OggS marker not found");  	}  	// Skip through Ogg page header to page_segments position  	stream.Seek (22' SeekOrigin.Current);  	// Skip segment_table  	int pageSegments = stream.Read1 ();  	stream.Seek (pageSegments' SeekOrigin.Current);  	// Read vorbis header  	int packetType = stream.Read1 ();  	if (packetType != 0x01) {  		throw new InvalidDataException ("Vorbis identification header not found");  	}  	byte[] vorbisMarker = stream.Read (6);  	if (ByteUtils.Compare (vorbisMarker' VORBIS_MARKER) == false) {  		throw new InvalidDataException ("Vorbis marker not found");  	}  	// Skip vorbis_version  	stream.Seek (4' SeekOrigin.Current);  	_channels = stream.Read1 ();  	_frequency = stream.ReadInt32LittleEndian ();  	byte[] buf = new byte[251];  	long size = stream.Length;  	// Get total number of samples  	_samples = 0;  	for (int index = 1; index <= 50 && _samples == 0; index++) {  		long dataIndex = size - ((251 - 10) * index) - 10;  		stream.Seek (dataIndex' SeekOrigin.Begin);  		stream.Read (buf' 0' 251);  		// Get number of PCM samples from last Ogg packet header  		for (int i = 251 - 10; i >= 0; i--) {  			bool headerFound = true;  			for (int j = 0; j < 4; j++) {  				if (buf [i + j] != OGG_MARKER [j]) {  					headerFound = false;  					break;  				}  			}  			if (headerFound) {  				stream.Seek (dataIndex + i + 6' SeekOrigin.Begin);  				stream.Read (buf' 0' 8);  				for (i = 0; i < 8; i++) {  					_samples += buf [i] << (8 * i);  				}  				break;  			}  		}  	}  	if (_samples == 0) {  		throw new InvalidDataException ("Could not position to last frame");  	}  	_totalSeconds = _samples / (decimal)_frequency;  	_bitrate = (size - tmpID3v2Size) / _totalSeconds / 125.0m;  } catch (Exception ex) {  	throw new Exception ("Invalid Ogg-Vorbis file; stream may be corrupt"' ex);  }  
Magic Number,IdSharp.AudioInfo,OggVorbis,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\OggVorbis\OggVorbis.cs,OggVorbis,The following statement contains a magic number: try {  	int tmpID3v2Size = ID3v2.GetTagSize (stream);  	stream.Seek (tmpID3v2Size' SeekOrigin.Begin);  	byte[] oggMarker = stream.Read (4);  	if (ByteUtils.Compare (oggMarker' OGG_MARKER) == false) {  		throw new InvalidDataException ("OggS marker not found");  	}  	// Skip through Ogg page header to page_segments position  	stream.Seek (22' SeekOrigin.Current);  	// Skip segment_table  	int pageSegments = stream.Read1 ();  	stream.Seek (pageSegments' SeekOrigin.Current);  	// Read vorbis header  	int packetType = stream.Read1 ();  	if (packetType != 0x01) {  		throw new InvalidDataException ("Vorbis identification header not found");  	}  	byte[] vorbisMarker = stream.Read (6);  	if (ByteUtils.Compare (vorbisMarker' VORBIS_MARKER) == false) {  		throw new InvalidDataException ("Vorbis marker not found");  	}  	// Skip vorbis_version  	stream.Seek (4' SeekOrigin.Current);  	_channels = stream.Read1 ();  	_frequency = stream.ReadInt32LittleEndian ();  	byte[] buf = new byte[251];  	long size = stream.Length;  	// Get total number of samples  	_samples = 0;  	for (int index = 1; index <= 50 && _samples == 0; index++) {  		long dataIndex = size - ((251 - 10) * index) - 10;  		stream.Seek (dataIndex' SeekOrigin.Begin);  		stream.Read (buf' 0' 251);  		// Get number of PCM samples from last Ogg packet header  		for (int i = 251 - 10; i >= 0; i--) {  			bool headerFound = true;  			for (int j = 0; j < 4; j++) {  				if (buf [i + j] != OGG_MARKER [j]) {  					headerFound = false;  					break;  				}  			}  			if (headerFound) {  				stream.Seek (dataIndex + i + 6' SeekOrigin.Begin);  				stream.Read (buf' 0' 8);  				for (i = 0; i < 8; i++) {  					_samples += buf [i] << (8 * i);  				}  				break;  			}  		}  	}  	if (_samples == 0) {  		throw new InvalidDataException ("Could not position to last frame");  	}  	_totalSeconds = _samples / (decimal)_frequency;  	_bitrate = (size - tmpID3v2Size) / _totalSeconds / 125.0m;  } catch (Exception ex) {  	throw new Exception ("Invalid Ogg-Vorbis file; stream may be corrupt"' ex);  }  
Magic Number,IdSharp.AudioInfo,OggVorbis,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\OggVorbis\OggVorbis.cs,OggVorbis,The following statement contains a magic number: try {  	int tmpID3v2Size = ID3v2.GetTagSize (stream);  	stream.Seek (tmpID3v2Size' SeekOrigin.Begin);  	byte[] oggMarker = stream.Read (4);  	if (ByteUtils.Compare (oggMarker' OGG_MARKER) == false) {  		throw new InvalidDataException ("OggS marker not found");  	}  	// Skip through Ogg page header to page_segments position  	stream.Seek (22' SeekOrigin.Current);  	// Skip segment_table  	int pageSegments = stream.Read1 ();  	stream.Seek (pageSegments' SeekOrigin.Current);  	// Read vorbis header  	int packetType = stream.Read1 ();  	if (packetType != 0x01) {  		throw new InvalidDataException ("Vorbis identification header not found");  	}  	byte[] vorbisMarker = stream.Read (6);  	if (ByteUtils.Compare (vorbisMarker' VORBIS_MARKER) == false) {  		throw new InvalidDataException ("Vorbis marker not found");  	}  	// Skip vorbis_version  	stream.Seek (4' SeekOrigin.Current);  	_channels = stream.Read1 ();  	_frequency = stream.ReadInt32LittleEndian ();  	byte[] buf = new byte[251];  	long size = stream.Length;  	// Get total number of samples  	_samples = 0;  	for (int index = 1; index <= 50 && _samples == 0; index++) {  		long dataIndex = size - ((251 - 10) * index) - 10;  		stream.Seek (dataIndex' SeekOrigin.Begin);  		stream.Read (buf' 0' 251);  		// Get number of PCM samples from last Ogg packet header  		for (int i = 251 - 10; i >= 0; i--) {  			bool headerFound = true;  			for (int j = 0; j < 4; j++) {  				if (buf [i + j] != OGG_MARKER [j]) {  					headerFound = false;  					break;  				}  			}  			if (headerFound) {  				stream.Seek (dataIndex + i + 6' SeekOrigin.Begin);  				stream.Read (buf' 0' 8);  				for (i = 0; i < 8; i++) {  					_samples += buf [i] << (8 * i);  				}  				break;  			}  		}  	}  	if (_samples == 0) {  		throw new InvalidDataException ("Could not position to last frame");  	}  	_totalSeconds = _samples / (decimal)_frequency;  	_bitrate = (size - tmpID3v2Size) / _totalSeconds / 125.0m;  } catch (Exception ex) {  	throw new Exception ("Invalid Ogg-Vorbis file; stream may be corrupt"' ex);  }  
Magic Number,IdSharp.AudioInfo,OggVorbis,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\OggVorbis\OggVorbis.cs,OggVorbis,The following statement contains a magic number: try {  	int tmpID3v2Size = ID3v2.GetTagSize (stream);  	stream.Seek (tmpID3v2Size' SeekOrigin.Begin);  	byte[] oggMarker = stream.Read (4);  	if (ByteUtils.Compare (oggMarker' OGG_MARKER) == false) {  		throw new InvalidDataException ("OggS marker not found");  	}  	// Skip through Ogg page header to page_segments position  	stream.Seek (22' SeekOrigin.Current);  	// Skip segment_table  	int pageSegments = stream.Read1 ();  	stream.Seek (pageSegments' SeekOrigin.Current);  	// Read vorbis header  	int packetType = stream.Read1 ();  	if (packetType != 0x01) {  		throw new InvalidDataException ("Vorbis identification header not found");  	}  	byte[] vorbisMarker = stream.Read (6);  	if (ByteUtils.Compare (vorbisMarker' VORBIS_MARKER) == false) {  		throw new InvalidDataException ("Vorbis marker not found");  	}  	// Skip vorbis_version  	stream.Seek (4' SeekOrigin.Current);  	_channels = stream.Read1 ();  	_frequency = stream.ReadInt32LittleEndian ();  	byte[] buf = new byte[251];  	long size = stream.Length;  	// Get total number of samples  	_samples = 0;  	for (int index = 1; index <= 50 && _samples == 0; index++) {  		long dataIndex = size - ((251 - 10) * index) - 10;  		stream.Seek (dataIndex' SeekOrigin.Begin);  		stream.Read (buf' 0' 251);  		// Get number of PCM samples from last Ogg packet header  		for (int i = 251 - 10; i >= 0; i--) {  			bool headerFound = true;  			for (int j = 0; j < 4; j++) {  				if (buf [i + j] != OGG_MARKER [j]) {  					headerFound = false;  					break;  				}  			}  			if (headerFound) {  				stream.Seek (dataIndex + i + 6' SeekOrigin.Begin);  				stream.Read (buf' 0' 8);  				for (i = 0; i < 8; i++) {  					_samples += buf [i] << (8 * i);  				}  				break;  			}  		}  	}  	if (_samples == 0) {  		throw new InvalidDataException ("Could not position to last frame");  	}  	_totalSeconds = _samples / (decimal)_frequency;  	_bitrate = (size - tmpID3v2Size) / _totalSeconds / 125.0m;  } catch (Exception ex) {  	throw new Exception ("Invalid Ogg-Vorbis file; stream may be corrupt"' ex);  }  
Magic Number,IdSharp.AudioInfo,OggVorbis,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\OggVorbis\OggVorbis.cs,OggVorbis,The following statement contains a magic number: try {  	int tmpID3v2Size = ID3v2.GetTagSize (stream);  	stream.Seek (tmpID3v2Size' SeekOrigin.Begin);  	byte[] oggMarker = stream.Read (4);  	if (ByteUtils.Compare (oggMarker' OGG_MARKER) == false) {  		throw new InvalidDataException ("OggS marker not found");  	}  	// Skip through Ogg page header to page_segments position  	stream.Seek (22' SeekOrigin.Current);  	// Skip segment_table  	int pageSegments = stream.Read1 ();  	stream.Seek (pageSegments' SeekOrigin.Current);  	// Read vorbis header  	int packetType = stream.Read1 ();  	if (packetType != 0x01) {  		throw new InvalidDataException ("Vorbis identification header not found");  	}  	byte[] vorbisMarker = stream.Read (6);  	if (ByteUtils.Compare (vorbisMarker' VORBIS_MARKER) == false) {  		throw new InvalidDataException ("Vorbis marker not found");  	}  	// Skip vorbis_version  	stream.Seek (4' SeekOrigin.Current);  	_channels = stream.Read1 ();  	_frequency = stream.ReadInt32LittleEndian ();  	byte[] buf = new byte[251];  	long size = stream.Length;  	// Get total number of samples  	_samples = 0;  	for (int index = 1; index <= 50 && _samples == 0; index++) {  		long dataIndex = size - ((251 - 10) * index) - 10;  		stream.Seek (dataIndex' SeekOrigin.Begin);  		stream.Read (buf' 0' 251);  		// Get number of PCM samples from last Ogg packet header  		for (int i = 251 - 10; i >= 0; i--) {  			bool headerFound = true;  			for (int j = 0; j < 4; j++) {  				if (buf [i + j] != OGG_MARKER [j]) {  					headerFound = false;  					break;  				}  			}  			if (headerFound) {  				stream.Seek (dataIndex + i + 6' SeekOrigin.Begin);  				stream.Read (buf' 0' 8);  				for (i = 0; i < 8; i++) {  					_samples += buf [i] << (8 * i);  				}  				break;  			}  		}  	}  	if (_samples == 0) {  		throw new InvalidDataException ("Could not position to last frame");  	}  	_totalSeconds = _samples / (decimal)_frequency;  	_bitrate = (size - tmpID3v2Size) / _totalSeconds / 125.0m;  } catch (Exception ex) {  	throw new Exception ("Invalid Ogg-Vorbis file; stream may be corrupt"' ex);  }  
Magic Number,IdSharp.AudioInfo,OggVorbis,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\OggVorbis\OggVorbis.cs,OggVorbis,The following statement contains a magic number: try {  	int tmpID3v2Size = ID3v2.GetTagSize (stream);  	stream.Seek (tmpID3v2Size' SeekOrigin.Begin);  	byte[] oggMarker = stream.Read (4);  	if (ByteUtils.Compare (oggMarker' OGG_MARKER) == false) {  		throw new InvalidDataException ("OggS marker not found");  	}  	// Skip through Ogg page header to page_segments position  	stream.Seek (22' SeekOrigin.Current);  	// Skip segment_table  	int pageSegments = stream.Read1 ();  	stream.Seek (pageSegments' SeekOrigin.Current);  	// Read vorbis header  	int packetType = stream.Read1 ();  	if (packetType != 0x01) {  		throw new InvalidDataException ("Vorbis identification header not found");  	}  	byte[] vorbisMarker = stream.Read (6);  	if (ByteUtils.Compare (vorbisMarker' VORBIS_MARKER) == false) {  		throw new InvalidDataException ("Vorbis marker not found");  	}  	// Skip vorbis_version  	stream.Seek (4' SeekOrigin.Current);  	_channels = stream.Read1 ();  	_frequency = stream.ReadInt32LittleEndian ();  	byte[] buf = new byte[251];  	long size = stream.Length;  	// Get total number of samples  	_samples = 0;  	for (int index = 1; index <= 50 && _samples == 0; index++) {  		long dataIndex = size - ((251 - 10) * index) - 10;  		stream.Seek (dataIndex' SeekOrigin.Begin);  		stream.Read (buf' 0' 251);  		// Get number of PCM samples from last Ogg packet header  		for (int i = 251 - 10; i >= 0; i--) {  			bool headerFound = true;  			for (int j = 0; j < 4; j++) {  				if (buf [i + j] != OGG_MARKER [j]) {  					headerFound = false;  					break;  				}  			}  			if (headerFound) {  				stream.Seek (dataIndex + i + 6' SeekOrigin.Begin);  				stream.Read (buf' 0' 8);  				for (i = 0; i < 8; i++) {  					_samples += buf [i] << (8 * i);  				}  				break;  			}  		}  	}  	if (_samples == 0) {  		throw new InvalidDataException ("Could not position to last frame");  	}  	_totalSeconds = _samples / (decimal)_frequency;  	_bitrate = (size - tmpID3v2Size) / _totalSeconds / 125.0m;  } catch (Exception ex) {  	throw new Exception ("Invalid Ogg-Vorbis file; stream may be corrupt"' ex);  }  
Magic Number,IdSharp.AudioInfo,OggVorbis,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\OggVorbis\OggVorbis.cs,OggVorbis,The following statement contains a magic number: try {  	int tmpID3v2Size = ID3v2.GetTagSize (stream);  	stream.Seek (tmpID3v2Size' SeekOrigin.Begin);  	byte[] oggMarker = stream.Read (4);  	if (ByteUtils.Compare (oggMarker' OGG_MARKER) == false) {  		throw new InvalidDataException ("OggS marker not found");  	}  	// Skip through Ogg page header to page_segments position  	stream.Seek (22' SeekOrigin.Current);  	// Skip segment_table  	int pageSegments = stream.Read1 ();  	stream.Seek (pageSegments' SeekOrigin.Current);  	// Read vorbis header  	int packetType = stream.Read1 ();  	if (packetType != 0x01) {  		throw new InvalidDataException ("Vorbis identification header not found");  	}  	byte[] vorbisMarker = stream.Read (6);  	if (ByteUtils.Compare (vorbisMarker' VORBIS_MARKER) == false) {  		throw new InvalidDataException ("Vorbis marker not found");  	}  	// Skip vorbis_version  	stream.Seek (4' SeekOrigin.Current);  	_channels = stream.Read1 ();  	_frequency = stream.ReadInt32LittleEndian ();  	byte[] buf = new byte[251];  	long size = stream.Length;  	// Get total number of samples  	_samples = 0;  	for (int index = 1; index <= 50 && _samples == 0; index++) {  		long dataIndex = size - ((251 - 10) * index) - 10;  		stream.Seek (dataIndex' SeekOrigin.Begin);  		stream.Read (buf' 0' 251);  		// Get number of PCM samples from last Ogg packet header  		for (int i = 251 - 10; i >= 0; i--) {  			bool headerFound = true;  			for (int j = 0; j < 4; j++) {  				if (buf [i + j] != OGG_MARKER [j]) {  					headerFound = false;  					break;  				}  			}  			if (headerFound) {  				stream.Seek (dataIndex + i + 6' SeekOrigin.Begin);  				stream.Read (buf' 0' 8);  				for (i = 0; i < 8; i++) {  					_samples += buf [i] << (8 * i);  				}  				break;  			}  		}  	}  	if (_samples == 0) {  		throw new InvalidDataException ("Could not position to last frame");  	}  	_totalSeconds = _samples / (decimal)_frequency;  	_bitrate = (size - tmpID3v2Size) / _totalSeconds / 125.0m;  } catch (Exception ex) {  	throw new Exception ("Invalid Ogg-Vorbis file; stream may be corrupt"' ex);  }  
Magic Number,IdSharp.AudioInfo,OggVorbis,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\OggVorbis\OggVorbis.cs,OggVorbis,The following statement contains a magic number: try {  	int tmpID3v2Size = ID3v2.GetTagSize (stream);  	stream.Seek (tmpID3v2Size' SeekOrigin.Begin);  	byte[] oggMarker = stream.Read (4);  	if (ByteUtils.Compare (oggMarker' OGG_MARKER) == false) {  		throw new InvalidDataException ("OggS marker not found");  	}  	// Skip through Ogg page header to page_segments position  	stream.Seek (22' SeekOrigin.Current);  	// Skip segment_table  	int pageSegments = stream.Read1 ();  	stream.Seek (pageSegments' SeekOrigin.Current);  	// Read vorbis header  	int packetType = stream.Read1 ();  	if (packetType != 0x01) {  		throw new InvalidDataException ("Vorbis identification header not found");  	}  	byte[] vorbisMarker = stream.Read (6);  	if (ByteUtils.Compare (vorbisMarker' VORBIS_MARKER) == false) {  		throw new InvalidDataException ("Vorbis marker not found");  	}  	// Skip vorbis_version  	stream.Seek (4' SeekOrigin.Current);  	_channels = stream.Read1 ();  	_frequency = stream.ReadInt32LittleEndian ();  	byte[] buf = new byte[251];  	long size = stream.Length;  	// Get total number of samples  	_samples = 0;  	for (int index = 1; index <= 50 && _samples == 0; index++) {  		long dataIndex = size - ((251 - 10) * index) - 10;  		stream.Seek (dataIndex' SeekOrigin.Begin);  		stream.Read (buf' 0' 251);  		// Get number of PCM samples from last Ogg packet header  		for (int i = 251 - 10; i >= 0; i--) {  			bool headerFound = true;  			for (int j = 0; j < 4; j++) {  				if (buf [i + j] != OGG_MARKER [j]) {  					headerFound = false;  					break;  				}  			}  			if (headerFound) {  				stream.Seek (dataIndex + i + 6' SeekOrigin.Begin);  				stream.Read (buf' 0' 8);  				for (i = 0; i < 8; i++) {  					_samples += buf [i] << (8 * i);  				}  				break;  			}  		}  	}  	if (_samples == 0) {  		throw new InvalidDataException ("Could not position to last frame");  	}  	_totalSeconds = _samples / (decimal)_frequency;  	_bitrate = (size - tmpID3v2Size) / _totalSeconds / 125.0m;  } catch (Exception ex) {  	throw new Exception ("Invalid Ogg-Vorbis file; stream may be corrupt"' ex);  }  
Magic Number,IdSharp.AudioInfo,OggVorbis,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\OggVorbis\OggVorbis.cs,OggVorbis,The following statement contains a magic number: try {  	int tmpID3v2Size = ID3v2.GetTagSize (stream);  	stream.Seek (tmpID3v2Size' SeekOrigin.Begin);  	byte[] oggMarker = stream.Read (4);  	if (ByteUtils.Compare (oggMarker' OGG_MARKER) == false) {  		throw new InvalidDataException ("OggS marker not found");  	}  	// Skip through Ogg page header to page_segments position  	stream.Seek (22' SeekOrigin.Current);  	// Skip segment_table  	int pageSegments = stream.Read1 ();  	stream.Seek (pageSegments' SeekOrigin.Current);  	// Read vorbis header  	int packetType = stream.Read1 ();  	if (packetType != 0x01) {  		throw new InvalidDataException ("Vorbis identification header not found");  	}  	byte[] vorbisMarker = stream.Read (6);  	if (ByteUtils.Compare (vorbisMarker' VORBIS_MARKER) == false) {  		throw new InvalidDataException ("Vorbis marker not found");  	}  	// Skip vorbis_version  	stream.Seek (4' SeekOrigin.Current);  	_channels = stream.Read1 ();  	_frequency = stream.ReadInt32LittleEndian ();  	byte[] buf = new byte[251];  	long size = stream.Length;  	// Get total number of samples  	_samples = 0;  	for (int index = 1; index <= 50 && _samples == 0; index++) {  		long dataIndex = size - ((251 - 10) * index) - 10;  		stream.Seek (dataIndex' SeekOrigin.Begin);  		stream.Read (buf' 0' 251);  		// Get number of PCM samples from last Ogg packet header  		for (int i = 251 - 10; i >= 0; i--) {  			bool headerFound = true;  			for (int j = 0; j < 4; j++) {  				if (buf [i + j] != OGG_MARKER [j]) {  					headerFound = false;  					break;  				}  			}  			if (headerFound) {  				stream.Seek (dataIndex + i + 6' SeekOrigin.Begin);  				stream.Read (buf' 0' 8);  				for (i = 0; i < 8; i++) {  					_samples += buf [i] << (8 * i);  				}  				break;  			}  		}  	}  	if (_samples == 0) {  		throw new InvalidDataException ("Could not position to last frame");  	}  	_totalSeconds = _samples / (decimal)_frequency;  	_bitrate = (size - tmpID3v2Size) / _totalSeconds / 125.0m;  } catch (Exception ex) {  	throw new Exception ("Invalid Ogg-Vorbis file; stream may be corrupt"' ex);  }  
Magic Number,IdSharp.AudioInfo,OggVorbis,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\OggVorbis\OggVorbis.cs,OggVorbis,The following statement contains a magic number: try {  	int tmpID3v2Size = ID3v2.GetTagSize (stream);  	stream.Seek (tmpID3v2Size' SeekOrigin.Begin);  	byte[] oggMarker = stream.Read (4);  	if (ByteUtils.Compare (oggMarker' OGG_MARKER) == false) {  		throw new InvalidDataException ("OggS marker not found");  	}  	// Skip through Ogg page header to page_segments position  	stream.Seek (22' SeekOrigin.Current);  	// Skip segment_table  	int pageSegments = stream.Read1 ();  	stream.Seek (pageSegments' SeekOrigin.Current);  	// Read vorbis header  	int packetType = stream.Read1 ();  	if (packetType != 0x01) {  		throw new InvalidDataException ("Vorbis identification header not found");  	}  	byte[] vorbisMarker = stream.Read (6);  	if (ByteUtils.Compare (vorbisMarker' VORBIS_MARKER) == false) {  		throw new InvalidDataException ("Vorbis marker not found");  	}  	// Skip vorbis_version  	stream.Seek (4' SeekOrigin.Current);  	_channels = stream.Read1 ();  	_frequency = stream.ReadInt32LittleEndian ();  	byte[] buf = new byte[251];  	long size = stream.Length;  	// Get total number of samples  	_samples = 0;  	for (int index = 1; index <= 50 && _samples == 0; index++) {  		long dataIndex = size - ((251 - 10) * index) - 10;  		stream.Seek (dataIndex' SeekOrigin.Begin);  		stream.Read (buf' 0' 251);  		// Get number of PCM samples from last Ogg packet header  		for (int i = 251 - 10; i >= 0; i--) {  			bool headerFound = true;  			for (int j = 0; j < 4; j++) {  				if (buf [i + j] != OGG_MARKER [j]) {  					headerFound = false;  					break;  				}  			}  			if (headerFound) {  				stream.Seek (dataIndex + i + 6' SeekOrigin.Begin);  				stream.Read (buf' 0' 8);  				for (i = 0; i < 8; i++) {  					_samples += buf [i] << (8 * i);  				}  				break;  			}  		}  	}  	if (_samples == 0) {  		throw new InvalidDataException ("Could not position to last frame");  	}  	_totalSeconds = _samples / (decimal)_frequency;  	_bitrate = (size - tmpID3v2Size) / _totalSeconds / 125.0m;  } catch (Exception ex) {  	throw new Exception ("Invalid Ogg-Vorbis file; stream may be corrupt"' ex);  }  
Magic Number,IdSharp.AudioInfo,OggVorbis,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\OggVorbis\OggVorbis.cs,OggVorbis,The following statement contains a magic number: try {  	int tmpID3v2Size = ID3v2.GetTagSize (stream);  	stream.Seek (tmpID3v2Size' SeekOrigin.Begin);  	byte[] oggMarker = stream.Read (4);  	if (ByteUtils.Compare (oggMarker' OGG_MARKER) == false) {  		throw new InvalidDataException ("OggS marker not found");  	}  	// Skip through Ogg page header to page_segments position  	stream.Seek (22' SeekOrigin.Current);  	// Skip segment_table  	int pageSegments = stream.Read1 ();  	stream.Seek (pageSegments' SeekOrigin.Current);  	// Read vorbis header  	int packetType = stream.Read1 ();  	if (packetType != 0x01) {  		throw new InvalidDataException ("Vorbis identification header not found");  	}  	byte[] vorbisMarker = stream.Read (6);  	if (ByteUtils.Compare (vorbisMarker' VORBIS_MARKER) == false) {  		throw new InvalidDataException ("Vorbis marker not found");  	}  	// Skip vorbis_version  	stream.Seek (4' SeekOrigin.Current);  	_channels = stream.Read1 ();  	_frequency = stream.ReadInt32LittleEndian ();  	byte[] buf = new byte[251];  	long size = stream.Length;  	// Get total number of samples  	_samples = 0;  	for (int index = 1; index <= 50 && _samples == 0; index++) {  		long dataIndex = size - ((251 - 10) * index) - 10;  		stream.Seek (dataIndex' SeekOrigin.Begin);  		stream.Read (buf' 0' 251);  		// Get number of PCM samples from last Ogg packet header  		for (int i = 251 - 10; i >= 0; i--) {  			bool headerFound = true;  			for (int j = 0; j < 4; j++) {  				if (buf [i + j] != OGG_MARKER [j]) {  					headerFound = false;  					break;  				}  			}  			if (headerFound) {  				stream.Seek (dataIndex + i + 6' SeekOrigin.Begin);  				stream.Read (buf' 0' 8);  				for (i = 0; i < 8; i++) {  					_samples += buf [i] << (8 * i);  				}  				break;  			}  		}  	}  	if (_samples == 0) {  		throw new InvalidDataException ("Could not position to last frame");  	}  	_totalSeconds = _samples / (decimal)_frequency;  	_bitrate = (size - tmpID3v2Size) / _totalSeconds / 125.0m;  } catch (Exception ex) {  	throw new Exception ("Invalid Ogg-Vorbis file; stream may be corrupt"' ex);  }  
Magic Number,IdSharp.AudioInfo,OggVorbis,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\OggVorbis\OggVorbis.cs,OggVorbis,The following statement contains a magic number: try {  	int tmpID3v2Size = ID3v2.GetTagSize (stream);  	stream.Seek (tmpID3v2Size' SeekOrigin.Begin);  	byte[] oggMarker = stream.Read (4);  	if (ByteUtils.Compare (oggMarker' OGG_MARKER) == false) {  		throw new InvalidDataException ("OggS marker not found");  	}  	// Skip through Ogg page header to page_segments position  	stream.Seek (22' SeekOrigin.Current);  	// Skip segment_table  	int pageSegments = stream.Read1 ();  	stream.Seek (pageSegments' SeekOrigin.Current);  	// Read vorbis header  	int packetType = stream.Read1 ();  	if (packetType != 0x01) {  		throw new InvalidDataException ("Vorbis identification header not found");  	}  	byte[] vorbisMarker = stream.Read (6);  	if (ByteUtils.Compare (vorbisMarker' VORBIS_MARKER) == false) {  		throw new InvalidDataException ("Vorbis marker not found");  	}  	// Skip vorbis_version  	stream.Seek (4' SeekOrigin.Current);  	_channels = stream.Read1 ();  	_frequency = stream.ReadInt32LittleEndian ();  	byte[] buf = new byte[251];  	long size = stream.Length;  	// Get total number of samples  	_samples = 0;  	for (int index = 1; index <= 50 && _samples == 0; index++) {  		long dataIndex = size - ((251 - 10) * index) - 10;  		stream.Seek (dataIndex' SeekOrigin.Begin);  		stream.Read (buf' 0' 251);  		// Get number of PCM samples from last Ogg packet header  		for (int i = 251 - 10; i >= 0; i--) {  			bool headerFound = true;  			for (int j = 0; j < 4; j++) {  				if (buf [i + j] != OGG_MARKER [j]) {  					headerFound = false;  					break;  				}  			}  			if (headerFound) {  				stream.Seek (dataIndex + i + 6' SeekOrigin.Begin);  				stream.Read (buf' 0' 8);  				for (i = 0; i < 8; i++) {  					_samples += buf [i] << (8 * i);  				}  				break;  			}  		}  	}  	if (_samples == 0) {  		throw new InvalidDataException ("Could not position to last frame");  	}  	_totalSeconds = _samples / (decimal)_frequency;  	_bitrate = (size - tmpID3v2Size) / _totalSeconds / 125.0m;  } catch (Exception ex) {  	throw new Exception ("Invalid Ogg-Vorbis file; stream may be corrupt"' ex);  }  
Magic Number,IdSharp.AudioInfo,OggVorbis,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\OggVorbis\OggVorbis.cs,OggVorbis,The following statement contains a magic number: try {  	int tmpID3v2Size = ID3v2.GetTagSize (stream);  	stream.Seek (tmpID3v2Size' SeekOrigin.Begin);  	byte[] oggMarker = stream.Read (4);  	if (ByteUtils.Compare (oggMarker' OGG_MARKER) == false) {  		throw new InvalidDataException ("OggS marker not found");  	}  	// Skip through Ogg page header to page_segments position  	stream.Seek (22' SeekOrigin.Current);  	// Skip segment_table  	int pageSegments = stream.Read1 ();  	stream.Seek (pageSegments' SeekOrigin.Current);  	// Read vorbis header  	int packetType = stream.Read1 ();  	if (packetType != 0x01) {  		throw new InvalidDataException ("Vorbis identification header not found");  	}  	byte[] vorbisMarker = stream.Read (6);  	if (ByteUtils.Compare (vorbisMarker' VORBIS_MARKER) == false) {  		throw new InvalidDataException ("Vorbis marker not found");  	}  	// Skip vorbis_version  	stream.Seek (4' SeekOrigin.Current);  	_channels = stream.Read1 ();  	_frequency = stream.ReadInt32LittleEndian ();  	byte[] buf = new byte[251];  	long size = stream.Length;  	// Get total number of samples  	_samples = 0;  	for (int index = 1; index <= 50 && _samples == 0; index++) {  		long dataIndex = size - ((251 - 10) * index) - 10;  		stream.Seek (dataIndex' SeekOrigin.Begin);  		stream.Read (buf' 0' 251);  		// Get number of PCM samples from last Ogg packet header  		for (int i = 251 - 10; i >= 0; i--) {  			bool headerFound = true;  			for (int j = 0; j < 4; j++) {  				if (buf [i + j] != OGG_MARKER [j]) {  					headerFound = false;  					break;  				}  			}  			if (headerFound) {  				stream.Seek (dataIndex + i + 6' SeekOrigin.Begin);  				stream.Read (buf' 0' 8);  				for (i = 0; i < 8; i++) {  					_samples += buf [i] << (8 * i);  				}  				break;  			}  		}  	}  	if (_samples == 0) {  		throw new InvalidDataException ("Could not position to last frame");  	}  	_totalSeconds = _samples / (decimal)_frequency;  	_bitrate = (size - tmpID3v2Size) / _totalSeconds / 125.0m;  } catch (Exception ex) {  	throw new Exception ("Invalid Ogg-Vorbis file; stream may be corrupt"' ex);  }  
Magic Number,IdSharp.AudioInfo,OggVorbis,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\OggVorbis\OggVorbis.cs,OggVorbis,The following statement contains a magic number: try {  	int tmpID3v2Size = ID3v2.GetTagSize (stream);  	stream.Seek (tmpID3v2Size' SeekOrigin.Begin);  	byte[] oggMarker = stream.Read (4);  	if (ByteUtils.Compare (oggMarker' OGG_MARKER) == false) {  		throw new InvalidDataException ("OggS marker not found");  	}  	// Skip through Ogg page header to page_segments position  	stream.Seek (22' SeekOrigin.Current);  	// Skip segment_table  	int pageSegments = stream.Read1 ();  	stream.Seek (pageSegments' SeekOrigin.Current);  	// Read vorbis header  	int packetType = stream.Read1 ();  	if (packetType != 0x01) {  		throw new InvalidDataException ("Vorbis identification header not found");  	}  	byte[] vorbisMarker = stream.Read (6);  	if (ByteUtils.Compare (vorbisMarker' VORBIS_MARKER) == false) {  		throw new InvalidDataException ("Vorbis marker not found");  	}  	// Skip vorbis_version  	stream.Seek (4' SeekOrigin.Current);  	_channels = stream.Read1 ();  	_frequency = stream.ReadInt32LittleEndian ();  	byte[] buf = new byte[251];  	long size = stream.Length;  	// Get total number of samples  	_samples = 0;  	for (int index = 1; index <= 50 && _samples == 0; index++) {  		long dataIndex = size - ((251 - 10) * index) - 10;  		stream.Seek (dataIndex' SeekOrigin.Begin);  		stream.Read (buf' 0' 251);  		// Get number of PCM samples from last Ogg packet header  		for (int i = 251 - 10; i >= 0; i--) {  			bool headerFound = true;  			for (int j = 0; j < 4; j++) {  				if (buf [i + j] != OGG_MARKER [j]) {  					headerFound = false;  					break;  				}  			}  			if (headerFound) {  				stream.Seek (dataIndex + i + 6' SeekOrigin.Begin);  				stream.Read (buf' 0' 8);  				for (i = 0; i < 8; i++) {  					_samples += buf [i] << (8 * i);  				}  				break;  			}  		}  	}  	if (_samples == 0) {  		throw new InvalidDataException ("Could not position to last frame");  	}  	_totalSeconds = _samples / (decimal)_frequency;  	_bitrate = (size - tmpID3v2Size) / _totalSeconds / 125.0m;  } catch (Exception ex) {  	throw new Exception ("Invalid Ogg-Vorbis file; stream may be corrupt"' ex);  }  
Magic Number,IdSharp.AudioInfo,OggVorbis,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\OggVorbis\OggVorbis.cs,OggVorbis,The following statement contains a magic number: try {  	int tmpID3v2Size = ID3v2.GetTagSize (stream);  	stream.Seek (tmpID3v2Size' SeekOrigin.Begin);  	byte[] oggMarker = stream.Read (4);  	if (ByteUtils.Compare (oggMarker' OGG_MARKER) == false) {  		throw new InvalidDataException ("OggS marker not found");  	}  	// Skip through Ogg page header to page_segments position  	stream.Seek (22' SeekOrigin.Current);  	// Skip segment_table  	int pageSegments = stream.Read1 ();  	stream.Seek (pageSegments' SeekOrigin.Current);  	// Read vorbis header  	int packetType = stream.Read1 ();  	if (packetType != 0x01) {  		throw new InvalidDataException ("Vorbis identification header not found");  	}  	byte[] vorbisMarker = stream.Read (6);  	if (ByteUtils.Compare (vorbisMarker' VORBIS_MARKER) == false) {  		throw new InvalidDataException ("Vorbis marker not found");  	}  	// Skip vorbis_version  	stream.Seek (4' SeekOrigin.Current);  	_channels = stream.Read1 ();  	_frequency = stream.ReadInt32LittleEndian ();  	byte[] buf = new byte[251];  	long size = stream.Length;  	// Get total number of samples  	_samples = 0;  	for (int index = 1; index <= 50 && _samples == 0; index++) {  		long dataIndex = size - ((251 - 10) * index) - 10;  		stream.Seek (dataIndex' SeekOrigin.Begin);  		stream.Read (buf' 0' 251);  		// Get number of PCM samples from last Ogg packet header  		for (int i = 251 - 10; i >= 0; i--) {  			bool headerFound = true;  			for (int j = 0; j < 4; j++) {  				if (buf [i + j] != OGG_MARKER [j]) {  					headerFound = false;  					break;  				}  			}  			if (headerFound) {  				stream.Seek (dataIndex + i + 6' SeekOrigin.Begin);  				stream.Read (buf' 0' 8);  				for (i = 0; i < 8; i++) {  					_samples += buf [i] << (8 * i);  				}  				break;  			}  		}  	}  	if (_samples == 0) {  		throw new InvalidDataException ("Could not position to last frame");  	}  	_totalSeconds = _samples / (decimal)_frequency;  	_bitrate = (size - tmpID3v2Size) / _totalSeconds / 125.0m;  } catch (Exception ex) {  	throw new Exception ("Invalid Ogg-Vorbis file; stream may be corrupt"' ex);  }  
Magic Number,IdSharp.AudioInfo,OggVorbis,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\OggVorbis\OggVorbis.cs,OggVorbis,The following statement contains a magic number: try {  	int tmpID3v2Size = ID3v2.GetTagSize (stream);  	stream.Seek (tmpID3v2Size' SeekOrigin.Begin);  	byte[] oggMarker = stream.Read (4);  	if (ByteUtils.Compare (oggMarker' OGG_MARKER) == false) {  		throw new InvalidDataException ("OggS marker not found");  	}  	// Skip through Ogg page header to page_segments position  	stream.Seek (22' SeekOrigin.Current);  	// Skip segment_table  	int pageSegments = stream.Read1 ();  	stream.Seek (pageSegments' SeekOrigin.Current);  	// Read vorbis header  	int packetType = stream.Read1 ();  	if (packetType != 0x01) {  		throw new InvalidDataException ("Vorbis identification header not found");  	}  	byte[] vorbisMarker = stream.Read (6);  	if (ByteUtils.Compare (vorbisMarker' VORBIS_MARKER) == false) {  		throw new InvalidDataException ("Vorbis marker not found");  	}  	// Skip vorbis_version  	stream.Seek (4' SeekOrigin.Current);  	_channels = stream.Read1 ();  	_frequency = stream.ReadInt32LittleEndian ();  	byte[] buf = new byte[251];  	long size = stream.Length;  	// Get total number of samples  	_samples = 0;  	for (int index = 1; index <= 50 && _samples == 0; index++) {  		long dataIndex = size - ((251 - 10) * index) - 10;  		stream.Seek (dataIndex' SeekOrigin.Begin);  		stream.Read (buf' 0' 251);  		// Get number of PCM samples from last Ogg packet header  		for (int i = 251 - 10; i >= 0; i--) {  			bool headerFound = true;  			for (int j = 0; j < 4; j++) {  				if (buf [i + j] != OGG_MARKER [j]) {  					headerFound = false;  					break;  				}  			}  			if (headerFound) {  				stream.Seek (dataIndex + i + 6' SeekOrigin.Begin);  				stream.Read (buf' 0' 8);  				for (i = 0; i < 8; i++) {  					_samples += buf [i] << (8 * i);  				}  				break;  			}  		}  	}  	if (_samples == 0) {  		throw new InvalidDataException ("Could not position to last frame");  	}  	_totalSeconds = _samples / (decimal)_frequency;  	_bitrate = (size - tmpID3v2Size) / _totalSeconds / 125.0m;  } catch (Exception ex) {  	throw new Exception ("Invalid Ogg-Vorbis file; stream may be corrupt"' ex);  }  
Magic Number,IdSharp.AudioInfo,OggVorbis,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\OggVorbis\OggVorbis.cs,OggVorbis,The following statement contains a magic number: try {  	int tmpID3v2Size = ID3v2.GetTagSize (stream);  	stream.Seek (tmpID3v2Size' SeekOrigin.Begin);  	byte[] oggMarker = stream.Read (4);  	if (ByteUtils.Compare (oggMarker' OGG_MARKER) == false) {  		throw new InvalidDataException ("OggS marker not found");  	}  	// Skip through Ogg page header to page_segments position  	stream.Seek (22' SeekOrigin.Current);  	// Skip segment_table  	int pageSegments = stream.Read1 ();  	stream.Seek (pageSegments' SeekOrigin.Current);  	// Read vorbis header  	int packetType = stream.Read1 ();  	if (packetType != 0x01) {  		throw new InvalidDataException ("Vorbis identification header not found");  	}  	byte[] vorbisMarker = stream.Read (6);  	if (ByteUtils.Compare (vorbisMarker' VORBIS_MARKER) == false) {  		throw new InvalidDataException ("Vorbis marker not found");  	}  	// Skip vorbis_version  	stream.Seek (4' SeekOrigin.Current);  	_channels = stream.Read1 ();  	_frequency = stream.ReadInt32LittleEndian ();  	byte[] buf = new byte[251];  	long size = stream.Length;  	// Get total number of samples  	_samples = 0;  	for (int index = 1; index <= 50 && _samples == 0; index++) {  		long dataIndex = size - ((251 - 10) * index) - 10;  		stream.Seek (dataIndex' SeekOrigin.Begin);  		stream.Read (buf' 0' 251);  		// Get number of PCM samples from last Ogg packet header  		for (int i = 251 - 10; i >= 0; i--) {  			bool headerFound = true;  			for (int j = 0; j < 4; j++) {  				if (buf [i + j] != OGG_MARKER [j]) {  					headerFound = false;  					break;  				}  			}  			if (headerFound) {  				stream.Seek (dataIndex + i + 6' SeekOrigin.Begin);  				stream.Read (buf' 0' 8);  				for (i = 0; i < 8; i++) {  					_samples += buf [i] << (8 * i);  				}  				break;  			}  		}  	}  	if (_samples == 0) {  		throw new InvalidDataException ("Could not position to last frame");  	}  	_totalSeconds = _samples / (decimal)_frequency;  	_bitrate = (size - tmpID3v2Size) / _totalSeconds / 125.0m;  } catch (Exception ex) {  	throw new Exception ("Invalid Ogg-Vorbis file; stream may be corrupt"' ex);  }  
Magic Number,IdSharp.AudioInfo,OggVorbis,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\OggVorbis\OggVorbis.cs,OggVorbis,The following statement contains a magic number: stream.Seek (22' SeekOrigin.Current);  
Magic Number,IdSharp.AudioInfo,OggVorbis,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\OggVorbis\OggVorbis.cs,OggVorbis,The following statement contains a magic number: stream.Seek (4' SeekOrigin.Current);  
Magic Number,IdSharp.AudioInfo,OggVorbis,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\OggVorbis\OggVorbis.cs,OggVorbis,The following statement contains a magic number: for (int index = 1; index <= 50 && _samples == 0; index++) {  	long dataIndex = size - ((251 - 10) * index) - 10;  	stream.Seek (dataIndex' SeekOrigin.Begin);  	stream.Read (buf' 0' 251);  	// Get number of PCM samples from last Ogg packet header  	for (int i = 251 - 10; i >= 0; i--) {  		bool headerFound = true;  		for (int j = 0; j < 4; j++) {  			if (buf [i + j] != OGG_MARKER [j]) {  				headerFound = false;  				break;  			}  		}  		if (headerFound) {  			stream.Seek (dataIndex + i + 6' SeekOrigin.Begin);  			stream.Read (buf' 0' 8);  			for (i = 0; i < 8; i++) {  				_samples += buf [i] << (8 * i);  			}  			break;  		}  	}  }  
Magic Number,IdSharp.AudioInfo,OggVorbis,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\OggVorbis\OggVorbis.cs,OggVorbis,The following statement contains a magic number: for (int index = 1; index <= 50 && _samples == 0; index++) {  	long dataIndex = size - ((251 - 10) * index) - 10;  	stream.Seek (dataIndex' SeekOrigin.Begin);  	stream.Read (buf' 0' 251);  	// Get number of PCM samples from last Ogg packet header  	for (int i = 251 - 10; i >= 0; i--) {  		bool headerFound = true;  		for (int j = 0; j < 4; j++) {  			if (buf [i + j] != OGG_MARKER [j]) {  				headerFound = false;  				break;  			}  		}  		if (headerFound) {  			stream.Seek (dataIndex + i + 6' SeekOrigin.Begin);  			stream.Read (buf' 0' 8);  			for (i = 0; i < 8; i++) {  				_samples += buf [i] << (8 * i);  			}  			break;  		}  	}  }  
Magic Number,IdSharp.AudioInfo,OggVorbis,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\OggVorbis\OggVorbis.cs,OggVorbis,The following statement contains a magic number: for (int index = 1; index <= 50 && _samples == 0; index++) {  	long dataIndex = size - ((251 - 10) * index) - 10;  	stream.Seek (dataIndex' SeekOrigin.Begin);  	stream.Read (buf' 0' 251);  	// Get number of PCM samples from last Ogg packet header  	for (int i = 251 - 10; i >= 0; i--) {  		bool headerFound = true;  		for (int j = 0; j < 4; j++) {  			if (buf [i + j] != OGG_MARKER [j]) {  				headerFound = false;  				break;  			}  		}  		if (headerFound) {  			stream.Seek (dataIndex + i + 6' SeekOrigin.Begin);  			stream.Read (buf' 0' 8);  			for (i = 0; i < 8; i++) {  				_samples += buf [i] << (8 * i);  			}  			break;  		}  	}  }  
Magic Number,IdSharp.AudioInfo,OggVorbis,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\OggVorbis\OggVorbis.cs,OggVorbis,The following statement contains a magic number: for (int index = 1; index <= 50 && _samples == 0; index++) {  	long dataIndex = size - ((251 - 10) * index) - 10;  	stream.Seek (dataIndex' SeekOrigin.Begin);  	stream.Read (buf' 0' 251);  	// Get number of PCM samples from last Ogg packet header  	for (int i = 251 - 10; i >= 0; i--) {  		bool headerFound = true;  		for (int j = 0; j < 4; j++) {  			if (buf [i + j] != OGG_MARKER [j]) {  				headerFound = false;  				break;  			}  		}  		if (headerFound) {  			stream.Seek (dataIndex + i + 6' SeekOrigin.Begin);  			stream.Read (buf' 0' 8);  			for (i = 0; i < 8; i++) {  				_samples += buf [i] << (8 * i);  			}  			break;  		}  	}  }  
Magic Number,IdSharp.AudioInfo,OggVorbis,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\OggVorbis\OggVorbis.cs,OggVorbis,The following statement contains a magic number: for (int index = 1; index <= 50 && _samples == 0; index++) {  	long dataIndex = size - ((251 - 10) * index) - 10;  	stream.Seek (dataIndex' SeekOrigin.Begin);  	stream.Read (buf' 0' 251);  	// Get number of PCM samples from last Ogg packet header  	for (int i = 251 - 10; i >= 0; i--) {  		bool headerFound = true;  		for (int j = 0; j < 4; j++) {  			if (buf [i + j] != OGG_MARKER [j]) {  				headerFound = false;  				break;  			}  		}  		if (headerFound) {  			stream.Seek (dataIndex + i + 6' SeekOrigin.Begin);  			stream.Read (buf' 0' 8);  			for (i = 0; i < 8; i++) {  				_samples += buf [i] << (8 * i);  			}  			break;  		}  	}  }  
Magic Number,IdSharp.AudioInfo,OggVorbis,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\OggVorbis\OggVorbis.cs,OggVorbis,The following statement contains a magic number: for (int index = 1; index <= 50 && _samples == 0; index++) {  	long dataIndex = size - ((251 - 10) * index) - 10;  	stream.Seek (dataIndex' SeekOrigin.Begin);  	stream.Read (buf' 0' 251);  	// Get number of PCM samples from last Ogg packet header  	for (int i = 251 - 10; i >= 0; i--) {  		bool headerFound = true;  		for (int j = 0; j < 4; j++) {  			if (buf [i + j] != OGG_MARKER [j]) {  				headerFound = false;  				break;  			}  		}  		if (headerFound) {  			stream.Seek (dataIndex + i + 6' SeekOrigin.Begin);  			stream.Read (buf' 0' 8);  			for (i = 0; i < 8; i++) {  				_samples += buf [i] << (8 * i);  			}  			break;  		}  	}  }  
Magic Number,IdSharp.AudioInfo,OggVorbis,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\OggVorbis\OggVorbis.cs,OggVorbis,The following statement contains a magic number: for (int index = 1; index <= 50 && _samples == 0; index++) {  	long dataIndex = size - ((251 - 10) * index) - 10;  	stream.Seek (dataIndex' SeekOrigin.Begin);  	stream.Read (buf' 0' 251);  	// Get number of PCM samples from last Ogg packet header  	for (int i = 251 - 10; i >= 0; i--) {  		bool headerFound = true;  		for (int j = 0; j < 4; j++) {  			if (buf [i + j] != OGG_MARKER [j]) {  				headerFound = false;  				break;  			}  		}  		if (headerFound) {  			stream.Seek (dataIndex + i + 6' SeekOrigin.Begin);  			stream.Read (buf' 0' 8);  			for (i = 0; i < 8; i++) {  				_samples += buf [i] << (8 * i);  			}  			break;  		}  	}  }  
Magic Number,IdSharp.AudioInfo,OggVorbis,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\OggVorbis\OggVorbis.cs,OggVorbis,The following statement contains a magic number: for (int index = 1; index <= 50 && _samples == 0; index++) {  	long dataIndex = size - ((251 - 10) * index) - 10;  	stream.Seek (dataIndex' SeekOrigin.Begin);  	stream.Read (buf' 0' 251);  	// Get number of PCM samples from last Ogg packet header  	for (int i = 251 - 10; i >= 0; i--) {  		bool headerFound = true;  		for (int j = 0; j < 4; j++) {  			if (buf [i + j] != OGG_MARKER [j]) {  				headerFound = false;  				break;  			}  		}  		if (headerFound) {  			stream.Seek (dataIndex + i + 6' SeekOrigin.Begin);  			stream.Read (buf' 0' 8);  			for (i = 0; i < 8; i++) {  				_samples += buf [i] << (8 * i);  			}  			break;  		}  	}  }  
Magic Number,IdSharp.AudioInfo,OggVorbis,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\OggVorbis\OggVorbis.cs,OggVorbis,The following statement contains a magic number: for (int index = 1; index <= 50 && _samples == 0; index++) {  	long dataIndex = size - ((251 - 10) * index) - 10;  	stream.Seek (dataIndex' SeekOrigin.Begin);  	stream.Read (buf' 0' 251);  	// Get number of PCM samples from last Ogg packet header  	for (int i = 251 - 10; i >= 0; i--) {  		bool headerFound = true;  		for (int j = 0; j < 4; j++) {  			if (buf [i + j] != OGG_MARKER [j]) {  				headerFound = false;  				break;  			}  		}  		if (headerFound) {  			stream.Seek (dataIndex + i + 6' SeekOrigin.Begin);  			stream.Read (buf' 0' 8);  			for (i = 0; i < 8; i++) {  				_samples += buf [i] << (8 * i);  			}  			break;  		}  	}  }  
Magic Number,IdSharp.AudioInfo,OggVorbis,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\OggVorbis\OggVorbis.cs,OggVorbis,The following statement contains a magic number: for (int index = 1; index <= 50 && _samples == 0; index++) {  	long dataIndex = size - ((251 - 10) * index) - 10;  	stream.Seek (dataIndex' SeekOrigin.Begin);  	stream.Read (buf' 0' 251);  	// Get number of PCM samples from last Ogg packet header  	for (int i = 251 - 10; i >= 0; i--) {  		bool headerFound = true;  		for (int j = 0; j < 4; j++) {  			if (buf [i + j] != OGG_MARKER [j]) {  				headerFound = false;  				break;  			}  		}  		if (headerFound) {  			stream.Seek (dataIndex + i + 6' SeekOrigin.Begin);  			stream.Read (buf' 0' 8);  			for (i = 0; i < 8; i++) {  				_samples += buf [i] << (8 * i);  			}  			break;  		}  	}  }  
Magic Number,IdSharp.AudioInfo,OggVorbis,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\OggVorbis\OggVorbis.cs,OggVorbis,The following statement contains a magic number: for (int index = 1; index <= 50 && _samples == 0; index++) {  	long dataIndex = size - ((251 - 10) * index) - 10;  	stream.Seek (dataIndex' SeekOrigin.Begin);  	stream.Read (buf' 0' 251);  	// Get number of PCM samples from last Ogg packet header  	for (int i = 251 - 10; i >= 0; i--) {  		bool headerFound = true;  		for (int j = 0; j < 4; j++) {  			if (buf [i + j] != OGG_MARKER [j]) {  				headerFound = false;  				break;  			}  		}  		if (headerFound) {  			stream.Seek (dataIndex + i + 6' SeekOrigin.Begin);  			stream.Read (buf' 0' 8);  			for (i = 0; i < 8; i++) {  				_samples += buf [i] << (8 * i);  			}  			break;  		}  	}  }  
Magic Number,IdSharp.AudioInfo,OggVorbis,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\OggVorbis\OggVorbis.cs,OggVorbis,The following statement contains a magic number: for (int index = 1; index <= 50 && _samples == 0; index++) {  	long dataIndex = size - ((251 - 10) * index) - 10;  	stream.Seek (dataIndex' SeekOrigin.Begin);  	stream.Read (buf' 0' 251);  	// Get number of PCM samples from last Ogg packet header  	for (int i = 251 - 10; i >= 0; i--) {  		bool headerFound = true;  		for (int j = 0; j < 4; j++) {  			if (buf [i + j] != OGG_MARKER [j]) {  				headerFound = false;  				break;  			}  		}  		if (headerFound) {  			stream.Seek (dataIndex + i + 6' SeekOrigin.Begin);  			stream.Read (buf' 0' 8);  			for (i = 0; i < 8; i++) {  				_samples += buf [i] << (8 * i);  			}  			break;  		}  	}  }  
Magic Number,IdSharp.AudioInfo,OggVorbis,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\OggVorbis\OggVorbis.cs,OggVorbis,The following statement contains a magic number: stream.Read (buf' 0' 251);  
Magic Number,IdSharp.AudioInfo,OggVorbis,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\OggVorbis\OggVorbis.cs,OggVorbis,The following statement contains a magic number: for (int i = 251 - 10; i >= 0; i--) {  	bool headerFound = true;  	for (int j = 0; j < 4; j++) {  		if (buf [i + j] != OGG_MARKER [j]) {  			headerFound = false;  			break;  		}  	}  	if (headerFound) {  		stream.Seek (dataIndex + i + 6' SeekOrigin.Begin);  		stream.Read (buf' 0' 8);  		for (i = 0; i < 8; i++) {  			_samples += buf [i] << (8 * i);  		}  		break;  	}  }  
Magic Number,IdSharp.AudioInfo,OggVorbis,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\OggVorbis\OggVorbis.cs,OggVorbis,The following statement contains a magic number: for (int i = 251 - 10; i >= 0; i--) {  	bool headerFound = true;  	for (int j = 0; j < 4; j++) {  		if (buf [i + j] != OGG_MARKER [j]) {  			headerFound = false;  			break;  		}  	}  	if (headerFound) {  		stream.Seek (dataIndex + i + 6' SeekOrigin.Begin);  		stream.Read (buf' 0' 8);  		for (i = 0; i < 8; i++) {  			_samples += buf [i] << (8 * i);  		}  		break;  	}  }  
Magic Number,IdSharp.AudioInfo,OggVorbis,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\OggVorbis\OggVorbis.cs,OggVorbis,The following statement contains a magic number: for (int i = 251 - 10; i >= 0; i--) {  	bool headerFound = true;  	for (int j = 0; j < 4; j++) {  		if (buf [i + j] != OGG_MARKER [j]) {  			headerFound = false;  			break;  		}  	}  	if (headerFound) {  		stream.Seek (dataIndex + i + 6' SeekOrigin.Begin);  		stream.Read (buf' 0' 8);  		for (i = 0; i < 8; i++) {  			_samples += buf [i] << (8 * i);  		}  		break;  	}  }  
Magic Number,IdSharp.AudioInfo,OggVorbis,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\OggVorbis\OggVorbis.cs,OggVorbis,The following statement contains a magic number: for (int i = 251 - 10; i >= 0; i--) {  	bool headerFound = true;  	for (int j = 0; j < 4; j++) {  		if (buf [i + j] != OGG_MARKER [j]) {  			headerFound = false;  			break;  		}  	}  	if (headerFound) {  		stream.Seek (dataIndex + i + 6' SeekOrigin.Begin);  		stream.Read (buf' 0' 8);  		for (i = 0; i < 8; i++) {  			_samples += buf [i] << (8 * i);  		}  		break;  	}  }  
Magic Number,IdSharp.AudioInfo,OggVorbis,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\OggVorbis\OggVorbis.cs,OggVorbis,The following statement contains a magic number: for (int i = 251 - 10; i >= 0; i--) {  	bool headerFound = true;  	for (int j = 0; j < 4; j++) {  		if (buf [i + j] != OGG_MARKER [j]) {  			headerFound = false;  			break;  		}  	}  	if (headerFound) {  		stream.Seek (dataIndex + i + 6' SeekOrigin.Begin);  		stream.Read (buf' 0' 8);  		for (i = 0; i < 8; i++) {  			_samples += buf [i] << (8 * i);  		}  		break;  	}  }  
Magic Number,IdSharp.AudioInfo,OggVorbis,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\OggVorbis\OggVorbis.cs,OggVorbis,The following statement contains a magic number: for (int i = 251 - 10; i >= 0; i--) {  	bool headerFound = true;  	for (int j = 0; j < 4; j++) {  		if (buf [i + j] != OGG_MARKER [j]) {  			headerFound = false;  			break;  		}  	}  	if (headerFound) {  		stream.Seek (dataIndex + i + 6' SeekOrigin.Begin);  		stream.Read (buf' 0' 8);  		for (i = 0; i < 8; i++) {  			_samples += buf [i] << (8 * i);  		}  		break;  	}  }  
Magic Number,IdSharp.AudioInfo,OggVorbis,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\OggVorbis\OggVorbis.cs,OggVorbis,The following statement contains a magic number: for (int i = 251 - 10; i >= 0; i--) {  	bool headerFound = true;  	for (int j = 0; j < 4; j++) {  		if (buf [i + j] != OGG_MARKER [j]) {  			headerFound = false;  			break;  		}  	}  	if (headerFound) {  		stream.Seek (dataIndex + i + 6' SeekOrigin.Begin);  		stream.Read (buf' 0' 8);  		for (i = 0; i < 8; i++) {  			_samples += buf [i] << (8 * i);  		}  		break;  	}  }  
Magic Number,IdSharp.AudioInfo,OggVorbis,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\OggVorbis\OggVorbis.cs,OggVorbis,The following statement contains a magic number: for (int j = 0; j < 4; j++) {  	if (buf [i + j] != OGG_MARKER [j]) {  		headerFound = false;  		break;  	}  }  
Magic Number,IdSharp.AudioInfo,OggVorbis,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\OggVorbis\OggVorbis.cs,OggVorbis,The following statement contains a magic number: if (headerFound) {  	stream.Seek (dataIndex + i + 6' SeekOrigin.Begin);  	stream.Read (buf' 0' 8);  	for (i = 0; i < 8; i++) {  		_samples += buf [i] << (8 * i);  	}  	break;  }  
Magic Number,IdSharp.AudioInfo,OggVorbis,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\OggVorbis\OggVorbis.cs,OggVorbis,The following statement contains a magic number: if (headerFound) {  	stream.Seek (dataIndex + i + 6' SeekOrigin.Begin);  	stream.Read (buf' 0' 8);  	for (i = 0; i < 8; i++) {  		_samples += buf [i] << (8 * i);  	}  	break;  }  
Magic Number,IdSharp.AudioInfo,OggVorbis,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\OggVorbis\OggVorbis.cs,OggVorbis,The following statement contains a magic number: if (headerFound) {  	stream.Seek (dataIndex + i + 6' SeekOrigin.Begin);  	stream.Read (buf' 0' 8);  	for (i = 0; i < 8; i++) {  		_samples += buf [i] << (8 * i);  	}  	break;  }  
Magic Number,IdSharp.AudioInfo,OggVorbis,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\OggVorbis\OggVorbis.cs,OggVorbis,The following statement contains a magic number: if (headerFound) {  	stream.Seek (dataIndex + i + 6' SeekOrigin.Begin);  	stream.Read (buf' 0' 8);  	for (i = 0; i < 8; i++) {  		_samples += buf [i] << (8 * i);  	}  	break;  }  
Magic Number,IdSharp.AudioInfo,OggVorbis,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\OggVorbis\OggVorbis.cs,OggVorbis,The following statement contains a magic number: stream.Seek (dataIndex + i + 6' SeekOrigin.Begin);  
Magic Number,IdSharp.AudioInfo,OggVorbis,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\OggVorbis\OggVorbis.cs,OggVorbis,The following statement contains a magic number: stream.Read (buf' 0' 8);  
Magic Number,IdSharp.AudioInfo,OggVorbis,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\OggVorbis\OggVorbis.cs,OggVorbis,The following statement contains a magic number: for (i = 0; i < 8; i++) {  	_samples += buf [i] << (8 * i);  }  
Magic Number,IdSharp.AudioInfo,OggVorbis,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\OggVorbis\OggVorbis.cs,OggVorbis,The following statement contains a magic number: for (i = 0; i < 8; i++) {  	_samples += buf [i] << (8 * i);  }  
Magic Number,IdSharp.AudioInfo,OggVorbis,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\OggVorbis\OggVorbis.cs,OggVorbis,The following statement contains a magic number: _samples += buf [i] << (8 * i);  
Magic Number,IdSharp.AudioInfo,OggVorbis,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\OggVorbis\OggVorbis.cs,IsOggVorbis,The following statement contains a magic number: stream.Read (oggMarker' 0' 4);  
Magic Number,IdSharp.AudioInfo,OggVorbis,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\OggVorbis\OggVorbis.cs,IsOggVorbis,The following statement contains a magic number: stream.Seek (-4' SeekOrigin.Current);  
Magic Number,IdSharp.AudioInfo,OptimFrog,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\OptimFrog\OptimFrog.cs,OptimFrog,The following statement contains a magic number: using (FileStream fs = File.Open (path' FileMode.Open' FileAccess.Read' FileShare.Read)) {  	fs.Position = 31;  	RiffWave wav = new RiffWave (fs);  	_channels = wav.Channels;  	_frequency = wav.Frequency;  	_totalSeconds = wav.TotalSeconds;  	_bitrate = (fs.Length / 125.0m) / _totalSeconds;  }  
Magic Number,IdSharp.AudioInfo,OptimFrog,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\OptimFrog\OptimFrog.cs,OptimFrog,The following statement contains a magic number: fs.Position = 31;  
Magic Number,IdSharp.AudioInfo,RiffWave,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\RiffWave\RiffWave.cs,ReadStream,The following statement contains a magic number: if (header [0] != 'R' || header [1] != 'I' || header [2] != 'F' || header [3] != 'F') {  	throw new InvalidDataException ("'RIFF' identifier not found");  }  
Magic Number,IdSharp.AudioInfo,RiffWave,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\RiffWave\RiffWave.cs,ReadStream,The following statement contains a magic number: if (header [0] != 'R' || header [1] != 'I' || header [2] != 'F' || header [3] != 'F') {  	throw new InvalidDataException ("'RIFF' identifier not found");  }  
Magic Number,IdSharp.AudioInfo,RiffWave,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\RiffWave\RiffWave.cs,ReadStream,The following statement contains a magic number: if (header [8] != 'W' || header [9] != 'A' || header [10] != 'V' || header [11] != 'E') {  	throw new InvalidDataException ("'WAVE' identifier not found");  }  
Magic Number,IdSharp.AudioInfo,RiffWave,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\RiffWave\RiffWave.cs,ReadStream,The following statement contains a magic number: if (header [8] != 'W' || header [9] != 'A' || header [10] != 'V' || header [11] != 'E') {  	throw new InvalidDataException ("'WAVE' identifier not found");  }  
Magic Number,IdSharp.AudioInfo,RiffWave,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\RiffWave\RiffWave.cs,ReadStream,The following statement contains a magic number: if (header [8] != 'W' || header [9] != 'A' || header [10] != 'V' || header [11] != 'E') {  	throw new InvalidDataException ("'WAVE' identifier not found");  }  
Magic Number,IdSharp.AudioInfo,RiffWave,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\RiffWave\RiffWave.cs,ReadStream,The following statement contains a magic number: if (header [8] != 'W' || header [9] != 'A' || header [10] != 'V' || header [11] != 'E') {  	throw new InvalidDataException ("'WAVE' identifier not found");  }  
Magic Number,IdSharp.AudioInfo,RiffWave,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\RiffWave\RiffWave.cs,ReadStream,The following statement contains a magic number: while (true) {  	byte[] identifierHeader = stream.Read (4);  	dataSize = stream.ReadInt32LittleEndian ();  	// the data block starts WAV data  	if (identifierHeader [0] == 'd' && identifierHeader [1] == 'a' && identifierHeader [2] == 't' && identifierHeader [3] == 'a')  		break;  	byte[] data = stream.Read (dataSize);  	if (identifierHeader [0] == 'f' && identifierHeader [1] == 'm' && identifierHeader [2] == 't' && identifierHeader [3] == ' ') {  		fmtBlockFound = true;  		//int extraBytes = hdr[16] + (hdr[17] << 8) + (hdr[18] << 16) + (hdr[19] << 24) - 16;  		// start at 20  		int compression = data [0] + (data [1] << 8);  		// Type 1 is PCM/Uncompressed  		if (compression != 1)  			throw new NotSupportedException ("Only PCM/Uncompressed is supported");  		_channels = data [2] + (data [3] << 8);  		// Only mono or stereo PCM is supported in this example  		if (_channels < 1 || _channels > 2)  			throw new NotSupportedException ("Only mono or stereo PCM is supported");  		// Samples per second' independent of number of channels  		_frequency = data [4] + (data [5] << 8) + (data [6] << 16) + (data [7] << 24);  		// Bytes 8-11 contain the "average bytes per second"' unneeded here  		// Bytes 12-13 contain the number of bytes per sample (includes channels)  		// Bytes 14-15 contain the number of bits per single sample  		int bits = data [14] + (data [15] << 8);  		// Supporting othe sample depths will require conversion  		if (bits != 16)  			throw new InvalidDataException (string.Format ("Only 16-bit audio is supported (bits={0})"' bits));  		// Skip past extra bytes' if any  		//if (extraBytes != 0)  		//	stream.Seek(extraBytes' SeekOrigin.Current);  	}  }  
Magic Number,IdSharp.AudioInfo,RiffWave,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\RiffWave\RiffWave.cs,ReadStream,The following statement contains a magic number: while (true) {  	byte[] identifierHeader = stream.Read (4);  	dataSize = stream.ReadInt32LittleEndian ();  	// the data block starts WAV data  	if (identifierHeader [0] == 'd' && identifierHeader [1] == 'a' && identifierHeader [2] == 't' && identifierHeader [3] == 'a')  		break;  	byte[] data = stream.Read (dataSize);  	if (identifierHeader [0] == 'f' && identifierHeader [1] == 'm' && identifierHeader [2] == 't' && identifierHeader [3] == ' ') {  		fmtBlockFound = true;  		//int extraBytes = hdr[16] + (hdr[17] << 8) + (hdr[18] << 16) + (hdr[19] << 24) - 16;  		// start at 20  		int compression = data [0] + (data [1] << 8);  		// Type 1 is PCM/Uncompressed  		if (compression != 1)  			throw new NotSupportedException ("Only PCM/Uncompressed is supported");  		_channels = data [2] + (data [3] << 8);  		// Only mono or stereo PCM is supported in this example  		if (_channels < 1 || _channels > 2)  			throw new NotSupportedException ("Only mono or stereo PCM is supported");  		// Samples per second' independent of number of channels  		_frequency = data [4] + (data [5] << 8) + (data [6] << 16) + (data [7] << 24);  		// Bytes 8-11 contain the "average bytes per second"' unneeded here  		// Bytes 12-13 contain the number of bytes per sample (includes channels)  		// Bytes 14-15 contain the number of bits per single sample  		int bits = data [14] + (data [15] << 8);  		// Supporting othe sample depths will require conversion  		if (bits != 16)  			throw new InvalidDataException (string.Format ("Only 16-bit audio is supported (bits={0})"' bits));  		// Skip past extra bytes' if any  		//if (extraBytes != 0)  		//	stream.Seek(extraBytes' SeekOrigin.Current);  	}  }  
Magic Number,IdSharp.AudioInfo,RiffWave,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\RiffWave\RiffWave.cs,ReadStream,The following statement contains a magic number: while (true) {  	byte[] identifierHeader = stream.Read (4);  	dataSize = stream.ReadInt32LittleEndian ();  	// the data block starts WAV data  	if (identifierHeader [0] == 'd' && identifierHeader [1] == 'a' && identifierHeader [2] == 't' && identifierHeader [3] == 'a')  		break;  	byte[] data = stream.Read (dataSize);  	if (identifierHeader [0] == 'f' && identifierHeader [1] == 'm' && identifierHeader [2] == 't' && identifierHeader [3] == ' ') {  		fmtBlockFound = true;  		//int extraBytes = hdr[16] + (hdr[17] << 8) + (hdr[18] << 16) + (hdr[19] << 24) - 16;  		// start at 20  		int compression = data [0] + (data [1] << 8);  		// Type 1 is PCM/Uncompressed  		if (compression != 1)  			throw new NotSupportedException ("Only PCM/Uncompressed is supported");  		_channels = data [2] + (data [3] << 8);  		// Only mono or stereo PCM is supported in this example  		if (_channels < 1 || _channels > 2)  			throw new NotSupportedException ("Only mono or stereo PCM is supported");  		// Samples per second' independent of number of channels  		_frequency = data [4] + (data [5] << 8) + (data [6] << 16) + (data [7] << 24);  		// Bytes 8-11 contain the "average bytes per second"' unneeded here  		// Bytes 12-13 contain the number of bytes per sample (includes channels)  		// Bytes 14-15 contain the number of bits per single sample  		int bits = data [14] + (data [15] << 8);  		// Supporting othe sample depths will require conversion  		if (bits != 16)  			throw new InvalidDataException (string.Format ("Only 16-bit audio is supported (bits={0})"' bits));  		// Skip past extra bytes' if any  		//if (extraBytes != 0)  		//	stream.Seek(extraBytes' SeekOrigin.Current);  	}  }  
Magic Number,IdSharp.AudioInfo,RiffWave,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\RiffWave\RiffWave.cs,ReadStream,The following statement contains a magic number: while (true) {  	byte[] identifierHeader = stream.Read (4);  	dataSize = stream.ReadInt32LittleEndian ();  	// the data block starts WAV data  	if (identifierHeader [0] == 'd' && identifierHeader [1] == 'a' && identifierHeader [2] == 't' && identifierHeader [3] == 'a')  		break;  	byte[] data = stream.Read (dataSize);  	if (identifierHeader [0] == 'f' && identifierHeader [1] == 'm' && identifierHeader [2] == 't' && identifierHeader [3] == ' ') {  		fmtBlockFound = true;  		//int extraBytes = hdr[16] + (hdr[17] << 8) + (hdr[18] << 16) + (hdr[19] << 24) - 16;  		// start at 20  		int compression = data [0] + (data [1] << 8);  		// Type 1 is PCM/Uncompressed  		if (compression != 1)  			throw new NotSupportedException ("Only PCM/Uncompressed is supported");  		_channels = data [2] + (data [3] << 8);  		// Only mono or stereo PCM is supported in this example  		if (_channels < 1 || _channels > 2)  			throw new NotSupportedException ("Only mono or stereo PCM is supported");  		// Samples per second' independent of number of channels  		_frequency = data [4] + (data [5] << 8) + (data [6] << 16) + (data [7] << 24);  		// Bytes 8-11 contain the "average bytes per second"' unneeded here  		// Bytes 12-13 contain the number of bytes per sample (includes channels)  		// Bytes 14-15 contain the number of bits per single sample  		int bits = data [14] + (data [15] << 8);  		// Supporting othe sample depths will require conversion  		if (bits != 16)  			throw new InvalidDataException (string.Format ("Only 16-bit audio is supported (bits={0})"' bits));  		// Skip past extra bytes' if any  		//if (extraBytes != 0)  		//	stream.Seek(extraBytes' SeekOrigin.Current);  	}  }  
Magic Number,IdSharp.AudioInfo,RiffWave,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\RiffWave\RiffWave.cs,ReadStream,The following statement contains a magic number: while (true) {  	byte[] identifierHeader = stream.Read (4);  	dataSize = stream.ReadInt32LittleEndian ();  	// the data block starts WAV data  	if (identifierHeader [0] == 'd' && identifierHeader [1] == 'a' && identifierHeader [2] == 't' && identifierHeader [3] == 'a')  		break;  	byte[] data = stream.Read (dataSize);  	if (identifierHeader [0] == 'f' && identifierHeader [1] == 'm' && identifierHeader [2] == 't' && identifierHeader [3] == ' ') {  		fmtBlockFound = true;  		//int extraBytes = hdr[16] + (hdr[17] << 8) + (hdr[18] << 16) + (hdr[19] << 24) - 16;  		// start at 20  		int compression = data [0] + (data [1] << 8);  		// Type 1 is PCM/Uncompressed  		if (compression != 1)  			throw new NotSupportedException ("Only PCM/Uncompressed is supported");  		_channels = data [2] + (data [3] << 8);  		// Only mono or stereo PCM is supported in this example  		if (_channels < 1 || _channels > 2)  			throw new NotSupportedException ("Only mono or stereo PCM is supported");  		// Samples per second' independent of number of channels  		_frequency = data [4] + (data [5] << 8) + (data [6] << 16) + (data [7] << 24);  		// Bytes 8-11 contain the "average bytes per second"' unneeded here  		// Bytes 12-13 contain the number of bytes per sample (includes channels)  		// Bytes 14-15 contain the number of bits per single sample  		int bits = data [14] + (data [15] << 8);  		// Supporting othe sample depths will require conversion  		if (bits != 16)  			throw new InvalidDataException (string.Format ("Only 16-bit audio is supported (bits={0})"' bits));  		// Skip past extra bytes' if any  		//if (extraBytes != 0)  		//	stream.Seek(extraBytes' SeekOrigin.Current);  	}  }  
Magic Number,IdSharp.AudioInfo,RiffWave,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\RiffWave\RiffWave.cs,ReadStream,The following statement contains a magic number: while (true) {  	byte[] identifierHeader = stream.Read (4);  	dataSize = stream.ReadInt32LittleEndian ();  	// the data block starts WAV data  	if (identifierHeader [0] == 'd' && identifierHeader [1] == 'a' && identifierHeader [2] == 't' && identifierHeader [3] == 'a')  		break;  	byte[] data = stream.Read (dataSize);  	if (identifierHeader [0] == 'f' && identifierHeader [1] == 'm' && identifierHeader [2] == 't' && identifierHeader [3] == ' ') {  		fmtBlockFound = true;  		//int extraBytes = hdr[16] + (hdr[17] << 8) + (hdr[18] << 16) + (hdr[19] << 24) - 16;  		// start at 20  		int compression = data [0] + (data [1] << 8);  		// Type 1 is PCM/Uncompressed  		if (compression != 1)  			throw new NotSupportedException ("Only PCM/Uncompressed is supported");  		_channels = data [2] + (data [3] << 8);  		// Only mono or stereo PCM is supported in this example  		if (_channels < 1 || _channels > 2)  			throw new NotSupportedException ("Only mono or stereo PCM is supported");  		// Samples per second' independent of number of channels  		_frequency = data [4] + (data [5] << 8) + (data [6] << 16) + (data [7] << 24);  		// Bytes 8-11 contain the "average bytes per second"' unneeded here  		// Bytes 12-13 contain the number of bytes per sample (includes channels)  		// Bytes 14-15 contain the number of bits per single sample  		int bits = data [14] + (data [15] << 8);  		// Supporting othe sample depths will require conversion  		if (bits != 16)  			throw new InvalidDataException (string.Format ("Only 16-bit audio is supported (bits={0})"' bits));  		// Skip past extra bytes' if any  		//if (extraBytes != 0)  		//	stream.Seek(extraBytes' SeekOrigin.Current);  	}  }  
Magic Number,IdSharp.AudioInfo,RiffWave,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\RiffWave\RiffWave.cs,ReadStream,The following statement contains a magic number: while (true) {  	byte[] identifierHeader = stream.Read (4);  	dataSize = stream.ReadInt32LittleEndian ();  	// the data block starts WAV data  	if (identifierHeader [0] == 'd' && identifierHeader [1] == 'a' && identifierHeader [2] == 't' && identifierHeader [3] == 'a')  		break;  	byte[] data = stream.Read (dataSize);  	if (identifierHeader [0] == 'f' && identifierHeader [1] == 'm' && identifierHeader [2] == 't' && identifierHeader [3] == ' ') {  		fmtBlockFound = true;  		//int extraBytes = hdr[16] + (hdr[17] << 8) + (hdr[18] << 16) + (hdr[19] << 24) - 16;  		// start at 20  		int compression = data [0] + (data [1] << 8);  		// Type 1 is PCM/Uncompressed  		if (compression != 1)  			throw new NotSupportedException ("Only PCM/Uncompressed is supported");  		_channels = data [2] + (data [3] << 8);  		// Only mono or stereo PCM is supported in this example  		if (_channels < 1 || _channels > 2)  			throw new NotSupportedException ("Only mono or stereo PCM is supported");  		// Samples per second' independent of number of channels  		_frequency = data [4] + (data [5] << 8) + (data [6] << 16) + (data [7] << 24);  		// Bytes 8-11 contain the "average bytes per second"' unneeded here  		// Bytes 12-13 contain the number of bytes per sample (includes channels)  		// Bytes 14-15 contain the number of bits per single sample  		int bits = data [14] + (data [15] << 8);  		// Supporting othe sample depths will require conversion  		if (bits != 16)  			throw new InvalidDataException (string.Format ("Only 16-bit audio is supported (bits={0})"' bits));  		// Skip past extra bytes' if any  		//if (extraBytes != 0)  		//	stream.Seek(extraBytes' SeekOrigin.Current);  	}  }  
Magic Number,IdSharp.AudioInfo,RiffWave,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\RiffWave\RiffWave.cs,ReadStream,The following statement contains a magic number: while (true) {  	byte[] identifierHeader = stream.Read (4);  	dataSize = stream.ReadInt32LittleEndian ();  	// the data block starts WAV data  	if (identifierHeader [0] == 'd' && identifierHeader [1] == 'a' && identifierHeader [2] == 't' && identifierHeader [3] == 'a')  		break;  	byte[] data = stream.Read (dataSize);  	if (identifierHeader [0] == 'f' && identifierHeader [1] == 'm' && identifierHeader [2] == 't' && identifierHeader [3] == ' ') {  		fmtBlockFound = true;  		//int extraBytes = hdr[16] + (hdr[17] << 8) + (hdr[18] << 16) + (hdr[19] << 24) - 16;  		// start at 20  		int compression = data [0] + (data [1] << 8);  		// Type 1 is PCM/Uncompressed  		if (compression != 1)  			throw new NotSupportedException ("Only PCM/Uncompressed is supported");  		_channels = data [2] + (data [3] << 8);  		// Only mono or stereo PCM is supported in this example  		if (_channels < 1 || _channels > 2)  			throw new NotSupportedException ("Only mono or stereo PCM is supported");  		// Samples per second' independent of number of channels  		_frequency = data [4] + (data [5] << 8) + (data [6] << 16) + (data [7] << 24);  		// Bytes 8-11 contain the "average bytes per second"' unneeded here  		// Bytes 12-13 contain the number of bytes per sample (includes channels)  		// Bytes 14-15 contain the number of bits per single sample  		int bits = data [14] + (data [15] << 8);  		// Supporting othe sample depths will require conversion  		if (bits != 16)  			throw new InvalidDataException (string.Format ("Only 16-bit audio is supported (bits={0})"' bits));  		// Skip past extra bytes' if any  		//if (extraBytes != 0)  		//	stream.Seek(extraBytes' SeekOrigin.Current);  	}  }  
Magic Number,IdSharp.AudioInfo,RiffWave,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\RiffWave\RiffWave.cs,ReadStream,The following statement contains a magic number: while (true) {  	byte[] identifierHeader = stream.Read (4);  	dataSize = stream.ReadInt32LittleEndian ();  	// the data block starts WAV data  	if (identifierHeader [0] == 'd' && identifierHeader [1] == 'a' && identifierHeader [2] == 't' && identifierHeader [3] == 'a')  		break;  	byte[] data = stream.Read (dataSize);  	if (identifierHeader [0] == 'f' && identifierHeader [1] == 'm' && identifierHeader [2] == 't' && identifierHeader [3] == ' ') {  		fmtBlockFound = true;  		//int extraBytes = hdr[16] + (hdr[17] << 8) + (hdr[18] << 16) + (hdr[19] << 24) - 16;  		// start at 20  		int compression = data [0] + (data [1] << 8);  		// Type 1 is PCM/Uncompressed  		if (compression != 1)  			throw new NotSupportedException ("Only PCM/Uncompressed is supported");  		_channels = data [2] + (data [3] << 8);  		// Only mono or stereo PCM is supported in this example  		if (_channels < 1 || _channels > 2)  			throw new NotSupportedException ("Only mono or stereo PCM is supported");  		// Samples per second' independent of number of channels  		_frequency = data [4] + (data [5] << 8) + (data [6] << 16) + (data [7] << 24);  		// Bytes 8-11 contain the "average bytes per second"' unneeded here  		// Bytes 12-13 contain the number of bytes per sample (includes channels)  		// Bytes 14-15 contain the number of bits per single sample  		int bits = data [14] + (data [15] << 8);  		// Supporting othe sample depths will require conversion  		if (bits != 16)  			throw new InvalidDataException (string.Format ("Only 16-bit audio is supported (bits={0})"' bits));  		// Skip past extra bytes' if any  		//if (extraBytes != 0)  		//	stream.Seek(extraBytes' SeekOrigin.Current);  	}  }  
Magic Number,IdSharp.AudioInfo,RiffWave,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\RiffWave\RiffWave.cs,ReadStream,The following statement contains a magic number: while (true) {  	byte[] identifierHeader = stream.Read (4);  	dataSize = stream.ReadInt32LittleEndian ();  	// the data block starts WAV data  	if (identifierHeader [0] == 'd' && identifierHeader [1] == 'a' && identifierHeader [2] == 't' && identifierHeader [3] == 'a')  		break;  	byte[] data = stream.Read (dataSize);  	if (identifierHeader [0] == 'f' && identifierHeader [1] == 'm' && identifierHeader [2] == 't' && identifierHeader [3] == ' ') {  		fmtBlockFound = true;  		//int extraBytes = hdr[16] + (hdr[17] << 8) + (hdr[18] << 16) + (hdr[19] << 24) - 16;  		// start at 20  		int compression = data [0] + (data [1] << 8);  		// Type 1 is PCM/Uncompressed  		if (compression != 1)  			throw new NotSupportedException ("Only PCM/Uncompressed is supported");  		_channels = data [2] + (data [3] << 8);  		// Only mono or stereo PCM is supported in this example  		if (_channels < 1 || _channels > 2)  			throw new NotSupportedException ("Only mono or stereo PCM is supported");  		// Samples per second' independent of number of channels  		_frequency = data [4] + (data [5] << 8) + (data [6] << 16) + (data [7] << 24);  		// Bytes 8-11 contain the "average bytes per second"' unneeded here  		// Bytes 12-13 contain the number of bytes per sample (includes channels)  		// Bytes 14-15 contain the number of bits per single sample  		int bits = data [14] + (data [15] << 8);  		// Supporting othe sample depths will require conversion  		if (bits != 16)  			throw new InvalidDataException (string.Format ("Only 16-bit audio is supported (bits={0})"' bits));  		// Skip past extra bytes' if any  		//if (extraBytes != 0)  		//	stream.Seek(extraBytes' SeekOrigin.Current);  	}  }  
Magic Number,IdSharp.AudioInfo,RiffWave,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\RiffWave\RiffWave.cs,ReadStream,The following statement contains a magic number: while (true) {  	byte[] identifierHeader = stream.Read (4);  	dataSize = stream.ReadInt32LittleEndian ();  	// the data block starts WAV data  	if (identifierHeader [0] == 'd' && identifierHeader [1] == 'a' && identifierHeader [2] == 't' && identifierHeader [3] == 'a')  		break;  	byte[] data = stream.Read (dataSize);  	if (identifierHeader [0] == 'f' && identifierHeader [1] == 'm' && identifierHeader [2] == 't' && identifierHeader [3] == ' ') {  		fmtBlockFound = true;  		//int extraBytes = hdr[16] + (hdr[17] << 8) + (hdr[18] << 16) + (hdr[19] << 24) - 16;  		// start at 20  		int compression = data [0] + (data [1] << 8);  		// Type 1 is PCM/Uncompressed  		if (compression != 1)  			throw new NotSupportedException ("Only PCM/Uncompressed is supported");  		_channels = data [2] + (data [3] << 8);  		// Only mono or stereo PCM is supported in this example  		if (_channels < 1 || _channels > 2)  			throw new NotSupportedException ("Only mono or stereo PCM is supported");  		// Samples per second' independent of number of channels  		_frequency = data [4] + (data [5] << 8) + (data [6] << 16) + (data [7] << 24);  		// Bytes 8-11 contain the "average bytes per second"' unneeded here  		// Bytes 12-13 contain the number of bytes per sample (includes channels)  		// Bytes 14-15 contain the number of bits per single sample  		int bits = data [14] + (data [15] << 8);  		// Supporting othe sample depths will require conversion  		if (bits != 16)  			throw new InvalidDataException (string.Format ("Only 16-bit audio is supported (bits={0})"' bits));  		// Skip past extra bytes' if any  		//if (extraBytes != 0)  		//	stream.Seek(extraBytes' SeekOrigin.Current);  	}  }  
Magic Number,IdSharp.AudioInfo,RiffWave,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\RiffWave\RiffWave.cs,ReadStream,The following statement contains a magic number: while (true) {  	byte[] identifierHeader = stream.Read (4);  	dataSize = stream.ReadInt32LittleEndian ();  	// the data block starts WAV data  	if (identifierHeader [0] == 'd' && identifierHeader [1] == 'a' && identifierHeader [2] == 't' && identifierHeader [3] == 'a')  		break;  	byte[] data = stream.Read (dataSize);  	if (identifierHeader [0] == 'f' && identifierHeader [1] == 'm' && identifierHeader [2] == 't' && identifierHeader [3] == ' ') {  		fmtBlockFound = true;  		//int extraBytes = hdr[16] + (hdr[17] << 8) + (hdr[18] << 16) + (hdr[19] << 24) - 16;  		// start at 20  		int compression = data [0] + (data [1] << 8);  		// Type 1 is PCM/Uncompressed  		if (compression != 1)  			throw new NotSupportedException ("Only PCM/Uncompressed is supported");  		_channels = data [2] + (data [3] << 8);  		// Only mono or stereo PCM is supported in this example  		if (_channels < 1 || _channels > 2)  			throw new NotSupportedException ("Only mono or stereo PCM is supported");  		// Samples per second' independent of number of channels  		_frequency = data [4] + (data [5] << 8) + (data [6] << 16) + (data [7] << 24);  		// Bytes 8-11 contain the "average bytes per second"' unneeded here  		// Bytes 12-13 contain the number of bytes per sample (includes channels)  		// Bytes 14-15 contain the number of bits per single sample  		int bits = data [14] + (data [15] << 8);  		// Supporting othe sample depths will require conversion  		if (bits != 16)  			throw new InvalidDataException (string.Format ("Only 16-bit audio is supported (bits={0})"' bits));  		// Skip past extra bytes' if any  		//if (extraBytes != 0)  		//	stream.Seek(extraBytes' SeekOrigin.Current);  	}  }  
Magic Number,IdSharp.AudioInfo,RiffWave,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\RiffWave\RiffWave.cs,ReadStream,The following statement contains a magic number: while (true) {  	byte[] identifierHeader = stream.Read (4);  	dataSize = stream.ReadInt32LittleEndian ();  	// the data block starts WAV data  	if (identifierHeader [0] == 'd' && identifierHeader [1] == 'a' && identifierHeader [2] == 't' && identifierHeader [3] == 'a')  		break;  	byte[] data = stream.Read (dataSize);  	if (identifierHeader [0] == 'f' && identifierHeader [1] == 'm' && identifierHeader [2] == 't' && identifierHeader [3] == ' ') {  		fmtBlockFound = true;  		//int extraBytes = hdr[16] + (hdr[17] << 8) + (hdr[18] << 16) + (hdr[19] << 24) - 16;  		// start at 20  		int compression = data [0] + (data [1] << 8);  		// Type 1 is PCM/Uncompressed  		if (compression != 1)  			throw new NotSupportedException ("Only PCM/Uncompressed is supported");  		_channels = data [2] + (data [3] << 8);  		// Only mono or stereo PCM is supported in this example  		if (_channels < 1 || _channels > 2)  			throw new NotSupportedException ("Only mono or stereo PCM is supported");  		// Samples per second' independent of number of channels  		_frequency = data [4] + (data [5] << 8) + (data [6] << 16) + (data [7] << 24);  		// Bytes 8-11 contain the "average bytes per second"' unneeded here  		// Bytes 12-13 contain the number of bytes per sample (includes channels)  		// Bytes 14-15 contain the number of bits per single sample  		int bits = data [14] + (data [15] << 8);  		// Supporting othe sample depths will require conversion  		if (bits != 16)  			throw new InvalidDataException (string.Format ("Only 16-bit audio is supported (bits={0})"' bits));  		// Skip past extra bytes' if any  		//if (extraBytes != 0)  		//	stream.Seek(extraBytes' SeekOrigin.Current);  	}  }  
Magic Number,IdSharp.AudioInfo,RiffWave,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\RiffWave\RiffWave.cs,ReadStream,The following statement contains a magic number: while (true) {  	byte[] identifierHeader = stream.Read (4);  	dataSize = stream.ReadInt32LittleEndian ();  	// the data block starts WAV data  	if (identifierHeader [0] == 'd' && identifierHeader [1] == 'a' && identifierHeader [2] == 't' && identifierHeader [3] == 'a')  		break;  	byte[] data = stream.Read (dataSize);  	if (identifierHeader [0] == 'f' && identifierHeader [1] == 'm' && identifierHeader [2] == 't' && identifierHeader [3] == ' ') {  		fmtBlockFound = true;  		//int extraBytes = hdr[16] + (hdr[17] << 8) + (hdr[18] << 16) + (hdr[19] << 24) - 16;  		// start at 20  		int compression = data [0] + (data [1] << 8);  		// Type 1 is PCM/Uncompressed  		if (compression != 1)  			throw new NotSupportedException ("Only PCM/Uncompressed is supported");  		_channels = data [2] + (data [3] << 8);  		// Only mono or stereo PCM is supported in this example  		if (_channels < 1 || _channels > 2)  			throw new NotSupportedException ("Only mono or stereo PCM is supported");  		// Samples per second' independent of number of channels  		_frequency = data [4] + (data [5] << 8) + (data [6] << 16) + (data [7] << 24);  		// Bytes 8-11 contain the "average bytes per second"' unneeded here  		// Bytes 12-13 contain the number of bytes per sample (includes channels)  		// Bytes 14-15 contain the number of bits per single sample  		int bits = data [14] + (data [15] << 8);  		// Supporting othe sample depths will require conversion  		if (bits != 16)  			throw new InvalidDataException (string.Format ("Only 16-bit audio is supported (bits={0})"' bits));  		// Skip past extra bytes' if any  		//if (extraBytes != 0)  		//	stream.Seek(extraBytes' SeekOrigin.Current);  	}  }  
Magic Number,IdSharp.AudioInfo,RiffWave,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\RiffWave\RiffWave.cs,ReadStream,The following statement contains a magic number: while (true) {  	byte[] identifierHeader = stream.Read (4);  	dataSize = stream.ReadInt32LittleEndian ();  	// the data block starts WAV data  	if (identifierHeader [0] == 'd' && identifierHeader [1] == 'a' && identifierHeader [2] == 't' && identifierHeader [3] == 'a')  		break;  	byte[] data = stream.Read (dataSize);  	if (identifierHeader [0] == 'f' && identifierHeader [1] == 'm' && identifierHeader [2] == 't' && identifierHeader [3] == ' ') {  		fmtBlockFound = true;  		//int extraBytes = hdr[16] + (hdr[17] << 8) + (hdr[18] << 16) + (hdr[19] << 24) - 16;  		// start at 20  		int compression = data [0] + (data [1] << 8);  		// Type 1 is PCM/Uncompressed  		if (compression != 1)  			throw new NotSupportedException ("Only PCM/Uncompressed is supported");  		_channels = data [2] + (data [3] << 8);  		// Only mono or stereo PCM is supported in this example  		if (_channels < 1 || _channels > 2)  			throw new NotSupportedException ("Only mono or stereo PCM is supported");  		// Samples per second' independent of number of channels  		_frequency = data [4] + (data [5] << 8) + (data [6] << 16) + (data [7] << 24);  		// Bytes 8-11 contain the "average bytes per second"' unneeded here  		// Bytes 12-13 contain the number of bytes per sample (includes channels)  		// Bytes 14-15 contain the number of bits per single sample  		int bits = data [14] + (data [15] << 8);  		// Supporting othe sample depths will require conversion  		if (bits != 16)  			throw new InvalidDataException (string.Format ("Only 16-bit audio is supported (bits={0})"' bits));  		// Skip past extra bytes' if any  		//if (extraBytes != 0)  		//	stream.Seek(extraBytes' SeekOrigin.Current);  	}  }  
Magic Number,IdSharp.AudioInfo,RiffWave,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\RiffWave\RiffWave.cs,ReadStream,The following statement contains a magic number: while (true) {  	byte[] identifierHeader = stream.Read (4);  	dataSize = stream.ReadInt32LittleEndian ();  	// the data block starts WAV data  	if (identifierHeader [0] == 'd' && identifierHeader [1] == 'a' && identifierHeader [2] == 't' && identifierHeader [3] == 'a')  		break;  	byte[] data = stream.Read (dataSize);  	if (identifierHeader [0] == 'f' && identifierHeader [1] == 'm' && identifierHeader [2] == 't' && identifierHeader [3] == ' ') {  		fmtBlockFound = true;  		//int extraBytes = hdr[16] + (hdr[17] << 8) + (hdr[18] << 16) + (hdr[19] << 24) - 16;  		// start at 20  		int compression = data [0] + (data [1] << 8);  		// Type 1 is PCM/Uncompressed  		if (compression != 1)  			throw new NotSupportedException ("Only PCM/Uncompressed is supported");  		_channels = data [2] + (data [3] << 8);  		// Only mono or stereo PCM is supported in this example  		if (_channels < 1 || _channels > 2)  			throw new NotSupportedException ("Only mono or stereo PCM is supported");  		// Samples per second' independent of number of channels  		_frequency = data [4] + (data [5] << 8) + (data [6] << 16) + (data [7] << 24);  		// Bytes 8-11 contain the "average bytes per second"' unneeded here  		// Bytes 12-13 contain the number of bytes per sample (includes channels)  		// Bytes 14-15 contain the number of bits per single sample  		int bits = data [14] + (data [15] << 8);  		// Supporting othe sample depths will require conversion  		if (bits != 16)  			throw new InvalidDataException (string.Format ("Only 16-bit audio is supported (bits={0})"' bits));  		// Skip past extra bytes' if any  		//if (extraBytes != 0)  		//	stream.Seek(extraBytes' SeekOrigin.Current);  	}  }  
Magic Number,IdSharp.AudioInfo,RiffWave,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\RiffWave\RiffWave.cs,ReadStream,The following statement contains a magic number: while (true) {  	byte[] identifierHeader = stream.Read (4);  	dataSize = stream.ReadInt32LittleEndian ();  	// the data block starts WAV data  	if (identifierHeader [0] == 'd' && identifierHeader [1] == 'a' && identifierHeader [2] == 't' && identifierHeader [3] == 'a')  		break;  	byte[] data = stream.Read (dataSize);  	if (identifierHeader [0] == 'f' && identifierHeader [1] == 'm' && identifierHeader [2] == 't' && identifierHeader [3] == ' ') {  		fmtBlockFound = true;  		//int extraBytes = hdr[16] + (hdr[17] << 8) + (hdr[18] << 16) + (hdr[19] << 24) - 16;  		// start at 20  		int compression = data [0] + (data [1] << 8);  		// Type 1 is PCM/Uncompressed  		if (compression != 1)  			throw new NotSupportedException ("Only PCM/Uncompressed is supported");  		_channels = data [2] + (data [3] << 8);  		// Only mono or stereo PCM is supported in this example  		if (_channels < 1 || _channels > 2)  			throw new NotSupportedException ("Only mono or stereo PCM is supported");  		// Samples per second' independent of number of channels  		_frequency = data [4] + (data [5] << 8) + (data [6] << 16) + (data [7] << 24);  		// Bytes 8-11 contain the "average bytes per second"' unneeded here  		// Bytes 12-13 contain the number of bytes per sample (includes channels)  		// Bytes 14-15 contain the number of bits per single sample  		int bits = data [14] + (data [15] << 8);  		// Supporting othe sample depths will require conversion  		if (bits != 16)  			throw new InvalidDataException (string.Format ("Only 16-bit audio is supported (bits={0})"' bits));  		// Skip past extra bytes' if any  		//if (extraBytes != 0)  		//	stream.Seek(extraBytes' SeekOrigin.Current);  	}  }  
Magic Number,IdSharp.AudioInfo,RiffWave,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\RiffWave\RiffWave.cs,ReadStream,The following statement contains a magic number: while (true) {  	byte[] identifierHeader = stream.Read (4);  	dataSize = stream.ReadInt32LittleEndian ();  	// the data block starts WAV data  	if (identifierHeader [0] == 'd' && identifierHeader [1] == 'a' && identifierHeader [2] == 't' && identifierHeader [3] == 'a')  		break;  	byte[] data = stream.Read (dataSize);  	if (identifierHeader [0] == 'f' && identifierHeader [1] == 'm' && identifierHeader [2] == 't' && identifierHeader [3] == ' ') {  		fmtBlockFound = true;  		//int extraBytes = hdr[16] + (hdr[17] << 8) + (hdr[18] << 16) + (hdr[19] << 24) - 16;  		// start at 20  		int compression = data [0] + (data [1] << 8);  		// Type 1 is PCM/Uncompressed  		if (compression != 1)  			throw new NotSupportedException ("Only PCM/Uncompressed is supported");  		_channels = data [2] + (data [3] << 8);  		// Only mono or stereo PCM is supported in this example  		if (_channels < 1 || _channels > 2)  			throw new NotSupportedException ("Only mono or stereo PCM is supported");  		// Samples per second' independent of number of channels  		_frequency = data [4] + (data [5] << 8) + (data [6] << 16) + (data [7] << 24);  		// Bytes 8-11 contain the "average bytes per second"' unneeded here  		// Bytes 12-13 contain the number of bytes per sample (includes channels)  		// Bytes 14-15 contain the number of bits per single sample  		int bits = data [14] + (data [15] << 8);  		// Supporting othe sample depths will require conversion  		if (bits != 16)  			throw new InvalidDataException (string.Format ("Only 16-bit audio is supported (bits={0})"' bits));  		// Skip past extra bytes' if any  		//if (extraBytes != 0)  		//	stream.Seek(extraBytes' SeekOrigin.Current);  	}  }  
Magic Number,IdSharp.AudioInfo,RiffWave,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\RiffWave\RiffWave.cs,ReadStream,The following statement contains a magic number: while (true) {  	byte[] identifierHeader = stream.Read (4);  	dataSize = stream.ReadInt32LittleEndian ();  	// the data block starts WAV data  	if (identifierHeader [0] == 'd' && identifierHeader [1] == 'a' && identifierHeader [2] == 't' && identifierHeader [3] == 'a')  		break;  	byte[] data = stream.Read (dataSize);  	if (identifierHeader [0] == 'f' && identifierHeader [1] == 'm' && identifierHeader [2] == 't' && identifierHeader [3] == ' ') {  		fmtBlockFound = true;  		//int extraBytes = hdr[16] + (hdr[17] << 8) + (hdr[18] << 16) + (hdr[19] << 24) - 16;  		// start at 20  		int compression = data [0] + (data [1] << 8);  		// Type 1 is PCM/Uncompressed  		if (compression != 1)  			throw new NotSupportedException ("Only PCM/Uncompressed is supported");  		_channels = data [2] + (data [3] << 8);  		// Only mono or stereo PCM is supported in this example  		if (_channels < 1 || _channels > 2)  			throw new NotSupportedException ("Only mono or stereo PCM is supported");  		// Samples per second' independent of number of channels  		_frequency = data [4] + (data [5] << 8) + (data [6] << 16) + (data [7] << 24);  		// Bytes 8-11 contain the "average bytes per second"' unneeded here  		// Bytes 12-13 contain the number of bytes per sample (includes channels)  		// Bytes 14-15 contain the number of bits per single sample  		int bits = data [14] + (data [15] << 8);  		// Supporting othe sample depths will require conversion  		if (bits != 16)  			throw new InvalidDataException (string.Format ("Only 16-bit audio is supported (bits={0})"' bits));  		// Skip past extra bytes' if any  		//if (extraBytes != 0)  		//	stream.Seek(extraBytes' SeekOrigin.Current);  	}  }  
Magic Number,IdSharp.AudioInfo,RiffWave,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\RiffWave\RiffWave.cs,ReadStream,The following statement contains a magic number: while (true) {  	byte[] identifierHeader = stream.Read (4);  	dataSize = stream.ReadInt32LittleEndian ();  	// the data block starts WAV data  	if (identifierHeader [0] == 'd' && identifierHeader [1] == 'a' && identifierHeader [2] == 't' && identifierHeader [3] == 'a')  		break;  	byte[] data = stream.Read (dataSize);  	if (identifierHeader [0] == 'f' && identifierHeader [1] == 'm' && identifierHeader [2] == 't' && identifierHeader [3] == ' ') {  		fmtBlockFound = true;  		//int extraBytes = hdr[16] + (hdr[17] << 8) + (hdr[18] << 16) + (hdr[19] << 24) - 16;  		// start at 20  		int compression = data [0] + (data [1] << 8);  		// Type 1 is PCM/Uncompressed  		if (compression != 1)  			throw new NotSupportedException ("Only PCM/Uncompressed is supported");  		_channels = data [2] + (data [3] << 8);  		// Only mono or stereo PCM is supported in this example  		if (_channels < 1 || _channels > 2)  			throw new NotSupportedException ("Only mono or stereo PCM is supported");  		// Samples per second' independent of number of channels  		_frequency = data [4] + (data [5] << 8) + (data [6] << 16) + (data [7] << 24);  		// Bytes 8-11 contain the "average bytes per second"' unneeded here  		// Bytes 12-13 contain the number of bytes per sample (includes channels)  		// Bytes 14-15 contain the number of bits per single sample  		int bits = data [14] + (data [15] << 8);  		// Supporting othe sample depths will require conversion  		if (bits != 16)  			throw new InvalidDataException (string.Format ("Only 16-bit audio is supported (bits={0})"' bits));  		// Skip past extra bytes' if any  		//if (extraBytes != 0)  		//	stream.Seek(extraBytes' SeekOrigin.Current);  	}  }  
Magic Number,IdSharp.AudioInfo,RiffWave,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\RiffWave\RiffWave.cs,ReadStream,The following statement contains a magic number: while (true) {  	byte[] identifierHeader = stream.Read (4);  	dataSize = stream.ReadInt32LittleEndian ();  	// the data block starts WAV data  	if (identifierHeader [0] == 'd' && identifierHeader [1] == 'a' && identifierHeader [2] == 't' && identifierHeader [3] == 'a')  		break;  	byte[] data = stream.Read (dataSize);  	if (identifierHeader [0] == 'f' && identifierHeader [1] == 'm' && identifierHeader [2] == 't' && identifierHeader [3] == ' ') {  		fmtBlockFound = true;  		//int extraBytes = hdr[16] + (hdr[17] << 8) + (hdr[18] << 16) + (hdr[19] << 24) - 16;  		// start at 20  		int compression = data [0] + (data [1] << 8);  		// Type 1 is PCM/Uncompressed  		if (compression != 1)  			throw new NotSupportedException ("Only PCM/Uncompressed is supported");  		_channels = data [2] + (data [3] << 8);  		// Only mono or stereo PCM is supported in this example  		if (_channels < 1 || _channels > 2)  			throw new NotSupportedException ("Only mono or stereo PCM is supported");  		// Samples per second' independent of number of channels  		_frequency = data [4] + (data [5] << 8) + (data [6] << 16) + (data [7] << 24);  		// Bytes 8-11 contain the "average bytes per second"' unneeded here  		// Bytes 12-13 contain the number of bytes per sample (includes channels)  		// Bytes 14-15 contain the number of bits per single sample  		int bits = data [14] + (data [15] << 8);  		// Supporting othe sample depths will require conversion  		if (bits != 16)  			throw new InvalidDataException (string.Format ("Only 16-bit audio is supported (bits={0})"' bits));  		// Skip past extra bytes' if any  		//if (extraBytes != 0)  		//	stream.Seek(extraBytes' SeekOrigin.Current);  	}  }  
Magic Number,IdSharp.AudioInfo,RiffWave,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\RiffWave\RiffWave.cs,ReadStream,The following statement contains a magic number: if (identifierHeader [0] == 'd' && identifierHeader [1] == 'a' && identifierHeader [2] == 't' && identifierHeader [3] == 'a')  	break;  
Magic Number,IdSharp.AudioInfo,RiffWave,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\RiffWave\RiffWave.cs,ReadStream,The following statement contains a magic number: if (identifierHeader [0] == 'd' && identifierHeader [1] == 'a' && identifierHeader [2] == 't' && identifierHeader [3] == 'a')  	break;  
Magic Number,IdSharp.AudioInfo,RiffWave,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\RiffWave\RiffWave.cs,ReadStream,The following statement contains a magic number: if (identifierHeader [0] == 'f' && identifierHeader [1] == 'm' && identifierHeader [2] == 't' && identifierHeader [3] == ' ') {  	fmtBlockFound = true;  	//int extraBytes = hdr[16] + (hdr[17] << 8) + (hdr[18] << 16) + (hdr[19] << 24) - 16;  	// start at 20  	int compression = data [0] + (data [1] << 8);  	// Type 1 is PCM/Uncompressed  	if (compression != 1)  		throw new NotSupportedException ("Only PCM/Uncompressed is supported");  	_channels = data [2] + (data [3] << 8);  	// Only mono or stereo PCM is supported in this example  	if (_channels < 1 || _channels > 2)  		throw new NotSupportedException ("Only mono or stereo PCM is supported");  	// Samples per second' independent of number of channels  	_frequency = data [4] + (data [5] << 8) + (data [6] << 16) + (data [7] << 24);  	// Bytes 8-11 contain the "average bytes per second"' unneeded here  	// Bytes 12-13 contain the number of bytes per sample (includes channels)  	// Bytes 14-15 contain the number of bits per single sample  	int bits = data [14] + (data [15] << 8);  	// Supporting othe sample depths will require conversion  	if (bits != 16)  		throw new InvalidDataException (string.Format ("Only 16-bit audio is supported (bits={0})"' bits));  	// Skip past extra bytes' if any  	//if (extraBytes != 0)  	//	stream.Seek(extraBytes' SeekOrigin.Current);  }  
Magic Number,IdSharp.AudioInfo,RiffWave,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\RiffWave\RiffWave.cs,ReadStream,The following statement contains a magic number: if (identifierHeader [0] == 'f' && identifierHeader [1] == 'm' && identifierHeader [2] == 't' && identifierHeader [3] == ' ') {  	fmtBlockFound = true;  	//int extraBytes = hdr[16] + (hdr[17] << 8) + (hdr[18] << 16) + (hdr[19] << 24) - 16;  	// start at 20  	int compression = data [0] + (data [1] << 8);  	// Type 1 is PCM/Uncompressed  	if (compression != 1)  		throw new NotSupportedException ("Only PCM/Uncompressed is supported");  	_channels = data [2] + (data [3] << 8);  	// Only mono or stereo PCM is supported in this example  	if (_channels < 1 || _channels > 2)  		throw new NotSupportedException ("Only mono or stereo PCM is supported");  	// Samples per second' independent of number of channels  	_frequency = data [4] + (data [5] << 8) + (data [6] << 16) + (data [7] << 24);  	// Bytes 8-11 contain the "average bytes per second"' unneeded here  	// Bytes 12-13 contain the number of bytes per sample (includes channels)  	// Bytes 14-15 contain the number of bits per single sample  	int bits = data [14] + (data [15] << 8);  	// Supporting othe sample depths will require conversion  	if (bits != 16)  		throw new InvalidDataException (string.Format ("Only 16-bit audio is supported (bits={0})"' bits));  	// Skip past extra bytes' if any  	//if (extraBytes != 0)  	//	stream.Seek(extraBytes' SeekOrigin.Current);  }  
Magic Number,IdSharp.AudioInfo,RiffWave,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\RiffWave\RiffWave.cs,ReadStream,The following statement contains a magic number: if (identifierHeader [0] == 'f' && identifierHeader [1] == 'm' && identifierHeader [2] == 't' && identifierHeader [3] == ' ') {  	fmtBlockFound = true;  	//int extraBytes = hdr[16] + (hdr[17] << 8) + (hdr[18] << 16) + (hdr[19] << 24) - 16;  	// start at 20  	int compression = data [0] + (data [1] << 8);  	// Type 1 is PCM/Uncompressed  	if (compression != 1)  		throw new NotSupportedException ("Only PCM/Uncompressed is supported");  	_channels = data [2] + (data [3] << 8);  	// Only mono or stereo PCM is supported in this example  	if (_channels < 1 || _channels > 2)  		throw new NotSupportedException ("Only mono or stereo PCM is supported");  	// Samples per second' independent of number of channels  	_frequency = data [4] + (data [5] << 8) + (data [6] << 16) + (data [7] << 24);  	// Bytes 8-11 contain the "average bytes per second"' unneeded here  	// Bytes 12-13 contain the number of bytes per sample (includes channels)  	// Bytes 14-15 contain the number of bits per single sample  	int bits = data [14] + (data [15] << 8);  	// Supporting othe sample depths will require conversion  	if (bits != 16)  		throw new InvalidDataException (string.Format ("Only 16-bit audio is supported (bits={0})"' bits));  	// Skip past extra bytes' if any  	//if (extraBytes != 0)  	//	stream.Seek(extraBytes' SeekOrigin.Current);  }  
Magic Number,IdSharp.AudioInfo,RiffWave,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\RiffWave\RiffWave.cs,ReadStream,The following statement contains a magic number: if (identifierHeader [0] == 'f' && identifierHeader [1] == 'm' && identifierHeader [2] == 't' && identifierHeader [3] == ' ') {  	fmtBlockFound = true;  	//int extraBytes = hdr[16] + (hdr[17] << 8) + (hdr[18] << 16) + (hdr[19] << 24) - 16;  	// start at 20  	int compression = data [0] + (data [1] << 8);  	// Type 1 is PCM/Uncompressed  	if (compression != 1)  		throw new NotSupportedException ("Only PCM/Uncompressed is supported");  	_channels = data [2] + (data [3] << 8);  	// Only mono or stereo PCM is supported in this example  	if (_channels < 1 || _channels > 2)  		throw new NotSupportedException ("Only mono or stereo PCM is supported");  	// Samples per second' independent of number of channels  	_frequency = data [4] + (data [5] << 8) + (data [6] << 16) + (data [7] << 24);  	// Bytes 8-11 contain the "average bytes per second"' unneeded here  	// Bytes 12-13 contain the number of bytes per sample (includes channels)  	// Bytes 14-15 contain the number of bits per single sample  	int bits = data [14] + (data [15] << 8);  	// Supporting othe sample depths will require conversion  	if (bits != 16)  		throw new InvalidDataException (string.Format ("Only 16-bit audio is supported (bits={0})"' bits));  	// Skip past extra bytes' if any  	//if (extraBytes != 0)  	//	stream.Seek(extraBytes' SeekOrigin.Current);  }  
Magic Number,IdSharp.AudioInfo,RiffWave,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\RiffWave\RiffWave.cs,ReadStream,The following statement contains a magic number: if (identifierHeader [0] == 'f' && identifierHeader [1] == 'm' && identifierHeader [2] == 't' && identifierHeader [3] == ' ') {  	fmtBlockFound = true;  	//int extraBytes = hdr[16] + (hdr[17] << 8) + (hdr[18] << 16) + (hdr[19] << 24) - 16;  	// start at 20  	int compression = data [0] + (data [1] << 8);  	// Type 1 is PCM/Uncompressed  	if (compression != 1)  		throw new NotSupportedException ("Only PCM/Uncompressed is supported");  	_channels = data [2] + (data [3] << 8);  	// Only mono or stereo PCM is supported in this example  	if (_channels < 1 || _channels > 2)  		throw new NotSupportedException ("Only mono or stereo PCM is supported");  	// Samples per second' independent of number of channels  	_frequency = data [4] + (data [5] << 8) + (data [6] << 16) + (data [7] << 24);  	// Bytes 8-11 contain the "average bytes per second"' unneeded here  	// Bytes 12-13 contain the number of bytes per sample (includes channels)  	// Bytes 14-15 contain the number of bits per single sample  	int bits = data [14] + (data [15] << 8);  	// Supporting othe sample depths will require conversion  	if (bits != 16)  		throw new InvalidDataException (string.Format ("Only 16-bit audio is supported (bits={0})"' bits));  	// Skip past extra bytes' if any  	//if (extraBytes != 0)  	//	stream.Seek(extraBytes' SeekOrigin.Current);  }  
Magic Number,IdSharp.AudioInfo,RiffWave,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\RiffWave\RiffWave.cs,ReadStream,The following statement contains a magic number: if (identifierHeader [0] == 'f' && identifierHeader [1] == 'm' && identifierHeader [2] == 't' && identifierHeader [3] == ' ') {  	fmtBlockFound = true;  	//int extraBytes = hdr[16] + (hdr[17] << 8) + (hdr[18] << 16) + (hdr[19] << 24) - 16;  	// start at 20  	int compression = data [0] + (data [1] << 8);  	// Type 1 is PCM/Uncompressed  	if (compression != 1)  		throw new NotSupportedException ("Only PCM/Uncompressed is supported");  	_channels = data [2] + (data [3] << 8);  	// Only mono or stereo PCM is supported in this example  	if (_channels < 1 || _channels > 2)  		throw new NotSupportedException ("Only mono or stereo PCM is supported");  	// Samples per second' independent of number of channels  	_frequency = data [4] + (data [5] << 8) + (data [6] << 16) + (data [7] << 24);  	// Bytes 8-11 contain the "average bytes per second"' unneeded here  	// Bytes 12-13 contain the number of bytes per sample (includes channels)  	// Bytes 14-15 contain the number of bits per single sample  	int bits = data [14] + (data [15] << 8);  	// Supporting othe sample depths will require conversion  	if (bits != 16)  		throw new InvalidDataException (string.Format ("Only 16-bit audio is supported (bits={0})"' bits));  	// Skip past extra bytes' if any  	//if (extraBytes != 0)  	//	stream.Seek(extraBytes' SeekOrigin.Current);  }  
Magic Number,IdSharp.AudioInfo,RiffWave,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\RiffWave\RiffWave.cs,ReadStream,The following statement contains a magic number: if (identifierHeader [0] == 'f' && identifierHeader [1] == 'm' && identifierHeader [2] == 't' && identifierHeader [3] == ' ') {  	fmtBlockFound = true;  	//int extraBytes = hdr[16] + (hdr[17] << 8) + (hdr[18] << 16) + (hdr[19] << 24) - 16;  	// start at 20  	int compression = data [0] + (data [1] << 8);  	// Type 1 is PCM/Uncompressed  	if (compression != 1)  		throw new NotSupportedException ("Only PCM/Uncompressed is supported");  	_channels = data [2] + (data [3] << 8);  	// Only mono or stereo PCM is supported in this example  	if (_channels < 1 || _channels > 2)  		throw new NotSupportedException ("Only mono or stereo PCM is supported");  	// Samples per second' independent of number of channels  	_frequency = data [4] + (data [5] << 8) + (data [6] << 16) + (data [7] << 24);  	// Bytes 8-11 contain the "average bytes per second"' unneeded here  	// Bytes 12-13 contain the number of bytes per sample (includes channels)  	// Bytes 14-15 contain the number of bits per single sample  	int bits = data [14] + (data [15] << 8);  	// Supporting othe sample depths will require conversion  	if (bits != 16)  		throw new InvalidDataException (string.Format ("Only 16-bit audio is supported (bits={0})"' bits));  	// Skip past extra bytes' if any  	//if (extraBytes != 0)  	//	stream.Seek(extraBytes' SeekOrigin.Current);  }  
Magic Number,IdSharp.AudioInfo,RiffWave,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\RiffWave\RiffWave.cs,ReadStream,The following statement contains a magic number: if (identifierHeader [0] == 'f' && identifierHeader [1] == 'm' && identifierHeader [2] == 't' && identifierHeader [3] == ' ') {  	fmtBlockFound = true;  	//int extraBytes = hdr[16] + (hdr[17] << 8) + (hdr[18] << 16) + (hdr[19] << 24) - 16;  	// start at 20  	int compression = data [0] + (data [1] << 8);  	// Type 1 is PCM/Uncompressed  	if (compression != 1)  		throw new NotSupportedException ("Only PCM/Uncompressed is supported");  	_channels = data [2] + (data [3] << 8);  	// Only mono or stereo PCM is supported in this example  	if (_channels < 1 || _channels > 2)  		throw new NotSupportedException ("Only mono or stereo PCM is supported");  	// Samples per second' independent of number of channels  	_frequency = data [4] + (data [5] << 8) + (data [6] << 16) + (data [7] << 24);  	// Bytes 8-11 contain the "average bytes per second"' unneeded here  	// Bytes 12-13 contain the number of bytes per sample (includes channels)  	// Bytes 14-15 contain the number of bits per single sample  	int bits = data [14] + (data [15] << 8);  	// Supporting othe sample depths will require conversion  	if (bits != 16)  		throw new InvalidDataException (string.Format ("Only 16-bit audio is supported (bits={0})"' bits));  	// Skip past extra bytes' if any  	//if (extraBytes != 0)  	//	stream.Seek(extraBytes' SeekOrigin.Current);  }  
Magic Number,IdSharp.AudioInfo,RiffWave,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\RiffWave\RiffWave.cs,ReadStream,The following statement contains a magic number: if (identifierHeader [0] == 'f' && identifierHeader [1] == 'm' && identifierHeader [2] == 't' && identifierHeader [3] == ' ') {  	fmtBlockFound = true;  	//int extraBytes = hdr[16] + (hdr[17] << 8) + (hdr[18] << 16) + (hdr[19] << 24) - 16;  	// start at 20  	int compression = data [0] + (data [1] << 8);  	// Type 1 is PCM/Uncompressed  	if (compression != 1)  		throw new NotSupportedException ("Only PCM/Uncompressed is supported");  	_channels = data [2] + (data [3] << 8);  	// Only mono or stereo PCM is supported in this example  	if (_channels < 1 || _channels > 2)  		throw new NotSupportedException ("Only mono or stereo PCM is supported");  	// Samples per second' independent of number of channels  	_frequency = data [4] + (data [5] << 8) + (data [6] << 16) + (data [7] << 24);  	// Bytes 8-11 contain the "average bytes per second"' unneeded here  	// Bytes 12-13 contain the number of bytes per sample (includes channels)  	// Bytes 14-15 contain the number of bits per single sample  	int bits = data [14] + (data [15] << 8);  	// Supporting othe sample depths will require conversion  	if (bits != 16)  		throw new InvalidDataException (string.Format ("Only 16-bit audio is supported (bits={0})"' bits));  	// Skip past extra bytes' if any  	//if (extraBytes != 0)  	//	stream.Seek(extraBytes' SeekOrigin.Current);  }  
Magic Number,IdSharp.AudioInfo,RiffWave,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\RiffWave\RiffWave.cs,ReadStream,The following statement contains a magic number: if (identifierHeader [0] == 'f' && identifierHeader [1] == 'm' && identifierHeader [2] == 't' && identifierHeader [3] == ' ') {  	fmtBlockFound = true;  	//int extraBytes = hdr[16] + (hdr[17] << 8) + (hdr[18] << 16) + (hdr[19] << 24) - 16;  	// start at 20  	int compression = data [0] + (data [1] << 8);  	// Type 1 is PCM/Uncompressed  	if (compression != 1)  		throw new NotSupportedException ("Only PCM/Uncompressed is supported");  	_channels = data [2] + (data [3] << 8);  	// Only mono or stereo PCM is supported in this example  	if (_channels < 1 || _channels > 2)  		throw new NotSupportedException ("Only mono or stereo PCM is supported");  	// Samples per second' independent of number of channels  	_frequency = data [4] + (data [5] << 8) + (data [6] << 16) + (data [7] << 24);  	// Bytes 8-11 contain the "average bytes per second"' unneeded here  	// Bytes 12-13 contain the number of bytes per sample (includes channels)  	// Bytes 14-15 contain the number of bits per single sample  	int bits = data [14] + (data [15] << 8);  	// Supporting othe sample depths will require conversion  	if (bits != 16)  		throw new InvalidDataException (string.Format ("Only 16-bit audio is supported (bits={0})"' bits));  	// Skip past extra bytes' if any  	//if (extraBytes != 0)  	//	stream.Seek(extraBytes' SeekOrigin.Current);  }  
Magic Number,IdSharp.AudioInfo,RiffWave,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\RiffWave\RiffWave.cs,ReadStream,The following statement contains a magic number: if (identifierHeader [0] == 'f' && identifierHeader [1] == 'm' && identifierHeader [2] == 't' && identifierHeader [3] == ' ') {  	fmtBlockFound = true;  	//int extraBytes = hdr[16] + (hdr[17] << 8) + (hdr[18] << 16) + (hdr[19] << 24) - 16;  	// start at 20  	int compression = data [0] + (data [1] << 8);  	// Type 1 is PCM/Uncompressed  	if (compression != 1)  		throw new NotSupportedException ("Only PCM/Uncompressed is supported");  	_channels = data [2] + (data [3] << 8);  	// Only mono or stereo PCM is supported in this example  	if (_channels < 1 || _channels > 2)  		throw new NotSupportedException ("Only mono or stereo PCM is supported");  	// Samples per second' independent of number of channels  	_frequency = data [4] + (data [5] << 8) + (data [6] << 16) + (data [7] << 24);  	// Bytes 8-11 contain the "average bytes per second"' unneeded here  	// Bytes 12-13 contain the number of bytes per sample (includes channels)  	// Bytes 14-15 contain the number of bits per single sample  	int bits = data [14] + (data [15] << 8);  	// Supporting othe sample depths will require conversion  	if (bits != 16)  		throw new InvalidDataException (string.Format ("Only 16-bit audio is supported (bits={0})"' bits));  	// Skip past extra bytes' if any  	//if (extraBytes != 0)  	//	stream.Seek(extraBytes' SeekOrigin.Current);  }  
Magic Number,IdSharp.AudioInfo,RiffWave,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\RiffWave\RiffWave.cs,ReadStream,The following statement contains a magic number: if (identifierHeader [0] == 'f' && identifierHeader [1] == 'm' && identifierHeader [2] == 't' && identifierHeader [3] == ' ') {  	fmtBlockFound = true;  	//int extraBytes = hdr[16] + (hdr[17] << 8) + (hdr[18] << 16) + (hdr[19] << 24) - 16;  	// start at 20  	int compression = data [0] + (data [1] << 8);  	// Type 1 is PCM/Uncompressed  	if (compression != 1)  		throw new NotSupportedException ("Only PCM/Uncompressed is supported");  	_channels = data [2] + (data [3] << 8);  	// Only mono or stereo PCM is supported in this example  	if (_channels < 1 || _channels > 2)  		throw new NotSupportedException ("Only mono or stereo PCM is supported");  	// Samples per second' independent of number of channels  	_frequency = data [4] + (data [5] << 8) + (data [6] << 16) + (data [7] << 24);  	// Bytes 8-11 contain the "average bytes per second"' unneeded here  	// Bytes 12-13 contain the number of bytes per sample (includes channels)  	// Bytes 14-15 contain the number of bits per single sample  	int bits = data [14] + (data [15] << 8);  	// Supporting othe sample depths will require conversion  	if (bits != 16)  		throw new InvalidDataException (string.Format ("Only 16-bit audio is supported (bits={0})"' bits));  	// Skip past extra bytes' if any  	//if (extraBytes != 0)  	//	stream.Seek(extraBytes' SeekOrigin.Current);  }  
Magic Number,IdSharp.AudioInfo,RiffWave,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\RiffWave\RiffWave.cs,ReadStream,The following statement contains a magic number: if (identifierHeader [0] == 'f' && identifierHeader [1] == 'm' && identifierHeader [2] == 't' && identifierHeader [3] == ' ') {  	fmtBlockFound = true;  	//int extraBytes = hdr[16] + (hdr[17] << 8) + (hdr[18] << 16) + (hdr[19] << 24) - 16;  	// start at 20  	int compression = data [0] + (data [1] << 8);  	// Type 1 is PCM/Uncompressed  	if (compression != 1)  		throw new NotSupportedException ("Only PCM/Uncompressed is supported");  	_channels = data [2] + (data [3] << 8);  	// Only mono or stereo PCM is supported in this example  	if (_channels < 1 || _channels > 2)  		throw new NotSupportedException ("Only mono or stereo PCM is supported");  	// Samples per second' independent of number of channels  	_frequency = data [4] + (data [5] << 8) + (data [6] << 16) + (data [7] << 24);  	// Bytes 8-11 contain the "average bytes per second"' unneeded here  	// Bytes 12-13 contain the number of bytes per sample (includes channels)  	// Bytes 14-15 contain the number of bits per single sample  	int bits = data [14] + (data [15] << 8);  	// Supporting othe sample depths will require conversion  	if (bits != 16)  		throw new InvalidDataException (string.Format ("Only 16-bit audio is supported (bits={0})"' bits));  	// Skip past extra bytes' if any  	//if (extraBytes != 0)  	//	stream.Seek(extraBytes' SeekOrigin.Current);  }  
Magic Number,IdSharp.AudioInfo,RiffWave,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\RiffWave\RiffWave.cs,ReadStream,The following statement contains a magic number: if (identifierHeader [0] == 'f' && identifierHeader [1] == 'm' && identifierHeader [2] == 't' && identifierHeader [3] == ' ') {  	fmtBlockFound = true;  	//int extraBytes = hdr[16] + (hdr[17] << 8) + (hdr[18] << 16) + (hdr[19] << 24) - 16;  	// start at 20  	int compression = data [0] + (data [1] << 8);  	// Type 1 is PCM/Uncompressed  	if (compression != 1)  		throw new NotSupportedException ("Only PCM/Uncompressed is supported");  	_channels = data [2] + (data [3] << 8);  	// Only mono or stereo PCM is supported in this example  	if (_channels < 1 || _channels > 2)  		throw new NotSupportedException ("Only mono or stereo PCM is supported");  	// Samples per second' independent of number of channels  	_frequency = data [4] + (data [5] << 8) + (data [6] << 16) + (data [7] << 24);  	// Bytes 8-11 contain the "average bytes per second"' unneeded here  	// Bytes 12-13 contain the number of bytes per sample (includes channels)  	// Bytes 14-15 contain the number of bits per single sample  	int bits = data [14] + (data [15] << 8);  	// Supporting othe sample depths will require conversion  	if (bits != 16)  		throw new InvalidDataException (string.Format ("Only 16-bit audio is supported (bits={0})"' bits));  	// Skip past extra bytes' if any  	//if (extraBytes != 0)  	//	stream.Seek(extraBytes' SeekOrigin.Current);  }  
Magic Number,IdSharp.AudioInfo,RiffWave,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\RiffWave\RiffWave.cs,ReadStream,The following statement contains a magic number: if (identifierHeader [0] == 'f' && identifierHeader [1] == 'm' && identifierHeader [2] == 't' && identifierHeader [3] == ' ') {  	fmtBlockFound = true;  	//int extraBytes = hdr[16] + (hdr[17] << 8) + (hdr[18] << 16) + (hdr[19] << 24) - 16;  	// start at 20  	int compression = data [0] + (data [1] << 8);  	// Type 1 is PCM/Uncompressed  	if (compression != 1)  		throw new NotSupportedException ("Only PCM/Uncompressed is supported");  	_channels = data [2] + (data [3] << 8);  	// Only mono or stereo PCM is supported in this example  	if (_channels < 1 || _channels > 2)  		throw new NotSupportedException ("Only mono or stereo PCM is supported");  	// Samples per second' independent of number of channels  	_frequency = data [4] + (data [5] << 8) + (data [6] << 16) + (data [7] << 24);  	// Bytes 8-11 contain the "average bytes per second"' unneeded here  	// Bytes 12-13 contain the number of bytes per sample (includes channels)  	// Bytes 14-15 contain the number of bits per single sample  	int bits = data [14] + (data [15] << 8);  	// Supporting othe sample depths will require conversion  	if (bits != 16)  		throw new InvalidDataException (string.Format ("Only 16-bit audio is supported (bits={0})"' bits));  	// Skip past extra bytes' if any  	//if (extraBytes != 0)  	//	stream.Seek(extraBytes' SeekOrigin.Current);  }  
Magic Number,IdSharp.AudioInfo,RiffWave,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\RiffWave\RiffWave.cs,ReadStream,The following statement contains a magic number: if (identifierHeader [0] == 'f' && identifierHeader [1] == 'm' && identifierHeader [2] == 't' && identifierHeader [3] == ' ') {  	fmtBlockFound = true;  	//int extraBytes = hdr[16] + (hdr[17] << 8) + (hdr[18] << 16) + (hdr[19] << 24) - 16;  	// start at 20  	int compression = data [0] + (data [1] << 8);  	// Type 1 is PCM/Uncompressed  	if (compression != 1)  		throw new NotSupportedException ("Only PCM/Uncompressed is supported");  	_channels = data [2] + (data [3] << 8);  	// Only mono or stereo PCM is supported in this example  	if (_channels < 1 || _channels > 2)  		throw new NotSupportedException ("Only mono or stereo PCM is supported");  	// Samples per second' independent of number of channels  	_frequency = data [4] + (data [5] << 8) + (data [6] << 16) + (data [7] << 24);  	// Bytes 8-11 contain the "average bytes per second"' unneeded here  	// Bytes 12-13 contain the number of bytes per sample (includes channels)  	// Bytes 14-15 contain the number of bits per single sample  	int bits = data [14] + (data [15] << 8);  	// Supporting othe sample depths will require conversion  	if (bits != 16)  		throw new InvalidDataException (string.Format ("Only 16-bit audio is supported (bits={0})"' bits));  	// Skip past extra bytes' if any  	//if (extraBytes != 0)  	//	stream.Seek(extraBytes' SeekOrigin.Current);  }  
Magic Number,IdSharp.AudioInfo,RiffWave,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\RiffWave\RiffWave.cs,ReadStream,The following statement contains a magic number: if (identifierHeader [0] == 'f' && identifierHeader [1] == 'm' && identifierHeader [2] == 't' && identifierHeader [3] == ' ') {  	fmtBlockFound = true;  	//int extraBytes = hdr[16] + (hdr[17] << 8) + (hdr[18] << 16) + (hdr[19] << 24) - 16;  	// start at 20  	int compression = data [0] + (data [1] << 8);  	// Type 1 is PCM/Uncompressed  	if (compression != 1)  		throw new NotSupportedException ("Only PCM/Uncompressed is supported");  	_channels = data [2] + (data [3] << 8);  	// Only mono or stereo PCM is supported in this example  	if (_channels < 1 || _channels > 2)  		throw new NotSupportedException ("Only mono or stereo PCM is supported");  	// Samples per second' independent of number of channels  	_frequency = data [4] + (data [5] << 8) + (data [6] << 16) + (data [7] << 24);  	// Bytes 8-11 contain the "average bytes per second"' unneeded here  	// Bytes 12-13 contain the number of bytes per sample (includes channels)  	// Bytes 14-15 contain the number of bits per single sample  	int bits = data [14] + (data [15] << 8);  	// Supporting othe sample depths will require conversion  	if (bits != 16)  		throw new InvalidDataException (string.Format ("Only 16-bit audio is supported (bits={0})"' bits));  	// Skip past extra bytes' if any  	//if (extraBytes != 0)  	//	stream.Seek(extraBytes' SeekOrigin.Current);  }  
Magic Number,IdSharp.AudioInfo,RiffWave,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\RiffWave\RiffWave.cs,ReadStream,The following statement contains a magic number: if (identifierHeader [0] == 'f' && identifierHeader [1] == 'm' && identifierHeader [2] == 't' && identifierHeader [3] == ' ') {  	fmtBlockFound = true;  	//int extraBytes = hdr[16] + (hdr[17] << 8) + (hdr[18] << 16) + (hdr[19] << 24) - 16;  	// start at 20  	int compression = data [0] + (data [1] << 8);  	// Type 1 is PCM/Uncompressed  	if (compression != 1)  		throw new NotSupportedException ("Only PCM/Uncompressed is supported");  	_channels = data [2] + (data [3] << 8);  	// Only mono or stereo PCM is supported in this example  	if (_channels < 1 || _channels > 2)  		throw new NotSupportedException ("Only mono or stereo PCM is supported");  	// Samples per second' independent of number of channels  	_frequency = data [4] + (data [5] << 8) + (data [6] << 16) + (data [7] << 24);  	// Bytes 8-11 contain the "average bytes per second"' unneeded here  	// Bytes 12-13 contain the number of bytes per sample (includes channels)  	// Bytes 14-15 contain the number of bits per single sample  	int bits = data [14] + (data [15] << 8);  	// Supporting othe sample depths will require conversion  	if (bits != 16)  		throw new InvalidDataException (string.Format ("Only 16-bit audio is supported (bits={0})"' bits));  	// Skip past extra bytes' if any  	//if (extraBytes != 0)  	//	stream.Seek(extraBytes' SeekOrigin.Current);  }  
Magic Number,IdSharp.AudioInfo,RiffWave,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\RiffWave\RiffWave.cs,ReadStream,The following statement contains a magic number: _channels = data [2] + (data [3] << 8);  
Magic Number,IdSharp.AudioInfo,RiffWave,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\RiffWave\RiffWave.cs,ReadStream,The following statement contains a magic number: _channels = data [2] + (data [3] << 8);  
Magic Number,IdSharp.AudioInfo,RiffWave,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\RiffWave\RiffWave.cs,ReadStream,The following statement contains a magic number: _channels = data [2] + (data [3] << 8);  
Magic Number,IdSharp.AudioInfo,RiffWave,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\RiffWave\RiffWave.cs,ReadStream,The following statement contains a magic number: if (_channels < 1 || _channels > 2)  	throw new NotSupportedException ("Only mono or stereo PCM is supported");  
Magic Number,IdSharp.AudioInfo,RiffWave,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\RiffWave\RiffWave.cs,ReadStream,The following statement contains a magic number: _frequency = data [4] + (data [5] << 8) + (data [6] << 16) + (data [7] << 24);  
Magic Number,IdSharp.AudioInfo,RiffWave,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\RiffWave\RiffWave.cs,ReadStream,The following statement contains a magic number: _frequency = data [4] + (data [5] << 8) + (data [6] << 16) + (data [7] << 24);  
Magic Number,IdSharp.AudioInfo,RiffWave,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\RiffWave\RiffWave.cs,ReadStream,The following statement contains a magic number: _frequency = data [4] + (data [5] << 8) + (data [6] << 16) + (data [7] << 24);  
Magic Number,IdSharp.AudioInfo,RiffWave,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\RiffWave\RiffWave.cs,ReadStream,The following statement contains a magic number: _frequency = data [4] + (data [5] << 8) + (data [6] << 16) + (data [7] << 24);  
Magic Number,IdSharp.AudioInfo,RiffWave,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\RiffWave\RiffWave.cs,ReadStream,The following statement contains a magic number: _frequency = data [4] + (data [5] << 8) + (data [6] << 16) + (data [7] << 24);  
Magic Number,IdSharp.AudioInfo,RiffWave,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\RiffWave\RiffWave.cs,ReadStream,The following statement contains a magic number: _frequency = data [4] + (data [5] << 8) + (data [6] << 16) + (data [7] << 24);  
Magic Number,IdSharp.AudioInfo,RiffWave,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\RiffWave\RiffWave.cs,ReadStream,The following statement contains a magic number: _frequency = data [4] + (data [5] << 8) + (data [6] << 16) + (data [7] << 24);  
Magic Number,IdSharp.AudioInfo,RiffWave,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\RiffWave\RiffWave.cs,ReadStream,The following statement contains a magic number: if (bits != 16)  	throw new InvalidDataException (string.Format ("Only 16-bit audio is supported (bits={0})"' bits));  
Magic Number,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,word_get,The following statement contains a magic number: if (nbyteget < 4) {  	int bytes = stream.Read (getbuf' 0' BUFSIZE);  	getbufOffset = 0;  	nbyteget += bytes;  	if (nbyteget < 4) {  		unchecked {  			return (uint)(-1);  		}  	}  }  
Magic Number,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,word_get,The following statement contains a magic number: if (nbyteget < 4) {  	int bytes = stream.Read (getbuf' 0' BUFSIZE);  	getbufOffset = 0;  	nbyteget += bytes;  	if (nbyteget < 4) {  		unchecked {  			return (uint)(-1);  		}  	}  }  
Magic Number,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,word_get,The following statement contains a magic number: if (nbyteget < 4) {  	unchecked {  		return (uint)(-1);  	}  }  
Magic Number,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,word_get,The following statement contains a magic number: getbufOffset += 4;  
Magic Number,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,word_get,The following statement contains a magic number: nbyteget -= 4;  
Magic Number,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,uvar_get,The following statement contains a magic number: if (nbitget == 0) {  	gbuffer = word_get (stream);  	nbitget = 32;  }  
Magic Number,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,uvar_get,The following statement contains a magic number: nbitget = 32;  
Magic Number,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,uvar_get,The following statement contains a magic number: for (result = 0; (gbuffer & (1L << --nbitget)) == 0; result++) {  	if (nbitget == 0) {  		gbuffer = word_get (stream);  		nbitget = 32;  	}  }  
Magic Number,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,uvar_get,The following statement contains a magic number: if (nbitget == 0) {  	gbuffer = word_get (stream);  	nbitget = 32;  }  
Magic Number,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,uvar_get,The following statement contains a magic number: nbitget = 32;  
Magic Number,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,uvar_get,The following statement contains a magic number: while (nbin != 0) {  	if (nbitget >= nbin) {  		result = (int)((uint)(result << nbin) | ((gbuffer >> (nbitget - nbin)) & masktab [nbin]));  		nbitget -= nbin;  		nbin = 0;  	} else {  		result = (int)((uint)(result << nbitget) | (gbuffer & masktab [nbitget]));  		gbuffer = word_get (stream);  		nbin -= nbitget;  		nbitget = 32;  	}  }  
Magic Number,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,uvar_get,The following statement contains a magic number: if (nbitget >= nbin) {  	result = (int)((uint)(result << nbin) | ((gbuffer >> (nbitget - nbin)) & masktab [nbin]));  	nbitget -= nbin;  	nbin = 0;  } else {  	result = (int)((uint)(result << nbitget) | (gbuffer & masktab [nbitget]));  	gbuffer = word_get (stream);  	nbin -= nbitget;  	nbitget = 32;  }  
Magic Number,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,uvar_get,The following statement contains a magic number: nbitget = 32;  
Magic Number,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,getSamples,The following statement contains a magic number: while (cmd != FN_QUIT) {  	switch (cmd) {  	case FN_ZERO:  	case FN_DIFF0:  	case FN_DIFF1:  	case FN_DIFF2:  	case FN_DIFF3:  	case FN_QLPC:  		int resn = 0;  		if (cmd != FN_ZERO) {  			resn = uvar_get (ENERGYSIZE' stream);  			// this is a hack as version 0 differed in definition of var_get  			if (version == 0)  				resn--;  		}  		switch (cmd) {  		case FN_ZERO:  			break;  		case FN_DIFF0:  		case FN_DIFF1:  		case FN_DIFF2:  		case FN_DIFF3:  			for (i = 0; i < blocksize; i++) {  				int nbin = resn + 1;  				if (nbitget == 0) {  					if (nbyteget < 4) {  						int bytes = stream.Read (getbuf' 0' BUFSIZE);  						getbufOffset = 0;  						nbyteget += bytes;  					}  					gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  					getbufOffset += 4;  					nbyteget -= 4;  					nbitget = 32;  				}  				while ((gbuffer & (1L << --nbitget)) == 0) {  					if (nbitget == 0) {  						if (nbyteget < 4) {  							int bytes = stream.Read (getbuf' 0' BUFSIZE);  							getbufOffset = 0;  							nbyteget += bytes;  						}  						gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  						getbufOffset += 4;  						nbyteget -= 4;  						nbitget = 32;  					}  				}  				while (nbin != 0) {  					if (nbitget >= nbin) {  						nbitget -= nbin;  						nbin = 0;  					} else {  						if (nbyteget < 4) {  							int bytes = stream.Read (getbuf' 0' BUFSIZE);  							getbufOffset = 0;  							nbyteget += bytes;  						}  						gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  						getbufOffset += 4;  						nbyteget -= 4;  						nbin -= nbitget;  						nbitget = 32;  					}  				}  			}  			break;  		case FN_QLPC:  			int nlpc = uvar_get (LPCQSIZE' stream);  			for (i = 0; i < nlpc; i++)  				var_get (LPCQUANT' stream);  			break;  		}  		if (chan == nchan - 1) {  			SampleNumber += blocksize;  		}  		chan = (chan + 1) % nchan;  		break;  	case FN_BLOCKSIZE:  		blocksize = (int)UINT_GET ((int)(Math.Log (blocksize) / M_LN2)' stream);  		break;  	case FN_BITSHIFT:  		uvar_get (BITSHIFTSIZE' stream);  		break;  	case FN_VERBATIM:  		int cklen = uvar_get (VERBATIM_CKSIZE_SIZE' stream);  		while (cklen-- != 0) {  			uvar_get (VERBATIM_BYTE_SIZE' stream);  		}  		break;  	default:  		return 0;  	}  	cmd = uvar_get (FNSIZE' stream);  }  
Magic Number,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,getSamples,The following statement contains a magic number: while (cmd != FN_QUIT) {  	switch (cmd) {  	case FN_ZERO:  	case FN_DIFF0:  	case FN_DIFF1:  	case FN_DIFF2:  	case FN_DIFF3:  	case FN_QLPC:  		int resn = 0;  		if (cmd != FN_ZERO) {  			resn = uvar_get (ENERGYSIZE' stream);  			// this is a hack as version 0 differed in definition of var_get  			if (version == 0)  				resn--;  		}  		switch (cmd) {  		case FN_ZERO:  			break;  		case FN_DIFF0:  		case FN_DIFF1:  		case FN_DIFF2:  		case FN_DIFF3:  			for (i = 0; i < blocksize; i++) {  				int nbin = resn + 1;  				if (nbitget == 0) {  					if (nbyteget < 4) {  						int bytes = stream.Read (getbuf' 0' BUFSIZE);  						getbufOffset = 0;  						nbyteget += bytes;  					}  					gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  					getbufOffset += 4;  					nbyteget -= 4;  					nbitget = 32;  				}  				while ((gbuffer & (1L << --nbitget)) == 0) {  					if (nbitget == 0) {  						if (nbyteget < 4) {  							int bytes = stream.Read (getbuf' 0' BUFSIZE);  							getbufOffset = 0;  							nbyteget += bytes;  						}  						gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  						getbufOffset += 4;  						nbyteget -= 4;  						nbitget = 32;  					}  				}  				while (nbin != 0) {  					if (nbitget >= nbin) {  						nbitget -= nbin;  						nbin = 0;  					} else {  						if (nbyteget < 4) {  							int bytes = stream.Read (getbuf' 0' BUFSIZE);  							getbufOffset = 0;  							nbyteget += bytes;  						}  						gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  						getbufOffset += 4;  						nbyteget -= 4;  						nbin -= nbitget;  						nbitget = 32;  					}  				}  			}  			break;  		case FN_QLPC:  			int nlpc = uvar_get (LPCQSIZE' stream);  			for (i = 0; i < nlpc; i++)  				var_get (LPCQUANT' stream);  			break;  		}  		if (chan == nchan - 1) {  			SampleNumber += blocksize;  		}  		chan = (chan + 1) % nchan;  		break;  	case FN_BLOCKSIZE:  		blocksize = (int)UINT_GET ((int)(Math.Log (blocksize) / M_LN2)' stream);  		break;  	case FN_BITSHIFT:  		uvar_get (BITSHIFTSIZE' stream);  		break;  	case FN_VERBATIM:  		int cklen = uvar_get (VERBATIM_CKSIZE_SIZE' stream);  		while (cklen-- != 0) {  			uvar_get (VERBATIM_BYTE_SIZE' stream);  		}  		break;  	default:  		return 0;  	}  	cmd = uvar_get (FNSIZE' stream);  }  
Magic Number,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,getSamples,The following statement contains a magic number: while (cmd != FN_QUIT) {  	switch (cmd) {  	case FN_ZERO:  	case FN_DIFF0:  	case FN_DIFF1:  	case FN_DIFF2:  	case FN_DIFF3:  	case FN_QLPC:  		int resn = 0;  		if (cmd != FN_ZERO) {  			resn = uvar_get (ENERGYSIZE' stream);  			// this is a hack as version 0 differed in definition of var_get  			if (version == 0)  				resn--;  		}  		switch (cmd) {  		case FN_ZERO:  			break;  		case FN_DIFF0:  		case FN_DIFF1:  		case FN_DIFF2:  		case FN_DIFF3:  			for (i = 0; i < blocksize; i++) {  				int nbin = resn + 1;  				if (nbitget == 0) {  					if (nbyteget < 4) {  						int bytes = stream.Read (getbuf' 0' BUFSIZE);  						getbufOffset = 0;  						nbyteget += bytes;  					}  					gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  					getbufOffset += 4;  					nbyteget -= 4;  					nbitget = 32;  				}  				while ((gbuffer & (1L << --nbitget)) == 0) {  					if (nbitget == 0) {  						if (nbyteget < 4) {  							int bytes = stream.Read (getbuf' 0' BUFSIZE);  							getbufOffset = 0;  							nbyteget += bytes;  						}  						gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  						getbufOffset += 4;  						nbyteget -= 4;  						nbitget = 32;  					}  				}  				while (nbin != 0) {  					if (nbitget >= nbin) {  						nbitget -= nbin;  						nbin = 0;  					} else {  						if (nbyteget < 4) {  							int bytes = stream.Read (getbuf' 0' BUFSIZE);  							getbufOffset = 0;  							nbyteget += bytes;  						}  						gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  						getbufOffset += 4;  						nbyteget -= 4;  						nbin -= nbitget;  						nbitget = 32;  					}  				}  			}  			break;  		case FN_QLPC:  			int nlpc = uvar_get (LPCQSIZE' stream);  			for (i = 0; i < nlpc; i++)  				var_get (LPCQUANT' stream);  			break;  		}  		if (chan == nchan - 1) {  			SampleNumber += blocksize;  		}  		chan = (chan + 1) % nchan;  		break;  	case FN_BLOCKSIZE:  		blocksize = (int)UINT_GET ((int)(Math.Log (blocksize) / M_LN2)' stream);  		break;  	case FN_BITSHIFT:  		uvar_get (BITSHIFTSIZE' stream);  		break;  	case FN_VERBATIM:  		int cklen = uvar_get (VERBATIM_CKSIZE_SIZE' stream);  		while (cklen-- != 0) {  			uvar_get (VERBATIM_BYTE_SIZE' stream);  		}  		break;  	default:  		return 0;  	}  	cmd = uvar_get (FNSIZE' stream);  }  
Magic Number,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,getSamples,The following statement contains a magic number: while (cmd != FN_QUIT) {  	switch (cmd) {  	case FN_ZERO:  	case FN_DIFF0:  	case FN_DIFF1:  	case FN_DIFF2:  	case FN_DIFF3:  	case FN_QLPC:  		int resn = 0;  		if (cmd != FN_ZERO) {  			resn = uvar_get (ENERGYSIZE' stream);  			// this is a hack as version 0 differed in definition of var_get  			if (version == 0)  				resn--;  		}  		switch (cmd) {  		case FN_ZERO:  			break;  		case FN_DIFF0:  		case FN_DIFF1:  		case FN_DIFF2:  		case FN_DIFF3:  			for (i = 0; i < blocksize; i++) {  				int nbin = resn + 1;  				if (nbitget == 0) {  					if (nbyteget < 4) {  						int bytes = stream.Read (getbuf' 0' BUFSIZE);  						getbufOffset = 0;  						nbyteget += bytes;  					}  					gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  					getbufOffset += 4;  					nbyteget -= 4;  					nbitget = 32;  				}  				while ((gbuffer & (1L << --nbitget)) == 0) {  					if (nbitget == 0) {  						if (nbyteget < 4) {  							int bytes = stream.Read (getbuf' 0' BUFSIZE);  							getbufOffset = 0;  							nbyteget += bytes;  						}  						gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  						getbufOffset += 4;  						nbyteget -= 4;  						nbitget = 32;  					}  				}  				while (nbin != 0) {  					if (nbitget >= nbin) {  						nbitget -= nbin;  						nbin = 0;  					} else {  						if (nbyteget < 4) {  							int bytes = stream.Read (getbuf' 0' BUFSIZE);  							getbufOffset = 0;  							nbyteget += bytes;  						}  						gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  						getbufOffset += 4;  						nbyteget -= 4;  						nbin -= nbitget;  						nbitget = 32;  					}  				}  			}  			break;  		case FN_QLPC:  			int nlpc = uvar_get (LPCQSIZE' stream);  			for (i = 0; i < nlpc; i++)  				var_get (LPCQUANT' stream);  			break;  		}  		if (chan == nchan - 1) {  			SampleNumber += blocksize;  		}  		chan = (chan + 1) % nchan;  		break;  	case FN_BLOCKSIZE:  		blocksize = (int)UINT_GET ((int)(Math.Log (blocksize) / M_LN2)' stream);  		break;  	case FN_BITSHIFT:  		uvar_get (BITSHIFTSIZE' stream);  		break;  	case FN_VERBATIM:  		int cklen = uvar_get (VERBATIM_CKSIZE_SIZE' stream);  		while (cklen-- != 0) {  			uvar_get (VERBATIM_BYTE_SIZE' stream);  		}  		break;  	default:  		return 0;  	}  	cmd = uvar_get (FNSIZE' stream);  }  
Magic Number,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,getSamples,The following statement contains a magic number: while (cmd != FN_QUIT) {  	switch (cmd) {  	case FN_ZERO:  	case FN_DIFF0:  	case FN_DIFF1:  	case FN_DIFF2:  	case FN_DIFF3:  	case FN_QLPC:  		int resn = 0;  		if (cmd != FN_ZERO) {  			resn = uvar_get (ENERGYSIZE' stream);  			// this is a hack as version 0 differed in definition of var_get  			if (version == 0)  				resn--;  		}  		switch (cmd) {  		case FN_ZERO:  			break;  		case FN_DIFF0:  		case FN_DIFF1:  		case FN_DIFF2:  		case FN_DIFF3:  			for (i = 0; i < blocksize; i++) {  				int nbin = resn + 1;  				if (nbitget == 0) {  					if (nbyteget < 4) {  						int bytes = stream.Read (getbuf' 0' BUFSIZE);  						getbufOffset = 0;  						nbyteget += bytes;  					}  					gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  					getbufOffset += 4;  					nbyteget -= 4;  					nbitget = 32;  				}  				while ((gbuffer & (1L << --nbitget)) == 0) {  					if (nbitget == 0) {  						if (nbyteget < 4) {  							int bytes = stream.Read (getbuf' 0' BUFSIZE);  							getbufOffset = 0;  							nbyteget += bytes;  						}  						gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  						getbufOffset += 4;  						nbyteget -= 4;  						nbitget = 32;  					}  				}  				while (nbin != 0) {  					if (nbitget >= nbin) {  						nbitget -= nbin;  						nbin = 0;  					} else {  						if (nbyteget < 4) {  							int bytes = stream.Read (getbuf' 0' BUFSIZE);  							getbufOffset = 0;  							nbyteget += bytes;  						}  						gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  						getbufOffset += 4;  						nbyteget -= 4;  						nbin -= nbitget;  						nbitget = 32;  					}  				}  			}  			break;  		case FN_QLPC:  			int nlpc = uvar_get (LPCQSIZE' stream);  			for (i = 0; i < nlpc; i++)  				var_get (LPCQUANT' stream);  			break;  		}  		if (chan == nchan - 1) {  			SampleNumber += blocksize;  		}  		chan = (chan + 1) % nchan;  		break;  	case FN_BLOCKSIZE:  		blocksize = (int)UINT_GET ((int)(Math.Log (blocksize) / M_LN2)' stream);  		break;  	case FN_BITSHIFT:  		uvar_get (BITSHIFTSIZE' stream);  		break;  	case FN_VERBATIM:  		int cklen = uvar_get (VERBATIM_CKSIZE_SIZE' stream);  		while (cklen-- != 0) {  			uvar_get (VERBATIM_BYTE_SIZE' stream);  		}  		break;  	default:  		return 0;  	}  	cmd = uvar_get (FNSIZE' stream);  }  
Magic Number,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,getSamples,The following statement contains a magic number: while (cmd != FN_QUIT) {  	switch (cmd) {  	case FN_ZERO:  	case FN_DIFF0:  	case FN_DIFF1:  	case FN_DIFF2:  	case FN_DIFF3:  	case FN_QLPC:  		int resn = 0;  		if (cmd != FN_ZERO) {  			resn = uvar_get (ENERGYSIZE' stream);  			// this is a hack as version 0 differed in definition of var_get  			if (version == 0)  				resn--;  		}  		switch (cmd) {  		case FN_ZERO:  			break;  		case FN_DIFF0:  		case FN_DIFF1:  		case FN_DIFF2:  		case FN_DIFF3:  			for (i = 0; i < blocksize; i++) {  				int nbin = resn + 1;  				if (nbitget == 0) {  					if (nbyteget < 4) {  						int bytes = stream.Read (getbuf' 0' BUFSIZE);  						getbufOffset = 0;  						nbyteget += bytes;  					}  					gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  					getbufOffset += 4;  					nbyteget -= 4;  					nbitget = 32;  				}  				while ((gbuffer & (1L << --nbitget)) == 0) {  					if (nbitget == 0) {  						if (nbyteget < 4) {  							int bytes = stream.Read (getbuf' 0' BUFSIZE);  							getbufOffset = 0;  							nbyteget += bytes;  						}  						gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  						getbufOffset += 4;  						nbyteget -= 4;  						nbitget = 32;  					}  				}  				while (nbin != 0) {  					if (nbitget >= nbin) {  						nbitget -= nbin;  						nbin = 0;  					} else {  						if (nbyteget < 4) {  							int bytes = stream.Read (getbuf' 0' BUFSIZE);  							getbufOffset = 0;  							nbyteget += bytes;  						}  						gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  						getbufOffset += 4;  						nbyteget -= 4;  						nbin -= nbitget;  						nbitget = 32;  					}  				}  			}  			break;  		case FN_QLPC:  			int nlpc = uvar_get (LPCQSIZE' stream);  			for (i = 0; i < nlpc; i++)  				var_get (LPCQUANT' stream);  			break;  		}  		if (chan == nchan - 1) {  			SampleNumber += blocksize;  		}  		chan = (chan + 1) % nchan;  		break;  	case FN_BLOCKSIZE:  		blocksize = (int)UINT_GET ((int)(Math.Log (blocksize) / M_LN2)' stream);  		break;  	case FN_BITSHIFT:  		uvar_get (BITSHIFTSIZE' stream);  		break;  	case FN_VERBATIM:  		int cklen = uvar_get (VERBATIM_CKSIZE_SIZE' stream);  		while (cklen-- != 0) {  			uvar_get (VERBATIM_BYTE_SIZE' stream);  		}  		break;  	default:  		return 0;  	}  	cmd = uvar_get (FNSIZE' stream);  }  
Magic Number,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,getSamples,The following statement contains a magic number: while (cmd != FN_QUIT) {  	switch (cmd) {  	case FN_ZERO:  	case FN_DIFF0:  	case FN_DIFF1:  	case FN_DIFF2:  	case FN_DIFF3:  	case FN_QLPC:  		int resn = 0;  		if (cmd != FN_ZERO) {  			resn = uvar_get (ENERGYSIZE' stream);  			// this is a hack as version 0 differed in definition of var_get  			if (version == 0)  				resn--;  		}  		switch (cmd) {  		case FN_ZERO:  			break;  		case FN_DIFF0:  		case FN_DIFF1:  		case FN_DIFF2:  		case FN_DIFF3:  			for (i = 0; i < blocksize; i++) {  				int nbin = resn + 1;  				if (nbitget == 0) {  					if (nbyteget < 4) {  						int bytes = stream.Read (getbuf' 0' BUFSIZE);  						getbufOffset = 0;  						nbyteget += bytes;  					}  					gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  					getbufOffset += 4;  					nbyteget -= 4;  					nbitget = 32;  				}  				while ((gbuffer & (1L << --nbitget)) == 0) {  					if (nbitget == 0) {  						if (nbyteget < 4) {  							int bytes = stream.Read (getbuf' 0' BUFSIZE);  							getbufOffset = 0;  							nbyteget += bytes;  						}  						gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  						getbufOffset += 4;  						nbyteget -= 4;  						nbitget = 32;  					}  				}  				while (nbin != 0) {  					if (nbitget >= nbin) {  						nbitget -= nbin;  						nbin = 0;  					} else {  						if (nbyteget < 4) {  							int bytes = stream.Read (getbuf' 0' BUFSIZE);  							getbufOffset = 0;  							nbyteget += bytes;  						}  						gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  						getbufOffset += 4;  						nbyteget -= 4;  						nbin -= nbitget;  						nbitget = 32;  					}  				}  			}  			break;  		case FN_QLPC:  			int nlpc = uvar_get (LPCQSIZE' stream);  			for (i = 0; i < nlpc; i++)  				var_get (LPCQUANT' stream);  			break;  		}  		if (chan == nchan - 1) {  			SampleNumber += blocksize;  		}  		chan = (chan + 1) % nchan;  		break;  	case FN_BLOCKSIZE:  		blocksize = (int)UINT_GET ((int)(Math.Log (blocksize) / M_LN2)' stream);  		break;  	case FN_BITSHIFT:  		uvar_get (BITSHIFTSIZE' stream);  		break;  	case FN_VERBATIM:  		int cklen = uvar_get (VERBATIM_CKSIZE_SIZE' stream);  		while (cklen-- != 0) {  			uvar_get (VERBATIM_BYTE_SIZE' stream);  		}  		break;  	default:  		return 0;  	}  	cmd = uvar_get (FNSIZE' stream);  }  
Magic Number,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,getSamples,The following statement contains a magic number: while (cmd != FN_QUIT) {  	switch (cmd) {  	case FN_ZERO:  	case FN_DIFF0:  	case FN_DIFF1:  	case FN_DIFF2:  	case FN_DIFF3:  	case FN_QLPC:  		int resn = 0;  		if (cmd != FN_ZERO) {  			resn = uvar_get (ENERGYSIZE' stream);  			// this is a hack as version 0 differed in definition of var_get  			if (version == 0)  				resn--;  		}  		switch (cmd) {  		case FN_ZERO:  			break;  		case FN_DIFF0:  		case FN_DIFF1:  		case FN_DIFF2:  		case FN_DIFF3:  			for (i = 0; i < blocksize; i++) {  				int nbin = resn + 1;  				if (nbitget == 0) {  					if (nbyteget < 4) {  						int bytes = stream.Read (getbuf' 0' BUFSIZE);  						getbufOffset = 0;  						nbyteget += bytes;  					}  					gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  					getbufOffset += 4;  					nbyteget -= 4;  					nbitget = 32;  				}  				while ((gbuffer & (1L << --nbitget)) == 0) {  					if (nbitget == 0) {  						if (nbyteget < 4) {  							int bytes = stream.Read (getbuf' 0' BUFSIZE);  							getbufOffset = 0;  							nbyteget += bytes;  						}  						gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  						getbufOffset += 4;  						nbyteget -= 4;  						nbitget = 32;  					}  				}  				while (nbin != 0) {  					if (nbitget >= nbin) {  						nbitget -= nbin;  						nbin = 0;  					} else {  						if (nbyteget < 4) {  							int bytes = stream.Read (getbuf' 0' BUFSIZE);  							getbufOffset = 0;  							nbyteget += bytes;  						}  						gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  						getbufOffset += 4;  						nbyteget -= 4;  						nbin -= nbitget;  						nbitget = 32;  					}  				}  			}  			break;  		case FN_QLPC:  			int nlpc = uvar_get (LPCQSIZE' stream);  			for (i = 0; i < nlpc; i++)  				var_get (LPCQUANT' stream);  			break;  		}  		if (chan == nchan - 1) {  			SampleNumber += blocksize;  		}  		chan = (chan + 1) % nchan;  		break;  	case FN_BLOCKSIZE:  		blocksize = (int)UINT_GET ((int)(Math.Log (blocksize) / M_LN2)' stream);  		break;  	case FN_BITSHIFT:  		uvar_get (BITSHIFTSIZE' stream);  		break;  	case FN_VERBATIM:  		int cklen = uvar_get (VERBATIM_CKSIZE_SIZE' stream);  		while (cklen-- != 0) {  			uvar_get (VERBATIM_BYTE_SIZE' stream);  		}  		break;  	default:  		return 0;  	}  	cmd = uvar_get (FNSIZE' stream);  }  
Magic Number,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,getSamples,The following statement contains a magic number: while (cmd != FN_QUIT) {  	switch (cmd) {  	case FN_ZERO:  	case FN_DIFF0:  	case FN_DIFF1:  	case FN_DIFF2:  	case FN_DIFF3:  	case FN_QLPC:  		int resn = 0;  		if (cmd != FN_ZERO) {  			resn = uvar_get (ENERGYSIZE' stream);  			// this is a hack as version 0 differed in definition of var_get  			if (version == 0)  				resn--;  		}  		switch (cmd) {  		case FN_ZERO:  			break;  		case FN_DIFF0:  		case FN_DIFF1:  		case FN_DIFF2:  		case FN_DIFF3:  			for (i = 0; i < blocksize; i++) {  				int nbin = resn + 1;  				if (nbitget == 0) {  					if (nbyteget < 4) {  						int bytes = stream.Read (getbuf' 0' BUFSIZE);  						getbufOffset = 0;  						nbyteget += bytes;  					}  					gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  					getbufOffset += 4;  					nbyteget -= 4;  					nbitget = 32;  				}  				while ((gbuffer & (1L << --nbitget)) == 0) {  					if (nbitget == 0) {  						if (nbyteget < 4) {  							int bytes = stream.Read (getbuf' 0' BUFSIZE);  							getbufOffset = 0;  							nbyteget += bytes;  						}  						gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  						getbufOffset += 4;  						nbyteget -= 4;  						nbitget = 32;  					}  				}  				while (nbin != 0) {  					if (nbitget >= nbin) {  						nbitget -= nbin;  						nbin = 0;  					} else {  						if (nbyteget < 4) {  							int bytes = stream.Read (getbuf' 0' BUFSIZE);  							getbufOffset = 0;  							nbyteget += bytes;  						}  						gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  						getbufOffset += 4;  						nbyteget -= 4;  						nbin -= nbitget;  						nbitget = 32;  					}  				}  			}  			break;  		case FN_QLPC:  			int nlpc = uvar_get (LPCQSIZE' stream);  			for (i = 0; i < nlpc; i++)  				var_get (LPCQUANT' stream);  			break;  		}  		if (chan == nchan - 1) {  			SampleNumber += blocksize;  		}  		chan = (chan + 1) % nchan;  		break;  	case FN_BLOCKSIZE:  		blocksize = (int)UINT_GET ((int)(Math.Log (blocksize) / M_LN2)' stream);  		break;  	case FN_BITSHIFT:  		uvar_get (BITSHIFTSIZE' stream);  		break;  	case FN_VERBATIM:  		int cklen = uvar_get (VERBATIM_CKSIZE_SIZE' stream);  		while (cklen-- != 0) {  			uvar_get (VERBATIM_BYTE_SIZE' stream);  		}  		break;  	default:  		return 0;  	}  	cmd = uvar_get (FNSIZE' stream);  }  
Magic Number,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,getSamples,The following statement contains a magic number: while (cmd != FN_QUIT) {  	switch (cmd) {  	case FN_ZERO:  	case FN_DIFF0:  	case FN_DIFF1:  	case FN_DIFF2:  	case FN_DIFF3:  	case FN_QLPC:  		int resn = 0;  		if (cmd != FN_ZERO) {  			resn = uvar_get (ENERGYSIZE' stream);  			// this is a hack as version 0 differed in definition of var_get  			if (version == 0)  				resn--;  		}  		switch (cmd) {  		case FN_ZERO:  			break;  		case FN_DIFF0:  		case FN_DIFF1:  		case FN_DIFF2:  		case FN_DIFF3:  			for (i = 0; i < blocksize; i++) {  				int nbin = resn + 1;  				if (nbitget == 0) {  					if (nbyteget < 4) {  						int bytes = stream.Read (getbuf' 0' BUFSIZE);  						getbufOffset = 0;  						nbyteget += bytes;  					}  					gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  					getbufOffset += 4;  					nbyteget -= 4;  					nbitget = 32;  				}  				while ((gbuffer & (1L << --nbitget)) == 0) {  					if (nbitget == 0) {  						if (nbyteget < 4) {  							int bytes = stream.Read (getbuf' 0' BUFSIZE);  							getbufOffset = 0;  							nbyteget += bytes;  						}  						gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  						getbufOffset += 4;  						nbyteget -= 4;  						nbitget = 32;  					}  				}  				while (nbin != 0) {  					if (nbitget >= nbin) {  						nbitget -= nbin;  						nbin = 0;  					} else {  						if (nbyteget < 4) {  							int bytes = stream.Read (getbuf' 0' BUFSIZE);  							getbufOffset = 0;  							nbyteget += bytes;  						}  						gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  						getbufOffset += 4;  						nbyteget -= 4;  						nbin -= nbitget;  						nbitget = 32;  					}  				}  			}  			break;  		case FN_QLPC:  			int nlpc = uvar_get (LPCQSIZE' stream);  			for (i = 0; i < nlpc; i++)  				var_get (LPCQUANT' stream);  			break;  		}  		if (chan == nchan - 1) {  			SampleNumber += blocksize;  		}  		chan = (chan + 1) % nchan;  		break;  	case FN_BLOCKSIZE:  		blocksize = (int)UINT_GET ((int)(Math.Log (blocksize) / M_LN2)' stream);  		break;  	case FN_BITSHIFT:  		uvar_get (BITSHIFTSIZE' stream);  		break;  	case FN_VERBATIM:  		int cklen = uvar_get (VERBATIM_CKSIZE_SIZE' stream);  		while (cklen-- != 0) {  			uvar_get (VERBATIM_BYTE_SIZE' stream);  		}  		break;  	default:  		return 0;  	}  	cmd = uvar_get (FNSIZE' stream);  }  
Magic Number,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,getSamples,The following statement contains a magic number: while (cmd != FN_QUIT) {  	switch (cmd) {  	case FN_ZERO:  	case FN_DIFF0:  	case FN_DIFF1:  	case FN_DIFF2:  	case FN_DIFF3:  	case FN_QLPC:  		int resn = 0;  		if (cmd != FN_ZERO) {  			resn = uvar_get (ENERGYSIZE' stream);  			// this is a hack as version 0 differed in definition of var_get  			if (version == 0)  				resn--;  		}  		switch (cmd) {  		case FN_ZERO:  			break;  		case FN_DIFF0:  		case FN_DIFF1:  		case FN_DIFF2:  		case FN_DIFF3:  			for (i = 0; i < blocksize; i++) {  				int nbin = resn + 1;  				if (nbitget == 0) {  					if (nbyteget < 4) {  						int bytes = stream.Read (getbuf' 0' BUFSIZE);  						getbufOffset = 0;  						nbyteget += bytes;  					}  					gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  					getbufOffset += 4;  					nbyteget -= 4;  					nbitget = 32;  				}  				while ((gbuffer & (1L << --nbitget)) == 0) {  					if (nbitget == 0) {  						if (nbyteget < 4) {  							int bytes = stream.Read (getbuf' 0' BUFSIZE);  							getbufOffset = 0;  							nbyteget += bytes;  						}  						gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  						getbufOffset += 4;  						nbyteget -= 4;  						nbitget = 32;  					}  				}  				while (nbin != 0) {  					if (nbitget >= nbin) {  						nbitget -= nbin;  						nbin = 0;  					} else {  						if (nbyteget < 4) {  							int bytes = stream.Read (getbuf' 0' BUFSIZE);  							getbufOffset = 0;  							nbyteget += bytes;  						}  						gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  						getbufOffset += 4;  						nbyteget -= 4;  						nbin -= nbitget;  						nbitget = 32;  					}  				}  			}  			break;  		case FN_QLPC:  			int nlpc = uvar_get (LPCQSIZE' stream);  			for (i = 0; i < nlpc; i++)  				var_get (LPCQUANT' stream);  			break;  		}  		if (chan == nchan - 1) {  			SampleNumber += blocksize;  		}  		chan = (chan + 1) % nchan;  		break;  	case FN_BLOCKSIZE:  		blocksize = (int)UINT_GET ((int)(Math.Log (blocksize) / M_LN2)' stream);  		break;  	case FN_BITSHIFT:  		uvar_get (BITSHIFTSIZE' stream);  		break;  	case FN_VERBATIM:  		int cklen = uvar_get (VERBATIM_CKSIZE_SIZE' stream);  		while (cklen-- != 0) {  			uvar_get (VERBATIM_BYTE_SIZE' stream);  		}  		break;  	default:  		return 0;  	}  	cmd = uvar_get (FNSIZE' stream);  }  
Magic Number,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,getSamples,The following statement contains a magic number: while (cmd != FN_QUIT) {  	switch (cmd) {  	case FN_ZERO:  	case FN_DIFF0:  	case FN_DIFF1:  	case FN_DIFF2:  	case FN_DIFF3:  	case FN_QLPC:  		int resn = 0;  		if (cmd != FN_ZERO) {  			resn = uvar_get (ENERGYSIZE' stream);  			// this is a hack as version 0 differed in definition of var_get  			if (version == 0)  				resn--;  		}  		switch (cmd) {  		case FN_ZERO:  			break;  		case FN_DIFF0:  		case FN_DIFF1:  		case FN_DIFF2:  		case FN_DIFF3:  			for (i = 0; i < blocksize; i++) {  				int nbin = resn + 1;  				if (nbitget == 0) {  					if (nbyteget < 4) {  						int bytes = stream.Read (getbuf' 0' BUFSIZE);  						getbufOffset = 0;  						nbyteget += bytes;  					}  					gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  					getbufOffset += 4;  					nbyteget -= 4;  					nbitget = 32;  				}  				while ((gbuffer & (1L << --nbitget)) == 0) {  					if (nbitget == 0) {  						if (nbyteget < 4) {  							int bytes = stream.Read (getbuf' 0' BUFSIZE);  							getbufOffset = 0;  							nbyteget += bytes;  						}  						gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  						getbufOffset += 4;  						nbyteget -= 4;  						nbitget = 32;  					}  				}  				while (nbin != 0) {  					if (nbitget >= nbin) {  						nbitget -= nbin;  						nbin = 0;  					} else {  						if (nbyteget < 4) {  							int bytes = stream.Read (getbuf' 0' BUFSIZE);  							getbufOffset = 0;  							nbyteget += bytes;  						}  						gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  						getbufOffset += 4;  						nbyteget -= 4;  						nbin -= nbitget;  						nbitget = 32;  					}  				}  			}  			break;  		case FN_QLPC:  			int nlpc = uvar_get (LPCQSIZE' stream);  			for (i = 0; i < nlpc; i++)  				var_get (LPCQUANT' stream);  			break;  		}  		if (chan == nchan - 1) {  			SampleNumber += blocksize;  		}  		chan = (chan + 1) % nchan;  		break;  	case FN_BLOCKSIZE:  		blocksize = (int)UINT_GET ((int)(Math.Log (blocksize) / M_LN2)' stream);  		break;  	case FN_BITSHIFT:  		uvar_get (BITSHIFTSIZE' stream);  		break;  	case FN_VERBATIM:  		int cklen = uvar_get (VERBATIM_CKSIZE_SIZE' stream);  		while (cklen-- != 0) {  			uvar_get (VERBATIM_BYTE_SIZE' stream);  		}  		break;  	default:  		return 0;  	}  	cmd = uvar_get (FNSIZE' stream);  }  
Magic Number,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,getSamples,The following statement contains a magic number: while (cmd != FN_QUIT) {  	switch (cmd) {  	case FN_ZERO:  	case FN_DIFF0:  	case FN_DIFF1:  	case FN_DIFF2:  	case FN_DIFF3:  	case FN_QLPC:  		int resn = 0;  		if (cmd != FN_ZERO) {  			resn = uvar_get (ENERGYSIZE' stream);  			// this is a hack as version 0 differed in definition of var_get  			if (version == 0)  				resn--;  		}  		switch (cmd) {  		case FN_ZERO:  			break;  		case FN_DIFF0:  		case FN_DIFF1:  		case FN_DIFF2:  		case FN_DIFF3:  			for (i = 0; i < blocksize; i++) {  				int nbin = resn + 1;  				if (nbitget == 0) {  					if (nbyteget < 4) {  						int bytes = stream.Read (getbuf' 0' BUFSIZE);  						getbufOffset = 0;  						nbyteget += bytes;  					}  					gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  					getbufOffset += 4;  					nbyteget -= 4;  					nbitget = 32;  				}  				while ((gbuffer & (1L << --nbitget)) == 0) {  					if (nbitget == 0) {  						if (nbyteget < 4) {  							int bytes = stream.Read (getbuf' 0' BUFSIZE);  							getbufOffset = 0;  							nbyteget += bytes;  						}  						gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  						getbufOffset += 4;  						nbyteget -= 4;  						nbitget = 32;  					}  				}  				while (nbin != 0) {  					if (nbitget >= nbin) {  						nbitget -= nbin;  						nbin = 0;  					} else {  						if (nbyteget < 4) {  							int bytes = stream.Read (getbuf' 0' BUFSIZE);  							getbufOffset = 0;  							nbyteget += bytes;  						}  						gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  						getbufOffset += 4;  						nbyteget -= 4;  						nbin -= nbitget;  						nbitget = 32;  					}  				}  			}  			break;  		case FN_QLPC:  			int nlpc = uvar_get (LPCQSIZE' stream);  			for (i = 0; i < nlpc; i++)  				var_get (LPCQUANT' stream);  			break;  		}  		if (chan == nchan - 1) {  			SampleNumber += blocksize;  		}  		chan = (chan + 1) % nchan;  		break;  	case FN_BLOCKSIZE:  		blocksize = (int)UINT_GET ((int)(Math.Log (blocksize) / M_LN2)' stream);  		break;  	case FN_BITSHIFT:  		uvar_get (BITSHIFTSIZE' stream);  		break;  	case FN_VERBATIM:  		int cklen = uvar_get (VERBATIM_CKSIZE_SIZE' stream);  		while (cklen-- != 0) {  			uvar_get (VERBATIM_BYTE_SIZE' stream);  		}  		break;  	default:  		return 0;  	}  	cmd = uvar_get (FNSIZE' stream);  }  
Magic Number,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,getSamples,The following statement contains a magic number: while (cmd != FN_QUIT) {  	switch (cmd) {  	case FN_ZERO:  	case FN_DIFF0:  	case FN_DIFF1:  	case FN_DIFF2:  	case FN_DIFF3:  	case FN_QLPC:  		int resn = 0;  		if (cmd != FN_ZERO) {  			resn = uvar_get (ENERGYSIZE' stream);  			// this is a hack as version 0 differed in definition of var_get  			if (version == 0)  				resn--;  		}  		switch (cmd) {  		case FN_ZERO:  			break;  		case FN_DIFF0:  		case FN_DIFF1:  		case FN_DIFF2:  		case FN_DIFF3:  			for (i = 0; i < blocksize; i++) {  				int nbin = resn + 1;  				if (nbitget == 0) {  					if (nbyteget < 4) {  						int bytes = stream.Read (getbuf' 0' BUFSIZE);  						getbufOffset = 0;  						nbyteget += bytes;  					}  					gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  					getbufOffset += 4;  					nbyteget -= 4;  					nbitget = 32;  				}  				while ((gbuffer & (1L << --nbitget)) == 0) {  					if (nbitget == 0) {  						if (nbyteget < 4) {  							int bytes = stream.Read (getbuf' 0' BUFSIZE);  							getbufOffset = 0;  							nbyteget += bytes;  						}  						gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  						getbufOffset += 4;  						nbyteget -= 4;  						nbitget = 32;  					}  				}  				while (nbin != 0) {  					if (nbitget >= nbin) {  						nbitget -= nbin;  						nbin = 0;  					} else {  						if (nbyteget < 4) {  							int bytes = stream.Read (getbuf' 0' BUFSIZE);  							getbufOffset = 0;  							nbyteget += bytes;  						}  						gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  						getbufOffset += 4;  						nbyteget -= 4;  						nbin -= nbitget;  						nbitget = 32;  					}  				}  			}  			break;  		case FN_QLPC:  			int nlpc = uvar_get (LPCQSIZE' stream);  			for (i = 0; i < nlpc; i++)  				var_get (LPCQUANT' stream);  			break;  		}  		if (chan == nchan - 1) {  			SampleNumber += blocksize;  		}  		chan = (chan + 1) % nchan;  		break;  	case FN_BLOCKSIZE:  		blocksize = (int)UINT_GET ((int)(Math.Log (blocksize) / M_LN2)' stream);  		break;  	case FN_BITSHIFT:  		uvar_get (BITSHIFTSIZE' stream);  		break;  	case FN_VERBATIM:  		int cklen = uvar_get (VERBATIM_CKSIZE_SIZE' stream);  		while (cklen-- != 0) {  			uvar_get (VERBATIM_BYTE_SIZE' stream);  		}  		break;  	default:  		return 0;  	}  	cmd = uvar_get (FNSIZE' stream);  }  
Magic Number,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,getSamples,The following statement contains a magic number: while (cmd != FN_QUIT) {  	switch (cmd) {  	case FN_ZERO:  	case FN_DIFF0:  	case FN_DIFF1:  	case FN_DIFF2:  	case FN_DIFF3:  	case FN_QLPC:  		int resn = 0;  		if (cmd != FN_ZERO) {  			resn = uvar_get (ENERGYSIZE' stream);  			// this is a hack as version 0 differed in definition of var_get  			if (version == 0)  				resn--;  		}  		switch (cmd) {  		case FN_ZERO:  			break;  		case FN_DIFF0:  		case FN_DIFF1:  		case FN_DIFF2:  		case FN_DIFF3:  			for (i = 0; i < blocksize; i++) {  				int nbin = resn + 1;  				if (nbitget == 0) {  					if (nbyteget < 4) {  						int bytes = stream.Read (getbuf' 0' BUFSIZE);  						getbufOffset = 0;  						nbyteget += bytes;  					}  					gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  					getbufOffset += 4;  					nbyteget -= 4;  					nbitget = 32;  				}  				while ((gbuffer & (1L << --nbitget)) == 0) {  					if (nbitget == 0) {  						if (nbyteget < 4) {  							int bytes = stream.Read (getbuf' 0' BUFSIZE);  							getbufOffset = 0;  							nbyteget += bytes;  						}  						gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  						getbufOffset += 4;  						nbyteget -= 4;  						nbitget = 32;  					}  				}  				while (nbin != 0) {  					if (nbitget >= nbin) {  						nbitget -= nbin;  						nbin = 0;  					} else {  						if (nbyteget < 4) {  							int bytes = stream.Read (getbuf' 0' BUFSIZE);  							getbufOffset = 0;  							nbyteget += bytes;  						}  						gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  						getbufOffset += 4;  						nbyteget -= 4;  						nbin -= nbitget;  						nbitget = 32;  					}  				}  			}  			break;  		case FN_QLPC:  			int nlpc = uvar_get (LPCQSIZE' stream);  			for (i = 0; i < nlpc; i++)  				var_get (LPCQUANT' stream);  			break;  		}  		if (chan == nchan - 1) {  			SampleNumber += blocksize;  		}  		chan = (chan + 1) % nchan;  		break;  	case FN_BLOCKSIZE:  		blocksize = (int)UINT_GET ((int)(Math.Log (blocksize) / M_LN2)' stream);  		break;  	case FN_BITSHIFT:  		uvar_get (BITSHIFTSIZE' stream);  		break;  	case FN_VERBATIM:  		int cklen = uvar_get (VERBATIM_CKSIZE_SIZE' stream);  		while (cklen-- != 0) {  			uvar_get (VERBATIM_BYTE_SIZE' stream);  		}  		break;  	default:  		return 0;  	}  	cmd = uvar_get (FNSIZE' stream);  }  
Magic Number,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,getSamples,The following statement contains a magic number: while (cmd != FN_QUIT) {  	switch (cmd) {  	case FN_ZERO:  	case FN_DIFF0:  	case FN_DIFF1:  	case FN_DIFF2:  	case FN_DIFF3:  	case FN_QLPC:  		int resn = 0;  		if (cmd != FN_ZERO) {  			resn = uvar_get (ENERGYSIZE' stream);  			// this is a hack as version 0 differed in definition of var_get  			if (version == 0)  				resn--;  		}  		switch (cmd) {  		case FN_ZERO:  			break;  		case FN_DIFF0:  		case FN_DIFF1:  		case FN_DIFF2:  		case FN_DIFF3:  			for (i = 0; i < blocksize; i++) {  				int nbin = resn + 1;  				if (nbitget == 0) {  					if (nbyteget < 4) {  						int bytes = stream.Read (getbuf' 0' BUFSIZE);  						getbufOffset = 0;  						nbyteget += bytes;  					}  					gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  					getbufOffset += 4;  					nbyteget -= 4;  					nbitget = 32;  				}  				while ((gbuffer & (1L << --nbitget)) == 0) {  					if (nbitget == 0) {  						if (nbyteget < 4) {  							int bytes = stream.Read (getbuf' 0' BUFSIZE);  							getbufOffset = 0;  							nbyteget += bytes;  						}  						gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  						getbufOffset += 4;  						nbyteget -= 4;  						nbitget = 32;  					}  				}  				while (nbin != 0) {  					if (nbitget >= nbin) {  						nbitget -= nbin;  						nbin = 0;  					} else {  						if (nbyteget < 4) {  							int bytes = stream.Read (getbuf' 0' BUFSIZE);  							getbufOffset = 0;  							nbyteget += bytes;  						}  						gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  						getbufOffset += 4;  						nbyteget -= 4;  						nbin -= nbitget;  						nbitget = 32;  					}  				}  			}  			break;  		case FN_QLPC:  			int nlpc = uvar_get (LPCQSIZE' stream);  			for (i = 0; i < nlpc; i++)  				var_get (LPCQUANT' stream);  			break;  		}  		if (chan == nchan - 1) {  			SampleNumber += blocksize;  		}  		chan = (chan + 1) % nchan;  		break;  	case FN_BLOCKSIZE:  		blocksize = (int)UINT_GET ((int)(Math.Log (blocksize) / M_LN2)' stream);  		break;  	case FN_BITSHIFT:  		uvar_get (BITSHIFTSIZE' stream);  		break;  	case FN_VERBATIM:  		int cklen = uvar_get (VERBATIM_CKSIZE_SIZE' stream);  		while (cklen-- != 0) {  			uvar_get (VERBATIM_BYTE_SIZE' stream);  		}  		break;  	default:  		return 0;  	}  	cmd = uvar_get (FNSIZE' stream);  }  
Magic Number,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,getSamples,The following statement contains a magic number: while (cmd != FN_QUIT) {  	switch (cmd) {  	case FN_ZERO:  	case FN_DIFF0:  	case FN_DIFF1:  	case FN_DIFF2:  	case FN_DIFF3:  	case FN_QLPC:  		int resn = 0;  		if (cmd != FN_ZERO) {  			resn = uvar_get (ENERGYSIZE' stream);  			// this is a hack as version 0 differed in definition of var_get  			if (version == 0)  				resn--;  		}  		switch (cmd) {  		case FN_ZERO:  			break;  		case FN_DIFF0:  		case FN_DIFF1:  		case FN_DIFF2:  		case FN_DIFF3:  			for (i = 0; i < blocksize; i++) {  				int nbin = resn + 1;  				if (nbitget == 0) {  					if (nbyteget < 4) {  						int bytes = stream.Read (getbuf' 0' BUFSIZE);  						getbufOffset = 0;  						nbyteget += bytes;  					}  					gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  					getbufOffset += 4;  					nbyteget -= 4;  					nbitget = 32;  				}  				while ((gbuffer & (1L << --nbitget)) == 0) {  					if (nbitget == 0) {  						if (nbyteget < 4) {  							int bytes = stream.Read (getbuf' 0' BUFSIZE);  							getbufOffset = 0;  							nbyteget += bytes;  						}  						gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  						getbufOffset += 4;  						nbyteget -= 4;  						nbitget = 32;  					}  				}  				while (nbin != 0) {  					if (nbitget >= nbin) {  						nbitget -= nbin;  						nbin = 0;  					} else {  						if (nbyteget < 4) {  							int bytes = stream.Read (getbuf' 0' BUFSIZE);  							getbufOffset = 0;  							nbyteget += bytes;  						}  						gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  						getbufOffset += 4;  						nbyteget -= 4;  						nbin -= nbitget;  						nbitget = 32;  					}  				}  			}  			break;  		case FN_QLPC:  			int nlpc = uvar_get (LPCQSIZE' stream);  			for (i = 0; i < nlpc; i++)  				var_get (LPCQUANT' stream);  			break;  		}  		if (chan == nchan - 1) {  			SampleNumber += blocksize;  		}  		chan = (chan + 1) % nchan;  		break;  	case FN_BLOCKSIZE:  		blocksize = (int)UINT_GET ((int)(Math.Log (blocksize) / M_LN2)' stream);  		break;  	case FN_BITSHIFT:  		uvar_get (BITSHIFTSIZE' stream);  		break;  	case FN_VERBATIM:  		int cklen = uvar_get (VERBATIM_CKSIZE_SIZE' stream);  		while (cklen-- != 0) {  			uvar_get (VERBATIM_BYTE_SIZE' stream);  		}  		break;  	default:  		return 0;  	}  	cmd = uvar_get (FNSIZE' stream);  }  
Magic Number,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,getSamples,The following statement contains a magic number: while (cmd != FN_QUIT) {  	switch (cmd) {  	case FN_ZERO:  	case FN_DIFF0:  	case FN_DIFF1:  	case FN_DIFF2:  	case FN_DIFF3:  	case FN_QLPC:  		int resn = 0;  		if (cmd != FN_ZERO) {  			resn = uvar_get (ENERGYSIZE' stream);  			// this is a hack as version 0 differed in definition of var_get  			if (version == 0)  				resn--;  		}  		switch (cmd) {  		case FN_ZERO:  			break;  		case FN_DIFF0:  		case FN_DIFF1:  		case FN_DIFF2:  		case FN_DIFF3:  			for (i = 0; i < blocksize; i++) {  				int nbin = resn + 1;  				if (nbitget == 0) {  					if (nbyteget < 4) {  						int bytes = stream.Read (getbuf' 0' BUFSIZE);  						getbufOffset = 0;  						nbyteget += bytes;  					}  					gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  					getbufOffset += 4;  					nbyteget -= 4;  					nbitget = 32;  				}  				while ((gbuffer & (1L << --nbitget)) == 0) {  					if (nbitget == 0) {  						if (nbyteget < 4) {  							int bytes = stream.Read (getbuf' 0' BUFSIZE);  							getbufOffset = 0;  							nbyteget += bytes;  						}  						gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  						getbufOffset += 4;  						nbyteget -= 4;  						nbitget = 32;  					}  				}  				while (nbin != 0) {  					if (nbitget >= nbin) {  						nbitget -= nbin;  						nbin = 0;  					} else {  						if (nbyteget < 4) {  							int bytes = stream.Read (getbuf' 0' BUFSIZE);  							getbufOffset = 0;  							nbyteget += bytes;  						}  						gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  						getbufOffset += 4;  						nbyteget -= 4;  						nbin -= nbitget;  						nbitget = 32;  					}  				}  			}  			break;  		case FN_QLPC:  			int nlpc = uvar_get (LPCQSIZE' stream);  			for (i = 0; i < nlpc; i++)  				var_get (LPCQUANT' stream);  			break;  		}  		if (chan == nchan - 1) {  			SampleNumber += blocksize;  		}  		chan = (chan + 1) % nchan;  		break;  	case FN_BLOCKSIZE:  		blocksize = (int)UINT_GET ((int)(Math.Log (blocksize) / M_LN2)' stream);  		break;  	case FN_BITSHIFT:  		uvar_get (BITSHIFTSIZE' stream);  		break;  	case FN_VERBATIM:  		int cklen = uvar_get (VERBATIM_CKSIZE_SIZE' stream);  		while (cklen-- != 0) {  			uvar_get (VERBATIM_BYTE_SIZE' stream);  		}  		break;  	default:  		return 0;  	}  	cmd = uvar_get (FNSIZE' stream);  }  
Magic Number,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,getSamples,The following statement contains a magic number: while (cmd != FN_QUIT) {  	switch (cmd) {  	case FN_ZERO:  	case FN_DIFF0:  	case FN_DIFF1:  	case FN_DIFF2:  	case FN_DIFF3:  	case FN_QLPC:  		int resn = 0;  		if (cmd != FN_ZERO) {  			resn = uvar_get (ENERGYSIZE' stream);  			// this is a hack as version 0 differed in definition of var_get  			if (version == 0)  				resn--;  		}  		switch (cmd) {  		case FN_ZERO:  			break;  		case FN_DIFF0:  		case FN_DIFF1:  		case FN_DIFF2:  		case FN_DIFF3:  			for (i = 0; i < blocksize; i++) {  				int nbin = resn + 1;  				if (nbitget == 0) {  					if (nbyteget < 4) {  						int bytes = stream.Read (getbuf' 0' BUFSIZE);  						getbufOffset = 0;  						nbyteget += bytes;  					}  					gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  					getbufOffset += 4;  					nbyteget -= 4;  					nbitget = 32;  				}  				while ((gbuffer & (1L << --nbitget)) == 0) {  					if (nbitget == 0) {  						if (nbyteget < 4) {  							int bytes = stream.Read (getbuf' 0' BUFSIZE);  							getbufOffset = 0;  							nbyteget += bytes;  						}  						gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  						getbufOffset += 4;  						nbyteget -= 4;  						nbitget = 32;  					}  				}  				while (nbin != 0) {  					if (nbitget >= nbin) {  						nbitget -= nbin;  						nbin = 0;  					} else {  						if (nbyteget < 4) {  							int bytes = stream.Read (getbuf' 0' BUFSIZE);  							getbufOffset = 0;  							nbyteget += bytes;  						}  						gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  						getbufOffset += 4;  						nbyteget -= 4;  						nbin -= nbitget;  						nbitget = 32;  					}  				}  			}  			break;  		case FN_QLPC:  			int nlpc = uvar_get (LPCQSIZE' stream);  			for (i = 0; i < nlpc; i++)  				var_get (LPCQUANT' stream);  			break;  		}  		if (chan == nchan - 1) {  			SampleNumber += blocksize;  		}  		chan = (chan + 1) % nchan;  		break;  	case FN_BLOCKSIZE:  		blocksize = (int)UINT_GET ((int)(Math.Log (blocksize) / M_LN2)' stream);  		break;  	case FN_BITSHIFT:  		uvar_get (BITSHIFTSIZE' stream);  		break;  	case FN_VERBATIM:  		int cklen = uvar_get (VERBATIM_CKSIZE_SIZE' stream);  		while (cklen-- != 0) {  			uvar_get (VERBATIM_BYTE_SIZE' stream);  		}  		break;  	default:  		return 0;  	}  	cmd = uvar_get (FNSIZE' stream);  }  
Magic Number,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,getSamples,The following statement contains a magic number: while (cmd != FN_QUIT) {  	switch (cmd) {  	case FN_ZERO:  	case FN_DIFF0:  	case FN_DIFF1:  	case FN_DIFF2:  	case FN_DIFF3:  	case FN_QLPC:  		int resn = 0;  		if (cmd != FN_ZERO) {  			resn = uvar_get (ENERGYSIZE' stream);  			// this is a hack as version 0 differed in definition of var_get  			if (version == 0)  				resn--;  		}  		switch (cmd) {  		case FN_ZERO:  			break;  		case FN_DIFF0:  		case FN_DIFF1:  		case FN_DIFF2:  		case FN_DIFF3:  			for (i = 0; i < blocksize; i++) {  				int nbin = resn + 1;  				if (nbitget == 0) {  					if (nbyteget < 4) {  						int bytes = stream.Read (getbuf' 0' BUFSIZE);  						getbufOffset = 0;  						nbyteget += bytes;  					}  					gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  					getbufOffset += 4;  					nbyteget -= 4;  					nbitget = 32;  				}  				while ((gbuffer & (1L << --nbitget)) == 0) {  					if (nbitget == 0) {  						if (nbyteget < 4) {  							int bytes = stream.Read (getbuf' 0' BUFSIZE);  							getbufOffset = 0;  							nbyteget += bytes;  						}  						gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  						getbufOffset += 4;  						nbyteget -= 4;  						nbitget = 32;  					}  				}  				while (nbin != 0) {  					if (nbitget >= nbin) {  						nbitget -= nbin;  						nbin = 0;  					} else {  						if (nbyteget < 4) {  							int bytes = stream.Read (getbuf' 0' BUFSIZE);  							getbufOffset = 0;  							nbyteget += bytes;  						}  						gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  						getbufOffset += 4;  						nbyteget -= 4;  						nbin -= nbitget;  						nbitget = 32;  					}  				}  			}  			break;  		case FN_QLPC:  			int nlpc = uvar_get (LPCQSIZE' stream);  			for (i = 0; i < nlpc; i++)  				var_get (LPCQUANT' stream);  			break;  		}  		if (chan == nchan - 1) {  			SampleNumber += blocksize;  		}  		chan = (chan + 1) % nchan;  		break;  	case FN_BLOCKSIZE:  		blocksize = (int)UINT_GET ((int)(Math.Log (blocksize) / M_LN2)' stream);  		break;  	case FN_BITSHIFT:  		uvar_get (BITSHIFTSIZE' stream);  		break;  	case FN_VERBATIM:  		int cklen = uvar_get (VERBATIM_CKSIZE_SIZE' stream);  		while (cklen-- != 0) {  			uvar_get (VERBATIM_BYTE_SIZE' stream);  		}  		break;  	default:  		return 0;  	}  	cmd = uvar_get (FNSIZE' stream);  }  
Magic Number,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,getSamples,The following statement contains a magic number: while (cmd != FN_QUIT) {  	switch (cmd) {  	case FN_ZERO:  	case FN_DIFF0:  	case FN_DIFF1:  	case FN_DIFF2:  	case FN_DIFF3:  	case FN_QLPC:  		int resn = 0;  		if (cmd != FN_ZERO) {  			resn = uvar_get (ENERGYSIZE' stream);  			// this is a hack as version 0 differed in definition of var_get  			if (version == 0)  				resn--;  		}  		switch (cmd) {  		case FN_ZERO:  			break;  		case FN_DIFF0:  		case FN_DIFF1:  		case FN_DIFF2:  		case FN_DIFF3:  			for (i = 0; i < blocksize; i++) {  				int nbin = resn + 1;  				if (nbitget == 0) {  					if (nbyteget < 4) {  						int bytes = stream.Read (getbuf' 0' BUFSIZE);  						getbufOffset = 0;  						nbyteget += bytes;  					}  					gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  					getbufOffset += 4;  					nbyteget -= 4;  					nbitget = 32;  				}  				while ((gbuffer & (1L << --nbitget)) == 0) {  					if (nbitget == 0) {  						if (nbyteget < 4) {  							int bytes = stream.Read (getbuf' 0' BUFSIZE);  							getbufOffset = 0;  							nbyteget += bytes;  						}  						gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  						getbufOffset += 4;  						nbyteget -= 4;  						nbitget = 32;  					}  				}  				while (nbin != 0) {  					if (nbitget >= nbin) {  						nbitget -= nbin;  						nbin = 0;  					} else {  						if (nbyteget < 4) {  							int bytes = stream.Read (getbuf' 0' BUFSIZE);  							getbufOffset = 0;  							nbyteget += bytes;  						}  						gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  						getbufOffset += 4;  						nbyteget -= 4;  						nbin -= nbitget;  						nbitget = 32;  					}  				}  			}  			break;  		case FN_QLPC:  			int nlpc = uvar_get (LPCQSIZE' stream);  			for (i = 0; i < nlpc; i++)  				var_get (LPCQUANT' stream);  			break;  		}  		if (chan == nchan - 1) {  			SampleNumber += blocksize;  		}  		chan = (chan + 1) % nchan;  		break;  	case FN_BLOCKSIZE:  		blocksize = (int)UINT_GET ((int)(Math.Log (blocksize) / M_LN2)' stream);  		break;  	case FN_BITSHIFT:  		uvar_get (BITSHIFTSIZE' stream);  		break;  	case FN_VERBATIM:  		int cklen = uvar_get (VERBATIM_CKSIZE_SIZE' stream);  		while (cklen-- != 0) {  			uvar_get (VERBATIM_BYTE_SIZE' stream);  		}  		break;  	default:  		return 0;  	}  	cmd = uvar_get (FNSIZE' stream);  }  
Magic Number,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,getSamples,The following statement contains a magic number: while (cmd != FN_QUIT) {  	switch (cmd) {  	case FN_ZERO:  	case FN_DIFF0:  	case FN_DIFF1:  	case FN_DIFF2:  	case FN_DIFF3:  	case FN_QLPC:  		int resn = 0;  		if (cmd != FN_ZERO) {  			resn = uvar_get (ENERGYSIZE' stream);  			// this is a hack as version 0 differed in definition of var_get  			if (version == 0)  				resn--;  		}  		switch (cmd) {  		case FN_ZERO:  			break;  		case FN_DIFF0:  		case FN_DIFF1:  		case FN_DIFF2:  		case FN_DIFF3:  			for (i = 0; i < blocksize; i++) {  				int nbin = resn + 1;  				if (nbitget == 0) {  					if (nbyteget < 4) {  						int bytes = stream.Read (getbuf' 0' BUFSIZE);  						getbufOffset = 0;  						nbyteget += bytes;  					}  					gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  					getbufOffset += 4;  					nbyteget -= 4;  					nbitget = 32;  				}  				while ((gbuffer & (1L << --nbitget)) == 0) {  					if (nbitget == 0) {  						if (nbyteget < 4) {  							int bytes = stream.Read (getbuf' 0' BUFSIZE);  							getbufOffset = 0;  							nbyteget += bytes;  						}  						gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  						getbufOffset += 4;  						nbyteget -= 4;  						nbitget = 32;  					}  				}  				while (nbin != 0) {  					if (nbitget >= nbin) {  						nbitget -= nbin;  						nbin = 0;  					} else {  						if (nbyteget < 4) {  							int bytes = stream.Read (getbuf' 0' BUFSIZE);  							getbufOffset = 0;  							nbyteget += bytes;  						}  						gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  						getbufOffset += 4;  						nbyteget -= 4;  						nbin -= nbitget;  						nbitget = 32;  					}  				}  			}  			break;  		case FN_QLPC:  			int nlpc = uvar_get (LPCQSIZE' stream);  			for (i = 0; i < nlpc; i++)  				var_get (LPCQUANT' stream);  			break;  		}  		if (chan == nchan - 1) {  			SampleNumber += blocksize;  		}  		chan = (chan + 1) % nchan;  		break;  	case FN_BLOCKSIZE:  		blocksize = (int)UINT_GET ((int)(Math.Log (blocksize) / M_LN2)' stream);  		break;  	case FN_BITSHIFT:  		uvar_get (BITSHIFTSIZE' stream);  		break;  	case FN_VERBATIM:  		int cklen = uvar_get (VERBATIM_CKSIZE_SIZE' stream);  		while (cklen-- != 0) {  			uvar_get (VERBATIM_BYTE_SIZE' stream);  		}  		break;  	default:  		return 0;  	}  	cmd = uvar_get (FNSIZE' stream);  }  
Magic Number,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,getSamples,The following statement contains a magic number: while (cmd != FN_QUIT) {  	switch (cmd) {  	case FN_ZERO:  	case FN_DIFF0:  	case FN_DIFF1:  	case FN_DIFF2:  	case FN_DIFF3:  	case FN_QLPC:  		int resn = 0;  		if (cmd != FN_ZERO) {  			resn = uvar_get (ENERGYSIZE' stream);  			// this is a hack as version 0 differed in definition of var_get  			if (version == 0)  				resn--;  		}  		switch (cmd) {  		case FN_ZERO:  			break;  		case FN_DIFF0:  		case FN_DIFF1:  		case FN_DIFF2:  		case FN_DIFF3:  			for (i = 0; i < blocksize; i++) {  				int nbin = resn + 1;  				if (nbitget == 0) {  					if (nbyteget < 4) {  						int bytes = stream.Read (getbuf' 0' BUFSIZE);  						getbufOffset = 0;  						nbyteget += bytes;  					}  					gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  					getbufOffset += 4;  					nbyteget -= 4;  					nbitget = 32;  				}  				while ((gbuffer & (1L << --nbitget)) == 0) {  					if (nbitget == 0) {  						if (nbyteget < 4) {  							int bytes = stream.Read (getbuf' 0' BUFSIZE);  							getbufOffset = 0;  							nbyteget += bytes;  						}  						gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  						getbufOffset += 4;  						nbyteget -= 4;  						nbitget = 32;  					}  				}  				while (nbin != 0) {  					if (nbitget >= nbin) {  						nbitget -= nbin;  						nbin = 0;  					} else {  						if (nbyteget < 4) {  							int bytes = stream.Read (getbuf' 0' BUFSIZE);  							getbufOffset = 0;  							nbyteget += bytes;  						}  						gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  						getbufOffset += 4;  						nbyteget -= 4;  						nbin -= nbitget;  						nbitget = 32;  					}  				}  			}  			break;  		case FN_QLPC:  			int nlpc = uvar_get (LPCQSIZE' stream);  			for (i = 0; i < nlpc; i++)  				var_get (LPCQUANT' stream);  			break;  		}  		if (chan == nchan - 1) {  			SampleNumber += blocksize;  		}  		chan = (chan + 1) % nchan;  		break;  	case FN_BLOCKSIZE:  		blocksize = (int)UINT_GET ((int)(Math.Log (blocksize) / M_LN2)' stream);  		break;  	case FN_BITSHIFT:  		uvar_get (BITSHIFTSIZE' stream);  		break;  	case FN_VERBATIM:  		int cklen = uvar_get (VERBATIM_CKSIZE_SIZE' stream);  		while (cklen-- != 0) {  			uvar_get (VERBATIM_BYTE_SIZE' stream);  		}  		break;  	default:  		return 0;  	}  	cmd = uvar_get (FNSIZE' stream);  }  
Magic Number,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,getSamples,The following statement contains a magic number: while (cmd != FN_QUIT) {  	switch (cmd) {  	case FN_ZERO:  	case FN_DIFF0:  	case FN_DIFF1:  	case FN_DIFF2:  	case FN_DIFF3:  	case FN_QLPC:  		int resn = 0;  		if (cmd != FN_ZERO) {  			resn = uvar_get (ENERGYSIZE' stream);  			// this is a hack as version 0 differed in definition of var_get  			if (version == 0)  				resn--;  		}  		switch (cmd) {  		case FN_ZERO:  			break;  		case FN_DIFF0:  		case FN_DIFF1:  		case FN_DIFF2:  		case FN_DIFF3:  			for (i = 0; i < blocksize; i++) {  				int nbin = resn + 1;  				if (nbitget == 0) {  					if (nbyteget < 4) {  						int bytes = stream.Read (getbuf' 0' BUFSIZE);  						getbufOffset = 0;  						nbyteget += bytes;  					}  					gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  					getbufOffset += 4;  					nbyteget -= 4;  					nbitget = 32;  				}  				while ((gbuffer & (1L << --nbitget)) == 0) {  					if (nbitget == 0) {  						if (nbyteget < 4) {  							int bytes = stream.Read (getbuf' 0' BUFSIZE);  							getbufOffset = 0;  							nbyteget += bytes;  						}  						gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  						getbufOffset += 4;  						nbyteget -= 4;  						nbitget = 32;  					}  				}  				while (nbin != 0) {  					if (nbitget >= nbin) {  						nbitget -= nbin;  						nbin = 0;  					} else {  						if (nbyteget < 4) {  							int bytes = stream.Read (getbuf' 0' BUFSIZE);  							getbufOffset = 0;  							nbyteget += bytes;  						}  						gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  						getbufOffset += 4;  						nbyteget -= 4;  						nbin -= nbitget;  						nbitget = 32;  					}  				}  			}  			break;  		case FN_QLPC:  			int nlpc = uvar_get (LPCQSIZE' stream);  			for (i = 0; i < nlpc; i++)  				var_get (LPCQUANT' stream);  			break;  		}  		if (chan == nchan - 1) {  			SampleNumber += blocksize;  		}  		chan = (chan + 1) % nchan;  		break;  	case FN_BLOCKSIZE:  		blocksize = (int)UINT_GET ((int)(Math.Log (blocksize) / M_LN2)' stream);  		break;  	case FN_BITSHIFT:  		uvar_get (BITSHIFTSIZE' stream);  		break;  	case FN_VERBATIM:  		int cklen = uvar_get (VERBATIM_CKSIZE_SIZE' stream);  		while (cklen-- != 0) {  			uvar_get (VERBATIM_BYTE_SIZE' stream);  		}  		break;  	default:  		return 0;  	}  	cmd = uvar_get (FNSIZE' stream);  }  
Magic Number,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,getSamples,The following statement contains a magic number: while (cmd != FN_QUIT) {  	switch (cmd) {  	case FN_ZERO:  	case FN_DIFF0:  	case FN_DIFF1:  	case FN_DIFF2:  	case FN_DIFF3:  	case FN_QLPC:  		int resn = 0;  		if (cmd != FN_ZERO) {  			resn = uvar_get (ENERGYSIZE' stream);  			// this is a hack as version 0 differed in definition of var_get  			if (version == 0)  				resn--;  		}  		switch (cmd) {  		case FN_ZERO:  			break;  		case FN_DIFF0:  		case FN_DIFF1:  		case FN_DIFF2:  		case FN_DIFF3:  			for (i = 0; i < blocksize; i++) {  				int nbin = resn + 1;  				if (nbitget == 0) {  					if (nbyteget < 4) {  						int bytes = stream.Read (getbuf' 0' BUFSIZE);  						getbufOffset = 0;  						nbyteget += bytes;  					}  					gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  					getbufOffset += 4;  					nbyteget -= 4;  					nbitget = 32;  				}  				while ((gbuffer & (1L << --nbitget)) == 0) {  					if (nbitget == 0) {  						if (nbyteget < 4) {  							int bytes = stream.Read (getbuf' 0' BUFSIZE);  							getbufOffset = 0;  							nbyteget += bytes;  						}  						gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  						getbufOffset += 4;  						nbyteget -= 4;  						nbitget = 32;  					}  				}  				while (nbin != 0) {  					if (nbitget >= nbin) {  						nbitget -= nbin;  						nbin = 0;  					} else {  						if (nbyteget < 4) {  							int bytes = stream.Read (getbuf' 0' BUFSIZE);  							getbufOffset = 0;  							nbyteget += bytes;  						}  						gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  						getbufOffset += 4;  						nbyteget -= 4;  						nbin -= nbitget;  						nbitget = 32;  					}  				}  			}  			break;  		case FN_QLPC:  			int nlpc = uvar_get (LPCQSIZE' stream);  			for (i = 0; i < nlpc; i++)  				var_get (LPCQUANT' stream);  			break;  		}  		if (chan == nchan - 1) {  			SampleNumber += blocksize;  		}  		chan = (chan + 1) % nchan;  		break;  	case FN_BLOCKSIZE:  		blocksize = (int)UINT_GET ((int)(Math.Log (blocksize) / M_LN2)' stream);  		break;  	case FN_BITSHIFT:  		uvar_get (BITSHIFTSIZE' stream);  		break;  	case FN_VERBATIM:  		int cklen = uvar_get (VERBATIM_CKSIZE_SIZE' stream);  		while (cklen-- != 0) {  			uvar_get (VERBATIM_BYTE_SIZE' stream);  		}  		break;  	default:  		return 0;  	}  	cmd = uvar_get (FNSIZE' stream);  }  
Magic Number,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,getSamples,The following statement contains a magic number: while (cmd != FN_QUIT) {  	switch (cmd) {  	case FN_ZERO:  	case FN_DIFF0:  	case FN_DIFF1:  	case FN_DIFF2:  	case FN_DIFF3:  	case FN_QLPC:  		int resn = 0;  		if (cmd != FN_ZERO) {  			resn = uvar_get (ENERGYSIZE' stream);  			// this is a hack as version 0 differed in definition of var_get  			if (version == 0)  				resn--;  		}  		switch (cmd) {  		case FN_ZERO:  			break;  		case FN_DIFF0:  		case FN_DIFF1:  		case FN_DIFF2:  		case FN_DIFF3:  			for (i = 0; i < blocksize; i++) {  				int nbin = resn + 1;  				if (nbitget == 0) {  					if (nbyteget < 4) {  						int bytes = stream.Read (getbuf' 0' BUFSIZE);  						getbufOffset = 0;  						nbyteget += bytes;  					}  					gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  					getbufOffset += 4;  					nbyteget -= 4;  					nbitget = 32;  				}  				while ((gbuffer & (1L << --nbitget)) == 0) {  					if (nbitget == 0) {  						if (nbyteget < 4) {  							int bytes = stream.Read (getbuf' 0' BUFSIZE);  							getbufOffset = 0;  							nbyteget += bytes;  						}  						gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  						getbufOffset += 4;  						nbyteget -= 4;  						nbitget = 32;  					}  				}  				while (nbin != 0) {  					if (nbitget >= nbin) {  						nbitget -= nbin;  						nbin = 0;  					} else {  						if (nbyteget < 4) {  							int bytes = stream.Read (getbuf' 0' BUFSIZE);  							getbufOffset = 0;  							nbyteget += bytes;  						}  						gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  						getbufOffset += 4;  						nbyteget -= 4;  						nbin -= nbitget;  						nbitget = 32;  					}  				}  			}  			break;  		case FN_QLPC:  			int nlpc = uvar_get (LPCQSIZE' stream);  			for (i = 0; i < nlpc; i++)  				var_get (LPCQUANT' stream);  			break;  		}  		if (chan == nchan - 1) {  			SampleNumber += blocksize;  		}  		chan = (chan + 1) % nchan;  		break;  	case FN_BLOCKSIZE:  		blocksize = (int)UINT_GET ((int)(Math.Log (blocksize) / M_LN2)' stream);  		break;  	case FN_BITSHIFT:  		uvar_get (BITSHIFTSIZE' stream);  		break;  	case FN_VERBATIM:  		int cklen = uvar_get (VERBATIM_CKSIZE_SIZE' stream);  		while (cklen-- != 0) {  			uvar_get (VERBATIM_BYTE_SIZE' stream);  		}  		break;  	default:  		return 0;  	}  	cmd = uvar_get (FNSIZE' stream);  }  
Magic Number,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,getSamples,The following statement contains a magic number: while (cmd != FN_QUIT) {  	switch (cmd) {  	case FN_ZERO:  	case FN_DIFF0:  	case FN_DIFF1:  	case FN_DIFF2:  	case FN_DIFF3:  	case FN_QLPC:  		int resn = 0;  		if (cmd != FN_ZERO) {  			resn = uvar_get (ENERGYSIZE' stream);  			// this is a hack as version 0 differed in definition of var_get  			if (version == 0)  				resn--;  		}  		switch (cmd) {  		case FN_ZERO:  			break;  		case FN_DIFF0:  		case FN_DIFF1:  		case FN_DIFF2:  		case FN_DIFF3:  			for (i = 0; i < blocksize; i++) {  				int nbin = resn + 1;  				if (nbitget == 0) {  					if (nbyteget < 4) {  						int bytes = stream.Read (getbuf' 0' BUFSIZE);  						getbufOffset = 0;  						nbyteget += bytes;  					}  					gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  					getbufOffset += 4;  					nbyteget -= 4;  					nbitget = 32;  				}  				while ((gbuffer & (1L << --nbitget)) == 0) {  					if (nbitget == 0) {  						if (nbyteget < 4) {  							int bytes = stream.Read (getbuf' 0' BUFSIZE);  							getbufOffset = 0;  							nbyteget += bytes;  						}  						gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  						getbufOffset += 4;  						nbyteget -= 4;  						nbitget = 32;  					}  				}  				while (nbin != 0) {  					if (nbitget >= nbin) {  						nbitget -= nbin;  						nbin = 0;  					} else {  						if (nbyteget < 4) {  							int bytes = stream.Read (getbuf' 0' BUFSIZE);  							getbufOffset = 0;  							nbyteget += bytes;  						}  						gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  						getbufOffset += 4;  						nbyteget -= 4;  						nbin -= nbitget;  						nbitget = 32;  					}  				}  			}  			break;  		case FN_QLPC:  			int nlpc = uvar_get (LPCQSIZE' stream);  			for (i = 0; i < nlpc; i++)  				var_get (LPCQUANT' stream);  			break;  		}  		if (chan == nchan - 1) {  			SampleNumber += blocksize;  		}  		chan = (chan + 1) % nchan;  		break;  	case FN_BLOCKSIZE:  		blocksize = (int)UINT_GET ((int)(Math.Log (blocksize) / M_LN2)' stream);  		break;  	case FN_BITSHIFT:  		uvar_get (BITSHIFTSIZE' stream);  		break;  	case FN_VERBATIM:  		int cklen = uvar_get (VERBATIM_CKSIZE_SIZE' stream);  		while (cklen-- != 0) {  			uvar_get (VERBATIM_BYTE_SIZE' stream);  		}  		break;  	default:  		return 0;  	}  	cmd = uvar_get (FNSIZE' stream);  }  
Magic Number,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,getSamples,The following statement contains a magic number: switch (cmd) {  case FN_ZERO:  case FN_DIFF0:  case FN_DIFF1:  case FN_DIFF2:  case FN_DIFF3:  case FN_QLPC:  	int resn = 0;  	if (cmd != FN_ZERO) {  		resn = uvar_get (ENERGYSIZE' stream);  		// this is a hack as version 0 differed in definition of var_get  		if (version == 0)  			resn--;  	}  	switch (cmd) {  	case FN_ZERO:  		break;  	case FN_DIFF0:  	case FN_DIFF1:  	case FN_DIFF2:  	case FN_DIFF3:  		for (i = 0; i < blocksize; i++) {  			int nbin = resn + 1;  			if (nbitget == 0) {  				if (nbyteget < 4) {  					int bytes = stream.Read (getbuf' 0' BUFSIZE);  					getbufOffset = 0;  					nbyteget += bytes;  				}  				gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  				getbufOffset += 4;  				nbyteget -= 4;  				nbitget = 32;  			}  			while ((gbuffer & (1L << --nbitget)) == 0) {  				if (nbitget == 0) {  					if (nbyteget < 4) {  						int bytes = stream.Read (getbuf' 0' BUFSIZE);  						getbufOffset = 0;  						nbyteget += bytes;  					}  					gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  					getbufOffset += 4;  					nbyteget -= 4;  					nbitget = 32;  				}  			}  			while (nbin != 0) {  				if (nbitget >= nbin) {  					nbitget -= nbin;  					nbin = 0;  				} else {  					if (nbyteget < 4) {  						int bytes = stream.Read (getbuf' 0' BUFSIZE);  						getbufOffset = 0;  						nbyteget += bytes;  					}  					gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  					getbufOffset += 4;  					nbyteget -= 4;  					nbin -= nbitget;  					nbitget = 32;  				}  			}  		}  		break;  	case FN_QLPC:  		int nlpc = uvar_get (LPCQSIZE' stream);  		for (i = 0; i < nlpc; i++)  			var_get (LPCQUANT' stream);  		break;  	}  	if (chan == nchan - 1) {  		SampleNumber += blocksize;  	}  	chan = (chan + 1) % nchan;  	break;  case FN_BLOCKSIZE:  	blocksize = (int)UINT_GET ((int)(Math.Log (blocksize) / M_LN2)' stream);  	break;  case FN_BITSHIFT:  	uvar_get (BITSHIFTSIZE' stream);  	break;  case FN_VERBATIM:  	int cklen = uvar_get (VERBATIM_CKSIZE_SIZE' stream);  	while (cklen-- != 0) {  		uvar_get (VERBATIM_BYTE_SIZE' stream);  	}  	break;  default:  	return 0;  }  
Magic Number,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,getSamples,The following statement contains a magic number: switch (cmd) {  case FN_ZERO:  case FN_DIFF0:  case FN_DIFF1:  case FN_DIFF2:  case FN_DIFF3:  case FN_QLPC:  	int resn = 0;  	if (cmd != FN_ZERO) {  		resn = uvar_get (ENERGYSIZE' stream);  		// this is a hack as version 0 differed in definition of var_get  		if (version == 0)  			resn--;  	}  	switch (cmd) {  	case FN_ZERO:  		break;  	case FN_DIFF0:  	case FN_DIFF1:  	case FN_DIFF2:  	case FN_DIFF3:  		for (i = 0; i < blocksize; i++) {  			int nbin = resn + 1;  			if (nbitget == 0) {  				if (nbyteget < 4) {  					int bytes = stream.Read (getbuf' 0' BUFSIZE);  					getbufOffset = 0;  					nbyteget += bytes;  				}  				gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  				getbufOffset += 4;  				nbyteget -= 4;  				nbitget = 32;  			}  			while ((gbuffer & (1L << --nbitget)) == 0) {  				if (nbitget == 0) {  					if (nbyteget < 4) {  						int bytes = stream.Read (getbuf' 0' BUFSIZE);  						getbufOffset = 0;  						nbyteget += bytes;  					}  					gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  					getbufOffset += 4;  					nbyteget -= 4;  					nbitget = 32;  				}  			}  			while (nbin != 0) {  				if (nbitget >= nbin) {  					nbitget -= nbin;  					nbin = 0;  				} else {  					if (nbyteget < 4) {  						int bytes = stream.Read (getbuf' 0' BUFSIZE);  						getbufOffset = 0;  						nbyteget += bytes;  					}  					gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  					getbufOffset += 4;  					nbyteget -= 4;  					nbin -= nbitget;  					nbitget = 32;  				}  			}  		}  		break;  	case FN_QLPC:  		int nlpc = uvar_get (LPCQSIZE' stream);  		for (i = 0; i < nlpc; i++)  			var_get (LPCQUANT' stream);  		break;  	}  	if (chan == nchan - 1) {  		SampleNumber += blocksize;  	}  	chan = (chan + 1) % nchan;  	break;  case FN_BLOCKSIZE:  	blocksize = (int)UINT_GET ((int)(Math.Log (blocksize) / M_LN2)' stream);  	break;  case FN_BITSHIFT:  	uvar_get (BITSHIFTSIZE' stream);  	break;  case FN_VERBATIM:  	int cklen = uvar_get (VERBATIM_CKSIZE_SIZE' stream);  	while (cklen-- != 0) {  		uvar_get (VERBATIM_BYTE_SIZE' stream);  	}  	break;  default:  	return 0;  }  
Magic Number,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,getSamples,The following statement contains a magic number: switch (cmd) {  case FN_ZERO:  case FN_DIFF0:  case FN_DIFF1:  case FN_DIFF2:  case FN_DIFF3:  case FN_QLPC:  	int resn = 0;  	if (cmd != FN_ZERO) {  		resn = uvar_get (ENERGYSIZE' stream);  		// this is a hack as version 0 differed in definition of var_get  		if (version == 0)  			resn--;  	}  	switch (cmd) {  	case FN_ZERO:  		break;  	case FN_DIFF0:  	case FN_DIFF1:  	case FN_DIFF2:  	case FN_DIFF3:  		for (i = 0; i < blocksize; i++) {  			int nbin = resn + 1;  			if (nbitget == 0) {  				if (nbyteget < 4) {  					int bytes = stream.Read (getbuf' 0' BUFSIZE);  					getbufOffset = 0;  					nbyteget += bytes;  				}  				gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  				getbufOffset += 4;  				nbyteget -= 4;  				nbitget = 32;  			}  			while ((gbuffer & (1L << --nbitget)) == 0) {  				if (nbitget == 0) {  					if (nbyteget < 4) {  						int bytes = stream.Read (getbuf' 0' BUFSIZE);  						getbufOffset = 0;  						nbyteget += bytes;  					}  					gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  					getbufOffset += 4;  					nbyteget -= 4;  					nbitget = 32;  				}  			}  			while (nbin != 0) {  				if (nbitget >= nbin) {  					nbitget -= nbin;  					nbin = 0;  				} else {  					if (nbyteget < 4) {  						int bytes = stream.Read (getbuf' 0' BUFSIZE);  						getbufOffset = 0;  						nbyteget += bytes;  					}  					gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  					getbufOffset += 4;  					nbyteget -= 4;  					nbin -= nbitget;  					nbitget = 32;  				}  			}  		}  		break;  	case FN_QLPC:  		int nlpc = uvar_get (LPCQSIZE' stream);  		for (i = 0; i < nlpc; i++)  			var_get (LPCQUANT' stream);  		break;  	}  	if (chan == nchan - 1) {  		SampleNumber += blocksize;  	}  	chan = (chan + 1) % nchan;  	break;  case FN_BLOCKSIZE:  	blocksize = (int)UINT_GET ((int)(Math.Log (blocksize) / M_LN2)' stream);  	break;  case FN_BITSHIFT:  	uvar_get (BITSHIFTSIZE' stream);  	break;  case FN_VERBATIM:  	int cklen = uvar_get (VERBATIM_CKSIZE_SIZE' stream);  	while (cklen-- != 0) {  		uvar_get (VERBATIM_BYTE_SIZE' stream);  	}  	break;  default:  	return 0;  }  
Magic Number,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,getSamples,The following statement contains a magic number: switch (cmd) {  case FN_ZERO:  case FN_DIFF0:  case FN_DIFF1:  case FN_DIFF2:  case FN_DIFF3:  case FN_QLPC:  	int resn = 0;  	if (cmd != FN_ZERO) {  		resn = uvar_get (ENERGYSIZE' stream);  		// this is a hack as version 0 differed in definition of var_get  		if (version == 0)  			resn--;  	}  	switch (cmd) {  	case FN_ZERO:  		break;  	case FN_DIFF0:  	case FN_DIFF1:  	case FN_DIFF2:  	case FN_DIFF3:  		for (i = 0; i < blocksize; i++) {  			int nbin = resn + 1;  			if (nbitget == 0) {  				if (nbyteget < 4) {  					int bytes = stream.Read (getbuf' 0' BUFSIZE);  					getbufOffset = 0;  					nbyteget += bytes;  				}  				gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  				getbufOffset += 4;  				nbyteget -= 4;  				nbitget = 32;  			}  			while ((gbuffer & (1L << --nbitget)) == 0) {  				if (nbitget == 0) {  					if (nbyteget < 4) {  						int bytes = stream.Read (getbuf' 0' BUFSIZE);  						getbufOffset = 0;  						nbyteget += bytes;  					}  					gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  					getbufOffset += 4;  					nbyteget -= 4;  					nbitget = 32;  				}  			}  			while (nbin != 0) {  				if (nbitget >= nbin) {  					nbitget -= nbin;  					nbin = 0;  				} else {  					if (nbyteget < 4) {  						int bytes = stream.Read (getbuf' 0' BUFSIZE);  						getbufOffset = 0;  						nbyteget += bytes;  					}  					gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  					getbufOffset += 4;  					nbyteget -= 4;  					nbin -= nbitget;  					nbitget = 32;  				}  			}  		}  		break;  	case FN_QLPC:  		int nlpc = uvar_get (LPCQSIZE' stream);  		for (i = 0; i < nlpc; i++)  			var_get (LPCQUANT' stream);  		break;  	}  	if (chan == nchan - 1) {  		SampleNumber += blocksize;  	}  	chan = (chan + 1) % nchan;  	break;  case FN_BLOCKSIZE:  	blocksize = (int)UINT_GET ((int)(Math.Log (blocksize) / M_LN2)' stream);  	break;  case FN_BITSHIFT:  	uvar_get (BITSHIFTSIZE' stream);  	break;  case FN_VERBATIM:  	int cklen = uvar_get (VERBATIM_CKSIZE_SIZE' stream);  	while (cklen-- != 0) {  		uvar_get (VERBATIM_BYTE_SIZE' stream);  	}  	break;  default:  	return 0;  }  
Magic Number,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,getSamples,The following statement contains a magic number: switch (cmd) {  case FN_ZERO:  case FN_DIFF0:  case FN_DIFF1:  case FN_DIFF2:  case FN_DIFF3:  case FN_QLPC:  	int resn = 0;  	if (cmd != FN_ZERO) {  		resn = uvar_get (ENERGYSIZE' stream);  		// this is a hack as version 0 differed in definition of var_get  		if (version == 0)  			resn--;  	}  	switch (cmd) {  	case FN_ZERO:  		break;  	case FN_DIFF0:  	case FN_DIFF1:  	case FN_DIFF2:  	case FN_DIFF3:  		for (i = 0; i < blocksize; i++) {  			int nbin = resn + 1;  			if (nbitget == 0) {  				if (nbyteget < 4) {  					int bytes = stream.Read (getbuf' 0' BUFSIZE);  					getbufOffset = 0;  					nbyteget += bytes;  				}  				gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  				getbufOffset += 4;  				nbyteget -= 4;  				nbitget = 32;  			}  			while ((gbuffer & (1L << --nbitget)) == 0) {  				if (nbitget == 0) {  					if (nbyteget < 4) {  						int bytes = stream.Read (getbuf' 0' BUFSIZE);  						getbufOffset = 0;  						nbyteget += bytes;  					}  					gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  					getbufOffset += 4;  					nbyteget -= 4;  					nbitget = 32;  				}  			}  			while (nbin != 0) {  				if (nbitget >= nbin) {  					nbitget -= nbin;  					nbin = 0;  				} else {  					if (nbyteget < 4) {  						int bytes = stream.Read (getbuf' 0' BUFSIZE);  						getbufOffset = 0;  						nbyteget += bytes;  					}  					gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  					getbufOffset += 4;  					nbyteget -= 4;  					nbin -= nbitget;  					nbitget = 32;  				}  			}  		}  		break;  	case FN_QLPC:  		int nlpc = uvar_get (LPCQSIZE' stream);  		for (i = 0; i < nlpc; i++)  			var_get (LPCQUANT' stream);  		break;  	}  	if (chan == nchan - 1) {  		SampleNumber += blocksize;  	}  	chan = (chan + 1) % nchan;  	break;  case FN_BLOCKSIZE:  	blocksize = (int)UINT_GET ((int)(Math.Log (blocksize) / M_LN2)' stream);  	break;  case FN_BITSHIFT:  	uvar_get (BITSHIFTSIZE' stream);  	break;  case FN_VERBATIM:  	int cklen = uvar_get (VERBATIM_CKSIZE_SIZE' stream);  	while (cklen-- != 0) {  		uvar_get (VERBATIM_BYTE_SIZE' stream);  	}  	break;  default:  	return 0;  }  
Magic Number,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,getSamples,The following statement contains a magic number: switch (cmd) {  case FN_ZERO:  case FN_DIFF0:  case FN_DIFF1:  case FN_DIFF2:  case FN_DIFF3:  case FN_QLPC:  	int resn = 0;  	if (cmd != FN_ZERO) {  		resn = uvar_get (ENERGYSIZE' stream);  		// this is a hack as version 0 differed in definition of var_get  		if (version == 0)  			resn--;  	}  	switch (cmd) {  	case FN_ZERO:  		break;  	case FN_DIFF0:  	case FN_DIFF1:  	case FN_DIFF2:  	case FN_DIFF3:  		for (i = 0; i < blocksize; i++) {  			int nbin = resn + 1;  			if (nbitget == 0) {  				if (nbyteget < 4) {  					int bytes = stream.Read (getbuf' 0' BUFSIZE);  					getbufOffset = 0;  					nbyteget += bytes;  				}  				gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  				getbufOffset += 4;  				nbyteget -= 4;  				nbitget = 32;  			}  			while ((gbuffer & (1L << --nbitget)) == 0) {  				if (nbitget == 0) {  					if (nbyteget < 4) {  						int bytes = stream.Read (getbuf' 0' BUFSIZE);  						getbufOffset = 0;  						nbyteget += bytes;  					}  					gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  					getbufOffset += 4;  					nbyteget -= 4;  					nbitget = 32;  				}  			}  			while (nbin != 0) {  				if (nbitget >= nbin) {  					nbitget -= nbin;  					nbin = 0;  				} else {  					if (nbyteget < 4) {  						int bytes = stream.Read (getbuf' 0' BUFSIZE);  						getbufOffset = 0;  						nbyteget += bytes;  					}  					gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  					getbufOffset += 4;  					nbyteget -= 4;  					nbin -= nbitget;  					nbitget = 32;  				}  			}  		}  		break;  	case FN_QLPC:  		int nlpc = uvar_get (LPCQSIZE' stream);  		for (i = 0; i < nlpc; i++)  			var_get (LPCQUANT' stream);  		break;  	}  	if (chan == nchan - 1) {  		SampleNumber += blocksize;  	}  	chan = (chan + 1) % nchan;  	break;  case FN_BLOCKSIZE:  	blocksize = (int)UINT_GET ((int)(Math.Log (blocksize) / M_LN2)' stream);  	break;  case FN_BITSHIFT:  	uvar_get (BITSHIFTSIZE' stream);  	break;  case FN_VERBATIM:  	int cklen = uvar_get (VERBATIM_CKSIZE_SIZE' stream);  	while (cklen-- != 0) {  		uvar_get (VERBATIM_BYTE_SIZE' stream);  	}  	break;  default:  	return 0;  }  
Magic Number,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,getSamples,The following statement contains a magic number: switch (cmd) {  case FN_ZERO:  case FN_DIFF0:  case FN_DIFF1:  case FN_DIFF2:  case FN_DIFF3:  case FN_QLPC:  	int resn = 0;  	if (cmd != FN_ZERO) {  		resn = uvar_get (ENERGYSIZE' stream);  		// this is a hack as version 0 differed in definition of var_get  		if (version == 0)  			resn--;  	}  	switch (cmd) {  	case FN_ZERO:  		break;  	case FN_DIFF0:  	case FN_DIFF1:  	case FN_DIFF2:  	case FN_DIFF3:  		for (i = 0; i < blocksize; i++) {  			int nbin = resn + 1;  			if (nbitget == 0) {  				if (nbyteget < 4) {  					int bytes = stream.Read (getbuf' 0' BUFSIZE);  					getbufOffset = 0;  					nbyteget += bytes;  				}  				gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  				getbufOffset += 4;  				nbyteget -= 4;  				nbitget = 32;  			}  			while ((gbuffer & (1L << --nbitget)) == 0) {  				if (nbitget == 0) {  					if (nbyteget < 4) {  						int bytes = stream.Read (getbuf' 0' BUFSIZE);  						getbufOffset = 0;  						nbyteget += bytes;  					}  					gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  					getbufOffset += 4;  					nbyteget -= 4;  					nbitget = 32;  				}  			}  			while (nbin != 0) {  				if (nbitget >= nbin) {  					nbitget -= nbin;  					nbin = 0;  				} else {  					if (nbyteget < 4) {  						int bytes = stream.Read (getbuf' 0' BUFSIZE);  						getbufOffset = 0;  						nbyteget += bytes;  					}  					gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  					getbufOffset += 4;  					nbyteget -= 4;  					nbin -= nbitget;  					nbitget = 32;  				}  			}  		}  		break;  	case FN_QLPC:  		int nlpc = uvar_get (LPCQSIZE' stream);  		for (i = 0; i < nlpc; i++)  			var_get (LPCQUANT' stream);  		break;  	}  	if (chan == nchan - 1) {  		SampleNumber += blocksize;  	}  	chan = (chan + 1) % nchan;  	break;  case FN_BLOCKSIZE:  	blocksize = (int)UINT_GET ((int)(Math.Log (blocksize) / M_LN2)' stream);  	break;  case FN_BITSHIFT:  	uvar_get (BITSHIFTSIZE' stream);  	break;  case FN_VERBATIM:  	int cklen = uvar_get (VERBATIM_CKSIZE_SIZE' stream);  	while (cklen-- != 0) {  		uvar_get (VERBATIM_BYTE_SIZE' stream);  	}  	break;  default:  	return 0;  }  
Magic Number,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,getSamples,The following statement contains a magic number: switch (cmd) {  case FN_ZERO:  case FN_DIFF0:  case FN_DIFF1:  case FN_DIFF2:  case FN_DIFF3:  case FN_QLPC:  	int resn = 0;  	if (cmd != FN_ZERO) {  		resn = uvar_get (ENERGYSIZE' stream);  		// this is a hack as version 0 differed in definition of var_get  		if (version == 0)  			resn--;  	}  	switch (cmd) {  	case FN_ZERO:  		break;  	case FN_DIFF0:  	case FN_DIFF1:  	case FN_DIFF2:  	case FN_DIFF3:  		for (i = 0; i < blocksize; i++) {  			int nbin = resn + 1;  			if (nbitget == 0) {  				if (nbyteget < 4) {  					int bytes = stream.Read (getbuf' 0' BUFSIZE);  					getbufOffset = 0;  					nbyteget += bytes;  				}  				gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  				getbufOffset += 4;  				nbyteget -= 4;  				nbitget = 32;  			}  			while ((gbuffer & (1L << --nbitget)) == 0) {  				if (nbitget == 0) {  					if (nbyteget < 4) {  						int bytes = stream.Read (getbuf' 0' BUFSIZE);  						getbufOffset = 0;  						nbyteget += bytes;  					}  					gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  					getbufOffset += 4;  					nbyteget -= 4;  					nbitget = 32;  				}  			}  			while (nbin != 0) {  				if (nbitget >= nbin) {  					nbitget -= nbin;  					nbin = 0;  				} else {  					if (nbyteget < 4) {  						int bytes = stream.Read (getbuf' 0' BUFSIZE);  						getbufOffset = 0;  						nbyteget += bytes;  					}  					gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  					getbufOffset += 4;  					nbyteget -= 4;  					nbin -= nbitget;  					nbitget = 32;  				}  			}  		}  		break;  	case FN_QLPC:  		int nlpc = uvar_get (LPCQSIZE' stream);  		for (i = 0; i < nlpc; i++)  			var_get (LPCQUANT' stream);  		break;  	}  	if (chan == nchan - 1) {  		SampleNumber += blocksize;  	}  	chan = (chan + 1) % nchan;  	break;  case FN_BLOCKSIZE:  	blocksize = (int)UINT_GET ((int)(Math.Log (blocksize) / M_LN2)' stream);  	break;  case FN_BITSHIFT:  	uvar_get (BITSHIFTSIZE' stream);  	break;  case FN_VERBATIM:  	int cklen = uvar_get (VERBATIM_CKSIZE_SIZE' stream);  	while (cklen-- != 0) {  		uvar_get (VERBATIM_BYTE_SIZE' stream);  	}  	break;  default:  	return 0;  }  
Magic Number,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,getSamples,The following statement contains a magic number: switch (cmd) {  case FN_ZERO:  case FN_DIFF0:  case FN_DIFF1:  case FN_DIFF2:  case FN_DIFF3:  case FN_QLPC:  	int resn = 0;  	if (cmd != FN_ZERO) {  		resn = uvar_get (ENERGYSIZE' stream);  		// this is a hack as version 0 differed in definition of var_get  		if (version == 0)  			resn--;  	}  	switch (cmd) {  	case FN_ZERO:  		break;  	case FN_DIFF0:  	case FN_DIFF1:  	case FN_DIFF2:  	case FN_DIFF3:  		for (i = 0; i < blocksize; i++) {  			int nbin = resn + 1;  			if (nbitget == 0) {  				if (nbyteget < 4) {  					int bytes = stream.Read (getbuf' 0' BUFSIZE);  					getbufOffset = 0;  					nbyteget += bytes;  				}  				gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  				getbufOffset += 4;  				nbyteget -= 4;  				nbitget = 32;  			}  			while ((gbuffer & (1L << --nbitget)) == 0) {  				if (nbitget == 0) {  					if (nbyteget < 4) {  						int bytes = stream.Read (getbuf' 0' BUFSIZE);  						getbufOffset = 0;  						nbyteget += bytes;  					}  					gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  					getbufOffset += 4;  					nbyteget -= 4;  					nbitget = 32;  				}  			}  			while (nbin != 0) {  				if (nbitget >= nbin) {  					nbitget -= nbin;  					nbin = 0;  				} else {  					if (nbyteget < 4) {  						int bytes = stream.Read (getbuf' 0' BUFSIZE);  						getbufOffset = 0;  						nbyteget += bytes;  					}  					gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  					getbufOffset += 4;  					nbyteget -= 4;  					nbin -= nbitget;  					nbitget = 32;  				}  			}  		}  		break;  	case FN_QLPC:  		int nlpc = uvar_get (LPCQSIZE' stream);  		for (i = 0; i < nlpc; i++)  			var_get (LPCQUANT' stream);  		break;  	}  	if (chan == nchan - 1) {  		SampleNumber += blocksize;  	}  	chan = (chan + 1) % nchan;  	break;  case FN_BLOCKSIZE:  	blocksize = (int)UINT_GET ((int)(Math.Log (blocksize) / M_LN2)' stream);  	break;  case FN_BITSHIFT:  	uvar_get (BITSHIFTSIZE' stream);  	break;  case FN_VERBATIM:  	int cklen = uvar_get (VERBATIM_CKSIZE_SIZE' stream);  	while (cklen-- != 0) {  		uvar_get (VERBATIM_BYTE_SIZE' stream);  	}  	break;  default:  	return 0;  }  
Magic Number,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,getSamples,The following statement contains a magic number: switch (cmd) {  case FN_ZERO:  case FN_DIFF0:  case FN_DIFF1:  case FN_DIFF2:  case FN_DIFF3:  case FN_QLPC:  	int resn = 0;  	if (cmd != FN_ZERO) {  		resn = uvar_get (ENERGYSIZE' stream);  		// this is a hack as version 0 differed in definition of var_get  		if (version == 0)  			resn--;  	}  	switch (cmd) {  	case FN_ZERO:  		break;  	case FN_DIFF0:  	case FN_DIFF1:  	case FN_DIFF2:  	case FN_DIFF3:  		for (i = 0; i < blocksize; i++) {  			int nbin = resn + 1;  			if (nbitget == 0) {  				if (nbyteget < 4) {  					int bytes = stream.Read (getbuf' 0' BUFSIZE);  					getbufOffset = 0;  					nbyteget += bytes;  				}  				gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  				getbufOffset += 4;  				nbyteget -= 4;  				nbitget = 32;  			}  			while ((gbuffer & (1L << --nbitget)) == 0) {  				if (nbitget == 0) {  					if (nbyteget < 4) {  						int bytes = stream.Read (getbuf' 0' BUFSIZE);  						getbufOffset = 0;  						nbyteget += bytes;  					}  					gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  					getbufOffset += 4;  					nbyteget -= 4;  					nbitget = 32;  				}  			}  			while (nbin != 0) {  				if (nbitget >= nbin) {  					nbitget -= nbin;  					nbin = 0;  				} else {  					if (nbyteget < 4) {  						int bytes = stream.Read (getbuf' 0' BUFSIZE);  						getbufOffset = 0;  						nbyteget += bytes;  					}  					gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  					getbufOffset += 4;  					nbyteget -= 4;  					nbin -= nbitget;  					nbitget = 32;  				}  			}  		}  		break;  	case FN_QLPC:  		int nlpc = uvar_get (LPCQSIZE' stream);  		for (i = 0; i < nlpc; i++)  			var_get (LPCQUANT' stream);  		break;  	}  	if (chan == nchan - 1) {  		SampleNumber += blocksize;  	}  	chan = (chan + 1) % nchan;  	break;  case FN_BLOCKSIZE:  	blocksize = (int)UINT_GET ((int)(Math.Log (blocksize) / M_LN2)' stream);  	break;  case FN_BITSHIFT:  	uvar_get (BITSHIFTSIZE' stream);  	break;  case FN_VERBATIM:  	int cklen = uvar_get (VERBATIM_CKSIZE_SIZE' stream);  	while (cklen-- != 0) {  		uvar_get (VERBATIM_BYTE_SIZE' stream);  	}  	break;  default:  	return 0;  }  
Magic Number,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,getSamples,The following statement contains a magic number: switch (cmd) {  case FN_ZERO:  case FN_DIFF0:  case FN_DIFF1:  case FN_DIFF2:  case FN_DIFF3:  case FN_QLPC:  	int resn = 0;  	if (cmd != FN_ZERO) {  		resn = uvar_get (ENERGYSIZE' stream);  		// this is a hack as version 0 differed in definition of var_get  		if (version == 0)  			resn--;  	}  	switch (cmd) {  	case FN_ZERO:  		break;  	case FN_DIFF0:  	case FN_DIFF1:  	case FN_DIFF2:  	case FN_DIFF3:  		for (i = 0; i < blocksize; i++) {  			int nbin = resn + 1;  			if (nbitget == 0) {  				if (nbyteget < 4) {  					int bytes = stream.Read (getbuf' 0' BUFSIZE);  					getbufOffset = 0;  					nbyteget += bytes;  				}  				gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  				getbufOffset += 4;  				nbyteget -= 4;  				nbitget = 32;  			}  			while ((gbuffer & (1L << --nbitget)) == 0) {  				if (nbitget == 0) {  					if (nbyteget < 4) {  						int bytes = stream.Read (getbuf' 0' BUFSIZE);  						getbufOffset = 0;  						nbyteget += bytes;  					}  					gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  					getbufOffset += 4;  					nbyteget -= 4;  					nbitget = 32;  				}  			}  			while (nbin != 0) {  				if (nbitget >= nbin) {  					nbitget -= nbin;  					nbin = 0;  				} else {  					if (nbyteget < 4) {  						int bytes = stream.Read (getbuf' 0' BUFSIZE);  						getbufOffset = 0;  						nbyteget += bytes;  					}  					gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  					getbufOffset += 4;  					nbyteget -= 4;  					nbin -= nbitget;  					nbitget = 32;  				}  			}  		}  		break;  	case FN_QLPC:  		int nlpc = uvar_get (LPCQSIZE' stream);  		for (i = 0; i < nlpc; i++)  			var_get (LPCQUANT' stream);  		break;  	}  	if (chan == nchan - 1) {  		SampleNumber += blocksize;  	}  	chan = (chan + 1) % nchan;  	break;  case FN_BLOCKSIZE:  	blocksize = (int)UINT_GET ((int)(Math.Log (blocksize) / M_LN2)' stream);  	break;  case FN_BITSHIFT:  	uvar_get (BITSHIFTSIZE' stream);  	break;  case FN_VERBATIM:  	int cklen = uvar_get (VERBATIM_CKSIZE_SIZE' stream);  	while (cklen-- != 0) {  		uvar_get (VERBATIM_BYTE_SIZE' stream);  	}  	break;  default:  	return 0;  }  
Magic Number,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,getSamples,The following statement contains a magic number: switch (cmd) {  case FN_ZERO:  case FN_DIFF0:  case FN_DIFF1:  case FN_DIFF2:  case FN_DIFF3:  case FN_QLPC:  	int resn = 0;  	if (cmd != FN_ZERO) {  		resn = uvar_get (ENERGYSIZE' stream);  		// this is a hack as version 0 differed in definition of var_get  		if (version == 0)  			resn--;  	}  	switch (cmd) {  	case FN_ZERO:  		break;  	case FN_DIFF0:  	case FN_DIFF1:  	case FN_DIFF2:  	case FN_DIFF3:  		for (i = 0; i < blocksize; i++) {  			int nbin = resn + 1;  			if (nbitget == 0) {  				if (nbyteget < 4) {  					int bytes = stream.Read (getbuf' 0' BUFSIZE);  					getbufOffset = 0;  					nbyteget += bytes;  				}  				gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  				getbufOffset += 4;  				nbyteget -= 4;  				nbitget = 32;  			}  			while ((gbuffer & (1L << --nbitget)) == 0) {  				if (nbitget == 0) {  					if (nbyteget < 4) {  						int bytes = stream.Read (getbuf' 0' BUFSIZE);  						getbufOffset = 0;  						nbyteget += bytes;  					}  					gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  					getbufOffset += 4;  					nbyteget -= 4;  					nbitget = 32;  				}  			}  			while (nbin != 0) {  				if (nbitget >= nbin) {  					nbitget -= nbin;  					nbin = 0;  				} else {  					if (nbyteget < 4) {  						int bytes = stream.Read (getbuf' 0' BUFSIZE);  						getbufOffset = 0;  						nbyteget += bytes;  					}  					gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  					getbufOffset += 4;  					nbyteget -= 4;  					nbin -= nbitget;  					nbitget = 32;  				}  			}  		}  		break;  	case FN_QLPC:  		int nlpc = uvar_get (LPCQSIZE' stream);  		for (i = 0; i < nlpc; i++)  			var_get (LPCQUANT' stream);  		break;  	}  	if (chan == nchan - 1) {  		SampleNumber += blocksize;  	}  	chan = (chan + 1) % nchan;  	break;  case FN_BLOCKSIZE:  	blocksize = (int)UINT_GET ((int)(Math.Log (blocksize) / M_LN2)' stream);  	break;  case FN_BITSHIFT:  	uvar_get (BITSHIFTSIZE' stream);  	break;  case FN_VERBATIM:  	int cklen = uvar_get (VERBATIM_CKSIZE_SIZE' stream);  	while (cklen-- != 0) {  		uvar_get (VERBATIM_BYTE_SIZE' stream);  	}  	break;  default:  	return 0;  }  
Magic Number,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,getSamples,The following statement contains a magic number: switch (cmd) {  case FN_ZERO:  case FN_DIFF0:  case FN_DIFF1:  case FN_DIFF2:  case FN_DIFF3:  case FN_QLPC:  	int resn = 0;  	if (cmd != FN_ZERO) {  		resn = uvar_get (ENERGYSIZE' stream);  		// this is a hack as version 0 differed in definition of var_get  		if (version == 0)  			resn--;  	}  	switch (cmd) {  	case FN_ZERO:  		break;  	case FN_DIFF0:  	case FN_DIFF1:  	case FN_DIFF2:  	case FN_DIFF3:  		for (i = 0; i < blocksize; i++) {  			int nbin = resn + 1;  			if (nbitget == 0) {  				if (nbyteget < 4) {  					int bytes = stream.Read (getbuf' 0' BUFSIZE);  					getbufOffset = 0;  					nbyteget += bytes;  				}  				gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  				getbufOffset += 4;  				nbyteget -= 4;  				nbitget = 32;  			}  			while ((gbuffer & (1L << --nbitget)) == 0) {  				if (nbitget == 0) {  					if (nbyteget < 4) {  						int bytes = stream.Read (getbuf' 0' BUFSIZE);  						getbufOffset = 0;  						nbyteget += bytes;  					}  					gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  					getbufOffset += 4;  					nbyteget -= 4;  					nbitget = 32;  				}  			}  			while (nbin != 0) {  				if (nbitget >= nbin) {  					nbitget -= nbin;  					nbin = 0;  				} else {  					if (nbyteget < 4) {  						int bytes = stream.Read (getbuf' 0' BUFSIZE);  						getbufOffset = 0;  						nbyteget += bytes;  					}  					gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  					getbufOffset += 4;  					nbyteget -= 4;  					nbin -= nbitget;  					nbitget = 32;  				}  			}  		}  		break;  	case FN_QLPC:  		int nlpc = uvar_get (LPCQSIZE' stream);  		for (i = 0; i < nlpc; i++)  			var_get (LPCQUANT' stream);  		break;  	}  	if (chan == nchan - 1) {  		SampleNumber += blocksize;  	}  	chan = (chan + 1) % nchan;  	break;  case FN_BLOCKSIZE:  	blocksize = (int)UINT_GET ((int)(Math.Log (blocksize) / M_LN2)' stream);  	break;  case FN_BITSHIFT:  	uvar_get (BITSHIFTSIZE' stream);  	break;  case FN_VERBATIM:  	int cklen = uvar_get (VERBATIM_CKSIZE_SIZE' stream);  	while (cklen-- != 0) {  		uvar_get (VERBATIM_BYTE_SIZE' stream);  	}  	break;  default:  	return 0;  }  
Magic Number,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,getSamples,The following statement contains a magic number: switch (cmd) {  case FN_ZERO:  case FN_DIFF0:  case FN_DIFF1:  case FN_DIFF2:  case FN_DIFF3:  case FN_QLPC:  	int resn = 0;  	if (cmd != FN_ZERO) {  		resn = uvar_get (ENERGYSIZE' stream);  		// this is a hack as version 0 differed in definition of var_get  		if (version == 0)  			resn--;  	}  	switch (cmd) {  	case FN_ZERO:  		break;  	case FN_DIFF0:  	case FN_DIFF1:  	case FN_DIFF2:  	case FN_DIFF3:  		for (i = 0; i < blocksize; i++) {  			int nbin = resn + 1;  			if (nbitget == 0) {  				if (nbyteget < 4) {  					int bytes = stream.Read (getbuf' 0' BUFSIZE);  					getbufOffset = 0;  					nbyteget += bytes;  				}  				gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  				getbufOffset += 4;  				nbyteget -= 4;  				nbitget = 32;  			}  			while ((gbuffer & (1L << --nbitget)) == 0) {  				if (nbitget == 0) {  					if (nbyteget < 4) {  						int bytes = stream.Read (getbuf' 0' BUFSIZE);  						getbufOffset = 0;  						nbyteget += bytes;  					}  					gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  					getbufOffset += 4;  					nbyteget -= 4;  					nbitget = 32;  				}  			}  			while (nbin != 0) {  				if (nbitget >= nbin) {  					nbitget -= nbin;  					nbin = 0;  				} else {  					if (nbyteget < 4) {  						int bytes = stream.Read (getbuf' 0' BUFSIZE);  						getbufOffset = 0;  						nbyteget += bytes;  					}  					gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  					getbufOffset += 4;  					nbyteget -= 4;  					nbin -= nbitget;  					nbitget = 32;  				}  			}  		}  		break;  	case FN_QLPC:  		int nlpc = uvar_get (LPCQSIZE' stream);  		for (i = 0; i < nlpc; i++)  			var_get (LPCQUANT' stream);  		break;  	}  	if (chan == nchan - 1) {  		SampleNumber += blocksize;  	}  	chan = (chan + 1) % nchan;  	break;  case FN_BLOCKSIZE:  	blocksize = (int)UINT_GET ((int)(Math.Log (blocksize) / M_LN2)' stream);  	break;  case FN_BITSHIFT:  	uvar_get (BITSHIFTSIZE' stream);  	break;  case FN_VERBATIM:  	int cklen = uvar_get (VERBATIM_CKSIZE_SIZE' stream);  	while (cklen-- != 0) {  		uvar_get (VERBATIM_BYTE_SIZE' stream);  	}  	break;  default:  	return 0;  }  
Magic Number,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,getSamples,The following statement contains a magic number: switch (cmd) {  case FN_ZERO:  case FN_DIFF0:  case FN_DIFF1:  case FN_DIFF2:  case FN_DIFF3:  case FN_QLPC:  	int resn = 0;  	if (cmd != FN_ZERO) {  		resn = uvar_get (ENERGYSIZE' stream);  		// this is a hack as version 0 differed in definition of var_get  		if (version == 0)  			resn--;  	}  	switch (cmd) {  	case FN_ZERO:  		break;  	case FN_DIFF0:  	case FN_DIFF1:  	case FN_DIFF2:  	case FN_DIFF3:  		for (i = 0; i < blocksize; i++) {  			int nbin = resn + 1;  			if (nbitget == 0) {  				if (nbyteget < 4) {  					int bytes = stream.Read (getbuf' 0' BUFSIZE);  					getbufOffset = 0;  					nbyteget += bytes;  				}  				gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  				getbufOffset += 4;  				nbyteget -= 4;  				nbitget = 32;  			}  			while ((gbuffer & (1L << --nbitget)) == 0) {  				if (nbitget == 0) {  					if (nbyteget < 4) {  						int bytes = stream.Read (getbuf' 0' BUFSIZE);  						getbufOffset = 0;  						nbyteget += bytes;  					}  					gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  					getbufOffset += 4;  					nbyteget -= 4;  					nbitget = 32;  				}  			}  			while (nbin != 0) {  				if (nbitget >= nbin) {  					nbitget -= nbin;  					nbin = 0;  				} else {  					if (nbyteget < 4) {  						int bytes = stream.Read (getbuf' 0' BUFSIZE);  						getbufOffset = 0;  						nbyteget += bytes;  					}  					gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  					getbufOffset += 4;  					nbyteget -= 4;  					nbin -= nbitget;  					nbitget = 32;  				}  			}  		}  		break;  	case FN_QLPC:  		int nlpc = uvar_get (LPCQSIZE' stream);  		for (i = 0; i < nlpc; i++)  			var_get (LPCQUANT' stream);  		break;  	}  	if (chan == nchan - 1) {  		SampleNumber += blocksize;  	}  	chan = (chan + 1) % nchan;  	break;  case FN_BLOCKSIZE:  	blocksize = (int)UINT_GET ((int)(Math.Log (blocksize) / M_LN2)' stream);  	break;  case FN_BITSHIFT:  	uvar_get (BITSHIFTSIZE' stream);  	break;  case FN_VERBATIM:  	int cklen = uvar_get (VERBATIM_CKSIZE_SIZE' stream);  	while (cklen-- != 0) {  		uvar_get (VERBATIM_BYTE_SIZE' stream);  	}  	break;  default:  	return 0;  }  
Magic Number,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,getSamples,The following statement contains a magic number: switch (cmd) {  case FN_ZERO:  case FN_DIFF0:  case FN_DIFF1:  case FN_DIFF2:  case FN_DIFF3:  case FN_QLPC:  	int resn = 0;  	if (cmd != FN_ZERO) {  		resn = uvar_get (ENERGYSIZE' stream);  		// this is a hack as version 0 differed in definition of var_get  		if (version == 0)  			resn--;  	}  	switch (cmd) {  	case FN_ZERO:  		break;  	case FN_DIFF0:  	case FN_DIFF1:  	case FN_DIFF2:  	case FN_DIFF3:  		for (i = 0; i < blocksize; i++) {  			int nbin = resn + 1;  			if (nbitget == 0) {  				if (nbyteget < 4) {  					int bytes = stream.Read (getbuf' 0' BUFSIZE);  					getbufOffset = 0;  					nbyteget += bytes;  				}  				gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  				getbufOffset += 4;  				nbyteget -= 4;  				nbitget = 32;  			}  			while ((gbuffer & (1L << --nbitget)) == 0) {  				if (nbitget == 0) {  					if (nbyteget < 4) {  						int bytes = stream.Read (getbuf' 0' BUFSIZE);  						getbufOffset = 0;  						nbyteget += bytes;  					}  					gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  					getbufOffset += 4;  					nbyteget -= 4;  					nbitget = 32;  				}  			}  			while (nbin != 0) {  				if (nbitget >= nbin) {  					nbitget -= nbin;  					nbin = 0;  				} else {  					if (nbyteget < 4) {  						int bytes = stream.Read (getbuf' 0' BUFSIZE);  						getbufOffset = 0;  						nbyteget += bytes;  					}  					gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  					getbufOffset += 4;  					nbyteget -= 4;  					nbin -= nbitget;  					nbitget = 32;  				}  			}  		}  		break;  	case FN_QLPC:  		int nlpc = uvar_get (LPCQSIZE' stream);  		for (i = 0; i < nlpc; i++)  			var_get (LPCQUANT' stream);  		break;  	}  	if (chan == nchan - 1) {  		SampleNumber += blocksize;  	}  	chan = (chan + 1) % nchan;  	break;  case FN_BLOCKSIZE:  	blocksize = (int)UINT_GET ((int)(Math.Log (blocksize) / M_LN2)' stream);  	break;  case FN_BITSHIFT:  	uvar_get (BITSHIFTSIZE' stream);  	break;  case FN_VERBATIM:  	int cklen = uvar_get (VERBATIM_CKSIZE_SIZE' stream);  	while (cklen-- != 0) {  		uvar_get (VERBATIM_BYTE_SIZE' stream);  	}  	break;  default:  	return 0;  }  
Magic Number,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,getSamples,The following statement contains a magic number: switch (cmd) {  case FN_ZERO:  case FN_DIFF0:  case FN_DIFF1:  case FN_DIFF2:  case FN_DIFF3:  case FN_QLPC:  	int resn = 0;  	if (cmd != FN_ZERO) {  		resn = uvar_get (ENERGYSIZE' stream);  		// this is a hack as version 0 differed in definition of var_get  		if (version == 0)  			resn--;  	}  	switch (cmd) {  	case FN_ZERO:  		break;  	case FN_DIFF0:  	case FN_DIFF1:  	case FN_DIFF2:  	case FN_DIFF3:  		for (i = 0; i < blocksize; i++) {  			int nbin = resn + 1;  			if (nbitget == 0) {  				if (nbyteget < 4) {  					int bytes = stream.Read (getbuf' 0' BUFSIZE);  					getbufOffset = 0;  					nbyteget += bytes;  				}  				gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  				getbufOffset += 4;  				nbyteget -= 4;  				nbitget = 32;  			}  			while ((gbuffer & (1L << --nbitget)) == 0) {  				if (nbitget == 0) {  					if (nbyteget < 4) {  						int bytes = stream.Read (getbuf' 0' BUFSIZE);  						getbufOffset = 0;  						nbyteget += bytes;  					}  					gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  					getbufOffset += 4;  					nbyteget -= 4;  					nbitget = 32;  				}  			}  			while (nbin != 0) {  				if (nbitget >= nbin) {  					nbitget -= nbin;  					nbin = 0;  				} else {  					if (nbyteget < 4) {  						int bytes = stream.Read (getbuf' 0' BUFSIZE);  						getbufOffset = 0;  						nbyteget += bytes;  					}  					gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  					getbufOffset += 4;  					nbyteget -= 4;  					nbin -= nbitget;  					nbitget = 32;  				}  			}  		}  		break;  	case FN_QLPC:  		int nlpc = uvar_get (LPCQSIZE' stream);  		for (i = 0; i < nlpc; i++)  			var_get (LPCQUANT' stream);  		break;  	}  	if (chan == nchan - 1) {  		SampleNumber += blocksize;  	}  	chan = (chan + 1) % nchan;  	break;  case FN_BLOCKSIZE:  	blocksize = (int)UINT_GET ((int)(Math.Log (blocksize) / M_LN2)' stream);  	break;  case FN_BITSHIFT:  	uvar_get (BITSHIFTSIZE' stream);  	break;  case FN_VERBATIM:  	int cklen = uvar_get (VERBATIM_CKSIZE_SIZE' stream);  	while (cklen-- != 0) {  		uvar_get (VERBATIM_BYTE_SIZE' stream);  	}  	break;  default:  	return 0;  }  
Magic Number,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,getSamples,The following statement contains a magic number: switch (cmd) {  case FN_ZERO:  case FN_DIFF0:  case FN_DIFF1:  case FN_DIFF2:  case FN_DIFF3:  case FN_QLPC:  	int resn = 0;  	if (cmd != FN_ZERO) {  		resn = uvar_get (ENERGYSIZE' stream);  		// this is a hack as version 0 differed in definition of var_get  		if (version == 0)  			resn--;  	}  	switch (cmd) {  	case FN_ZERO:  		break;  	case FN_DIFF0:  	case FN_DIFF1:  	case FN_DIFF2:  	case FN_DIFF3:  		for (i = 0; i < blocksize; i++) {  			int nbin = resn + 1;  			if (nbitget == 0) {  				if (nbyteget < 4) {  					int bytes = stream.Read (getbuf' 0' BUFSIZE);  					getbufOffset = 0;  					nbyteget += bytes;  				}  				gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  				getbufOffset += 4;  				nbyteget -= 4;  				nbitget = 32;  			}  			while ((gbuffer & (1L << --nbitget)) == 0) {  				if (nbitget == 0) {  					if (nbyteget < 4) {  						int bytes = stream.Read (getbuf' 0' BUFSIZE);  						getbufOffset = 0;  						nbyteget += bytes;  					}  					gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  					getbufOffset += 4;  					nbyteget -= 4;  					nbitget = 32;  				}  			}  			while (nbin != 0) {  				if (nbitget >= nbin) {  					nbitget -= nbin;  					nbin = 0;  				} else {  					if (nbyteget < 4) {  						int bytes = stream.Read (getbuf' 0' BUFSIZE);  						getbufOffset = 0;  						nbyteget += bytes;  					}  					gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  					getbufOffset += 4;  					nbyteget -= 4;  					nbin -= nbitget;  					nbitget = 32;  				}  			}  		}  		break;  	case FN_QLPC:  		int nlpc = uvar_get (LPCQSIZE' stream);  		for (i = 0; i < nlpc; i++)  			var_get (LPCQUANT' stream);  		break;  	}  	if (chan == nchan - 1) {  		SampleNumber += blocksize;  	}  	chan = (chan + 1) % nchan;  	break;  case FN_BLOCKSIZE:  	blocksize = (int)UINT_GET ((int)(Math.Log (blocksize) / M_LN2)' stream);  	break;  case FN_BITSHIFT:  	uvar_get (BITSHIFTSIZE' stream);  	break;  case FN_VERBATIM:  	int cklen = uvar_get (VERBATIM_CKSIZE_SIZE' stream);  	while (cklen-- != 0) {  		uvar_get (VERBATIM_BYTE_SIZE' stream);  	}  	break;  default:  	return 0;  }  
Magic Number,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,getSamples,The following statement contains a magic number: switch (cmd) {  case FN_ZERO:  case FN_DIFF0:  case FN_DIFF1:  case FN_DIFF2:  case FN_DIFF3:  case FN_QLPC:  	int resn = 0;  	if (cmd != FN_ZERO) {  		resn = uvar_get (ENERGYSIZE' stream);  		// this is a hack as version 0 differed in definition of var_get  		if (version == 0)  			resn--;  	}  	switch (cmd) {  	case FN_ZERO:  		break;  	case FN_DIFF0:  	case FN_DIFF1:  	case FN_DIFF2:  	case FN_DIFF3:  		for (i = 0; i < blocksize; i++) {  			int nbin = resn + 1;  			if (nbitget == 0) {  				if (nbyteget < 4) {  					int bytes = stream.Read (getbuf' 0' BUFSIZE);  					getbufOffset = 0;  					nbyteget += bytes;  				}  				gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  				getbufOffset += 4;  				nbyteget -= 4;  				nbitget = 32;  			}  			while ((gbuffer & (1L << --nbitget)) == 0) {  				if (nbitget == 0) {  					if (nbyteget < 4) {  						int bytes = stream.Read (getbuf' 0' BUFSIZE);  						getbufOffset = 0;  						nbyteget += bytes;  					}  					gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  					getbufOffset += 4;  					nbyteget -= 4;  					nbitget = 32;  				}  			}  			while (nbin != 0) {  				if (nbitget >= nbin) {  					nbitget -= nbin;  					nbin = 0;  				} else {  					if (nbyteget < 4) {  						int bytes = stream.Read (getbuf' 0' BUFSIZE);  						getbufOffset = 0;  						nbyteget += bytes;  					}  					gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  					getbufOffset += 4;  					nbyteget -= 4;  					nbin -= nbitget;  					nbitget = 32;  				}  			}  		}  		break;  	case FN_QLPC:  		int nlpc = uvar_get (LPCQSIZE' stream);  		for (i = 0; i < nlpc; i++)  			var_get (LPCQUANT' stream);  		break;  	}  	if (chan == nchan - 1) {  		SampleNumber += blocksize;  	}  	chan = (chan + 1) % nchan;  	break;  case FN_BLOCKSIZE:  	blocksize = (int)UINT_GET ((int)(Math.Log (blocksize) / M_LN2)' stream);  	break;  case FN_BITSHIFT:  	uvar_get (BITSHIFTSIZE' stream);  	break;  case FN_VERBATIM:  	int cklen = uvar_get (VERBATIM_CKSIZE_SIZE' stream);  	while (cklen-- != 0) {  		uvar_get (VERBATIM_BYTE_SIZE' stream);  	}  	break;  default:  	return 0;  }  
Magic Number,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,getSamples,The following statement contains a magic number: switch (cmd) {  case FN_ZERO:  case FN_DIFF0:  case FN_DIFF1:  case FN_DIFF2:  case FN_DIFF3:  case FN_QLPC:  	int resn = 0;  	if (cmd != FN_ZERO) {  		resn = uvar_get (ENERGYSIZE' stream);  		// this is a hack as version 0 differed in definition of var_get  		if (version == 0)  			resn--;  	}  	switch (cmd) {  	case FN_ZERO:  		break;  	case FN_DIFF0:  	case FN_DIFF1:  	case FN_DIFF2:  	case FN_DIFF3:  		for (i = 0; i < blocksize; i++) {  			int nbin = resn + 1;  			if (nbitget == 0) {  				if (nbyteget < 4) {  					int bytes = stream.Read (getbuf' 0' BUFSIZE);  					getbufOffset = 0;  					nbyteget += bytes;  				}  				gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  				getbufOffset += 4;  				nbyteget -= 4;  				nbitget = 32;  			}  			while ((gbuffer & (1L << --nbitget)) == 0) {  				if (nbitget == 0) {  					if (nbyteget < 4) {  						int bytes = stream.Read (getbuf' 0' BUFSIZE);  						getbufOffset = 0;  						nbyteget += bytes;  					}  					gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  					getbufOffset += 4;  					nbyteget -= 4;  					nbitget = 32;  				}  			}  			while (nbin != 0) {  				if (nbitget >= nbin) {  					nbitget -= nbin;  					nbin = 0;  				} else {  					if (nbyteget < 4) {  						int bytes = stream.Read (getbuf' 0' BUFSIZE);  						getbufOffset = 0;  						nbyteget += bytes;  					}  					gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  					getbufOffset += 4;  					nbyteget -= 4;  					nbin -= nbitget;  					nbitget = 32;  				}  			}  		}  		break;  	case FN_QLPC:  		int nlpc = uvar_get (LPCQSIZE' stream);  		for (i = 0; i < nlpc; i++)  			var_get (LPCQUANT' stream);  		break;  	}  	if (chan == nchan - 1) {  		SampleNumber += blocksize;  	}  	chan = (chan + 1) % nchan;  	break;  case FN_BLOCKSIZE:  	blocksize = (int)UINT_GET ((int)(Math.Log (blocksize) / M_LN2)' stream);  	break;  case FN_BITSHIFT:  	uvar_get (BITSHIFTSIZE' stream);  	break;  case FN_VERBATIM:  	int cklen = uvar_get (VERBATIM_CKSIZE_SIZE' stream);  	while (cklen-- != 0) {  		uvar_get (VERBATIM_BYTE_SIZE' stream);  	}  	break;  default:  	return 0;  }  
Magic Number,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,getSamples,The following statement contains a magic number: switch (cmd) {  case FN_ZERO:  case FN_DIFF0:  case FN_DIFF1:  case FN_DIFF2:  case FN_DIFF3:  case FN_QLPC:  	int resn = 0;  	if (cmd != FN_ZERO) {  		resn = uvar_get (ENERGYSIZE' stream);  		// this is a hack as version 0 differed in definition of var_get  		if (version == 0)  			resn--;  	}  	switch (cmd) {  	case FN_ZERO:  		break;  	case FN_DIFF0:  	case FN_DIFF1:  	case FN_DIFF2:  	case FN_DIFF3:  		for (i = 0; i < blocksize; i++) {  			int nbin = resn + 1;  			if (nbitget == 0) {  				if (nbyteget < 4) {  					int bytes = stream.Read (getbuf' 0' BUFSIZE);  					getbufOffset = 0;  					nbyteget += bytes;  				}  				gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  				getbufOffset += 4;  				nbyteget -= 4;  				nbitget = 32;  			}  			while ((gbuffer & (1L << --nbitget)) == 0) {  				if (nbitget == 0) {  					if (nbyteget < 4) {  						int bytes = stream.Read (getbuf' 0' BUFSIZE);  						getbufOffset = 0;  						nbyteget += bytes;  					}  					gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  					getbufOffset += 4;  					nbyteget -= 4;  					nbitget = 32;  				}  			}  			while (nbin != 0) {  				if (nbitget >= nbin) {  					nbitget -= nbin;  					nbin = 0;  				} else {  					if (nbyteget < 4) {  						int bytes = stream.Read (getbuf' 0' BUFSIZE);  						getbufOffset = 0;  						nbyteget += bytes;  					}  					gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  					getbufOffset += 4;  					nbyteget -= 4;  					nbin -= nbitget;  					nbitget = 32;  				}  			}  		}  		break;  	case FN_QLPC:  		int nlpc = uvar_get (LPCQSIZE' stream);  		for (i = 0; i < nlpc; i++)  			var_get (LPCQUANT' stream);  		break;  	}  	if (chan == nchan - 1) {  		SampleNumber += blocksize;  	}  	chan = (chan + 1) % nchan;  	break;  case FN_BLOCKSIZE:  	blocksize = (int)UINT_GET ((int)(Math.Log (blocksize) / M_LN2)' stream);  	break;  case FN_BITSHIFT:  	uvar_get (BITSHIFTSIZE' stream);  	break;  case FN_VERBATIM:  	int cklen = uvar_get (VERBATIM_CKSIZE_SIZE' stream);  	while (cklen-- != 0) {  		uvar_get (VERBATIM_BYTE_SIZE' stream);  	}  	break;  default:  	return 0;  }  
Magic Number,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,getSamples,The following statement contains a magic number: switch (cmd) {  case FN_ZERO:  case FN_DIFF0:  case FN_DIFF1:  case FN_DIFF2:  case FN_DIFF3:  case FN_QLPC:  	int resn = 0;  	if (cmd != FN_ZERO) {  		resn = uvar_get (ENERGYSIZE' stream);  		// this is a hack as version 0 differed in definition of var_get  		if (version == 0)  			resn--;  	}  	switch (cmd) {  	case FN_ZERO:  		break;  	case FN_DIFF0:  	case FN_DIFF1:  	case FN_DIFF2:  	case FN_DIFF3:  		for (i = 0; i < blocksize; i++) {  			int nbin = resn + 1;  			if (nbitget == 0) {  				if (nbyteget < 4) {  					int bytes = stream.Read (getbuf' 0' BUFSIZE);  					getbufOffset = 0;  					nbyteget += bytes;  				}  				gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  				getbufOffset += 4;  				nbyteget -= 4;  				nbitget = 32;  			}  			while ((gbuffer & (1L << --nbitget)) == 0) {  				if (nbitget == 0) {  					if (nbyteget < 4) {  						int bytes = stream.Read (getbuf' 0' BUFSIZE);  						getbufOffset = 0;  						nbyteget += bytes;  					}  					gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  					getbufOffset += 4;  					nbyteget -= 4;  					nbitget = 32;  				}  			}  			while (nbin != 0) {  				if (nbitget >= nbin) {  					nbitget -= nbin;  					nbin = 0;  				} else {  					if (nbyteget < 4) {  						int bytes = stream.Read (getbuf' 0' BUFSIZE);  						getbufOffset = 0;  						nbyteget += bytes;  					}  					gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  					getbufOffset += 4;  					nbyteget -= 4;  					nbin -= nbitget;  					nbitget = 32;  				}  			}  		}  		break;  	case FN_QLPC:  		int nlpc = uvar_get (LPCQSIZE' stream);  		for (i = 0; i < nlpc; i++)  			var_get (LPCQUANT' stream);  		break;  	}  	if (chan == nchan - 1) {  		SampleNumber += blocksize;  	}  	chan = (chan + 1) % nchan;  	break;  case FN_BLOCKSIZE:  	blocksize = (int)UINT_GET ((int)(Math.Log (blocksize) / M_LN2)' stream);  	break;  case FN_BITSHIFT:  	uvar_get (BITSHIFTSIZE' stream);  	break;  case FN_VERBATIM:  	int cklen = uvar_get (VERBATIM_CKSIZE_SIZE' stream);  	while (cklen-- != 0) {  		uvar_get (VERBATIM_BYTE_SIZE' stream);  	}  	break;  default:  	return 0;  }  
Magic Number,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,getSamples,The following statement contains a magic number: switch (cmd) {  case FN_ZERO:  case FN_DIFF0:  case FN_DIFF1:  case FN_DIFF2:  case FN_DIFF3:  case FN_QLPC:  	int resn = 0;  	if (cmd != FN_ZERO) {  		resn = uvar_get (ENERGYSIZE' stream);  		// this is a hack as version 0 differed in definition of var_get  		if (version == 0)  			resn--;  	}  	switch (cmd) {  	case FN_ZERO:  		break;  	case FN_DIFF0:  	case FN_DIFF1:  	case FN_DIFF2:  	case FN_DIFF3:  		for (i = 0; i < blocksize; i++) {  			int nbin = resn + 1;  			if (nbitget == 0) {  				if (nbyteget < 4) {  					int bytes = stream.Read (getbuf' 0' BUFSIZE);  					getbufOffset = 0;  					nbyteget += bytes;  				}  				gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  				getbufOffset += 4;  				nbyteget -= 4;  				nbitget = 32;  			}  			while ((gbuffer & (1L << --nbitget)) == 0) {  				if (nbitget == 0) {  					if (nbyteget < 4) {  						int bytes = stream.Read (getbuf' 0' BUFSIZE);  						getbufOffset = 0;  						nbyteget += bytes;  					}  					gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  					getbufOffset += 4;  					nbyteget -= 4;  					nbitget = 32;  				}  			}  			while (nbin != 0) {  				if (nbitget >= nbin) {  					nbitget -= nbin;  					nbin = 0;  				} else {  					if (nbyteget < 4) {  						int bytes = stream.Read (getbuf' 0' BUFSIZE);  						getbufOffset = 0;  						nbyteget += bytes;  					}  					gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  					getbufOffset += 4;  					nbyteget -= 4;  					nbin -= nbitget;  					nbitget = 32;  				}  			}  		}  		break;  	case FN_QLPC:  		int nlpc = uvar_get (LPCQSIZE' stream);  		for (i = 0; i < nlpc; i++)  			var_get (LPCQUANT' stream);  		break;  	}  	if (chan == nchan - 1) {  		SampleNumber += blocksize;  	}  	chan = (chan + 1) % nchan;  	break;  case FN_BLOCKSIZE:  	blocksize = (int)UINT_GET ((int)(Math.Log (blocksize) / M_LN2)' stream);  	break;  case FN_BITSHIFT:  	uvar_get (BITSHIFTSIZE' stream);  	break;  case FN_VERBATIM:  	int cklen = uvar_get (VERBATIM_CKSIZE_SIZE' stream);  	while (cklen-- != 0) {  		uvar_get (VERBATIM_BYTE_SIZE' stream);  	}  	break;  default:  	return 0;  }  
Magic Number,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,getSamples,The following statement contains a magic number: switch (cmd) {  case FN_ZERO:  case FN_DIFF0:  case FN_DIFF1:  case FN_DIFF2:  case FN_DIFF3:  case FN_QLPC:  	int resn = 0;  	if (cmd != FN_ZERO) {  		resn = uvar_get (ENERGYSIZE' stream);  		// this is a hack as version 0 differed in definition of var_get  		if (version == 0)  			resn--;  	}  	switch (cmd) {  	case FN_ZERO:  		break;  	case FN_DIFF0:  	case FN_DIFF1:  	case FN_DIFF2:  	case FN_DIFF3:  		for (i = 0; i < blocksize; i++) {  			int nbin = resn + 1;  			if (nbitget == 0) {  				if (nbyteget < 4) {  					int bytes = stream.Read (getbuf' 0' BUFSIZE);  					getbufOffset = 0;  					nbyteget += bytes;  				}  				gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  				getbufOffset += 4;  				nbyteget -= 4;  				nbitget = 32;  			}  			while ((gbuffer & (1L << --nbitget)) == 0) {  				if (nbitget == 0) {  					if (nbyteget < 4) {  						int bytes = stream.Read (getbuf' 0' BUFSIZE);  						getbufOffset = 0;  						nbyteget += bytes;  					}  					gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  					getbufOffset += 4;  					nbyteget -= 4;  					nbitget = 32;  				}  			}  			while (nbin != 0) {  				if (nbitget >= nbin) {  					nbitget -= nbin;  					nbin = 0;  				} else {  					if (nbyteget < 4) {  						int bytes = stream.Read (getbuf' 0' BUFSIZE);  						getbufOffset = 0;  						nbyteget += bytes;  					}  					gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  					getbufOffset += 4;  					nbyteget -= 4;  					nbin -= nbitget;  					nbitget = 32;  				}  			}  		}  		break;  	case FN_QLPC:  		int nlpc = uvar_get (LPCQSIZE' stream);  		for (i = 0; i < nlpc; i++)  			var_get (LPCQUANT' stream);  		break;  	}  	if (chan == nchan - 1) {  		SampleNumber += blocksize;  	}  	chan = (chan + 1) % nchan;  	break;  case FN_BLOCKSIZE:  	blocksize = (int)UINT_GET ((int)(Math.Log (blocksize) / M_LN2)' stream);  	break;  case FN_BITSHIFT:  	uvar_get (BITSHIFTSIZE' stream);  	break;  case FN_VERBATIM:  	int cklen = uvar_get (VERBATIM_CKSIZE_SIZE' stream);  	while (cklen-- != 0) {  		uvar_get (VERBATIM_BYTE_SIZE' stream);  	}  	break;  default:  	return 0;  }  
Magic Number,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,getSamples,The following statement contains a magic number: switch (cmd) {  case FN_ZERO:  case FN_DIFF0:  case FN_DIFF1:  case FN_DIFF2:  case FN_DIFF3:  case FN_QLPC:  	int resn = 0;  	if (cmd != FN_ZERO) {  		resn = uvar_get (ENERGYSIZE' stream);  		// this is a hack as version 0 differed in definition of var_get  		if (version == 0)  			resn--;  	}  	switch (cmd) {  	case FN_ZERO:  		break;  	case FN_DIFF0:  	case FN_DIFF1:  	case FN_DIFF2:  	case FN_DIFF3:  		for (i = 0; i < blocksize; i++) {  			int nbin = resn + 1;  			if (nbitget == 0) {  				if (nbyteget < 4) {  					int bytes = stream.Read (getbuf' 0' BUFSIZE);  					getbufOffset = 0;  					nbyteget += bytes;  				}  				gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  				getbufOffset += 4;  				nbyteget -= 4;  				nbitget = 32;  			}  			while ((gbuffer & (1L << --nbitget)) == 0) {  				if (nbitget == 0) {  					if (nbyteget < 4) {  						int bytes = stream.Read (getbuf' 0' BUFSIZE);  						getbufOffset = 0;  						nbyteget += bytes;  					}  					gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  					getbufOffset += 4;  					nbyteget -= 4;  					nbitget = 32;  				}  			}  			while (nbin != 0) {  				if (nbitget >= nbin) {  					nbitget -= nbin;  					nbin = 0;  				} else {  					if (nbyteget < 4) {  						int bytes = stream.Read (getbuf' 0' BUFSIZE);  						getbufOffset = 0;  						nbyteget += bytes;  					}  					gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  					getbufOffset += 4;  					nbyteget -= 4;  					nbin -= nbitget;  					nbitget = 32;  				}  			}  		}  		break;  	case FN_QLPC:  		int nlpc = uvar_get (LPCQSIZE' stream);  		for (i = 0; i < nlpc; i++)  			var_get (LPCQUANT' stream);  		break;  	}  	if (chan == nchan - 1) {  		SampleNumber += blocksize;  	}  	chan = (chan + 1) % nchan;  	break;  case FN_BLOCKSIZE:  	blocksize = (int)UINT_GET ((int)(Math.Log (blocksize) / M_LN2)' stream);  	break;  case FN_BITSHIFT:  	uvar_get (BITSHIFTSIZE' stream);  	break;  case FN_VERBATIM:  	int cklen = uvar_get (VERBATIM_CKSIZE_SIZE' stream);  	while (cklen-- != 0) {  		uvar_get (VERBATIM_BYTE_SIZE' stream);  	}  	break;  default:  	return 0;  }  
Magic Number,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,getSamples,The following statement contains a magic number: switch (cmd) {  case FN_ZERO:  case FN_DIFF0:  case FN_DIFF1:  case FN_DIFF2:  case FN_DIFF3:  case FN_QLPC:  	int resn = 0;  	if (cmd != FN_ZERO) {  		resn = uvar_get (ENERGYSIZE' stream);  		// this is a hack as version 0 differed in definition of var_get  		if (version == 0)  			resn--;  	}  	switch (cmd) {  	case FN_ZERO:  		break;  	case FN_DIFF0:  	case FN_DIFF1:  	case FN_DIFF2:  	case FN_DIFF3:  		for (i = 0; i < blocksize; i++) {  			int nbin = resn + 1;  			if (nbitget == 0) {  				if (nbyteget < 4) {  					int bytes = stream.Read (getbuf' 0' BUFSIZE);  					getbufOffset = 0;  					nbyteget += bytes;  				}  				gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  				getbufOffset += 4;  				nbyteget -= 4;  				nbitget = 32;  			}  			while ((gbuffer & (1L << --nbitget)) == 0) {  				if (nbitget == 0) {  					if (nbyteget < 4) {  						int bytes = stream.Read (getbuf' 0' BUFSIZE);  						getbufOffset = 0;  						nbyteget += bytes;  					}  					gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  					getbufOffset += 4;  					nbyteget -= 4;  					nbitget = 32;  				}  			}  			while (nbin != 0) {  				if (nbitget >= nbin) {  					nbitget -= nbin;  					nbin = 0;  				} else {  					if (nbyteget < 4) {  						int bytes = stream.Read (getbuf' 0' BUFSIZE);  						getbufOffset = 0;  						nbyteget += bytes;  					}  					gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  					getbufOffset += 4;  					nbyteget -= 4;  					nbin -= nbitget;  					nbitget = 32;  				}  			}  		}  		break;  	case FN_QLPC:  		int nlpc = uvar_get (LPCQSIZE' stream);  		for (i = 0; i < nlpc; i++)  			var_get (LPCQUANT' stream);  		break;  	}  	if (chan == nchan - 1) {  		SampleNumber += blocksize;  	}  	chan = (chan + 1) % nchan;  	break;  case FN_BLOCKSIZE:  	blocksize = (int)UINT_GET ((int)(Math.Log (blocksize) / M_LN2)' stream);  	break;  case FN_BITSHIFT:  	uvar_get (BITSHIFTSIZE' stream);  	break;  case FN_VERBATIM:  	int cklen = uvar_get (VERBATIM_CKSIZE_SIZE' stream);  	while (cklen-- != 0) {  		uvar_get (VERBATIM_BYTE_SIZE' stream);  	}  	break;  default:  	return 0;  }  
Magic Number,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,getSamples,The following statement contains a magic number: switch (cmd) {  case FN_ZERO:  case FN_DIFF0:  case FN_DIFF1:  case FN_DIFF2:  case FN_DIFF3:  case FN_QLPC:  	int resn = 0;  	if (cmd != FN_ZERO) {  		resn = uvar_get (ENERGYSIZE' stream);  		// this is a hack as version 0 differed in definition of var_get  		if (version == 0)  			resn--;  	}  	switch (cmd) {  	case FN_ZERO:  		break;  	case FN_DIFF0:  	case FN_DIFF1:  	case FN_DIFF2:  	case FN_DIFF3:  		for (i = 0; i < blocksize; i++) {  			int nbin = resn + 1;  			if (nbitget == 0) {  				if (nbyteget < 4) {  					int bytes = stream.Read (getbuf' 0' BUFSIZE);  					getbufOffset = 0;  					nbyteget += bytes;  				}  				gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  				getbufOffset += 4;  				nbyteget -= 4;  				nbitget = 32;  			}  			while ((gbuffer & (1L << --nbitget)) == 0) {  				if (nbitget == 0) {  					if (nbyteget < 4) {  						int bytes = stream.Read (getbuf' 0' BUFSIZE);  						getbufOffset = 0;  						nbyteget += bytes;  					}  					gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  					getbufOffset += 4;  					nbyteget -= 4;  					nbitget = 32;  				}  			}  			while (nbin != 0) {  				if (nbitget >= nbin) {  					nbitget -= nbin;  					nbin = 0;  				} else {  					if (nbyteget < 4) {  						int bytes = stream.Read (getbuf' 0' BUFSIZE);  						getbufOffset = 0;  						nbyteget += bytes;  					}  					gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  					getbufOffset += 4;  					nbyteget -= 4;  					nbin -= nbitget;  					nbitget = 32;  				}  			}  		}  		break;  	case FN_QLPC:  		int nlpc = uvar_get (LPCQSIZE' stream);  		for (i = 0; i < nlpc; i++)  			var_get (LPCQUANT' stream);  		break;  	}  	if (chan == nchan - 1) {  		SampleNumber += blocksize;  	}  	chan = (chan + 1) % nchan;  	break;  case FN_BLOCKSIZE:  	blocksize = (int)UINT_GET ((int)(Math.Log (blocksize) / M_LN2)' stream);  	break;  case FN_BITSHIFT:  	uvar_get (BITSHIFTSIZE' stream);  	break;  case FN_VERBATIM:  	int cklen = uvar_get (VERBATIM_CKSIZE_SIZE' stream);  	while (cklen-- != 0) {  		uvar_get (VERBATIM_BYTE_SIZE' stream);  	}  	break;  default:  	return 0;  }  
Magic Number,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,getSamples,The following statement contains a magic number: switch (cmd) {  case FN_ZERO:  	break;  case FN_DIFF0:  case FN_DIFF1:  case FN_DIFF2:  case FN_DIFF3:  	for (i = 0; i < blocksize; i++) {  		int nbin = resn + 1;  		if (nbitget == 0) {  			if (nbyteget < 4) {  				int bytes = stream.Read (getbuf' 0' BUFSIZE);  				getbufOffset = 0;  				nbyteget += bytes;  			}  			gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  			getbufOffset += 4;  			nbyteget -= 4;  			nbitget = 32;  		}  		while ((gbuffer & (1L << --nbitget)) == 0) {  			if (nbitget == 0) {  				if (nbyteget < 4) {  					int bytes = stream.Read (getbuf' 0' BUFSIZE);  					getbufOffset = 0;  					nbyteget += bytes;  				}  				gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  				getbufOffset += 4;  				nbyteget -= 4;  				nbitget = 32;  			}  		}  		while (nbin != 0) {  			if (nbitget >= nbin) {  				nbitget -= nbin;  				nbin = 0;  			} else {  				if (nbyteget < 4) {  					int bytes = stream.Read (getbuf' 0' BUFSIZE);  					getbufOffset = 0;  					nbyteget += bytes;  				}  				gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  				getbufOffset += 4;  				nbyteget -= 4;  				nbin -= nbitget;  				nbitget = 32;  			}  		}  	}  	break;  case FN_QLPC:  	int nlpc = uvar_get (LPCQSIZE' stream);  	for (i = 0; i < nlpc; i++)  		var_get (LPCQUANT' stream);  	break;  }  
Magic Number,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,getSamples,The following statement contains a magic number: switch (cmd) {  case FN_ZERO:  	break;  case FN_DIFF0:  case FN_DIFF1:  case FN_DIFF2:  case FN_DIFF3:  	for (i = 0; i < blocksize; i++) {  		int nbin = resn + 1;  		if (nbitget == 0) {  			if (nbyteget < 4) {  				int bytes = stream.Read (getbuf' 0' BUFSIZE);  				getbufOffset = 0;  				nbyteget += bytes;  			}  			gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  			getbufOffset += 4;  			nbyteget -= 4;  			nbitget = 32;  		}  		while ((gbuffer & (1L << --nbitget)) == 0) {  			if (nbitget == 0) {  				if (nbyteget < 4) {  					int bytes = stream.Read (getbuf' 0' BUFSIZE);  					getbufOffset = 0;  					nbyteget += bytes;  				}  				gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  				getbufOffset += 4;  				nbyteget -= 4;  				nbitget = 32;  			}  		}  		while (nbin != 0) {  			if (nbitget >= nbin) {  				nbitget -= nbin;  				nbin = 0;  			} else {  				if (nbyteget < 4) {  					int bytes = stream.Read (getbuf' 0' BUFSIZE);  					getbufOffset = 0;  					nbyteget += bytes;  				}  				gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  				getbufOffset += 4;  				nbyteget -= 4;  				nbin -= nbitget;  				nbitget = 32;  			}  		}  	}  	break;  case FN_QLPC:  	int nlpc = uvar_get (LPCQSIZE' stream);  	for (i = 0; i < nlpc; i++)  		var_get (LPCQUANT' stream);  	break;  }  
Magic Number,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,getSamples,The following statement contains a magic number: switch (cmd) {  case FN_ZERO:  	break;  case FN_DIFF0:  case FN_DIFF1:  case FN_DIFF2:  case FN_DIFF3:  	for (i = 0; i < blocksize; i++) {  		int nbin = resn + 1;  		if (nbitget == 0) {  			if (nbyteget < 4) {  				int bytes = stream.Read (getbuf' 0' BUFSIZE);  				getbufOffset = 0;  				nbyteget += bytes;  			}  			gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  			getbufOffset += 4;  			nbyteget -= 4;  			nbitget = 32;  		}  		while ((gbuffer & (1L << --nbitget)) == 0) {  			if (nbitget == 0) {  				if (nbyteget < 4) {  					int bytes = stream.Read (getbuf' 0' BUFSIZE);  					getbufOffset = 0;  					nbyteget += bytes;  				}  				gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  				getbufOffset += 4;  				nbyteget -= 4;  				nbitget = 32;  			}  		}  		while (nbin != 0) {  			if (nbitget >= nbin) {  				nbitget -= nbin;  				nbin = 0;  			} else {  				if (nbyteget < 4) {  					int bytes = stream.Read (getbuf' 0' BUFSIZE);  					getbufOffset = 0;  					nbyteget += bytes;  				}  				gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  				getbufOffset += 4;  				nbyteget -= 4;  				nbin -= nbitget;  				nbitget = 32;  			}  		}  	}  	break;  case FN_QLPC:  	int nlpc = uvar_get (LPCQSIZE' stream);  	for (i = 0; i < nlpc; i++)  		var_get (LPCQUANT' stream);  	break;  }  
Magic Number,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,getSamples,The following statement contains a magic number: switch (cmd) {  case FN_ZERO:  	break;  case FN_DIFF0:  case FN_DIFF1:  case FN_DIFF2:  case FN_DIFF3:  	for (i = 0; i < blocksize; i++) {  		int nbin = resn + 1;  		if (nbitget == 0) {  			if (nbyteget < 4) {  				int bytes = stream.Read (getbuf' 0' BUFSIZE);  				getbufOffset = 0;  				nbyteget += bytes;  			}  			gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  			getbufOffset += 4;  			nbyteget -= 4;  			nbitget = 32;  		}  		while ((gbuffer & (1L << --nbitget)) == 0) {  			if (nbitget == 0) {  				if (nbyteget < 4) {  					int bytes = stream.Read (getbuf' 0' BUFSIZE);  					getbufOffset = 0;  					nbyteget += bytes;  				}  				gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  				getbufOffset += 4;  				nbyteget -= 4;  				nbitget = 32;  			}  		}  		while (nbin != 0) {  			if (nbitget >= nbin) {  				nbitget -= nbin;  				nbin = 0;  			} else {  				if (nbyteget < 4) {  					int bytes = stream.Read (getbuf' 0' BUFSIZE);  					getbufOffset = 0;  					nbyteget += bytes;  				}  				gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  				getbufOffset += 4;  				nbyteget -= 4;  				nbin -= nbitget;  				nbitget = 32;  			}  		}  	}  	break;  case FN_QLPC:  	int nlpc = uvar_get (LPCQSIZE' stream);  	for (i = 0; i < nlpc; i++)  		var_get (LPCQUANT' stream);  	break;  }  
Magic Number,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,getSamples,The following statement contains a magic number: switch (cmd) {  case FN_ZERO:  	break;  case FN_DIFF0:  case FN_DIFF1:  case FN_DIFF2:  case FN_DIFF3:  	for (i = 0; i < blocksize; i++) {  		int nbin = resn + 1;  		if (nbitget == 0) {  			if (nbyteget < 4) {  				int bytes = stream.Read (getbuf' 0' BUFSIZE);  				getbufOffset = 0;  				nbyteget += bytes;  			}  			gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  			getbufOffset += 4;  			nbyteget -= 4;  			nbitget = 32;  		}  		while ((gbuffer & (1L << --nbitget)) == 0) {  			if (nbitget == 0) {  				if (nbyteget < 4) {  					int bytes = stream.Read (getbuf' 0' BUFSIZE);  					getbufOffset = 0;  					nbyteget += bytes;  				}  				gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  				getbufOffset += 4;  				nbyteget -= 4;  				nbitget = 32;  			}  		}  		while (nbin != 0) {  			if (nbitget >= nbin) {  				nbitget -= nbin;  				nbin = 0;  			} else {  				if (nbyteget < 4) {  					int bytes = stream.Read (getbuf' 0' BUFSIZE);  					getbufOffset = 0;  					nbyteget += bytes;  				}  				gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  				getbufOffset += 4;  				nbyteget -= 4;  				nbin -= nbitget;  				nbitget = 32;  			}  		}  	}  	break;  case FN_QLPC:  	int nlpc = uvar_get (LPCQSIZE' stream);  	for (i = 0; i < nlpc; i++)  		var_get (LPCQUANT' stream);  	break;  }  
Magic Number,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,getSamples,The following statement contains a magic number: switch (cmd) {  case FN_ZERO:  	break;  case FN_DIFF0:  case FN_DIFF1:  case FN_DIFF2:  case FN_DIFF3:  	for (i = 0; i < blocksize; i++) {  		int nbin = resn + 1;  		if (nbitget == 0) {  			if (nbyteget < 4) {  				int bytes = stream.Read (getbuf' 0' BUFSIZE);  				getbufOffset = 0;  				nbyteget += bytes;  			}  			gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  			getbufOffset += 4;  			nbyteget -= 4;  			nbitget = 32;  		}  		while ((gbuffer & (1L << --nbitget)) == 0) {  			if (nbitget == 0) {  				if (nbyteget < 4) {  					int bytes = stream.Read (getbuf' 0' BUFSIZE);  					getbufOffset = 0;  					nbyteget += bytes;  				}  				gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  				getbufOffset += 4;  				nbyteget -= 4;  				nbitget = 32;  			}  		}  		while (nbin != 0) {  			if (nbitget >= nbin) {  				nbitget -= nbin;  				nbin = 0;  			} else {  				if (nbyteget < 4) {  					int bytes = stream.Read (getbuf' 0' BUFSIZE);  					getbufOffset = 0;  					nbyteget += bytes;  				}  				gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  				getbufOffset += 4;  				nbyteget -= 4;  				nbin -= nbitget;  				nbitget = 32;  			}  		}  	}  	break;  case FN_QLPC:  	int nlpc = uvar_get (LPCQSIZE' stream);  	for (i = 0; i < nlpc; i++)  		var_get (LPCQUANT' stream);  	break;  }  
Magic Number,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,getSamples,The following statement contains a magic number: switch (cmd) {  case FN_ZERO:  	break;  case FN_DIFF0:  case FN_DIFF1:  case FN_DIFF2:  case FN_DIFF3:  	for (i = 0; i < blocksize; i++) {  		int nbin = resn + 1;  		if (nbitget == 0) {  			if (nbyteget < 4) {  				int bytes = stream.Read (getbuf' 0' BUFSIZE);  				getbufOffset = 0;  				nbyteget += bytes;  			}  			gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  			getbufOffset += 4;  			nbyteget -= 4;  			nbitget = 32;  		}  		while ((gbuffer & (1L << --nbitget)) == 0) {  			if (nbitget == 0) {  				if (nbyteget < 4) {  					int bytes = stream.Read (getbuf' 0' BUFSIZE);  					getbufOffset = 0;  					nbyteget += bytes;  				}  				gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  				getbufOffset += 4;  				nbyteget -= 4;  				nbitget = 32;  			}  		}  		while (nbin != 0) {  			if (nbitget >= nbin) {  				nbitget -= nbin;  				nbin = 0;  			} else {  				if (nbyteget < 4) {  					int bytes = stream.Read (getbuf' 0' BUFSIZE);  					getbufOffset = 0;  					nbyteget += bytes;  				}  				gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  				getbufOffset += 4;  				nbyteget -= 4;  				nbin -= nbitget;  				nbitget = 32;  			}  		}  	}  	break;  case FN_QLPC:  	int nlpc = uvar_get (LPCQSIZE' stream);  	for (i = 0; i < nlpc; i++)  		var_get (LPCQUANT' stream);  	break;  }  
Magic Number,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,getSamples,The following statement contains a magic number: switch (cmd) {  case FN_ZERO:  	break;  case FN_DIFF0:  case FN_DIFF1:  case FN_DIFF2:  case FN_DIFF3:  	for (i = 0; i < blocksize; i++) {  		int nbin = resn + 1;  		if (nbitget == 0) {  			if (nbyteget < 4) {  				int bytes = stream.Read (getbuf' 0' BUFSIZE);  				getbufOffset = 0;  				nbyteget += bytes;  			}  			gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  			getbufOffset += 4;  			nbyteget -= 4;  			nbitget = 32;  		}  		while ((gbuffer & (1L << --nbitget)) == 0) {  			if (nbitget == 0) {  				if (nbyteget < 4) {  					int bytes = stream.Read (getbuf' 0' BUFSIZE);  					getbufOffset = 0;  					nbyteget += bytes;  				}  				gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  				getbufOffset += 4;  				nbyteget -= 4;  				nbitget = 32;  			}  		}  		while (nbin != 0) {  			if (nbitget >= nbin) {  				nbitget -= nbin;  				nbin = 0;  			} else {  				if (nbyteget < 4) {  					int bytes = stream.Read (getbuf' 0' BUFSIZE);  					getbufOffset = 0;  					nbyteget += bytes;  				}  				gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  				getbufOffset += 4;  				nbyteget -= 4;  				nbin -= nbitget;  				nbitget = 32;  			}  		}  	}  	break;  case FN_QLPC:  	int nlpc = uvar_get (LPCQSIZE' stream);  	for (i = 0; i < nlpc; i++)  		var_get (LPCQUANT' stream);  	break;  }  
Magic Number,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,getSamples,The following statement contains a magic number: switch (cmd) {  case FN_ZERO:  	break;  case FN_DIFF0:  case FN_DIFF1:  case FN_DIFF2:  case FN_DIFF3:  	for (i = 0; i < blocksize; i++) {  		int nbin = resn + 1;  		if (nbitget == 0) {  			if (nbyteget < 4) {  				int bytes = stream.Read (getbuf' 0' BUFSIZE);  				getbufOffset = 0;  				nbyteget += bytes;  			}  			gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  			getbufOffset += 4;  			nbyteget -= 4;  			nbitget = 32;  		}  		while ((gbuffer & (1L << --nbitget)) == 0) {  			if (nbitget == 0) {  				if (nbyteget < 4) {  					int bytes = stream.Read (getbuf' 0' BUFSIZE);  					getbufOffset = 0;  					nbyteget += bytes;  				}  				gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  				getbufOffset += 4;  				nbyteget -= 4;  				nbitget = 32;  			}  		}  		while (nbin != 0) {  			if (nbitget >= nbin) {  				nbitget -= nbin;  				nbin = 0;  			} else {  				if (nbyteget < 4) {  					int bytes = stream.Read (getbuf' 0' BUFSIZE);  					getbufOffset = 0;  					nbyteget += bytes;  				}  				gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  				getbufOffset += 4;  				nbyteget -= 4;  				nbin -= nbitget;  				nbitget = 32;  			}  		}  	}  	break;  case FN_QLPC:  	int nlpc = uvar_get (LPCQSIZE' stream);  	for (i = 0; i < nlpc; i++)  		var_get (LPCQUANT' stream);  	break;  }  
Magic Number,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,getSamples,The following statement contains a magic number: switch (cmd) {  case FN_ZERO:  	break;  case FN_DIFF0:  case FN_DIFF1:  case FN_DIFF2:  case FN_DIFF3:  	for (i = 0; i < blocksize; i++) {  		int nbin = resn + 1;  		if (nbitget == 0) {  			if (nbyteget < 4) {  				int bytes = stream.Read (getbuf' 0' BUFSIZE);  				getbufOffset = 0;  				nbyteget += bytes;  			}  			gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  			getbufOffset += 4;  			nbyteget -= 4;  			nbitget = 32;  		}  		while ((gbuffer & (1L << --nbitget)) == 0) {  			if (nbitget == 0) {  				if (nbyteget < 4) {  					int bytes = stream.Read (getbuf' 0' BUFSIZE);  					getbufOffset = 0;  					nbyteget += bytes;  				}  				gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  				getbufOffset += 4;  				nbyteget -= 4;  				nbitget = 32;  			}  		}  		while (nbin != 0) {  			if (nbitget >= nbin) {  				nbitget -= nbin;  				nbin = 0;  			} else {  				if (nbyteget < 4) {  					int bytes = stream.Read (getbuf' 0' BUFSIZE);  					getbufOffset = 0;  					nbyteget += bytes;  				}  				gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  				getbufOffset += 4;  				nbyteget -= 4;  				nbin -= nbitget;  				nbitget = 32;  			}  		}  	}  	break;  case FN_QLPC:  	int nlpc = uvar_get (LPCQSIZE' stream);  	for (i = 0; i < nlpc; i++)  		var_get (LPCQUANT' stream);  	break;  }  
Magic Number,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,getSamples,The following statement contains a magic number: switch (cmd) {  case FN_ZERO:  	break;  case FN_DIFF0:  case FN_DIFF1:  case FN_DIFF2:  case FN_DIFF3:  	for (i = 0; i < blocksize; i++) {  		int nbin = resn + 1;  		if (nbitget == 0) {  			if (nbyteget < 4) {  				int bytes = stream.Read (getbuf' 0' BUFSIZE);  				getbufOffset = 0;  				nbyteget += bytes;  			}  			gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  			getbufOffset += 4;  			nbyteget -= 4;  			nbitget = 32;  		}  		while ((gbuffer & (1L << --nbitget)) == 0) {  			if (nbitget == 0) {  				if (nbyteget < 4) {  					int bytes = stream.Read (getbuf' 0' BUFSIZE);  					getbufOffset = 0;  					nbyteget += bytes;  				}  				gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  				getbufOffset += 4;  				nbyteget -= 4;  				nbitget = 32;  			}  		}  		while (nbin != 0) {  			if (nbitget >= nbin) {  				nbitget -= nbin;  				nbin = 0;  			} else {  				if (nbyteget < 4) {  					int bytes = stream.Read (getbuf' 0' BUFSIZE);  					getbufOffset = 0;  					nbyteget += bytes;  				}  				gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  				getbufOffset += 4;  				nbyteget -= 4;  				nbin -= nbitget;  				nbitget = 32;  			}  		}  	}  	break;  case FN_QLPC:  	int nlpc = uvar_get (LPCQSIZE' stream);  	for (i = 0; i < nlpc; i++)  		var_get (LPCQUANT' stream);  	break;  }  
Magic Number,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,getSamples,The following statement contains a magic number: switch (cmd) {  case FN_ZERO:  	break;  case FN_DIFF0:  case FN_DIFF1:  case FN_DIFF2:  case FN_DIFF3:  	for (i = 0; i < blocksize; i++) {  		int nbin = resn + 1;  		if (nbitget == 0) {  			if (nbyteget < 4) {  				int bytes = stream.Read (getbuf' 0' BUFSIZE);  				getbufOffset = 0;  				nbyteget += bytes;  			}  			gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  			getbufOffset += 4;  			nbyteget -= 4;  			nbitget = 32;  		}  		while ((gbuffer & (1L << --nbitget)) == 0) {  			if (nbitget == 0) {  				if (nbyteget < 4) {  					int bytes = stream.Read (getbuf' 0' BUFSIZE);  					getbufOffset = 0;  					nbyteget += bytes;  				}  				gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  				getbufOffset += 4;  				nbyteget -= 4;  				nbitget = 32;  			}  		}  		while (nbin != 0) {  			if (nbitget >= nbin) {  				nbitget -= nbin;  				nbin = 0;  			} else {  				if (nbyteget < 4) {  					int bytes = stream.Read (getbuf' 0' BUFSIZE);  					getbufOffset = 0;  					nbyteget += bytes;  				}  				gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  				getbufOffset += 4;  				nbyteget -= 4;  				nbin -= nbitget;  				nbitget = 32;  			}  		}  	}  	break;  case FN_QLPC:  	int nlpc = uvar_get (LPCQSIZE' stream);  	for (i = 0; i < nlpc; i++)  		var_get (LPCQUANT' stream);  	break;  }  
Magic Number,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,getSamples,The following statement contains a magic number: switch (cmd) {  case FN_ZERO:  	break;  case FN_DIFF0:  case FN_DIFF1:  case FN_DIFF2:  case FN_DIFF3:  	for (i = 0; i < blocksize; i++) {  		int nbin = resn + 1;  		if (nbitget == 0) {  			if (nbyteget < 4) {  				int bytes = stream.Read (getbuf' 0' BUFSIZE);  				getbufOffset = 0;  				nbyteget += bytes;  			}  			gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  			getbufOffset += 4;  			nbyteget -= 4;  			nbitget = 32;  		}  		while ((gbuffer & (1L << --nbitget)) == 0) {  			if (nbitget == 0) {  				if (nbyteget < 4) {  					int bytes = stream.Read (getbuf' 0' BUFSIZE);  					getbufOffset = 0;  					nbyteget += bytes;  				}  				gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  				getbufOffset += 4;  				nbyteget -= 4;  				nbitget = 32;  			}  		}  		while (nbin != 0) {  			if (nbitget >= nbin) {  				nbitget -= nbin;  				nbin = 0;  			} else {  				if (nbyteget < 4) {  					int bytes = stream.Read (getbuf' 0' BUFSIZE);  					getbufOffset = 0;  					nbyteget += bytes;  				}  				gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  				getbufOffset += 4;  				nbyteget -= 4;  				nbin -= nbitget;  				nbitget = 32;  			}  		}  	}  	break;  case FN_QLPC:  	int nlpc = uvar_get (LPCQSIZE' stream);  	for (i = 0; i < nlpc; i++)  		var_get (LPCQUANT' stream);  	break;  }  
Magic Number,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,getSamples,The following statement contains a magic number: switch (cmd) {  case FN_ZERO:  	break;  case FN_DIFF0:  case FN_DIFF1:  case FN_DIFF2:  case FN_DIFF3:  	for (i = 0; i < blocksize; i++) {  		int nbin = resn + 1;  		if (nbitget == 0) {  			if (nbyteget < 4) {  				int bytes = stream.Read (getbuf' 0' BUFSIZE);  				getbufOffset = 0;  				nbyteget += bytes;  			}  			gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  			getbufOffset += 4;  			nbyteget -= 4;  			nbitget = 32;  		}  		while ((gbuffer & (1L << --nbitget)) == 0) {  			if (nbitget == 0) {  				if (nbyteget < 4) {  					int bytes = stream.Read (getbuf' 0' BUFSIZE);  					getbufOffset = 0;  					nbyteget += bytes;  				}  				gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  				getbufOffset += 4;  				nbyteget -= 4;  				nbitget = 32;  			}  		}  		while (nbin != 0) {  			if (nbitget >= nbin) {  				nbitget -= nbin;  				nbin = 0;  			} else {  				if (nbyteget < 4) {  					int bytes = stream.Read (getbuf' 0' BUFSIZE);  					getbufOffset = 0;  					nbyteget += bytes;  				}  				gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  				getbufOffset += 4;  				nbyteget -= 4;  				nbin -= nbitget;  				nbitget = 32;  			}  		}  	}  	break;  case FN_QLPC:  	int nlpc = uvar_get (LPCQSIZE' stream);  	for (i = 0; i < nlpc; i++)  		var_get (LPCQUANT' stream);  	break;  }  
Magic Number,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,getSamples,The following statement contains a magic number: switch (cmd) {  case FN_ZERO:  	break;  case FN_DIFF0:  case FN_DIFF1:  case FN_DIFF2:  case FN_DIFF3:  	for (i = 0; i < blocksize; i++) {  		int nbin = resn + 1;  		if (nbitget == 0) {  			if (nbyteget < 4) {  				int bytes = stream.Read (getbuf' 0' BUFSIZE);  				getbufOffset = 0;  				nbyteget += bytes;  			}  			gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  			getbufOffset += 4;  			nbyteget -= 4;  			nbitget = 32;  		}  		while ((gbuffer & (1L << --nbitget)) == 0) {  			if (nbitget == 0) {  				if (nbyteget < 4) {  					int bytes = stream.Read (getbuf' 0' BUFSIZE);  					getbufOffset = 0;  					nbyteget += bytes;  				}  				gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  				getbufOffset += 4;  				nbyteget -= 4;  				nbitget = 32;  			}  		}  		while (nbin != 0) {  			if (nbitget >= nbin) {  				nbitget -= nbin;  				nbin = 0;  			} else {  				if (nbyteget < 4) {  					int bytes = stream.Read (getbuf' 0' BUFSIZE);  					getbufOffset = 0;  					nbyteget += bytes;  				}  				gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  				getbufOffset += 4;  				nbyteget -= 4;  				nbin -= nbitget;  				nbitget = 32;  			}  		}  	}  	break;  case FN_QLPC:  	int nlpc = uvar_get (LPCQSIZE' stream);  	for (i = 0; i < nlpc; i++)  		var_get (LPCQUANT' stream);  	break;  }  
Magic Number,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,getSamples,The following statement contains a magic number: switch (cmd) {  case FN_ZERO:  	break;  case FN_DIFF0:  case FN_DIFF1:  case FN_DIFF2:  case FN_DIFF3:  	for (i = 0; i < blocksize; i++) {  		int nbin = resn + 1;  		if (nbitget == 0) {  			if (nbyteget < 4) {  				int bytes = stream.Read (getbuf' 0' BUFSIZE);  				getbufOffset = 0;  				nbyteget += bytes;  			}  			gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  			getbufOffset += 4;  			nbyteget -= 4;  			nbitget = 32;  		}  		while ((gbuffer & (1L << --nbitget)) == 0) {  			if (nbitget == 0) {  				if (nbyteget < 4) {  					int bytes = stream.Read (getbuf' 0' BUFSIZE);  					getbufOffset = 0;  					nbyteget += bytes;  				}  				gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  				getbufOffset += 4;  				nbyteget -= 4;  				nbitget = 32;  			}  		}  		while (nbin != 0) {  			if (nbitget >= nbin) {  				nbitget -= nbin;  				nbin = 0;  			} else {  				if (nbyteget < 4) {  					int bytes = stream.Read (getbuf' 0' BUFSIZE);  					getbufOffset = 0;  					nbyteget += bytes;  				}  				gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  				getbufOffset += 4;  				nbyteget -= 4;  				nbin -= nbitget;  				nbitget = 32;  			}  		}  	}  	break;  case FN_QLPC:  	int nlpc = uvar_get (LPCQSIZE' stream);  	for (i = 0; i < nlpc; i++)  		var_get (LPCQUANT' stream);  	break;  }  
Magic Number,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,getSamples,The following statement contains a magic number: switch (cmd) {  case FN_ZERO:  	break;  case FN_DIFF0:  case FN_DIFF1:  case FN_DIFF2:  case FN_DIFF3:  	for (i = 0; i < blocksize; i++) {  		int nbin = resn + 1;  		if (nbitget == 0) {  			if (nbyteget < 4) {  				int bytes = stream.Read (getbuf' 0' BUFSIZE);  				getbufOffset = 0;  				nbyteget += bytes;  			}  			gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  			getbufOffset += 4;  			nbyteget -= 4;  			nbitget = 32;  		}  		while ((gbuffer & (1L << --nbitget)) == 0) {  			if (nbitget == 0) {  				if (nbyteget < 4) {  					int bytes = stream.Read (getbuf' 0' BUFSIZE);  					getbufOffset = 0;  					nbyteget += bytes;  				}  				gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  				getbufOffset += 4;  				nbyteget -= 4;  				nbitget = 32;  			}  		}  		while (nbin != 0) {  			if (nbitget >= nbin) {  				nbitget -= nbin;  				nbin = 0;  			} else {  				if (nbyteget < 4) {  					int bytes = stream.Read (getbuf' 0' BUFSIZE);  					getbufOffset = 0;  					nbyteget += bytes;  				}  				gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  				getbufOffset += 4;  				nbyteget -= 4;  				nbin -= nbitget;  				nbitget = 32;  			}  		}  	}  	break;  case FN_QLPC:  	int nlpc = uvar_get (LPCQSIZE' stream);  	for (i = 0; i < nlpc; i++)  		var_get (LPCQUANT' stream);  	break;  }  
Magic Number,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,getSamples,The following statement contains a magic number: switch (cmd) {  case FN_ZERO:  	break;  case FN_DIFF0:  case FN_DIFF1:  case FN_DIFF2:  case FN_DIFF3:  	for (i = 0; i < blocksize; i++) {  		int nbin = resn + 1;  		if (nbitget == 0) {  			if (nbyteget < 4) {  				int bytes = stream.Read (getbuf' 0' BUFSIZE);  				getbufOffset = 0;  				nbyteget += bytes;  			}  			gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  			getbufOffset += 4;  			nbyteget -= 4;  			nbitget = 32;  		}  		while ((gbuffer & (1L << --nbitget)) == 0) {  			if (nbitget == 0) {  				if (nbyteget < 4) {  					int bytes = stream.Read (getbuf' 0' BUFSIZE);  					getbufOffset = 0;  					nbyteget += bytes;  				}  				gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  				getbufOffset += 4;  				nbyteget -= 4;  				nbitget = 32;  			}  		}  		while (nbin != 0) {  			if (nbitget >= nbin) {  				nbitget -= nbin;  				nbin = 0;  			} else {  				if (nbyteget < 4) {  					int bytes = stream.Read (getbuf' 0' BUFSIZE);  					getbufOffset = 0;  					nbyteget += bytes;  				}  				gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  				getbufOffset += 4;  				nbyteget -= 4;  				nbin -= nbitget;  				nbitget = 32;  			}  		}  	}  	break;  case FN_QLPC:  	int nlpc = uvar_get (LPCQSIZE' stream);  	for (i = 0; i < nlpc; i++)  		var_get (LPCQUANT' stream);  	break;  }  
Magic Number,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,getSamples,The following statement contains a magic number: switch (cmd) {  case FN_ZERO:  	break;  case FN_DIFF0:  case FN_DIFF1:  case FN_DIFF2:  case FN_DIFF3:  	for (i = 0; i < blocksize; i++) {  		int nbin = resn + 1;  		if (nbitget == 0) {  			if (nbyteget < 4) {  				int bytes = stream.Read (getbuf' 0' BUFSIZE);  				getbufOffset = 0;  				nbyteget += bytes;  			}  			gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  			getbufOffset += 4;  			nbyteget -= 4;  			nbitget = 32;  		}  		while ((gbuffer & (1L << --nbitget)) == 0) {  			if (nbitget == 0) {  				if (nbyteget < 4) {  					int bytes = stream.Read (getbuf' 0' BUFSIZE);  					getbufOffset = 0;  					nbyteget += bytes;  				}  				gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  				getbufOffset += 4;  				nbyteget -= 4;  				nbitget = 32;  			}  		}  		while (nbin != 0) {  			if (nbitget >= nbin) {  				nbitget -= nbin;  				nbin = 0;  			} else {  				if (nbyteget < 4) {  					int bytes = stream.Read (getbuf' 0' BUFSIZE);  					getbufOffset = 0;  					nbyteget += bytes;  				}  				gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  				getbufOffset += 4;  				nbyteget -= 4;  				nbin -= nbitget;  				nbitget = 32;  			}  		}  	}  	break;  case FN_QLPC:  	int nlpc = uvar_get (LPCQSIZE' stream);  	for (i = 0; i < nlpc; i++)  		var_get (LPCQUANT' stream);  	break;  }  
Magic Number,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,getSamples,The following statement contains a magic number: switch (cmd) {  case FN_ZERO:  	break;  case FN_DIFF0:  case FN_DIFF1:  case FN_DIFF2:  case FN_DIFF3:  	for (i = 0; i < blocksize; i++) {  		int nbin = resn + 1;  		if (nbitget == 0) {  			if (nbyteget < 4) {  				int bytes = stream.Read (getbuf' 0' BUFSIZE);  				getbufOffset = 0;  				nbyteget += bytes;  			}  			gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  			getbufOffset += 4;  			nbyteget -= 4;  			nbitget = 32;  		}  		while ((gbuffer & (1L << --nbitget)) == 0) {  			if (nbitget == 0) {  				if (nbyteget < 4) {  					int bytes = stream.Read (getbuf' 0' BUFSIZE);  					getbufOffset = 0;  					nbyteget += bytes;  				}  				gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  				getbufOffset += 4;  				nbyteget -= 4;  				nbitget = 32;  			}  		}  		while (nbin != 0) {  			if (nbitget >= nbin) {  				nbitget -= nbin;  				nbin = 0;  			} else {  				if (nbyteget < 4) {  					int bytes = stream.Read (getbuf' 0' BUFSIZE);  					getbufOffset = 0;  					nbyteget += bytes;  				}  				gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  				getbufOffset += 4;  				nbyteget -= 4;  				nbin -= nbitget;  				nbitget = 32;  			}  		}  	}  	break;  case FN_QLPC:  	int nlpc = uvar_get (LPCQSIZE' stream);  	for (i = 0; i < nlpc; i++)  		var_get (LPCQUANT' stream);  	break;  }  
Magic Number,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,getSamples,The following statement contains a magic number: switch (cmd) {  case FN_ZERO:  	break;  case FN_DIFF0:  case FN_DIFF1:  case FN_DIFF2:  case FN_DIFF3:  	for (i = 0; i < blocksize; i++) {  		int nbin = resn + 1;  		if (nbitget == 0) {  			if (nbyteget < 4) {  				int bytes = stream.Read (getbuf' 0' BUFSIZE);  				getbufOffset = 0;  				nbyteget += bytes;  			}  			gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  			getbufOffset += 4;  			nbyteget -= 4;  			nbitget = 32;  		}  		while ((gbuffer & (1L << --nbitget)) == 0) {  			if (nbitget == 0) {  				if (nbyteget < 4) {  					int bytes = stream.Read (getbuf' 0' BUFSIZE);  					getbufOffset = 0;  					nbyteget += bytes;  				}  				gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  				getbufOffset += 4;  				nbyteget -= 4;  				nbitget = 32;  			}  		}  		while (nbin != 0) {  			if (nbitget >= nbin) {  				nbitget -= nbin;  				nbin = 0;  			} else {  				if (nbyteget < 4) {  					int bytes = stream.Read (getbuf' 0' BUFSIZE);  					getbufOffset = 0;  					nbyteget += bytes;  				}  				gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  				getbufOffset += 4;  				nbyteget -= 4;  				nbin -= nbitget;  				nbitget = 32;  			}  		}  	}  	break;  case FN_QLPC:  	int nlpc = uvar_get (LPCQSIZE' stream);  	for (i = 0; i < nlpc; i++)  		var_get (LPCQUANT' stream);  	break;  }  
Magic Number,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,getSamples,The following statement contains a magic number: switch (cmd) {  case FN_ZERO:  	break;  case FN_DIFF0:  case FN_DIFF1:  case FN_DIFF2:  case FN_DIFF3:  	for (i = 0; i < blocksize; i++) {  		int nbin = resn + 1;  		if (nbitget == 0) {  			if (nbyteget < 4) {  				int bytes = stream.Read (getbuf' 0' BUFSIZE);  				getbufOffset = 0;  				nbyteget += bytes;  			}  			gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  			getbufOffset += 4;  			nbyteget -= 4;  			nbitget = 32;  		}  		while ((gbuffer & (1L << --nbitget)) == 0) {  			if (nbitget == 0) {  				if (nbyteget < 4) {  					int bytes = stream.Read (getbuf' 0' BUFSIZE);  					getbufOffset = 0;  					nbyteget += bytes;  				}  				gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  				getbufOffset += 4;  				nbyteget -= 4;  				nbitget = 32;  			}  		}  		while (nbin != 0) {  			if (nbitget >= nbin) {  				nbitget -= nbin;  				nbin = 0;  			} else {  				if (nbyteget < 4) {  					int bytes = stream.Read (getbuf' 0' BUFSIZE);  					getbufOffset = 0;  					nbyteget += bytes;  				}  				gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  				getbufOffset += 4;  				nbyteget -= 4;  				nbin -= nbitget;  				nbitget = 32;  			}  		}  	}  	break;  case FN_QLPC:  	int nlpc = uvar_get (LPCQSIZE' stream);  	for (i = 0; i < nlpc; i++)  		var_get (LPCQUANT' stream);  	break;  }  
Magic Number,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,getSamples,The following statement contains a magic number: switch (cmd) {  case FN_ZERO:  	break;  case FN_DIFF0:  case FN_DIFF1:  case FN_DIFF2:  case FN_DIFF3:  	for (i = 0; i < blocksize; i++) {  		int nbin = resn + 1;  		if (nbitget == 0) {  			if (nbyteget < 4) {  				int bytes = stream.Read (getbuf' 0' BUFSIZE);  				getbufOffset = 0;  				nbyteget += bytes;  			}  			gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  			getbufOffset += 4;  			nbyteget -= 4;  			nbitget = 32;  		}  		while ((gbuffer & (1L << --nbitget)) == 0) {  			if (nbitget == 0) {  				if (nbyteget < 4) {  					int bytes = stream.Read (getbuf' 0' BUFSIZE);  					getbufOffset = 0;  					nbyteget += bytes;  				}  				gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  				getbufOffset += 4;  				nbyteget -= 4;  				nbitget = 32;  			}  		}  		while (nbin != 0) {  			if (nbitget >= nbin) {  				nbitget -= nbin;  				nbin = 0;  			} else {  				if (nbyteget < 4) {  					int bytes = stream.Read (getbuf' 0' BUFSIZE);  					getbufOffset = 0;  					nbyteget += bytes;  				}  				gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  				getbufOffset += 4;  				nbyteget -= 4;  				nbin -= nbitget;  				nbitget = 32;  			}  		}  	}  	break;  case FN_QLPC:  	int nlpc = uvar_get (LPCQSIZE' stream);  	for (i = 0; i < nlpc; i++)  		var_get (LPCQUANT' stream);  	break;  }  
Magic Number,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,getSamples,The following statement contains a magic number: switch (cmd) {  case FN_ZERO:  	break;  case FN_DIFF0:  case FN_DIFF1:  case FN_DIFF2:  case FN_DIFF3:  	for (i = 0; i < blocksize; i++) {  		int nbin = resn + 1;  		if (nbitget == 0) {  			if (nbyteget < 4) {  				int bytes = stream.Read (getbuf' 0' BUFSIZE);  				getbufOffset = 0;  				nbyteget += bytes;  			}  			gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  			getbufOffset += 4;  			nbyteget -= 4;  			nbitget = 32;  		}  		while ((gbuffer & (1L << --nbitget)) == 0) {  			if (nbitget == 0) {  				if (nbyteget < 4) {  					int bytes = stream.Read (getbuf' 0' BUFSIZE);  					getbufOffset = 0;  					nbyteget += bytes;  				}  				gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  				getbufOffset += 4;  				nbyteget -= 4;  				nbitget = 32;  			}  		}  		while (nbin != 0) {  			if (nbitget >= nbin) {  				nbitget -= nbin;  				nbin = 0;  			} else {  				if (nbyteget < 4) {  					int bytes = stream.Read (getbuf' 0' BUFSIZE);  					getbufOffset = 0;  					nbyteget += bytes;  				}  				gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  				getbufOffset += 4;  				nbyteget -= 4;  				nbin -= nbitget;  				nbitget = 32;  			}  		}  	}  	break;  case FN_QLPC:  	int nlpc = uvar_get (LPCQSIZE' stream);  	for (i = 0; i < nlpc; i++)  		var_get (LPCQUANT' stream);  	break;  }  
Magic Number,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,getSamples,The following statement contains a magic number: switch (cmd) {  case FN_ZERO:  	break;  case FN_DIFF0:  case FN_DIFF1:  case FN_DIFF2:  case FN_DIFF3:  	for (i = 0; i < blocksize; i++) {  		int nbin = resn + 1;  		if (nbitget == 0) {  			if (nbyteget < 4) {  				int bytes = stream.Read (getbuf' 0' BUFSIZE);  				getbufOffset = 0;  				nbyteget += bytes;  			}  			gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  			getbufOffset += 4;  			nbyteget -= 4;  			nbitget = 32;  		}  		while ((gbuffer & (1L << --nbitget)) == 0) {  			if (nbitget == 0) {  				if (nbyteget < 4) {  					int bytes = stream.Read (getbuf' 0' BUFSIZE);  					getbufOffset = 0;  					nbyteget += bytes;  				}  				gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  				getbufOffset += 4;  				nbyteget -= 4;  				nbitget = 32;  			}  		}  		while (nbin != 0) {  			if (nbitget >= nbin) {  				nbitget -= nbin;  				nbin = 0;  			} else {  				if (nbyteget < 4) {  					int bytes = stream.Read (getbuf' 0' BUFSIZE);  					getbufOffset = 0;  					nbyteget += bytes;  				}  				gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  				getbufOffset += 4;  				nbyteget -= 4;  				nbin -= nbitget;  				nbitget = 32;  			}  		}  	}  	break;  case FN_QLPC:  	int nlpc = uvar_get (LPCQSIZE' stream);  	for (i = 0; i < nlpc; i++)  		var_get (LPCQUANT' stream);  	break;  }  
Magic Number,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,getSamples,The following statement contains a magic number: switch (cmd) {  case FN_ZERO:  	break;  case FN_DIFF0:  case FN_DIFF1:  case FN_DIFF2:  case FN_DIFF3:  	for (i = 0; i < blocksize; i++) {  		int nbin = resn + 1;  		if (nbitget == 0) {  			if (nbyteget < 4) {  				int bytes = stream.Read (getbuf' 0' BUFSIZE);  				getbufOffset = 0;  				nbyteget += bytes;  			}  			gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  			getbufOffset += 4;  			nbyteget -= 4;  			nbitget = 32;  		}  		while ((gbuffer & (1L << --nbitget)) == 0) {  			if (nbitget == 0) {  				if (nbyteget < 4) {  					int bytes = stream.Read (getbuf' 0' BUFSIZE);  					getbufOffset = 0;  					nbyteget += bytes;  				}  				gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  				getbufOffset += 4;  				nbyteget -= 4;  				nbitget = 32;  			}  		}  		while (nbin != 0) {  			if (nbitget >= nbin) {  				nbitget -= nbin;  				nbin = 0;  			} else {  				if (nbyteget < 4) {  					int bytes = stream.Read (getbuf' 0' BUFSIZE);  					getbufOffset = 0;  					nbyteget += bytes;  				}  				gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  				getbufOffset += 4;  				nbyteget -= 4;  				nbin -= nbitget;  				nbitget = 32;  			}  		}  	}  	break;  case FN_QLPC:  	int nlpc = uvar_get (LPCQSIZE' stream);  	for (i = 0; i < nlpc; i++)  		var_get (LPCQUANT' stream);  	break;  }  
Magic Number,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,getSamples,The following statement contains a magic number: switch (cmd) {  case FN_ZERO:  	break;  case FN_DIFF0:  case FN_DIFF1:  case FN_DIFF2:  case FN_DIFF3:  	for (i = 0; i < blocksize; i++) {  		int nbin = resn + 1;  		if (nbitget == 0) {  			if (nbyteget < 4) {  				int bytes = stream.Read (getbuf' 0' BUFSIZE);  				getbufOffset = 0;  				nbyteget += bytes;  			}  			gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  			getbufOffset += 4;  			nbyteget -= 4;  			nbitget = 32;  		}  		while ((gbuffer & (1L << --nbitget)) == 0) {  			if (nbitget == 0) {  				if (nbyteget < 4) {  					int bytes = stream.Read (getbuf' 0' BUFSIZE);  					getbufOffset = 0;  					nbyteget += bytes;  				}  				gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  				getbufOffset += 4;  				nbyteget -= 4;  				nbitget = 32;  			}  		}  		while (nbin != 0) {  			if (nbitget >= nbin) {  				nbitget -= nbin;  				nbin = 0;  			} else {  				if (nbyteget < 4) {  					int bytes = stream.Read (getbuf' 0' BUFSIZE);  					getbufOffset = 0;  					nbyteget += bytes;  				}  				gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  				getbufOffset += 4;  				nbyteget -= 4;  				nbin -= nbitget;  				nbitget = 32;  			}  		}  	}  	break;  case FN_QLPC:  	int nlpc = uvar_get (LPCQSIZE' stream);  	for (i = 0; i < nlpc; i++)  		var_get (LPCQUANT' stream);  	break;  }  
Magic Number,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,getSamples,The following statement contains a magic number: for (i = 0; i < blocksize; i++) {  	int nbin = resn + 1;  	if (nbitget == 0) {  		if (nbyteget < 4) {  			int bytes = stream.Read (getbuf' 0' BUFSIZE);  			getbufOffset = 0;  			nbyteget += bytes;  		}  		gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  		getbufOffset += 4;  		nbyteget -= 4;  		nbitget = 32;  	}  	while ((gbuffer & (1L << --nbitget)) == 0) {  		if (nbitget == 0) {  			if (nbyteget < 4) {  				int bytes = stream.Read (getbuf' 0' BUFSIZE);  				getbufOffset = 0;  				nbyteget += bytes;  			}  			gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  			getbufOffset += 4;  			nbyteget -= 4;  			nbitget = 32;  		}  	}  	while (nbin != 0) {  		if (nbitget >= nbin) {  			nbitget -= nbin;  			nbin = 0;  		} else {  			if (nbyteget < 4) {  				int bytes = stream.Read (getbuf' 0' BUFSIZE);  				getbufOffset = 0;  				nbyteget += bytes;  			}  			gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  			getbufOffset += 4;  			nbyteget -= 4;  			nbin -= nbitget;  			nbitget = 32;  		}  	}  }  
Magic Number,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,getSamples,The following statement contains a magic number: for (i = 0; i < blocksize; i++) {  	int nbin = resn + 1;  	if (nbitget == 0) {  		if (nbyteget < 4) {  			int bytes = stream.Read (getbuf' 0' BUFSIZE);  			getbufOffset = 0;  			nbyteget += bytes;  		}  		gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  		getbufOffset += 4;  		nbyteget -= 4;  		nbitget = 32;  	}  	while ((gbuffer & (1L << --nbitget)) == 0) {  		if (nbitget == 0) {  			if (nbyteget < 4) {  				int bytes = stream.Read (getbuf' 0' BUFSIZE);  				getbufOffset = 0;  				nbyteget += bytes;  			}  			gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  			getbufOffset += 4;  			nbyteget -= 4;  			nbitget = 32;  		}  	}  	while (nbin != 0) {  		if (nbitget >= nbin) {  			nbitget -= nbin;  			nbin = 0;  		} else {  			if (nbyteget < 4) {  				int bytes = stream.Read (getbuf' 0' BUFSIZE);  				getbufOffset = 0;  				nbyteget += bytes;  			}  			gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  			getbufOffset += 4;  			nbyteget -= 4;  			nbin -= nbitget;  			nbitget = 32;  		}  	}  }  
Magic Number,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,getSamples,The following statement contains a magic number: for (i = 0; i < blocksize; i++) {  	int nbin = resn + 1;  	if (nbitget == 0) {  		if (nbyteget < 4) {  			int bytes = stream.Read (getbuf' 0' BUFSIZE);  			getbufOffset = 0;  			nbyteget += bytes;  		}  		gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  		getbufOffset += 4;  		nbyteget -= 4;  		nbitget = 32;  	}  	while ((gbuffer & (1L << --nbitget)) == 0) {  		if (nbitget == 0) {  			if (nbyteget < 4) {  				int bytes = stream.Read (getbuf' 0' BUFSIZE);  				getbufOffset = 0;  				nbyteget += bytes;  			}  			gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  			getbufOffset += 4;  			nbyteget -= 4;  			nbitget = 32;  		}  	}  	while (nbin != 0) {  		if (nbitget >= nbin) {  			nbitget -= nbin;  			nbin = 0;  		} else {  			if (nbyteget < 4) {  				int bytes = stream.Read (getbuf' 0' BUFSIZE);  				getbufOffset = 0;  				nbyteget += bytes;  			}  			gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  			getbufOffset += 4;  			nbyteget -= 4;  			nbin -= nbitget;  			nbitget = 32;  		}  	}  }  
Magic Number,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,getSamples,The following statement contains a magic number: for (i = 0; i < blocksize; i++) {  	int nbin = resn + 1;  	if (nbitget == 0) {  		if (nbyteget < 4) {  			int bytes = stream.Read (getbuf' 0' BUFSIZE);  			getbufOffset = 0;  			nbyteget += bytes;  		}  		gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  		getbufOffset += 4;  		nbyteget -= 4;  		nbitget = 32;  	}  	while ((gbuffer & (1L << --nbitget)) == 0) {  		if (nbitget == 0) {  			if (nbyteget < 4) {  				int bytes = stream.Read (getbuf' 0' BUFSIZE);  				getbufOffset = 0;  				nbyteget += bytes;  			}  			gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  			getbufOffset += 4;  			nbyteget -= 4;  			nbitget = 32;  		}  	}  	while (nbin != 0) {  		if (nbitget >= nbin) {  			nbitget -= nbin;  			nbin = 0;  		} else {  			if (nbyteget < 4) {  				int bytes = stream.Read (getbuf' 0' BUFSIZE);  				getbufOffset = 0;  				nbyteget += bytes;  			}  			gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  			getbufOffset += 4;  			nbyteget -= 4;  			nbin -= nbitget;  			nbitget = 32;  		}  	}  }  
Magic Number,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,getSamples,The following statement contains a magic number: for (i = 0; i < blocksize; i++) {  	int nbin = resn + 1;  	if (nbitget == 0) {  		if (nbyteget < 4) {  			int bytes = stream.Read (getbuf' 0' BUFSIZE);  			getbufOffset = 0;  			nbyteget += bytes;  		}  		gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  		getbufOffset += 4;  		nbyteget -= 4;  		nbitget = 32;  	}  	while ((gbuffer & (1L << --nbitget)) == 0) {  		if (nbitget == 0) {  			if (nbyteget < 4) {  				int bytes = stream.Read (getbuf' 0' BUFSIZE);  				getbufOffset = 0;  				nbyteget += bytes;  			}  			gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  			getbufOffset += 4;  			nbyteget -= 4;  			nbitget = 32;  		}  	}  	while (nbin != 0) {  		if (nbitget >= nbin) {  			nbitget -= nbin;  			nbin = 0;  		} else {  			if (nbyteget < 4) {  				int bytes = stream.Read (getbuf' 0' BUFSIZE);  				getbufOffset = 0;  				nbyteget += bytes;  			}  			gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  			getbufOffset += 4;  			nbyteget -= 4;  			nbin -= nbitget;  			nbitget = 32;  		}  	}  }  
Magic Number,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,getSamples,The following statement contains a magic number: for (i = 0; i < blocksize; i++) {  	int nbin = resn + 1;  	if (nbitget == 0) {  		if (nbyteget < 4) {  			int bytes = stream.Read (getbuf' 0' BUFSIZE);  			getbufOffset = 0;  			nbyteget += bytes;  		}  		gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  		getbufOffset += 4;  		nbyteget -= 4;  		nbitget = 32;  	}  	while ((gbuffer & (1L << --nbitget)) == 0) {  		if (nbitget == 0) {  			if (nbyteget < 4) {  				int bytes = stream.Read (getbuf' 0' BUFSIZE);  				getbufOffset = 0;  				nbyteget += bytes;  			}  			gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  			getbufOffset += 4;  			nbyteget -= 4;  			nbitget = 32;  		}  	}  	while (nbin != 0) {  		if (nbitget >= nbin) {  			nbitget -= nbin;  			nbin = 0;  		} else {  			if (nbyteget < 4) {  				int bytes = stream.Read (getbuf' 0' BUFSIZE);  				getbufOffset = 0;  				nbyteget += bytes;  			}  			gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  			getbufOffset += 4;  			nbyteget -= 4;  			nbin -= nbitget;  			nbitget = 32;  		}  	}  }  
Magic Number,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,getSamples,The following statement contains a magic number: for (i = 0; i < blocksize; i++) {  	int nbin = resn + 1;  	if (nbitget == 0) {  		if (nbyteget < 4) {  			int bytes = stream.Read (getbuf' 0' BUFSIZE);  			getbufOffset = 0;  			nbyteget += bytes;  		}  		gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  		getbufOffset += 4;  		nbyteget -= 4;  		nbitget = 32;  	}  	while ((gbuffer & (1L << --nbitget)) == 0) {  		if (nbitget == 0) {  			if (nbyteget < 4) {  				int bytes = stream.Read (getbuf' 0' BUFSIZE);  				getbufOffset = 0;  				nbyteget += bytes;  			}  			gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  			getbufOffset += 4;  			nbyteget -= 4;  			nbitget = 32;  		}  	}  	while (nbin != 0) {  		if (nbitget >= nbin) {  			nbitget -= nbin;  			nbin = 0;  		} else {  			if (nbyteget < 4) {  				int bytes = stream.Read (getbuf' 0' BUFSIZE);  				getbufOffset = 0;  				nbyteget += bytes;  			}  			gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  			getbufOffset += 4;  			nbyteget -= 4;  			nbin -= nbitget;  			nbitget = 32;  		}  	}  }  
Magic Number,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,getSamples,The following statement contains a magic number: for (i = 0; i < blocksize; i++) {  	int nbin = resn + 1;  	if (nbitget == 0) {  		if (nbyteget < 4) {  			int bytes = stream.Read (getbuf' 0' BUFSIZE);  			getbufOffset = 0;  			nbyteget += bytes;  		}  		gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  		getbufOffset += 4;  		nbyteget -= 4;  		nbitget = 32;  	}  	while ((gbuffer & (1L << --nbitget)) == 0) {  		if (nbitget == 0) {  			if (nbyteget < 4) {  				int bytes = stream.Read (getbuf' 0' BUFSIZE);  				getbufOffset = 0;  				nbyteget += bytes;  			}  			gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  			getbufOffset += 4;  			nbyteget -= 4;  			nbitget = 32;  		}  	}  	while (nbin != 0) {  		if (nbitget >= nbin) {  			nbitget -= nbin;  			nbin = 0;  		} else {  			if (nbyteget < 4) {  				int bytes = stream.Read (getbuf' 0' BUFSIZE);  				getbufOffset = 0;  				nbyteget += bytes;  			}  			gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  			getbufOffset += 4;  			nbyteget -= 4;  			nbin -= nbitget;  			nbitget = 32;  		}  	}  }  
Magic Number,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,getSamples,The following statement contains a magic number: for (i = 0; i < blocksize; i++) {  	int nbin = resn + 1;  	if (nbitget == 0) {  		if (nbyteget < 4) {  			int bytes = stream.Read (getbuf' 0' BUFSIZE);  			getbufOffset = 0;  			nbyteget += bytes;  		}  		gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  		getbufOffset += 4;  		nbyteget -= 4;  		nbitget = 32;  	}  	while ((gbuffer & (1L << --nbitget)) == 0) {  		if (nbitget == 0) {  			if (nbyteget < 4) {  				int bytes = stream.Read (getbuf' 0' BUFSIZE);  				getbufOffset = 0;  				nbyteget += bytes;  			}  			gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  			getbufOffset += 4;  			nbyteget -= 4;  			nbitget = 32;  		}  	}  	while (nbin != 0) {  		if (nbitget >= nbin) {  			nbitget -= nbin;  			nbin = 0;  		} else {  			if (nbyteget < 4) {  				int bytes = stream.Read (getbuf' 0' BUFSIZE);  				getbufOffset = 0;  				nbyteget += bytes;  			}  			gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  			getbufOffset += 4;  			nbyteget -= 4;  			nbin -= nbitget;  			nbitget = 32;  		}  	}  }  
Magic Number,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,getSamples,The following statement contains a magic number: for (i = 0; i < blocksize; i++) {  	int nbin = resn + 1;  	if (nbitget == 0) {  		if (nbyteget < 4) {  			int bytes = stream.Read (getbuf' 0' BUFSIZE);  			getbufOffset = 0;  			nbyteget += bytes;  		}  		gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  		getbufOffset += 4;  		nbyteget -= 4;  		nbitget = 32;  	}  	while ((gbuffer & (1L << --nbitget)) == 0) {  		if (nbitget == 0) {  			if (nbyteget < 4) {  				int bytes = stream.Read (getbuf' 0' BUFSIZE);  				getbufOffset = 0;  				nbyteget += bytes;  			}  			gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  			getbufOffset += 4;  			nbyteget -= 4;  			nbitget = 32;  		}  	}  	while (nbin != 0) {  		if (nbitget >= nbin) {  			nbitget -= nbin;  			nbin = 0;  		} else {  			if (nbyteget < 4) {  				int bytes = stream.Read (getbuf' 0' BUFSIZE);  				getbufOffset = 0;  				nbyteget += bytes;  			}  			gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  			getbufOffset += 4;  			nbyteget -= 4;  			nbin -= nbitget;  			nbitget = 32;  		}  	}  }  
Magic Number,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,getSamples,The following statement contains a magic number: for (i = 0; i < blocksize; i++) {  	int nbin = resn + 1;  	if (nbitget == 0) {  		if (nbyteget < 4) {  			int bytes = stream.Read (getbuf' 0' BUFSIZE);  			getbufOffset = 0;  			nbyteget += bytes;  		}  		gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  		getbufOffset += 4;  		nbyteget -= 4;  		nbitget = 32;  	}  	while ((gbuffer & (1L << --nbitget)) == 0) {  		if (nbitget == 0) {  			if (nbyteget < 4) {  				int bytes = stream.Read (getbuf' 0' BUFSIZE);  				getbufOffset = 0;  				nbyteget += bytes;  			}  			gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  			getbufOffset += 4;  			nbyteget -= 4;  			nbitget = 32;  		}  	}  	while (nbin != 0) {  		if (nbitget >= nbin) {  			nbitget -= nbin;  			nbin = 0;  		} else {  			if (nbyteget < 4) {  				int bytes = stream.Read (getbuf' 0' BUFSIZE);  				getbufOffset = 0;  				nbyteget += bytes;  			}  			gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  			getbufOffset += 4;  			nbyteget -= 4;  			nbin -= nbitget;  			nbitget = 32;  		}  	}  }  
Magic Number,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,getSamples,The following statement contains a magic number: for (i = 0; i < blocksize; i++) {  	int nbin = resn + 1;  	if (nbitget == 0) {  		if (nbyteget < 4) {  			int bytes = stream.Read (getbuf' 0' BUFSIZE);  			getbufOffset = 0;  			nbyteget += bytes;  		}  		gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  		getbufOffset += 4;  		nbyteget -= 4;  		nbitget = 32;  	}  	while ((gbuffer & (1L << --nbitget)) == 0) {  		if (nbitget == 0) {  			if (nbyteget < 4) {  				int bytes = stream.Read (getbuf' 0' BUFSIZE);  				getbufOffset = 0;  				nbyteget += bytes;  			}  			gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  			getbufOffset += 4;  			nbyteget -= 4;  			nbitget = 32;  		}  	}  	while (nbin != 0) {  		if (nbitget >= nbin) {  			nbitget -= nbin;  			nbin = 0;  		} else {  			if (nbyteget < 4) {  				int bytes = stream.Read (getbuf' 0' BUFSIZE);  				getbufOffset = 0;  				nbyteget += bytes;  			}  			gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  			getbufOffset += 4;  			nbyteget -= 4;  			nbin -= nbitget;  			nbitget = 32;  		}  	}  }  
Magic Number,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,getSamples,The following statement contains a magic number: for (i = 0; i < blocksize; i++) {  	int nbin = resn + 1;  	if (nbitget == 0) {  		if (nbyteget < 4) {  			int bytes = stream.Read (getbuf' 0' BUFSIZE);  			getbufOffset = 0;  			nbyteget += bytes;  		}  		gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  		getbufOffset += 4;  		nbyteget -= 4;  		nbitget = 32;  	}  	while ((gbuffer & (1L << --nbitget)) == 0) {  		if (nbitget == 0) {  			if (nbyteget < 4) {  				int bytes = stream.Read (getbuf' 0' BUFSIZE);  				getbufOffset = 0;  				nbyteget += bytes;  			}  			gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  			getbufOffset += 4;  			nbyteget -= 4;  			nbitget = 32;  		}  	}  	while (nbin != 0) {  		if (nbitget >= nbin) {  			nbitget -= nbin;  			nbin = 0;  		} else {  			if (nbyteget < 4) {  				int bytes = stream.Read (getbuf' 0' BUFSIZE);  				getbufOffset = 0;  				nbyteget += bytes;  			}  			gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  			getbufOffset += 4;  			nbyteget -= 4;  			nbin -= nbitget;  			nbitget = 32;  		}  	}  }  
Magic Number,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,getSamples,The following statement contains a magic number: for (i = 0; i < blocksize; i++) {  	int nbin = resn + 1;  	if (nbitget == 0) {  		if (nbyteget < 4) {  			int bytes = stream.Read (getbuf' 0' BUFSIZE);  			getbufOffset = 0;  			nbyteget += bytes;  		}  		gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  		getbufOffset += 4;  		nbyteget -= 4;  		nbitget = 32;  	}  	while ((gbuffer & (1L << --nbitget)) == 0) {  		if (nbitget == 0) {  			if (nbyteget < 4) {  				int bytes = stream.Read (getbuf' 0' BUFSIZE);  				getbufOffset = 0;  				nbyteget += bytes;  			}  			gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  			getbufOffset += 4;  			nbyteget -= 4;  			nbitget = 32;  		}  	}  	while (nbin != 0) {  		if (nbitget >= nbin) {  			nbitget -= nbin;  			nbin = 0;  		} else {  			if (nbyteget < 4) {  				int bytes = stream.Read (getbuf' 0' BUFSIZE);  				getbufOffset = 0;  				nbyteget += bytes;  			}  			gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  			getbufOffset += 4;  			nbyteget -= 4;  			nbin -= nbitget;  			nbitget = 32;  		}  	}  }  
Magic Number,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,getSamples,The following statement contains a magic number: for (i = 0; i < blocksize; i++) {  	int nbin = resn + 1;  	if (nbitget == 0) {  		if (nbyteget < 4) {  			int bytes = stream.Read (getbuf' 0' BUFSIZE);  			getbufOffset = 0;  			nbyteget += bytes;  		}  		gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  		getbufOffset += 4;  		nbyteget -= 4;  		nbitget = 32;  	}  	while ((gbuffer & (1L << --nbitget)) == 0) {  		if (nbitget == 0) {  			if (nbyteget < 4) {  				int bytes = stream.Read (getbuf' 0' BUFSIZE);  				getbufOffset = 0;  				nbyteget += bytes;  			}  			gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  			getbufOffset += 4;  			nbyteget -= 4;  			nbitget = 32;  		}  	}  	while (nbin != 0) {  		if (nbitget >= nbin) {  			nbitget -= nbin;  			nbin = 0;  		} else {  			if (nbyteget < 4) {  				int bytes = stream.Read (getbuf' 0' BUFSIZE);  				getbufOffset = 0;  				nbyteget += bytes;  			}  			gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  			getbufOffset += 4;  			nbyteget -= 4;  			nbin -= nbitget;  			nbitget = 32;  		}  	}  }  
Magic Number,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,getSamples,The following statement contains a magic number: for (i = 0; i < blocksize; i++) {  	int nbin = resn + 1;  	if (nbitget == 0) {  		if (nbyteget < 4) {  			int bytes = stream.Read (getbuf' 0' BUFSIZE);  			getbufOffset = 0;  			nbyteget += bytes;  		}  		gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  		getbufOffset += 4;  		nbyteget -= 4;  		nbitget = 32;  	}  	while ((gbuffer & (1L << --nbitget)) == 0) {  		if (nbitget == 0) {  			if (nbyteget < 4) {  				int bytes = stream.Read (getbuf' 0' BUFSIZE);  				getbufOffset = 0;  				nbyteget += bytes;  			}  			gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  			getbufOffset += 4;  			nbyteget -= 4;  			nbitget = 32;  		}  	}  	while (nbin != 0) {  		if (nbitget >= nbin) {  			nbitget -= nbin;  			nbin = 0;  		} else {  			if (nbyteget < 4) {  				int bytes = stream.Read (getbuf' 0' BUFSIZE);  				getbufOffset = 0;  				nbyteget += bytes;  			}  			gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  			getbufOffset += 4;  			nbyteget -= 4;  			nbin -= nbitget;  			nbitget = 32;  		}  	}  }  
Magic Number,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,getSamples,The following statement contains a magic number: for (i = 0; i < blocksize; i++) {  	int nbin = resn + 1;  	if (nbitget == 0) {  		if (nbyteget < 4) {  			int bytes = stream.Read (getbuf' 0' BUFSIZE);  			getbufOffset = 0;  			nbyteget += bytes;  		}  		gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  		getbufOffset += 4;  		nbyteget -= 4;  		nbitget = 32;  	}  	while ((gbuffer & (1L << --nbitget)) == 0) {  		if (nbitget == 0) {  			if (nbyteget < 4) {  				int bytes = stream.Read (getbuf' 0' BUFSIZE);  				getbufOffset = 0;  				nbyteget += bytes;  			}  			gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  			getbufOffset += 4;  			nbyteget -= 4;  			nbitget = 32;  		}  	}  	while (nbin != 0) {  		if (nbitget >= nbin) {  			nbitget -= nbin;  			nbin = 0;  		} else {  			if (nbyteget < 4) {  				int bytes = stream.Read (getbuf' 0' BUFSIZE);  				getbufOffset = 0;  				nbyteget += bytes;  			}  			gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  			getbufOffset += 4;  			nbyteget -= 4;  			nbin -= nbitget;  			nbitget = 32;  		}  	}  }  
Magic Number,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,getSamples,The following statement contains a magic number: for (i = 0; i < blocksize; i++) {  	int nbin = resn + 1;  	if (nbitget == 0) {  		if (nbyteget < 4) {  			int bytes = stream.Read (getbuf' 0' BUFSIZE);  			getbufOffset = 0;  			nbyteget += bytes;  		}  		gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  		getbufOffset += 4;  		nbyteget -= 4;  		nbitget = 32;  	}  	while ((gbuffer & (1L << --nbitget)) == 0) {  		if (nbitget == 0) {  			if (nbyteget < 4) {  				int bytes = stream.Read (getbuf' 0' BUFSIZE);  				getbufOffset = 0;  				nbyteget += bytes;  			}  			gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  			getbufOffset += 4;  			nbyteget -= 4;  			nbitget = 32;  		}  	}  	while (nbin != 0) {  		if (nbitget >= nbin) {  			nbitget -= nbin;  			nbin = 0;  		} else {  			if (nbyteget < 4) {  				int bytes = stream.Read (getbuf' 0' BUFSIZE);  				getbufOffset = 0;  				nbyteget += bytes;  			}  			gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  			getbufOffset += 4;  			nbyteget -= 4;  			nbin -= nbitget;  			nbitget = 32;  		}  	}  }  
Magic Number,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,getSamples,The following statement contains a magic number: for (i = 0; i < blocksize; i++) {  	int nbin = resn + 1;  	if (nbitget == 0) {  		if (nbyteget < 4) {  			int bytes = stream.Read (getbuf' 0' BUFSIZE);  			getbufOffset = 0;  			nbyteget += bytes;  		}  		gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  		getbufOffset += 4;  		nbyteget -= 4;  		nbitget = 32;  	}  	while ((gbuffer & (1L << --nbitget)) == 0) {  		if (nbitget == 0) {  			if (nbyteget < 4) {  				int bytes = stream.Read (getbuf' 0' BUFSIZE);  				getbufOffset = 0;  				nbyteget += bytes;  			}  			gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  			getbufOffset += 4;  			nbyteget -= 4;  			nbitget = 32;  		}  	}  	while (nbin != 0) {  		if (nbitget >= nbin) {  			nbitget -= nbin;  			nbin = 0;  		} else {  			if (nbyteget < 4) {  				int bytes = stream.Read (getbuf' 0' BUFSIZE);  				getbufOffset = 0;  				nbyteget += bytes;  			}  			gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  			getbufOffset += 4;  			nbyteget -= 4;  			nbin -= nbitget;  			nbitget = 32;  		}  	}  }  
Magic Number,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,getSamples,The following statement contains a magic number: for (i = 0; i < blocksize; i++) {  	int nbin = resn + 1;  	if (nbitget == 0) {  		if (nbyteget < 4) {  			int bytes = stream.Read (getbuf' 0' BUFSIZE);  			getbufOffset = 0;  			nbyteget += bytes;  		}  		gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  		getbufOffset += 4;  		nbyteget -= 4;  		nbitget = 32;  	}  	while ((gbuffer & (1L << --nbitget)) == 0) {  		if (nbitget == 0) {  			if (nbyteget < 4) {  				int bytes = stream.Read (getbuf' 0' BUFSIZE);  				getbufOffset = 0;  				nbyteget += bytes;  			}  			gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  			getbufOffset += 4;  			nbyteget -= 4;  			nbitget = 32;  		}  	}  	while (nbin != 0) {  		if (nbitget >= nbin) {  			nbitget -= nbin;  			nbin = 0;  		} else {  			if (nbyteget < 4) {  				int bytes = stream.Read (getbuf' 0' BUFSIZE);  				getbufOffset = 0;  				nbyteget += bytes;  			}  			gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  			getbufOffset += 4;  			nbyteget -= 4;  			nbin -= nbitget;  			nbitget = 32;  		}  	}  }  
Magic Number,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,getSamples,The following statement contains a magic number: for (i = 0; i < blocksize; i++) {  	int nbin = resn + 1;  	if (nbitget == 0) {  		if (nbyteget < 4) {  			int bytes = stream.Read (getbuf' 0' BUFSIZE);  			getbufOffset = 0;  			nbyteget += bytes;  		}  		gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  		getbufOffset += 4;  		nbyteget -= 4;  		nbitget = 32;  	}  	while ((gbuffer & (1L << --nbitget)) == 0) {  		if (nbitget == 0) {  			if (nbyteget < 4) {  				int bytes = stream.Read (getbuf' 0' BUFSIZE);  				getbufOffset = 0;  				nbyteget += bytes;  			}  			gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  			getbufOffset += 4;  			nbyteget -= 4;  			nbitget = 32;  		}  	}  	while (nbin != 0) {  		if (nbitget >= nbin) {  			nbitget -= nbin;  			nbin = 0;  		} else {  			if (nbyteget < 4) {  				int bytes = stream.Read (getbuf' 0' BUFSIZE);  				getbufOffset = 0;  				nbyteget += bytes;  			}  			gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  			getbufOffset += 4;  			nbyteget -= 4;  			nbin -= nbitget;  			nbitget = 32;  		}  	}  }  
Magic Number,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,getSamples,The following statement contains a magic number: for (i = 0; i < blocksize; i++) {  	int nbin = resn + 1;  	if (nbitget == 0) {  		if (nbyteget < 4) {  			int bytes = stream.Read (getbuf' 0' BUFSIZE);  			getbufOffset = 0;  			nbyteget += bytes;  		}  		gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  		getbufOffset += 4;  		nbyteget -= 4;  		nbitget = 32;  	}  	while ((gbuffer & (1L << --nbitget)) == 0) {  		if (nbitget == 0) {  			if (nbyteget < 4) {  				int bytes = stream.Read (getbuf' 0' BUFSIZE);  				getbufOffset = 0;  				nbyteget += bytes;  			}  			gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  			getbufOffset += 4;  			nbyteget -= 4;  			nbitget = 32;  		}  	}  	while (nbin != 0) {  		if (nbitget >= nbin) {  			nbitget -= nbin;  			nbin = 0;  		} else {  			if (nbyteget < 4) {  				int bytes = stream.Read (getbuf' 0' BUFSIZE);  				getbufOffset = 0;  				nbyteget += bytes;  			}  			gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  			getbufOffset += 4;  			nbyteget -= 4;  			nbin -= nbitget;  			nbitget = 32;  		}  	}  }  
Magic Number,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,getSamples,The following statement contains a magic number: for (i = 0; i < blocksize; i++) {  	int nbin = resn + 1;  	if (nbitget == 0) {  		if (nbyteget < 4) {  			int bytes = stream.Read (getbuf' 0' BUFSIZE);  			getbufOffset = 0;  			nbyteget += bytes;  		}  		gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  		getbufOffset += 4;  		nbyteget -= 4;  		nbitget = 32;  	}  	while ((gbuffer & (1L << --nbitget)) == 0) {  		if (nbitget == 0) {  			if (nbyteget < 4) {  				int bytes = stream.Read (getbuf' 0' BUFSIZE);  				getbufOffset = 0;  				nbyteget += bytes;  			}  			gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  			getbufOffset += 4;  			nbyteget -= 4;  			nbitget = 32;  		}  	}  	while (nbin != 0) {  		if (nbitget >= nbin) {  			nbitget -= nbin;  			nbin = 0;  		} else {  			if (nbyteget < 4) {  				int bytes = stream.Read (getbuf' 0' BUFSIZE);  				getbufOffset = 0;  				nbyteget += bytes;  			}  			gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  			getbufOffset += 4;  			nbyteget -= 4;  			nbin -= nbitget;  			nbitget = 32;  		}  	}  }  
Magic Number,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,getSamples,The following statement contains a magic number: for (i = 0; i < blocksize; i++) {  	int nbin = resn + 1;  	if (nbitget == 0) {  		if (nbyteget < 4) {  			int bytes = stream.Read (getbuf' 0' BUFSIZE);  			getbufOffset = 0;  			nbyteget += bytes;  		}  		gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  		getbufOffset += 4;  		nbyteget -= 4;  		nbitget = 32;  	}  	while ((gbuffer & (1L << --nbitget)) == 0) {  		if (nbitget == 0) {  			if (nbyteget < 4) {  				int bytes = stream.Read (getbuf' 0' BUFSIZE);  				getbufOffset = 0;  				nbyteget += bytes;  			}  			gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  			getbufOffset += 4;  			nbyteget -= 4;  			nbitget = 32;  		}  	}  	while (nbin != 0) {  		if (nbitget >= nbin) {  			nbitget -= nbin;  			nbin = 0;  		} else {  			if (nbyteget < 4) {  				int bytes = stream.Read (getbuf' 0' BUFSIZE);  				getbufOffset = 0;  				nbyteget += bytes;  			}  			gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  			getbufOffset += 4;  			nbyteget -= 4;  			nbin -= nbitget;  			nbitget = 32;  		}  	}  }  
Magic Number,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,getSamples,The following statement contains a magic number: for (i = 0; i < blocksize; i++) {  	int nbin = resn + 1;  	if (nbitget == 0) {  		if (nbyteget < 4) {  			int bytes = stream.Read (getbuf' 0' BUFSIZE);  			getbufOffset = 0;  			nbyteget += bytes;  		}  		gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  		getbufOffset += 4;  		nbyteget -= 4;  		nbitget = 32;  	}  	while ((gbuffer & (1L << --nbitget)) == 0) {  		if (nbitget == 0) {  			if (nbyteget < 4) {  				int bytes = stream.Read (getbuf' 0' BUFSIZE);  				getbufOffset = 0;  				nbyteget += bytes;  			}  			gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  			getbufOffset += 4;  			nbyteget -= 4;  			nbitget = 32;  		}  	}  	while (nbin != 0) {  		if (nbitget >= nbin) {  			nbitget -= nbin;  			nbin = 0;  		} else {  			if (nbyteget < 4) {  				int bytes = stream.Read (getbuf' 0' BUFSIZE);  				getbufOffset = 0;  				nbyteget += bytes;  			}  			gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  			getbufOffset += 4;  			nbyteget -= 4;  			nbin -= nbitget;  			nbitget = 32;  		}  	}  }  
Magic Number,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,getSamples,The following statement contains a magic number: for (i = 0; i < blocksize; i++) {  	int nbin = resn + 1;  	if (nbitget == 0) {  		if (nbyteget < 4) {  			int bytes = stream.Read (getbuf' 0' BUFSIZE);  			getbufOffset = 0;  			nbyteget += bytes;  		}  		gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  		getbufOffset += 4;  		nbyteget -= 4;  		nbitget = 32;  	}  	while ((gbuffer & (1L << --nbitget)) == 0) {  		if (nbitget == 0) {  			if (nbyteget < 4) {  				int bytes = stream.Read (getbuf' 0' BUFSIZE);  				getbufOffset = 0;  				nbyteget += bytes;  			}  			gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  			getbufOffset += 4;  			nbyteget -= 4;  			nbitget = 32;  		}  	}  	while (nbin != 0) {  		if (nbitget >= nbin) {  			nbitget -= nbin;  			nbin = 0;  		} else {  			if (nbyteget < 4) {  				int bytes = stream.Read (getbuf' 0' BUFSIZE);  				getbufOffset = 0;  				nbyteget += bytes;  			}  			gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  			getbufOffset += 4;  			nbyteget -= 4;  			nbin -= nbitget;  			nbitget = 32;  		}  	}  }  
Magic Number,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,getSamples,The following statement contains a magic number: for (i = 0; i < blocksize; i++) {  	int nbin = resn + 1;  	if (nbitget == 0) {  		if (nbyteget < 4) {  			int bytes = stream.Read (getbuf' 0' BUFSIZE);  			getbufOffset = 0;  			nbyteget += bytes;  		}  		gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  		getbufOffset += 4;  		nbyteget -= 4;  		nbitget = 32;  	}  	while ((gbuffer & (1L << --nbitget)) == 0) {  		if (nbitget == 0) {  			if (nbyteget < 4) {  				int bytes = stream.Read (getbuf' 0' BUFSIZE);  				getbufOffset = 0;  				nbyteget += bytes;  			}  			gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  			getbufOffset += 4;  			nbyteget -= 4;  			nbitget = 32;  		}  	}  	while (nbin != 0) {  		if (nbitget >= nbin) {  			nbitget -= nbin;  			nbin = 0;  		} else {  			if (nbyteget < 4) {  				int bytes = stream.Read (getbuf' 0' BUFSIZE);  				getbufOffset = 0;  				nbyteget += bytes;  			}  			gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  			getbufOffset += 4;  			nbyteget -= 4;  			nbin -= nbitget;  			nbitget = 32;  		}  	}  }  
Magic Number,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,getSamples,The following statement contains a magic number: if (nbitget == 0) {  	if (nbyteget < 4) {  		int bytes = stream.Read (getbuf' 0' BUFSIZE);  		getbufOffset = 0;  		nbyteget += bytes;  	}  	gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  	getbufOffset += 4;  	nbyteget -= 4;  	nbitget = 32;  }  
Magic Number,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,getSamples,The following statement contains a magic number: if (nbitget == 0) {  	if (nbyteget < 4) {  		int bytes = stream.Read (getbuf' 0' BUFSIZE);  		getbufOffset = 0;  		nbyteget += bytes;  	}  	gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  	getbufOffset += 4;  	nbyteget -= 4;  	nbitget = 32;  }  
Magic Number,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,getSamples,The following statement contains a magic number: if (nbitget == 0) {  	if (nbyteget < 4) {  		int bytes = stream.Read (getbuf' 0' BUFSIZE);  		getbufOffset = 0;  		nbyteget += bytes;  	}  	gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  	getbufOffset += 4;  	nbyteget -= 4;  	nbitget = 32;  }  
Magic Number,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,getSamples,The following statement contains a magic number: if (nbitget == 0) {  	if (nbyteget < 4) {  		int bytes = stream.Read (getbuf' 0' BUFSIZE);  		getbufOffset = 0;  		nbyteget += bytes;  	}  	gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  	getbufOffset += 4;  	nbyteget -= 4;  	nbitget = 32;  }  
Magic Number,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,getSamples,The following statement contains a magic number: if (nbitget == 0) {  	if (nbyteget < 4) {  		int bytes = stream.Read (getbuf' 0' BUFSIZE);  		getbufOffset = 0;  		nbyteget += bytes;  	}  	gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  	getbufOffset += 4;  	nbyteget -= 4;  	nbitget = 32;  }  
Magic Number,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,getSamples,The following statement contains a magic number: if (nbitget == 0) {  	if (nbyteget < 4) {  		int bytes = stream.Read (getbuf' 0' BUFSIZE);  		getbufOffset = 0;  		nbyteget += bytes;  	}  	gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  	getbufOffset += 4;  	nbyteget -= 4;  	nbitget = 32;  }  
Magic Number,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,getSamples,The following statement contains a magic number: if (nbitget == 0) {  	if (nbyteget < 4) {  		int bytes = stream.Read (getbuf' 0' BUFSIZE);  		getbufOffset = 0;  		nbyteget += bytes;  	}  	gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  	getbufOffset += 4;  	nbyteget -= 4;  	nbitget = 32;  }  
Magic Number,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,getSamples,The following statement contains a magic number: if (nbitget == 0) {  	if (nbyteget < 4) {  		int bytes = stream.Read (getbuf' 0' BUFSIZE);  		getbufOffset = 0;  		nbyteget += bytes;  	}  	gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  	getbufOffset += 4;  	nbyteget -= 4;  	nbitget = 32;  }  
Magic Number,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,getSamples,The following statement contains a magic number: if (nbitget == 0) {  	if (nbyteget < 4) {  		int bytes = stream.Read (getbuf' 0' BUFSIZE);  		getbufOffset = 0;  		nbyteget += bytes;  	}  	gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  	getbufOffset += 4;  	nbyteget -= 4;  	nbitget = 32;  }  
Magic Number,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,getSamples,The following statement contains a magic number: if (nbyteget < 4) {  	int bytes = stream.Read (getbuf' 0' BUFSIZE);  	getbufOffset = 0;  	nbyteget += bytes;  }  
Magic Number,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,getSamples,The following statement contains a magic number: gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  
Magic Number,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,getSamples,The following statement contains a magic number: gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  
Magic Number,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,getSamples,The following statement contains a magic number: gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  
Magic Number,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,getSamples,The following statement contains a magic number: gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  
Magic Number,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,getSamples,The following statement contains a magic number: gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  
Magic Number,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,getSamples,The following statement contains a magic number: getbufOffset += 4;  
Magic Number,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,getSamples,The following statement contains a magic number: nbyteget -= 4;  
Magic Number,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,getSamples,The following statement contains a magic number: nbitget = 32;  
Magic Number,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,getSamples,The following statement contains a magic number: while ((gbuffer & (1L << --nbitget)) == 0) {  	if (nbitget == 0) {  		if (nbyteget < 4) {  			int bytes = stream.Read (getbuf' 0' BUFSIZE);  			getbufOffset = 0;  			nbyteget += bytes;  		}  		gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  		getbufOffset += 4;  		nbyteget -= 4;  		nbitget = 32;  	}  }  
Magic Number,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,getSamples,The following statement contains a magic number: while ((gbuffer & (1L << --nbitget)) == 0) {  	if (nbitget == 0) {  		if (nbyteget < 4) {  			int bytes = stream.Read (getbuf' 0' BUFSIZE);  			getbufOffset = 0;  			nbyteget += bytes;  		}  		gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  		getbufOffset += 4;  		nbyteget -= 4;  		nbitget = 32;  	}  }  
Magic Number,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,getSamples,The following statement contains a magic number: while ((gbuffer & (1L << --nbitget)) == 0) {  	if (nbitget == 0) {  		if (nbyteget < 4) {  			int bytes = stream.Read (getbuf' 0' BUFSIZE);  			getbufOffset = 0;  			nbyteget += bytes;  		}  		gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  		getbufOffset += 4;  		nbyteget -= 4;  		nbitget = 32;  	}  }  
Magic Number,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,getSamples,The following statement contains a magic number: while ((gbuffer & (1L << --nbitget)) == 0) {  	if (nbitget == 0) {  		if (nbyteget < 4) {  			int bytes = stream.Read (getbuf' 0' BUFSIZE);  			getbufOffset = 0;  			nbyteget += bytes;  		}  		gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  		getbufOffset += 4;  		nbyteget -= 4;  		nbitget = 32;  	}  }  
Magic Number,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,getSamples,The following statement contains a magic number: while ((gbuffer & (1L << --nbitget)) == 0) {  	if (nbitget == 0) {  		if (nbyteget < 4) {  			int bytes = stream.Read (getbuf' 0' BUFSIZE);  			getbufOffset = 0;  			nbyteget += bytes;  		}  		gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  		getbufOffset += 4;  		nbyteget -= 4;  		nbitget = 32;  	}  }  
Magic Number,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,getSamples,The following statement contains a magic number: while ((gbuffer & (1L << --nbitget)) == 0) {  	if (nbitget == 0) {  		if (nbyteget < 4) {  			int bytes = stream.Read (getbuf' 0' BUFSIZE);  			getbufOffset = 0;  			nbyteget += bytes;  		}  		gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  		getbufOffset += 4;  		nbyteget -= 4;  		nbitget = 32;  	}  }  
Magic Number,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,getSamples,The following statement contains a magic number: while ((gbuffer & (1L << --nbitget)) == 0) {  	if (nbitget == 0) {  		if (nbyteget < 4) {  			int bytes = stream.Read (getbuf' 0' BUFSIZE);  			getbufOffset = 0;  			nbyteget += bytes;  		}  		gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  		getbufOffset += 4;  		nbyteget -= 4;  		nbitget = 32;  	}  }  
Magic Number,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,getSamples,The following statement contains a magic number: while ((gbuffer & (1L << --nbitget)) == 0) {  	if (nbitget == 0) {  		if (nbyteget < 4) {  			int bytes = stream.Read (getbuf' 0' BUFSIZE);  			getbufOffset = 0;  			nbyteget += bytes;  		}  		gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  		getbufOffset += 4;  		nbyteget -= 4;  		nbitget = 32;  	}  }  
Magic Number,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,getSamples,The following statement contains a magic number: while ((gbuffer & (1L << --nbitget)) == 0) {  	if (nbitget == 0) {  		if (nbyteget < 4) {  			int bytes = stream.Read (getbuf' 0' BUFSIZE);  			getbufOffset = 0;  			nbyteget += bytes;  		}  		gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  		getbufOffset += 4;  		nbyteget -= 4;  		nbitget = 32;  	}  }  
Magic Number,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,getSamples,The following statement contains a magic number: if (nbitget == 0) {  	if (nbyteget < 4) {  		int bytes = stream.Read (getbuf' 0' BUFSIZE);  		getbufOffset = 0;  		nbyteget += bytes;  	}  	gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  	getbufOffset += 4;  	nbyteget -= 4;  	nbitget = 32;  }  
Magic Number,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,getSamples,The following statement contains a magic number: if (nbitget == 0) {  	if (nbyteget < 4) {  		int bytes = stream.Read (getbuf' 0' BUFSIZE);  		getbufOffset = 0;  		nbyteget += bytes;  	}  	gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  	getbufOffset += 4;  	nbyteget -= 4;  	nbitget = 32;  }  
Magic Number,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,getSamples,The following statement contains a magic number: if (nbitget == 0) {  	if (nbyteget < 4) {  		int bytes = stream.Read (getbuf' 0' BUFSIZE);  		getbufOffset = 0;  		nbyteget += bytes;  	}  	gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  	getbufOffset += 4;  	nbyteget -= 4;  	nbitget = 32;  }  
Magic Number,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,getSamples,The following statement contains a magic number: if (nbitget == 0) {  	if (nbyteget < 4) {  		int bytes = stream.Read (getbuf' 0' BUFSIZE);  		getbufOffset = 0;  		nbyteget += bytes;  	}  	gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  	getbufOffset += 4;  	nbyteget -= 4;  	nbitget = 32;  }  
Magic Number,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,getSamples,The following statement contains a magic number: if (nbitget == 0) {  	if (nbyteget < 4) {  		int bytes = stream.Read (getbuf' 0' BUFSIZE);  		getbufOffset = 0;  		nbyteget += bytes;  	}  	gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  	getbufOffset += 4;  	nbyteget -= 4;  	nbitget = 32;  }  
Magic Number,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,getSamples,The following statement contains a magic number: if (nbitget == 0) {  	if (nbyteget < 4) {  		int bytes = stream.Read (getbuf' 0' BUFSIZE);  		getbufOffset = 0;  		nbyteget += bytes;  	}  	gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  	getbufOffset += 4;  	nbyteget -= 4;  	nbitget = 32;  }  
Magic Number,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,getSamples,The following statement contains a magic number: if (nbitget == 0) {  	if (nbyteget < 4) {  		int bytes = stream.Read (getbuf' 0' BUFSIZE);  		getbufOffset = 0;  		nbyteget += bytes;  	}  	gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  	getbufOffset += 4;  	nbyteget -= 4;  	nbitget = 32;  }  
Magic Number,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,getSamples,The following statement contains a magic number: if (nbitget == 0) {  	if (nbyteget < 4) {  		int bytes = stream.Read (getbuf' 0' BUFSIZE);  		getbufOffset = 0;  		nbyteget += bytes;  	}  	gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  	getbufOffset += 4;  	nbyteget -= 4;  	nbitget = 32;  }  
Magic Number,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,getSamples,The following statement contains a magic number: if (nbitget == 0) {  	if (nbyteget < 4) {  		int bytes = stream.Read (getbuf' 0' BUFSIZE);  		getbufOffset = 0;  		nbyteget += bytes;  	}  	gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  	getbufOffset += 4;  	nbyteget -= 4;  	nbitget = 32;  }  
Magic Number,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,getSamples,The following statement contains a magic number: if (nbyteget < 4) {  	int bytes = stream.Read (getbuf' 0' BUFSIZE);  	getbufOffset = 0;  	nbyteget += bytes;  }  
Magic Number,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,getSamples,The following statement contains a magic number: gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  
Magic Number,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,getSamples,The following statement contains a magic number: gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  
Magic Number,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,getSamples,The following statement contains a magic number: gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  
Magic Number,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,getSamples,The following statement contains a magic number: gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  
Magic Number,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,getSamples,The following statement contains a magic number: gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  
Magic Number,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,getSamples,The following statement contains a magic number: getbufOffset += 4;  
Magic Number,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,getSamples,The following statement contains a magic number: nbyteget -= 4;  
Magic Number,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,getSamples,The following statement contains a magic number: nbitget = 32;  
Magic Number,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,getSamples,The following statement contains a magic number: while (nbin != 0) {  	if (nbitget >= nbin) {  		nbitget -= nbin;  		nbin = 0;  	} else {  		if (nbyteget < 4) {  			int bytes = stream.Read (getbuf' 0' BUFSIZE);  			getbufOffset = 0;  			nbyteget += bytes;  		}  		gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  		getbufOffset += 4;  		nbyteget -= 4;  		nbin -= nbitget;  		nbitget = 32;  	}  }  
Magic Number,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,getSamples,The following statement contains a magic number: while (nbin != 0) {  	if (nbitget >= nbin) {  		nbitget -= nbin;  		nbin = 0;  	} else {  		if (nbyteget < 4) {  			int bytes = stream.Read (getbuf' 0' BUFSIZE);  			getbufOffset = 0;  			nbyteget += bytes;  		}  		gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  		getbufOffset += 4;  		nbyteget -= 4;  		nbin -= nbitget;  		nbitget = 32;  	}  }  
Magic Number,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,getSamples,The following statement contains a magic number: while (nbin != 0) {  	if (nbitget >= nbin) {  		nbitget -= nbin;  		nbin = 0;  	} else {  		if (nbyteget < 4) {  			int bytes = stream.Read (getbuf' 0' BUFSIZE);  			getbufOffset = 0;  			nbyteget += bytes;  		}  		gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  		getbufOffset += 4;  		nbyteget -= 4;  		nbin -= nbitget;  		nbitget = 32;  	}  }  
Magic Number,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,getSamples,The following statement contains a magic number: while (nbin != 0) {  	if (nbitget >= nbin) {  		nbitget -= nbin;  		nbin = 0;  	} else {  		if (nbyteget < 4) {  			int bytes = stream.Read (getbuf' 0' BUFSIZE);  			getbufOffset = 0;  			nbyteget += bytes;  		}  		gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  		getbufOffset += 4;  		nbyteget -= 4;  		nbin -= nbitget;  		nbitget = 32;  	}  }  
Magic Number,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,getSamples,The following statement contains a magic number: while (nbin != 0) {  	if (nbitget >= nbin) {  		nbitget -= nbin;  		nbin = 0;  	} else {  		if (nbyteget < 4) {  			int bytes = stream.Read (getbuf' 0' BUFSIZE);  			getbufOffset = 0;  			nbyteget += bytes;  		}  		gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  		getbufOffset += 4;  		nbyteget -= 4;  		nbin -= nbitget;  		nbitget = 32;  	}  }  
Magic Number,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,getSamples,The following statement contains a magic number: while (nbin != 0) {  	if (nbitget >= nbin) {  		nbitget -= nbin;  		nbin = 0;  	} else {  		if (nbyteget < 4) {  			int bytes = stream.Read (getbuf' 0' BUFSIZE);  			getbufOffset = 0;  			nbyteget += bytes;  		}  		gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  		getbufOffset += 4;  		nbyteget -= 4;  		nbin -= nbitget;  		nbitget = 32;  	}  }  
Magic Number,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,getSamples,The following statement contains a magic number: while (nbin != 0) {  	if (nbitget >= nbin) {  		nbitget -= nbin;  		nbin = 0;  	} else {  		if (nbyteget < 4) {  			int bytes = stream.Read (getbuf' 0' BUFSIZE);  			getbufOffset = 0;  			nbyteget += bytes;  		}  		gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  		getbufOffset += 4;  		nbyteget -= 4;  		nbin -= nbitget;  		nbitget = 32;  	}  }  
Magic Number,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,getSamples,The following statement contains a magic number: while (nbin != 0) {  	if (nbitget >= nbin) {  		nbitget -= nbin;  		nbin = 0;  	} else {  		if (nbyteget < 4) {  			int bytes = stream.Read (getbuf' 0' BUFSIZE);  			getbufOffset = 0;  			nbyteget += bytes;  		}  		gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  		getbufOffset += 4;  		nbyteget -= 4;  		nbin -= nbitget;  		nbitget = 32;  	}  }  
Magic Number,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,getSamples,The following statement contains a magic number: while (nbin != 0) {  	if (nbitget >= nbin) {  		nbitget -= nbin;  		nbin = 0;  	} else {  		if (nbyteget < 4) {  			int bytes = stream.Read (getbuf' 0' BUFSIZE);  			getbufOffset = 0;  			nbyteget += bytes;  		}  		gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  		getbufOffset += 4;  		nbyteget -= 4;  		nbin -= nbitget;  		nbitget = 32;  	}  }  
Magic Number,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,getSamples,The following statement contains a magic number: if (nbitget >= nbin) {  	nbitget -= nbin;  	nbin = 0;  } else {  	if (nbyteget < 4) {  		int bytes = stream.Read (getbuf' 0' BUFSIZE);  		getbufOffset = 0;  		nbyteget += bytes;  	}  	gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  	getbufOffset += 4;  	nbyteget -= 4;  	nbin -= nbitget;  	nbitget = 32;  }  
Magic Number,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,getSamples,The following statement contains a magic number: if (nbitget >= nbin) {  	nbitget -= nbin;  	nbin = 0;  } else {  	if (nbyteget < 4) {  		int bytes = stream.Read (getbuf' 0' BUFSIZE);  		getbufOffset = 0;  		nbyteget += bytes;  	}  	gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  	getbufOffset += 4;  	nbyteget -= 4;  	nbin -= nbitget;  	nbitget = 32;  }  
Magic Number,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,getSamples,The following statement contains a magic number: if (nbitget >= nbin) {  	nbitget -= nbin;  	nbin = 0;  } else {  	if (nbyteget < 4) {  		int bytes = stream.Read (getbuf' 0' BUFSIZE);  		getbufOffset = 0;  		nbyteget += bytes;  	}  	gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  	getbufOffset += 4;  	nbyteget -= 4;  	nbin -= nbitget;  	nbitget = 32;  }  
Magic Number,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,getSamples,The following statement contains a magic number: if (nbitget >= nbin) {  	nbitget -= nbin;  	nbin = 0;  } else {  	if (nbyteget < 4) {  		int bytes = stream.Read (getbuf' 0' BUFSIZE);  		getbufOffset = 0;  		nbyteget += bytes;  	}  	gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  	getbufOffset += 4;  	nbyteget -= 4;  	nbin -= nbitget;  	nbitget = 32;  }  
Magic Number,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,getSamples,The following statement contains a magic number: if (nbitget >= nbin) {  	nbitget -= nbin;  	nbin = 0;  } else {  	if (nbyteget < 4) {  		int bytes = stream.Read (getbuf' 0' BUFSIZE);  		getbufOffset = 0;  		nbyteget += bytes;  	}  	gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  	getbufOffset += 4;  	nbyteget -= 4;  	nbin -= nbitget;  	nbitget = 32;  }  
Magic Number,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,getSamples,The following statement contains a magic number: if (nbitget >= nbin) {  	nbitget -= nbin;  	nbin = 0;  } else {  	if (nbyteget < 4) {  		int bytes = stream.Read (getbuf' 0' BUFSIZE);  		getbufOffset = 0;  		nbyteget += bytes;  	}  	gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  	getbufOffset += 4;  	nbyteget -= 4;  	nbin -= nbitget;  	nbitget = 32;  }  
Magic Number,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,getSamples,The following statement contains a magic number: if (nbitget >= nbin) {  	nbitget -= nbin;  	nbin = 0;  } else {  	if (nbyteget < 4) {  		int bytes = stream.Read (getbuf' 0' BUFSIZE);  		getbufOffset = 0;  		nbyteget += bytes;  	}  	gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  	getbufOffset += 4;  	nbyteget -= 4;  	nbin -= nbitget;  	nbitget = 32;  }  
Magic Number,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,getSamples,The following statement contains a magic number: if (nbitget >= nbin) {  	nbitget -= nbin;  	nbin = 0;  } else {  	if (nbyteget < 4) {  		int bytes = stream.Read (getbuf' 0' BUFSIZE);  		getbufOffset = 0;  		nbyteget += bytes;  	}  	gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  	getbufOffset += 4;  	nbyteget -= 4;  	nbin -= nbitget;  	nbitget = 32;  }  
Magic Number,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,getSamples,The following statement contains a magic number: if (nbitget >= nbin) {  	nbitget -= nbin;  	nbin = 0;  } else {  	if (nbyteget < 4) {  		int bytes = stream.Read (getbuf' 0' BUFSIZE);  		getbufOffset = 0;  		nbyteget += bytes;  	}  	gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  	getbufOffset += 4;  	nbyteget -= 4;  	nbin -= nbitget;  	nbitget = 32;  }  
Magic Number,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,getSamples,The following statement contains a magic number: if (nbyteget < 4) {  	int bytes = stream.Read (getbuf' 0' BUFSIZE);  	getbufOffset = 0;  	nbyteget += bytes;  }  
Magic Number,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,getSamples,The following statement contains a magic number: gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  
Magic Number,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,getSamples,The following statement contains a magic number: gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  
Magic Number,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,getSamples,The following statement contains a magic number: gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  
Magic Number,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,getSamples,The following statement contains a magic number: gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  
Magic Number,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,getSamples,The following statement contains a magic number: gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  
Magic Number,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,getSamples,The following statement contains a magic number: getbufOffset += 4;  
Magic Number,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,getSamples,The following statement contains a magic number: nbyteget -= 4;  
Magic Number,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,getSamples,The following statement contains a magic number: nbitget = 32;  
Magic Number,IdSharp.AudioInfo,APEv2,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\TagSizes\APEv2.cs,GetTagSize,The following statement contains a magic number: try {  	byte[] buf = new byte[32];  	stream.Seek (-32' SeekOrigin.End);  	stream.Read (buf' 0' 32);  	if (ByteUtils.Compare (buf' APETAGEX' 8) == false) {  		// Skip past possible ID3v1 tag  		stream.Seek (-128 - 32' SeekOrigin.End);  		stream.Read (buf' 0' 32);  		if (ByteUtils.Compare (buf' APETAGEX' 8) == false) {  			// TODO: skip past possible Lyrics3 tag  			return 0;  		}  	}  	// Check version  	int version = 0;  	for (int i = 8; i < 12; i++) {  		version += (buf [i] << ((i - 8) * 8));  	}  	// Must be APEv2 or APEv1  	if (version != 2000 && version != 1000) {  		return 0;  	}  	// Size  	int tagSize = 0;  	for (int i = 12; i < 16; i++) {  		tagSize += (buf [i] << ((i - 12) * 8));  	}  	bool containsHeader = ((buf [23] >> 7) == 1);  	tagSize += (containsHeader ? 32 : 0);  	return tagSize;  } finally {  	stream.Position = currentPosition;  }  
Magic Number,IdSharp.AudioInfo,APEv2,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\TagSizes\APEv2.cs,GetTagSize,The following statement contains a magic number: try {  	byte[] buf = new byte[32];  	stream.Seek (-32' SeekOrigin.End);  	stream.Read (buf' 0' 32);  	if (ByteUtils.Compare (buf' APETAGEX' 8) == false) {  		// Skip past possible ID3v1 tag  		stream.Seek (-128 - 32' SeekOrigin.End);  		stream.Read (buf' 0' 32);  		if (ByteUtils.Compare (buf' APETAGEX' 8) == false) {  			// TODO: skip past possible Lyrics3 tag  			return 0;  		}  	}  	// Check version  	int version = 0;  	for (int i = 8; i < 12; i++) {  		version += (buf [i] << ((i - 8) * 8));  	}  	// Must be APEv2 or APEv1  	if (version != 2000 && version != 1000) {  		return 0;  	}  	// Size  	int tagSize = 0;  	for (int i = 12; i < 16; i++) {  		tagSize += (buf [i] << ((i - 12) * 8));  	}  	bool containsHeader = ((buf [23] >> 7) == 1);  	tagSize += (containsHeader ? 32 : 0);  	return tagSize;  } finally {  	stream.Position = currentPosition;  }  
Magic Number,IdSharp.AudioInfo,APEv2,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\TagSizes\APEv2.cs,GetTagSize,The following statement contains a magic number: try {  	byte[] buf = new byte[32];  	stream.Seek (-32' SeekOrigin.End);  	stream.Read (buf' 0' 32);  	if (ByteUtils.Compare (buf' APETAGEX' 8) == false) {  		// Skip past possible ID3v1 tag  		stream.Seek (-128 - 32' SeekOrigin.End);  		stream.Read (buf' 0' 32);  		if (ByteUtils.Compare (buf' APETAGEX' 8) == false) {  			// TODO: skip past possible Lyrics3 tag  			return 0;  		}  	}  	// Check version  	int version = 0;  	for (int i = 8; i < 12; i++) {  		version += (buf [i] << ((i - 8) * 8));  	}  	// Must be APEv2 or APEv1  	if (version != 2000 && version != 1000) {  		return 0;  	}  	// Size  	int tagSize = 0;  	for (int i = 12; i < 16; i++) {  		tagSize += (buf [i] << ((i - 12) * 8));  	}  	bool containsHeader = ((buf [23] >> 7) == 1);  	tagSize += (containsHeader ? 32 : 0);  	return tagSize;  } finally {  	stream.Position = currentPosition;  }  
Magic Number,IdSharp.AudioInfo,APEv2,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\TagSizes\APEv2.cs,GetTagSize,The following statement contains a magic number: try {  	byte[] buf = new byte[32];  	stream.Seek (-32' SeekOrigin.End);  	stream.Read (buf' 0' 32);  	if (ByteUtils.Compare (buf' APETAGEX' 8) == false) {  		// Skip past possible ID3v1 tag  		stream.Seek (-128 - 32' SeekOrigin.End);  		stream.Read (buf' 0' 32);  		if (ByteUtils.Compare (buf' APETAGEX' 8) == false) {  			// TODO: skip past possible Lyrics3 tag  			return 0;  		}  	}  	// Check version  	int version = 0;  	for (int i = 8; i < 12; i++) {  		version += (buf [i] << ((i - 8) * 8));  	}  	// Must be APEv2 or APEv1  	if (version != 2000 && version != 1000) {  		return 0;  	}  	// Size  	int tagSize = 0;  	for (int i = 12; i < 16; i++) {  		tagSize += (buf [i] << ((i - 12) * 8));  	}  	bool containsHeader = ((buf [23] >> 7) == 1);  	tagSize += (containsHeader ? 32 : 0);  	return tagSize;  } finally {  	stream.Position = currentPosition;  }  
Magic Number,IdSharp.AudioInfo,APEv2,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\TagSizes\APEv2.cs,GetTagSize,The following statement contains a magic number: try {  	byte[] buf = new byte[32];  	stream.Seek (-32' SeekOrigin.End);  	stream.Read (buf' 0' 32);  	if (ByteUtils.Compare (buf' APETAGEX' 8) == false) {  		// Skip past possible ID3v1 tag  		stream.Seek (-128 - 32' SeekOrigin.End);  		stream.Read (buf' 0' 32);  		if (ByteUtils.Compare (buf' APETAGEX' 8) == false) {  			// TODO: skip past possible Lyrics3 tag  			return 0;  		}  	}  	// Check version  	int version = 0;  	for (int i = 8; i < 12; i++) {  		version += (buf [i] << ((i - 8) * 8));  	}  	// Must be APEv2 or APEv1  	if (version != 2000 && version != 1000) {  		return 0;  	}  	// Size  	int tagSize = 0;  	for (int i = 12; i < 16; i++) {  		tagSize += (buf [i] << ((i - 12) * 8));  	}  	bool containsHeader = ((buf [23] >> 7) == 1);  	tagSize += (containsHeader ? 32 : 0);  	return tagSize;  } finally {  	stream.Position = currentPosition;  }  
Magic Number,IdSharp.AudioInfo,APEv2,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\TagSizes\APEv2.cs,GetTagSize,The following statement contains a magic number: try {  	byte[] buf = new byte[32];  	stream.Seek (-32' SeekOrigin.End);  	stream.Read (buf' 0' 32);  	if (ByteUtils.Compare (buf' APETAGEX' 8) == false) {  		// Skip past possible ID3v1 tag  		stream.Seek (-128 - 32' SeekOrigin.End);  		stream.Read (buf' 0' 32);  		if (ByteUtils.Compare (buf' APETAGEX' 8) == false) {  			// TODO: skip past possible Lyrics3 tag  			return 0;  		}  	}  	// Check version  	int version = 0;  	for (int i = 8; i < 12; i++) {  		version += (buf [i] << ((i - 8) * 8));  	}  	// Must be APEv2 or APEv1  	if (version != 2000 && version != 1000) {  		return 0;  	}  	// Size  	int tagSize = 0;  	for (int i = 12; i < 16; i++) {  		tagSize += (buf [i] << ((i - 12) * 8));  	}  	bool containsHeader = ((buf [23] >> 7) == 1);  	tagSize += (containsHeader ? 32 : 0);  	return tagSize;  } finally {  	stream.Position = currentPosition;  }  
Magic Number,IdSharp.AudioInfo,APEv2,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\TagSizes\APEv2.cs,GetTagSize,The following statement contains a magic number: try {  	byte[] buf = new byte[32];  	stream.Seek (-32' SeekOrigin.End);  	stream.Read (buf' 0' 32);  	if (ByteUtils.Compare (buf' APETAGEX' 8) == false) {  		// Skip past possible ID3v1 tag  		stream.Seek (-128 - 32' SeekOrigin.End);  		stream.Read (buf' 0' 32);  		if (ByteUtils.Compare (buf' APETAGEX' 8) == false) {  			// TODO: skip past possible Lyrics3 tag  			return 0;  		}  	}  	// Check version  	int version = 0;  	for (int i = 8; i < 12; i++) {  		version += (buf [i] << ((i - 8) * 8));  	}  	// Must be APEv2 or APEv1  	if (version != 2000 && version != 1000) {  		return 0;  	}  	// Size  	int tagSize = 0;  	for (int i = 12; i < 16; i++) {  		tagSize += (buf [i] << ((i - 12) * 8));  	}  	bool containsHeader = ((buf [23] >> 7) == 1);  	tagSize += (containsHeader ? 32 : 0);  	return tagSize;  } finally {  	stream.Position = currentPosition;  }  
Magic Number,IdSharp.AudioInfo,APEv2,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\TagSizes\APEv2.cs,GetTagSize,The following statement contains a magic number: try {  	byte[] buf = new byte[32];  	stream.Seek (-32' SeekOrigin.End);  	stream.Read (buf' 0' 32);  	if (ByteUtils.Compare (buf' APETAGEX' 8) == false) {  		// Skip past possible ID3v1 tag  		stream.Seek (-128 - 32' SeekOrigin.End);  		stream.Read (buf' 0' 32);  		if (ByteUtils.Compare (buf' APETAGEX' 8) == false) {  			// TODO: skip past possible Lyrics3 tag  			return 0;  		}  	}  	// Check version  	int version = 0;  	for (int i = 8; i < 12; i++) {  		version += (buf [i] << ((i - 8) * 8));  	}  	// Must be APEv2 or APEv1  	if (version != 2000 && version != 1000) {  		return 0;  	}  	// Size  	int tagSize = 0;  	for (int i = 12; i < 16; i++) {  		tagSize += (buf [i] << ((i - 12) * 8));  	}  	bool containsHeader = ((buf [23] >> 7) == 1);  	tagSize += (containsHeader ? 32 : 0);  	return tagSize;  } finally {  	stream.Position = currentPosition;  }  
Magic Number,IdSharp.AudioInfo,APEv2,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\TagSizes\APEv2.cs,GetTagSize,The following statement contains a magic number: try {  	byte[] buf = new byte[32];  	stream.Seek (-32' SeekOrigin.End);  	stream.Read (buf' 0' 32);  	if (ByteUtils.Compare (buf' APETAGEX' 8) == false) {  		// Skip past possible ID3v1 tag  		stream.Seek (-128 - 32' SeekOrigin.End);  		stream.Read (buf' 0' 32);  		if (ByteUtils.Compare (buf' APETAGEX' 8) == false) {  			// TODO: skip past possible Lyrics3 tag  			return 0;  		}  	}  	// Check version  	int version = 0;  	for (int i = 8; i < 12; i++) {  		version += (buf [i] << ((i - 8) * 8));  	}  	// Must be APEv2 or APEv1  	if (version != 2000 && version != 1000) {  		return 0;  	}  	// Size  	int tagSize = 0;  	for (int i = 12; i < 16; i++) {  		tagSize += (buf [i] << ((i - 12) * 8));  	}  	bool containsHeader = ((buf [23] >> 7) == 1);  	tagSize += (containsHeader ? 32 : 0);  	return tagSize;  } finally {  	stream.Position = currentPosition;  }  
Magic Number,IdSharp.AudioInfo,APEv2,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\TagSizes\APEv2.cs,GetTagSize,The following statement contains a magic number: try {  	byte[] buf = new byte[32];  	stream.Seek (-32' SeekOrigin.End);  	stream.Read (buf' 0' 32);  	if (ByteUtils.Compare (buf' APETAGEX' 8) == false) {  		// Skip past possible ID3v1 tag  		stream.Seek (-128 - 32' SeekOrigin.End);  		stream.Read (buf' 0' 32);  		if (ByteUtils.Compare (buf' APETAGEX' 8) == false) {  			// TODO: skip past possible Lyrics3 tag  			return 0;  		}  	}  	// Check version  	int version = 0;  	for (int i = 8; i < 12; i++) {  		version += (buf [i] << ((i - 8) * 8));  	}  	// Must be APEv2 or APEv1  	if (version != 2000 && version != 1000) {  		return 0;  	}  	// Size  	int tagSize = 0;  	for (int i = 12; i < 16; i++) {  		tagSize += (buf [i] << ((i - 12) * 8));  	}  	bool containsHeader = ((buf [23] >> 7) == 1);  	tagSize += (containsHeader ? 32 : 0);  	return tagSize;  } finally {  	stream.Position = currentPosition;  }  
Magic Number,IdSharp.AudioInfo,APEv2,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\TagSizes\APEv2.cs,GetTagSize,The following statement contains a magic number: try {  	byte[] buf = new byte[32];  	stream.Seek (-32' SeekOrigin.End);  	stream.Read (buf' 0' 32);  	if (ByteUtils.Compare (buf' APETAGEX' 8) == false) {  		// Skip past possible ID3v1 tag  		stream.Seek (-128 - 32' SeekOrigin.End);  		stream.Read (buf' 0' 32);  		if (ByteUtils.Compare (buf' APETAGEX' 8) == false) {  			// TODO: skip past possible Lyrics3 tag  			return 0;  		}  	}  	// Check version  	int version = 0;  	for (int i = 8; i < 12; i++) {  		version += (buf [i] << ((i - 8) * 8));  	}  	// Must be APEv2 or APEv1  	if (version != 2000 && version != 1000) {  		return 0;  	}  	// Size  	int tagSize = 0;  	for (int i = 12; i < 16; i++) {  		tagSize += (buf [i] << ((i - 12) * 8));  	}  	bool containsHeader = ((buf [23] >> 7) == 1);  	tagSize += (containsHeader ? 32 : 0);  	return tagSize;  } finally {  	stream.Position = currentPosition;  }  
Magic Number,IdSharp.AudioInfo,APEv2,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\TagSizes\APEv2.cs,GetTagSize,The following statement contains a magic number: try {  	byte[] buf = new byte[32];  	stream.Seek (-32' SeekOrigin.End);  	stream.Read (buf' 0' 32);  	if (ByteUtils.Compare (buf' APETAGEX' 8) == false) {  		// Skip past possible ID3v1 tag  		stream.Seek (-128 - 32' SeekOrigin.End);  		stream.Read (buf' 0' 32);  		if (ByteUtils.Compare (buf' APETAGEX' 8) == false) {  			// TODO: skip past possible Lyrics3 tag  			return 0;  		}  	}  	// Check version  	int version = 0;  	for (int i = 8; i < 12; i++) {  		version += (buf [i] << ((i - 8) * 8));  	}  	// Must be APEv2 or APEv1  	if (version != 2000 && version != 1000) {  		return 0;  	}  	// Size  	int tagSize = 0;  	for (int i = 12; i < 16; i++) {  		tagSize += (buf [i] << ((i - 12) * 8));  	}  	bool containsHeader = ((buf [23] >> 7) == 1);  	tagSize += (containsHeader ? 32 : 0);  	return tagSize;  } finally {  	stream.Position = currentPosition;  }  
Magic Number,IdSharp.AudioInfo,APEv2,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\TagSizes\APEv2.cs,GetTagSize,The following statement contains a magic number: try {  	byte[] buf = new byte[32];  	stream.Seek (-32' SeekOrigin.End);  	stream.Read (buf' 0' 32);  	if (ByteUtils.Compare (buf' APETAGEX' 8) == false) {  		// Skip past possible ID3v1 tag  		stream.Seek (-128 - 32' SeekOrigin.End);  		stream.Read (buf' 0' 32);  		if (ByteUtils.Compare (buf' APETAGEX' 8) == false) {  			// TODO: skip past possible Lyrics3 tag  			return 0;  		}  	}  	// Check version  	int version = 0;  	for (int i = 8; i < 12; i++) {  		version += (buf [i] << ((i - 8) * 8));  	}  	// Must be APEv2 or APEv1  	if (version != 2000 && version != 1000) {  		return 0;  	}  	// Size  	int tagSize = 0;  	for (int i = 12; i < 16; i++) {  		tagSize += (buf [i] << ((i - 12) * 8));  	}  	bool containsHeader = ((buf [23] >> 7) == 1);  	tagSize += (containsHeader ? 32 : 0);  	return tagSize;  } finally {  	stream.Position = currentPosition;  }  
Magic Number,IdSharp.AudioInfo,APEv2,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\TagSizes\APEv2.cs,GetTagSize,The following statement contains a magic number: try {  	byte[] buf = new byte[32];  	stream.Seek (-32' SeekOrigin.End);  	stream.Read (buf' 0' 32);  	if (ByteUtils.Compare (buf' APETAGEX' 8) == false) {  		// Skip past possible ID3v1 tag  		stream.Seek (-128 - 32' SeekOrigin.End);  		stream.Read (buf' 0' 32);  		if (ByteUtils.Compare (buf' APETAGEX' 8) == false) {  			// TODO: skip past possible Lyrics3 tag  			return 0;  		}  	}  	// Check version  	int version = 0;  	for (int i = 8; i < 12; i++) {  		version += (buf [i] << ((i - 8) * 8));  	}  	// Must be APEv2 or APEv1  	if (version != 2000 && version != 1000) {  		return 0;  	}  	// Size  	int tagSize = 0;  	for (int i = 12; i < 16; i++) {  		tagSize += (buf [i] << ((i - 12) * 8));  	}  	bool containsHeader = ((buf [23] >> 7) == 1);  	tagSize += (containsHeader ? 32 : 0);  	return tagSize;  } finally {  	stream.Position = currentPosition;  }  
Magic Number,IdSharp.AudioInfo,APEv2,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\TagSizes\APEv2.cs,GetTagSize,The following statement contains a magic number: try {  	byte[] buf = new byte[32];  	stream.Seek (-32' SeekOrigin.End);  	stream.Read (buf' 0' 32);  	if (ByteUtils.Compare (buf' APETAGEX' 8) == false) {  		// Skip past possible ID3v1 tag  		stream.Seek (-128 - 32' SeekOrigin.End);  		stream.Read (buf' 0' 32);  		if (ByteUtils.Compare (buf' APETAGEX' 8) == false) {  			// TODO: skip past possible Lyrics3 tag  			return 0;  		}  	}  	// Check version  	int version = 0;  	for (int i = 8; i < 12; i++) {  		version += (buf [i] << ((i - 8) * 8));  	}  	// Must be APEv2 or APEv1  	if (version != 2000 && version != 1000) {  		return 0;  	}  	// Size  	int tagSize = 0;  	for (int i = 12; i < 16; i++) {  		tagSize += (buf [i] << ((i - 12) * 8));  	}  	bool containsHeader = ((buf [23] >> 7) == 1);  	tagSize += (containsHeader ? 32 : 0);  	return tagSize;  } finally {  	stream.Position = currentPosition;  }  
Magic Number,IdSharp.AudioInfo,APEv2,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\TagSizes\APEv2.cs,GetTagSize,The following statement contains a magic number: try {  	byte[] buf = new byte[32];  	stream.Seek (-32' SeekOrigin.End);  	stream.Read (buf' 0' 32);  	if (ByteUtils.Compare (buf' APETAGEX' 8) == false) {  		// Skip past possible ID3v1 tag  		stream.Seek (-128 - 32' SeekOrigin.End);  		stream.Read (buf' 0' 32);  		if (ByteUtils.Compare (buf' APETAGEX' 8) == false) {  			// TODO: skip past possible Lyrics3 tag  			return 0;  		}  	}  	// Check version  	int version = 0;  	for (int i = 8; i < 12; i++) {  		version += (buf [i] << ((i - 8) * 8));  	}  	// Must be APEv2 or APEv1  	if (version != 2000 && version != 1000) {  		return 0;  	}  	// Size  	int tagSize = 0;  	for (int i = 12; i < 16; i++) {  		tagSize += (buf [i] << ((i - 12) * 8));  	}  	bool containsHeader = ((buf [23] >> 7) == 1);  	tagSize += (containsHeader ? 32 : 0);  	return tagSize;  } finally {  	stream.Position = currentPosition;  }  
Magic Number,IdSharp.AudioInfo,APEv2,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\TagSizes\APEv2.cs,GetTagSize,The following statement contains a magic number: try {  	byte[] buf = new byte[32];  	stream.Seek (-32' SeekOrigin.End);  	stream.Read (buf' 0' 32);  	if (ByteUtils.Compare (buf' APETAGEX' 8) == false) {  		// Skip past possible ID3v1 tag  		stream.Seek (-128 - 32' SeekOrigin.End);  		stream.Read (buf' 0' 32);  		if (ByteUtils.Compare (buf' APETAGEX' 8) == false) {  			// TODO: skip past possible Lyrics3 tag  			return 0;  		}  	}  	// Check version  	int version = 0;  	for (int i = 8; i < 12; i++) {  		version += (buf [i] << ((i - 8) * 8));  	}  	// Must be APEv2 or APEv1  	if (version != 2000 && version != 1000) {  		return 0;  	}  	// Size  	int tagSize = 0;  	for (int i = 12; i < 16; i++) {  		tagSize += (buf [i] << ((i - 12) * 8));  	}  	bool containsHeader = ((buf [23] >> 7) == 1);  	tagSize += (containsHeader ? 32 : 0);  	return tagSize;  } finally {  	stream.Position = currentPosition;  }  
Magic Number,IdSharp.AudioInfo,APEv2,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\TagSizes\APEv2.cs,GetTagSize,The following statement contains a magic number: try {  	byte[] buf = new byte[32];  	stream.Seek (-32' SeekOrigin.End);  	stream.Read (buf' 0' 32);  	if (ByteUtils.Compare (buf' APETAGEX' 8) == false) {  		// Skip past possible ID3v1 tag  		stream.Seek (-128 - 32' SeekOrigin.End);  		stream.Read (buf' 0' 32);  		if (ByteUtils.Compare (buf' APETAGEX' 8) == false) {  			// TODO: skip past possible Lyrics3 tag  			return 0;  		}  	}  	// Check version  	int version = 0;  	for (int i = 8; i < 12; i++) {  		version += (buf [i] << ((i - 8) * 8));  	}  	// Must be APEv2 or APEv1  	if (version != 2000 && version != 1000) {  		return 0;  	}  	// Size  	int tagSize = 0;  	for (int i = 12; i < 16; i++) {  		tagSize += (buf [i] << ((i - 12) * 8));  	}  	bool containsHeader = ((buf [23] >> 7) == 1);  	tagSize += (containsHeader ? 32 : 0);  	return tagSize;  } finally {  	stream.Position = currentPosition;  }  
Magic Number,IdSharp.AudioInfo,APEv2,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\TagSizes\APEv2.cs,GetTagSize,The following statement contains a magic number: try {  	byte[] buf = new byte[32];  	stream.Seek (-32' SeekOrigin.End);  	stream.Read (buf' 0' 32);  	if (ByteUtils.Compare (buf' APETAGEX' 8) == false) {  		// Skip past possible ID3v1 tag  		stream.Seek (-128 - 32' SeekOrigin.End);  		stream.Read (buf' 0' 32);  		if (ByteUtils.Compare (buf' APETAGEX' 8) == false) {  			// TODO: skip past possible Lyrics3 tag  			return 0;  		}  	}  	// Check version  	int version = 0;  	for (int i = 8; i < 12; i++) {  		version += (buf [i] << ((i - 8) * 8));  	}  	// Must be APEv2 or APEv1  	if (version != 2000 && version != 1000) {  		return 0;  	}  	// Size  	int tagSize = 0;  	for (int i = 12; i < 16; i++) {  		tagSize += (buf [i] << ((i - 12) * 8));  	}  	bool containsHeader = ((buf [23] >> 7) == 1);  	tagSize += (containsHeader ? 32 : 0);  	return tagSize;  } finally {  	stream.Position = currentPosition;  }  
Magic Number,IdSharp.AudioInfo,APEv2,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\TagSizes\APEv2.cs,GetTagSize,The following statement contains a magic number: try {  	byte[] buf = new byte[32];  	stream.Seek (-32' SeekOrigin.End);  	stream.Read (buf' 0' 32);  	if (ByteUtils.Compare (buf' APETAGEX' 8) == false) {  		// Skip past possible ID3v1 tag  		stream.Seek (-128 - 32' SeekOrigin.End);  		stream.Read (buf' 0' 32);  		if (ByteUtils.Compare (buf' APETAGEX' 8) == false) {  			// TODO: skip past possible Lyrics3 tag  			return 0;  		}  	}  	// Check version  	int version = 0;  	for (int i = 8; i < 12; i++) {  		version += (buf [i] << ((i - 8) * 8));  	}  	// Must be APEv2 or APEv1  	if (version != 2000 && version != 1000) {  		return 0;  	}  	// Size  	int tagSize = 0;  	for (int i = 12; i < 16; i++) {  		tagSize += (buf [i] << ((i - 12) * 8));  	}  	bool containsHeader = ((buf [23] >> 7) == 1);  	tagSize += (containsHeader ? 32 : 0);  	return tagSize;  } finally {  	stream.Position = currentPosition;  }  
Magic Number,IdSharp.AudioInfo,APEv2,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\TagSizes\APEv2.cs,GetTagSize,The following statement contains a magic number: try {  	byte[] buf = new byte[32];  	stream.Seek (-32' SeekOrigin.End);  	stream.Read (buf' 0' 32);  	if (ByteUtils.Compare (buf' APETAGEX' 8) == false) {  		// Skip past possible ID3v1 tag  		stream.Seek (-128 - 32' SeekOrigin.End);  		stream.Read (buf' 0' 32);  		if (ByteUtils.Compare (buf' APETAGEX' 8) == false) {  			// TODO: skip past possible Lyrics3 tag  			return 0;  		}  	}  	// Check version  	int version = 0;  	for (int i = 8; i < 12; i++) {  		version += (buf [i] << ((i - 8) * 8));  	}  	// Must be APEv2 or APEv1  	if (version != 2000 && version != 1000) {  		return 0;  	}  	// Size  	int tagSize = 0;  	for (int i = 12; i < 16; i++) {  		tagSize += (buf [i] << ((i - 12) * 8));  	}  	bool containsHeader = ((buf [23] >> 7) == 1);  	tagSize += (containsHeader ? 32 : 0);  	return tagSize;  } finally {  	stream.Position = currentPosition;  }  
Magic Number,IdSharp.AudioInfo,APEv2,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\TagSizes\APEv2.cs,GetTagSize,The following statement contains a magic number: stream.Seek (-32' SeekOrigin.End);  
Magic Number,IdSharp.AudioInfo,APEv2,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\TagSizes\APEv2.cs,GetTagSize,The following statement contains a magic number: stream.Read (buf' 0' 32);  
Magic Number,IdSharp.AudioInfo,APEv2,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\TagSizes\APEv2.cs,GetTagSize,The following statement contains a magic number: if (ByteUtils.Compare (buf' APETAGEX' 8) == false) {  	// Skip past possible ID3v1 tag  	stream.Seek (-128 - 32' SeekOrigin.End);  	stream.Read (buf' 0' 32);  	if (ByteUtils.Compare (buf' APETAGEX' 8) == false) {  		// TODO: skip past possible Lyrics3 tag  		return 0;  	}  }  
Magic Number,IdSharp.AudioInfo,APEv2,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\TagSizes\APEv2.cs,GetTagSize,The following statement contains a magic number: if (ByteUtils.Compare (buf' APETAGEX' 8) == false) {  	// Skip past possible ID3v1 tag  	stream.Seek (-128 - 32' SeekOrigin.End);  	stream.Read (buf' 0' 32);  	if (ByteUtils.Compare (buf' APETAGEX' 8) == false) {  		// TODO: skip past possible Lyrics3 tag  		return 0;  	}  }  
Magic Number,IdSharp.AudioInfo,APEv2,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\TagSizes\APEv2.cs,GetTagSize,The following statement contains a magic number: if (ByteUtils.Compare (buf' APETAGEX' 8) == false) {  	// Skip past possible ID3v1 tag  	stream.Seek (-128 - 32' SeekOrigin.End);  	stream.Read (buf' 0' 32);  	if (ByteUtils.Compare (buf' APETAGEX' 8) == false) {  		// TODO: skip past possible Lyrics3 tag  		return 0;  	}  }  
Magic Number,IdSharp.AudioInfo,APEv2,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\TagSizes\APEv2.cs,GetTagSize,The following statement contains a magic number: if (ByteUtils.Compare (buf' APETAGEX' 8) == false) {  	// Skip past possible ID3v1 tag  	stream.Seek (-128 - 32' SeekOrigin.End);  	stream.Read (buf' 0' 32);  	if (ByteUtils.Compare (buf' APETAGEX' 8) == false) {  		// TODO: skip past possible Lyrics3 tag  		return 0;  	}  }  
Magic Number,IdSharp.AudioInfo,APEv2,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\TagSizes\APEv2.cs,GetTagSize,The following statement contains a magic number: if (ByteUtils.Compare (buf' APETAGEX' 8) == false) {  	// Skip past possible ID3v1 tag  	stream.Seek (-128 - 32' SeekOrigin.End);  	stream.Read (buf' 0' 32);  	if (ByteUtils.Compare (buf' APETAGEX' 8) == false) {  		// TODO: skip past possible Lyrics3 tag  		return 0;  	}  }  
Magic Number,IdSharp.AudioInfo,APEv2,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\TagSizes\APEv2.cs,GetTagSize,The following statement contains a magic number: stream.Seek (-128 - 32' SeekOrigin.End);  
Magic Number,IdSharp.AudioInfo,APEv2,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\TagSizes\APEv2.cs,GetTagSize,The following statement contains a magic number: stream.Seek (-128 - 32' SeekOrigin.End);  
Magic Number,IdSharp.AudioInfo,APEv2,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\TagSizes\APEv2.cs,GetTagSize,The following statement contains a magic number: stream.Read (buf' 0' 32);  
Magic Number,IdSharp.AudioInfo,APEv2,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\TagSizes\APEv2.cs,GetTagSize,The following statement contains a magic number: if (ByteUtils.Compare (buf' APETAGEX' 8) == false) {  	// TODO: skip past possible Lyrics3 tag  	return 0;  }  
Magic Number,IdSharp.AudioInfo,APEv2,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\TagSizes\APEv2.cs,GetTagSize,The following statement contains a magic number: for (int i = 8; i < 12; i++) {  	version += (buf [i] << ((i - 8) * 8));  }  
Magic Number,IdSharp.AudioInfo,APEv2,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\TagSizes\APEv2.cs,GetTagSize,The following statement contains a magic number: for (int i = 8; i < 12; i++) {  	version += (buf [i] << ((i - 8) * 8));  }  
Magic Number,IdSharp.AudioInfo,APEv2,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\TagSizes\APEv2.cs,GetTagSize,The following statement contains a magic number: for (int i = 8; i < 12; i++) {  	version += (buf [i] << ((i - 8) * 8));  }  
Magic Number,IdSharp.AudioInfo,APEv2,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\TagSizes\APEv2.cs,GetTagSize,The following statement contains a magic number: for (int i = 8; i < 12; i++) {  	version += (buf [i] << ((i - 8) * 8));  }  
Magic Number,IdSharp.AudioInfo,APEv2,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\TagSizes\APEv2.cs,GetTagSize,The following statement contains a magic number: version += (buf [i] << ((i - 8) * 8));  
Magic Number,IdSharp.AudioInfo,APEv2,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\TagSizes\APEv2.cs,GetTagSize,The following statement contains a magic number: version += (buf [i] << ((i - 8) * 8));  
Magic Number,IdSharp.AudioInfo,APEv2,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\TagSizes\APEv2.cs,GetTagSize,The following statement contains a magic number: if (version != 2000 && version != 1000) {  	return 0;  }  
Magic Number,IdSharp.AudioInfo,APEv2,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\TagSizes\APEv2.cs,GetTagSize,The following statement contains a magic number: if (version != 2000 && version != 1000) {  	return 0;  }  
Magic Number,IdSharp.AudioInfo,APEv2,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\TagSizes\APEv2.cs,GetTagSize,The following statement contains a magic number: for (int i = 12; i < 16; i++) {  	tagSize += (buf [i] << ((i - 12) * 8));  }  
Magic Number,IdSharp.AudioInfo,APEv2,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\TagSizes\APEv2.cs,GetTagSize,The following statement contains a magic number: for (int i = 12; i < 16; i++) {  	tagSize += (buf [i] << ((i - 12) * 8));  }  
Magic Number,IdSharp.AudioInfo,APEv2,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\TagSizes\APEv2.cs,GetTagSize,The following statement contains a magic number: for (int i = 12; i < 16; i++) {  	tagSize += (buf [i] << ((i - 12) * 8));  }  
Magic Number,IdSharp.AudioInfo,APEv2,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\TagSizes\APEv2.cs,GetTagSize,The following statement contains a magic number: for (int i = 12; i < 16; i++) {  	tagSize += (buf [i] << ((i - 12) * 8));  }  
Magic Number,IdSharp.AudioInfo,APEv2,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\TagSizes\APEv2.cs,GetTagSize,The following statement contains a magic number: tagSize += (buf [i] << ((i - 12) * 8));  
Magic Number,IdSharp.AudioInfo,APEv2,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\TagSizes\APEv2.cs,GetTagSize,The following statement contains a magic number: tagSize += (buf [i] << ((i - 12) * 8));  
Magic Number,IdSharp.AudioInfo,APEv2,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\TagSizes\APEv2.cs,GetTagSize,The following statement contains a magic number: tagSize += (containsHeader ? 32 : 0);  
Magic Number,IdSharp.AudioInfo,ID3v1,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\TagSizes\ID3v1.cs,GetTagSize,The following statement contains a magic number: try {  	if (stream.Length >= 128) {  		stream.Seek (-128' SeekOrigin.End);  		byte[] buf = new byte[3];  		stream.Read (buf' 0' 3);  		// Check for 'TAG'  		if (buf [0] == 0x54 && buf [1] == 0x41 && buf [2] == 0x47) {  			return 128;  		}  	}  	return 0;  } finally {  	stream.Position = currentPosition;  }  
Magic Number,IdSharp.AudioInfo,ID3v1,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\TagSizes\ID3v1.cs,GetTagSize,The following statement contains a magic number: try {  	if (stream.Length >= 128) {  		stream.Seek (-128' SeekOrigin.End);  		byte[] buf = new byte[3];  		stream.Read (buf' 0' 3);  		// Check for 'TAG'  		if (buf [0] == 0x54 && buf [1] == 0x41 && buf [2] == 0x47) {  			return 128;  		}  	}  	return 0;  } finally {  	stream.Position = currentPosition;  }  
Magic Number,IdSharp.AudioInfo,ID3v1,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\TagSizes\ID3v1.cs,GetTagSize,The following statement contains a magic number: try {  	if (stream.Length >= 128) {  		stream.Seek (-128' SeekOrigin.End);  		byte[] buf = new byte[3];  		stream.Read (buf' 0' 3);  		// Check for 'TAG'  		if (buf [0] == 0x54 && buf [1] == 0x41 && buf [2] == 0x47) {  			return 128;  		}  	}  	return 0;  } finally {  	stream.Position = currentPosition;  }  
Magic Number,IdSharp.AudioInfo,ID3v1,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\TagSizes\ID3v1.cs,GetTagSize,The following statement contains a magic number: try {  	if (stream.Length >= 128) {  		stream.Seek (-128' SeekOrigin.End);  		byte[] buf = new byte[3];  		stream.Read (buf' 0' 3);  		// Check for 'TAG'  		if (buf [0] == 0x54 && buf [1] == 0x41 && buf [2] == 0x47) {  			return 128;  		}  	}  	return 0;  } finally {  	stream.Position = currentPosition;  }  
Magic Number,IdSharp.AudioInfo,ID3v1,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\TagSizes\ID3v1.cs,GetTagSize,The following statement contains a magic number: try {  	if (stream.Length >= 128) {  		stream.Seek (-128' SeekOrigin.End);  		byte[] buf = new byte[3];  		stream.Read (buf' 0' 3);  		// Check for 'TAG'  		if (buf [0] == 0x54 && buf [1] == 0x41 && buf [2] == 0x47) {  			return 128;  		}  	}  	return 0;  } finally {  	stream.Position = currentPosition;  }  
Magic Number,IdSharp.AudioInfo,ID3v1,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\TagSizes\ID3v1.cs,GetTagSize,The following statement contains a magic number: try {  	if (stream.Length >= 128) {  		stream.Seek (-128' SeekOrigin.End);  		byte[] buf = new byte[3];  		stream.Read (buf' 0' 3);  		// Check for 'TAG'  		if (buf [0] == 0x54 && buf [1] == 0x41 && buf [2] == 0x47) {  			return 128;  		}  	}  	return 0;  } finally {  	stream.Position = currentPosition;  }  
Magic Number,IdSharp.AudioInfo,ID3v1,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\TagSizes\ID3v1.cs,GetTagSize,The following statement contains a magic number: if (stream.Length >= 128) {  	stream.Seek (-128' SeekOrigin.End);  	byte[] buf = new byte[3];  	stream.Read (buf' 0' 3);  	// Check for 'TAG'  	if (buf [0] == 0x54 && buf [1] == 0x41 && buf [2] == 0x47) {  		return 128;  	}  }  
Magic Number,IdSharp.AudioInfo,ID3v1,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\TagSizes\ID3v1.cs,GetTagSize,The following statement contains a magic number: if (stream.Length >= 128) {  	stream.Seek (-128' SeekOrigin.End);  	byte[] buf = new byte[3];  	stream.Read (buf' 0' 3);  	// Check for 'TAG'  	if (buf [0] == 0x54 && buf [1] == 0x41 && buf [2] == 0x47) {  		return 128;  	}  }  
Magic Number,IdSharp.AudioInfo,ID3v1,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\TagSizes\ID3v1.cs,GetTagSize,The following statement contains a magic number: if (stream.Length >= 128) {  	stream.Seek (-128' SeekOrigin.End);  	byte[] buf = new byte[3];  	stream.Read (buf' 0' 3);  	// Check for 'TAG'  	if (buf [0] == 0x54 && buf [1] == 0x41 && buf [2] == 0x47) {  		return 128;  	}  }  
Magic Number,IdSharp.AudioInfo,ID3v1,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\TagSizes\ID3v1.cs,GetTagSize,The following statement contains a magic number: if (stream.Length >= 128) {  	stream.Seek (-128' SeekOrigin.End);  	byte[] buf = new byte[3];  	stream.Read (buf' 0' 3);  	// Check for 'TAG'  	if (buf [0] == 0x54 && buf [1] == 0x41 && buf [2] == 0x47) {  		return 128;  	}  }  
Magic Number,IdSharp.AudioInfo,ID3v1,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\TagSizes\ID3v1.cs,GetTagSize,The following statement contains a magic number: if (stream.Length >= 128) {  	stream.Seek (-128' SeekOrigin.End);  	byte[] buf = new byte[3];  	stream.Read (buf' 0' 3);  	// Check for 'TAG'  	if (buf [0] == 0x54 && buf [1] == 0x41 && buf [2] == 0x47) {  		return 128;  	}  }  
Magic Number,IdSharp.AudioInfo,ID3v1,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\TagSizes\ID3v1.cs,GetTagSize,The following statement contains a magic number: if (stream.Length >= 128) {  	stream.Seek (-128' SeekOrigin.End);  	byte[] buf = new byte[3];  	stream.Read (buf' 0' 3);  	// Check for 'TAG'  	if (buf [0] == 0x54 && buf [1] == 0x41 && buf [2] == 0x47) {  		return 128;  	}  }  
Magic Number,IdSharp.AudioInfo,ID3v1,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\TagSizes\ID3v1.cs,GetTagSize,The following statement contains a magic number: stream.Seek (-128' SeekOrigin.End);  
Magic Number,IdSharp.AudioInfo,ID3v1,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\TagSizes\ID3v1.cs,GetTagSize,The following statement contains a magic number: stream.Read (buf' 0' 3);  
Magic Number,IdSharp.AudioInfo,ID3v1,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\TagSizes\ID3v1.cs,GetTagSize,The following statement contains a magic number: if (buf [0] == 0x54 && buf [1] == 0x41 && buf [2] == 0x47) {  	return 128;  }  
Magic Number,IdSharp.AudioInfo,ID3v1,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\TagSizes\ID3v1.cs,GetTagSize,The following statement contains a magic number: if (buf [0] == 0x54 && buf [1] == 0x41 && buf [2] == 0x47) {  	return 128;  }  
Magic Number,IdSharp.AudioInfo,ID3v1,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\TagSizes\ID3v1.cs,GetTagSize,The following statement contains a magic number: return 128;  
Magic Number,IdSharp.AudioInfo,ID3v2,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\TagSizes\ID3v2.cs,GetTagSize,The following statement contains a magic number: try {  	if (stream.Length >= 16) {  		stream.Position = 0;  		byte[] identifier = stream.Read (3);  		// Identifier 'ID3'  		if (!(identifier [0] == 0x49 && identifier [1] == 0x44 && identifier [2] == 0x33)) {  			return 0;  		}  		ID3v2Header header = new ID3v2Header (stream);  		int tagSize = header.TagSize;  		if (tagSize != 0)  			return tagSize + 10 + (header.IsFooterPresent ? 10 : 0);  		else  			return 0;  	}  	return 0;  } finally {  	stream.Position = 0;  }  
Magic Number,IdSharp.AudioInfo,ID3v2,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\TagSizes\ID3v2.cs,GetTagSize,The following statement contains a magic number: try {  	if (stream.Length >= 16) {  		stream.Position = 0;  		byte[] identifier = stream.Read (3);  		// Identifier 'ID3'  		if (!(identifier [0] == 0x49 && identifier [1] == 0x44 && identifier [2] == 0x33)) {  			return 0;  		}  		ID3v2Header header = new ID3v2Header (stream);  		int tagSize = header.TagSize;  		if (tagSize != 0)  			return tagSize + 10 + (header.IsFooterPresent ? 10 : 0);  		else  			return 0;  	}  	return 0;  } finally {  	stream.Position = 0;  }  
Magic Number,IdSharp.AudioInfo,ID3v2,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\TagSizes\ID3v2.cs,GetTagSize,The following statement contains a magic number: try {  	if (stream.Length >= 16) {  		stream.Position = 0;  		byte[] identifier = stream.Read (3);  		// Identifier 'ID3'  		if (!(identifier [0] == 0x49 && identifier [1] == 0x44 && identifier [2] == 0x33)) {  			return 0;  		}  		ID3v2Header header = new ID3v2Header (stream);  		int tagSize = header.TagSize;  		if (tagSize != 0)  			return tagSize + 10 + (header.IsFooterPresent ? 10 : 0);  		else  			return 0;  	}  	return 0;  } finally {  	stream.Position = 0;  }  
Magic Number,IdSharp.AudioInfo,ID3v2,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\TagSizes\ID3v2.cs,GetTagSize,The following statement contains a magic number: try {  	if (stream.Length >= 16) {  		stream.Position = 0;  		byte[] identifier = stream.Read (3);  		// Identifier 'ID3'  		if (!(identifier [0] == 0x49 && identifier [1] == 0x44 && identifier [2] == 0x33)) {  			return 0;  		}  		ID3v2Header header = new ID3v2Header (stream);  		int tagSize = header.TagSize;  		if (tagSize != 0)  			return tagSize + 10 + (header.IsFooterPresent ? 10 : 0);  		else  			return 0;  	}  	return 0;  } finally {  	stream.Position = 0;  }  
Magic Number,IdSharp.AudioInfo,ID3v2,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\TagSizes\ID3v2.cs,GetTagSize,The following statement contains a magic number: try {  	if (stream.Length >= 16) {  		stream.Position = 0;  		byte[] identifier = stream.Read (3);  		// Identifier 'ID3'  		if (!(identifier [0] == 0x49 && identifier [1] == 0x44 && identifier [2] == 0x33)) {  			return 0;  		}  		ID3v2Header header = new ID3v2Header (stream);  		int tagSize = header.TagSize;  		if (tagSize != 0)  			return tagSize + 10 + (header.IsFooterPresent ? 10 : 0);  		else  			return 0;  	}  	return 0;  } finally {  	stream.Position = 0;  }  
Magic Number,IdSharp.AudioInfo,ID3v2,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\TagSizes\ID3v2.cs,GetTagSize,The following statement contains a magic number: if (stream.Length >= 16) {  	stream.Position = 0;  	byte[] identifier = stream.Read (3);  	// Identifier 'ID3'  	if (!(identifier [0] == 0x49 && identifier [1] == 0x44 && identifier [2] == 0x33)) {  		return 0;  	}  	ID3v2Header header = new ID3v2Header (stream);  	int tagSize = header.TagSize;  	if (tagSize != 0)  		return tagSize + 10 + (header.IsFooterPresent ? 10 : 0);  	else  		return 0;  }  
Magic Number,IdSharp.AudioInfo,ID3v2,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\TagSizes\ID3v2.cs,GetTagSize,The following statement contains a magic number: if (stream.Length >= 16) {  	stream.Position = 0;  	byte[] identifier = stream.Read (3);  	// Identifier 'ID3'  	if (!(identifier [0] == 0x49 && identifier [1] == 0x44 && identifier [2] == 0x33)) {  		return 0;  	}  	ID3v2Header header = new ID3v2Header (stream);  	int tagSize = header.TagSize;  	if (tagSize != 0)  		return tagSize + 10 + (header.IsFooterPresent ? 10 : 0);  	else  		return 0;  }  
Magic Number,IdSharp.AudioInfo,ID3v2,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\TagSizes\ID3v2.cs,GetTagSize,The following statement contains a magic number: if (stream.Length >= 16) {  	stream.Position = 0;  	byte[] identifier = stream.Read (3);  	// Identifier 'ID3'  	if (!(identifier [0] == 0x49 && identifier [1] == 0x44 && identifier [2] == 0x33)) {  		return 0;  	}  	ID3v2Header header = new ID3v2Header (stream);  	int tagSize = header.TagSize;  	if (tagSize != 0)  		return tagSize + 10 + (header.IsFooterPresent ? 10 : 0);  	else  		return 0;  }  
Magic Number,IdSharp.AudioInfo,ID3v2,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\TagSizes\ID3v2.cs,GetTagSize,The following statement contains a magic number: if (stream.Length >= 16) {  	stream.Position = 0;  	byte[] identifier = stream.Read (3);  	// Identifier 'ID3'  	if (!(identifier [0] == 0x49 && identifier [1] == 0x44 && identifier [2] == 0x33)) {  		return 0;  	}  	ID3v2Header header = new ID3v2Header (stream);  	int tagSize = header.TagSize;  	if (tagSize != 0)  		return tagSize + 10 + (header.IsFooterPresent ? 10 : 0);  	else  		return 0;  }  
Magic Number,IdSharp.AudioInfo,ID3v2,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\TagSizes\ID3v2.cs,GetTagSize,The following statement contains a magic number: if (stream.Length >= 16) {  	stream.Position = 0;  	byte[] identifier = stream.Read (3);  	// Identifier 'ID3'  	if (!(identifier [0] == 0x49 && identifier [1] == 0x44 && identifier [2] == 0x33)) {  		return 0;  	}  	ID3v2Header header = new ID3v2Header (stream);  	int tagSize = header.TagSize;  	if (tagSize != 0)  		return tagSize + 10 + (header.IsFooterPresent ? 10 : 0);  	else  		return 0;  }  
Magic Number,IdSharp.AudioInfo,ID3v2,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\TagSizes\ID3v2.cs,GetTagSize,The following statement contains a magic number: if (!(identifier [0] == 0x49 && identifier [1] == 0x44 && identifier [2] == 0x33)) {  	return 0;  }  
Magic Number,IdSharp.AudioInfo,ID3v2,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\TagSizes\ID3v2.cs,GetTagSize,The following statement contains a magic number: if (tagSize != 0)  	return tagSize + 10 + (header.IsFooterPresent ? 10 : 0);  else  	return 0;  
Magic Number,IdSharp.AudioInfo,ID3v2,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\TagSizes\ID3v2.cs,GetTagSize,The following statement contains a magic number: if (tagSize != 0)  	return tagSize + 10 + (header.IsFooterPresent ? 10 : 0);  else  	return 0;  
Magic Number,IdSharp.AudioInfo,ID3v2,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\TagSizes\ID3v2.cs,GetTagSize,The following statement contains a magic number: return tagSize + 10 + (header.IsFooterPresent ? 10 : 0);  
Magic Number,IdSharp.AudioInfo,ID3v2,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\TagSizes\ID3v2.cs,GetTagSize,The following statement contains a magic number: return tagSize + 10 + (header.IsFooterPresent ? 10 : 0);  
Magic Number,IdSharp.AudioInfo,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\TagSizes\Mpeg4Tag.cs,ReadInt32,The following statement contains a magic number: n += (data [offset + 1] & 0xff) << 16;  
Magic Number,IdSharp.AudioInfo,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\TagSizes\Mpeg4Tag.cs,ReadInt32,The following statement contains a magic number: n += (data [offset + 2] & 0xff) << 8;  
Magic Number,IdSharp.AudioInfo,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\TagSizes\Mpeg4Tag.cs,ReadInt32,The following statement contains a magic number: n += (data [offset + 2] & 0xff) << 8;  
Magic Number,IdSharp.AudioInfo,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\TagSizes\Mpeg4Tag.cs,ReadInt32,The following statement contains a magic number: n += (data [offset + 3] & 0xff);  
Magic Number,IdSharp.AudioInfo,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\TagSizes\Mpeg4Tag.cs,ParseStsdAtom,The following statement contains a magic number: for (int i = 0; i < num; i++) {  	int size = ReadInt32 (atomdata' stsdOff);  	stsdOff += 4;  	Buffer.BlockCopy (atomdata' stsdOff' data_format' 0' 4);  	stsdOff += 12;  	byte[] data = new byte[size - 4 - 12];  	Buffer.BlockCopy (atomdata' stsdOff' data' 0' (size - 4 - 12));  	stsdOff += (size - 4 - 12);  	Buffer.BlockCopy (data' 4' encoder_vendor' 0' 4);  	if (encoder_vendor [0] == 0) {  		Frequency = ((data [16] & 0xff) << 8) + (data [17] & 0xff);  		Channels = (data [8] << 8) + data [9];  		if (ByteUtils.Compare (data_format' Encoding.ASCII.GetBytes ("mp4a"))) {  			Codec = "AAC";  		} else {  			Codec = Encoding.UTF8.GetString (data_format);  		}  	}  }  
Magic Number,IdSharp.AudioInfo,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\TagSizes\Mpeg4Tag.cs,ParseStsdAtom,The following statement contains a magic number: for (int i = 0; i < num; i++) {  	int size = ReadInt32 (atomdata' stsdOff);  	stsdOff += 4;  	Buffer.BlockCopy (atomdata' stsdOff' data_format' 0' 4);  	stsdOff += 12;  	byte[] data = new byte[size - 4 - 12];  	Buffer.BlockCopy (atomdata' stsdOff' data' 0' (size - 4 - 12));  	stsdOff += (size - 4 - 12);  	Buffer.BlockCopy (data' 4' encoder_vendor' 0' 4);  	if (encoder_vendor [0] == 0) {  		Frequency = ((data [16] & 0xff) << 8) + (data [17] & 0xff);  		Channels = (data [8] << 8) + data [9];  		if (ByteUtils.Compare (data_format' Encoding.ASCII.GetBytes ("mp4a"))) {  			Codec = "AAC";  		} else {  			Codec = Encoding.UTF8.GetString (data_format);  		}  	}  }  
Magic Number,IdSharp.AudioInfo,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\TagSizes\Mpeg4Tag.cs,ParseStsdAtom,The following statement contains a magic number: for (int i = 0; i < num; i++) {  	int size = ReadInt32 (atomdata' stsdOff);  	stsdOff += 4;  	Buffer.BlockCopy (atomdata' stsdOff' data_format' 0' 4);  	stsdOff += 12;  	byte[] data = new byte[size - 4 - 12];  	Buffer.BlockCopy (atomdata' stsdOff' data' 0' (size - 4 - 12));  	stsdOff += (size - 4 - 12);  	Buffer.BlockCopy (data' 4' encoder_vendor' 0' 4);  	if (encoder_vendor [0] == 0) {  		Frequency = ((data [16] & 0xff) << 8) + (data [17] & 0xff);  		Channels = (data [8] << 8) + data [9];  		if (ByteUtils.Compare (data_format' Encoding.ASCII.GetBytes ("mp4a"))) {  			Codec = "AAC";  		} else {  			Codec = Encoding.UTF8.GetString (data_format);  		}  	}  }  
Magic Number,IdSharp.AudioInfo,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\TagSizes\Mpeg4Tag.cs,ParseStsdAtom,The following statement contains a magic number: for (int i = 0; i < num; i++) {  	int size = ReadInt32 (atomdata' stsdOff);  	stsdOff += 4;  	Buffer.BlockCopy (atomdata' stsdOff' data_format' 0' 4);  	stsdOff += 12;  	byte[] data = new byte[size - 4 - 12];  	Buffer.BlockCopy (atomdata' stsdOff' data' 0' (size - 4 - 12));  	stsdOff += (size - 4 - 12);  	Buffer.BlockCopy (data' 4' encoder_vendor' 0' 4);  	if (encoder_vendor [0] == 0) {  		Frequency = ((data [16] & 0xff) << 8) + (data [17] & 0xff);  		Channels = (data [8] << 8) + data [9];  		if (ByteUtils.Compare (data_format' Encoding.ASCII.GetBytes ("mp4a"))) {  			Codec = "AAC";  		} else {  			Codec = Encoding.UTF8.GetString (data_format);  		}  	}  }  
Magic Number,IdSharp.AudioInfo,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\TagSizes\Mpeg4Tag.cs,ParseStsdAtom,The following statement contains a magic number: for (int i = 0; i < num; i++) {  	int size = ReadInt32 (atomdata' stsdOff);  	stsdOff += 4;  	Buffer.BlockCopy (atomdata' stsdOff' data_format' 0' 4);  	stsdOff += 12;  	byte[] data = new byte[size - 4 - 12];  	Buffer.BlockCopy (atomdata' stsdOff' data' 0' (size - 4 - 12));  	stsdOff += (size - 4 - 12);  	Buffer.BlockCopy (data' 4' encoder_vendor' 0' 4);  	if (encoder_vendor [0] == 0) {  		Frequency = ((data [16] & 0xff) << 8) + (data [17] & 0xff);  		Channels = (data [8] << 8) + data [9];  		if (ByteUtils.Compare (data_format' Encoding.ASCII.GetBytes ("mp4a"))) {  			Codec = "AAC";  		} else {  			Codec = Encoding.UTF8.GetString (data_format);  		}  	}  }  
Magic Number,IdSharp.AudioInfo,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\TagSizes\Mpeg4Tag.cs,ParseStsdAtom,The following statement contains a magic number: for (int i = 0; i < num; i++) {  	int size = ReadInt32 (atomdata' stsdOff);  	stsdOff += 4;  	Buffer.BlockCopy (atomdata' stsdOff' data_format' 0' 4);  	stsdOff += 12;  	byte[] data = new byte[size - 4 - 12];  	Buffer.BlockCopy (atomdata' stsdOff' data' 0' (size - 4 - 12));  	stsdOff += (size - 4 - 12);  	Buffer.BlockCopy (data' 4' encoder_vendor' 0' 4);  	if (encoder_vendor [0] == 0) {  		Frequency = ((data [16] & 0xff) << 8) + (data [17] & 0xff);  		Channels = (data [8] << 8) + data [9];  		if (ByteUtils.Compare (data_format' Encoding.ASCII.GetBytes ("mp4a"))) {  			Codec = "AAC";  		} else {  			Codec = Encoding.UTF8.GetString (data_format);  		}  	}  }  
Magic Number,IdSharp.AudioInfo,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\TagSizes\Mpeg4Tag.cs,ParseStsdAtom,The following statement contains a magic number: for (int i = 0; i < num; i++) {  	int size = ReadInt32 (atomdata' stsdOff);  	stsdOff += 4;  	Buffer.BlockCopy (atomdata' stsdOff' data_format' 0' 4);  	stsdOff += 12;  	byte[] data = new byte[size - 4 - 12];  	Buffer.BlockCopy (atomdata' stsdOff' data' 0' (size - 4 - 12));  	stsdOff += (size - 4 - 12);  	Buffer.BlockCopy (data' 4' encoder_vendor' 0' 4);  	if (encoder_vendor [0] == 0) {  		Frequency = ((data [16] & 0xff) << 8) + (data [17] & 0xff);  		Channels = (data [8] << 8) + data [9];  		if (ByteUtils.Compare (data_format' Encoding.ASCII.GetBytes ("mp4a"))) {  			Codec = "AAC";  		} else {  			Codec = Encoding.UTF8.GetString (data_format);  		}  	}  }  
Magic Number,IdSharp.AudioInfo,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\TagSizes\Mpeg4Tag.cs,ParseStsdAtom,The following statement contains a magic number: for (int i = 0; i < num; i++) {  	int size = ReadInt32 (atomdata' stsdOff);  	stsdOff += 4;  	Buffer.BlockCopy (atomdata' stsdOff' data_format' 0' 4);  	stsdOff += 12;  	byte[] data = new byte[size - 4 - 12];  	Buffer.BlockCopy (atomdata' stsdOff' data' 0' (size - 4 - 12));  	stsdOff += (size - 4 - 12);  	Buffer.BlockCopy (data' 4' encoder_vendor' 0' 4);  	if (encoder_vendor [0] == 0) {  		Frequency = ((data [16] & 0xff) << 8) + (data [17] & 0xff);  		Channels = (data [8] << 8) + data [9];  		if (ByteUtils.Compare (data_format' Encoding.ASCII.GetBytes ("mp4a"))) {  			Codec = "AAC";  		} else {  			Codec = Encoding.UTF8.GetString (data_format);  		}  	}  }  
Magic Number,IdSharp.AudioInfo,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\TagSizes\Mpeg4Tag.cs,ParseStsdAtom,The following statement contains a magic number: for (int i = 0; i < num; i++) {  	int size = ReadInt32 (atomdata' stsdOff);  	stsdOff += 4;  	Buffer.BlockCopy (atomdata' stsdOff' data_format' 0' 4);  	stsdOff += 12;  	byte[] data = new byte[size - 4 - 12];  	Buffer.BlockCopy (atomdata' stsdOff' data' 0' (size - 4 - 12));  	stsdOff += (size - 4 - 12);  	Buffer.BlockCopy (data' 4' encoder_vendor' 0' 4);  	if (encoder_vendor [0] == 0) {  		Frequency = ((data [16] & 0xff) << 8) + (data [17] & 0xff);  		Channels = (data [8] << 8) + data [9];  		if (ByteUtils.Compare (data_format' Encoding.ASCII.GetBytes ("mp4a"))) {  			Codec = "AAC";  		} else {  			Codec = Encoding.UTF8.GetString (data_format);  		}  	}  }  
Magic Number,IdSharp.AudioInfo,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\TagSizes\Mpeg4Tag.cs,ParseStsdAtom,The following statement contains a magic number: for (int i = 0; i < num; i++) {  	int size = ReadInt32 (atomdata' stsdOff);  	stsdOff += 4;  	Buffer.BlockCopy (atomdata' stsdOff' data_format' 0' 4);  	stsdOff += 12;  	byte[] data = new byte[size - 4 - 12];  	Buffer.BlockCopy (atomdata' stsdOff' data' 0' (size - 4 - 12));  	stsdOff += (size - 4 - 12);  	Buffer.BlockCopy (data' 4' encoder_vendor' 0' 4);  	if (encoder_vendor [0] == 0) {  		Frequency = ((data [16] & 0xff) << 8) + (data [17] & 0xff);  		Channels = (data [8] << 8) + data [9];  		if (ByteUtils.Compare (data_format' Encoding.ASCII.GetBytes ("mp4a"))) {  			Codec = "AAC";  		} else {  			Codec = Encoding.UTF8.GetString (data_format);  		}  	}  }  
Magic Number,IdSharp.AudioInfo,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\TagSizes\Mpeg4Tag.cs,ParseStsdAtom,The following statement contains a magic number: for (int i = 0; i < num; i++) {  	int size = ReadInt32 (atomdata' stsdOff);  	stsdOff += 4;  	Buffer.BlockCopy (atomdata' stsdOff' data_format' 0' 4);  	stsdOff += 12;  	byte[] data = new byte[size - 4 - 12];  	Buffer.BlockCopy (atomdata' stsdOff' data' 0' (size - 4 - 12));  	stsdOff += (size - 4 - 12);  	Buffer.BlockCopy (data' 4' encoder_vendor' 0' 4);  	if (encoder_vendor [0] == 0) {  		Frequency = ((data [16] & 0xff) << 8) + (data [17] & 0xff);  		Channels = (data [8] << 8) + data [9];  		if (ByteUtils.Compare (data_format' Encoding.ASCII.GetBytes ("mp4a"))) {  			Codec = "AAC";  		} else {  			Codec = Encoding.UTF8.GetString (data_format);  		}  	}  }  
Magic Number,IdSharp.AudioInfo,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\TagSizes\Mpeg4Tag.cs,ParseStsdAtom,The following statement contains a magic number: for (int i = 0; i < num; i++) {  	int size = ReadInt32 (atomdata' stsdOff);  	stsdOff += 4;  	Buffer.BlockCopy (atomdata' stsdOff' data_format' 0' 4);  	stsdOff += 12;  	byte[] data = new byte[size - 4 - 12];  	Buffer.BlockCopy (atomdata' stsdOff' data' 0' (size - 4 - 12));  	stsdOff += (size - 4 - 12);  	Buffer.BlockCopy (data' 4' encoder_vendor' 0' 4);  	if (encoder_vendor [0] == 0) {  		Frequency = ((data [16] & 0xff) << 8) + (data [17] & 0xff);  		Channels = (data [8] << 8) + data [9];  		if (ByteUtils.Compare (data_format' Encoding.ASCII.GetBytes ("mp4a"))) {  			Codec = "AAC";  		} else {  			Codec = Encoding.UTF8.GetString (data_format);  		}  	}  }  
Magic Number,IdSharp.AudioInfo,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\TagSizes\Mpeg4Tag.cs,ParseStsdAtom,The following statement contains a magic number: for (int i = 0; i < num; i++) {  	int size = ReadInt32 (atomdata' stsdOff);  	stsdOff += 4;  	Buffer.BlockCopy (atomdata' stsdOff' data_format' 0' 4);  	stsdOff += 12;  	byte[] data = new byte[size - 4 - 12];  	Buffer.BlockCopy (atomdata' stsdOff' data' 0' (size - 4 - 12));  	stsdOff += (size - 4 - 12);  	Buffer.BlockCopy (data' 4' encoder_vendor' 0' 4);  	if (encoder_vendor [0] == 0) {  		Frequency = ((data [16] & 0xff) << 8) + (data [17] & 0xff);  		Channels = (data [8] << 8) + data [9];  		if (ByteUtils.Compare (data_format' Encoding.ASCII.GetBytes ("mp4a"))) {  			Codec = "AAC";  		} else {  			Codec = Encoding.UTF8.GetString (data_format);  		}  	}  }  
Magic Number,IdSharp.AudioInfo,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\TagSizes\Mpeg4Tag.cs,ParseStsdAtom,The following statement contains a magic number: for (int i = 0; i < num; i++) {  	int size = ReadInt32 (atomdata' stsdOff);  	stsdOff += 4;  	Buffer.BlockCopy (atomdata' stsdOff' data_format' 0' 4);  	stsdOff += 12;  	byte[] data = new byte[size - 4 - 12];  	Buffer.BlockCopy (atomdata' stsdOff' data' 0' (size - 4 - 12));  	stsdOff += (size - 4 - 12);  	Buffer.BlockCopy (data' 4' encoder_vendor' 0' 4);  	if (encoder_vendor [0] == 0) {  		Frequency = ((data [16] & 0xff) << 8) + (data [17] & 0xff);  		Channels = (data [8] << 8) + data [9];  		if (ByteUtils.Compare (data_format' Encoding.ASCII.GetBytes ("mp4a"))) {  			Codec = "AAC";  		} else {  			Codec = Encoding.UTF8.GetString (data_format);  		}  	}  }  
Magic Number,IdSharp.AudioInfo,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\TagSizes\Mpeg4Tag.cs,ParseStsdAtom,The following statement contains a magic number: for (int i = 0; i < num; i++) {  	int size = ReadInt32 (atomdata' stsdOff);  	stsdOff += 4;  	Buffer.BlockCopy (atomdata' stsdOff' data_format' 0' 4);  	stsdOff += 12;  	byte[] data = new byte[size - 4 - 12];  	Buffer.BlockCopy (atomdata' stsdOff' data' 0' (size - 4 - 12));  	stsdOff += (size - 4 - 12);  	Buffer.BlockCopy (data' 4' encoder_vendor' 0' 4);  	if (encoder_vendor [0] == 0) {  		Frequency = ((data [16] & 0xff) << 8) + (data [17] & 0xff);  		Channels = (data [8] << 8) + data [9];  		if (ByteUtils.Compare (data_format' Encoding.ASCII.GetBytes ("mp4a"))) {  			Codec = "AAC";  		} else {  			Codec = Encoding.UTF8.GetString (data_format);  		}  	}  }  
Magic Number,IdSharp.AudioInfo,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\TagSizes\Mpeg4Tag.cs,ParseStsdAtom,The following statement contains a magic number: for (int i = 0; i < num; i++) {  	int size = ReadInt32 (atomdata' stsdOff);  	stsdOff += 4;  	Buffer.BlockCopy (atomdata' stsdOff' data_format' 0' 4);  	stsdOff += 12;  	byte[] data = new byte[size - 4 - 12];  	Buffer.BlockCopy (atomdata' stsdOff' data' 0' (size - 4 - 12));  	stsdOff += (size - 4 - 12);  	Buffer.BlockCopy (data' 4' encoder_vendor' 0' 4);  	if (encoder_vendor [0] == 0) {  		Frequency = ((data [16] & 0xff) << 8) + (data [17] & 0xff);  		Channels = (data [8] << 8) + data [9];  		if (ByteUtils.Compare (data_format' Encoding.ASCII.GetBytes ("mp4a"))) {  			Codec = "AAC";  		} else {  			Codec = Encoding.UTF8.GetString (data_format);  		}  	}  }  
Magic Number,IdSharp.AudioInfo,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\TagSizes\Mpeg4Tag.cs,ParseStsdAtom,The following statement contains a magic number: for (int i = 0; i < num; i++) {  	int size = ReadInt32 (atomdata' stsdOff);  	stsdOff += 4;  	Buffer.BlockCopy (atomdata' stsdOff' data_format' 0' 4);  	stsdOff += 12;  	byte[] data = new byte[size - 4 - 12];  	Buffer.BlockCopy (atomdata' stsdOff' data' 0' (size - 4 - 12));  	stsdOff += (size - 4 - 12);  	Buffer.BlockCopy (data' 4' encoder_vendor' 0' 4);  	if (encoder_vendor [0] == 0) {  		Frequency = ((data [16] & 0xff) << 8) + (data [17] & 0xff);  		Channels = (data [8] << 8) + data [9];  		if (ByteUtils.Compare (data_format' Encoding.ASCII.GetBytes ("mp4a"))) {  			Codec = "AAC";  		} else {  			Codec = Encoding.UTF8.GetString (data_format);  		}  	}  }  
Magic Number,IdSharp.AudioInfo,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\TagSizes\Mpeg4Tag.cs,ParseStsdAtom,The following statement contains a magic number: stsdOff += 4;  
Magic Number,IdSharp.AudioInfo,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\TagSizes\Mpeg4Tag.cs,ParseStsdAtom,The following statement contains a magic number: Buffer.BlockCopy (atomdata' stsdOff' data_format' 0' 4);  
Magic Number,IdSharp.AudioInfo,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\TagSizes\Mpeg4Tag.cs,ParseStsdAtom,The following statement contains a magic number: stsdOff += 12;  
Magic Number,IdSharp.AudioInfo,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\TagSizes\Mpeg4Tag.cs,ParseStsdAtom,The following statement contains a magic number: Buffer.BlockCopy (atomdata' stsdOff' data' 0' (size - 4 - 12));  
Magic Number,IdSharp.AudioInfo,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\TagSizes\Mpeg4Tag.cs,ParseStsdAtom,The following statement contains a magic number: Buffer.BlockCopy (atomdata' stsdOff' data' 0' (size - 4 - 12));  
Magic Number,IdSharp.AudioInfo,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\TagSizes\Mpeg4Tag.cs,ParseStsdAtom,The following statement contains a magic number: stsdOff += (size - 4 - 12);  
Magic Number,IdSharp.AudioInfo,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\TagSizes\Mpeg4Tag.cs,ParseStsdAtom,The following statement contains a magic number: stsdOff += (size - 4 - 12);  
Magic Number,IdSharp.AudioInfo,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\TagSizes\Mpeg4Tag.cs,ParseStsdAtom,The following statement contains a magic number: Buffer.BlockCopy (data' 4' encoder_vendor' 0' 4);  
Magic Number,IdSharp.AudioInfo,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\TagSizes\Mpeg4Tag.cs,ParseStsdAtom,The following statement contains a magic number: Buffer.BlockCopy (data' 4' encoder_vendor' 0' 4);  
Magic Number,IdSharp.AudioInfo,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\TagSizes\Mpeg4Tag.cs,ParseStsdAtom,The following statement contains a magic number: if (encoder_vendor [0] == 0) {  	Frequency = ((data [16] & 0xff) << 8) + (data [17] & 0xff);  	Channels = (data [8] << 8) + data [9];  	if (ByteUtils.Compare (data_format' Encoding.ASCII.GetBytes ("mp4a"))) {  		Codec = "AAC";  	} else {  		Codec = Encoding.UTF8.GetString (data_format);  	}  }  
Magic Number,IdSharp.AudioInfo,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\TagSizes\Mpeg4Tag.cs,ParseStsdAtom,The following statement contains a magic number: if (encoder_vendor [0] == 0) {  	Frequency = ((data [16] & 0xff) << 8) + (data [17] & 0xff);  	Channels = (data [8] << 8) + data [9];  	if (ByteUtils.Compare (data_format' Encoding.ASCII.GetBytes ("mp4a"))) {  		Codec = "AAC";  	} else {  		Codec = Encoding.UTF8.GetString (data_format);  	}  }  
Magic Number,IdSharp.AudioInfo,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\TagSizes\Mpeg4Tag.cs,ParseStsdAtom,The following statement contains a magic number: if (encoder_vendor [0] == 0) {  	Frequency = ((data [16] & 0xff) << 8) + (data [17] & 0xff);  	Channels = (data [8] << 8) + data [9];  	if (ByteUtils.Compare (data_format' Encoding.ASCII.GetBytes ("mp4a"))) {  		Codec = "AAC";  	} else {  		Codec = Encoding.UTF8.GetString (data_format);  	}  }  
Magic Number,IdSharp.AudioInfo,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\TagSizes\Mpeg4Tag.cs,ParseStsdAtom,The following statement contains a magic number: if (encoder_vendor [0] == 0) {  	Frequency = ((data [16] & 0xff) << 8) + (data [17] & 0xff);  	Channels = (data [8] << 8) + data [9];  	if (ByteUtils.Compare (data_format' Encoding.ASCII.GetBytes ("mp4a"))) {  		Codec = "AAC";  	} else {  		Codec = Encoding.UTF8.GetString (data_format);  	}  }  
Magic Number,IdSharp.AudioInfo,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\TagSizes\Mpeg4Tag.cs,ParseStsdAtom,The following statement contains a magic number: if (encoder_vendor [0] == 0) {  	Frequency = ((data [16] & 0xff) << 8) + (data [17] & 0xff);  	Channels = (data [8] << 8) + data [9];  	if (ByteUtils.Compare (data_format' Encoding.ASCII.GetBytes ("mp4a"))) {  		Codec = "AAC";  	} else {  		Codec = Encoding.UTF8.GetString (data_format);  	}  }  
Magic Number,IdSharp.AudioInfo,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\TagSizes\Mpeg4Tag.cs,ParseStsdAtom,The following statement contains a magic number: if (encoder_vendor [0] == 0) {  	Frequency = ((data [16] & 0xff) << 8) + (data [17] & 0xff);  	Channels = (data [8] << 8) + data [9];  	if (ByteUtils.Compare (data_format' Encoding.ASCII.GetBytes ("mp4a"))) {  		Codec = "AAC";  	} else {  		Codec = Encoding.UTF8.GetString (data_format);  	}  }  
Magic Number,IdSharp.AudioInfo,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\TagSizes\Mpeg4Tag.cs,ParseStsdAtom,The following statement contains a magic number: Frequency = ((data [16] & 0xff) << 8) + (data [17] & 0xff);  
Magic Number,IdSharp.AudioInfo,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\TagSizes\Mpeg4Tag.cs,ParseStsdAtom,The following statement contains a magic number: Frequency = ((data [16] & 0xff) << 8) + (data [17] & 0xff);  
Magic Number,IdSharp.AudioInfo,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\TagSizes\Mpeg4Tag.cs,ParseStsdAtom,The following statement contains a magic number: Frequency = ((data [16] & 0xff) << 8) + (data [17] & 0xff);  
Magic Number,IdSharp.AudioInfo,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\TagSizes\Mpeg4Tag.cs,ParseStsdAtom,The following statement contains a magic number: Channels = (data [8] << 8) + data [9];  
Magic Number,IdSharp.AudioInfo,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\TagSizes\Mpeg4Tag.cs,ParseStsdAtom,The following statement contains a magic number: Channels = (data [8] << 8) + data [9];  
Magic Number,IdSharp.AudioInfo,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\TagSizes\Mpeg4Tag.cs,ParseStsdAtom,The following statement contains a magic number: Channels = (data [8] << 8) + data [9];  
Magic Number,IdSharp.AudioInfo,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\TagSizes\Mpeg4Tag.cs,ParseAtom,The following statement contains a magic number: while (offset < stopAt) {  	stream.Seek (offset' SeekOrigin.Begin);  	int atomsize = stream.ReadInt32 ();  	string atomname = ByteUtils.ISO88591.GetString (stream.Read (4));  	if ((offset + atomsize) > end) {  		throw new InvalidDataException (String.Format ("atom at {0} claims {1} bytes' end = {2}"' offset' atomsize' end));  	}  	Atom atom = new Atom ();  	atom.name = atomname;  	//atom.size = atomsize;  	//atom.pos = stream.Position - 8;  	atom.level = level;  	_atoms.Add (atom);  	if (string.Compare (atomname' "mdat"' true) == 0) {  		_mdatsize = atomsize;  	} /*else if (String.Compare(atomname' "moov"' true) == 0)                 {                     _moovpos = stream.Position - 8;                 }*//*else if (String.Compare(atomname' "udta"' true) == 0)                 {                     _udtapos = stream.Position - 8;                     _udtasize = atomsize;                 }*/else if (string.Compare (atomname' "free"' true) == 0) {  		// we'd like a free under a moov  		// so check for level = 1  		if (atom.level == 2) {  			// go backwards through the entries  			for (int i = _atoms.Count - 1; i > 0; i--) {  				// until we hit a level 1  				if (_atoms [i].level == 1) {  					if (string.Compare (_atoms [i].name' "moov"' true) == 0) {  						if (atomsize > _freesize) {  							// is this free bigger than others?  							//_freepos = stream.Position - 8;  							_freesize = atomsize;  						} else {  							break;  						}  					}  					// if moov  				}  				// if level = 1  			}  			// for  		}  		// if level = 2  	}  	// if free  	// if it's a container atom' parse the contents of the atom  	foreach (string atomType in ATOM_TYPES) {  		if (string.Compare (atomname' atomType' true) == 0) {  			ParseAtom (stream' stream.Position' offset + atomsize' level);  			break;  		}  	}  	// meta atom contains tags and some other data  	if (string.Compare (atomname' "meta"' true) == 0) {  		// read in meta atom  		byte[] atomdata = stream.Read (atomsize - 8);  		int nextTagPosition = 0;  		for (int i = 0; i < atomdata.Length - 4; i++) {  			// ilst  			if (atomdata [i] == 'i' && atomdata [i + 1] == 'l' && atomdata [i + 2] == 's' && atomdata [i + 3] == 't') {  				nextTagPosition = i + 8;  				break;  			}  		}  		while (nextTagPosition < (atomsize - 4) && nextTagPosition > 8) {  			int size = ReadInt32 (atomdata' (nextTagPosition - 4)) - 4;  			nextTagPosition += size + 4;  		}  	}  	// if meta  	// mdhd has data for calculating playtime  	if (string.Compare (atomname' "mdhd"' true) == 0) {  		stream.Seek (12' SeekOrigin.Current);  		Frequency = stream.ReadInt32 ();  		Samples = stream.ReadInt32 ();  	}  	// stsd has data for sample' channels and codec  	if (string.Compare (atomname' "stsd"' true) == 0) {  		byte[] atomdata = stream.Read (atomsize - 8);  		ParseStsdAtom (atomdata);  	}  	// bump offest and continue  	if (atomsize == 0) {  		// a 0 byte atom is the end  		offset = stopAt;  	} else {  		offset += atomsize;  	}  }  
Magic Number,IdSharp.AudioInfo,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\TagSizes\Mpeg4Tag.cs,ParseAtom,The following statement contains a magic number: while (offset < stopAt) {  	stream.Seek (offset' SeekOrigin.Begin);  	int atomsize = stream.ReadInt32 ();  	string atomname = ByteUtils.ISO88591.GetString (stream.Read (4));  	if ((offset + atomsize) > end) {  		throw new InvalidDataException (String.Format ("atom at {0} claims {1} bytes' end = {2}"' offset' atomsize' end));  	}  	Atom atom = new Atom ();  	atom.name = atomname;  	//atom.size = atomsize;  	//atom.pos = stream.Position - 8;  	atom.level = level;  	_atoms.Add (atom);  	if (string.Compare (atomname' "mdat"' true) == 0) {  		_mdatsize = atomsize;  	} /*else if (String.Compare(atomname' "moov"' true) == 0)                 {                     _moovpos = stream.Position - 8;                 }*//*else if (String.Compare(atomname' "udta"' true) == 0)                 {                     _udtapos = stream.Position - 8;                     _udtasize = atomsize;                 }*/else if (string.Compare (atomname' "free"' true) == 0) {  		// we'd like a free under a moov  		// so check for level = 1  		if (atom.level == 2) {  			// go backwards through the entries  			for (int i = _atoms.Count - 1; i > 0; i--) {  				// until we hit a level 1  				if (_atoms [i].level == 1) {  					if (string.Compare (_atoms [i].name' "moov"' true) == 0) {  						if (atomsize > _freesize) {  							// is this free bigger than others?  							//_freepos = stream.Position - 8;  							_freesize = atomsize;  						} else {  							break;  						}  					}  					// if moov  				}  				// if level = 1  			}  			// for  		}  		// if level = 2  	}  	// if free  	// if it's a container atom' parse the contents of the atom  	foreach (string atomType in ATOM_TYPES) {  		if (string.Compare (atomname' atomType' true) == 0) {  			ParseAtom (stream' stream.Position' offset + atomsize' level);  			break;  		}  	}  	// meta atom contains tags and some other data  	if (string.Compare (atomname' "meta"' true) == 0) {  		// read in meta atom  		byte[] atomdata = stream.Read (atomsize - 8);  		int nextTagPosition = 0;  		for (int i = 0; i < atomdata.Length - 4; i++) {  			// ilst  			if (atomdata [i] == 'i' && atomdata [i + 1] == 'l' && atomdata [i + 2] == 's' && atomdata [i + 3] == 't') {  				nextTagPosition = i + 8;  				break;  			}  		}  		while (nextTagPosition < (atomsize - 4) && nextTagPosition > 8) {  			int size = ReadInt32 (atomdata' (nextTagPosition - 4)) - 4;  			nextTagPosition += size + 4;  		}  	}  	// if meta  	// mdhd has data for calculating playtime  	if (string.Compare (atomname' "mdhd"' true) == 0) {  		stream.Seek (12' SeekOrigin.Current);  		Frequency = stream.ReadInt32 ();  		Samples = stream.ReadInt32 ();  	}  	// stsd has data for sample' channels and codec  	if (string.Compare (atomname' "stsd"' true) == 0) {  		byte[] atomdata = stream.Read (atomsize - 8);  		ParseStsdAtom (atomdata);  	}  	// bump offest and continue  	if (atomsize == 0) {  		// a 0 byte atom is the end  		offset = stopAt;  	} else {  		offset += atomsize;  	}  }  
Magic Number,IdSharp.AudioInfo,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\TagSizes\Mpeg4Tag.cs,ParseAtom,The following statement contains a magic number: while (offset < stopAt) {  	stream.Seek (offset' SeekOrigin.Begin);  	int atomsize = stream.ReadInt32 ();  	string atomname = ByteUtils.ISO88591.GetString (stream.Read (4));  	if ((offset + atomsize) > end) {  		throw new InvalidDataException (String.Format ("atom at {0} claims {1} bytes' end = {2}"' offset' atomsize' end));  	}  	Atom atom = new Atom ();  	atom.name = atomname;  	//atom.size = atomsize;  	//atom.pos = stream.Position - 8;  	atom.level = level;  	_atoms.Add (atom);  	if (string.Compare (atomname' "mdat"' true) == 0) {  		_mdatsize = atomsize;  	} /*else if (String.Compare(atomname' "moov"' true) == 0)                 {                     _moovpos = stream.Position - 8;                 }*//*else if (String.Compare(atomname' "udta"' true) == 0)                 {                     _udtapos = stream.Position - 8;                     _udtasize = atomsize;                 }*/else if (string.Compare (atomname' "free"' true) == 0) {  		// we'd like a free under a moov  		// so check for level = 1  		if (atom.level == 2) {  			// go backwards through the entries  			for (int i = _atoms.Count - 1; i > 0; i--) {  				// until we hit a level 1  				if (_atoms [i].level == 1) {  					if (string.Compare (_atoms [i].name' "moov"' true) == 0) {  						if (atomsize > _freesize) {  							// is this free bigger than others?  							//_freepos = stream.Position - 8;  							_freesize = atomsize;  						} else {  							break;  						}  					}  					// if moov  				}  				// if level = 1  			}  			// for  		}  		// if level = 2  	}  	// if free  	// if it's a container atom' parse the contents of the atom  	foreach (string atomType in ATOM_TYPES) {  		if (string.Compare (atomname' atomType' true) == 0) {  			ParseAtom (stream' stream.Position' offset + atomsize' level);  			break;  		}  	}  	// meta atom contains tags and some other data  	if (string.Compare (atomname' "meta"' true) == 0) {  		// read in meta atom  		byte[] atomdata = stream.Read (atomsize - 8);  		int nextTagPosition = 0;  		for (int i = 0; i < atomdata.Length - 4; i++) {  			// ilst  			if (atomdata [i] == 'i' && atomdata [i + 1] == 'l' && atomdata [i + 2] == 's' && atomdata [i + 3] == 't') {  				nextTagPosition = i + 8;  				break;  			}  		}  		while (nextTagPosition < (atomsize - 4) && nextTagPosition > 8) {  			int size = ReadInt32 (atomdata' (nextTagPosition - 4)) - 4;  			nextTagPosition += size + 4;  		}  	}  	// if meta  	// mdhd has data for calculating playtime  	if (string.Compare (atomname' "mdhd"' true) == 0) {  		stream.Seek (12' SeekOrigin.Current);  		Frequency = stream.ReadInt32 ();  		Samples = stream.ReadInt32 ();  	}  	// stsd has data for sample' channels and codec  	if (string.Compare (atomname' "stsd"' true) == 0) {  		byte[] atomdata = stream.Read (atomsize - 8);  		ParseStsdAtom (atomdata);  	}  	// bump offest and continue  	if (atomsize == 0) {  		// a 0 byte atom is the end  		offset = stopAt;  	} else {  		offset += atomsize;  	}  }  
Magic Number,IdSharp.AudioInfo,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\TagSizes\Mpeg4Tag.cs,ParseAtom,The following statement contains a magic number: while (offset < stopAt) {  	stream.Seek (offset' SeekOrigin.Begin);  	int atomsize = stream.ReadInt32 ();  	string atomname = ByteUtils.ISO88591.GetString (stream.Read (4));  	if ((offset + atomsize) > end) {  		throw new InvalidDataException (String.Format ("atom at {0} claims {1} bytes' end = {2}"' offset' atomsize' end));  	}  	Atom atom = new Atom ();  	atom.name = atomname;  	//atom.size = atomsize;  	//atom.pos = stream.Position - 8;  	atom.level = level;  	_atoms.Add (atom);  	if (string.Compare (atomname' "mdat"' true) == 0) {  		_mdatsize = atomsize;  	} /*else if (String.Compare(atomname' "moov"' true) == 0)                 {                     _moovpos = stream.Position - 8;                 }*//*else if (String.Compare(atomname' "udta"' true) == 0)                 {                     _udtapos = stream.Position - 8;                     _udtasize = atomsize;                 }*/else if (string.Compare (atomname' "free"' true) == 0) {  		// we'd like a free under a moov  		// so check for level = 1  		if (atom.level == 2) {  			// go backwards through the entries  			for (int i = _atoms.Count - 1; i > 0; i--) {  				// until we hit a level 1  				if (_atoms [i].level == 1) {  					if (string.Compare (_atoms [i].name' "moov"' true) == 0) {  						if (atomsize > _freesize) {  							// is this free bigger than others?  							//_freepos = stream.Position - 8;  							_freesize = atomsize;  						} else {  							break;  						}  					}  					// if moov  				}  				// if level = 1  			}  			// for  		}  		// if level = 2  	}  	// if free  	// if it's a container atom' parse the contents of the atom  	foreach (string atomType in ATOM_TYPES) {  		if (string.Compare (atomname' atomType' true) == 0) {  			ParseAtom (stream' stream.Position' offset + atomsize' level);  			break;  		}  	}  	// meta atom contains tags and some other data  	if (string.Compare (atomname' "meta"' true) == 0) {  		// read in meta atom  		byte[] atomdata = stream.Read (atomsize - 8);  		int nextTagPosition = 0;  		for (int i = 0; i < atomdata.Length - 4; i++) {  			// ilst  			if (atomdata [i] == 'i' && atomdata [i + 1] == 'l' && atomdata [i + 2] == 's' && atomdata [i + 3] == 't') {  				nextTagPosition = i + 8;  				break;  			}  		}  		while (nextTagPosition < (atomsize - 4) && nextTagPosition > 8) {  			int size = ReadInt32 (atomdata' (nextTagPosition - 4)) - 4;  			nextTagPosition += size + 4;  		}  	}  	// if meta  	// mdhd has data for calculating playtime  	if (string.Compare (atomname' "mdhd"' true) == 0) {  		stream.Seek (12' SeekOrigin.Current);  		Frequency = stream.ReadInt32 ();  		Samples = stream.ReadInt32 ();  	}  	// stsd has data for sample' channels and codec  	if (string.Compare (atomname' "stsd"' true) == 0) {  		byte[] atomdata = stream.Read (atomsize - 8);  		ParseStsdAtom (atomdata);  	}  	// bump offest and continue  	if (atomsize == 0) {  		// a 0 byte atom is the end  		offset = stopAt;  	} else {  		offset += atomsize;  	}  }  
Magic Number,IdSharp.AudioInfo,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\TagSizes\Mpeg4Tag.cs,ParseAtom,The following statement contains a magic number: while (offset < stopAt) {  	stream.Seek (offset' SeekOrigin.Begin);  	int atomsize = stream.ReadInt32 ();  	string atomname = ByteUtils.ISO88591.GetString (stream.Read (4));  	if ((offset + atomsize) > end) {  		throw new InvalidDataException (String.Format ("atom at {0} claims {1} bytes' end = {2}"' offset' atomsize' end));  	}  	Atom atom = new Atom ();  	atom.name = atomname;  	//atom.size = atomsize;  	//atom.pos = stream.Position - 8;  	atom.level = level;  	_atoms.Add (atom);  	if (string.Compare (atomname' "mdat"' true) == 0) {  		_mdatsize = atomsize;  	} /*else if (String.Compare(atomname' "moov"' true) == 0)                 {                     _moovpos = stream.Position - 8;                 }*//*else if (String.Compare(atomname' "udta"' true) == 0)                 {                     _udtapos = stream.Position - 8;                     _udtasize = atomsize;                 }*/else if (string.Compare (atomname' "free"' true) == 0) {  		// we'd like a free under a moov  		// so check for level = 1  		if (atom.level == 2) {  			// go backwards through the entries  			for (int i = _atoms.Count - 1; i > 0; i--) {  				// until we hit a level 1  				if (_atoms [i].level == 1) {  					if (string.Compare (_atoms [i].name' "moov"' true) == 0) {  						if (atomsize > _freesize) {  							// is this free bigger than others?  							//_freepos = stream.Position - 8;  							_freesize = atomsize;  						} else {  							break;  						}  					}  					// if moov  				}  				// if level = 1  			}  			// for  		}  		// if level = 2  	}  	// if free  	// if it's a container atom' parse the contents of the atom  	foreach (string atomType in ATOM_TYPES) {  		if (string.Compare (atomname' atomType' true) == 0) {  			ParseAtom (stream' stream.Position' offset + atomsize' level);  			break;  		}  	}  	// meta atom contains tags and some other data  	if (string.Compare (atomname' "meta"' true) == 0) {  		// read in meta atom  		byte[] atomdata = stream.Read (atomsize - 8);  		int nextTagPosition = 0;  		for (int i = 0; i < atomdata.Length - 4; i++) {  			// ilst  			if (atomdata [i] == 'i' && atomdata [i + 1] == 'l' && atomdata [i + 2] == 's' && atomdata [i + 3] == 't') {  				nextTagPosition = i + 8;  				break;  			}  		}  		while (nextTagPosition < (atomsize - 4) && nextTagPosition > 8) {  			int size = ReadInt32 (atomdata' (nextTagPosition - 4)) - 4;  			nextTagPosition += size + 4;  		}  	}  	// if meta  	// mdhd has data for calculating playtime  	if (string.Compare (atomname' "mdhd"' true) == 0) {  		stream.Seek (12' SeekOrigin.Current);  		Frequency = stream.ReadInt32 ();  		Samples = stream.ReadInt32 ();  	}  	// stsd has data for sample' channels and codec  	if (string.Compare (atomname' "stsd"' true) == 0) {  		byte[] atomdata = stream.Read (atomsize - 8);  		ParseStsdAtom (atomdata);  	}  	// bump offest and continue  	if (atomsize == 0) {  		// a 0 byte atom is the end  		offset = stopAt;  	} else {  		offset += atomsize;  	}  }  
Magic Number,IdSharp.AudioInfo,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\TagSizes\Mpeg4Tag.cs,ParseAtom,The following statement contains a magic number: while (offset < stopAt) {  	stream.Seek (offset' SeekOrigin.Begin);  	int atomsize = stream.ReadInt32 ();  	string atomname = ByteUtils.ISO88591.GetString (stream.Read (4));  	if ((offset + atomsize) > end) {  		throw new InvalidDataException (String.Format ("atom at {0} claims {1} bytes' end = {2}"' offset' atomsize' end));  	}  	Atom atom = new Atom ();  	atom.name = atomname;  	//atom.size = atomsize;  	//atom.pos = stream.Position - 8;  	atom.level = level;  	_atoms.Add (atom);  	if (string.Compare (atomname' "mdat"' true) == 0) {  		_mdatsize = atomsize;  	} /*else if (String.Compare(atomname' "moov"' true) == 0)                 {                     _moovpos = stream.Position - 8;                 }*//*else if (String.Compare(atomname' "udta"' true) == 0)                 {                     _udtapos = stream.Position - 8;                     _udtasize = atomsize;                 }*/else if (string.Compare (atomname' "free"' true) == 0) {  		// we'd like a free under a moov  		// so check for level = 1  		if (atom.level == 2) {  			// go backwards through the entries  			for (int i = _atoms.Count - 1; i > 0; i--) {  				// until we hit a level 1  				if (_atoms [i].level == 1) {  					if (string.Compare (_atoms [i].name' "moov"' true) == 0) {  						if (atomsize > _freesize) {  							// is this free bigger than others?  							//_freepos = stream.Position - 8;  							_freesize = atomsize;  						} else {  							break;  						}  					}  					// if moov  				}  				// if level = 1  			}  			// for  		}  		// if level = 2  	}  	// if free  	// if it's a container atom' parse the contents of the atom  	foreach (string atomType in ATOM_TYPES) {  		if (string.Compare (atomname' atomType' true) == 0) {  			ParseAtom (stream' stream.Position' offset + atomsize' level);  			break;  		}  	}  	// meta atom contains tags and some other data  	if (string.Compare (atomname' "meta"' true) == 0) {  		// read in meta atom  		byte[] atomdata = stream.Read (atomsize - 8);  		int nextTagPosition = 0;  		for (int i = 0; i < atomdata.Length - 4; i++) {  			// ilst  			if (atomdata [i] == 'i' && atomdata [i + 1] == 'l' && atomdata [i + 2] == 's' && atomdata [i + 3] == 't') {  				nextTagPosition = i + 8;  				break;  			}  		}  		while (nextTagPosition < (atomsize - 4) && nextTagPosition > 8) {  			int size = ReadInt32 (atomdata' (nextTagPosition - 4)) - 4;  			nextTagPosition += size + 4;  		}  	}  	// if meta  	// mdhd has data for calculating playtime  	if (string.Compare (atomname' "mdhd"' true) == 0) {  		stream.Seek (12' SeekOrigin.Current);  		Frequency = stream.ReadInt32 ();  		Samples = stream.ReadInt32 ();  	}  	// stsd has data for sample' channels and codec  	if (string.Compare (atomname' "stsd"' true) == 0) {  		byte[] atomdata = stream.Read (atomsize - 8);  		ParseStsdAtom (atomdata);  	}  	// bump offest and continue  	if (atomsize == 0) {  		// a 0 byte atom is the end  		offset = stopAt;  	} else {  		offset += atomsize;  	}  }  
Magic Number,IdSharp.AudioInfo,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\TagSizes\Mpeg4Tag.cs,ParseAtom,The following statement contains a magic number: while (offset < stopAt) {  	stream.Seek (offset' SeekOrigin.Begin);  	int atomsize = stream.ReadInt32 ();  	string atomname = ByteUtils.ISO88591.GetString (stream.Read (4));  	if ((offset + atomsize) > end) {  		throw new InvalidDataException (String.Format ("atom at {0} claims {1} bytes' end = {2}"' offset' atomsize' end));  	}  	Atom atom = new Atom ();  	atom.name = atomname;  	//atom.size = atomsize;  	//atom.pos = stream.Position - 8;  	atom.level = level;  	_atoms.Add (atom);  	if (string.Compare (atomname' "mdat"' true) == 0) {  		_mdatsize = atomsize;  	} /*else if (String.Compare(atomname' "moov"' true) == 0)                 {                     _moovpos = stream.Position - 8;                 }*//*else if (String.Compare(atomname' "udta"' true) == 0)                 {                     _udtapos = stream.Position - 8;                     _udtasize = atomsize;                 }*/else if (string.Compare (atomname' "free"' true) == 0) {  		// we'd like a free under a moov  		// so check for level = 1  		if (atom.level == 2) {  			// go backwards through the entries  			for (int i = _atoms.Count - 1; i > 0; i--) {  				// until we hit a level 1  				if (_atoms [i].level == 1) {  					if (string.Compare (_atoms [i].name' "moov"' true) == 0) {  						if (atomsize > _freesize) {  							// is this free bigger than others?  							//_freepos = stream.Position - 8;  							_freesize = atomsize;  						} else {  							break;  						}  					}  					// if moov  				}  				// if level = 1  			}  			// for  		}  		// if level = 2  	}  	// if free  	// if it's a container atom' parse the contents of the atom  	foreach (string atomType in ATOM_TYPES) {  		if (string.Compare (atomname' atomType' true) == 0) {  			ParseAtom (stream' stream.Position' offset + atomsize' level);  			break;  		}  	}  	// meta atom contains tags and some other data  	if (string.Compare (atomname' "meta"' true) == 0) {  		// read in meta atom  		byte[] atomdata = stream.Read (atomsize - 8);  		int nextTagPosition = 0;  		for (int i = 0; i < atomdata.Length - 4; i++) {  			// ilst  			if (atomdata [i] == 'i' && atomdata [i + 1] == 'l' && atomdata [i + 2] == 's' && atomdata [i + 3] == 't') {  				nextTagPosition = i + 8;  				break;  			}  		}  		while (nextTagPosition < (atomsize - 4) && nextTagPosition > 8) {  			int size = ReadInt32 (atomdata' (nextTagPosition - 4)) - 4;  			nextTagPosition += size + 4;  		}  	}  	// if meta  	// mdhd has data for calculating playtime  	if (string.Compare (atomname' "mdhd"' true) == 0) {  		stream.Seek (12' SeekOrigin.Current);  		Frequency = stream.ReadInt32 ();  		Samples = stream.ReadInt32 ();  	}  	// stsd has data for sample' channels and codec  	if (string.Compare (atomname' "stsd"' true) == 0) {  		byte[] atomdata = stream.Read (atomsize - 8);  		ParseStsdAtom (atomdata);  	}  	// bump offest and continue  	if (atomsize == 0) {  		// a 0 byte atom is the end  		offset = stopAt;  	} else {  		offset += atomsize;  	}  }  
Magic Number,IdSharp.AudioInfo,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\TagSizes\Mpeg4Tag.cs,ParseAtom,The following statement contains a magic number: while (offset < stopAt) {  	stream.Seek (offset' SeekOrigin.Begin);  	int atomsize = stream.ReadInt32 ();  	string atomname = ByteUtils.ISO88591.GetString (stream.Read (4));  	if ((offset + atomsize) > end) {  		throw new InvalidDataException (String.Format ("atom at {0} claims {1} bytes' end = {2}"' offset' atomsize' end));  	}  	Atom atom = new Atom ();  	atom.name = atomname;  	//atom.size = atomsize;  	//atom.pos = stream.Position - 8;  	atom.level = level;  	_atoms.Add (atom);  	if (string.Compare (atomname' "mdat"' true) == 0) {  		_mdatsize = atomsize;  	} /*else if (String.Compare(atomname' "moov"' true) == 0)                 {                     _moovpos = stream.Position - 8;                 }*//*else if (String.Compare(atomname' "udta"' true) == 0)                 {                     _udtapos = stream.Position - 8;                     _udtasize = atomsize;                 }*/else if (string.Compare (atomname' "free"' true) == 0) {  		// we'd like a free under a moov  		// so check for level = 1  		if (atom.level == 2) {  			// go backwards through the entries  			for (int i = _atoms.Count - 1; i > 0; i--) {  				// until we hit a level 1  				if (_atoms [i].level == 1) {  					if (string.Compare (_atoms [i].name' "moov"' true) == 0) {  						if (atomsize > _freesize) {  							// is this free bigger than others?  							//_freepos = stream.Position - 8;  							_freesize = atomsize;  						} else {  							break;  						}  					}  					// if moov  				}  				// if level = 1  			}  			// for  		}  		// if level = 2  	}  	// if free  	// if it's a container atom' parse the contents of the atom  	foreach (string atomType in ATOM_TYPES) {  		if (string.Compare (atomname' atomType' true) == 0) {  			ParseAtom (stream' stream.Position' offset + atomsize' level);  			break;  		}  	}  	// meta atom contains tags and some other data  	if (string.Compare (atomname' "meta"' true) == 0) {  		// read in meta atom  		byte[] atomdata = stream.Read (atomsize - 8);  		int nextTagPosition = 0;  		for (int i = 0; i < atomdata.Length - 4; i++) {  			// ilst  			if (atomdata [i] == 'i' && atomdata [i + 1] == 'l' && atomdata [i + 2] == 's' && atomdata [i + 3] == 't') {  				nextTagPosition = i + 8;  				break;  			}  		}  		while (nextTagPosition < (atomsize - 4) && nextTagPosition > 8) {  			int size = ReadInt32 (atomdata' (nextTagPosition - 4)) - 4;  			nextTagPosition += size + 4;  		}  	}  	// if meta  	// mdhd has data for calculating playtime  	if (string.Compare (atomname' "mdhd"' true) == 0) {  		stream.Seek (12' SeekOrigin.Current);  		Frequency = stream.ReadInt32 ();  		Samples = stream.ReadInt32 ();  	}  	// stsd has data for sample' channels and codec  	if (string.Compare (atomname' "stsd"' true) == 0) {  		byte[] atomdata = stream.Read (atomsize - 8);  		ParseStsdAtom (atomdata);  	}  	// bump offest and continue  	if (atomsize == 0) {  		// a 0 byte atom is the end  		offset = stopAt;  	} else {  		offset += atomsize;  	}  }  
Magic Number,IdSharp.AudioInfo,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\TagSizes\Mpeg4Tag.cs,ParseAtom,The following statement contains a magic number: while (offset < stopAt) {  	stream.Seek (offset' SeekOrigin.Begin);  	int atomsize = stream.ReadInt32 ();  	string atomname = ByteUtils.ISO88591.GetString (stream.Read (4));  	if ((offset + atomsize) > end) {  		throw new InvalidDataException (String.Format ("atom at {0} claims {1} bytes' end = {2}"' offset' atomsize' end));  	}  	Atom atom = new Atom ();  	atom.name = atomname;  	//atom.size = atomsize;  	//atom.pos = stream.Position - 8;  	atom.level = level;  	_atoms.Add (atom);  	if (string.Compare (atomname' "mdat"' true) == 0) {  		_mdatsize = atomsize;  	} /*else if (String.Compare(atomname' "moov"' true) == 0)                 {                     _moovpos = stream.Position - 8;                 }*//*else if (String.Compare(atomname' "udta"' true) == 0)                 {                     _udtapos = stream.Position - 8;                     _udtasize = atomsize;                 }*/else if (string.Compare (atomname' "free"' true) == 0) {  		// we'd like a free under a moov  		// so check for level = 1  		if (atom.level == 2) {  			// go backwards through the entries  			for (int i = _atoms.Count - 1; i > 0; i--) {  				// until we hit a level 1  				if (_atoms [i].level == 1) {  					if (string.Compare (_atoms [i].name' "moov"' true) == 0) {  						if (atomsize > _freesize) {  							// is this free bigger than others?  							//_freepos = stream.Position - 8;  							_freesize = atomsize;  						} else {  							break;  						}  					}  					// if moov  				}  				// if level = 1  			}  			// for  		}  		// if level = 2  	}  	// if free  	// if it's a container atom' parse the contents of the atom  	foreach (string atomType in ATOM_TYPES) {  		if (string.Compare (atomname' atomType' true) == 0) {  			ParseAtom (stream' stream.Position' offset + atomsize' level);  			break;  		}  	}  	// meta atom contains tags and some other data  	if (string.Compare (atomname' "meta"' true) == 0) {  		// read in meta atom  		byte[] atomdata = stream.Read (atomsize - 8);  		int nextTagPosition = 0;  		for (int i = 0; i < atomdata.Length - 4; i++) {  			// ilst  			if (atomdata [i] == 'i' && atomdata [i + 1] == 'l' && atomdata [i + 2] == 's' && atomdata [i + 3] == 't') {  				nextTagPosition = i + 8;  				break;  			}  		}  		while (nextTagPosition < (atomsize - 4) && nextTagPosition > 8) {  			int size = ReadInt32 (atomdata' (nextTagPosition - 4)) - 4;  			nextTagPosition += size + 4;  		}  	}  	// if meta  	// mdhd has data for calculating playtime  	if (string.Compare (atomname' "mdhd"' true) == 0) {  		stream.Seek (12' SeekOrigin.Current);  		Frequency = stream.ReadInt32 ();  		Samples = stream.ReadInt32 ();  	}  	// stsd has data for sample' channels and codec  	if (string.Compare (atomname' "stsd"' true) == 0) {  		byte[] atomdata = stream.Read (atomsize - 8);  		ParseStsdAtom (atomdata);  	}  	// bump offest and continue  	if (atomsize == 0) {  		// a 0 byte atom is the end  		offset = stopAt;  	} else {  		offset += atomsize;  	}  }  
Magic Number,IdSharp.AudioInfo,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\TagSizes\Mpeg4Tag.cs,ParseAtom,The following statement contains a magic number: while (offset < stopAt) {  	stream.Seek (offset' SeekOrigin.Begin);  	int atomsize = stream.ReadInt32 ();  	string atomname = ByteUtils.ISO88591.GetString (stream.Read (4));  	if ((offset + atomsize) > end) {  		throw new InvalidDataException (String.Format ("atom at {0} claims {1} bytes' end = {2}"' offset' atomsize' end));  	}  	Atom atom = new Atom ();  	atom.name = atomname;  	//atom.size = atomsize;  	//atom.pos = stream.Position - 8;  	atom.level = level;  	_atoms.Add (atom);  	if (string.Compare (atomname' "mdat"' true) == 0) {  		_mdatsize = atomsize;  	} /*else if (String.Compare(atomname' "moov"' true) == 0)                 {                     _moovpos = stream.Position - 8;                 }*//*else if (String.Compare(atomname' "udta"' true) == 0)                 {                     _udtapos = stream.Position - 8;                     _udtasize = atomsize;                 }*/else if (string.Compare (atomname' "free"' true) == 0) {  		// we'd like a free under a moov  		// so check for level = 1  		if (atom.level == 2) {  			// go backwards through the entries  			for (int i = _atoms.Count - 1; i > 0; i--) {  				// until we hit a level 1  				if (_atoms [i].level == 1) {  					if (string.Compare (_atoms [i].name' "moov"' true) == 0) {  						if (atomsize > _freesize) {  							// is this free bigger than others?  							//_freepos = stream.Position - 8;  							_freesize = atomsize;  						} else {  							break;  						}  					}  					// if moov  				}  				// if level = 1  			}  			// for  		}  		// if level = 2  	}  	// if free  	// if it's a container atom' parse the contents of the atom  	foreach (string atomType in ATOM_TYPES) {  		if (string.Compare (atomname' atomType' true) == 0) {  			ParseAtom (stream' stream.Position' offset + atomsize' level);  			break;  		}  	}  	// meta atom contains tags and some other data  	if (string.Compare (atomname' "meta"' true) == 0) {  		// read in meta atom  		byte[] atomdata = stream.Read (atomsize - 8);  		int nextTagPosition = 0;  		for (int i = 0; i < atomdata.Length - 4; i++) {  			// ilst  			if (atomdata [i] == 'i' && atomdata [i + 1] == 'l' && atomdata [i + 2] == 's' && atomdata [i + 3] == 't') {  				nextTagPosition = i + 8;  				break;  			}  		}  		while (nextTagPosition < (atomsize - 4) && nextTagPosition > 8) {  			int size = ReadInt32 (atomdata' (nextTagPosition - 4)) - 4;  			nextTagPosition += size + 4;  		}  	}  	// if meta  	// mdhd has data for calculating playtime  	if (string.Compare (atomname' "mdhd"' true) == 0) {  		stream.Seek (12' SeekOrigin.Current);  		Frequency = stream.ReadInt32 ();  		Samples = stream.ReadInt32 ();  	}  	// stsd has data for sample' channels and codec  	if (string.Compare (atomname' "stsd"' true) == 0) {  		byte[] atomdata = stream.Read (atomsize - 8);  		ParseStsdAtom (atomdata);  	}  	// bump offest and continue  	if (atomsize == 0) {  		// a 0 byte atom is the end  		offset = stopAt;  	} else {  		offset += atomsize;  	}  }  
Magic Number,IdSharp.AudioInfo,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\TagSizes\Mpeg4Tag.cs,ParseAtom,The following statement contains a magic number: while (offset < stopAt) {  	stream.Seek (offset' SeekOrigin.Begin);  	int atomsize = stream.ReadInt32 ();  	string atomname = ByteUtils.ISO88591.GetString (stream.Read (4));  	if ((offset + atomsize) > end) {  		throw new InvalidDataException (String.Format ("atom at {0} claims {1} bytes' end = {2}"' offset' atomsize' end));  	}  	Atom atom = new Atom ();  	atom.name = atomname;  	//atom.size = atomsize;  	//atom.pos = stream.Position - 8;  	atom.level = level;  	_atoms.Add (atom);  	if (string.Compare (atomname' "mdat"' true) == 0) {  		_mdatsize = atomsize;  	} /*else if (String.Compare(atomname' "moov"' true) == 0)                 {                     _moovpos = stream.Position - 8;                 }*//*else if (String.Compare(atomname' "udta"' true) == 0)                 {                     _udtapos = stream.Position - 8;                     _udtasize = atomsize;                 }*/else if (string.Compare (atomname' "free"' true) == 0) {  		// we'd like a free under a moov  		// so check for level = 1  		if (atom.level == 2) {  			// go backwards through the entries  			for (int i = _atoms.Count - 1; i > 0; i--) {  				// until we hit a level 1  				if (_atoms [i].level == 1) {  					if (string.Compare (_atoms [i].name' "moov"' true) == 0) {  						if (atomsize > _freesize) {  							// is this free bigger than others?  							//_freepos = stream.Position - 8;  							_freesize = atomsize;  						} else {  							break;  						}  					}  					// if moov  				}  				// if level = 1  			}  			// for  		}  		// if level = 2  	}  	// if free  	// if it's a container atom' parse the contents of the atom  	foreach (string atomType in ATOM_TYPES) {  		if (string.Compare (atomname' atomType' true) == 0) {  			ParseAtom (stream' stream.Position' offset + atomsize' level);  			break;  		}  	}  	// meta atom contains tags and some other data  	if (string.Compare (atomname' "meta"' true) == 0) {  		// read in meta atom  		byte[] atomdata = stream.Read (atomsize - 8);  		int nextTagPosition = 0;  		for (int i = 0; i < atomdata.Length - 4; i++) {  			// ilst  			if (atomdata [i] == 'i' && atomdata [i + 1] == 'l' && atomdata [i + 2] == 's' && atomdata [i + 3] == 't') {  				nextTagPosition = i + 8;  				break;  			}  		}  		while (nextTagPosition < (atomsize - 4) && nextTagPosition > 8) {  			int size = ReadInt32 (atomdata' (nextTagPosition - 4)) - 4;  			nextTagPosition += size + 4;  		}  	}  	// if meta  	// mdhd has data for calculating playtime  	if (string.Compare (atomname' "mdhd"' true) == 0) {  		stream.Seek (12' SeekOrigin.Current);  		Frequency = stream.ReadInt32 ();  		Samples = stream.ReadInt32 ();  	}  	// stsd has data for sample' channels and codec  	if (string.Compare (atomname' "stsd"' true) == 0) {  		byte[] atomdata = stream.Read (atomsize - 8);  		ParseStsdAtom (atomdata);  	}  	// bump offest and continue  	if (atomsize == 0) {  		// a 0 byte atom is the end  		offset = stopAt;  	} else {  		offset += atomsize;  	}  }  
Magic Number,IdSharp.AudioInfo,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\TagSizes\Mpeg4Tag.cs,ParseAtom,The following statement contains a magic number: while (offset < stopAt) {  	stream.Seek (offset' SeekOrigin.Begin);  	int atomsize = stream.ReadInt32 ();  	string atomname = ByteUtils.ISO88591.GetString (stream.Read (4));  	if ((offset + atomsize) > end) {  		throw new InvalidDataException (String.Format ("atom at {0} claims {1} bytes' end = {2}"' offset' atomsize' end));  	}  	Atom atom = new Atom ();  	atom.name = atomname;  	//atom.size = atomsize;  	//atom.pos = stream.Position - 8;  	atom.level = level;  	_atoms.Add (atom);  	if (string.Compare (atomname' "mdat"' true) == 0) {  		_mdatsize = atomsize;  	} /*else if (String.Compare(atomname' "moov"' true) == 0)                 {                     _moovpos = stream.Position - 8;                 }*//*else if (String.Compare(atomname' "udta"' true) == 0)                 {                     _udtapos = stream.Position - 8;                     _udtasize = atomsize;                 }*/else if (string.Compare (atomname' "free"' true) == 0) {  		// we'd like a free under a moov  		// so check for level = 1  		if (atom.level == 2) {  			// go backwards through the entries  			for (int i = _atoms.Count - 1; i > 0; i--) {  				// until we hit a level 1  				if (_atoms [i].level == 1) {  					if (string.Compare (_atoms [i].name' "moov"' true) == 0) {  						if (atomsize > _freesize) {  							// is this free bigger than others?  							//_freepos = stream.Position - 8;  							_freesize = atomsize;  						} else {  							break;  						}  					}  					// if moov  				}  				// if level = 1  			}  			// for  		}  		// if level = 2  	}  	// if free  	// if it's a container atom' parse the contents of the atom  	foreach (string atomType in ATOM_TYPES) {  		if (string.Compare (atomname' atomType' true) == 0) {  			ParseAtom (stream' stream.Position' offset + atomsize' level);  			break;  		}  	}  	// meta atom contains tags and some other data  	if (string.Compare (atomname' "meta"' true) == 0) {  		// read in meta atom  		byte[] atomdata = stream.Read (atomsize - 8);  		int nextTagPosition = 0;  		for (int i = 0; i < atomdata.Length - 4; i++) {  			// ilst  			if (atomdata [i] == 'i' && atomdata [i + 1] == 'l' && atomdata [i + 2] == 's' && atomdata [i + 3] == 't') {  				nextTagPosition = i + 8;  				break;  			}  		}  		while (nextTagPosition < (atomsize - 4) && nextTagPosition > 8) {  			int size = ReadInt32 (atomdata' (nextTagPosition - 4)) - 4;  			nextTagPosition += size + 4;  		}  	}  	// if meta  	// mdhd has data for calculating playtime  	if (string.Compare (atomname' "mdhd"' true) == 0) {  		stream.Seek (12' SeekOrigin.Current);  		Frequency = stream.ReadInt32 ();  		Samples = stream.ReadInt32 ();  	}  	// stsd has data for sample' channels and codec  	if (string.Compare (atomname' "stsd"' true) == 0) {  		byte[] atomdata = stream.Read (atomsize - 8);  		ParseStsdAtom (atomdata);  	}  	// bump offest and continue  	if (atomsize == 0) {  		// a 0 byte atom is the end  		offset = stopAt;  	} else {  		offset += atomsize;  	}  }  
Magic Number,IdSharp.AudioInfo,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\TagSizes\Mpeg4Tag.cs,ParseAtom,The following statement contains a magic number: while (offset < stopAt) {  	stream.Seek (offset' SeekOrigin.Begin);  	int atomsize = stream.ReadInt32 ();  	string atomname = ByteUtils.ISO88591.GetString (stream.Read (4));  	if ((offset + atomsize) > end) {  		throw new InvalidDataException (String.Format ("atom at {0} claims {1} bytes' end = {2}"' offset' atomsize' end));  	}  	Atom atom = new Atom ();  	atom.name = atomname;  	//atom.size = atomsize;  	//atom.pos = stream.Position - 8;  	atom.level = level;  	_atoms.Add (atom);  	if (string.Compare (atomname' "mdat"' true) == 0) {  		_mdatsize = atomsize;  	} /*else if (String.Compare(atomname' "moov"' true) == 0)                 {                     _moovpos = stream.Position - 8;                 }*//*else if (String.Compare(atomname' "udta"' true) == 0)                 {                     _udtapos = stream.Position - 8;                     _udtasize = atomsize;                 }*/else if (string.Compare (atomname' "free"' true) == 0) {  		// we'd like a free under a moov  		// so check for level = 1  		if (atom.level == 2) {  			// go backwards through the entries  			for (int i = _atoms.Count - 1; i > 0; i--) {  				// until we hit a level 1  				if (_atoms [i].level == 1) {  					if (string.Compare (_atoms [i].name' "moov"' true) == 0) {  						if (atomsize > _freesize) {  							// is this free bigger than others?  							//_freepos = stream.Position - 8;  							_freesize = atomsize;  						} else {  							break;  						}  					}  					// if moov  				}  				// if level = 1  			}  			// for  		}  		// if level = 2  	}  	// if free  	// if it's a container atom' parse the contents of the atom  	foreach (string atomType in ATOM_TYPES) {  		if (string.Compare (atomname' atomType' true) == 0) {  			ParseAtom (stream' stream.Position' offset + atomsize' level);  			break;  		}  	}  	// meta atom contains tags and some other data  	if (string.Compare (atomname' "meta"' true) == 0) {  		// read in meta atom  		byte[] atomdata = stream.Read (atomsize - 8);  		int nextTagPosition = 0;  		for (int i = 0; i < atomdata.Length - 4; i++) {  			// ilst  			if (atomdata [i] == 'i' && atomdata [i + 1] == 'l' && atomdata [i + 2] == 's' && atomdata [i + 3] == 't') {  				nextTagPosition = i + 8;  				break;  			}  		}  		while (nextTagPosition < (atomsize - 4) && nextTagPosition > 8) {  			int size = ReadInt32 (atomdata' (nextTagPosition - 4)) - 4;  			nextTagPosition += size + 4;  		}  	}  	// if meta  	// mdhd has data for calculating playtime  	if (string.Compare (atomname' "mdhd"' true) == 0) {  		stream.Seek (12' SeekOrigin.Current);  		Frequency = stream.ReadInt32 ();  		Samples = stream.ReadInt32 ();  	}  	// stsd has data for sample' channels and codec  	if (string.Compare (atomname' "stsd"' true) == 0) {  		byte[] atomdata = stream.Read (atomsize - 8);  		ParseStsdAtom (atomdata);  	}  	// bump offest and continue  	if (atomsize == 0) {  		// a 0 byte atom is the end  		offset = stopAt;  	} else {  		offset += atomsize;  	}  }  
Magic Number,IdSharp.AudioInfo,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\TagSizes\Mpeg4Tag.cs,ParseAtom,The following statement contains a magic number: while (offset < stopAt) {  	stream.Seek (offset' SeekOrigin.Begin);  	int atomsize = stream.ReadInt32 ();  	string atomname = ByteUtils.ISO88591.GetString (stream.Read (4));  	if ((offset + atomsize) > end) {  		throw new InvalidDataException (String.Format ("atom at {0} claims {1} bytes' end = {2}"' offset' atomsize' end));  	}  	Atom atom = new Atom ();  	atom.name = atomname;  	//atom.size = atomsize;  	//atom.pos = stream.Position - 8;  	atom.level = level;  	_atoms.Add (atom);  	if (string.Compare (atomname' "mdat"' true) == 0) {  		_mdatsize = atomsize;  	} /*else if (String.Compare(atomname' "moov"' true) == 0)                 {                     _moovpos = stream.Position - 8;                 }*//*else if (String.Compare(atomname' "udta"' true) == 0)                 {                     _udtapos = stream.Position - 8;                     _udtasize = atomsize;                 }*/else if (string.Compare (atomname' "free"' true) == 0) {  		// we'd like a free under a moov  		// so check for level = 1  		if (atom.level == 2) {  			// go backwards through the entries  			for (int i = _atoms.Count - 1; i > 0; i--) {  				// until we hit a level 1  				if (_atoms [i].level == 1) {  					if (string.Compare (_atoms [i].name' "moov"' true) == 0) {  						if (atomsize > _freesize) {  							// is this free bigger than others?  							//_freepos = stream.Position - 8;  							_freesize = atomsize;  						} else {  							break;  						}  					}  					// if moov  				}  				// if level = 1  			}  			// for  		}  		// if level = 2  	}  	// if free  	// if it's a container atom' parse the contents of the atom  	foreach (string atomType in ATOM_TYPES) {  		if (string.Compare (atomname' atomType' true) == 0) {  			ParseAtom (stream' stream.Position' offset + atomsize' level);  			break;  		}  	}  	// meta atom contains tags and some other data  	if (string.Compare (atomname' "meta"' true) == 0) {  		// read in meta atom  		byte[] atomdata = stream.Read (atomsize - 8);  		int nextTagPosition = 0;  		for (int i = 0; i < atomdata.Length - 4; i++) {  			// ilst  			if (atomdata [i] == 'i' && atomdata [i + 1] == 'l' && atomdata [i + 2] == 's' && atomdata [i + 3] == 't') {  				nextTagPosition = i + 8;  				break;  			}  		}  		while (nextTagPosition < (atomsize - 4) && nextTagPosition > 8) {  			int size = ReadInt32 (atomdata' (nextTagPosition - 4)) - 4;  			nextTagPosition += size + 4;  		}  	}  	// if meta  	// mdhd has data for calculating playtime  	if (string.Compare (atomname' "mdhd"' true) == 0) {  		stream.Seek (12' SeekOrigin.Current);  		Frequency = stream.ReadInt32 ();  		Samples = stream.ReadInt32 ();  	}  	// stsd has data for sample' channels and codec  	if (string.Compare (atomname' "stsd"' true) == 0) {  		byte[] atomdata = stream.Read (atomsize - 8);  		ParseStsdAtom (atomdata);  	}  	// bump offest and continue  	if (atomsize == 0) {  		// a 0 byte atom is the end  		offset = stopAt;  	} else {  		offset += atomsize;  	}  }  
Magic Number,IdSharp.AudioInfo,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\TagSizes\Mpeg4Tag.cs,ParseAtom,The following statement contains a magic number: if (string.Compare (atomname' "mdat"' true) == 0) {  	_mdatsize = atomsize;  } /*else if (String.Compare(atomname' "moov"' true) == 0)                 {                     _moovpos = stream.Position - 8;                 }*//*else if (String.Compare(atomname' "udta"' true) == 0)                 {                     _udtapos = stream.Position - 8;                     _udtasize = atomsize;                 }*/else if (string.Compare (atomname' "free"' true) == 0) {  	// we'd like a free under a moov  	// so check for level = 1  	if (atom.level == 2) {  		// go backwards through the entries  		for (int i = _atoms.Count - 1; i > 0; i--) {  			// until we hit a level 1  			if (_atoms [i].level == 1) {  				if (string.Compare (_atoms [i].name' "moov"' true) == 0) {  					if (atomsize > _freesize) {  						// is this free bigger than others?  						//_freepos = stream.Position - 8;  						_freesize = atomsize;  					} else {  						break;  					}  				}  				// if moov  			}  			// if level = 1  		}  		// for  	}  	// if level = 2  }  
Magic Number,IdSharp.AudioInfo,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\TagSizes\Mpeg4Tag.cs,ParseAtom,The following statement contains a magic number: if (string.Compare (atomname' "free"' true) == 0) {  	// we'd like a free under a moov  	// so check for level = 1  	if (atom.level == 2) {  		// go backwards through the entries  		for (int i = _atoms.Count - 1; i > 0; i--) {  			// until we hit a level 1  			if (_atoms [i].level == 1) {  				if (string.Compare (_atoms [i].name' "moov"' true) == 0) {  					if (atomsize > _freesize) {  						// is this free bigger than others?  						//_freepos = stream.Position - 8;  						_freesize = atomsize;  					} else {  						break;  					}  				}  				// if moov  			}  			// if level = 1  		}  		// for  	}  	// if level = 2  }  
Magic Number,IdSharp.AudioInfo,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\TagSizes\Mpeg4Tag.cs,ParseAtom,The following statement contains a magic number: if (atom.level == 2) {  	// go backwards through the entries  	for (int i = _atoms.Count - 1; i > 0; i--) {  		// until we hit a level 1  		if (_atoms [i].level == 1) {  			if (string.Compare (_atoms [i].name' "moov"' true) == 0) {  				if (atomsize > _freesize) {  					// is this free bigger than others?  					//_freepos = stream.Position - 8;  					_freesize = atomsize;  				} else {  					break;  				}  			}  			// if moov  		}  		// if level = 1  	}  	// for  }  
Magic Number,IdSharp.AudioInfo,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\TagSizes\Mpeg4Tag.cs,ParseAtom,The following statement contains a magic number: if (string.Compare (atomname' "meta"' true) == 0) {  	// read in meta atom  	byte[] atomdata = stream.Read (atomsize - 8);  	int nextTagPosition = 0;  	for (int i = 0; i < atomdata.Length - 4; i++) {  		// ilst  		if (atomdata [i] == 'i' && atomdata [i + 1] == 'l' && atomdata [i + 2] == 's' && atomdata [i + 3] == 't') {  			nextTagPosition = i + 8;  			break;  		}  	}  	while (nextTagPosition < (atomsize - 4) && nextTagPosition > 8) {  		int size = ReadInt32 (atomdata' (nextTagPosition - 4)) - 4;  		nextTagPosition += size + 4;  	}  }  
Magic Number,IdSharp.AudioInfo,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\TagSizes\Mpeg4Tag.cs,ParseAtom,The following statement contains a magic number: if (string.Compare (atomname' "meta"' true) == 0) {  	// read in meta atom  	byte[] atomdata = stream.Read (atomsize - 8);  	int nextTagPosition = 0;  	for (int i = 0; i < atomdata.Length - 4; i++) {  		// ilst  		if (atomdata [i] == 'i' && atomdata [i + 1] == 'l' && atomdata [i + 2] == 's' && atomdata [i + 3] == 't') {  			nextTagPosition = i + 8;  			break;  		}  	}  	while (nextTagPosition < (atomsize - 4) && nextTagPosition > 8) {  		int size = ReadInt32 (atomdata' (nextTagPosition - 4)) - 4;  		nextTagPosition += size + 4;  	}  }  
Magic Number,IdSharp.AudioInfo,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\TagSizes\Mpeg4Tag.cs,ParseAtom,The following statement contains a magic number: if (string.Compare (atomname' "meta"' true) == 0) {  	// read in meta atom  	byte[] atomdata = stream.Read (atomsize - 8);  	int nextTagPosition = 0;  	for (int i = 0; i < atomdata.Length - 4; i++) {  		// ilst  		if (atomdata [i] == 'i' && atomdata [i + 1] == 'l' && atomdata [i + 2] == 's' && atomdata [i + 3] == 't') {  			nextTagPosition = i + 8;  			break;  		}  	}  	while (nextTagPosition < (atomsize - 4) && nextTagPosition > 8) {  		int size = ReadInt32 (atomdata' (nextTagPosition - 4)) - 4;  		nextTagPosition += size + 4;  	}  }  
Magic Number,IdSharp.AudioInfo,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\TagSizes\Mpeg4Tag.cs,ParseAtom,The following statement contains a magic number: if (string.Compare (atomname' "meta"' true) == 0) {  	// read in meta atom  	byte[] atomdata = stream.Read (atomsize - 8);  	int nextTagPosition = 0;  	for (int i = 0; i < atomdata.Length - 4; i++) {  		// ilst  		if (atomdata [i] == 'i' && atomdata [i + 1] == 'l' && atomdata [i + 2] == 's' && atomdata [i + 3] == 't') {  			nextTagPosition = i + 8;  			break;  		}  	}  	while (nextTagPosition < (atomsize - 4) && nextTagPosition > 8) {  		int size = ReadInt32 (atomdata' (nextTagPosition - 4)) - 4;  		nextTagPosition += size + 4;  	}  }  
Magic Number,IdSharp.AudioInfo,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\TagSizes\Mpeg4Tag.cs,ParseAtom,The following statement contains a magic number: if (string.Compare (atomname' "meta"' true) == 0) {  	// read in meta atom  	byte[] atomdata = stream.Read (atomsize - 8);  	int nextTagPosition = 0;  	for (int i = 0; i < atomdata.Length - 4; i++) {  		// ilst  		if (atomdata [i] == 'i' && atomdata [i + 1] == 'l' && atomdata [i + 2] == 's' && atomdata [i + 3] == 't') {  			nextTagPosition = i + 8;  			break;  		}  	}  	while (nextTagPosition < (atomsize - 4) && nextTagPosition > 8) {  		int size = ReadInt32 (atomdata' (nextTagPosition - 4)) - 4;  		nextTagPosition += size + 4;  	}  }  
Magic Number,IdSharp.AudioInfo,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\TagSizes\Mpeg4Tag.cs,ParseAtom,The following statement contains a magic number: if (string.Compare (atomname' "meta"' true) == 0) {  	// read in meta atom  	byte[] atomdata = stream.Read (atomsize - 8);  	int nextTagPosition = 0;  	for (int i = 0; i < atomdata.Length - 4; i++) {  		// ilst  		if (atomdata [i] == 'i' && atomdata [i + 1] == 'l' && atomdata [i + 2] == 's' && atomdata [i + 3] == 't') {  			nextTagPosition = i + 8;  			break;  		}  	}  	while (nextTagPosition < (atomsize - 4) && nextTagPosition > 8) {  		int size = ReadInt32 (atomdata' (nextTagPosition - 4)) - 4;  		nextTagPosition += size + 4;  	}  }  
Magic Number,IdSharp.AudioInfo,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\TagSizes\Mpeg4Tag.cs,ParseAtom,The following statement contains a magic number: if (string.Compare (atomname' "meta"' true) == 0) {  	// read in meta atom  	byte[] atomdata = stream.Read (atomsize - 8);  	int nextTagPosition = 0;  	for (int i = 0; i < atomdata.Length - 4; i++) {  		// ilst  		if (atomdata [i] == 'i' && atomdata [i + 1] == 'l' && atomdata [i + 2] == 's' && atomdata [i + 3] == 't') {  			nextTagPosition = i + 8;  			break;  		}  	}  	while (nextTagPosition < (atomsize - 4) && nextTagPosition > 8) {  		int size = ReadInt32 (atomdata' (nextTagPosition - 4)) - 4;  		nextTagPosition += size + 4;  	}  }  
Magic Number,IdSharp.AudioInfo,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\TagSizes\Mpeg4Tag.cs,ParseAtom,The following statement contains a magic number: if (string.Compare (atomname' "meta"' true) == 0) {  	// read in meta atom  	byte[] atomdata = stream.Read (atomsize - 8);  	int nextTagPosition = 0;  	for (int i = 0; i < atomdata.Length - 4; i++) {  		// ilst  		if (atomdata [i] == 'i' && atomdata [i + 1] == 'l' && atomdata [i + 2] == 's' && atomdata [i + 3] == 't') {  			nextTagPosition = i + 8;  			break;  		}  	}  	while (nextTagPosition < (atomsize - 4) && nextTagPosition > 8) {  		int size = ReadInt32 (atomdata' (nextTagPosition - 4)) - 4;  		nextTagPosition += size + 4;  	}  }  
Magic Number,IdSharp.AudioInfo,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\TagSizes\Mpeg4Tag.cs,ParseAtom,The following statement contains a magic number: if (string.Compare (atomname' "meta"' true) == 0) {  	// read in meta atom  	byte[] atomdata = stream.Read (atomsize - 8);  	int nextTagPosition = 0;  	for (int i = 0; i < atomdata.Length - 4; i++) {  		// ilst  		if (atomdata [i] == 'i' && atomdata [i + 1] == 'l' && atomdata [i + 2] == 's' && atomdata [i + 3] == 't') {  			nextTagPosition = i + 8;  			break;  		}  	}  	while (nextTagPosition < (atomsize - 4) && nextTagPosition > 8) {  		int size = ReadInt32 (atomdata' (nextTagPosition - 4)) - 4;  		nextTagPosition += size + 4;  	}  }  
Magic Number,IdSharp.AudioInfo,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\TagSizes\Mpeg4Tag.cs,ParseAtom,The following statement contains a magic number: if (string.Compare (atomname' "meta"' true) == 0) {  	// read in meta atom  	byte[] atomdata = stream.Read (atomsize - 8);  	int nextTagPosition = 0;  	for (int i = 0; i < atomdata.Length - 4; i++) {  		// ilst  		if (atomdata [i] == 'i' && atomdata [i + 1] == 'l' && atomdata [i + 2] == 's' && atomdata [i + 3] == 't') {  			nextTagPosition = i + 8;  			break;  		}  	}  	while (nextTagPosition < (atomsize - 4) && nextTagPosition > 8) {  		int size = ReadInt32 (atomdata' (nextTagPosition - 4)) - 4;  		nextTagPosition += size + 4;  	}  }  
Magic Number,IdSharp.AudioInfo,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\TagSizes\Mpeg4Tag.cs,ParseAtom,The following statement contains a magic number: for (int i = 0; i < atomdata.Length - 4; i++) {  	// ilst  	if (atomdata [i] == 'i' && atomdata [i + 1] == 'l' && atomdata [i + 2] == 's' && atomdata [i + 3] == 't') {  		nextTagPosition = i + 8;  		break;  	}  }  
Magic Number,IdSharp.AudioInfo,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\TagSizes\Mpeg4Tag.cs,ParseAtom,The following statement contains a magic number: for (int i = 0; i < atomdata.Length - 4; i++) {  	// ilst  	if (atomdata [i] == 'i' && atomdata [i + 1] == 'l' && atomdata [i + 2] == 's' && atomdata [i + 3] == 't') {  		nextTagPosition = i + 8;  		break;  	}  }  
Magic Number,IdSharp.AudioInfo,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\TagSizes\Mpeg4Tag.cs,ParseAtom,The following statement contains a magic number: for (int i = 0; i < atomdata.Length - 4; i++) {  	// ilst  	if (atomdata [i] == 'i' && atomdata [i + 1] == 'l' && atomdata [i + 2] == 's' && atomdata [i + 3] == 't') {  		nextTagPosition = i + 8;  		break;  	}  }  
Magic Number,IdSharp.AudioInfo,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\TagSizes\Mpeg4Tag.cs,ParseAtom,The following statement contains a magic number: for (int i = 0; i < atomdata.Length - 4; i++) {  	// ilst  	if (atomdata [i] == 'i' && atomdata [i + 1] == 'l' && atomdata [i + 2] == 's' && atomdata [i + 3] == 't') {  		nextTagPosition = i + 8;  		break;  	}  }  
Magic Number,IdSharp.AudioInfo,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\TagSizes\Mpeg4Tag.cs,ParseAtom,The following statement contains a magic number: if (atomdata [i] == 'i' && atomdata [i + 1] == 'l' && atomdata [i + 2] == 's' && atomdata [i + 3] == 't') {  	nextTagPosition = i + 8;  	break;  }  
Magic Number,IdSharp.AudioInfo,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\TagSizes\Mpeg4Tag.cs,ParseAtom,The following statement contains a magic number: if (atomdata [i] == 'i' && atomdata [i + 1] == 'l' && atomdata [i + 2] == 's' && atomdata [i + 3] == 't') {  	nextTagPosition = i + 8;  	break;  }  
Magic Number,IdSharp.AudioInfo,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\TagSizes\Mpeg4Tag.cs,ParseAtom,The following statement contains a magic number: if (atomdata [i] == 'i' && atomdata [i + 1] == 'l' && atomdata [i + 2] == 's' && atomdata [i + 3] == 't') {  	nextTagPosition = i + 8;  	break;  }  
Magic Number,IdSharp.AudioInfo,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\TagSizes\Mpeg4Tag.cs,ParseAtom,The following statement contains a magic number: nextTagPosition = i + 8;  
Magic Number,IdSharp.AudioInfo,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\TagSizes\Mpeg4Tag.cs,ParseAtom,The following statement contains a magic number: while (nextTagPosition < (atomsize - 4) && nextTagPosition > 8) {  	int size = ReadInt32 (atomdata' (nextTagPosition - 4)) - 4;  	nextTagPosition += size + 4;  }  
Magic Number,IdSharp.AudioInfo,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\TagSizes\Mpeg4Tag.cs,ParseAtom,The following statement contains a magic number: while (nextTagPosition < (atomsize - 4) && nextTagPosition > 8) {  	int size = ReadInt32 (atomdata' (nextTagPosition - 4)) - 4;  	nextTagPosition += size + 4;  }  
Magic Number,IdSharp.AudioInfo,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\TagSizes\Mpeg4Tag.cs,ParseAtom,The following statement contains a magic number: while (nextTagPosition < (atomsize - 4) && nextTagPosition > 8) {  	int size = ReadInt32 (atomdata' (nextTagPosition - 4)) - 4;  	nextTagPosition += size + 4;  }  
Magic Number,IdSharp.AudioInfo,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\TagSizes\Mpeg4Tag.cs,ParseAtom,The following statement contains a magic number: while (nextTagPosition < (atomsize - 4) && nextTagPosition > 8) {  	int size = ReadInt32 (atomdata' (nextTagPosition - 4)) - 4;  	nextTagPosition += size + 4;  }  
Magic Number,IdSharp.AudioInfo,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\TagSizes\Mpeg4Tag.cs,ParseAtom,The following statement contains a magic number: while (nextTagPosition < (atomsize - 4) && nextTagPosition > 8) {  	int size = ReadInt32 (atomdata' (nextTagPosition - 4)) - 4;  	nextTagPosition += size + 4;  }  
Magic Number,IdSharp.AudioInfo,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\TagSizes\Mpeg4Tag.cs,ParseAtom,The following statement contains a magic number: nextTagPosition += size + 4;  
Magic Number,IdSharp.AudioInfo,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\TagSizes\Mpeg4Tag.cs,ParseAtom,The following statement contains a magic number: if (string.Compare (atomname' "mdhd"' true) == 0) {  	stream.Seek (12' SeekOrigin.Current);  	Frequency = stream.ReadInt32 ();  	Samples = stream.ReadInt32 ();  }  
Magic Number,IdSharp.AudioInfo,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\TagSizes\Mpeg4Tag.cs,ParseAtom,The following statement contains a magic number: stream.Seek (12' SeekOrigin.Current);  
Magic Number,IdSharp.AudioInfo,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\TagSizes\Mpeg4Tag.cs,ParseAtom,The following statement contains a magic number: if (string.Compare (atomname' "stsd"' true) == 0) {  	byte[] atomdata = stream.Read (atomsize - 8);  	ParseStsdAtom (atomdata);  }  
Magic Number,IdSharp.AudioInfo.Inspection,BasicLameTagReader,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\BasicLameTagReader.cs,BasicLameTagReader,The following statement contains a magic number: if (_tag.VersionString [1] == '.') {  	byte[] versionString = new byte[6];  	int i;  	for (i = 0; i < 4 || (i == 4 && _tag.VersionString [i] == 'b'); i++)  		versionString [i] = _tag.VersionString [i];  	Array.Resize (ref versionString' i);  	_versionString = Encoding.ASCII.GetString (versionString);  } else {  	_versionString = "";  }  
Magic Number,IdSharp.AudioInfo.Inspection,BasicLameTagReader,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\BasicLameTagReader.cs,BasicLameTagReader,The following statement contains a magic number: if (_tag.VersionString [1] == '.') {  	byte[] versionString = new byte[6];  	int i;  	for (i = 0; i < 4 || (i == 4 && _tag.VersionString [i] == 'b'); i++)  		versionString [i] = _tag.VersionString [i];  	Array.Resize (ref versionString' i);  	_versionString = Encoding.ASCII.GetString (versionString);  } else {  	_versionString = "";  }  
Magic Number,IdSharp.AudioInfo.Inspection,BasicLameTagReader,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\BasicLameTagReader.cs,BasicLameTagReader,The following statement contains a magic number: if (_tag.VersionString [1] == '.') {  	byte[] versionString = new byte[6];  	int i;  	for (i = 0; i < 4 || (i == 4 && _tag.VersionString [i] == 'b'); i++)  		versionString [i] = _tag.VersionString [i];  	Array.Resize (ref versionString' i);  	_versionString = Encoding.ASCII.GetString (versionString);  } else {  	_versionString = "";  }  
Magic Number,IdSharp.AudioInfo.Inspection,BasicLameTagReader,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\BasicLameTagReader.cs,BasicLameTagReader,The following statement contains a magic number: for (i = 0; i < 4 || (i == 4 && _tag.VersionString [i] == 'b'); i++)  	versionString [i] = _tag.VersionString [i];  
Magic Number,IdSharp.AudioInfo.Inspection,BasicLameTagReader,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\BasicLameTagReader.cs,BasicLameTagReader,The following statement contains a magic number: for (i = 0; i < 4 || (i == 4 && _tag.VersionString [i] == 'b'); i++)  	versionString [i] = _tag.VersionString [i];  
Magic Number,IdSharp.AudioInfo.Inspection,BasicLameTagReader,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\BasicLameTagReader.cs,BasicLameTagReader,The following statement contains a magic number: _preset = (ushort)(((_tag.Surround_Preset [0] << 8) + _tag.Surround_Preset [1]) & 0x07FF);  
Magic Number,IdSharp.AudioInfo.Inspection,DescriptiveLameTagReader,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\DescriptiveLameTagReader.cs,DeterminePreset,The following statement contains a magic number: if (preset >= 8 && preset <= 320) {  	result = preset.ToString ();  	if (_basicReader.EncodingMethod == 1)  		result = "cbr " + result;  	usePresetGuess = UsePresetGuess.UseGuess;  } else {  	switch (preset) {  	case 0:  		result = "<not stored>";  		usePresetGuess = UsePresetGuess.UseGuess;  		break;  	case 410:  		result = "V9";  		break;  	case 420:  		result = "V8";  		break;  	case 430:  		result = "V7";  		break;  	case 440:  		result = "V6";  		break;  	case 450:  		result = "V5";  		break;  	case 460:  		result = "V4: preset medium";  		break;  	case 470:  		result = "V3";  		break;  	case 480:  		result = "V2: preset standard";  		break;  	case 490:  		result = "V1";  		break;  	case 500:  		result = "V0: preset extreme";  		break;  	case 1000:  		result = "r3mix";  		break;  	case 1001:  		result = "--alt-preset standard";  		break;  	case 1002:  		result = "--alt-preset extreme";  		break;  	case 1003:  		result = "--alt-preset insane";  		break;  	case 1004:  		result = "--alt-preset fast standard";  		break;  	case 1005:  		result = "--alt-preset fast extreme";  		break;  	case 1006:  		result = "preset medium";  		break;  	case 1007:  		result = "preset fast medium";  		break;  	case 1010:  		result = "preset portable";  		// only used in alpha versions (3.94 alpha 14 and below)  		break;  	case 1015:  		result = "preset radio";  		// only used in alpha versions (3.94 alpha 14 and below)  		break;  	default:  		result = string.Format ("<unrecognised value {0}>"' preset);  		usePresetGuess = UsePresetGuess.UseGuess;  		break;  	}  }  
Magic Number,IdSharp.AudioInfo.Inspection,DescriptiveLameTagReader,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\DescriptiveLameTagReader.cs,DeterminePreset,The following statement contains a magic number: if (preset >= 8 && preset <= 320) {  	result = preset.ToString ();  	if (_basicReader.EncodingMethod == 1)  		result = "cbr " + result;  	usePresetGuess = UsePresetGuess.UseGuess;  } else {  	switch (preset) {  	case 0:  		result = "<not stored>";  		usePresetGuess = UsePresetGuess.UseGuess;  		break;  	case 410:  		result = "V9";  		break;  	case 420:  		result = "V8";  		break;  	case 430:  		result = "V7";  		break;  	case 440:  		result = "V6";  		break;  	case 450:  		result = "V5";  		break;  	case 460:  		result = "V4: preset medium";  		break;  	case 470:  		result = "V3";  		break;  	case 480:  		result = "V2: preset standard";  		break;  	case 490:  		result = "V1";  		break;  	case 500:  		result = "V0: preset extreme";  		break;  	case 1000:  		result = "r3mix";  		break;  	case 1001:  		result = "--alt-preset standard";  		break;  	case 1002:  		result = "--alt-preset extreme";  		break;  	case 1003:  		result = "--alt-preset insane";  		break;  	case 1004:  		result = "--alt-preset fast standard";  		break;  	case 1005:  		result = "--alt-preset fast extreme";  		break;  	case 1006:  		result = "preset medium";  		break;  	case 1007:  		result = "preset fast medium";  		break;  	case 1010:  		result = "preset portable";  		// only used in alpha versions (3.94 alpha 14 and below)  		break;  	case 1015:  		result = "preset radio";  		// only used in alpha versions (3.94 alpha 14 and below)  		break;  	default:  		result = string.Format ("<unrecognised value {0}>"' preset);  		usePresetGuess = UsePresetGuess.UseGuess;  		break;  	}  }  
Magic Number,IdSharp.AudioInfo.Inspection,DescriptiveLameTagReader,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\DescriptiveLameTagReader.cs,DeterminePreset,The following statement contains a magic number: if (preset >= 8 && preset <= 320) {  	result = preset.ToString ();  	if (_basicReader.EncodingMethod == 1)  		result = "cbr " + result;  	usePresetGuess = UsePresetGuess.UseGuess;  } else {  	switch (preset) {  	case 0:  		result = "<not stored>";  		usePresetGuess = UsePresetGuess.UseGuess;  		break;  	case 410:  		result = "V9";  		break;  	case 420:  		result = "V8";  		break;  	case 430:  		result = "V7";  		break;  	case 440:  		result = "V6";  		break;  	case 450:  		result = "V5";  		break;  	case 460:  		result = "V4: preset medium";  		break;  	case 470:  		result = "V3";  		break;  	case 480:  		result = "V2: preset standard";  		break;  	case 490:  		result = "V1";  		break;  	case 500:  		result = "V0: preset extreme";  		break;  	case 1000:  		result = "r3mix";  		break;  	case 1001:  		result = "--alt-preset standard";  		break;  	case 1002:  		result = "--alt-preset extreme";  		break;  	case 1003:  		result = "--alt-preset insane";  		break;  	case 1004:  		result = "--alt-preset fast standard";  		break;  	case 1005:  		result = "--alt-preset fast extreme";  		break;  	case 1006:  		result = "preset medium";  		break;  	case 1007:  		result = "preset fast medium";  		break;  	case 1010:  		result = "preset portable";  		// only used in alpha versions (3.94 alpha 14 and below)  		break;  	case 1015:  		result = "preset radio";  		// only used in alpha versions (3.94 alpha 14 and below)  		break;  	default:  		result = string.Format ("<unrecognised value {0}>"' preset);  		usePresetGuess = UsePresetGuess.UseGuess;  		break;  	}  }  
Magic Number,IdSharp.AudioInfo.Inspection,DescriptiveLameTagReader,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\DescriptiveLameTagReader.cs,DeterminePreset,The following statement contains a magic number: if (preset >= 8 && preset <= 320) {  	result = preset.ToString ();  	if (_basicReader.EncodingMethod == 1)  		result = "cbr " + result;  	usePresetGuess = UsePresetGuess.UseGuess;  } else {  	switch (preset) {  	case 0:  		result = "<not stored>";  		usePresetGuess = UsePresetGuess.UseGuess;  		break;  	case 410:  		result = "V9";  		break;  	case 420:  		result = "V8";  		break;  	case 430:  		result = "V7";  		break;  	case 440:  		result = "V6";  		break;  	case 450:  		result = "V5";  		break;  	case 460:  		result = "V4: preset medium";  		break;  	case 470:  		result = "V3";  		break;  	case 480:  		result = "V2: preset standard";  		break;  	case 490:  		result = "V1";  		break;  	case 500:  		result = "V0: preset extreme";  		break;  	case 1000:  		result = "r3mix";  		break;  	case 1001:  		result = "--alt-preset standard";  		break;  	case 1002:  		result = "--alt-preset extreme";  		break;  	case 1003:  		result = "--alt-preset insane";  		break;  	case 1004:  		result = "--alt-preset fast standard";  		break;  	case 1005:  		result = "--alt-preset fast extreme";  		break;  	case 1006:  		result = "preset medium";  		break;  	case 1007:  		result = "preset fast medium";  		break;  	case 1010:  		result = "preset portable";  		// only used in alpha versions (3.94 alpha 14 and below)  		break;  	case 1015:  		result = "preset radio";  		// only used in alpha versions (3.94 alpha 14 and below)  		break;  	default:  		result = string.Format ("<unrecognised value {0}>"' preset);  		usePresetGuess = UsePresetGuess.UseGuess;  		break;  	}  }  
Magic Number,IdSharp.AudioInfo.Inspection,DescriptiveLameTagReader,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\DescriptiveLameTagReader.cs,DeterminePreset,The following statement contains a magic number: if (preset >= 8 && preset <= 320) {  	result = preset.ToString ();  	if (_basicReader.EncodingMethod == 1)  		result = "cbr " + result;  	usePresetGuess = UsePresetGuess.UseGuess;  } else {  	switch (preset) {  	case 0:  		result = "<not stored>";  		usePresetGuess = UsePresetGuess.UseGuess;  		break;  	case 410:  		result = "V9";  		break;  	case 420:  		result = "V8";  		break;  	case 430:  		result = "V7";  		break;  	case 440:  		result = "V6";  		break;  	case 450:  		result = "V5";  		break;  	case 460:  		result = "V4: preset medium";  		break;  	case 470:  		result = "V3";  		break;  	case 480:  		result = "V2: preset standard";  		break;  	case 490:  		result = "V1";  		break;  	case 500:  		result = "V0: preset extreme";  		break;  	case 1000:  		result = "r3mix";  		break;  	case 1001:  		result = "--alt-preset standard";  		break;  	case 1002:  		result = "--alt-preset extreme";  		break;  	case 1003:  		result = "--alt-preset insane";  		break;  	case 1004:  		result = "--alt-preset fast standard";  		break;  	case 1005:  		result = "--alt-preset fast extreme";  		break;  	case 1006:  		result = "preset medium";  		break;  	case 1007:  		result = "preset fast medium";  		break;  	case 1010:  		result = "preset portable";  		// only used in alpha versions (3.94 alpha 14 and below)  		break;  	case 1015:  		result = "preset radio";  		// only used in alpha versions (3.94 alpha 14 and below)  		break;  	default:  		result = string.Format ("<unrecognised value {0}>"' preset);  		usePresetGuess = UsePresetGuess.UseGuess;  		break;  	}  }  
Magic Number,IdSharp.AudioInfo.Inspection,DescriptiveLameTagReader,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\DescriptiveLameTagReader.cs,DeterminePreset,The following statement contains a magic number: if (preset >= 8 && preset <= 320) {  	result = preset.ToString ();  	if (_basicReader.EncodingMethod == 1)  		result = "cbr " + result;  	usePresetGuess = UsePresetGuess.UseGuess;  } else {  	switch (preset) {  	case 0:  		result = "<not stored>";  		usePresetGuess = UsePresetGuess.UseGuess;  		break;  	case 410:  		result = "V9";  		break;  	case 420:  		result = "V8";  		break;  	case 430:  		result = "V7";  		break;  	case 440:  		result = "V6";  		break;  	case 450:  		result = "V5";  		break;  	case 460:  		result = "V4: preset medium";  		break;  	case 470:  		result = "V3";  		break;  	case 480:  		result = "V2: preset standard";  		break;  	case 490:  		result = "V1";  		break;  	case 500:  		result = "V0: preset extreme";  		break;  	case 1000:  		result = "r3mix";  		break;  	case 1001:  		result = "--alt-preset standard";  		break;  	case 1002:  		result = "--alt-preset extreme";  		break;  	case 1003:  		result = "--alt-preset insane";  		break;  	case 1004:  		result = "--alt-preset fast standard";  		break;  	case 1005:  		result = "--alt-preset fast extreme";  		break;  	case 1006:  		result = "preset medium";  		break;  	case 1007:  		result = "preset fast medium";  		break;  	case 1010:  		result = "preset portable";  		// only used in alpha versions (3.94 alpha 14 and below)  		break;  	case 1015:  		result = "preset radio";  		// only used in alpha versions (3.94 alpha 14 and below)  		break;  	default:  		result = string.Format ("<unrecognised value {0}>"' preset);  		usePresetGuess = UsePresetGuess.UseGuess;  		break;  	}  }  
Magic Number,IdSharp.AudioInfo.Inspection,DescriptiveLameTagReader,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\DescriptiveLameTagReader.cs,DeterminePreset,The following statement contains a magic number: if (preset >= 8 && preset <= 320) {  	result = preset.ToString ();  	if (_basicReader.EncodingMethod == 1)  		result = "cbr " + result;  	usePresetGuess = UsePresetGuess.UseGuess;  } else {  	switch (preset) {  	case 0:  		result = "<not stored>";  		usePresetGuess = UsePresetGuess.UseGuess;  		break;  	case 410:  		result = "V9";  		break;  	case 420:  		result = "V8";  		break;  	case 430:  		result = "V7";  		break;  	case 440:  		result = "V6";  		break;  	case 450:  		result = "V5";  		break;  	case 460:  		result = "V4: preset medium";  		break;  	case 470:  		result = "V3";  		break;  	case 480:  		result = "V2: preset standard";  		break;  	case 490:  		result = "V1";  		break;  	case 500:  		result = "V0: preset extreme";  		break;  	case 1000:  		result = "r3mix";  		break;  	case 1001:  		result = "--alt-preset standard";  		break;  	case 1002:  		result = "--alt-preset extreme";  		break;  	case 1003:  		result = "--alt-preset insane";  		break;  	case 1004:  		result = "--alt-preset fast standard";  		break;  	case 1005:  		result = "--alt-preset fast extreme";  		break;  	case 1006:  		result = "preset medium";  		break;  	case 1007:  		result = "preset fast medium";  		break;  	case 1010:  		result = "preset portable";  		// only used in alpha versions (3.94 alpha 14 and below)  		break;  	case 1015:  		result = "preset radio";  		// only used in alpha versions (3.94 alpha 14 and below)  		break;  	default:  		result = string.Format ("<unrecognised value {0}>"' preset);  		usePresetGuess = UsePresetGuess.UseGuess;  		break;  	}  }  
Magic Number,IdSharp.AudioInfo.Inspection,DescriptiveLameTagReader,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\DescriptiveLameTagReader.cs,DeterminePreset,The following statement contains a magic number: if (preset >= 8 && preset <= 320) {  	result = preset.ToString ();  	if (_basicReader.EncodingMethod == 1)  		result = "cbr " + result;  	usePresetGuess = UsePresetGuess.UseGuess;  } else {  	switch (preset) {  	case 0:  		result = "<not stored>";  		usePresetGuess = UsePresetGuess.UseGuess;  		break;  	case 410:  		result = "V9";  		break;  	case 420:  		result = "V8";  		break;  	case 430:  		result = "V7";  		break;  	case 440:  		result = "V6";  		break;  	case 450:  		result = "V5";  		break;  	case 460:  		result = "V4: preset medium";  		break;  	case 470:  		result = "V3";  		break;  	case 480:  		result = "V2: preset standard";  		break;  	case 490:  		result = "V1";  		break;  	case 500:  		result = "V0: preset extreme";  		break;  	case 1000:  		result = "r3mix";  		break;  	case 1001:  		result = "--alt-preset standard";  		break;  	case 1002:  		result = "--alt-preset extreme";  		break;  	case 1003:  		result = "--alt-preset insane";  		break;  	case 1004:  		result = "--alt-preset fast standard";  		break;  	case 1005:  		result = "--alt-preset fast extreme";  		break;  	case 1006:  		result = "preset medium";  		break;  	case 1007:  		result = "preset fast medium";  		break;  	case 1010:  		result = "preset portable";  		// only used in alpha versions (3.94 alpha 14 and below)  		break;  	case 1015:  		result = "preset radio";  		// only used in alpha versions (3.94 alpha 14 and below)  		break;  	default:  		result = string.Format ("<unrecognised value {0}>"' preset);  		usePresetGuess = UsePresetGuess.UseGuess;  		break;  	}  }  
Magic Number,IdSharp.AudioInfo.Inspection,DescriptiveLameTagReader,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\DescriptiveLameTagReader.cs,DeterminePreset,The following statement contains a magic number: if (preset >= 8 && preset <= 320) {  	result = preset.ToString ();  	if (_basicReader.EncodingMethod == 1)  		result = "cbr " + result;  	usePresetGuess = UsePresetGuess.UseGuess;  } else {  	switch (preset) {  	case 0:  		result = "<not stored>";  		usePresetGuess = UsePresetGuess.UseGuess;  		break;  	case 410:  		result = "V9";  		break;  	case 420:  		result = "V8";  		break;  	case 430:  		result = "V7";  		break;  	case 440:  		result = "V6";  		break;  	case 450:  		result = "V5";  		break;  	case 460:  		result = "V4: preset medium";  		break;  	case 470:  		result = "V3";  		break;  	case 480:  		result = "V2: preset standard";  		break;  	case 490:  		result = "V1";  		break;  	case 500:  		result = "V0: preset extreme";  		break;  	case 1000:  		result = "r3mix";  		break;  	case 1001:  		result = "--alt-preset standard";  		break;  	case 1002:  		result = "--alt-preset extreme";  		break;  	case 1003:  		result = "--alt-preset insane";  		break;  	case 1004:  		result = "--alt-preset fast standard";  		break;  	case 1005:  		result = "--alt-preset fast extreme";  		break;  	case 1006:  		result = "preset medium";  		break;  	case 1007:  		result = "preset fast medium";  		break;  	case 1010:  		result = "preset portable";  		// only used in alpha versions (3.94 alpha 14 and below)  		break;  	case 1015:  		result = "preset radio";  		// only used in alpha versions (3.94 alpha 14 and below)  		break;  	default:  		result = string.Format ("<unrecognised value {0}>"' preset);  		usePresetGuess = UsePresetGuess.UseGuess;  		break;  	}  }  
Magic Number,IdSharp.AudioInfo.Inspection,DescriptiveLameTagReader,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\DescriptiveLameTagReader.cs,DeterminePreset,The following statement contains a magic number: if (preset >= 8 && preset <= 320) {  	result = preset.ToString ();  	if (_basicReader.EncodingMethod == 1)  		result = "cbr " + result;  	usePresetGuess = UsePresetGuess.UseGuess;  } else {  	switch (preset) {  	case 0:  		result = "<not stored>";  		usePresetGuess = UsePresetGuess.UseGuess;  		break;  	case 410:  		result = "V9";  		break;  	case 420:  		result = "V8";  		break;  	case 430:  		result = "V7";  		break;  	case 440:  		result = "V6";  		break;  	case 450:  		result = "V5";  		break;  	case 460:  		result = "V4: preset medium";  		break;  	case 470:  		result = "V3";  		break;  	case 480:  		result = "V2: preset standard";  		break;  	case 490:  		result = "V1";  		break;  	case 500:  		result = "V0: preset extreme";  		break;  	case 1000:  		result = "r3mix";  		break;  	case 1001:  		result = "--alt-preset standard";  		break;  	case 1002:  		result = "--alt-preset extreme";  		break;  	case 1003:  		result = "--alt-preset insane";  		break;  	case 1004:  		result = "--alt-preset fast standard";  		break;  	case 1005:  		result = "--alt-preset fast extreme";  		break;  	case 1006:  		result = "preset medium";  		break;  	case 1007:  		result = "preset fast medium";  		break;  	case 1010:  		result = "preset portable";  		// only used in alpha versions (3.94 alpha 14 and below)  		break;  	case 1015:  		result = "preset radio";  		// only used in alpha versions (3.94 alpha 14 and below)  		break;  	default:  		result = string.Format ("<unrecognised value {0}>"' preset);  		usePresetGuess = UsePresetGuess.UseGuess;  		break;  	}  }  
Magic Number,IdSharp.AudioInfo.Inspection,DescriptiveLameTagReader,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\DescriptiveLameTagReader.cs,DeterminePreset,The following statement contains a magic number: if (preset >= 8 && preset <= 320) {  	result = preset.ToString ();  	if (_basicReader.EncodingMethod == 1)  		result = "cbr " + result;  	usePresetGuess = UsePresetGuess.UseGuess;  } else {  	switch (preset) {  	case 0:  		result = "<not stored>";  		usePresetGuess = UsePresetGuess.UseGuess;  		break;  	case 410:  		result = "V9";  		break;  	case 420:  		result = "V8";  		break;  	case 430:  		result = "V7";  		break;  	case 440:  		result = "V6";  		break;  	case 450:  		result = "V5";  		break;  	case 460:  		result = "V4: preset medium";  		break;  	case 470:  		result = "V3";  		break;  	case 480:  		result = "V2: preset standard";  		break;  	case 490:  		result = "V1";  		break;  	case 500:  		result = "V0: preset extreme";  		break;  	case 1000:  		result = "r3mix";  		break;  	case 1001:  		result = "--alt-preset standard";  		break;  	case 1002:  		result = "--alt-preset extreme";  		break;  	case 1003:  		result = "--alt-preset insane";  		break;  	case 1004:  		result = "--alt-preset fast standard";  		break;  	case 1005:  		result = "--alt-preset fast extreme";  		break;  	case 1006:  		result = "preset medium";  		break;  	case 1007:  		result = "preset fast medium";  		break;  	case 1010:  		result = "preset portable";  		// only used in alpha versions (3.94 alpha 14 and below)  		break;  	case 1015:  		result = "preset radio";  		// only used in alpha versions (3.94 alpha 14 and below)  		break;  	default:  		result = string.Format ("<unrecognised value {0}>"' preset);  		usePresetGuess = UsePresetGuess.UseGuess;  		break;  	}  }  
Magic Number,IdSharp.AudioInfo.Inspection,DescriptiveLameTagReader,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\DescriptiveLameTagReader.cs,DeterminePreset,The following statement contains a magic number: if (preset >= 8 && preset <= 320) {  	result = preset.ToString ();  	if (_basicReader.EncodingMethod == 1)  		result = "cbr " + result;  	usePresetGuess = UsePresetGuess.UseGuess;  } else {  	switch (preset) {  	case 0:  		result = "<not stored>";  		usePresetGuess = UsePresetGuess.UseGuess;  		break;  	case 410:  		result = "V9";  		break;  	case 420:  		result = "V8";  		break;  	case 430:  		result = "V7";  		break;  	case 440:  		result = "V6";  		break;  	case 450:  		result = "V5";  		break;  	case 460:  		result = "V4: preset medium";  		break;  	case 470:  		result = "V3";  		break;  	case 480:  		result = "V2: preset standard";  		break;  	case 490:  		result = "V1";  		break;  	case 500:  		result = "V0: preset extreme";  		break;  	case 1000:  		result = "r3mix";  		break;  	case 1001:  		result = "--alt-preset standard";  		break;  	case 1002:  		result = "--alt-preset extreme";  		break;  	case 1003:  		result = "--alt-preset insane";  		break;  	case 1004:  		result = "--alt-preset fast standard";  		break;  	case 1005:  		result = "--alt-preset fast extreme";  		break;  	case 1006:  		result = "preset medium";  		break;  	case 1007:  		result = "preset fast medium";  		break;  	case 1010:  		result = "preset portable";  		// only used in alpha versions (3.94 alpha 14 and below)  		break;  	case 1015:  		result = "preset radio";  		// only used in alpha versions (3.94 alpha 14 and below)  		break;  	default:  		result = string.Format ("<unrecognised value {0}>"' preset);  		usePresetGuess = UsePresetGuess.UseGuess;  		break;  	}  }  
Magic Number,IdSharp.AudioInfo.Inspection,DescriptiveLameTagReader,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\DescriptiveLameTagReader.cs,DeterminePreset,The following statement contains a magic number: if (preset >= 8 && preset <= 320) {  	result = preset.ToString ();  	if (_basicReader.EncodingMethod == 1)  		result = "cbr " + result;  	usePresetGuess = UsePresetGuess.UseGuess;  } else {  	switch (preset) {  	case 0:  		result = "<not stored>";  		usePresetGuess = UsePresetGuess.UseGuess;  		break;  	case 410:  		result = "V9";  		break;  	case 420:  		result = "V8";  		break;  	case 430:  		result = "V7";  		break;  	case 440:  		result = "V6";  		break;  	case 450:  		result = "V5";  		break;  	case 460:  		result = "V4: preset medium";  		break;  	case 470:  		result = "V3";  		break;  	case 480:  		result = "V2: preset standard";  		break;  	case 490:  		result = "V1";  		break;  	case 500:  		result = "V0: preset extreme";  		break;  	case 1000:  		result = "r3mix";  		break;  	case 1001:  		result = "--alt-preset standard";  		break;  	case 1002:  		result = "--alt-preset extreme";  		break;  	case 1003:  		result = "--alt-preset insane";  		break;  	case 1004:  		result = "--alt-preset fast standard";  		break;  	case 1005:  		result = "--alt-preset fast extreme";  		break;  	case 1006:  		result = "preset medium";  		break;  	case 1007:  		result = "preset fast medium";  		break;  	case 1010:  		result = "preset portable";  		// only used in alpha versions (3.94 alpha 14 and below)  		break;  	case 1015:  		result = "preset radio";  		// only used in alpha versions (3.94 alpha 14 and below)  		break;  	default:  		result = string.Format ("<unrecognised value {0}>"' preset);  		usePresetGuess = UsePresetGuess.UseGuess;  		break;  	}  }  
Magic Number,IdSharp.AudioInfo.Inspection,DescriptiveLameTagReader,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\DescriptiveLameTagReader.cs,DeterminePreset,The following statement contains a magic number: if (preset >= 8 && preset <= 320) {  	result = preset.ToString ();  	if (_basicReader.EncodingMethod == 1)  		result = "cbr " + result;  	usePresetGuess = UsePresetGuess.UseGuess;  } else {  	switch (preset) {  	case 0:  		result = "<not stored>";  		usePresetGuess = UsePresetGuess.UseGuess;  		break;  	case 410:  		result = "V9";  		break;  	case 420:  		result = "V8";  		break;  	case 430:  		result = "V7";  		break;  	case 440:  		result = "V6";  		break;  	case 450:  		result = "V5";  		break;  	case 460:  		result = "V4: preset medium";  		break;  	case 470:  		result = "V3";  		break;  	case 480:  		result = "V2: preset standard";  		break;  	case 490:  		result = "V1";  		break;  	case 500:  		result = "V0: preset extreme";  		break;  	case 1000:  		result = "r3mix";  		break;  	case 1001:  		result = "--alt-preset standard";  		break;  	case 1002:  		result = "--alt-preset extreme";  		break;  	case 1003:  		result = "--alt-preset insane";  		break;  	case 1004:  		result = "--alt-preset fast standard";  		break;  	case 1005:  		result = "--alt-preset fast extreme";  		break;  	case 1006:  		result = "preset medium";  		break;  	case 1007:  		result = "preset fast medium";  		break;  	case 1010:  		result = "preset portable";  		// only used in alpha versions (3.94 alpha 14 and below)  		break;  	case 1015:  		result = "preset radio";  		// only used in alpha versions (3.94 alpha 14 and below)  		break;  	default:  		result = string.Format ("<unrecognised value {0}>"' preset);  		usePresetGuess = UsePresetGuess.UseGuess;  		break;  	}  }  
Magic Number,IdSharp.AudioInfo.Inspection,DescriptiveLameTagReader,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\DescriptiveLameTagReader.cs,DeterminePreset,The following statement contains a magic number: if (preset >= 8 && preset <= 320) {  	result = preset.ToString ();  	if (_basicReader.EncodingMethod == 1)  		result = "cbr " + result;  	usePresetGuess = UsePresetGuess.UseGuess;  } else {  	switch (preset) {  	case 0:  		result = "<not stored>";  		usePresetGuess = UsePresetGuess.UseGuess;  		break;  	case 410:  		result = "V9";  		break;  	case 420:  		result = "V8";  		break;  	case 430:  		result = "V7";  		break;  	case 440:  		result = "V6";  		break;  	case 450:  		result = "V5";  		break;  	case 460:  		result = "V4: preset medium";  		break;  	case 470:  		result = "V3";  		break;  	case 480:  		result = "V2: preset standard";  		break;  	case 490:  		result = "V1";  		break;  	case 500:  		result = "V0: preset extreme";  		break;  	case 1000:  		result = "r3mix";  		break;  	case 1001:  		result = "--alt-preset standard";  		break;  	case 1002:  		result = "--alt-preset extreme";  		break;  	case 1003:  		result = "--alt-preset insane";  		break;  	case 1004:  		result = "--alt-preset fast standard";  		break;  	case 1005:  		result = "--alt-preset fast extreme";  		break;  	case 1006:  		result = "preset medium";  		break;  	case 1007:  		result = "preset fast medium";  		break;  	case 1010:  		result = "preset portable";  		// only used in alpha versions (3.94 alpha 14 and below)  		break;  	case 1015:  		result = "preset radio";  		// only used in alpha versions (3.94 alpha 14 and below)  		break;  	default:  		result = string.Format ("<unrecognised value {0}>"' preset);  		usePresetGuess = UsePresetGuess.UseGuess;  		break;  	}  }  
Magic Number,IdSharp.AudioInfo.Inspection,DescriptiveLameTagReader,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\DescriptiveLameTagReader.cs,DeterminePreset,The following statement contains a magic number: if (preset >= 8 && preset <= 320) {  	result = preset.ToString ();  	if (_basicReader.EncodingMethod == 1)  		result = "cbr " + result;  	usePresetGuess = UsePresetGuess.UseGuess;  } else {  	switch (preset) {  	case 0:  		result = "<not stored>";  		usePresetGuess = UsePresetGuess.UseGuess;  		break;  	case 410:  		result = "V9";  		break;  	case 420:  		result = "V8";  		break;  	case 430:  		result = "V7";  		break;  	case 440:  		result = "V6";  		break;  	case 450:  		result = "V5";  		break;  	case 460:  		result = "V4: preset medium";  		break;  	case 470:  		result = "V3";  		break;  	case 480:  		result = "V2: preset standard";  		break;  	case 490:  		result = "V1";  		break;  	case 500:  		result = "V0: preset extreme";  		break;  	case 1000:  		result = "r3mix";  		break;  	case 1001:  		result = "--alt-preset standard";  		break;  	case 1002:  		result = "--alt-preset extreme";  		break;  	case 1003:  		result = "--alt-preset insane";  		break;  	case 1004:  		result = "--alt-preset fast standard";  		break;  	case 1005:  		result = "--alt-preset fast extreme";  		break;  	case 1006:  		result = "preset medium";  		break;  	case 1007:  		result = "preset fast medium";  		break;  	case 1010:  		result = "preset portable";  		// only used in alpha versions (3.94 alpha 14 and below)  		break;  	case 1015:  		result = "preset radio";  		// only used in alpha versions (3.94 alpha 14 and below)  		break;  	default:  		result = string.Format ("<unrecognised value {0}>"' preset);  		usePresetGuess = UsePresetGuess.UseGuess;  		break;  	}  }  
Magic Number,IdSharp.AudioInfo.Inspection,DescriptiveLameTagReader,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\DescriptiveLameTagReader.cs,DeterminePreset,The following statement contains a magic number: if (preset >= 8 && preset <= 320) {  	result = preset.ToString ();  	if (_basicReader.EncodingMethod == 1)  		result = "cbr " + result;  	usePresetGuess = UsePresetGuess.UseGuess;  } else {  	switch (preset) {  	case 0:  		result = "<not stored>";  		usePresetGuess = UsePresetGuess.UseGuess;  		break;  	case 410:  		result = "V9";  		break;  	case 420:  		result = "V8";  		break;  	case 430:  		result = "V7";  		break;  	case 440:  		result = "V6";  		break;  	case 450:  		result = "V5";  		break;  	case 460:  		result = "V4: preset medium";  		break;  	case 470:  		result = "V3";  		break;  	case 480:  		result = "V2: preset standard";  		break;  	case 490:  		result = "V1";  		break;  	case 500:  		result = "V0: preset extreme";  		break;  	case 1000:  		result = "r3mix";  		break;  	case 1001:  		result = "--alt-preset standard";  		break;  	case 1002:  		result = "--alt-preset extreme";  		break;  	case 1003:  		result = "--alt-preset insane";  		break;  	case 1004:  		result = "--alt-preset fast standard";  		break;  	case 1005:  		result = "--alt-preset fast extreme";  		break;  	case 1006:  		result = "preset medium";  		break;  	case 1007:  		result = "preset fast medium";  		break;  	case 1010:  		result = "preset portable";  		// only used in alpha versions (3.94 alpha 14 and below)  		break;  	case 1015:  		result = "preset radio";  		// only used in alpha versions (3.94 alpha 14 and below)  		break;  	default:  		result = string.Format ("<unrecognised value {0}>"' preset);  		usePresetGuess = UsePresetGuess.UseGuess;  		break;  	}  }  
Magic Number,IdSharp.AudioInfo.Inspection,DescriptiveLameTagReader,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\DescriptiveLameTagReader.cs,DeterminePreset,The following statement contains a magic number: if (preset >= 8 && preset <= 320) {  	result = preset.ToString ();  	if (_basicReader.EncodingMethod == 1)  		result = "cbr " + result;  	usePresetGuess = UsePresetGuess.UseGuess;  } else {  	switch (preset) {  	case 0:  		result = "<not stored>";  		usePresetGuess = UsePresetGuess.UseGuess;  		break;  	case 410:  		result = "V9";  		break;  	case 420:  		result = "V8";  		break;  	case 430:  		result = "V7";  		break;  	case 440:  		result = "V6";  		break;  	case 450:  		result = "V5";  		break;  	case 460:  		result = "V4: preset medium";  		break;  	case 470:  		result = "V3";  		break;  	case 480:  		result = "V2: preset standard";  		break;  	case 490:  		result = "V1";  		break;  	case 500:  		result = "V0: preset extreme";  		break;  	case 1000:  		result = "r3mix";  		break;  	case 1001:  		result = "--alt-preset standard";  		break;  	case 1002:  		result = "--alt-preset extreme";  		break;  	case 1003:  		result = "--alt-preset insane";  		break;  	case 1004:  		result = "--alt-preset fast standard";  		break;  	case 1005:  		result = "--alt-preset fast extreme";  		break;  	case 1006:  		result = "preset medium";  		break;  	case 1007:  		result = "preset fast medium";  		break;  	case 1010:  		result = "preset portable";  		// only used in alpha versions (3.94 alpha 14 and below)  		break;  	case 1015:  		result = "preset radio";  		// only used in alpha versions (3.94 alpha 14 and below)  		break;  	default:  		result = string.Format ("<unrecognised value {0}>"' preset);  		usePresetGuess = UsePresetGuess.UseGuess;  		break;  	}  }  
Magic Number,IdSharp.AudioInfo.Inspection,DescriptiveLameTagReader,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\DescriptiveLameTagReader.cs,DeterminePreset,The following statement contains a magic number: if (preset >= 8 && preset <= 320) {  	result = preset.ToString ();  	if (_basicReader.EncodingMethod == 1)  		result = "cbr " + result;  	usePresetGuess = UsePresetGuess.UseGuess;  } else {  	switch (preset) {  	case 0:  		result = "<not stored>";  		usePresetGuess = UsePresetGuess.UseGuess;  		break;  	case 410:  		result = "V9";  		break;  	case 420:  		result = "V8";  		break;  	case 430:  		result = "V7";  		break;  	case 440:  		result = "V6";  		break;  	case 450:  		result = "V5";  		break;  	case 460:  		result = "V4: preset medium";  		break;  	case 470:  		result = "V3";  		break;  	case 480:  		result = "V2: preset standard";  		break;  	case 490:  		result = "V1";  		break;  	case 500:  		result = "V0: preset extreme";  		break;  	case 1000:  		result = "r3mix";  		break;  	case 1001:  		result = "--alt-preset standard";  		break;  	case 1002:  		result = "--alt-preset extreme";  		break;  	case 1003:  		result = "--alt-preset insane";  		break;  	case 1004:  		result = "--alt-preset fast standard";  		break;  	case 1005:  		result = "--alt-preset fast extreme";  		break;  	case 1006:  		result = "preset medium";  		break;  	case 1007:  		result = "preset fast medium";  		break;  	case 1010:  		result = "preset portable";  		// only used in alpha versions (3.94 alpha 14 and below)  		break;  	case 1015:  		result = "preset radio";  		// only used in alpha versions (3.94 alpha 14 and below)  		break;  	default:  		result = string.Format ("<unrecognised value {0}>"' preset);  		usePresetGuess = UsePresetGuess.UseGuess;  		break;  	}  }  
Magic Number,IdSharp.AudioInfo.Inspection,DescriptiveLameTagReader,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\DescriptiveLameTagReader.cs,DeterminePreset,The following statement contains a magic number: if (preset >= 8 && preset <= 320) {  	result = preset.ToString ();  	if (_basicReader.EncodingMethod == 1)  		result = "cbr " + result;  	usePresetGuess = UsePresetGuess.UseGuess;  } else {  	switch (preset) {  	case 0:  		result = "<not stored>";  		usePresetGuess = UsePresetGuess.UseGuess;  		break;  	case 410:  		result = "V9";  		break;  	case 420:  		result = "V8";  		break;  	case 430:  		result = "V7";  		break;  	case 440:  		result = "V6";  		break;  	case 450:  		result = "V5";  		break;  	case 460:  		result = "V4: preset medium";  		break;  	case 470:  		result = "V3";  		break;  	case 480:  		result = "V2: preset standard";  		break;  	case 490:  		result = "V1";  		break;  	case 500:  		result = "V0: preset extreme";  		break;  	case 1000:  		result = "r3mix";  		break;  	case 1001:  		result = "--alt-preset standard";  		break;  	case 1002:  		result = "--alt-preset extreme";  		break;  	case 1003:  		result = "--alt-preset insane";  		break;  	case 1004:  		result = "--alt-preset fast standard";  		break;  	case 1005:  		result = "--alt-preset fast extreme";  		break;  	case 1006:  		result = "preset medium";  		break;  	case 1007:  		result = "preset fast medium";  		break;  	case 1010:  		result = "preset portable";  		// only used in alpha versions (3.94 alpha 14 and below)  		break;  	case 1015:  		result = "preset radio";  		// only used in alpha versions (3.94 alpha 14 and below)  		break;  	default:  		result = string.Format ("<unrecognised value {0}>"' preset);  		usePresetGuess = UsePresetGuess.UseGuess;  		break;  	}  }  
Magic Number,IdSharp.AudioInfo.Inspection,DescriptiveLameTagReader,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\DescriptiveLameTagReader.cs,DeterminePreset,The following statement contains a magic number: if (preset >= 8 && preset <= 320) {  	result = preset.ToString ();  	if (_basicReader.EncodingMethod == 1)  		result = "cbr " + result;  	usePresetGuess = UsePresetGuess.UseGuess;  } else {  	switch (preset) {  	case 0:  		result = "<not stored>";  		usePresetGuess = UsePresetGuess.UseGuess;  		break;  	case 410:  		result = "V9";  		break;  	case 420:  		result = "V8";  		break;  	case 430:  		result = "V7";  		break;  	case 440:  		result = "V6";  		break;  	case 450:  		result = "V5";  		break;  	case 460:  		result = "V4: preset medium";  		break;  	case 470:  		result = "V3";  		break;  	case 480:  		result = "V2: preset standard";  		break;  	case 490:  		result = "V1";  		break;  	case 500:  		result = "V0: preset extreme";  		break;  	case 1000:  		result = "r3mix";  		break;  	case 1001:  		result = "--alt-preset standard";  		break;  	case 1002:  		result = "--alt-preset extreme";  		break;  	case 1003:  		result = "--alt-preset insane";  		break;  	case 1004:  		result = "--alt-preset fast standard";  		break;  	case 1005:  		result = "--alt-preset fast extreme";  		break;  	case 1006:  		result = "preset medium";  		break;  	case 1007:  		result = "preset fast medium";  		break;  	case 1010:  		result = "preset portable";  		// only used in alpha versions (3.94 alpha 14 and below)  		break;  	case 1015:  		result = "preset radio";  		// only used in alpha versions (3.94 alpha 14 and below)  		break;  	default:  		result = string.Format ("<unrecognised value {0}>"' preset);  		usePresetGuess = UsePresetGuess.UseGuess;  		break;  	}  }  
Magic Number,IdSharp.AudioInfo.Inspection,DescriptiveLameTagReader,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\DescriptiveLameTagReader.cs,DeterminePreset,The following statement contains a magic number: if (preset >= 8 && preset <= 320) {  	result = preset.ToString ();  	if (_basicReader.EncodingMethod == 1)  		result = "cbr " + result;  	usePresetGuess = UsePresetGuess.UseGuess;  } else {  	switch (preset) {  	case 0:  		result = "<not stored>";  		usePresetGuess = UsePresetGuess.UseGuess;  		break;  	case 410:  		result = "V9";  		break;  	case 420:  		result = "V8";  		break;  	case 430:  		result = "V7";  		break;  	case 440:  		result = "V6";  		break;  	case 450:  		result = "V5";  		break;  	case 460:  		result = "V4: preset medium";  		break;  	case 470:  		result = "V3";  		break;  	case 480:  		result = "V2: preset standard";  		break;  	case 490:  		result = "V1";  		break;  	case 500:  		result = "V0: preset extreme";  		break;  	case 1000:  		result = "r3mix";  		break;  	case 1001:  		result = "--alt-preset standard";  		break;  	case 1002:  		result = "--alt-preset extreme";  		break;  	case 1003:  		result = "--alt-preset insane";  		break;  	case 1004:  		result = "--alt-preset fast standard";  		break;  	case 1005:  		result = "--alt-preset fast extreme";  		break;  	case 1006:  		result = "preset medium";  		break;  	case 1007:  		result = "preset fast medium";  		break;  	case 1010:  		result = "preset portable";  		// only used in alpha versions (3.94 alpha 14 and below)  		break;  	case 1015:  		result = "preset radio";  		// only used in alpha versions (3.94 alpha 14 and below)  		break;  	default:  		result = string.Format ("<unrecognised value {0}>"' preset);  		usePresetGuess = UsePresetGuess.UseGuess;  		break;  	}  }  
Magic Number,IdSharp.AudioInfo.Inspection,DescriptiveLameTagReader,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\DescriptiveLameTagReader.cs,DeterminePreset,The following statement contains a magic number: switch (preset) {  case 0:  	result = "<not stored>";  	usePresetGuess = UsePresetGuess.UseGuess;  	break;  case 410:  	result = "V9";  	break;  case 420:  	result = "V8";  	break;  case 430:  	result = "V7";  	break;  case 440:  	result = "V6";  	break;  case 450:  	result = "V5";  	break;  case 460:  	result = "V4: preset medium";  	break;  case 470:  	result = "V3";  	break;  case 480:  	result = "V2: preset standard";  	break;  case 490:  	result = "V1";  	break;  case 500:  	result = "V0: preset extreme";  	break;  case 1000:  	result = "r3mix";  	break;  case 1001:  	result = "--alt-preset standard";  	break;  case 1002:  	result = "--alt-preset extreme";  	break;  case 1003:  	result = "--alt-preset insane";  	break;  case 1004:  	result = "--alt-preset fast standard";  	break;  case 1005:  	result = "--alt-preset fast extreme";  	break;  case 1006:  	result = "preset medium";  	break;  case 1007:  	result = "preset fast medium";  	break;  case 1010:  	result = "preset portable";  	// only used in alpha versions (3.94 alpha 14 and below)  	break;  case 1015:  	result = "preset radio";  	// only used in alpha versions (3.94 alpha 14 and below)  	break;  default:  	result = string.Format ("<unrecognised value {0}>"' preset);  	usePresetGuess = UsePresetGuess.UseGuess;  	break;  }  
Magic Number,IdSharp.AudioInfo.Inspection,DescriptiveLameTagReader,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\DescriptiveLameTagReader.cs,DeterminePreset,The following statement contains a magic number: switch (preset) {  case 0:  	result = "<not stored>";  	usePresetGuess = UsePresetGuess.UseGuess;  	break;  case 410:  	result = "V9";  	break;  case 420:  	result = "V8";  	break;  case 430:  	result = "V7";  	break;  case 440:  	result = "V6";  	break;  case 450:  	result = "V5";  	break;  case 460:  	result = "V4: preset medium";  	break;  case 470:  	result = "V3";  	break;  case 480:  	result = "V2: preset standard";  	break;  case 490:  	result = "V1";  	break;  case 500:  	result = "V0: preset extreme";  	break;  case 1000:  	result = "r3mix";  	break;  case 1001:  	result = "--alt-preset standard";  	break;  case 1002:  	result = "--alt-preset extreme";  	break;  case 1003:  	result = "--alt-preset insane";  	break;  case 1004:  	result = "--alt-preset fast standard";  	break;  case 1005:  	result = "--alt-preset fast extreme";  	break;  case 1006:  	result = "preset medium";  	break;  case 1007:  	result = "preset fast medium";  	break;  case 1010:  	result = "preset portable";  	// only used in alpha versions (3.94 alpha 14 and below)  	break;  case 1015:  	result = "preset radio";  	// only used in alpha versions (3.94 alpha 14 and below)  	break;  default:  	result = string.Format ("<unrecognised value {0}>"' preset);  	usePresetGuess = UsePresetGuess.UseGuess;  	break;  }  
Magic Number,IdSharp.AudioInfo.Inspection,DescriptiveLameTagReader,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\DescriptiveLameTagReader.cs,DeterminePreset,The following statement contains a magic number: switch (preset) {  case 0:  	result = "<not stored>";  	usePresetGuess = UsePresetGuess.UseGuess;  	break;  case 410:  	result = "V9";  	break;  case 420:  	result = "V8";  	break;  case 430:  	result = "V7";  	break;  case 440:  	result = "V6";  	break;  case 450:  	result = "V5";  	break;  case 460:  	result = "V4: preset medium";  	break;  case 470:  	result = "V3";  	break;  case 480:  	result = "V2: preset standard";  	break;  case 490:  	result = "V1";  	break;  case 500:  	result = "V0: preset extreme";  	break;  case 1000:  	result = "r3mix";  	break;  case 1001:  	result = "--alt-preset standard";  	break;  case 1002:  	result = "--alt-preset extreme";  	break;  case 1003:  	result = "--alt-preset insane";  	break;  case 1004:  	result = "--alt-preset fast standard";  	break;  case 1005:  	result = "--alt-preset fast extreme";  	break;  case 1006:  	result = "preset medium";  	break;  case 1007:  	result = "preset fast medium";  	break;  case 1010:  	result = "preset portable";  	// only used in alpha versions (3.94 alpha 14 and below)  	break;  case 1015:  	result = "preset radio";  	// only used in alpha versions (3.94 alpha 14 and below)  	break;  default:  	result = string.Format ("<unrecognised value {0}>"' preset);  	usePresetGuess = UsePresetGuess.UseGuess;  	break;  }  
Magic Number,IdSharp.AudioInfo.Inspection,DescriptiveLameTagReader,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\DescriptiveLameTagReader.cs,DeterminePreset,The following statement contains a magic number: switch (preset) {  case 0:  	result = "<not stored>";  	usePresetGuess = UsePresetGuess.UseGuess;  	break;  case 410:  	result = "V9";  	break;  case 420:  	result = "V8";  	break;  case 430:  	result = "V7";  	break;  case 440:  	result = "V6";  	break;  case 450:  	result = "V5";  	break;  case 460:  	result = "V4: preset medium";  	break;  case 470:  	result = "V3";  	break;  case 480:  	result = "V2: preset standard";  	break;  case 490:  	result = "V1";  	break;  case 500:  	result = "V0: preset extreme";  	break;  case 1000:  	result = "r3mix";  	break;  case 1001:  	result = "--alt-preset standard";  	break;  case 1002:  	result = "--alt-preset extreme";  	break;  case 1003:  	result = "--alt-preset insane";  	break;  case 1004:  	result = "--alt-preset fast standard";  	break;  case 1005:  	result = "--alt-preset fast extreme";  	break;  case 1006:  	result = "preset medium";  	break;  case 1007:  	result = "preset fast medium";  	break;  case 1010:  	result = "preset portable";  	// only used in alpha versions (3.94 alpha 14 and below)  	break;  case 1015:  	result = "preset radio";  	// only used in alpha versions (3.94 alpha 14 and below)  	break;  default:  	result = string.Format ("<unrecognised value {0}>"' preset);  	usePresetGuess = UsePresetGuess.UseGuess;  	break;  }  
Magic Number,IdSharp.AudioInfo.Inspection,DescriptiveLameTagReader,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\DescriptiveLameTagReader.cs,DeterminePreset,The following statement contains a magic number: switch (preset) {  case 0:  	result = "<not stored>";  	usePresetGuess = UsePresetGuess.UseGuess;  	break;  case 410:  	result = "V9";  	break;  case 420:  	result = "V8";  	break;  case 430:  	result = "V7";  	break;  case 440:  	result = "V6";  	break;  case 450:  	result = "V5";  	break;  case 460:  	result = "V4: preset medium";  	break;  case 470:  	result = "V3";  	break;  case 480:  	result = "V2: preset standard";  	break;  case 490:  	result = "V1";  	break;  case 500:  	result = "V0: preset extreme";  	break;  case 1000:  	result = "r3mix";  	break;  case 1001:  	result = "--alt-preset standard";  	break;  case 1002:  	result = "--alt-preset extreme";  	break;  case 1003:  	result = "--alt-preset insane";  	break;  case 1004:  	result = "--alt-preset fast standard";  	break;  case 1005:  	result = "--alt-preset fast extreme";  	break;  case 1006:  	result = "preset medium";  	break;  case 1007:  	result = "preset fast medium";  	break;  case 1010:  	result = "preset portable";  	// only used in alpha versions (3.94 alpha 14 and below)  	break;  case 1015:  	result = "preset radio";  	// only used in alpha versions (3.94 alpha 14 and below)  	break;  default:  	result = string.Format ("<unrecognised value {0}>"' preset);  	usePresetGuess = UsePresetGuess.UseGuess;  	break;  }  
Magic Number,IdSharp.AudioInfo.Inspection,DescriptiveLameTagReader,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\DescriptiveLameTagReader.cs,DeterminePreset,The following statement contains a magic number: switch (preset) {  case 0:  	result = "<not stored>";  	usePresetGuess = UsePresetGuess.UseGuess;  	break;  case 410:  	result = "V9";  	break;  case 420:  	result = "V8";  	break;  case 430:  	result = "V7";  	break;  case 440:  	result = "V6";  	break;  case 450:  	result = "V5";  	break;  case 460:  	result = "V4: preset medium";  	break;  case 470:  	result = "V3";  	break;  case 480:  	result = "V2: preset standard";  	break;  case 490:  	result = "V1";  	break;  case 500:  	result = "V0: preset extreme";  	break;  case 1000:  	result = "r3mix";  	break;  case 1001:  	result = "--alt-preset standard";  	break;  case 1002:  	result = "--alt-preset extreme";  	break;  case 1003:  	result = "--alt-preset insane";  	break;  case 1004:  	result = "--alt-preset fast standard";  	break;  case 1005:  	result = "--alt-preset fast extreme";  	break;  case 1006:  	result = "preset medium";  	break;  case 1007:  	result = "preset fast medium";  	break;  case 1010:  	result = "preset portable";  	// only used in alpha versions (3.94 alpha 14 and below)  	break;  case 1015:  	result = "preset radio";  	// only used in alpha versions (3.94 alpha 14 and below)  	break;  default:  	result = string.Format ("<unrecognised value {0}>"' preset);  	usePresetGuess = UsePresetGuess.UseGuess;  	break;  }  
Magic Number,IdSharp.AudioInfo.Inspection,DescriptiveLameTagReader,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\DescriptiveLameTagReader.cs,DeterminePreset,The following statement contains a magic number: switch (preset) {  case 0:  	result = "<not stored>";  	usePresetGuess = UsePresetGuess.UseGuess;  	break;  case 410:  	result = "V9";  	break;  case 420:  	result = "V8";  	break;  case 430:  	result = "V7";  	break;  case 440:  	result = "V6";  	break;  case 450:  	result = "V5";  	break;  case 460:  	result = "V4: preset medium";  	break;  case 470:  	result = "V3";  	break;  case 480:  	result = "V2: preset standard";  	break;  case 490:  	result = "V1";  	break;  case 500:  	result = "V0: preset extreme";  	break;  case 1000:  	result = "r3mix";  	break;  case 1001:  	result = "--alt-preset standard";  	break;  case 1002:  	result = "--alt-preset extreme";  	break;  case 1003:  	result = "--alt-preset insane";  	break;  case 1004:  	result = "--alt-preset fast standard";  	break;  case 1005:  	result = "--alt-preset fast extreme";  	break;  case 1006:  	result = "preset medium";  	break;  case 1007:  	result = "preset fast medium";  	break;  case 1010:  	result = "preset portable";  	// only used in alpha versions (3.94 alpha 14 and below)  	break;  case 1015:  	result = "preset radio";  	// only used in alpha versions (3.94 alpha 14 and below)  	break;  default:  	result = string.Format ("<unrecognised value {0}>"' preset);  	usePresetGuess = UsePresetGuess.UseGuess;  	break;  }  
Magic Number,IdSharp.AudioInfo.Inspection,DescriptiveLameTagReader,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\DescriptiveLameTagReader.cs,DeterminePreset,The following statement contains a magic number: switch (preset) {  case 0:  	result = "<not stored>";  	usePresetGuess = UsePresetGuess.UseGuess;  	break;  case 410:  	result = "V9";  	break;  case 420:  	result = "V8";  	break;  case 430:  	result = "V7";  	break;  case 440:  	result = "V6";  	break;  case 450:  	result = "V5";  	break;  case 460:  	result = "V4: preset medium";  	break;  case 470:  	result = "V3";  	break;  case 480:  	result = "V2: preset standard";  	break;  case 490:  	result = "V1";  	break;  case 500:  	result = "V0: preset extreme";  	break;  case 1000:  	result = "r3mix";  	break;  case 1001:  	result = "--alt-preset standard";  	break;  case 1002:  	result = "--alt-preset extreme";  	break;  case 1003:  	result = "--alt-preset insane";  	break;  case 1004:  	result = "--alt-preset fast standard";  	break;  case 1005:  	result = "--alt-preset fast extreme";  	break;  case 1006:  	result = "preset medium";  	break;  case 1007:  	result = "preset fast medium";  	break;  case 1010:  	result = "preset portable";  	// only used in alpha versions (3.94 alpha 14 and below)  	break;  case 1015:  	result = "preset radio";  	// only used in alpha versions (3.94 alpha 14 and below)  	break;  default:  	result = string.Format ("<unrecognised value {0}>"' preset);  	usePresetGuess = UsePresetGuess.UseGuess;  	break;  }  
Magic Number,IdSharp.AudioInfo.Inspection,DescriptiveLameTagReader,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\DescriptiveLameTagReader.cs,DeterminePreset,The following statement contains a magic number: switch (preset) {  case 0:  	result = "<not stored>";  	usePresetGuess = UsePresetGuess.UseGuess;  	break;  case 410:  	result = "V9";  	break;  case 420:  	result = "V8";  	break;  case 430:  	result = "V7";  	break;  case 440:  	result = "V6";  	break;  case 450:  	result = "V5";  	break;  case 460:  	result = "V4: preset medium";  	break;  case 470:  	result = "V3";  	break;  case 480:  	result = "V2: preset standard";  	break;  case 490:  	result = "V1";  	break;  case 500:  	result = "V0: preset extreme";  	break;  case 1000:  	result = "r3mix";  	break;  case 1001:  	result = "--alt-preset standard";  	break;  case 1002:  	result = "--alt-preset extreme";  	break;  case 1003:  	result = "--alt-preset insane";  	break;  case 1004:  	result = "--alt-preset fast standard";  	break;  case 1005:  	result = "--alt-preset fast extreme";  	break;  case 1006:  	result = "preset medium";  	break;  case 1007:  	result = "preset fast medium";  	break;  case 1010:  	result = "preset portable";  	// only used in alpha versions (3.94 alpha 14 and below)  	break;  case 1015:  	result = "preset radio";  	// only used in alpha versions (3.94 alpha 14 and below)  	break;  default:  	result = string.Format ("<unrecognised value {0}>"' preset);  	usePresetGuess = UsePresetGuess.UseGuess;  	break;  }  
Magic Number,IdSharp.AudioInfo.Inspection,DescriptiveLameTagReader,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\DescriptiveLameTagReader.cs,DeterminePreset,The following statement contains a magic number: switch (preset) {  case 0:  	result = "<not stored>";  	usePresetGuess = UsePresetGuess.UseGuess;  	break;  case 410:  	result = "V9";  	break;  case 420:  	result = "V8";  	break;  case 430:  	result = "V7";  	break;  case 440:  	result = "V6";  	break;  case 450:  	result = "V5";  	break;  case 460:  	result = "V4: preset medium";  	break;  case 470:  	result = "V3";  	break;  case 480:  	result = "V2: preset standard";  	break;  case 490:  	result = "V1";  	break;  case 500:  	result = "V0: preset extreme";  	break;  case 1000:  	result = "r3mix";  	break;  case 1001:  	result = "--alt-preset standard";  	break;  case 1002:  	result = "--alt-preset extreme";  	break;  case 1003:  	result = "--alt-preset insane";  	break;  case 1004:  	result = "--alt-preset fast standard";  	break;  case 1005:  	result = "--alt-preset fast extreme";  	break;  case 1006:  	result = "preset medium";  	break;  case 1007:  	result = "preset fast medium";  	break;  case 1010:  	result = "preset portable";  	// only used in alpha versions (3.94 alpha 14 and below)  	break;  case 1015:  	result = "preset radio";  	// only used in alpha versions (3.94 alpha 14 and below)  	break;  default:  	result = string.Format ("<unrecognised value {0}>"' preset);  	usePresetGuess = UsePresetGuess.UseGuess;  	break;  }  
Magic Number,IdSharp.AudioInfo.Inspection,DescriptiveLameTagReader,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\DescriptiveLameTagReader.cs,DeterminePreset,The following statement contains a magic number: switch (preset) {  case 0:  	result = "<not stored>";  	usePresetGuess = UsePresetGuess.UseGuess;  	break;  case 410:  	result = "V9";  	break;  case 420:  	result = "V8";  	break;  case 430:  	result = "V7";  	break;  case 440:  	result = "V6";  	break;  case 450:  	result = "V5";  	break;  case 460:  	result = "V4: preset medium";  	break;  case 470:  	result = "V3";  	break;  case 480:  	result = "V2: preset standard";  	break;  case 490:  	result = "V1";  	break;  case 500:  	result = "V0: preset extreme";  	break;  case 1000:  	result = "r3mix";  	break;  case 1001:  	result = "--alt-preset standard";  	break;  case 1002:  	result = "--alt-preset extreme";  	break;  case 1003:  	result = "--alt-preset insane";  	break;  case 1004:  	result = "--alt-preset fast standard";  	break;  case 1005:  	result = "--alt-preset fast extreme";  	break;  case 1006:  	result = "preset medium";  	break;  case 1007:  	result = "preset fast medium";  	break;  case 1010:  	result = "preset portable";  	// only used in alpha versions (3.94 alpha 14 and below)  	break;  case 1015:  	result = "preset radio";  	// only used in alpha versions (3.94 alpha 14 and below)  	break;  default:  	result = string.Format ("<unrecognised value {0}>"' preset);  	usePresetGuess = UsePresetGuess.UseGuess;  	break;  }  
Magic Number,IdSharp.AudioInfo.Inspection,DescriptiveLameTagReader,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\DescriptiveLameTagReader.cs,DeterminePreset,The following statement contains a magic number: switch (preset) {  case 0:  	result = "<not stored>";  	usePresetGuess = UsePresetGuess.UseGuess;  	break;  case 410:  	result = "V9";  	break;  case 420:  	result = "V8";  	break;  case 430:  	result = "V7";  	break;  case 440:  	result = "V6";  	break;  case 450:  	result = "V5";  	break;  case 460:  	result = "V4: preset medium";  	break;  case 470:  	result = "V3";  	break;  case 480:  	result = "V2: preset standard";  	break;  case 490:  	result = "V1";  	break;  case 500:  	result = "V0: preset extreme";  	break;  case 1000:  	result = "r3mix";  	break;  case 1001:  	result = "--alt-preset standard";  	break;  case 1002:  	result = "--alt-preset extreme";  	break;  case 1003:  	result = "--alt-preset insane";  	break;  case 1004:  	result = "--alt-preset fast standard";  	break;  case 1005:  	result = "--alt-preset fast extreme";  	break;  case 1006:  	result = "preset medium";  	break;  case 1007:  	result = "preset fast medium";  	break;  case 1010:  	result = "preset portable";  	// only used in alpha versions (3.94 alpha 14 and below)  	break;  case 1015:  	result = "preset radio";  	// only used in alpha versions (3.94 alpha 14 and below)  	break;  default:  	result = string.Format ("<unrecognised value {0}>"' preset);  	usePresetGuess = UsePresetGuess.UseGuess;  	break;  }  
Magic Number,IdSharp.AudioInfo.Inspection,DescriptiveLameTagReader,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\DescriptiveLameTagReader.cs,DeterminePreset,The following statement contains a magic number: switch (preset) {  case 0:  	result = "<not stored>";  	usePresetGuess = UsePresetGuess.UseGuess;  	break;  case 410:  	result = "V9";  	break;  case 420:  	result = "V8";  	break;  case 430:  	result = "V7";  	break;  case 440:  	result = "V6";  	break;  case 450:  	result = "V5";  	break;  case 460:  	result = "V4: preset medium";  	break;  case 470:  	result = "V3";  	break;  case 480:  	result = "V2: preset standard";  	break;  case 490:  	result = "V1";  	break;  case 500:  	result = "V0: preset extreme";  	break;  case 1000:  	result = "r3mix";  	break;  case 1001:  	result = "--alt-preset standard";  	break;  case 1002:  	result = "--alt-preset extreme";  	break;  case 1003:  	result = "--alt-preset insane";  	break;  case 1004:  	result = "--alt-preset fast standard";  	break;  case 1005:  	result = "--alt-preset fast extreme";  	break;  case 1006:  	result = "preset medium";  	break;  case 1007:  	result = "preset fast medium";  	break;  case 1010:  	result = "preset portable";  	// only used in alpha versions (3.94 alpha 14 and below)  	break;  case 1015:  	result = "preset radio";  	// only used in alpha versions (3.94 alpha 14 and below)  	break;  default:  	result = string.Format ("<unrecognised value {0}>"' preset);  	usePresetGuess = UsePresetGuess.UseGuess;  	break;  }  
Magic Number,IdSharp.AudioInfo.Inspection,DescriptiveLameTagReader,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\DescriptiveLameTagReader.cs,DeterminePreset,The following statement contains a magic number: switch (preset) {  case 0:  	result = "<not stored>";  	usePresetGuess = UsePresetGuess.UseGuess;  	break;  case 410:  	result = "V9";  	break;  case 420:  	result = "V8";  	break;  case 430:  	result = "V7";  	break;  case 440:  	result = "V6";  	break;  case 450:  	result = "V5";  	break;  case 460:  	result = "V4: preset medium";  	break;  case 470:  	result = "V3";  	break;  case 480:  	result = "V2: preset standard";  	break;  case 490:  	result = "V1";  	break;  case 500:  	result = "V0: preset extreme";  	break;  case 1000:  	result = "r3mix";  	break;  case 1001:  	result = "--alt-preset standard";  	break;  case 1002:  	result = "--alt-preset extreme";  	break;  case 1003:  	result = "--alt-preset insane";  	break;  case 1004:  	result = "--alt-preset fast standard";  	break;  case 1005:  	result = "--alt-preset fast extreme";  	break;  case 1006:  	result = "preset medium";  	break;  case 1007:  	result = "preset fast medium";  	break;  case 1010:  	result = "preset portable";  	// only used in alpha versions (3.94 alpha 14 and below)  	break;  case 1015:  	result = "preset radio";  	// only used in alpha versions (3.94 alpha 14 and below)  	break;  default:  	result = string.Format ("<unrecognised value {0}>"' preset);  	usePresetGuess = UsePresetGuess.UseGuess;  	break;  }  
Magic Number,IdSharp.AudioInfo.Inspection,DescriptiveLameTagReader,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\DescriptiveLameTagReader.cs,DeterminePreset,The following statement contains a magic number: switch (preset) {  case 0:  	result = "<not stored>";  	usePresetGuess = UsePresetGuess.UseGuess;  	break;  case 410:  	result = "V9";  	break;  case 420:  	result = "V8";  	break;  case 430:  	result = "V7";  	break;  case 440:  	result = "V6";  	break;  case 450:  	result = "V5";  	break;  case 460:  	result = "V4: preset medium";  	break;  case 470:  	result = "V3";  	break;  case 480:  	result = "V2: preset standard";  	break;  case 490:  	result = "V1";  	break;  case 500:  	result = "V0: preset extreme";  	break;  case 1000:  	result = "r3mix";  	break;  case 1001:  	result = "--alt-preset standard";  	break;  case 1002:  	result = "--alt-preset extreme";  	break;  case 1003:  	result = "--alt-preset insane";  	break;  case 1004:  	result = "--alt-preset fast standard";  	break;  case 1005:  	result = "--alt-preset fast extreme";  	break;  case 1006:  	result = "preset medium";  	break;  case 1007:  	result = "preset fast medium";  	break;  case 1010:  	result = "preset portable";  	// only used in alpha versions (3.94 alpha 14 and below)  	break;  case 1015:  	result = "preset radio";  	// only used in alpha versions (3.94 alpha 14 and below)  	break;  default:  	result = string.Format ("<unrecognised value {0}>"' preset);  	usePresetGuess = UsePresetGuess.UseGuess;  	break;  }  
Magic Number,IdSharp.AudioInfo.Inspection,DescriptiveLameTagReader,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\DescriptiveLameTagReader.cs,DeterminePreset,The following statement contains a magic number: switch (preset) {  case 0:  	result = "<not stored>";  	usePresetGuess = UsePresetGuess.UseGuess;  	break;  case 410:  	result = "V9";  	break;  case 420:  	result = "V8";  	break;  case 430:  	result = "V7";  	break;  case 440:  	result = "V6";  	break;  case 450:  	result = "V5";  	break;  case 460:  	result = "V4: preset medium";  	break;  case 470:  	result = "V3";  	break;  case 480:  	result = "V2: preset standard";  	break;  case 490:  	result = "V1";  	break;  case 500:  	result = "V0: preset extreme";  	break;  case 1000:  	result = "r3mix";  	break;  case 1001:  	result = "--alt-preset standard";  	break;  case 1002:  	result = "--alt-preset extreme";  	break;  case 1003:  	result = "--alt-preset insane";  	break;  case 1004:  	result = "--alt-preset fast standard";  	break;  case 1005:  	result = "--alt-preset fast extreme";  	break;  case 1006:  	result = "preset medium";  	break;  case 1007:  	result = "preset fast medium";  	break;  case 1010:  	result = "preset portable";  	// only used in alpha versions (3.94 alpha 14 and below)  	break;  case 1015:  	result = "preset radio";  	// only used in alpha versions (3.94 alpha 14 and below)  	break;  default:  	result = string.Format ("<unrecognised value {0}>"' preset);  	usePresetGuess = UsePresetGuess.UseGuess;  	break;  }  
Magic Number,IdSharp.AudioInfo.Inspection,DescriptiveLameTagReader,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\DescriptiveLameTagReader.cs,DeterminePreset,The following statement contains a magic number: switch (preset) {  case 0:  	result = "<not stored>";  	usePresetGuess = UsePresetGuess.UseGuess;  	break;  case 410:  	result = "V9";  	break;  case 420:  	result = "V8";  	break;  case 430:  	result = "V7";  	break;  case 440:  	result = "V6";  	break;  case 450:  	result = "V5";  	break;  case 460:  	result = "V4: preset medium";  	break;  case 470:  	result = "V3";  	break;  case 480:  	result = "V2: preset standard";  	break;  case 490:  	result = "V1";  	break;  case 500:  	result = "V0: preset extreme";  	break;  case 1000:  	result = "r3mix";  	break;  case 1001:  	result = "--alt-preset standard";  	break;  case 1002:  	result = "--alt-preset extreme";  	break;  case 1003:  	result = "--alt-preset insane";  	break;  case 1004:  	result = "--alt-preset fast standard";  	break;  case 1005:  	result = "--alt-preset fast extreme";  	break;  case 1006:  	result = "preset medium";  	break;  case 1007:  	result = "preset fast medium";  	break;  case 1010:  	result = "preset portable";  	// only used in alpha versions (3.94 alpha 14 and below)  	break;  case 1015:  	result = "preset radio";  	// only used in alpha versions (3.94 alpha 14 and below)  	break;  default:  	result = string.Format ("<unrecognised value {0}>"' preset);  	usePresetGuess = UsePresetGuess.UseGuess;  	break;  }  
Magic Number,IdSharp.AudioInfo.Inspection,DescriptiveLameTagReader,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\DescriptiveLameTagReader.cs,DeterminePreset,The following statement contains a magic number: switch (preset) {  case 0:  	result = "<not stored>";  	usePresetGuess = UsePresetGuess.UseGuess;  	break;  case 410:  	result = "V9";  	break;  case 420:  	result = "V8";  	break;  case 430:  	result = "V7";  	break;  case 440:  	result = "V6";  	break;  case 450:  	result = "V5";  	break;  case 460:  	result = "V4: preset medium";  	break;  case 470:  	result = "V3";  	break;  case 480:  	result = "V2: preset standard";  	break;  case 490:  	result = "V1";  	break;  case 500:  	result = "V0: preset extreme";  	break;  case 1000:  	result = "r3mix";  	break;  case 1001:  	result = "--alt-preset standard";  	break;  case 1002:  	result = "--alt-preset extreme";  	break;  case 1003:  	result = "--alt-preset insane";  	break;  case 1004:  	result = "--alt-preset fast standard";  	break;  case 1005:  	result = "--alt-preset fast extreme";  	break;  case 1006:  	result = "preset medium";  	break;  case 1007:  	result = "preset fast medium";  	break;  case 1010:  	result = "preset portable";  	// only used in alpha versions (3.94 alpha 14 and below)  	break;  case 1015:  	result = "preset radio";  	// only used in alpha versions (3.94 alpha 14 and below)  	break;  default:  	result = string.Format ("<unrecognised value {0}>"' preset);  	usePresetGuess = UsePresetGuess.UseGuess;  	break;  }  
Magic Number,IdSharp.AudioInfo.Inspection,DescriptiveLameTagReader,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\DescriptiveLameTagReader.cs,DeterminePreset,The following statement contains a magic number: switch (preset) {  case 0:  	result = "<not stored>";  	usePresetGuess = UsePresetGuess.UseGuess;  	break;  case 410:  	result = "V9";  	break;  case 420:  	result = "V8";  	break;  case 430:  	result = "V7";  	break;  case 440:  	result = "V6";  	break;  case 450:  	result = "V5";  	break;  case 460:  	result = "V4: preset medium";  	break;  case 470:  	result = "V3";  	break;  case 480:  	result = "V2: preset standard";  	break;  case 490:  	result = "V1";  	break;  case 500:  	result = "V0: preset extreme";  	break;  case 1000:  	result = "r3mix";  	break;  case 1001:  	result = "--alt-preset standard";  	break;  case 1002:  	result = "--alt-preset extreme";  	break;  case 1003:  	result = "--alt-preset insane";  	break;  case 1004:  	result = "--alt-preset fast standard";  	break;  case 1005:  	result = "--alt-preset fast extreme";  	break;  case 1006:  	result = "preset medium";  	break;  case 1007:  	result = "preset fast medium";  	break;  case 1010:  	result = "preset portable";  	// only used in alpha versions (3.94 alpha 14 and below)  	break;  case 1015:  	result = "preset radio";  	// only used in alpha versions (3.94 alpha 14 and below)  	break;  default:  	result = string.Format ("<unrecognised value {0}>"' preset);  	usePresetGuess = UsePresetGuess.UseGuess;  	break;  }  
Magic Number,IdSharp.AudioInfo.Inspection,DescriptiveLameTagReader,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\DescriptiveLameTagReader.cs,DeterminePreset,The following statement contains a magic number: switch (preset) {  case 0:  	result = "<not stored>";  	usePresetGuess = UsePresetGuess.UseGuess;  	break;  case 410:  	result = "V9";  	break;  case 420:  	result = "V8";  	break;  case 430:  	result = "V7";  	break;  case 440:  	result = "V6";  	break;  case 450:  	result = "V5";  	break;  case 460:  	result = "V4: preset medium";  	break;  case 470:  	result = "V3";  	break;  case 480:  	result = "V2: preset standard";  	break;  case 490:  	result = "V1";  	break;  case 500:  	result = "V0: preset extreme";  	break;  case 1000:  	result = "r3mix";  	break;  case 1001:  	result = "--alt-preset standard";  	break;  case 1002:  	result = "--alt-preset extreme";  	break;  case 1003:  	result = "--alt-preset insane";  	break;  case 1004:  	result = "--alt-preset fast standard";  	break;  case 1005:  	result = "--alt-preset fast extreme";  	break;  case 1006:  	result = "preset medium";  	break;  case 1007:  	result = "preset fast medium";  	break;  case 1010:  	result = "preset portable";  	// only used in alpha versions (3.94 alpha 14 and below)  	break;  case 1015:  	result = "preset radio";  	// only used in alpha versions (3.94 alpha 14 and below)  	break;  default:  	result = string.Format ("<unrecognised value {0}>"' preset);  	usePresetGuess = UsePresetGuess.UseGuess;  	break;  }  
Magic Number,IdSharp.AudioInfo.Inspection,DescriptiveLameTagReader,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\DescriptiveLameTagReader.cs,DeterminePreset,The following statement contains a magic number: if (_basicReader.EncodingMethod == 4) {  	if (preset == 410 || preset == 420 || preset == 430 || preset == 440 || preset == 450 || preset == 460 || preset == 470 || preset == 480 || preset == 490 || preset == 500) {  		result += " (fast mode)";  	}  }  
Magic Number,IdSharp.AudioInfo.Inspection,DescriptiveLameTagReader,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\DescriptiveLameTagReader.cs,DeterminePreset,The following statement contains a magic number: if (_basicReader.EncodingMethod == 4) {  	if (preset == 410 || preset == 420 || preset == 430 || preset == 440 || preset == 450 || preset == 460 || preset == 470 || preset == 480 || preset == 490 || preset == 500) {  		result += " (fast mode)";  	}  }  
Magic Number,IdSharp.AudioInfo.Inspection,DescriptiveLameTagReader,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\DescriptiveLameTagReader.cs,DeterminePreset,The following statement contains a magic number: if (_basicReader.EncodingMethod == 4) {  	if (preset == 410 || preset == 420 || preset == 430 || preset == 440 || preset == 450 || preset == 460 || preset == 470 || preset == 480 || preset == 490 || preset == 500) {  		result += " (fast mode)";  	}  }  
Magic Number,IdSharp.AudioInfo.Inspection,DescriptiveLameTagReader,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\DescriptiveLameTagReader.cs,DeterminePreset,The following statement contains a magic number: if (_basicReader.EncodingMethod == 4) {  	if (preset == 410 || preset == 420 || preset == 430 || preset == 440 || preset == 450 || preset == 460 || preset == 470 || preset == 480 || preset == 490 || preset == 500) {  		result += " (fast mode)";  	}  }  
Magic Number,IdSharp.AudioInfo.Inspection,DescriptiveLameTagReader,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\DescriptiveLameTagReader.cs,DeterminePreset,The following statement contains a magic number: if (_basicReader.EncodingMethod == 4) {  	if (preset == 410 || preset == 420 || preset == 430 || preset == 440 || preset == 450 || preset == 460 || preset == 470 || preset == 480 || preset == 490 || preset == 500) {  		result += " (fast mode)";  	}  }  
Magic Number,IdSharp.AudioInfo.Inspection,DescriptiveLameTagReader,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\DescriptiveLameTagReader.cs,DeterminePreset,The following statement contains a magic number: if (_basicReader.EncodingMethod == 4) {  	if (preset == 410 || preset == 420 || preset == 430 || preset == 440 || preset == 450 || preset == 460 || preset == 470 || preset == 480 || preset == 490 || preset == 500) {  		result += " (fast mode)";  	}  }  
Magic Number,IdSharp.AudioInfo.Inspection,DescriptiveLameTagReader,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\DescriptiveLameTagReader.cs,DeterminePreset,The following statement contains a magic number: if (_basicReader.EncodingMethod == 4) {  	if (preset == 410 || preset == 420 || preset == 430 || preset == 440 || preset == 450 || preset == 460 || preset == 470 || preset == 480 || preset == 490 || preset == 500) {  		result += " (fast mode)";  	}  }  
Magic Number,IdSharp.AudioInfo.Inspection,DescriptiveLameTagReader,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\DescriptiveLameTagReader.cs,DeterminePreset,The following statement contains a magic number: if (_basicReader.EncodingMethod == 4) {  	if (preset == 410 || preset == 420 || preset == 430 || preset == 440 || preset == 450 || preset == 460 || preset == 470 || preset == 480 || preset == 490 || preset == 500) {  		result += " (fast mode)";  	}  }  
Magic Number,IdSharp.AudioInfo.Inspection,DescriptiveLameTagReader,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\DescriptiveLameTagReader.cs,DeterminePreset,The following statement contains a magic number: if (_basicReader.EncodingMethod == 4) {  	if (preset == 410 || preset == 420 || preset == 430 || preset == 440 || preset == 450 || preset == 460 || preset == 470 || preset == 480 || preset == 490 || preset == 500) {  		result += " (fast mode)";  	}  }  
Magic Number,IdSharp.AudioInfo.Inspection,DescriptiveLameTagReader,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\DescriptiveLameTagReader.cs,DeterminePreset,The following statement contains a magic number: if (_basicReader.EncodingMethod == 4) {  	if (preset == 410 || preset == 420 || preset == 430 || preset == 440 || preset == 450 || preset == 460 || preset == 470 || preset == 480 || preset == 490 || preset == 500) {  		result += " (fast mode)";  	}  }  
Magic Number,IdSharp.AudioInfo.Inspection,DescriptiveLameTagReader,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\DescriptiveLameTagReader.cs,DeterminePreset,The following statement contains a magic number: if (_basicReader.EncodingMethod == 4) {  	if (preset == 410 || preset == 420 || preset == 430 || preset == 440 || preset == 450 || preset == 460 || preset == 470 || preset == 480 || preset == 490 || preset == 500) {  		result += " (fast mode)";  	}  }  
Magic Number,IdSharp.AudioInfo.Inspection,DescriptiveLameTagReader,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\DescriptiveLameTagReader.cs,DeterminePreset,The following statement contains a magic number: if (preset == 410 || preset == 420 || preset == 430 || preset == 440 || preset == 450 || preset == 460 || preset == 470 || preset == 480 || preset == 490 || preset == 500) {  	result += " (fast mode)";  }  
Magic Number,IdSharp.AudioInfo.Inspection,DescriptiveLameTagReader,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\DescriptiveLameTagReader.cs,DeterminePreset,The following statement contains a magic number: if (preset == 410 || preset == 420 || preset == 430 || preset == 440 || preset == 450 || preset == 460 || preset == 470 || preset == 480 || preset == 490 || preset == 500) {  	result += " (fast mode)";  }  
Magic Number,IdSharp.AudioInfo.Inspection,DescriptiveLameTagReader,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\DescriptiveLameTagReader.cs,DeterminePreset,The following statement contains a magic number: if (preset == 410 || preset == 420 || preset == 430 || preset == 440 || preset == 450 || preset == 460 || preset == 470 || preset == 480 || preset == 490 || preset == 500) {  	result += " (fast mode)";  }  
Magic Number,IdSharp.AudioInfo.Inspection,DescriptiveLameTagReader,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\DescriptiveLameTagReader.cs,DeterminePreset,The following statement contains a magic number: if (preset == 410 || preset == 420 || preset == 430 || preset == 440 || preset == 450 || preset == 460 || preset == 470 || preset == 480 || preset == 490 || preset == 500) {  	result += " (fast mode)";  }  
Magic Number,IdSharp.AudioInfo.Inspection,DescriptiveLameTagReader,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\DescriptiveLameTagReader.cs,DeterminePreset,The following statement contains a magic number: if (preset == 410 || preset == 420 || preset == 430 || preset == 440 || preset == 450 || preset == 460 || preset == 470 || preset == 480 || preset == 490 || preset == 500) {  	result += " (fast mode)";  }  
Magic Number,IdSharp.AudioInfo.Inspection,DescriptiveLameTagReader,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\DescriptiveLameTagReader.cs,DeterminePreset,The following statement contains a magic number: if (preset == 410 || preset == 420 || preset == 430 || preset == 440 || preset == 450 || preset == 460 || preset == 470 || preset == 480 || preset == 490 || preset == 500) {  	result += " (fast mode)";  }  
Magic Number,IdSharp.AudioInfo.Inspection,DescriptiveLameTagReader,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\DescriptiveLameTagReader.cs,DeterminePreset,The following statement contains a magic number: if (preset == 410 || preset == 420 || preset == 430 || preset == 440 || preset == 450 || preset == 460 || preset == 470 || preset == 480 || preset == 490 || preset == 500) {  	result += " (fast mode)";  }  
Magic Number,IdSharp.AudioInfo.Inspection,DescriptiveLameTagReader,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\DescriptiveLameTagReader.cs,DeterminePreset,The following statement contains a magic number: if (preset == 410 || preset == 420 || preset == 430 || preset == 440 || preset == 450 || preset == 460 || preset == 470 || preset == 480 || preset == 490 || preset == 500) {  	result += " (fast mode)";  }  
Magic Number,IdSharp.AudioInfo.Inspection,DescriptiveLameTagReader,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\DescriptiveLameTagReader.cs,DeterminePreset,The following statement contains a magic number: if (preset == 410 || preset == 420 || preset == 430 || preset == 440 || preset == 450 || preset == 460 || preset == 470 || preset == 480 || preset == 490 || preset == 500) {  	result += " (fast mode)";  }  
Magic Number,IdSharp.AudioInfo.Inspection,DescriptiveLameTagReader,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\DescriptiveLameTagReader.cs,DeterminePreset,The following statement contains a magic number: if (preset == 410 || preset == 420 || preset == 430 || preset == 440 || preset == 450 || preset == 460 || preset == 470 || preset == 480 || preset == 490 || preset == 500) {  	result += " (fast mode)";  }  
Magic Number,IdSharp.AudioInfo.Inspection,MpegAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\MpegAudio.cs,MpegAudio,The following statement contains a magic number: using (BinaryReader br = new BinaryReader (File.Open (path' FileMode.Open' FileAccess.Read' FileShare.Read))) {  	int startPos = ID3v2.GetTagSize (br.BaseStream);  	// Get file length  	m_FileLength = br.BaseStream.Length;  	// Seek past ID3v2 tag  	br.BaseStream.Seek (startPos' SeekOrigin.Begin);  	// Read first block of data and search for a frame  	Byte[] data = br.ReadBytes (dataLength);  	FindFrame (data' ref m_VBR);  	m_VendorID = FindVendorID (data);  	// Try to search in the middle of the file if no frame at the beginning found  	if (!m_Frame.Found) {  		br.BaseStream.Seek ((m_FileLength - startPos) / 2' SeekOrigin.Begin);  		data = br.ReadBytes (dataLength);  		FindFrame (data' ref m_VBR);  	}  	// Search for vendor ID at the end if CBR encoded  	if (m_Frame.Found && String.IsNullOrEmpty (m_VendorID)) {  		br.BaseStream.Seek (-(data.Length + ID3v1.GetTagSize (br.BaseStream))' SeekOrigin.End);  		data = br.ReadBytes (dataLength);  		FindFrame (data' ref m_VBR);  		m_VendorID = FindVendorID (data);  	}  }  
Magic Number,IdSharp.AudioInfo.Inspection,MpegAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\MpegAudio.cs,MpegAudio,The following statement contains a magic number: if (!m_Frame.Found) {  	br.BaseStream.Seek ((m_FileLength - startPos) / 2' SeekOrigin.Begin);  	data = br.ReadBytes (dataLength);  	FindFrame (data' ref m_VBR);  }  
Magic Number,IdSharp.AudioInfo.Inspection,MpegAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\MpegAudio.cs,MpegAudio,The following statement contains a magic number: br.BaseStream.Seek ((m_FileLength - startPos) / 2' SeekOrigin.Begin);  
Magic Number,IdSharp.AudioInfo.Inspection,MpegAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\MpegAudio.cs,FindFrame,The following statement contains a magic number: Buffer.BlockCopy (data' 0' headerData' 0' 4);  
Magic Number,IdSharp.AudioInfo.Inspection,MpegAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\MpegAudio.cs,FindFrame,The following statement contains a magic number: for (int i = 0; i < size; i++) {  	// Decode data if frame header found  	if (IsFrameHeader (headerData)) {  		DecodeHeader (headerData);  		int nextHeader = i + GetFrameLength (m_Frame);  		if (nextHeader < size) {  			// Check for next frame and try to find VBR header  			if (ValidFrameAt (nextHeader' data)) {  				m_Frame.Found = true;  				m_Frame.Position = i;  				m_Frame.Size = GetFrameLength (m_Frame);  				m_Frame.Xing = IsXing (i + headerData.Length' data);  				vbrHeader = FindVBR (i + GetVBRFrameOffset (m_Frame)' data);  				break;  			}  		}  	}  	// Prepare next data block  	headerData [0] = headerData [1];  	headerData [1] = headerData [2];  	headerData [2] = headerData [3];  	headerData [3] = data [4 + i];  }  
Magic Number,IdSharp.AudioInfo.Inspection,MpegAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\MpegAudio.cs,FindFrame,The following statement contains a magic number: for (int i = 0; i < size; i++) {  	// Decode data if frame header found  	if (IsFrameHeader (headerData)) {  		DecodeHeader (headerData);  		int nextHeader = i + GetFrameLength (m_Frame);  		if (nextHeader < size) {  			// Check for next frame and try to find VBR header  			if (ValidFrameAt (nextHeader' data)) {  				m_Frame.Found = true;  				m_Frame.Position = i;  				m_Frame.Size = GetFrameLength (m_Frame);  				m_Frame.Xing = IsXing (i + headerData.Length' data);  				vbrHeader = FindVBR (i + GetVBRFrameOffset (m_Frame)' data);  				break;  			}  		}  	}  	// Prepare next data block  	headerData [0] = headerData [1];  	headerData [1] = headerData [2];  	headerData [2] = headerData [3];  	headerData [3] = data [4 + i];  }  
Magic Number,IdSharp.AudioInfo.Inspection,MpegAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\MpegAudio.cs,FindFrame,The following statement contains a magic number: for (int i = 0; i < size; i++) {  	// Decode data if frame header found  	if (IsFrameHeader (headerData)) {  		DecodeHeader (headerData);  		int nextHeader = i + GetFrameLength (m_Frame);  		if (nextHeader < size) {  			// Check for next frame and try to find VBR header  			if (ValidFrameAt (nextHeader' data)) {  				m_Frame.Found = true;  				m_Frame.Position = i;  				m_Frame.Size = GetFrameLength (m_Frame);  				m_Frame.Xing = IsXing (i + headerData.Length' data);  				vbrHeader = FindVBR (i + GetVBRFrameOffset (m_Frame)' data);  				break;  			}  		}  	}  	// Prepare next data block  	headerData [0] = headerData [1];  	headerData [1] = headerData [2];  	headerData [2] = headerData [3];  	headerData [3] = data [4 + i];  }  
Magic Number,IdSharp.AudioInfo.Inspection,MpegAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\MpegAudio.cs,FindFrame,The following statement contains a magic number: for (int i = 0; i < size; i++) {  	// Decode data if frame header found  	if (IsFrameHeader (headerData)) {  		DecodeHeader (headerData);  		int nextHeader = i + GetFrameLength (m_Frame);  		if (nextHeader < size) {  			// Check for next frame and try to find VBR header  			if (ValidFrameAt (nextHeader' data)) {  				m_Frame.Found = true;  				m_Frame.Position = i;  				m_Frame.Size = GetFrameLength (m_Frame);  				m_Frame.Xing = IsXing (i + headerData.Length' data);  				vbrHeader = FindVBR (i + GetVBRFrameOffset (m_Frame)' data);  				break;  			}  		}  	}  	// Prepare next data block  	headerData [0] = headerData [1];  	headerData [1] = headerData [2];  	headerData [2] = headerData [3];  	headerData [3] = data [4 + i];  }  
Magic Number,IdSharp.AudioInfo.Inspection,MpegAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\MpegAudio.cs,FindFrame,The following statement contains a magic number: for (int i = 0; i < size; i++) {  	// Decode data if frame header found  	if (IsFrameHeader (headerData)) {  		DecodeHeader (headerData);  		int nextHeader = i + GetFrameLength (m_Frame);  		if (nextHeader < size) {  			// Check for next frame and try to find VBR header  			if (ValidFrameAt (nextHeader' data)) {  				m_Frame.Found = true;  				m_Frame.Position = i;  				m_Frame.Size = GetFrameLength (m_Frame);  				m_Frame.Xing = IsXing (i + headerData.Length' data);  				vbrHeader = FindVBR (i + GetVBRFrameOffset (m_Frame)' data);  				break;  			}  		}  	}  	// Prepare next data block  	headerData [0] = headerData [1];  	headerData [1] = headerData [2];  	headerData [2] = headerData [3];  	headerData [3] = data [4 + i];  }  
Magic Number,IdSharp.AudioInfo.Inspection,MpegAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\MpegAudio.cs,FindFrame,The following statement contains a magic number: headerData [1] = headerData [2];  
Magic Number,IdSharp.AudioInfo.Inspection,MpegAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\MpegAudio.cs,FindFrame,The following statement contains a magic number: headerData [2] = headerData [3];  
Magic Number,IdSharp.AudioInfo.Inspection,MpegAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\MpegAudio.cs,FindFrame,The following statement contains a magic number: headerData [2] = headerData [3];  
Magic Number,IdSharp.AudioInfo.Inspection,MpegAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\MpegAudio.cs,FindFrame,The following statement contains a magic number: headerData [3] = data [4 + i];  
Magic Number,IdSharp.AudioInfo.Inspection,MpegAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\MpegAudio.cs,FindFrame,The following statement contains a magic number: headerData [3] = data [4 + i];  
Magic Number,IdSharp.AudioInfo.Inspection,MpegAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\MpegAudio.cs,IsFrameHeader,The following statement contains a magic number: if ((headerData [0] & 0xFF) != 0xFF || (headerData [1] & 0xE0) != 0xE0 || ((headerData [1] >> 3) & 3) == 1 || ((headerData [1] >> 1) & 3) == 0 || (headerData [2] & 0xF0) == 0xF0 || (headerData [2] & 0xF0) == 0 || ((headerData [2] >> 2) & 3) == 3 || (headerData [3] & 3) == 2) {  	return false;  } else {  	return true;  }  
Magic Number,IdSharp.AudioInfo.Inspection,MpegAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\MpegAudio.cs,IsFrameHeader,The following statement contains a magic number: if ((headerData [0] & 0xFF) != 0xFF || (headerData [1] & 0xE0) != 0xE0 || ((headerData [1] >> 3) & 3) == 1 || ((headerData [1] >> 1) & 3) == 0 || (headerData [2] & 0xF0) == 0xF0 || (headerData [2] & 0xF0) == 0 || ((headerData [2] >> 2) & 3) == 3 || (headerData [3] & 3) == 2) {  	return false;  } else {  	return true;  }  
Magic Number,IdSharp.AudioInfo.Inspection,MpegAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\MpegAudio.cs,IsFrameHeader,The following statement contains a magic number: if ((headerData [0] & 0xFF) != 0xFF || (headerData [1] & 0xE0) != 0xE0 || ((headerData [1] >> 3) & 3) == 1 || ((headerData [1] >> 1) & 3) == 0 || (headerData [2] & 0xF0) == 0xF0 || (headerData [2] & 0xF0) == 0 || ((headerData [2] >> 2) & 3) == 3 || (headerData [3] & 3) == 2) {  	return false;  } else {  	return true;  }  
Magic Number,IdSharp.AudioInfo.Inspection,MpegAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\MpegAudio.cs,IsFrameHeader,The following statement contains a magic number: if ((headerData [0] & 0xFF) != 0xFF || (headerData [1] & 0xE0) != 0xE0 || ((headerData [1] >> 3) & 3) == 1 || ((headerData [1] >> 1) & 3) == 0 || (headerData [2] & 0xF0) == 0xF0 || (headerData [2] & 0xF0) == 0 || ((headerData [2] >> 2) & 3) == 3 || (headerData [3] & 3) == 2) {  	return false;  } else {  	return true;  }  
Magic Number,IdSharp.AudioInfo.Inspection,MpegAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\MpegAudio.cs,IsFrameHeader,The following statement contains a magic number: if ((headerData [0] & 0xFF) != 0xFF || (headerData [1] & 0xE0) != 0xE0 || ((headerData [1] >> 3) & 3) == 1 || ((headerData [1] >> 1) & 3) == 0 || (headerData [2] & 0xF0) == 0xF0 || (headerData [2] & 0xF0) == 0 || ((headerData [2] >> 2) & 3) == 3 || (headerData [3] & 3) == 2) {  	return false;  } else {  	return true;  }  
Magic Number,IdSharp.AudioInfo.Inspection,MpegAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\MpegAudio.cs,IsFrameHeader,The following statement contains a magic number: if ((headerData [0] & 0xFF) != 0xFF || (headerData [1] & 0xE0) != 0xE0 || ((headerData [1] >> 3) & 3) == 1 || ((headerData [1] >> 1) & 3) == 0 || (headerData [2] & 0xF0) == 0xF0 || (headerData [2] & 0xF0) == 0 || ((headerData [2] >> 2) & 3) == 3 || (headerData [3] & 3) == 2) {  	return false;  } else {  	return true;  }  
Magic Number,IdSharp.AudioInfo.Inspection,MpegAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\MpegAudio.cs,IsFrameHeader,The following statement contains a magic number: if ((headerData [0] & 0xFF) != 0xFF || (headerData [1] & 0xE0) != 0xE0 || ((headerData [1] >> 3) & 3) == 1 || ((headerData [1] >> 1) & 3) == 0 || (headerData [2] & 0xF0) == 0xF0 || (headerData [2] & 0xF0) == 0 || ((headerData [2] >> 2) & 3) == 3 || (headerData [3] & 3) == 2) {  	return false;  } else {  	return true;  }  
Magic Number,IdSharp.AudioInfo.Inspection,MpegAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\MpegAudio.cs,IsFrameHeader,The following statement contains a magic number: if ((headerData [0] & 0xFF) != 0xFF || (headerData [1] & 0xE0) != 0xE0 || ((headerData [1] >> 3) & 3) == 1 || ((headerData [1] >> 1) & 3) == 0 || (headerData [2] & 0xF0) == 0xF0 || (headerData [2] & 0xF0) == 0 || ((headerData [2] >> 2) & 3) == 3 || (headerData [3] & 3) == 2) {  	return false;  } else {  	return true;  }  
Magic Number,IdSharp.AudioInfo.Inspection,MpegAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\MpegAudio.cs,IsFrameHeader,The following statement contains a magic number: if ((headerData [0] & 0xFF) != 0xFF || (headerData [1] & 0xE0) != 0xE0 || ((headerData [1] >> 3) & 3) == 1 || ((headerData [1] >> 1) & 3) == 0 || (headerData [2] & 0xF0) == 0xF0 || (headerData [2] & 0xF0) == 0 || ((headerData [2] >> 2) & 3) == 3 || (headerData [3] & 3) == 2) {  	return false;  } else {  	return true;  }  
Magic Number,IdSharp.AudioInfo.Inspection,MpegAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\MpegAudio.cs,IsFrameHeader,The following statement contains a magic number: if ((headerData [0] & 0xFF) != 0xFF || (headerData [1] & 0xE0) != 0xE0 || ((headerData [1] >> 3) & 3) == 1 || ((headerData [1] >> 1) & 3) == 0 || (headerData [2] & 0xF0) == 0xF0 || (headerData [2] & 0xF0) == 0 || ((headerData [2] >> 2) & 3) == 3 || (headerData [3] & 3) == 2) {  	return false;  } else {  	return true;  }  
Magic Number,IdSharp.AudioInfo.Inspection,MpegAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\MpegAudio.cs,IsFrameHeader,The following statement contains a magic number: if ((headerData [0] & 0xFF) != 0xFF || (headerData [1] & 0xE0) != 0xE0 || ((headerData [1] >> 3) & 3) == 1 || ((headerData [1] >> 1) & 3) == 0 || (headerData [2] & 0xF0) == 0xF0 || (headerData [2] & 0xF0) == 0 || ((headerData [2] >> 2) & 3) == 3 || (headerData [3] & 3) == 2) {  	return false;  } else {  	return true;  }  
Magic Number,IdSharp.AudioInfo.Inspection,MpegAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\MpegAudio.cs,IsFrameHeader,The following statement contains a magic number: if ((headerData [0] & 0xFF) != 0xFF || (headerData [1] & 0xE0) != 0xE0 || ((headerData [1] >> 3) & 3) == 1 || ((headerData [1] >> 1) & 3) == 0 || (headerData [2] & 0xF0) == 0xF0 || (headerData [2] & 0xF0) == 0 || ((headerData [2] >> 2) & 3) == 3 || (headerData [3] & 3) == 2) {  	return false;  } else {  	return true;  }  
Magic Number,IdSharp.AudioInfo.Inspection,MpegAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\MpegAudio.cs,DecodeHeader,The following statement contains a magic number: m_Frame.VersionID = (MpegVersion)((headerData [1] >> 3) & 3);  
Magic Number,IdSharp.AudioInfo.Inspection,MpegAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\MpegAudio.cs,DecodeHeader,The following statement contains a magic number: m_Frame.VersionID = (MpegVersion)((headerData [1] >> 3) & 3);  
Magic Number,IdSharp.AudioInfo.Inspection,MpegAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\MpegAudio.cs,DecodeHeader,The following statement contains a magic number: m_Frame.LayerID = (MpegLayer)((headerData [1] >> 1) & 3);  
Magic Number,IdSharp.AudioInfo.Inspection,MpegAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\MpegAudio.cs,DecodeHeader,The following statement contains a magic number: m_Frame.BitRateID = (Byte)(headerData [2] >> 4);  
Magic Number,IdSharp.AudioInfo.Inspection,MpegAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\MpegAudio.cs,DecodeHeader,The following statement contains a magic number: m_Frame.BitRateID = (Byte)(headerData [2] >> 4);  
Magic Number,IdSharp.AudioInfo.Inspection,MpegAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\MpegAudio.cs,DecodeHeader,The following statement contains a magic number: m_Frame.SampleRateID = (SampleRateLevel)((headerData [2] >> 2) & 3);  
Magic Number,IdSharp.AudioInfo.Inspection,MpegAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\MpegAudio.cs,DecodeHeader,The following statement contains a magic number: m_Frame.SampleRateID = (SampleRateLevel)((headerData [2] >> 2) & 3);  
Magic Number,IdSharp.AudioInfo.Inspection,MpegAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\MpegAudio.cs,DecodeHeader,The following statement contains a magic number: m_Frame.SampleRateID = (SampleRateLevel)((headerData [2] >> 2) & 3);  
Magic Number,IdSharp.AudioInfo.Inspection,MpegAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\MpegAudio.cs,DecodeHeader,The following statement contains a magic number: m_Frame.PaddingBit = ((headerData [2] >> 1) & 1) == 1;  
Magic Number,IdSharp.AudioInfo.Inspection,MpegAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\MpegAudio.cs,DecodeHeader,The following statement contains a magic number: m_Frame.PrivateBit = (headerData [2] & 1) == 1;  
Magic Number,IdSharp.AudioInfo.Inspection,MpegAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\MpegAudio.cs,DecodeHeader,The following statement contains a magic number: m_Frame.ModeID = (MpegChannel)((headerData [3] >> 6) & 3);  
Magic Number,IdSharp.AudioInfo.Inspection,MpegAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\MpegAudio.cs,DecodeHeader,The following statement contains a magic number: m_Frame.ModeID = (MpegChannel)((headerData [3] >> 6) & 3);  
Magic Number,IdSharp.AudioInfo.Inspection,MpegAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\MpegAudio.cs,DecodeHeader,The following statement contains a magic number: m_Frame.ModeID = (MpegChannel)((headerData [3] >> 6) & 3);  
Magic Number,IdSharp.AudioInfo.Inspection,MpegAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\MpegAudio.cs,DecodeHeader,The following statement contains a magic number: m_Frame.ModeExtensionID = (JointStereoExtensionMode)((headerData [3] >> 4) & 3);  
Magic Number,IdSharp.AudioInfo.Inspection,MpegAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\MpegAudio.cs,DecodeHeader,The following statement contains a magic number: m_Frame.ModeExtensionID = (JointStereoExtensionMode)((headerData [3] >> 4) & 3);  
Magic Number,IdSharp.AudioInfo.Inspection,MpegAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\MpegAudio.cs,DecodeHeader,The following statement contains a magic number: m_Frame.ModeExtensionID = (JointStereoExtensionMode)((headerData [3] >> 4) & 3);  
Magic Number,IdSharp.AudioInfo.Inspection,MpegAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\MpegAudio.cs,DecodeHeader,The following statement contains a magic number: m_Frame.CopyrightBit = ((headerData [3] >> 3) & 1) == 1;  
Magic Number,IdSharp.AudioInfo.Inspection,MpegAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\MpegAudio.cs,DecodeHeader,The following statement contains a magic number: m_Frame.CopyrightBit = ((headerData [3] >> 3) & 1) == 1;  
Magic Number,IdSharp.AudioInfo.Inspection,MpegAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\MpegAudio.cs,DecodeHeader,The following statement contains a magic number: m_Frame.OriginalBit = ((headerData [3] >> 2) & 1) == 1;  
Magic Number,IdSharp.AudioInfo.Inspection,MpegAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\MpegAudio.cs,DecodeHeader,The following statement contains a magic number: m_Frame.OriginalBit = ((headerData [3] >> 2) & 1) == 1;  
Magic Number,IdSharp.AudioInfo.Inspection,MpegAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\MpegAudio.cs,DecodeHeader,The following statement contains a magic number: m_Frame.EmphasisID = (Emphasis)(headerData [3] & 3);  
Magic Number,IdSharp.AudioInfo.Inspection,MpegAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\MpegAudio.cs,DecodeHeader,The following statement contains a magic number: m_Frame.EmphasisID = (Emphasis)(headerData [3] & 3);  
Magic Number,IdSharp.AudioInfo.Inspection,MpegAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\MpegAudio.cs,ValidFrameAt,The following statement contains a magic number: HeaderData [2] = data [index + 2];  
Magic Number,IdSharp.AudioInfo.Inspection,MpegAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\MpegAudio.cs,ValidFrameAt,The following statement contains a magic number: HeaderData [2] = data [index + 2];  
Magic Number,IdSharp.AudioInfo.Inspection,MpegAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\MpegAudio.cs,ValidFrameAt,The following statement contains a magic number: HeaderData [3] = data [index + 3];  
Magic Number,IdSharp.AudioInfo.Inspection,MpegAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\MpegAudio.cs,ValidFrameAt,The following statement contains a magic number: HeaderData [3] = data [index + 3];  
Magic Number,IdSharp.AudioInfo.Inspection,MpegAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\MpegAudio.cs,GetVBRFrameOffset,The following statement contains a magic number: if (Frame.VersionID == MpegVersion.Version1) {  	if (Frame.ModeID != MpegChannel.Mono)  		result = 36;  	else  		result = 21;  } else {  	if (Frame.ModeID != MpegChannel.Mono)  		result = 21;  	else  		result = 13;  }  
Magic Number,IdSharp.AudioInfo.Inspection,MpegAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\MpegAudio.cs,GetVBRFrameOffset,The following statement contains a magic number: if (Frame.VersionID == MpegVersion.Version1) {  	if (Frame.ModeID != MpegChannel.Mono)  		result = 36;  	else  		result = 21;  } else {  	if (Frame.ModeID != MpegChannel.Mono)  		result = 21;  	else  		result = 13;  }  
Magic Number,IdSharp.AudioInfo.Inspection,MpegAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\MpegAudio.cs,GetVBRFrameOffset,The following statement contains a magic number: if (Frame.VersionID == MpegVersion.Version1) {  	if (Frame.ModeID != MpegChannel.Mono)  		result = 36;  	else  		result = 21;  } else {  	if (Frame.ModeID != MpegChannel.Mono)  		result = 21;  	else  		result = 13;  }  
Magic Number,IdSharp.AudioInfo.Inspection,MpegAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\MpegAudio.cs,GetVBRFrameOffset,The following statement contains a magic number: if (Frame.VersionID == MpegVersion.Version1) {  	if (Frame.ModeID != MpegChannel.Mono)  		result = 36;  	else  		result = 21;  } else {  	if (Frame.ModeID != MpegChannel.Mono)  		result = 21;  	else  		result = 13;  }  
Magic Number,IdSharp.AudioInfo.Inspection,MpegAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\MpegAudio.cs,GetVBRFrameOffset,The following statement contains a magic number: if (Frame.ModeID != MpegChannel.Mono)  	result = 36;  else  	result = 21;  
Magic Number,IdSharp.AudioInfo.Inspection,MpegAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\MpegAudio.cs,GetVBRFrameOffset,The following statement contains a magic number: if (Frame.ModeID != MpegChannel.Mono)  	result = 36;  else  	result = 21;  
Magic Number,IdSharp.AudioInfo.Inspection,MpegAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\MpegAudio.cs,GetVBRFrameOffset,The following statement contains a magic number: result = 36;  
Magic Number,IdSharp.AudioInfo.Inspection,MpegAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\MpegAudio.cs,GetVBRFrameOffset,The following statement contains a magic number: result = 21;  
Magic Number,IdSharp.AudioInfo.Inspection,MpegAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\MpegAudio.cs,GetVBRFrameOffset,The following statement contains a magic number: if (Frame.ModeID != MpegChannel.Mono)  	result = 21;  else  	result = 13;  
Magic Number,IdSharp.AudioInfo.Inspection,MpegAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\MpegAudio.cs,GetVBRFrameOffset,The following statement contains a magic number: if (Frame.ModeID != MpegChannel.Mono)  	result = 21;  else  	result = 13;  
Magic Number,IdSharp.AudioInfo.Inspection,MpegAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\MpegAudio.cs,GetVBRFrameOffset,The following statement contains a magic number: result = 21;  
Magic Number,IdSharp.AudioInfo.Inspection,MpegAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\MpegAudio.cs,GetVBRFrameOffset,The following statement contains a magic number: result = 13;  
Magic Number,IdSharp.AudioInfo.Inspection,MpegAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\MpegAudio.cs,GetCoefficient,The following statement contains a magic number: if (Frame.VersionID == MpegVersion.Version1) {  	if (Frame.LayerID == MpegLayer.LayerI)  		result = 48;  	else  		result = 144;  } else {  	if (Frame.LayerID == MpegLayer.LayerI)  		result = 24;  	else if (Frame.LayerID == MpegLayer.LayerII)  		result = 144;  	else  		result = 72;  }  
Magic Number,IdSharp.AudioInfo.Inspection,MpegAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\MpegAudio.cs,GetCoefficient,The following statement contains a magic number: if (Frame.VersionID == MpegVersion.Version1) {  	if (Frame.LayerID == MpegLayer.LayerI)  		result = 48;  	else  		result = 144;  } else {  	if (Frame.LayerID == MpegLayer.LayerI)  		result = 24;  	else if (Frame.LayerID == MpegLayer.LayerII)  		result = 144;  	else  		result = 72;  }  
Magic Number,IdSharp.AudioInfo.Inspection,MpegAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\MpegAudio.cs,GetCoefficient,The following statement contains a magic number: if (Frame.VersionID == MpegVersion.Version1) {  	if (Frame.LayerID == MpegLayer.LayerI)  		result = 48;  	else  		result = 144;  } else {  	if (Frame.LayerID == MpegLayer.LayerI)  		result = 24;  	else if (Frame.LayerID == MpegLayer.LayerII)  		result = 144;  	else  		result = 72;  }  
Magic Number,IdSharp.AudioInfo.Inspection,MpegAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\MpegAudio.cs,GetCoefficient,The following statement contains a magic number: if (Frame.VersionID == MpegVersion.Version1) {  	if (Frame.LayerID == MpegLayer.LayerI)  		result = 48;  	else  		result = 144;  } else {  	if (Frame.LayerID == MpegLayer.LayerI)  		result = 24;  	else if (Frame.LayerID == MpegLayer.LayerII)  		result = 144;  	else  		result = 72;  }  
Magic Number,IdSharp.AudioInfo.Inspection,MpegAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\MpegAudio.cs,GetCoefficient,The following statement contains a magic number: if (Frame.VersionID == MpegVersion.Version1) {  	if (Frame.LayerID == MpegLayer.LayerI)  		result = 48;  	else  		result = 144;  } else {  	if (Frame.LayerID == MpegLayer.LayerI)  		result = 24;  	else if (Frame.LayerID == MpegLayer.LayerII)  		result = 144;  	else  		result = 72;  }  
Magic Number,IdSharp.AudioInfo.Inspection,MpegAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\MpegAudio.cs,GetCoefficient,The following statement contains a magic number: if (Frame.LayerID == MpegLayer.LayerI)  	result = 48;  else  	result = 144;  
Magic Number,IdSharp.AudioInfo.Inspection,MpegAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\MpegAudio.cs,GetCoefficient,The following statement contains a magic number: if (Frame.LayerID == MpegLayer.LayerI)  	result = 48;  else  	result = 144;  
Magic Number,IdSharp.AudioInfo.Inspection,MpegAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\MpegAudio.cs,GetCoefficient,The following statement contains a magic number: result = 48;  
Magic Number,IdSharp.AudioInfo.Inspection,MpegAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\MpegAudio.cs,GetCoefficient,The following statement contains a magic number: result = 144;  
Magic Number,IdSharp.AudioInfo.Inspection,MpegAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\MpegAudio.cs,GetCoefficient,The following statement contains a magic number: if (Frame.LayerID == MpegLayer.LayerI)  	result = 24;  else if (Frame.LayerID == MpegLayer.LayerII)  	result = 144;  else  	result = 72;  
Magic Number,IdSharp.AudioInfo.Inspection,MpegAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\MpegAudio.cs,GetCoefficient,The following statement contains a magic number: if (Frame.LayerID == MpegLayer.LayerI)  	result = 24;  else if (Frame.LayerID == MpegLayer.LayerII)  	result = 144;  else  	result = 72;  
Magic Number,IdSharp.AudioInfo.Inspection,MpegAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\MpegAudio.cs,GetCoefficient,The following statement contains a magic number: if (Frame.LayerID == MpegLayer.LayerI)  	result = 24;  else if (Frame.LayerID == MpegLayer.LayerII)  	result = 144;  else  	result = 72;  
Magic Number,IdSharp.AudioInfo.Inspection,MpegAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\MpegAudio.cs,GetCoefficient,The following statement contains a magic number: result = 24;  
Magic Number,IdSharp.AudioInfo.Inspection,MpegAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\MpegAudio.cs,GetCoefficient,The following statement contains a magic number: if (Frame.LayerID == MpegLayer.LayerII)  	result = 144;  else  	result = 72;  
Magic Number,IdSharp.AudioInfo.Inspection,MpegAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\MpegAudio.cs,GetCoefficient,The following statement contains a magic number: if (Frame.LayerID == MpegLayer.LayerII)  	result = 144;  else  	result = 72;  
Magic Number,IdSharp.AudioInfo.Inspection,MpegAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\MpegAudio.cs,GetCoefficient,The following statement contains a magic number: result = 144;  
Magic Number,IdSharp.AudioInfo.Inspection,MpegAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\MpegAudio.cs,GetCoefficient,The following statement contains a magic number: result = 72;  
Magic Number,IdSharp.AudioInfo.Inspection,MpegAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\MpegAudio.cs,GetPadding,The following statement contains a magic number: if (Frame.PaddingBit) {  	if (Frame.LayerID == MpegLayer.LayerI)  		result = 4;  	else  		result = 1;  } else {  	result = 0;  }  
Magic Number,IdSharp.AudioInfo.Inspection,MpegAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\MpegAudio.cs,GetPadding,The following statement contains a magic number: if (Frame.LayerID == MpegLayer.LayerI)  	result = 4;  else  	result = 1;  
Magic Number,IdSharp.AudioInfo.Inspection,MpegAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\MpegAudio.cs,GetPadding,The following statement contains a magic number: result = 4;  
Magic Number,IdSharp.AudioInfo.Inspection,MpegAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\MpegAudio.cs,GetXingInfo,The following statement contains a magic number: result.Frames = data [index + 8] * 0x1000000 + data [index + 9] * 0x10000 + data [index + 10] * 0x100 + data [index + 11];  
Magic Number,IdSharp.AudioInfo.Inspection,MpegAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\MpegAudio.cs,GetXingInfo,The following statement contains a magic number: result.Frames = data [index + 8] * 0x1000000 + data [index + 9] * 0x10000 + data [index + 10] * 0x100 + data [index + 11];  
Magic Number,IdSharp.AudioInfo.Inspection,MpegAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\MpegAudio.cs,GetXingInfo,The following statement contains a magic number: result.Frames = data [index + 8] * 0x1000000 + data [index + 9] * 0x10000 + data [index + 10] * 0x100 + data [index + 11];  
Magic Number,IdSharp.AudioInfo.Inspection,MpegAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\MpegAudio.cs,GetXingInfo,The following statement contains a magic number: result.Frames = data [index + 8] * 0x1000000 + data [index + 9] * 0x10000 + data [index + 10] * 0x100 + data [index + 11];  
Magic Number,IdSharp.AudioInfo.Inspection,MpegAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\MpegAudio.cs,GetXingInfo,The following statement contains a magic number: result.Bytes = data [index + 12] * 0x1000000 + data [index + 13] * 0x10000 + data [index + 14] * 0x100 + data [index + 15];  
Magic Number,IdSharp.AudioInfo.Inspection,MpegAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\MpegAudio.cs,GetXingInfo,The following statement contains a magic number: result.Bytes = data [index + 12] * 0x1000000 + data [index + 13] * 0x10000 + data [index + 14] * 0x100 + data [index + 15];  
Magic Number,IdSharp.AudioInfo.Inspection,MpegAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\MpegAudio.cs,GetXingInfo,The following statement contains a magic number: result.Bytes = data [index + 12] * 0x1000000 + data [index + 13] * 0x10000 + data [index + 14] * 0x100 + data [index + 15];  
Magic Number,IdSharp.AudioInfo.Inspection,MpegAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\MpegAudio.cs,GetXingInfo,The following statement contains a magic number: result.Bytes = data [index + 12] * 0x1000000 + data [index + 13] * 0x10000 + data [index + 14] * 0x100 + data [index + 15];  
Magic Number,IdSharp.AudioInfo.Inspection,MpegAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\MpegAudio.cs,GetXingInfo,The following statement contains a magic number: result.Scale = data [index + 119];  
Magic Number,IdSharp.AudioInfo.Inspection,MpegAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\MpegAudio.cs,GetXingInfo,The following statement contains a magic number: result.VendorID = String.Format ("{0}{1}{2}{3}{4}{5}{6}{7}"' (Char)data [index + 120]' (Char)data [index + 121]' (Char)data [index + 122]' (Char)data [index + 123]' (Char)data [index + 124]' (Char)data [index + 125]' (Char)data [index + 126]' (Char)data [index + 127]);  
Magic Number,IdSharp.AudioInfo.Inspection,MpegAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\MpegAudio.cs,GetXingInfo,The following statement contains a magic number: result.VendorID = String.Format ("{0}{1}{2}{3}{4}{5}{6}{7}"' (Char)data [index + 120]' (Char)data [index + 121]' (Char)data [index + 122]' (Char)data [index + 123]' (Char)data [index + 124]' (Char)data [index + 125]' (Char)data [index + 126]' (Char)data [index + 127]);  
Magic Number,IdSharp.AudioInfo.Inspection,MpegAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\MpegAudio.cs,GetXingInfo,The following statement contains a magic number: result.VendorID = String.Format ("{0}{1}{2}{3}{4}{5}{6}{7}"' (Char)data [index + 120]' (Char)data [index + 121]' (Char)data [index + 122]' (Char)data [index + 123]' (Char)data [index + 124]' (Char)data [index + 125]' (Char)data [index + 126]' (Char)data [index + 127]);  
Magic Number,IdSharp.AudioInfo.Inspection,MpegAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\MpegAudio.cs,GetXingInfo,The following statement contains a magic number: result.VendorID = String.Format ("{0}{1}{2}{3}{4}{5}{6}{7}"' (Char)data [index + 120]' (Char)data [index + 121]' (Char)data [index + 122]' (Char)data [index + 123]' (Char)data [index + 124]' (Char)data [index + 125]' (Char)data [index + 126]' (Char)data [index + 127]);  
Magic Number,IdSharp.AudioInfo.Inspection,MpegAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\MpegAudio.cs,GetXingInfo,The following statement contains a magic number: result.VendorID = String.Format ("{0}{1}{2}{3}{4}{5}{6}{7}"' (Char)data [index + 120]' (Char)data [index + 121]' (Char)data [index + 122]' (Char)data [index + 123]' (Char)data [index + 124]' (Char)data [index + 125]' (Char)data [index + 126]' (Char)data [index + 127]);  
Magic Number,IdSharp.AudioInfo.Inspection,MpegAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\MpegAudio.cs,GetXingInfo,The following statement contains a magic number: result.VendorID = String.Format ("{0}{1}{2}{3}{4}{5}{6}{7}"' (Char)data [index + 120]' (Char)data [index + 121]' (Char)data [index + 122]' (Char)data [index + 123]' (Char)data [index + 124]' (Char)data [index + 125]' (Char)data [index + 126]' (Char)data [index + 127]);  
Magic Number,IdSharp.AudioInfo.Inspection,MpegAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\MpegAudio.cs,GetXingInfo,The following statement contains a magic number: result.VendorID = String.Format ("{0}{1}{2}{3}{4}{5}{6}{7}"' (Char)data [index + 120]' (Char)data [index + 121]' (Char)data [index + 122]' (Char)data [index + 123]' (Char)data [index + 124]' (Char)data [index + 125]' (Char)data [index + 126]' (Char)data [index + 127]);  
Magic Number,IdSharp.AudioInfo.Inspection,MpegAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\MpegAudio.cs,GetXingInfo,The following statement contains a magic number: result.VendorID = String.Format ("{0}{1}{2}{3}{4}{5}{6}{7}"' (Char)data [index + 120]' (Char)data [index + 121]' (Char)data [index + 122]' (Char)data [index + 123]' (Char)data [index + 124]' (Char)data [index + 125]' (Char)data [index + 126]' (Char)data [index + 127]);  
Magic Number,IdSharp.AudioInfo.Inspection,MpegAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\MpegAudio.cs,GetFhGInfo,The following statement contains a magic number: result.Scale = data [index + 9];  
Magic Number,IdSharp.AudioInfo.Inspection,MpegAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\MpegAudio.cs,GetFhGInfo,The following statement contains a magic number: result.Bytes = data [index + 10] * 0x1000000 + data [index + 11] * 0x10000 + data [index + 12] * 0x100 + data [index + 13];  
Magic Number,IdSharp.AudioInfo.Inspection,MpegAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\MpegAudio.cs,GetFhGInfo,The following statement contains a magic number: result.Bytes = data [index + 10] * 0x1000000 + data [index + 11] * 0x10000 + data [index + 12] * 0x100 + data [index + 13];  
Magic Number,IdSharp.AudioInfo.Inspection,MpegAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\MpegAudio.cs,GetFhGInfo,The following statement contains a magic number: result.Bytes = data [index + 10] * 0x1000000 + data [index + 11] * 0x10000 + data [index + 12] * 0x100 + data [index + 13];  
Magic Number,IdSharp.AudioInfo.Inspection,MpegAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\MpegAudio.cs,GetFhGInfo,The following statement contains a magic number: result.Bytes = data [index + 10] * 0x1000000 + data [index + 11] * 0x10000 + data [index + 12] * 0x100 + data [index + 13];  
Magic Number,IdSharp.AudioInfo.Inspection,MpegAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\MpegAudio.cs,GetFhGInfo,The following statement contains a magic number: result.Frames = data [index + 14] * 0x1000000 + data [index + 15] * 0x10000 + data [index + 16] * 0x100 + data [index + 17];  
Magic Number,IdSharp.AudioInfo.Inspection,MpegAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\MpegAudio.cs,GetFhGInfo,The following statement contains a magic number: result.Frames = data [index + 14] * 0x1000000 + data [index + 15] * 0x10000 + data [index + 16] * 0x100 + data [index + 17];  
Magic Number,IdSharp.AudioInfo.Inspection,MpegAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\MpegAudio.cs,GetFhGInfo,The following statement contains a magic number: result.Frames = data [index + 14] * 0x1000000 + data [index + 15] * 0x10000 + data [index + 16] * 0x100 + data [index + 17];  
Magic Number,IdSharp.AudioInfo.Inspection,MpegAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\MpegAudio.cs,GetFhGInfo,The following statement contains a magic number: result.Frames = data [index + 14] * 0x1000000 + data [index + 15] * 0x10000 + data [index + 16] * 0x100 + data [index + 17];  
Magic Number,IdSharp.AudioInfo.Inspection,MpegAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\MpegAudio.cs,FindVendorID,The following statement contains a magic number: for (int i = 0; i <= size - 8; i++) {  	String VendorID = String.Format ("{0}{1}{2}{3}"' (Char)data [size - i - 8]' (Char)data [size - i - 7]' (Char)data [size - i - 6]' (Char)data [size - i - 5]);  	if (VendorID == VBRVendorID.LAME) {  		result = VendorID + String.Format ("{0}{1}{2}{3}"' (Char)data [size - i - 4]' (Char)data [size - i - 3]' (Char)data [size - i - 2]' (Char)data [size - i - 1]);  		break;  	}  	if (VendorID == VBRVendorID.GoGoNew) {  		result = VendorID;  		break;  	}  }  
Magic Number,IdSharp.AudioInfo.Inspection,MpegAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\MpegAudio.cs,FindVendorID,The following statement contains a magic number: for (int i = 0; i <= size - 8; i++) {  	String VendorID = String.Format ("{0}{1}{2}{3}"' (Char)data [size - i - 8]' (Char)data [size - i - 7]' (Char)data [size - i - 6]' (Char)data [size - i - 5]);  	if (VendorID == VBRVendorID.LAME) {  		result = VendorID + String.Format ("{0}{1}{2}{3}"' (Char)data [size - i - 4]' (Char)data [size - i - 3]' (Char)data [size - i - 2]' (Char)data [size - i - 1]);  		break;  	}  	if (VendorID == VBRVendorID.GoGoNew) {  		result = VendorID;  		break;  	}  }  
Magic Number,IdSharp.AudioInfo.Inspection,MpegAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\MpegAudio.cs,FindVendorID,The following statement contains a magic number: for (int i = 0; i <= size - 8; i++) {  	String VendorID = String.Format ("{0}{1}{2}{3}"' (Char)data [size - i - 8]' (Char)data [size - i - 7]' (Char)data [size - i - 6]' (Char)data [size - i - 5]);  	if (VendorID == VBRVendorID.LAME) {  		result = VendorID + String.Format ("{0}{1}{2}{3}"' (Char)data [size - i - 4]' (Char)data [size - i - 3]' (Char)data [size - i - 2]' (Char)data [size - i - 1]);  		break;  	}  	if (VendorID == VBRVendorID.GoGoNew) {  		result = VendorID;  		break;  	}  }  
Magic Number,IdSharp.AudioInfo.Inspection,MpegAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\MpegAudio.cs,FindVendorID,The following statement contains a magic number: for (int i = 0; i <= size - 8; i++) {  	String VendorID = String.Format ("{0}{1}{2}{3}"' (Char)data [size - i - 8]' (Char)data [size - i - 7]' (Char)data [size - i - 6]' (Char)data [size - i - 5]);  	if (VendorID == VBRVendorID.LAME) {  		result = VendorID + String.Format ("{0}{1}{2}{3}"' (Char)data [size - i - 4]' (Char)data [size - i - 3]' (Char)data [size - i - 2]' (Char)data [size - i - 1]);  		break;  	}  	if (VendorID == VBRVendorID.GoGoNew) {  		result = VendorID;  		break;  	}  }  
Magic Number,IdSharp.AudioInfo.Inspection,MpegAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\MpegAudio.cs,FindVendorID,The following statement contains a magic number: for (int i = 0; i <= size - 8; i++) {  	String VendorID = String.Format ("{0}{1}{2}{3}"' (Char)data [size - i - 8]' (Char)data [size - i - 7]' (Char)data [size - i - 6]' (Char)data [size - i - 5]);  	if (VendorID == VBRVendorID.LAME) {  		result = VendorID + String.Format ("{0}{1}{2}{3}"' (Char)data [size - i - 4]' (Char)data [size - i - 3]' (Char)data [size - i - 2]' (Char)data [size - i - 1]);  		break;  	}  	if (VendorID == VBRVendorID.GoGoNew) {  		result = VendorID;  		break;  	}  }  
Magic Number,IdSharp.AudioInfo.Inspection,MpegAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\MpegAudio.cs,FindVendorID,The following statement contains a magic number: for (int i = 0; i <= size - 8; i++) {  	String VendorID = String.Format ("{0}{1}{2}{3}"' (Char)data [size - i - 8]' (Char)data [size - i - 7]' (Char)data [size - i - 6]' (Char)data [size - i - 5]);  	if (VendorID == VBRVendorID.LAME) {  		result = VendorID + String.Format ("{0}{1}{2}{3}"' (Char)data [size - i - 4]' (Char)data [size - i - 3]' (Char)data [size - i - 2]' (Char)data [size - i - 1]);  		break;  	}  	if (VendorID == VBRVendorID.GoGoNew) {  		result = VendorID;  		break;  	}  }  
Magic Number,IdSharp.AudioInfo.Inspection,MpegAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\MpegAudio.cs,FindVendorID,The following statement contains a magic number: for (int i = 0; i <= size - 8; i++) {  	String VendorID = String.Format ("{0}{1}{2}{3}"' (Char)data [size - i - 8]' (Char)data [size - i - 7]' (Char)data [size - i - 6]' (Char)data [size - i - 5]);  	if (VendorID == VBRVendorID.LAME) {  		result = VendorID + String.Format ("{0}{1}{2}{3}"' (Char)data [size - i - 4]' (Char)data [size - i - 3]' (Char)data [size - i - 2]' (Char)data [size - i - 1]);  		break;  	}  	if (VendorID == VBRVendorID.GoGoNew) {  		result = VendorID;  		break;  	}  }  
Magic Number,IdSharp.AudioInfo.Inspection,MpegAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\MpegAudio.cs,FindVendorID,The following statement contains a magic number: for (int i = 0; i <= size - 8; i++) {  	String VendorID = String.Format ("{0}{1}{2}{3}"' (Char)data [size - i - 8]' (Char)data [size - i - 7]' (Char)data [size - i - 6]' (Char)data [size - i - 5]);  	if (VendorID == VBRVendorID.LAME) {  		result = VendorID + String.Format ("{0}{1}{2}{3}"' (Char)data [size - i - 4]' (Char)data [size - i - 3]' (Char)data [size - i - 2]' (Char)data [size - i - 1]);  		break;  	}  	if (VendorID == VBRVendorID.GoGoNew) {  		result = VendorID;  		break;  	}  }  
Magic Number,IdSharp.AudioInfo.Inspection,MpegAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\MpegAudio.cs,FindVendorID,The following statement contains a magic number: if (VendorID == VBRVendorID.LAME) {  	result = VendorID + String.Format ("{0}{1}{2}{3}"' (Char)data [size - i - 4]' (Char)data [size - i - 3]' (Char)data [size - i - 2]' (Char)data [size - i - 1]);  	break;  }  
Magic Number,IdSharp.AudioInfo.Inspection,MpegAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\MpegAudio.cs,FindVendorID,The following statement contains a magic number: if (VendorID == VBRVendorID.LAME) {  	result = VendorID + String.Format ("{0}{1}{2}{3}"' (Char)data [size - i - 4]' (Char)data [size - i - 3]' (Char)data [size - i - 2]' (Char)data [size - i - 1]);  	break;  }  
Magic Number,IdSharp.AudioInfo.Inspection,MpegAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\MpegAudio.cs,FindVendorID,The following statement contains a magic number: if (VendorID == VBRVendorID.LAME) {  	result = VendorID + String.Format ("{0}{1}{2}{3}"' (Char)data [size - i - 4]' (Char)data [size - i - 3]' (Char)data [size - i - 2]' (Char)data [size - i - 1]);  	break;  }  
Magic Number,IdSharp.AudioInfo.Inspection,MpegAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\MpegAudio.cs,FindVendorID,The following statement contains a magic number: result = VendorID + String.Format ("{0}{1}{2}{3}"' (Char)data [size - i - 4]' (Char)data [size - i - 3]' (Char)data [size - i - 2]' (Char)data [size - i - 1]);  
Magic Number,IdSharp.AudioInfo.Inspection,MpegAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\MpegAudio.cs,FindVendorID,The following statement contains a magic number: result = VendorID + String.Format ("{0}{1}{2}{3}"' (Char)data [size - i - 4]' (Char)data [size - i - 3]' (Char)data [size - i - 2]' (Char)data [size - i - 1]);  
Magic Number,IdSharp.AudioInfo.Inspection,MpegAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\MpegAudio.cs,FindVendorID,The following statement contains a magic number: result = VendorID + String.Format ("{0}{1}{2}{3}"' (Char)data [size - i - 4]' (Char)data [size - i - 3]' (Char)data [size - i - 2]' (Char)data [size - i - 1]);  
Magic Number,IdSharp.AudioInfo.Inspection,MpegAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\MpegAudio.cs,GetCBREncoderID,The following statement contains a magic number: if (!String.IsNullOrEmpty (m_VendorID) && m_VendorID.Length >= 4) {  	shortVendor = m_VendorID.Substring (0' 4);  } else {  	shortVendor = "";  }  
Magic Number,IdSharp.AudioInfo.Inspection,MpegAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\MpegAudio.cs,GetCBREncoderID,The following statement contains a magic number: if (!String.IsNullOrEmpty (m_VendorID) && m_VendorID.Length >= 4) {  	shortVendor = m_VendorID.Substring (0' 4);  } else {  	shortVendor = "";  }  
Magic Number,IdSharp.AudioInfo.Inspection,MpegAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\MpegAudio.cs,GetCBREncoderID,The following statement contains a magic number: shortVendor = m_VendorID.Substring (0' 4);  
Magic Number,IdSharp.AudioInfo.Inspection,MpegAudio,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\MpegAudio.cs,GetCBREncoderID,The following statement contains a magic number: if (GetBitRate (m_Frame) <= 160 && m_Frame.ModeID == MpegChannel.Stereo)  	result = MpegEncoder.Blade;  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg390_3901_392' 255' 58' 1' 1' 3' 2' 205' LamePreset.Insane));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg390_3901_392' 255' 58' 1' 1' 3' 2' 205' LamePreset.Insane));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg390_3901_392' 255' 58' 1' 1' 3' 2' 205' LamePreset.Insane));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg390_3901_392' 255' 58' 1' 1' 3' 2' 205' LamePreset.Insane));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg390_3901_392' 255' 58' 1' 1' 3' 2' 205' LamePreset.Insane));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg3902_391' LameVersionGroup.lvg3931_3903up' 255' 58' 1' 1' 3' 2' 206' LamePreset.Insane));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg3902_391' LameVersionGroup.lvg3931_3903up' 255' 58' 1' 1' 3' 2' 206' LamePreset.Insane));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg3902_391' LameVersionGroup.lvg3931_3903up' 255' 58' 1' 1' 3' 2' 206' LamePreset.Insane));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg3902_391' LameVersionGroup.lvg3931_3903up' 255' 58' 1' 1' 3' 2' 206' LamePreset.Insane));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg3902_391' LameVersionGroup.lvg3931_3903up' 255' 58' 1' 1' 3' 2' 206' LamePreset.Insane));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg394up' 255' 57' 1' 1' 3' 4' 205' LamePreset.Insane));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg394up' 255' 57' 1' 1' 3' 4' 205' LamePreset.Insane));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg394up' 255' 57' 1' 1' 3' 4' 205' LamePreset.Insane));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg394up' 255' 57' 1' 1' 3' 4' 205' LamePreset.Insane));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg394up' 255' 57' 1' 1' 3' 4' 205' LamePreset.Insane));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg390_3901_392' 0' 78' 3' 2' 3' 2' 195' LamePreset.Extreme));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg390_3901_392' 0' 78' 3' 2' 3' 2' 195' LamePreset.Extreme));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg390_3901_392' 0' 78' 3' 2' 3' 2' 195' LamePreset.Extreme));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg390_3901_392' 0' 78' 3' 2' 3' 2' 195' LamePreset.Extreme));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg390_3901_392' 0' 78' 3' 2' 3' 2' 195' LamePreset.Extreme));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg390_3901_392' 0' 78' 3' 2' 3' 2' 195' LamePreset.Extreme));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg3902_391' 0' 78' 3' 2' 3' 2' 196' LamePreset.Extreme));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg3902_391' 0' 78' 3' 2' 3' 2' 196' LamePreset.Extreme));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg3902_391' 0' 78' 3' 2' 3' 2' 196' LamePreset.Extreme));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg3902_391' 0' 78' 3' 2' 3' 2' 196' LamePreset.Extreme));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg3902_391' 0' 78' 3' 2' 3' 2' 196' LamePreset.Extreme));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg3902_391' 0' 78' 3' 2' 3' 2' 196' LamePreset.Extreme));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg3931_3903up' 0' 78' 3' 1' 3' 2' 196' LamePreset.Extreme));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg3931_3903up' 0' 78' 3' 1' 3' 2' 196' LamePreset.Extreme));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg3931_3903up' 0' 78' 3' 1' 3' 2' 196' LamePreset.Extreme));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg3931_3903up' 0' 78' 3' 1' 3' 2' 196' LamePreset.Extreme));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg3931_3903up' 0' 78' 3' 1' 3' 2' 196' LamePreset.Extreme));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg390_3901_392' 0' 78' 4' 2' 3' 2' 195' LamePreset.FastExtreme));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg390_3901_392' 0' 78' 4' 2' 3' 2' 195' LamePreset.FastExtreme));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg390_3901_392' 0' 78' 4' 2' 3' 2' 195' LamePreset.FastExtreme));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg390_3901_392' 0' 78' 4' 2' 3' 2' 195' LamePreset.FastExtreme));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg390_3901_392' 0' 78' 4' 2' 3' 2' 195' LamePreset.FastExtreme));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg390_3901_392' 0' 78' 4' 2' 3' 2' 195' LamePreset.FastExtreme));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg3902_391' LameVersionGroup.lvg3931_3903up' 0' 78' 4' 2' 3' 2' 196' LamePreset.FastExtreme));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg3902_391' LameVersionGroup.lvg3931_3903up' 0' 78' 4' 2' 3' 2' 196' LamePreset.FastExtreme));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg3902_391' LameVersionGroup.lvg3931_3903up' 0' 78' 4' 2' 3' 2' 196' LamePreset.FastExtreme));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg3902_391' LameVersionGroup.lvg3931_3903up' 0' 78' 4' 2' 3' 2' 196' LamePreset.FastExtreme));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg3902_391' LameVersionGroup.lvg3931_3903up' 0' 78' 4' 2' 3' 2' 196' LamePreset.FastExtreme));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg3902_391' LameVersionGroup.lvg3931_3903up' 0' 78' 4' 2' 3' 2' 196' LamePreset.FastExtreme));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg390_3901_392' LameVersionGroup.lvg3902_391' 0' 78' 3' 2' 3' 4' 190' LamePreset.Standard));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg390_3901_392' LameVersionGroup.lvg3902_391' 0' 78' 3' 2' 3' 4' 190' LamePreset.Standard));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg390_3901_392' LameVersionGroup.lvg3902_391' 0' 78' 3' 2' 3' 4' 190' LamePreset.Standard));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg390_3901_392' LameVersionGroup.lvg3902_391' 0' 78' 3' 2' 3' 4' 190' LamePreset.Standard));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg390_3901_392' LameVersionGroup.lvg3902_391' 0' 78' 3' 2' 3' 4' 190' LamePreset.Standard));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg390_3901_392' LameVersionGroup.lvg3902_391' 0' 78' 3' 2' 3' 4' 190' LamePreset.Standard));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg3931_3903up' 0' 78' 3' 1' 3' 4' 190' LamePreset.Standard));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg3931_3903up' 0' 78' 3' 1' 3' 4' 190' LamePreset.Standard));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg3931_3903up' 0' 78' 3' 1' 3' 4' 190' LamePreset.Standard));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg3931_3903up' 0' 78' 3' 1' 3' 4' 190' LamePreset.Standard));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg3931_3903up' 0' 78' 3' 1' 3' 4' 190' LamePreset.Standard));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg390_3901_392' LameVersionGroup.lvg3902_391' LameVersionGroup.lvg3931_3903up' 0' 78' 4' 2' 3' 4' 190' LamePreset.FastStandard));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg390_3901_392' LameVersionGroup.lvg3902_391' LameVersionGroup.lvg3931_3903up' 0' 78' 4' 2' 3' 4' 190' LamePreset.FastStandard));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg390_3901_392' LameVersionGroup.lvg3902_391' LameVersionGroup.lvg3931_3903up' 0' 78' 4' 2' 3' 4' 190' LamePreset.FastStandard));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg390_3901_392' LameVersionGroup.lvg3902_391' LameVersionGroup.lvg3931_3903up' 0' 78' 4' 2' 3' 4' 190' LamePreset.FastStandard));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg390_3901_392' LameVersionGroup.lvg3902_391' LameVersionGroup.lvg3931_3903up' 0' 78' 4' 2' 3' 4' 190' LamePreset.FastStandard));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg390_3901_392' LameVersionGroup.lvg3902_391' LameVersionGroup.lvg3931_3903up' 0' 78' 4' 2' 3' 4' 190' LamePreset.FastStandard));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg3931_3903up' 0' 68' 3' 2' 3' 4' 180' LamePreset.Medium));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg3931_3903up' 0' 68' 3' 2' 3' 4' 180' LamePreset.Medium));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg3931_3903up' 0' 68' 3' 2' 3' 4' 180' LamePreset.Medium));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg3931_3903up' 0' 68' 3' 2' 3' 4' 180' LamePreset.Medium));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg3931_3903up' 0' 68' 3' 2' 3' 4' 180' LamePreset.Medium));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg3931_3903up' 0' 68' 3' 2' 3' 4' 180' LamePreset.Medium));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg3931_3903up' 0' 68' 4' 2' 3' 4' 180' LamePreset.FastMedium));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg3931_3903up' 0' 68' 4' 2' 3' 4' 180' LamePreset.FastMedium));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg3931_3903up' 0' 68' 4' 2' 3' 4' 180' LamePreset.FastMedium));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg3931_3903up' 0' 68' 4' 2' 3' 4' 180' LamePreset.FastMedium));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg3931_3903up' 0' 68' 4' 2' 3' 4' 180' LamePreset.FastMedium));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg3931_3903up' 0' 68' 4' 2' 3' 4' 180' LamePreset.FastMedium));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg390_3901_392' 0' 88' 4' 1' 3' 3' 195' LamePreset.R3mix));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg390_3901_392' 0' 88' 4' 1' 3' 3' 195' LamePreset.R3mix));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg390_3901_392' 0' 88' 4' 1' 3' 3' 195' LamePreset.R3mix));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg390_3901_392' 0' 88' 4' 1' 3' 3' 195' LamePreset.R3mix));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg390_3901_392' 0' 88' 4' 1' 3' 3' 195' LamePreset.R3mix));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg3902_391' LameVersionGroup.lvg3931_3903up' 0' 88' 4' 1' 3' 3' 196' LamePreset.R3mix));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg3902_391' LameVersionGroup.lvg3931_3903up' 0' 88' 4' 1' 3' 3' 196' LamePreset.R3mix));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg3902_391' LameVersionGroup.lvg3931_3903up' 0' 88' 4' 1' 3' 3' 196' LamePreset.R3mix));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg3902_391' LameVersionGroup.lvg3931_3903up' 0' 88' 4' 1' 3' 3' 196' LamePreset.R3mix));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg3902_391' LameVersionGroup.lvg3931_3903up' 0' 88' 4' 1' 3' 3' 196' LamePreset.R3mix));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg390_3901_392' LameVersionGroup.lvg3902_391' 255' 99' 1' 1' 1' 2' 0' LamePreset.Studio));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg390_3901_392' LameVersionGroup.lvg3902_391' 255' 99' 1' 1' 1' 2' 0' LamePreset.Studio));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg390_3901_392' LameVersionGroup.lvg3902_391' 255' 99' 1' 1' 1' 2' 0' LamePreset.Studio));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg3931_3903up' 255' 58' 2' 1' 3' 2' 206' LamePreset.Studio));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg3931_3903up' 255' 58' 2' 1' 3' 2' 206' LamePreset.Studio));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg3931_3903up' 255' 58' 2' 1' 3' 2' 206' LamePreset.Studio));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg3931_3903up' 255' 58' 2' 1' 3' 2' 206' LamePreset.Studio));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg3931_3903up' 255' 58' 2' 1' 3' 2' 206' LamePreset.Studio));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg3931_3903up' 255' 58' 2' 1' 3' 2' 206' LamePreset.Studio));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg393' 255' 58' 2' 1' 3' 2' 205' LamePreset.Studio));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg393' 255' 58' 2' 1' 3' 2' 205' LamePreset.Studio));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg393' 255' 58' 2' 1' 3' 2' 205' LamePreset.Studio));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg393' 255' 58' 2' 1' 3' 2' 205' LamePreset.Studio));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg393' 255' 58' 2' 1' 3' 2' 205' LamePreset.Studio));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg393' 255' 58' 2' 1' 3' 2' 205' LamePreset.Studio));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg394up' 255' 57' 2' 1' 3' 4' 205' LamePreset.Studio));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg394up' 255' 57' 2' 1' 3' 4' 205' LamePreset.Studio));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg394up' 255' 57' 2' 1' 3' 4' 205' LamePreset.Studio));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg394up' 255' 57' 2' 1' 3' 4' 205' LamePreset.Studio));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg394up' 255' 57' 2' 1' 3' 4' 205' LamePreset.Studio));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg394up' 255' 57' 2' 1' 3' 4' 205' LamePreset.Studio));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg390_3901_392' LameVersionGroup.lvg3902_391' 192' 88' 1' 1' 1' 2' 0' LamePreset.CD));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg390_3901_392' LameVersionGroup.lvg3902_391' 192' 88' 1' 1' 1' 2' 0' LamePreset.CD));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg390_3901_392' LameVersionGroup.lvg3902_391' 192' 88' 1' 1' 1' 2' 0' LamePreset.CD));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg3931_3903up' 192' 58' 2' 2' 3' 2' 196' LamePreset.CD));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg3931_3903up' 192' 58' 2' 2' 3' 2' 196' LamePreset.CD));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg3931_3903up' 192' 58' 2' 2' 3' 2' 196' LamePreset.CD));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg3931_3903up' 192' 58' 2' 2' 3' 2' 196' LamePreset.CD));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg3931_3903up' 192' 58' 2' 2' 3' 2' 196' LamePreset.CD));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg3931_3903up' 192' 58' 2' 2' 3' 2' 196' LamePreset.CD));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg3931_3903up' 192' 58' 2' 2' 3' 2' 196' LamePreset.CD));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg393' 192' 58' 2' 2' 3' 2' 195' LamePreset.CD));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg393' 192' 58' 2' 2' 3' 2' 195' LamePreset.CD));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg393' 192' 58' 2' 2' 3' 2' 195' LamePreset.CD));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg393' 192' 58' 2' 2' 3' 2' 195' LamePreset.CD));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg393' 192' 58' 2' 2' 3' 2' 195' LamePreset.CD));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg393' 192' 58' 2' 2' 3' 2' 195' LamePreset.CD));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg393' 192' 58' 2' 2' 3' 2' 195' LamePreset.CD));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg394up' 192' 57' 2' 1' 3' 4' 195' LamePreset.CD));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg394up' 192' 57' 2' 1' 3' 4' 195' LamePreset.CD));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg394up' 192' 57' 2' 1' 3' 4' 195' LamePreset.CD));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg394up' 192' 57' 2' 1' 3' 4' 195' LamePreset.CD));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg394up' 192' 57' 2' 1' 3' 4' 195' LamePreset.CD));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg394up' 192' 57' 2' 1' 3' 4' 195' LamePreset.CD));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg390_3901_392' LameVersionGroup.lvg3902_391' 160' 78' 1' 1' 3' 2' 180' LamePreset.Hifi));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg390_3901_392' LameVersionGroup.lvg3902_391' 160' 78' 1' 1' 3' 2' 180' LamePreset.Hifi));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg390_3901_392' LameVersionGroup.lvg3902_391' 160' 78' 1' 1' 3' 2' 180' LamePreset.Hifi));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg390_3901_392' LameVersionGroup.lvg3902_391' 160' 78' 1' 1' 3' 2' 180' LamePreset.Hifi));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg390_3901_392' LameVersionGroup.lvg3902_391' 160' 78' 1' 1' 3' 2' 180' LamePreset.Hifi));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg393' LameVersionGroup.lvg3931_3903up' 160' 58' 2' 2' 3' 2' 180' LamePreset.Hifi));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg393' LameVersionGroup.lvg3931_3903up' 160' 58' 2' 2' 3' 2' 180' LamePreset.Hifi));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg393' LameVersionGroup.lvg3931_3903up' 160' 58' 2' 2' 3' 2' 180' LamePreset.Hifi));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg393' LameVersionGroup.lvg3931_3903up' 160' 58' 2' 2' 3' 2' 180' LamePreset.Hifi));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg393' LameVersionGroup.lvg3931_3903up' 160' 58' 2' 2' 3' 2' 180' LamePreset.Hifi));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg393' LameVersionGroup.lvg3931_3903up' 160' 58' 2' 2' 3' 2' 180' LamePreset.Hifi));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg393' LameVersionGroup.lvg3931_3903up' 160' 58' 2' 2' 3' 2' 180' LamePreset.Hifi));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg394up' 160' 57' 2' 1' 3' 4' 180' LamePreset.Hifi));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg394up' 160' 57' 2' 1' 3' 4' 180' LamePreset.Hifi));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg394up' 160' 57' 2' 1' 3' 4' 180' LamePreset.Hifi));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg394up' 160' 57' 2' 1' 3' 4' 180' LamePreset.Hifi));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg394up' 160' 57' 2' 1' 3' 4' 180' LamePreset.Hifi));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg394up' 160' 57' 2' 1' 3' 4' 180' LamePreset.Hifi));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg390_3901_392' LameVersionGroup.lvg3902_391' 128' 67' 1' 1' 3' 2' 180' LamePreset.Tape));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg390_3901_392' LameVersionGroup.lvg3902_391' 128' 67' 1' 1' 3' 2' 180' LamePreset.Tape));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg390_3901_392' LameVersionGroup.lvg3902_391' 128' 67' 1' 1' 3' 2' 180' LamePreset.Tape));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg390_3901_392' LameVersionGroup.lvg3902_391' 128' 67' 1' 1' 3' 2' 180' LamePreset.Tape));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg390_3901_392' LameVersionGroup.lvg3902_391' 128' 67' 1' 1' 3' 2' 180' LamePreset.Tape));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg390_3901_392' LameVersionGroup.lvg3902_391' 128' 67' 1' 1' 3' 2' 150' LamePreset.Radio));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg390_3901_392' LameVersionGroup.lvg3902_391' 128' 67' 1' 1' 3' 2' 150' LamePreset.Radio));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg390_3901_392' LameVersionGroup.lvg3902_391' 128' 67' 1' 1' 3' 2' 150' LamePreset.Radio));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg390_3901_392' LameVersionGroup.lvg3902_391' 128' 67' 1' 1' 3' 2' 150' LamePreset.Radio));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg390_3901_392' LameVersionGroup.lvg3902_391' 128' 67' 1' 1' 3' 2' 150' LamePreset.Radio));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg390_3901_392' LameVersionGroup.lvg3902_391' 112' 67' 1' 1' 3' 2' 150' LamePreset.FM));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg390_3901_392' LameVersionGroup.lvg3902_391' 112' 67' 1' 1' 3' 2' 150' LamePreset.FM));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg390_3901_392' LameVersionGroup.lvg3902_391' 112' 67' 1' 1' 3' 2' 150' LamePreset.FM));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg390_3901_392' LameVersionGroup.lvg3902_391' 112' 67' 1' 1' 3' 2' 150' LamePreset.FM));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg390_3901_392' LameVersionGroup.lvg3902_391' 112' 67' 1' 1' 3' 2' 150' LamePreset.FM));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg393' LameVersionGroup.lvg3931_3903up' 112' 58' 2' 2' 3' 2' 160' LamePreset.TapeRadioFM));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg393' LameVersionGroup.lvg3931_3903up' 112' 58' 2' 2' 3' 2' 160' LamePreset.TapeRadioFM));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg393' LameVersionGroup.lvg3931_3903up' 112' 58' 2' 2' 3' 2' 160' LamePreset.TapeRadioFM));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg393' LameVersionGroup.lvg3931_3903up' 112' 58' 2' 2' 3' 2' 160' LamePreset.TapeRadioFM));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg393' LameVersionGroup.lvg3931_3903up' 112' 58' 2' 2' 3' 2' 160' LamePreset.TapeRadioFM));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg393' LameVersionGroup.lvg3931_3903up' 112' 58' 2' 2' 3' 2' 160' LamePreset.TapeRadioFM));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg393' LameVersionGroup.lvg3931_3903up' 112' 58' 2' 2' 3' 2' 160' LamePreset.TapeRadioFM));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg394up' 112' 57' 2' 1' 3' 4' 160' LamePreset.TapeRadioFM));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg394up' 112' 57' 2' 1' 3' 4' 160' LamePreset.TapeRadioFM));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg394up' 112' 57' 2' 1' 3' 4' 160' LamePreset.TapeRadioFM));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg394up' 112' 57' 2' 1' 3' 4' 160' LamePreset.TapeRadioFM));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg394up' 112' 57' 2' 1' 3' 4' 160' LamePreset.TapeRadioFM));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg394up' 112' 57' 2' 1' 3' 4' 160' LamePreset.TapeRadioFM));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg393' LameVersionGroup.lvg3931_3903up' 56' 58' 2' 2' 0' 2' 100' LamePreset.Voice));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg393' LameVersionGroup.lvg3931_3903up' 56' 58' 2' 2' 0' 2' 100' LamePreset.Voice));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg393' LameVersionGroup.lvg3931_3903up' 56' 58' 2' 2' 0' 2' 100' LamePreset.Voice));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg393' LameVersionGroup.lvg3931_3903up' 56' 58' 2' 2' 0' 2' 100' LamePreset.Voice));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg393' LameVersionGroup.lvg3931_3903up' 56' 58' 2' 2' 0' 2' 100' LamePreset.Voice));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg393' LameVersionGroup.lvg3931_3903up' 56' 58' 2' 2' 0' 2' 100' LamePreset.Voice));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg394up' 56' 57' 2' 1' 0' 4' 150' LamePreset.Voice));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg394up' 56' 57' 2' 1' 0' 4' 150' LamePreset.Voice));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg394up' 56' 57' 2' 1' 0' 4' 150' LamePreset.Voice));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg394up' 56' 57' 2' 1' 0' 4' 150' LamePreset.Voice));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg394up' 56' 57' 2' 1' 0' 4' 150' LamePreset.Voice));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg390_3901_392' 40' 65' 1' 1' 0' 2' 75' LamePreset.MWUS));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg390_3901_392' 40' 65' 1' 1' 0' 2' 75' LamePreset.MWUS));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg390_3901_392' 40' 65' 1' 1' 0' 2' 75' LamePreset.MWUS));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg390_3901_392' 40' 65' 1' 1' 0' 2' 75' LamePreset.MWUS));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg3902_391' 40' 65' 1' 1' 0' 2' 76' LamePreset.MWUS));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg3902_391' 40' 65' 1' 1' 0' 2' 76' LamePreset.MWUS));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg3902_391' 40' 65' 1' 1' 0' 2' 76' LamePreset.MWUS));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg3902_391' 40' 65' 1' 1' 0' 2' 76' LamePreset.MWUS));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg393' LameVersionGroup.lvg3931_3903up' 40' 58' 2' 2' 0' 2' 70' LamePreset.MWUS));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg393' LameVersionGroup.lvg3931_3903up' 40' 58' 2' 2' 0' 2' 70' LamePreset.MWUS));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg393' LameVersionGroup.lvg3931_3903up' 40' 58' 2' 2' 0' 2' 70' LamePreset.MWUS));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg393' LameVersionGroup.lvg3931_3903up' 40' 58' 2' 2' 0' 2' 70' LamePreset.MWUS));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg393' LameVersionGroup.lvg3931_3903up' 40' 58' 2' 2' 0' 2' 70' LamePreset.MWUS));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg393' LameVersionGroup.lvg3931_3903up' 40' 58' 2' 2' 0' 2' 70' LamePreset.MWUS));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg394up' 40' 57' 2' 1' 0' 4' 105' LamePreset.MWUS));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg394up' 40' 57' 2' 1' 0' 4' 105' LamePreset.MWUS));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg394up' 40' 57' 2' 1' 0' 4' 105' LamePreset.MWUS));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg394up' 40' 57' 2' 1' 0' 4' 105' LamePreset.MWUS));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg394up' 40' 57' 2' 1' 0' 4' 105' LamePreset.MWUS));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg3931_3903up' 24' 58' 2' 2' 0' 2' 40' LamePreset.MWEU));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg3931_3903up' 24' 58' 2' 2' 0' 2' 40' LamePreset.MWEU));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg3931_3903up' 24' 58' 2' 2' 0' 2' 40' LamePreset.MWEU));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg3931_3903up' 24' 58' 2' 2' 0' 2' 40' LamePreset.MWEU));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg3931_3903up' 24' 58' 2' 2' 0' 2' 40' LamePreset.MWEU));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg3931_3903up' 24' 58' 2' 2' 0' 2' 40' LamePreset.MWEU));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg393' 24' 58' 2' 2' 0' 2' 39' LamePreset.MWEU));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg393' 24' 58' 2' 2' 0' 2' 39' LamePreset.MWEU));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg393' 24' 58' 2' 2' 0' 2' 39' LamePreset.MWEU));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg393' 24' 58' 2' 2' 0' 2' 39' LamePreset.MWEU));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg393' 24' 58' 2' 2' 0' 2' 39' LamePreset.MWEU));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg393' 24' 58' 2' 2' 0' 2' 39' LamePreset.MWEU));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg394up' 24' 57' 2' 1' 0' 4' 59' LamePreset.MWEU));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg394up' 24' 57' 2' 1' 0' 4' 59' LamePreset.MWEU));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg394up' 24' 57' 2' 1' 0' 4' 59' LamePreset.MWEU));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg394up' 24' 57' 2' 1' 0' 4' 59' LamePreset.MWEU));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg394up' 24' 57' 2' 1' 0' 4' 59' LamePreset.MWEU));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg3931_3903up' 16' 58' 2' 2' 0' 2' 38' LamePreset.Phone));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg3931_3903up' 16' 58' 2' 2' 0' 2' 38' LamePreset.Phone));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg3931_3903up' 16' 58' 2' 2' 0' 2' 38' LamePreset.Phone));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg3931_3903up' 16' 58' 2' 2' 0' 2' 38' LamePreset.Phone));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg3931_3903up' 16' 58' 2' 2' 0' 2' 38' LamePreset.Phone));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg3931_3903up' 16' 58' 2' 2' 0' 2' 38' LamePreset.Phone));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg393' 16' 58' 2' 2' 0' 2' 37' LamePreset.Phone));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg393' 16' 58' 2' 2' 0' 2' 37' LamePreset.Phone));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg393' 16' 58' 2' 2' 0' 2' 37' LamePreset.Phone));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg393' 16' 58' 2' 2' 0' 2' 37' LamePreset.Phone));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg393' 16' 58' 2' 2' 0' 2' 37' LamePreset.Phone));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg393' 16' 58' 2' 2' 0' 2' 37' LamePreset.Phone));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg394up' 16' 57' 2' 1' 0' 4' 56' LamePreset.Phone));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg394up' 16' 57' 2' 1' 0' 4' 56' LamePreset.Phone));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg394up' 16' 57' 2' 1' 0' 4' 56' LamePreset.Phone));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg394up' 16' 57' 2' 1' 0' 4' 56' LamePreset.Phone));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,PresetGuesser,The following statement contains a magic number: _presetGuessTable.Add (new PresetGuessRow (LameVersionGroup.lvg394up' 16' 57' 2' 1' 0' 4' 56' LamePreset.Phone));  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,GuessForVersion,The following statement contains a magic number: foreach (PresetGuessRow row in _presetGuessTable) {  	if ((row.HasVersionGroup (AVersionGroup)) && (row.TVs [1] == AQuality) && (row.TVs [2] == AEncodingMethod) && (row.TVs [3] == ANoiseShaping) && (row.TVs [4] == AStereoMode) && (row.TVs [5] == AATHType) && (row.TVs [6] == ALowpassDiv100)) {  		if (row.TVs [0] == ABitrate) {  			Result = row.Res;  			break;  		} // Non-bitrate based guessing is only relevant to the VBR presets.  		else if (AEncodingMethod == 3 || AEncodingMethod == 4) {  			NonBitrateResult = row.Res;  		}  	}  }  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,GuessForVersion,The following statement contains a magic number: foreach (PresetGuessRow row in _presetGuessTable) {  	if ((row.HasVersionGroup (AVersionGroup)) && (row.TVs [1] == AQuality) && (row.TVs [2] == AEncodingMethod) && (row.TVs [3] == ANoiseShaping) && (row.TVs [4] == AStereoMode) && (row.TVs [5] == AATHType) && (row.TVs [6] == ALowpassDiv100)) {  		if (row.TVs [0] == ABitrate) {  			Result = row.Res;  			break;  		} // Non-bitrate based guessing is only relevant to the VBR presets.  		else if (AEncodingMethod == 3 || AEncodingMethod == 4) {  			NonBitrateResult = row.Res;  		}  	}  }  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,GuessForVersion,The following statement contains a magic number: foreach (PresetGuessRow row in _presetGuessTable) {  	if ((row.HasVersionGroup (AVersionGroup)) && (row.TVs [1] == AQuality) && (row.TVs [2] == AEncodingMethod) && (row.TVs [3] == ANoiseShaping) && (row.TVs [4] == AStereoMode) && (row.TVs [5] == AATHType) && (row.TVs [6] == ALowpassDiv100)) {  		if (row.TVs [0] == ABitrate) {  			Result = row.Res;  			break;  		} // Non-bitrate based guessing is only relevant to the VBR presets.  		else if (AEncodingMethod == 3 || AEncodingMethod == 4) {  			NonBitrateResult = row.Res;  		}  	}  }  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,GuessForVersion,The following statement contains a magic number: foreach (PresetGuessRow row in _presetGuessTable) {  	if ((row.HasVersionGroup (AVersionGroup)) && (row.TVs [1] == AQuality) && (row.TVs [2] == AEncodingMethod) && (row.TVs [3] == ANoiseShaping) && (row.TVs [4] == AStereoMode) && (row.TVs [5] == AATHType) && (row.TVs [6] == ALowpassDiv100)) {  		if (row.TVs [0] == ABitrate) {  			Result = row.Res;  			break;  		} // Non-bitrate based guessing is only relevant to the VBR presets.  		else if (AEncodingMethod == 3 || AEncodingMethod == 4) {  			NonBitrateResult = row.Res;  		}  	}  }  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,GuessForVersion,The following statement contains a magic number: foreach (PresetGuessRow row in _presetGuessTable) {  	if ((row.HasVersionGroup (AVersionGroup)) && (row.TVs [1] == AQuality) && (row.TVs [2] == AEncodingMethod) && (row.TVs [3] == ANoiseShaping) && (row.TVs [4] == AStereoMode) && (row.TVs [5] == AATHType) && (row.TVs [6] == ALowpassDiv100)) {  		if (row.TVs [0] == ABitrate) {  			Result = row.Res;  			break;  		} // Non-bitrate based guessing is only relevant to the VBR presets.  		else if (AEncodingMethod == 3 || AEncodingMethod == 4) {  			NonBitrateResult = row.Res;  		}  	}  }  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,GuessForVersion,The following statement contains a magic number: foreach (PresetGuessRow row in _presetGuessTable) {  	if ((row.HasVersionGroup (AVersionGroup)) && (row.TVs [1] == AQuality) && (row.TVs [2] == AEncodingMethod) && (row.TVs [3] == ANoiseShaping) && (row.TVs [4] == AStereoMode) && (row.TVs [5] == AATHType) && (row.TVs [6] == ALowpassDiv100)) {  		if (row.TVs [0] == ABitrate) {  			Result = row.Res;  			break;  		} // Non-bitrate based guessing is only relevant to the VBR presets.  		else if (AEncodingMethod == 3 || AEncodingMethod == 4) {  			NonBitrateResult = row.Res;  		}  	}  }  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,GuessForVersion,The following statement contains a magic number: foreach (PresetGuessRow row in _presetGuessTable) {  	if ((row.HasVersionGroup (AVersionGroup)) && (row.TVs [1] == AQuality) && (row.TVs [2] == AEncodingMethod) && (row.TVs [3] == ANoiseShaping) && (row.TVs [4] == AStereoMode) && (row.TVs [5] == AATHType) && (row.TVs [6] == ALowpassDiv100)) {  		if (row.TVs [0] == ABitrate) {  			Result = row.Res;  			break;  		} // Non-bitrate based guessing is only relevant to the VBR presets.  		else if (AEncodingMethod == 3 || AEncodingMethod == 4) {  			NonBitrateResult = row.Res;  		}  	}  }  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,GuessForVersion,The following statement contains a magic number: if ((row.HasVersionGroup (AVersionGroup)) && (row.TVs [1] == AQuality) && (row.TVs [2] == AEncodingMethod) && (row.TVs [3] == ANoiseShaping) && (row.TVs [4] == AStereoMode) && (row.TVs [5] == AATHType) && (row.TVs [6] == ALowpassDiv100)) {  	if (row.TVs [0] == ABitrate) {  		Result = row.Res;  		break;  	} // Non-bitrate based guessing is only relevant to the VBR presets.  	else if (AEncodingMethod == 3 || AEncodingMethod == 4) {  		NonBitrateResult = row.Res;  	}  }  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,GuessForVersion,The following statement contains a magic number: if ((row.HasVersionGroup (AVersionGroup)) && (row.TVs [1] == AQuality) && (row.TVs [2] == AEncodingMethod) && (row.TVs [3] == ANoiseShaping) && (row.TVs [4] == AStereoMode) && (row.TVs [5] == AATHType) && (row.TVs [6] == ALowpassDiv100)) {  	if (row.TVs [0] == ABitrate) {  		Result = row.Res;  		break;  	} // Non-bitrate based guessing is only relevant to the VBR presets.  	else if (AEncodingMethod == 3 || AEncodingMethod == 4) {  		NonBitrateResult = row.Res;  	}  }  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,GuessForVersion,The following statement contains a magic number: if ((row.HasVersionGroup (AVersionGroup)) && (row.TVs [1] == AQuality) && (row.TVs [2] == AEncodingMethod) && (row.TVs [3] == ANoiseShaping) && (row.TVs [4] == AStereoMode) && (row.TVs [5] == AATHType) && (row.TVs [6] == ALowpassDiv100)) {  	if (row.TVs [0] == ABitrate) {  		Result = row.Res;  		break;  	} // Non-bitrate based guessing is only relevant to the VBR presets.  	else if (AEncodingMethod == 3 || AEncodingMethod == 4) {  		NonBitrateResult = row.Res;  	}  }  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,GuessForVersion,The following statement contains a magic number: if ((row.HasVersionGroup (AVersionGroup)) && (row.TVs [1] == AQuality) && (row.TVs [2] == AEncodingMethod) && (row.TVs [3] == ANoiseShaping) && (row.TVs [4] == AStereoMode) && (row.TVs [5] == AATHType) && (row.TVs [6] == ALowpassDiv100)) {  	if (row.TVs [0] == ABitrate) {  		Result = row.Res;  		break;  	} // Non-bitrate based guessing is only relevant to the VBR presets.  	else if (AEncodingMethod == 3 || AEncodingMethod == 4) {  		NonBitrateResult = row.Res;  	}  }  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,GuessForVersion,The following statement contains a magic number: if ((row.HasVersionGroup (AVersionGroup)) && (row.TVs [1] == AQuality) && (row.TVs [2] == AEncodingMethod) && (row.TVs [3] == ANoiseShaping) && (row.TVs [4] == AStereoMode) && (row.TVs [5] == AATHType) && (row.TVs [6] == ALowpassDiv100)) {  	if (row.TVs [0] == ABitrate) {  		Result = row.Res;  		break;  	} // Non-bitrate based guessing is only relevant to the VBR presets.  	else if (AEncodingMethod == 3 || AEncodingMethod == 4) {  		NonBitrateResult = row.Res;  	}  }  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,GuessForVersion,The following statement contains a magic number: if ((row.HasVersionGroup (AVersionGroup)) && (row.TVs [1] == AQuality) && (row.TVs [2] == AEncodingMethod) && (row.TVs [3] == ANoiseShaping) && (row.TVs [4] == AStereoMode) && (row.TVs [5] == AATHType) && (row.TVs [6] == ALowpassDiv100)) {  	if (row.TVs [0] == ABitrate) {  		Result = row.Res;  		break;  	} // Non-bitrate based guessing is only relevant to the VBR presets.  	else if (AEncodingMethod == 3 || AEncodingMethod == 4) {  		NonBitrateResult = row.Res;  	}  }  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,GuessForVersion,The following statement contains a magic number: if ((row.HasVersionGroup (AVersionGroup)) && (row.TVs [1] == AQuality) && (row.TVs [2] == AEncodingMethod) && (row.TVs [3] == ANoiseShaping) && (row.TVs [4] == AStereoMode) && (row.TVs [5] == AATHType) && (row.TVs [6] == ALowpassDiv100)) {  	if (row.TVs [0] == ABitrate) {  		Result = row.Res;  		break;  	} // Non-bitrate based guessing is only relevant to the VBR presets.  	else if (AEncodingMethod == 3 || AEncodingMethod == 4) {  		NonBitrateResult = row.Res;  	}  }  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,GuessForVersion,The following statement contains a magic number: if (row.TVs [0] == ABitrate) {  	Result = row.Res;  	break;  } // Non-bitrate based guessing is only relevant to the VBR presets.  else if (AEncodingMethod == 3 || AEncodingMethod == 4) {  	NonBitrateResult = row.Res;  }  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,GuessForVersion,The following statement contains a magic number: if (row.TVs [0] == ABitrate) {  	Result = row.Res;  	break;  } // Non-bitrate based guessing is only relevant to the VBR presets.  else if (AEncodingMethod == 3 || AEncodingMethod == 4) {  	NonBitrateResult = row.Res;  }  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,GuessForVersion,The following statement contains a magic number: if (AEncodingMethod == 3 || AEncodingMethod == 4) {  	NonBitrateResult = row.Res;  }  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuesser,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuesser.cs,GuessForVersion,The following statement contains a magic number: if (AEncodingMethod == 3 || AEncodingMethod == 4) {  	NonBitrateResult = row.Res;  }  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuessRow,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuessRow.cs,HasVersionGroup,The following statement contains a magic number: for (int i = 0; i < 3; i++)  	if (vg1 == VGs [i])  		return true;  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuessRow,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuessRow.cs,Initialize,The following statement contains a magic number: VGs [2] = vg3;  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuessRow,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuessRow.cs,Initialize,The following statement contains a magic number: TVs [2] = tv3;  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuessRow,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuessRow.cs,Initialize,The following statement contains a magic number: TVs [3] = tv4;  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuessRow,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuessRow.cs,Initialize,The following statement contains a magic number: TVs [4] = tv5;  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuessRow,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuessRow.cs,Initialize,The following statement contains a magic number: TVs [5] = tv6;  
Magic Number,IdSharp.AudioInfo.Inspection,PresetGuessRow,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\PresetGuessRow.cs,Initialize,The following statement contains a magic number: TVs [6] = tv7;  
Magic Number,IdSharp.AudioInfo.Inspection,LameTag,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\Structs.cs,FromBinaryReader,The following statement contains a magic number: tmpLameTag.Encoder = br.ReadBytes (4);  
Magic Number,IdSharp.AudioInfo.Inspection,LameTag,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\Structs.cs,FromBinaryReader,The following statement contains a magic number: tmpLameTag.VersionString = br.ReadBytes (5);  
Magic Number,IdSharp.AudioInfo.Inspection,LameTag,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\Structs.cs,FromBinaryReader,The following statement contains a magic number: tmpLameTag.ReplayGain = br.ReadBytes (8);  
Magic Number,IdSharp.AudioInfo.Inspection,LameTag,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\Structs.cs,FromBinaryReader,The following statement contains a magic number: tmpLameTag.EncoderDelays = br.ReadBytes (3);  
Magic Number,IdSharp.AudioInfo.Inspection,LameTag,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\Structs.cs,FromBinaryReader,The following statement contains a magic number: tmpLameTag.Surround_Preset = br.ReadBytes (2);  
Magic Number,IdSharp.AudioInfo.Inspection,LameTag,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\Structs.cs,FromBinaryReader,The following statement contains a magic number: tmpLameTag.MusicLength = br.ReadBytes (4);  
Magic Number,IdSharp.AudioInfo.Inspection,LameTag,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\Structs.cs,FromBinaryReader,The following statement contains a magic number: tmpLameTag.MusicCRC = br.ReadBytes (2);  
Magic Number,IdSharp.AudioInfo.Inspection,LameTag,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\Structs.cs,FromBinaryReader,The following statement contains a magic number: tmpLameTag.InfoTagCRC = br.ReadBytes (2);  
Magic Number,IdSharp.AudioInfo.Inspection,LameTag,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\Structs.cs,FromBinaryReader,The following statement contains a magic number: tmpLameTag.StereoMode = (byte)((tmpLameTag.MiscInfo & 0x1C) >> 2);  
Magic Number,IdSharp.AudioInfo.Inspection,OldLameHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\Structs.cs,FromBinaryReader,The following statement contains a magic number: tmpOldLameHeader.Encoder = br.ReadBytes (4);  
Magic Number,IdSharp.AudioInfo.Inspection,OldLameHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\Structs.cs,FromBinaryReader,The following statement contains a magic number: tmpOldLameHeader.VersionString = br.ReadBytes (16);  
Magic Number,IdSharp.AudioInfo.Inspection,StartOfFile,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\Structs.cs,FromBinaryReader,The following statement contains a magic number: tmpStartOfFile.Misc1 = br.ReadBytes (13);  
Magic Number,IdSharp.AudioInfo.Inspection,StartOfFile,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\Structs.cs,FromBinaryReader,The following statement contains a magic number: tmpStartOfFile.Info1 = br.ReadBytes (4);  
Magic Number,IdSharp.AudioInfo.Inspection,StartOfFile,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\Structs.cs,FromBinaryReader,The following statement contains a magic number: tmpStartOfFile.Misc2 = br.ReadBytes (4);  
Magic Number,IdSharp.AudioInfo.Inspection,StartOfFile,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\Structs.cs,FromBinaryReader,The following statement contains a magic number: tmpStartOfFile.Info2 = br.ReadBytes (4);  
Magic Number,IdSharp.AudioInfo.Inspection,StartOfFile,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\Structs.cs,FromBinaryReader,The following statement contains a magic number: tmpStartOfFile.Misc3 = br.ReadBytes (11);  
Magic Number,IdSharp.AudioInfo.Inspection,StartOfFile,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Inspection\Structs.cs,FromBinaryReader,The following statement contains a magic number: tmpStartOfFile.Info3 = br.ReadBytes (4);  
Duplicate Code,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,Mpeg,The method contains a code clone-set at the following line numbers (starting from the method definition): ((5' 56)' (60' 111))
Missing Default,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,GetSamplesPerFrame,The following switch statement is missing a default case: switch (mpegVersion) {  // MPEG-1  case MpegVersion.Mpeg1:  	if (mpegLayer == MpegLayer.Layer1)  		tmpSamplesPerFrame = 384;  	else if (mpegLayer == MpegLayer.Layer2 || mpegLayer == MpegLayer.Layer3)  		tmpSamplesPerFrame = 1152;  	break;  // MPEG-2/2.5  case MpegVersion.Mpeg2:  case MpegVersion.Mpeg25:  	if (mpegLayer == MpegLayer.Layer1)  		tmpSamplesPerFrame = 384;  	else if (mpegLayer == MpegLayer.Layer2)  		tmpSamplesPerFrame = 1152;  	else if (mpegLayer == MpegLayer.Layer3)  		tmpSamplesPerFrame = 576;  	break;  }  
Missing Default,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,GetFrequency,The following switch statement is missing a default case: switch (mpegVersion) {  // MPEG-1  case MpegVersion.Mpeg1:  	switch (frequencyID) {  	case 0:  		tmpFrequency = 44100;  		break;  	case 1:  		tmpFrequency = 48000;  		break;  	case 2:  		tmpFrequency = 32000;  		break;  	}  	// end switch (Frequency)  	break;  // MPEG-2  case MpegVersion.Mpeg2:  	switch (frequencyID) {  	case 0:  		tmpFrequency = 22050;  		break;  	case 1:  		tmpFrequency = 24000;  		break;  	case 2:  		tmpFrequency = 16000;  		break;  	}  	// end switch (Frequency)  	break;  // MPEG-2.5  case MpegVersion.Mpeg25:  	switch (frequencyID) {  	case 0:  		tmpFrequency = 11025;  		break;  	case 1:  		tmpFrequency = 12000;  		break;  	case 2:  		tmpFrequency = 8000;  		break;  	}  	// end switch (Frequency)  	break;  }  
Missing Default,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,GetFrequency,The following switch statement is missing a default case: switch (frequencyID) {  case 0:  	tmpFrequency = 44100;  	break;  case 1:  	tmpFrequency = 48000;  	break;  case 2:  	tmpFrequency = 32000;  	break;  }  
Missing Default,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,GetFrequency,The following switch statement is missing a default case: switch (frequencyID) {  case 0:  	tmpFrequency = 22050;  	break;  case 1:  	tmpFrequency = 24000;  	break;  case 2:  	tmpFrequency = 16000;  	break;  }  
Missing Default,IdSharp.AudioInfo,Mpeg,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Mpeg\Mpeg.cs,GetFrequency,The following switch statement is missing a default case: switch (frequencyID) {  case 0:  	tmpFrequency = 11025;  	break;  case 1:  	tmpFrequency = 12000;  	break;  case 2:  	tmpFrequency = 8000;  	break;  }  
Missing Default,IdSharp.AudioInfo,Musepack,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Musepack\Musepack.cs,Musepack,The following switch statement is missing a default case: switch ((byteArray [1] % 32) / 2) {  case 3:  	_streamVersion = 4;  	break;  case 7:  	_streamVersion = 5;  	break;  case 11:  	_streamVersion = 6;  	break;  }  
Missing Default,IdSharp.AudioInfo,Shorten,F:\newReposMay17\judwhite_IdSharp\IdSharp.AudioInfo\Shorten\Shorten.cs,getSamples,The following switch statement is missing a default case: switch (cmd) {  case FN_ZERO:  	break;  case FN_DIFF0:  case FN_DIFF1:  case FN_DIFF2:  case FN_DIFF3:  	for (i = 0; i < blocksize; i++) {  		int nbin = resn + 1;  		if (nbitget == 0) {  			if (nbyteget < 4) {  				int bytes = stream.Read (getbuf' 0' BUFSIZE);  				getbufOffset = 0;  				nbyteget += bytes;  			}  			gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  			getbufOffset += 4;  			nbyteget -= 4;  			nbitget = 32;  		}  		while ((gbuffer & (1L << --nbitget)) == 0) {  			if (nbitget == 0) {  				if (nbyteget < 4) {  					int bytes = stream.Read (getbuf' 0' BUFSIZE);  					getbufOffset = 0;  					nbyteget += bytes;  				}  				gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  				getbufOffset += 4;  				nbyteget -= 4;  				nbitget = 32;  			}  		}  		while (nbin != 0) {  			if (nbitget >= nbin) {  				nbitget -= nbin;  				nbin = 0;  			} else {  				if (nbyteget < 4) {  					int bytes = stream.Read (getbuf' 0' BUFSIZE);  					getbufOffset = 0;  					nbyteget += bytes;  				}  				gbuffer = (((uint)getbuf [getbufOffset]) << 24) | (((uint)getbuf [getbufOffset + 1]) << 16) | (((uint)getbuf [getbufOffset + 2]) << 8) | (getbuf [getbufOffset + 3]);  				getbufOffset += 4;  				nbyteget -= 4;  				nbin -= nbitget;  				nbitget = 32;  			}  		}  	}  	break;  case FN_QLPC:  	int nlpc = uvar_get (LPCQSIZE' stream);  	for (i = 0; i < nlpc; i++)  		var_get (LPCQUANT' stream);  	break;  }  
