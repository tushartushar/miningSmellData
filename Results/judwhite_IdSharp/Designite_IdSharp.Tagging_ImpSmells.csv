Implementation smell,Namespace,Class,File,Method,Description
Long Method,IdSharp.Tagging.ID3v2,FrameContainer,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameContainer.FrameCreation.cs,FrameContainer,The method has 177 lines of code.
Long Method,IdSharp.Tagging.ID3v2,FrameContainer,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameContainer.FrameCreation.cs,Read,The method has 134 lines of code.
Long Method,IdSharp.Tagging.ID3v2,ID3v2Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2Tag.cs,Read,The method has 129 lines of code.
Long Method,IdSharp.Tagging.ID3v2,LanguageHelper,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\LanguageHelper.cs,LanguageHelper,The method has 434 lines of code.
Long Method,IdSharp.Tagging.ID3v2,ID3v2Utils,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\ID3v2Utils.cs,ReadString,The method has 124 lines of code.
Long Method,IdSharp.Tagging.ID3v2.Frames,RelativeVolumeAdjustment,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\Frames\RelativeVolumeAdjustment.cs,Read,The method has 130 lines of code.
Long Method,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ParseAtom,The method has 107 lines of code.
Long Method,IdSharp.Tagging.VorbisComment,VorbisComment,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\VorbisComment\VorbisComment.cs,WriteTagFlac,The method has 170 lines of code.
Complex Method,IdSharp.Tagging.APEv2,APEv2Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\APEv2\APEv2Tag.cs,Read,Cyclomatic complexity of the method is 10
Complex Method,IdSharp.Tagging.APEv2,APEv2Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\APEv2\APEv2Tag.cs,ReadField,Cyclomatic complexity of the method is 39
Complex Method,IdSharp.Tagging.ID3v2,FrameContainer,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameContainer.FrameCreation.cs,ValidateFractionValue,Cyclomatic complexity of the method is 11
Complex Method,IdSharp.Tagging.ID3v2,FrameContainer,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameContainer.FrameCreation.cs,Read,Cyclomatic complexity of the method is 26
Complex Method,IdSharp.Tagging.ID3v2,FrameContainer,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameContainer.FrameCreation.cs,GetBytes,Cyclomatic complexity of the method is 9
Complex Method,IdSharp.Tagging.ID3v2,ID3v2Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2Tag.cs,Read,Cyclomatic complexity of the method is 23
Complex Method,IdSharp.Tagging.ID3v2,FrameHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameHeader.cs,Read,Cyclomatic complexity of the method is 16
Complex Method,IdSharp.Tagging.ID3v2,FrameHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameHeader.cs,GetBytes,Cyclomatic complexity of the method is 21
Complex Method,IdSharp.Tagging.ID3v2,ID3v2Header,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2Header.cs,Read,Cyclomatic complexity of the method is 21
Complex Method,IdSharp.Tagging.ID3v2,ID3v2Utils,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\ID3v2Utils.cs,GetStringBytes,Cyclomatic complexity of the method is 11
Complex Method,IdSharp.Tagging.ID3v2,ID3v2Utils,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\ID3v2Utils.cs,ReadString,Cyclomatic complexity of the method is 11
Complex Method,IdSharp.Tagging.ID3v2,ID3v2Utils,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\ID3v2Utils.cs,ReadString,Cyclomatic complexity of the method is 15
Complex Method,IdSharp.Tagging.ID3v2,ID3v2Utils,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\ID3v2Utils.cs,ReadString,Cyclomatic complexity of the method is 24
Complex Method,IdSharp.Tagging.ID3v2.Frames,Comments,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\Frames\Comments.cs,Read,Cyclomatic complexity of the method is 9
Complex Method,IdSharp.Tagging.ID3v2.Frames,Commercial,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\Frames\Commercial.cs,Read,Cyclomatic complexity of the method is 12
Complex Method,IdSharp.Tagging.ID3v2.Frames,Commercial,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\Frames\Commercial.cs,GetBytes,Cyclomatic complexity of the method is 8
Complex Method,IdSharp.Tagging.ID3v2.Frames,InvolvedPersonList,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\Frames\InvolvedPersonList.cs,GetBytes,Cyclomatic complexity of the method is 10
Complex Method,IdSharp.Tagging.ID3v2.Frames,SynchronizedText,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\Frames\SynchronizedText.cs,Read,Cyclomatic complexity of the method is 8
Complex Method,IdSharp.Tagging.ID3v2.Frames,SynchronizedText,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\Frames\SynchronizedText.cs,GetBytes,Cyclomatic complexity of the method is 8
Complex Method,IdSharp.Tagging.ID3v2.Frames,RelativeVolumeAdjustment,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\Frames\RelativeVolumeAdjustment.cs,Read,Cyclomatic complexity of the method is 23
Complex Method,IdSharp.Tagging.ID3v2.Frames,AttachedPicture,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\Frames\AttachedPicture.cs,SetMimeType,Cyclomatic complexity of the method is 12
Complex Method,IdSharp.Tagging.ID3v2.Frames,AttachedPicture,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\Frames\AttachedPicture.cs,LoadPicture,Cyclomatic complexity of the method is 10
Complex Method,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ParseTag,Cyclomatic complexity of the method is 16
Complex Method,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ParseAtom,Cyclomatic complexity of the method is 22
Complex Method,IdSharp.Tagging.VorbisComment,VorbisComment,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\VorbisComment\VorbisComment.cs,WriteTagFlac,Cyclomatic complexity of the method is 36
Complex Method,IdSharp.Tagging.SimpleTag,SimpleTag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\SimpleTag\SimpleTag.cs,Read,Cyclomatic complexity of the method is 14
Complex Method,IdSharp.Tagging.SimpleTag,SimpleTag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\SimpleTag\SimpleTag.cs,Save,Cyclomatic complexity of the method is 8
Long Parameter List,IdSharp.Tagging.ID3v2,FrameContainer,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameContainer.FrameCreation.cs,CreateFrame,The method has 5 parameters.
Long Parameter List,IdSharp.Tagging.ID3v2,FrameContainer,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameContainer.FrameCreation.cs,Bind,The method has 7 parameters.
Long Parameter List,IdSharp.Tagging.ID3v2,FrameContainer,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameContainer.FrameCreation.cs,CreateMusicCDIdentifierFrame,The method has 5 parameters.
Long Parameter List,IdSharp.Tagging.ID3v2,FrameContainer,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameContainer.FrameCreation.cs,CreateLanguageFrame,The method has 5 parameters.
Long Parameter List,IdSharp.Tagging.ID3v2,FrameContainer,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameContainer.FrameCreation.cs,CreateTextFrame,The method has 5 parameters.
Long Parameter List,IdSharp.Tagging.ID3v2,FrameContainer,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameContainer.FrameCreation.cs,CreateUrlFrame,The method has 5 parameters.
Long Parameter List,IdSharp.Tagging.ID3v2,FrameContainer,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameContainer.FrameCreation.cs,Read,The method has 5 parameters.
Long Statement,IdSharp.Tagging.ID3v2,FrameContainer,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameContainer.FrameCreation.cs,ValidateTrackNumber,The length of the statement  "	// NOTE: Track Num is commonly used as a show number in the podcast world. Given where we are with podcasting as this date'  " is 123.
Long Statement,IdSharp.Tagging.ID3v2,FrameContainer,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameContainer.FrameCreation.cs,ValidateTrackNumber,The length of the statement  "	ValidateFractionValue ("TrackNumber"' TrackNumber' "Value should contain either the track number or track number/total tracks in the format ## or ##/##\nExample: 1 or 1/14"); " is 174.
Long Statement,IdSharp.Tagging.ID3v2,FrameContainer,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameContainer.FrameCreation.cs,ValidateDiscNumber,The length of the statement  "	ValidateFractionValue ("DiscNumber"' DiscNumber' "Value should contain either the disc number or disc number/total discs in the format ## or ##/##\nExample: 1 or 1/2"); " is 168.
Long Statement,IdSharp.Tagging.ID3v2,FrameContainer,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameContainer.FrameCreation.cs,ValidateCopyright,The length of the statement  "			FireWarning ("Copyright"' string.Format ("The copyright field should begin with a year followed by the copyright owner{0}Example: 2007 Sony Records"' Environment.NewLine)); " is 172.
Long Statement,IdSharp.Tagging.ID3v2,FrameContainer,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameContainer.FrameCreation.cs,Read,The length of the statement  "			if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) { " is 219.
Long Statement,IdSharp.Tagging.ID3v2,FrameContainer,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameContainer.FrameCreation.cs,Read,The length of the statement  "					string msg = string.Format ("Out of range FrameID - 0x{0:X}|0x{1:X}|0x{2:X}|0x{3:X}"' frameIDBytes [0]' frameIDBytes [1]' frameIDBytes [2]' frameIDBytes [3]); " is 158.
Long Statement,IdSharp.Tagging.ID3v2,FrameContainer,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameContainer.FrameCreation.cs,Read,The length of the statement  "			if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A) { " is 165.
Long Statement,IdSharp.Tagging.ID3v2,FrameContainer,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameContainer.FrameCreation.cs,Read,The length of the statement  "					string msg = string.Format ("Out of range FrameID - 0x{0:X}|0x{1:X}|0x{2:X}"' frameIDBytes [0]' frameIDBytes [1]' frameIDBytes [2]); " is 132.
Long Statement,IdSharp.Tagging.ID3v2,FrameContainer,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameContainer.FrameCreation.cs,GetAllFrames,The length of the statement  "			if (frame.GetFrameID (ID3v2TagVersion.ID3v22) == frameID || frame.GetFrameID (ID3v2TagVersion.ID3v23) == frameID || frame.GetFrameID (ID3v2TagVersion.ID3v24) == frameID) { " is 171.
Long Statement,IdSharp.Tagging.ID3v2,ID3v2Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2Tag.cs,Read,The length of the statement  "			if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) { " is 219.
Long Statement,IdSharp.Tagging.ID3v2,ID3v2Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2Tag.cs,Read,The length of the statement  "					if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) { " is 219.
Long Statement,IdSharp.Tagging.ID3v2,ID3v2Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2Tag.cs,Read,The length of the statement  "					if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) { " is 219.
Long Statement,IdSharp.Tagging.ID3v2,FrameHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameHeader.cs,Read,The length of the statement  "	bool usesUnsynchronization = ((tagReadingInfo.TagVersionOptions & TagVersionOptions.Unsynchronized) == TagVersionOptions.Unsynchronized); " is 137.
Long Statement,IdSharp.Tagging.ID3v2,FrameHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameHeader.cs,Read,The length of the statement  "		if ((tagReadingInfo.TagVersionOptions & TagVersionOptions.UseNonSyncSafeFrameSizeID3v24) == TagVersionOptions.UseNonSyncSafeFrameSizeID3v24) " is 140.
Long Statement,IdSharp.Tagging.ID3v2,FrameHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameHeader.cs,GetBytes,The length of the statement  "			throw new ArgumentException (String.Format ("FrameID must be 3 bytes from ID3v2.2 ({0} bytes passed)"' frameIDBytes.Length)); " is 125.
Long Statement,IdSharp.Tagging.ID3v2,FrameHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameHeader.cs,GetBytes,The length of the statement  "		byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x80 : 0) + (_isFileAlterPreservation ? 0x40 : 0) + (_isReadOnly ? 0x20 : 0)); " is 128.
Long Statement,IdSharp.Tagging.ID3v2,FrameHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameHeader.cs,GetBytes,The length of the statement  "		byte tmpByte2 = (byte)((_isCompressed ? 0x80 : 0) + (_encryptionMethod != null ? 0x40 : 0) + (_groupingIdentity != null ? 0x20 : 0)); " is 133.
Long Statement,IdSharp.Tagging.ID3v2,FrameHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameHeader.cs,GetBytes,The length of the statement  "		byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x40 : 0) + (_isFileAlterPreservation ? 0x20 : 0) + (_isReadOnly ? 0x10 : 0)); " is 128.
Long Statement,IdSharp.Tagging.ID3v2,FrameHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameHeader.cs,GetBytes,The length of the statement  "		byte tmpByte2 = (byte)((_groupingIdentity != null ? 0x40 : 0) + (_isCompressed ? 0x08 : 0) + (_encryptionMethod != null ? 0x04 : 0)/* +" is 135.
Long Statement,IdSharp.Tagging.ID3v2,ID3v2Utils,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\ID3v2Utils.cs,ReadString,The length of the statement  "		//String msg = String.Format("ReadString (unknown length) called with {0} bytes left at position {1}"' bytesLeft' stream.Position); " is 131.
Long Statement,IdSharp.Tagging.ID3v2,ID3v2Utils,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\ID3v2Utils.cs,ReadString,The length of the statement  "			//String msg = String.Format("End of frame reached while reading unknown length string at position {0}"' stream.Position); " is 122.
Long Statement,IdSharp.Tagging.ID3v2,ID3v2Utils,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\ID3v2Utils.cs,ReadString,The length of the statement  "				//String msg = String.Format("End of frame reached while reading unknown length string at position {0}"' stream.Position); " is 122.
Long Statement,IdSharp.Tagging.ID3v2,ID3v2Utils,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\ID3v2Utils.cs,ReadString,The length of the statement  "				//String msg = String.Format("End of frame reached while reading unknown length string at position {0}"' stream.Position); " is 122.
Long Statement,IdSharp.Tagging.ID3v2,ID3v2Utils,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\ID3v2Utils.cs,ReadString,The length of the statement  "				//String msg = String.Format("End of frame reached while reading unknown length string at position {0}"' stream.Position); " is 122.
Long Statement,IdSharp.Tagging.ID3v2,ID3v2Utils,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\ID3v2Utils.cs,ReadString,The length of the statement  "				//String msg = String.Format("End of frame reached while reading unknown length string at position {0}"' stream.Position); " is 122.
Long Statement,IdSharp.Tagging.ID3v2,ID3v2Utils,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\ID3v2Utils.cs,ReadString,The length of the statement  "				//String msg = String.Format("End of frame reached while reading unknown length string at position {0}"' stream.Position); " is 122.
Long Statement,IdSharp.Tagging.ID3v2,ID3v2Utils,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\ID3v2Utils.cs,ReadString,The length of the statement  "			//String msg = String.Format("End of frame reached while reading unknown length string at position {0}"' stream.Position); " is 122.
Long Statement,IdSharp.Tagging.ID3v2,ID3v2Utils,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\ID3v2Utils.cs,ReadString,The length of the statement  "				//String msg = String.Format("End of frame reached while reading unknown length string at position {0}"' stream.Position); " is 122.
Long Statement,IdSharp.Tagging.ID3v2.Frames,AudioText,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\Frames\AudioText.cs,NextByte,The length of the statement  "	byte newByte = (byte)(((bit6 ^ bit5) << 7) + ((bit5 ^ bit4) << 6) + ((bit4 ^ bit3) << 5) + ((bit3 ^ bit2) << 4) + ((bit2 ^ bit1) << 3) + ((bit1 ^ bit0) << 2) + ((bit7 ^ bit5) << 1) + (bit6 ^ bit4)); " is 198.
Long Statement,IdSharp.Tagging.ID3v2.Frames,Comments,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\Frames\Comments.cs,Read,The length of the statement  "			string msg = string.Format ("Under-sized ({0} bytes) COMM frame at position {1}"' _frameHeader.FrameSizeExcludingAdditions' stream.Position); " is 141.
Long Statement,IdSharp.Tagging.ID3v2.Frames,Comments,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\Frames\Comments.cs,Read,The length of the statement  "		string msg = string.Format ("Under-sized ({0} bytes) COMM frame at position {1}"' _frameHeader.FrameSizeExcludingAdditions' stream.Position); " is 141.
Long Statement,IdSharp.Tagging.ID3v2.Frames,Comments,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\Frames\Comments.cs,GetBytes,The length of the statement  "	} while (this.RequiresFix (tagVersion' Description' descriptionData) || this.RequiresFix (tagVersion' Value' valueData)); " is 121.
Long Statement,IdSharp.Tagging.ID3v2.Frames,Commercial,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\Frames\Commercial.cs,Read,The length of the statement  "					if (decimal.TryParse (pricePart' System.Globalization.NumberStyles.Any' System.Globalization.NumberFormatInfo.InvariantInfo' out price)) { " is 138.
Long Statement,IdSharp.Tagging.ID3v2.Frames,Commercial,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\Frames\Commercial.cs,Read,The length of the statement  "				validUntil = string.Format ("{0}-{1}-{2}"' validUntil.Substring (0' 4)' validUntil.Substring (4' 2)' validUntil.Substring (6' 2)); " is 130.
Long Statement,IdSharp.Tagging.ID3v2.Frames,Commercial,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\Frames\Commercial.cs,GetBytes,The length of the statement  "		} while (this.RequiresFix (tagVersion' _nameOfSeller' nameOfSellerData) || this.RequiresFix (tagVersion' _description' descriptionData)); " is 137.
Long Statement,IdSharp.Tagging.ID3v2.Frames,GeneralEncapsulatedObject,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\Frames\GeneralEncapsulatedObject.cs,GetBytes,The length of the statement  "		} while (this.RequiresFix (tagVersion' FileName' fileNameData) || this.RequiresFix (tagVersion' Description' descriptionData)); " is 127.
Long Statement,IdSharp.Tagging.ID3v2.Frames,MpegLookupTable,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\Frames\MpegLookupTable.cs,GetBytes,The length of the statement  "	if (FramesBetweenReference == 0 || BytesBetweenReference == 0 || MillisecondsBetweenReference == 0 || Items.Count == 0) { " is 121.
Long Statement,IdSharp.Tagging.ID3v2.Frames,Ownership,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\Frames\Ownership.cs,GetBytes,The length of the statement  "	if (PricePaid == 0 && string.IsNullOrEmpty (CurrencyCode) && DateOfPurchase == DateTime.MinValue && string.IsNullOrEmpty (Seller)) { " is 132.
Long Statement,IdSharp.Tagging.ID3v2.Frames,TXXXFrame,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\Frames\TXXXFrame.cs,GetBytes,The length of the statement  "	} while (this.RequiresFix (tagVersion' Description' descriptionData) || this.RequiresFix (tagVersion' Value' valueData)); " is 121.
Long Statement,IdSharp.Tagging.ID3v2.Frames,UnsynchronizedText,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\Frames\UnsynchronizedText.cs,Read,The length of the statement  "		string msg = string.Format ("Under-sized ({0} bytes) unsynchronized text frame at position {1}"' _frameHeader.FrameSizeExcludingAdditions' stream.Position); " is 156.
Long Statement,IdSharp.Tagging.ID3v2.Frames,UnsynchronizedText,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\Frames\UnsynchronizedText.cs,GetBytes,The length of the statement  "	} while (this.RequiresFix (tagVersion' ContentDescriptor' contentDescriptorData) || this.RequiresFix (tagVersion' Text' textData)); " is 131.
Long Statement,IdSharp.Tagging.ID3v2.Frames,TextFrame,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\Frames\TextFrame.cs,Read,The length of the statement  "		//String msg = String.Format("Under-sized ({0} bytes) text frame at position {1}"' m_FrameHeader.FrameSizeExcludingAdditions' stream.Position); " is 143.
Long Statement,IdSharp.Tagging.VorbisComment,VorbisComment,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\VorbisComment\VorbisComment.cs,WriteTagFlac,The length of the statement  "		if (metaDataBlock.BlockType == FlacMetaDataBlockType.Application || metaDataBlock.BlockType == FlacMetaDataBlockType.CueSheet || metaDataBlock.BlockType == FlacMetaDataBlockType.Picture) { " is 188.
Long Statement,IdSharp.Tagging.VorbisComment,VorbisComment,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\VorbisComment\VorbisComment.cs,WriteTagFlac,The length of the statement  "		throw new Exception (String.Format ("Internal Error: newMetaDataSize ({0}) < origMetaDataSize ({1})"' newMetaDataSize' origMetaDataSize)); " is 138.
Complex Conditional,IdSharp.Tagging.ID3v2,FrameContainer,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameContainer.FrameCreation.cs,Read,The conditional expression  "frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A"  is complex.
Complex Conditional,IdSharp.Tagging.ID3v2,FrameContainer,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameContainer.FrameCreation.cs,Read,The conditional expression  "frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A"  is complex.
Complex Conditional,IdSharp.Tagging.ID3v2,FrameContainer,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameContainer.FrameCreation.cs,Read,The conditional expression  "frameID != "NCON" && // non standard (old music match)  frameID != "MJMD" && // Non standard frame (Music Match XML)  frameID != "TT22" && // 000.00 - maybe meant to be 3 letter TT2 frame' and value be 2000.00? still makes no sense  frameID != "PCST" && // null data  frameID != "TCAT" && // category (ie' comedy) (distorted view)  frameID != "TKWD" && // looks like blog tags "comedy funny weird"' etc (distorted view)  frameID != "TDES" && // xml file - used by distortedview.com  frameID != "TGID" && // url (from distortedview)  frameID != "WFED" && // url (thanks distortedview)  frameID != "CM1" && // some kind of comment' seen in ID3v2.2  frameID != "TMB" && // ripped by something other' not in spec  frameID != "RTNG" && frameID != "XDOR" && // year  frameID != "XSOP" && // looks like artist' "Allman Brothers Band' The"  frameID != "TENK""  is complex.
Complex Conditional,IdSharp.Tagging.ID3v2,ID3v2Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2Tag.cs,Read,The conditional expression  "frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A"  is complex.
Complex Conditional,IdSharp.Tagging.ID3v2,ID3v2Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2Tag.cs,Read,The conditional expression  "frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A"  is complex.
Complex Conditional,IdSharp.Tagging.ID3v2,ID3v2Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2Tag.cs,Read,The conditional expression  "frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A"  is complex.
Complex Conditional,IdSharp.Tagging.ID3v2,ID3v2Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2Tag.cs,Read,The conditional expression  "frameIDBytes [1] >= 0x30 && frameIDBytes [1] <= 0x5A && frameIDBytes [2] >= 0x30 && frameIDBytes [2] <= 0x5A"  is complex.
Complex Conditional,IdSharp.Tagging.ID3v2.Frames,MpegLookupTable,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\Frames\MpegLookupTable.cs,GetBytes,The conditional expression  "FramesBetweenReference == 0 || BytesBetweenReference == 0 || MillisecondsBetweenReference == 0 || Items.Count == 0"  is complex.
Complex Conditional,IdSharp.Tagging.ID3v2.Frames,Ownership,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\Frames\Ownership.cs,GetBytes,The conditional expression  "PricePaid == 0 && string.IsNullOrEmpty (CurrencyCode) && DateOfPurchase == DateTime.MinValue && string.IsNullOrEmpty (Seller)"  is complex.
Complex Conditional,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ParseAtom,The conditional expression  "atomdata [i] == 'i' && atomdata [i + 1] == 'l' && atomdata [i + 2] == 's' && atomdata [i + 3] == 't'"  is complex.
Magic Number,IdSharp.Tagging.APEv2,APEv2Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\APEv2\APEv2Tag.cs,GetBytes,The following statement contains a magic number: if (elements != 0) {  	tagSize = 32;  	// footer + all tag items' excluding header (to be compatible with APEv1)  	foreach (KeyValuePair<string' string> item in _items) {  		int valueLength = Encoding.UTF8.GetByteCount (item.Value);  		tagSize += 8 + item.Key.Length + 1 + valueLength;  	}  } else {  	return new byte[0];  }  
Magic Number,IdSharp.Tagging.APEv2,APEv2Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\APEv2\APEv2Tag.cs,GetBytes,The following statement contains a magic number: if (elements != 0) {  	tagSize = 32;  	// footer + all tag items' excluding header (to be compatible with APEv1)  	foreach (KeyValuePair<string' string> item in _items) {  		int valueLength = Encoding.UTF8.GetByteCount (item.Value);  		tagSize += 8 + item.Key.Length + 1 + valueLength;  	}  } else {  	return new byte[0];  }  
Magic Number,IdSharp.Tagging.APEv2,APEv2Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\APEv2\APEv2Tag.cs,GetBytes,The following statement contains a magic number: tagSize = 32;  
Magic Number,IdSharp.Tagging.APEv2,APEv2Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\APEv2\APEv2Tag.cs,GetBytes,The following statement contains a magic number: foreach (KeyValuePair<string' string> item in _items) {  	int valueLength = Encoding.UTF8.GetByteCount (item.Value);  	tagSize += 8 + item.Key.Length + 1 + valueLength;  }  
Magic Number,IdSharp.Tagging.APEv2,APEv2Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\APEv2\APEv2Tag.cs,GetBytes,The following statement contains a magic number: tagSize += 8 + item.Key.Length + 1 + valueLength;  
Magic Number,IdSharp.Tagging.APEv2,APEv2Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\APEv2\APEv2Tag.cs,GetBytes,The following statement contains a magic number: using (MemoryStream ms = new MemoryStream ()) {  	ms.Write (_APETAGEX);  	// Footer  	ms.WriteInt32LittleEndian (2000);  	// Version (2000) ; 0xD0 0x07 0x00 0x00  	ms.WriteInt32LittleEndian (tagSize);  	// Tag size  	ms.WriteInt32LittleEndian (elements);  	// Element count  	ms.Write (new byte[] {  		0'  		0'  		0'  		0xA0  	});  	// Tag flags + IsHeader' Contains Header' Contains Footer  	ms.Write (new byte[] {  		0'  		0'  		0'  		0'  		0'  		0'  		0'  		0  	});  	// reserved  	// 0000 0000  	// 0xA0 = 0000 1010  	// Elements  	foreach (KeyValuePair<string' string> item in _items) {  		byte[] valueBytes = Encoding.UTF8.GetBytes (item.Value);  		ms.WriteInt32LittleEndian (valueBytes.Length);  		// size  		ms.Write (new byte[] {  			0x00'  			0x00'  			0x00'  			0x00  		});  		// todo: account for encoding type  		ms.Write (Encoding.ASCII.GetBytes (item.Key));  		ms.WriteByte (0x00);  		ms.Write (valueBytes);  	}  	ms.Write (_APETAGEX);  	// Footer  	ms.WriteInt32LittleEndian (2000);  	// Version (2000) ; 0xD0 0x07 0x00 0x00  	ms.WriteInt32LittleEndian (tagSize);  	// Tag size  	ms.WriteInt32LittleEndian (elements);  	// Element count  	ms.Write (new byte[] {  		0'  		0'  		0  	});  	// Other fields  	ms.WriteByte (0x80);  	// IsHeader' Contains Header' Contains Footer  	// 0000 1000  	ms.Write (new byte[] {  		0'  		0'  		0'  		0'  		0'  		0'  		0'  		0  	});  	// reserved  	return ms.ToArray ();  }  
Magic Number,IdSharp.Tagging.APEv2,APEv2Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\APEv2\APEv2Tag.cs,GetBytes,The following statement contains a magic number: using (MemoryStream ms = new MemoryStream ()) {  	ms.Write (_APETAGEX);  	// Footer  	ms.WriteInt32LittleEndian (2000);  	// Version (2000) ; 0xD0 0x07 0x00 0x00  	ms.WriteInt32LittleEndian (tagSize);  	// Tag size  	ms.WriteInt32LittleEndian (elements);  	// Element count  	ms.Write (new byte[] {  		0'  		0'  		0'  		0xA0  	});  	// Tag flags + IsHeader' Contains Header' Contains Footer  	ms.Write (new byte[] {  		0'  		0'  		0'  		0'  		0'  		0'  		0'  		0  	});  	// reserved  	// 0000 0000  	// 0xA0 = 0000 1010  	// Elements  	foreach (KeyValuePair<string' string> item in _items) {  		byte[] valueBytes = Encoding.UTF8.GetBytes (item.Value);  		ms.WriteInt32LittleEndian (valueBytes.Length);  		// size  		ms.Write (new byte[] {  			0x00'  			0x00'  			0x00'  			0x00  		});  		// todo: account for encoding type  		ms.Write (Encoding.ASCII.GetBytes (item.Key));  		ms.WriteByte (0x00);  		ms.Write (valueBytes);  	}  	ms.Write (_APETAGEX);  	// Footer  	ms.WriteInt32LittleEndian (2000);  	// Version (2000) ; 0xD0 0x07 0x00 0x00  	ms.WriteInt32LittleEndian (tagSize);  	// Tag size  	ms.WriteInt32LittleEndian (elements);  	// Element count  	ms.Write (new byte[] {  		0'  		0'  		0  	});  	// Other fields  	ms.WriteByte (0x80);  	// IsHeader' Contains Header' Contains Footer  	// 0000 1000  	ms.Write (new byte[] {  		0'  		0'  		0'  		0'  		0'  		0'  		0'  		0  	});  	// reserved  	return ms.ToArray ();  }  
Magic Number,IdSharp.Tagging.APEv2,APEv2Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\APEv2\APEv2Tag.cs,GetBytes,The following statement contains a magic number: ms.WriteInt32LittleEndian (2000);  
Magic Number,IdSharp.Tagging.APEv2,APEv2Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\APEv2\APEv2Tag.cs,GetBytes,The following statement contains a magic number: ms.WriteInt32LittleEndian (2000);  
Magic Number,IdSharp.Tagging.APEv2,APEv2Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\APEv2\APEv2Tag.cs,Read,The following statement contains a magic number: stream.Seek (-32' SeekOrigin.End);  
Magic Number,IdSharp.Tagging.APEv2,APEv2Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\APEv2\APEv2Tag.cs,Read,The following statement contains a magic number: stream.Read (buf' 0' 32);  
Magic Number,IdSharp.Tagging.APEv2,APEv2Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\APEv2\APEv2Tag.cs,Read,The following statement contains a magic number: if (ByteUtils.Compare (buf' _APETAGEX' 8) == false) {  	// skip past possible ID3v1 tag  	footerOffset = 128;  	stream.Seek (-128 - 32' SeekOrigin.End);  	stream.Read (buf' 0' 32);  	if (ByteUtils.Compare (buf' _APETAGEX' 8) == false) {  		return;  		// skip past possible Lyrics3 tag  		// TODO!  		/*CLyrics3* Lyrics3 = new CLyrics3();                     Lyrics3->ReadTag(fp);                     if (Lyrics3->TagString() != "")                     {                         fseek(fp' 0L - Lyrics3->ExistingOffset() - 32' SEEK_END);                         fread(buf' 32' 1' fp);                         strcpy(tmp' buf);                         tmp[8] = 0;                          if (strcmp(tmp' "APETAGEX"))                         {                             delete Lyrics3;                             return;                         }                          footeroffset = Lyrics3->ExistingOffset();                     }                     else                     {                         return;                     }*/}  }  
Magic Number,IdSharp.Tagging.APEv2,APEv2Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\APEv2\APEv2Tag.cs,Read,The following statement contains a magic number: if (ByteUtils.Compare (buf' _APETAGEX' 8) == false) {  	// skip past possible ID3v1 tag  	footerOffset = 128;  	stream.Seek (-128 - 32' SeekOrigin.End);  	stream.Read (buf' 0' 32);  	if (ByteUtils.Compare (buf' _APETAGEX' 8) == false) {  		return;  		// skip past possible Lyrics3 tag  		// TODO!  		/*CLyrics3* Lyrics3 = new CLyrics3();                     Lyrics3->ReadTag(fp);                     if (Lyrics3->TagString() != "")                     {                         fseek(fp' 0L - Lyrics3->ExistingOffset() - 32' SEEK_END);                         fread(buf' 32' 1' fp);                         strcpy(tmp' buf);                         tmp[8] = 0;                          if (strcmp(tmp' "APETAGEX"))                         {                             delete Lyrics3;                             return;                         }                          footeroffset = Lyrics3->ExistingOffset();                     }                     else                     {                         return;                     }*/}  }  
Magic Number,IdSharp.Tagging.APEv2,APEv2Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\APEv2\APEv2Tag.cs,Read,The following statement contains a magic number: if (ByteUtils.Compare (buf' _APETAGEX' 8) == false) {  	// skip past possible ID3v1 tag  	footerOffset = 128;  	stream.Seek (-128 - 32' SeekOrigin.End);  	stream.Read (buf' 0' 32);  	if (ByteUtils.Compare (buf' _APETAGEX' 8) == false) {  		return;  		// skip past possible Lyrics3 tag  		// TODO!  		/*CLyrics3* Lyrics3 = new CLyrics3();                     Lyrics3->ReadTag(fp);                     if (Lyrics3->TagString() != "")                     {                         fseek(fp' 0L - Lyrics3->ExistingOffset() - 32' SEEK_END);                         fread(buf' 32' 1' fp);                         strcpy(tmp' buf);                         tmp[8] = 0;                          if (strcmp(tmp' "APETAGEX"))                         {                             delete Lyrics3;                             return;                         }                          footeroffset = Lyrics3->ExistingOffset();                     }                     else                     {                         return;                     }*/}  }  
Magic Number,IdSharp.Tagging.APEv2,APEv2Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\APEv2\APEv2Tag.cs,Read,The following statement contains a magic number: if (ByteUtils.Compare (buf' _APETAGEX' 8) == false) {  	// skip past possible ID3v1 tag  	footerOffset = 128;  	stream.Seek (-128 - 32' SeekOrigin.End);  	stream.Read (buf' 0' 32);  	if (ByteUtils.Compare (buf' _APETAGEX' 8) == false) {  		return;  		// skip past possible Lyrics3 tag  		// TODO!  		/*CLyrics3* Lyrics3 = new CLyrics3();                     Lyrics3->ReadTag(fp);                     if (Lyrics3->TagString() != "")                     {                         fseek(fp' 0L - Lyrics3->ExistingOffset() - 32' SEEK_END);                         fread(buf' 32' 1' fp);                         strcpy(tmp' buf);                         tmp[8] = 0;                          if (strcmp(tmp' "APETAGEX"))                         {                             delete Lyrics3;                             return;                         }                          footeroffset = Lyrics3->ExistingOffset();                     }                     else                     {                         return;                     }*/}  }  
Magic Number,IdSharp.Tagging.APEv2,APEv2Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\APEv2\APEv2Tag.cs,Read,The following statement contains a magic number: if (ByteUtils.Compare (buf' _APETAGEX' 8) == false) {  	// skip past possible ID3v1 tag  	footerOffset = 128;  	stream.Seek (-128 - 32' SeekOrigin.End);  	stream.Read (buf' 0' 32);  	if (ByteUtils.Compare (buf' _APETAGEX' 8) == false) {  		return;  		// skip past possible Lyrics3 tag  		// TODO!  		/*CLyrics3* Lyrics3 = new CLyrics3();                     Lyrics3->ReadTag(fp);                     if (Lyrics3->TagString() != "")                     {                         fseek(fp' 0L - Lyrics3->ExistingOffset() - 32' SEEK_END);                         fread(buf' 32' 1' fp);                         strcpy(tmp' buf);                         tmp[8] = 0;                          if (strcmp(tmp' "APETAGEX"))                         {                             delete Lyrics3;                             return;                         }                          footeroffset = Lyrics3->ExistingOffset();                     }                     else                     {                         return;                     }*/}  }  
Magic Number,IdSharp.Tagging.APEv2,APEv2Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\APEv2\APEv2Tag.cs,Read,The following statement contains a magic number: if (ByteUtils.Compare (buf' _APETAGEX' 8) == false) {  	// skip past possible ID3v1 tag  	footerOffset = 128;  	stream.Seek (-128 - 32' SeekOrigin.End);  	stream.Read (buf' 0' 32);  	if (ByteUtils.Compare (buf' _APETAGEX' 8) == false) {  		return;  		// skip past possible Lyrics3 tag  		// TODO!  		/*CLyrics3* Lyrics3 = new CLyrics3();                     Lyrics3->ReadTag(fp);                     if (Lyrics3->TagString() != "")                     {                         fseek(fp' 0L - Lyrics3->ExistingOffset() - 32' SEEK_END);                         fread(buf' 32' 1' fp);                         strcpy(tmp' buf);                         tmp[8] = 0;                          if (strcmp(tmp' "APETAGEX"))                         {                             delete Lyrics3;                             return;                         }                          footeroffset = Lyrics3->ExistingOffset();                     }                     else                     {                         return;                     }*/}  }  
Magic Number,IdSharp.Tagging.APEv2,APEv2Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\APEv2\APEv2Tag.cs,Read,The following statement contains a magic number: footerOffset = 128;  
Magic Number,IdSharp.Tagging.APEv2,APEv2Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\APEv2\APEv2Tag.cs,Read,The following statement contains a magic number: stream.Seek (-128 - 32' SeekOrigin.End);  
Magic Number,IdSharp.Tagging.APEv2,APEv2Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\APEv2\APEv2Tag.cs,Read,The following statement contains a magic number: stream.Seek (-128 - 32' SeekOrigin.End);  
Magic Number,IdSharp.Tagging.APEv2,APEv2Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\APEv2\APEv2Tag.cs,Read,The following statement contains a magic number: stream.Read (buf' 0' 32);  
Magic Number,IdSharp.Tagging.APEv2,APEv2Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\APEv2\APEv2Tag.cs,Read,The following statement contains a magic number: if (ByteUtils.Compare (buf' _APETAGEX' 8) == false) {  	return;  	// skip past possible Lyrics3 tag  	// TODO!  	/*CLyrics3* Lyrics3 = new CLyrics3();                     Lyrics3->ReadTag(fp);                     if (Lyrics3->TagString() != "")                     {                         fseek(fp' 0L - Lyrics3->ExistingOffset() - 32' SEEK_END);                         fread(buf' 32' 1' fp);                         strcpy(tmp' buf);                         tmp[8] = 0;                          if (strcmp(tmp' "APETAGEX"))                         {                             delete Lyrics3;                             return;                         }                          footeroffset = Lyrics3->ExistingOffset();                     }                     else                     {                         return;                     }*/}  
Magic Number,IdSharp.Tagging.APEv2,APEv2Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\APEv2\APEv2Tag.cs,Read,The following statement contains a magic number: for (int i = 8; i < 12; i++) {  	_version += (buf [i] << ((i - 8) * 8));  }  
Magic Number,IdSharp.Tagging.APEv2,APEv2Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\APEv2\APEv2Tag.cs,Read,The following statement contains a magic number: for (int i = 8; i < 12; i++) {  	_version += (buf [i] << ((i - 8) * 8));  }  
Magic Number,IdSharp.Tagging.APEv2,APEv2Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\APEv2\APEv2Tag.cs,Read,The following statement contains a magic number: for (int i = 8; i < 12; i++) {  	_version += (buf [i] << ((i - 8) * 8));  }  
Magic Number,IdSharp.Tagging.APEv2,APEv2Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\APEv2\APEv2Tag.cs,Read,The following statement contains a magic number: for (int i = 8; i < 12; i++) {  	_version += (buf [i] << ((i - 8) * 8));  }  
Magic Number,IdSharp.Tagging.APEv2,APEv2Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\APEv2\APEv2Tag.cs,Read,The following statement contains a magic number: _version += (buf [i] << ((i - 8) * 8));  
Magic Number,IdSharp.Tagging.APEv2,APEv2Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\APEv2\APEv2Tag.cs,Read,The following statement contains a magic number: _version += (buf [i] << ((i - 8) * 8));  
Magic Number,IdSharp.Tagging.APEv2,APEv2Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\APEv2\APEv2Tag.cs,Read,The following statement contains a magic number: if (_version != 2000 && _version != 1000) {  	_version = 0;  	return;  }  
Magic Number,IdSharp.Tagging.APEv2,APEv2Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\APEv2\APEv2Tag.cs,Read,The following statement contains a magic number: if (_version != 2000 && _version != 1000) {  	_version = 0;  	return;  }  
Magic Number,IdSharp.Tagging.APEv2,APEv2Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\APEv2\APEv2Tag.cs,Read,The following statement contains a magic number: for (int i = 12; i < 16; i++) {  	tagSize += (buf [i] << ((i - 12) * 8));  }  
Magic Number,IdSharp.Tagging.APEv2,APEv2Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\APEv2\APEv2Tag.cs,Read,The following statement contains a magic number: for (int i = 12; i < 16; i++) {  	tagSize += (buf [i] << ((i - 12) * 8));  }  
Magic Number,IdSharp.Tagging.APEv2,APEv2Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\APEv2\APEv2Tag.cs,Read,The following statement contains a magic number: for (int i = 12; i < 16; i++) {  	tagSize += (buf [i] << ((i - 12) * 8));  }  
Magic Number,IdSharp.Tagging.APEv2,APEv2Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\APEv2\APEv2Tag.cs,Read,The following statement contains a magic number: for (int i = 12; i < 16; i++) {  	tagSize += (buf [i] << ((i - 12) * 8));  }  
Magic Number,IdSharp.Tagging.APEv2,APEv2Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\APEv2\APEv2Tag.cs,Read,The following statement contains a magic number: tagSize += (buf [i] << ((i - 12) * 8));  
Magic Number,IdSharp.Tagging.APEv2,APEv2Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\APEv2\APEv2Tag.cs,Read,The following statement contains a magic number: tagSize += (buf [i] << ((i - 12) * 8));  
Magic Number,IdSharp.Tagging.APEv2,APEv2Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\APEv2\APEv2Tag.cs,Read,The following statement contains a magic number: for (int i = 16; i < 20; i++) {  	elements += (buf [i] << ((i - 16) * 8));  }  
Magic Number,IdSharp.Tagging.APEv2,APEv2Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\APEv2\APEv2Tag.cs,Read,The following statement contains a magic number: for (int i = 16; i < 20; i++) {  	elements += (buf [i] << ((i - 16) * 8));  }  
Magic Number,IdSharp.Tagging.APEv2,APEv2Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\APEv2\APEv2Tag.cs,Read,The following statement contains a magic number: for (int i = 16; i < 20; i++) {  	elements += (buf [i] << ((i - 16) * 8));  }  
Magic Number,IdSharp.Tagging.APEv2,APEv2Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\APEv2\APEv2Tag.cs,Read,The following statement contains a magic number: for (int i = 16; i < 20; i++) {  	elements += (buf [i] << ((i - 16) * 8));  }  
Magic Number,IdSharp.Tagging.APEv2,APEv2Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\APEv2\APEv2Tag.cs,Read,The following statement contains a magic number: elements += (buf [i] << ((i - 16) * 8));  
Magic Number,IdSharp.Tagging.APEv2,APEv2Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\APEv2\APEv2Tag.cs,Read,The following statement contains a magic number: elements += (buf [i] << ((i - 16) * 8));  
Magic Number,IdSharp.Tagging.APEv2,APEv2Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\APEv2\APEv2Tag.cs,Read,The following statement contains a magic number: _tagSize = tagSize + (containsHeader ? 32 : 0);  
Magic Number,IdSharp.Tagging.APEv2,APEv2Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\APEv2\APEv2Tag.cs,ReadField,The following statement contains a magic number: stream.Read (buf' 0' 8);  
Magic Number,IdSharp.Tagging.APEv2,APEv2Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\APEv2\APEv2Tag.cs,ReadField,The following statement contains a magic number: for (int i = 0; i < 4; i++) {  	size += (buf [i] << (i * 8));  }  
Magic Number,IdSharp.Tagging.APEv2,APEv2Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\APEv2\APEv2Tag.cs,ReadField,The following statement contains a magic number: for (int i = 0; i < 4; i++) {  	size += (buf [i] << (i * 8));  }  
Magic Number,IdSharp.Tagging.APEv2,APEv2Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\APEv2\APEv2Tag.cs,ReadField,The following statement contains a magic number: size += (buf [i] << (i * 8));  
Magic Number,IdSharp.Tagging.ID3v1,ID3v1Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v1\ID3v1Tag.cs,ID3v1Tag,The following statement contains a magic number: _genreIndex = 12;  
Magic Number,IdSharp.Tagging.ID3v1,ID3v1Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v1\ID3v1Tag.cs,ID3v1Tag,The following statement contains a magic number: _genreIndex = 12;  
Magic Number,IdSharp.Tagging.ID3v1,ID3v1Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v1\ID3v1Tag.cs,ID3v1Tag,The following statement contains a magic number: _genreIndex = 12;  
Magic Number,IdSharp.Tagging.ID3v1,ID3v1Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v1\ID3v1Tag.cs,Read,The following statement contains a magic number: if (stream.Length >= 128) {  	stream.Seek (-128' SeekOrigin.End);  	if (GetString (stream' 3) == "TAG") {  		Title = GetString (stream' 30);  		Artist = GetString (stream' 30);  		Album = GetString (stream' 30);  		Year = GetString (stream' 4);  		// Comment  		byte[] buf = new byte[30];  		stream.Read (buf' 0' 30);  		string comment = GetString (buf);  		// ID3v1.1  		if (buf [28] == 0 && buf [29] != 0) {  			TagVersion = ID3v1TagVersion.ID3v11;  			Comment = GetTrimmedString (comment' 28);  			TrackNumber = buf [29];  		} else {  			TagVersion = ID3v1TagVersion.ID3v10;  			Comment = comment;  			TrackNumber = null;  		}  		int genreIndex = stream.Read1 ();  		if (genreIndex < 0 || genreIndex > 147)  			genreIndex = 12;  		// "Other"  		GenreIndex = genreIndex;  	} else {  		Reset ();  	}  } else {  	Reset ();  }  
Magic Number,IdSharp.Tagging.ID3v1,ID3v1Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v1\ID3v1Tag.cs,Read,The following statement contains a magic number: if (stream.Length >= 128) {  	stream.Seek (-128' SeekOrigin.End);  	if (GetString (stream' 3) == "TAG") {  		Title = GetString (stream' 30);  		Artist = GetString (stream' 30);  		Album = GetString (stream' 30);  		Year = GetString (stream' 4);  		// Comment  		byte[] buf = new byte[30];  		stream.Read (buf' 0' 30);  		string comment = GetString (buf);  		// ID3v1.1  		if (buf [28] == 0 && buf [29] != 0) {  			TagVersion = ID3v1TagVersion.ID3v11;  			Comment = GetTrimmedString (comment' 28);  			TrackNumber = buf [29];  		} else {  			TagVersion = ID3v1TagVersion.ID3v10;  			Comment = comment;  			TrackNumber = null;  		}  		int genreIndex = stream.Read1 ();  		if (genreIndex < 0 || genreIndex > 147)  			genreIndex = 12;  		// "Other"  		GenreIndex = genreIndex;  	} else {  		Reset ();  	}  } else {  	Reset ();  }  
Magic Number,IdSharp.Tagging.ID3v1,ID3v1Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v1\ID3v1Tag.cs,Read,The following statement contains a magic number: if (stream.Length >= 128) {  	stream.Seek (-128' SeekOrigin.End);  	if (GetString (stream' 3) == "TAG") {  		Title = GetString (stream' 30);  		Artist = GetString (stream' 30);  		Album = GetString (stream' 30);  		Year = GetString (stream' 4);  		// Comment  		byte[] buf = new byte[30];  		stream.Read (buf' 0' 30);  		string comment = GetString (buf);  		// ID3v1.1  		if (buf [28] == 0 && buf [29] != 0) {  			TagVersion = ID3v1TagVersion.ID3v11;  			Comment = GetTrimmedString (comment' 28);  			TrackNumber = buf [29];  		} else {  			TagVersion = ID3v1TagVersion.ID3v10;  			Comment = comment;  			TrackNumber = null;  		}  		int genreIndex = stream.Read1 ();  		if (genreIndex < 0 || genreIndex > 147)  			genreIndex = 12;  		// "Other"  		GenreIndex = genreIndex;  	} else {  		Reset ();  	}  } else {  	Reset ();  }  
Magic Number,IdSharp.Tagging.ID3v1,ID3v1Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v1\ID3v1Tag.cs,Read,The following statement contains a magic number: if (stream.Length >= 128) {  	stream.Seek (-128' SeekOrigin.End);  	if (GetString (stream' 3) == "TAG") {  		Title = GetString (stream' 30);  		Artist = GetString (stream' 30);  		Album = GetString (stream' 30);  		Year = GetString (stream' 4);  		// Comment  		byte[] buf = new byte[30];  		stream.Read (buf' 0' 30);  		string comment = GetString (buf);  		// ID3v1.1  		if (buf [28] == 0 && buf [29] != 0) {  			TagVersion = ID3v1TagVersion.ID3v11;  			Comment = GetTrimmedString (comment' 28);  			TrackNumber = buf [29];  		} else {  			TagVersion = ID3v1TagVersion.ID3v10;  			Comment = comment;  			TrackNumber = null;  		}  		int genreIndex = stream.Read1 ();  		if (genreIndex < 0 || genreIndex > 147)  			genreIndex = 12;  		// "Other"  		GenreIndex = genreIndex;  	} else {  		Reset ();  	}  } else {  	Reset ();  }  
Magic Number,IdSharp.Tagging.ID3v1,ID3v1Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v1\ID3v1Tag.cs,Read,The following statement contains a magic number: if (stream.Length >= 128) {  	stream.Seek (-128' SeekOrigin.End);  	if (GetString (stream' 3) == "TAG") {  		Title = GetString (stream' 30);  		Artist = GetString (stream' 30);  		Album = GetString (stream' 30);  		Year = GetString (stream' 4);  		// Comment  		byte[] buf = new byte[30];  		stream.Read (buf' 0' 30);  		string comment = GetString (buf);  		// ID3v1.1  		if (buf [28] == 0 && buf [29] != 0) {  			TagVersion = ID3v1TagVersion.ID3v11;  			Comment = GetTrimmedString (comment' 28);  			TrackNumber = buf [29];  		} else {  			TagVersion = ID3v1TagVersion.ID3v10;  			Comment = comment;  			TrackNumber = null;  		}  		int genreIndex = stream.Read1 ();  		if (genreIndex < 0 || genreIndex > 147)  			genreIndex = 12;  		// "Other"  		GenreIndex = genreIndex;  	} else {  		Reset ();  	}  } else {  	Reset ();  }  
Magic Number,IdSharp.Tagging.ID3v1,ID3v1Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v1\ID3v1Tag.cs,Read,The following statement contains a magic number: if (stream.Length >= 128) {  	stream.Seek (-128' SeekOrigin.End);  	if (GetString (stream' 3) == "TAG") {  		Title = GetString (stream' 30);  		Artist = GetString (stream' 30);  		Album = GetString (stream' 30);  		Year = GetString (stream' 4);  		// Comment  		byte[] buf = new byte[30];  		stream.Read (buf' 0' 30);  		string comment = GetString (buf);  		// ID3v1.1  		if (buf [28] == 0 && buf [29] != 0) {  			TagVersion = ID3v1TagVersion.ID3v11;  			Comment = GetTrimmedString (comment' 28);  			TrackNumber = buf [29];  		} else {  			TagVersion = ID3v1TagVersion.ID3v10;  			Comment = comment;  			TrackNumber = null;  		}  		int genreIndex = stream.Read1 ();  		if (genreIndex < 0 || genreIndex > 147)  			genreIndex = 12;  		// "Other"  		GenreIndex = genreIndex;  	} else {  		Reset ();  	}  } else {  	Reset ();  }  
Magic Number,IdSharp.Tagging.ID3v1,ID3v1Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v1\ID3v1Tag.cs,Read,The following statement contains a magic number: if (stream.Length >= 128) {  	stream.Seek (-128' SeekOrigin.End);  	if (GetString (stream' 3) == "TAG") {  		Title = GetString (stream' 30);  		Artist = GetString (stream' 30);  		Album = GetString (stream' 30);  		Year = GetString (stream' 4);  		// Comment  		byte[] buf = new byte[30];  		stream.Read (buf' 0' 30);  		string comment = GetString (buf);  		// ID3v1.1  		if (buf [28] == 0 && buf [29] != 0) {  			TagVersion = ID3v1TagVersion.ID3v11;  			Comment = GetTrimmedString (comment' 28);  			TrackNumber = buf [29];  		} else {  			TagVersion = ID3v1TagVersion.ID3v10;  			Comment = comment;  			TrackNumber = null;  		}  		int genreIndex = stream.Read1 ();  		if (genreIndex < 0 || genreIndex > 147)  			genreIndex = 12;  		// "Other"  		GenreIndex = genreIndex;  	} else {  		Reset ();  	}  } else {  	Reset ();  }  
Magic Number,IdSharp.Tagging.ID3v1,ID3v1Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v1\ID3v1Tag.cs,Read,The following statement contains a magic number: if (stream.Length >= 128) {  	stream.Seek (-128' SeekOrigin.End);  	if (GetString (stream' 3) == "TAG") {  		Title = GetString (stream' 30);  		Artist = GetString (stream' 30);  		Album = GetString (stream' 30);  		Year = GetString (stream' 4);  		// Comment  		byte[] buf = new byte[30];  		stream.Read (buf' 0' 30);  		string comment = GetString (buf);  		// ID3v1.1  		if (buf [28] == 0 && buf [29] != 0) {  			TagVersion = ID3v1TagVersion.ID3v11;  			Comment = GetTrimmedString (comment' 28);  			TrackNumber = buf [29];  		} else {  			TagVersion = ID3v1TagVersion.ID3v10;  			Comment = comment;  			TrackNumber = null;  		}  		int genreIndex = stream.Read1 ();  		if (genreIndex < 0 || genreIndex > 147)  			genreIndex = 12;  		// "Other"  		GenreIndex = genreIndex;  	} else {  		Reset ();  	}  } else {  	Reset ();  }  
Magic Number,IdSharp.Tagging.ID3v1,ID3v1Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v1\ID3v1Tag.cs,Read,The following statement contains a magic number: if (stream.Length >= 128) {  	stream.Seek (-128' SeekOrigin.End);  	if (GetString (stream' 3) == "TAG") {  		Title = GetString (stream' 30);  		Artist = GetString (stream' 30);  		Album = GetString (stream' 30);  		Year = GetString (stream' 4);  		// Comment  		byte[] buf = new byte[30];  		stream.Read (buf' 0' 30);  		string comment = GetString (buf);  		// ID3v1.1  		if (buf [28] == 0 && buf [29] != 0) {  			TagVersion = ID3v1TagVersion.ID3v11;  			Comment = GetTrimmedString (comment' 28);  			TrackNumber = buf [29];  		} else {  			TagVersion = ID3v1TagVersion.ID3v10;  			Comment = comment;  			TrackNumber = null;  		}  		int genreIndex = stream.Read1 ();  		if (genreIndex < 0 || genreIndex > 147)  			genreIndex = 12;  		// "Other"  		GenreIndex = genreIndex;  	} else {  		Reset ();  	}  } else {  	Reset ();  }  
Magic Number,IdSharp.Tagging.ID3v1,ID3v1Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v1\ID3v1Tag.cs,Read,The following statement contains a magic number: if (stream.Length >= 128) {  	stream.Seek (-128' SeekOrigin.End);  	if (GetString (stream' 3) == "TAG") {  		Title = GetString (stream' 30);  		Artist = GetString (stream' 30);  		Album = GetString (stream' 30);  		Year = GetString (stream' 4);  		// Comment  		byte[] buf = new byte[30];  		stream.Read (buf' 0' 30);  		string comment = GetString (buf);  		// ID3v1.1  		if (buf [28] == 0 && buf [29] != 0) {  			TagVersion = ID3v1TagVersion.ID3v11;  			Comment = GetTrimmedString (comment' 28);  			TrackNumber = buf [29];  		} else {  			TagVersion = ID3v1TagVersion.ID3v10;  			Comment = comment;  			TrackNumber = null;  		}  		int genreIndex = stream.Read1 ();  		if (genreIndex < 0 || genreIndex > 147)  			genreIndex = 12;  		// "Other"  		GenreIndex = genreIndex;  	} else {  		Reset ();  	}  } else {  	Reset ();  }  
Magic Number,IdSharp.Tagging.ID3v1,ID3v1Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v1\ID3v1Tag.cs,Read,The following statement contains a magic number: if (stream.Length >= 128) {  	stream.Seek (-128' SeekOrigin.End);  	if (GetString (stream' 3) == "TAG") {  		Title = GetString (stream' 30);  		Artist = GetString (stream' 30);  		Album = GetString (stream' 30);  		Year = GetString (stream' 4);  		// Comment  		byte[] buf = new byte[30];  		stream.Read (buf' 0' 30);  		string comment = GetString (buf);  		// ID3v1.1  		if (buf [28] == 0 && buf [29] != 0) {  			TagVersion = ID3v1TagVersion.ID3v11;  			Comment = GetTrimmedString (comment' 28);  			TrackNumber = buf [29];  		} else {  			TagVersion = ID3v1TagVersion.ID3v10;  			Comment = comment;  			TrackNumber = null;  		}  		int genreIndex = stream.Read1 ();  		if (genreIndex < 0 || genreIndex > 147)  			genreIndex = 12;  		// "Other"  		GenreIndex = genreIndex;  	} else {  		Reset ();  	}  } else {  	Reset ();  }  
Magic Number,IdSharp.Tagging.ID3v1,ID3v1Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v1\ID3v1Tag.cs,Read,The following statement contains a magic number: if (stream.Length >= 128) {  	stream.Seek (-128' SeekOrigin.End);  	if (GetString (stream' 3) == "TAG") {  		Title = GetString (stream' 30);  		Artist = GetString (stream' 30);  		Album = GetString (stream' 30);  		Year = GetString (stream' 4);  		// Comment  		byte[] buf = new byte[30];  		stream.Read (buf' 0' 30);  		string comment = GetString (buf);  		// ID3v1.1  		if (buf [28] == 0 && buf [29] != 0) {  			TagVersion = ID3v1TagVersion.ID3v11;  			Comment = GetTrimmedString (comment' 28);  			TrackNumber = buf [29];  		} else {  			TagVersion = ID3v1TagVersion.ID3v10;  			Comment = comment;  			TrackNumber = null;  		}  		int genreIndex = stream.Read1 ();  		if (genreIndex < 0 || genreIndex > 147)  			genreIndex = 12;  		// "Other"  		GenreIndex = genreIndex;  	} else {  		Reset ();  	}  } else {  	Reset ();  }  
Magic Number,IdSharp.Tagging.ID3v1,ID3v1Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v1\ID3v1Tag.cs,Read,The following statement contains a magic number: if (stream.Length >= 128) {  	stream.Seek (-128' SeekOrigin.End);  	if (GetString (stream' 3) == "TAG") {  		Title = GetString (stream' 30);  		Artist = GetString (stream' 30);  		Album = GetString (stream' 30);  		Year = GetString (stream' 4);  		// Comment  		byte[] buf = new byte[30];  		stream.Read (buf' 0' 30);  		string comment = GetString (buf);  		// ID3v1.1  		if (buf [28] == 0 && buf [29] != 0) {  			TagVersion = ID3v1TagVersion.ID3v11;  			Comment = GetTrimmedString (comment' 28);  			TrackNumber = buf [29];  		} else {  			TagVersion = ID3v1TagVersion.ID3v10;  			Comment = comment;  			TrackNumber = null;  		}  		int genreIndex = stream.Read1 ();  		if (genreIndex < 0 || genreIndex > 147)  			genreIndex = 12;  		// "Other"  		GenreIndex = genreIndex;  	} else {  		Reset ();  	}  } else {  	Reset ();  }  
Magic Number,IdSharp.Tagging.ID3v1,ID3v1Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v1\ID3v1Tag.cs,Read,The following statement contains a magic number: if (stream.Length >= 128) {  	stream.Seek (-128' SeekOrigin.End);  	if (GetString (stream' 3) == "TAG") {  		Title = GetString (stream' 30);  		Artist = GetString (stream' 30);  		Album = GetString (stream' 30);  		Year = GetString (stream' 4);  		// Comment  		byte[] buf = new byte[30];  		stream.Read (buf' 0' 30);  		string comment = GetString (buf);  		// ID3v1.1  		if (buf [28] == 0 && buf [29] != 0) {  			TagVersion = ID3v1TagVersion.ID3v11;  			Comment = GetTrimmedString (comment' 28);  			TrackNumber = buf [29];  		} else {  			TagVersion = ID3v1TagVersion.ID3v10;  			Comment = comment;  			TrackNumber = null;  		}  		int genreIndex = stream.Read1 ();  		if (genreIndex < 0 || genreIndex > 147)  			genreIndex = 12;  		// "Other"  		GenreIndex = genreIndex;  	} else {  		Reset ();  	}  } else {  	Reset ();  }  
Magic Number,IdSharp.Tagging.ID3v1,ID3v1Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v1\ID3v1Tag.cs,Read,The following statement contains a magic number: if (stream.Length >= 128) {  	stream.Seek (-128' SeekOrigin.End);  	if (GetString (stream' 3) == "TAG") {  		Title = GetString (stream' 30);  		Artist = GetString (stream' 30);  		Album = GetString (stream' 30);  		Year = GetString (stream' 4);  		// Comment  		byte[] buf = new byte[30];  		stream.Read (buf' 0' 30);  		string comment = GetString (buf);  		// ID3v1.1  		if (buf [28] == 0 && buf [29] != 0) {  			TagVersion = ID3v1TagVersion.ID3v11;  			Comment = GetTrimmedString (comment' 28);  			TrackNumber = buf [29];  		} else {  			TagVersion = ID3v1TagVersion.ID3v10;  			Comment = comment;  			TrackNumber = null;  		}  		int genreIndex = stream.Read1 ();  		if (genreIndex < 0 || genreIndex > 147)  			genreIndex = 12;  		// "Other"  		GenreIndex = genreIndex;  	} else {  		Reset ();  	}  } else {  	Reset ();  }  
Magic Number,IdSharp.Tagging.ID3v1,ID3v1Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v1\ID3v1Tag.cs,Read,The following statement contains a magic number: stream.Seek (-128' SeekOrigin.End);  
Magic Number,IdSharp.Tagging.ID3v1,ID3v1Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v1\ID3v1Tag.cs,Read,The following statement contains a magic number: if (GetString (stream' 3) == "TAG") {  	Title = GetString (stream' 30);  	Artist = GetString (stream' 30);  	Album = GetString (stream' 30);  	Year = GetString (stream' 4);  	// Comment  	byte[] buf = new byte[30];  	stream.Read (buf' 0' 30);  	string comment = GetString (buf);  	// ID3v1.1  	if (buf [28] == 0 && buf [29] != 0) {  		TagVersion = ID3v1TagVersion.ID3v11;  		Comment = GetTrimmedString (comment' 28);  		TrackNumber = buf [29];  	} else {  		TagVersion = ID3v1TagVersion.ID3v10;  		Comment = comment;  		TrackNumber = null;  	}  	int genreIndex = stream.Read1 ();  	if (genreIndex < 0 || genreIndex > 147)  		genreIndex = 12;  	// "Other"  	GenreIndex = genreIndex;  } else {  	Reset ();  }  
Magic Number,IdSharp.Tagging.ID3v1,ID3v1Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v1\ID3v1Tag.cs,Read,The following statement contains a magic number: if (GetString (stream' 3) == "TAG") {  	Title = GetString (stream' 30);  	Artist = GetString (stream' 30);  	Album = GetString (stream' 30);  	Year = GetString (stream' 4);  	// Comment  	byte[] buf = new byte[30];  	stream.Read (buf' 0' 30);  	string comment = GetString (buf);  	// ID3v1.1  	if (buf [28] == 0 && buf [29] != 0) {  		TagVersion = ID3v1TagVersion.ID3v11;  		Comment = GetTrimmedString (comment' 28);  		TrackNumber = buf [29];  	} else {  		TagVersion = ID3v1TagVersion.ID3v10;  		Comment = comment;  		TrackNumber = null;  	}  	int genreIndex = stream.Read1 ();  	if (genreIndex < 0 || genreIndex > 147)  		genreIndex = 12;  	// "Other"  	GenreIndex = genreIndex;  } else {  	Reset ();  }  
Magic Number,IdSharp.Tagging.ID3v1,ID3v1Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v1\ID3v1Tag.cs,Read,The following statement contains a magic number: if (GetString (stream' 3) == "TAG") {  	Title = GetString (stream' 30);  	Artist = GetString (stream' 30);  	Album = GetString (stream' 30);  	Year = GetString (stream' 4);  	// Comment  	byte[] buf = new byte[30];  	stream.Read (buf' 0' 30);  	string comment = GetString (buf);  	// ID3v1.1  	if (buf [28] == 0 && buf [29] != 0) {  		TagVersion = ID3v1TagVersion.ID3v11;  		Comment = GetTrimmedString (comment' 28);  		TrackNumber = buf [29];  	} else {  		TagVersion = ID3v1TagVersion.ID3v10;  		Comment = comment;  		TrackNumber = null;  	}  	int genreIndex = stream.Read1 ();  	if (genreIndex < 0 || genreIndex > 147)  		genreIndex = 12;  	// "Other"  	GenreIndex = genreIndex;  } else {  	Reset ();  }  
Magic Number,IdSharp.Tagging.ID3v1,ID3v1Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v1\ID3v1Tag.cs,Read,The following statement contains a magic number: if (GetString (stream' 3) == "TAG") {  	Title = GetString (stream' 30);  	Artist = GetString (stream' 30);  	Album = GetString (stream' 30);  	Year = GetString (stream' 4);  	// Comment  	byte[] buf = new byte[30];  	stream.Read (buf' 0' 30);  	string comment = GetString (buf);  	// ID3v1.1  	if (buf [28] == 0 && buf [29] != 0) {  		TagVersion = ID3v1TagVersion.ID3v11;  		Comment = GetTrimmedString (comment' 28);  		TrackNumber = buf [29];  	} else {  		TagVersion = ID3v1TagVersion.ID3v10;  		Comment = comment;  		TrackNumber = null;  	}  	int genreIndex = stream.Read1 ();  	if (genreIndex < 0 || genreIndex > 147)  		genreIndex = 12;  	// "Other"  	GenreIndex = genreIndex;  } else {  	Reset ();  }  
Magic Number,IdSharp.Tagging.ID3v1,ID3v1Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v1\ID3v1Tag.cs,Read,The following statement contains a magic number: if (GetString (stream' 3) == "TAG") {  	Title = GetString (stream' 30);  	Artist = GetString (stream' 30);  	Album = GetString (stream' 30);  	Year = GetString (stream' 4);  	// Comment  	byte[] buf = new byte[30];  	stream.Read (buf' 0' 30);  	string comment = GetString (buf);  	// ID3v1.1  	if (buf [28] == 0 && buf [29] != 0) {  		TagVersion = ID3v1TagVersion.ID3v11;  		Comment = GetTrimmedString (comment' 28);  		TrackNumber = buf [29];  	} else {  		TagVersion = ID3v1TagVersion.ID3v10;  		Comment = comment;  		TrackNumber = null;  	}  	int genreIndex = stream.Read1 ();  	if (genreIndex < 0 || genreIndex > 147)  		genreIndex = 12;  	// "Other"  	GenreIndex = genreIndex;  } else {  	Reset ();  }  
Magic Number,IdSharp.Tagging.ID3v1,ID3v1Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v1\ID3v1Tag.cs,Read,The following statement contains a magic number: if (GetString (stream' 3) == "TAG") {  	Title = GetString (stream' 30);  	Artist = GetString (stream' 30);  	Album = GetString (stream' 30);  	Year = GetString (stream' 4);  	// Comment  	byte[] buf = new byte[30];  	stream.Read (buf' 0' 30);  	string comment = GetString (buf);  	// ID3v1.1  	if (buf [28] == 0 && buf [29] != 0) {  		TagVersion = ID3v1TagVersion.ID3v11;  		Comment = GetTrimmedString (comment' 28);  		TrackNumber = buf [29];  	} else {  		TagVersion = ID3v1TagVersion.ID3v10;  		Comment = comment;  		TrackNumber = null;  	}  	int genreIndex = stream.Read1 ();  	if (genreIndex < 0 || genreIndex > 147)  		genreIndex = 12;  	// "Other"  	GenreIndex = genreIndex;  } else {  	Reset ();  }  
Magic Number,IdSharp.Tagging.ID3v1,ID3v1Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v1\ID3v1Tag.cs,Read,The following statement contains a magic number: if (GetString (stream' 3) == "TAG") {  	Title = GetString (stream' 30);  	Artist = GetString (stream' 30);  	Album = GetString (stream' 30);  	Year = GetString (stream' 4);  	// Comment  	byte[] buf = new byte[30];  	stream.Read (buf' 0' 30);  	string comment = GetString (buf);  	// ID3v1.1  	if (buf [28] == 0 && buf [29] != 0) {  		TagVersion = ID3v1TagVersion.ID3v11;  		Comment = GetTrimmedString (comment' 28);  		TrackNumber = buf [29];  	} else {  		TagVersion = ID3v1TagVersion.ID3v10;  		Comment = comment;  		TrackNumber = null;  	}  	int genreIndex = stream.Read1 ();  	if (genreIndex < 0 || genreIndex > 147)  		genreIndex = 12;  	// "Other"  	GenreIndex = genreIndex;  } else {  	Reset ();  }  
Magic Number,IdSharp.Tagging.ID3v1,ID3v1Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v1\ID3v1Tag.cs,Read,The following statement contains a magic number: if (GetString (stream' 3) == "TAG") {  	Title = GetString (stream' 30);  	Artist = GetString (stream' 30);  	Album = GetString (stream' 30);  	Year = GetString (stream' 4);  	// Comment  	byte[] buf = new byte[30];  	stream.Read (buf' 0' 30);  	string comment = GetString (buf);  	// ID3v1.1  	if (buf [28] == 0 && buf [29] != 0) {  		TagVersion = ID3v1TagVersion.ID3v11;  		Comment = GetTrimmedString (comment' 28);  		TrackNumber = buf [29];  	} else {  		TagVersion = ID3v1TagVersion.ID3v10;  		Comment = comment;  		TrackNumber = null;  	}  	int genreIndex = stream.Read1 ();  	if (genreIndex < 0 || genreIndex > 147)  		genreIndex = 12;  	// "Other"  	GenreIndex = genreIndex;  } else {  	Reset ();  }  
Magic Number,IdSharp.Tagging.ID3v1,ID3v1Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v1\ID3v1Tag.cs,Read,The following statement contains a magic number: if (GetString (stream' 3) == "TAG") {  	Title = GetString (stream' 30);  	Artist = GetString (stream' 30);  	Album = GetString (stream' 30);  	Year = GetString (stream' 4);  	// Comment  	byte[] buf = new byte[30];  	stream.Read (buf' 0' 30);  	string comment = GetString (buf);  	// ID3v1.1  	if (buf [28] == 0 && buf [29] != 0) {  		TagVersion = ID3v1TagVersion.ID3v11;  		Comment = GetTrimmedString (comment' 28);  		TrackNumber = buf [29];  	} else {  		TagVersion = ID3v1TagVersion.ID3v10;  		Comment = comment;  		TrackNumber = null;  	}  	int genreIndex = stream.Read1 ();  	if (genreIndex < 0 || genreIndex > 147)  		genreIndex = 12;  	// "Other"  	GenreIndex = genreIndex;  } else {  	Reset ();  }  
Magic Number,IdSharp.Tagging.ID3v1,ID3v1Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v1\ID3v1Tag.cs,Read,The following statement contains a magic number: if (GetString (stream' 3) == "TAG") {  	Title = GetString (stream' 30);  	Artist = GetString (stream' 30);  	Album = GetString (stream' 30);  	Year = GetString (stream' 4);  	// Comment  	byte[] buf = new byte[30];  	stream.Read (buf' 0' 30);  	string comment = GetString (buf);  	// ID3v1.1  	if (buf [28] == 0 && buf [29] != 0) {  		TagVersion = ID3v1TagVersion.ID3v11;  		Comment = GetTrimmedString (comment' 28);  		TrackNumber = buf [29];  	} else {  		TagVersion = ID3v1TagVersion.ID3v10;  		Comment = comment;  		TrackNumber = null;  	}  	int genreIndex = stream.Read1 ();  	if (genreIndex < 0 || genreIndex > 147)  		genreIndex = 12;  	// "Other"  	GenreIndex = genreIndex;  } else {  	Reset ();  }  
Magic Number,IdSharp.Tagging.ID3v1,ID3v1Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v1\ID3v1Tag.cs,Read,The following statement contains a magic number: if (GetString (stream' 3) == "TAG") {  	Title = GetString (stream' 30);  	Artist = GetString (stream' 30);  	Album = GetString (stream' 30);  	Year = GetString (stream' 4);  	// Comment  	byte[] buf = new byte[30];  	stream.Read (buf' 0' 30);  	string comment = GetString (buf);  	// ID3v1.1  	if (buf [28] == 0 && buf [29] != 0) {  		TagVersion = ID3v1TagVersion.ID3v11;  		Comment = GetTrimmedString (comment' 28);  		TrackNumber = buf [29];  	} else {  		TagVersion = ID3v1TagVersion.ID3v10;  		Comment = comment;  		TrackNumber = null;  	}  	int genreIndex = stream.Read1 ();  	if (genreIndex < 0 || genreIndex > 147)  		genreIndex = 12;  	// "Other"  	GenreIndex = genreIndex;  } else {  	Reset ();  }  
Magic Number,IdSharp.Tagging.ID3v1,ID3v1Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v1\ID3v1Tag.cs,Read,The following statement contains a magic number: if (GetString (stream' 3) == "TAG") {  	Title = GetString (stream' 30);  	Artist = GetString (stream' 30);  	Album = GetString (stream' 30);  	Year = GetString (stream' 4);  	// Comment  	byte[] buf = new byte[30];  	stream.Read (buf' 0' 30);  	string comment = GetString (buf);  	// ID3v1.1  	if (buf [28] == 0 && buf [29] != 0) {  		TagVersion = ID3v1TagVersion.ID3v11;  		Comment = GetTrimmedString (comment' 28);  		TrackNumber = buf [29];  	} else {  		TagVersion = ID3v1TagVersion.ID3v10;  		Comment = comment;  		TrackNumber = null;  	}  	int genreIndex = stream.Read1 ();  	if (genreIndex < 0 || genreIndex > 147)  		genreIndex = 12;  	// "Other"  	GenreIndex = genreIndex;  } else {  	Reset ();  }  
Magic Number,IdSharp.Tagging.ID3v1,ID3v1Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v1\ID3v1Tag.cs,Read,The following statement contains a magic number: if (GetString (stream' 3) == "TAG") {  	Title = GetString (stream' 30);  	Artist = GetString (stream' 30);  	Album = GetString (stream' 30);  	Year = GetString (stream' 4);  	// Comment  	byte[] buf = new byte[30];  	stream.Read (buf' 0' 30);  	string comment = GetString (buf);  	// ID3v1.1  	if (buf [28] == 0 && buf [29] != 0) {  		TagVersion = ID3v1TagVersion.ID3v11;  		Comment = GetTrimmedString (comment' 28);  		TrackNumber = buf [29];  	} else {  		TagVersion = ID3v1TagVersion.ID3v10;  		Comment = comment;  		TrackNumber = null;  	}  	int genreIndex = stream.Read1 ();  	if (genreIndex < 0 || genreIndex > 147)  		genreIndex = 12;  	// "Other"  	GenreIndex = genreIndex;  } else {  	Reset ();  }  
Magic Number,IdSharp.Tagging.ID3v1,ID3v1Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v1\ID3v1Tag.cs,Read,The following statement contains a magic number: Title = GetString (stream' 30);  
Magic Number,IdSharp.Tagging.ID3v1,ID3v1Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v1\ID3v1Tag.cs,Read,The following statement contains a magic number: Artist = GetString (stream' 30);  
Magic Number,IdSharp.Tagging.ID3v1,ID3v1Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v1\ID3v1Tag.cs,Read,The following statement contains a magic number: Album = GetString (stream' 30);  
Magic Number,IdSharp.Tagging.ID3v1,ID3v1Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v1\ID3v1Tag.cs,Read,The following statement contains a magic number: Year = GetString (stream' 4);  
Magic Number,IdSharp.Tagging.ID3v1,ID3v1Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v1\ID3v1Tag.cs,Read,The following statement contains a magic number: stream.Read (buf' 0' 30);  
Magic Number,IdSharp.Tagging.ID3v1,ID3v1Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v1\ID3v1Tag.cs,Read,The following statement contains a magic number: if (buf [28] == 0 && buf [29] != 0) {  	TagVersion = ID3v1TagVersion.ID3v11;  	Comment = GetTrimmedString (comment' 28);  	TrackNumber = buf [29];  } else {  	TagVersion = ID3v1TagVersion.ID3v10;  	Comment = comment;  	TrackNumber = null;  }  
Magic Number,IdSharp.Tagging.ID3v1,ID3v1Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v1\ID3v1Tag.cs,Read,The following statement contains a magic number: if (buf [28] == 0 && buf [29] != 0) {  	TagVersion = ID3v1TagVersion.ID3v11;  	Comment = GetTrimmedString (comment' 28);  	TrackNumber = buf [29];  } else {  	TagVersion = ID3v1TagVersion.ID3v10;  	Comment = comment;  	TrackNumber = null;  }  
Magic Number,IdSharp.Tagging.ID3v1,ID3v1Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v1\ID3v1Tag.cs,Read,The following statement contains a magic number: if (buf [28] == 0 && buf [29] != 0) {  	TagVersion = ID3v1TagVersion.ID3v11;  	Comment = GetTrimmedString (comment' 28);  	TrackNumber = buf [29];  } else {  	TagVersion = ID3v1TagVersion.ID3v10;  	Comment = comment;  	TrackNumber = null;  }  
Magic Number,IdSharp.Tagging.ID3v1,ID3v1Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v1\ID3v1Tag.cs,Read,The following statement contains a magic number: if (buf [28] == 0 && buf [29] != 0) {  	TagVersion = ID3v1TagVersion.ID3v11;  	Comment = GetTrimmedString (comment' 28);  	TrackNumber = buf [29];  } else {  	TagVersion = ID3v1TagVersion.ID3v10;  	Comment = comment;  	TrackNumber = null;  }  
Magic Number,IdSharp.Tagging.ID3v1,ID3v1Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v1\ID3v1Tag.cs,Read,The following statement contains a magic number: Comment = GetTrimmedString (comment' 28);  
Magic Number,IdSharp.Tagging.ID3v1,ID3v1Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v1\ID3v1Tag.cs,Read,The following statement contains a magic number: TrackNumber = buf [29];  
Magic Number,IdSharp.Tagging.ID3v1,ID3v1Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v1\ID3v1Tag.cs,Read,The following statement contains a magic number: if (genreIndex < 0 || genreIndex > 147)  	genreIndex = 12;  
Magic Number,IdSharp.Tagging.ID3v1,ID3v1Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v1\ID3v1Tag.cs,Read,The following statement contains a magic number: if (genreIndex < 0 || genreIndex > 147)  	genreIndex = 12;  
Magic Number,IdSharp.Tagging.ID3v1,ID3v1Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v1\ID3v1Tag.cs,Read,The following statement contains a magic number: genreIndex = 12;  
Magic Number,IdSharp.Tagging.ID3v1,ID3v1Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v1\ID3v1Tag.cs,Reset,The following statement contains a magic number: GenreIndex = 12;  
Magic Number,IdSharp.Tagging.ID3v1,ID3v1Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v1\ID3v1Tag.cs,Save,The following statement contains a magic number: using (FileStream fileStream = File.Open (path' FileMode.Open' FileAccess.ReadWrite' FileShare.None)) {  	fileStream.Seek (0 - GetTagSize (fileStream)' SeekOrigin.End);  	byte[] titleBytes = SafeGetBytes (_title);  	byte[] artistBytes = SafeGetBytes (_artist);  	byte[] albumBytes = SafeGetBytes (_album);  	byte[] yearBytes = SafeGetBytes (_year);  	byte[] commentBytes;  	fileStream.Write (Encoding.ASCII.GetBytes ("TAG"));  	WriteBytesPadded (fileStream' titleBytes' 30);  	WriteBytesPadded (fileStream' artistBytes' 30);  	WriteBytesPadded (fileStream' albumBytes' 30);  	WriteBytesPadded (fileStream' yearBytes' 4);  	if (_tagVersion == ID3v1TagVersion.ID3v11) {  		commentBytes = SafeGetBytes (_comment);  		WriteBytesPadded (fileStream' commentBytes' 28);  		fileStream.WriteByte (0);  		fileStream.WriteByte ((byte)(_trackNumber ?? 0));  	} else {  		commentBytes = SafeGetBytes (_comment);  		WriteBytesPadded (fileStream' commentBytes' 30);  	}  	fileStream.WriteByte ((byte)_genreIndex);  }  
Magic Number,IdSharp.Tagging.ID3v1,ID3v1Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v1\ID3v1Tag.cs,Save,The following statement contains a magic number: using (FileStream fileStream = File.Open (path' FileMode.Open' FileAccess.ReadWrite' FileShare.None)) {  	fileStream.Seek (0 - GetTagSize (fileStream)' SeekOrigin.End);  	byte[] titleBytes = SafeGetBytes (_title);  	byte[] artistBytes = SafeGetBytes (_artist);  	byte[] albumBytes = SafeGetBytes (_album);  	byte[] yearBytes = SafeGetBytes (_year);  	byte[] commentBytes;  	fileStream.Write (Encoding.ASCII.GetBytes ("TAG"));  	WriteBytesPadded (fileStream' titleBytes' 30);  	WriteBytesPadded (fileStream' artistBytes' 30);  	WriteBytesPadded (fileStream' albumBytes' 30);  	WriteBytesPadded (fileStream' yearBytes' 4);  	if (_tagVersion == ID3v1TagVersion.ID3v11) {  		commentBytes = SafeGetBytes (_comment);  		WriteBytesPadded (fileStream' commentBytes' 28);  		fileStream.WriteByte (0);  		fileStream.WriteByte ((byte)(_trackNumber ?? 0));  	} else {  		commentBytes = SafeGetBytes (_comment);  		WriteBytesPadded (fileStream' commentBytes' 30);  	}  	fileStream.WriteByte ((byte)_genreIndex);  }  
Magic Number,IdSharp.Tagging.ID3v1,ID3v1Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v1\ID3v1Tag.cs,Save,The following statement contains a magic number: using (FileStream fileStream = File.Open (path' FileMode.Open' FileAccess.ReadWrite' FileShare.None)) {  	fileStream.Seek (0 - GetTagSize (fileStream)' SeekOrigin.End);  	byte[] titleBytes = SafeGetBytes (_title);  	byte[] artistBytes = SafeGetBytes (_artist);  	byte[] albumBytes = SafeGetBytes (_album);  	byte[] yearBytes = SafeGetBytes (_year);  	byte[] commentBytes;  	fileStream.Write (Encoding.ASCII.GetBytes ("TAG"));  	WriteBytesPadded (fileStream' titleBytes' 30);  	WriteBytesPadded (fileStream' artistBytes' 30);  	WriteBytesPadded (fileStream' albumBytes' 30);  	WriteBytesPadded (fileStream' yearBytes' 4);  	if (_tagVersion == ID3v1TagVersion.ID3v11) {  		commentBytes = SafeGetBytes (_comment);  		WriteBytesPadded (fileStream' commentBytes' 28);  		fileStream.WriteByte (0);  		fileStream.WriteByte ((byte)(_trackNumber ?? 0));  	} else {  		commentBytes = SafeGetBytes (_comment);  		WriteBytesPadded (fileStream' commentBytes' 30);  	}  	fileStream.WriteByte ((byte)_genreIndex);  }  
Magic Number,IdSharp.Tagging.ID3v1,ID3v1Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v1\ID3v1Tag.cs,Save,The following statement contains a magic number: using (FileStream fileStream = File.Open (path' FileMode.Open' FileAccess.ReadWrite' FileShare.None)) {  	fileStream.Seek (0 - GetTagSize (fileStream)' SeekOrigin.End);  	byte[] titleBytes = SafeGetBytes (_title);  	byte[] artistBytes = SafeGetBytes (_artist);  	byte[] albumBytes = SafeGetBytes (_album);  	byte[] yearBytes = SafeGetBytes (_year);  	byte[] commentBytes;  	fileStream.Write (Encoding.ASCII.GetBytes ("TAG"));  	WriteBytesPadded (fileStream' titleBytes' 30);  	WriteBytesPadded (fileStream' artistBytes' 30);  	WriteBytesPadded (fileStream' albumBytes' 30);  	WriteBytesPadded (fileStream' yearBytes' 4);  	if (_tagVersion == ID3v1TagVersion.ID3v11) {  		commentBytes = SafeGetBytes (_comment);  		WriteBytesPadded (fileStream' commentBytes' 28);  		fileStream.WriteByte (0);  		fileStream.WriteByte ((byte)(_trackNumber ?? 0));  	} else {  		commentBytes = SafeGetBytes (_comment);  		WriteBytesPadded (fileStream' commentBytes' 30);  	}  	fileStream.WriteByte ((byte)_genreIndex);  }  
Magic Number,IdSharp.Tagging.ID3v1,ID3v1Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v1\ID3v1Tag.cs,Save,The following statement contains a magic number: using (FileStream fileStream = File.Open (path' FileMode.Open' FileAccess.ReadWrite' FileShare.None)) {  	fileStream.Seek (0 - GetTagSize (fileStream)' SeekOrigin.End);  	byte[] titleBytes = SafeGetBytes (_title);  	byte[] artistBytes = SafeGetBytes (_artist);  	byte[] albumBytes = SafeGetBytes (_album);  	byte[] yearBytes = SafeGetBytes (_year);  	byte[] commentBytes;  	fileStream.Write (Encoding.ASCII.GetBytes ("TAG"));  	WriteBytesPadded (fileStream' titleBytes' 30);  	WriteBytesPadded (fileStream' artistBytes' 30);  	WriteBytesPadded (fileStream' albumBytes' 30);  	WriteBytesPadded (fileStream' yearBytes' 4);  	if (_tagVersion == ID3v1TagVersion.ID3v11) {  		commentBytes = SafeGetBytes (_comment);  		WriteBytesPadded (fileStream' commentBytes' 28);  		fileStream.WriteByte (0);  		fileStream.WriteByte ((byte)(_trackNumber ?? 0));  	} else {  		commentBytes = SafeGetBytes (_comment);  		WriteBytesPadded (fileStream' commentBytes' 30);  	}  	fileStream.WriteByte ((byte)_genreIndex);  }  
Magic Number,IdSharp.Tagging.ID3v1,ID3v1Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v1\ID3v1Tag.cs,Save,The following statement contains a magic number: using (FileStream fileStream = File.Open (path' FileMode.Open' FileAccess.ReadWrite' FileShare.None)) {  	fileStream.Seek (0 - GetTagSize (fileStream)' SeekOrigin.End);  	byte[] titleBytes = SafeGetBytes (_title);  	byte[] artistBytes = SafeGetBytes (_artist);  	byte[] albumBytes = SafeGetBytes (_album);  	byte[] yearBytes = SafeGetBytes (_year);  	byte[] commentBytes;  	fileStream.Write (Encoding.ASCII.GetBytes ("TAG"));  	WriteBytesPadded (fileStream' titleBytes' 30);  	WriteBytesPadded (fileStream' artistBytes' 30);  	WriteBytesPadded (fileStream' albumBytes' 30);  	WriteBytesPadded (fileStream' yearBytes' 4);  	if (_tagVersion == ID3v1TagVersion.ID3v11) {  		commentBytes = SafeGetBytes (_comment);  		WriteBytesPadded (fileStream' commentBytes' 28);  		fileStream.WriteByte (0);  		fileStream.WriteByte ((byte)(_trackNumber ?? 0));  	} else {  		commentBytes = SafeGetBytes (_comment);  		WriteBytesPadded (fileStream' commentBytes' 30);  	}  	fileStream.WriteByte ((byte)_genreIndex);  }  
Magic Number,IdSharp.Tagging.ID3v1,ID3v1Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v1\ID3v1Tag.cs,Save,The following statement contains a magic number: WriteBytesPadded (fileStream' titleBytes' 30);  
Magic Number,IdSharp.Tagging.ID3v1,ID3v1Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v1\ID3v1Tag.cs,Save,The following statement contains a magic number: WriteBytesPadded (fileStream' artistBytes' 30);  
Magic Number,IdSharp.Tagging.ID3v1,ID3v1Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v1\ID3v1Tag.cs,Save,The following statement contains a magic number: WriteBytesPadded (fileStream' albumBytes' 30);  
Magic Number,IdSharp.Tagging.ID3v1,ID3v1Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v1\ID3v1Tag.cs,Save,The following statement contains a magic number: WriteBytesPadded (fileStream' yearBytes' 4);  
Magic Number,IdSharp.Tagging.ID3v1,ID3v1Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v1\ID3v1Tag.cs,Save,The following statement contains a magic number: if (_tagVersion == ID3v1TagVersion.ID3v11) {  	commentBytes = SafeGetBytes (_comment);  	WriteBytesPadded (fileStream' commentBytes' 28);  	fileStream.WriteByte (0);  	fileStream.WriteByte ((byte)(_trackNumber ?? 0));  } else {  	commentBytes = SafeGetBytes (_comment);  	WriteBytesPadded (fileStream' commentBytes' 30);  }  
Magic Number,IdSharp.Tagging.ID3v1,ID3v1Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v1\ID3v1Tag.cs,Save,The following statement contains a magic number: if (_tagVersion == ID3v1TagVersion.ID3v11) {  	commentBytes = SafeGetBytes (_comment);  	WriteBytesPadded (fileStream' commentBytes' 28);  	fileStream.WriteByte (0);  	fileStream.WriteByte ((byte)(_trackNumber ?? 0));  } else {  	commentBytes = SafeGetBytes (_comment);  	WriteBytesPadded (fileStream' commentBytes' 30);  }  
Magic Number,IdSharp.Tagging.ID3v1,ID3v1Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v1\ID3v1Tag.cs,Save,The following statement contains a magic number: WriteBytesPadded (fileStream' commentBytes' 28);  
Magic Number,IdSharp.Tagging.ID3v1,ID3v1Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v1\ID3v1Tag.cs,Save,The following statement contains a magic number: WriteBytesPadded (fileStream' commentBytes' 30);  
Magic Number,IdSharp.Tagging.ID3v1,ID3v1Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v1\ID3v1Tag.cs,GetString,The following statement contains a magic number: for (maxLength = byteArray.Length; maxLength > 0; maxLength--) {  	if (byteArray [maxLength - 1] >= 32)  		break;  }  
Magic Number,IdSharp.Tagging.ID3v1,ID3v1Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v1\ID3v1Tag.cs,GetString,The following statement contains a magic number: if (byteArray [maxLength - 1] >= 32)  	break;  
Magic Number,IdSharp.Tagging.ID3v1,ID3v1Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v1\ID3v1Tag.cs,GetTagSize,The following statement contains a magic number: try {  	if (stream.Length >= 128) {  		stream.Seek (-128' SeekOrigin.End);  		byte[] buf = new byte[3];  		stream.Read (buf' 0' 3);  		// Check for 'TAG'  		if (buf [0] == 0x54 && buf [1] == 0x41 && buf [2] == 0x47) {  			return 128;  		}  	}  	return 0;  } finally {  	stream.Position = currentPosition;  }  
Magic Number,IdSharp.Tagging.ID3v1,ID3v1Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v1\ID3v1Tag.cs,GetTagSize,The following statement contains a magic number: try {  	if (stream.Length >= 128) {  		stream.Seek (-128' SeekOrigin.End);  		byte[] buf = new byte[3];  		stream.Read (buf' 0' 3);  		// Check for 'TAG'  		if (buf [0] == 0x54 && buf [1] == 0x41 && buf [2] == 0x47) {  			return 128;  		}  	}  	return 0;  } finally {  	stream.Position = currentPosition;  }  
Magic Number,IdSharp.Tagging.ID3v1,ID3v1Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v1\ID3v1Tag.cs,GetTagSize,The following statement contains a magic number: try {  	if (stream.Length >= 128) {  		stream.Seek (-128' SeekOrigin.End);  		byte[] buf = new byte[3];  		stream.Read (buf' 0' 3);  		// Check for 'TAG'  		if (buf [0] == 0x54 && buf [1] == 0x41 && buf [2] == 0x47) {  			return 128;  		}  	}  	return 0;  } finally {  	stream.Position = currentPosition;  }  
Magic Number,IdSharp.Tagging.ID3v1,ID3v1Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v1\ID3v1Tag.cs,GetTagSize,The following statement contains a magic number: try {  	if (stream.Length >= 128) {  		stream.Seek (-128' SeekOrigin.End);  		byte[] buf = new byte[3];  		stream.Read (buf' 0' 3);  		// Check for 'TAG'  		if (buf [0] == 0x54 && buf [1] == 0x41 && buf [2] == 0x47) {  			return 128;  		}  	}  	return 0;  } finally {  	stream.Position = currentPosition;  }  
Magic Number,IdSharp.Tagging.ID3v1,ID3v1Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v1\ID3v1Tag.cs,GetTagSize,The following statement contains a magic number: try {  	if (stream.Length >= 128) {  		stream.Seek (-128' SeekOrigin.End);  		byte[] buf = new byte[3];  		stream.Read (buf' 0' 3);  		// Check for 'TAG'  		if (buf [0] == 0x54 && buf [1] == 0x41 && buf [2] == 0x47) {  			return 128;  		}  	}  	return 0;  } finally {  	stream.Position = currentPosition;  }  
Magic Number,IdSharp.Tagging.ID3v1,ID3v1Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v1\ID3v1Tag.cs,GetTagSize,The following statement contains a magic number: try {  	if (stream.Length >= 128) {  		stream.Seek (-128' SeekOrigin.End);  		byte[] buf = new byte[3];  		stream.Read (buf' 0' 3);  		// Check for 'TAG'  		if (buf [0] == 0x54 && buf [1] == 0x41 && buf [2] == 0x47) {  			return 128;  		}  	}  	return 0;  } finally {  	stream.Position = currentPosition;  }  
Magic Number,IdSharp.Tagging.ID3v1,ID3v1Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v1\ID3v1Tag.cs,GetTagSize,The following statement contains a magic number: if (stream.Length >= 128) {  	stream.Seek (-128' SeekOrigin.End);  	byte[] buf = new byte[3];  	stream.Read (buf' 0' 3);  	// Check for 'TAG'  	if (buf [0] == 0x54 && buf [1] == 0x41 && buf [2] == 0x47) {  		return 128;  	}  }  
Magic Number,IdSharp.Tagging.ID3v1,ID3v1Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v1\ID3v1Tag.cs,GetTagSize,The following statement contains a magic number: if (stream.Length >= 128) {  	stream.Seek (-128' SeekOrigin.End);  	byte[] buf = new byte[3];  	stream.Read (buf' 0' 3);  	// Check for 'TAG'  	if (buf [0] == 0x54 && buf [1] == 0x41 && buf [2] == 0x47) {  		return 128;  	}  }  
Magic Number,IdSharp.Tagging.ID3v1,ID3v1Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v1\ID3v1Tag.cs,GetTagSize,The following statement contains a magic number: if (stream.Length >= 128) {  	stream.Seek (-128' SeekOrigin.End);  	byte[] buf = new byte[3];  	stream.Read (buf' 0' 3);  	// Check for 'TAG'  	if (buf [0] == 0x54 && buf [1] == 0x41 && buf [2] == 0x47) {  		return 128;  	}  }  
Magic Number,IdSharp.Tagging.ID3v1,ID3v1Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v1\ID3v1Tag.cs,GetTagSize,The following statement contains a magic number: if (stream.Length >= 128) {  	stream.Seek (-128' SeekOrigin.End);  	byte[] buf = new byte[3];  	stream.Read (buf' 0' 3);  	// Check for 'TAG'  	if (buf [0] == 0x54 && buf [1] == 0x41 && buf [2] == 0x47) {  		return 128;  	}  }  
Magic Number,IdSharp.Tagging.ID3v1,ID3v1Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v1\ID3v1Tag.cs,GetTagSize,The following statement contains a magic number: if (stream.Length >= 128) {  	stream.Seek (-128' SeekOrigin.End);  	byte[] buf = new byte[3];  	stream.Read (buf' 0' 3);  	// Check for 'TAG'  	if (buf [0] == 0x54 && buf [1] == 0x41 && buf [2] == 0x47) {  		return 128;  	}  }  
Magic Number,IdSharp.Tagging.ID3v1,ID3v1Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v1\ID3v1Tag.cs,GetTagSize,The following statement contains a magic number: if (stream.Length >= 128) {  	stream.Seek (-128' SeekOrigin.End);  	byte[] buf = new byte[3];  	stream.Read (buf' 0' 3);  	// Check for 'TAG'  	if (buf [0] == 0x54 && buf [1] == 0x41 && buf [2] == 0x47) {  		return 128;  	}  }  
Magic Number,IdSharp.Tagging.ID3v1,ID3v1Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v1\ID3v1Tag.cs,GetTagSize,The following statement contains a magic number: stream.Seek (-128' SeekOrigin.End);  
Magic Number,IdSharp.Tagging.ID3v1,ID3v1Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v1\ID3v1Tag.cs,GetTagSize,The following statement contains a magic number: stream.Read (buf' 0' 3);  
Magic Number,IdSharp.Tagging.ID3v1,ID3v1Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v1\ID3v1Tag.cs,GetTagSize,The following statement contains a magic number: if (buf [0] == 0x54 && buf [1] == 0x41 && buf [2] == 0x47) {  	return 128;  }  
Magic Number,IdSharp.Tagging.ID3v1,ID3v1Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v1\ID3v1Tag.cs,GetTagSize,The following statement contains a magic number: if (buf [0] == 0x54 && buf [1] == 0x41 && buf [2] == 0x47) {  	return 128;  }  
Magic Number,IdSharp.Tagging.ID3v1,ID3v1Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v1\ID3v1Tag.cs,GetTagSize,The following statement contains a magic number: return 128;  
Magic Number,IdSharp.Tagging.ID3v1,ID3v1Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v1\ID3v1Tag.cs,RemoveTag,The following statement contains a magic number: using (FileStream fileStream = File.Open (path' FileMode.Open' FileAccess.ReadWrite' FileShare.None)) {  	if (!DoesTagExist (fileStream))  		return false;  	fileStream.SetLength (fileStream.Length - 128);  }  
Magic Number,IdSharp.Tagging.ID3v1,ID3v1Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v1\ID3v1Tag.cs,RemoveTag,The following statement contains a magic number: fileStream.SetLength (fileStream.Length - 128);  
Magic Number,IdSharp.Tagging.ID3v2,FrameContainer,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameContainer.FrameCreation.cs,ValidateRecordingTimestamp,The following statement contains a magic number: if (value != null) {  	// yyyy-MM-dd  	if (value.Length >= 10) {  		// MMdd  		DateRecorded = value.Substring (5' 2) + value.Substring (8' 2);  	} // yyyy-MM  	else if (value.Length >= 7) {  		// MMdd  		DateRecorded = value.Substring (6' 2) + "00";  	} else {  		DateRecorded = null;  	}  	// yyyy-MM-ddTHH:mm  	if (value.Length >= 16) {  		// HHmm  		TimeRecorded = value.Substring (11' 2) + value.Substring (14' 2);  	} // yyyy-MM-ddTHH  	else if (value.Length >= 13) {  		// HHmm  		TimeRecorded = value.Substring (11' 2) + "00";  	} else {  		TimeRecorded = null;  	}  	// yyyy-MM-ddTHH:mm:ss  	if (value.Length >= 19) {  		/* Nowhere to store seconds */}  	// TODO: Fire warnings on invalid data  } else {  	DateRecorded = null;  	TimeRecorded = null;  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameContainer,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameContainer.FrameCreation.cs,ValidateRecordingTimestamp,The following statement contains a magic number: if (value != null) {  	// yyyy-MM-dd  	if (value.Length >= 10) {  		// MMdd  		DateRecorded = value.Substring (5' 2) + value.Substring (8' 2);  	} // yyyy-MM  	else if (value.Length >= 7) {  		// MMdd  		DateRecorded = value.Substring (6' 2) + "00";  	} else {  		DateRecorded = null;  	}  	// yyyy-MM-ddTHH:mm  	if (value.Length >= 16) {  		// HHmm  		TimeRecorded = value.Substring (11' 2) + value.Substring (14' 2);  	} // yyyy-MM-ddTHH  	else if (value.Length >= 13) {  		// HHmm  		TimeRecorded = value.Substring (11' 2) + "00";  	} else {  		TimeRecorded = null;  	}  	// yyyy-MM-ddTHH:mm:ss  	if (value.Length >= 19) {  		/* Nowhere to store seconds */}  	// TODO: Fire warnings on invalid data  } else {  	DateRecorded = null;  	TimeRecorded = null;  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameContainer,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameContainer.FrameCreation.cs,ValidateRecordingTimestamp,The following statement contains a magic number: if (value != null) {  	// yyyy-MM-dd  	if (value.Length >= 10) {  		// MMdd  		DateRecorded = value.Substring (5' 2) + value.Substring (8' 2);  	} // yyyy-MM  	else if (value.Length >= 7) {  		// MMdd  		DateRecorded = value.Substring (6' 2) + "00";  	} else {  		DateRecorded = null;  	}  	// yyyy-MM-ddTHH:mm  	if (value.Length >= 16) {  		// HHmm  		TimeRecorded = value.Substring (11' 2) + value.Substring (14' 2);  	} // yyyy-MM-ddTHH  	else if (value.Length >= 13) {  		// HHmm  		TimeRecorded = value.Substring (11' 2) + "00";  	} else {  		TimeRecorded = null;  	}  	// yyyy-MM-ddTHH:mm:ss  	if (value.Length >= 19) {  		/* Nowhere to store seconds */}  	// TODO: Fire warnings on invalid data  } else {  	DateRecorded = null;  	TimeRecorded = null;  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameContainer,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameContainer.FrameCreation.cs,ValidateRecordingTimestamp,The following statement contains a magic number: if (value != null) {  	// yyyy-MM-dd  	if (value.Length >= 10) {  		// MMdd  		DateRecorded = value.Substring (5' 2) + value.Substring (8' 2);  	} // yyyy-MM  	else if (value.Length >= 7) {  		// MMdd  		DateRecorded = value.Substring (6' 2) + "00";  	} else {  		DateRecorded = null;  	}  	// yyyy-MM-ddTHH:mm  	if (value.Length >= 16) {  		// HHmm  		TimeRecorded = value.Substring (11' 2) + value.Substring (14' 2);  	} // yyyy-MM-ddTHH  	else if (value.Length >= 13) {  		// HHmm  		TimeRecorded = value.Substring (11' 2) + "00";  	} else {  		TimeRecorded = null;  	}  	// yyyy-MM-ddTHH:mm:ss  	if (value.Length >= 19) {  		/* Nowhere to store seconds */}  	// TODO: Fire warnings on invalid data  } else {  	DateRecorded = null;  	TimeRecorded = null;  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameContainer,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameContainer.FrameCreation.cs,ValidateRecordingTimestamp,The following statement contains a magic number: if (value != null) {  	// yyyy-MM-dd  	if (value.Length >= 10) {  		// MMdd  		DateRecorded = value.Substring (5' 2) + value.Substring (8' 2);  	} // yyyy-MM  	else if (value.Length >= 7) {  		// MMdd  		DateRecorded = value.Substring (6' 2) + "00";  	} else {  		DateRecorded = null;  	}  	// yyyy-MM-ddTHH:mm  	if (value.Length >= 16) {  		// HHmm  		TimeRecorded = value.Substring (11' 2) + value.Substring (14' 2);  	} // yyyy-MM-ddTHH  	else if (value.Length >= 13) {  		// HHmm  		TimeRecorded = value.Substring (11' 2) + "00";  	} else {  		TimeRecorded = null;  	}  	// yyyy-MM-ddTHH:mm:ss  	if (value.Length >= 19) {  		/* Nowhere to store seconds */}  	// TODO: Fire warnings on invalid data  } else {  	DateRecorded = null;  	TimeRecorded = null;  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameContainer,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameContainer.FrameCreation.cs,ValidateRecordingTimestamp,The following statement contains a magic number: if (value != null) {  	// yyyy-MM-dd  	if (value.Length >= 10) {  		// MMdd  		DateRecorded = value.Substring (5' 2) + value.Substring (8' 2);  	} // yyyy-MM  	else if (value.Length >= 7) {  		// MMdd  		DateRecorded = value.Substring (6' 2) + "00";  	} else {  		DateRecorded = null;  	}  	// yyyy-MM-ddTHH:mm  	if (value.Length >= 16) {  		// HHmm  		TimeRecorded = value.Substring (11' 2) + value.Substring (14' 2);  	} // yyyy-MM-ddTHH  	else if (value.Length >= 13) {  		// HHmm  		TimeRecorded = value.Substring (11' 2) + "00";  	} else {  		TimeRecorded = null;  	}  	// yyyy-MM-ddTHH:mm:ss  	if (value.Length >= 19) {  		/* Nowhere to store seconds */}  	// TODO: Fire warnings on invalid data  } else {  	DateRecorded = null;  	TimeRecorded = null;  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameContainer,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameContainer.FrameCreation.cs,ValidateRecordingTimestamp,The following statement contains a magic number: if (value != null) {  	// yyyy-MM-dd  	if (value.Length >= 10) {  		// MMdd  		DateRecorded = value.Substring (5' 2) + value.Substring (8' 2);  	} // yyyy-MM  	else if (value.Length >= 7) {  		// MMdd  		DateRecorded = value.Substring (6' 2) + "00";  	} else {  		DateRecorded = null;  	}  	// yyyy-MM-ddTHH:mm  	if (value.Length >= 16) {  		// HHmm  		TimeRecorded = value.Substring (11' 2) + value.Substring (14' 2);  	} // yyyy-MM-ddTHH  	else if (value.Length >= 13) {  		// HHmm  		TimeRecorded = value.Substring (11' 2) + "00";  	} else {  		TimeRecorded = null;  	}  	// yyyy-MM-ddTHH:mm:ss  	if (value.Length >= 19) {  		/* Nowhere to store seconds */}  	// TODO: Fire warnings on invalid data  } else {  	DateRecorded = null;  	TimeRecorded = null;  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameContainer,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameContainer.FrameCreation.cs,ValidateRecordingTimestamp,The following statement contains a magic number: if (value != null) {  	// yyyy-MM-dd  	if (value.Length >= 10) {  		// MMdd  		DateRecorded = value.Substring (5' 2) + value.Substring (8' 2);  	} // yyyy-MM  	else if (value.Length >= 7) {  		// MMdd  		DateRecorded = value.Substring (6' 2) + "00";  	} else {  		DateRecorded = null;  	}  	// yyyy-MM-ddTHH:mm  	if (value.Length >= 16) {  		// HHmm  		TimeRecorded = value.Substring (11' 2) + value.Substring (14' 2);  	} // yyyy-MM-ddTHH  	else if (value.Length >= 13) {  		// HHmm  		TimeRecorded = value.Substring (11' 2) + "00";  	} else {  		TimeRecorded = null;  	}  	// yyyy-MM-ddTHH:mm:ss  	if (value.Length >= 19) {  		/* Nowhere to store seconds */}  	// TODO: Fire warnings on invalid data  } else {  	DateRecorded = null;  	TimeRecorded = null;  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameContainer,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameContainer.FrameCreation.cs,ValidateRecordingTimestamp,The following statement contains a magic number: if (value != null) {  	// yyyy-MM-dd  	if (value.Length >= 10) {  		// MMdd  		DateRecorded = value.Substring (5' 2) + value.Substring (8' 2);  	} // yyyy-MM  	else if (value.Length >= 7) {  		// MMdd  		DateRecorded = value.Substring (6' 2) + "00";  	} else {  		DateRecorded = null;  	}  	// yyyy-MM-ddTHH:mm  	if (value.Length >= 16) {  		// HHmm  		TimeRecorded = value.Substring (11' 2) + value.Substring (14' 2);  	} // yyyy-MM-ddTHH  	else if (value.Length >= 13) {  		// HHmm  		TimeRecorded = value.Substring (11' 2) + "00";  	} else {  		TimeRecorded = null;  	}  	// yyyy-MM-ddTHH:mm:ss  	if (value.Length >= 19) {  		/* Nowhere to store seconds */}  	// TODO: Fire warnings on invalid data  } else {  	DateRecorded = null;  	TimeRecorded = null;  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameContainer,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameContainer.FrameCreation.cs,ValidateRecordingTimestamp,The following statement contains a magic number: if (value != null) {  	// yyyy-MM-dd  	if (value.Length >= 10) {  		// MMdd  		DateRecorded = value.Substring (5' 2) + value.Substring (8' 2);  	} // yyyy-MM  	else if (value.Length >= 7) {  		// MMdd  		DateRecorded = value.Substring (6' 2) + "00";  	} else {  		DateRecorded = null;  	}  	// yyyy-MM-ddTHH:mm  	if (value.Length >= 16) {  		// HHmm  		TimeRecorded = value.Substring (11' 2) + value.Substring (14' 2);  	} // yyyy-MM-ddTHH  	else if (value.Length >= 13) {  		// HHmm  		TimeRecorded = value.Substring (11' 2) + "00";  	} else {  		TimeRecorded = null;  	}  	// yyyy-MM-ddTHH:mm:ss  	if (value.Length >= 19) {  		/* Nowhere to store seconds */}  	// TODO: Fire warnings on invalid data  } else {  	DateRecorded = null;  	TimeRecorded = null;  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameContainer,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameContainer.FrameCreation.cs,ValidateRecordingTimestamp,The following statement contains a magic number: if (value != null) {  	// yyyy-MM-dd  	if (value.Length >= 10) {  		// MMdd  		DateRecorded = value.Substring (5' 2) + value.Substring (8' 2);  	} // yyyy-MM  	else if (value.Length >= 7) {  		// MMdd  		DateRecorded = value.Substring (6' 2) + "00";  	} else {  		DateRecorded = null;  	}  	// yyyy-MM-ddTHH:mm  	if (value.Length >= 16) {  		// HHmm  		TimeRecorded = value.Substring (11' 2) + value.Substring (14' 2);  	} // yyyy-MM-ddTHH  	else if (value.Length >= 13) {  		// HHmm  		TimeRecorded = value.Substring (11' 2) + "00";  	} else {  		TimeRecorded = null;  	}  	// yyyy-MM-ddTHH:mm:ss  	if (value.Length >= 19) {  		/* Nowhere to store seconds */}  	// TODO: Fire warnings on invalid data  } else {  	DateRecorded = null;  	TimeRecorded = null;  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameContainer,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameContainer.FrameCreation.cs,ValidateRecordingTimestamp,The following statement contains a magic number: if (value != null) {  	// yyyy-MM-dd  	if (value.Length >= 10) {  		// MMdd  		DateRecorded = value.Substring (5' 2) + value.Substring (8' 2);  	} // yyyy-MM  	else if (value.Length >= 7) {  		// MMdd  		DateRecorded = value.Substring (6' 2) + "00";  	} else {  		DateRecorded = null;  	}  	// yyyy-MM-ddTHH:mm  	if (value.Length >= 16) {  		// HHmm  		TimeRecorded = value.Substring (11' 2) + value.Substring (14' 2);  	} // yyyy-MM-ddTHH  	else if (value.Length >= 13) {  		// HHmm  		TimeRecorded = value.Substring (11' 2) + "00";  	} else {  		TimeRecorded = null;  	}  	// yyyy-MM-ddTHH:mm:ss  	if (value.Length >= 19) {  		/* Nowhere to store seconds */}  	// TODO: Fire warnings on invalid data  } else {  	DateRecorded = null;  	TimeRecorded = null;  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameContainer,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameContainer.FrameCreation.cs,ValidateRecordingTimestamp,The following statement contains a magic number: if (value != null) {  	// yyyy-MM-dd  	if (value.Length >= 10) {  		// MMdd  		DateRecorded = value.Substring (5' 2) + value.Substring (8' 2);  	} // yyyy-MM  	else if (value.Length >= 7) {  		// MMdd  		DateRecorded = value.Substring (6' 2) + "00";  	} else {  		DateRecorded = null;  	}  	// yyyy-MM-ddTHH:mm  	if (value.Length >= 16) {  		// HHmm  		TimeRecorded = value.Substring (11' 2) + value.Substring (14' 2);  	} // yyyy-MM-ddTHH  	else if (value.Length >= 13) {  		// HHmm  		TimeRecorded = value.Substring (11' 2) + "00";  	} else {  		TimeRecorded = null;  	}  	// yyyy-MM-ddTHH:mm:ss  	if (value.Length >= 19) {  		/* Nowhere to store seconds */}  	// TODO: Fire warnings on invalid data  } else {  	DateRecorded = null;  	TimeRecorded = null;  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameContainer,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameContainer.FrameCreation.cs,ValidateRecordingTimestamp,The following statement contains a magic number: if (value != null) {  	// yyyy-MM-dd  	if (value.Length >= 10) {  		// MMdd  		DateRecorded = value.Substring (5' 2) + value.Substring (8' 2);  	} // yyyy-MM  	else if (value.Length >= 7) {  		// MMdd  		DateRecorded = value.Substring (6' 2) + "00";  	} else {  		DateRecorded = null;  	}  	// yyyy-MM-ddTHH:mm  	if (value.Length >= 16) {  		// HHmm  		TimeRecorded = value.Substring (11' 2) + value.Substring (14' 2);  	} // yyyy-MM-ddTHH  	else if (value.Length >= 13) {  		// HHmm  		TimeRecorded = value.Substring (11' 2) + "00";  	} else {  		TimeRecorded = null;  	}  	// yyyy-MM-ddTHH:mm:ss  	if (value.Length >= 19) {  		/* Nowhere to store seconds */}  	// TODO: Fire warnings on invalid data  } else {  	DateRecorded = null;  	TimeRecorded = null;  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameContainer,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameContainer.FrameCreation.cs,ValidateRecordingTimestamp,The following statement contains a magic number: if (value != null) {  	// yyyy-MM-dd  	if (value.Length >= 10) {  		// MMdd  		DateRecorded = value.Substring (5' 2) + value.Substring (8' 2);  	} // yyyy-MM  	else if (value.Length >= 7) {  		// MMdd  		DateRecorded = value.Substring (6' 2) + "00";  	} else {  		DateRecorded = null;  	}  	// yyyy-MM-ddTHH:mm  	if (value.Length >= 16) {  		// HHmm  		TimeRecorded = value.Substring (11' 2) + value.Substring (14' 2);  	} // yyyy-MM-ddTHH  	else if (value.Length >= 13) {  		// HHmm  		TimeRecorded = value.Substring (11' 2) + "00";  	} else {  		TimeRecorded = null;  	}  	// yyyy-MM-ddTHH:mm:ss  	if (value.Length >= 19) {  		/* Nowhere to store seconds */}  	// TODO: Fire warnings on invalid data  } else {  	DateRecorded = null;  	TimeRecorded = null;  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameContainer,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameContainer.FrameCreation.cs,ValidateRecordingTimestamp,The following statement contains a magic number: if (value != null) {  	// yyyy-MM-dd  	if (value.Length >= 10) {  		// MMdd  		DateRecorded = value.Substring (5' 2) + value.Substring (8' 2);  	} // yyyy-MM  	else if (value.Length >= 7) {  		// MMdd  		DateRecorded = value.Substring (6' 2) + "00";  	} else {  		DateRecorded = null;  	}  	// yyyy-MM-ddTHH:mm  	if (value.Length >= 16) {  		// HHmm  		TimeRecorded = value.Substring (11' 2) + value.Substring (14' 2);  	} // yyyy-MM-ddTHH  	else if (value.Length >= 13) {  		// HHmm  		TimeRecorded = value.Substring (11' 2) + "00";  	} else {  		TimeRecorded = null;  	}  	// yyyy-MM-ddTHH:mm:ss  	if (value.Length >= 19) {  		/* Nowhere to store seconds */}  	// TODO: Fire warnings on invalid data  } else {  	DateRecorded = null;  	TimeRecorded = null;  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameContainer,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameContainer.FrameCreation.cs,ValidateRecordingTimestamp,The following statement contains a magic number: if (value != null) {  	// yyyy-MM-dd  	if (value.Length >= 10) {  		// MMdd  		DateRecorded = value.Substring (5' 2) + value.Substring (8' 2);  	} // yyyy-MM  	else if (value.Length >= 7) {  		// MMdd  		DateRecorded = value.Substring (6' 2) + "00";  	} else {  		DateRecorded = null;  	}  	// yyyy-MM-ddTHH:mm  	if (value.Length >= 16) {  		// HHmm  		TimeRecorded = value.Substring (11' 2) + value.Substring (14' 2);  	} // yyyy-MM-ddTHH  	else if (value.Length >= 13) {  		// HHmm  		TimeRecorded = value.Substring (11' 2) + "00";  	} else {  		TimeRecorded = null;  	}  	// yyyy-MM-ddTHH:mm:ss  	if (value.Length >= 19) {  		/* Nowhere to store seconds */}  	// TODO: Fire warnings on invalid data  } else {  	DateRecorded = null;  	TimeRecorded = null;  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameContainer,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameContainer.FrameCreation.cs,ValidateRecordingTimestamp,The following statement contains a magic number: if (value.Length >= 10) {  	// MMdd  	DateRecorded = value.Substring (5' 2) + value.Substring (8' 2);  } // yyyy-MM  else if (value.Length >= 7) {  	// MMdd  	DateRecorded = value.Substring (6' 2) + "00";  } else {  	DateRecorded = null;  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameContainer,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameContainer.FrameCreation.cs,ValidateRecordingTimestamp,The following statement contains a magic number: if (value.Length >= 10) {  	// MMdd  	DateRecorded = value.Substring (5' 2) + value.Substring (8' 2);  } // yyyy-MM  else if (value.Length >= 7) {  	// MMdd  	DateRecorded = value.Substring (6' 2) + "00";  } else {  	DateRecorded = null;  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameContainer,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameContainer.FrameCreation.cs,ValidateRecordingTimestamp,The following statement contains a magic number: if (value.Length >= 10) {  	// MMdd  	DateRecorded = value.Substring (5' 2) + value.Substring (8' 2);  } // yyyy-MM  else if (value.Length >= 7) {  	// MMdd  	DateRecorded = value.Substring (6' 2) + "00";  } else {  	DateRecorded = null;  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameContainer,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameContainer.FrameCreation.cs,ValidateRecordingTimestamp,The following statement contains a magic number: if (value.Length >= 10) {  	// MMdd  	DateRecorded = value.Substring (5' 2) + value.Substring (8' 2);  } // yyyy-MM  else if (value.Length >= 7) {  	// MMdd  	DateRecorded = value.Substring (6' 2) + "00";  } else {  	DateRecorded = null;  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameContainer,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameContainer.FrameCreation.cs,ValidateRecordingTimestamp,The following statement contains a magic number: if (value.Length >= 10) {  	// MMdd  	DateRecorded = value.Substring (5' 2) + value.Substring (8' 2);  } // yyyy-MM  else if (value.Length >= 7) {  	// MMdd  	DateRecorded = value.Substring (6' 2) + "00";  } else {  	DateRecorded = null;  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameContainer,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameContainer.FrameCreation.cs,ValidateRecordingTimestamp,The following statement contains a magic number: if (value.Length >= 10) {  	// MMdd  	DateRecorded = value.Substring (5' 2) + value.Substring (8' 2);  } // yyyy-MM  else if (value.Length >= 7) {  	// MMdd  	DateRecorded = value.Substring (6' 2) + "00";  } else {  	DateRecorded = null;  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameContainer,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameContainer.FrameCreation.cs,ValidateRecordingTimestamp,The following statement contains a magic number: if (value.Length >= 10) {  	// MMdd  	DateRecorded = value.Substring (5' 2) + value.Substring (8' 2);  } // yyyy-MM  else if (value.Length >= 7) {  	// MMdd  	DateRecorded = value.Substring (6' 2) + "00";  } else {  	DateRecorded = null;  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameContainer,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameContainer.FrameCreation.cs,ValidateRecordingTimestamp,The following statement contains a magic number: if (value.Length >= 10) {  	// MMdd  	DateRecorded = value.Substring (5' 2) + value.Substring (8' 2);  } // yyyy-MM  else if (value.Length >= 7) {  	// MMdd  	DateRecorded = value.Substring (6' 2) + "00";  } else {  	DateRecorded = null;  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameContainer,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameContainer.FrameCreation.cs,ValidateRecordingTimestamp,The following statement contains a magic number: DateRecorded = value.Substring (5' 2) + value.Substring (8' 2);  
Magic Number,IdSharp.Tagging.ID3v2,FrameContainer,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameContainer.FrameCreation.cs,ValidateRecordingTimestamp,The following statement contains a magic number: DateRecorded = value.Substring (5' 2) + value.Substring (8' 2);  
Magic Number,IdSharp.Tagging.ID3v2,FrameContainer,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameContainer.FrameCreation.cs,ValidateRecordingTimestamp,The following statement contains a magic number: DateRecorded = value.Substring (5' 2) + value.Substring (8' 2);  
Magic Number,IdSharp.Tagging.ID3v2,FrameContainer,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameContainer.FrameCreation.cs,ValidateRecordingTimestamp,The following statement contains a magic number: DateRecorded = value.Substring (5' 2) + value.Substring (8' 2);  
Magic Number,IdSharp.Tagging.ID3v2,FrameContainer,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameContainer.FrameCreation.cs,ValidateRecordingTimestamp,The following statement contains a magic number: if (value.Length >= 7) {  	// MMdd  	DateRecorded = value.Substring (6' 2) + "00";  } else {  	DateRecorded = null;  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameContainer,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameContainer.FrameCreation.cs,ValidateRecordingTimestamp,The following statement contains a magic number: if (value.Length >= 7) {  	// MMdd  	DateRecorded = value.Substring (6' 2) + "00";  } else {  	DateRecorded = null;  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameContainer,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameContainer.FrameCreation.cs,ValidateRecordingTimestamp,The following statement contains a magic number: if (value.Length >= 7) {  	// MMdd  	DateRecorded = value.Substring (6' 2) + "00";  } else {  	DateRecorded = null;  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameContainer,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameContainer.FrameCreation.cs,ValidateRecordingTimestamp,The following statement contains a magic number: DateRecorded = value.Substring (6' 2) + "00";  
Magic Number,IdSharp.Tagging.ID3v2,FrameContainer,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameContainer.FrameCreation.cs,ValidateRecordingTimestamp,The following statement contains a magic number: DateRecorded = value.Substring (6' 2) + "00";  
Magic Number,IdSharp.Tagging.ID3v2,FrameContainer,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameContainer.FrameCreation.cs,ValidateRecordingTimestamp,The following statement contains a magic number: if (value.Length >= 16) {  	// HHmm  	TimeRecorded = value.Substring (11' 2) + value.Substring (14' 2);  } // yyyy-MM-ddTHH  else if (value.Length >= 13) {  	// HHmm  	TimeRecorded = value.Substring (11' 2) + "00";  } else {  	TimeRecorded = null;  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameContainer,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameContainer.FrameCreation.cs,ValidateRecordingTimestamp,The following statement contains a magic number: if (value.Length >= 16) {  	// HHmm  	TimeRecorded = value.Substring (11' 2) + value.Substring (14' 2);  } // yyyy-MM-ddTHH  else if (value.Length >= 13) {  	// HHmm  	TimeRecorded = value.Substring (11' 2) + "00";  } else {  	TimeRecorded = null;  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameContainer,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameContainer.FrameCreation.cs,ValidateRecordingTimestamp,The following statement contains a magic number: if (value.Length >= 16) {  	// HHmm  	TimeRecorded = value.Substring (11' 2) + value.Substring (14' 2);  } // yyyy-MM-ddTHH  else if (value.Length >= 13) {  	// HHmm  	TimeRecorded = value.Substring (11' 2) + "00";  } else {  	TimeRecorded = null;  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameContainer,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameContainer.FrameCreation.cs,ValidateRecordingTimestamp,The following statement contains a magic number: if (value.Length >= 16) {  	// HHmm  	TimeRecorded = value.Substring (11' 2) + value.Substring (14' 2);  } // yyyy-MM-ddTHH  else if (value.Length >= 13) {  	// HHmm  	TimeRecorded = value.Substring (11' 2) + "00";  } else {  	TimeRecorded = null;  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameContainer,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameContainer.FrameCreation.cs,ValidateRecordingTimestamp,The following statement contains a magic number: if (value.Length >= 16) {  	// HHmm  	TimeRecorded = value.Substring (11' 2) + value.Substring (14' 2);  } // yyyy-MM-ddTHH  else if (value.Length >= 13) {  	// HHmm  	TimeRecorded = value.Substring (11' 2) + "00";  } else {  	TimeRecorded = null;  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameContainer,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameContainer.FrameCreation.cs,ValidateRecordingTimestamp,The following statement contains a magic number: if (value.Length >= 16) {  	// HHmm  	TimeRecorded = value.Substring (11' 2) + value.Substring (14' 2);  } // yyyy-MM-ddTHH  else if (value.Length >= 13) {  	// HHmm  	TimeRecorded = value.Substring (11' 2) + "00";  } else {  	TimeRecorded = null;  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameContainer,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameContainer.FrameCreation.cs,ValidateRecordingTimestamp,The following statement contains a magic number: if (value.Length >= 16) {  	// HHmm  	TimeRecorded = value.Substring (11' 2) + value.Substring (14' 2);  } // yyyy-MM-ddTHH  else if (value.Length >= 13) {  	// HHmm  	TimeRecorded = value.Substring (11' 2) + "00";  } else {  	TimeRecorded = null;  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameContainer,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameContainer.FrameCreation.cs,ValidateRecordingTimestamp,The following statement contains a magic number: if (value.Length >= 16) {  	// HHmm  	TimeRecorded = value.Substring (11' 2) + value.Substring (14' 2);  } // yyyy-MM-ddTHH  else if (value.Length >= 13) {  	// HHmm  	TimeRecorded = value.Substring (11' 2) + "00";  } else {  	TimeRecorded = null;  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameContainer,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameContainer.FrameCreation.cs,ValidateRecordingTimestamp,The following statement contains a magic number: TimeRecorded = value.Substring (11' 2) + value.Substring (14' 2);  
Magic Number,IdSharp.Tagging.ID3v2,FrameContainer,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameContainer.FrameCreation.cs,ValidateRecordingTimestamp,The following statement contains a magic number: TimeRecorded = value.Substring (11' 2) + value.Substring (14' 2);  
Magic Number,IdSharp.Tagging.ID3v2,FrameContainer,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameContainer.FrameCreation.cs,ValidateRecordingTimestamp,The following statement contains a magic number: TimeRecorded = value.Substring (11' 2) + value.Substring (14' 2);  
Magic Number,IdSharp.Tagging.ID3v2,FrameContainer,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameContainer.FrameCreation.cs,ValidateRecordingTimestamp,The following statement contains a magic number: TimeRecorded = value.Substring (11' 2) + value.Substring (14' 2);  
Magic Number,IdSharp.Tagging.ID3v2,FrameContainer,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameContainer.FrameCreation.cs,ValidateRecordingTimestamp,The following statement contains a magic number: if (value.Length >= 13) {  	// HHmm  	TimeRecorded = value.Substring (11' 2) + "00";  } else {  	TimeRecorded = null;  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameContainer,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameContainer.FrameCreation.cs,ValidateRecordingTimestamp,The following statement contains a magic number: if (value.Length >= 13) {  	// HHmm  	TimeRecorded = value.Substring (11' 2) + "00";  } else {  	TimeRecorded = null;  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameContainer,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameContainer.FrameCreation.cs,ValidateRecordingTimestamp,The following statement contains a magic number: if (value.Length >= 13) {  	// HHmm  	TimeRecorded = value.Substring (11' 2) + "00";  } else {  	TimeRecorded = null;  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameContainer,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameContainer.FrameCreation.cs,ValidateRecordingTimestamp,The following statement contains a magic number: TimeRecorded = value.Substring (11' 2) + "00";  
Magic Number,IdSharp.Tagging.ID3v2,FrameContainer,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameContainer.FrameCreation.cs,ValidateRecordingTimestamp,The following statement contains a magic number: TimeRecorded = value.Substring (11' 2) + "00";  
Magic Number,IdSharp.Tagging.ID3v2,FrameContainer,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameContainer.FrameCreation.cs,ValidateRecordingTimestamp,The following statement contains a magic number: if (value.Length >= 19) {  	/* Nowhere to store seconds */}  
Magic Number,IdSharp.Tagging.ID3v2,FrameContainer,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameContainer.FrameCreation.cs,ValidateReleaseTimestamp,The following statement contains a magic number: if (value != null) {  	// yyyy  	if (value.Length >= 4) {  		Year = value.Substring (0' 4);  	} else {  		Year = null;  	}  	// TODO: Fire warnings on invalid data  } else {  	Year = null;  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameContainer,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameContainer.FrameCreation.cs,ValidateReleaseTimestamp,The following statement contains a magic number: if (value != null) {  	// yyyy  	if (value.Length >= 4) {  		Year = value.Substring (0' 4);  	} else {  		Year = null;  	}  	// TODO: Fire warnings on invalid data  } else {  	Year = null;  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameContainer,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameContainer.FrameCreation.cs,ValidateReleaseTimestamp,The following statement contains a magic number: if (value.Length >= 4) {  	Year = value.Substring (0' 4);  } else {  	Year = null;  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameContainer,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameContainer.FrameCreation.cs,ValidateReleaseTimestamp,The following statement contains a magic number: if (value.Length >= 4) {  	Year = value.Substring (0' 4);  } else {  	Year = null;  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameContainer,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameContainer.FrameCreation.cs,ValidateReleaseTimestamp,The following statement contains a magic number: Year = value.Substring (0' 4);  
Magic Number,IdSharp.Tagging.ID3v2,FrameContainer,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameContainer.FrameCreation.cs,ValidateISRC,The following statement contains a magic number: if (!string.IsNullOrEmpty (value)) {  	if (value.Length != 12) {  		FireWarning ("ISRC"' "ISRC value should be 12 characters in length");  	}  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameContainer,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameContainer.FrameCreation.cs,ValidateISRC,The following statement contains a magic number: if (value.Length != 12) {  	FireWarning ("ISRC"' "ISRC value should be 12 characters in length");  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameContainer,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameContainer.FrameCreation.cs,ValidateFractionValue,The following statement contains a magic number: if (!string.IsNullOrEmpty (value)) {  	bool isValid = true;  	string[] valueArray = value.Split ('/');  	if (valueArray.Length > 2) {  		isValid = false;  	} else {  		int i = 0;  		uint extractedFirstPart = 0;  		uint extractedSecondPart = 0;  		foreach (string tmpValuePart in valueArray) {  			uint tmpIntValue;  			if (!uint.TryParse (tmpValuePart' out tmpIntValue)) {  				isValid = false;  				break;  			} else {  				if (i == 0)  					extractedFirstPart = tmpIntValue;  				else if (i == 1)  					extractedSecondPart = tmpIntValue;  			}  			i++;  		}  		// If first # is 0  		if (extractedFirstPart == 0)  			isValid = false;  		// If ##/## used  		else if (i == 2) {  			// If first partis greater than second part  			if (extractedFirstPart > extractedSecondPart) {  				isValid = false;  			}  		}  	}  	if (isValid == false) {  		FireWarning (propertyName' message);  	}  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameContainer,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameContainer.FrameCreation.cs,ValidateFractionValue,The following statement contains a magic number: if (!string.IsNullOrEmpty (value)) {  	bool isValid = true;  	string[] valueArray = value.Split ('/');  	if (valueArray.Length > 2) {  		isValid = false;  	} else {  		int i = 0;  		uint extractedFirstPart = 0;  		uint extractedSecondPart = 0;  		foreach (string tmpValuePart in valueArray) {  			uint tmpIntValue;  			if (!uint.TryParse (tmpValuePart' out tmpIntValue)) {  				isValid = false;  				break;  			} else {  				if (i == 0)  					extractedFirstPart = tmpIntValue;  				else if (i == 1)  					extractedSecondPart = tmpIntValue;  			}  			i++;  		}  		// If first # is 0  		if (extractedFirstPart == 0)  			isValid = false;  		// If ##/## used  		else if (i == 2) {  			// If first partis greater than second part  			if (extractedFirstPart > extractedSecondPart) {  				isValid = false;  			}  		}  	}  	if (isValid == false) {  		FireWarning (propertyName' message);  	}  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameContainer,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameContainer.FrameCreation.cs,ValidateFractionValue,The following statement contains a magic number: if (valueArray.Length > 2) {  	isValid = false;  } else {  	int i = 0;  	uint extractedFirstPart = 0;  	uint extractedSecondPart = 0;  	foreach (string tmpValuePart in valueArray) {  		uint tmpIntValue;  		if (!uint.TryParse (tmpValuePart' out tmpIntValue)) {  			isValid = false;  			break;  		} else {  			if (i == 0)  				extractedFirstPart = tmpIntValue;  			else if (i == 1)  				extractedSecondPart = tmpIntValue;  		}  		i++;  	}  	// If first # is 0  	if (extractedFirstPart == 0)  		isValid = false;  	// If ##/## used  	else if (i == 2) {  		// If first partis greater than second part  		if (extractedFirstPart > extractedSecondPart) {  			isValid = false;  		}  	}  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameContainer,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameContainer.FrameCreation.cs,ValidateFractionValue,The following statement contains a magic number: if (valueArray.Length > 2) {  	isValid = false;  } else {  	int i = 0;  	uint extractedFirstPart = 0;  	uint extractedSecondPart = 0;  	foreach (string tmpValuePart in valueArray) {  		uint tmpIntValue;  		if (!uint.TryParse (tmpValuePart' out tmpIntValue)) {  			isValid = false;  			break;  		} else {  			if (i == 0)  				extractedFirstPart = tmpIntValue;  			else if (i == 1)  				extractedSecondPart = tmpIntValue;  		}  		i++;  	}  	// If first # is 0  	if (extractedFirstPart == 0)  		isValid = false;  	// If ##/## used  	else if (i == 2) {  		// If first partis greater than second part  		if (extractedFirstPart > extractedSecondPart) {  			isValid = false;  		}  	}  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameContainer,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameContainer.FrameCreation.cs,ValidateFractionValue,The following statement contains a magic number: if (extractedFirstPart == 0)  	isValid = false;  // If ##/## used  else if (i == 2) {  	// If first partis greater than second part  	if (extractedFirstPart > extractedSecondPart) {  		isValid = false;  	}  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameContainer,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameContainer.FrameCreation.cs,ValidateFractionValue,The following statement contains a magic number: if (i == 2) {  	// If first partis greater than second part  	if (extractedFirstPart > extractedSecondPart) {  		isValid = false;  	}  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameContainer,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameContainer.FrameCreation.cs,ValidateCopyright,The following statement contains a magic number: if (!string.IsNullOrEmpty (value)) {  	bool isValid = false;  	if (value.Length >= 6) {  		string yearString = value.Substring (0' 4);  		int year;  		if (int.TryParse (yearString' out year) && year >= 1000 && year <= 9999) {  			if (value [4] == ' ')  				isValid = true;  		}  	}  	if (!isValid) {  		FireWarning ("Copyright"' string.Format ("The copyright field should begin with a year followed by the copyright owner{0}Example: 2007 Sony Records"' Environment.NewLine));  	}  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameContainer,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameContainer.FrameCreation.cs,ValidateCopyright,The following statement contains a magic number: if (!string.IsNullOrEmpty (value)) {  	bool isValid = false;  	if (value.Length >= 6) {  		string yearString = value.Substring (0' 4);  		int year;  		if (int.TryParse (yearString' out year) && year >= 1000 && year <= 9999) {  			if (value [4] == ' ')  				isValid = true;  		}  	}  	if (!isValid) {  		FireWarning ("Copyright"' string.Format ("The copyright field should begin with a year followed by the copyright owner{0}Example: 2007 Sony Records"' Environment.NewLine));  	}  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameContainer,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameContainer.FrameCreation.cs,ValidateCopyright,The following statement contains a magic number: if (!string.IsNullOrEmpty (value)) {  	bool isValid = false;  	if (value.Length >= 6) {  		string yearString = value.Substring (0' 4);  		int year;  		if (int.TryParse (yearString' out year) && year >= 1000 && year <= 9999) {  			if (value [4] == ' ')  				isValid = true;  		}  	}  	if (!isValid) {  		FireWarning ("Copyright"' string.Format ("The copyright field should begin with a year followed by the copyright owner{0}Example: 2007 Sony Records"' Environment.NewLine));  	}  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameContainer,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameContainer.FrameCreation.cs,ValidateCopyright,The following statement contains a magic number: if (!string.IsNullOrEmpty (value)) {  	bool isValid = false;  	if (value.Length >= 6) {  		string yearString = value.Substring (0' 4);  		int year;  		if (int.TryParse (yearString' out year) && year >= 1000 && year <= 9999) {  			if (value [4] == ' ')  				isValid = true;  		}  	}  	if (!isValid) {  		FireWarning ("Copyright"' string.Format ("The copyright field should begin with a year followed by the copyright owner{0}Example: 2007 Sony Records"' Environment.NewLine));  	}  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameContainer,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameContainer.FrameCreation.cs,ValidateCopyright,The following statement contains a magic number: if (!string.IsNullOrEmpty (value)) {  	bool isValid = false;  	if (value.Length >= 6) {  		string yearString = value.Substring (0' 4);  		int year;  		if (int.TryParse (yearString' out year) && year >= 1000 && year <= 9999) {  			if (value [4] == ' ')  				isValid = true;  		}  	}  	if (!isValid) {  		FireWarning ("Copyright"' string.Format ("The copyright field should begin with a year followed by the copyright owner{0}Example: 2007 Sony Records"' Environment.NewLine));  	}  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameContainer,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameContainer.FrameCreation.cs,ValidateCopyright,The following statement contains a magic number: if (value.Length >= 6) {  	string yearString = value.Substring (0' 4);  	int year;  	if (int.TryParse (yearString' out year) && year >= 1000 && year <= 9999) {  		if (value [4] == ' ')  			isValid = true;  	}  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameContainer,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameContainer.FrameCreation.cs,ValidateCopyright,The following statement contains a magic number: if (value.Length >= 6) {  	string yearString = value.Substring (0' 4);  	int year;  	if (int.TryParse (yearString' out year) && year >= 1000 && year <= 9999) {  		if (value [4] == ' ')  			isValid = true;  	}  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameContainer,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameContainer.FrameCreation.cs,ValidateCopyright,The following statement contains a magic number: if (value.Length >= 6) {  	string yearString = value.Substring (0' 4);  	int year;  	if (int.TryParse (yearString' out year) && year >= 1000 && year <= 9999) {  		if (value [4] == ' ')  			isValid = true;  	}  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameContainer,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameContainer.FrameCreation.cs,ValidateCopyright,The following statement contains a magic number: if (value.Length >= 6) {  	string yearString = value.Substring (0' 4);  	int year;  	if (int.TryParse (yearString' out year) && year >= 1000 && year <= 9999) {  		if (value [4] == ' ')  			isValid = true;  	}  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameContainer,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameContainer.FrameCreation.cs,ValidateCopyright,The following statement contains a magic number: if (value.Length >= 6) {  	string yearString = value.Substring (0' 4);  	int year;  	if (int.TryParse (yearString' out year) && year >= 1000 && year <= 9999) {  		if (value [4] == ' ')  			isValid = true;  	}  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameContainer,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameContainer.FrameCreation.cs,ValidateCopyright,The following statement contains a magic number: if (int.TryParse (yearString' out year) && year >= 1000 && year <= 9999) {  	if (value [4] == ' ')  		isValid = true;  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameContainer,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameContainer.FrameCreation.cs,ValidateCopyright,The following statement contains a magic number: if (int.TryParse (yearString' out year) && year >= 1000 && year <= 9999) {  	if (value [4] == ' ')  		isValid = true;  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameContainer,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameContainer.FrameCreation.cs,ValidateCopyright,The following statement contains a magic number: if (int.TryParse (yearString' out year) && year >= 1000 && year <= 9999) {  	if (value [4] == ' ')  		isValid = true;  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameContainer,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameContainer.FrameCreation.cs,ValidateCopyright,The following statement contains a magic number: if (value [4] == ' ')  	isValid = true;  
Magic Number,IdSharp.Tagging.ID3v2,FrameContainer,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameContainer.FrameCreation.cs,ValidateYear,The following statement contains a magic number: if (!string.IsNullOrEmpty (value)) {  	int tmpYear;  	if (!int.TryParse (value' out tmpYear) || tmpYear < 1000 || tmpYear >= 10000) {  		FireWarning ("Year"' string.Format ("The year field should be a 4 digit number{0}Example: 2007"' Environment.NewLine));  	}  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameContainer,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameContainer.FrameCreation.cs,ValidateYear,The following statement contains a magic number: if (!string.IsNullOrEmpty (value)) {  	int tmpYear;  	if (!int.TryParse (value' out tmpYear) || tmpYear < 1000 || tmpYear >= 10000) {  		FireWarning ("Year"' string.Format ("The year field should be a 4 digit number{0}Example: 2007"' Environment.NewLine));  	}  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameContainer,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameContainer.FrameCreation.cs,ValidateYear,The following statement contains a magic number: if (!int.TryParse (value' out tmpYear) || tmpYear < 1000 || tmpYear >= 10000) {  	FireWarning ("Year"' string.Format ("The year field should be a 4 digit number{0}Example: 2007"' Environment.NewLine));  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameContainer,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameContainer.FrameCreation.cs,ValidateYear,The following statement contains a magic number: if (!int.TryParse (value' out tmpYear) || tmpYear < 1000 || tmpYear >= 10000) {  	FireWarning ("Year"' string.Format ("The year field should be a 4 digit number{0}Example: 2007"' Environment.NewLine));  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameContainer,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameContainer.FrameCreation.cs,Read,The following statement contains a magic number: while (bytesRead < readUntil) {  	byte[] frameIDBytes = stream.Read (frameIDSize);  	// If character is not a letter or number' padding reached' audio began'  	// or otherwise the frame is not readable  	if (frameIDSize == 4) {  		if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  			// TODO: Try to keep reading and look for a valid frame  			if (frameIDBytes [0] != 0 && frameIDBytes [0] != 0xFF) {  				string msg = string.Format ("Out of range FrameID - 0x{0:X}|0x{1:X}|0x{2:X}|0x{3:X}"' frameIDBytes [0]' frameIDBytes [1]' frameIDBytes [2]' frameIDBytes [3]);  				if (ByteUtils.ISO88591GetString (frameIDBytes) != "MP3e") {  					string tmpBadFrameID = ByteUtils.ISO88591GetString (frameIDBytes).TrimEnd ('\0');  					Trace.WriteLine (msg + " - " + tmpBadFrameID);  				}  			}  			break;  		}  	} else if (frameIDSize == 3) {  		if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A) {  			// TODO: Try to keep reading and look for a valid frame  			if (frameIDBytes [0] != 0 && frameIDBytes [0] != 0xFF) {  				string msg = string.Format ("Out of range FrameID - 0x{0:X}|0x{1:X}|0x{2:X}"' frameIDBytes [0]' frameIDBytes [1]' frameIDBytes [2]);  				Trace.WriteLine (msg);  				Trace.WriteLine (ByteUtils.ISO88591GetString (frameIDBytes));  			}  			break;  		}  	}  	string frameID = ByteUtils.ISO88591GetString (frameIDBytes);  	// TODO: Take out  	//Console.WriteLine(tmpFrameID); // TODO: take out  	/*                     COMM Frames:                     SoundJam_CDDB_TrackNumber                     SoundJam_CDDB_1                     iTunNORM                     iTunSMPB                     iTunes_CDDB_IDs                     iTunes_CDDB_1                     iTunes_CDDB_TrackNumber                  */IFrame frame;  	do {  		IBindingList bindingList;  		if (singleOccurrenceFrames.TryGetValue (frameID' out frame)) {  			frame.Read (tagReadingInfo' stream);  			bytesRead += frame.FrameHeader.FrameSizeTotal;  			//m_ReadFrames.Add(tmpFrame);  		} else if (multipleOccurrenceFrames.TryGetValue (frameID' out bindingList)) {  			frame = (IFrame)bindingList.AddNew ();  			frame.Read (tagReadingInfo' stream);  			//m_ReadFrames.Add(tmpFrame);  			bytesRead += frame.FrameHeader.FrameSizeTotal;  		} else {  			if (tagVersion == ID3v2TagVersion.ID3v24) {  				string newFrameID;  				if (_id3v24FrameAliases.TryGetValue (frameID' out newFrameID))  					frameID = newFrameID;  				else  					break;  			} else if (tagVersion == ID3v2TagVersion.ID3v23) {  				string newFrameID;  				if (_id3v23FrameAliases.TryGetValue (frameID' out newFrameID))  					frameID = newFrameID;  				else  					break;  			} else {  				break;  			}  		}  	} while (frame == null);  	// Frame is unknown  	if (frame == null) {  		if (frameID != "NCON" && // non standard (old music match)  		frameID != "MJMD" && // Non standard frame (Music Match XML)  		frameID != "TT22" && // 000.00 - maybe meant to be 3 letter TT2 frame' and value be 2000.00? still makes no sense  		frameID != "PCST" && // null data  		frameID != "TCAT" && // category (ie' comedy) (distorted view)  		frameID != "TKWD" && // looks like blog tags "comedy funny weird"' etc (distorted view)  		frameID != "TDES" && // xml file - used by distortedview.com  		frameID != "TGID" && // url (from distortedview)  		frameID != "WFED" && // url (thanks distortedview)  		frameID != "CM1" && // some kind of comment' seen in ID3v2.2  		frameID != "TMB" && // ripped by something other' not in spec  		frameID != "RTNG" && frameID != "XDOR" && // year  		frameID != "XSOP" && // looks like artist' "Allman Brothers Band' The"  		frameID != "TENK")// itunes encoder (todo: add alias?)  		 {  			/*String msg = String.Format("Unrecognized FrameID '{0}' (not critical)"' tmpFrameID);                         Trace.WriteLine(msg);*/}  		UnknownFrame unknownFrame = new UnknownFrame (frameID' tagReadingInfo' stream);  		_unknownFrames.Add (unknownFrame);  		//m_ReadFrames.Add(tmpUNKN);  		bytesRead += unknownFrame.FrameHeader.FrameSizeTotal;  	}  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameContainer,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameContainer.FrameCreation.cs,Read,The following statement contains a magic number: while (bytesRead < readUntil) {  	byte[] frameIDBytes = stream.Read (frameIDSize);  	// If character is not a letter or number' padding reached' audio began'  	// or otherwise the frame is not readable  	if (frameIDSize == 4) {  		if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  			// TODO: Try to keep reading and look for a valid frame  			if (frameIDBytes [0] != 0 && frameIDBytes [0] != 0xFF) {  				string msg = string.Format ("Out of range FrameID - 0x{0:X}|0x{1:X}|0x{2:X}|0x{3:X}"' frameIDBytes [0]' frameIDBytes [1]' frameIDBytes [2]' frameIDBytes [3]);  				if (ByteUtils.ISO88591GetString (frameIDBytes) != "MP3e") {  					string tmpBadFrameID = ByteUtils.ISO88591GetString (frameIDBytes).TrimEnd ('\0');  					Trace.WriteLine (msg + " - " + tmpBadFrameID);  				}  			}  			break;  		}  	} else if (frameIDSize == 3) {  		if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A) {  			// TODO: Try to keep reading and look for a valid frame  			if (frameIDBytes [0] != 0 && frameIDBytes [0] != 0xFF) {  				string msg = string.Format ("Out of range FrameID - 0x{0:X}|0x{1:X}|0x{2:X}"' frameIDBytes [0]' frameIDBytes [1]' frameIDBytes [2]);  				Trace.WriteLine (msg);  				Trace.WriteLine (ByteUtils.ISO88591GetString (frameIDBytes));  			}  			break;  		}  	}  	string frameID = ByteUtils.ISO88591GetString (frameIDBytes);  	// TODO: Take out  	//Console.WriteLine(tmpFrameID); // TODO: take out  	/*                     COMM Frames:                     SoundJam_CDDB_TrackNumber                     SoundJam_CDDB_1                     iTunNORM                     iTunSMPB                     iTunes_CDDB_IDs                     iTunes_CDDB_1                     iTunes_CDDB_TrackNumber                  */IFrame frame;  	do {  		IBindingList bindingList;  		if (singleOccurrenceFrames.TryGetValue (frameID' out frame)) {  			frame.Read (tagReadingInfo' stream);  			bytesRead += frame.FrameHeader.FrameSizeTotal;  			//m_ReadFrames.Add(tmpFrame);  		} else if (multipleOccurrenceFrames.TryGetValue (frameID' out bindingList)) {  			frame = (IFrame)bindingList.AddNew ();  			frame.Read (tagReadingInfo' stream);  			//m_ReadFrames.Add(tmpFrame);  			bytesRead += frame.FrameHeader.FrameSizeTotal;  		} else {  			if (tagVersion == ID3v2TagVersion.ID3v24) {  				string newFrameID;  				if (_id3v24FrameAliases.TryGetValue (frameID' out newFrameID))  					frameID = newFrameID;  				else  					break;  			} else if (tagVersion == ID3v2TagVersion.ID3v23) {  				string newFrameID;  				if (_id3v23FrameAliases.TryGetValue (frameID' out newFrameID))  					frameID = newFrameID;  				else  					break;  			} else {  				break;  			}  		}  	} while (frame == null);  	// Frame is unknown  	if (frame == null) {  		if (frameID != "NCON" && // non standard (old music match)  		frameID != "MJMD" && // Non standard frame (Music Match XML)  		frameID != "TT22" && // 000.00 - maybe meant to be 3 letter TT2 frame' and value be 2000.00? still makes no sense  		frameID != "PCST" && // null data  		frameID != "TCAT" && // category (ie' comedy) (distorted view)  		frameID != "TKWD" && // looks like blog tags "comedy funny weird"' etc (distorted view)  		frameID != "TDES" && // xml file - used by distortedview.com  		frameID != "TGID" && // url (from distortedview)  		frameID != "WFED" && // url (thanks distortedview)  		frameID != "CM1" && // some kind of comment' seen in ID3v2.2  		frameID != "TMB" && // ripped by something other' not in spec  		frameID != "RTNG" && frameID != "XDOR" && // year  		frameID != "XSOP" && // looks like artist' "Allman Brothers Band' The"  		frameID != "TENK")// itunes encoder (todo: add alias?)  		 {  			/*String msg = String.Format("Unrecognized FrameID '{0}' (not critical)"' tmpFrameID);                         Trace.WriteLine(msg);*/}  		UnknownFrame unknownFrame = new UnknownFrame (frameID' tagReadingInfo' stream);  		_unknownFrames.Add (unknownFrame);  		//m_ReadFrames.Add(tmpUNKN);  		bytesRead += unknownFrame.FrameHeader.FrameSizeTotal;  	}  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameContainer,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameContainer.FrameCreation.cs,Read,The following statement contains a magic number: while (bytesRead < readUntil) {  	byte[] frameIDBytes = stream.Read (frameIDSize);  	// If character is not a letter or number' padding reached' audio began'  	// or otherwise the frame is not readable  	if (frameIDSize == 4) {  		if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  			// TODO: Try to keep reading and look for a valid frame  			if (frameIDBytes [0] != 0 && frameIDBytes [0] != 0xFF) {  				string msg = string.Format ("Out of range FrameID - 0x{0:X}|0x{1:X}|0x{2:X}|0x{3:X}"' frameIDBytes [0]' frameIDBytes [1]' frameIDBytes [2]' frameIDBytes [3]);  				if (ByteUtils.ISO88591GetString (frameIDBytes) != "MP3e") {  					string tmpBadFrameID = ByteUtils.ISO88591GetString (frameIDBytes).TrimEnd ('\0');  					Trace.WriteLine (msg + " - " + tmpBadFrameID);  				}  			}  			break;  		}  	} else if (frameIDSize == 3) {  		if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A) {  			// TODO: Try to keep reading and look for a valid frame  			if (frameIDBytes [0] != 0 && frameIDBytes [0] != 0xFF) {  				string msg = string.Format ("Out of range FrameID - 0x{0:X}|0x{1:X}|0x{2:X}"' frameIDBytes [0]' frameIDBytes [1]' frameIDBytes [2]);  				Trace.WriteLine (msg);  				Trace.WriteLine (ByteUtils.ISO88591GetString (frameIDBytes));  			}  			break;  		}  	}  	string frameID = ByteUtils.ISO88591GetString (frameIDBytes);  	// TODO: Take out  	//Console.WriteLine(tmpFrameID); // TODO: take out  	/*                     COMM Frames:                     SoundJam_CDDB_TrackNumber                     SoundJam_CDDB_1                     iTunNORM                     iTunSMPB                     iTunes_CDDB_IDs                     iTunes_CDDB_1                     iTunes_CDDB_TrackNumber                  */IFrame frame;  	do {  		IBindingList bindingList;  		if (singleOccurrenceFrames.TryGetValue (frameID' out frame)) {  			frame.Read (tagReadingInfo' stream);  			bytesRead += frame.FrameHeader.FrameSizeTotal;  			//m_ReadFrames.Add(tmpFrame);  		} else if (multipleOccurrenceFrames.TryGetValue (frameID' out bindingList)) {  			frame = (IFrame)bindingList.AddNew ();  			frame.Read (tagReadingInfo' stream);  			//m_ReadFrames.Add(tmpFrame);  			bytesRead += frame.FrameHeader.FrameSizeTotal;  		} else {  			if (tagVersion == ID3v2TagVersion.ID3v24) {  				string newFrameID;  				if (_id3v24FrameAliases.TryGetValue (frameID' out newFrameID))  					frameID = newFrameID;  				else  					break;  			} else if (tagVersion == ID3v2TagVersion.ID3v23) {  				string newFrameID;  				if (_id3v23FrameAliases.TryGetValue (frameID' out newFrameID))  					frameID = newFrameID;  				else  					break;  			} else {  				break;  			}  		}  	} while (frame == null);  	// Frame is unknown  	if (frame == null) {  		if (frameID != "NCON" && // non standard (old music match)  		frameID != "MJMD" && // Non standard frame (Music Match XML)  		frameID != "TT22" && // 000.00 - maybe meant to be 3 letter TT2 frame' and value be 2000.00? still makes no sense  		frameID != "PCST" && // null data  		frameID != "TCAT" && // category (ie' comedy) (distorted view)  		frameID != "TKWD" && // looks like blog tags "comedy funny weird"' etc (distorted view)  		frameID != "TDES" && // xml file - used by distortedview.com  		frameID != "TGID" && // url (from distortedview)  		frameID != "WFED" && // url (thanks distortedview)  		frameID != "CM1" && // some kind of comment' seen in ID3v2.2  		frameID != "TMB" && // ripped by something other' not in spec  		frameID != "RTNG" && frameID != "XDOR" && // year  		frameID != "XSOP" && // looks like artist' "Allman Brothers Band' The"  		frameID != "TENK")// itunes encoder (todo: add alias?)  		 {  			/*String msg = String.Format("Unrecognized FrameID '{0}' (not critical)"' tmpFrameID);                         Trace.WriteLine(msg);*/}  		UnknownFrame unknownFrame = new UnknownFrame (frameID' tagReadingInfo' stream);  		_unknownFrames.Add (unknownFrame);  		//m_ReadFrames.Add(tmpUNKN);  		bytesRead += unknownFrame.FrameHeader.FrameSizeTotal;  	}  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameContainer,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameContainer.FrameCreation.cs,Read,The following statement contains a magic number: while (bytesRead < readUntil) {  	byte[] frameIDBytes = stream.Read (frameIDSize);  	// If character is not a letter or number' padding reached' audio began'  	// or otherwise the frame is not readable  	if (frameIDSize == 4) {  		if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  			// TODO: Try to keep reading and look for a valid frame  			if (frameIDBytes [0] != 0 && frameIDBytes [0] != 0xFF) {  				string msg = string.Format ("Out of range FrameID - 0x{0:X}|0x{1:X}|0x{2:X}|0x{3:X}"' frameIDBytes [0]' frameIDBytes [1]' frameIDBytes [2]' frameIDBytes [3]);  				if (ByteUtils.ISO88591GetString (frameIDBytes) != "MP3e") {  					string tmpBadFrameID = ByteUtils.ISO88591GetString (frameIDBytes).TrimEnd ('\0');  					Trace.WriteLine (msg + " - " + tmpBadFrameID);  				}  			}  			break;  		}  	} else if (frameIDSize == 3) {  		if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A) {  			// TODO: Try to keep reading and look for a valid frame  			if (frameIDBytes [0] != 0 && frameIDBytes [0] != 0xFF) {  				string msg = string.Format ("Out of range FrameID - 0x{0:X}|0x{1:X}|0x{2:X}"' frameIDBytes [0]' frameIDBytes [1]' frameIDBytes [2]);  				Trace.WriteLine (msg);  				Trace.WriteLine (ByteUtils.ISO88591GetString (frameIDBytes));  			}  			break;  		}  	}  	string frameID = ByteUtils.ISO88591GetString (frameIDBytes);  	// TODO: Take out  	//Console.WriteLine(tmpFrameID); // TODO: take out  	/*                     COMM Frames:                     SoundJam_CDDB_TrackNumber                     SoundJam_CDDB_1                     iTunNORM                     iTunSMPB                     iTunes_CDDB_IDs                     iTunes_CDDB_1                     iTunes_CDDB_TrackNumber                  */IFrame frame;  	do {  		IBindingList bindingList;  		if (singleOccurrenceFrames.TryGetValue (frameID' out frame)) {  			frame.Read (tagReadingInfo' stream);  			bytesRead += frame.FrameHeader.FrameSizeTotal;  			//m_ReadFrames.Add(tmpFrame);  		} else if (multipleOccurrenceFrames.TryGetValue (frameID' out bindingList)) {  			frame = (IFrame)bindingList.AddNew ();  			frame.Read (tagReadingInfo' stream);  			//m_ReadFrames.Add(tmpFrame);  			bytesRead += frame.FrameHeader.FrameSizeTotal;  		} else {  			if (tagVersion == ID3v2TagVersion.ID3v24) {  				string newFrameID;  				if (_id3v24FrameAliases.TryGetValue (frameID' out newFrameID))  					frameID = newFrameID;  				else  					break;  			} else if (tagVersion == ID3v2TagVersion.ID3v23) {  				string newFrameID;  				if (_id3v23FrameAliases.TryGetValue (frameID' out newFrameID))  					frameID = newFrameID;  				else  					break;  			} else {  				break;  			}  		}  	} while (frame == null);  	// Frame is unknown  	if (frame == null) {  		if (frameID != "NCON" && // non standard (old music match)  		frameID != "MJMD" && // Non standard frame (Music Match XML)  		frameID != "TT22" && // 000.00 - maybe meant to be 3 letter TT2 frame' and value be 2000.00? still makes no sense  		frameID != "PCST" && // null data  		frameID != "TCAT" && // category (ie' comedy) (distorted view)  		frameID != "TKWD" && // looks like blog tags "comedy funny weird"' etc (distorted view)  		frameID != "TDES" && // xml file - used by distortedview.com  		frameID != "TGID" && // url (from distortedview)  		frameID != "WFED" && // url (thanks distortedview)  		frameID != "CM1" && // some kind of comment' seen in ID3v2.2  		frameID != "TMB" && // ripped by something other' not in spec  		frameID != "RTNG" && frameID != "XDOR" && // year  		frameID != "XSOP" && // looks like artist' "Allman Brothers Band' The"  		frameID != "TENK")// itunes encoder (todo: add alias?)  		 {  			/*String msg = String.Format("Unrecognized FrameID '{0}' (not critical)"' tmpFrameID);                         Trace.WriteLine(msg);*/}  		UnknownFrame unknownFrame = new UnknownFrame (frameID' tagReadingInfo' stream);  		_unknownFrames.Add (unknownFrame);  		//m_ReadFrames.Add(tmpUNKN);  		bytesRead += unknownFrame.FrameHeader.FrameSizeTotal;  	}  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameContainer,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameContainer.FrameCreation.cs,Read,The following statement contains a magic number: while (bytesRead < readUntil) {  	byte[] frameIDBytes = stream.Read (frameIDSize);  	// If character is not a letter or number' padding reached' audio began'  	// or otherwise the frame is not readable  	if (frameIDSize == 4) {  		if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  			// TODO: Try to keep reading and look for a valid frame  			if (frameIDBytes [0] != 0 && frameIDBytes [0] != 0xFF) {  				string msg = string.Format ("Out of range FrameID - 0x{0:X}|0x{1:X}|0x{2:X}|0x{3:X}"' frameIDBytes [0]' frameIDBytes [1]' frameIDBytes [2]' frameIDBytes [3]);  				if (ByteUtils.ISO88591GetString (frameIDBytes) != "MP3e") {  					string tmpBadFrameID = ByteUtils.ISO88591GetString (frameIDBytes).TrimEnd ('\0');  					Trace.WriteLine (msg + " - " + tmpBadFrameID);  				}  			}  			break;  		}  	} else if (frameIDSize == 3) {  		if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A) {  			// TODO: Try to keep reading and look for a valid frame  			if (frameIDBytes [0] != 0 && frameIDBytes [0] != 0xFF) {  				string msg = string.Format ("Out of range FrameID - 0x{0:X}|0x{1:X}|0x{2:X}"' frameIDBytes [0]' frameIDBytes [1]' frameIDBytes [2]);  				Trace.WriteLine (msg);  				Trace.WriteLine (ByteUtils.ISO88591GetString (frameIDBytes));  			}  			break;  		}  	}  	string frameID = ByteUtils.ISO88591GetString (frameIDBytes);  	// TODO: Take out  	//Console.WriteLine(tmpFrameID); // TODO: take out  	/*                     COMM Frames:                     SoundJam_CDDB_TrackNumber                     SoundJam_CDDB_1                     iTunNORM                     iTunSMPB                     iTunes_CDDB_IDs                     iTunes_CDDB_1                     iTunes_CDDB_TrackNumber                  */IFrame frame;  	do {  		IBindingList bindingList;  		if (singleOccurrenceFrames.TryGetValue (frameID' out frame)) {  			frame.Read (tagReadingInfo' stream);  			bytesRead += frame.FrameHeader.FrameSizeTotal;  			//m_ReadFrames.Add(tmpFrame);  		} else if (multipleOccurrenceFrames.TryGetValue (frameID' out bindingList)) {  			frame = (IFrame)bindingList.AddNew ();  			frame.Read (tagReadingInfo' stream);  			//m_ReadFrames.Add(tmpFrame);  			bytesRead += frame.FrameHeader.FrameSizeTotal;  		} else {  			if (tagVersion == ID3v2TagVersion.ID3v24) {  				string newFrameID;  				if (_id3v24FrameAliases.TryGetValue (frameID' out newFrameID))  					frameID = newFrameID;  				else  					break;  			} else if (tagVersion == ID3v2TagVersion.ID3v23) {  				string newFrameID;  				if (_id3v23FrameAliases.TryGetValue (frameID' out newFrameID))  					frameID = newFrameID;  				else  					break;  			} else {  				break;  			}  		}  	} while (frame == null);  	// Frame is unknown  	if (frame == null) {  		if (frameID != "NCON" && // non standard (old music match)  		frameID != "MJMD" && // Non standard frame (Music Match XML)  		frameID != "TT22" && // 000.00 - maybe meant to be 3 letter TT2 frame' and value be 2000.00? still makes no sense  		frameID != "PCST" && // null data  		frameID != "TCAT" && // category (ie' comedy) (distorted view)  		frameID != "TKWD" && // looks like blog tags "comedy funny weird"' etc (distorted view)  		frameID != "TDES" && // xml file - used by distortedview.com  		frameID != "TGID" && // url (from distortedview)  		frameID != "WFED" && // url (thanks distortedview)  		frameID != "CM1" && // some kind of comment' seen in ID3v2.2  		frameID != "TMB" && // ripped by something other' not in spec  		frameID != "RTNG" && frameID != "XDOR" && // year  		frameID != "XSOP" && // looks like artist' "Allman Brothers Band' The"  		frameID != "TENK")// itunes encoder (todo: add alias?)  		 {  			/*String msg = String.Format("Unrecognized FrameID '{0}' (not critical)"' tmpFrameID);                         Trace.WriteLine(msg);*/}  		UnknownFrame unknownFrame = new UnknownFrame (frameID' tagReadingInfo' stream);  		_unknownFrames.Add (unknownFrame);  		//m_ReadFrames.Add(tmpUNKN);  		bytesRead += unknownFrame.FrameHeader.FrameSizeTotal;  	}  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameContainer,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameContainer.FrameCreation.cs,Read,The following statement contains a magic number: while (bytesRead < readUntil) {  	byte[] frameIDBytes = stream.Read (frameIDSize);  	// If character is not a letter or number' padding reached' audio began'  	// or otherwise the frame is not readable  	if (frameIDSize == 4) {  		if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  			// TODO: Try to keep reading and look for a valid frame  			if (frameIDBytes [0] != 0 && frameIDBytes [0] != 0xFF) {  				string msg = string.Format ("Out of range FrameID - 0x{0:X}|0x{1:X}|0x{2:X}|0x{3:X}"' frameIDBytes [0]' frameIDBytes [1]' frameIDBytes [2]' frameIDBytes [3]);  				if (ByteUtils.ISO88591GetString (frameIDBytes) != "MP3e") {  					string tmpBadFrameID = ByteUtils.ISO88591GetString (frameIDBytes).TrimEnd ('\0');  					Trace.WriteLine (msg + " - " + tmpBadFrameID);  				}  			}  			break;  		}  	} else if (frameIDSize == 3) {  		if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A) {  			// TODO: Try to keep reading and look for a valid frame  			if (frameIDBytes [0] != 0 && frameIDBytes [0] != 0xFF) {  				string msg = string.Format ("Out of range FrameID - 0x{0:X}|0x{1:X}|0x{2:X}"' frameIDBytes [0]' frameIDBytes [1]' frameIDBytes [2]);  				Trace.WriteLine (msg);  				Trace.WriteLine (ByteUtils.ISO88591GetString (frameIDBytes));  			}  			break;  		}  	}  	string frameID = ByteUtils.ISO88591GetString (frameIDBytes);  	// TODO: Take out  	//Console.WriteLine(tmpFrameID); // TODO: take out  	/*                     COMM Frames:                     SoundJam_CDDB_TrackNumber                     SoundJam_CDDB_1                     iTunNORM                     iTunSMPB                     iTunes_CDDB_IDs                     iTunes_CDDB_1                     iTunes_CDDB_TrackNumber                  */IFrame frame;  	do {  		IBindingList bindingList;  		if (singleOccurrenceFrames.TryGetValue (frameID' out frame)) {  			frame.Read (tagReadingInfo' stream);  			bytesRead += frame.FrameHeader.FrameSizeTotal;  			//m_ReadFrames.Add(tmpFrame);  		} else if (multipleOccurrenceFrames.TryGetValue (frameID' out bindingList)) {  			frame = (IFrame)bindingList.AddNew ();  			frame.Read (tagReadingInfo' stream);  			//m_ReadFrames.Add(tmpFrame);  			bytesRead += frame.FrameHeader.FrameSizeTotal;  		} else {  			if (tagVersion == ID3v2TagVersion.ID3v24) {  				string newFrameID;  				if (_id3v24FrameAliases.TryGetValue (frameID' out newFrameID))  					frameID = newFrameID;  				else  					break;  			} else if (tagVersion == ID3v2TagVersion.ID3v23) {  				string newFrameID;  				if (_id3v23FrameAliases.TryGetValue (frameID' out newFrameID))  					frameID = newFrameID;  				else  					break;  			} else {  				break;  			}  		}  	} while (frame == null);  	// Frame is unknown  	if (frame == null) {  		if (frameID != "NCON" && // non standard (old music match)  		frameID != "MJMD" && // Non standard frame (Music Match XML)  		frameID != "TT22" && // 000.00 - maybe meant to be 3 letter TT2 frame' and value be 2000.00? still makes no sense  		frameID != "PCST" && // null data  		frameID != "TCAT" && // category (ie' comedy) (distorted view)  		frameID != "TKWD" && // looks like blog tags "comedy funny weird"' etc (distorted view)  		frameID != "TDES" && // xml file - used by distortedview.com  		frameID != "TGID" && // url (from distortedview)  		frameID != "WFED" && // url (thanks distortedview)  		frameID != "CM1" && // some kind of comment' seen in ID3v2.2  		frameID != "TMB" && // ripped by something other' not in spec  		frameID != "RTNG" && frameID != "XDOR" && // year  		frameID != "XSOP" && // looks like artist' "Allman Brothers Band' The"  		frameID != "TENK")// itunes encoder (todo: add alias?)  		 {  			/*String msg = String.Format("Unrecognized FrameID '{0}' (not critical)"' tmpFrameID);                         Trace.WriteLine(msg);*/}  		UnknownFrame unknownFrame = new UnknownFrame (frameID' tagReadingInfo' stream);  		_unknownFrames.Add (unknownFrame);  		//m_ReadFrames.Add(tmpUNKN);  		bytesRead += unknownFrame.FrameHeader.FrameSizeTotal;  	}  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameContainer,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameContainer.FrameCreation.cs,Read,The following statement contains a magic number: while (bytesRead < readUntil) {  	byte[] frameIDBytes = stream.Read (frameIDSize);  	// If character is not a letter or number' padding reached' audio began'  	// or otherwise the frame is not readable  	if (frameIDSize == 4) {  		if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  			// TODO: Try to keep reading and look for a valid frame  			if (frameIDBytes [0] != 0 && frameIDBytes [0] != 0xFF) {  				string msg = string.Format ("Out of range FrameID - 0x{0:X}|0x{1:X}|0x{2:X}|0x{3:X}"' frameIDBytes [0]' frameIDBytes [1]' frameIDBytes [2]' frameIDBytes [3]);  				if (ByteUtils.ISO88591GetString (frameIDBytes) != "MP3e") {  					string tmpBadFrameID = ByteUtils.ISO88591GetString (frameIDBytes).TrimEnd ('\0');  					Trace.WriteLine (msg + " - " + tmpBadFrameID);  				}  			}  			break;  		}  	} else if (frameIDSize == 3) {  		if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A) {  			// TODO: Try to keep reading and look for a valid frame  			if (frameIDBytes [0] != 0 && frameIDBytes [0] != 0xFF) {  				string msg = string.Format ("Out of range FrameID - 0x{0:X}|0x{1:X}|0x{2:X}"' frameIDBytes [0]' frameIDBytes [1]' frameIDBytes [2]);  				Trace.WriteLine (msg);  				Trace.WriteLine (ByteUtils.ISO88591GetString (frameIDBytes));  			}  			break;  		}  	}  	string frameID = ByteUtils.ISO88591GetString (frameIDBytes);  	// TODO: Take out  	//Console.WriteLine(tmpFrameID); // TODO: take out  	/*                     COMM Frames:                     SoundJam_CDDB_TrackNumber                     SoundJam_CDDB_1                     iTunNORM                     iTunSMPB                     iTunes_CDDB_IDs                     iTunes_CDDB_1                     iTunes_CDDB_TrackNumber                  */IFrame frame;  	do {  		IBindingList bindingList;  		if (singleOccurrenceFrames.TryGetValue (frameID' out frame)) {  			frame.Read (tagReadingInfo' stream);  			bytesRead += frame.FrameHeader.FrameSizeTotal;  			//m_ReadFrames.Add(tmpFrame);  		} else if (multipleOccurrenceFrames.TryGetValue (frameID' out bindingList)) {  			frame = (IFrame)bindingList.AddNew ();  			frame.Read (tagReadingInfo' stream);  			//m_ReadFrames.Add(tmpFrame);  			bytesRead += frame.FrameHeader.FrameSizeTotal;  		} else {  			if (tagVersion == ID3v2TagVersion.ID3v24) {  				string newFrameID;  				if (_id3v24FrameAliases.TryGetValue (frameID' out newFrameID))  					frameID = newFrameID;  				else  					break;  			} else if (tagVersion == ID3v2TagVersion.ID3v23) {  				string newFrameID;  				if (_id3v23FrameAliases.TryGetValue (frameID' out newFrameID))  					frameID = newFrameID;  				else  					break;  			} else {  				break;  			}  		}  	} while (frame == null);  	// Frame is unknown  	if (frame == null) {  		if (frameID != "NCON" && // non standard (old music match)  		frameID != "MJMD" && // Non standard frame (Music Match XML)  		frameID != "TT22" && // 000.00 - maybe meant to be 3 letter TT2 frame' and value be 2000.00? still makes no sense  		frameID != "PCST" && // null data  		frameID != "TCAT" && // category (ie' comedy) (distorted view)  		frameID != "TKWD" && // looks like blog tags "comedy funny weird"' etc (distorted view)  		frameID != "TDES" && // xml file - used by distortedview.com  		frameID != "TGID" && // url (from distortedview)  		frameID != "WFED" && // url (thanks distortedview)  		frameID != "CM1" && // some kind of comment' seen in ID3v2.2  		frameID != "TMB" && // ripped by something other' not in spec  		frameID != "RTNG" && frameID != "XDOR" && // year  		frameID != "XSOP" && // looks like artist' "Allman Brothers Band' The"  		frameID != "TENK")// itunes encoder (todo: add alias?)  		 {  			/*String msg = String.Format("Unrecognized FrameID '{0}' (not critical)"' tmpFrameID);                         Trace.WriteLine(msg);*/}  		UnknownFrame unknownFrame = new UnknownFrame (frameID' tagReadingInfo' stream);  		_unknownFrames.Add (unknownFrame);  		//m_ReadFrames.Add(tmpUNKN);  		bytesRead += unknownFrame.FrameHeader.FrameSizeTotal;  	}  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameContainer,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameContainer.FrameCreation.cs,Read,The following statement contains a magic number: while (bytesRead < readUntil) {  	byte[] frameIDBytes = stream.Read (frameIDSize);  	// If character is not a letter or number' padding reached' audio began'  	// or otherwise the frame is not readable  	if (frameIDSize == 4) {  		if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  			// TODO: Try to keep reading and look for a valid frame  			if (frameIDBytes [0] != 0 && frameIDBytes [0] != 0xFF) {  				string msg = string.Format ("Out of range FrameID - 0x{0:X}|0x{1:X}|0x{2:X}|0x{3:X}"' frameIDBytes [0]' frameIDBytes [1]' frameIDBytes [2]' frameIDBytes [3]);  				if (ByteUtils.ISO88591GetString (frameIDBytes) != "MP3e") {  					string tmpBadFrameID = ByteUtils.ISO88591GetString (frameIDBytes).TrimEnd ('\0');  					Trace.WriteLine (msg + " - " + tmpBadFrameID);  				}  			}  			break;  		}  	} else if (frameIDSize == 3) {  		if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A) {  			// TODO: Try to keep reading and look for a valid frame  			if (frameIDBytes [0] != 0 && frameIDBytes [0] != 0xFF) {  				string msg = string.Format ("Out of range FrameID - 0x{0:X}|0x{1:X}|0x{2:X}"' frameIDBytes [0]' frameIDBytes [1]' frameIDBytes [2]);  				Trace.WriteLine (msg);  				Trace.WriteLine (ByteUtils.ISO88591GetString (frameIDBytes));  			}  			break;  		}  	}  	string frameID = ByteUtils.ISO88591GetString (frameIDBytes);  	// TODO: Take out  	//Console.WriteLine(tmpFrameID); // TODO: take out  	/*                     COMM Frames:                     SoundJam_CDDB_TrackNumber                     SoundJam_CDDB_1                     iTunNORM                     iTunSMPB                     iTunes_CDDB_IDs                     iTunes_CDDB_1                     iTunes_CDDB_TrackNumber                  */IFrame frame;  	do {  		IBindingList bindingList;  		if (singleOccurrenceFrames.TryGetValue (frameID' out frame)) {  			frame.Read (tagReadingInfo' stream);  			bytesRead += frame.FrameHeader.FrameSizeTotal;  			//m_ReadFrames.Add(tmpFrame);  		} else if (multipleOccurrenceFrames.TryGetValue (frameID' out bindingList)) {  			frame = (IFrame)bindingList.AddNew ();  			frame.Read (tagReadingInfo' stream);  			//m_ReadFrames.Add(tmpFrame);  			bytesRead += frame.FrameHeader.FrameSizeTotal;  		} else {  			if (tagVersion == ID3v2TagVersion.ID3v24) {  				string newFrameID;  				if (_id3v24FrameAliases.TryGetValue (frameID' out newFrameID))  					frameID = newFrameID;  				else  					break;  			} else if (tagVersion == ID3v2TagVersion.ID3v23) {  				string newFrameID;  				if (_id3v23FrameAliases.TryGetValue (frameID' out newFrameID))  					frameID = newFrameID;  				else  					break;  			} else {  				break;  			}  		}  	} while (frame == null);  	// Frame is unknown  	if (frame == null) {  		if (frameID != "NCON" && // non standard (old music match)  		frameID != "MJMD" && // Non standard frame (Music Match XML)  		frameID != "TT22" && // 000.00 - maybe meant to be 3 letter TT2 frame' and value be 2000.00? still makes no sense  		frameID != "PCST" && // null data  		frameID != "TCAT" && // category (ie' comedy) (distorted view)  		frameID != "TKWD" && // looks like blog tags "comedy funny weird"' etc (distorted view)  		frameID != "TDES" && // xml file - used by distortedview.com  		frameID != "TGID" && // url (from distortedview)  		frameID != "WFED" && // url (thanks distortedview)  		frameID != "CM1" && // some kind of comment' seen in ID3v2.2  		frameID != "TMB" && // ripped by something other' not in spec  		frameID != "RTNG" && frameID != "XDOR" && // year  		frameID != "XSOP" && // looks like artist' "Allman Brothers Band' The"  		frameID != "TENK")// itunes encoder (todo: add alias?)  		 {  			/*String msg = String.Format("Unrecognized FrameID '{0}' (not critical)"' tmpFrameID);                         Trace.WriteLine(msg);*/}  		UnknownFrame unknownFrame = new UnknownFrame (frameID' tagReadingInfo' stream);  		_unknownFrames.Add (unknownFrame);  		//m_ReadFrames.Add(tmpUNKN);  		bytesRead += unknownFrame.FrameHeader.FrameSizeTotal;  	}  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameContainer,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameContainer.FrameCreation.cs,Read,The following statement contains a magic number: while (bytesRead < readUntil) {  	byte[] frameIDBytes = stream.Read (frameIDSize);  	// If character is not a letter or number' padding reached' audio began'  	// or otherwise the frame is not readable  	if (frameIDSize == 4) {  		if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  			// TODO: Try to keep reading and look for a valid frame  			if (frameIDBytes [0] != 0 && frameIDBytes [0] != 0xFF) {  				string msg = string.Format ("Out of range FrameID - 0x{0:X}|0x{1:X}|0x{2:X}|0x{3:X}"' frameIDBytes [0]' frameIDBytes [1]' frameIDBytes [2]' frameIDBytes [3]);  				if (ByteUtils.ISO88591GetString (frameIDBytes) != "MP3e") {  					string tmpBadFrameID = ByteUtils.ISO88591GetString (frameIDBytes).TrimEnd ('\0');  					Trace.WriteLine (msg + " - " + tmpBadFrameID);  				}  			}  			break;  		}  	} else if (frameIDSize == 3) {  		if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A) {  			// TODO: Try to keep reading and look for a valid frame  			if (frameIDBytes [0] != 0 && frameIDBytes [0] != 0xFF) {  				string msg = string.Format ("Out of range FrameID - 0x{0:X}|0x{1:X}|0x{2:X}"' frameIDBytes [0]' frameIDBytes [1]' frameIDBytes [2]);  				Trace.WriteLine (msg);  				Trace.WriteLine (ByteUtils.ISO88591GetString (frameIDBytes));  			}  			break;  		}  	}  	string frameID = ByteUtils.ISO88591GetString (frameIDBytes);  	// TODO: Take out  	//Console.WriteLine(tmpFrameID); // TODO: take out  	/*                     COMM Frames:                     SoundJam_CDDB_TrackNumber                     SoundJam_CDDB_1                     iTunNORM                     iTunSMPB                     iTunes_CDDB_IDs                     iTunes_CDDB_1                     iTunes_CDDB_TrackNumber                  */IFrame frame;  	do {  		IBindingList bindingList;  		if (singleOccurrenceFrames.TryGetValue (frameID' out frame)) {  			frame.Read (tagReadingInfo' stream);  			bytesRead += frame.FrameHeader.FrameSizeTotal;  			//m_ReadFrames.Add(tmpFrame);  		} else if (multipleOccurrenceFrames.TryGetValue (frameID' out bindingList)) {  			frame = (IFrame)bindingList.AddNew ();  			frame.Read (tagReadingInfo' stream);  			//m_ReadFrames.Add(tmpFrame);  			bytesRead += frame.FrameHeader.FrameSizeTotal;  		} else {  			if (tagVersion == ID3v2TagVersion.ID3v24) {  				string newFrameID;  				if (_id3v24FrameAliases.TryGetValue (frameID' out newFrameID))  					frameID = newFrameID;  				else  					break;  			} else if (tagVersion == ID3v2TagVersion.ID3v23) {  				string newFrameID;  				if (_id3v23FrameAliases.TryGetValue (frameID' out newFrameID))  					frameID = newFrameID;  				else  					break;  			} else {  				break;  			}  		}  	} while (frame == null);  	// Frame is unknown  	if (frame == null) {  		if (frameID != "NCON" && // non standard (old music match)  		frameID != "MJMD" && // Non standard frame (Music Match XML)  		frameID != "TT22" && // 000.00 - maybe meant to be 3 letter TT2 frame' and value be 2000.00? still makes no sense  		frameID != "PCST" && // null data  		frameID != "TCAT" && // category (ie' comedy) (distorted view)  		frameID != "TKWD" && // looks like blog tags "comedy funny weird"' etc (distorted view)  		frameID != "TDES" && // xml file - used by distortedview.com  		frameID != "TGID" && // url (from distortedview)  		frameID != "WFED" && // url (thanks distortedview)  		frameID != "CM1" && // some kind of comment' seen in ID3v2.2  		frameID != "TMB" && // ripped by something other' not in spec  		frameID != "RTNG" && frameID != "XDOR" && // year  		frameID != "XSOP" && // looks like artist' "Allman Brothers Band' The"  		frameID != "TENK")// itunes encoder (todo: add alias?)  		 {  			/*String msg = String.Format("Unrecognized FrameID '{0}' (not critical)"' tmpFrameID);                         Trace.WriteLine(msg);*/}  		UnknownFrame unknownFrame = new UnknownFrame (frameID' tagReadingInfo' stream);  		_unknownFrames.Add (unknownFrame);  		//m_ReadFrames.Add(tmpUNKN);  		bytesRead += unknownFrame.FrameHeader.FrameSizeTotal;  	}  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameContainer,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameContainer.FrameCreation.cs,Read,The following statement contains a magic number: while (bytesRead < readUntil) {  	byte[] frameIDBytes = stream.Read (frameIDSize);  	// If character is not a letter or number' padding reached' audio began'  	// or otherwise the frame is not readable  	if (frameIDSize == 4) {  		if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  			// TODO: Try to keep reading and look for a valid frame  			if (frameIDBytes [0] != 0 && frameIDBytes [0] != 0xFF) {  				string msg = string.Format ("Out of range FrameID - 0x{0:X}|0x{1:X}|0x{2:X}|0x{3:X}"' frameIDBytes [0]' frameIDBytes [1]' frameIDBytes [2]' frameIDBytes [3]);  				if (ByteUtils.ISO88591GetString (frameIDBytes) != "MP3e") {  					string tmpBadFrameID = ByteUtils.ISO88591GetString (frameIDBytes).TrimEnd ('\0');  					Trace.WriteLine (msg + " - " + tmpBadFrameID);  				}  			}  			break;  		}  	} else if (frameIDSize == 3) {  		if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A) {  			// TODO: Try to keep reading and look for a valid frame  			if (frameIDBytes [0] != 0 && frameIDBytes [0] != 0xFF) {  				string msg = string.Format ("Out of range FrameID - 0x{0:X}|0x{1:X}|0x{2:X}"' frameIDBytes [0]' frameIDBytes [1]' frameIDBytes [2]);  				Trace.WriteLine (msg);  				Trace.WriteLine (ByteUtils.ISO88591GetString (frameIDBytes));  			}  			break;  		}  	}  	string frameID = ByteUtils.ISO88591GetString (frameIDBytes);  	// TODO: Take out  	//Console.WriteLine(tmpFrameID); // TODO: take out  	/*                     COMM Frames:                     SoundJam_CDDB_TrackNumber                     SoundJam_CDDB_1                     iTunNORM                     iTunSMPB                     iTunes_CDDB_IDs                     iTunes_CDDB_1                     iTunes_CDDB_TrackNumber                  */IFrame frame;  	do {  		IBindingList bindingList;  		if (singleOccurrenceFrames.TryGetValue (frameID' out frame)) {  			frame.Read (tagReadingInfo' stream);  			bytesRead += frame.FrameHeader.FrameSizeTotal;  			//m_ReadFrames.Add(tmpFrame);  		} else if (multipleOccurrenceFrames.TryGetValue (frameID' out bindingList)) {  			frame = (IFrame)bindingList.AddNew ();  			frame.Read (tagReadingInfo' stream);  			//m_ReadFrames.Add(tmpFrame);  			bytesRead += frame.FrameHeader.FrameSizeTotal;  		} else {  			if (tagVersion == ID3v2TagVersion.ID3v24) {  				string newFrameID;  				if (_id3v24FrameAliases.TryGetValue (frameID' out newFrameID))  					frameID = newFrameID;  				else  					break;  			} else if (tagVersion == ID3v2TagVersion.ID3v23) {  				string newFrameID;  				if (_id3v23FrameAliases.TryGetValue (frameID' out newFrameID))  					frameID = newFrameID;  				else  					break;  			} else {  				break;  			}  		}  	} while (frame == null);  	// Frame is unknown  	if (frame == null) {  		if (frameID != "NCON" && // non standard (old music match)  		frameID != "MJMD" && // Non standard frame (Music Match XML)  		frameID != "TT22" && // 000.00 - maybe meant to be 3 letter TT2 frame' and value be 2000.00? still makes no sense  		frameID != "PCST" && // null data  		frameID != "TCAT" && // category (ie' comedy) (distorted view)  		frameID != "TKWD" && // looks like blog tags "comedy funny weird"' etc (distorted view)  		frameID != "TDES" && // xml file - used by distortedview.com  		frameID != "TGID" && // url (from distortedview)  		frameID != "WFED" && // url (thanks distortedview)  		frameID != "CM1" && // some kind of comment' seen in ID3v2.2  		frameID != "TMB" && // ripped by something other' not in spec  		frameID != "RTNG" && frameID != "XDOR" && // year  		frameID != "XSOP" && // looks like artist' "Allman Brothers Band' The"  		frameID != "TENK")// itunes encoder (todo: add alias?)  		 {  			/*String msg = String.Format("Unrecognized FrameID '{0}' (not critical)"' tmpFrameID);                         Trace.WriteLine(msg);*/}  		UnknownFrame unknownFrame = new UnknownFrame (frameID' tagReadingInfo' stream);  		_unknownFrames.Add (unknownFrame);  		//m_ReadFrames.Add(tmpUNKN);  		bytesRead += unknownFrame.FrameHeader.FrameSizeTotal;  	}  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameContainer,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameContainer.FrameCreation.cs,Read,The following statement contains a magic number: while (bytesRead < readUntil) {  	byte[] frameIDBytes = stream.Read (frameIDSize);  	// If character is not a letter or number' padding reached' audio began'  	// or otherwise the frame is not readable  	if (frameIDSize == 4) {  		if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  			// TODO: Try to keep reading and look for a valid frame  			if (frameIDBytes [0] != 0 && frameIDBytes [0] != 0xFF) {  				string msg = string.Format ("Out of range FrameID - 0x{0:X}|0x{1:X}|0x{2:X}|0x{3:X}"' frameIDBytes [0]' frameIDBytes [1]' frameIDBytes [2]' frameIDBytes [3]);  				if (ByteUtils.ISO88591GetString (frameIDBytes) != "MP3e") {  					string tmpBadFrameID = ByteUtils.ISO88591GetString (frameIDBytes).TrimEnd ('\0');  					Trace.WriteLine (msg + " - " + tmpBadFrameID);  				}  			}  			break;  		}  	} else if (frameIDSize == 3) {  		if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A) {  			// TODO: Try to keep reading and look for a valid frame  			if (frameIDBytes [0] != 0 && frameIDBytes [0] != 0xFF) {  				string msg = string.Format ("Out of range FrameID - 0x{0:X}|0x{1:X}|0x{2:X}"' frameIDBytes [0]' frameIDBytes [1]' frameIDBytes [2]);  				Trace.WriteLine (msg);  				Trace.WriteLine (ByteUtils.ISO88591GetString (frameIDBytes));  			}  			break;  		}  	}  	string frameID = ByteUtils.ISO88591GetString (frameIDBytes);  	// TODO: Take out  	//Console.WriteLine(tmpFrameID); // TODO: take out  	/*                     COMM Frames:                     SoundJam_CDDB_TrackNumber                     SoundJam_CDDB_1                     iTunNORM                     iTunSMPB                     iTunes_CDDB_IDs                     iTunes_CDDB_1                     iTunes_CDDB_TrackNumber                  */IFrame frame;  	do {  		IBindingList bindingList;  		if (singleOccurrenceFrames.TryGetValue (frameID' out frame)) {  			frame.Read (tagReadingInfo' stream);  			bytesRead += frame.FrameHeader.FrameSizeTotal;  			//m_ReadFrames.Add(tmpFrame);  		} else if (multipleOccurrenceFrames.TryGetValue (frameID' out bindingList)) {  			frame = (IFrame)bindingList.AddNew ();  			frame.Read (tagReadingInfo' stream);  			//m_ReadFrames.Add(tmpFrame);  			bytesRead += frame.FrameHeader.FrameSizeTotal;  		} else {  			if (tagVersion == ID3v2TagVersion.ID3v24) {  				string newFrameID;  				if (_id3v24FrameAliases.TryGetValue (frameID' out newFrameID))  					frameID = newFrameID;  				else  					break;  			} else if (tagVersion == ID3v2TagVersion.ID3v23) {  				string newFrameID;  				if (_id3v23FrameAliases.TryGetValue (frameID' out newFrameID))  					frameID = newFrameID;  				else  					break;  			} else {  				break;  			}  		}  	} while (frame == null);  	// Frame is unknown  	if (frame == null) {  		if (frameID != "NCON" && // non standard (old music match)  		frameID != "MJMD" && // Non standard frame (Music Match XML)  		frameID != "TT22" && // 000.00 - maybe meant to be 3 letter TT2 frame' and value be 2000.00? still makes no sense  		frameID != "PCST" && // null data  		frameID != "TCAT" && // category (ie' comedy) (distorted view)  		frameID != "TKWD" && // looks like blog tags "comedy funny weird"' etc (distorted view)  		frameID != "TDES" && // xml file - used by distortedview.com  		frameID != "TGID" && // url (from distortedview)  		frameID != "WFED" && // url (thanks distortedview)  		frameID != "CM1" && // some kind of comment' seen in ID3v2.2  		frameID != "TMB" && // ripped by something other' not in spec  		frameID != "RTNG" && frameID != "XDOR" && // year  		frameID != "XSOP" && // looks like artist' "Allman Brothers Band' The"  		frameID != "TENK")// itunes encoder (todo: add alias?)  		 {  			/*String msg = String.Format("Unrecognized FrameID '{0}' (not critical)"' tmpFrameID);                         Trace.WriteLine(msg);*/}  		UnknownFrame unknownFrame = new UnknownFrame (frameID' tagReadingInfo' stream);  		_unknownFrames.Add (unknownFrame);  		//m_ReadFrames.Add(tmpUNKN);  		bytesRead += unknownFrame.FrameHeader.FrameSizeTotal;  	}  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameContainer,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameContainer.FrameCreation.cs,Read,The following statement contains a magic number: if (frameIDSize == 4) {  	if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  		// TODO: Try to keep reading and look for a valid frame  		if (frameIDBytes [0] != 0 && frameIDBytes [0] != 0xFF) {  			string msg = string.Format ("Out of range FrameID - 0x{0:X}|0x{1:X}|0x{2:X}|0x{3:X}"' frameIDBytes [0]' frameIDBytes [1]' frameIDBytes [2]' frameIDBytes [3]);  			if (ByteUtils.ISO88591GetString (frameIDBytes) != "MP3e") {  				string tmpBadFrameID = ByteUtils.ISO88591GetString (frameIDBytes).TrimEnd ('\0');  				Trace.WriteLine (msg + " - " + tmpBadFrameID);  			}  		}  		break;  	}  } else if (frameIDSize == 3) {  	if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A) {  		// TODO: Try to keep reading and look for a valid frame  		if (frameIDBytes [0] != 0 && frameIDBytes [0] != 0xFF) {  			string msg = string.Format ("Out of range FrameID - 0x{0:X}|0x{1:X}|0x{2:X}"' frameIDBytes [0]' frameIDBytes [1]' frameIDBytes [2]);  			Trace.WriteLine (msg);  			Trace.WriteLine (ByteUtils.ISO88591GetString (frameIDBytes));  		}  		break;  	}  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameContainer,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameContainer.FrameCreation.cs,Read,The following statement contains a magic number: if (frameIDSize == 4) {  	if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  		// TODO: Try to keep reading and look for a valid frame  		if (frameIDBytes [0] != 0 && frameIDBytes [0] != 0xFF) {  			string msg = string.Format ("Out of range FrameID - 0x{0:X}|0x{1:X}|0x{2:X}|0x{3:X}"' frameIDBytes [0]' frameIDBytes [1]' frameIDBytes [2]' frameIDBytes [3]);  			if (ByteUtils.ISO88591GetString (frameIDBytes) != "MP3e") {  				string tmpBadFrameID = ByteUtils.ISO88591GetString (frameIDBytes).TrimEnd ('\0');  				Trace.WriteLine (msg + " - " + tmpBadFrameID);  			}  		}  		break;  	}  } else if (frameIDSize == 3) {  	if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A) {  		// TODO: Try to keep reading and look for a valid frame  		if (frameIDBytes [0] != 0 && frameIDBytes [0] != 0xFF) {  			string msg = string.Format ("Out of range FrameID - 0x{0:X}|0x{1:X}|0x{2:X}"' frameIDBytes [0]' frameIDBytes [1]' frameIDBytes [2]);  			Trace.WriteLine (msg);  			Trace.WriteLine (ByteUtils.ISO88591GetString (frameIDBytes));  		}  		break;  	}  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameContainer,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameContainer.FrameCreation.cs,Read,The following statement contains a magic number: if (frameIDSize == 4) {  	if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  		// TODO: Try to keep reading and look for a valid frame  		if (frameIDBytes [0] != 0 && frameIDBytes [0] != 0xFF) {  			string msg = string.Format ("Out of range FrameID - 0x{0:X}|0x{1:X}|0x{2:X}|0x{3:X}"' frameIDBytes [0]' frameIDBytes [1]' frameIDBytes [2]' frameIDBytes [3]);  			if (ByteUtils.ISO88591GetString (frameIDBytes) != "MP3e") {  				string tmpBadFrameID = ByteUtils.ISO88591GetString (frameIDBytes).TrimEnd ('\0');  				Trace.WriteLine (msg + " - " + tmpBadFrameID);  			}  		}  		break;  	}  } else if (frameIDSize == 3) {  	if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A) {  		// TODO: Try to keep reading and look for a valid frame  		if (frameIDBytes [0] != 0 && frameIDBytes [0] != 0xFF) {  			string msg = string.Format ("Out of range FrameID - 0x{0:X}|0x{1:X}|0x{2:X}"' frameIDBytes [0]' frameIDBytes [1]' frameIDBytes [2]);  			Trace.WriteLine (msg);  			Trace.WriteLine (ByteUtils.ISO88591GetString (frameIDBytes));  		}  		break;  	}  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameContainer,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameContainer.FrameCreation.cs,Read,The following statement contains a magic number: if (frameIDSize == 4) {  	if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  		// TODO: Try to keep reading and look for a valid frame  		if (frameIDBytes [0] != 0 && frameIDBytes [0] != 0xFF) {  			string msg = string.Format ("Out of range FrameID - 0x{0:X}|0x{1:X}|0x{2:X}|0x{3:X}"' frameIDBytes [0]' frameIDBytes [1]' frameIDBytes [2]' frameIDBytes [3]);  			if (ByteUtils.ISO88591GetString (frameIDBytes) != "MP3e") {  				string tmpBadFrameID = ByteUtils.ISO88591GetString (frameIDBytes).TrimEnd ('\0');  				Trace.WriteLine (msg + " - " + tmpBadFrameID);  			}  		}  		break;  	}  } else if (frameIDSize == 3) {  	if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A) {  		// TODO: Try to keep reading and look for a valid frame  		if (frameIDBytes [0] != 0 && frameIDBytes [0] != 0xFF) {  			string msg = string.Format ("Out of range FrameID - 0x{0:X}|0x{1:X}|0x{2:X}"' frameIDBytes [0]' frameIDBytes [1]' frameIDBytes [2]);  			Trace.WriteLine (msg);  			Trace.WriteLine (ByteUtils.ISO88591GetString (frameIDBytes));  		}  		break;  	}  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameContainer,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameContainer.FrameCreation.cs,Read,The following statement contains a magic number: if (frameIDSize == 4) {  	if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  		// TODO: Try to keep reading and look for a valid frame  		if (frameIDBytes [0] != 0 && frameIDBytes [0] != 0xFF) {  			string msg = string.Format ("Out of range FrameID - 0x{0:X}|0x{1:X}|0x{2:X}|0x{3:X}"' frameIDBytes [0]' frameIDBytes [1]' frameIDBytes [2]' frameIDBytes [3]);  			if (ByteUtils.ISO88591GetString (frameIDBytes) != "MP3e") {  				string tmpBadFrameID = ByteUtils.ISO88591GetString (frameIDBytes).TrimEnd ('\0');  				Trace.WriteLine (msg + " - " + tmpBadFrameID);  			}  		}  		break;  	}  } else if (frameIDSize == 3) {  	if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A) {  		// TODO: Try to keep reading and look for a valid frame  		if (frameIDBytes [0] != 0 && frameIDBytes [0] != 0xFF) {  			string msg = string.Format ("Out of range FrameID - 0x{0:X}|0x{1:X}|0x{2:X}"' frameIDBytes [0]' frameIDBytes [1]' frameIDBytes [2]);  			Trace.WriteLine (msg);  			Trace.WriteLine (ByteUtils.ISO88591GetString (frameIDBytes));  		}  		break;  	}  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameContainer,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameContainer.FrameCreation.cs,Read,The following statement contains a magic number: if (frameIDSize == 4) {  	if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  		// TODO: Try to keep reading and look for a valid frame  		if (frameIDBytes [0] != 0 && frameIDBytes [0] != 0xFF) {  			string msg = string.Format ("Out of range FrameID - 0x{0:X}|0x{1:X}|0x{2:X}|0x{3:X}"' frameIDBytes [0]' frameIDBytes [1]' frameIDBytes [2]' frameIDBytes [3]);  			if (ByteUtils.ISO88591GetString (frameIDBytes) != "MP3e") {  				string tmpBadFrameID = ByteUtils.ISO88591GetString (frameIDBytes).TrimEnd ('\0');  				Trace.WriteLine (msg + " - " + tmpBadFrameID);  			}  		}  		break;  	}  } else if (frameIDSize == 3) {  	if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A) {  		// TODO: Try to keep reading and look for a valid frame  		if (frameIDBytes [0] != 0 && frameIDBytes [0] != 0xFF) {  			string msg = string.Format ("Out of range FrameID - 0x{0:X}|0x{1:X}|0x{2:X}"' frameIDBytes [0]' frameIDBytes [1]' frameIDBytes [2]);  			Trace.WriteLine (msg);  			Trace.WriteLine (ByteUtils.ISO88591GetString (frameIDBytes));  		}  		break;  	}  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameContainer,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameContainer.FrameCreation.cs,Read,The following statement contains a magic number: if (frameIDSize == 4) {  	if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  		// TODO: Try to keep reading and look for a valid frame  		if (frameIDBytes [0] != 0 && frameIDBytes [0] != 0xFF) {  			string msg = string.Format ("Out of range FrameID - 0x{0:X}|0x{1:X}|0x{2:X}|0x{3:X}"' frameIDBytes [0]' frameIDBytes [1]' frameIDBytes [2]' frameIDBytes [3]);  			if (ByteUtils.ISO88591GetString (frameIDBytes) != "MP3e") {  				string tmpBadFrameID = ByteUtils.ISO88591GetString (frameIDBytes).TrimEnd ('\0');  				Trace.WriteLine (msg + " - " + tmpBadFrameID);  			}  		}  		break;  	}  } else if (frameIDSize == 3) {  	if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A) {  		// TODO: Try to keep reading and look for a valid frame  		if (frameIDBytes [0] != 0 && frameIDBytes [0] != 0xFF) {  			string msg = string.Format ("Out of range FrameID - 0x{0:X}|0x{1:X}|0x{2:X}"' frameIDBytes [0]' frameIDBytes [1]' frameIDBytes [2]);  			Trace.WriteLine (msg);  			Trace.WriteLine (ByteUtils.ISO88591GetString (frameIDBytes));  		}  		break;  	}  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameContainer,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameContainer.FrameCreation.cs,Read,The following statement contains a magic number: if (frameIDSize == 4) {  	if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  		// TODO: Try to keep reading and look for a valid frame  		if (frameIDBytes [0] != 0 && frameIDBytes [0] != 0xFF) {  			string msg = string.Format ("Out of range FrameID - 0x{0:X}|0x{1:X}|0x{2:X}|0x{3:X}"' frameIDBytes [0]' frameIDBytes [1]' frameIDBytes [2]' frameIDBytes [3]);  			if (ByteUtils.ISO88591GetString (frameIDBytes) != "MP3e") {  				string tmpBadFrameID = ByteUtils.ISO88591GetString (frameIDBytes).TrimEnd ('\0');  				Trace.WriteLine (msg + " - " + tmpBadFrameID);  			}  		}  		break;  	}  } else if (frameIDSize == 3) {  	if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A) {  		// TODO: Try to keep reading and look for a valid frame  		if (frameIDBytes [0] != 0 && frameIDBytes [0] != 0xFF) {  			string msg = string.Format ("Out of range FrameID - 0x{0:X}|0x{1:X}|0x{2:X}"' frameIDBytes [0]' frameIDBytes [1]' frameIDBytes [2]);  			Trace.WriteLine (msg);  			Trace.WriteLine (ByteUtils.ISO88591GetString (frameIDBytes));  		}  		break;  	}  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameContainer,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameContainer.FrameCreation.cs,Read,The following statement contains a magic number: if (frameIDSize == 4) {  	if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  		// TODO: Try to keep reading and look for a valid frame  		if (frameIDBytes [0] != 0 && frameIDBytes [0] != 0xFF) {  			string msg = string.Format ("Out of range FrameID - 0x{0:X}|0x{1:X}|0x{2:X}|0x{3:X}"' frameIDBytes [0]' frameIDBytes [1]' frameIDBytes [2]' frameIDBytes [3]);  			if (ByteUtils.ISO88591GetString (frameIDBytes) != "MP3e") {  				string tmpBadFrameID = ByteUtils.ISO88591GetString (frameIDBytes).TrimEnd ('\0');  				Trace.WriteLine (msg + " - " + tmpBadFrameID);  			}  		}  		break;  	}  } else if (frameIDSize == 3) {  	if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A) {  		// TODO: Try to keep reading and look for a valid frame  		if (frameIDBytes [0] != 0 && frameIDBytes [0] != 0xFF) {  			string msg = string.Format ("Out of range FrameID - 0x{0:X}|0x{1:X}|0x{2:X}"' frameIDBytes [0]' frameIDBytes [1]' frameIDBytes [2]);  			Trace.WriteLine (msg);  			Trace.WriteLine (ByteUtils.ISO88591GetString (frameIDBytes));  		}  		break;  	}  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameContainer,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameContainer.FrameCreation.cs,Read,The following statement contains a magic number: if (frameIDSize == 4) {  	if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  		// TODO: Try to keep reading and look for a valid frame  		if (frameIDBytes [0] != 0 && frameIDBytes [0] != 0xFF) {  			string msg = string.Format ("Out of range FrameID - 0x{0:X}|0x{1:X}|0x{2:X}|0x{3:X}"' frameIDBytes [0]' frameIDBytes [1]' frameIDBytes [2]' frameIDBytes [3]);  			if (ByteUtils.ISO88591GetString (frameIDBytes) != "MP3e") {  				string tmpBadFrameID = ByteUtils.ISO88591GetString (frameIDBytes).TrimEnd ('\0');  				Trace.WriteLine (msg + " - " + tmpBadFrameID);  			}  		}  		break;  	}  } else if (frameIDSize == 3) {  	if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A) {  		// TODO: Try to keep reading and look for a valid frame  		if (frameIDBytes [0] != 0 && frameIDBytes [0] != 0xFF) {  			string msg = string.Format ("Out of range FrameID - 0x{0:X}|0x{1:X}|0x{2:X}"' frameIDBytes [0]' frameIDBytes [1]' frameIDBytes [2]);  			Trace.WriteLine (msg);  			Trace.WriteLine (ByteUtils.ISO88591GetString (frameIDBytes));  		}  		break;  	}  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameContainer,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameContainer.FrameCreation.cs,Read,The following statement contains a magic number: if (frameIDSize == 4) {  	if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  		// TODO: Try to keep reading and look for a valid frame  		if (frameIDBytes [0] != 0 && frameIDBytes [0] != 0xFF) {  			string msg = string.Format ("Out of range FrameID - 0x{0:X}|0x{1:X}|0x{2:X}|0x{3:X}"' frameIDBytes [0]' frameIDBytes [1]' frameIDBytes [2]' frameIDBytes [3]);  			if (ByteUtils.ISO88591GetString (frameIDBytes) != "MP3e") {  				string tmpBadFrameID = ByteUtils.ISO88591GetString (frameIDBytes).TrimEnd ('\0');  				Trace.WriteLine (msg + " - " + tmpBadFrameID);  			}  		}  		break;  	}  } else if (frameIDSize == 3) {  	if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A) {  		// TODO: Try to keep reading and look for a valid frame  		if (frameIDBytes [0] != 0 && frameIDBytes [0] != 0xFF) {  			string msg = string.Format ("Out of range FrameID - 0x{0:X}|0x{1:X}|0x{2:X}"' frameIDBytes [0]' frameIDBytes [1]' frameIDBytes [2]);  			Trace.WriteLine (msg);  			Trace.WriteLine (ByteUtils.ISO88591GetString (frameIDBytes));  		}  		break;  	}  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameContainer,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameContainer.FrameCreation.cs,Read,The following statement contains a magic number: if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  	// TODO: Try to keep reading and look for a valid frame  	if (frameIDBytes [0] != 0 && frameIDBytes [0] != 0xFF) {  		string msg = string.Format ("Out of range FrameID - 0x{0:X}|0x{1:X}|0x{2:X}|0x{3:X}"' frameIDBytes [0]' frameIDBytes [1]' frameIDBytes [2]' frameIDBytes [3]);  		if (ByteUtils.ISO88591GetString (frameIDBytes) != "MP3e") {  			string tmpBadFrameID = ByteUtils.ISO88591GetString (frameIDBytes).TrimEnd ('\0');  			Trace.WriteLine (msg + " - " + tmpBadFrameID);  		}  	}  	break;  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameContainer,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameContainer.FrameCreation.cs,Read,The following statement contains a magic number: if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  	// TODO: Try to keep reading and look for a valid frame  	if (frameIDBytes [0] != 0 && frameIDBytes [0] != 0xFF) {  		string msg = string.Format ("Out of range FrameID - 0x{0:X}|0x{1:X}|0x{2:X}|0x{3:X}"' frameIDBytes [0]' frameIDBytes [1]' frameIDBytes [2]' frameIDBytes [3]);  		if (ByteUtils.ISO88591GetString (frameIDBytes) != "MP3e") {  			string tmpBadFrameID = ByteUtils.ISO88591GetString (frameIDBytes).TrimEnd ('\0');  			Trace.WriteLine (msg + " - " + tmpBadFrameID);  		}  	}  	break;  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameContainer,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameContainer.FrameCreation.cs,Read,The following statement contains a magic number: if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  	// TODO: Try to keep reading and look for a valid frame  	if (frameIDBytes [0] != 0 && frameIDBytes [0] != 0xFF) {  		string msg = string.Format ("Out of range FrameID - 0x{0:X}|0x{1:X}|0x{2:X}|0x{3:X}"' frameIDBytes [0]' frameIDBytes [1]' frameIDBytes [2]' frameIDBytes [3]);  		if (ByteUtils.ISO88591GetString (frameIDBytes) != "MP3e") {  			string tmpBadFrameID = ByteUtils.ISO88591GetString (frameIDBytes).TrimEnd ('\0');  			Trace.WriteLine (msg + " - " + tmpBadFrameID);  		}  	}  	break;  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameContainer,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameContainer.FrameCreation.cs,Read,The following statement contains a magic number: if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  	// TODO: Try to keep reading and look for a valid frame  	if (frameIDBytes [0] != 0 && frameIDBytes [0] != 0xFF) {  		string msg = string.Format ("Out of range FrameID - 0x{0:X}|0x{1:X}|0x{2:X}|0x{3:X}"' frameIDBytes [0]' frameIDBytes [1]' frameIDBytes [2]' frameIDBytes [3]);  		if (ByteUtils.ISO88591GetString (frameIDBytes) != "MP3e") {  			string tmpBadFrameID = ByteUtils.ISO88591GetString (frameIDBytes).TrimEnd ('\0');  			Trace.WriteLine (msg + " - " + tmpBadFrameID);  		}  	}  	break;  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameContainer,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameContainer.FrameCreation.cs,Read,The following statement contains a magic number: if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  	// TODO: Try to keep reading and look for a valid frame  	if (frameIDBytes [0] != 0 && frameIDBytes [0] != 0xFF) {  		string msg = string.Format ("Out of range FrameID - 0x{0:X}|0x{1:X}|0x{2:X}|0x{3:X}"' frameIDBytes [0]' frameIDBytes [1]' frameIDBytes [2]' frameIDBytes [3]);  		if (ByteUtils.ISO88591GetString (frameIDBytes) != "MP3e") {  			string tmpBadFrameID = ByteUtils.ISO88591GetString (frameIDBytes).TrimEnd ('\0');  			Trace.WriteLine (msg + " - " + tmpBadFrameID);  		}  	}  	break;  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameContainer,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameContainer.FrameCreation.cs,Read,The following statement contains a magic number: if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  	// TODO: Try to keep reading and look for a valid frame  	if (frameIDBytes [0] != 0 && frameIDBytes [0] != 0xFF) {  		string msg = string.Format ("Out of range FrameID - 0x{0:X}|0x{1:X}|0x{2:X}|0x{3:X}"' frameIDBytes [0]' frameIDBytes [1]' frameIDBytes [2]' frameIDBytes [3]);  		if (ByteUtils.ISO88591GetString (frameIDBytes) != "MP3e") {  			string tmpBadFrameID = ByteUtils.ISO88591GetString (frameIDBytes).TrimEnd ('\0');  			Trace.WriteLine (msg + " - " + tmpBadFrameID);  		}  	}  	break;  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameContainer,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameContainer.FrameCreation.cs,Read,The following statement contains a magic number: if (frameIDBytes [0] != 0 && frameIDBytes [0] != 0xFF) {  	string msg = string.Format ("Out of range FrameID - 0x{0:X}|0x{1:X}|0x{2:X}|0x{3:X}"' frameIDBytes [0]' frameIDBytes [1]' frameIDBytes [2]' frameIDBytes [3]);  	if (ByteUtils.ISO88591GetString (frameIDBytes) != "MP3e") {  		string tmpBadFrameID = ByteUtils.ISO88591GetString (frameIDBytes).TrimEnd ('\0');  		Trace.WriteLine (msg + " - " + tmpBadFrameID);  	}  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameContainer,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameContainer.FrameCreation.cs,Read,The following statement contains a magic number: if (frameIDBytes [0] != 0 && frameIDBytes [0] != 0xFF) {  	string msg = string.Format ("Out of range FrameID - 0x{0:X}|0x{1:X}|0x{2:X}|0x{3:X}"' frameIDBytes [0]' frameIDBytes [1]' frameIDBytes [2]' frameIDBytes [3]);  	if (ByteUtils.ISO88591GetString (frameIDBytes) != "MP3e") {  		string tmpBadFrameID = ByteUtils.ISO88591GetString (frameIDBytes).TrimEnd ('\0');  		Trace.WriteLine (msg + " - " + tmpBadFrameID);  	}  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameContainer,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameContainer.FrameCreation.cs,Read,The following statement contains a magic number: if (frameIDSize == 3) {  	if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A) {  		// TODO: Try to keep reading and look for a valid frame  		if (frameIDBytes [0] != 0 && frameIDBytes [0] != 0xFF) {  			string msg = string.Format ("Out of range FrameID - 0x{0:X}|0x{1:X}|0x{2:X}"' frameIDBytes [0]' frameIDBytes [1]' frameIDBytes [2]);  			Trace.WriteLine (msg);  			Trace.WriteLine (ByteUtils.ISO88591GetString (frameIDBytes));  		}  		break;  	}  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameContainer,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameContainer.FrameCreation.cs,Read,The following statement contains a magic number: if (frameIDSize == 3) {  	if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A) {  		// TODO: Try to keep reading and look for a valid frame  		if (frameIDBytes [0] != 0 && frameIDBytes [0] != 0xFF) {  			string msg = string.Format ("Out of range FrameID - 0x{0:X}|0x{1:X}|0x{2:X}"' frameIDBytes [0]' frameIDBytes [1]' frameIDBytes [2]);  			Trace.WriteLine (msg);  			Trace.WriteLine (ByteUtils.ISO88591GetString (frameIDBytes));  		}  		break;  	}  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameContainer,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameContainer.FrameCreation.cs,Read,The following statement contains a magic number: if (frameIDSize == 3) {  	if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A) {  		// TODO: Try to keep reading and look for a valid frame  		if (frameIDBytes [0] != 0 && frameIDBytes [0] != 0xFF) {  			string msg = string.Format ("Out of range FrameID - 0x{0:X}|0x{1:X}|0x{2:X}"' frameIDBytes [0]' frameIDBytes [1]' frameIDBytes [2]);  			Trace.WriteLine (msg);  			Trace.WriteLine (ByteUtils.ISO88591GetString (frameIDBytes));  		}  		break;  	}  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameContainer,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameContainer.FrameCreation.cs,Read,The following statement contains a magic number: if (frameIDSize == 3) {  	if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A) {  		// TODO: Try to keep reading and look for a valid frame  		if (frameIDBytes [0] != 0 && frameIDBytes [0] != 0xFF) {  			string msg = string.Format ("Out of range FrameID - 0x{0:X}|0x{1:X}|0x{2:X}"' frameIDBytes [0]' frameIDBytes [1]' frameIDBytes [2]);  			Trace.WriteLine (msg);  			Trace.WriteLine (ByteUtils.ISO88591GetString (frameIDBytes));  		}  		break;  	}  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameContainer,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameContainer.FrameCreation.cs,Read,The following statement contains a magic number: if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A) {  	// TODO: Try to keep reading and look for a valid frame  	if (frameIDBytes [0] != 0 && frameIDBytes [0] != 0xFF) {  		string msg = string.Format ("Out of range FrameID - 0x{0:X}|0x{1:X}|0x{2:X}"' frameIDBytes [0]' frameIDBytes [1]' frameIDBytes [2]);  		Trace.WriteLine (msg);  		Trace.WriteLine (ByteUtils.ISO88591GetString (frameIDBytes));  	}  	break;  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameContainer,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameContainer.FrameCreation.cs,Read,The following statement contains a magic number: if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A) {  	// TODO: Try to keep reading and look for a valid frame  	if (frameIDBytes [0] != 0 && frameIDBytes [0] != 0xFF) {  		string msg = string.Format ("Out of range FrameID - 0x{0:X}|0x{1:X}|0x{2:X}"' frameIDBytes [0]' frameIDBytes [1]' frameIDBytes [2]);  		Trace.WriteLine (msg);  		Trace.WriteLine (ByteUtils.ISO88591GetString (frameIDBytes));  	}  	break;  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameContainer,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameContainer.FrameCreation.cs,Read,The following statement contains a magic number: if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A) {  	// TODO: Try to keep reading and look for a valid frame  	if (frameIDBytes [0] != 0 && frameIDBytes [0] != 0xFF) {  		string msg = string.Format ("Out of range FrameID - 0x{0:X}|0x{1:X}|0x{2:X}"' frameIDBytes [0]' frameIDBytes [1]' frameIDBytes [2]);  		Trace.WriteLine (msg);  		Trace.WriteLine (ByteUtils.ISO88591GetString (frameIDBytes));  	}  	break;  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameContainer,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameContainer.FrameCreation.cs,Read,The following statement contains a magic number: if (frameIDBytes [0] != 0 && frameIDBytes [0] != 0xFF) {  	string msg = string.Format ("Out of range FrameID - 0x{0:X}|0x{1:X}|0x{2:X}"' frameIDBytes [0]' frameIDBytes [1]' frameIDBytes [2]);  	Trace.WriteLine (msg);  	Trace.WriteLine (ByteUtils.ISO88591GetString (frameIDBytes));  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2Tag.cs,Read,The following statement contains a magic number: try {  	// Open the file and read from the stream  	using (Stream stream = File.Open (path' FileMode.Open' FileAccess.Read' FileShare.Read)) {  		if (stream.Length < 10)  			return;  		Read (stream);  	}  } catch (Exception ex) {  	throw new Exception (String.Format ("Error reading '{0}'"' path)' ex);  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2Tag.cs,Read,The following statement contains a magic number: using (Stream stream = File.Open (path' FileMode.Open' FileAccess.Read' FileShare.Read)) {  	if (stream.Length < 10)  		return;  	Read (stream);  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2Tag.cs,Read,The following statement contains a magic number: if (stream.Length < 10)  	return;  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2Tag.cs,GetBytes,The following statement contains a magic number: using (MemoryStream tag = new MemoryStream ()) {  	byte[] framesByteArray = GetBytes (tagVersion);  	int tagSize = framesByteArray.Length;  	_id3v2Header.UsesUnsynchronization = false;  	// hack  	_id3v2Header.IsExperimental = true;  	// hack  	//_id3v2ExtendedHeader.IsCRCDataPresent = true; // hack: for testing  	//_id3v2Header.HasExtendedHeader = true; // hack: for testing  	if (_id3v2Header.HasExtendedHeader) {  		// Add total size of extended header  		tagSize += _id3v2ExtendedHeader.SizeExcludingSizeBytes + 4;  	}  	int paddingSize = minimumSize - (tagSize + 10);  	if (paddingSize < 0) {  		paddingSize = 2000;  	}  	tagSize += paddingSize;  	// Set tag size in ID3v2 header  	_id3v2Header.TagSize = tagSize;  	byte[] id3v2Header = _id3v2Header.GetBytes ();  	tag.Write (id3v2Header' 0' id3v2Header.Length);  	if (_id3v2Header.HasExtendedHeader) {  		if (_id3v2ExtendedHeader.IsCRCDataPresent) {  			// TODO: Calculate total frame CRC (before or after unsync? compression? encr?)  			_id3v2ExtendedHeader.CRC32 = CRC32.CalculateInt32 (framesByteArray);  		}  		// Set padding size  		_id3v2ExtendedHeader.PaddingSize = paddingSize;  		// todo: check  		byte[] id3v2ExtendedHeader = _id3v2ExtendedHeader.GetBytes (tagVersion);  		tag.Write (id3v2ExtendedHeader' 0' id3v2ExtendedHeader.Length);  	}  	tag.Write (framesByteArray' 0' framesByteArray.Length);  	byte[] padding = new byte[paddingSize];  	tag.Write (padding' 0' paddingSize);  	// Make sure WE can read it without throwing errors  	// TODO: Take this out eventually' this is just a precaution.  	tag.Position = 0;  	ID3v2Tag newID3v2 = new ID3v2Tag ();  	newID3v2.Read (tag);  	return tag.ToArray ();  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2Tag.cs,GetBytes,The following statement contains a magic number: using (MemoryStream tag = new MemoryStream ()) {  	byte[] framesByteArray = GetBytes (tagVersion);  	int tagSize = framesByteArray.Length;  	_id3v2Header.UsesUnsynchronization = false;  	// hack  	_id3v2Header.IsExperimental = true;  	// hack  	//_id3v2ExtendedHeader.IsCRCDataPresent = true; // hack: for testing  	//_id3v2Header.HasExtendedHeader = true; // hack: for testing  	if (_id3v2Header.HasExtendedHeader) {  		// Add total size of extended header  		tagSize += _id3v2ExtendedHeader.SizeExcludingSizeBytes + 4;  	}  	int paddingSize = minimumSize - (tagSize + 10);  	if (paddingSize < 0) {  		paddingSize = 2000;  	}  	tagSize += paddingSize;  	// Set tag size in ID3v2 header  	_id3v2Header.TagSize = tagSize;  	byte[] id3v2Header = _id3v2Header.GetBytes ();  	tag.Write (id3v2Header' 0' id3v2Header.Length);  	if (_id3v2Header.HasExtendedHeader) {  		if (_id3v2ExtendedHeader.IsCRCDataPresent) {  			// TODO: Calculate total frame CRC (before or after unsync? compression? encr?)  			_id3v2ExtendedHeader.CRC32 = CRC32.CalculateInt32 (framesByteArray);  		}  		// Set padding size  		_id3v2ExtendedHeader.PaddingSize = paddingSize;  		// todo: check  		byte[] id3v2ExtendedHeader = _id3v2ExtendedHeader.GetBytes (tagVersion);  		tag.Write (id3v2ExtendedHeader' 0' id3v2ExtendedHeader.Length);  	}  	tag.Write (framesByteArray' 0' framesByteArray.Length);  	byte[] padding = new byte[paddingSize];  	tag.Write (padding' 0' paddingSize);  	// Make sure WE can read it without throwing errors  	// TODO: Take this out eventually' this is just a precaution.  	tag.Position = 0;  	ID3v2Tag newID3v2 = new ID3v2Tag ();  	newID3v2.Read (tag);  	return tag.ToArray ();  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2Tag.cs,GetBytes,The following statement contains a magic number: using (MemoryStream tag = new MemoryStream ()) {  	byte[] framesByteArray = GetBytes (tagVersion);  	int tagSize = framesByteArray.Length;  	_id3v2Header.UsesUnsynchronization = false;  	// hack  	_id3v2Header.IsExperimental = true;  	// hack  	//_id3v2ExtendedHeader.IsCRCDataPresent = true; // hack: for testing  	//_id3v2Header.HasExtendedHeader = true; // hack: for testing  	if (_id3v2Header.HasExtendedHeader) {  		// Add total size of extended header  		tagSize += _id3v2ExtendedHeader.SizeExcludingSizeBytes + 4;  	}  	int paddingSize = minimumSize - (tagSize + 10);  	if (paddingSize < 0) {  		paddingSize = 2000;  	}  	tagSize += paddingSize;  	// Set tag size in ID3v2 header  	_id3v2Header.TagSize = tagSize;  	byte[] id3v2Header = _id3v2Header.GetBytes ();  	tag.Write (id3v2Header' 0' id3v2Header.Length);  	if (_id3v2Header.HasExtendedHeader) {  		if (_id3v2ExtendedHeader.IsCRCDataPresent) {  			// TODO: Calculate total frame CRC (before or after unsync? compression? encr?)  			_id3v2ExtendedHeader.CRC32 = CRC32.CalculateInt32 (framesByteArray);  		}  		// Set padding size  		_id3v2ExtendedHeader.PaddingSize = paddingSize;  		// todo: check  		byte[] id3v2ExtendedHeader = _id3v2ExtendedHeader.GetBytes (tagVersion);  		tag.Write (id3v2ExtendedHeader' 0' id3v2ExtendedHeader.Length);  	}  	tag.Write (framesByteArray' 0' framesByteArray.Length);  	byte[] padding = new byte[paddingSize];  	tag.Write (padding' 0' paddingSize);  	// Make sure WE can read it without throwing errors  	// TODO: Take this out eventually' this is just a precaution.  	tag.Position = 0;  	ID3v2Tag newID3v2 = new ID3v2Tag ();  	newID3v2.Read (tag);  	return tag.ToArray ();  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2Tag.cs,GetBytes,The following statement contains a magic number: if (_id3v2Header.HasExtendedHeader) {  	// Add total size of extended header  	tagSize += _id3v2ExtendedHeader.SizeExcludingSizeBytes + 4;  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2Tag.cs,GetBytes,The following statement contains a magic number: tagSize += _id3v2ExtendedHeader.SizeExcludingSizeBytes + 4;  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2Tag.cs,GetBytes,The following statement contains a magic number: if (paddingSize < 0) {  	paddingSize = 2000;  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2Tag.cs,GetBytes,The following statement contains a magic number: paddingSize = 2000;  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2Tag.cs,Read,The following statement contains a magic number: if (!(identifier [0] == 0x49 && identifier [1] == 0x44 && identifier [2] == 0x33)) {  	return;  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2Tag.cs,Read,The following statement contains a magic number: if (_id3v2Header.TagVersion == ID3v2TagVersion.ID3v24) {  	bool isID3v24SyncSafe = true;  	bytesRead = 0;  	readUntil = _id3v2Header.TagSize - _id3v2ExtendedHeader.SizeIncludingSizeBytes - frameIDSize;  	long initialPosition = stream.Position;  	while (bytesRead < readUntil) {  		byte[] frameIDBytes = stream.Read (frameIDSize);  		// TODO: Noticed some tags contain 0x00 'E' 'N' as a FrameID.  Frame is well structured  		// and other frames follow.  I believe the below (keep reading+looking) will cover this issue.  		// If character is not a letter or number' padding reached' audio began'  		// or otherwise the frame is not readable  		if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  			// TODO: Try to keep reading and look for a valid frame  			if (frameIDBytes [0] != 0 && frameIDBytes [0] != 0xFF) {  				/*String msg = String.Format("Out of range FrameID - 0x{0:X}|0x{1:X}|0x{2:X}|0x{3:X}"'                                                        tmpFrameIDBytes[0]' tmpFrameIDBytes[1]' tmpFrameIDBytes[2]'                                                        tmpFrameIDBytes[3]);                             Trace.WriteLine(msg);*/}  			break;  		}  		int frameSize = stream.ReadInt32 ();  		if (frameSize > 0xFF) {  			if ((frameSize & 0x80) == 0x80) {  				isID3v24SyncSafe = false;  				break;  			}  			if ((frameSize & 0x8000) == 0x8000) {  				isID3v24SyncSafe = false;  				break;  			}  			if ((frameSize & 0x800000) == 0x800000) {  				isID3v24SyncSafe = false;  				break;  			}  			if (bytesRead + frameSize + 10 == _id3v2Header.TagSize) {  				// Could give a false positive' but relatively unlikely (famous last words' huh?)  				isID3v24SyncSafe = false;  				break;  			} else {  				stream.Seek (-4' SeekOrigin.Current);  				// go back to read sync-safe version  				int syncSafeFrameSize = ID3v2Utils.ReadInt32SyncSafe (stream);  				long currentPosition = stream.Position;  				bool isValidAtSyncSafe = true;  				bool isValidAtNonSyncSafe = true;  				// TODO - if it's the last frame and there is padding' both would indicate false  				// Use the one that returns some padding bytes opposed to bytes with non-zero values (could be frame data)  				// If non sync-safe reads past the end of the tag' then it's sync safe  				// Testing non-sync safe since it will always be bigger than the sync safe integer  				if (currentPosition + frameSize + 2 >= readUntil) {  					isID3v24SyncSafe = true;  					break;  				}  				// Test non-sync safe  				stream.Seek (currentPosition + frameSize + 2' SeekOrigin.Begin);  				frameIDBytes = stream.Read (frameIDSize);  				if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  					isValidAtNonSyncSafe = false;  				}  				// Test sync-safe  				stream.Seek (currentPosition + syncSafeFrameSize + 2' SeekOrigin.Begin);  				frameIDBytes = stream.Read (frameIDSize);  				if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  					isValidAtSyncSafe = false;  				}  				// if they're equal' we'll just have to go with syncsafe' since that's the spec  				if (isValidAtNonSyncSafe != isValidAtSyncSafe) {  					isID3v24SyncSafe = isValidAtSyncSafe;  				}  				break;  			}  		}  		stream.Seek (frameSize + 2' SeekOrigin.Current);  		bytesRead += frameSize + 10;  	}  	stream.Position = initialPosition;  	if (isID3v24SyncSafe == false) {  		tagReadingInfo.TagVersionOptions |= TagVersionOptions.UseNonSyncSafeFrameSizeID3v24;  	}  } else if (_id3v2Header.TagVersion == ID3v2TagVersion.ID3v22) {  	bool isID3v22CorrectSize = true;  	bytesRead = 0;  	readUntil = _id3v2Header.TagSize - _id3v2ExtendedHeader.SizeIncludingSizeBytes - frameIDSize;  	long initialPosition = stream.Position;  	stream.Read (frameIDSize);  	UnknownFrame unknownFrame = new UnknownFrame (null' tagReadingInfo' stream);  	bytesRead += unknownFrame.FrameHeader.FrameSizeTotal;  	if (bytesRead < readUntil) {  		byte[] frameIDBytes = stream.Read (frameIDSize);  		// TODO: Noticed some tags contain 0x00 'E' 'N' as a FrameID.  Frame is well structured  		// and other frames follow.  I believe the below (keep reading+looking) will cover this issue.  		// If character is not a letter or number' padding reached' audio began'  		// or otherwise the frame is not readable  		if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A) {  			if (frameIDBytes [1] >= 0x30 && frameIDBytes [1] <= 0x5A && frameIDBytes [2] >= 0x30 && frameIDBytes [2] <= 0x5A) {  				Trace.WriteLine ("ID3v2.2 frame size off by 1 byte");  				isID3v22CorrectSize = false;  			}  		}  	}  	stream.Position = initialPosition;  	if (isID3v22CorrectSize == false) {  		tagReadingInfo.TagVersionOptions |= TagVersionOptions.AddOneByteToSize;  	}  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2Tag.cs,Read,The following statement contains a magic number: if (_id3v2Header.TagVersion == ID3v2TagVersion.ID3v24) {  	bool isID3v24SyncSafe = true;  	bytesRead = 0;  	readUntil = _id3v2Header.TagSize - _id3v2ExtendedHeader.SizeIncludingSizeBytes - frameIDSize;  	long initialPosition = stream.Position;  	while (bytesRead < readUntil) {  		byte[] frameIDBytes = stream.Read (frameIDSize);  		// TODO: Noticed some tags contain 0x00 'E' 'N' as a FrameID.  Frame is well structured  		// and other frames follow.  I believe the below (keep reading+looking) will cover this issue.  		// If character is not a letter or number' padding reached' audio began'  		// or otherwise the frame is not readable  		if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  			// TODO: Try to keep reading and look for a valid frame  			if (frameIDBytes [0] != 0 && frameIDBytes [0] != 0xFF) {  				/*String msg = String.Format("Out of range FrameID - 0x{0:X}|0x{1:X}|0x{2:X}|0x{3:X}"'                                                        tmpFrameIDBytes[0]' tmpFrameIDBytes[1]' tmpFrameIDBytes[2]'                                                        tmpFrameIDBytes[3]);                             Trace.WriteLine(msg);*/}  			break;  		}  		int frameSize = stream.ReadInt32 ();  		if (frameSize > 0xFF) {  			if ((frameSize & 0x80) == 0x80) {  				isID3v24SyncSafe = false;  				break;  			}  			if ((frameSize & 0x8000) == 0x8000) {  				isID3v24SyncSafe = false;  				break;  			}  			if ((frameSize & 0x800000) == 0x800000) {  				isID3v24SyncSafe = false;  				break;  			}  			if (bytesRead + frameSize + 10 == _id3v2Header.TagSize) {  				// Could give a false positive' but relatively unlikely (famous last words' huh?)  				isID3v24SyncSafe = false;  				break;  			} else {  				stream.Seek (-4' SeekOrigin.Current);  				// go back to read sync-safe version  				int syncSafeFrameSize = ID3v2Utils.ReadInt32SyncSafe (stream);  				long currentPosition = stream.Position;  				bool isValidAtSyncSafe = true;  				bool isValidAtNonSyncSafe = true;  				// TODO - if it's the last frame and there is padding' both would indicate false  				// Use the one that returns some padding bytes opposed to bytes with non-zero values (could be frame data)  				// If non sync-safe reads past the end of the tag' then it's sync safe  				// Testing non-sync safe since it will always be bigger than the sync safe integer  				if (currentPosition + frameSize + 2 >= readUntil) {  					isID3v24SyncSafe = true;  					break;  				}  				// Test non-sync safe  				stream.Seek (currentPosition + frameSize + 2' SeekOrigin.Begin);  				frameIDBytes = stream.Read (frameIDSize);  				if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  					isValidAtNonSyncSafe = false;  				}  				// Test sync-safe  				stream.Seek (currentPosition + syncSafeFrameSize + 2' SeekOrigin.Begin);  				frameIDBytes = stream.Read (frameIDSize);  				if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  					isValidAtSyncSafe = false;  				}  				// if they're equal' we'll just have to go with syncsafe' since that's the spec  				if (isValidAtNonSyncSafe != isValidAtSyncSafe) {  					isID3v24SyncSafe = isValidAtSyncSafe;  				}  				break;  			}  		}  		stream.Seek (frameSize + 2' SeekOrigin.Current);  		bytesRead += frameSize + 10;  	}  	stream.Position = initialPosition;  	if (isID3v24SyncSafe == false) {  		tagReadingInfo.TagVersionOptions |= TagVersionOptions.UseNonSyncSafeFrameSizeID3v24;  	}  } else if (_id3v2Header.TagVersion == ID3v2TagVersion.ID3v22) {  	bool isID3v22CorrectSize = true;  	bytesRead = 0;  	readUntil = _id3v2Header.TagSize - _id3v2ExtendedHeader.SizeIncludingSizeBytes - frameIDSize;  	long initialPosition = stream.Position;  	stream.Read (frameIDSize);  	UnknownFrame unknownFrame = new UnknownFrame (null' tagReadingInfo' stream);  	bytesRead += unknownFrame.FrameHeader.FrameSizeTotal;  	if (bytesRead < readUntil) {  		byte[] frameIDBytes = stream.Read (frameIDSize);  		// TODO: Noticed some tags contain 0x00 'E' 'N' as a FrameID.  Frame is well structured  		// and other frames follow.  I believe the below (keep reading+looking) will cover this issue.  		// If character is not a letter or number' padding reached' audio began'  		// or otherwise the frame is not readable  		if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A) {  			if (frameIDBytes [1] >= 0x30 && frameIDBytes [1] <= 0x5A && frameIDBytes [2] >= 0x30 && frameIDBytes [2] <= 0x5A) {  				Trace.WriteLine ("ID3v2.2 frame size off by 1 byte");  				isID3v22CorrectSize = false;  			}  		}  	}  	stream.Position = initialPosition;  	if (isID3v22CorrectSize == false) {  		tagReadingInfo.TagVersionOptions |= TagVersionOptions.AddOneByteToSize;  	}  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2Tag.cs,Read,The following statement contains a magic number: if (_id3v2Header.TagVersion == ID3v2TagVersion.ID3v24) {  	bool isID3v24SyncSafe = true;  	bytesRead = 0;  	readUntil = _id3v2Header.TagSize - _id3v2ExtendedHeader.SizeIncludingSizeBytes - frameIDSize;  	long initialPosition = stream.Position;  	while (bytesRead < readUntil) {  		byte[] frameIDBytes = stream.Read (frameIDSize);  		// TODO: Noticed some tags contain 0x00 'E' 'N' as a FrameID.  Frame is well structured  		// and other frames follow.  I believe the below (keep reading+looking) will cover this issue.  		// If character is not a letter or number' padding reached' audio began'  		// or otherwise the frame is not readable  		if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  			// TODO: Try to keep reading and look for a valid frame  			if (frameIDBytes [0] != 0 && frameIDBytes [0] != 0xFF) {  				/*String msg = String.Format("Out of range FrameID - 0x{0:X}|0x{1:X}|0x{2:X}|0x{3:X}"'                                                        tmpFrameIDBytes[0]' tmpFrameIDBytes[1]' tmpFrameIDBytes[2]'                                                        tmpFrameIDBytes[3]);                             Trace.WriteLine(msg);*/}  			break;  		}  		int frameSize = stream.ReadInt32 ();  		if (frameSize > 0xFF) {  			if ((frameSize & 0x80) == 0x80) {  				isID3v24SyncSafe = false;  				break;  			}  			if ((frameSize & 0x8000) == 0x8000) {  				isID3v24SyncSafe = false;  				break;  			}  			if ((frameSize & 0x800000) == 0x800000) {  				isID3v24SyncSafe = false;  				break;  			}  			if (bytesRead + frameSize + 10 == _id3v2Header.TagSize) {  				// Could give a false positive' but relatively unlikely (famous last words' huh?)  				isID3v24SyncSafe = false;  				break;  			} else {  				stream.Seek (-4' SeekOrigin.Current);  				// go back to read sync-safe version  				int syncSafeFrameSize = ID3v2Utils.ReadInt32SyncSafe (stream);  				long currentPosition = stream.Position;  				bool isValidAtSyncSafe = true;  				bool isValidAtNonSyncSafe = true;  				// TODO - if it's the last frame and there is padding' both would indicate false  				// Use the one that returns some padding bytes opposed to bytes with non-zero values (could be frame data)  				// If non sync-safe reads past the end of the tag' then it's sync safe  				// Testing non-sync safe since it will always be bigger than the sync safe integer  				if (currentPosition + frameSize + 2 >= readUntil) {  					isID3v24SyncSafe = true;  					break;  				}  				// Test non-sync safe  				stream.Seek (currentPosition + frameSize + 2' SeekOrigin.Begin);  				frameIDBytes = stream.Read (frameIDSize);  				if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  					isValidAtNonSyncSafe = false;  				}  				// Test sync-safe  				stream.Seek (currentPosition + syncSafeFrameSize + 2' SeekOrigin.Begin);  				frameIDBytes = stream.Read (frameIDSize);  				if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  					isValidAtSyncSafe = false;  				}  				// if they're equal' we'll just have to go with syncsafe' since that's the spec  				if (isValidAtNonSyncSafe != isValidAtSyncSafe) {  					isID3v24SyncSafe = isValidAtSyncSafe;  				}  				break;  			}  		}  		stream.Seek (frameSize + 2' SeekOrigin.Current);  		bytesRead += frameSize + 10;  	}  	stream.Position = initialPosition;  	if (isID3v24SyncSafe == false) {  		tagReadingInfo.TagVersionOptions |= TagVersionOptions.UseNonSyncSafeFrameSizeID3v24;  	}  } else if (_id3v2Header.TagVersion == ID3v2TagVersion.ID3v22) {  	bool isID3v22CorrectSize = true;  	bytesRead = 0;  	readUntil = _id3v2Header.TagSize - _id3v2ExtendedHeader.SizeIncludingSizeBytes - frameIDSize;  	long initialPosition = stream.Position;  	stream.Read (frameIDSize);  	UnknownFrame unknownFrame = new UnknownFrame (null' tagReadingInfo' stream);  	bytesRead += unknownFrame.FrameHeader.FrameSizeTotal;  	if (bytesRead < readUntil) {  		byte[] frameIDBytes = stream.Read (frameIDSize);  		// TODO: Noticed some tags contain 0x00 'E' 'N' as a FrameID.  Frame is well structured  		// and other frames follow.  I believe the below (keep reading+looking) will cover this issue.  		// If character is not a letter or number' padding reached' audio began'  		// or otherwise the frame is not readable  		if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A) {  			if (frameIDBytes [1] >= 0x30 && frameIDBytes [1] <= 0x5A && frameIDBytes [2] >= 0x30 && frameIDBytes [2] <= 0x5A) {  				Trace.WriteLine ("ID3v2.2 frame size off by 1 byte");  				isID3v22CorrectSize = false;  			}  		}  	}  	stream.Position = initialPosition;  	if (isID3v22CorrectSize == false) {  		tagReadingInfo.TagVersionOptions |= TagVersionOptions.AddOneByteToSize;  	}  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2Tag.cs,Read,The following statement contains a magic number: if (_id3v2Header.TagVersion == ID3v2TagVersion.ID3v24) {  	bool isID3v24SyncSafe = true;  	bytesRead = 0;  	readUntil = _id3v2Header.TagSize - _id3v2ExtendedHeader.SizeIncludingSizeBytes - frameIDSize;  	long initialPosition = stream.Position;  	while (bytesRead < readUntil) {  		byte[] frameIDBytes = stream.Read (frameIDSize);  		// TODO: Noticed some tags contain 0x00 'E' 'N' as a FrameID.  Frame is well structured  		// and other frames follow.  I believe the below (keep reading+looking) will cover this issue.  		// If character is not a letter or number' padding reached' audio began'  		// or otherwise the frame is not readable  		if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  			// TODO: Try to keep reading and look for a valid frame  			if (frameIDBytes [0] != 0 && frameIDBytes [0] != 0xFF) {  				/*String msg = String.Format("Out of range FrameID - 0x{0:X}|0x{1:X}|0x{2:X}|0x{3:X}"'                                                        tmpFrameIDBytes[0]' tmpFrameIDBytes[1]' tmpFrameIDBytes[2]'                                                        tmpFrameIDBytes[3]);                             Trace.WriteLine(msg);*/}  			break;  		}  		int frameSize = stream.ReadInt32 ();  		if (frameSize > 0xFF) {  			if ((frameSize & 0x80) == 0x80) {  				isID3v24SyncSafe = false;  				break;  			}  			if ((frameSize & 0x8000) == 0x8000) {  				isID3v24SyncSafe = false;  				break;  			}  			if ((frameSize & 0x800000) == 0x800000) {  				isID3v24SyncSafe = false;  				break;  			}  			if (bytesRead + frameSize + 10 == _id3v2Header.TagSize) {  				// Could give a false positive' but relatively unlikely (famous last words' huh?)  				isID3v24SyncSafe = false;  				break;  			} else {  				stream.Seek (-4' SeekOrigin.Current);  				// go back to read sync-safe version  				int syncSafeFrameSize = ID3v2Utils.ReadInt32SyncSafe (stream);  				long currentPosition = stream.Position;  				bool isValidAtSyncSafe = true;  				bool isValidAtNonSyncSafe = true;  				// TODO - if it's the last frame and there is padding' both would indicate false  				// Use the one that returns some padding bytes opposed to bytes with non-zero values (could be frame data)  				// If non sync-safe reads past the end of the tag' then it's sync safe  				// Testing non-sync safe since it will always be bigger than the sync safe integer  				if (currentPosition + frameSize + 2 >= readUntil) {  					isID3v24SyncSafe = true;  					break;  				}  				// Test non-sync safe  				stream.Seek (currentPosition + frameSize + 2' SeekOrigin.Begin);  				frameIDBytes = stream.Read (frameIDSize);  				if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  					isValidAtNonSyncSafe = false;  				}  				// Test sync-safe  				stream.Seek (currentPosition + syncSafeFrameSize + 2' SeekOrigin.Begin);  				frameIDBytes = stream.Read (frameIDSize);  				if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  					isValidAtSyncSafe = false;  				}  				// if they're equal' we'll just have to go with syncsafe' since that's the spec  				if (isValidAtNonSyncSafe != isValidAtSyncSafe) {  					isID3v24SyncSafe = isValidAtSyncSafe;  				}  				break;  			}  		}  		stream.Seek (frameSize + 2' SeekOrigin.Current);  		bytesRead += frameSize + 10;  	}  	stream.Position = initialPosition;  	if (isID3v24SyncSafe == false) {  		tagReadingInfo.TagVersionOptions |= TagVersionOptions.UseNonSyncSafeFrameSizeID3v24;  	}  } else if (_id3v2Header.TagVersion == ID3v2TagVersion.ID3v22) {  	bool isID3v22CorrectSize = true;  	bytesRead = 0;  	readUntil = _id3v2Header.TagSize - _id3v2ExtendedHeader.SizeIncludingSizeBytes - frameIDSize;  	long initialPosition = stream.Position;  	stream.Read (frameIDSize);  	UnknownFrame unknownFrame = new UnknownFrame (null' tagReadingInfo' stream);  	bytesRead += unknownFrame.FrameHeader.FrameSizeTotal;  	if (bytesRead < readUntil) {  		byte[] frameIDBytes = stream.Read (frameIDSize);  		// TODO: Noticed some tags contain 0x00 'E' 'N' as a FrameID.  Frame is well structured  		// and other frames follow.  I believe the below (keep reading+looking) will cover this issue.  		// If character is not a letter or number' padding reached' audio began'  		// or otherwise the frame is not readable  		if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A) {  			if (frameIDBytes [1] >= 0x30 && frameIDBytes [1] <= 0x5A && frameIDBytes [2] >= 0x30 && frameIDBytes [2] <= 0x5A) {  				Trace.WriteLine ("ID3v2.2 frame size off by 1 byte");  				isID3v22CorrectSize = false;  			}  		}  	}  	stream.Position = initialPosition;  	if (isID3v22CorrectSize == false) {  		tagReadingInfo.TagVersionOptions |= TagVersionOptions.AddOneByteToSize;  	}  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2Tag.cs,Read,The following statement contains a magic number: if (_id3v2Header.TagVersion == ID3v2TagVersion.ID3v24) {  	bool isID3v24SyncSafe = true;  	bytesRead = 0;  	readUntil = _id3v2Header.TagSize - _id3v2ExtendedHeader.SizeIncludingSizeBytes - frameIDSize;  	long initialPosition = stream.Position;  	while (bytesRead < readUntil) {  		byte[] frameIDBytes = stream.Read (frameIDSize);  		// TODO: Noticed some tags contain 0x00 'E' 'N' as a FrameID.  Frame is well structured  		// and other frames follow.  I believe the below (keep reading+looking) will cover this issue.  		// If character is not a letter or number' padding reached' audio began'  		// or otherwise the frame is not readable  		if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  			// TODO: Try to keep reading and look for a valid frame  			if (frameIDBytes [0] != 0 && frameIDBytes [0] != 0xFF) {  				/*String msg = String.Format("Out of range FrameID - 0x{0:X}|0x{1:X}|0x{2:X}|0x{3:X}"'                                                        tmpFrameIDBytes[0]' tmpFrameIDBytes[1]' tmpFrameIDBytes[2]'                                                        tmpFrameIDBytes[3]);                             Trace.WriteLine(msg);*/}  			break;  		}  		int frameSize = stream.ReadInt32 ();  		if (frameSize > 0xFF) {  			if ((frameSize & 0x80) == 0x80) {  				isID3v24SyncSafe = false;  				break;  			}  			if ((frameSize & 0x8000) == 0x8000) {  				isID3v24SyncSafe = false;  				break;  			}  			if ((frameSize & 0x800000) == 0x800000) {  				isID3v24SyncSafe = false;  				break;  			}  			if (bytesRead + frameSize + 10 == _id3v2Header.TagSize) {  				// Could give a false positive' but relatively unlikely (famous last words' huh?)  				isID3v24SyncSafe = false;  				break;  			} else {  				stream.Seek (-4' SeekOrigin.Current);  				// go back to read sync-safe version  				int syncSafeFrameSize = ID3v2Utils.ReadInt32SyncSafe (stream);  				long currentPosition = stream.Position;  				bool isValidAtSyncSafe = true;  				bool isValidAtNonSyncSafe = true;  				// TODO - if it's the last frame and there is padding' both would indicate false  				// Use the one that returns some padding bytes opposed to bytes with non-zero values (could be frame data)  				// If non sync-safe reads past the end of the tag' then it's sync safe  				// Testing non-sync safe since it will always be bigger than the sync safe integer  				if (currentPosition + frameSize + 2 >= readUntil) {  					isID3v24SyncSafe = true;  					break;  				}  				// Test non-sync safe  				stream.Seek (currentPosition + frameSize + 2' SeekOrigin.Begin);  				frameIDBytes = stream.Read (frameIDSize);  				if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  					isValidAtNonSyncSafe = false;  				}  				// Test sync-safe  				stream.Seek (currentPosition + syncSafeFrameSize + 2' SeekOrigin.Begin);  				frameIDBytes = stream.Read (frameIDSize);  				if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  					isValidAtSyncSafe = false;  				}  				// if they're equal' we'll just have to go with syncsafe' since that's the spec  				if (isValidAtNonSyncSafe != isValidAtSyncSafe) {  					isID3v24SyncSafe = isValidAtSyncSafe;  				}  				break;  			}  		}  		stream.Seek (frameSize + 2' SeekOrigin.Current);  		bytesRead += frameSize + 10;  	}  	stream.Position = initialPosition;  	if (isID3v24SyncSafe == false) {  		tagReadingInfo.TagVersionOptions |= TagVersionOptions.UseNonSyncSafeFrameSizeID3v24;  	}  } else if (_id3v2Header.TagVersion == ID3v2TagVersion.ID3v22) {  	bool isID3v22CorrectSize = true;  	bytesRead = 0;  	readUntil = _id3v2Header.TagSize - _id3v2ExtendedHeader.SizeIncludingSizeBytes - frameIDSize;  	long initialPosition = stream.Position;  	stream.Read (frameIDSize);  	UnknownFrame unknownFrame = new UnknownFrame (null' tagReadingInfo' stream);  	bytesRead += unknownFrame.FrameHeader.FrameSizeTotal;  	if (bytesRead < readUntil) {  		byte[] frameIDBytes = stream.Read (frameIDSize);  		// TODO: Noticed some tags contain 0x00 'E' 'N' as a FrameID.  Frame is well structured  		// and other frames follow.  I believe the below (keep reading+looking) will cover this issue.  		// If character is not a letter or number' padding reached' audio began'  		// or otherwise the frame is not readable  		if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A) {  			if (frameIDBytes [1] >= 0x30 && frameIDBytes [1] <= 0x5A && frameIDBytes [2] >= 0x30 && frameIDBytes [2] <= 0x5A) {  				Trace.WriteLine ("ID3v2.2 frame size off by 1 byte");  				isID3v22CorrectSize = false;  			}  		}  	}  	stream.Position = initialPosition;  	if (isID3v22CorrectSize == false) {  		tagReadingInfo.TagVersionOptions |= TagVersionOptions.AddOneByteToSize;  	}  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2Tag.cs,Read,The following statement contains a magic number: if (_id3v2Header.TagVersion == ID3v2TagVersion.ID3v24) {  	bool isID3v24SyncSafe = true;  	bytesRead = 0;  	readUntil = _id3v2Header.TagSize - _id3v2ExtendedHeader.SizeIncludingSizeBytes - frameIDSize;  	long initialPosition = stream.Position;  	while (bytesRead < readUntil) {  		byte[] frameIDBytes = stream.Read (frameIDSize);  		// TODO: Noticed some tags contain 0x00 'E' 'N' as a FrameID.  Frame is well structured  		// and other frames follow.  I believe the below (keep reading+looking) will cover this issue.  		// If character is not a letter or number' padding reached' audio began'  		// or otherwise the frame is not readable  		if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  			// TODO: Try to keep reading and look for a valid frame  			if (frameIDBytes [0] != 0 && frameIDBytes [0] != 0xFF) {  				/*String msg = String.Format("Out of range FrameID - 0x{0:X}|0x{1:X}|0x{2:X}|0x{3:X}"'                                                        tmpFrameIDBytes[0]' tmpFrameIDBytes[1]' tmpFrameIDBytes[2]'                                                        tmpFrameIDBytes[3]);                             Trace.WriteLine(msg);*/}  			break;  		}  		int frameSize = stream.ReadInt32 ();  		if (frameSize > 0xFF) {  			if ((frameSize & 0x80) == 0x80) {  				isID3v24SyncSafe = false;  				break;  			}  			if ((frameSize & 0x8000) == 0x8000) {  				isID3v24SyncSafe = false;  				break;  			}  			if ((frameSize & 0x800000) == 0x800000) {  				isID3v24SyncSafe = false;  				break;  			}  			if (bytesRead + frameSize + 10 == _id3v2Header.TagSize) {  				// Could give a false positive' but relatively unlikely (famous last words' huh?)  				isID3v24SyncSafe = false;  				break;  			} else {  				stream.Seek (-4' SeekOrigin.Current);  				// go back to read sync-safe version  				int syncSafeFrameSize = ID3v2Utils.ReadInt32SyncSafe (stream);  				long currentPosition = stream.Position;  				bool isValidAtSyncSafe = true;  				bool isValidAtNonSyncSafe = true;  				// TODO - if it's the last frame and there is padding' both would indicate false  				// Use the one that returns some padding bytes opposed to bytes with non-zero values (could be frame data)  				// If non sync-safe reads past the end of the tag' then it's sync safe  				// Testing non-sync safe since it will always be bigger than the sync safe integer  				if (currentPosition + frameSize + 2 >= readUntil) {  					isID3v24SyncSafe = true;  					break;  				}  				// Test non-sync safe  				stream.Seek (currentPosition + frameSize + 2' SeekOrigin.Begin);  				frameIDBytes = stream.Read (frameIDSize);  				if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  					isValidAtNonSyncSafe = false;  				}  				// Test sync-safe  				stream.Seek (currentPosition + syncSafeFrameSize + 2' SeekOrigin.Begin);  				frameIDBytes = stream.Read (frameIDSize);  				if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  					isValidAtSyncSafe = false;  				}  				// if they're equal' we'll just have to go with syncsafe' since that's the spec  				if (isValidAtNonSyncSafe != isValidAtSyncSafe) {  					isID3v24SyncSafe = isValidAtSyncSafe;  				}  				break;  			}  		}  		stream.Seek (frameSize + 2' SeekOrigin.Current);  		bytesRead += frameSize + 10;  	}  	stream.Position = initialPosition;  	if (isID3v24SyncSafe == false) {  		tagReadingInfo.TagVersionOptions |= TagVersionOptions.UseNonSyncSafeFrameSizeID3v24;  	}  } else if (_id3v2Header.TagVersion == ID3v2TagVersion.ID3v22) {  	bool isID3v22CorrectSize = true;  	bytesRead = 0;  	readUntil = _id3v2Header.TagSize - _id3v2ExtendedHeader.SizeIncludingSizeBytes - frameIDSize;  	long initialPosition = stream.Position;  	stream.Read (frameIDSize);  	UnknownFrame unknownFrame = new UnknownFrame (null' tagReadingInfo' stream);  	bytesRead += unknownFrame.FrameHeader.FrameSizeTotal;  	if (bytesRead < readUntil) {  		byte[] frameIDBytes = stream.Read (frameIDSize);  		// TODO: Noticed some tags contain 0x00 'E' 'N' as a FrameID.  Frame is well structured  		// and other frames follow.  I believe the below (keep reading+looking) will cover this issue.  		// If character is not a letter or number' padding reached' audio began'  		// or otherwise the frame is not readable  		if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A) {  			if (frameIDBytes [1] >= 0x30 && frameIDBytes [1] <= 0x5A && frameIDBytes [2] >= 0x30 && frameIDBytes [2] <= 0x5A) {  				Trace.WriteLine ("ID3v2.2 frame size off by 1 byte");  				isID3v22CorrectSize = false;  			}  		}  	}  	stream.Position = initialPosition;  	if (isID3v22CorrectSize == false) {  		tagReadingInfo.TagVersionOptions |= TagVersionOptions.AddOneByteToSize;  	}  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2Tag.cs,Read,The following statement contains a magic number: if (_id3v2Header.TagVersion == ID3v2TagVersion.ID3v24) {  	bool isID3v24SyncSafe = true;  	bytesRead = 0;  	readUntil = _id3v2Header.TagSize - _id3v2ExtendedHeader.SizeIncludingSizeBytes - frameIDSize;  	long initialPosition = stream.Position;  	while (bytesRead < readUntil) {  		byte[] frameIDBytes = stream.Read (frameIDSize);  		// TODO: Noticed some tags contain 0x00 'E' 'N' as a FrameID.  Frame is well structured  		// and other frames follow.  I believe the below (keep reading+looking) will cover this issue.  		// If character is not a letter or number' padding reached' audio began'  		// or otherwise the frame is not readable  		if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  			// TODO: Try to keep reading and look for a valid frame  			if (frameIDBytes [0] != 0 && frameIDBytes [0] != 0xFF) {  				/*String msg = String.Format("Out of range FrameID - 0x{0:X}|0x{1:X}|0x{2:X}|0x{3:X}"'                                                        tmpFrameIDBytes[0]' tmpFrameIDBytes[1]' tmpFrameIDBytes[2]'                                                        tmpFrameIDBytes[3]);                             Trace.WriteLine(msg);*/}  			break;  		}  		int frameSize = stream.ReadInt32 ();  		if (frameSize > 0xFF) {  			if ((frameSize & 0x80) == 0x80) {  				isID3v24SyncSafe = false;  				break;  			}  			if ((frameSize & 0x8000) == 0x8000) {  				isID3v24SyncSafe = false;  				break;  			}  			if ((frameSize & 0x800000) == 0x800000) {  				isID3v24SyncSafe = false;  				break;  			}  			if (bytesRead + frameSize + 10 == _id3v2Header.TagSize) {  				// Could give a false positive' but relatively unlikely (famous last words' huh?)  				isID3v24SyncSafe = false;  				break;  			} else {  				stream.Seek (-4' SeekOrigin.Current);  				// go back to read sync-safe version  				int syncSafeFrameSize = ID3v2Utils.ReadInt32SyncSafe (stream);  				long currentPosition = stream.Position;  				bool isValidAtSyncSafe = true;  				bool isValidAtNonSyncSafe = true;  				// TODO - if it's the last frame and there is padding' both would indicate false  				// Use the one that returns some padding bytes opposed to bytes with non-zero values (could be frame data)  				// If non sync-safe reads past the end of the tag' then it's sync safe  				// Testing non-sync safe since it will always be bigger than the sync safe integer  				if (currentPosition + frameSize + 2 >= readUntil) {  					isID3v24SyncSafe = true;  					break;  				}  				// Test non-sync safe  				stream.Seek (currentPosition + frameSize + 2' SeekOrigin.Begin);  				frameIDBytes = stream.Read (frameIDSize);  				if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  					isValidAtNonSyncSafe = false;  				}  				// Test sync-safe  				stream.Seek (currentPosition + syncSafeFrameSize + 2' SeekOrigin.Begin);  				frameIDBytes = stream.Read (frameIDSize);  				if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  					isValidAtSyncSafe = false;  				}  				// if they're equal' we'll just have to go with syncsafe' since that's the spec  				if (isValidAtNonSyncSafe != isValidAtSyncSafe) {  					isID3v24SyncSafe = isValidAtSyncSafe;  				}  				break;  			}  		}  		stream.Seek (frameSize + 2' SeekOrigin.Current);  		bytesRead += frameSize + 10;  	}  	stream.Position = initialPosition;  	if (isID3v24SyncSafe == false) {  		tagReadingInfo.TagVersionOptions |= TagVersionOptions.UseNonSyncSafeFrameSizeID3v24;  	}  } else if (_id3v2Header.TagVersion == ID3v2TagVersion.ID3v22) {  	bool isID3v22CorrectSize = true;  	bytesRead = 0;  	readUntil = _id3v2Header.TagSize - _id3v2ExtendedHeader.SizeIncludingSizeBytes - frameIDSize;  	long initialPosition = stream.Position;  	stream.Read (frameIDSize);  	UnknownFrame unknownFrame = new UnknownFrame (null' tagReadingInfo' stream);  	bytesRead += unknownFrame.FrameHeader.FrameSizeTotal;  	if (bytesRead < readUntil) {  		byte[] frameIDBytes = stream.Read (frameIDSize);  		// TODO: Noticed some tags contain 0x00 'E' 'N' as a FrameID.  Frame is well structured  		// and other frames follow.  I believe the below (keep reading+looking) will cover this issue.  		// If character is not a letter or number' padding reached' audio began'  		// or otherwise the frame is not readable  		if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A) {  			if (frameIDBytes [1] >= 0x30 && frameIDBytes [1] <= 0x5A && frameIDBytes [2] >= 0x30 && frameIDBytes [2] <= 0x5A) {  				Trace.WriteLine ("ID3v2.2 frame size off by 1 byte");  				isID3v22CorrectSize = false;  			}  		}  	}  	stream.Position = initialPosition;  	if (isID3v22CorrectSize == false) {  		tagReadingInfo.TagVersionOptions |= TagVersionOptions.AddOneByteToSize;  	}  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2Tag.cs,Read,The following statement contains a magic number: if (_id3v2Header.TagVersion == ID3v2TagVersion.ID3v24) {  	bool isID3v24SyncSafe = true;  	bytesRead = 0;  	readUntil = _id3v2Header.TagSize - _id3v2ExtendedHeader.SizeIncludingSizeBytes - frameIDSize;  	long initialPosition = stream.Position;  	while (bytesRead < readUntil) {  		byte[] frameIDBytes = stream.Read (frameIDSize);  		// TODO: Noticed some tags contain 0x00 'E' 'N' as a FrameID.  Frame is well structured  		// and other frames follow.  I believe the below (keep reading+looking) will cover this issue.  		// If character is not a letter or number' padding reached' audio began'  		// or otherwise the frame is not readable  		if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  			// TODO: Try to keep reading and look for a valid frame  			if (frameIDBytes [0] != 0 && frameIDBytes [0] != 0xFF) {  				/*String msg = String.Format("Out of range FrameID - 0x{0:X}|0x{1:X}|0x{2:X}|0x{3:X}"'                                                        tmpFrameIDBytes[0]' tmpFrameIDBytes[1]' tmpFrameIDBytes[2]'                                                        tmpFrameIDBytes[3]);                             Trace.WriteLine(msg);*/}  			break;  		}  		int frameSize = stream.ReadInt32 ();  		if (frameSize > 0xFF) {  			if ((frameSize & 0x80) == 0x80) {  				isID3v24SyncSafe = false;  				break;  			}  			if ((frameSize & 0x8000) == 0x8000) {  				isID3v24SyncSafe = false;  				break;  			}  			if ((frameSize & 0x800000) == 0x800000) {  				isID3v24SyncSafe = false;  				break;  			}  			if (bytesRead + frameSize + 10 == _id3v2Header.TagSize) {  				// Could give a false positive' but relatively unlikely (famous last words' huh?)  				isID3v24SyncSafe = false;  				break;  			} else {  				stream.Seek (-4' SeekOrigin.Current);  				// go back to read sync-safe version  				int syncSafeFrameSize = ID3v2Utils.ReadInt32SyncSafe (stream);  				long currentPosition = stream.Position;  				bool isValidAtSyncSafe = true;  				bool isValidAtNonSyncSafe = true;  				// TODO - if it's the last frame and there is padding' both would indicate false  				// Use the one that returns some padding bytes opposed to bytes with non-zero values (could be frame data)  				// If non sync-safe reads past the end of the tag' then it's sync safe  				// Testing non-sync safe since it will always be bigger than the sync safe integer  				if (currentPosition + frameSize + 2 >= readUntil) {  					isID3v24SyncSafe = true;  					break;  				}  				// Test non-sync safe  				stream.Seek (currentPosition + frameSize + 2' SeekOrigin.Begin);  				frameIDBytes = stream.Read (frameIDSize);  				if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  					isValidAtNonSyncSafe = false;  				}  				// Test sync-safe  				stream.Seek (currentPosition + syncSafeFrameSize + 2' SeekOrigin.Begin);  				frameIDBytes = stream.Read (frameIDSize);  				if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  					isValidAtSyncSafe = false;  				}  				// if they're equal' we'll just have to go with syncsafe' since that's the spec  				if (isValidAtNonSyncSafe != isValidAtSyncSafe) {  					isID3v24SyncSafe = isValidAtSyncSafe;  				}  				break;  			}  		}  		stream.Seek (frameSize + 2' SeekOrigin.Current);  		bytesRead += frameSize + 10;  	}  	stream.Position = initialPosition;  	if (isID3v24SyncSafe == false) {  		tagReadingInfo.TagVersionOptions |= TagVersionOptions.UseNonSyncSafeFrameSizeID3v24;  	}  } else if (_id3v2Header.TagVersion == ID3v2TagVersion.ID3v22) {  	bool isID3v22CorrectSize = true;  	bytesRead = 0;  	readUntil = _id3v2Header.TagSize - _id3v2ExtendedHeader.SizeIncludingSizeBytes - frameIDSize;  	long initialPosition = stream.Position;  	stream.Read (frameIDSize);  	UnknownFrame unknownFrame = new UnknownFrame (null' tagReadingInfo' stream);  	bytesRead += unknownFrame.FrameHeader.FrameSizeTotal;  	if (bytesRead < readUntil) {  		byte[] frameIDBytes = stream.Read (frameIDSize);  		// TODO: Noticed some tags contain 0x00 'E' 'N' as a FrameID.  Frame is well structured  		// and other frames follow.  I believe the below (keep reading+looking) will cover this issue.  		// If character is not a letter or number' padding reached' audio began'  		// or otherwise the frame is not readable  		if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A) {  			if (frameIDBytes [1] >= 0x30 && frameIDBytes [1] <= 0x5A && frameIDBytes [2] >= 0x30 && frameIDBytes [2] <= 0x5A) {  				Trace.WriteLine ("ID3v2.2 frame size off by 1 byte");  				isID3v22CorrectSize = false;  			}  		}  	}  	stream.Position = initialPosition;  	if (isID3v22CorrectSize == false) {  		tagReadingInfo.TagVersionOptions |= TagVersionOptions.AddOneByteToSize;  	}  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2Tag.cs,Read,The following statement contains a magic number: if (_id3v2Header.TagVersion == ID3v2TagVersion.ID3v24) {  	bool isID3v24SyncSafe = true;  	bytesRead = 0;  	readUntil = _id3v2Header.TagSize - _id3v2ExtendedHeader.SizeIncludingSizeBytes - frameIDSize;  	long initialPosition = stream.Position;  	while (bytesRead < readUntil) {  		byte[] frameIDBytes = stream.Read (frameIDSize);  		// TODO: Noticed some tags contain 0x00 'E' 'N' as a FrameID.  Frame is well structured  		// and other frames follow.  I believe the below (keep reading+looking) will cover this issue.  		// If character is not a letter or number' padding reached' audio began'  		// or otherwise the frame is not readable  		if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  			// TODO: Try to keep reading and look for a valid frame  			if (frameIDBytes [0] != 0 && frameIDBytes [0] != 0xFF) {  				/*String msg = String.Format("Out of range FrameID - 0x{0:X}|0x{1:X}|0x{2:X}|0x{3:X}"'                                                        tmpFrameIDBytes[0]' tmpFrameIDBytes[1]' tmpFrameIDBytes[2]'                                                        tmpFrameIDBytes[3]);                             Trace.WriteLine(msg);*/}  			break;  		}  		int frameSize = stream.ReadInt32 ();  		if (frameSize > 0xFF) {  			if ((frameSize & 0x80) == 0x80) {  				isID3v24SyncSafe = false;  				break;  			}  			if ((frameSize & 0x8000) == 0x8000) {  				isID3v24SyncSafe = false;  				break;  			}  			if ((frameSize & 0x800000) == 0x800000) {  				isID3v24SyncSafe = false;  				break;  			}  			if (bytesRead + frameSize + 10 == _id3v2Header.TagSize) {  				// Could give a false positive' but relatively unlikely (famous last words' huh?)  				isID3v24SyncSafe = false;  				break;  			} else {  				stream.Seek (-4' SeekOrigin.Current);  				// go back to read sync-safe version  				int syncSafeFrameSize = ID3v2Utils.ReadInt32SyncSafe (stream);  				long currentPosition = stream.Position;  				bool isValidAtSyncSafe = true;  				bool isValidAtNonSyncSafe = true;  				// TODO - if it's the last frame and there is padding' both would indicate false  				// Use the one that returns some padding bytes opposed to bytes with non-zero values (could be frame data)  				// If non sync-safe reads past the end of the tag' then it's sync safe  				// Testing non-sync safe since it will always be bigger than the sync safe integer  				if (currentPosition + frameSize + 2 >= readUntil) {  					isID3v24SyncSafe = true;  					break;  				}  				// Test non-sync safe  				stream.Seek (currentPosition + frameSize + 2' SeekOrigin.Begin);  				frameIDBytes = stream.Read (frameIDSize);  				if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  					isValidAtNonSyncSafe = false;  				}  				// Test sync-safe  				stream.Seek (currentPosition + syncSafeFrameSize + 2' SeekOrigin.Begin);  				frameIDBytes = stream.Read (frameIDSize);  				if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  					isValidAtSyncSafe = false;  				}  				// if they're equal' we'll just have to go with syncsafe' since that's the spec  				if (isValidAtNonSyncSafe != isValidAtSyncSafe) {  					isID3v24SyncSafe = isValidAtSyncSafe;  				}  				break;  			}  		}  		stream.Seek (frameSize + 2' SeekOrigin.Current);  		bytesRead += frameSize + 10;  	}  	stream.Position = initialPosition;  	if (isID3v24SyncSafe == false) {  		tagReadingInfo.TagVersionOptions |= TagVersionOptions.UseNonSyncSafeFrameSizeID3v24;  	}  } else if (_id3v2Header.TagVersion == ID3v2TagVersion.ID3v22) {  	bool isID3v22CorrectSize = true;  	bytesRead = 0;  	readUntil = _id3v2Header.TagSize - _id3v2ExtendedHeader.SizeIncludingSizeBytes - frameIDSize;  	long initialPosition = stream.Position;  	stream.Read (frameIDSize);  	UnknownFrame unknownFrame = new UnknownFrame (null' tagReadingInfo' stream);  	bytesRead += unknownFrame.FrameHeader.FrameSizeTotal;  	if (bytesRead < readUntil) {  		byte[] frameIDBytes = stream.Read (frameIDSize);  		// TODO: Noticed some tags contain 0x00 'E' 'N' as a FrameID.  Frame is well structured  		// and other frames follow.  I believe the below (keep reading+looking) will cover this issue.  		// If character is not a letter or number' padding reached' audio began'  		// or otherwise the frame is not readable  		if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A) {  			if (frameIDBytes [1] >= 0x30 && frameIDBytes [1] <= 0x5A && frameIDBytes [2] >= 0x30 && frameIDBytes [2] <= 0x5A) {  				Trace.WriteLine ("ID3v2.2 frame size off by 1 byte");  				isID3v22CorrectSize = false;  			}  		}  	}  	stream.Position = initialPosition;  	if (isID3v22CorrectSize == false) {  		tagReadingInfo.TagVersionOptions |= TagVersionOptions.AddOneByteToSize;  	}  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2Tag.cs,Read,The following statement contains a magic number: if (_id3v2Header.TagVersion == ID3v2TagVersion.ID3v24) {  	bool isID3v24SyncSafe = true;  	bytesRead = 0;  	readUntil = _id3v2Header.TagSize - _id3v2ExtendedHeader.SizeIncludingSizeBytes - frameIDSize;  	long initialPosition = stream.Position;  	while (bytesRead < readUntil) {  		byte[] frameIDBytes = stream.Read (frameIDSize);  		// TODO: Noticed some tags contain 0x00 'E' 'N' as a FrameID.  Frame is well structured  		// and other frames follow.  I believe the below (keep reading+looking) will cover this issue.  		// If character is not a letter or number' padding reached' audio began'  		// or otherwise the frame is not readable  		if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  			// TODO: Try to keep reading and look for a valid frame  			if (frameIDBytes [0] != 0 && frameIDBytes [0] != 0xFF) {  				/*String msg = String.Format("Out of range FrameID - 0x{0:X}|0x{1:X}|0x{2:X}|0x{3:X}"'                                                        tmpFrameIDBytes[0]' tmpFrameIDBytes[1]' tmpFrameIDBytes[2]'                                                        tmpFrameIDBytes[3]);                             Trace.WriteLine(msg);*/}  			break;  		}  		int frameSize = stream.ReadInt32 ();  		if (frameSize > 0xFF) {  			if ((frameSize & 0x80) == 0x80) {  				isID3v24SyncSafe = false;  				break;  			}  			if ((frameSize & 0x8000) == 0x8000) {  				isID3v24SyncSafe = false;  				break;  			}  			if ((frameSize & 0x800000) == 0x800000) {  				isID3v24SyncSafe = false;  				break;  			}  			if (bytesRead + frameSize + 10 == _id3v2Header.TagSize) {  				// Could give a false positive' but relatively unlikely (famous last words' huh?)  				isID3v24SyncSafe = false;  				break;  			} else {  				stream.Seek (-4' SeekOrigin.Current);  				// go back to read sync-safe version  				int syncSafeFrameSize = ID3v2Utils.ReadInt32SyncSafe (stream);  				long currentPosition = stream.Position;  				bool isValidAtSyncSafe = true;  				bool isValidAtNonSyncSafe = true;  				// TODO - if it's the last frame and there is padding' both would indicate false  				// Use the one that returns some padding bytes opposed to bytes with non-zero values (could be frame data)  				// If non sync-safe reads past the end of the tag' then it's sync safe  				// Testing non-sync safe since it will always be bigger than the sync safe integer  				if (currentPosition + frameSize + 2 >= readUntil) {  					isID3v24SyncSafe = true;  					break;  				}  				// Test non-sync safe  				stream.Seek (currentPosition + frameSize + 2' SeekOrigin.Begin);  				frameIDBytes = stream.Read (frameIDSize);  				if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  					isValidAtNonSyncSafe = false;  				}  				// Test sync-safe  				stream.Seek (currentPosition + syncSafeFrameSize + 2' SeekOrigin.Begin);  				frameIDBytes = stream.Read (frameIDSize);  				if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  					isValidAtSyncSafe = false;  				}  				// if they're equal' we'll just have to go with syncsafe' since that's the spec  				if (isValidAtNonSyncSafe != isValidAtSyncSafe) {  					isID3v24SyncSafe = isValidAtSyncSafe;  				}  				break;  			}  		}  		stream.Seek (frameSize + 2' SeekOrigin.Current);  		bytesRead += frameSize + 10;  	}  	stream.Position = initialPosition;  	if (isID3v24SyncSafe == false) {  		tagReadingInfo.TagVersionOptions |= TagVersionOptions.UseNonSyncSafeFrameSizeID3v24;  	}  } else if (_id3v2Header.TagVersion == ID3v2TagVersion.ID3v22) {  	bool isID3v22CorrectSize = true;  	bytesRead = 0;  	readUntil = _id3v2Header.TagSize - _id3v2ExtendedHeader.SizeIncludingSizeBytes - frameIDSize;  	long initialPosition = stream.Position;  	stream.Read (frameIDSize);  	UnknownFrame unknownFrame = new UnknownFrame (null' tagReadingInfo' stream);  	bytesRead += unknownFrame.FrameHeader.FrameSizeTotal;  	if (bytesRead < readUntil) {  		byte[] frameIDBytes = stream.Read (frameIDSize);  		// TODO: Noticed some tags contain 0x00 'E' 'N' as a FrameID.  Frame is well structured  		// and other frames follow.  I believe the below (keep reading+looking) will cover this issue.  		// If character is not a letter or number' padding reached' audio began'  		// or otherwise the frame is not readable  		if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A) {  			if (frameIDBytes [1] >= 0x30 && frameIDBytes [1] <= 0x5A && frameIDBytes [2] >= 0x30 && frameIDBytes [2] <= 0x5A) {  				Trace.WriteLine ("ID3v2.2 frame size off by 1 byte");  				isID3v22CorrectSize = false;  			}  		}  	}  	stream.Position = initialPosition;  	if (isID3v22CorrectSize == false) {  		tagReadingInfo.TagVersionOptions |= TagVersionOptions.AddOneByteToSize;  	}  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2Tag.cs,Read,The following statement contains a magic number: if (_id3v2Header.TagVersion == ID3v2TagVersion.ID3v24) {  	bool isID3v24SyncSafe = true;  	bytesRead = 0;  	readUntil = _id3v2Header.TagSize - _id3v2ExtendedHeader.SizeIncludingSizeBytes - frameIDSize;  	long initialPosition = stream.Position;  	while (bytesRead < readUntil) {  		byte[] frameIDBytes = stream.Read (frameIDSize);  		// TODO: Noticed some tags contain 0x00 'E' 'N' as a FrameID.  Frame is well structured  		// and other frames follow.  I believe the below (keep reading+looking) will cover this issue.  		// If character is not a letter or number' padding reached' audio began'  		// or otherwise the frame is not readable  		if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  			// TODO: Try to keep reading and look for a valid frame  			if (frameIDBytes [0] != 0 && frameIDBytes [0] != 0xFF) {  				/*String msg = String.Format("Out of range FrameID - 0x{0:X}|0x{1:X}|0x{2:X}|0x{3:X}"'                                                        tmpFrameIDBytes[0]' tmpFrameIDBytes[1]' tmpFrameIDBytes[2]'                                                        tmpFrameIDBytes[3]);                             Trace.WriteLine(msg);*/}  			break;  		}  		int frameSize = stream.ReadInt32 ();  		if (frameSize > 0xFF) {  			if ((frameSize & 0x80) == 0x80) {  				isID3v24SyncSafe = false;  				break;  			}  			if ((frameSize & 0x8000) == 0x8000) {  				isID3v24SyncSafe = false;  				break;  			}  			if ((frameSize & 0x800000) == 0x800000) {  				isID3v24SyncSafe = false;  				break;  			}  			if (bytesRead + frameSize + 10 == _id3v2Header.TagSize) {  				// Could give a false positive' but relatively unlikely (famous last words' huh?)  				isID3v24SyncSafe = false;  				break;  			} else {  				stream.Seek (-4' SeekOrigin.Current);  				// go back to read sync-safe version  				int syncSafeFrameSize = ID3v2Utils.ReadInt32SyncSafe (stream);  				long currentPosition = stream.Position;  				bool isValidAtSyncSafe = true;  				bool isValidAtNonSyncSafe = true;  				// TODO - if it's the last frame and there is padding' both would indicate false  				// Use the one that returns some padding bytes opposed to bytes with non-zero values (could be frame data)  				// If non sync-safe reads past the end of the tag' then it's sync safe  				// Testing non-sync safe since it will always be bigger than the sync safe integer  				if (currentPosition + frameSize + 2 >= readUntil) {  					isID3v24SyncSafe = true;  					break;  				}  				// Test non-sync safe  				stream.Seek (currentPosition + frameSize + 2' SeekOrigin.Begin);  				frameIDBytes = stream.Read (frameIDSize);  				if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  					isValidAtNonSyncSafe = false;  				}  				// Test sync-safe  				stream.Seek (currentPosition + syncSafeFrameSize + 2' SeekOrigin.Begin);  				frameIDBytes = stream.Read (frameIDSize);  				if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  					isValidAtSyncSafe = false;  				}  				// if they're equal' we'll just have to go with syncsafe' since that's the spec  				if (isValidAtNonSyncSafe != isValidAtSyncSafe) {  					isID3v24SyncSafe = isValidAtSyncSafe;  				}  				break;  			}  		}  		stream.Seek (frameSize + 2' SeekOrigin.Current);  		bytesRead += frameSize + 10;  	}  	stream.Position = initialPosition;  	if (isID3v24SyncSafe == false) {  		tagReadingInfo.TagVersionOptions |= TagVersionOptions.UseNonSyncSafeFrameSizeID3v24;  	}  } else if (_id3v2Header.TagVersion == ID3v2TagVersion.ID3v22) {  	bool isID3v22CorrectSize = true;  	bytesRead = 0;  	readUntil = _id3v2Header.TagSize - _id3v2ExtendedHeader.SizeIncludingSizeBytes - frameIDSize;  	long initialPosition = stream.Position;  	stream.Read (frameIDSize);  	UnknownFrame unknownFrame = new UnknownFrame (null' tagReadingInfo' stream);  	bytesRead += unknownFrame.FrameHeader.FrameSizeTotal;  	if (bytesRead < readUntil) {  		byte[] frameIDBytes = stream.Read (frameIDSize);  		// TODO: Noticed some tags contain 0x00 'E' 'N' as a FrameID.  Frame is well structured  		// and other frames follow.  I believe the below (keep reading+looking) will cover this issue.  		// If character is not a letter or number' padding reached' audio began'  		// or otherwise the frame is not readable  		if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A) {  			if (frameIDBytes [1] >= 0x30 && frameIDBytes [1] <= 0x5A && frameIDBytes [2] >= 0x30 && frameIDBytes [2] <= 0x5A) {  				Trace.WriteLine ("ID3v2.2 frame size off by 1 byte");  				isID3v22CorrectSize = false;  			}  		}  	}  	stream.Position = initialPosition;  	if (isID3v22CorrectSize == false) {  		tagReadingInfo.TagVersionOptions |= TagVersionOptions.AddOneByteToSize;  	}  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2Tag.cs,Read,The following statement contains a magic number: if (_id3v2Header.TagVersion == ID3v2TagVersion.ID3v24) {  	bool isID3v24SyncSafe = true;  	bytesRead = 0;  	readUntil = _id3v2Header.TagSize - _id3v2ExtendedHeader.SizeIncludingSizeBytes - frameIDSize;  	long initialPosition = stream.Position;  	while (bytesRead < readUntil) {  		byte[] frameIDBytes = stream.Read (frameIDSize);  		// TODO: Noticed some tags contain 0x00 'E' 'N' as a FrameID.  Frame is well structured  		// and other frames follow.  I believe the below (keep reading+looking) will cover this issue.  		// If character is not a letter or number' padding reached' audio began'  		// or otherwise the frame is not readable  		if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  			// TODO: Try to keep reading and look for a valid frame  			if (frameIDBytes [0] != 0 && frameIDBytes [0] != 0xFF) {  				/*String msg = String.Format("Out of range FrameID - 0x{0:X}|0x{1:X}|0x{2:X}|0x{3:X}"'                                                        tmpFrameIDBytes[0]' tmpFrameIDBytes[1]' tmpFrameIDBytes[2]'                                                        tmpFrameIDBytes[3]);                             Trace.WriteLine(msg);*/}  			break;  		}  		int frameSize = stream.ReadInt32 ();  		if (frameSize > 0xFF) {  			if ((frameSize & 0x80) == 0x80) {  				isID3v24SyncSafe = false;  				break;  			}  			if ((frameSize & 0x8000) == 0x8000) {  				isID3v24SyncSafe = false;  				break;  			}  			if ((frameSize & 0x800000) == 0x800000) {  				isID3v24SyncSafe = false;  				break;  			}  			if (bytesRead + frameSize + 10 == _id3v2Header.TagSize) {  				// Could give a false positive' but relatively unlikely (famous last words' huh?)  				isID3v24SyncSafe = false;  				break;  			} else {  				stream.Seek (-4' SeekOrigin.Current);  				// go back to read sync-safe version  				int syncSafeFrameSize = ID3v2Utils.ReadInt32SyncSafe (stream);  				long currentPosition = stream.Position;  				bool isValidAtSyncSafe = true;  				bool isValidAtNonSyncSafe = true;  				// TODO - if it's the last frame and there is padding' both would indicate false  				// Use the one that returns some padding bytes opposed to bytes with non-zero values (could be frame data)  				// If non sync-safe reads past the end of the tag' then it's sync safe  				// Testing non-sync safe since it will always be bigger than the sync safe integer  				if (currentPosition + frameSize + 2 >= readUntil) {  					isID3v24SyncSafe = true;  					break;  				}  				// Test non-sync safe  				stream.Seek (currentPosition + frameSize + 2' SeekOrigin.Begin);  				frameIDBytes = stream.Read (frameIDSize);  				if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  					isValidAtNonSyncSafe = false;  				}  				// Test sync-safe  				stream.Seek (currentPosition + syncSafeFrameSize + 2' SeekOrigin.Begin);  				frameIDBytes = stream.Read (frameIDSize);  				if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  					isValidAtSyncSafe = false;  				}  				// if they're equal' we'll just have to go with syncsafe' since that's the spec  				if (isValidAtNonSyncSafe != isValidAtSyncSafe) {  					isID3v24SyncSafe = isValidAtSyncSafe;  				}  				break;  			}  		}  		stream.Seek (frameSize + 2' SeekOrigin.Current);  		bytesRead += frameSize + 10;  	}  	stream.Position = initialPosition;  	if (isID3v24SyncSafe == false) {  		tagReadingInfo.TagVersionOptions |= TagVersionOptions.UseNonSyncSafeFrameSizeID3v24;  	}  } else if (_id3v2Header.TagVersion == ID3v2TagVersion.ID3v22) {  	bool isID3v22CorrectSize = true;  	bytesRead = 0;  	readUntil = _id3v2Header.TagSize - _id3v2ExtendedHeader.SizeIncludingSizeBytes - frameIDSize;  	long initialPosition = stream.Position;  	stream.Read (frameIDSize);  	UnknownFrame unknownFrame = new UnknownFrame (null' tagReadingInfo' stream);  	bytesRead += unknownFrame.FrameHeader.FrameSizeTotal;  	if (bytesRead < readUntil) {  		byte[] frameIDBytes = stream.Read (frameIDSize);  		// TODO: Noticed some tags contain 0x00 'E' 'N' as a FrameID.  Frame is well structured  		// and other frames follow.  I believe the below (keep reading+looking) will cover this issue.  		// If character is not a letter or number' padding reached' audio began'  		// or otherwise the frame is not readable  		if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A) {  			if (frameIDBytes [1] >= 0x30 && frameIDBytes [1] <= 0x5A && frameIDBytes [2] >= 0x30 && frameIDBytes [2] <= 0x5A) {  				Trace.WriteLine ("ID3v2.2 frame size off by 1 byte");  				isID3v22CorrectSize = false;  			}  		}  	}  	stream.Position = initialPosition;  	if (isID3v22CorrectSize == false) {  		tagReadingInfo.TagVersionOptions |= TagVersionOptions.AddOneByteToSize;  	}  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2Tag.cs,Read,The following statement contains a magic number: if (_id3v2Header.TagVersion == ID3v2TagVersion.ID3v24) {  	bool isID3v24SyncSafe = true;  	bytesRead = 0;  	readUntil = _id3v2Header.TagSize - _id3v2ExtendedHeader.SizeIncludingSizeBytes - frameIDSize;  	long initialPosition = stream.Position;  	while (bytesRead < readUntil) {  		byte[] frameIDBytes = stream.Read (frameIDSize);  		// TODO: Noticed some tags contain 0x00 'E' 'N' as a FrameID.  Frame is well structured  		// and other frames follow.  I believe the below (keep reading+looking) will cover this issue.  		// If character is not a letter or number' padding reached' audio began'  		// or otherwise the frame is not readable  		if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  			// TODO: Try to keep reading and look for a valid frame  			if (frameIDBytes [0] != 0 && frameIDBytes [0] != 0xFF) {  				/*String msg = String.Format("Out of range FrameID - 0x{0:X}|0x{1:X}|0x{2:X}|0x{3:X}"'                                                        tmpFrameIDBytes[0]' tmpFrameIDBytes[1]' tmpFrameIDBytes[2]'                                                        tmpFrameIDBytes[3]);                             Trace.WriteLine(msg);*/}  			break;  		}  		int frameSize = stream.ReadInt32 ();  		if (frameSize > 0xFF) {  			if ((frameSize & 0x80) == 0x80) {  				isID3v24SyncSafe = false;  				break;  			}  			if ((frameSize & 0x8000) == 0x8000) {  				isID3v24SyncSafe = false;  				break;  			}  			if ((frameSize & 0x800000) == 0x800000) {  				isID3v24SyncSafe = false;  				break;  			}  			if (bytesRead + frameSize + 10 == _id3v2Header.TagSize) {  				// Could give a false positive' but relatively unlikely (famous last words' huh?)  				isID3v24SyncSafe = false;  				break;  			} else {  				stream.Seek (-4' SeekOrigin.Current);  				// go back to read sync-safe version  				int syncSafeFrameSize = ID3v2Utils.ReadInt32SyncSafe (stream);  				long currentPosition = stream.Position;  				bool isValidAtSyncSafe = true;  				bool isValidAtNonSyncSafe = true;  				// TODO - if it's the last frame and there is padding' both would indicate false  				// Use the one that returns some padding bytes opposed to bytes with non-zero values (could be frame data)  				// If non sync-safe reads past the end of the tag' then it's sync safe  				// Testing non-sync safe since it will always be bigger than the sync safe integer  				if (currentPosition + frameSize + 2 >= readUntil) {  					isID3v24SyncSafe = true;  					break;  				}  				// Test non-sync safe  				stream.Seek (currentPosition + frameSize + 2' SeekOrigin.Begin);  				frameIDBytes = stream.Read (frameIDSize);  				if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  					isValidAtNonSyncSafe = false;  				}  				// Test sync-safe  				stream.Seek (currentPosition + syncSafeFrameSize + 2' SeekOrigin.Begin);  				frameIDBytes = stream.Read (frameIDSize);  				if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  					isValidAtSyncSafe = false;  				}  				// if they're equal' we'll just have to go with syncsafe' since that's the spec  				if (isValidAtNonSyncSafe != isValidAtSyncSafe) {  					isID3v24SyncSafe = isValidAtSyncSafe;  				}  				break;  			}  		}  		stream.Seek (frameSize + 2' SeekOrigin.Current);  		bytesRead += frameSize + 10;  	}  	stream.Position = initialPosition;  	if (isID3v24SyncSafe == false) {  		tagReadingInfo.TagVersionOptions |= TagVersionOptions.UseNonSyncSafeFrameSizeID3v24;  	}  } else if (_id3v2Header.TagVersion == ID3v2TagVersion.ID3v22) {  	bool isID3v22CorrectSize = true;  	bytesRead = 0;  	readUntil = _id3v2Header.TagSize - _id3v2ExtendedHeader.SizeIncludingSizeBytes - frameIDSize;  	long initialPosition = stream.Position;  	stream.Read (frameIDSize);  	UnknownFrame unknownFrame = new UnknownFrame (null' tagReadingInfo' stream);  	bytesRead += unknownFrame.FrameHeader.FrameSizeTotal;  	if (bytesRead < readUntil) {  		byte[] frameIDBytes = stream.Read (frameIDSize);  		// TODO: Noticed some tags contain 0x00 'E' 'N' as a FrameID.  Frame is well structured  		// and other frames follow.  I believe the below (keep reading+looking) will cover this issue.  		// If character is not a letter or number' padding reached' audio began'  		// or otherwise the frame is not readable  		if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A) {  			if (frameIDBytes [1] >= 0x30 && frameIDBytes [1] <= 0x5A && frameIDBytes [2] >= 0x30 && frameIDBytes [2] <= 0x5A) {  				Trace.WriteLine ("ID3v2.2 frame size off by 1 byte");  				isID3v22CorrectSize = false;  			}  		}  	}  	stream.Position = initialPosition;  	if (isID3v22CorrectSize == false) {  		tagReadingInfo.TagVersionOptions |= TagVersionOptions.AddOneByteToSize;  	}  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2Tag.cs,Read,The following statement contains a magic number: if (_id3v2Header.TagVersion == ID3v2TagVersion.ID3v24) {  	bool isID3v24SyncSafe = true;  	bytesRead = 0;  	readUntil = _id3v2Header.TagSize - _id3v2ExtendedHeader.SizeIncludingSizeBytes - frameIDSize;  	long initialPosition = stream.Position;  	while (bytesRead < readUntil) {  		byte[] frameIDBytes = stream.Read (frameIDSize);  		// TODO: Noticed some tags contain 0x00 'E' 'N' as a FrameID.  Frame is well structured  		// and other frames follow.  I believe the below (keep reading+looking) will cover this issue.  		// If character is not a letter or number' padding reached' audio began'  		// or otherwise the frame is not readable  		if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  			// TODO: Try to keep reading and look for a valid frame  			if (frameIDBytes [0] != 0 && frameIDBytes [0] != 0xFF) {  				/*String msg = String.Format("Out of range FrameID - 0x{0:X}|0x{1:X}|0x{2:X}|0x{3:X}"'                                                        tmpFrameIDBytes[0]' tmpFrameIDBytes[1]' tmpFrameIDBytes[2]'                                                        tmpFrameIDBytes[3]);                             Trace.WriteLine(msg);*/}  			break;  		}  		int frameSize = stream.ReadInt32 ();  		if (frameSize > 0xFF) {  			if ((frameSize & 0x80) == 0x80) {  				isID3v24SyncSafe = false;  				break;  			}  			if ((frameSize & 0x8000) == 0x8000) {  				isID3v24SyncSafe = false;  				break;  			}  			if ((frameSize & 0x800000) == 0x800000) {  				isID3v24SyncSafe = false;  				break;  			}  			if (bytesRead + frameSize + 10 == _id3v2Header.TagSize) {  				// Could give a false positive' but relatively unlikely (famous last words' huh?)  				isID3v24SyncSafe = false;  				break;  			} else {  				stream.Seek (-4' SeekOrigin.Current);  				// go back to read sync-safe version  				int syncSafeFrameSize = ID3v2Utils.ReadInt32SyncSafe (stream);  				long currentPosition = stream.Position;  				bool isValidAtSyncSafe = true;  				bool isValidAtNonSyncSafe = true;  				// TODO - if it's the last frame and there is padding' both would indicate false  				// Use the one that returns some padding bytes opposed to bytes with non-zero values (could be frame data)  				// If non sync-safe reads past the end of the tag' then it's sync safe  				// Testing non-sync safe since it will always be bigger than the sync safe integer  				if (currentPosition + frameSize + 2 >= readUntil) {  					isID3v24SyncSafe = true;  					break;  				}  				// Test non-sync safe  				stream.Seek (currentPosition + frameSize + 2' SeekOrigin.Begin);  				frameIDBytes = stream.Read (frameIDSize);  				if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  					isValidAtNonSyncSafe = false;  				}  				// Test sync-safe  				stream.Seek (currentPosition + syncSafeFrameSize + 2' SeekOrigin.Begin);  				frameIDBytes = stream.Read (frameIDSize);  				if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  					isValidAtSyncSafe = false;  				}  				// if they're equal' we'll just have to go with syncsafe' since that's the spec  				if (isValidAtNonSyncSafe != isValidAtSyncSafe) {  					isID3v24SyncSafe = isValidAtSyncSafe;  				}  				break;  			}  		}  		stream.Seek (frameSize + 2' SeekOrigin.Current);  		bytesRead += frameSize + 10;  	}  	stream.Position = initialPosition;  	if (isID3v24SyncSafe == false) {  		tagReadingInfo.TagVersionOptions |= TagVersionOptions.UseNonSyncSafeFrameSizeID3v24;  	}  } else if (_id3v2Header.TagVersion == ID3v2TagVersion.ID3v22) {  	bool isID3v22CorrectSize = true;  	bytesRead = 0;  	readUntil = _id3v2Header.TagSize - _id3v2ExtendedHeader.SizeIncludingSizeBytes - frameIDSize;  	long initialPosition = stream.Position;  	stream.Read (frameIDSize);  	UnknownFrame unknownFrame = new UnknownFrame (null' tagReadingInfo' stream);  	bytesRead += unknownFrame.FrameHeader.FrameSizeTotal;  	if (bytesRead < readUntil) {  		byte[] frameIDBytes = stream.Read (frameIDSize);  		// TODO: Noticed some tags contain 0x00 'E' 'N' as a FrameID.  Frame is well structured  		// and other frames follow.  I believe the below (keep reading+looking) will cover this issue.  		// If character is not a letter or number' padding reached' audio began'  		// or otherwise the frame is not readable  		if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A) {  			if (frameIDBytes [1] >= 0x30 && frameIDBytes [1] <= 0x5A && frameIDBytes [2] >= 0x30 && frameIDBytes [2] <= 0x5A) {  				Trace.WriteLine ("ID3v2.2 frame size off by 1 byte");  				isID3v22CorrectSize = false;  			}  		}  	}  	stream.Position = initialPosition;  	if (isID3v22CorrectSize == false) {  		tagReadingInfo.TagVersionOptions |= TagVersionOptions.AddOneByteToSize;  	}  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2Tag.cs,Read,The following statement contains a magic number: if (_id3v2Header.TagVersion == ID3v2TagVersion.ID3v24) {  	bool isID3v24SyncSafe = true;  	bytesRead = 0;  	readUntil = _id3v2Header.TagSize - _id3v2ExtendedHeader.SizeIncludingSizeBytes - frameIDSize;  	long initialPosition = stream.Position;  	while (bytesRead < readUntil) {  		byte[] frameIDBytes = stream.Read (frameIDSize);  		// TODO: Noticed some tags contain 0x00 'E' 'N' as a FrameID.  Frame is well structured  		// and other frames follow.  I believe the below (keep reading+looking) will cover this issue.  		// If character is not a letter or number' padding reached' audio began'  		// or otherwise the frame is not readable  		if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  			// TODO: Try to keep reading and look for a valid frame  			if (frameIDBytes [0] != 0 && frameIDBytes [0] != 0xFF) {  				/*String msg = String.Format("Out of range FrameID - 0x{0:X}|0x{1:X}|0x{2:X}|0x{3:X}"'                                                        tmpFrameIDBytes[0]' tmpFrameIDBytes[1]' tmpFrameIDBytes[2]'                                                        tmpFrameIDBytes[3]);                             Trace.WriteLine(msg);*/}  			break;  		}  		int frameSize = stream.ReadInt32 ();  		if (frameSize > 0xFF) {  			if ((frameSize & 0x80) == 0x80) {  				isID3v24SyncSafe = false;  				break;  			}  			if ((frameSize & 0x8000) == 0x8000) {  				isID3v24SyncSafe = false;  				break;  			}  			if ((frameSize & 0x800000) == 0x800000) {  				isID3v24SyncSafe = false;  				break;  			}  			if (bytesRead + frameSize + 10 == _id3v2Header.TagSize) {  				// Could give a false positive' but relatively unlikely (famous last words' huh?)  				isID3v24SyncSafe = false;  				break;  			} else {  				stream.Seek (-4' SeekOrigin.Current);  				// go back to read sync-safe version  				int syncSafeFrameSize = ID3v2Utils.ReadInt32SyncSafe (stream);  				long currentPosition = stream.Position;  				bool isValidAtSyncSafe = true;  				bool isValidAtNonSyncSafe = true;  				// TODO - if it's the last frame and there is padding' both would indicate false  				// Use the one that returns some padding bytes opposed to bytes with non-zero values (could be frame data)  				// If non sync-safe reads past the end of the tag' then it's sync safe  				// Testing non-sync safe since it will always be bigger than the sync safe integer  				if (currentPosition + frameSize + 2 >= readUntil) {  					isID3v24SyncSafe = true;  					break;  				}  				// Test non-sync safe  				stream.Seek (currentPosition + frameSize + 2' SeekOrigin.Begin);  				frameIDBytes = stream.Read (frameIDSize);  				if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  					isValidAtNonSyncSafe = false;  				}  				// Test sync-safe  				stream.Seek (currentPosition + syncSafeFrameSize + 2' SeekOrigin.Begin);  				frameIDBytes = stream.Read (frameIDSize);  				if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  					isValidAtSyncSafe = false;  				}  				// if they're equal' we'll just have to go with syncsafe' since that's the spec  				if (isValidAtNonSyncSafe != isValidAtSyncSafe) {  					isID3v24SyncSafe = isValidAtSyncSafe;  				}  				break;  			}  		}  		stream.Seek (frameSize + 2' SeekOrigin.Current);  		bytesRead += frameSize + 10;  	}  	stream.Position = initialPosition;  	if (isID3v24SyncSafe == false) {  		tagReadingInfo.TagVersionOptions |= TagVersionOptions.UseNonSyncSafeFrameSizeID3v24;  	}  } else if (_id3v2Header.TagVersion == ID3v2TagVersion.ID3v22) {  	bool isID3v22CorrectSize = true;  	bytesRead = 0;  	readUntil = _id3v2Header.TagSize - _id3v2ExtendedHeader.SizeIncludingSizeBytes - frameIDSize;  	long initialPosition = stream.Position;  	stream.Read (frameIDSize);  	UnknownFrame unknownFrame = new UnknownFrame (null' tagReadingInfo' stream);  	bytesRead += unknownFrame.FrameHeader.FrameSizeTotal;  	if (bytesRead < readUntil) {  		byte[] frameIDBytes = stream.Read (frameIDSize);  		// TODO: Noticed some tags contain 0x00 'E' 'N' as a FrameID.  Frame is well structured  		// and other frames follow.  I believe the below (keep reading+looking) will cover this issue.  		// If character is not a letter or number' padding reached' audio began'  		// or otherwise the frame is not readable  		if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A) {  			if (frameIDBytes [1] >= 0x30 && frameIDBytes [1] <= 0x5A && frameIDBytes [2] >= 0x30 && frameIDBytes [2] <= 0x5A) {  				Trace.WriteLine ("ID3v2.2 frame size off by 1 byte");  				isID3v22CorrectSize = false;  			}  		}  	}  	stream.Position = initialPosition;  	if (isID3v22CorrectSize == false) {  		tagReadingInfo.TagVersionOptions |= TagVersionOptions.AddOneByteToSize;  	}  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2Tag.cs,Read,The following statement contains a magic number: if (_id3v2Header.TagVersion == ID3v2TagVersion.ID3v24) {  	bool isID3v24SyncSafe = true;  	bytesRead = 0;  	readUntil = _id3v2Header.TagSize - _id3v2ExtendedHeader.SizeIncludingSizeBytes - frameIDSize;  	long initialPosition = stream.Position;  	while (bytesRead < readUntil) {  		byte[] frameIDBytes = stream.Read (frameIDSize);  		// TODO: Noticed some tags contain 0x00 'E' 'N' as a FrameID.  Frame is well structured  		// and other frames follow.  I believe the below (keep reading+looking) will cover this issue.  		// If character is not a letter or number' padding reached' audio began'  		// or otherwise the frame is not readable  		if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  			// TODO: Try to keep reading and look for a valid frame  			if (frameIDBytes [0] != 0 && frameIDBytes [0] != 0xFF) {  				/*String msg = String.Format("Out of range FrameID - 0x{0:X}|0x{1:X}|0x{2:X}|0x{3:X}"'                                                        tmpFrameIDBytes[0]' tmpFrameIDBytes[1]' tmpFrameIDBytes[2]'                                                        tmpFrameIDBytes[3]);                             Trace.WriteLine(msg);*/}  			break;  		}  		int frameSize = stream.ReadInt32 ();  		if (frameSize > 0xFF) {  			if ((frameSize & 0x80) == 0x80) {  				isID3v24SyncSafe = false;  				break;  			}  			if ((frameSize & 0x8000) == 0x8000) {  				isID3v24SyncSafe = false;  				break;  			}  			if ((frameSize & 0x800000) == 0x800000) {  				isID3v24SyncSafe = false;  				break;  			}  			if (bytesRead + frameSize + 10 == _id3v2Header.TagSize) {  				// Could give a false positive' but relatively unlikely (famous last words' huh?)  				isID3v24SyncSafe = false;  				break;  			} else {  				stream.Seek (-4' SeekOrigin.Current);  				// go back to read sync-safe version  				int syncSafeFrameSize = ID3v2Utils.ReadInt32SyncSafe (stream);  				long currentPosition = stream.Position;  				bool isValidAtSyncSafe = true;  				bool isValidAtNonSyncSafe = true;  				// TODO - if it's the last frame and there is padding' both would indicate false  				// Use the one that returns some padding bytes opposed to bytes with non-zero values (could be frame data)  				// If non sync-safe reads past the end of the tag' then it's sync safe  				// Testing non-sync safe since it will always be bigger than the sync safe integer  				if (currentPosition + frameSize + 2 >= readUntil) {  					isID3v24SyncSafe = true;  					break;  				}  				// Test non-sync safe  				stream.Seek (currentPosition + frameSize + 2' SeekOrigin.Begin);  				frameIDBytes = stream.Read (frameIDSize);  				if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  					isValidAtNonSyncSafe = false;  				}  				// Test sync-safe  				stream.Seek (currentPosition + syncSafeFrameSize + 2' SeekOrigin.Begin);  				frameIDBytes = stream.Read (frameIDSize);  				if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  					isValidAtSyncSafe = false;  				}  				// if they're equal' we'll just have to go with syncsafe' since that's the spec  				if (isValidAtNonSyncSafe != isValidAtSyncSafe) {  					isID3v24SyncSafe = isValidAtSyncSafe;  				}  				break;  			}  		}  		stream.Seek (frameSize + 2' SeekOrigin.Current);  		bytesRead += frameSize + 10;  	}  	stream.Position = initialPosition;  	if (isID3v24SyncSafe == false) {  		tagReadingInfo.TagVersionOptions |= TagVersionOptions.UseNonSyncSafeFrameSizeID3v24;  	}  } else if (_id3v2Header.TagVersion == ID3v2TagVersion.ID3v22) {  	bool isID3v22CorrectSize = true;  	bytesRead = 0;  	readUntil = _id3v2Header.TagSize - _id3v2ExtendedHeader.SizeIncludingSizeBytes - frameIDSize;  	long initialPosition = stream.Position;  	stream.Read (frameIDSize);  	UnknownFrame unknownFrame = new UnknownFrame (null' tagReadingInfo' stream);  	bytesRead += unknownFrame.FrameHeader.FrameSizeTotal;  	if (bytesRead < readUntil) {  		byte[] frameIDBytes = stream.Read (frameIDSize);  		// TODO: Noticed some tags contain 0x00 'E' 'N' as a FrameID.  Frame is well structured  		// and other frames follow.  I believe the below (keep reading+looking) will cover this issue.  		// If character is not a letter or number' padding reached' audio began'  		// or otherwise the frame is not readable  		if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A) {  			if (frameIDBytes [1] >= 0x30 && frameIDBytes [1] <= 0x5A && frameIDBytes [2] >= 0x30 && frameIDBytes [2] <= 0x5A) {  				Trace.WriteLine ("ID3v2.2 frame size off by 1 byte");  				isID3v22CorrectSize = false;  			}  		}  	}  	stream.Position = initialPosition;  	if (isID3v22CorrectSize == false) {  		tagReadingInfo.TagVersionOptions |= TagVersionOptions.AddOneByteToSize;  	}  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2Tag.cs,Read,The following statement contains a magic number: if (_id3v2Header.TagVersion == ID3v2TagVersion.ID3v24) {  	bool isID3v24SyncSafe = true;  	bytesRead = 0;  	readUntil = _id3v2Header.TagSize - _id3v2ExtendedHeader.SizeIncludingSizeBytes - frameIDSize;  	long initialPosition = stream.Position;  	while (bytesRead < readUntil) {  		byte[] frameIDBytes = stream.Read (frameIDSize);  		// TODO: Noticed some tags contain 0x00 'E' 'N' as a FrameID.  Frame is well structured  		// and other frames follow.  I believe the below (keep reading+looking) will cover this issue.  		// If character is not a letter or number' padding reached' audio began'  		// or otherwise the frame is not readable  		if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  			// TODO: Try to keep reading and look for a valid frame  			if (frameIDBytes [0] != 0 && frameIDBytes [0] != 0xFF) {  				/*String msg = String.Format("Out of range FrameID - 0x{0:X}|0x{1:X}|0x{2:X}|0x{3:X}"'                                                        tmpFrameIDBytes[0]' tmpFrameIDBytes[1]' tmpFrameIDBytes[2]'                                                        tmpFrameIDBytes[3]);                             Trace.WriteLine(msg);*/}  			break;  		}  		int frameSize = stream.ReadInt32 ();  		if (frameSize > 0xFF) {  			if ((frameSize & 0x80) == 0x80) {  				isID3v24SyncSafe = false;  				break;  			}  			if ((frameSize & 0x8000) == 0x8000) {  				isID3v24SyncSafe = false;  				break;  			}  			if ((frameSize & 0x800000) == 0x800000) {  				isID3v24SyncSafe = false;  				break;  			}  			if (bytesRead + frameSize + 10 == _id3v2Header.TagSize) {  				// Could give a false positive' but relatively unlikely (famous last words' huh?)  				isID3v24SyncSafe = false;  				break;  			} else {  				stream.Seek (-4' SeekOrigin.Current);  				// go back to read sync-safe version  				int syncSafeFrameSize = ID3v2Utils.ReadInt32SyncSafe (stream);  				long currentPosition = stream.Position;  				bool isValidAtSyncSafe = true;  				bool isValidAtNonSyncSafe = true;  				// TODO - if it's the last frame and there is padding' both would indicate false  				// Use the one that returns some padding bytes opposed to bytes with non-zero values (could be frame data)  				// If non sync-safe reads past the end of the tag' then it's sync safe  				// Testing non-sync safe since it will always be bigger than the sync safe integer  				if (currentPosition + frameSize + 2 >= readUntil) {  					isID3v24SyncSafe = true;  					break;  				}  				// Test non-sync safe  				stream.Seek (currentPosition + frameSize + 2' SeekOrigin.Begin);  				frameIDBytes = stream.Read (frameIDSize);  				if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  					isValidAtNonSyncSafe = false;  				}  				// Test sync-safe  				stream.Seek (currentPosition + syncSafeFrameSize + 2' SeekOrigin.Begin);  				frameIDBytes = stream.Read (frameIDSize);  				if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  					isValidAtSyncSafe = false;  				}  				// if they're equal' we'll just have to go with syncsafe' since that's the spec  				if (isValidAtNonSyncSafe != isValidAtSyncSafe) {  					isID3v24SyncSafe = isValidAtSyncSafe;  				}  				break;  			}  		}  		stream.Seek (frameSize + 2' SeekOrigin.Current);  		bytesRead += frameSize + 10;  	}  	stream.Position = initialPosition;  	if (isID3v24SyncSafe == false) {  		tagReadingInfo.TagVersionOptions |= TagVersionOptions.UseNonSyncSafeFrameSizeID3v24;  	}  } else if (_id3v2Header.TagVersion == ID3v2TagVersion.ID3v22) {  	bool isID3v22CorrectSize = true;  	bytesRead = 0;  	readUntil = _id3v2Header.TagSize - _id3v2ExtendedHeader.SizeIncludingSizeBytes - frameIDSize;  	long initialPosition = stream.Position;  	stream.Read (frameIDSize);  	UnknownFrame unknownFrame = new UnknownFrame (null' tagReadingInfo' stream);  	bytesRead += unknownFrame.FrameHeader.FrameSizeTotal;  	if (bytesRead < readUntil) {  		byte[] frameIDBytes = stream.Read (frameIDSize);  		// TODO: Noticed some tags contain 0x00 'E' 'N' as a FrameID.  Frame is well structured  		// and other frames follow.  I believe the below (keep reading+looking) will cover this issue.  		// If character is not a letter or number' padding reached' audio began'  		// or otherwise the frame is not readable  		if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A) {  			if (frameIDBytes [1] >= 0x30 && frameIDBytes [1] <= 0x5A && frameIDBytes [2] >= 0x30 && frameIDBytes [2] <= 0x5A) {  				Trace.WriteLine ("ID3v2.2 frame size off by 1 byte");  				isID3v22CorrectSize = false;  			}  		}  	}  	stream.Position = initialPosition;  	if (isID3v22CorrectSize == false) {  		tagReadingInfo.TagVersionOptions |= TagVersionOptions.AddOneByteToSize;  	}  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2Tag.cs,Read,The following statement contains a magic number: if (_id3v2Header.TagVersion == ID3v2TagVersion.ID3v24) {  	bool isID3v24SyncSafe = true;  	bytesRead = 0;  	readUntil = _id3v2Header.TagSize - _id3v2ExtendedHeader.SizeIncludingSizeBytes - frameIDSize;  	long initialPosition = stream.Position;  	while (bytesRead < readUntil) {  		byte[] frameIDBytes = stream.Read (frameIDSize);  		// TODO: Noticed some tags contain 0x00 'E' 'N' as a FrameID.  Frame is well structured  		// and other frames follow.  I believe the below (keep reading+looking) will cover this issue.  		// If character is not a letter or number' padding reached' audio began'  		// or otherwise the frame is not readable  		if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  			// TODO: Try to keep reading and look for a valid frame  			if (frameIDBytes [0] != 0 && frameIDBytes [0] != 0xFF) {  				/*String msg = String.Format("Out of range FrameID - 0x{0:X}|0x{1:X}|0x{2:X}|0x{3:X}"'                                                        tmpFrameIDBytes[0]' tmpFrameIDBytes[1]' tmpFrameIDBytes[2]'                                                        tmpFrameIDBytes[3]);                             Trace.WriteLine(msg);*/}  			break;  		}  		int frameSize = stream.ReadInt32 ();  		if (frameSize > 0xFF) {  			if ((frameSize & 0x80) == 0x80) {  				isID3v24SyncSafe = false;  				break;  			}  			if ((frameSize & 0x8000) == 0x8000) {  				isID3v24SyncSafe = false;  				break;  			}  			if ((frameSize & 0x800000) == 0x800000) {  				isID3v24SyncSafe = false;  				break;  			}  			if (bytesRead + frameSize + 10 == _id3v2Header.TagSize) {  				// Could give a false positive' but relatively unlikely (famous last words' huh?)  				isID3v24SyncSafe = false;  				break;  			} else {  				stream.Seek (-4' SeekOrigin.Current);  				// go back to read sync-safe version  				int syncSafeFrameSize = ID3v2Utils.ReadInt32SyncSafe (stream);  				long currentPosition = stream.Position;  				bool isValidAtSyncSafe = true;  				bool isValidAtNonSyncSafe = true;  				// TODO - if it's the last frame and there is padding' both would indicate false  				// Use the one that returns some padding bytes opposed to bytes with non-zero values (could be frame data)  				// If non sync-safe reads past the end of the tag' then it's sync safe  				// Testing non-sync safe since it will always be bigger than the sync safe integer  				if (currentPosition + frameSize + 2 >= readUntil) {  					isID3v24SyncSafe = true;  					break;  				}  				// Test non-sync safe  				stream.Seek (currentPosition + frameSize + 2' SeekOrigin.Begin);  				frameIDBytes = stream.Read (frameIDSize);  				if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  					isValidAtNonSyncSafe = false;  				}  				// Test sync-safe  				stream.Seek (currentPosition + syncSafeFrameSize + 2' SeekOrigin.Begin);  				frameIDBytes = stream.Read (frameIDSize);  				if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  					isValidAtSyncSafe = false;  				}  				// if they're equal' we'll just have to go with syncsafe' since that's the spec  				if (isValidAtNonSyncSafe != isValidAtSyncSafe) {  					isID3v24SyncSafe = isValidAtSyncSafe;  				}  				break;  			}  		}  		stream.Seek (frameSize + 2' SeekOrigin.Current);  		bytesRead += frameSize + 10;  	}  	stream.Position = initialPosition;  	if (isID3v24SyncSafe == false) {  		tagReadingInfo.TagVersionOptions |= TagVersionOptions.UseNonSyncSafeFrameSizeID3v24;  	}  } else if (_id3v2Header.TagVersion == ID3v2TagVersion.ID3v22) {  	bool isID3v22CorrectSize = true;  	bytesRead = 0;  	readUntil = _id3v2Header.TagSize - _id3v2ExtendedHeader.SizeIncludingSizeBytes - frameIDSize;  	long initialPosition = stream.Position;  	stream.Read (frameIDSize);  	UnknownFrame unknownFrame = new UnknownFrame (null' tagReadingInfo' stream);  	bytesRead += unknownFrame.FrameHeader.FrameSizeTotal;  	if (bytesRead < readUntil) {  		byte[] frameIDBytes = stream.Read (frameIDSize);  		// TODO: Noticed some tags contain 0x00 'E' 'N' as a FrameID.  Frame is well structured  		// and other frames follow.  I believe the below (keep reading+looking) will cover this issue.  		// If character is not a letter or number' padding reached' audio began'  		// or otherwise the frame is not readable  		if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A) {  			if (frameIDBytes [1] >= 0x30 && frameIDBytes [1] <= 0x5A && frameIDBytes [2] >= 0x30 && frameIDBytes [2] <= 0x5A) {  				Trace.WriteLine ("ID3v2.2 frame size off by 1 byte");  				isID3v22CorrectSize = false;  			}  		}  	}  	stream.Position = initialPosition;  	if (isID3v22CorrectSize == false) {  		tagReadingInfo.TagVersionOptions |= TagVersionOptions.AddOneByteToSize;  	}  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2Tag.cs,Read,The following statement contains a magic number: if (_id3v2Header.TagVersion == ID3v2TagVersion.ID3v24) {  	bool isID3v24SyncSafe = true;  	bytesRead = 0;  	readUntil = _id3v2Header.TagSize - _id3v2ExtendedHeader.SizeIncludingSizeBytes - frameIDSize;  	long initialPosition = stream.Position;  	while (bytesRead < readUntil) {  		byte[] frameIDBytes = stream.Read (frameIDSize);  		// TODO: Noticed some tags contain 0x00 'E' 'N' as a FrameID.  Frame is well structured  		// and other frames follow.  I believe the below (keep reading+looking) will cover this issue.  		// If character is not a letter or number' padding reached' audio began'  		// or otherwise the frame is not readable  		if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  			// TODO: Try to keep reading and look for a valid frame  			if (frameIDBytes [0] != 0 && frameIDBytes [0] != 0xFF) {  				/*String msg = String.Format("Out of range FrameID - 0x{0:X}|0x{1:X}|0x{2:X}|0x{3:X}"'                                                        tmpFrameIDBytes[0]' tmpFrameIDBytes[1]' tmpFrameIDBytes[2]'                                                        tmpFrameIDBytes[3]);                             Trace.WriteLine(msg);*/}  			break;  		}  		int frameSize = stream.ReadInt32 ();  		if (frameSize > 0xFF) {  			if ((frameSize & 0x80) == 0x80) {  				isID3v24SyncSafe = false;  				break;  			}  			if ((frameSize & 0x8000) == 0x8000) {  				isID3v24SyncSafe = false;  				break;  			}  			if ((frameSize & 0x800000) == 0x800000) {  				isID3v24SyncSafe = false;  				break;  			}  			if (bytesRead + frameSize + 10 == _id3v2Header.TagSize) {  				// Could give a false positive' but relatively unlikely (famous last words' huh?)  				isID3v24SyncSafe = false;  				break;  			} else {  				stream.Seek (-4' SeekOrigin.Current);  				// go back to read sync-safe version  				int syncSafeFrameSize = ID3v2Utils.ReadInt32SyncSafe (stream);  				long currentPosition = stream.Position;  				bool isValidAtSyncSafe = true;  				bool isValidAtNonSyncSafe = true;  				// TODO - if it's the last frame and there is padding' both would indicate false  				// Use the one that returns some padding bytes opposed to bytes with non-zero values (could be frame data)  				// If non sync-safe reads past the end of the tag' then it's sync safe  				// Testing non-sync safe since it will always be bigger than the sync safe integer  				if (currentPosition + frameSize + 2 >= readUntil) {  					isID3v24SyncSafe = true;  					break;  				}  				// Test non-sync safe  				stream.Seek (currentPosition + frameSize + 2' SeekOrigin.Begin);  				frameIDBytes = stream.Read (frameIDSize);  				if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  					isValidAtNonSyncSafe = false;  				}  				// Test sync-safe  				stream.Seek (currentPosition + syncSafeFrameSize + 2' SeekOrigin.Begin);  				frameIDBytes = stream.Read (frameIDSize);  				if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  					isValidAtSyncSafe = false;  				}  				// if they're equal' we'll just have to go with syncsafe' since that's the spec  				if (isValidAtNonSyncSafe != isValidAtSyncSafe) {  					isID3v24SyncSafe = isValidAtSyncSafe;  				}  				break;  			}  		}  		stream.Seek (frameSize + 2' SeekOrigin.Current);  		bytesRead += frameSize + 10;  	}  	stream.Position = initialPosition;  	if (isID3v24SyncSafe == false) {  		tagReadingInfo.TagVersionOptions |= TagVersionOptions.UseNonSyncSafeFrameSizeID3v24;  	}  } else if (_id3v2Header.TagVersion == ID3v2TagVersion.ID3v22) {  	bool isID3v22CorrectSize = true;  	bytesRead = 0;  	readUntil = _id3v2Header.TagSize - _id3v2ExtendedHeader.SizeIncludingSizeBytes - frameIDSize;  	long initialPosition = stream.Position;  	stream.Read (frameIDSize);  	UnknownFrame unknownFrame = new UnknownFrame (null' tagReadingInfo' stream);  	bytesRead += unknownFrame.FrameHeader.FrameSizeTotal;  	if (bytesRead < readUntil) {  		byte[] frameIDBytes = stream.Read (frameIDSize);  		// TODO: Noticed some tags contain 0x00 'E' 'N' as a FrameID.  Frame is well structured  		// and other frames follow.  I believe the below (keep reading+looking) will cover this issue.  		// If character is not a letter or number' padding reached' audio began'  		// or otherwise the frame is not readable  		if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A) {  			if (frameIDBytes [1] >= 0x30 && frameIDBytes [1] <= 0x5A && frameIDBytes [2] >= 0x30 && frameIDBytes [2] <= 0x5A) {  				Trace.WriteLine ("ID3v2.2 frame size off by 1 byte");  				isID3v22CorrectSize = false;  			}  		}  	}  	stream.Position = initialPosition;  	if (isID3v22CorrectSize == false) {  		tagReadingInfo.TagVersionOptions |= TagVersionOptions.AddOneByteToSize;  	}  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2Tag.cs,Read,The following statement contains a magic number: if (_id3v2Header.TagVersion == ID3v2TagVersion.ID3v24) {  	bool isID3v24SyncSafe = true;  	bytesRead = 0;  	readUntil = _id3v2Header.TagSize - _id3v2ExtendedHeader.SizeIncludingSizeBytes - frameIDSize;  	long initialPosition = stream.Position;  	while (bytesRead < readUntil) {  		byte[] frameIDBytes = stream.Read (frameIDSize);  		// TODO: Noticed some tags contain 0x00 'E' 'N' as a FrameID.  Frame is well structured  		// and other frames follow.  I believe the below (keep reading+looking) will cover this issue.  		// If character is not a letter or number' padding reached' audio began'  		// or otherwise the frame is not readable  		if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  			// TODO: Try to keep reading and look for a valid frame  			if (frameIDBytes [0] != 0 && frameIDBytes [0] != 0xFF) {  				/*String msg = String.Format("Out of range FrameID - 0x{0:X}|0x{1:X}|0x{2:X}|0x{3:X}"'                                                        tmpFrameIDBytes[0]' tmpFrameIDBytes[1]' tmpFrameIDBytes[2]'                                                        tmpFrameIDBytes[3]);                             Trace.WriteLine(msg);*/}  			break;  		}  		int frameSize = stream.ReadInt32 ();  		if (frameSize > 0xFF) {  			if ((frameSize & 0x80) == 0x80) {  				isID3v24SyncSafe = false;  				break;  			}  			if ((frameSize & 0x8000) == 0x8000) {  				isID3v24SyncSafe = false;  				break;  			}  			if ((frameSize & 0x800000) == 0x800000) {  				isID3v24SyncSafe = false;  				break;  			}  			if (bytesRead + frameSize + 10 == _id3v2Header.TagSize) {  				// Could give a false positive' but relatively unlikely (famous last words' huh?)  				isID3v24SyncSafe = false;  				break;  			} else {  				stream.Seek (-4' SeekOrigin.Current);  				// go back to read sync-safe version  				int syncSafeFrameSize = ID3v2Utils.ReadInt32SyncSafe (stream);  				long currentPosition = stream.Position;  				bool isValidAtSyncSafe = true;  				bool isValidAtNonSyncSafe = true;  				// TODO - if it's the last frame and there is padding' both would indicate false  				// Use the one that returns some padding bytes opposed to bytes with non-zero values (could be frame data)  				// If non sync-safe reads past the end of the tag' then it's sync safe  				// Testing non-sync safe since it will always be bigger than the sync safe integer  				if (currentPosition + frameSize + 2 >= readUntil) {  					isID3v24SyncSafe = true;  					break;  				}  				// Test non-sync safe  				stream.Seek (currentPosition + frameSize + 2' SeekOrigin.Begin);  				frameIDBytes = stream.Read (frameIDSize);  				if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  					isValidAtNonSyncSafe = false;  				}  				// Test sync-safe  				stream.Seek (currentPosition + syncSafeFrameSize + 2' SeekOrigin.Begin);  				frameIDBytes = stream.Read (frameIDSize);  				if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  					isValidAtSyncSafe = false;  				}  				// if they're equal' we'll just have to go with syncsafe' since that's the spec  				if (isValidAtNonSyncSafe != isValidAtSyncSafe) {  					isID3v24SyncSafe = isValidAtSyncSafe;  				}  				break;  			}  		}  		stream.Seek (frameSize + 2' SeekOrigin.Current);  		bytesRead += frameSize + 10;  	}  	stream.Position = initialPosition;  	if (isID3v24SyncSafe == false) {  		tagReadingInfo.TagVersionOptions |= TagVersionOptions.UseNonSyncSafeFrameSizeID3v24;  	}  } else if (_id3v2Header.TagVersion == ID3v2TagVersion.ID3v22) {  	bool isID3v22CorrectSize = true;  	bytesRead = 0;  	readUntil = _id3v2Header.TagSize - _id3v2ExtendedHeader.SizeIncludingSizeBytes - frameIDSize;  	long initialPosition = stream.Position;  	stream.Read (frameIDSize);  	UnknownFrame unknownFrame = new UnknownFrame (null' tagReadingInfo' stream);  	bytesRead += unknownFrame.FrameHeader.FrameSizeTotal;  	if (bytesRead < readUntil) {  		byte[] frameIDBytes = stream.Read (frameIDSize);  		// TODO: Noticed some tags contain 0x00 'E' 'N' as a FrameID.  Frame is well structured  		// and other frames follow.  I believe the below (keep reading+looking) will cover this issue.  		// If character is not a letter or number' padding reached' audio began'  		// or otherwise the frame is not readable  		if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A) {  			if (frameIDBytes [1] >= 0x30 && frameIDBytes [1] <= 0x5A && frameIDBytes [2] >= 0x30 && frameIDBytes [2] <= 0x5A) {  				Trace.WriteLine ("ID3v2.2 frame size off by 1 byte");  				isID3v22CorrectSize = false;  			}  		}  	}  	stream.Position = initialPosition;  	if (isID3v22CorrectSize == false) {  		tagReadingInfo.TagVersionOptions |= TagVersionOptions.AddOneByteToSize;  	}  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2Tag.cs,Read,The following statement contains a magic number: if (_id3v2Header.TagVersion == ID3v2TagVersion.ID3v24) {  	bool isID3v24SyncSafe = true;  	bytesRead = 0;  	readUntil = _id3v2Header.TagSize - _id3v2ExtendedHeader.SizeIncludingSizeBytes - frameIDSize;  	long initialPosition = stream.Position;  	while (bytesRead < readUntil) {  		byte[] frameIDBytes = stream.Read (frameIDSize);  		// TODO: Noticed some tags contain 0x00 'E' 'N' as a FrameID.  Frame is well structured  		// and other frames follow.  I believe the below (keep reading+looking) will cover this issue.  		// If character is not a letter or number' padding reached' audio began'  		// or otherwise the frame is not readable  		if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  			// TODO: Try to keep reading and look for a valid frame  			if (frameIDBytes [0] != 0 && frameIDBytes [0] != 0xFF) {  				/*String msg = String.Format("Out of range FrameID - 0x{0:X}|0x{1:X}|0x{2:X}|0x{3:X}"'                                                        tmpFrameIDBytes[0]' tmpFrameIDBytes[1]' tmpFrameIDBytes[2]'                                                        tmpFrameIDBytes[3]);                             Trace.WriteLine(msg);*/}  			break;  		}  		int frameSize = stream.ReadInt32 ();  		if (frameSize > 0xFF) {  			if ((frameSize & 0x80) == 0x80) {  				isID3v24SyncSafe = false;  				break;  			}  			if ((frameSize & 0x8000) == 0x8000) {  				isID3v24SyncSafe = false;  				break;  			}  			if ((frameSize & 0x800000) == 0x800000) {  				isID3v24SyncSafe = false;  				break;  			}  			if (bytesRead + frameSize + 10 == _id3v2Header.TagSize) {  				// Could give a false positive' but relatively unlikely (famous last words' huh?)  				isID3v24SyncSafe = false;  				break;  			} else {  				stream.Seek (-4' SeekOrigin.Current);  				// go back to read sync-safe version  				int syncSafeFrameSize = ID3v2Utils.ReadInt32SyncSafe (stream);  				long currentPosition = stream.Position;  				bool isValidAtSyncSafe = true;  				bool isValidAtNonSyncSafe = true;  				// TODO - if it's the last frame and there is padding' both would indicate false  				// Use the one that returns some padding bytes opposed to bytes with non-zero values (could be frame data)  				// If non sync-safe reads past the end of the tag' then it's sync safe  				// Testing non-sync safe since it will always be bigger than the sync safe integer  				if (currentPosition + frameSize + 2 >= readUntil) {  					isID3v24SyncSafe = true;  					break;  				}  				// Test non-sync safe  				stream.Seek (currentPosition + frameSize + 2' SeekOrigin.Begin);  				frameIDBytes = stream.Read (frameIDSize);  				if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  					isValidAtNonSyncSafe = false;  				}  				// Test sync-safe  				stream.Seek (currentPosition + syncSafeFrameSize + 2' SeekOrigin.Begin);  				frameIDBytes = stream.Read (frameIDSize);  				if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  					isValidAtSyncSafe = false;  				}  				// if they're equal' we'll just have to go with syncsafe' since that's the spec  				if (isValidAtNonSyncSafe != isValidAtSyncSafe) {  					isID3v24SyncSafe = isValidAtSyncSafe;  				}  				break;  			}  		}  		stream.Seek (frameSize + 2' SeekOrigin.Current);  		bytesRead += frameSize + 10;  	}  	stream.Position = initialPosition;  	if (isID3v24SyncSafe == false) {  		tagReadingInfo.TagVersionOptions |= TagVersionOptions.UseNonSyncSafeFrameSizeID3v24;  	}  } else if (_id3v2Header.TagVersion == ID3v2TagVersion.ID3v22) {  	bool isID3v22CorrectSize = true;  	bytesRead = 0;  	readUntil = _id3v2Header.TagSize - _id3v2ExtendedHeader.SizeIncludingSizeBytes - frameIDSize;  	long initialPosition = stream.Position;  	stream.Read (frameIDSize);  	UnknownFrame unknownFrame = new UnknownFrame (null' tagReadingInfo' stream);  	bytesRead += unknownFrame.FrameHeader.FrameSizeTotal;  	if (bytesRead < readUntil) {  		byte[] frameIDBytes = stream.Read (frameIDSize);  		// TODO: Noticed some tags contain 0x00 'E' 'N' as a FrameID.  Frame is well structured  		// and other frames follow.  I believe the below (keep reading+looking) will cover this issue.  		// If character is not a letter or number' padding reached' audio began'  		// or otherwise the frame is not readable  		if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A) {  			if (frameIDBytes [1] >= 0x30 && frameIDBytes [1] <= 0x5A && frameIDBytes [2] >= 0x30 && frameIDBytes [2] <= 0x5A) {  				Trace.WriteLine ("ID3v2.2 frame size off by 1 byte");  				isID3v22CorrectSize = false;  			}  		}  	}  	stream.Position = initialPosition;  	if (isID3v22CorrectSize == false) {  		tagReadingInfo.TagVersionOptions |= TagVersionOptions.AddOneByteToSize;  	}  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2Tag.cs,Read,The following statement contains a magic number: while (bytesRead < readUntil) {  	byte[] frameIDBytes = stream.Read (frameIDSize);  	// TODO: Noticed some tags contain 0x00 'E' 'N' as a FrameID.  Frame is well structured  	// and other frames follow.  I believe the below (keep reading+looking) will cover this issue.  	// If character is not a letter or number' padding reached' audio began'  	// or otherwise the frame is not readable  	if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  		// TODO: Try to keep reading and look for a valid frame  		if (frameIDBytes [0] != 0 && frameIDBytes [0] != 0xFF) {  			/*String msg = String.Format("Out of range FrameID - 0x{0:X}|0x{1:X}|0x{2:X}|0x{3:X}"'                                                        tmpFrameIDBytes[0]' tmpFrameIDBytes[1]' tmpFrameIDBytes[2]'                                                        tmpFrameIDBytes[3]);                             Trace.WriteLine(msg);*/}  		break;  	}  	int frameSize = stream.ReadInt32 ();  	if (frameSize > 0xFF) {  		if ((frameSize & 0x80) == 0x80) {  			isID3v24SyncSafe = false;  			break;  		}  		if ((frameSize & 0x8000) == 0x8000) {  			isID3v24SyncSafe = false;  			break;  		}  		if ((frameSize & 0x800000) == 0x800000) {  			isID3v24SyncSafe = false;  			break;  		}  		if (bytesRead + frameSize + 10 == _id3v2Header.TagSize) {  			// Could give a false positive' but relatively unlikely (famous last words' huh?)  			isID3v24SyncSafe = false;  			break;  		} else {  			stream.Seek (-4' SeekOrigin.Current);  			// go back to read sync-safe version  			int syncSafeFrameSize = ID3v2Utils.ReadInt32SyncSafe (stream);  			long currentPosition = stream.Position;  			bool isValidAtSyncSafe = true;  			bool isValidAtNonSyncSafe = true;  			// TODO - if it's the last frame and there is padding' both would indicate false  			// Use the one that returns some padding bytes opposed to bytes with non-zero values (could be frame data)  			// If non sync-safe reads past the end of the tag' then it's sync safe  			// Testing non-sync safe since it will always be bigger than the sync safe integer  			if (currentPosition + frameSize + 2 >= readUntil) {  				isID3v24SyncSafe = true;  				break;  			}  			// Test non-sync safe  			stream.Seek (currentPosition + frameSize + 2' SeekOrigin.Begin);  			frameIDBytes = stream.Read (frameIDSize);  			if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  				isValidAtNonSyncSafe = false;  			}  			// Test sync-safe  			stream.Seek (currentPosition + syncSafeFrameSize + 2' SeekOrigin.Begin);  			frameIDBytes = stream.Read (frameIDSize);  			if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  				isValidAtSyncSafe = false;  			}  			// if they're equal' we'll just have to go with syncsafe' since that's the spec  			if (isValidAtNonSyncSafe != isValidAtSyncSafe) {  				isID3v24SyncSafe = isValidAtSyncSafe;  			}  			break;  		}  	}  	stream.Seek (frameSize + 2' SeekOrigin.Current);  	bytesRead += frameSize + 10;  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2Tag.cs,Read,The following statement contains a magic number: while (bytesRead < readUntil) {  	byte[] frameIDBytes = stream.Read (frameIDSize);  	// TODO: Noticed some tags contain 0x00 'E' 'N' as a FrameID.  Frame is well structured  	// and other frames follow.  I believe the below (keep reading+looking) will cover this issue.  	// If character is not a letter or number' padding reached' audio began'  	// or otherwise the frame is not readable  	if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  		// TODO: Try to keep reading and look for a valid frame  		if (frameIDBytes [0] != 0 && frameIDBytes [0] != 0xFF) {  			/*String msg = String.Format("Out of range FrameID - 0x{0:X}|0x{1:X}|0x{2:X}|0x{3:X}"'                                                        tmpFrameIDBytes[0]' tmpFrameIDBytes[1]' tmpFrameIDBytes[2]'                                                        tmpFrameIDBytes[3]);                             Trace.WriteLine(msg);*/}  		break;  	}  	int frameSize = stream.ReadInt32 ();  	if (frameSize > 0xFF) {  		if ((frameSize & 0x80) == 0x80) {  			isID3v24SyncSafe = false;  			break;  		}  		if ((frameSize & 0x8000) == 0x8000) {  			isID3v24SyncSafe = false;  			break;  		}  		if ((frameSize & 0x800000) == 0x800000) {  			isID3v24SyncSafe = false;  			break;  		}  		if (bytesRead + frameSize + 10 == _id3v2Header.TagSize) {  			// Could give a false positive' but relatively unlikely (famous last words' huh?)  			isID3v24SyncSafe = false;  			break;  		} else {  			stream.Seek (-4' SeekOrigin.Current);  			// go back to read sync-safe version  			int syncSafeFrameSize = ID3v2Utils.ReadInt32SyncSafe (stream);  			long currentPosition = stream.Position;  			bool isValidAtSyncSafe = true;  			bool isValidAtNonSyncSafe = true;  			// TODO - if it's the last frame and there is padding' both would indicate false  			// Use the one that returns some padding bytes opposed to bytes with non-zero values (could be frame data)  			// If non sync-safe reads past the end of the tag' then it's sync safe  			// Testing non-sync safe since it will always be bigger than the sync safe integer  			if (currentPosition + frameSize + 2 >= readUntil) {  				isID3v24SyncSafe = true;  				break;  			}  			// Test non-sync safe  			stream.Seek (currentPosition + frameSize + 2' SeekOrigin.Begin);  			frameIDBytes = stream.Read (frameIDSize);  			if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  				isValidAtNonSyncSafe = false;  			}  			// Test sync-safe  			stream.Seek (currentPosition + syncSafeFrameSize + 2' SeekOrigin.Begin);  			frameIDBytes = stream.Read (frameIDSize);  			if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  				isValidAtSyncSafe = false;  			}  			// if they're equal' we'll just have to go with syncsafe' since that's the spec  			if (isValidAtNonSyncSafe != isValidAtSyncSafe) {  				isID3v24SyncSafe = isValidAtSyncSafe;  			}  			break;  		}  	}  	stream.Seek (frameSize + 2' SeekOrigin.Current);  	bytesRead += frameSize + 10;  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2Tag.cs,Read,The following statement contains a magic number: while (bytesRead < readUntil) {  	byte[] frameIDBytes = stream.Read (frameIDSize);  	// TODO: Noticed some tags contain 0x00 'E' 'N' as a FrameID.  Frame is well structured  	// and other frames follow.  I believe the below (keep reading+looking) will cover this issue.  	// If character is not a letter or number' padding reached' audio began'  	// or otherwise the frame is not readable  	if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  		// TODO: Try to keep reading and look for a valid frame  		if (frameIDBytes [0] != 0 && frameIDBytes [0] != 0xFF) {  			/*String msg = String.Format("Out of range FrameID - 0x{0:X}|0x{1:X}|0x{2:X}|0x{3:X}"'                                                        tmpFrameIDBytes[0]' tmpFrameIDBytes[1]' tmpFrameIDBytes[2]'                                                        tmpFrameIDBytes[3]);                             Trace.WriteLine(msg);*/}  		break;  	}  	int frameSize = stream.ReadInt32 ();  	if (frameSize > 0xFF) {  		if ((frameSize & 0x80) == 0x80) {  			isID3v24SyncSafe = false;  			break;  		}  		if ((frameSize & 0x8000) == 0x8000) {  			isID3v24SyncSafe = false;  			break;  		}  		if ((frameSize & 0x800000) == 0x800000) {  			isID3v24SyncSafe = false;  			break;  		}  		if (bytesRead + frameSize + 10 == _id3v2Header.TagSize) {  			// Could give a false positive' but relatively unlikely (famous last words' huh?)  			isID3v24SyncSafe = false;  			break;  		} else {  			stream.Seek (-4' SeekOrigin.Current);  			// go back to read sync-safe version  			int syncSafeFrameSize = ID3v2Utils.ReadInt32SyncSafe (stream);  			long currentPosition = stream.Position;  			bool isValidAtSyncSafe = true;  			bool isValidAtNonSyncSafe = true;  			// TODO - if it's the last frame and there is padding' both would indicate false  			// Use the one that returns some padding bytes opposed to bytes with non-zero values (could be frame data)  			// If non sync-safe reads past the end of the tag' then it's sync safe  			// Testing non-sync safe since it will always be bigger than the sync safe integer  			if (currentPosition + frameSize + 2 >= readUntil) {  				isID3v24SyncSafe = true;  				break;  			}  			// Test non-sync safe  			stream.Seek (currentPosition + frameSize + 2' SeekOrigin.Begin);  			frameIDBytes = stream.Read (frameIDSize);  			if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  				isValidAtNonSyncSafe = false;  			}  			// Test sync-safe  			stream.Seek (currentPosition + syncSafeFrameSize + 2' SeekOrigin.Begin);  			frameIDBytes = stream.Read (frameIDSize);  			if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  				isValidAtSyncSafe = false;  			}  			// if they're equal' we'll just have to go with syncsafe' since that's the spec  			if (isValidAtNonSyncSafe != isValidAtSyncSafe) {  				isID3v24SyncSafe = isValidAtSyncSafe;  			}  			break;  		}  	}  	stream.Seek (frameSize + 2' SeekOrigin.Current);  	bytesRead += frameSize + 10;  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2Tag.cs,Read,The following statement contains a magic number: while (bytesRead < readUntil) {  	byte[] frameIDBytes = stream.Read (frameIDSize);  	// TODO: Noticed some tags contain 0x00 'E' 'N' as a FrameID.  Frame is well structured  	// and other frames follow.  I believe the below (keep reading+looking) will cover this issue.  	// If character is not a letter or number' padding reached' audio began'  	// or otherwise the frame is not readable  	if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  		// TODO: Try to keep reading and look for a valid frame  		if (frameIDBytes [0] != 0 && frameIDBytes [0] != 0xFF) {  			/*String msg = String.Format("Out of range FrameID - 0x{0:X}|0x{1:X}|0x{2:X}|0x{3:X}"'                                                        tmpFrameIDBytes[0]' tmpFrameIDBytes[1]' tmpFrameIDBytes[2]'                                                        tmpFrameIDBytes[3]);                             Trace.WriteLine(msg);*/}  		break;  	}  	int frameSize = stream.ReadInt32 ();  	if (frameSize > 0xFF) {  		if ((frameSize & 0x80) == 0x80) {  			isID3v24SyncSafe = false;  			break;  		}  		if ((frameSize & 0x8000) == 0x8000) {  			isID3v24SyncSafe = false;  			break;  		}  		if ((frameSize & 0x800000) == 0x800000) {  			isID3v24SyncSafe = false;  			break;  		}  		if (bytesRead + frameSize + 10 == _id3v2Header.TagSize) {  			// Could give a false positive' but relatively unlikely (famous last words' huh?)  			isID3v24SyncSafe = false;  			break;  		} else {  			stream.Seek (-4' SeekOrigin.Current);  			// go back to read sync-safe version  			int syncSafeFrameSize = ID3v2Utils.ReadInt32SyncSafe (stream);  			long currentPosition = stream.Position;  			bool isValidAtSyncSafe = true;  			bool isValidAtNonSyncSafe = true;  			// TODO - if it's the last frame and there is padding' both would indicate false  			// Use the one that returns some padding bytes opposed to bytes with non-zero values (could be frame data)  			// If non sync-safe reads past the end of the tag' then it's sync safe  			// Testing non-sync safe since it will always be bigger than the sync safe integer  			if (currentPosition + frameSize + 2 >= readUntil) {  				isID3v24SyncSafe = true;  				break;  			}  			// Test non-sync safe  			stream.Seek (currentPosition + frameSize + 2' SeekOrigin.Begin);  			frameIDBytes = stream.Read (frameIDSize);  			if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  				isValidAtNonSyncSafe = false;  			}  			// Test sync-safe  			stream.Seek (currentPosition + syncSafeFrameSize + 2' SeekOrigin.Begin);  			frameIDBytes = stream.Read (frameIDSize);  			if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  				isValidAtSyncSafe = false;  			}  			// if they're equal' we'll just have to go with syncsafe' since that's the spec  			if (isValidAtNonSyncSafe != isValidAtSyncSafe) {  				isID3v24SyncSafe = isValidAtSyncSafe;  			}  			break;  		}  	}  	stream.Seek (frameSize + 2' SeekOrigin.Current);  	bytesRead += frameSize + 10;  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2Tag.cs,Read,The following statement contains a magic number: while (bytesRead < readUntil) {  	byte[] frameIDBytes = stream.Read (frameIDSize);  	// TODO: Noticed some tags contain 0x00 'E' 'N' as a FrameID.  Frame is well structured  	// and other frames follow.  I believe the below (keep reading+looking) will cover this issue.  	// If character is not a letter or number' padding reached' audio began'  	// or otherwise the frame is not readable  	if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  		// TODO: Try to keep reading and look for a valid frame  		if (frameIDBytes [0] != 0 && frameIDBytes [0] != 0xFF) {  			/*String msg = String.Format("Out of range FrameID - 0x{0:X}|0x{1:X}|0x{2:X}|0x{3:X}"'                                                        tmpFrameIDBytes[0]' tmpFrameIDBytes[1]' tmpFrameIDBytes[2]'                                                        tmpFrameIDBytes[3]);                             Trace.WriteLine(msg);*/}  		break;  	}  	int frameSize = stream.ReadInt32 ();  	if (frameSize > 0xFF) {  		if ((frameSize & 0x80) == 0x80) {  			isID3v24SyncSafe = false;  			break;  		}  		if ((frameSize & 0x8000) == 0x8000) {  			isID3v24SyncSafe = false;  			break;  		}  		if ((frameSize & 0x800000) == 0x800000) {  			isID3v24SyncSafe = false;  			break;  		}  		if (bytesRead + frameSize + 10 == _id3v2Header.TagSize) {  			// Could give a false positive' but relatively unlikely (famous last words' huh?)  			isID3v24SyncSafe = false;  			break;  		} else {  			stream.Seek (-4' SeekOrigin.Current);  			// go back to read sync-safe version  			int syncSafeFrameSize = ID3v2Utils.ReadInt32SyncSafe (stream);  			long currentPosition = stream.Position;  			bool isValidAtSyncSafe = true;  			bool isValidAtNonSyncSafe = true;  			// TODO - if it's the last frame and there is padding' both would indicate false  			// Use the one that returns some padding bytes opposed to bytes with non-zero values (could be frame data)  			// If non sync-safe reads past the end of the tag' then it's sync safe  			// Testing non-sync safe since it will always be bigger than the sync safe integer  			if (currentPosition + frameSize + 2 >= readUntil) {  				isID3v24SyncSafe = true;  				break;  			}  			// Test non-sync safe  			stream.Seek (currentPosition + frameSize + 2' SeekOrigin.Begin);  			frameIDBytes = stream.Read (frameIDSize);  			if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  				isValidAtNonSyncSafe = false;  			}  			// Test sync-safe  			stream.Seek (currentPosition + syncSafeFrameSize + 2' SeekOrigin.Begin);  			frameIDBytes = stream.Read (frameIDSize);  			if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  				isValidAtSyncSafe = false;  			}  			// if they're equal' we'll just have to go with syncsafe' since that's the spec  			if (isValidAtNonSyncSafe != isValidAtSyncSafe) {  				isID3v24SyncSafe = isValidAtSyncSafe;  			}  			break;  		}  	}  	stream.Seek (frameSize + 2' SeekOrigin.Current);  	bytesRead += frameSize + 10;  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2Tag.cs,Read,The following statement contains a magic number: while (bytesRead < readUntil) {  	byte[] frameIDBytes = stream.Read (frameIDSize);  	// TODO: Noticed some tags contain 0x00 'E' 'N' as a FrameID.  Frame is well structured  	// and other frames follow.  I believe the below (keep reading+looking) will cover this issue.  	// If character is not a letter or number' padding reached' audio began'  	// or otherwise the frame is not readable  	if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  		// TODO: Try to keep reading and look for a valid frame  		if (frameIDBytes [0] != 0 && frameIDBytes [0] != 0xFF) {  			/*String msg = String.Format("Out of range FrameID - 0x{0:X}|0x{1:X}|0x{2:X}|0x{3:X}"'                                                        tmpFrameIDBytes[0]' tmpFrameIDBytes[1]' tmpFrameIDBytes[2]'                                                        tmpFrameIDBytes[3]);                             Trace.WriteLine(msg);*/}  		break;  	}  	int frameSize = stream.ReadInt32 ();  	if (frameSize > 0xFF) {  		if ((frameSize & 0x80) == 0x80) {  			isID3v24SyncSafe = false;  			break;  		}  		if ((frameSize & 0x8000) == 0x8000) {  			isID3v24SyncSafe = false;  			break;  		}  		if ((frameSize & 0x800000) == 0x800000) {  			isID3v24SyncSafe = false;  			break;  		}  		if (bytesRead + frameSize + 10 == _id3v2Header.TagSize) {  			// Could give a false positive' but relatively unlikely (famous last words' huh?)  			isID3v24SyncSafe = false;  			break;  		} else {  			stream.Seek (-4' SeekOrigin.Current);  			// go back to read sync-safe version  			int syncSafeFrameSize = ID3v2Utils.ReadInt32SyncSafe (stream);  			long currentPosition = stream.Position;  			bool isValidAtSyncSafe = true;  			bool isValidAtNonSyncSafe = true;  			// TODO - if it's the last frame and there is padding' both would indicate false  			// Use the one that returns some padding bytes opposed to bytes with non-zero values (could be frame data)  			// If non sync-safe reads past the end of the tag' then it's sync safe  			// Testing non-sync safe since it will always be bigger than the sync safe integer  			if (currentPosition + frameSize + 2 >= readUntil) {  				isID3v24SyncSafe = true;  				break;  			}  			// Test non-sync safe  			stream.Seek (currentPosition + frameSize + 2' SeekOrigin.Begin);  			frameIDBytes = stream.Read (frameIDSize);  			if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  				isValidAtNonSyncSafe = false;  			}  			// Test sync-safe  			stream.Seek (currentPosition + syncSafeFrameSize + 2' SeekOrigin.Begin);  			frameIDBytes = stream.Read (frameIDSize);  			if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  				isValidAtSyncSafe = false;  			}  			// if they're equal' we'll just have to go with syncsafe' since that's the spec  			if (isValidAtNonSyncSafe != isValidAtSyncSafe) {  				isID3v24SyncSafe = isValidAtSyncSafe;  			}  			break;  		}  	}  	stream.Seek (frameSize + 2' SeekOrigin.Current);  	bytesRead += frameSize + 10;  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2Tag.cs,Read,The following statement contains a magic number: while (bytesRead < readUntil) {  	byte[] frameIDBytes = stream.Read (frameIDSize);  	// TODO: Noticed some tags contain 0x00 'E' 'N' as a FrameID.  Frame is well structured  	// and other frames follow.  I believe the below (keep reading+looking) will cover this issue.  	// If character is not a letter or number' padding reached' audio began'  	// or otherwise the frame is not readable  	if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  		// TODO: Try to keep reading and look for a valid frame  		if (frameIDBytes [0] != 0 && frameIDBytes [0] != 0xFF) {  			/*String msg = String.Format("Out of range FrameID - 0x{0:X}|0x{1:X}|0x{2:X}|0x{3:X}"'                                                        tmpFrameIDBytes[0]' tmpFrameIDBytes[1]' tmpFrameIDBytes[2]'                                                        tmpFrameIDBytes[3]);                             Trace.WriteLine(msg);*/}  		break;  	}  	int frameSize = stream.ReadInt32 ();  	if (frameSize > 0xFF) {  		if ((frameSize & 0x80) == 0x80) {  			isID3v24SyncSafe = false;  			break;  		}  		if ((frameSize & 0x8000) == 0x8000) {  			isID3v24SyncSafe = false;  			break;  		}  		if ((frameSize & 0x800000) == 0x800000) {  			isID3v24SyncSafe = false;  			break;  		}  		if (bytesRead + frameSize + 10 == _id3v2Header.TagSize) {  			// Could give a false positive' but relatively unlikely (famous last words' huh?)  			isID3v24SyncSafe = false;  			break;  		} else {  			stream.Seek (-4' SeekOrigin.Current);  			// go back to read sync-safe version  			int syncSafeFrameSize = ID3v2Utils.ReadInt32SyncSafe (stream);  			long currentPosition = stream.Position;  			bool isValidAtSyncSafe = true;  			bool isValidAtNonSyncSafe = true;  			// TODO - if it's the last frame and there is padding' both would indicate false  			// Use the one that returns some padding bytes opposed to bytes with non-zero values (could be frame data)  			// If non sync-safe reads past the end of the tag' then it's sync safe  			// Testing non-sync safe since it will always be bigger than the sync safe integer  			if (currentPosition + frameSize + 2 >= readUntil) {  				isID3v24SyncSafe = true;  				break;  			}  			// Test non-sync safe  			stream.Seek (currentPosition + frameSize + 2' SeekOrigin.Begin);  			frameIDBytes = stream.Read (frameIDSize);  			if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  				isValidAtNonSyncSafe = false;  			}  			// Test sync-safe  			stream.Seek (currentPosition + syncSafeFrameSize + 2' SeekOrigin.Begin);  			frameIDBytes = stream.Read (frameIDSize);  			if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  				isValidAtSyncSafe = false;  			}  			// if they're equal' we'll just have to go with syncsafe' since that's the spec  			if (isValidAtNonSyncSafe != isValidAtSyncSafe) {  				isID3v24SyncSafe = isValidAtSyncSafe;  			}  			break;  		}  	}  	stream.Seek (frameSize + 2' SeekOrigin.Current);  	bytesRead += frameSize + 10;  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2Tag.cs,Read,The following statement contains a magic number: while (bytesRead < readUntil) {  	byte[] frameIDBytes = stream.Read (frameIDSize);  	// TODO: Noticed some tags contain 0x00 'E' 'N' as a FrameID.  Frame is well structured  	// and other frames follow.  I believe the below (keep reading+looking) will cover this issue.  	// If character is not a letter or number' padding reached' audio began'  	// or otherwise the frame is not readable  	if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  		// TODO: Try to keep reading and look for a valid frame  		if (frameIDBytes [0] != 0 && frameIDBytes [0] != 0xFF) {  			/*String msg = String.Format("Out of range FrameID - 0x{0:X}|0x{1:X}|0x{2:X}|0x{3:X}"'                                                        tmpFrameIDBytes[0]' tmpFrameIDBytes[1]' tmpFrameIDBytes[2]'                                                        tmpFrameIDBytes[3]);                             Trace.WriteLine(msg);*/}  		break;  	}  	int frameSize = stream.ReadInt32 ();  	if (frameSize > 0xFF) {  		if ((frameSize & 0x80) == 0x80) {  			isID3v24SyncSafe = false;  			break;  		}  		if ((frameSize & 0x8000) == 0x8000) {  			isID3v24SyncSafe = false;  			break;  		}  		if ((frameSize & 0x800000) == 0x800000) {  			isID3v24SyncSafe = false;  			break;  		}  		if (bytesRead + frameSize + 10 == _id3v2Header.TagSize) {  			// Could give a false positive' but relatively unlikely (famous last words' huh?)  			isID3v24SyncSafe = false;  			break;  		} else {  			stream.Seek (-4' SeekOrigin.Current);  			// go back to read sync-safe version  			int syncSafeFrameSize = ID3v2Utils.ReadInt32SyncSafe (stream);  			long currentPosition = stream.Position;  			bool isValidAtSyncSafe = true;  			bool isValidAtNonSyncSafe = true;  			// TODO - if it's the last frame and there is padding' both would indicate false  			// Use the one that returns some padding bytes opposed to bytes with non-zero values (could be frame data)  			// If non sync-safe reads past the end of the tag' then it's sync safe  			// Testing non-sync safe since it will always be bigger than the sync safe integer  			if (currentPosition + frameSize + 2 >= readUntil) {  				isID3v24SyncSafe = true;  				break;  			}  			// Test non-sync safe  			stream.Seek (currentPosition + frameSize + 2' SeekOrigin.Begin);  			frameIDBytes = stream.Read (frameIDSize);  			if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  				isValidAtNonSyncSafe = false;  			}  			// Test sync-safe  			stream.Seek (currentPosition + syncSafeFrameSize + 2' SeekOrigin.Begin);  			frameIDBytes = stream.Read (frameIDSize);  			if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  				isValidAtSyncSafe = false;  			}  			// if they're equal' we'll just have to go with syncsafe' since that's the spec  			if (isValidAtNonSyncSafe != isValidAtSyncSafe) {  				isID3v24SyncSafe = isValidAtSyncSafe;  			}  			break;  		}  	}  	stream.Seek (frameSize + 2' SeekOrigin.Current);  	bytesRead += frameSize + 10;  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2Tag.cs,Read,The following statement contains a magic number: while (bytesRead < readUntil) {  	byte[] frameIDBytes = stream.Read (frameIDSize);  	// TODO: Noticed some tags contain 0x00 'E' 'N' as a FrameID.  Frame is well structured  	// and other frames follow.  I believe the below (keep reading+looking) will cover this issue.  	// If character is not a letter or number' padding reached' audio began'  	// or otherwise the frame is not readable  	if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  		// TODO: Try to keep reading and look for a valid frame  		if (frameIDBytes [0] != 0 && frameIDBytes [0] != 0xFF) {  			/*String msg = String.Format("Out of range FrameID - 0x{0:X}|0x{1:X}|0x{2:X}|0x{3:X}"'                                                        tmpFrameIDBytes[0]' tmpFrameIDBytes[1]' tmpFrameIDBytes[2]'                                                        tmpFrameIDBytes[3]);                             Trace.WriteLine(msg);*/}  		break;  	}  	int frameSize = stream.ReadInt32 ();  	if (frameSize > 0xFF) {  		if ((frameSize & 0x80) == 0x80) {  			isID3v24SyncSafe = false;  			break;  		}  		if ((frameSize & 0x8000) == 0x8000) {  			isID3v24SyncSafe = false;  			break;  		}  		if ((frameSize & 0x800000) == 0x800000) {  			isID3v24SyncSafe = false;  			break;  		}  		if (bytesRead + frameSize + 10 == _id3v2Header.TagSize) {  			// Could give a false positive' but relatively unlikely (famous last words' huh?)  			isID3v24SyncSafe = false;  			break;  		} else {  			stream.Seek (-4' SeekOrigin.Current);  			// go back to read sync-safe version  			int syncSafeFrameSize = ID3v2Utils.ReadInt32SyncSafe (stream);  			long currentPosition = stream.Position;  			bool isValidAtSyncSafe = true;  			bool isValidAtNonSyncSafe = true;  			// TODO - if it's the last frame and there is padding' both would indicate false  			// Use the one that returns some padding bytes opposed to bytes with non-zero values (could be frame data)  			// If non sync-safe reads past the end of the tag' then it's sync safe  			// Testing non-sync safe since it will always be bigger than the sync safe integer  			if (currentPosition + frameSize + 2 >= readUntil) {  				isID3v24SyncSafe = true;  				break;  			}  			// Test non-sync safe  			stream.Seek (currentPosition + frameSize + 2' SeekOrigin.Begin);  			frameIDBytes = stream.Read (frameIDSize);  			if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  				isValidAtNonSyncSafe = false;  			}  			// Test sync-safe  			stream.Seek (currentPosition + syncSafeFrameSize + 2' SeekOrigin.Begin);  			frameIDBytes = stream.Read (frameIDSize);  			if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  				isValidAtSyncSafe = false;  			}  			// if they're equal' we'll just have to go with syncsafe' since that's the spec  			if (isValidAtNonSyncSafe != isValidAtSyncSafe) {  				isID3v24SyncSafe = isValidAtSyncSafe;  			}  			break;  		}  	}  	stream.Seek (frameSize + 2' SeekOrigin.Current);  	bytesRead += frameSize + 10;  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2Tag.cs,Read,The following statement contains a magic number: while (bytesRead < readUntil) {  	byte[] frameIDBytes = stream.Read (frameIDSize);  	// TODO: Noticed some tags contain 0x00 'E' 'N' as a FrameID.  Frame is well structured  	// and other frames follow.  I believe the below (keep reading+looking) will cover this issue.  	// If character is not a letter or number' padding reached' audio began'  	// or otherwise the frame is not readable  	if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  		// TODO: Try to keep reading and look for a valid frame  		if (frameIDBytes [0] != 0 && frameIDBytes [0] != 0xFF) {  			/*String msg = String.Format("Out of range FrameID - 0x{0:X}|0x{1:X}|0x{2:X}|0x{3:X}"'                                                        tmpFrameIDBytes[0]' tmpFrameIDBytes[1]' tmpFrameIDBytes[2]'                                                        tmpFrameIDBytes[3]);                             Trace.WriteLine(msg);*/}  		break;  	}  	int frameSize = stream.ReadInt32 ();  	if (frameSize > 0xFF) {  		if ((frameSize & 0x80) == 0x80) {  			isID3v24SyncSafe = false;  			break;  		}  		if ((frameSize & 0x8000) == 0x8000) {  			isID3v24SyncSafe = false;  			break;  		}  		if ((frameSize & 0x800000) == 0x800000) {  			isID3v24SyncSafe = false;  			break;  		}  		if (bytesRead + frameSize + 10 == _id3v2Header.TagSize) {  			// Could give a false positive' but relatively unlikely (famous last words' huh?)  			isID3v24SyncSafe = false;  			break;  		} else {  			stream.Seek (-4' SeekOrigin.Current);  			// go back to read sync-safe version  			int syncSafeFrameSize = ID3v2Utils.ReadInt32SyncSafe (stream);  			long currentPosition = stream.Position;  			bool isValidAtSyncSafe = true;  			bool isValidAtNonSyncSafe = true;  			// TODO - if it's the last frame and there is padding' both would indicate false  			// Use the one that returns some padding bytes opposed to bytes with non-zero values (could be frame data)  			// If non sync-safe reads past the end of the tag' then it's sync safe  			// Testing non-sync safe since it will always be bigger than the sync safe integer  			if (currentPosition + frameSize + 2 >= readUntil) {  				isID3v24SyncSafe = true;  				break;  			}  			// Test non-sync safe  			stream.Seek (currentPosition + frameSize + 2' SeekOrigin.Begin);  			frameIDBytes = stream.Read (frameIDSize);  			if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  				isValidAtNonSyncSafe = false;  			}  			// Test sync-safe  			stream.Seek (currentPosition + syncSafeFrameSize + 2' SeekOrigin.Begin);  			frameIDBytes = stream.Read (frameIDSize);  			if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  				isValidAtSyncSafe = false;  			}  			// if they're equal' we'll just have to go with syncsafe' since that's the spec  			if (isValidAtNonSyncSafe != isValidAtSyncSafe) {  				isID3v24SyncSafe = isValidAtSyncSafe;  			}  			break;  		}  	}  	stream.Seek (frameSize + 2' SeekOrigin.Current);  	bytesRead += frameSize + 10;  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2Tag.cs,Read,The following statement contains a magic number: while (bytesRead < readUntil) {  	byte[] frameIDBytes = stream.Read (frameIDSize);  	// TODO: Noticed some tags contain 0x00 'E' 'N' as a FrameID.  Frame is well structured  	// and other frames follow.  I believe the below (keep reading+looking) will cover this issue.  	// If character is not a letter or number' padding reached' audio began'  	// or otherwise the frame is not readable  	if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  		// TODO: Try to keep reading and look for a valid frame  		if (frameIDBytes [0] != 0 && frameIDBytes [0] != 0xFF) {  			/*String msg = String.Format("Out of range FrameID - 0x{0:X}|0x{1:X}|0x{2:X}|0x{3:X}"'                                                        tmpFrameIDBytes[0]' tmpFrameIDBytes[1]' tmpFrameIDBytes[2]'                                                        tmpFrameIDBytes[3]);                             Trace.WriteLine(msg);*/}  		break;  	}  	int frameSize = stream.ReadInt32 ();  	if (frameSize > 0xFF) {  		if ((frameSize & 0x80) == 0x80) {  			isID3v24SyncSafe = false;  			break;  		}  		if ((frameSize & 0x8000) == 0x8000) {  			isID3v24SyncSafe = false;  			break;  		}  		if ((frameSize & 0x800000) == 0x800000) {  			isID3v24SyncSafe = false;  			break;  		}  		if (bytesRead + frameSize + 10 == _id3v2Header.TagSize) {  			// Could give a false positive' but relatively unlikely (famous last words' huh?)  			isID3v24SyncSafe = false;  			break;  		} else {  			stream.Seek (-4' SeekOrigin.Current);  			// go back to read sync-safe version  			int syncSafeFrameSize = ID3v2Utils.ReadInt32SyncSafe (stream);  			long currentPosition = stream.Position;  			bool isValidAtSyncSafe = true;  			bool isValidAtNonSyncSafe = true;  			// TODO - if it's the last frame and there is padding' both would indicate false  			// Use the one that returns some padding bytes opposed to bytes with non-zero values (could be frame data)  			// If non sync-safe reads past the end of the tag' then it's sync safe  			// Testing non-sync safe since it will always be bigger than the sync safe integer  			if (currentPosition + frameSize + 2 >= readUntil) {  				isID3v24SyncSafe = true;  				break;  			}  			// Test non-sync safe  			stream.Seek (currentPosition + frameSize + 2' SeekOrigin.Begin);  			frameIDBytes = stream.Read (frameIDSize);  			if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  				isValidAtNonSyncSafe = false;  			}  			// Test sync-safe  			stream.Seek (currentPosition + syncSafeFrameSize + 2' SeekOrigin.Begin);  			frameIDBytes = stream.Read (frameIDSize);  			if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  				isValidAtSyncSafe = false;  			}  			// if they're equal' we'll just have to go with syncsafe' since that's the spec  			if (isValidAtNonSyncSafe != isValidAtSyncSafe) {  				isID3v24SyncSafe = isValidAtSyncSafe;  			}  			break;  		}  	}  	stream.Seek (frameSize + 2' SeekOrigin.Current);  	bytesRead += frameSize + 10;  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2Tag.cs,Read,The following statement contains a magic number: while (bytesRead < readUntil) {  	byte[] frameIDBytes = stream.Read (frameIDSize);  	// TODO: Noticed some tags contain 0x00 'E' 'N' as a FrameID.  Frame is well structured  	// and other frames follow.  I believe the below (keep reading+looking) will cover this issue.  	// If character is not a letter or number' padding reached' audio began'  	// or otherwise the frame is not readable  	if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  		// TODO: Try to keep reading and look for a valid frame  		if (frameIDBytes [0] != 0 && frameIDBytes [0] != 0xFF) {  			/*String msg = String.Format("Out of range FrameID - 0x{0:X}|0x{1:X}|0x{2:X}|0x{3:X}"'                                                        tmpFrameIDBytes[0]' tmpFrameIDBytes[1]' tmpFrameIDBytes[2]'                                                        tmpFrameIDBytes[3]);                             Trace.WriteLine(msg);*/}  		break;  	}  	int frameSize = stream.ReadInt32 ();  	if (frameSize > 0xFF) {  		if ((frameSize & 0x80) == 0x80) {  			isID3v24SyncSafe = false;  			break;  		}  		if ((frameSize & 0x8000) == 0x8000) {  			isID3v24SyncSafe = false;  			break;  		}  		if ((frameSize & 0x800000) == 0x800000) {  			isID3v24SyncSafe = false;  			break;  		}  		if (bytesRead + frameSize + 10 == _id3v2Header.TagSize) {  			// Could give a false positive' but relatively unlikely (famous last words' huh?)  			isID3v24SyncSafe = false;  			break;  		} else {  			stream.Seek (-4' SeekOrigin.Current);  			// go back to read sync-safe version  			int syncSafeFrameSize = ID3v2Utils.ReadInt32SyncSafe (stream);  			long currentPosition = stream.Position;  			bool isValidAtSyncSafe = true;  			bool isValidAtNonSyncSafe = true;  			// TODO - if it's the last frame and there is padding' both would indicate false  			// Use the one that returns some padding bytes opposed to bytes with non-zero values (could be frame data)  			// If non sync-safe reads past the end of the tag' then it's sync safe  			// Testing non-sync safe since it will always be bigger than the sync safe integer  			if (currentPosition + frameSize + 2 >= readUntil) {  				isID3v24SyncSafe = true;  				break;  			}  			// Test non-sync safe  			stream.Seek (currentPosition + frameSize + 2' SeekOrigin.Begin);  			frameIDBytes = stream.Read (frameIDSize);  			if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  				isValidAtNonSyncSafe = false;  			}  			// Test sync-safe  			stream.Seek (currentPosition + syncSafeFrameSize + 2' SeekOrigin.Begin);  			frameIDBytes = stream.Read (frameIDSize);  			if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  				isValidAtSyncSafe = false;  			}  			// if they're equal' we'll just have to go with syncsafe' since that's the spec  			if (isValidAtNonSyncSafe != isValidAtSyncSafe) {  				isID3v24SyncSafe = isValidAtSyncSafe;  			}  			break;  		}  	}  	stream.Seek (frameSize + 2' SeekOrigin.Current);  	bytesRead += frameSize + 10;  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2Tag.cs,Read,The following statement contains a magic number: while (bytesRead < readUntil) {  	byte[] frameIDBytes = stream.Read (frameIDSize);  	// TODO: Noticed some tags contain 0x00 'E' 'N' as a FrameID.  Frame is well structured  	// and other frames follow.  I believe the below (keep reading+looking) will cover this issue.  	// If character is not a letter or number' padding reached' audio began'  	// or otherwise the frame is not readable  	if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  		// TODO: Try to keep reading and look for a valid frame  		if (frameIDBytes [0] != 0 && frameIDBytes [0] != 0xFF) {  			/*String msg = String.Format("Out of range FrameID - 0x{0:X}|0x{1:X}|0x{2:X}|0x{3:X}"'                                                        tmpFrameIDBytes[0]' tmpFrameIDBytes[1]' tmpFrameIDBytes[2]'                                                        tmpFrameIDBytes[3]);                             Trace.WriteLine(msg);*/}  		break;  	}  	int frameSize = stream.ReadInt32 ();  	if (frameSize > 0xFF) {  		if ((frameSize & 0x80) == 0x80) {  			isID3v24SyncSafe = false;  			break;  		}  		if ((frameSize & 0x8000) == 0x8000) {  			isID3v24SyncSafe = false;  			break;  		}  		if ((frameSize & 0x800000) == 0x800000) {  			isID3v24SyncSafe = false;  			break;  		}  		if (bytesRead + frameSize + 10 == _id3v2Header.TagSize) {  			// Could give a false positive' but relatively unlikely (famous last words' huh?)  			isID3v24SyncSafe = false;  			break;  		} else {  			stream.Seek (-4' SeekOrigin.Current);  			// go back to read sync-safe version  			int syncSafeFrameSize = ID3v2Utils.ReadInt32SyncSafe (stream);  			long currentPosition = stream.Position;  			bool isValidAtSyncSafe = true;  			bool isValidAtNonSyncSafe = true;  			// TODO - if it's the last frame and there is padding' both would indicate false  			// Use the one that returns some padding bytes opposed to bytes with non-zero values (could be frame data)  			// If non sync-safe reads past the end of the tag' then it's sync safe  			// Testing non-sync safe since it will always be bigger than the sync safe integer  			if (currentPosition + frameSize + 2 >= readUntil) {  				isID3v24SyncSafe = true;  				break;  			}  			// Test non-sync safe  			stream.Seek (currentPosition + frameSize + 2' SeekOrigin.Begin);  			frameIDBytes = stream.Read (frameIDSize);  			if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  				isValidAtNonSyncSafe = false;  			}  			// Test sync-safe  			stream.Seek (currentPosition + syncSafeFrameSize + 2' SeekOrigin.Begin);  			frameIDBytes = stream.Read (frameIDSize);  			if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  				isValidAtSyncSafe = false;  			}  			// if they're equal' we'll just have to go with syncsafe' since that's the spec  			if (isValidAtNonSyncSafe != isValidAtSyncSafe) {  				isID3v24SyncSafe = isValidAtSyncSafe;  			}  			break;  		}  	}  	stream.Seek (frameSize + 2' SeekOrigin.Current);  	bytesRead += frameSize + 10;  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2Tag.cs,Read,The following statement contains a magic number: while (bytesRead < readUntil) {  	byte[] frameIDBytes = stream.Read (frameIDSize);  	// TODO: Noticed some tags contain 0x00 'E' 'N' as a FrameID.  Frame is well structured  	// and other frames follow.  I believe the below (keep reading+looking) will cover this issue.  	// If character is not a letter or number' padding reached' audio began'  	// or otherwise the frame is not readable  	if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  		// TODO: Try to keep reading and look for a valid frame  		if (frameIDBytes [0] != 0 && frameIDBytes [0] != 0xFF) {  			/*String msg = String.Format("Out of range FrameID - 0x{0:X}|0x{1:X}|0x{2:X}|0x{3:X}"'                                                        tmpFrameIDBytes[0]' tmpFrameIDBytes[1]' tmpFrameIDBytes[2]'                                                        tmpFrameIDBytes[3]);                             Trace.WriteLine(msg);*/}  		break;  	}  	int frameSize = stream.ReadInt32 ();  	if (frameSize > 0xFF) {  		if ((frameSize & 0x80) == 0x80) {  			isID3v24SyncSafe = false;  			break;  		}  		if ((frameSize & 0x8000) == 0x8000) {  			isID3v24SyncSafe = false;  			break;  		}  		if ((frameSize & 0x800000) == 0x800000) {  			isID3v24SyncSafe = false;  			break;  		}  		if (bytesRead + frameSize + 10 == _id3v2Header.TagSize) {  			// Could give a false positive' but relatively unlikely (famous last words' huh?)  			isID3v24SyncSafe = false;  			break;  		} else {  			stream.Seek (-4' SeekOrigin.Current);  			// go back to read sync-safe version  			int syncSafeFrameSize = ID3v2Utils.ReadInt32SyncSafe (stream);  			long currentPosition = stream.Position;  			bool isValidAtSyncSafe = true;  			bool isValidAtNonSyncSafe = true;  			// TODO - if it's the last frame and there is padding' both would indicate false  			// Use the one that returns some padding bytes opposed to bytes with non-zero values (could be frame data)  			// If non sync-safe reads past the end of the tag' then it's sync safe  			// Testing non-sync safe since it will always be bigger than the sync safe integer  			if (currentPosition + frameSize + 2 >= readUntil) {  				isID3v24SyncSafe = true;  				break;  			}  			// Test non-sync safe  			stream.Seek (currentPosition + frameSize + 2' SeekOrigin.Begin);  			frameIDBytes = stream.Read (frameIDSize);  			if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  				isValidAtNonSyncSafe = false;  			}  			// Test sync-safe  			stream.Seek (currentPosition + syncSafeFrameSize + 2' SeekOrigin.Begin);  			frameIDBytes = stream.Read (frameIDSize);  			if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  				isValidAtSyncSafe = false;  			}  			// if they're equal' we'll just have to go with syncsafe' since that's the spec  			if (isValidAtNonSyncSafe != isValidAtSyncSafe) {  				isID3v24SyncSafe = isValidAtSyncSafe;  			}  			break;  		}  	}  	stream.Seek (frameSize + 2' SeekOrigin.Current);  	bytesRead += frameSize + 10;  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2Tag.cs,Read,The following statement contains a magic number: while (bytesRead < readUntil) {  	byte[] frameIDBytes = stream.Read (frameIDSize);  	// TODO: Noticed some tags contain 0x00 'E' 'N' as a FrameID.  Frame is well structured  	// and other frames follow.  I believe the below (keep reading+looking) will cover this issue.  	// If character is not a letter or number' padding reached' audio began'  	// or otherwise the frame is not readable  	if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  		// TODO: Try to keep reading and look for a valid frame  		if (frameIDBytes [0] != 0 && frameIDBytes [0] != 0xFF) {  			/*String msg = String.Format("Out of range FrameID - 0x{0:X}|0x{1:X}|0x{2:X}|0x{3:X}"'                                                        tmpFrameIDBytes[0]' tmpFrameIDBytes[1]' tmpFrameIDBytes[2]'                                                        tmpFrameIDBytes[3]);                             Trace.WriteLine(msg);*/}  		break;  	}  	int frameSize = stream.ReadInt32 ();  	if (frameSize > 0xFF) {  		if ((frameSize & 0x80) == 0x80) {  			isID3v24SyncSafe = false;  			break;  		}  		if ((frameSize & 0x8000) == 0x8000) {  			isID3v24SyncSafe = false;  			break;  		}  		if ((frameSize & 0x800000) == 0x800000) {  			isID3v24SyncSafe = false;  			break;  		}  		if (bytesRead + frameSize + 10 == _id3v2Header.TagSize) {  			// Could give a false positive' but relatively unlikely (famous last words' huh?)  			isID3v24SyncSafe = false;  			break;  		} else {  			stream.Seek (-4' SeekOrigin.Current);  			// go back to read sync-safe version  			int syncSafeFrameSize = ID3v2Utils.ReadInt32SyncSafe (stream);  			long currentPosition = stream.Position;  			bool isValidAtSyncSafe = true;  			bool isValidAtNonSyncSafe = true;  			// TODO - if it's the last frame and there is padding' both would indicate false  			// Use the one that returns some padding bytes opposed to bytes with non-zero values (could be frame data)  			// If non sync-safe reads past the end of the tag' then it's sync safe  			// Testing non-sync safe since it will always be bigger than the sync safe integer  			if (currentPosition + frameSize + 2 >= readUntil) {  				isID3v24SyncSafe = true;  				break;  			}  			// Test non-sync safe  			stream.Seek (currentPosition + frameSize + 2' SeekOrigin.Begin);  			frameIDBytes = stream.Read (frameIDSize);  			if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  				isValidAtNonSyncSafe = false;  			}  			// Test sync-safe  			stream.Seek (currentPosition + syncSafeFrameSize + 2' SeekOrigin.Begin);  			frameIDBytes = stream.Read (frameIDSize);  			if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  				isValidAtSyncSafe = false;  			}  			// if they're equal' we'll just have to go with syncsafe' since that's the spec  			if (isValidAtNonSyncSafe != isValidAtSyncSafe) {  				isID3v24SyncSafe = isValidAtSyncSafe;  			}  			break;  		}  	}  	stream.Seek (frameSize + 2' SeekOrigin.Current);  	bytesRead += frameSize + 10;  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2Tag.cs,Read,The following statement contains a magic number: while (bytesRead < readUntil) {  	byte[] frameIDBytes = stream.Read (frameIDSize);  	// TODO: Noticed some tags contain 0x00 'E' 'N' as a FrameID.  Frame is well structured  	// and other frames follow.  I believe the below (keep reading+looking) will cover this issue.  	// If character is not a letter or number' padding reached' audio began'  	// or otherwise the frame is not readable  	if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  		// TODO: Try to keep reading and look for a valid frame  		if (frameIDBytes [0] != 0 && frameIDBytes [0] != 0xFF) {  			/*String msg = String.Format("Out of range FrameID - 0x{0:X}|0x{1:X}|0x{2:X}|0x{3:X}"'                                                        tmpFrameIDBytes[0]' tmpFrameIDBytes[1]' tmpFrameIDBytes[2]'                                                        tmpFrameIDBytes[3]);                             Trace.WriteLine(msg);*/}  		break;  	}  	int frameSize = stream.ReadInt32 ();  	if (frameSize > 0xFF) {  		if ((frameSize & 0x80) == 0x80) {  			isID3v24SyncSafe = false;  			break;  		}  		if ((frameSize & 0x8000) == 0x8000) {  			isID3v24SyncSafe = false;  			break;  		}  		if ((frameSize & 0x800000) == 0x800000) {  			isID3v24SyncSafe = false;  			break;  		}  		if (bytesRead + frameSize + 10 == _id3v2Header.TagSize) {  			// Could give a false positive' but relatively unlikely (famous last words' huh?)  			isID3v24SyncSafe = false;  			break;  		} else {  			stream.Seek (-4' SeekOrigin.Current);  			// go back to read sync-safe version  			int syncSafeFrameSize = ID3v2Utils.ReadInt32SyncSafe (stream);  			long currentPosition = stream.Position;  			bool isValidAtSyncSafe = true;  			bool isValidAtNonSyncSafe = true;  			// TODO - if it's the last frame and there is padding' both would indicate false  			// Use the one that returns some padding bytes opposed to bytes with non-zero values (could be frame data)  			// If non sync-safe reads past the end of the tag' then it's sync safe  			// Testing non-sync safe since it will always be bigger than the sync safe integer  			if (currentPosition + frameSize + 2 >= readUntil) {  				isID3v24SyncSafe = true;  				break;  			}  			// Test non-sync safe  			stream.Seek (currentPosition + frameSize + 2' SeekOrigin.Begin);  			frameIDBytes = stream.Read (frameIDSize);  			if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  				isValidAtNonSyncSafe = false;  			}  			// Test sync-safe  			stream.Seek (currentPosition + syncSafeFrameSize + 2' SeekOrigin.Begin);  			frameIDBytes = stream.Read (frameIDSize);  			if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  				isValidAtSyncSafe = false;  			}  			// if they're equal' we'll just have to go with syncsafe' since that's the spec  			if (isValidAtNonSyncSafe != isValidAtSyncSafe) {  				isID3v24SyncSafe = isValidAtSyncSafe;  			}  			break;  		}  	}  	stream.Seek (frameSize + 2' SeekOrigin.Current);  	bytesRead += frameSize + 10;  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2Tag.cs,Read,The following statement contains a magic number: while (bytesRead < readUntil) {  	byte[] frameIDBytes = stream.Read (frameIDSize);  	// TODO: Noticed some tags contain 0x00 'E' 'N' as a FrameID.  Frame is well structured  	// and other frames follow.  I believe the below (keep reading+looking) will cover this issue.  	// If character is not a letter or number' padding reached' audio began'  	// or otherwise the frame is not readable  	if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  		// TODO: Try to keep reading and look for a valid frame  		if (frameIDBytes [0] != 0 && frameIDBytes [0] != 0xFF) {  			/*String msg = String.Format("Out of range FrameID - 0x{0:X}|0x{1:X}|0x{2:X}|0x{3:X}"'                                                        tmpFrameIDBytes[0]' tmpFrameIDBytes[1]' tmpFrameIDBytes[2]'                                                        tmpFrameIDBytes[3]);                             Trace.WriteLine(msg);*/}  		break;  	}  	int frameSize = stream.ReadInt32 ();  	if (frameSize > 0xFF) {  		if ((frameSize & 0x80) == 0x80) {  			isID3v24SyncSafe = false;  			break;  		}  		if ((frameSize & 0x8000) == 0x8000) {  			isID3v24SyncSafe = false;  			break;  		}  		if ((frameSize & 0x800000) == 0x800000) {  			isID3v24SyncSafe = false;  			break;  		}  		if (bytesRead + frameSize + 10 == _id3v2Header.TagSize) {  			// Could give a false positive' but relatively unlikely (famous last words' huh?)  			isID3v24SyncSafe = false;  			break;  		} else {  			stream.Seek (-4' SeekOrigin.Current);  			// go back to read sync-safe version  			int syncSafeFrameSize = ID3v2Utils.ReadInt32SyncSafe (stream);  			long currentPosition = stream.Position;  			bool isValidAtSyncSafe = true;  			bool isValidAtNonSyncSafe = true;  			// TODO - if it's the last frame and there is padding' both would indicate false  			// Use the one that returns some padding bytes opposed to bytes with non-zero values (could be frame data)  			// If non sync-safe reads past the end of the tag' then it's sync safe  			// Testing non-sync safe since it will always be bigger than the sync safe integer  			if (currentPosition + frameSize + 2 >= readUntil) {  				isID3v24SyncSafe = true;  				break;  			}  			// Test non-sync safe  			stream.Seek (currentPosition + frameSize + 2' SeekOrigin.Begin);  			frameIDBytes = stream.Read (frameIDSize);  			if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  				isValidAtNonSyncSafe = false;  			}  			// Test sync-safe  			stream.Seek (currentPosition + syncSafeFrameSize + 2' SeekOrigin.Begin);  			frameIDBytes = stream.Read (frameIDSize);  			if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  				isValidAtSyncSafe = false;  			}  			// if they're equal' we'll just have to go with syncsafe' since that's the spec  			if (isValidAtNonSyncSafe != isValidAtSyncSafe) {  				isID3v24SyncSafe = isValidAtSyncSafe;  			}  			break;  		}  	}  	stream.Seek (frameSize + 2' SeekOrigin.Current);  	bytesRead += frameSize + 10;  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2Tag.cs,Read,The following statement contains a magic number: while (bytesRead < readUntil) {  	byte[] frameIDBytes = stream.Read (frameIDSize);  	// TODO: Noticed some tags contain 0x00 'E' 'N' as a FrameID.  Frame is well structured  	// and other frames follow.  I believe the below (keep reading+looking) will cover this issue.  	// If character is not a letter or number' padding reached' audio began'  	// or otherwise the frame is not readable  	if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  		// TODO: Try to keep reading and look for a valid frame  		if (frameIDBytes [0] != 0 && frameIDBytes [0] != 0xFF) {  			/*String msg = String.Format("Out of range FrameID - 0x{0:X}|0x{1:X}|0x{2:X}|0x{3:X}"'                                                        tmpFrameIDBytes[0]' tmpFrameIDBytes[1]' tmpFrameIDBytes[2]'                                                        tmpFrameIDBytes[3]);                             Trace.WriteLine(msg);*/}  		break;  	}  	int frameSize = stream.ReadInt32 ();  	if (frameSize > 0xFF) {  		if ((frameSize & 0x80) == 0x80) {  			isID3v24SyncSafe = false;  			break;  		}  		if ((frameSize & 0x8000) == 0x8000) {  			isID3v24SyncSafe = false;  			break;  		}  		if ((frameSize & 0x800000) == 0x800000) {  			isID3v24SyncSafe = false;  			break;  		}  		if (bytesRead + frameSize + 10 == _id3v2Header.TagSize) {  			// Could give a false positive' but relatively unlikely (famous last words' huh?)  			isID3v24SyncSafe = false;  			break;  		} else {  			stream.Seek (-4' SeekOrigin.Current);  			// go back to read sync-safe version  			int syncSafeFrameSize = ID3v2Utils.ReadInt32SyncSafe (stream);  			long currentPosition = stream.Position;  			bool isValidAtSyncSafe = true;  			bool isValidAtNonSyncSafe = true;  			// TODO - if it's the last frame and there is padding' both would indicate false  			// Use the one that returns some padding bytes opposed to bytes with non-zero values (could be frame data)  			// If non sync-safe reads past the end of the tag' then it's sync safe  			// Testing non-sync safe since it will always be bigger than the sync safe integer  			if (currentPosition + frameSize + 2 >= readUntil) {  				isID3v24SyncSafe = true;  				break;  			}  			// Test non-sync safe  			stream.Seek (currentPosition + frameSize + 2' SeekOrigin.Begin);  			frameIDBytes = stream.Read (frameIDSize);  			if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  				isValidAtNonSyncSafe = false;  			}  			// Test sync-safe  			stream.Seek (currentPosition + syncSafeFrameSize + 2' SeekOrigin.Begin);  			frameIDBytes = stream.Read (frameIDSize);  			if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  				isValidAtSyncSafe = false;  			}  			// if they're equal' we'll just have to go with syncsafe' since that's the spec  			if (isValidAtNonSyncSafe != isValidAtSyncSafe) {  				isID3v24SyncSafe = isValidAtSyncSafe;  			}  			break;  		}  	}  	stream.Seek (frameSize + 2' SeekOrigin.Current);  	bytesRead += frameSize + 10;  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2Tag.cs,Read,The following statement contains a magic number: while (bytesRead < readUntil) {  	byte[] frameIDBytes = stream.Read (frameIDSize);  	// TODO: Noticed some tags contain 0x00 'E' 'N' as a FrameID.  Frame is well structured  	// and other frames follow.  I believe the below (keep reading+looking) will cover this issue.  	// If character is not a letter or number' padding reached' audio began'  	// or otherwise the frame is not readable  	if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  		// TODO: Try to keep reading and look for a valid frame  		if (frameIDBytes [0] != 0 && frameIDBytes [0] != 0xFF) {  			/*String msg = String.Format("Out of range FrameID - 0x{0:X}|0x{1:X}|0x{2:X}|0x{3:X}"'                                                        tmpFrameIDBytes[0]' tmpFrameIDBytes[1]' tmpFrameIDBytes[2]'                                                        tmpFrameIDBytes[3]);                             Trace.WriteLine(msg);*/}  		break;  	}  	int frameSize = stream.ReadInt32 ();  	if (frameSize > 0xFF) {  		if ((frameSize & 0x80) == 0x80) {  			isID3v24SyncSafe = false;  			break;  		}  		if ((frameSize & 0x8000) == 0x8000) {  			isID3v24SyncSafe = false;  			break;  		}  		if ((frameSize & 0x800000) == 0x800000) {  			isID3v24SyncSafe = false;  			break;  		}  		if (bytesRead + frameSize + 10 == _id3v2Header.TagSize) {  			// Could give a false positive' but relatively unlikely (famous last words' huh?)  			isID3v24SyncSafe = false;  			break;  		} else {  			stream.Seek (-4' SeekOrigin.Current);  			// go back to read sync-safe version  			int syncSafeFrameSize = ID3v2Utils.ReadInt32SyncSafe (stream);  			long currentPosition = stream.Position;  			bool isValidAtSyncSafe = true;  			bool isValidAtNonSyncSafe = true;  			// TODO - if it's the last frame and there is padding' both would indicate false  			// Use the one that returns some padding bytes opposed to bytes with non-zero values (could be frame data)  			// If non sync-safe reads past the end of the tag' then it's sync safe  			// Testing non-sync safe since it will always be bigger than the sync safe integer  			if (currentPosition + frameSize + 2 >= readUntil) {  				isID3v24SyncSafe = true;  				break;  			}  			// Test non-sync safe  			stream.Seek (currentPosition + frameSize + 2' SeekOrigin.Begin);  			frameIDBytes = stream.Read (frameIDSize);  			if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  				isValidAtNonSyncSafe = false;  			}  			// Test sync-safe  			stream.Seek (currentPosition + syncSafeFrameSize + 2' SeekOrigin.Begin);  			frameIDBytes = stream.Read (frameIDSize);  			if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  				isValidAtSyncSafe = false;  			}  			// if they're equal' we'll just have to go with syncsafe' since that's the spec  			if (isValidAtNonSyncSafe != isValidAtSyncSafe) {  				isID3v24SyncSafe = isValidAtSyncSafe;  			}  			break;  		}  	}  	stream.Seek (frameSize + 2' SeekOrigin.Current);  	bytesRead += frameSize + 10;  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2Tag.cs,Read,The following statement contains a magic number: if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  	// TODO: Try to keep reading and look for a valid frame  	if (frameIDBytes [0] != 0 && frameIDBytes [0] != 0xFF) {  		/*String msg = String.Format("Out of range FrameID - 0x{0:X}|0x{1:X}|0x{2:X}|0x{3:X}"'                                                        tmpFrameIDBytes[0]' tmpFrameIDBytes[1]' tmpFrameIDBytes[2]'                                                        tmpFrameIDBytes[3]);                             Trace.WriteLine(msg);*/}  	break;  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2Tag.cs,Read,The following statement contains a magic number: if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  	// TODO: Try to keep reading and look for a valid frame  	if (frameIDBytes [0] != 0 && frameIDBytes [0] != 0xFF) {  		/*String msg = String.Format("Out of range FrameID - 0x{0:X}|0x{1:X}|0x{2:X}|0x{3:X}"'                                                        tmpFrameIDBytes[0]' tmpFrameIDBytes[1]' tmpFrameIDBytes[2]'                                                        tmpFrameIDBytes[3]);                             Trace.WriteLine(msg);*/}  	break;  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2Tag.cs,Read,The following statement contains a magic number: if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  	// TODO: Try to keep reading and look for a valid frame  	if (frameIDBytes [0] != 0 && frameIDBytes [0] != 0xFF) {  		/*String msg = String.Format("Out of range FrameID - 0x{0:X}|0x{1:X}|0x{2:X}|0x{3:X}"'                                                        tmpFrameIDBytes[0]' tmpFrameIDBytes[1]' tmpFrameIDBytes[2]'                                                        tmpFrameIDBytes[3]);                             Trace.WriteLine(msg);*/}  	break;  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2Tag.cs,Read,The following statement contains a magic number: if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  	// TODO: Try to keep reading and look for a valid frame  	if (frameIDBytes [0] != 0 && frameIDBytes [0] != 0xFF) {  		/*String msg = String.Format("Out of range FrameID - 0x{0:X}|0x{1:X}|0x{2:X}|0x{3:X}"'                                                        tmpFrameIDBytes[0]' tmpFrameIDBytes[1]' tmpFrameIDBytes[2]'                                                        tmpFrameIDBytes[3]);                             Trace.WriteLine(msg);*/}  	break;  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2Tag.cs,Read,The following statement contains a magic number: if (frameSize > 0xFF) {  	if ((frameSize & 0x80) == 0x80) {  		isID3v24SyncSafe = false;  		break;  	}  	if ((frameSize & 0x8000) == 0x8000) {  		isID3v24SyncSafe = false;  		break;  	}  	if ((frameSize & 0x800000) == 0x800000) {  		isID3v24SyncSafe = false;  		break;  	}  	if (bytesRead + frameSize + 10 == _id3v2Header.TagSize) {  		// Could give a false positive' but relatively unlikely (famous last words' huh?)  		isID3v24SyncSafe = false;  		break;  	} else {  		stream.Seek (-4' SeekOrigin.Current);  		// go back to read sync-safe version  		int syncSafeFrameSize = ID3v2Utils.ReadInt32SyncSafe (stream);  		long currentPosition = stream.Position;  		bool isValidAtSyncSafe = true;  		bool isValidAtNonSyncSafe = true;  		// TODO - if it's the last frame and there is padding' both would indicate false  		// Use the one that returns some padding bytes opposed to bytes with non-zero values (could be frame data)  		// If non sync-safe reads past the end of the tag' then it's sync safe  		// Testing non-sync safe since it will always be bigger than the sync safe integer  		if (currentPosition + frameSize + 2 >= readUntil) {  			isID3v24SyncSafe = true;  			break;  		}  		// Test non-sync safe  		stream.Seek (currentPosition + frameSize + 2' SeekOrigin.Begin);  		frameIDBytes = stream.Read (frameIDSize);  		if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  			isValidAtNonSyncSafe = false;  		}  		// Test sync-safe  		stream.Seek (currentPosition + syncSafeFrameSize + 2' SeekOrigin.Begin);  		frameIDBytes = stream.Read (frameIDSize);  		if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  			isValidAtSyncSafe = false;  		}  		// if they're equal' we'll just have to go with syncsafe' since that's the spec  		if (isValidAtNonSyncSafe != isValidAtSyncSafe) {  			isID3v24SyncSafe = isValidAtSyncSafe;  		}  		break;  	}  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2Tag.cs,Read,The following statement contains a magic number: if (frameSize > 0xFF) {  	if ((frameSize & 0x80) == 0x80) {  		isID3v24SyncSafe = false;  		break;  	}  	if ((frameSize & 0x8000) == 0x8000) {  		isID3v24SyncSafe = false;  		break;  	}  	if ((frameSize & 0x800000) == 0x800000) {  		isID3v24SyncSafe = false;  		break;  	}  	if (bytesRead + frameSize + 10 == _id3v2Header.TagSize) {  		// Could give a false positive' but relatively unlikely (famous last words' huh?)  		isID3v24SyncSafe = false;  		break;  	} else {  		stream.Seek (-4' SeekOrigin.Current);  		// go back to read sync-safe version  		int syncSafeFrameSize = ID3v2Utils.ReadInt32SyncSafe (stream);  		long currentPosition = stream.Position;  		bool isValidAtSyncSafe = true;  		bool isValidAtNonSyncSafe = true;  		// TODO - if it's the last frame and there is padding' both would indicate false  		// Use the one that returns some padding bytes opposed to bytes with non-zero values (could be frame data)  		// If non sync-safe reads past the end of the tag' then it's sync safe  		// Testing non-sync safe since it will always be bigger than the sync safe integer  		if (currentPosition + frameSize + 2 >= readUntil) {  			isID3v24SyncSafe = true;  			break;  		}  		// Test non-sync safe  		stream.Seek (currentPosition + frameSize + 2' SeekOrigin.Begin);  		frameIDBytes = stream.Read (frameIDSize);  		if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  			isValidAtNonSyncSafe = false;  		}  		// Test sync-safe  		stream.Seek (currentPosition + syncSafeFrameSize + 2' SeekOrigin.Begin);  		frameIDBytes = stream.Read (frameIDSize);  		if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  			isValidAtSyncSafe = false;  		}  		// if they're equal' we'll just have to go with syncsafe' since that's the spec  		if (isValidAtNonSyncSafe != isValidAtSyncSafe) {  			isID3v24SyncSafe = isValidAtSyncSafe;  		}  		break;  	}  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2Tag.cs,Read,The following statement contains a magic number: if (frameSize > 0xFF) {  	if ((frameSize & 0x80) == 0x80) {  		isID3v24SyncSafe = false;  		break;  	}  	if ((frameSize & 0x8000) == 0x8000) {  		isID3v24SyncSafe = false;  		break;  	}  	if ((frameSize & 0x800000) == 0x800000) {  		isID3v24SyncSafe = false;  		break;  	}  	if (bytesRead + frameSize + 10 == _id3v2Header.TagSize) {  		// Could give a false positive' but relatively unlikely (famous last words' huh?)  		isID3v24SyncSafe = false;  		break;  	} else {  		stream.Seek (-4' SeekOrigin.Current);  		// go back to read sync-safe version  		int syncSafeFrameSize = ID3v2Utils.ReadInt32SyncSafe (stream);  		long currentPosition = stream.Position;  		bool isValidAtSyncSafe = true;  		bool isValidAtNonSyncSafe = true;  		// TODO - if it's the last frame and there is padding' both would indicate false  		// Use the one that returns some padding bytes opposed to bytes with non-zero values (could be frame data)  		// If non sync-safe reads past the end of the tag' then it's sync safe  		// Testing non-sync safe since it will always be bigger than the sync safe integer  		if (currentPosition + frameSize + 2 >= readUntil) {  			isID3v24SyncSafe = true;  			break;  		}  		// Test non-sync safe  		stream.Seek (currentPosition + frameSize + 2' SeekOrigin.Begin);  		frameIDBytes = stream.Read (frameIDSize);  		if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  			isValidAtNonSyncSafe = false;  		}  		// Test sync-safe  		stream.Seek (currentPosition + syncSafeFrameSize + 2' SeekOrigin.Begin);  		frameIDBytes = stream.Read (frameIDSize);  		if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  			isValidAtSyncSafe = false;  		}  		// if they're equal' we'll just have to go with syncsafe' since that's the spec  		if (isValidAtNonSyncSafe != isValidAtSyncSafe) {  			isID3v24SyncSafe = isValidAtSyncSafe;  		}  		break;  	}  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2Tag.cs,Read,The following statement contains a magic number: if (frameSize > 0xFF) {  	if ((frameSize & 0x80) == 0x80) {  		isID3v24SyncSafe = false;  		break;  	}  	if ((frameSize & 0x8000) == 0x8000) {  		isID3v24SyncSafe = false;  		break;  	}  	if ((frameSize & 0x800000) == 0x800000) {  		isID3v24SyncSafe = false;  		break;  	}  	if (bytesRead + frameSize + 10 == _id3v2Header.TagSize) {  		// Could give a false positive' but relatively unlikely (famous last words' huh?)  		isID3v24SyncSafe = false;  		break;  	} else {  		stream.Seek (-4' SeekOrigin.Current);  		// go back to read sync-safe version  		int syncSafeFrameSize = ID3v2Utils.ReadInt32SyncSafe (stream);  		long currentPosition = stream.Position;  		bool isValidAtSyncSafe = true;  		bool isValidAtNonSyncSafe = true;  		// TODO - if it's the last frame and there is padding' both would indicate false  		// Use the one that returns some padding bytes opposed to bytes with non-zero values (could be frame data)  		// If non sync-safe reads past the end of the tag' then it's sync safe  		// Testing non-sync safe since it will always be bigger than the sync safe integer  		if (currentPosition + frameSize + 2 >= readUntil) {  			isID3v24SyncSafe = true;  			break;  		}  		// Test non-sync safe  		stream.Seek (currentPosition + frameSize + 2' SeekOrigin.Begin);  		frameIDBytes = stream.Read (frameIDSize);  		if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  			isValidAtNonSyncSafe = false;  		}  		// Test sync-safe  		stream.Seek (currentPosition + syncSafeFrameSize + 2' SeekOrigin.Begin);  		frameIDBytes = stream.Read (frameIDSize);  		if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  			isValidAtSyncSafe = false;  		}  		// if they're equal' we'll just have to go with syncsafe' since that's the spec  		if (isValidAtNonSyncSafe != isValidAtSyncSafe) {  			isID3v24SyncSafe = isValidAtSyncSafe;  		}  		break;  	}  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2Tag.cs,Read,The following statement contains a magic number: if (frameSize > 0xFF) {  	if ((frameSize & 0x80) == 0x80) {  		isID3v24SyncSafe = false;  		break;  	}  	if ((frameSize & 0x8000) == 0x8000) {  		isID3v24SyncSafe = false;  		break;  	}  	if ((frameSize & 0x800000) == 0x800000) {  		isID3v24SyncSafe = false;  		break;  	}  	if (bytesRead + frameSize + 10 == _id3v2Header.TagSize) {  		// Could give a false positive' but relatively unlikely (famous last words' huh?)  		isID3v24SyncSafe = false;  		break;  	} else {  		stream.Seek (-4' SeekOrigin.Current);  		// go back to read sync-safe version  		int syncSafeFrameSize = ID3v2Utils.ReadInt32SyncSafe (stream);  		long currentPosition = stream.Position;  		bool isValidAtSyncSafe = true;  		bool isValidAtNonSyncSafe = true;  		// TODO - if it's the last frame and there is padding' both would indicate false  		// Use the one that returns some padding bytes opposed to bytes with non-zero values (could be frame data)  		// If non sync-safe reads past the end of the tag' then it's sync safe  		// Testing non-sync safe since it will always be bigger than the sync safe integer  		if (currentPosition + frameSize + 2 >= readUntil) {  			isID3v24SyncSafe = true;  			break;  		}  		// Test non-sync safe  		stream.Seek (currentPosition + frameSize + 2' SeekOrigin.Begin);  		frameIDBytes = stream.Read (frameIDSize);  		if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  			isValidAtNonSyncSafe = false;  		}  		// Test sync-safe  		stream.Seek (currentPosition + syncSafeFrameSize + 2' SeekOrigin.Begin);  		frameIDBytes = stream.Read (frameIDSize);  		if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  			isValidAtSyncSafe = false;  		}  		// if they're equal' we'll just have to go with syncsafe' since that's the spec  		if (isValidAtNonSyncSafe != isValidAtSyncSafe) {  			isID3v24SyncSafe = isValidAtSyncSafe;  		}  		break;  	}  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2Tag.cs,Read,The following statement contains a magic number: if (frameSize > 0xFF) {  	if ((frameSize & 0x80) == 0x80) {  		isID3v24SyncSafe = false;  		break;  	}  	if ((frameSize & 0x8000) == 0x8000) {  		isID3v24SyncSafe = false;  		break;  	}  	if ((frameSize & 0x800000) == 0x800000) {  		isID3v24SyncSafe = false;  		break;  	}  	if (bytesRead + frameSize + 10 == _id3v2Header.TagSize) {  		// Could give a false positive' but relatively unlikely (famous last words' huh?)  		isID3v24SyncSafe = false;  		break;  	} else {  		stream.Seek (-4' SeekOrigin.Current);  		// go back to read sync-safe version  		int syncSafeFrameSize = ID3v2Utils.ReadInt32SyncSafe (stream);  		long currentPosition = stream.Position;  		bool isValidAtSyncSafe = true;  		bool isValidAtNonSyncSafe = true;  		// TODO - if it's the last frame and there is padding' both would indicate false  		// Use the one that returns some padding bytes opposed to bytes with non-zero values (could be frame data)  		// If non sync-safe reads past the end of the tag' then it's sync safe  		// Testing non-sync safe since it will always be bigger than the sync safe integer  		if (currentPosition + frameSize + 2 >= readUntil) {  			isID3v24SyncSafe = true;  			break;  		}  		// Test non-sync safe  		stream.Seek (currentPosition + frameSize + 2' SeekOrigin.Begin);  		frameIDBytes = stream.Read (frameIDSize);  		if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  			isValidAtNonSyncSafe = false;  		}  		// Test sync-safe  		stream.Seek (currentPosition + syncSafeFrameSize + 2' SeekOrigin.Begin);  		frameIDBytes = stream.Read (frameIDSize);  		if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  			isValidAtSyncSafe = false;  		}  		// if they're equal' we'll just have to go with syncsafe' since that's the spec  		if (isValidAtNonSyncSafe != isValidAtSyncSafe) {  			isID3v24SyncSafe = isValidAtSyncSafe;  		}  		break;  	}  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2Tag.cs,Read,The following statement contains a magic number: if (frameSize > 0xFF) {  	if ((frameSize & 0x80) == 0x80) {  		isID3v24SyncSafe = false;  		break;  	}  	if ((frameSize & 0x8000) == 0x8000) {  		isID3v24SyncSafe = false;  		break;  	}  	if ((frameSize & 0x800000) == 0x800000) {  		isID3v24SyncSafe = false;  		break;  	}  	if (bytesRead + frameSize + 10 == _id3v2Header.TagSize) {  		// Could give a false positive' but relatively unlikely (famous last words' huh?)  		isID3v24SyncSafe = false;  		break;  	} else {  		stream.Seek (-4' SeekOrigin.Current);  		// go back to read sync-safe version  		int syncSafeFrameSize = ID3v2Utils.ReadInt32SyncSafe (stream);  		long currentPosition = stream.Position;  		bool isValidAtSyncSafe = true;  		bool isValidAtNonSyncSafe = true;  		// TODO - if it's the last frame and there is padding' both would indicate false  		// Use the one that returns some padding bytes opposed to bytes with non-zero values (could be frame data)  		// If non sync-safe reads past the end of the tag' then it's sync safe  		// Testing non-sync safe since it will always be bigger than the sync safe integer  		if (currentPosition + frameSize + 2 >= readUntil) {  			isID3v24SyncSafe = true;  			break;  		}  		// Test non-sync safe  		stream.Seek (currentPosition + frameSize + 2' SeekOrigin.Begin);  		frameIDBytes = stream.Read (frameIDSize);  		if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  			isValidAtNonSyncSafe = false;  		}  		// Test sync-safe  		stream.Seek (currentPosition + syncSafeFrameSize + 2' SeekOrigin.Begin);  		frameIDBytes = stream.Read (frameIDSize);  		if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  			isValidAtSyncSafe = false;  		}  		// if they're equal' we'll just have to go with syncsafe' since that's the spec  		if (isValidAtNonSyncSafe != isValidAtSyncSafe) {  			isID3v24SyncSafe = isValidAtSyncSafe;  		}  		break;  	}  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2Tag.cs,Read,The following statement contains a magic number: if (frameSize > 0xFF) {  	if ((frameSize & 0x80) == 0x80) {  		isID3v24SyncSafe = false;  		break;  	}  	if ((frameSize & 0x8000) == 0x8000) {  		isID3v24SyncSafe = false;  		break;  	}  	if ((frameSize & 0x800000) == 0x800000) {  		isID3v24SyncSafe = false;  		break;  	}  	if (bytesRead + frameSize + 10 == _id3v2Header.TagSize) {  		// Could give a false positive' but relatively unlikely (famous last words' huh?)  		isID3v24SyncSafe = false;  		break;  	} else {  		stream.Seek (-4' SeekOrigin.Current);  		// go back to read sync-safe version  		int syncSafeFrameSize = ID3v2Utils.ReadInt32SyncSafe (stream);  		long currentPosition = stream.Position;  		bool isValidAtSyncSafe = true;  		bool isValidAtNonSyncSafe = true;  		// TODO - if it's the last frame and there is padding' both would indicate false  		// Use the one that returns some padding bytes opposed to bytes with non-zero values (could be frame data)  		// If non sync-safe reads past the end of the tag' then it's sync safe  		// Testing non-sync safe since it will always be bigger than the sync safe integer  		if (currentPosition + frameSize + 2 >= readUntil) {  			isID3v24SyncSafe = true;  			break;  		}  		// Test non-sync safe  		stream.Seek (currentPosition + frameSize + 2' SeekOrigin.Begin);  		frameIDBytes = stream.Read (frameIDSize);  		if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  			isValidAtNonSyncSafe = false;  		}  		// Test sync-safe  		stream.Seek (currentPosition + syncSafeFrameSize + 2' SeekOrigin.Begin);  		frameIDBytes = stream.Read (frameIDSize);  		if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  			isValidAtSyncSafe = false;  		}  		// if they're equal' we'll just have to go with syncsafe' since that's the spec  		if (isValidAtNonSyncSafe != isValidAtSyncSafe) {  			isID3v24SyncSafe = isValidAtSyncSafe;  		}  		break;  	}  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2Tag.cs,Read,The following statement contains a magic number: if (frameSize > 0xFF) {  	if ((frameSize & 0x80) == 0x80) {  		isID3v24SyncSafe = false;  		break;  	}  	if ((frameSize & 0x8000) == 0x8000) {  		isID3v24SyncSafe = false;  		break;  	}  	if ((frameSize & 0x800000) == 0x800000) {  		isID3v24SyncSafe = false;  		break;  	}  	if (bytesRead + frameSize + 10 == _id3v2Header.TagSize) {  		// Could give a false positive' but relatively unlikely (famous last words' huh?)  		isID3v24SyncSafe = false;  		break;  	} else {  		stream.Seek (-4' SeekOrigin.Current);  		// go back to read sync-safe version  		int syncSafeFrameSize = ID3v2Utils.ReadInt32SyncSafe (stream);  		long currentPosition = stream.Position;  		bool isValidAtSyncSafe = true;  		bool isValidAtNonSyncSafe = true;  		// TODO - if it's the last frame and there is padding' both would indicate false  		// Use the one that returns some padding bytes opposed to bytes with non-zero values (could be frame data)  		// If non sync-safe reads past the end of the tag' then it's sync safe  		// Testing non-sync safe since it will always be bigger than the sync safe integer  		if (currentPosition + frameSize + 2 >= readUntil) {  			isID3v24SyncSafe = true;  			break;  		}  		// Test non-sync safe  		stream.Seek (currentPosition + frameSize + 2' SeekOrigin.Begin);  		frameIDBytes = stream.Read (frameIDSize);  		if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  			isValidAtNonSyncSafe = false;  		}  		// Test sync-safe  		stream.Seek (currentPosition + syncSafeFrameSize + 2' SeekOrigin.Begin);  		frameIDBytes = stream.Read (frameIDSize);  		if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  			isValidAtSyncSafe = false;  		}  		// if they're equal' we'll just have to go with syncsafe' since that's the spec  		if (isValidAtNonSyncSafe != isValidAtSyncSafe) {  			isID3v24SyncSafe = isValidAtSyncSafe;  		}  		break;  	}  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2Tag.cs,Read,The following statement contains a magic number: if (frameSize > 0xFF) {  	if ((frameSize & 0x80) == 0x80) {  		isID3v24SyncSafe = false;  		break;  	}  	if ((frameSize & 0x8000) == 0x8000) {  		isID3v24SyncSafe = false;  		break;  	}  	if ((frameSize & 0x800000) == 0x800000) {  		isID3v24SyncSafe = false;  		break;  	}  	if (bytesRead + frameSize + 10 == _id3v2Header.TagSize) {  		// Could give a false positive' but relatively unlikely (famous last words' huh?)  		isID3v24SyncSafe = false;  		break;  	} else {  		stream.Seek (-4' SeekOrigin.Current);  		// go back to read sync-safe version  		int syncSafeFrameSize = ID3v2Utils.ReadInt32SyncSafe (stream);  		long currentPosition = stream.Position;  		bool isValidAtSyncSafe = true;  		bool isValidAtNonSyncSafe = true;  		// TODO - if it's the last frame and there is padding' both would indicate false  		// Use the one that returns some padding bytes opposed to bytes with non-zero values (could be frame data)  		// If non sync-safe reads past the end of the tag' then it's sync safe  		// Testing non-sync safe since it will always be bigger than the sync safe integer  		if (currentPosition + frameSize + 2 >= readUntil) {  			isID3v24SyncSafe = true;  			break;  		}  		// Test non-sync safe  		stream.Seek (currentPosition + frameSize + 2' SeekOrigin.Begin);  		frameIDBytes = stream.Read (frameIDSize);  		if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  			isValidAtNonSyncSafe = false;  		}  		// Test sync-safe  		stream.Seek (currentPosition + syncSafeFrameSize + 2' SeekOrigin.Begin);  		frameIDBytes = stream.Read (frameIDSize);  		if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  			isValidAtSyncSafe = false;  		}  		// if they're equal' we'll just have to go with syncsafe' since that's the spec  		if (isValidAtNonSyncSafe != isValidAtSyncSafe) {  			isID3v24SyncSafe = isValidAtSyncSafe;  		}  		break;  	}  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2Tag.cs,Read,The following statement contains a magic number: if (frameSize > 0xFF) {  	if ((frameSize & 0x80) == 0x80) {  		isID3v24SyncSafe = false;  		break;  	}  	if ((frameSize & 0x8000) == 0x8000) {  		isID3v24SyncSafe = false;  		break;  	}  	if ((frameSize & 0x800000) == 0x800000) {  		isID3v24SyncSafe = false;  		break;  	}  	if (bytesRead + frameSize + 10 == _id3v2Header.TagSize) {  		// Could give a false positive' but relatively unlikely (famous last words' huh?)  		isID3v24SyncSafe = false;  		break;  	} else {  		stream.Seek (-4' SeekOrigin.Current);  		// go back to read sync-safe version  		int syncSafeFrameSize = ID3v2Utils.ReadInt32SyncSafe (stream);  		long currentPosition = stream.Position;  		bool isValidAtSyncSafe = true;  		bool isValidAtNonSyncSafe = true;  		// TODO - if it's the last frame and there is padding' both would indicate false  		// Use the one that returns some padding bytes opposed to bytes with non-zero values (could be frame data)  		// If non sync-safe reads past the end of the tag' then it's sync safe  		// Testing non-sync safe since it will always be bigger than the sync safe integer  		if (currentPosition + frameSize + 2 >= readUntil) {  			isID3v24SyncSafe = true;  			break;  		}  		// Test non-sync safe  		stream.Seek (currentPosition + frameSize + 2' SeekOrigin.Begin);  		frameIDBytes = stream.Read (frameIDSize);  		if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  			isValidAtNonSyncSafe = false;  		}  		// Test sync-safe  		stream.Seek (currentPosition + syncSafeFrameSize + 2' SeekOrigin.Begin);  		frameIDBytes = stream.Read (frameIDSize);  		if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  			isValidAtSyncSafe = false;  		}  		// if they're equal' we'll just have to go with syncsafe' since that's the spec  		if (isValidAtNonSyncSafe != isValidAtSyncSafe) {  			isID3v24SyncSafe = isValidAtSyncSafe;  		}  		break;  	}  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2Tag.cs,Read,The following statement contains a magic number: if (frameSize > 0xFF) {  	if ((frameSize & 0x80) == 0x80) {  		isID3v24SyncSafe = false;  		break;  	}  	if ((frameSize & 0x8000) == 0x8000) {  		isID3v24SyncSafe = false;  		break;  	}  	if ((frameSize & 0x800000) == 0x800000) {  		isID3v24SyncSafe = false;  		break;  	}  	if (bytesRead + frameSize + 10 == _id3v2Header.TagSize) {  		// Could give a false positive' but relatively unlikely (famous last words' huh?)  		isID3v24SyncSafe = false;  		break;  	} else {  		stream.Seek (-4' SeekOrigin.Current);  		// go back to read sync-safe version  		int syncSafeFrameSize = ID3v2Utils.ReadInt32SyncSafe (stream);  		long currentPosition = stream.Position;  		bool isValidAtSyncSafe = true;  		bool isValidAtNonSyncSafe = true;  		// TODO - if it's the last frame and there is padding' both would indicate false  		// Use the one that returns some padding bytes opposed to bytes with non-zero values (could be frame data)  		// If non sync-safe reads past the end of the tag' then it's sync safe  		// Testing non-sync safe since it will always be bigger than the sync safe integer  		if (currentPosition + frameSize + 2 >= readUntil) {  			isID3v24SyncSafe = true;  			break;  		}  		// Test non-sync safe  		stream.Seek (currentPosition + frameSize + 2' SeekOrigin.Begin);  		frameIDBytes = stream.Read (frameIDSize);  		if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  			isValidAtNonSyncSafe = false;  		}  		// Test sync-safe  		stream.Seek (currentPosition + syncSafeFrameSize + 2' SeekOrigin.Begin);  		frameIDBytes = stream.Read (frameIDSize);  		if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  			isValidAtSyncSafe = false;  		}  		// if they're equal' we'll just have to go with syncsafe' since that's the spec  		if (isValidAtNonSyncSafe != isValidAtSyncSafe) {  			isID3v24SyncSafe = isValidAtSyncSafe;  		}  		break;  	}  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2Tag.cs,Read,The following statement contains a magic number: if (frameSize > 0xFF) {  	if ((frameSize & 0x80) == 0x80) {  		isID3v24SyncSafe = false;  		break;  	}  	if ((frameSize & 0x8000) == 0x8000) {  		isID3v24SyncSafe = false;  		break;  	}  	if ((frameSize & 0x800000) == 0x800000) {  		isID3v24SyncSafe = false;  		break;  	}  	if (bytesRead + frameSize + 10 == _id3v2Header.TagSize) {  		// Could give a false positive' but relatively unlikely (famous last words' huh?)  		isID3v24SyncSafe = false;  		break;  	} else {  		stream.Seek (-4' SeekOrigin.Current);  		// go back to read sync-safe version  		int syncSafeFrameSize = ID3v2Utils.ReadInt32SyncSafe (stream);  		long currentPosition = stream.Position;  		bool isValidAtSyncSafe = true;  		bool isValidAtNonSyncSafe = true;  		// TODO - if it's the last frame and there is padding' both would indicate false  		// Use the one that returns some padding bytes opposed to bytes with non-zero values (could be frame data)  		// If non sync-safe reads past the end of the tag' then it's sync safe  		// Testing non-sync safe since it will always be bigger than the sync safe integer  		if (currentPosition + frameSize + 2 >= readUntil) {  			isID3v24SyncSafe = true;  			break;  		}  		// Test non-sync safe  		stream.Seek (currentPosition + frameSize + 2' SeekOrigin.Begin);  		frameIDBytes = stream.Read (frameIDSize);  		if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  			isValidAtNonSyncSafe = false;  		}  		// Test sync-safe  		stream.Seek (currentPosition + syncSafeFrameSize + 2' SeekOrigin.Begin);  		frameIDBytes = stream.Read (frameIDSize);  		if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  			isValidAtSyncSafe = false;  		}  		// if they're equal' we'll just have to go with syncsafe' since that's the spec  		if (isValidAtNonSyncSafe != isValidAtSyncSafe) {  			isID3v24SyncSafe = isValidAtSyncSafe;  		}  		break;  	}  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2Tag.cs,Read,The following statement contains a magic number: if (bytesRead + frameSize + 10 == _id3v2Header.TagSize) {  	// Could give a false positive' but relatively unlikely (famous last words' huh?)  	isID3v24SyncSafe = false;  	break;  } else {  	stream.Seek (-4' SeekOrigin.Current);  	// go back to read sync-safe version  	int syncSafeFrameSize = ID3v2Utils.ReadInt32SyncSafe (stream);  	long currentPosition = stream.Position;  	bool isValidAtSyncSafe = true;  	bool isValidAtNonSyncSafe = true;  	// TODO - if it's the last frame and there is padding' both would indicate false  	// Use the one that returns some padding bytes opposed to bytes with non-zero values (could be frame data)  	// If non sync-safe reads past the end of the tag' then it's sync safe  	// Testing non-sync safe since it will always be bigger than the sync safe integer  	if (currentPosition + frameSize + 2 >= readUntil) {  		isID3v24SyncSafe = true;  		break;  	}  	// Test non-sync safe  	stream.Seek (currentPosition + frameSize + 2' SeekOrigin.Begin);  	frameIDBytes = stream.Read (frameIDSize);  	if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  		isValidAtNonSyncSafe = false;  	}  	// Test sync-safe  	stream.Seek (currentPosition + syncSafeFrameSize + 2' SeekOrigin.Begin);  	frameIDBytes = stream.Read (frameIDSize);  	if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  		isValidAtSyncSafe = false;  	}  	// if they're equal' we'll just have to go with syncsafe' since that's the spec  	if (isValidAtNonSyncSafe != isValidAtSyncSafe) {  		isID3v24SyncSafe = isValidAtSyncSafe;  	}  	break;  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2Tag.cs,Read,The following statement contains a magic number: if (bytesRead + frameSize + 10 == _id3v2Header.TagSize) {  	// Could give a false positive' but relatively unlikely (famous last words' huh?)  	isID3v24SyncSafe = false;  	break;  } else {  	stream.Seek (-4' SeekOrigin.Current);  	// go back to read sync-safe version  	int syncSafeFrameSize = ID3v2Utils.ReadInt32SyncSafe (stream);  	long currentPosition = stream.Position;  	bool isValidAtSyncSafe = true;  	bool isValidAtNonSyncSafe = true;  	// TODO - if it's the last frame and there is padding' both would indicate false  	// Use the one that returns some padding bytes opposed to bytes with non-zero values (could be frame data)  	// If non sync-safe reads past the end of the tag' then it's sync safe  	// Testing non-sync safe since it will always be bigger than the sync safe integer  	if (currentPosition + frameSize + 2 >= readUntil) {  		isID3v24SyncSafe = true;  		break;  	}  	// Test non-sync safe  	stream.Seek (currentPosition + frameSize + 2' SeekOrigin.Begin);  	frameIDBytes = stream.Read (frameIDSize);  	if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  		isValidAtNonSyncSafe = false;  	}  	// Test sync-safe  	stream.Seek (currentPosition + syncSafeFrameSize + 2' SeekOrigin.Begin);  	frameIDBytes = stream.Read (frameIDSize);  	if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  		isValidAtSyncSafe = false;  	}  	// if they're equal' we'll just have to go with syncsafe' since that's the spec  	if (isValidAtNonSyncSafe != isValidAtSyncSafe) {  		isID3v24SyncSafe = isValidAtSyncSafe;  	}  	break;  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2Tag.cs,Read,The following statement contains a magic number: if (bytesRead + frameSize + 10 == _id3v2Header.TagSize) {  	// Could give a false positive' but relatively unlikely (famous last words' huh?)  	isID3v24SyncSafe = false;  	break;  } else {  	stream.Seek (-4' SeekOrigin.Current);  	// go back to read sync-safe version  	int syncSafeFrameSize = ID3v2Utils.ReadInt32SyncSafe (stream);  	long currentPosition = stream.Position;  	bool isValidAtSyncSafe = true;  	bool isValidAtNonSyncSafe = true;  	// TODO - if it's the last frame and there is padding' both would indicate false  	// Use the one that returns some padding bytes opposed to bytes with non-zero values (could be frame data)  	// If non sync-safe reads past the end of the tag' then it's sync safe  	// Testing non-sync safe since it will always be bigger than the sync safe integer  	if (currentPosition + frameSize + 2 >= readUntil) {  		isID3v24SyncSafe = true;  		break;  	}  	// Test non-sync safe  	stream.Seek (currentPosition + frameSize + 2' SeekOrigin.Begin);  	frameIDBytes = stream.Read (frameIDSize);  	if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  		isValidAtNonSyncSafe = false;  	}  	// Test sync-safe  	stream.Seek (currentPosition + syncSafeFrameSize + 2' SeekOrigin.Begin);  	frameIDBytes = stream.Read (frameIDSize);  	if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  		isValidAtSyncSafe = false;  	}  	// if they're equal' we'll just have to go with syncsafe' since that's the spec  	if (isValidAtNonSyncSafe != isValidAtSyncSafe) {  		isID3v24SyncSafe = isValidAtSyncSafe;  	}  	break;  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2Tag.cs,Read,The following statement contains a magic number: if (bytesRead + frameSize + 10 == _id3v2Header.TagSize) {  	// Could give a false positive' but relatively unlikely (famous last words' huh?)  	isID3v24SyncSafe = false;  	break;  } else {  	stream.Seek (-4' SeekOrigin.Current);  	// go back to read sync-safe version  	int syncSafeFrameSize = ID3v2Utils.ReadInt32SyncSafe (stream);  	long currentPosition = stream.Position;  	bool isValidAtSyncSafe = true;  	bool isValidAtNonSyncSafe = true;  	// TODO - if it's the last frame and there is padding' both would indicate false  	// Use the one that returns some padding bytes opposed to bytes with non-zero values (could be frame data)  	// If non sync-safe reads past the end of the tag' then it's sync safe  	// Testing non-sync safe since it will always be bigger than the sync safe integer  	if (currentPosition + frameSize + 2 >= readUntil) {  		isID3v24SyncSafe = true;  		break;  	}  	// Test non-sync safe  	stream.Seek (currentPosition + frameSize + 2' SeekOrigin.Begin);  	frameIDBytes = stream.Read (frameIDSize);  	if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  		isValidAtNonSyncSafe = false;  	}  	// Test sync-safe  	stream.Seek (currentPosition + syncSafeFrameSize + 2' SeekOrigin.Begin);  	frameIDBytes = stream.Read (frameIDSize);  	if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  		isValidAtSyncSafe = false;  	}  	// if they're equal' we'll just have to go with syncsafe' since that's the spec  	if (isValidAtNonSyncSafe != isValidAtSyncSafe) {  		isID3v24SyncSafe = isValidAtSyncSafe;  	}  	break;  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2Tag.cs,Read,The following statement contains a magic number: if (bytesRead + frameSize + 10 == _id3v2Header.TagSize) {  	// Could give a false positive' but relatively unlikely (famous last words' huh?)  	isID3v24SyncSafe = false;  	break;  } else {  	stream.Seek (-4' SeekOrigin.Current);  	// go back to read sync-safe version  	int syncSafeFrameSize = ID3v2Utils.ReadInt32SyncSafe (stream);  	long currentPosition = stream.Position;  	bool isValidAtSyncSafe = true;  	bool isValidAtNonSyncSafe = true;  	// TODO - if it's the last frame and there is padding' both would indicate false  	// Use the one that returns some padding bytes opposed to bytes with non-zero values (could be frame data)  	// If non sync-safe reads past the end of the tag' then it's sync safe  	// Testing non-sync safe since it will always be bigger than the sync safe integer  	if (currentPosition + frameSize + 2 >= readUntil) {  		isID3v24SyncSafe = true;  		break;  	}  	// Test non-sync safe  	stream.Seek (currentPosition + frameSize + 2' SeekOrigin.Begin);  	frameIDBytes = stream.Read (frameIDSize);  	if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  		isValidAtNonSyncSafe = false;  	}  	// Test sync-safe  	stream.Seek (currentPosition + syncSafeFrameSize + 2' SeekOrigin.Begin);  	frameIDBytes = stream.Read (frameIDSize);  	if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  		isValidAtSyncSafe = false;  	}  	// if they're equal' we'll just have to go with syncsafe' since that's the spec  	if (isValidAtNonSyncSafe != isValidAtSyncSafe) {  		isID3v24SyncSafe = isValidAtSyncSafe;  	}  	break;  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2Tag.cs,Read,The following statement contains a magic number: if (bytesRead + frameSize + 10 == _id3v2Header.TagSize) {  	// Could give a false positive' but relatively unlikely (famous last words' huh?)  	isID3v24SyncSafe = false;  	break;  } else {  	stream.Seek (-4' SeekOrigin.Current);  	// go back to read sync-safe version  	int syncSafeFrameSize = ID3v2Utils.ReadInt32SyncSafe (stream);  	long currentPosition = stream.Position;  	bool isValidAtSyncSafe = true;  	bool isValidAtNonSyncSafe = true;  	// TODO - if it's the last frame and there is padding' both would indicate false  	// Use the one that returns some padding bytes opposed to bytes with non-zero values (could be frame data)  	// If non sync-safe reads past the end of the tag' then it's sync safe  	// Testing non-sync safe since it will always be bigger than the sync safe integer  	if (currentPosition + frameSize + 2 >= readUntil) {  		isID3v24SyncSafe = true;  		break;  	}  	// Test non-sync safe  	stream.Seek (currentPosition + frameSize + 2' SeekOrigin.Begin);  	frameIDBytes = stream.Read (frameIDSize);  	if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  		isValidAtNonSyncSafe = false;  	}  	// Test sync-safe  	stream.Seek (currentPosition + syncSafeFrameSize + 2' SeekOrigin.Begin);  	frameIDBytes = stream.Read (frameIDSize);  	if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  		isValidAtSyncSafe = false;  	}  	// if they're equal' we'll just have to go with syncsafe' since that's the spec  	if (isValidAtNonSyncSafe != isValidAtSyncSafe) {  		isID3v24SyncSafe = isValidAtSyncSafe;  	}  	break;  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2Tag.cs,Read,The following statement contains a magic number: if (bytesRead + frameSize + 10 == _id3v2Header.TagSize) {  	// Could give a false positive' but relatively unlikely (famous last words' huh?)  	isID3v24SyncSafe = false;  	break;  } else {  	stream.Seek (-4' SeekOrigin.Current);  	// go back to read sync-safe version  	int syncSafeFrameSize = ID3v2Utils.ReadInt32SyncSafe (stream);  	long currentPosition = stream.Position;  	bool isValidAtSyncSafe = true;  	bool isValidAtNonSyncSafe = true;  	// TODO - if it's the last frame and there is padding' both would indicate false  	// Use the one that returns some padding bytes opposed to bytes with non-zero values (could be frame data)  	// If non sync-safe reads past the end of the tag' then it's sync safe  	// Testing non-sync safe since it will always be bigger than the sync safe integer  	if (currentPosition + frameSize + 2 >= readUntil) {  		isID3v24SyncSafe = true;  		break;  	}  	// Test non-sync safe  	stream.Seek (currentPosition + frameSize + 2' SeekOrigin.Begin);  	frameIDBytes = stream.Read (frameIDSize);  	if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  		isValidAtNonSyncSafe = false;  	}  	// Test sync-safe  	stream.Seek (currentPosition + syncSafeFrameSize + 2' SeekOrigin.Begin);  	frameIDBytes = stream.Read (frameIDSize);  	if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  		isValidAtSyncSafe = false;  	}  	// if they're equal' we'll just have to go with syncsafe' since that's the spec  	if (isValidAtNonSyncSafe != isValidAtSyncSafe) {  		isID3v24SyncSafe = isValidAtSyncSafe;  	}  	break;  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2Tag.cs,Read,The following statement contains a magic number: if (bytesRead + frameSize + 10 == _id3v2Header.TagSize) {  	// Could give a false positive' but relatively unlikely (famous last words' huh?)  	isID3v24SyncSafe = false;  	break;  } else {  	stream.Seek (-4' SeekOrigin.Current);  	// go back to read sync-safe version  	int syncSafeFrameSize = ID3v2Utils.ReadInt32SyncSafe (stream);  	long currentPosition = stream.Position;  	bool isValidAtSyncSafe = true;  	bool isValidAtNonSyncSafe = true;  	// TODO - if it's the last frame and there is padding' both would indicate false  	// Use the one that returns some padding bytes opposed to bytes with non-zero values (could be frame data)  	// If non sync-safe reads past the end of the tag' then it's sync safe  	// Testing non-sync safe since it will always be bigger than the sync safe integer  	if (currentPosition + frameSize + 2 >= readUntil) {  		isID3v24SyncSafe = true;  		break;  	}  	// Test non-sync safe  	stream.Seek (currentPosition + frameSize + 2' SeekOrigin.Begin);  	frameIDBytes = stream.Read (frameIDSize);  	if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  		isValidAtNonSyncSafe = false;  	}  	// Test sync-safe  	stream.Seek (currentPosition + syncSafeFrameSize + 2' SeekOrigin.Begin);  	frameIDBytes = stream.Read (frameIDSize);  	if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  		isValidAtSyncSafe = false;  	}  	// if they're equal' we'll just have to go with syncsafe' since that's the spec  	if (isValidAtNonSyncSafe != isValidAtSyncSafe) {  		isID3v24SyncSafe = isValidAtSyncSafe;  	}  	break;  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2Tag.cs,Read,The following statement contains a magic number: if (bytesRead + frameSize + 10 == _id3v2Header.TagSize) {  	// Could give a false positive' but relatively unlikely (famous last words' huh?)  	isID3v24SyncSafe = false;  	break;  } else {  	stream.Seek (-4' SeekOrigin.Current);  	// go back to read sync-safe version  	int syncSafeFrameSize = ID3v2Utils.ReadInt32SyncSafe (stream);  	long currentPosition = stream.Position;  	bool isValidAtSyncSafe = true;  	bool isValidAtNonSyncSafe = true;  	// TODO - if it's the last frame and there is padding' both would indicate false  	// Use the one that returns some padding bytes opposed to bytes with non-zero values (could be frame data)  	// If non sync-safe reads past the end of the tag' then it's sync safe  	// Testing non-sync safe since it will always be bigger than the sync safe integer  	if (currentPosition + frameSize + 2 >= readUntil) {  		isID3v24SyncSafe = true;  		break;  	}  	// Test non-sync safe  	stream.Seek (currentPosition + frameSize + 2' SeekOrigin.Begin);  	frameIDBytes = stream.Read (frameIDSize);  	if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  		isValidAtNonSyncSafe = false;  	}  	// Test sync-safe  	stream.Seek (currentPosition + syncSafeFrameSize + 2' SeekOrigin.Begin);  	frameIDBytes = stream.Read (frameIDSize);  	if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  		isValidAtSyncSafe = false;  	}  	// if they're equal' we'll just have to go with syncsafe' since that's the spec  	if (isValidAtNonSyncSafe != isValidAtSyncSafe) {  		isID3v24SyncSafe = isValidAtSyncSafe;  	}  	break;  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2Tag.cs,Read,The following statement contains a magic number: if (bytesRead + frameSize + 10 == _id3v2Header.TagSize) {  	// Could give a false positive' but relatively unlikely (famous last words' huh?)  	isID3v24SyncSafe = false;  	break;  } else {  	stream.Seek (-4' SeekOrigin.Current);  	// go back to read sync-safe version  	int syncSafeFrameSize = ID3v2Utils.ReadInt32SyncSafe (stream);  	long currentPosition = stream.Position;  	bool isValidAtSyncSafe = true;  	bool isValidAtNonSyncSafe = true;  	// TODO - if it's the last frame and there is padding' both would indicate false  	// Use the one that returns some padding bytes opposed to bytes with non-zero values (could be frame data)  	// If non sync-safe reads past the end of the tag' then it's sync safe  	// Testing non-sync safe since it will always be bigger than the sync safe integer  	if (currentPosition + frameSize + 2 >= readUntil) {  		isID3v24SyncSafe = true;  		break;  	}  	// Test non-sync safe  	stream.Seek (currentPosition + frameSize + 2' SeekOrigin.Begin);  	frameIDBytes = stream.Read (frameIDSize);  	if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  		isValidAtNonSyncSafe = false;  	}  	// Test sync-safe  	stream.Seek (currentPosition + syncSafeFrameSize + 2' SeekOrigin.Begin);  	frameIDBytes = stream.Read (frameIDSize);  	if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  		isValidAtSyncSafe = false;  	}  	// if they're equal' we'll just have to go with syncsafe' since that's the spec  	if (isValidAtNonSyncSafe != isValidAtSyncSafe) {  		isID3v24SyncSafe = isValidAtSyncSafe;  	}  	break;  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2Tag.cs,Read,The following statement contains a magic number: if (bytesRead + frameSize + 10 == _id3v2Header.TagSize) {  	// Could give a false positive' but relatively unlikely (famous last words' huh?)  	isID3v24SyncSafe = false;  	break;  } else {  	stream.Seek (-4' SeekOrigin.Current);  	// go back to read sync-safe version  	int syncSafeFrameSize = ID3v2Utils.ReadInt32SyncSafe (stream);  	long currentPosition = stream.Position;  	bool isValidAtSyncSafe = true;  	bool isValidAtNonSyncSafe = true;  	// TODO - if it's the last frame and there is padding' both would indicate false  	// Use the one that returns some padding bytes opposed to bytes with non-zero values (could be frame data)  	// If non sync-safe reads past the end of the tag' then it's sync safe  	// Testing non-sync safe since it will always be bigger than the sync safe integer  	if (currentPosition + frameSize + 2 >= readUntil) {  		isID3v24SyncSafe = true;  		break;  	}  	// Test non-sync safe  	stream.Seek (currentPosition + frameSize + 2' SeekOrigin.Begin);  	frameIDBytes = stream.Read (frameIDSize);  	if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  		isValidAtNonSyncSafe = false;  	}  	// Test sync-safe  	stream.Seek (currentPosition + syncSafeFrameSize + 2' SeekOrigin.Begin);  	frameIDBytes = stream.Read (frameIDSize);  	if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  		isValidAtSyncSafe = false;  	}  	// if they're equal' we'll just have to go with syncsafe' since that's the spec  	if (isValidAtNonSyncSafe != isValidAtSyncSafe) {  		isID3v24SyncSafe = isValidAtSyncSafe;  	}  	break;  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2Tag.cs,Read,The following statement contains a magic number: if (bytesRead + frameSize + 10 == _id3v2Header.TagSize) {  	// Could give a false positive' but relatively unlikely (famous last words' huh?)  	isID3v24SyncSafe = false;  	break;  } else {  	stream.Seek (-4' SeekOrigin.Current);  	// go back to read sync-safe version  	int syncSafeFrameSize = ID3v2Utils.ReadInt32SyncSafe (stream);  	long currentPosition = stream.Position;  	bool isValidAtSyncSafe = true;  	bool isValidAtNonSyncSafe = true;  	// TODO - if it's the last frame and there is padding' both would indicate false  	// Use the one that returns some padding bytes opposed to bytes with non-zero values (could be frame data)  	// If non sync-safe reads past the end of the tag' then it's sync safe  	// Testing non-sync safe since it will always be bigger than the sync safe integer  	if (currentPosition + frameSize + 2 >= readUntil) {  		isID3v24SyncSafe = true;  		break;  	}  	// Test non-sync safe  	stream.Seek (currentPosition + frameSize + 2' SeekOrigin.Begin);  	frameIDBytes = stream.Read (frameIDSize);  	if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  		isValidAtNonSyncSafe = false;  	}  	// Test sync-safe  	stream.Seek (currentPosition + syncSafeFrameSize + 2' SeekOrigin.Begin);  	frameIDBytes = stream.Read (frameIDSize);  	if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  		isValidAtSyncSafe = false;  	}  	// if they're equal' we'll just have to go with syncsafe' since that's the spec  	if (isValidAtNonSyncSafe != isValidAtSyncSafe) {  		isID3v24SyncSafe = isValidAtSyncSafe;  	}  	break;  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2Tag.cs,Read,The following statement contains a magic number: if (bytesRead + frameSize + 10 == _id3v2Header.TagSize) {  	// Could give a false positive' but relatively unlikely (famous last words' huh?)  	isID3v24SyncSafe = false;  	break;  } else {  	stream.Seek (-4' SeekOrigin.Current);  	// go back to read sync-safe version  	int syncSafeFrameSize = ID3v2Utils.ReadInt32SyncSafe (stream);  	long currentPosition = stream.Position;  	bool isValidAtSyncSafe = true;  	bool isValidAtNonSyncSafe = true;  	// TODO - if it's the last frame and there is padding' both would indicate false  	// Use the one that returns some padding bytes opposed to bytes with non-zero values (could be frame data)  	// If non sync-safe reads past the end of the tag' then it's sync safe  	// Testing non-sync safe since it will always be bigger than the sync safe integer  	if (currentPosition + frameSize + 2 >= readUntil) {  		isID3v24SyncSafe = true;  		break;  	}  	// Test non-sync safe  	stream.Seek (currentPosition + frameSize + 2' SeekOrigin.Begin);  	frameIDBytes = stream.Read (frameIDSize);  	if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  		isValidAtNonSyncSafe = false;  	}  	// Test sync-safe  	stream.Seek (currentPosition + syncSafeFrameSize + 2' SeekOrigin.Begin);  	frameIDBytes = stream.Read (frameIDSize);  	if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  		isValidAtSyncSafe = false;  	}  	// if they're equal' we'll just have to go with syncsafe' since that's the spec  	if (isValidAtNonSyncSafe != isValidAtSyncSafe) {  		isID3v24SyncSafe = isValidAtSyncSafe;  	}  	break;  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2Tag.cs,Read,The following statement contains a magic number: stream.Seek (-4' SeekOrigin.Current);  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2Tag.cs,Read,The following statement contains a magic number: if (currentPosition + frameSize + 2 >= readUntil) {  	isID3v24SyncSafe = true;  	break;  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2Tag.cs,Read,The following statement contains a magic number: stream.Seek (currentPosition + frameSize + 2' SeekOrigin.Begin);  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2Tag.cs,Read,The following statement contains a magic number: if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  	isValidAtNonSyncSafe = false;  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2Tag.cs,Read,The following statement contains a magic number: if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  	isValidAtNonSyncSafe = false;  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2Tag.cs,Read,The following statement contains a magic number: if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  	isValidAtNonSyncSafe = false;  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2Tag.cs,Read,The following statement contains a magic number: if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  	isValidAtNonSyncSafe = false;  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2Tag.cs,Read,The following statement contains a magic number: stream.Seek (currentPosition + syncSafeFrameSize + 2' SeekOrigin.Begin);  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2Tag.cs,Read,The following statement contains a magic number: if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  	isValidAtSyncSafe = false;  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2Tag.cs,Read,The following statement contains a magic number: if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  	isValidAtSyncSafe = false;  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2Tag.cs,Read,The following statement contains a magic number: if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  	isValidAtSyncSafe = false;  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2Tag.cs,Read,The following statement contains a magic number: if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A || frameIDBytes [1] < 0x30 || frameIDBytes [1] > 0x5A || frameIDBytes [2] < 0x30 || frameIDBytes [2] > 0x5A || frameIDBytes [3] < 0x30 || frameIDBytes [3] > 0x5A) {  	isValidAtSyncSafe = false;  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2Tag.cs,Read,The following statement contains a magic number: stream.Seek (frameSize + 2' SeekOrigin.Current);  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2Tag.cs,Read,The following statement contains a magic number: bytesRead += frameSize + 10;  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2Tag.cs,Read,The following statement contains a magic number: if (_id3v2Header.TagVersion == ID3v2TagVersion.ID3v22) {  	bool isID3v22CorrectSize = true;  	bytesRead = 0;  	readUntil = _id3v2Header.TagSize - _id3v2ExtendedHeader.SizeIncludingSizeBytes - frameIDSize;  	long initialPosition = stream.Position;  	stream.Read (frameIDSize);  	UnknownFrame unknownFrame = new UnknownFrame (null' tagReadingInfo' stream);  	bytesRead += unknownFrame.FrameHeader.FrameSizeTotal;  	if (bytesRead < readUntil) {  		byte[] frameIDBytes = stream.Read (frameIDSize);  		// TODO: Noticed some tags contain 0x00 'E' 'N' as a FrameID.  Frame is well structured  		// and other frames follow.  I believe the below (keep reading+looking) will cover this issue.  		// If character is not a letter or number' padding reached' audio began'  		// or otherwise the frame is not readable  		if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A) {  			if (frameIDBytes [1] >= 0x30 && frameIDBytes [1] <= 0x5A && frameIDBytes [2] >= 0x30 && frameIDBytes [2] <= 0x5A) {  				Trace.WriteLine ("ID3v2.2 frame size off by 1 byte");  				isID3v22CorrectSize = false;  			}  		}  	}  	stream.Position = initialPosition;  	if (isID3v22CorrectSize == false) {  		tagReadingInfo.TagVersionOptions |= TagVersionOptions.AddOneByteToSize;  	}  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2Tag.cs,Read,The following statement contains a magic number: if (_id3v2Header.TagVersion == ID3v2TagVersion.ID3v22) {  	bool isID3v22CorrectSize = true;  	bytesRead = 0;  	readUntil = _id3v2Header.TagSize - _id3v2ExtendedHeader.SizeIncludingSizeBytes - frameIDSize;  	long initialPosition = stream.Position;  	stream.Read (frameIDSize);  	UnknownFrame unknownFrame = new UnknownFrame (null' tagReadingInfo' stream);  	bytesRead += unknownFrame.FrameHeader.FrameSizeTotal;  	if (bytesRead < readUntil) {  		byte[] frameIDBytes = stream.Read (frameIDSize);  		// TODO: Noticed some tags contain 0x00 'E' 'N' as a FrameID.  Frame is well structured  		// and other frames follow.  I believe the below (keep reading+looking) will cover this issue.  		// If character is not a letter or number' padding reached' audio began'  		// or otherwise the frame is not readable  		if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A) {  			if (frameIDBytes [1] >= 0x30 && frameIDBytes [1] <= 0x5A && frameIDBytes [2] >= 0x30 && frameIDBytes [2] <= 0x5A) {  				Trace.WriteLine ("ID3v2.2 frame size off by 1 byte");  				isID3v22CorrectSize = false;  			}  		}  	}  	stream.Position = initialPosition;  	if (isID3v22CorrectSize == false) {  		tagReadingInfo.TagVersionOptions |= TagVersionOptions.AddOneByteToSize;  	}  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2Tag.cs,Read,The following statement contains a magic number: if (bytesRead < readUntil) {  	byte[] frameIDBytes = stream.Read (frameIDSize);  	// TODO: Noticed some tags contain 0x00 'E' 'N' as a FrameID.  Frame is well structured  	// and other frames follow.  I believe the below (keep reading+looking) will cover this issue.  	// If character is not a letter or number' padding reached' audio began'  	// or otherwise the frame is not readable  	if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A) {  		if (frameIDBytes [1] >= 0x30 && frameIDBytes [1] <= 0x5A && frameIDBytes [2] >= 0x30 && frameIDBytes [2] <= 0x5A) {  			Trace.WriteLine ("ID3v2.2 frame size off by 1 byte");  			isID3v22CorrectSize = false;  		}  	}  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2Tag.cs,Read,The following statement contains a magic number: if (bytesRead < readUntil) {  	byte[] frameIDBytes = stream.Read (frameIDSize);  	// TODO: Noticed some tags contain 0x00 'E' 'N' as a FrameID.  Frame is well structured  	// and other frames follow.  I believe the below (keep reading+looking) will cover this issue.  	// If character is not a letter or number' padding reached' audio began'  	// or otherwise the frame is not readable  	if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A) {  		if (frameIDBytes [1] >= 0x30 && frameIDBytes [1] <= 0x5A && frameIDBytes [2] >= 0x30 && frameIDBytes [2] <= 0x5A) {  			Trace.WriteLine ("ID3v2.2 frame size off by 1 byte");  			isID3v22CorrectSize = false;  		}  	}  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2Tag.cs,Read,The following statement contains a magic number: if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A) {  	if (frameIDBytes [1] >= 0x30 && frameIDBytes [1] <= 0x5A && frameIDBytes [2] >= 0x30 && frameIDBytes [2] <= 0x5A) {  		Trace.WriteLine ("ID3v2.2 frame size off by 1 byte");  		isID3v22CorrectSize = false;  	}  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2Tag.cs,Read,The following statement contains a magic number: if (frameIDBytes [0] < 0x30 || frameIDBytes [0] > 0x5A) {  	if (frameIDBytes [1] >= 0x30 && frameIDBytes [1] <= 0x5A && frameIDBytes [2] >= 0x30 && frameIDBytes [2] <= 0x5A) {  		Trace.WriteLine ("ID3v2.2 frame size off by 1 byte");  		isID3v22CorrectSize = false;  	}  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2Tag.cs,Read,The following statement contains a magic number: if (frameIDBytes [1] >= 0x30 && frameIDBytes [1] <= 0x5A && frameIDBytes [2] >= 0x30 && frameIDBytes [2] <= 0x5A) {  	Trace.WriteLine ("ID3v2.2 frame size off by 1 byte");  	isID3v22CorrectSize = false;  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2Tag.cs,Read,The following statement contains a magic number: if (frameIDBytes [1] >= 0x30 && frameIDBytes [1] <= 0x5A && frameIDBytes [2] >= 0x30 && frameIDBytes [2] <= 0x5A) {  	Trace.WriteLine ("ID3v2.2 frame size off by 1 byte");  	isID3v22CorrectSize = false;  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2Tag.cs,GetTagSize,The following statement contains a magic number: try {  	if (stream.Length >= 16) {  		stream.Position = 0;  		byte[] identifier = stream.Read (3);  		// 'ID3' identifier  		if (!(identifier [0] == 0x49 && identifier [1] == 0x44 && identifier [2] == 0x33)) {  			return 0;  		}  		IID3v2Header header = new ID3v2Header (stream' false);  		int tagSize = header.TagSize;  		if (tagSize != 0)  			return tagSize + 10 + (header.IsFooterPresent ? 10 : 0);  		else  			return 0;  	}  	return 0;  } finally {  	stream.Position = 0;  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2Tag.cs,GetTagSize,The following statement contains a magic number: try {  	if (stream.Length >= 16) {  		stream.Position = 0;  		byte[] identifier = stream.Read (3);  		// 'ID3' identifier  		if (!(identifier [0] == 0x49 && identifier [1] == 0x44 && identifier [2] == 0x33)) {  			return 0;  		}  		IID3v2Header header = new ID3v2Header (stream' false);  		int tagSize = header.TagSize;  		if (tagSize != 0)  			return tagSize + 10 + (header.IsFooterPresent ? 10 : 0);  		else  			return 0;  	}  	return 0;  } finally {  	stream.Position = 0;  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2Tag.cs,GetTagSize,The following statement contains a magic number: try {  	if (stream.Length >= 16) {  		stream.Position = 0;  		byte[] identifier = stream.Read (3);  		// 'ID3' identifier  		if (!(identifier [0] == 0x49 && identifier [1] == 0x44 && identifier [2] == 0x33)) {  			return 0;  		}  		IID3v2Header header = new ID3v2Header (stream' false);  		int tagSize = header.TagSize;  		if (tagSize != 0)  			return tagSize + 10 + (header.IsFooterPresent ? 10 : 0);  		else  			return 0;  	}  	return 0;  } finally {  	stream.Position = 0;  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2Tag.cs,GetTagSize,The following statement contains a magic number: try {  	if (stream.Length >= 16) {  		stream.Position = 0;  		byte[] identifier = stream.Read (3);  		// 'ID3' identifier  		if (!(identifier [0] == 0x49 && identifier [1] == 0x44 && identifier [2] == 0x33)) {  			return 0;  		}  		IID3v2Header header = new ID3v2Header (stream' false);  		int tagSize = header.TagSize;  		if (tagSize != 0)  			return tagSize + 10 + (header.IsFooterPresent ? 10 : 0);  		else  			return 0;  	}  	return 0;  } finally {  	stream.Position = 0;  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2Tag.cs,GetTagSize,The following statement contains a magic number: try {  	if (stream.Length >= 16) {  		stream.Position = 0;  		byte[] identifier = stream.Read (3);  		// 'ID3' identifier  		if (!(identifier [0] == 0x49 && identifier [1] == 0x44 && identifier [2] == 0x33)) {  			return 0;  		}  		IID3v2Header header = new ID3v2Header (stream' false);  		int tagSize = header.TagSize;  		if (tagSize != 0)  			return tagSize + 10 + (header.IsFooterPresent ? 10 : 0);  		else  			return 0;  	}  	return 0;  } finally {  	stream.Position = 0;  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2Tag.cs,GetTagSize,The following statement contains a magic number: if (stream.Length >= 16) {  	stream.Position = 0;  	byte[] identifier = stream.Read (3);  	// 'ID3' identifier  	if (!(identifier [0] == 0x49 && identifier [1] == 0x44 && identifier [2] == 0x33)) {  		return 0;  	}  	IID3v2Header header = new ID3v2Header (stream' false);  	int tagSize = header.TagSize;  	if (tagSize != 0)  		return tagSize + 10 + (header.IsFooterPresent ? 10 : 0);  	else  		return 0;  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2Tag.cs,GetTagSize,The following statement contains a magic number: if (stream.Length >= 16) {  	stream.Position = 0;  	byte[] identifier = stream.Read (3);  	// 'ID3' identifier  	if (!(identifier [0] == 0x49 && identifier [1] == 0x44 && identifier [2] == 0x33)) {  		return 0;  	}  	IID3v2Header header = new ID3v2Header (stream' false);  	int tagSize = header.TagSize;  	if (tagSize != 0)  		return tagSize + 10 + (header.IsFooterPresent ? 10 : 0);  	else  		return 0;  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2Tag.cs,GetTagSize,The following statement contains a magic number: if (stream.Length >= 16) {  	stream.Position = 0;  	byte[] identifier = stream.Read (3);  	// 'ID3' identifier  	if (!(identifier [0] == 0x49 && identifier [1] == 0x44 && identifier [2] == 0x33)) {  		return 0;  	}  	IID3v2Header header = new ID3v2Header (stream' false);  	int tagSize = header.TagSize;  	if (tagSize != 0)  		return tagSize + 10 + (header.IsFooterPresent ? 10 : 0);  	else  		return 0;  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2Tag.cs,GetTagSize,The following statement contains a magic number: if (stream.Length >= 16) {  	stream.Position = 0;  	byte[] identifier = stream.Read (3);  	// 'ID3' identifier  	if (!(identifier [0] == 0x49 && identifier [1] == 0x44 && identifier [2] == 0x33)) {  		return 0;  	}  	IID3v2Header header = new ID3v2Header (stream' false);  	int tagSize = header.TagSize;  	if (tagSize != 0)  		return tagSize + 10 + (header.IsFooterPresent ? 10 : 0);  	else  		return 0;  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2Tag.cs,GetTagSize,The following statement contains a magic number: if (stream.Length >= 16) {  	stream.Position = 0;  	byte[] identifier = stream.Read (3);  	// 'ID3' identifier  	if (!(identifier [0] == 0x49 && identifier [1] == 0x44 && identifier [2] == 0x33)) {  		return 0;  	}  	IID3v2Header header = new ID3v2Header (stream' false);  	int tagSize = header.TagSize;  	if (tagSize != 0)  		return tagSize + 10 + (header.IsFooterPresent ? 10 : 0);  	else  		return 0;  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2Tag.cs,GetTagSize,The following statement contains a magic number: if (!(identifier [0] == 0x49 && identifier [1] == 0x44 && identifier [2] == 0x33)) {  	return 0;  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2Tag.cs,GetTagSize,The following statement contains a magic number: if (tagSize != 0)  	return tagSize + 10 + (header.IsFooterPresent ? 10 : 0);  else  	return 0;  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2Tag.cs,GetTagSize,The following statement contains a magic number: if (tagSize != 0)  	return tagSize + 10 + (header.IsFooterPresent ? 10 : 0);  else  	return 0;  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2Tag.cs,GetTagSize,The following statement contains a magic number: return tagSize + 10 + (header.IsFooterPresent ? 10 : 0);  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2Tag.cs,GetTagSize,The following statement contains a magic number: return tagSize + 10 + (header.IsFooterPresent ? 10 : 0);  
Magic Number,IdSharp.Tagging.ID3v2,FrameHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameHeader.cs,Read,The following statement contains a magic number: if (tagReadingInfo.TagVersion == ID3v2TagVersion.ID3v23) {  	if (!usesUnsynchronization)  		_frameSize = stream.ReadInt32 ();  	else  		_frameSize = ID3v2Utils.ReadInt32Unsynchronized (stream);  	_frameSizeExcludingAdditions = _frameSize;  	byte byte0 = stream.Read1 ();  	byte byte1 = stream.Read1 ();  	// First byte  	IsTagAlterPreservation = ((byte0 & 0x80) == 0x80);  	IsFileAlterPreservation = ((byte0 & 0x40) == 0x40);  	IsReadOnly = ((byte0 & 0x20) == 0x20);  	// Second byte  	IsCompressed = ((byte1 & 0x80) == 0x80);  	bool tmpIsEncrypted = ((byte1 & 0x40) == 0x40);  	bool tmpIsGroupingIdentity = ((byte1 & 0x20) == 0x20);  	// Additional bytes  	// Compression  	if (IsCompressed) {  		DecompressedSize = stream.ReadInt32 ();  		_frameSizeExcludingAdditions -= 4;  	} else {  		DecompressedSize = 0;  	}  	// Encryption  	if (tmpIsEncrypted) {  		EncryptionMethod = stream.Read1 ();  		_frameSizeExcludingAdditions -= 1;  	} else {  		EncryptionMethod = null;  	}  	// Grouping Identity  	if (tmpIsGroupingIdentity) {  		GroupingIdentity = stream.Read1 ();  		_frameSizeExcludingAdditions -= 1;  	} else {  		GroupingIdentity = null;  	}  	if (usesUnsynchronization) {  		stream = ID3v2Utils.ReadUnsynchronizedStream (stream' _frameSize);  	}  } else if (tagReadingInfo.TagVersion == ID3v2TagVersion.ID3v22) {  	if (!usesUnsynchronization)  		_frameSize = stream.ReadInt24 ();  	else  		_frameSize = ID3v2Utils.ReadInt24Unsynchronized (stream);  	if ((tagReadingInfo.TagVersionOptions & TagVersionOptions.AddOneByteToSize) == TagVersionOptions.AddOneByteToSize) {  		_frameSize++;  	}  	_frameSizeExcludingAdditions = _frameSize;  	// These fields are not supported in ID3v2.2  	IsTagAlterPreservation = false;  	IsFileAlterPreservation = false;  	IsReadOnly = false;  	IsCompressed = false;  	DecompressedSize = 0;  	EncryptionMethod = null;  	GroupingIdentity = null;  	if (usesUnsynchronization) {  		stream = ID3v2Utils.ReadUnsynchronizedStream (stream' _frameSize);  	}  } else if (tagReadingInfo.TagVersion == ID3v2TagVersion.ID3v24) {  	if ((tagReadingInfo.TagVersionOptions & TagVersionOptions.UseNonSyncSafeFrameSizeID3v24) == TagVersionOptions.UseNonSyncSafeFrameSizeID3v24)  		_frameSize = stream.ReadInt32 ();  	else  		_frameSize = ID3v2Utils.ReadInt32SyncSafe (stream);  	_frameSizeExcludingAdditions = _frameSize;  	byte byte0 = stream.Read1 ();  	byte byte1 = stream.Read1 ();  	bool hasDataLengthIndicator = ((byte1 & 0x01) == 0x01);  	usesUnsynchronization = ((byte1 & 0x03) == 0x03);  	if (hasDataLengthIndicator) {  		_frameSizeExcludingAdditions -= 4;  		stream.Seek (4' SeekOrigin.Current);  		// skip data length indicator  	}  	if (usesUnsynchronization) {  		stream = ID3v2Utils.ReadUnsynchronizedStream (stream' _frameSize);  	}  	// TODO - finish parsing  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameHeader.cs,Read,The following statement contains a magic number: if (tagReadingInfo.TagVersion == ID3v2TagVersion.ID3v23) {  	if (!usesUnsynchronization)  		_frameSize = stream.ReadInt32 ();  	else  		_frameSize = ID3v2Utils.ReadInt32Unsynchronized (stream);  	_frameSizeExcludingAdditions = _frameSize;  	byte byte0 = stream.Read1 ();  	byte byte1 = stream.Read1 ();  	// First byte  	IsTagAlterPreservation = ((byte0 & 0x80) == 0x80);  	IsFileAlterPreservation = ((byte0 & 0x40) == 0x40);  	IsReadOnly = ((byte0 & 0x20) == 0x20);  	// Second byte  	IsCompressed = ((byte1 & 0x80) == 0x80);  	bool tmpIsEncrypted = ((byte1 & 0x40) == 0x40);  	bool tmpIsGroupingIdentity = ((byte1 & 0x20) == 0x20);  	// Additional bytes  	// Compression  	if (IsCompressed) {  		DecompressedSize = stream.ReadInt32 ();  		_frameSizeExcludingAdditions -= 4;  	} else {  		DecompressedSize = 0;  	}  	// Encryption  	if (tmpIsEncrypted) {  		EncryptionMethod = stream.Read1 ();  		_frameSizeExcludingAdditions -= 1;  	} else {  		EncryptionMethod = null;  	}  	// Grouping Identity  	if (tmpIsGroupingIdentity) {  		GroupingIdentity = stream.Read1 ();  		_frameSizeExcludingAdditions -= 1;  	} else {  		GroupingIdentity = null;  	}  	if (usesUnsynchronization) {  		stream = ID3v2Utils.ReadUnsynchronizedStream (stream' _frameSize);  	}  } else if (tagReadingInfo.TagVersion == ID3v2TagVersion.ID3v22) {  	if (!usesUnsynchronization)  		_frameSize = stream.ReadInt24 ();  	else  		_frameSize = ID3v2Utils.ReadInt24Unsynchronized (stream);  	if ((tagReadingInfo.TagVersionOptions & TagVersionOptions.AddOneByteToSize) == TagVersionOptions.AddOneByteToSize) {  		_frameSize++;  	}  	_frameSizeExcludingAdditions = _frameSize;  	// These fields are not supported in ID3v2.2  	IsTagAlterPreservation = false;  	IsFileAlterPreservation = false;  	IsReadOnly = false;  	IsCompressed = false;  	DecompressedSize = 0;  	EncryptionMethod = null;  	GroupingIdentity = null;  	if (usesUnsynchronization) {  		stream = ID3v2Utils.ReadUnsynchronizedStream (stream' _frameSize);  	}  } else if (tagReadingInfo.TagVersion == ID3v2TagVersion.ID3v24) {  	if ((tagReadingInfo.TagVersionOptions & TagVersionOptions.UseNonSyncSafeFrameSizeID3v24) == TagVersionOptions.UseNonSyncSafeFrameSizeID3v24)  		_frameSize = stream.ReadInt32 ();  	else  		_frameSize = ID3v2Utils.ReadInt32SyncSafe (stream);  	_frameSizeExcludingAdditions = _frameSize;  	byte byte0 = stream.Read1 ();  	byte byte1 = stream.Read1 ();  	bool hasDataLengthIndicator = ((byte1 & 0x01) == 0x01);  	usesUnsynchronization = ((byte1 & 0x03) == 0x03);  	if (hasDataLengthIndicator) {  		_frameSizeExcludingAdditions -= 4;  		stream.Seek (4' SeekOrigin.Current);  		// skip data length indicator  	}  	if (usesUnsynchronization) {  		stream = ID3v2Utils.ReadUnsynchronizedStream (stream' _frameSize);  	}  	// TODO - finish parsing  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameHeader.cs,Read,The following statement contains a magic number: if (tagReadingInfo.TagVersion == ID3v2TagVersion.ID3v23) {  	if (!usesUnsynchronization)  		_frameSize = stream.ReadInt32 ();  	else  		_frameSize = ID3v2Utils.ReadInt32Unsynchronized (stream);  	_frameSizeExcludingAdditions = _frameSize;  	byte byte0 = stream.Read1 ();  	byte byte1 = stream.Read1 ();  	// First byte  	IsTagAlterPreservation = ((byte0 & 0x80) == 0x80);  	IsFileAlterPreservation = ((byte0 & 0x40) == 0x40);  	IsReadOnly = ((byte0 & 0x20) == 0x20);  	// Second byte  	IsCompressed = ((byte1 & 0x80) == 0x80);  	bool tmpIsEncrypted = ((byte1 & 0x40) == 0x40);  	bool tmpIsGroupingIdentity = ((byte1 & 0x20) == 0x20);  	// Additional bytes  	// Compression  	if (IsCompressed) {  		DecompressedSize = stream.ReadInt32 ();  		_frameSizeExcludingAdditions -= 4;  	} else {  		DecompressedSize = 0;  	}  	// Encryption  	if (tmpIsEncrypted) {  		EncryptionMethod = stream.Read1 ();  		_frameSizeExcludingAdditions -= 1;  	} else {  		EncryptionMethod = null;  	}  	// Grouping Identity  	if (tmpIsGroupingIdentity) {  		GroupingIdentity = stream.Read1 ();  		_frameSizeExcludingAdditions -= 1;  	} else {  		GroupingIdentity = null;  	}  	if (usesUnsynchronization) {  		stream = ID3v2Utils.ReadUnsynchronizedStream (stream' _frameSize);  	}  } else if (tagReadingInfo.TagVersion == ID3v2TagVersion.ID3v22) {  	if (!usesUnsynchronization)  		_frameSize = stream.ReadInt24 ();  	else  		_frameSize = ID3v2Utils.ReadInt24Unsynchronized (stream);  	if ((tagReadingInfo.TagVersionOptions & TagVersionOptions.AddOneByteToSize) == TagVersionOptions.AddOneByteToSize) {  		_frameSize++;  	}  	_frameSizeExcludingAdditions = _frameSize;  	// These fields are not supported in ID3v2.2  	IsTagAlterPreservation = false;  	IsFileAlterPreservation = false;  	IsReadOnly = false;  	IsCompressed = false;  	DecompressedSize = 0;  	EncryptionMethod = null;  	GroupingIdentity = null;  	if (usesUnsynchronization) {  		stream = ID3v2Utils.ReadUnsynchronizedStream (stream' _frameSize);  	}  } else if (tagReadingInfo.TagVersion == ID3v2TagVersion.ID3v24) {  	if ((tagReadingInfo.TagVersionOptions & TagVersionOptions.UseNonSyncSafeFrameSizeID3v24) == TagVersionOptions.UseNonSyncSafeFrameSizeID3v24)  		_frameSize = stream.ReadInt32 ();  	else  		_frameSize = ID3v2Utils.ReadInt32SyncSafe (stream);  	_frameSizeExcludingAdditions = _frameSize;  	byte byte0 = stream.Read1 ();  	byte byte1 = stream.Read1 ();  	bool hasDataLengthIndicator = ((byte1 & 0x01) == 0x01);  	usesUnsynchronization = ((byte1 & 0x03) == 0x03);  	if (hasDataLengthIndicator) {  		_frameSizeExcludingAdditions -= 4;  		stream.Seek (4' SeekOrigin.Current);  		// skip data length indicator  	}  	if (usesUnsynchronization) {  		stream = ID3v2Utils.ReadUnsynchronizedStream (stream' _frameSize);  	}  	// TODO - finish parsing  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameHeader.cs,Read,The following statement contains a magic number: if (IsCompressed) {  	DecompressedSize = stream.ReadInt32 ();  	_frameSizeExcludingAdditions -= 4;  } else {  	DecompressedSize = 0;  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameHeader.cs,Read,The following statement contains a magic number: _frameSizeExcludingAdditions -= 4;  
Magic Number,IdSharp.Tagging.ID3v2,FrameHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameHeader.cs,Read,The following statement contains a magic number: if (tagReadingInfo.TagVersion == ID3v2TagVersion.ID3v22) {  	if (!usesUnsynchronization)  		_frameSize = stream.ReadInt24 ();  	else  		_frameSize = ID3v2Utils.ReadInt24Unsynchronized (stream);  	if ((tagReadingInfo.TagVersionOptions & TagVersionOptions.AddOneByteToSize) == TagVersionOptions.AddOneByteToSize) {  		_frameSize++;  	}  	_frameSizeExcludingAdditions = _frameSize;  	// These fields are not supported in ID3v2.2  	IsTagAlterPreservation = false;  	IsFileAlterPreservation = false;  	IsReadOnly = false;  	IsCompressed = false;  	DecompressedSize = 0;  	EncryptionMethod = null;  	GroupingIdentity = null;  	if (usesUnsynchronization) {  		stream = ID3v2Utils.ReadUnsynchronizedStream (stream' _frameSize);  	}  } else if (tagReadingInfo.TagVersion == ID3v2TagVersion.ID3v24) {  	if ((tagReadingInfo.TagVersionOptions & TagVersionOptions.UseNonSyncSafeFrameSizeID3v24) == TagVersionOptions.UseNonSyncSafeFrameSizeID3v24)  		_frameSize = stream.ReadInt32 ();  	else  		_frameSize = ID3v2Utils.ReadInt32SyncSafe (stream);  	_frameSizeExcludingAdditions = _frameSize;  	byte byte0 = stream.Read1 ();  	byte byte1 = stream.Read1 ();  	bool hasDataLengthIndicator = ((byte1 & 0x01) == 0x01);  	usesUnsynchronization = ((byte1 & 0x03) == 0x03);  	if (hasDataLengthIndicator) {  		_frameSizeExcludingAdditions -= 4;  		stream.Seek (4' SeekOrigin.Current);  		// skip data length indicator  	}  	if (usesUnsynchronization) {  		stream = ID3v2Utils.ReadUnsynchronizedStream (stream' _frameSize);  	}  	// TODO - finish parsing  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameHeader.cs,Read,The following statement contains a magic number: if (tagReadingInfo.TagVersion == ID3v2TagVersion.ID3v22) {  	if (!usesUnsynchronization)  		_frameSize = stream.ReadInt24 ();  	else  		_frameSize = ID3v2Utils.ReadInt24Unsynchronized (stream);  	if ((tagReadingInfo.TagVersionOptions & TagVersionOptions.AddOneByteToSize) == TagVersionOptions.AddOneByteToSize) {  		_frameSize++;  	}  	_frameSizeExcludingAdditions = _frameSize;  	// These fields are not supported in ID3v2.2  	IsTagAlterPreservation = false;  	IsFileAlterPreservation = false;  	IsReadOnly = false;  	IsCompressed = false;  	DecompressedSize = 0;  	EncryptionMethod = null;  	GroupingIdentity = null;  	if (usesUnsynchronization) {  		stream = ID3v2Utils.ReadUnsynchronizedStream (stream' _frameSize);  	}  } else if (tagReadingInfo.TagVersion == ID3v2TagVersion.ID3v24) {  	if ((tagReadingInfo.TagVersionOptions & TagVersionOptions.UseNonSyncSafeFrameSizeID3v24) == TagVersionOptions.UseNonSyncSafeFrameSizeID3v24)  		_frameSize = stream.ReadInt32 ();  	else  		_frameSize = ID3v2Utils.ReadInt32SyncSafe (stream);  	_frameSizeExcludingAdditions = _frameSize;  	byte byte0 = stream.Read1 ();  	byte byte1 = stream.Read1 ();  	bool hasDataLengthIndicator = ((byte1 & 0x01) == 0x01);  	usesUnsynchronization = ((byte1 & 0x03) == 0x03);  	if (hasDataLengthIndicator) {  		_frameSizeExcludingAdditions -= 4;  		stream.Seek (4' SeekOrigin.Current);  		// skip data length indicator  	}  	if (usesUnsynchronization) {  		stream = ID3v2Utils.ReadUnsynchronizedStream (stream' _frameSize);  	}  	// TODO - finish parsing  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameHeader.cs,Read,The following statement contains a magic number: if (tagReadingInfo.TagVersion == ID3v2TagVersion.ID3v24) {  	if ((tagReadingInfo.TagVersionOptions & TagVersionOptions.UseNonSyncSafeFrameSizeID3v24) == TagVersionOptions.UseNonSyncSafeFrameSizeID3v24)  		_frameSize = stream.ReadInt32 ();  	else  		_frameSize = ID3v2Utils.ReadInt32SyncSafe (stream);  	_frameSizeExcludingAdditions = _frameSize;  	byte byte0 = stream.Read1 ();  	byte byte1 = stream.Read1 ();  	bool hasDataLengthIndicator = ((byte1 & 0x01) == 0x01);  	usesUnsynchronization = ((byte1 & 0x03) == 0x03);  	if (hasDataLengthIndicator) {  		_frameSizeExcludingAdditions -= 4;  		stream.Seek (4' SeekOrigin.Current);  		// skip data length indicator  	}  	if (usesUnsynchronization) {  		stream = ID3v2Utils.ReadUnsynchronizedStream (stream' _frameSize);  	}  	// TODO - finish parsing  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameHeader.cs,Read,The following statement contains a magic number: if (tagReadingInfo.TagVersion == ID3v2TagVersion.ID3v24) {  	if ((tagReadingInfo.TagVersionOptions & TagVersionOptions.UseNonSyncSafeFrameSizeID3v24) == TagVersionOptions.UseNonSyncSafeFrameSizeID3v24)  		_frameSize = stream.ReadInt32 ();  	else  		_frameSize = ID3v2Utils.ReadInt32SyncSafe (stream);  	_frameSizeExcludingAdditions = _frameSize;  	byte byte0 = stream.Read1 ();  	byte byte1 = stream.Read1 ();  	bool hasDataLengthIndicator = ((byte1 & 0x01) == 0x01);  	usesUnsynchronization = ((byte1 & 0x03) == 0x03);  	if (hasDataLengthIndicator) {  		_frameSizeExcludingAdditions -= 4;  		stream.Seek (4' SeekOrigin.Current);  		// skip data length indicator  	}  	if (usesUnsynchronization) {  		stream = ID3v2Utils.ReadUnsynchronizedStream (stream' _frameSize);  	}  	// TODO - finish parsing  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameHeader.cs,Read,The following statement contains a magic number: if (hasDataLengthIndicator) {  	_frameSizeExcludingAdditions -= 4;  	stream.Seek (4' SeekOrigin.Current);  	// skip data length indicator  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameHeader.cs,Read,The following statement contains a magic number: if (hasDataLengthIndicator) {  	_frameSizeExcludingAdditions -= 4;  	stream.Seek (4' SeekOrigin.Current);  	// skip data length indicator  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameHeader.cs,Read,The following statement contains a magic number: _frameSizeExcludingAdditions -= 4;  
Magic Number,IdSharp.Tagging.ID3v2,FrameHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameHeader.cs,Read,The following statement contains a magic number: stream.Seek (4' SeekOrigin.Current);  
Magic Number,IdSharp.Tagging.ID3v2,FrameHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameHeader.cs,GetBytes,The following statement contains a magic number: if (tagVersion == ID3v2TagVersion.ID3v22) {  	if (frameIDBytes.Length != 3)  		throw new ArgumentException (String.Format ("FrameID must be 3 bytes from ID3v2.2 ({0} bytes passed)"' frameIDBytes.Length));  	tmpRawData = new byte[6];  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = (byte)((_frameSizeExcludingAdditions >> 16) & 0xFF);  	tmpRawData [4] = (byte)((_frameSizeExcludingAdditions >> 8) & 0xFF);  	tmpRawData [5] = (byte)(_frameSizeExcludingAdditions & 0xFF);  } else if (tagVersion == ID3v2TagVersion.ID3v23) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x80 : 0) + (_isFileAlterPreservation ? 0x40 : 0) + (_isReadOnly ? 0x20 : 0));  	byte tmpByte2 = (byte)((_isCompressed ? 0x80 : 0) + (_encryptionMethod != null ? 0x40 : 0) + (_groupingIdentity != null ? 0x20 : 0));  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 24) & 0xFF);  	tmpRawData [5] = (byte)((tmpFrameSize >> 16) & 0xFF);  	tmpRawData [6] = (byte)((tmpFrameSize >> 8) & 0xFF);  	tmpRawData [7] = (byte)(tmpFrameSize & 0xFF);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition] = _groupingIdentity.Value;  } else if (tagVersion == ID3v2TagVersion.ID3v24) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x40 : 0) + (_isFileAlterPreservation ? 0x20 : 0) + (_isReadOnly ? 0x10 : 0));  	byte tmpByte2 = (byte)((_groupingIdentity != null ? 0x40 : 0) + (_isCompressed ? 0x08 : 0) + (_encryptionMethod != null ? 0x04 : 0)/* +                                   (false Unsynchronization ? 0x02 : 0) +                                   (false Data length indicator ? 0x01 : 0)*/);  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	/*TODO: unsync'DLI*/int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	// Note: ID3v2.4 uses sync safe frame sizes  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 21) & 0x7F);  	tmpRawData [5] = (byte)((tmpFrameSize >> 14) & 0x7F);  	tmpRawData [6] = (byte)((tmpFrameSize >> 7) & 0x7F);  	tmpRawData [7] = (byte)(tmpFrameSize & 0x7F);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition++] = _groupingIdentity.Value;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	/*TODO: unsync'DLI*/} else {  	throw new ArgumentOutOfRangeException ("tagVersion"' tagVersion' "Unknown tag version");  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameHeader.cs,GetBytes,The following statement contains a magic number: if (tagVersion == ID3v2TagVersion.ID3v22) {  	if (frameIDBytes.Length != 3)  		throw new ArgumentException (String.Format ("FrameID must be 3 bytes from ID3v2.2 ({0} bytes passed)"' frameIDBytes.Length));  	tmpRawData = new byte[6];  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = (byte)((_frameSizeExcludingAdditions >> 16) & 0xFF);  	tmpRawData [4] = (byte)((_frameSizeExcludingAdditions >> 8) & 0xFF);  	tmpRawData [5] = (byte)(_frameSizeExcludingAdditions & 0xFF);  } else if (tagVersion == ID3v2TagVersion.ID3v23) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x80 : 0) + (_isFileAlterPreservation ? 0x40 : 0) + (_isReadOnly ? 0x20 : 0));  	byte tmpByte2 = (byte)((_isCompressed ? 0x80 : 0) + (_encryptionMethod != null ? 0x40 : 0) + (_groupingIdentity != null ? 0x20 : 0));  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 24) & 0xFF);  	tmpRawData [5] = (byte)((tmpFrameSize >> 16) & 0xFF);  	tmpRawData [6] = (byte)((tmpFrameSize >> 8) & 0xFF);  	tmpRawData [7] = (byte)(tmpFrameSize & 0xFF);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition] = _groupingIdentity.Value;  } else if (tagVersion == ID3v2TagVersion.ID3v24) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x40 : 0) + (_isFileAlterPreservation ? 0x20 : 0) + (_isReadOnly ? 0x10 : 0));  	byte tmpByte2 = (byte)((_groupingIdentity != null ? 0x40 : 0) + (_isCompressed ? 0x08 : 0) + (_encryptionMethod != null ? 0x04 : 0)/* +                                   (false Unsynchronization ? 0x02 : 0) +                                   (false Data length indicator ? 0x01 : 0)*/);  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	/*TODO: unsync'DLI*/int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	// Note: ID3v2.4 uses sync safe frame sizes  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 21) & 0x7F);  	tmpRawData [5] = (byte)((tmpFrameSize >> 14) & 0x7F);  	tmpRawData [6] = (byte)((tmpFrameSize >> 7) & 0x7F);  	tmpRawData [7] = (byte)(tmpFrameSize & 0x7F);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition++] = _groupingIdentity.Value;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	/*TODO: unsync'DLI*/} else {  	throw new ArgumentOutOfRangeException ("tagVersion"' tagVersion' "Unknown tag version");  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameHeader.cs,GetBytes,The following statement contains a magic number: if (tagVersion == ID3v2TagVersion.ID3v22) {  	if (frameIDBytes.Length != 3)  		throw new ArgumentException (String.Format ("FrameID must be 3 bytes from ID3v2.2 ({0} bytes passed)"' frameIDBytes.Length));  	tmpRawData = new byte[6];  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = (byte)((_frameSizeExcludingAdditions >> 16) & 0xFF);  	tmpRawData [4] = (byte)((_frameSizeExcludingAdditions >> 8) & 0xFF);  	tmpRawData [5] = (byte)(_frameSizeExcludingAdditions & 0xFF);  } else if (tagVersion == ID3v2TagVersion.ID3v23) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x80 : 0) + (_isFileAlterPreservation ? 0x40 : 0) + (_isReadOnly ? 0x20 : 0));  	byte tmpByte2 = (byte)((_isCompressed ? 0x80 : 0) + (_encryptionMethod != null ? 0x40 : 0) + (_groupingIdentity != null ? 0x20 : 0));  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 24) & 0xFF);  	tmpRawData [5] = (byte)((tmpFrameSize >> 16) & 0xFF);  	tmpRawData [6] = (byte)((tmpFrameSize >> 8) & 0xFF);  	tmpRawData [7] = (byte)(tmpFrameSize & 0xFF);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition] = _groupingIdentity.Value;  } else if (tagVersion == ID3v2TagVersion.ID3v24) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x40 : 0) + (_isFileAlterPreservation ? 0x20 : 0) + (_isReadOnly ? 0x10 : 0));  	byte tmpByte2 = (byte)((_groupingIdentity != null ? 0x40 : 0) + (_isCompressed ? 0x08 : 0) + (_encryptionMethod != null ? 0x04 : 0)/* +                                   (false Unsynchronization ? 0x02 : 0) +                                   (false Data length indicator ? 0x01 : 0)*/);  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	/*TODO: unsync'DLI*/int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	// Note: ID3v2.4 uses sync safe frame sizes  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 21) & 0x7F);  	tmpRawData [5] = (byte)((tmpFrameSize >> 14) & 0x7F);  	tmpRawData [6] = (byte)((tmpFrameSize >> 7) & 0x7F);  	tmpRawData [7] = (byte)(tmpFrameSize & 0x7F);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition++] = _groupingIdentity.Value;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	/*TODO: unsync'DLI*/} else {  	throw new ArgumentOutOfRangeException ("tagVersion"' tagVersion' "Unknown tag version");  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameHeader.cs,GetBytes,The following statement contains a magic number: if (tagVersion == ID3v2TagVersion.ID3v22) {  	if (frameIDBytes.Length != 3)  		throw new ArgumentException (String.Format ("FrameID must be 3 bytes from ID3v2.2 ({0} bytes passed)"' frameIDBytes.Length));  	tmpRawData = new byte[6];  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = (byte)((_frameSizeExcludingAdditions >> 16) & 0xFF);  	tmpRawData [4] = (byte)((_frameSizeExcludingAdditions >> 8) & 0xFF);  	tmpRawData [5] = (byte)(_frameSizeExcludingAdditions & 0xFF);  } else if (tagVersion == ID3v2TagVersion.ID3v23) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x80 : 0) + (_isFileAlterPreservation ? 0x40 : 0) + (_isReadOnly ? 0x20 : 0));  	byte tmpByte2 = (byte)((_isCompressed ? 0x80 : 0) + (_encryptionMethod != null ? 0x40 : 0) + (_groupingIdentity != null ? 0x20 : 0));  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 24) & 0xFF);  	tmpRawData [5] = (byte)((tmpFrameSize >> 16) & 0xFF);  	tmpRawData [6] = (byte)((tmpFrameSize >> 8) & 0xFF);  	tmpRawData [7] = (byte)(tmpFrameSize & 0xFF);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition] = _groupingIdentity.Value;  } else if (tagVersion == ID3v2TagVersion.ID3v24) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x40 : 0) + (_isFileAlterPreservation ? 0x20 : 0) + (_isReadOnly ? 0x10 : 0));  	byte tmpByte2 = (byte)((_groupingIdentity != null ? 0x40 : 0) + (_isCompressed ? 0x08 : 0) + (_encryptionMethod != null ? 0x04 : 0)/* +                                   (false Unsynchronization ? 0x02 : 0) +                                   (false Data length indicator ? 0x01 : 0)*/);  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	/*TODO: unsync'DLI*/int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	// Note: ID3v2.4 uses sync safe frame sizes  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 21) & 0x7F);  	tmpRawData [5] = (byte)((tmpFrameSize >> 14) & 0x7F);  	tmpRawData [6] = (byte)((tmpFrameSize >> 7) & 0x7F);  	tmpRawData [7] = (byte)(tmpFrameSize & 0x7F);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition++] = _groupingIdentity.Value;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	/*TODO: unsync'DLI*/} else {  	throw new ArgumentOutOfRangeException ("tagVersion"' tagVersion' "Unknown tag version");  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameHeader.cs,GetBytes,The following statement contains a magic number: if (tagVersion == ID3v2TagVersion.ID3v22) {  	if (frameIDBytes.Length != 3)  		throw new ArgumentException (String.Format ("FrameID must be 3 bytes from ID3v2.2 ({0} bytes passed)"' frameIDBytes.Length));  	tmpRawData = new byte[6];  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = (byte)((_frameSizeExcludingAdditions >> 16) & 0xFF);  	tmpRawData [4] = (byte)((_frameSizeExcludingAdditions >> 8) & 0xFF);  	tmpRawData [5] = (byte)(_frameSizeExcludingAdditions & 0xFF);  } else if (tagVersion == ID3v2TagVersion.ID3v23) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x80 : 0) + (_isFileAlterPreservation ? 0x40 : 0) + (_isReadOnly ? 0x20 : 0));  	byte tmpByte2 = (byte)((_isCompressed ? 0x80 : 0) + (_encryptionMethod != null ? 0x40 : 0) + (_groupingIdentity != null ? 0x20 : 0));  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 24) & 0xFF);  	tmpRawData [5] = (byte)((tmpFrameSize >> 16) & 0xFF);  	tmpRawData [6] = (byte)((tmpFrameSize >> 8) & 0xFF);  	tmpRawData [7] = (byte)(tmpFrameSize & 0xFF);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition] = _groupingIdentity.Value;  } else if (tagVersion == ID3v2TagVersion.ID3v24) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x40 : 0) + (_isFileAlterPreservation ? 0x20 : 0) + (_isReadOnly ? 0x10 : 0));  	byte tmpByte2 = (byte)((_groupingIdentity != null ? 0x40 : 0) + (_isCompressed ? 0x08 : 0) + (_encryptionMethod != null ? 0x04 : 0)/* +                                   (false Unsynchronization ? 0x02 : 0) +                                   (false Data length indicator ? 0x01 : 0)*/);  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	/*TODO: unsync'DLI*/int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	// Note: ID3v2.4 uses sync safe frame sizes  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 21) & 0x7F);  	tmpRawData [5] = (byte)((tmpFrameSize >> 14) & 0x7F);  	tmpRawData [6] = (byte)((tmpFrameSize >> 7) & 0x7F);  	tmpRawData [7] = (byte)(tmpFrameSize & 0x7F);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition++] = _groupingIdentity.Value;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	/*TODO: unsync'DLI*/} else {  	throw new ArgumentOutOfRangeException ("tagVersion"' tagVersion' "Unknown tag version");  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameHeader.cs,GetBytes,The following statement contains a magic number: if (tagVersion == ID3v2TagVersion.ID3v22) {  	if (frameIDBytes.Length != 3)  		throw new ArgumentException (String.Format ("FrameID must be 3 bytes from ID3v2.2 ({0} bytes passed)"' frameIDBytes.Length));  	tmpRawData = new byte[6];  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = (byte)((_frameSizeExcludingAdditions >> 16) & 0xFF);  	tmpRawData [4] = (byte)((_frameSizeExcludingAdditions >> 8) & 0xFF);  	tmpRawData [5] = (byte)(_frameSizeExcludingAdditions & 0xFF);  } else if (tagVersion == ID3v2TagVersion.ID3v23) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x80 : 0) + (_isFileAlterPreservation ? 0x40 : 0) + (_isReadOnly ? 0x20 : 0));  	byte tmpByte2 = (byte)((_isCompressed ? 0x80 : 0) + (_encryptionMethod != null ? 0x40 : 0) + (_groupingIdentity != null ? 0x20 : 0));  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 24) & 0xFF);  	tmpRawData [5] = (byte)((tmpFrameSize >> 16) & 0xFF);  	tmpRawData [6] = (byte)((tmpFrameSize >> 8) & 0xFF);  	tmpRawData [7] = (byte)(tmpFrameSize & 0xFF);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition] = _groupingIdentity.Value;  } else if (tagVersion == ID3v2TagVersion.ID3v24) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x40 : 0) + (_isFileAlterPreservation ? 0x20 : 0) + (_isReadOnly ? 0x10 : 0));  	byte tmpByte2 = (byte)((_groupingIdentity != null ? 0x40 : 0) + (_isCompressed ? 0x08 : 0) + (_encryptionMethod != null ? 0x04 : 0)/* +                                   (false Unsynchronization ? 0x02 : 0) +                                   (false Data length indicator ? 0x01 : 0)*/);  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	/*TODO: unsync'DLI*/int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	// Note: ID3v2.4 uses sync safe frame sizes  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 21) & 0x7F);  	tmpRawData [5] = (byte)((tmpFrameSize >> 14) & 0x7F);  	tmpRawData [6] = (byte)((tmpFrameSize >> 7) & 0x7F);  	tmpRawData [7] = (byte)(tmpFrameSize & 0x7F);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition++] = _groupingIdentity.Value;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	/*TODO: unsync'DLI*/} else {  	throw new ArgumentOutOfRangeException ("tagVersion"' tagVersion' "Unknown tag version");  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameHeader.cs,GetBytes,The following statement contains a magic number: if (tagVersion == ID3v2TagVersion.ID3v22) {  	if (frameIDBytes.Length != 3)  		throw new ArgumentException (String.Format ("FrameID must be 3 bytes from ID3v2.2 ({0} bytes passed)"' frameIDBytes.Length));  	tmpRawData = new byte[6];  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = (byte)((_frameSizeExcludingAdditions >> 16) & 0xFF);  	tmpRawData [4] = (byte)((_frameSizeExcludingAdditions >> 8) & 0xFF);  	tmpRawData [5] = (byte)(_frameSizeExcludingAdditions & 0xFF);  } else if (tagVersion == ID3v2TagVersion.ID3v23) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x80 : 0) + (_isFileAlterPreservation ? 0x40 : 0) + (_isReadOnly ? 0x20 : 0));  	byte tmpByte2 = (byte)((_isCompressed ? 0x80 : 0) + (_encryptionMethod != null ? 0x40 : 0) + (_groupingIdentity != null ? 0x20 : 0));  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 24) & 0xFF);  	tmpRawData [5] = (byte)((tmpFrameSize >> 16) & 0xFF);  	tmpRawData [6] = (byte)((tmpFrameSize >> 8) & 0xFF);  	tmpRawData [7] = (byte)(tmpFrameSize & 0xFF);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition] = _groupingIdentity.Value;  } else if (tagVersion == ID3v2TagVersion.ID3v24) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x40 : 0) + (_isFileAlterPreservation ? 0x20 : 0) + (_isReadOnly ? 0x10 : 0));  	byte tmpByte2 = (byte)((_groupingIdentity != null ? 0x40 : 0) + (_isCompressed ? 0x08 : 0) + (_encryptionMethod != null ? 0x04 : 0)/* +                                   (false Unsynchronization ? 0x02 : 0) +                                   (false Data length indicator ? 0x01 : 0)*/);  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	/*TODO: unsync'DLI*/int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	// Note: ID3v2.4 uses sync safe frame sizes  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 21) & 0x7F);  	tmpRawData [5] = (byte)((tmpFrameSize >> 14) & 0x7F);  	tmpRawData [6] = (byte)((tmpFrameSize >> 7) & 0x7F);  	tmpRawData [7] = (byte)(tmpFrameSize & 0x7F);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition++] = _groupingIdentity.Value;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	/*TODO: unsync'DLI*/} else {  	throw new ArgumentOutOfRangeException ("tagVersion"' tagVersion' "Unknown tag version");  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameHeader.cs,GetBytes,The following statement contains a magic number: if (tagVersion == ID3v2TagVersion.ID3v22) {  	if (frameIDBytes.Length != 3)  		throw new ArgumentException (String.Format ("FrameID must be 3 bytes from ID3v2.2 ({0} bytes passed)"' frameIDBytes.Length));  	tmpRawData = new byte[6];  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = (byte)((_frameSizeExcludingAdditions >> 16) & 0xFF);  	tmpRawData [4] = (byte)((_frameSizeExcludingAdditions >> 8) & 0xFF);  	tmpRawData [5] = (byte)(_frameSizeExcludingAdditions & 0xFF);  } else if (tagVersion == ID3v2TagVersion.ID3v23) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x80 : 0) + (_isFileAlterPreservation ? 0x40 : 0) + (_isReadOnly ? 0x20 : 0));  	byte tmpByte2 = (byte)((_isCompressed ? 0x80 : 0) + (_encryptionMethod != null ? 0x40 : 0) + (_groupingIdentity != null ? 0x20 : 0));  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 24) & 0xFF);  	tmpRawData [5] = (byte)((tmpFrameSize >> 16) & 0xFF);  	tmpRawData [6] = (byte)((tmpFrameSize >> 8) & 0xFF);  	tmpRawData [7] = (byte)(tmpFrameSize & 0xFF);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition] = _groupingIdentity.Value;  } else if (tagVersion == ID3v2TagVersion.ID3v24) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x40 : 0) + (_isFileAlterPreservation ? 0x20 : 0) + (_isReadOnly ? 0x10 : 0));  	byte tmpByte2 = (byte)((_groupingIdentity != null ? 0x40 : 0) + (_isCompressed ? 0x08 : 0) + (_encryptionMethod != null ? 0x04 : 0)/* +                                   (false Unsynchronization ? 0x02 : 0) +                                   (false Data length indicator ? 0x01 : 0)*/);  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	/*TODO: unsync'DLI*/int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	// Note: ID3v2.4 uses sync safe frame sizes  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 21) & 0x7F);  	tmpRawData [5] = (byte)((tmpFrameSize >> 14) & 0x7F);  	tmpRawData [6] = (byte)((tmpFrameSize >> 7) & 0x7F);  	tmpRawData [7] = (byte)(tmpFrameSize & 0x7F);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition++] = _groupingIdentity.Value;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	/*TODO: unsync'DLI*/} else {  	throw new ArgumentOutOfRangeException ("tagVersion"' tagVersion' "Unknown tag version");  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameHeader.cs,GetBytes,The following statement contains a magic number: if (tagVersion == ID3v2TagVersion.ID3v22) {  	if (frameIDBytes.Length != 3)  		throw new ArgumentException (String.Format ("FrameID must be 3 bytes from ID3v2.2 ({0} bytes passed)"' frameIDBytes.Length));  	tmpRawData = new byte[6];  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = (byte)((_frameSizeExcludingAdditions >> 16) & 0xFF);  	tmpRawData [4] = (byte)((_frameSizeExcludingAdditions >> 8) & 0xFF);  	tmpRawData [5] = (byte)(_frameSizeExcludingAdditions & 0xFF);  } else if (tagVersion == ID3v2TagVersion.ID3v23) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x80 : 0) + (_isFileAlterPreservation ? 0x40 : 0) + (_isReadOnly ? 0x20 : 0));  	byte tmpByte2 = (byte)((_isCompressed ? 0x80 : 0) + (_encryptionMethod != null ? 0x40 : 0) + (_groupingIdentity != null ? 0x20 : 0));  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 24) & 0xFF);  	tmpRawData [5] = (byte)((tmpFrameSize >> 16) & 0xFF);  	tmpRawData [6] = (byte)((tmpFrameSize >> 8) & 0xFF);  	tmpRawData [7] = (byte)(tmpFrameSize & 0xFF);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition] = _groupingIdentity.Value;  } else if (tagVersion == ID3v2TagVersion.ID3v24) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x40 : 0) + (_isFileAlterPreservation ? 0x20 : 0) + (_isReadOnly ? 0x10 : 0));  	byte tmpByte2 = (byte)((_groupingIdentity != null ? 0x40 : 0) + (_isCompressed ? 0x08 : 0) + (_encryptionMethod != null ? 0x04 : 0)/* +                                   (false Unsynchronization ? 0x02 : 0) +                                   (false Data length indicator ? 0x01 : 0)*/);  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	/*TODO: unsync'DLI*/int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	// Note: ID3v2.4 uses sync safe frame sizes  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 21) & 0x7F);  	tmpRawData [5] = (byte)((tmpFrameSize >> 14) & 0x7F);  	tmpRawData [6] = (byte)((tmpFrameSize >> 7) & 0x7F);  	tmpRawData [7] = (byte)(tmpFrameSize & 0x7F);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition++] = _groupingIdentity.Value;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	/*TODO: unsync'DLI*/} else {  	throw new ArgumentOutOfRangeException ("tagVersion"' tagVersion' "Unknown tag version");  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameHeader.cs,GetBytes,The following statement contains a magic number: if (tagVersion == ID3v2TagVersion.ID3v22) {  	if (frameIDBytes.Length != 3)  		throw new ArgumentException (String.Format ("FrameID must be 3 bytes from ID3v2.2 ({0} bytes passed)"' frameIDBytes.Length));  	tmpRawData = new byte[6];  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = (byte)((_frameSizeExcludingAdditions >> 16) & 0xFF);  	tmpRawData [4] = (byte)((_frameSizeExcludingAdditions >> 8) & 0xFF);  	tmpRawData [5] = (byte)(_frameSizeExcludingAdditions & 0xFF);  } else if (tagVersion == ID3v2TagVersion.ID3v23) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x80 : 0) + (_isFileAlterPreservation ? 0x40 : 0) + (_isReadOnly ? 0x20 : 0));  	byte tmpByte2 = (byte)((_isCompressed ? 0x80 : 0) + (_encryptionMethod != null ? 0x40 : 0) + (_groupingIdentity != null ? 0x20 : 0));  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 24) & 0xFF);  	tmpRawData [5] = (byte)((tmpFrameSize >> 16) & 0xFF);  	tmpRawData [6] = (byte)((tmpFrameSize >> 8) & 0xFF);  	tmpRawData [7] = (byte)(tmpFrameSize & 0xFF);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition] = _groupingIdentity.Value;  } else if (tagVersion == ID3v2TagVersion.ID3v24) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x40 : 0) + (_isFileAlterPreservation ? 0x20 : 0) + (_isReadOnly ? 0x10 : 0));  	byte tmpByte2 = (byte)((_groupingIdentity != null ? 0x40 : 0) + (_isCompressed ? 0x08 : 0) + (_encryptionMethod != null ? 0x04 : 0)/* +                                   (false Unsynchronization ? 0x02 : 0) +                                   (false Data length indicator ? 0x01 : 0)*/);  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	/*TODO: unsync'DLI*/int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	// Note: ID3v2.4 uses sync safe frame sizes  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 21) & 0x7F);  	tmpRawData [5] = (byte)((tmpFrameSize >> 14) & 0x7F);  	tmpRawData [6] = (byte)((tmpFrameSize >> 7) & 0x7F);  	tmpRawData [7] = (byte)(tmpFrameSize & 0x7F);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition++] = _groupingIdentity.Value;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	/*TODO: unsync'DLI*/} else {  	throw new ArgumentOutOfRangeException ("tagVersion"' tagVersion' "Unknown tag version");  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameHeader.cs,GetBytes,The following statement contains a magic number: if (tagVersion == ID3v2TagVersion.ID3v22) {  	if (frameIDBytes.Length != 3)  		throw new ArgumentException (String.Format ("FrameID must be 3 bytes from ID3v2.2 ({0} bytes passed)"' frameIDBytes.Length));  	tmpRawData = new byte[6];  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = (byte)((_frameSizeExcludingAdditions >> 16) & 0xFF);  	tmpRawData [4] = (byte)((_frameSizeExcludingAdditions >> 8) & 0xFF);  	tmpRawData [5] = (byte)(_frameSizeExcludingAdditions & 0xFF);  } else if (tagVersion == ID3v2TagVersion.ID3v23) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x80 : 0) + (_isFileAlterPreservation ? 0x40 : 0) + (_isReadOnly ? 0x20 : 0));  	byte tmpByte2 = (byte)((_isCompressed ? 0x80 : 0) + (_encryptionMethod != null ? 0x40 : 0) + (_groupingIdentity != null ? 0x20 : 0));  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 24) & 0xFF);  	tmpRawData [5] = (byte)((tmpFrameSize >> 16) & 0xFF);  	tmpRawData [6] = (byte)((tmpFrameSize >> 8) & 0xFF);  	tmpRawData [7] = (byte)(tmpFrameSize & 0xFF);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition] = _groupingIdentity.Value;  } else if (tagVersion == ID3v2TagVersion.ID3v24) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x40 : 0) + (_isFileAlterPreservation ? 0x20 : 0) + (_isReadOnly ? 0x10 : 0));  	byte tmpByte2 = (byte)((_groupingIdentity != null ? 0x40 : 0) + (_isCompressed ? 0x08 : 0) + (_encryptionMethod != null ? 0x04 : 0)/* +                                   (false Unsynchronization ? 0x02 : 0) +                                   (false Data length indicator ? 0x01 : 0)*/);  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	/*TODO: unsync'DLI*/int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	// Note: ID3v2.4 uses sync safe frame sizes  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 21) & 0x7F);  	tmpRawData [5] = (byte)((tmpFrameSize >> 14) & 0x7F);  	tmpRawData [6] = (byte)((tmpFrameSize >> 7) & 0x7F);  	tmpRawData [7] = (byte)(tmpFrameSize & 0x7F);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition++] = _groupingIdentity.Value;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	/*TODO: unsync'DLI*/} else {  	throw new ArgumentOutOfRangeException ("tagVersion"' tagVersion' "Unknown tag version");  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameHeader.cs,GetBytes,The following statement contains a magic number: if (tagVersion == ID3v2TagVersion.ID3v22) {  	if (frameIDBytes.Length != 3)  		throw new ArgumentException (String.Format ("FrameID must be 3 bytes from ID3v2.2 ({0} bytes passed)"' frameIDBytes.Length));  	tmpRawData = new byte[6];  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = (byte)((_frameSizeExcludingAdditions >> 16) & 0xFF);  	tmpRawData [4] = (byte)((_frameSizeExcludingAdditions >> 8) & 0xFF);  	tmpRawData [5] = (byte)(_frameSizeExcludingAdditions & 0xFF);  } else if (tagVersion == ID3v2TagVersion.ID3v23) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x80 : 0) + (_isFileAlterPreservation ? 0x40 : 0) + (_isReadOnly ? 0x20 : 0));  	byte tmpByte2 = (byte)((_isCompressed ? 0x80 : 0) + (_encryptionMethod != null ? 0x40 : 0) + (_groupingIdentity != null ? 0x20 : 0));  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 24) & 0xFF);  	tmpRawData [5] = (byte)((tmpFrameSize >> 16) & 0xFF);  	tmpRawData [6] = (byte)((tmpFrameSize >> 8) & 0xFF);  	tmpRawData [7] = (byte)(tmpFrameSize & 0xFF);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition] = _groupingIdentity.Value;  } else if (tagVersion == ID3v2TagVersion.ID3v24) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x40 : 0) + (_isFileAlterPreservation ? 0x20 : 0) + (_isReadOnly ? 0x10 : 0));  	byte tmpByte2 = (byte)((_groupingIdentity != null ? 0x40 : 0) + (_isCompressed ? 0x08 : 0) + (_encryptionMethod != null ? 0x04 : 0)/* +                                   (false Unsynchronization ? 0x02 : 0) +                                   (false Data length indicator ? 0x01 : 0)*/);  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	/*TODO: unsync'DLI*/int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	// Note: ID3v2.4 uses sync safe frame sizes  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 21) & 0x7F);  	tmpRawData [5] = (byte)((tmpFrameSize >> 14) & 0x7F);  	tmpRawData [6] = (byte)((tmpFrameSize >> 7) & 0x7F);  	tmpRawData [7] = (byte)(tmpFrameSize & 0x7F);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition++] = _groupingIdentity.Value;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	/*TODO: unsync'DLI*/} else {  	throw new ArgumentOutOfRangeException ("tagVersion"' tagVersion' "Unknown tag version");  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameHeader.cs,GetBytes,The following statement contains a magic number: if (tagVersion == ID3v2TagVersion.ID3v22) {  	if (frameIDBytes.Length != 3)  		throw new ArgumentException (String.Format ("FrameID must be 3 bytes from ID3v2.2 ({0} bytes passed)"' frameIDBytes.Length));  	tmpRawData = new byte[6];  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = (byte)((_frameSizeExcludingAdditions >> 16) & 0xFF);  	tmpRawData [4] = (byte)((_frameSizeExcludingAdditions >> 8) & 0xFF);  	tmpRawData [5] = (byte)(_frameSizeExcludingAdditions & 0xFF);  } else if (tagVersion == ID3v2TagVersion.ID3v23) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x80 : 0) + (_isFileAlterPreservation ? 0x40 : 0) + (_isReadOnly ? 0x20 : 0));  	byte tmpByte2 = (byte)((_isCompressed ? 0x80 : 0) + (_encryptionMethod != null ? 0x40 : 0) + (_groupingIdentity != null ? 0x20 : 0));  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 24) & 0xFF);  	tmpRawData [5] = (byte)((tmpFrameSize >> 16) & 0xFF);  	tmpRawData [6] = (byte)((tmpFrameSize >> 8) & 0xFF);  	tmpRawData [7] = (byte)(tmpFrameSize & 0xFF);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition] = _groupingIdentity.Value;  } else if (tagVersion == ID3v2TagVersion.ID3v24) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x40 : 0) + (_isFileAlterPreservation ? 0x20 : 0) + (_isReadOnly ? 0x10 : 0));  	byte tmpByte2 = (byte)((_groupingIdentity != null ? 0x40 : 0) + (_isCompressed ? 0x08 : 0) + (_encryptionMethod != null ? 0x04 : 0)/* +                                   (false Unsynchronization ? 0x02 : 0) +                                   (false Data length indicator ? 0x01 : 0)*/);  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	/*TODO: unsync'DLI*/int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	// Note: ID3v2.4 uses sync safe frame sizes  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 21) & 0x7F);  	tmpRawData [5] = (byte)((tmpFrameSize >> 14) & 0x7F);  	tmpRawData [6] = (byte)((tmpFrameSize >> 7) & 0x7F);  	tmpRawData [7] = (byte)(tmpFrameSize & 0x7F);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition++] = _groupingIdentity.Value;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	/*TODO: unsync'DLI*/} else {  	throw new ArgumentOutOfRangeException ("tagVersion"' tagVersion' "Unknown tag version");  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameHeader.cs,GetBytes,The following statement contains a magic number: if (tagVersion == ID3v2TagVersion.ID3v22) {  	if (frameIDBytes.Length != 3)  		throw new ArgumentException (String.Format ("FrameID must be 3 bytes from ID3v2.2 ({0} bytes passed)"' frameIDBytes.Length));  	tmpRawData = new byte[6];  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = (byte)((_frameSizeExcludingAdditions >> 16) & 0xFF);  	tmpRawData [4] = (byte)((_frameSizeExcludingAdditions >> 8) & 0xFF);  	tmpRawData [5] = (byte)(_frameSizeExcludingAdditions & 0xFF);  } else if (tagVersion == ID3v2TagVersion.ID3v23) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x80 : 0) + (_isFileAlterPreservation ? 0x40 : 0) + (_isReadOnly ? 0x20 : 0));  	byte tmpByte2 = (byte)((_isCompressed ? 0x80 : 0) + (_encryptionMethod != null ? 0x40 : 0) + (_groupingIdentity != null ? 0x20 : 0));  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 24) & 0xFF);  	tmpRawData [5] = (byte)((tmpFrameSize >> 16) & 0xFF);  	tmpRawData [6] = (byte)((tmpFrameSize >> 8) & 0xFF);  	tmpRawData [7] = (byte)(tmpFrameSize & 0xFF);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition] = _groupingIdentity.Value;  } else if (tagVersion == ID3v2TagVersion.ID3v24) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x40 : 0) + (_isFileAlterPreservation ? 0x20 : 0) + (_isReadOnly ? 0x10 : 0));  	byte tmpByte2 = (byte)((_groupingIdentity != null ? 0x40 : 0) + (_isCompressed ? 0x08 : 0) + (_encryptionMethod != null ? 0x04 : 0)/* +                                   (false Unsynchronization ? 0x02 : 0) +                                   (false Data length indicator ? 0x01 : 0)*/);  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	/*TODO: unsync'DLI*/int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	// Note: ID3v2.4 uses sync safe frame sizes  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 21) & 0x7F);  	tmpRawData [5] = (byte)((tmpFrameSize >> 14) & 0x7F);  	tmpRawData [6] = (byte)((tmpFrameSize >> 7) & 0x7F);  	tmpRawData [7] = (byte)(tmpFrameSize & 0x7F);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition++] = _groupingIdentity.Value;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	/*TODO: unsync'DLI*/} else {  	throw new ArgumentOutOfRangeException ("tagVersion"' tagVersion' "Unknown tag version");  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameHeader.cs,GetBytes,The following statement contains a magic number: if (tagVersion == ID3v2TagVersion.ID3v22) {  	if (frameIDBytes.Length != 3)  		throw new ArgumentException (String.Format ("FrameID must be 3 bytes from ID3v2.2 ({0} bytes passed)"' frameIDBytes.Length));  	tmpRawData = new byte[6];  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = (byte)((_frameSizeExcludingAdditions >> 16) & 0xFF);  	tmpRawData [4] = (byte)((_frameSizeExcludingAdditions >> 8) & 0xFF);  	tmpRawData [5] = (byte)(_frameSizeExcludingAdditions & 0xFF);  } else if (tagVersion == ID3v2TagVersion.ID3v23) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x80 : 0) + (_isFileAlterPreservation ? 0x40 : 0) + (_isReadOnly ? 0x20 : 0));  	byte tmpByte2 = (byte)((_isCompressed ? 0x80 : 0) + (_encryptionMethod != null ? 0x40 : 0) + (_groupingIdentity != null ? 0x20 : 0));  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 24) & 0xFF);  	tmpRawData [5] = (byte)((tmpFrameSize >> 16) & 0xFF);  	tmpRawData [6] = (byte)((tmpFrameSize >> 8) & 0xFF);  	tmpRawData [7] = (byte)(tmpFrameSize & 0xFF);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition] = _groupingIdentity.Value;  } else if (tagVersion == ID3v2TagVersion.ID3v24) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x40 : 0) + (_isFileAlterPreservation ? 0x20 : 0) + (_isReadOnly ? 0x10 : 0));  	byte tmpByte2 = (byte)((_groupingIdentity != null ? 0x40 : 0) + (_isCompressed ? 0x08 : 0) + (_encryptionMethod != null ? 0x04 : 0)/* +                                   (false Unsynchronization ? 0x02 : 0) +                                   (false Data length indicator ? 0x01 : 0)*/);  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	/*TODO: unsync'DLI*/int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	// Note: ID3v2.4 uses sync safe frame sizes  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 21) & 0x7F);  	tmpRawData [5] = (byte)((tmpFrameSize >> 14) & 0x7F);  	tmpRawData [6] = (byte)((tmpFrameSize >> 7) & 0x7F);  	tmpRawData [7] = (byte)(tmpFrameSize & 0x7F);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition++] = _groupingIdentity.Value;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	/*TODO: unsync'DLI*/} else {  	throw new ArgumentOutOfRangeException ("tagVersion"' tagVersion' "Unknown tag version");  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameHeader.cs,GetBytes,The following statement contains a magic number: if (tagVersion == ID3v2TagVersion.ID3v22) {  	if (frameIDBytes.Length != 3)  		throw new ArgumentException (String.Format ("FrameID must be 3 bytes from ID3v2.2 ({0} bytes passed)"' frameIDBytes.Length));  	tmpRawData = new byte[6];  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = (byte)((_frameSizeExcludingAdditions >> 16) & 0xFF);  	tmpRawData [4] = (byte)((_frameSizeExcludingAdditions >> 8) & 0xFF);  	tmpRawData [5] = (byte)(_frameSizeExcludingAdditions & 0xFF);  } else if (tagVersion == ID3v2TagVersion.ID3v23) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x80 : 0) + (_isFileAlterPreservation ? 0x40 : 0) + (_isReadOnly ? 0x20 : 0));  	byte tmpByte2 = (byte)((_isCompressed ? 0x80 : 0) + (_encryptionMethod != null ? 0x40 : 0) + (_groupingIdentity != null ? 0x20 : 0));  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 24) & 0xFF);  	tmpRawData [5] = (byte)((tmpFrameSize >> 16) & 0xFF);  	tmpRawData [6] = (byte)((tmpFrameSize >> 8) & 0xFF);  	tmpRawData [7] = (byte)(tmpFrameSize & 0xFF);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition] = _groupingIdentity.Value;  } else if (tagVersion == ID3v2TagVersion.ID3v24) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x40 : 0) + (_isFileAlterPreservation ? 0x20 : 0) + (_isReadOnly ? 0x10 : 0));  	byte tmpByte2 = (byte)((_groupingIdentity != null ? 0x40 : 0) + (_isCompressed ? 0x08 : 0) + (_encryptionMethod != null ? 0x04 : 0)/* +                                   (false Unsynchronization ? 0x02 : 0) +                                   (false Data length indicator ? 0x01 : 0)*/);  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	/*TODO: unsync'DLI*/int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	// Note: ID3v2.4 uses sync safe frame sizes  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 21) & 0x7F);  	tmpRawData [5] = (byte)((tmpFrameSize >> 14) & 0x7F);  	tmpRawData [6] = (byte)((tmpFrameSize >> 7) & 0x7F);  	tmpRawData [7] = (byte)(tmpFrameSize & 0x7F);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition++] = _groupingIdentity.Value;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	/*TODO: unsync'DLI*/} else {  	throw new ArgumentOutOfRangeException ("tagVersion"' tagVersion' "Unknown tag version");  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameHeader.cs,GetBytes,The following statement contains a magic number: if (tagVersion == ID3v2TagVersion.ID3v22) {  	if (frameIDBytes.Length != 3)  		throw new ArgumentException (String.Format ("FrameID must be 3 bytes from ID3v2.2 ({0} bytes passed)"' frameIDBytes.Length));  	tmpRawData = new byte[6];  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = (byte)((_frameSizeExcludingAdditions >> 16) & 0xFF);  	tmpRawData [4] = (byte)((_frameSizeExcludingAdditions >> 8) & 0xFF);  	tmpRawData [5] = (byte)(_frameSizeExcludingAdditions & 0xFF);  } else if (tagVersion == ID3v2TagVersion.ID3v23) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x80 : 0) + (_isFileAlterPreservation ? 0x40 : 0) + (_isReadOnly ? 0x20 : 0));  	byte tmpByte2 = (byte)((_isCompressed ? 0x80 : 0) + (_encryptionMethod != null ? 0x40 : 0) + (_groupingIdentity != null ? 0x20 : 0));  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 24) & 0xFF);  	tmpRawData [5] = (byte)((tmpFrameSize >> 16) & 0xFF);  	tmpRawData [6] = (byte)((tmpFrameSize >> 8) & 0xFF);  	tmpRawData [7] = (byte)(tmpFrameSize & 0xFF);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition] = _groupingIdentity.Value;  } else if (tagVersion == ID3v2TagVersion.ID3v24) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x40 : 0) + (_isFileAlterPreservation ? 0x20 : 0) + (_isReadOnly ? 0x10 : 0));  	byte tmpByte2 = (byte)((_groupingIdentity != null ? 0x40 : 0) + (_isCompressed ? 0x08 : 0) + (_encryptionMethod != null ? 0x04 : 0)/* +                                   (false Unsynchronization ? 0x02 : 0) +                                   (false Data length indicator ? 0x01 : 0)*/);  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	/*TODO: unsync'DLI*/int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	// Note: ID3v2.4 uses sync safe frame sizes  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 21) & 0x7F);  	tmpRawData [5] = (byte)((tmpFrameSize >> 14) & 0x7F);  	tmpRawData [6] = (byte)((tmpFrameSize >> 7) & 0x7F);  	tmpRawData [7] = (byte)(tmpFrameSize & 0x7F);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition++] = _groupingIdentity.Value;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	/*TODO: unsync'DLI*/} else {  	throw new ArgumentOutOfRangeException ("tagVersion"' tagVersion' "Unknown tag version");  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameHeader.cs,GetBytes,The following statement contains a magic number: if (tagVersion == ID3v2TagVersion.ID3v22) {  	if (frameIDBytes.Length != 3)  		throw new ArgumentException (String.Format ("FrameID must be 3 bytes from ID3v2.2 ({0} bytes passed)"' frameIDBytes.Length));  	tmpRawData = new byte[6];  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = (byte)((_frameSizeExcludingAdditions >> 16) & 0xFF);  	tmpRawData [4] = (byte)((_frameSizeExcludingAdditions >> 8) & 0xFF);  	tmpRawData [5] = (byte)(_frameSizeExcludingAdditions & 0xFF);  } else if (tagVersion == ID3v2TagVersion.ID3v23) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x80 : 0) + (_isFileAlterPreservation ? 0x40 : 0) + (_isReadOnly ? 0x20 : 0));  	byte tmpByte2 = (byte)((_isCompressed ? 0x80 : 0) + (_encryptionMethod != null ? 0x40 : 0) + (_groupingIdentity != null ? 0x20 : 0));  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 24) & 0xFF);  	tmpRawData [5] = (byte)((tmpFrameSize >> 16) & 0xFF);  	tmpRawData [6] = (byte)((tmpFrameSize >> 8) & 0xFF);  	tmpRawData [7] = (byte)(tmpFrameSize & 0xFF);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition] = _groupingIdentity.Value;  } else if (tagVersion == ID3v2TagVersion.ID3v24) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x40 : 0) + (_isFileAlterPreservation ? 0x20 : 0) + (_isReadOnly ? 0x10 : 0));  	byte tmpByte2 = (byte)((_groupingIdentity != null ? 0x40 : 0) + (_isCompressed ? 0x08 : 0) + (_encryptionMethod != null ? 0x04 : 0)/* +                                   (false Unsynchronization ? 0x02 : 0) +                                   (false Data length indicator ? 0x01 : 0)*/);  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	/*TODO: unsync'DLI*/int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	// Note: ID3v2.4 uses sync safe frame sizes  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 21) & 0x7F);  	tmpRawData [5] = (byte)((tmpFrameSize >> 14) & 0x7F);  	tmpRawData [6] = (byte)((tmpFrameSize >> 7) & 0x7F);  	tmpRawData [7] = (byte)(tmpFrameSize & 0x7F);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition++] = _groupingIdentity.Value;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	/*TODO: unsync'DLI*/} else {  	throw new ArgumentOutOfRangeException ("tagVersion"' tagVersion' "Unknown tag version");  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameHeader.cs,GetBytes,The following statement contains a magic number: if (tagVersion == ID3v2TagVersion.ID3v22) {  	if (frameIDBytes.Length != 3)  		throw new ArgumentException (String.Format ("FrameID must be 3 bytes from ID3v2.2 ({0} bytes passed)"' frameIDBytes.Length));  	tmpRawData = new byte[6];  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = (byte)((_frameSizeExcludingAdditions >> 16) & 0xFF);  	tmpRawData [4] = (byte)((_frameSizeExcludingAdditions >> 8) & 0xFF);  	tmpRawData [5] = (byte)(_frameSizeExcludingAdditions & 0xFF);  } else if (tagVersion == ID3v2TagVersion.ID3v23) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x80 : 0) + (_isFileAlterPreservation ? 0x40 : 0) + (_isReadOnly ? 0x20 : 0));  	byte tmpByte2 = (byte)((_isCompressed ? 0x80 : 0) + (_encryptionMethod != null ? 0x40 : 0) + (_groupingIdentity != null ? 0x20 : 0));  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 24) & 0xFF);  	tmpRawData [5] = (byte)((tmpFrameSize >> 16) & 0xFF);  	tmpRawData [6] = (byte)((tmpFrameSize >> 8) & 0xFF);  	tmpRawData [7] = (byte)(tmpFrameSize & 0xFF);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition] = _groupingIdentity.Value;  } else if (tagVersion == ID3v2TagVersion.ID3v24) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x40 : 0) + (_isFileAlterPreservation ? 0x20 : 0) + (_isReadOnly ? 0x10 : 0));  	byte tmpByte2 = (byte)((_groupingIdentity != null ? 0x40 : 0) + (_isCompressed ? 0x08 : 0) + (_encryptionMethod != null ? 0x04 : 0)/* +                                   (false Unsynchronization ? 0x02 : 0) +                                   (false Data length indicator ? 0x01 : 0)*/);  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	/*TODO: unsync'DLI*/int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	// Note: ID3v2.4 uses sync safe frame sizes  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 21) & 0x7F);  	tmpRawData [5] = (byte)((tmpFrameSize >> 14) & 0x7F);  	tmpRawData [6] = (byte)((tmpFrameSize >> 7) & 0x7F);  	tmpRawData [7] = (byte)(tmpFrameSize & 0x7F);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition++] = _groupingIdentity.Value;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	/*TODO: unsync'DLI*/} else {  	throw new ArgumentOutOfRangeException ("tagVersion"' tagVersion' "Unknown tag version");  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameHeader.cs,GetBytes,The following statement contains a magic number: if (tagVersion == ID3v2TagVersion.ID3v22) {  	if (frameIDBytes.Length != 3)  		throw new ArgumentException (String.Format ("FrameID must be 3 bytes from ID3v2.2 ({0} bytes passed)"' frameIDBytes.Length));  	tmpRawData = new byte[6];  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = (byte)((_frameSizeExcludingAdditions >> 16) & 0xFF);  	tmpRawData [4] = (byte)((_frameSizeExcludingAdditions >> 8) & 0xFF);  	tmpRawData [5] = (byte)(_frameSizeExcludingAdditions & 0xFF);  } else if (tagVersion == ID3v2TagVersion.ID3v23) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x80 : 0) + (_isFileAlterPreservation ? 0x40 : 0) + (_isReadOnly ? 0x20 : 0));  	byte tmpByte2 = (byte)((_isCompressed ? 0x80 : 0) + (_encryptionMethod != null ? 0x40 : 0) + (_groupingIdentity != null ? 0x20 : 0));  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 24) & 0xFF);  	tmpRawData [5] = (byte)((tmpFrameSize >> 16) & 0xFF);  	tmpRawData [6] = (byte)((tmpFrameSize >> 8) & 0xFF);  	tmpRawData [7] = (byte)(tmpFrameSize & 0xFF);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition] = _groupingIdentity.Value;  } else if (tagVersion == ID3v2TagVersion.ID3v24) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x40 : 0) + (_isFileAlterPreservation ? 0x20 : 0) + (_isReadOnly ? 0x10 : 0));  	byte tmpByte2 = (byte)((_groupingIdentity != null ? 0x40 : 0) + (_isCompressed ? 0x08 : 0) + (_encryptionMethod != null ? 0x04 : 0)/* +                                   (false Unsynchronization ? 0x02 : 0) +                                   (false Data length indicator ? 0x01 : 0)*/);  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	/*TODO: unsync'DLI*/int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	// Note: ID3v2.4 uses sync safe frame sizes  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 21) & 0x7F);  	tmpRawData [5] = (byte)((tmpFrameSize >> 14) & 0x7F);  	tmpRawData [6] = (byte)((tmpFrameSize >> 7) & 0x7F);  	tmpRawData [7] = (byte)(tmpFrameSize & 0x7F);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition++] = _groupingIdentity.Value;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	/*TODO: unsync'DLI*/} else {  	throw new ArgumentOutOfRangeException ("tagVersion"' tagVersion' "Unknown tag version");  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameHeader.cs,GetBytes,The following statement contains a magic number: if (tagVersion == ID3v2TagVersion.ID3v22) {  	if (frameIDBytes.Length != 3)  		throw new ArgumentException (String.Format ("FrameID must be 3 bytes from ID3v2.2 ({0} bytes passed)"' frameIDBytes.Length));  	tmpRawData = new byte[6];  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = (byte)((_frameSizeExcludingAdditions >> 16) & 0xFF);  	tmpRawData [4] = (byte)((_frameSizeExcludingAdditions >> 8) & 0xFF);  	tmpRawData [5] = (byte)(_frameSizeExcludingAdditions & 0xFF);  } else if (tagVersion == ID3v2TagVersion.ID3v23) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x80 : 0) + (_isFileAlterPreservation ? 0x40 : 0) + (_isReadOnly ? 0x20 : 0));  	byte tmpByte2 = (byte)((_isCompressed ? 0x80 : 0) + (_encryptionMethod != null ? 0x40 : 0) + (_groupingIdentity != null ? 0x20 : 0));  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 24) & 0xFF);  	tmpRawData [5] = (byte)((tmpFrameSize >> 16) & 0xFF);  	tmpRawData [6] = (byte)((tmpFrameSize >> 8) & 0xFF);  	tmpRawData [7] = (byte)(tmpFrameSize & 0xFF);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition] = _groupingIdentity.Value;  } else if (tagVersion == ID3v2TagVersion.ID3v24) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x40 : 0) + (_isFileAlterPreservation ? 0x20 : 0) + (_isReadOnly ? 0x10 : 0));  	byte tmpByte2 = (byte)((_groupingIdentity != null ? 0x40 : 0) + (_isCompressed ? 0x08 : 0) + (_encryptionMethod != null ? 0x04 : 0)/* +                                   (false Unsynchronization ? 0x02 : 0) +                                   (false Data length indicator ? 0x01 : 0)*/);  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	/*TODO: unsync'DLI*/int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	// Note: ID3v2.4 uses sync safe frame sizes  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 21) & 0x7F);  	tmpRawData [5] = (byte)((tmpFrameSize >> 14) & 0x7F);  	tmpRawData [6] = (byte)((tmpFrameSize >> 7) & 0x7F);  	tmpRawData [7] = (byte)(tmpFrameSize & 0x7F);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition++] = _groupingIdentity.Value;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	/*TODO: unsync'DLI*/} else {  	throw new ArgumentOutOfRangeException ("tagVersion"' tagVersion' "Unknown tag version");  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameHeader.cs,GetBytes,The following statement contains a magic number: if (tagVersion == ID3v2TagVersion.ID3v22) {  	if (frameIDBytes.Length != 3)  		throw new ArgumentException (String.Format ("FrameID must be 3 bytes from ID3v2.2 ({0} bytes passed)"' frameIDBytes.Length));  	tmpRawData = new byte[6];  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = (byte)((_frameSizeExcludingAdditions >> 16) & 0xFF);  	tmpRawData [4] = (byte)((_frameSizeExcludingAdditions >> 8) & 0xFF);  	tmpRawData [5] = (byte)(_frameSizeExcludingAdditions & 0xFF);  } else if (tagVersion == ID3v2TagVersion.ID3v23) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x80 : 0) + (_isFileAlterPreservation ? 0x40 : 0) + (_isReadOnly ? 0x20 : 0));  	byte tmpByte2 = (byte)((_isCompressed ? 0x80 : 0) + (_encryptionMethod != null ? 0x40 : 0) + (_groupingIdentity != null ? 0x20 : 0));  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 24) & 0xFF);  	tmpRawData [5] = (byte)((tmpFrameSize >> 16) & 0xFF);  	tmpRawData [6] = (byte)((tmpFrameSize >> 8) & 0xFF);  	tmpRawData [7] = (byte)(tmpFrameSize & 0xFF);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition] = _groupingIdentity.Value;  } else if (tagVersion == ID3v2TagVersion.ID3v24) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x40 : 0) + (_isFileAlterPreservation ? 0x20 : 0) + (_isReadOnly ? 0x10 : 0));  	byte tmpByte2 = (byte)((_groupingIdentity != null ? 0x40 : 0) + (_isCompressed ? 0x08 : 0) + (_encryptionMethod != null ? 0x04 : 0)/* +                                   (false Unsynchronization ? 0x02 : 0) +                                   (false Data length indicator ? 0x01 : 0)*/);  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	/*TODO: unsync'DLI*/int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	// Note: ID3v2.4 uses sync safe frame sizes  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 21) & 0x7F);  	tmpRawData [5] = (byte)((tmpFrameSize >> 14) & 0x7F);  	tmpRawData [6] = (byte)((tmpFrameSize >> 7) & 0x7F);  	tmpRawData [7] = (byte)(tmpFrameSize & 0x7F);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition++] = _groupingIdentity.Value;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	/*TODO: unsync'DLI*/} else {  	throw new ArgumentOutOfRangeException ("tagVersion"' tagVersion' "Unknown tag version");  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameHeader.cs,GetBytes,The following statement contains a magic number: if (tagVersion == ID3v2TagVersion.ID3v22) {  	if (frameIDBytes.Length != 3)  		throw new ArgumentException (String.Format ("FrameID must be 3 bytes from ID3v2.2 ({0} bytes passed)"' frameIDBytes.Length));  	tmpRawData = new byte[6];  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = (byte)((_frameSizeExcludingAdditions >> 16) & 0xFF);  	tmpRawData [4] = (byte)((_frameSizeExcludingAdditions >> 8) & 0xFF);  	tmpRawData [5] = (byte)(_frameSizeExcludingAdditions & 0xFF);  } else if (tagVersion == ID3v2TagVersion.ID3v23) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x80 : 0) + (_isFileAlterPreservation ? 0x40 : 0) + (_isReadOnly ? 0x20 : 0));  	byte tmpByte2 = (byte)((_isCompressed ? 0x80 : 0) + (_encryptionMethod != null ? 0x40 : 0) + (_groupingIdentity != null ? 0x20 : 0));  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 24) & 0xFF);  	tmpRawData [5] = (byte)((tmpFrameSize >> 16) & 0xFF);  	tmpRawData [6] = (byte)((tmpFrameSize >> 8) & 0xFF);  	tmpRawData [7] = (byte)(tmpFrameSize & 0xFF);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition] = _groupingIdentity.Value;  } else if (tagVersion == ID3v2TagVersion.ID3v24) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x40 : 0) + (_isFileAlterPreservation ? 0x20 : 0) + (_isReadOnly ? 0x10 : 0));  	byte tmpByte2 = (byte)((_groupingIdentity != null ? 0x40 : 0) + (_isCompressed ? 0x08 : 0) + (_encryptionMethod != null ? 0x04 : 0)/* +                                   (false Unsynchronization ? 0x02 : 0) +                                   (false Data length indicator ? 0x01 : 0)*/);  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	/*TODO: unsync'DLI*/int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	// Note: ID3v2.4 uses sync safe frame sizes  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 21) & 0x7F);  	tmpRawData [5] = (byte)((tmpFrameSize >> 14) & 0x7F);  	tmpRawData [6] = (byte)((tmpFrameSize >> 7) & 0x7F);  	tmpRawData [7] = (byte)(tmpFrameSize & 0x7F);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition++] = _groupingIdentity.Value;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	/*TODO: unsync'DLI*/} else {  	throw new ArgumentOutOfRangeException ("tagVersion"' tagVersion' "Unknown tag version");  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameHeader.cs,GetBytes,The following statement contains a magic number: if (tagVersion == ID3v2TagVersion.ID3v22) {  	if (frameIDBytes.Length != 3)  		throw new ArgumentException (String.Format ("FrameID must be 3 bytes from ID3v2.2 ({0} bytes passed)"' frameIDBytes.Length));  	tmpRawData = new byte[6];  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = (byte)((_frameSizeExcludingAdditions >> 16) & 0xFF);  	tmpRawData [4] = (byte)((_frameSizeExcludingAdditions >> 8) & 0xFF);  	tmpRawData [5] = (byte)(_frameSizeExcludingAdditions & 0xFF);  } else if (tagVersion == ID3v2TagVersion.ID3v23) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x80 : 0) + (_isFileAlterPreservation ? 0x40 : 0) + (_isReadOnly ? 0x20 : 0));  	byte tmpByte2 = (byte)((_isCompressed ? 0x80 : 0) + (_encryptionMethod != null ? 0x40 : 0) + (_groupingIdentity != null ? 0x20 : 0));  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 24) & 0xFF);  	tmpRawData [5] = (byte)((tmpFrameSize >> 16) & 0xFF);  	tmpRawData [6] = (byte)((tmpFrameSize >> 8) & 0xFF);  	tmpRawData [7] = (byte)(tmpFrameSize & 0xFF);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition] = _groupingIdentity.Value;  } else if (tagVersion == ID3v2TagVersion.ID3v24) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x40 : 0) + (_isFileAlterPreservation ? 0x20 : 0) + (_isReadOnly ? 0x10 : 0));  	byte tmpByte2 = (byte)((_groupingIdentity != null ? 0x40 : 0) + (_isCompressed ? 0x08 : 0) + (_encryptionMethod != null ? 0x04 : 0)/* +                                   (false Unsynchronization ? 0x02 : 0) +                                   (false Data length indicator ? 0x01 : 0)*/);  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	/*TODO: unsync'DLI*/int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	// Note: ID3v2.4 uses sync safe frame sizes  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 21) & 0x7F);  	tmpRawData [5] = (byte)((tmpFrameSize >> 14) & 0x7F);  	tmpRawData [6] = (byte)((tmpFrameSize >> 7) & 0x7F);  	tmpRawData [7] = (byte)(tmpFrameSize & 0x7F);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition++] = _groupingIdentity.Value;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	/*TODO: unsync'DLI*/} else {  	throw new ArgumentOutOfRangeException ("tagVersion"' tagVersion' "Unknown tag version");  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameHeader.cs,GetBytes,The following statement contains a magic number: if (tagVersion == ID3v2TagVersion.ID3v22) {  	if (frameIDBytes.Length != 3)  		throw new ArgumentException (String.Format ("FrameID must be 3 bytes from ID3v2.2 ({0} bytes passed)"' frameIDBytes.Length));  	tmpRawData = new byte[6];  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = (byte)((_frameSizeExcludingAdditions >> 16) & 0xFF);  	tmpRawData [4] = (byte)((_frameSizeExcludingAdditions >> 8) & 0xFF);  	tmpRawData [5] = (byte)(_frameSizeExcludingAdditions & 0xFF);  } else if (tagVersion == ID3v2TagVersion.ID3v23) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x80 : 0) + (_isFileAlterPreservation ? 0x40 : 0) + (_isReadOnly ? 0x20 : 0));  	byte tmpByte2 = (byte)((_isCompressed ? 0x80 : 0) + (_encryptionMethod != null ? 0x40 : 0) + (_groupingIdentity != null ? 0x20 : 0));  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 24) & 0xFF);  	tmpRawData [5] = (byte)((tmpFrameSize >> 16) & 0xFF);  	tmpRawData [6] = (byte)((tmpFrameSize >> 8) & 0xFF);  	tmpRawData [7] = (byte)(tmpFrameSize & 0xFF);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition] = _groupingIdentity.Value;  } else if (tagVersion == ID3v2TagVersion.ID3v24) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x40 : 0) + (_isFileAlterPreservation ? 0x20 : 0) + (_isReadOnly ? 0x10 : 0));  	byte tmpByte2 = (byte)((_groupingIdentity != null ? 0x40 : 0) + (_isCompressed ? 0x08 : 0) + (_encryptionMethod != null ? 0x04 : 0)/* +                                   (false Unsynchronization ? 0x02 : 0) +                                   (false Data length indicator ? 0x01 : 0)*/);  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	/*TODO: unsync'DLI*/int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	// Note: ID3v2.4 uses sync safe frame sizes  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 21) & 0x7F);  	tmpRawData [5] = (byte)((tmpFrameSize >> 14) & 0x7F);  	tmpRawData [6] = (byte)((tmpFrameSize >> 7) & 0x7F);  	tmpRawData [7] = (byte)(tmpFrameSize & 0x7F);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition++] = _groupingIdentity.Value;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	/*TODO: unsync'DLI*/} else {  	throw new ArgumentOutOfRangeException ("tagVersion"' tagVersion' "Unknown tag version");  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameHeader.cs,GetBytes,The following statement contains a magic number: if (tagVersion == ID3v2TagVersion.ID3v22) {  	if (frameIDBytes.Length != 3)  		throw new ArgumentException (String.Format ("FrameID must be 3 bytes from ID3v2.2 ({0} bytes passed)"' frameIDBytes.Length));  	tmpRawData = new byte[6];  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = (byte)((_frameSizeExcludingAdditions >> 16) & 0xFF);  	tmpRawData [4] = (byte)((_frameSizeExcludingAdditions >> 8) & 0xFF);  	tmpRawData [5] = (byte)(_frameSizeExcludingAdditions & 0xFF);  } else if (tagVersion == ID3v2TagVersion.ID3v23) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x80 : 0) + (_isFileAlterPreservation ? 0x40 : 0) + (_isReadOnly ? 0x20 : 0));  	byte tmpByte2 = (byte)((_isCompressed ? 0x80 : 0) + (_encryptionMethod != null ? 0x40 : 0) + (_groupingIdentity != null ? 0x20 : 0));  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 24) & 0xFF);  	tmpRawData [5] = (byte)((tmpFrameSize >> 16) & 0xFF);  	tmpRawData [6] = (byte)((tmpFrameSize >> 8) & 0xFF);  	tmpRawData [7] = (byte)(tmpFrameSize & 0xFF);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition] = _groupingIdentity.Value;  } else if (tagVersion == ID3v2TagVersion.ID3v24) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x40 : 0) + (_isFileAlterPreservation ? 0x20 : 0) + (_isReadOnly ? 0x10 : 0));  	byte tmpByte2 = (byte)((_groupingIdentity != null ? 0x40 : 0) + (_isCompressed ? 0x08 : 0) + (_encryptionMethod != null ? 0x04 : 0)/* +                                   (false Unsynchronization ? 0x02 : 0) +                                   (false Data length indicator ? 0x01 : 0)*/);  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	/*TODO: unsync'DLI*/int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	// Note: ID3v2.4 uses sync safe frame sizes  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 21) & 0x7F);  	tmpRawData [5] = (byte)((tmpFrameSize >> 14) & 0x7F);  	tmpRawData [6] = (byte)((tmpFrameSize >> 7) & 0x7F);  	tmpRawData [7] = (byte)(tmpFrameSize & 0x7F);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition++] = _groupingIdentity.Value;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	/*TODO: unsync'DLI*/} else {  	throw new ArgumentOutOfRangeException ("tagVersion"' tagVersion' "Unknown tag version");  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameHeader.cs,GetBytes,The following statement contains a magic number: if (tagVersion == ID3v2TagVersion.ID3v22) {  	if (frameIDBytes.Length != 3)  		throw new ArgumentException (String.Format ("FrameID must be 3 bytes from ID3v2.2 ({0} bytes passed)"' frameIDBytes.Length));  	tmpRawData = new byte[6];  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = (byte)((_frameSizeExcludingAdditions >> 16) & 0xFF);  	tmpRawData [4] = (byte)((_frameSizeExcludingAdditions >> 8) & 0xFF);  	tmpRawData [5] = (byte)(_frameSizeExcludingAdditions & 0xFF);  } else if (tagVersion == ID3v2TagVersion.ID3v23) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x80 : 0) + (_isFileAlterPreservation ? 0x40 : 0) + (_isReadOnly ? 0x20 : 0));  	byte tmpByte2 = (byte)((_isCompressed ? 0x80 : 0) + (_encryptionMethod != null ? 0x40 : 0) + (_groupingIdentity != null ? 0x20 : 0));  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 24) & 0xFF);  	tmpRawData [5] = (byte)((tmpFrameSize >> 16) & 0xFF);  	tmpRawData [6] = (byte)((tmpFrameSize >> 8) & 0xFF);  	tmpRawData [7] = (byte)(tmpFrameSize & 0xFF);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition] = _groupingIdentity.Value;  } else if (tagVersion == ID3v2TagVersion.ID3v24) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x40 : 0) + (_isFileAlterPreservation ? 0x20 : 0) + (_isReadOnly ? 0x10 : 0));  	byte tmpByte2 = (byte)((_groupingIdentity != null ? 0x40 : 0) + (_isCompressed ? 0x08 : 0) + (_encryptionMethod != null ? 0x04 : 0)/* +                                   (false Unsynchronization ? 0x02 : 0) +                                   (false Data length indicator ? 0x01 : 0)*/);  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	/*TODO: unsync'DLI*/int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	// Note: ID3v2.4 uses sync safe frame sizes  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 21) & 0x7F);  	tmpRawData [5] = (byte)((tmpFrameSize >> 14) & 0x7F);  	tmpRawData [6] = (byte)((tmpFrameSize >> 7) & 0x7F);  	tmpRawData [7] = (byte)(tmpFrameSize & 0x7F);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition++] = _groupingIdentity.Value;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	/*TODO: unsync'DLI*/} else {  	throw new ArgumentOutOfRangeException ("tagVersion"' tagVersion' "Unknown tag version");  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameHeader.cs,GetBytes,The following statement contains a magic number: if (tagVersion == ID3v2TagVersion.ID3v22) {  	if (frameIDBytes.Length != 3)  		throw new ArgumentException (String.Format ("FrameID must be 3 bytes from ID3v2.2 ({0} bytes passed)"' frameIDBytes.Length));  	tmpRawData = new byte[6];  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = (byte)((_frameSizeExcludingAdditions >> 16) & 0xFF);  	tmpRawData [4] = (byte)((_frameSizeExcludingAdditions >> 8) & 0xFF);  	tmpRawData [5] = (byte)(_frameSizeExcludingAdditions & 0xFF);  } else if (tagVersion == ID3v2TagVersion.ID3v23) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x80 : 0) + (_isFileAlterPreservation ? 0x40 : 0) + (_isReadOnly ? 0x20 : 0));  	byte tmpByte2 = (byte)((_isCompressed ? 0x80 : 0) + (_encryptionMethod != null ? 0x40 : 0) + (_groupingIdentity != null ? 0x20 : 0));  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 24) & 0xFF);  	tmpRawData [5] = (byte)((tmpFrameSize >> 16) & 0xFF);  	tmpRawData [6] = (byte)((tmpFrameSize >> 8) & 0xFF);  	tmpRawData [7] = (byte)(tmpFrameSize & 0xFF);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition] = _groupingIdentity.Value;  } else if (tagVersion == ID3v2TagVersion.ID3v24) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x40 : 0) + (_isFileAlterPreservation ? 0x20 : 0) + (_isReadOnly ? 0x10 : 0));  	byte tmpByte2 = (byte)((_groupingIdentity != null ? 0x40 : 0) + (_isCompressed ? 0x08 : 0) + (_encryptionMethod != null ? 0x04 : 0)/* +                                   (false Unsynchronization ? 0x02 : 0) +                                   (false Data length indicator ? 0x01 : 0)*/);  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	/*TODO: unsync'DLI*/int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	// Note: ID3v2.4 uses sync safe frame sizes  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 21) & 0x7F);  	tmpRawData [5] = (byte)((tmpFrameSize >> 14) & 0x7F);  	tmpRawData [6] = (byte)((tmpFrameSize >> 7) & 0x7F);  	tmpRawData [7] = (byte)(tmpFrameSize & 0x7F);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition++] = _groupingIdentity.Value;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	/*TODO: unsync'DLI*/} else {  	throw new ArgumentOutOfRangeException ("tagVersion"' tagVersion' "Unknown tag version");  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameHeader.cs,GetBytes,The following statement contains a magic number: if (tagVersion == ID3v2TagVersion.ID3v22) {  	if (frameIDBytes.Length != 3)  		throw new ArgumentException (String.Format ("FrameID must be 3 bytes from ID3v2.2 ({0} bytes passed)"' frameIDBytes.Length));  	tmpRawData = new byte[6];  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = (byte)((_frameSizeExcludingAdditions >> 16) & 0xFF);  	tmpRawData [4] = (byte)((_frameSizeExcludingAdditions >> 8) & 0xFF);  	tmpRawData [5] = (byte)(_frameSizeExcludingAdditions & 0xFF);  } else if (tagVersion == ID3v2TagVersion.ID3v23) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x80 : 0) + (_isFileAlterPreservation ? 0x40 : 0) + (_isReadOnly ? 0x20 : 0));  	byte tmpByte2 = (byte)((_isCompressed ? 0x80 : 0) + (_encryptionMethod != null ? 0x40 : 0) + (_groupingIdentity != null ? 0x20 : 0));  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 24) & 0xFF);  	tmpRawData [5] = (byte)((tmpFrameSize >> 16) & 0xFF);  	tmpRawData [6] = (byte)((tmpFrameSize >> 8) & 0xFF);  	tmpRawData [7] = (byte)(tmpFrameSize & 0xFF);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition] = _groupingIdentity.Value;  } else if (tagVersion == ID3v2TagVersion.ID3v24) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x40 : 0) + (_isFileAlterPreservation ? 0x20 : 0) + (_isReadOnly ? 0x10 : 0));  	byte tmpByte2 = (byte)((_groupingIdentity != null ? 0x40 : 0) + (_isCompressed ? 0x08 : 0) + (_encryptionMethod != null ? 0x04 : 0)/* +                                   (false Unsynchronization ? 0x02 : 0) +                                   (false Data length indicator ? 0x01 : 0)*/);  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	/*TODO: unsync'DLI*/int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	// Note: ID3v2.4 uses sync safe frame sizes  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 21) & 0x7F);  	tmpRawData [5] = (byte)((tmpFrameSize >> 14) & 0x7F);  	tmpRawData [6] = (byte)((tmpFrameSize >> 7) & 0x7F);  	tmpRawData [7] = (byte)(tmpFrameSize & 0x7F);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition++] = _groupingIdentity.Value;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	/*TODO: unsync'DLI*/} else {  	throw new ArgumentOutOfRangeException ("tagVersion"' tagVersion' "Unknown tag version");  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameHeader.cs,GetBytes,The following statement contains a magic number: if (tagVersion == ID3v2TagVersion.ID3v22) {  	if (frameIDBytes.Length != 3)  		throw new ArgumentException (String.Format ("FrameID must be 3 bytes from ID3v2.2 ({0} bytes passed)"' frameIDBytes.Length));  	tmpRawData = new byte[6];  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = (byte)((_frameSizeExcludingAdditions >> 16) & 0xFF);  	tmpRawData [4] = (byte)((_frameSizeExcludingAdditions >> 8) & 0xFF);  	tmpRawData [5] = (byte)(_frameSizeExcludingAdditions & 0xFF);  } else if (tagVersion == ID3v2TagVersion.ID3v23) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x80 : 0) + (_isFileAlterPreservation ? 0x40 : 0) + (_isReadOnly ? 0x20 : 0));  	byte tmpByte2 = (byte)((_isCompressed ? 0x80 : 0) + (_encryptionMethod != null ? 0x40 : 0) + (_groupingIdentity != null ? 0x20 : 0));  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 24) & 0xFF);  	tmpRawData [5] = (byte)((tmpFrameSize >> 16) & 0xFF);  	tmpRawData [6] = (byte)((tmpFrameSize >> 8) & 0xFF);  	tmpRawData [7] = (byte)(tmpFrameSize & 0xFF);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition] = _groupingIdentity.Value;  } else if (tagVersion == ID3v2TagVersion.ID3v24) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x40 : 0) + (_isFileAlterPreservation ? 0x20 : 0) + (_isReadOnly ? 0x10 : 0));  	byte tmpByte2 = (byte)((_groupingIdentity != null ? 0x40 : 0) + (_isCompressed ? 0x08 : 0) + (_encryptionMethod != null ? 0x04 : 0)/* +                                   (false Unsynchronization ? 0x02 : 0) +                                   (false Data length indicator ? 0x01 : 0)*/);  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	/*TODO: unsync'DLI*/int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	// Note: ID3v2.4 uses sync safe frame sizes  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 21) & 0x7F);  	tmpRawData [5] = (byte)((tmpFrameSize >> 14) & 0x7F);  	tmpRawData [6] = (byte)((tmpFrameSize >> 7) & 0x7F);  	tmpRawData [7] = (byte)(tmpFrameSize & 0x7F);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition++] = _groupingIdentity.Value;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	/*TODO: unsync'DLI*/} else {  	throw new ArgumentOutOfRangeException ("tagVersion"' tagVersion' "Unknown tag version");  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameHeader.cs,GetBytes,The following statement contains a magic number: if (tagVersion == ID3v2TagVersion.ID3v22) {  	if (frameIDBytes.Length != 3)  		throw new ArgumentException (String.Format ("FrameID must be 3 bytes from ID3v2.2 ({0} bytes passed)"' frameIDBytes.Length));  	tmpRawData = new byte[6];  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = (byte)((_frameSizeExcludingAdditions >> 16) & 0xFF);  	tmpRawData [4] = (byte)((_frameSizeExcludingAdditions >> 8) & 0xFF);  	tmpRawData [5] = (byte)(_frameSizeExcludingAdditions & 0xFF);  } else if (tagVersion == ID3v2TagVersion.ID3v23) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x80 : 0) + (_isFileAlterPreservation ? 0x40 : 0) + (_isReadOnly ? 0x20 : 0));  	byte tmpByte2 = (byte)((_isCompressed ? 0x80 : 0) + (_encryptionMethod != null ? 0x40 : 0) + (_groupingIdentity != null ? 0x20 : 0));  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 24) & 0xFF);  	tmpRawData [5] = (byte)((tmpFrameSize >> 16) & 0xFF);  	tmpRawData [6] = (byte)((tmpFrameSize >> 8) & 0xFF);  	tmpRawData [7] = (byte)(tmpFrameSize & 0xFF);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition] = _groupingIdentity.Value;  } else if (tagVersion == ID3v2TagVersion.ID3v24) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x40 : 0) + (_isFileAlterPreservation ? 0x20 : 0) + (_isReadOnly ? 0x10 : 0));  	byte tmpByte2 = (byte)((_groupingIdentity != null ? 0x40 : 0) + (_isCompressed ? 0x08 : 0) + (_encryptionMethod != null ? 0x04 : 0)/* +                                   (false Unsynchronization ? 0x02 : 0) +                                   (false Data length indicator ? 0x01 : 0)*/);  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	/*TODO: unsync'DLI*/int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	// Note: ID3v2.4 uses sync safe frame sizes  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 21) & 0x7F);  	tmpRawData [5] = (byte)((tmpFrameSize >> 14) & 0x7F);  	tmpRawData [6] = (byte)((tmpFrameSize >> 7) & 0x7F);  	tmpRawData [7] = (byte)(tmpFrameSize & 0x7F);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition++] = _groupingIdentity.Value;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	/*TODO: unsync'DLI*/} else {  	throw new ArgumentOutOfRangeException ("tagVersion"' tagVersion' "Unknown tag version");  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameHeader.cs,GetBytes,The following statement contains a magic number: if (tagVersion == ID3v2TagVersion.ID3v22) {  	if (frameIDBytes.Length != 3)  		throw new ArgumentException (String.Format ("FrameID must be 3 bytes from ID3v2.2 ({0} bytes passed)"' frameIDBytes.Length));  	tmpRawData = new byte[6];  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = (byte)((_frameSizeExcludingAdditions >> 16) & 0xFF);  	tmpRawData [4] = (byte)((_frameSizeExcludingAdditions >> 8) & 0xFF);  	tmpRawData [5] = (byte)(_frameSizeExcludingAdditions & 0xFF);  } else if (tagVersion == ID3v2TagVersion.ID3v23) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x80 : 0) + (_isFileAlterPreservation ? 0x40 : 0) + (_isReadOnly ? 0x20 : 0));  	byte tmpByte2 = (byte)((_isCompressed ? 0x80 : 0) + (_encryptionMethod != null ? 0x40 : 0) + (_groupingIdentity != null ? 0x20 : 0));  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 24) & 0xFF);  	tmpRawData [5] = (byte)((tmpFrameSize >> 16) & 0xFF);  	tmpRawData [6] = (byte)((tmpFrameSize >> 8) & 0xFF);  	tmpRawData [7] = (byte)(tmpFrameSize & 0xFF);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition] = _groupingIdentity.Value;  } else if (tagVersion == ID3v2TagVersion.ID3v24) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x40 : 0) + (_isFileAlterPreservation ? 0x20 : 0) + (_isReadOnly ? 0x10 : 0));  	byte tmpByte2 = (byte)((_groupingIdentity != null ? 0x40 : 0) + (_isCompressed ? 0x08 : 0) + (_encryptionMethod != null ? 0x04 : 0)/* +                                   (false Unsynchronization ? 0x02 : 0) +                                   (false Data length indicator ? 0x01 : 0)*/);  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	/*TODO: unsync'DLI*/int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	// Note: ID3v2.4 uses sync safe frame sizes  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 21) & 0x7F);  	tmpRawData [5] = (byte)((tmpFrameSize >> 14) & 0x7F);  	tmpRawData [6] = (byte)((tmpFrameSize >> 7) & 0x7F);  	tmpRawData [7] = (byte)(tmpFrameSize & 0x7F);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition++] = _groupingIdentity.Value;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	/*TODO: unsync'DLI*/} else {  	throw new ArgumentOutOfRangeException ("tagVersion"' tagVersion' "Unknown tag version");  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameHeader.cs,GetBytes,The following statement contains a magic number: if (tagVersion == ID3v2TagVersion.ID3v22) {  	if (frameIDBytes.Length != 3)  		throw new ArgumentException (String.Format ("FrameID must be 3 bytes from ID3v2.2 ({0} bytes passed)"' frameIDBytes.Length));  	tmpRawData = new byte[6];  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = (byte)((_frameSizeExcludingAdditions >> 16) & 0xFF);  	tmpRawData [4] = (byte)((_frameSizeExcludingAdditions >> 8) & 0xFF);  	tmpRawData [5] = (byte)(_frameSizeExcludingAdditions & 0xFF);  } else if (tagVersion == ID3v2TagVersion.ID3v23) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x80 : 0) + (_isFileAlterPreservation ? 0x40 : 0) + (_isReadOnly ? 0x20 : 0));  	byte tmpByte2 = (byte)((_isCompressed ? 0x80 : 0) + (_encryptionMethod != null ? 0x40 : 0) + (_groupingIdentity != null ? 0x20 : 0));  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 24) & 0xFF);  	tmpRawData [5] = (byte)((tmpFrameSize >> 16) & 0xFF);  	tmpRawData [6] = (byte)((tmpFrameSize >> 8) & 0xFF);  	tmpRawData [7] = (byte)(tmpFrameSize & 0xFF);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition] = _groupingIdentity.Value;  } else if (tagVersion == ID3v2TagVersion.ID3v24) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x40 : 0) + (_isFileAlterPreservation ? 0x20 : 0) + (_isReadOnly ? 0x10 : 0));  	byte tmpByte2 = (byte)((_groupingIdentity != null ? 0x40 : 0) + (_isCompressed ? 0x08 : 0) + (_encryptionMethod != null ? 0x04 : 0)/* +                                   (false Unsynchronization ? 0x02 : 0) +                                   (false Data length indicator ? 0x01 : 0)*/);  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	/*TODO: unsync'DLI*/int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	// Note: ID3v2.4 uses sync safe frame sizes  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 21) & 0x7F);  	tmpRawData [5] = (byte)((tmpFrameSize >> 14) & 0x7F);  	tmpRawData [6] = (byte)((tmpFrameSize >> 7) & 0x7F);  	tmpRawData [7] = (byte)(tmpFrameSize & 0x7F);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition++] = _groupingIdentity.Value;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	/*TODO: unsync'DLI*/} else {  	throw new ArgumentOutOfRangeException ("tagVersion"' tagVersion' "Unknown tag version");  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameHeader.cs,GetBytes,The following statement contains a magic number: if (tagVersion == ID3v2TagVersion.ID3v22) {  	if (frameIDBytes.Length != 3)  		throw new ArgumentException (String.Format ("FrameID must be 3 bytes from ID3v2.2 ({0} bytes passed)"' frameIDBytes.Length));  	tmpRawData = new byte[6];  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = (byte)((_frameSizeExcludingAdditions >> 16) & 0xFF);  	tmpRawData [4] = (byte)((_frameSizeExcludingAdditions >> 8) & 0xFF);  	tmpRawData [5] = (byte)(_frameSizeExcludingAdditions & 0xFF);  } else if (tagVersion == ID3v2TagVersion.ID3v23) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x80 : 0) + (_isFileAlterPreservation ? 0x40 : 0) + (_isReadOnly ? 0x20 : 0));  	byte tmpByte2 = (byte)((_isCompressed ? 0x80 : 0) + (_encryptionMethod != null ? 0x40 : 0) + (_groupingIdentity != null ? 0x20 : 0));  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 24) & 0xFF);  	tmpRawData [5] = (byte)((tmpFrameSize >> 16) & 0xFF);  	tmpRawData [6] = (byte)((tmpFrameSize >> 8) & 0xFF);  	tmpRawData [7] = (byte)(tmpFrameSize & 0xFF);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition] = _groupingIdentity.Value;  } else if (tagVersion == ID3v2TagVersion.ID3v24) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x40 : 0) + (_isFileAlterPreservation ? 0x20 : 0) + (_isReadOnly ? 0x10 : 0));  	byte tmpByte2 = (byte)((_groupingIdentity != null ? 0x40 : 0) + (_isCompressed ? 0x08 : 0) + (_encryptionMethod != null ? 0x04 : 0)/* +                                   (false Unsynchronization ? 0x02 : 0) +                                   (false Data length indicator ? 0x01 : 0)*/);  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	/*TODO: unsync'DLI*/int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	// Note: ID3v2.4 uses sync safe frame sizes  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 21) & 0x7F);  	tmpRawData [5] = (byte)((tmpFrameSize >> 14) & 0x7F);  	tmpRawData [6] = (byte)((tmpFrameSize >> 7) & 0x7F);  	tmpRawData [7] = (byte)(tmpFrameSize & 0x7F);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition++] = _groupingIdentity.Value;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	/*TODO: unsync'DLI*/} else {  	throw new ArgumentOutOfRangeException ("tagVersion"' tagVersion' "Unknown tag version");  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameHeader.cs,GetBytes,The following statement contains a magic number: if (tagVersion == ID3v2TagVersion.ID3v22) {  	if (frameIDBytes.Length != 3)  		throw new ArgumentException (String.Format ("FrameID must be 3 bytes from ID3v2.2 ({0} bytes passed)"' frameIDBytes.Length));  	tmpRawData = new byte[6];  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = (byte)((_frameSizeExcludingAdditions >> 16) & 0xFF);  	tmpRawData [4] = (byte)((_frameSizeExcludingAdditions >> 8) & 0xFF);  	tmpRawData [5] = (byte)(_frameSizeExcludingAdditions & 0xFF);  } else if (tagVersion == ID3v2TagVersion.ID3v23) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x80 : 0) + (_isFileAlterPreservation ? 0x40 : 0) + (_isReadOnly ? 0x20 : 0));  	byte tmpByte2 = (byte)((_isCompressed ? 0x80 : 0) + (_encryptionMethod != null ? 0x40 : 0) + (_groupingIdentity != null ? 0x20 : 0));  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 24) & 0xFF);  	tmpRawData [5] = (byte)((tmpFrameSize >> 16) & 0xFF);  	tmpRawData [6] = (byte)((tmpFrameSize >> 8) & 0xFF);  	tmpRawData [7] = (byte)(tmpFrameSize & 0xFF);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition] = _groupingIdentity.Value;  } else if (tagVersion == ID3v2TagVersion.ID3v24) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x40 : 0) + (_isFileAlterPreservation ? 0x20 : 0) + (_isReadOnly ? 0x10 : 0));  	byte tmpByte2 = (byte)((_groupingIdentity != null ? 0x40 : 0) + (_isCompressed ? 0x08 : 0) + (_encryptionMethod != null ? 0x04 : 0)/* +                                   (false Unsynchronization ? 0x02 : 0) +                                   (false Data length indicator ? 0x01 : 0)*/);  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	/*TODO: unsync'DLI*/int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	// Note: ID3v2.4 uses sync safe frame sizes  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 21) & 0x7F);  	tmpRawData [5] = (byte)((tmpFrameSize >> 14) & 0x7F);  	tmpRawData [6] = (byte)((tmpFrameSize >> 7) & 0x7F);  	tmpRawData [7] = (byte)(tmpFrameSize & 0x7F);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition++] = _groupingIdentity.Value;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	/*TODO: unsync'DLI*/} else {  	throw new ArgumentOutOfRangeException ("tagVersion"' tagVersion' "Unknown tag version");  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameHeader.cs,GetBytes,The following statement contains a magic number: if (tagVersion == ID3v2TagVersion.ID3v22) {  	if (frameIDBytes.Length != 3)  		throw new ArgumentException (String.Format ("FrameID must be 3 bytes from ID3v2.2 ({0} bytes passed)"' frameIDBytes.Length));  	tmpRawData = new byte[6];  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = (byte)((_frameSizeExcludingAdditions >> 16) & 0xFF);  	tmpRawData [4] = (byte)((_frameSizeExcludingAdditions >> 8) & 0xFF);  	tmpRawData [5] = (byte)(_frameSizeExcludingAdditions & 0xFF);  } else if (tagVersion == ID3v2TagVersion.ID3v23) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x80 : 0) + (_isFileAlterPreservation ? 0x40 : 0) + (_isReadOnly ? 0x20 : 0));  	byte tmpByte2 = (byte)((_isCompressed ? 0x80 : 0) + (_encryptionMethod != null ? 0x40 : 0) + (_groupingIdentity != null ? 0x20 : 0));  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 24) & 0xFF);  	tmpRawData [5] = (byte)((tmpFrameSize >> 16) & 0xFF);  	tmpRawData [6] = (byte)((tmpFrameSize >> 8) & 0xFF);  	tmpRawData [7] = (byte)(tmpFrameSize & 0xFF);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition] = _groupingIdentity.Value;  } else if (tagVersion == ID3v2TagVersion.ID3v24) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x40 : 0) + (_isFileAlterPreservation ? 0x20 : 0) + (_isReadOnly ? 0x10 : 0));  	byte tmpByte2 = (byte)((_groupingIdentity != null ? 0x40 : 0) + (_isCompressed ? 0x08 : 0) + (_encryptionMethod != null ? 0x04 : 0)/* +                                   (false Unsynchronization ? 0x02 : 0) +                                   (false Data length indicator ? 0x01 : 0)*/);  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	/*TODO: unsync'DLI*/int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	// Note: ID3v2.4 uses sync safe frame sizes  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 21) & 0x7F);  	tmpRawData [5] = (byte)((tmpFrameSize >> 14) & 0x7F);  	tmpRawData [6] = (byte)((tmpFrameSize >> 7) & 0x7F);  	tmpRawData [7] = (byte)(tmpFrameSize & 0x7F);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition++] = _groupingIdentity.Value;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	/*TODO: unsync'DLI*/} else {  	throw new ArgumentOutOfRangeException ("tagVersion"' tagVersion' "Unknown tag version");  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameHeader.cs,GetBytes,The following statement contains a magic number: if (tagVersion == ID3v2TagVersion.ID3v22) {  	if (frameIDBytes.Length != 3)  		throw new ArgumentException (String.Format ("FrameID must be 3 bytes from ID3v2.2 ({0} bytes passed)"' frameIDBytes.Length));  	tmpRawData = new byte[6];  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = (byte)((_frameSizeExcludingAdditions >> 16) & 0xFF);  	tmpRawData [4] = (byte)((_frameSizeExcludingAdditions >> 8) & 0xFF);  	tmpRawData [5] = (byte)(_frameSizeExcludingAdditions & 0xFF);  } else if (tagVersion == ID3v2TagVersion.ID3v23) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x80 : 0) + (_isFileAlterPreservation ? 0x40 : 0) + (_isReadOnly ? 0x20 : 0));  	byte tmpByte2 = (byte)((_isCompressed ? 0x80 : 0) + (_encryptionMethod != null ? 0x40 : 0) + (_groupingIdentity != null ? 0x20 : 0));  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 24) & 0xFF);  	tmpRawData [5] = (byte)((tmpFrameSize >> 16) & 0xFF);  	tmpRawData [6] = (byte)((tmpFrameSize >> 8) & 0xFF);  	tmpRawData [7] = (byte)(tmpFrameSize & 0xFF);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition] = _groupingIdentity.Value;  } else if (tagVersion == ID3v2TagVersion.ID3v24) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x40 : 0) + (_isFileAlterPreservation ? 0x20 : 0) + (_isReadOnly ? 0x10 : 0));  	byte tmpByte2 = (byte)((_groupingIdentity != null ? 0x40 : 0) + (_isCompressed ? 0x08 : 0) + (_encryptionMethod != null ? 0x04 : 0)/* +                                   (false Unsynchronization ? 0x02 : 0) +                                   (false Data length indicator ? 0x01 : 0)*/);  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	/*TODO: unsync'DLI*/int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	// Note: ID3v2.4 uses sync safe frame sizes  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 21) & 0x7F);  	tmpRawData [5] = (byte)((tmpFrameSize >> 14) & 0x7F);  	tmpRawData [6] = (byte)((tmpFrameSize >> 7) & 0x7F);  	tmpRawData [7] = (byte)(tmpFrameSize & 0x7F);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition++] = _groupingIdentity.Value;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	/*TODO: unsync'DLI*/} else {  	throw new ArgumentOutOfRangeException ("tagVersion"' tagVersion' "Unknown tag version");  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameHeader.cs,GetBytes,The following statement contains a magic number: if (tagVersion == ID3v2TagVersion.ID3v22) {  	if (frameIDBytes.Length != 3)  		throw new ArgumentException (String.Format ("FrameID must be 3 bytes from ID3v2.2 ({0} bytes passed)"' frameIDBytes.Length));  	tmpRawData = new byte[6];  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = (byte)((_frameSizeExcludingAdditions >> 16) & 0xFF);  	tmpRawData [4] = (byte)((_frameSizeExcludingAdditions >> 8) & 0xFF);  	tmpRawData [5] = (byte)(_frameSizeExcludingAdditions & 0xFF);  } else if (tagVersion == ID3v2TagVersion.ID3v23) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x80 : 0) + (_isFileAlterPreservation ? 0x40 : 0) + (_isReadOnly ? 0x20 : 0));  	byte tmpByte2 = (byte)((_isCompressed ? 0x80 : 0) + (_encryptionMethod != null ? 0x40 : 0) + (_groupingIdentity != null ? 0x20 : 0));  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 24) & 0xFF);  	tmpRawData [5] = (byte)((tmpFrameSize >> 16) & 0xFF);  	tmpRawData [6] = (byte)((tmpFrameSize >> 8) & 0xFF);  	tmpRawData [7] = (byte)(tmpFrameSize & 0xFF);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition] = _groupingIdentity.Value;  } else if (tagVersion == ID3v2TagVersion.ID3v24) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x40 : 0) + (_isFileAlterPreservation ? 0x20 : 0) + (_isReadOnly ? 0x10 : 0));  	byte tmpByte2 = (byte)((_groupingIdentity != null ? 0x40 : 0) + (_isCompressed ? 0x08 : 0) + (_encryptionMethod != null ? 0x04 : 0)/* +                                   (false Unsynchronization ? 0x02 : 0) +                                   (false Data length indicator ? 0x01 : 0)*/);  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	/*TODO: unsync'DLI*/int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	// Note: ID3v2.4 uses sync safe frame sizes  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 21) & 0x7F);  	tmpRawData [5] = (byte)((tmpFrameSize >> 14) & 0x7F);  	tmpRawData [6] = (byte)((tmpFrameSize >> 7) & 0x7F);  	tmpRawData [7] = (byte)(tmpFrameSize & 0x7F);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition++] = _groupingIdentity.Value;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	/*TODO: unsync'DLI*/} else {  	throw new ArgumentOutOfRangeException ("tagVersion"' tagVersion' "Unknown tag version");  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameHeader.cs,GetBytes,The following statement contains a magic number: if (tagVersion == ID3v2TagVersion.ID3v22) {  	if (frameIDBytes.Length != 3)  		throw new ArgumentException (String.Format ("FrameID must be 3 bytes from ID3v2.2 ({0} bytes passed)"' frameIDBytes.Length));  	tmpRawData = new byte[6];  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = (byte)((_frameSizeExcludingAdditions >> 16) & 0xFF);  	tmpRawData [4] = (byte)((_frameSizeExcludingAdditions >> 8) & 0xFF);  	tmpRawData [5] = (byte)(_frameSizeExcludingAdditions & 0xFF);  } else if (tagVersion == ID3v2TagVersion.ID3v23) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x80 : 0) + (_isFileAlterPreservation ? 0x40 : 0) + (_isReadOnly ? 0x20 : 0));  	byte tmpByte2 = (byte)((_isCompressed ? 0x80 : 0) + (_encryptionMethod != null ? 0x40 : 0) + (_groupingIdentity != null ? 0x20 : 0));  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 24) & 0xFF);  	tmpRawData [5] = (byte)((tmpFrameSize >> 16) & 0xFF);  	tmpRawData [6] = (byte)((tmpFrameSize >> 8) & 0xFF);  	tmpRawData [7] = (byte)(tmpFrameSize & 0xFF);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition] = _groupingIdentity.Value;  } else if (tagVersion == ID3v2TagVersion.ID3v24) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x40 : 0) + (_isFileAlterPreservation ? 0x20 : 0) + (_isReadOnly ? 0x10 : 0));  	byte tmpByte2 = (byte)((_groupingIdentity != null ? 0x40 : 0) + (_isCompressed ? 0x08 : 0) + (_encryptionMethod != null ? 0x04 : 0)/* +                                   (false Unsynchronization ? 0x02 : 0) +                                   (false Data length indicator ? 0x01 : 0)*/);  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	/*TODO: unsync'DLI*/int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	// Note: ID3v2.4 uses sync safe frame sizes  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 21) & 0x7F);  	tmpRawData [5] = (byte)((tmpFrameSize >> 14) & 0x7F);  	tmpRawData [6] = (byte)((tmpFrameSize >> 7) & 0x7F);  	tmpRawData [7] = (byte)(tmpFrameSize & 0x7F);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition++] = _groupingIdentity.Value;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	/*TODO: unsync'DLI*/} else {  	throw new ArgumentOutOfRangeException ("tagVersion"' tagVersion' "Unknown tag version");  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameHeader.cs,GetBytes,The following statement contains a magic number: if (tagVersion == ID3v2TagVersion.ID3v22) {  	if (frameIDBytes.Length != 3)  		throw new ArgumentException (String.Format ("FrameID must be 3 bytes from ID3v2.2 ({0} bytes passed)"' frameIDBytes.Length));  	tmpRawData = new byte[6];  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = (byte)((_frameSizeExcludingAdditions >> 16) & 0xFF);  	tmpRawData [4] = (byte)((_frameSizeExcludingAdditions >> 8) & 0xFF);  	tmpRawData [5] = (byte)(_frameSizeExcludingAdditions & 0xFF);  } else if (tagVersion == ID3v2TagVersion.ID3v23) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x80 : 0) + (_isFileAlterPreservation ? 0x40 : 0) + (_isReadOnly ? 0x20 : 0));  	byte tmpByte2 = (byte)((_isCompressed ? 0x80 : 0) + (_encryptionMethod != null ? 0x40 : 0) + (_groupingIdentity != null ? 0x20 : 0));  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 24) & 0xFF);  	tmpRawData [5] = (byte)((tmpFrameSize >> 16) & 0xFF);  	tmpRawData [6] = (byte)((tmpFrameSize >> 8) & 0xFF);  	tmpRawData [7] = (byte)(tmpFrameSize & 0xFF);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition] = _groupingIdentity.Value;  } else if (tagVersion == ID3v2TagVersion.ID3v24) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x40 : 0) + (_isFileAlterPreservation ? 0x20 : 0) + (_isReadOnly ? 0x10 : 0));  	byte tmpByte2 = (byte)((_groupingIdentity != null ? 0x40 : 0) + (_isCompressed ? 0x08 : 0) + (_encryptionMethod != null ? 0x04 : 0)/* +                                   (false Unsynchronization ? 0x02 : 0) +                                   (false Data length indicator ? 0x01 : 0)*/);  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	/*TODO: unsync'DLI*/int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	// Note: ID3v2.4 uses sync safe frame sizes  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 21) & 0x7F);  	tmpRawData [5] = (byte)((tmpFrameSize >> 14) & 0x7F);  	tmpRawData [6] = (byte)((tmpFrameSize >> 7) & 0x7F);  	tmpRawData [7] = (byte)(tmpFrameSize & 0x7F);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition++] = _groupingIdentity.Value;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	/*TODO: unsync'DLI*/} else {  	throw new ArgumentOutOfRangeException ("tagVersion"' tagVersion' "Unknown tag version");  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameHeader.cs,GetBytes,The following statement contains a magic number: if (tagVersion == ID3v2TagVersion.ID3v22) {  	if (frameIDBytes.Length != 3)  		throw new ArgumentException (String.Format ("FrameID must be 3 bytes from ID3v2.2 ({0} bytes passed)"' frameIDBytes.Length));  	tmpRawData = new byte[6];  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = (byte)((_frameSizeExcludingAdditions >> 16) & 0xFF);  	tmpRawData [4] = (byte)((_frameSizeExcludingAdditions >> 8) & 0xFF);  	tmpRawData [5] = (byte)(_frameSizeExcludingAdditions & 0xFF);  } else if (tagVersion == ID3v2TagVersion.ID3v23) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x80 : 0) + (_isFileAlterPreservation ? 0x40 : 0) + (_isReadOnly ? 0x20 : 0));  	byte tmpByte2 = (byte)((_isCompressed ? 0x80 : 0) + (_encryptionMethod != null ? 0x40 : 0) + (_groupingIdentity != null ? 0x20 : 0));  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 24) & 0xFF);  	tmpRawData [5] = (byte)((tmpFrameSize >> 16) & 0xFF);  	tmpRawData [6] = (byte)((tmpFrameSize >> 8) & 0xFF);  	tmpRawData [7] = (byte)(tmpFrameSize & 0xFF);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition] = _groupingIdentity.Value;  } else if (tagVersion == ID3v2TagVersion.ID3v24) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x40 : 0) + (_isFileAlterPreservation ? 0x20 : 0) + (_isReadOnly ? 0x10 : 0));  	byte tmpByte2 = (byte)((_groupingIdentity != null ? 0x40 : 0) + (_isCompressed ? 0x08 : 0) + (_encryptionMethod != null ? 0x04 : 0)/* +                                   (false Unsynchronization ? 0x02 : 0) +                                   (false Data length indicator ? 0x01 : 0)*/);  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	/*TODO: unsync'DLI*/int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	// Note: ID3v2.4 uses sync safe frame sizes  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 21) & 0x7F);  	tmpRawData [5] = (byte)((tmpFrameSize >> 14) & 0x7F);  	tmpRawData [6] = (byte)((tmpFrameSize >> 7) & 0x7F);  	tmpRawData [7] = (byte)(tmpFrameSize & 0x7F);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition++] = _groupingIdentity.Value;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	/*TODO: unsync'DLI*/} else {  	throw new ArgumentOutOfRangeException ("tagVersion"' tagVersion' "Unknown tag version");  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameHeader.cs,GetBytes,The following statement contains a magic number: if (tagVersion == ID3v2TagVersion.ID3v22) {  	if (frameIDBytes.Length != 3)  		throw new ArgumentException (String.Format ("FrameID must be 3 bytes from ID3v2.2 ({0} bytes passed)"' frameIDBytes.Length));  	tmpRawData = new byte[6];  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = (byte)((_frameSizeExcludingAdditions >> 16) & 0xFF);  	tmpRawData [4] = (byte)((_frameSizeExcludingAdditions >> 8) & 0xFF);  	tmpRawData [5] = (byte)(_frameSizeExcludingAdditions & 0xFF);  } else if (tagVersion == ID3v2TagVersion.ID3v23) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x80 : 0) + (_isFileAlterPreservation ? 0x40 : 0) + (_isReadOnly ? 0x20 : 0));  	byte tmpByte2 = (byte)((_isCompressed ? 0x80 : 0) + (_encryptionMethod != null ? 0x40 : 0) + (_groupingIdentity != null ? 0x20 : 0));  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 24) & 0xFF);  	tmpRawData [5] = (byte)((tmpFrameSize >> 16) & 0xFF);  	tmpRawData [6] = (byte)((tmpFrameSize >> 8) & 0xFF);  	tmpRawData [7] = (byte)(tmpFrameSize & 0xFF);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition] = _groupingIdentity.Value;  } else if (tagVersion == ID3v2TagVersion.ID3v24) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x40 : 0) + (_isFileAlterPreservation ? 0x20 : 0) + (_isReadOnly ? 0x10 : 0));  	byte tmpByte2 = (byte)((_groupingIdentity != null ? 0x40 : 0) + (_isCompressed ? 0x08 : 0) + (_encryptionMethod != null ? 0x04 : 0)/* +                                   (false Unsynchronization ? 0x02 : 0) +                                   (false Data length indicator ? 0x01 : 0)*/);  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	/*TODO: unsync'DLI*/int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	// Note: ID3v2.4 uses sync safe frame sizes  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 21) & 0x7F);  	tmpRawData [5] = (byte)((tmpFrameSize >> 14) & 0x7F);  	tmpRawData [6] = (byte)((tmpFrameSize >> 7) & 0x7F);  	tmpRawData [7] = (byte)(tmpFrameSize & 0x7F);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition++] = _groupingIdentity.Value;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	/*TODO: unsync'DLI*/} else {  	throw new ArgumentOutOfRangeException ("tagVersion"' tagVersion' "Unknown tag version");  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameHeader.cs,GetBytes,The following statement contains a magic number: if (tagVersion == ID3v2TagVersion.ID3v22) {  	if (frameIDBytes.Length != 3)  		throw new ArgumentException (String.Format ("FrameID must be 3 bytes from ID3v2.2 ({0} bytes passed)"' frameIDBytes.Length));  	tmpRawData = new byte[6];  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = (byte)((_frameSizeExcludingAdditions >> 16) & 0xFF);  	tmpRawData [4] = (byte)((_frameSizeExcludingAdditions >> 8) & 0xFF);  	tmpRawData [5] = (byte)(_frameSizeExcludingAdditions & 0xFF);  } else if (tagVersion == ID3v2TagVersion.ID3v23) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x80 : 0) + (_isFileAlterPreservation ? 0x40 : 0) + (_isReadOnly ? 0x20 : 0));  	byte tmpByte2 = (byte)((_isCompressed ? 0x80 : 0) + (_encryptionMethod != null ? 0x40 : 0) + (_groupingIdentity != null ? 0x20 : 0));  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 24) & 0xFF);  	tmpRawData [5] = (byte)((tmpFrameSize >> 16) & 0xFF);  	tmpRawData [6] = (byte)((tmpFrameSize >> 8) & 0xFF);  	tmpRawData [7] = (byte)(tmpFrameSize & 0xFF);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition] = _groupingIdentity.Value;  } else if (tagVersion == ID3v2TagVersion.ID3v24) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x40 : 0) + (_isFileAlterPreservation ? 0x20 : 0) + (_isReadOnly ? 0x10 : 0));  	byte tmpByte2 = (byte)((_groupingIdentity != null ? 0x40 : 0) + (_isCompressed ? 0x08 : 0) + (_encryptionMethod != null ? 0x04 : 0)/* +                                   (false Unsynchronization ? 0x02 : 0) +                                   (false Data length indicator ? 0x01 : 0)*/);  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	/*TODO: unsync'DLI*/int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	// Note: ID3v2.4 uses sync safe frame sizes  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 21) & 0x7F);  	tmpRawData [5] = (byte)((tmpFrameSize >> 14) & 0x7F);  	tmpRawData [6] = (byte)((tmpFrameSize >> 7) & 0x7F);  	tmpRawData [7] = (byte)(tmpFrameSize & 0x7F);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition++] = _groupingIdentity.Value;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	/*TODO: unsync'DLI*/} else {  	throw new ArgumentOutOfRangeException ("tagVersion"' tagVersion' "Unknown tag version");  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameHeader.cs,GetBytes,The following statement contains a magic number: if (tagVersion == ID3v2TagVersion.ID3v22) {  	if (frameIDBytes.Length != 3)  		throw new ArgumentException (String.Format ("FrameID must be 3 bytes from ID3v2.2 ({0} bytes passed)"' frameIDBytes.Length));  	tmpRawData = new byte[6];  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = (byte)((_frameSizeExcludingAdditions >> 16) & 0xFF);  	tmpRawData [4] = (byte)((_frameSizeExcludingAdditions >> 8) & 0xFF);  	tmpRawData [5] = (byte)(_frameSizeExcludingAdditions & 0xFF);  } else if (tagVersion == ID3v2TagVersion.ID3v23) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x80 : 0) + (_isFileAlterPreservation ? 0x40 : 0) + (_isReadOnly ? 0x20 : 0));  	byte tmpByte2 = (byte)((_isCompressed ? 0x80 : 0) + (_encryptionMethod != null ? 0x40 : 0) + (_groupingIdentity != null ? 0x20 : 0));  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 24) & 0xFF);  	tmpRawData [5] = (byte)((tmpFrameSize >> 16) & 0xFF);  	tmpRawData [6] = (byte)((tmpFrameSize >> 8) & 0xFF);  	tmpRawData [7] = (byte)(tmpFrameSize & 0xFF);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition] = _groupingIdentity.Value;  } else if (tagVersion == ID3v2TagVersion.ID3v24) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x40 : 0) + (_isFileAlterPreservation ? 0x20 : 0) + (_isReadOnly ? 0x10 : 0));  	byte tmpByte2 = (byte)((_groupingIdentity != null ? 0x40 : 0) + (_isCompressed ? 0x08 : 0) + (_encryptionMethod != null ? 0x04 : 0)/* +                                   (false Unsynchronization ? 0x02 : 0) +                                   (false Data length indicator ? 0x01 : 0)*/);  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	/*TODO: unsync'DLI*/int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	// Note: ID3v2.4 uses sync safe frame sizes  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 21) & 0x7F);  	tmpRawData [5] = (byte)((tmpFrameSize >> 14) & 0x7F);  	tmpRawData [6] = (byte)((tmpFrameSize >> 7) & 0x7F);  	tmpRawData [7] = (byte)(tmpFrameSize & 0x7F);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition++] = _groupingIdentity.Value;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	/*TODO: unsync'DLI*/} else {  	throw new ArgumentOutOfRangeException ("tagVersion"' tagVersion' "Unknown tag version");  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameHeader.cs,GetBytes,The following statement contains a magic number: if (tagVersion == ID3v2TagVersion.ID3v22) {  	if (frameIDBytes.Length != 3)  		throw new ArgumentException (String.Format ("FrameID must be 3 bytes from ID3v2.2 ({0} bytes passed)"' frameIDBytes.Length));  	tmpRawData = new byte[6];  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = (byte)((_frameSizeExcludingAdditions >> 16) & 0xFF);  	tmpRawData [4] = (byte)((_frameSizeExcludingAdditions >> 8) & 0xFF);  	tmpRawData [5] = (byte)(_frameSizeExcludingAdditions & 0xFF);  } else if (tagVersion == ID3v2TagVersion.ID3v23) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x80 : 0) + (_isFileAlterPreservation ? 0x40 : 0) + (_isReadOnly ? 0x20 : 0));  	byte tmpByte2 = (byte)((_isCompressed ? 0x80 : 0) + (_encryptionMethod != null ? 0x40 : 0) + (_groupingIdentity != null ? 0x20 : 0));  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 24) & 0xFF);  	tmpRawData [5] = (byte)((tmpFrameSize >> 16) & 0xFF);  	tmpRawData [6] = (byte)((tmpFrameSize >> 8) & 0xFF);  	tmpRawData [7] = (byte)(tmpFrameSize & 0xFF);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition] = _groupingIdentity.Value;  } else if (tagVersion == ID3v2TagVersion.ID3v24) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x40 : 0) + (_isFileAlterPreservation ? 0x20 : 0) + (_isReadOnly ? 0x10 : 0));  	byte tmpByte2 = (byte)((_groupingIdentity != null ? 0x40 : 0) + (_isCompressed ? 0x08 : 0) + (_encryptionMethod != null ? 0x04 : 0)/* +                                   (false Unsynchronization ? 0x02 : 0) +                                   (false Data length indicator ? 0x01 : 0)*/);  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	/*TODO: unsync'DLI*/int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	// Note: ID3v2.4 uses sync safe frame sizes  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 21) & 0x7F);  	tmpRawData [5] = (byte)((tmpFrameSize >> 14) & 0x7F);  	tmpRawData [6] = (byte)((tmpFrameSize >> 7) & 0x7F);  	tmpRawData [7] = (byte)(tmpFrameSize & 0x7F);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition++] = _groupingIdentity.Value;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	/*TODO: unsync'DLI*/} else {  	throw new ArgumentOutOfRangeException ("tagVersion"' tagVersion' "Unknown tag version");  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameHeader.cs,GetBytes,The following statement contains a magic number: if (tagVersion == ID3v2TagVersion.ID3v22) {  	if (frameIDBytes.Length != 3)  		throw new ArgumentException (String.Format ("FrameID must be 3 bytes from ID3v2.2 ({0} bytes passed)"' frameIDBytes.Length));  	tmpRawData = new byte[6];  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = (byte)((_frameSizeExcludingAdditions >> 16) & 0xFF);  	tmpRawData [4] = (byte)((_frameSizeExcludingAdditions >> 8) & 0xFF);  	tmpRawData [5] = (byte)(_frameSizeExcludingAdditions & 0xFF);  } else if (tagVersion == ID3v2TagVersion.ID3v23) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x80 : 0) + (_isFileAlterPreservation ? 0x40 : 0) + (_isReadOnly ? 0x20 : 0));  	byte tmpByte2 = (byte)((_isCompressed ? 0x80 : 0) + (_encryptionMethod != null ? 0x40 : 0) + (_groupingIdentity != null ? 0x20 : 0));  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 24) & 0xFF);  	tmpRawData [5] = (byte)((tmpFrameSize >> 16) & 0xFF);  	tmpRawData [6] = (byte)((tmpFrameSize >> 8) & 0xFF);  	tmpRawData [7] = (byte)(tmpFrameSize & 0xFF);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition] = _groupingIdentity.Value;  } else if (tagVersion == ID3v2TagVersion.ID3v24) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x40 : 0) + (_isFileAlterPreservation ? 0x20 : 0) + (_isReadOnly ? 0x10 : 0));  	byte tmpByte2 = (byte)((_groupingIdentity != null ? 0x40 : 0) + (_isCompressed ? 0x08 : 0) + (_encryptionMethod != null ? 0x04 : 0)/* +                                   (false Unsynchronization ? 0x02 : 0) +                                   (false Data length indicator ? 0x01 : 0)*/);  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	/*TODO: unsync'DLI*/int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	// Note: ID3v2.4 uses sync safe frame sizes  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 21) & 0x7F);  	tmpRawData [5] = (byte)((tmpFrameSize >> 14) & 0x7F);  	tmpRawData [6] = (byte)((tmpFrameSize >> 7) & 0x7F);  	tmpRawData [7] = (byte)(tmpFrameSize & 0x7F);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition++] = _groupingIdentity.Value;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	/*TODO: unsync'DLI*/} else {  	throw new ArgumentOutOfRangeException ("tagVersion"' tagVersion' "Unknown tag version");  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameHeader.cs,GetBytes,The following statement contains a magic number: if (tagVersion == ID3v2TagVersion.ID3v22) {  	if (frameIDBytes.Length != 3)  		throw new ArgumentException (String.Format ("FrameID must be 3 bytes from ID3v2.2 ({0} bytes passed)"' frameIDBytes.Length));  	tmpRawData = new byte[6];  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = (byte)((_frameSizeExcludingAdditions >> 16) & 0xFF);  	tmpRawData [4] = (byte)((_frameSizeExcludingAdditions >> 8) & 0xFF);  	tmpRawData [5] = (byte)(_frameSizeExcludingAdditions & 0xFF);  } else if (tagVersion == ID3v2TagVersion.ID3v23) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x80 : 0) + (_isFileAlterPreservation ? 0x40 : 0) + (_isReadOnly ? 0x20 : 0));  	byte tmpByte2 = (byte)((_isCompressed ? 0x80 : 0) + (_encryptionMethod != null ? 0x40 : 0) + (_groupingIdentity != null ? 0x20 : 0));  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 24) & 0xFF);  	tmpRawData [5] = (byte)((tmpFrameSize >> 16) & 0xFF);  	tmpRawData [6] = (byte)((tmpFrameSize >> 8) & 0xFF);  	tmpRawData [7] = (byte)(tmpFrameSize & 0xFF);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition] = _groupingIdentity.Value;  } else if (tagVersion == ID3v2TagVersion.ID3v24) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x40 : 0) + (_isFileAlterPreservation ? 0x20 : 0) + (_isReadOnly ? 0x10 : 0));  	byte tmpByte2 = (byte)((_groupingIdentity != null ? 0x40 : 0) + (_isCompressed ? 0x08 : 0) + (_encryptionMethod != null ? 0x04 : 0)/* +                                   (false Unsynchronization ? 0x02 : 0) +                                   (false Data length indicator ? 0x01 : 0)*/);  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	/*TODO: unsync'DLI*/int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	// Note: ID3v2.4 uses sync safe frame sizes  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 21) & 0x7F);  	tmpRawData [5] = (byte)((tmpFrameSize >> 14) & 0x7F);  	tmpRawData [6] = (byte)((tmpFrameSize >> 7) & 0x7F);  	tmpRawData [7] = (byte)(tmpFrameSize & 0x7F);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition++] = _groupingIdentity.Value;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	/*TODO: unsync'DLI*/} else {  	throw new ArgumentOutOfRangeException ("tagVersion"' tagVersion' "Unknown tag version");  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameHeader.cs,GetBytes,The following statement contains a magic number: if (tagVersion == ID3v2TagVersion.ID3v22) {  	if (frameIDBytes.Length != 3)  		throw new ArgumentException (String.Format ("FrameID must be 3 bytes from ID3v2.2 ({0} bytes passed)"' frameIDBytes.Length));  	tmpRawData = new byte[6];  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = (byte)((_frameSizeExcludingAdditions >> 16) & 0xFF);  	tmpRawData [4] = (byte)((_frameSizeExcludingAdditions >> 8) & 0xFF);  	tmpRawData [5] = (byte)(_frameSizeExcludingAdditions & 0xFF);  } else if (tagVersion == ID3v2TagVersion.ID3v23) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x80 : 0) + (_isFileAlterPreservation ? 0x40 : 0) + (_isReadOnly ? 0x20 : 0));  	byte tmpByte2 = (byte)((_isCompressed ? 0x80 : 0) + (_encryptionMethod != null ? 0x40 : 0) + (_groupingIdentity != null ? 0x20 : 0));  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 24) & 0xFF);  	tmpRawData [5] = (byte)((tmpFrameSize >> 16) & 0xFF);  	tmpRawData [6] = (byte)((tmpFrameSize >> 8) & 0xFF);  	tmpRawData [7] = (byte)(tmpFrameSize & 0xFF);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition] = _groupingIdentity.Value;  } else if (tagVersion == ID3v2TagVersion.ID3v24) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x40 : 0) + (_isFileAlterPreservation ? 0x20 : 0) + (_isReadOnly ? 0x10 : 0));  	byte tmpByte2 = (byte)((_groupingIdentity != null ? 0x40 : 0) + (_isCompressed ? 0x08 : 0) + (_encryptionMethod != null ? 0x04 : 0)/* +                                   (false Unsynchronization ? 0x02 : 0) +                                   (false Data length indicator ? 0x01 : 0)*/);  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	/*TODO: unsync'DLI*/int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	// Note: ID3v2.4 uses sync safe frame sizes  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 21) & 0x7F);  	tmpRawData [5] = (byte)((tmpFrameSize >> 14) & 0x7F);  	tmpRawData [6] = (byte)((tmpFrameSize >> 7) & 0x7F);  	tmpRawData [7] = (byte)(tmpFrameSize & 0x7F);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition++] = _groupingIdentity.Value;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	/*TODO: unsync'DLI*/} else {  	throw new ArgumentOutOfRangeException ("tagVersion"' tagVersion' "Unknown tag version");  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameHeader.cs,GetBytes,The following statement contains a magic number: if (tagVersion == ID3v2TagVersion.ID3v22) {  	if (frameIDBytes.Length != 3)  		throw new ArgumentException (String.Format ("FrameID must be 3 bytes from ID3v2.2 ({0} bytes passed)"' frameIDBytes.Length));  	tmpRawData = new byte[6];  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = (byte)((_frameSizeExcludingAdditions >> 16) & 0xFF);  	tmpRawData [4] = (byte)((_frameSizeExcludingAdditions >> 8) & 0xFF);  	tmpRawData [5] = (byte)(_frameSizeExcludingAdditions & 0xFF);  } else if (tagVersion == ID3v2TagVersion.ID3v23) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x80 : 0) + (_isFileAlterPreservation ? 0x40 : 0) + (_isReadOnly ? 0x20 : 0));  	byte tmpByte2 = (byte)((_isCompressed ? 0x80 : 0) + (_encryptionMethod != null ? 0x40 : 0) + (_groupingIdentity != null ? 0x20 : 0));  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 24) & 0xFF);  	tmpRawData [5] = (byte)((tmpFrameSize >> 16) & 0xFF);  	tmpRawData [6] = (byte)((tmpFrameSize >> 8) & 0xFF);  	tmpRawData [7] = (byte)(tmpFrameSize & 0xFF);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition] = _groupingIdentity.Value;  } else if (tagVersion == ID3v2TagVersion.ID3v24) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x40 : 0) + (_isFileAlterPreservation ? 0x20 : 0) + (_isReadOnly ? 0x10 : 0));  	byte tmpByte2 = (byte)((_groupingIdentity != null ? 0x40 : 0) + (_isCompressed ? 0x08 : 0) + (_encryptionMethod != null ? 0x04 : 0)/* +                                   (false Unsynchronization ? 0x02 : 0) +                                   (false Data length indicator ? 0x01 : 0)*/);  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	/*TODO: unsync'DLI*/int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	// Note: ID3v2.4 uses sync safe frame sizes  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 21) & 0x7F);  	tmpRawData [5] = (byte)((tmpFrameSize >> 14) & 0x7F);  	tmpRawData [6] = (byte)((tmpFrameSize >> 7) & 0x7F);  	tmpRawData [7] = (byte)(tmpFrameSize & 0x7F);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition++] = _groupingIdentity.Value;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	/*TODO: unsync'DLI*/} else {  	throw new ArgumentOutOfRangeException ("tagVersion"' tagVersion' "Unknown tag version");  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameHeader.cs,GetBytes,The following statement contains a magic number: if (tagVersion == ID3v2TagVersion.ID3v22) {  	if (frameIDBytes.Length != 3)  		throw new ArgumentException (String.Format ("FrameID must be 3 bytes from ID3v2.2 ({0} bytes passed)"' frameIDBytes.Length));  	tmpRawData = new byte[6];  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = (byte)((_frameSizeExcludingAdditions >> 16) & 0xFF);  	tmpRawData [4] = (byte)((_frameSizeExcludingAdditions >> 8) & 0xFF);  	tmpRawData [5] = (byte)(_frameSizeExcludingAdditions & 0xFF);  } else if (tagVersion == ID3v2TagVersion.ID3v23) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x80 : 0) + (_isFileAlterPreservation ? 0x40 : 0) + (_isReadOnly ? 0x20 : 0));  	byte tmpByte2 = (byte)((_isCompressed ? 0x80 : 0) + (_encryptionMethod != null ? 0x40 : 0) + (_groupingIdentity != null ? 0x20 : 0));  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 24) & 0xFF);  	tmpRawData [5] = (byte)((tmpFrameSize >> 16) & 0xFF);  	tmpRawData [6] = (byte)((tmpFrameSize >> 8) & 0xFF);  	tmpRawData [7] = (byte)(tmpFrameSize & 0xFF);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition] = _groupingIdentity.Value;  } else if (tagVersion == ID3v2TagVersion.ID3v24) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x40 : 0) + (_isFileAlterPreservation ? 0x20 : 0) + (_isReadOnly ? 0x10 : 0));  	byte tmpByte2 = (byte)((_groupingIdentity != null ? 0x40 : 0) + (_isCompressed ? 0x08 : 0) + (_encryptionMethod != null ? 0x04 : 0)/* +                                   (false Unsynchronization ? 0x02 : 0) +                                   (false Data length indicator ? 0x01 : 0)*/);  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	/*TODO: unsync'DLI*/int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	// Note: ID3v2.4 uses sync safe frame sizes  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 21) & 0x7F);  	tmpRawData [5] = (byte)((tmpFrameSize >> 14) & 0x7F);  	tmpRawData [6] = (byte)((tmpFrameSize >> 7) & 0x7F);  	tmpRawData [7] = (byte)(tmpFrameSize & 0x7F);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition++] = _groupingIdentity.Value;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	/*TODO: unsync'DLI*/} else {  	throw new ArgumentOutOfRangeException ("tagVersion"' tagVersion' "Unknown tag version");  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameHeader.cs,GetBytes,The following statement contains a magic number: if (tagVersion == ID3v2TagVersion.ID3v22) {  	if (frameIDBytes.Length != 3)  		throw new ArgumentException (String.Format ("FrameID must be 3 bytes from ID3v2.2 ({0} bytes passed)"' frameIDBytes.Length));  	tmpRawData = new byte[6];  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = (byte)((_frameSizeExcludingAdditions >> 16) & 0xFF);  	tmpRawData [4] = (byte)((_frameSizeExcludingAdditions >> 8) & 0xFF);  	tmpRawData [5] = (byte)(_frameSizeExcludingAdditions & 0xFF);  } else if (tagVersion == ID3v2TagVersion.ID3v23) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x80 : 0) + (_isFileAlterPreservation ? 0x40 : 0) + (_isReadOnly ? 0x20 : 0));  	byte tmpByte2 = (byte)((_isCompressed ? 0x80 : 0) + (_encryptionMethod != null ? 0x40 : 0) + (_groupingIdentity != null ? 0x20 : 0));  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 24) & 0xFF);  	tmpRawData [5] = (byte)((tmpFrameSize >> 16) & 0xFF);  	tmpRawData [6] = (byte)((tmpFrameSize >> 8) & 0xFF);  	tmpRawData [7] = (byte)(tmpFrameSize & 0xFF);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition] = _groupingIdentity.Value;  } else if (tagVersion == ID3v2TagVersion.ID3v24) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x40 : 0) + (_isFileAlterPreservation ? 0x20 : 0) + (_isReadOnly ? 0x10 : 0));  	byte tmpByte2 = (byte)((_groupingIdentity != null ? 0x40 : 0) + (_isCompressed ? 0x08 : 0) + (_encryptionMethod != null ? 0x04 : 0)/* +                                   (false Unsynchronization ? 0x02 : 0) +                                   (false Data length indicator ? 0x01 : 0)*/);  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	/*TODO: unsync'DLI*/int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	// Note: ID3v2.4 uses sync safe frame sizes  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 21) & 0x7F);  	tmpRawData [5] = (byte)((tmpFrameSize >> 14) & 0x7F);  	tmpRawData [6] = (byte)((tmpFrameSize >> 7) & 0x7F);  	tmpRawData [7] = (byte)(tmpFrameSize & 0x7F);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition++] = _groupingIdentity.Value;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	/*TODO: unsync'DLI*/} else {  	throw new ArgumentOutOfRangeException ("tagVersion"' tagVersion' "Unknown tag version");  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameHeader.cs,GetBytes,The following statement contains a magic number: if (frameIDBytes.Length != 3)  	throw new ArgumentException (String.Format ("FrameID must be 3 bytes from ID3v2.2 ({0} bytes passed)"' frameIDBytes.Length));  
Magic Number,IdSharp.Tagging.ID3v2,FrameHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameHeader.cs,GetBytes,The following statement contains a magic number: tmpRawData = new byte[6];  
Magic Number,IdSharp.Tagging.ID3v2,FrameHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameHeader.cs,GetBytes,The following statement contains a magic number: tmpRawData [2] = frameIDBytes [2];  
Magic Number,IdSharp.Tagging.ID3v2,FrameHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameHeader.cs,GetBytes,The following statement contains a magic number: tmpRawData [2] = frameIDBytes [2];  
Magic Number,IdSharp.Tagging.ID3v2,FrameHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameHeader.cs,GetBytes,The following statement contains a magic number: tmpRawData [3] = (byte)((_frameSizeExcludingAdditions >> 16) & 0xFF);  
Magic Number,IdSharp.Tagging.ID3v2,FrameHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameHeader.cs,GetBytes,The following statement contains a magic number: tmpRawData [3] = (byte)((_frameSizeExcludingAdditions >> 16) & 0xFF);  
Magic Number,IdSharp.Tagging.ID3v2,FrameHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameHeader.cs,GetBytes,The following statement contains a magic number: tmpRawData [4] = (byte)((_frameSizeExcludingAdditions >> 8) & 0xFF);  
Magic Number,IdSharp.Tagging.ID3v2,FrameHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameHeader.cs,GetBytes,The following statement contains a magic number: tmpRawData [4] = (byte)((_frameSizeExcludingAdditions >> 8) & 0xFF);  
Magic Number,IdSharp.Tagging.ID3v2,FrameHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameHeader.cs,GetBytes,The following statement contains a magic number: tmpRawData [5] = (byte)(_frameSizeExcludingAdditions & 0xFF);  
Magic Number,IdSharp.Tagging.ID3v2,FrameHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameHeader.cs,GetBytes,The following statement contains a magic number: if (tagVersion == ID3v2TagVersion.ID3v23) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x80 : 0) + (_isFileAlterPreservation ? 0x40 : 0) + (_isReadOnly ? 0x20 : 0));  	byte tmpByte2 = (byte)((_isCompressed ? 0x80 : 0) + (_encryptionMethod != null ? 0x40 : 0) + (_groupingIdentity != null ? 0x20 : 0));  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 24) & 0xFF);  	tmpRawData [5] = (byte)((tmpFrameSize >> 16) & 0xFF);  	tmpRawData [6] = (byte)((tmpFrameSize >> 8) & 0xFF);  	tmpRawData [7] = (byte)(tmpFrameSize & 0xFF);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition] = _groupingIdentity.Value;  } else if (tagVersion == ID3v2TagVersion.ID3v24) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x40 : 0) + (_isFileAlterPreservation ? 0x20 : 0) + (_isReadOnly ? 0x10 : 0));  	byte tmpByte2 = (byte)((_groupingIdentity != null ? 0x40 : 0) + (_isCompressed ? 0x08 : 0) + (_encryptionMethod != null ? 0x04 : 0)/* +                                   (false Unsynchronization ? 0x02 : 0) +                                   (false Data length indicator ? 0x01 : 0)*/);  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	/*TODO: unsync'DLI*/int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	// Note: ID3v2.4 uses sync safe frame sizes  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 21) & 0x7F);  	tmpRawData [5] = (byte)((tmpFrameSize >> 14) & 0x7F);  	tmpRawData [6] = (byte)((tmpFrameSize >> 7) & 0x7F);  	tmpRawData [7] = (byte)(tmpFrameSize & 0x7F);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition++] = _groupingIdentity.Value;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	/*TODO: unsync'DLI*/} else {  	throw new ArgumentOutOfRangeException ("tagVersion"' tagVersion' "Unknown tag version");  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameHeader.cs,GetBytes,The following statement contains a magic number: if (tagVersion == ID3v2TagVersion.ID3v23) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x80 : 0) + (_isFileAlterPreservation ? 0x40 : 0) + (_isReadOnly ? 0x20 : 0));  	byte tmpByte2 = (byte)((_isCompressed ? 0x80 : 0) + (_encryptionMethod != null ? 0x40 : 0) + (_groupingIdentity != null ? 0x20 : 0));  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 24) & 0xFF);  	tmpRawData [5] = (byte)((tmpFrameSize >> 16) & 0xFF);  	tmpRawData [6] = (byte)((tmpFrameSize >> 8) & 0xFF);  	tmpRawData [7] = (byte)(tmpFrameSize & 0xFF);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition] = _groupingIdentity.Value;  } else if (tagVersion == ID3v2TagVersion.ID3v24) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x40 : 0) + (_isFileAlterPreservation ? 0x20 : 0) + (_isReadOnly ? 0x10 : 0));  	byte tmpByte2 = (byte)((_groupingIdentity != null ? 0x40 : 0) + (_isCompressed ? 0x08 : 0) + (_encryptionMethod != null ? 0x04 : 0)/* +                                   (false Unsynchronization ? 0x02 : 0) +                                   (false Data length indicator ? 0x01 : 0)*/);  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	/*TODO: unsync'DLI*/int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	// Note: ID3v2.4 uses sync safe frame sizes  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 21) & 0x7F);  	tmpRawData [5] = (byte)((tmpFrameSize >> 14) & 0x7F);  	tmpRawData [6] = (byte)((tmpFrameSize >> 7) & 0x7F);  	tmpRawData [7] = (byte)(tmpFrameSize & 0x7F);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition++] = _groupingIdentity.Value;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	/*TODO: unsync'DLI*/} else {  	throw new ArgumentOutOfRangeException ("tagVersion"' tagVersion' "Unknown tag version");  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameHeader.cs,GetBytes,The following statement contains a magic number: if (tagVersion == ID3v2TagVersion.ID3v23) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x80 : 0) + (_isFileAlterPreservation ? 0x40 : 0) + (_isReadOnly ? 0x20 : 0));  	byte tmpByte2 = (byte)((_isCompressed ? 0x80 : 0) + (_encryptionMethod != null ? 0x40 : 0) + (_groupingIdentity != null ? 0x20 : 0));  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 24) & 0xFF);  	tmpRawData [5] = (byte)((tmpFrameSize >> 16) & 0xFF);  	tmpRawData [6] = (byte)((tmpFrameSize >> 8) & 0xFF);  	tmpRawData [7] = (byte)(tmpFrameSize & 0xFF);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition] = _groupingIdentity.Value;  } else if (tagVersion == ID3v2TagVersion.ID3v24) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x40 : 0) + (_isFileAlterPreservation ? 0x20 : 0) + (_isReadOnly ? 0x10 : 0));  	byte tmpByte2 = (byte)((_groupingIdentity != null ? 0x40 : 0) + (_isCompressed ? 0x08 : 0) + (_encryptionMethod != null ? 0x04 : 0)/* +                                   (false Unsynchronization ? 0x02 : 0) +                                   (false Data length indicator ? 0x01 : 0)*/);  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	/*TODO: unsync'DLI*/int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	// Note: ID3v2.4 uses sync safe frame sizes  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 21) & 0x7F);  	tmpRawData [5] = (byte)((tmpFrameSize >> 14) & 0x7F);  	tmpRawData [6] = (byte)((tmpFrameSize >> 7) & 0x7F);  	tmpRawData [7] = (byte)(tmpFrameSize & 0x7F);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition++] = _groupingIdentity.Value;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	/*TODO: unsync'DLI*/} else {  	throw new ArgumentOutOfRangeException ("tagVersion"' tagVersion' "Unknown tag version");  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameHeader.cs,GetBytes,The following statement contains a magic number: if (tagVersion == ID3v2TagVersion.ID3v23) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x80 : 0) + (_isFileAlterPreservation ? 0x40 : 0) + (_isReadOnly ? 0x20 : 0));  	byte tmpByte2 = (byte)((_isCompressed ? 0x80 : 0) + (_encryptionMethod != null ? 0x40 : 0) + (_groupingIdentity != null ? 0x20 : 0));  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 24) & 0xFF);  	tmpRawData [5] = (byte)((tmpFrameSize >> 16) & 0xFF);  	tmpRawData [6] = (byte)((tmpFrameSize >> 8) & 0xFF);  	tmpRawData [7] = (byte)(tmpFrameSize & 0xFF);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition] = _groupingIdentity.Value;  } else if (tagVersion == ID3v2TagVersion.ID3v24) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x40 : 0) + (_isFileAlterPreservation ? 0x20 : 0) + (_isReadOnly ? 0x10 : 0));  	byte tmpByte2 = (byte)((_groupingIdentity != null ? 0x40 : 0) + (_isCompressed ? 0x08 : 0) + (_encryptionMethod != null ? 0x04 : 0)/* +                                   (false Unsynchronization ? 0x02 : 0) +                                   (false Data length indicator ? 0x01 : 0)*/);  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	/*TODO: unsync'DLI*/int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	// Note: ID3v2.4 uses sync safe frame sizes  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 21) & 0x7F);  	tmpRawData [5] = (byte)((tmpFrameSize >> 14) & 0x7F);  	tmpRawData [6] = (byte)((tmpFrameSize >> 7) & 0x7F);  	tmpRawData [7] = (byte)(tmpFrameSize & 0x7F);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition++] = _groupingIdentity.Value;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	/*TODO: unsync'DLI*/} else {  	throw new ArgumentOutOfRangeException ("tagVersion"' tagVersion' "Unknown tag version");  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameHeader.cs,GetBytes,The following statement contains a magic number: if (tagVersion == ID3v2TagVersion.ID3v23) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x80 : 0) + (_isFileAlterPreservation ? 0x40 : 0) + (_isReadOnly ? 0x20 : 0));  	byte tmpByte2 = (byte)((_isCompressed ? 0x80 : 0) + (_encryptionMethod != null ? 0x40 : 0) + (_groupingIdentity != null ? 0x20 : 0));  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 24) & 0xFF);  	tmpRawData [5] = (byte)((tmpFrameSize >> 16) & 0xFF);  	tmpRawData [6] = (byte)((tmpFrameSize >> 8) & 0xFF);  	tmpRawData [7] = (byte)(tmpFrameSize & 0xFF);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition] = _groupingIdentity.Value;  } else if (tagVersion == ID3v2TagVersion.ID3v24) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x40 : 0) + (_isFileAlterPreservation ? 0x20 : 0) + (_isReadOnly ? 0x10 : 0));  	byte tmpByte2 = (byte)((_groupingIdentity != null ? 0x40 : 0) + (_isCompressed ? 0x08 : 0) + (_encryptionMethod != null ? 0x04 : 0)/* +                                   (false Unsynchronization ? 0x02 : 0) +                                   (false Data length indicator ? 0x01 : 0)*/);  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	/*TODO: unsync'DLI*/int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	// Note: ID3v2.4 uses sync safe frame sizes  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 21) & 0x7F);  	tmpRawData [5] = (byte)((tmpFrameSize >> 14) & 0x7F);  	tmpRawData [6] = (byte)((tmpFrameSize >> 7) & 0x7F);  	tmpRawData [7] = (byte)(tmpFrameSize & 0x7F);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition++] = _groupingIdentity.Value;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	/*TODO: unsync'DLI*/} else {  	throw new ArgumentOutOfRangeException ("tagVersion"' tagVersion' "Unknown tag version");  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameHeader.cs,GetBytes,The following statement contains a magic number: if (tagVersion == ID3v2TagVersion.ID3v23) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x80 : 0) + (_isFileAlterPreservation ? 0x40 : 0) + (_isReadOnly ? 0x20 : 0));  	byte tmpByte2 = (byte)((_isCompressed ? 0x80 : 0) + (_encryptionMethod != null ? 0x40 : 0) + (_groupingIdentity != null ? 0x20 : 0));  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 24) & 0xFF);  	tmpRawData [5] = (byte)((tmpFrameSize >> 16) & 0xFF);  	tmpRawData [6] = (byte)((tmpFrameSize >> 8) & 0xFF);  	tmpRawData [7] = (byte)(tmpFrameSize & 0xFF);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition] = _groupingIdentity.Value;  } else if (tagVersion == ID3v2TagVersion.ID3v24) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x40 : 0) + (_isFileAlterPreservation ? 0x20 : 0) + (_isReadOnly ? 0x10 : 0));  	byte tmpByte2 = (byte)((_groupingIdentity != null ? 0x40 : 0) + (_isCompressed ? 0x08 : 0) + (_encryptionMethod != null ? 0x04 : 0)/* +                                   (false Unsynchronization ? 0x02 : 0) +                                   (false Data length indicator ? 0x01 : 0)*/);  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	/*TODO: unsync'DLI*/int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	// Note: ID3v2.4 uses sync safe frame sizes  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 21) & 0x7F);  	tmpRawData [5] = (byte)((tmpFrameSize >> 14) & 0x7F);  	tmpRawData [6] = (byte)((tmpFrameSize >> 7) & 0x7F);  	tmpRawData [7] = (byte)(tmpFrameSize & 0x7F);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition++] = _groupingIdentity.Value;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	/*TODO: unsync'DLI*/} else {  	throw new ArgumentOutOfRangeException ("tagVersion"' tagVersion' "Unknown tag version");  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameHeader.cs,GetBytes,The following statement contains a magic number: if (tagVersion == ID3v2TagVersion.ID3v23) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x80 : 0) + (_isFileAlterPreservation ? 0x40 : 0) + (_isReadOnly ? 0x20 : 0));  	byte tmpByte2 = (byte)((_isCompressed ? 0x80 : 0) + (_encryptionMethod != null ? 0x40 : 0) + (_groupingIdentity != null ? 0x20 : 0));  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 24) & 0xFF);  	tmpRawData [5] = (byte)((tmpFrameSize >> 16) & 0xFF);  	tmpRawData [6] = (byte)((tmpFrameSize >> 8) & 0xFF);  	tmpRawData [7] = (byte)(tmpFrameSize & 0xFF);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition] = _groupingIdentity.Value;  } else if (tagVersion == ID3v2TagVersion.ID3v24) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x40 : 0) + (_isFileAlterPreservation ? 0x20 : 0) + (_isReadOnly ? 0x10 : 0));  	byte tmpByte2 = (byte)((_groupingIdentity != null ? 0x40 : 0) + (_isCompressed ? 0x08 : 0) + (_encryptionMethod != null ? 0x04 : 0)/* +                                   (false Unsynchronization ? 0x02 : 0) +                                   (false Data length indicator ? 0x01 : 0)*/);  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	/*TODO: unsync'DLI*/int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	// Note: ID3v2.4 uses sync safe frame sizes  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 21) & 0x7F);  	tmpRawData [5] = (byte)((tmpFrameSize >> 14) & 0x7F);  	tmpRawData [6] = (byte)((tmpFrameSize >> 7) & 0x7F);  	tmpRawData [7] = (byte)(tmpFrameSize & 0x7F);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition++] = _groupingIdentity.Value;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	/*TODO: unsync'DLI*/} else {  	throw new ArgumentOutOfRangeException ("tagVersion"' tagVersion' "Unknown tag version");  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameHeader.cs,GetBytes,The following statement contains a magic number: if (tagVersion == ID3v2TagVersion.ID3v23) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x80 : 0) + (_isFileAlterPreservation ? 0x40 : 0) + (_isReadOnly ? 0x20 : 0));  	byte tmpByte2 = (byte)((_isCompressed ? 0x80 : 0) + (_encryptionMethod != null ? 0x40 : 0) + (_groupingIdentity != null ? 0x20 : 0));  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 24) & 0xFF);  	tmpRawData [5] = (byte)((tmpFrameSize >> 16) & 0xFF);  	tmpRawData [6] = (byte)((tmpFrameSize >> 8) & 0xFF);  	tmpRawData [7] = (byte)(tmpFrameSize & 0xFF);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition] = _groupingIdentity.Value;  } else if (tagVersion == ID3v2TagVersion.ID3v24) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x40 : 0) + (_isFileAlterPreservation ? 0x20 : 0) + (_isReadOnly ? 0x10 : 0));  	byte tmpByte2 = (byte)((_groupingIdentity != null ? 0x40 : 0) + (_isCompressed ? 0x08 : 0) + (_encryptionMethod != null ? 0x04 : 0)/* +                                   (false Unsynchronization ? 0x02 : 0) +                                   (false Data length indicator ? 0x01 : 0)*/);  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	/*TODO: unsync'DLI*/int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	// Note: ID3v2.4 uses sync safe frame sizes  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 21) & 0x7F);  	tmpRawData [5] = (byte)((tmpFrameSize >> 14) & 0x7F);  	tmpRawData [6] = (byte)((tmpFrameSize >> 7) & 0x7F);  	tmpRawData [7] = (byte)(tmpFrameSize & 0x7F);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition++] = _groupingIdentity.Value;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	/*TODO: unsync'DLI*/} else {  	throw new ArgumentOutOfRangeException ("tagVersion"' tagVersion' "Unknown tag version");  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameHeader.cs,GetBytes,The following statement contains a magic number: if (tagVersion == ID3v2TagVersion.ID3v23) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x80 : 0) + (_isFileAlterPreservation ? 0x40 : 0) + (_isReadOnly ? 0x20 : 0));  	byte tmpByte2 = (byte)((_isCompressed ? 0x80 : 0) + (_encryptionMethod != null ? 0x40 : 0) + (_groupingIdentity != null ? 0x20 : 0));  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 24) & 0xFF);  	tmpRawData [5] = (byte)((tmpFrameSize >> 16) & 0xFF);  	tmpRawData [6] = (byte)((tmpFrameSize >> 8) & 0xFF);  	tmpRawData [7] = (byte)(tmpFrameSize & 0xFF);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition] = _groupingIdentity.Value;  } else if (tagVersion == ID3v2TagVersion.ID3v24) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x40 : 0) + (_isFileAlterPreservation ? 0x20 : 0) + (_isReadOnly ? 0x10 : 0));  	byte tmpByte2 = (byte)((_groupingIdentity != null ? 0x40 : 0) + (_isCompressed ? 0x08 : 0) + (_encryptionMethod != null ? 0x04 : 0)/* +                                   (false Unsynchronization ? 0x02 : 0) +                                   (false Data length indicator ? 0x01 : 0)*/);  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	/*TODO: unsync'DLI*/int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	// Note: ID3v2.4 uses sync safe frame sizes  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 21) & 0x7F);  	tmpRawData [5] = (byte)((tmpFrameSize >> 14) & 0x7F);  	tmpRawData [6] = (byte)((tmpFrameSize >> 7) & 0x7F);  	tmpRawData [7] = (byte)(tmpFrameSize & 0x7F);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition++] = _groupingIdentity.Value;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	/*TODO: unsync'DLI*/} else {  	throw new ArgumentOutOfRangeException ("tagVersion"' tagVersion' "Unknown tag version");  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameHeader.cs,GetBytes,The following statement contains a magic number: if (tagVersion == ID3v2TagVersion.ID3v23) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x80 : 0) + (_isFileAlterPreservation ? 0x40 : 0) + (_isReadOnly ? 0x20 : 0));  	byte tmpByte2 = (byte)((_isCompressed ? 0x80 : 0) + (_encryptionMethod != null ? 0x40 : 0) + (_groupingIdentity != null ? 0x20 : 0));  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 24) & 0xFF);  	tmpRawData [5] = (byte)((tmpFrameSize >> 16) & 0xFF);  	tmpRawData [6] = (byte)((tmpFrameSize >> 8) & 0xFF);  	tmpRawData [7] = (byte)(tmpFrameSize & 0xFF);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition] = _groupingIdentity.Value;  } else if (tagVersion == ID3v2TagVersion.ID3v24) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x40 : 0) + (_isFileAlterPreservation ? 0x20 : 0) + (_isReadOnly ? 0x10 : 0));  	byte tmpByte2 = (byte)((_groupingIdentity != null ? 0x40 : 0) + (_isCompressed ? 0x08 : 0) + (_encryptionMethod != null ? 0x04 : 0)/* +                                   (false Unsynchronization ? 0x02 : 0) +                                   (false Data length indicator ? 0x01 : 0)*/);  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	/*TODO: unsync'DLI*/int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	// Note: ID3v2.4 uses sync safe frame sizes  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 21) & 0x7F);  	tmpRawData [5] = (byte)((tmpFrameSize >> 14) & 0x7F);  	tmpRawData [6] = (byte)((tmpFrameSize >> 7) & 0x7F);  	tmpRawData [7] = (byte)(tmpFrameSize & 0x7F);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition++] = _groupingIdentity.Value;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	/*TODO: unsync'DLI*/} else {  	throw new ArgumentOutOfRangeException ("tagVersion"' tagVersion' "Unknown tag version");  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameHeader.cs,GetBytes,The following statement contains a magic number: if (tagVersion == ID3v2TagVersion.ID3v23) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x80 : 0) + (_isFileAlterPreservation ? 0x40 : 0) + (_isReadOnly ? 0x20 : 0));  	byte tmpByte2 = (byte)((_isCompressed ? 0x80 : 0) + (_encryptionMethod != null ? 0x40 : 0) + (_groupingIdentity != null ? 0x20 : 0));  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 24) & 0xFF);  	tmpRawData [5] = (byte)((tmpFrameSize >> 16) & 0xFF);  	tmpRawData [6] = (byte)((tmpFrameSize >> 8) & 0xFF);  	tmpRawData [7] = (byte)(tmpFrameSize & 0xFF);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition] = _groupingIdentity.Value;  } else if (tagVersion == ID3v2TagVersion.ID3v24) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x40 : 0) + (_isFileAlterPreservation ? 0x20 : 0) + (_isReadOnly ? 0x10 : 0));  	byte tmpByte2 = (byte)((_groupingIdentity != null ? 0x40 : 0) + (_isCompressed ? 0x08 : 0) + (_encryptionMethod != null ? 0x04 : 0)/* +                                   (false Unsynchronization ? 0x02 : 0) +                                   (false Data length indicator ? 0x01 : 0)*/);  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	/*TODO: unsync'DLI*/int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	// Note: ID3v2.4 uses sync safe frame sizes  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 21) & 0x7F);  	tmpRawData [5] = (byte)((tmpFrameSize >> 14) & 0x7F);  	tmpRawData [6] = (byte)((tmpFrameSize >> 7) & 0x7F);  	tmpRawData [7] = (byte)(tmpFrameSize & 0x7F);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition++] = _groupingIdentity.Value;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	/*TODO: unsync'DLI*/} else {  	throw new ArgumentOutOfRangeException ("tagVersion"' tagVersion' "Unknown tag version");  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameHeader.cs,GetBytes,The following statement contains a magic number: if (tagVersion == ID3v2TagVersion.ID3v23) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x80 : 0) + (_isFileAlterPreservation ? 0x40 : 0) + (_isReadOnly ? 0x20 : 0));  	byte tmpByte2 = (byte)((_isCompressed ? 0x80 : 0) + (_encryptionMethod != null ? 0x40 : 0) + (_groupingIdentity != null ? 0x20 : 0));  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 24) & 0xFF);  	tmpRawData [5] = (byte)((tmpFrameSize >> 16) & 0xFF);  	tmpRawData [6] = (byte)((tmpFrameSize >> 8) & 0xFF);  	tmpRawData [7] = (byte)(tmpFrameSize & 0xFF);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition] = _groupingIdentity.Value;  } else if (tagVersion == ID3v2TagVersion.ID3v24) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x40 : 0) + (_isFileAlterPreservation ? 0x20 : 0) + (_isReadOnly ? 0x10 : 0));  	byte tmpByte2 = (byte)((_groupingIdentity != null ? 0x40 : 0) + (_isCompressed ? 0x08 : 0) + (_encryptionMethod != null ? 0x04 : 0)/* +                                   (false Unsynchronization ? 0x02 : 0) +                                   (false Data length indicator ? 0x01 : 0)*/);  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	/*TODO: unsync'DLI*/int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	// Note: ID3v2.4 uses sync safe frame sizes  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 21) & 0x7F);  	tmpRawData [5] = (byte)((tmpFrameSize >> 14) & 0x7F);  	tmpRawData [6] = (byte)((tmpFrameSize >> 7) & 0x7F);  	tmpRawData [7] = (byte)(tmpFrameSize & 0x7F);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition++] = _groupingIdentity.Value;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	/*TODO: unsync'DLI*/} else {  	throw new ArgumentOutOfRangeException ("tagVersion"' tagVersion' "Unknown tag version");  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameHeader.cs,GetBytes,The following statement contains a magic number: if (tagVersion == ID3v2TagVersion.ID3v23) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x80 : 0) + (_isFileAlterPreservation ? 0x40 : 0) + (_isReadOnly ? 0x20 : 0));  	byte tmpByte2 = (byte)((_isCompressed ? 0x80 : 0) + (_encryptionMethod != null ? 0x40 : 0) + (_groupingIdentity != null ? 0x20 : 0));  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 24) & 0xFF);  	tmpRawData [5] = (byte)((tmpFrameSize >> 16) & 0xFF);  	tmpRawData [6] = (byte)((tmpFrameSize >> 8) & 0xFF);  	tmpRawData [7] = (byte)(tmpFrameSize & 0xFF);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition] = _groupingIdentity.Value;  } else if (tagVersion == ID3v2TagVersion.ID3v24) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x40 : 0) + (_isFileAlterPreservation ? 0x20 : 0) + (_isReadOnly ? 0x10 : 0));  	byte tmpByte2 = (byte)((_groupingIdentity != null ? 0x40 : 0) + (_isCompressed ? 0x08 : 0) + (_encryptionMethod != null ? 0x04 : 0)/* +                                   (false Unsynchronization ? 0x02 : 0) +                                   (false Data length indicator ? 0x01 : 0)*/);  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	/*TODO: unsync'DLI*/int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	// Note: ID3v2.4 uses sync safe frame sizes  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 21) & 0x7F);  	tmpRawData [5] = (byte)((tmpFrameSize >> 14) & 0x7F);  	tmpRawData [6] = (byte)((tmpFrameSize >> 7) & 0x7F);  	tmpRawData [7] = (byte)(tmpFrameSize & 0x7F);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition++] = _groupingIdentity.Value;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	/*TODO: unsync'DLI*/} else {  	throw new ArgumentOutOfRangeException ("tagVersion"' tagVersion' "Unknown tag version");  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameHeader.cs,GetBytes,The following statement contains a magic number: if (tagVersion == ID3v2TagVersion.ID3v23) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x80 : 0) + (_isFileAlterPreservation ? 0x40 : 0) + (_isReadOnly ? 0x20 : 0));  	byte tmpByte2 = (byte)((_isCompressed ? 0x80 : 0) + (_encryptionMethod != null ? 0x40 : 0) + (_groupingIdentity != null ? 0x20 : 0));  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 24) & 0xFF);  	tmpRawData [5] = (byte)((tmpFrameSize >> 16) & 0xFF);  	tmpRawData [6] = (byte)((tmpFrameSize >> 8) & 0xFF);  	tmpRawData [7] = (byte)(tmpFrameSize & 0xFF);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition] = _groupingIdentity.Value;  } else if (tagVersion == ID3v2TagVersion.ID3v24) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x40 : 0) + (_isFileAlterPreservation ? 0x20 : 0) + (_isReadOnly ? 0x10 : 0));  	byte tmpByte2 = (byte)((_groupingIdentity != null ? 0x40 : 0) + (_isCompressed ? 0x08 : 0) + (_encryptionMethod != null ? 0x04 : 0)/* +                                   (false Unsynchronization ? 0x02 : 0) +                                   (false Data length indicator ? 0x01 : 0)*/);  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	/*TODO: unsync'DLI*/int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	// Note: ID3v2.4 uses sync safe frame sizes  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 21) & 0x7F);  	tmpRawData [5] = (byte)((tmpFrameSize >> 14) & 0x7F);  	tmpRawData [6] = (byte)((tmpFrameSize >> 7) & 0x7F);  	tmpRawData [7] = (byte)(tmpFrameSize & 0x7F);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition++] = _groupingIdentity.Value;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	/*TODO: unsync'DLI*/} else {  	throw new ArgumentOutOfRangeException ("tagVersion"' tagVersion' "Unknown tag version");  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameHeader.cs,GetBytes,The following statement contains a magic number: if (tagVersion == ID3v2TagVersion.ID3v23) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x80 : 0) + (_isFileAlterPreservation ? 0x40 : 0) + (_isReadOnly ? 0x20 : 0));  	byte tmpByte2 = (byte)((_isCompressed ? 0x80 : 0) + (_encryptionMethod != null ? 0x40 : 0) + (_groupingIdentity != null ? 0x20 : 0));  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 24) & 0xFF);  	tmpRawData [5] = (byte)((tmpFrameSize >> 16) & 0xFF);  	tmpRawData [6] = (byte)((tmpFrameSize >> 8) & 0xFF);  	tmpRawData [7] = (byte)(tmpFrameSize & 0xFF);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition] = _groupingIdentity.Value;  } else if (tagVersion == ID3v2TagVersion.ID3v24) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x40 : 0) + (_isFileAlterPreservation ? 0x20 : 0) + (_isReadOnly ? 0x10 : 0));  	byte tmpByte2 = (byte)((_groupingIdentity != null ? 0x40 : 0) + (_isCompressed ? 0x08 : 0) + (_encryptionMethod != null ? 0x04 : 0)/* +                                   (false Unsynchronization ? 0x02 : 0) +                                   (false Data length indicator ? 0x01 : 0)*/);  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	/*TODO: unsync'DLI*/int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	// Note: ID3v2.4 uses sync safe frame sizes  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 21) & 0x7F);  	tmpRawData [5] = (byte)((tmpFrameSize >> 14) & 0x7F);  	tmpRawData [6] = (byte)((tmpFrameSize >> 7) & 0x7F);  	tmpRawData [7] = (byte)(tmpFrameSize & 0x7F);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition++] = _groupingIdentity.Value;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	/*TODO: unsync'DLI*/} else {  	throw new ArgumentOutOfRangeException ("tagVersion"' tagVersion' "Unknown tag version");  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameHeader.cs,GetBytes,The following statement contains a magic number: if (tagVersion == ID3v2TagVersion.ID3v23) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x80 : 0) + (_isFileAlterPreservation ? 0x40 : 0) + (_isReadOnly ? 0x20 : 0));  	byte tmpByte2 = (byte)((_isCompressed ? 0x80 : 0) + (_encryptionMethod != null ? 0x40 : 0) + (_groupingIdentity != null ? 0x20 : 0));  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 24) & 0xFF);  	tmpRawData [5] = (byte)((tmpFrameSize >> 16) & 0xFF);  	tmpRawData [6] = (byte)((tmpFrameSize >> 8) & 0xFF);  	tmpRawData [7] = (byte)(tmpFrameSize & 0xFF);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition] = _groupingIdentity.Value;  } else if (tagVersion == ID3v2TagVersion.ID3v24) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x40 : 0) + (_isFileAlterPreservation ? 0x20 : 0) + (_isReadOnly ? 0x10 : 0));  	byte tmpByte2 = (byte)((_groupingIdentity != null ? 0x40 : 0) + (_isCompressed ? 0x08 : 0) + (_encryptionMethod != null ? 0x04 : 0)/* +                                   (false Unsynchronization ? 0x02 : 0) +                                   (false Data length indicator ? 0x01 : 0)*/);  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	/*TODO: unsync'DLI*/int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	// Note: ID3v2.4 uses sync safe frame sizes  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 21) & 0x7F);  	tmpRawData [5] = (byte)((tmpFrameSize >> 14) & 0x7F);  	tmpRawData [6] = (byte)((tmpFrameSize >> 7) & 0x7F);  	tmpRawData [7] = (byte)(tmpFrameSize & 0x7F);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition++] = _groupingIdentity.Value;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	/*TODO: unsync'DLI*/} else {  	throw new ArgumentOutOfRangeException ("tagVersion"' tagVersion' "Unknown tag version");  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameHeader.cs,GetBytes,The following statement contains a magic number: if (tagVersion == ID3v2TagVersion.ID3v23) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x80 : 0) + (_isFileAlterPreservation ? 0x40 : 0) + (_isReadOnly ? 0x20 : 0));  	byte tmpByte2 = (byte)((_isCompressed ? 0x80 : 0) + (_encryptionMethod != null ? 0x40 : 0) + (_groupingIdentity != null ? 0x20 : 0));  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 24) & 0xFF);  	tmpRawData [5] = (byte)((tmpFrameSize >> 16) & 0xFF);  	tmpRawData [6] = (byte)((tmpFrameSize >> 8) & 0xFF);  	tmpRawData [7] = (byte)(tmpFrameSize & 0xFF);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition] = _groupingIdentity.Value;  } else if (tagVersion == ID3v2TagVersion.ID3v24) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x40 : 0) + (_isFileAlterPreservation ? 0x20 : 0) + (_isReadOnly ? 0x10 : 0));  	byte tmpByte2 = (byte)((_groupingIdentity != null ? 0x40 : 0) + (_isCompressed ? 0x08 : 0) + (_encryptionMethod != null ? 0x04 : 0)/* +                                   (false Unsynchronization ? 0x02 : 0) +                                   (false Data length indicator ? 0x01 : 0)*/);  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	/*TODO: unsync'DLI*/int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	// Note: ID3v2.4 uses sync safe frame sizes  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 21) & 0x7F);  	tmpRawData [5] = (byte)((tmpFrameSize >> 14) & 0x7F);  	tmpRawData [6] = (byte)((tmpFrameSize >> 7) & 0x7F);  	tmpRawData [7] = (byte)(tmpFrameSize & 0x7F);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition++] = _groupingIdentity.Value;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	/*TODO: unsync'DLI*/} else {  	throw new ArgumentOutOfRangeException ("tagVersion"' tagVersion' "Unknown tag version");  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameHeader.cs,GetBytes,The following statement contains a magic number: if (tagVersion == ID3v2TagVersion.ID3v23) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x80 : 0) + (_isFileAlterPreservation ? 0x40 : 0) + (_isReadOnly ? 0x20 : 0));  	byte tmpByte2 = (byte)((_isCompressed ? 0x80 : 0) + (_encryptionMethod != null ? 0x40 : 0) + (_groupingIdentity != null ? 0x20 : 0));  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 24) & 0xFF);  	tmpRawData [5] = (byte)((tmpFrameSize >> 16) & 0xFF);  	tmpRawData [6] = (byte)((tmpFrameSize >> 8) & 0xFF);  	tmpRawData [7] = (byte)(tmpFrameSize & 0xFF);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition] = _groupingIdentity.Value;  } else if (tagVersion == ID3v2TagVersion.ID3v24) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x40 : 0) + (_isFileAlterPreservation ? 0x20 : 0) + (_isReadOnly ? 0x10 : 0));  	byte tmpByte2 = (byte)((_groupingIdentity != null ? 0x40 : 0) + (_isCompressed ? 0x08 : 0) + (_encryptionMethod != null ? 0x04 : 0)/* +                                   (false Unsynchronization ? 0x02 : 0) +                                   (false Data length indicator ? 0x01 : 0)*/);  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	/*TODO: unsync'DLI*/int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	// Note: ID3v2.4 uses sync safe frame sizes  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 21) & 0x7F);  	tmpRawData [5] = (byte)((tmpFrameSize >> 14) & 0x7F);  	tmpRawData [6] = (byte)((tmpFrameSize >> 7) & 0x7F);  	tmpRawData [7] = (byte)(tmpFrameSize & 0x7F);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition++] = _groupingIdentity.Value;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	/*TODO: unsync'DLI*/} else {  	throw new ArgumentOutOfRangeException ("tagVersion"' tagVersion' "Unknown tag version");  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameHeader.cs,GetBytes,The following statement contains a magic number: if (tagVersion == ID3v2TagVersion.ID3v23) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x80 : 0) + (_isFileAlterPreservation ? 0x40 : 0) + (_isReadOnly ? 0x20 : 0));  	byte tmpByte2 = (byte)((_isCompressed ? 0x80 : 0) + (_encryptionMethod != null ? 0x40 : 0) + (_groupingIdentity != null ? 0x20 : 0));  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 24) & 0xFF);  	tmpRawData [5] = (byte)((tmpFrameSize >> 16) & 0xFF);  	tmpRawData [6] = (byte)((tmpFrameSize >> 8) & 0xFF);  	tmpRawData [7] = (byte)(tmpFrameSize & 0xFF);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition] = _groupingIdentity.Value;  } else if (tagVersion == ID3v2TagVersion.ID3v24) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x40 : 0) + (_isFileAlterPreservation ? 0x20 : 0) + (_isReadOnly ? 0x10 : 0));  	byte tmpByte2 = (byte)((_groupingIdentity != null ? 0x40 : 0) + (_isCompressed ? 0x08 : 0) + (_encryptionMethod != null ? 0x04 : 0)/* +                                   (false Unsynchronization ? 0x02 : 0) +                                   (false Data length indicator ? 0x01 : 0)*/);  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	/*TODO: unsync'DLI*/int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	// Note: ID3v2.4 uses sync safe frame sizes  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 21) & 0x7F);  	tmpRawData [5] = (byte)((tmpFrameSize >> 14) & 0x7F);  	tmpRawData [6] = (byte)((tmpFrameSize >> 7) & 0x7F);  	tmpRawData [7] = (byte)(tmpFrameSize & 0x7F);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition++] = _groupingIdentity.Value;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	/*TODO: unsync'DLI*/} else {  	throw new ArgumentOutOfRangeException ("tagVersion"' tagVersion' "Unknown tag version");  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameHeader.cs,GetBytes,The following statement contains a magic number: if (tagVersion == ID3v2TagVersion.ID3v23) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x80 : 0) + (_isFileAlterPreservation ? 0x40 : 0) + (_isReadOnly ? 0x20 : 0));  	byte tmpByte2 = (byte)((_isCompressed ? 0x80 : 0) + (_encryptionMethod != null ? 0x40 : 0) + (_groupingIdentity != null ? 0x20 : 0));  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 24) & 0xFF);  	tmpRawData [5] = (byte)((tmpFrameSize >> 16) & 0xFF);  	tmpRawData [6] = (byte)((tmpFrameSize >> 8) & 0xFF);  	tmpRawData [7] = (byte)(tmpFrameSize & 0xFF);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition] = _groupingIdentity.Value;  } else if (tagVersion == ID3v2TagVersion.ID3v24) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x40 : 0) + (_isFileAlterPreservation ? 0x20 : 0) + (_isReadOnly ? 0x10 : 0));  	byte tmpByte2 = (byte)((_groupingIdentity != null ? 0x40 : 0) + (_isCompressed ? 0x08 : 0) + (_encryptionMethod != null ? 0x04 : 0)/* +                                   (false Unsynchronization ? 0x02 : 0) +                                   (false Data length indicator ? 0x01 : 0)*/);  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	/*TODO: unsync'DLI*/int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	// Note: ID3v2.4 uses sync safe frame sizes  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 21) & 0x7F);  	tmpRawData [5] = (byte)((tmpFrameSize >> 14) & 0x7F);  	tmpRawData [6] = (byte)((tmpFrameSize >> 7) & 0x7F);  	tmpRawData [7] = (byte)(tmpFrameSize & 0x7F);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition++] = _groupingIdentity.Value;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	/*TODO: unsync'DLI*/} else {  	throw new ArgumentOutOfRangeException ("tagVersion"' tagVersion' "Unknown tag version");  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameHeader.cs,GetBytes,The following statement contains a magic number: if (tagVersion == ID3v2TagVersion.ID3v23) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x80 : 0) + (_isFileAlterPreservation ? 0x40 : 0) + (_isReadOnly ? 0x20 : 0));  	byte tmpByte2 = (byte)((_isCompressed ? 0x80 : 0) + (_encryptionMethod != null ? 0x40 : 0) + (_groupingIdentity != null ? 0x20 : 0));  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 24) & 0xFF);  	tmpRawData [5] = (byte)((tmpFrameSize >> 16) & 0xFF);  	tmpRawData [6] = (byte)((tmpFrameSize >> 8) & 0xFF);  	tmpRawData [7] = (byte)(tmpFrameSize & 0xFF);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition] = _groupingIdentity.Value;  } else if (tagVersion == ID3v2TagVersion.ID3v24) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x40 : 0) + (_isFileAlterPreservation ? 0x20 : 0) + (_isReadOnly ? 0x10 : 0));  	byte tmpByte2 = (byte)((_groupingIdentity != null ? 0x40 : 0) + (_isCompressed ? 0x08 : 0) + (_encryptionMethod != null ? 0x04 : 0)/* +                                   (false Unsynchronization ? 0x02 : 0) +                                   (false Data length indicator ? 0x01 : 0)*/);  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	/*TODO: unsync'DLI*/int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	// Note: ID3v2.4 uses sync safe frame sizes  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 21) & 0x7F);  	tmpRawData [5] = (byte)((tmpFrameSize >> 14) & 0x7F);  	tmpRawData [6] = (byte)((tmpFrameSize >> 7) & 0x7F);  	tmpRawData [7] = (byte)(tmpFrameSize & 0x7F);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition++] = _groupingIdentity.Value;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	/*TODO: unsync'DLI*/} else {  	throw new ArgumentOutOfRangeException ("tagVersion"' tagVersion' "Unknown tag version");  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameHeader.cs,GetBytes,The following statement contains a magic number: if (tagVersion == ID3v2TagVersion.ID3v23) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x80 : 0) + (_isFileAlterPreservation ? 0x40 : 0) + (_isReadOnly ? 0x20 : 0));  	byte tmpByte2 = (byte)((_isCompressed ? 0x80 : 0) + (_encryptionMethod != null ? 0x40 : 0) + (_groupingIdentity != null ? 0x20 : 0));  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 24) & 0xFF);  	tmpRawData [5] = (byte)((tmpFrameSize >> 16) & 0xFF);  	tmpRawData [6] = (byte)((tmpFrameSize >> 8) & 0xFF);  	tmpRawData [7] = (byte)(tmpFrameSize & 0xFF);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition] = _groupingIdentity.Value;  } else if (tagVersion == ID3v2TagVersion.ID3v24) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x40 : 0) + (_isFileAlterPreservation ? 0x20 : 0) + (_isReadOnly ? 0x10 : 0));  	byte tmpByte2 = (byte)((_groupingIdentity != null ? 0x40 : 0) + (_isCompressed ? 0x08 : 0) + (_encryptionMethod != null ? 0x04 : 0)/* +                                   (false Unsynchronization ? 0x02 : 0) +                                   (false Data length indicator ? 0x01 : 0)*/);  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	/*TODO: unsync'DLI*/int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	// Note: ID3v2.4 uses sync safe frame sizes  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 21) & 0x7F);  	tmpRawData [5] = (byte)((tmpFrameSize >> 14) & 0x7F);  	tmpRawData [6] = (byte)((tmpFrameSize >> 7) & 0x7F);  	tmpRawData [7] = (byte)(tmpFrameSize & 0x7F);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition++] = _groupingIdentity.Value;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	/*TODO: unsync'DLI*/} else {  	throw new ArgumentOutOfRangeException ("tagVersion"' tagVersion' "Unknown tag version");  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameHeader.cs,GetBytes,The following statement contains a magic number: if (tagVersion == ID3v2TagVersion.ID3v23) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x80 : 0) + (_isFileAlterPreservation ? 0x40 : 0) + (_isReadOnly ? 0x20 : 0));  	byte tmpByte2 = (byte)((_isCompressed ? 0x80 : 0) + (_encryptionMethod != null ? 0x40 : 0) + (_groupingIdentity != null ? 0x20 : 0));  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 24) & 0xFF);  	tmpRawData [5] = (byte)((tmpFrameSize >> 16) & 0xFF);  	tmpRawData [6] = (byte)((tmpFrameSize >> 8) & 0xFF);  	tmpRawData [7] = (byte)(tmpFrameSize & 0xFF);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition] = _groupingIdentity.Value;  } else if (tagVersion == ID3v2TagVersion.ID3v24) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x40 : 0) + (_isFileAlterPreservation ? 0x20 : 0) + (_isReadOnly ? 0x10 : 0));  	byte tmpByte2 = (byte)((_groupingIdentity != null ? 0x40 : 0) + (_isCompressed ? 0x08 : 0) + (_encryptionMethod != null ? 0x04 : 0)/* +                                   (false Unsynchronization ? 0x02 : 0) +                                   (false Data length indicator ? 0x01 : 0)*/);  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	/*TODO: unsync'DLI*/int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	// Note: ID3v2.4 uses sync safe frame sizes  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 21) & 0x7F);  	tmpRawData [5] = (byte)((tmpFrameSize >> 14) & 0x7F);  	tmpRawData [6] = (byte)((tmpFrameSize >> 7) & 0x7F);  	tmpRawData [7] = (byte)(tmpFrameSize & 0x7F);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition++] = _groupingIdentity.Value;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	/*TODO: unsync'DLI*/} else {  	throw new ArgumentOutOfRangeException ("tagVersion"' tagVersion' "Unknown tag version");  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameHeader.cs,GetBytes,The following statement contains a magic number: if (tagVersion == ID3v2TagVersion.ID3v23) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x80 : 0) + (_isFileAlterPreservation ? 0x40 : 0) + (_isReadOnly ? 0x20 : 0));  	byte tmpByte2 = (byte)((_isCompressed ? 0x80 : 0) + (_encryptionMethod != null ? 0x40 : 0) + (_groupingIdentity != null ? 0x20 : 0));  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 24) & 0xFF);  	tmpRawData [5] = (byte)((tmpFrameSize >> 16) & 0xFF);  	tmpRawData [6] = (byte)((tmpFrameSize >> 8) & 0xFF);  	tmpRawData [7] = (byte)(tmpFrameSize & 0xFF);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition] = _groupingIdentity.Value;  } else if (tagVersion == ID3v2TagVersion.ID3v24) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x40 : 0) + (_isFileAlterPreservation ? 0x20 : 0) + (_isReadOnly ? 0x10 : 0));  	byte tmpByte2 = (byte)((_groupingIdentity != null ? 0x40 : 0) + (_isCompressed ? 0x08 : 0) + (_encryptionMethod != null ? 0x04 : 0)/* +                                   (false Unsynchronization ? 0x02 : 0) +                                   (false Data length indicator ? 0x01 : 0)*/);  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	/*TODO: unsync'DLI*/int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	// Note: ID3v2.4 uses sync safe frame sizes  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 21) & 0x7F);  	tmpRawData [5] = (byte)((tmpFrameSize >> 14) & 0x7F);  	tmpRawData [6] = (byte)((tmpFrameSize >> 7) & 0x7F);  	tmpRawData [7] = (byte)(tmpFrameSize & 0x7F);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition++] = _groupingIdentity.Value;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	/*TODO: unsync'DLI*/} else {  	throw new ArgumentOutOfRangeException ("tagVersion"' tagVersion' "Unknown tag version");  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameHeader.cs,GetBytes,The following statement contains a magic number: if (tagVersion == ID3v2TagVersion.ID3v23) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x80 : 0) + (_isFileAlterPreservation ? 0x40 : 0) + (_isReadOnly ? 0x20 : 0));  	byte tmpByte2 = (byte)((_isCompressed ? 0x80 : 0) + (_encryptionMethod != null ? 0x40 : 0) + (_groupingIdentity != null ? 0x20 : 0));  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 24) & 0xFF);  	tmpRawData [5] = (byte)((tmpFrameSize >> 16) & 0xFF);  	tmpRawData [6] = (byte)((tmpFrameSize >> 8) & 0xFF);  	tmpRawData [7] = (byte)(tmpFrameSize & 0xFF);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition] = _groupingIdentity.Value;  } else if (tagVersion == ID3v2TagVersion.ID3v24) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x40 : 0) + (_isFileAlterPreservation ? 0x20 : 0) + (_isReadOnly ? 0x10 : 0));  	byte tmpByte2 = (byte)((_groupingIdentity != null ? 0x40 : 0) + (_isCompressed ? 0x08 : 0) + (_encryptionMethod != null ? 0x04 : 0)/* +                                   (false Unsynchronization ? 0x02 : 0) +                                   (false Data length indicator ? 0x01 : 0)*/);  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	/*TODO: unsync'DLI*/int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	// Note: ID3v2.4 uses sync safe frame sizes  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 21) & 0x7F);  	tmpRawData [5] = (byte)((tmpFrameSize >> 14) & 0x7F);  	tmpRawData [6] = (byte)((tmpFrameSize >> 7) & 0x7F);  	tmpRawData [7] = (byte)(tmpFrameSize & 0x7F);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition++] = _groupingIdentity.Value;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	/*TODO: unsync'DLI*/} else {  	throw new ArgumentOutOfRangeException ("tagVersion"' tagVersion' "Unknown tag version");  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameHeader.cs,GetBytes,The following statement contains a magic number: if (tagVersion == ID3v2TagVersion.ID3v23) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x80 : 0) + (_isFileAlterPreservation ? 0x40 : 0) + (_isReadOnly ? 0x20 : 0));  	byte tmpByte2 = (byte)((_isCompressed ? 0x80 : 0) + (_encryptionMethod != null ? 0x40 : 0) + (_groupingIdentity != null ? 0x20 : 0));  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 24) & 0xFF);  	tmpRawData [5] = (byte)((tmpFrameSize >> 16) & 0xFF);  	tmpRawData [6] = (byte)((tmpFrameSize >> 8) & 0xFF);  	tmpRawData [7] = (byte)(tmpFrameSize & 0xFF);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition] = _groupingIdentity.Value;  } else if (tagVersion == ID3v2TagVersion.ID3v24) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x40 : 0) + (_isFileAlterPreservation ? 0x20 : 0) + (_isReadOnly ? 0x10 : 0));  	byte tmpByte2 = (byte)((_groupingIdentity != null ? 0x40 : 0) + (_isCompressed ? 0x08 : 0) + (_encryptionMethod != null ? 0x04 : 0)/* +                                   (false Unsynchronization ? 0x02 : 0) +                                   (false Data length indicator ? 0x01 : 0)*/);  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	/*TODO: unsync'DLI*/int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	// Note: ID3v2.4 uses sync safe frame sizes  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 21) & 0x7F);  	tmpRawData [5] = (byte)((tmpFrameSize >> 14) & 0x7F);  	tmpRawData [6] = (byte)((tmpFrameSize >> 7) & 0x7F);  	tmpRawData [7] = (byte)(tmpFrameSize & 0x7F);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition++] = _groupingIdentity.Value;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	/*TODO: unsync'DLI*/} else {  	throw new ArgumentOutOfRangeException ("tagVersion"' tagVersion' "Unknown tag version");  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameHeader.cs,GetBytes,The following statement contains a magic number: if (tagVersion == ID3v2TagVersion.ID3v23) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x80 : 0) + (_isFileAlterPreservation ? 0x40 : 0) + (_isReadOnly ? 0x20 : 0));  	byte tmpByte2 = (byte)((_isCompressed ? 0x80 : 0) + (_encryptionMethod != null ? 0x40 : 0) + (_groupingIdentity != null ? 0x20 : 0));  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 24) & 0xFF);  	tmpRawData [5] = (byte)((tmpFrameSize >> 16) & 0xFF);  	tmpRawData [6] = (byte)((tmpFrameSize >> 8) & 0xFF);  	tmpRawData [7] = (byte)(tmpFrameSize & 0xFF);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition] = _groupingIdentity.Value;  } else if (tagVersion == ID3v2TagVersion.ID3v24) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x40 : 0) + (_isFileAlterPreservation ? 0x20 : 0) + (_isReadOnly ? 0x10 : 0));  	byte tmpByte2 = (byte)((_groupingIdentity != null ? 0x40 : 0) + (_isCompressed ? 0x08 : 0) + (_encryptionMethod != null ? 0x04 : 0)/* +                                   (false Unsynchronization ? 0x02 : 0) +                                   (false Data length indicator ? 0x01 : 0)*/);  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	/*TODO: unsync'DLI*/int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	// Note: ID3v2.4 uses sync safe frame sizes  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 21) & 0x7F);  	tmpRawData [5] = (byte)((tmpFrameSize >> 14) & 0x7F);  	tmpRawData [6] = (byte)((tmpFrameSize >> 7) & 0x7F);  	tmpRawData [7] = (byte)(tmpFrameSize & 0x7F);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition++] = _groupingIdentity.Value;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	/*TODO: unsync'DLI*/} else {  	throw new ArgumentOutOfRangeException ("tagVersion"' tagVersion' "Unknown tag version");  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameHeader.cs,GetBytes,The following statement contains a magic number: if (tagVersion == ID3v2TagVersion.ID3v23) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x80 : 0) + (_isFileAlterPreservation ? 0x40 : 0) + (_isReadOnly ? 0x20 : 0));  	byte tmpByte2 = (byte)((_isCompressed ? 0x80 : 0) + (_encryptionMethod != null ? 0x40 : 0) + (_groupingIdentity != null ? 0x20 : 0));  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 24) & 0xFF);  	tmpRawData [5] = (byte)((tmpFrameSize >> 16) & 0xFF);  	tmpRawData [6] = (byte)((tmpFrameSize >> 8) & 0xFF);  	tmpRawData [7] = (byte)(tmpFrameSize & 0xFF);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition] = _groupingIdentity.Value;  } else if (tagVersion == ID3v2TagVersion.ID3v24) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x40 : 0) + (_isFileAlterPreservation ? 0x20 : 0) + (_isReadOnly ? 0x10 : 0));  	byte tmpByte2 = (byte)((_groupingIdentity != null ? 0x40 : 0) + (_isCompressed ? 0x08 : 0) + (_encryptionMethod != null ? 0x04 : 0)/* +                                   (false Unsynchronization ? 0x02 : 0) +                                   (false Data length indicator ? 0x01 : 0)*/);  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	/*TODO: unsync'DLI*/int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	// Note: ID3v2.4 uses sync safe frame sizes  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 21) & 0x7F);  	tmpRawData [5] = (byte)((tmpFrameSize >> 14) & 0x7F);  	tmpRawData [6] = (byte)((tmpFrameSize >> 7) & 0x7F);  	tmpRawData [7] = (byte)(tmpFrameSize & 0x7F);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition++] = _groupingIdentity.Value;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	/*TODO: unsync'DLI*/} else {  	throw new ArgumentOutOfRangeException ("tagVersion"' tagVersion' "Unknown tag version");  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameHeader.cs,GetBytes,The following statement contains a magic number: if (tagVersion == ID3v2TagVersion.ID3v23) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x80 : 0) + (_isFileAlterPreservation ? 0x40 : 0) + (_isReadOnly ? 0x20 : 0));  	byte tmpByte2 = (byte)((_isCompressed ? 0x80 : 0) + (_encryptionMethod != null ? 0x40 : 0) + (_groupingIdentity != null ? 0x20 : 0));  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 24) & 0xFF);  	tmpRawData [5] = (byte)((tmpFrameSize >> 16) & 0xFF);  	tmpRawData [6] = (byte)((tmpFrameSize >> 8) & 0xFF);  	tmpRawData [7] = (byte)(tmpFrameSize & 0xFF);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition] = _groupingIdentity.Value;  } else if (tagVersion == ID3v2TagVersion.ID3v24) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x40 : 0) + (_isFileAlterPreservation ? 0x20 : 0) + (_isReadOnly ? 0x10 : 0));  	byte tmpByte2 = (byte)((_groupingIdentity != null ? 0x40 : 0) + (_isCompressed ? 0x08 : 0) + (_encryptionMethod != null ? 0x04 : 0)/* +                                   (false Unsynchronization ? 0x02 : 0) +                                   (false Data length indicator ? 0x01 : 0)*/);  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	/*TODO: unsync'DLI*/int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	// Note: ID3v2.4 uses sync safe frame sizes  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 21) & 0x7F);  	tmpRawData [5] = (byte)((tmpFrameSize >> 14) & 0x7F);  	tmpRawData [6] = (byte)((tmpFrameSize >> 7) & 0x7F);  	tmpRawData [7] = (byte)(tmpFrameSize & 0x7F);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition++] = _groupingIdentity.Value;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	/*TODO: unsync'DLI*/} else {  	throw new ArgumentOutOfRangeException ("tagVersion"' tagVersion' "Unknown tag version");  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameHeader.cs,GetBytes,The following statement contains a magic number: if (tagVersion == ID3v2TagVersion.ID3v23) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x80 : 0) + (_isFileAlterPreservation ? 0x40 : 0) + (_isReadOnly ? 0x20 : 0));  	byte tmpByte2 = (byte)((_isCompressed ? 0x80 : 0) + (_encryptionMethod != null ? 0x40 : 0) + (_groupingIdentity != null ? 0x20 : 0));  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 24) & 0xFF);  	tmpRawData [5] = (byte)((tmpFrameSize >> 16) & 0xFF);  	tmpRawData [6] = (byte)((tmpFrameSize >> 8) & 0xFF);  	tmpRawData [7] = (byte)(tmpFrameSize & 0xFF);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition] = _groupingIdentity.Value;  } else if (tagVersion == ID3v2TagVersion.ID3v24) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x40 : 0) + (_isFileAlterPreservation ? 0x20 : 0) + (_isReadOnly ? 0x10 : 0));  	byte tmpByte2 = (byte)((_groupingIdentity != null ? 0x40 : 0) + (_isCompressed ? 0x08 : 0) + (_encryptionMethod != null ? 0x04 : 0)/* +                                   (false Unsynchronization ? 0x02 : 0) +                                   (false Data length indicator ? 0x01 : 0)*/);  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	/*TODO: unsync'DLI*/int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	// Note: ID3v2.4 uses sync safe frame sizes  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 21) & 0x7F);  	tmpRawData [5] = (byte)((tmpFrameSize >> 14) & 0x7F);  	tmpRawData [6] = (byte)((tmpFrameSize >> 7) & 0x7F);  	tmpRawData [7] = (byte)(tmpFrameSize & 0x7F);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition++] = _groupingIdentity.Value;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	/*TODO: unsync'DLI*/} else {  	throw new ArgumentOutOfRangeException ("tagVersion"' tagVersion' "Unknown tag version");  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameHeader.cs,GetBytes,The following statement contains a magic number: if (tagVersion == ID3v2TagVersion.ID3v23) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x80 : 0) + (_isFileAlterPreservation ? 0x40 : 0) + (_isReadOnly ? 0x20 : 0));  	byte tmpByte2 = (byte)((_isCompressed ? 0x80 : 0) + (_encryptionMethod != null ? 0x40 : 0) + (_groupingIdentity != null ? 0x20 : 0));  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 24) & 0xFF);  	tmpRawData [5] = (byte)((tmpFrameSize >> 16) & 0xFF);  	tmpRawData [6] = (byte)((tmpFrameSize >> 8) & 0xFF);  	tmpRawData [7] = (byte)(tmpFrameSize & 0xFF);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition] = _groupingIdentity.Value;  } else if (tagVersion == ID3v2TagVersion.ID3v24) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x40 : 0) + (_isFileAlterPreservation ? 0x20 : 0) + (_isReadOnly ? 0x10 : 0));  	byte tmpByte2 = (byte)((_groupingIdentity != null ? 0x40 : 0) + (_isCompressed ? 0x08 : 0) + (_encryptionMethod != null ? 0x04 : 0)/* +                                   (false Unsynchronization ? 0x02 : 0) +                                   (false Data length indicator ? 0x01 : 0)*/);  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	/*TODO: unsync'DLI*/int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	// Note: ID3v2.4 uses sync safe frame sizes  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 21) & 0x7F);  	tmpRawData [5] = (byte)((tmpFrameSize >> 14) & 0x7F);  	tmpRawData [6] = (byte)((tmpFrameSize >> 7) & 0x7F);  	tmpRawData [7] = (byte)(tmpFrameSize & 0x7F);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition++] = _groupingIdentity.Value;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	/*TODO: unsync'DLI*/} else {  	throw new ArgumentOutOfRangeException ("tagVersion"' tagVersion' "Unknown tag version");  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameHeader.cs,GetBytes,The following statement contains a magic number: if (tagVersion == ID3v2TagVersion.ID3v23) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x80 : 0) + (_isFileAlterPreservation ? 0x40 : 0) + (_isReadOnly ? 0x20 : 0));  	byte tmpByte2 = (byte)((_isCompressed ? 0x80 : 0) + (_encryptionMethod != null ? 0x40 : 0) + (_groupingIdentity != null ? 0x20 : 0));  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 24) & 0xFF);  	tmpRawData [5] = (byte)((tmpFrameSize >> 16) & 0xFF);  	tmpRawData [6] = (byte)((tmpFrameSize >> 8) & 0xFF);  	tmpRawData [7] = (byte)(tmpFrameSize & 0xFF);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition] = _groupingIdentity.Value;  } else if (tagVersion == ID3v2TagVersion.ID3v24) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x40 : 0) + (_isFileAlterPreservation ? 0x20 : 0) + (_isReadOnly ? 0x10 : 0));  	byte tmpByte2 = (byte)((_groupingIdentity != null ? 0x40 : 0) + (_isCompressed ? 0x08 : 0) + (_encryptionMethod != null ? 0x04 : 0)/* +                                   (false Unsynchronization ? 0x02 : 0) +                                   (false Data length indicator ? 0x01 : 0)*/);  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	/*TODO: unsync'DLI*/int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	// Note: ID3v2.4 uses sync safe frame sizes  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 21) & 0x7F);  	tmpRawData [5] = (byte)((tmpFrameSize >> 14) & 0x7F);  	tmpRawData [6] = (byte)((tmpFrameSize >> 7) & 0x7F);  	tmpRawData [7] = (byte)(tmpFrameSize & 0x7F);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition++] = _groupingIdentity.Value;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	/*TODO: unsync'DLI*/} else {  	throw new ArgumentOutOfRangeException ("tagVersion"' tagVersion' "Unknown tag version");  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameHeader.cs,GetBytes,The following statement contains a magic number: if (tagVersion == ID3v2TagVersion.ID3v23) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x80 : 0) + (_isFileAlterPreservation ? 0x40 : 0) + (_isReadOnly ? 0x20 : 0));  	byte tmpByte2 = (byte)((_isCompressed ? 0x80 : 0) + (_encryptionMethod != null ? 0x40 : 0) + (_groupingIdentity != null ? 0x20 : 0));  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 24) & 0xFF);  	tmpRawData [5] = (byte)((tmpFrameSize >> 16) & 0xFF);  	tmpRawData [6] = (byte)((tmpFrameSize >> 8) & 0xFF);  	tmpRawData [7] = (byte)(tmpFrameSize & 0xFF);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition] = _groupingIdentity.Value;  } else if (tagVersion == ID3v2TagVersion.ID3v24) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x40 : 0) + (_isFileAlterPreservation ? 0x20 : 0) + (_isReadOnly ? 0x10 : 0));  	byte tmpByte2 = (byte)((_groupingIdentity != null ? 0x40 : 0) + (_isCompressed ? 0x08 : 0) + (_encryptionMethod != null ? 0x04 : 0)/* +                                   (false Unsynchronization ? 0x02 : 0) +                                   (false Data length indicator ? 0x01 : 0)*/);  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	/*TODO: unsync'DLI*/int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	// Note: ID3v2.4 uses sync safe frame sizes  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 21) & 0x7F);  	tmpRawData [5] = (byte)((tmpFrameSize >> 14) & 0x7F);  	tmpRawData [6] = (byte)((tmpFrameSize >> 7) & 0x7F);  	tmpRawData [7] = (byte)(tmpFrameSize & 0x7F);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition++] = _groupingIdentity.Value;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	/*TODO: unsync'DLI*/} else {  	throw new ArgumentOutOfRangeException ("tagVersion"' tagVersion' "Unknown tag version");  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameHeader.cs,GetBytes,The following statement contains a magic number: if (tagVersion == ID3v2TagVersion.ID3v23) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x80 : 0) + (_isFileAlterPreservation ? 0x40 : 0) + (_isReadOnly ? 0x20 : 0));  	byte tmpByte2 = (byte)((_isCompressed ? 0x80 : 0) + (_encryptionMethod != null ? 0x40 : 0) + (_groupingIdentity != null ? 0x20 : 0));  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 24) & 0xFF);  	tmpRawData [5] = (byte)((tmpFrameSize >> 16) & 0xFF);  	tmpRawData [6] = (byte)((tmpFrameSize >> 8) & 0xFF);  	tmpRawData [7] = (byte)(tmpFrameSize & 0xFF);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition] = _groupingIdentity.Value;  } else if (tagVersion == ID3v2TagVersion.ID3v24) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x40 : 0) + (_isFileAlterPreservation ? 0x20 : 0) + (_isReadOnly ? 0x10 : 0));  	byte tmpByte2 = (byte)((_groupingIdentity != null ? 0x40 : 0) + (_isCompressed ? 0x08 : 0) + (_encryptionMethod != null ? 0x04 : 0)/* +                                   (false Unsynchronization ? 0x02 : 0) +                                   (false Data length indicator ? 0x01 : 0)*/);  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	/*TODO: unsync'DLI*/int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	// Note: ID3v2.4 uses sync safe frame sizes  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 21) & 0x7F);  	tmpRawData [5] = (byte)((tmpFrameSize >> 14) & 0x7F);  	tmpRawData [6] = (byte)((tmpFrameSize >> 7) & 0x7F);  	tmpRawData [7] = (byte)(tmpFrameSize & 0x7F);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition++] = _groupingIdentity.Value;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	/*TODO: unsync'DLI*/} else {  	throw new ArgumentOutOfRangeException ("tagVersion"' tagVersion' "Unknown tag version");  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameHeader.cs,GetBytes,The following statement contains a magic number: if (tagVersion == ID3v2TagVersion.ID3v23) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x80 : 0) + (_isFileAlterPreservation ? 0x40 : 0) + (_isReadOnly ? 0x20 : 0));  	byte tmpByte2 = (byte)((_isCompressed ? 0x80 : 0) + (_encryptionMethod != null ? 0x40 : 0) + (_groupingIdentity != null ? 0x20 : 0));  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 24) & 0xFF);  	tmpRawData [5] = (byte)((tmpFrameSize >> 16) & 0xFF);  	tmpRawData [6] = (byte)((tmpFrameSize >> 8) & 0xFF);  	tmpRawData [7] = (byte)(tmpFrameSize & 0xFF);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition] = _groupingIdentity.Value;  } else if (tagVersion == ID3v2TagVersion.ID3v24) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x40 : 0) + (_isFileAlterPreservation ? 0x20 : 0) + (_isReadOnly ? 0x10 : 0));  	byte tmpByte2 = (byte)((_groupingIdentity != null ? 0x40 : 0) + (_isCompressed ? 0x08 : 0) + (_encryptionMethod != null ? 0x04 : 0)/* +                                   (false Unsynchronization ? 0x02 : 0) +                                   (false Data length indicator ? 0x01 : 0)*/);  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	/*TODO: unsync'DLI*/int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	// Note: ID3v2.4 uses sync safe frame sizes  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 21) & 0x7F);  	tmpRawData [5] = (byte)((tmpFrameSize >> 14) & 0x7F);  	tmpRawData [6] = (byte)((tmpFrameSize >> 7) & 0x7F);  	tmpRawData [7] = (byte)(tmpFrameSize & 0x7F);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition++] = _groupingIdentity.Value;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	/*TODO: unsync'DLI*/} else {  	throw new ArgumentOutOfRangeException ("tagVersion"' tagVersion' "Unknown tag version");  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameHeader.cs,GetBytes,The following statement contains a magic number: if (tagVersion == ID3v2TagVersion.ID3v23) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x80 : 0) + (_isFileAlterPreservation ? 0x40 : 0) + (_isReadOnly ? 0x20 : 0));  	byte tmpByte2 = (byte)((_isCompressed ? 0x80 : 0) + (_encryptionMethod != null ? 0x40 : 0) + (_groupingIdentity != null ? 0x20 : 0));  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 24) & 0xFF);  	tmpRawData [5] = (byte)((tmpFrameSize >> 16) & 0xFF);  	tmpRawData [6] = (byte)((tmpFrameSize >> 8) & 0xFF);  	tmpRawData [7] = (byte)(tmpFrameSize & 0xFF);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition] = _groupingIdentity.Value;  } else if (tagVersion == ID3v2TagVersion.ID3v24) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x40 : 0) + (_isFileAlterPreservation ? 0x20 : 0) + (_isReadOnly ? 0x10 : 0));  	byte tmpByte2 = (byte)((_groupingIdentity != null ? 0x40 : 0) + (_isCompressed ? 0x08 : 0) + (_encryptionMethod != null ? 0x04 : 0)/* +                                   (false Unsynchronization ? 0x02 : 0) +                                   (false Data length indicator ? 0x01 : 0)*/);  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	/*TODO: unsync'DLI*/int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	// Note: ID3v2.4 uses sync safe frame sizes  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 21) & 0x7F);  	tmpRawData [5] = (byte)((tmpFrameSize >> 14) & 0x7F);  	tmpRawData [6] = (byte)((tmpFrameSize >> 7) & 0x7F);  	tmpRawData [7] = (byte)(tmpFrameSize & 0x7F);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition++] = _groupingIdentity.Value;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	/*TODO: unsync'DLI*/} else {  	throw new ArgumentOutOfRangeException ("tagVersion"' tagVersion' "Unknown tag version");  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameHeader.cs,GetBytes,The following statement contains a magic number: if (tagVersion == ID3v2TagVersion.ID3v23) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x80 : 0) + (_isFileAlterPreservation ? 0x40 : 0) + (_isReadOnly ? 0x20 : 0));  	byte tmpByte2 = (byte)((_isCompressed ? 0x80 : 0) + (_encryptionMethod != null ? 0x40 : 0) + (_groupingIdentity != null ? 0x20 : 0));  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 24) & 0xFF);  	tmpRawData [5] = (byte)((tmpFrameSize >> 16) & 0xFF);  	tmpRawData [6] = (byte)((tmpFrameSize >> 8) & 0xFF);  	tmpRawData [7] = (byte)(tmpFrameSize & 0xFF);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition] = _groupingIdentity.Value;  } else if (tagVersion == ID3v2TagVersion.ID3v24) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x40 : 0) + (_isFileAlterPreservation ? 0x20 : 0) + (_isReadOnly ? 0x10 : 0));  	byte tmpByte2 = (byte)((_groupingIdentity != null ? 0x40 : 0) + (_isCompressed ? 0x08 : 0) + (_encryptionMethod != null ? 0x04 : 0)/* +                                   (false Unsynchronization ? 0x02 : 0) +                                   (false Data length indicator ? 0x01 : 0)*/);  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	/*TODO: unsync'DLI*/int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	// Note: ID3v2.4 uses sync safe frame sizes  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 21) & 0x7F);  	tmpRawData [5] = (byte)((tmpFrameSize >> 14) & 0x7F);  	tmpRawData [6] = (byte)((tmpFrameSize >> 7) & 0x7F);  	tmpRawData [7] = (byte)(tmpFrameSize & 0x7F);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition++] = _groupingIdentity.Value;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	/*TODO: unsync'DLI*/} else {  	throw new ArgumentOutOfRangeException ("tagVersion"' tagVersion' "Unknown tag version");  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameHeader.cs,GetBytes,The following statement contains a magic number: if (tagVersion == ID3v2TagVersion.ID3v23) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x80 : 0) + (_isFileAlterPreservation ? 0x40 : 0) + (_isReadOnly ? 0x20 : 0));  	byte tmpByte2 = (byte)((_isCompressed ? 0x80 : 0) + (_encryptionMethod != null ? 0x40 : 0) + (_groupingIdentity != null ? 0x20 : 0));  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 24) & 0xFF);  	tmpRawData [5] = (byte)((tmpFrameSize >> 16) & 0xFF);  	tmpRawData [6] = (byte)((tmpFrameSize >> 8) & 0xFF);  	tmpRawData [7] = (byte)(tmpFrameSize & 0xFF);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition] = _groupingIdentity.Value;  } else if (tagVersion == ID3v2TagVersion.ID3v24) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x40 : 0) + (_isFileAlterPreservation ? 0x20 : 0) + (_isReadOnly ? 0x10 : 0));  	byte tmpByte2 = (byte)((_groupingIdentity != null ? 0x40 : 0) + (_isCompressed ? 0x08 : 0) + (_encryptionMethod != null ? 0x04 : 0)/* +                                   (false Unsynchronization ? 0x02 : 0) +                                   (false Data length indicator ? 0x01 : 0)*/);  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	/*TODO: unsync'DLI*/int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	// Note: ID3v2.4 uses sync safe frame sizes  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 21) & 0x7F);  	tmpRawData [5] = (byte)((tmpFrameSize >> 14) & 0x7F);  	tmpRawData [6] = (byte)((tmpFrameSize >> 7) & 0x7F);  	tmpRawData [7] = (byte)(tmpFrameSize & 0x7F);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition++] = _groupingIdentity.Value;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	/*TODO: unsync'DLI*/} else {  	throw new ArgumentOutOfRangeException ("tagVersion"' tagVersion' "Unknown tag version");  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameHeader.cs,GetBytes,The following statement contains a magic number: if (tagVersion == ID3v2TagVersion.ID3v23) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x80 : 0) + (_isFileAlterPreservation ? 0x40 : 0) + (_isReadOnly ? 0x20 : 0));  	byte tmpByte2 = (byte)((_isCompressed ? 0x80 : 0) + (_encryptionMethod != null ? 0x40 : 0) + (_groupingIdentity != null ? 0x20 : 0));  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 24) & 0xFF);  	tmpRawData [5] = (byte)((tmpFrameSize >> 16) & 0xFF);  	tmpRawData [6] = (byte)((tmpFrameSize >> 8) & 0xFF);  	tmpRawData [7] = (byte)(tmpFrameSize & 0xFF);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition] = _groupingIdentity.Value;  } else if (tagVersion == ID3v2TagVersion.ID3v24) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x40 : 0) + (_isFileAlterPreservation ? 0x20 : 0) + (_isReadOnly ? 0x10 : 0));  	byte tmpByte2 = (byte)((_groupingIdentity != null ? 0x40 : 0) + (_isCompressed ? 0x08 : 0) + (_encryptionMethod != null ? 0x04 : 0)/* +                                   (false Unsynchronization ? 0x02 : 0) +                                   (false Data length indicator ? 0x01 : 0)*/);  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	/*TODO: unsync'DLI*/int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	// Note: ID3v2.4 uses sync safe frame sizes  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 21) & 0x7F);  	tmpRawData [5] = (byte)((tmpFrameSize >> 14) & 0x7F);  	tmpRawData [6] = (byte)((tmpFrameSize >> 7) & 0x7F);  	tmpRawData [7] = (byte)(tmpFrameSize & 0x7F);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition++] = _groupingIdentity.Value;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	/*TODO: unsync'DLI*/} else {  	throw new ArgumentOutOfRangeException ("tagVersion"' tagVersion' "Unknown tag version");  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameHeader.cs,GetBytes,The following statement contains a magic number: if (tagVersion == ID3v2TagVersion.ID3v23) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x80 : 0) + (_isFileAlterPreservation ? 0x40 : 0) + (_isReadOnly ? 0x20 : 0));  	byte tmpByte2 = (byte)((_isCompressed ? 0x80 : 0) + (_encryptionMethod != null ? 0x40 : 0) + (_groupingIdentity != null ? 0x20 : 0));  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 24) & 0xFF);  	tmpRawData [5] = (byte)((tmpFrameSize >> 16) & 0xFF);  	tmpRawData [6] = (byte)((tmpFrameSize >> 8) & 0xFF);  	tmpRawData [7] = (byte)(tmpFrameSize & 0xFF);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition] = _groupingIdentity.Value;  } else if (tagVersion == ID3v2TagVersion.ID3v24) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x40 : 0) + (_isFileAlterPreservation ? 0x20 : 0) + (_isReadOnly ? 0x10 : 0));  	byte tmpByte2 = (byte)((_groupingIdentity != null ? 0x40 : 0) + (_isCompressed ? 0x08 : 0) + (_encryptionMethod != null ? 0x04 : 0)/* +                                   (false Unsynchronization ? 0x02 : 0) +                                   (false Data length indicator ? 0x01 : 0)*/);  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	/*TODO: unsync'DLI*/int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	// Note: ID3v2.4 uses sync safe frame sizes  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 21) & 0x7F);  	tmpRawData [5] = (byte)((tmpFrameSize >> 14) & 0x7F);  	tmpRawData [6] = (byte)((tmpFrameSize >> 7) & 0x7F);  	tmpRawData [7] = (byte)(tmpFrameSize & 0x7F);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition++] = _groupingIdentity.Value;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	/*TODO: unsync'DLI*/} else {  	throw new ArgumentOutOfRangeException ("tagVersion"' tagVersion' "Unknown tag version");  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameHeader.cs,GetBytes,The following statement contains a magic number: if (tagVersion == ID3v2TagVersion.ID3v23) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x80 : 0) + (_isFileAlterPreservation ? 0x40 : 0) + (_isReadOnly ? 0x20 : 0));  	byte tmpByte2 = (byte)((_isCompressed ? 0x80 : 0) + (_encryptionMethod != null ? 0x40 : 0) + (_groupingIdentity != null ? 0x20 : 0));  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 24) & 0xFF);  	tmpRawData [5] = (byte)((tmpFrameSize >> 16) & 0xFF);  	tmpRawData [6] = (byte)((tmpFrameSize >> 8) & 0xFF);  	tmpRawData [7] = (byte)(tmpFrameSize & 0xFF);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition] = _groupingIdentity.Value;  } else if (tagVersion == ID3v2TagVersion.ID3v24) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x40 : 0) + (_isFileAlterPreservation ? 0x20 : 0) + (_isReadOnly ? 0x10 : 0));  	byte tmpByte2 = (byte)((_groupingIdentity != null ? 0x40 : 0) + (_isCompressed ? 0x08 : 0) + (_encryptionMethod != null ? 0x04 : 0)/* +                                   (false Unsynchronization ? 0x02 : 0) +                                   (false Data length indicator ? 0x01 : 0)*/);  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	/*TODO: unsync'DLI*/int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	// Note: ID3v2.4 uses sync safe frame sizes  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 21) & 0x7F);  	tmpRawData [5] = (byte)((tmpFrameSize >> 14) & 0x7F);  	tmpRawData [6] = (byte)((tmpFrameSize >> 7) & 0x7F);  	tmpRawData [7] = (byte)(tmpFrameSize & 0x7F);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition++] = _groupingIdentity.Value;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	/*TODO: unsync'DLI*/} else {  	throw new ArgumentOutOfRangeException ("tagVersion"' tagVersion' "Unknown tag version");  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameHeader.cs,GetBytes,The following statement contains a magic number: if (tagVersion == ID3v2TagVersion.ID3v23) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x80 : 0) + (_isFileAlterPreservation ? 0x40 : 0) + (_isReadOnly ? 0x20 : 0));  	byte tmpByte2 = (byte)((_isCompressed ? 0x80 : 0) + (_encryptionMethod != null ? 0x40 : 0) + (_groupingIdentity != null ? 0x20 : 0));  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 24) & 0xFF);  	tmpRawData [5] = (byte)((tmpFrameSize >> 16) & 0xFF);  	tmpRawData [6] = (byte)((tmpFrameSize >> 8) & 0xFF);  	tmpRawData [7] = (byte)(tmpFrameSize & 0xFF);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition] = _groupingIdentity.Value;  } else if (tagVersion == ID3v2TagVersion.ID3v24) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x40 : 0) + (_isFileAlterPreservation ? 0x20 : 0) + (_isReadOnly ? 0x10 : 0));  	byte tmpByte2 = (byte)((_groupingIdentity != null ? 0x40 : 0) + (_isCompressed ? 0x08 : 0) + (_encryptionMethod != null ? 0x04 : 0)/* +                                   (false Unsynchronization ? 0x02 : 0) +                                   (false Data length indicator ? 0x01 : 0)*/);  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	/*TODO: unsync'DLI*/int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	// Note: ID3v2.4 uses sync safe frame sizes  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 21) & 0x7F);  	tmpRawData [5] = (byte)((tmpFrameSize >> 14) & 0x7F);  	tmpRawData [6] = (byte)((tmpFrameSize >> 7) & 0x7F);  	tmpRawData [7] = (byte)(tmpFrameSize & 0x7F);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition++] = _groupingIdentity.Value;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	/*TODO: unsync'DLI*/} else {  	throw new ArgumentOutOfRangeException ("tagVersion"' tagVersion' "Unknown tag version");  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameHeader.cs,GetBytes,The following statement contains a magic number: if (_isCompressed)  	tmpRawDataSize += 4;  
Magic Number,IdSharp.Tagging.ID3v2,FrameHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameHeader.cs,GetBytes,The following statement contains a magic number: tmpRawDataSize += 4;  
Magic Number,IdSharp.Tagging.ID3v2,FrameHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameHeader.cs,GetBytes,The following statement contains a magic number: if (frameIDBytes.Length != 4)  	throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  
Magic Number,IdSharp.Tagging.ID3v2,FrameHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameHeader.cs,GetBytes,The following statement contains a magic number: tmpRawData [2] = frameIDBytes [2];  
Magic Number,IdSharp.Tagging.ID3v2,FrameHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameHeader.cs,GetBytes,The following statement contains a magic number: tmpRawData [2] = frameIDBytes [2];  
Magic Number,IdSharp.Tagging.ID3v2,FrameHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameHeader.cs,GetBytes,The following statement contains a magic number: tmpRawData [3] = frameIDBytes [3];  
Magic Number,IdSharp.Tagging.ID3v2,FrameHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameHeader.cs,GetBytes,The following statement contains a magic number: tmpRawData [3] = frameIDBytes [3];  
Magic Number,IdSharp.Tagging.ID3v2,FrameHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameHeader.cs,GetBytes,The following statement contains a magic number: tmpRawData [4] = (byte)((tmpFrameSize >> 24) & 0xFF);  
Magic Number,IdSharp.Tagging.ID3v2,FrameHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameHeader.cs,GetBytes,The following statement contains a magic number: tmpRawData [4] = (byte)((tmpFrameSize >> 24) & 0xFF);  
Magic Number,IdSharp.Tagging.ID3v2,FrameHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameHeader.cs,GetBytes,The following statement contains a magic number: tmpRawData [5] = (byte)((tmpFrameSize >> 16) & 0xFF);  
Magic Number,IdSharp.Tagging.ID3v2,FrameHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameHeader.cs,GetBytes,The following statement contains a magic number: tmpRawData [5] = (byte)((tmpFrameSize >> 16) & 0xFF);  
Magic Number,IdSharp.Tagging.ID3v2,FrameHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameHeader.cs,GetBytes,The following statement contains a magic number: tmpRawData [6] = (byte)((tmpFrameSize >> 8) & 0xFF);  
Magic Number,IdSharp.Tagging.ID3v2,FrameHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameHeader.cs,GetBytes,The following statement contains a magic number: tmpRawData [6] = (byte)((tmpFrameSize >> 8) & 0xFF);  
Magic Number,IdSharp.Tagging.ID3v2,FrameHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameHeader.cs,GetBytes,The following statement contains a magic number: tmpRawData [7] = (byte)(tmpFrameSize & 0xFF);  
Magic Number,IdSharp.Tagging.ID3v2,FrameHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameHeader.cs,GetBytes,The following statement contains a magic number: tmpRawData [8] = tmpByte1;  
Magic Number,IdSharp.Tagging.ID3v2,FrameHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameHeader.cs,GetBytes,The following statement contains a magic number: tmpRawData [9] = tmpByte2;  
Magic Number,IdSharp.Tagging.ID3v2,FrameHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameHeader.cs,GetBytes,The following statement contains a magic number: if (_isCompressed) {  	tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  	tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  	tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  	tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameHeader.cs,GetBytes,The following statement contains a magic number: if (_isCompressed) {  	tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  	tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  	tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  	tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameHeader.cs,GetBytes,The following statement contains a magic number: if (_isCompressed) {  	tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  	tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  	tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  	tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameHeader.cs,GetBytes,The following statement contains a magic number: tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  
Magic Number,IdSharp.Tagging.ID3v2,FrameHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameHeader.cs,GetBytes,The following statement contains a magic number: tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  
Magic Number,IdSharp.Tagging.ID3v2,FrameHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameHeader.cs,GetBytes,The following statement contains a magic number: tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  
Magic Number,IdSharp.Tagging.ID3v2,FrameHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameHeader.cs,GetBytes,The following statement contains a magic number: if (tagVersion == ID3v2TagVersion.ID3v24) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x40 : 0) + (_isFileAlterPreservation ? 0x20 : 0) + (_isReadOnly ? 0x10 : 0));  	byte tmpByte2 = (byte)((_groupingIdentity != null ? 0x40 : 0) + (_isCompressed ? 0x08 : 0) + (_encryptionMethod != null ? 0x04 : 0)/* +                                   (false Unsynchronization ? 0x02 : 0) +                                   (false Data length indicator ? 0x01 : 0)*/);  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	/*TODO: unsync'DLI*/int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	// Note: ID3v2.4 uses sync safe frame sizes  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 21) & 0x7F);  	tmpRawData [5] = (byte)((tmpFrameSize >> 14) & 0x7F);  	tmpRawData [6] = (byte)((tmpFrameSize >> 7) & 0x7F);  	tmpRawData [7] = (byte)(tmpFrameSize & 0x7F);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition++] = _groupingIdentity.Value;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	/*TODO: unsync'DLI*/} else {  	throw new ArgumentOutOfRangeException ("tagVersion"' tagVersion' "Unknown tag version");  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameHeader.cs,GetBytes,The following statement contains a magic number: if (tagVersion == ID3v2TagVersion.ID3v24) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x40 : 0) + (_isFileAlterPreservation ? 0x20 : 0) + (_isReadOnly ? 0x10 : 0));  	byte tmpByte2 = (byte)((_groupingIdentity != null ? 0x40 : 0) + (_isCompressed ? 0x08 : 0) + (_encryptionMethod != null ? 0x04 : 0)/* +                                   (false Unsynchronization ? 0x02 : 0) +                                   (false Data length indicator ? 0x01 : 0)*/);  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	/*TODO: unsync'DLI*/int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	// Note: ID3v2.4 uses sync safe frame sizes  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 21) & 0x7F);  	tmpRawData [5] = (byte)((tmpFrameSize >> 14) & 0x7F);  	tmpRawData [6] = (byte)((tmpFrameSize >> 7) & 0x7F);  	tmpRawData [7] = (byte)(tmpFrameSize & 0x7F);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition++] = _groupingIdentity.Value;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	/*TODO: unsync'DLI*/} else {  	throw new ArgumentOutOfRangeException ("tagVersion"' tagVersion' "Unknown tag version");  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameHeader.cs,GetBytes,The following statement contains a magic number: if (tagVersion == ID3v2TagVersion.ID3v24) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x40 : 0) + (_isFileAlterPreservation ? 0x20 : 0) + (_isReadOnly ? 0x10 : 0));  	byte tmpByte2 = (byte)((_groupingIdentity != null ? 0x40 : 0) + (_isCompressed ? 0x08 : 0) + (_encryptionMethod != null ? 0x04 : 0)/* +                                   (false Unsynchronization ? 0x02 : 0) +                                   (false Data length indicator ? 0x01 : 0)*/);  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	/*TODO: unsync'DLI*/int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	// Note: ID3v2.4 uses sync safe frame sizes  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 21) & 0x7F);  	tmpRawData [5] = (byte)((tmpFrameSize >> 14) & 0x7F);  	tmpRawData [6] = (byte)((tmpFrameSize >> 7) & 0x7F);  	tmpRawData [7] = (byte)(tmpFrameSize & 0x7F);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition++] = _groupingIdentity.Value;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	/*TODO: unsync'DLI*/} else {  	throw new ArgumentOutOfRangeException ("tagVersion"' tagVersion' "Unknown tag version");  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameHeader.cs,GetBytes,The following statement contains a magic number: if (tagVersion == ID3v2TagVersion.ID3v24) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x40 : 0) + (_isFileAlterPreservation ? 0x20 : 0) + (_isReadOnly ? 0x10 : 0));  	byte tmpByte2 = (byte)((_groupingIdentity != null ? 0x40 : 0) + (_isCompressed ? 0x08 : 0) + (_encryptionMethod != null ? 0x04 : 0)/* +                                   (false Unsynchronization ? 0x02 : 0) +                                   (false Data length indicator ? 0x01 : 0)*/);  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	/*TODO: unsync'DLI*/int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	// Note: ID3v2.4 uses sync safe frame sizes  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 21) & 0x7F);  	tmpRawData [5] = (byte)((tmpFrameSize >> 14) & 0x7F);  	tmpRawData [6] = (byte)((tmpFrameSize >> 7) & 0x7F);  	tmpRawData [7] = (byte)(tmpFrameSize & 0x7F);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition++] = _groupingIdentity.Value;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	/*TODO: unsync'DLI*/} else {  	throw new ArgumentOutOfRangeException ("tagVersion"' tagVersion' "Unknown tag version");  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameHeader.cs,GetBytes,The following statement contains a magic number: if (tagVersion == ID3v2TagVersion.ID3v24) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x40 : 0) + (_isFileAlterPreservation ? 0x20 : 0) + (_isReadOnly ? 0x10 : 0));  	byte tmpByte2 = (byte)((_groupingIdentity != null ? 0x40 : 0) + (_isCompressed ? 0x08 : 0) + (_encryptionMethod != null ? 0x04 : 0)/* +                                   (false Unsynchronization ? 0x02 : 0) +                                   (false Data length indicator ? 0x01 : 0)*/);  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	/*TODO: unsync'DLI*/int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	// Note: ID3v2.4 uses sync safe frame sizes  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 21) & 0x7F);  	tmpRawData [5] = (byte)((tmpFrameSize >> 14) & 0x7F);  	tmpRawData [6] = (byte)((tmpFrameSize >> 7) & 0x7F);  	tmpRawData [7] = (byte)(tmpFrameSize & 0x7F);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition++] = _groupingIdentity.Value;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	/*TODO: unsync'DLI*/} else {  	throw new ArgumentOutOfRangeException ("tagVersion"' tagVersion' "Unknown tag version");  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameHeader.cs,GetBytes,The following statement contains a magic number: if (tagVersion == ID3v2TagVersion.ID3v24) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x40 : 0) + (_isFileAlterPreservation ? 0x20 : 0) + (_isReadOnly ? 0x10 : 0));  	byte tmpByte2 = (byte)((_groupingIdentity != null ? 0x40 : 0) + (_isCompressed ? 0x08 : 0) + (_encryptionMethod != null ? 0x04 : 0)/* +                                   (false Unsynchronization ? 0x02 : 0) +                                   (false Data length indicator ? 0x01 : 0)*/);  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	/*TODO: unsync'DLI*/int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	// Note: ID3v2.4 uses sync safe frame sizes  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 21) & 0x7F);  	tmpRawData [5] = (byte)((tmpFrameSize >> 14) & 0x7F);  	tmpRawData [6] = (byte)((tmpFrameSize >> 7) & 0x7F);  	tmpRawData [7] = (byte)(tmpFrameSize & 0x7F);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition++] = _groupingIdentity.Value;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	/*TODO: unsync'DLI*/} else {  	throw new ArgumentOutOfRangeException ("tagVersion"' tagVersion' "Unknown tag version");  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameHeader.cs,GetBytes,The following statement contains a magic number: if (tagVersion == ID3v2TagVersion.ID3v24) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x40 : 0) + (_isFileAlterPreservation ? 0x20 : 0) + (_isReadOnly ? 0x10 : 0));  	byte tmpByte2 = (byte)((_groupingIdentity != null ? 0x40 : 0) + (_isCompressed ? 0x08 : 0) + (_encryptionMethod != null ? 0x04 : 0)/* +                                   (false Unsynchronization ? 0x02 : 0) +                                   (false Data length indicator ? 0x01 : 0)*/);  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	/*TODO: unsync'DLI*/int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	// Note: ID3v2.4 uses sync safe frame sizes  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 21) & 0x7F);  	tmpRawData [5] = (byte)((tmpFrameSize >> 14) & 0x7F);  	tmpRawData [6] = (byte)((tmpFrameSize >> 7) & 0x7F);  	tmpRawData [7] = (byte)(tmpFrameSize & 0x7F);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition++] = _groupingIdentity.Value;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	/*TODO: unsync'DLI*/} else {  	throw new ArgumentOutOfRangeException ("tagVersion"' tagVersion' "Unknown tag version");  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameHeader.cs,GetBytes,The following statement contains a magic number: if (tagVersion == ID3v2TagVersion.ID3v24) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x40 : 0) + (_isFileAlterPreservation ? 0x20 : 0) + (_isReadOnly ? 0x10 : 0));  	byte tmpByte2 = (byte)((_groupingIdentity != null ? 0x40 : 0) + (_isCompressed ? 0x08 : 0) + (_encryptionMethod != null ? 0x04 : 0)/* +                                   (false Unsynchronization ? 0x02 : 0) +                                   (false Data length indicator ? 0x01 : 0)*/);  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	/*TODO: unsync'DLI*/int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	// Note: ID3v2.4 uses sync safe frame sizes  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 21) & 0x7F);  	tmpRawData [5] = (byte)((tmpFrameSize >> 14) & 0x7F);  	tmpRawData [6] = (byte)((tmpFrameSize >> 7) & 0x7F);  	tmpRawData [7] = (byte)(tmpFrameSize & 0x7F);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition++] = _groupingIdentity.Value;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	/*TODO: unsync'DLI*/} else {  	throw new ArgumentOutOfRangeException ("tagVersion"' tagVersion' "Unknown tag version");  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameHeader.cs,GetBytes,The following statement contains a magic number: if (tagVersion == ID3v2TagVersion.ID3v24) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x40 : 0) + (_isFileAlterPreservation ? 0x20 : 0) + (_isReadOnly ? 0x10 : 0));  	byte tmpByte2 = (byte)((_groupingIdentity != null ? 0x40 : 0) + (_isCompressed ? 0x08 : 0) + (_encryptionMethod != null ? 0x04 : 0)/* +                                   (false Unsynchronization ? 0x02 : 0) +                                   (false Data length indicator ? 0x01 : 0)*/);  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	/*TODO: unsync'DLI*/int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	// Note: ID3v2.4 uses sync safe frame sizes  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 21) & 0x7F);  	tmpRawData [5] = (byte)((tmpFrameSize >> 14) & 0x7F);  	tmpRawData [6] = (byte)((tmpFrameSize >> 7) & 0x7F);  	tmpRawData [7] = (byte)(tmpFrameSize & 0x7F);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition++] = _groupingIdentity.Value;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	/*TODO: unsync'DLI*/} else {  	throw new ArgumentOutOfRangeException ("tagVersion"' tagVersion' "Unknown tag version");  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameHeader.cs,GetBytes,The following statement contains a magic number: if (tagVersion == ID3v2TagVersion.ID3v24) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x40 : 0) + (_isFileAlterPreservation ? 0x20 : 0) + (_isReadOnly ? 0x10 : 0));  	byte tmpByte2 = (byte)((_groupingIdentity != null ? 0x40 : 0) + (_isCompressed ? 0x08 : 0) + (_encryptionMethod != null ? 0x04 : 0)/* +                                   (false Unsynchronization ? 0x02 : 0) +                                   (false Data length indicator ? 0x01 : 0)*/);  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	/*TODO: unsync'DLI*/int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	// Note: ID3v2.4 uses sync safe frame sizes  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 21) & 0x7F);  	tmpRawData [5] = (byte)((tmpFrameSize >> 14) & 0x7F);  	tmpRawData [6] = (byte)((tmpFrameSize >> 7) & 0x7F);  	tmpRawData [7] = (byte)(tmpFrameSize & 0x7F);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition++] = _groupingIdentity.Value;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	/*TODO: unsync'DLI*/} else {  	throw new ArgumentOutOfRangeException ("tagVersion"' tagVersion' "Unknown tag version");  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameHeader.cs,GetBytes,The following statement contains a magic number: if (tagVersion == ID3v2TagVersion.ID3v24) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x40 : 0) + (_isFileAlterPreservation ? 0x20 : 0) + (_isReadOnly ? 0x10 : 0));  	byte tmpByte2 = (byte)((_groupingIdentity != null ? 0x40 : 0) + (_isCompressed ? 0x08 : 0) + (_encryptionMethod != null ? 0x04 : 0)/* +                                   (false Unsynchronization ? 0x02 : 0) +                                   (false Data length indicator ? 0x01 : 0)*/);  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	/*TODO: unsync'DLI*/int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	// Note: ID3v2.4 uses sync safe frame sizes  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 21) & 0x7F);  	tmpRawData [5] = (byte)((tmpFrameSize >> 14) & 0x7F);  	tmpRawData [6] = (byte)((tmpFrameSize >> 7) & 0x7F);  	tmpRawData [7] = (byte)(tmpFrameSize & 0x7F);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition++] = _groupingIdentity.Value;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	/*TODO: unsync'DLI*/} else {  	throw new ArgumentOutOfRangeException ("tagVersion"' tagVersion' "Unknown tag version");  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameHeader.cs,GetBytes,The following statement contains a magic number: if (tagVersion == ID3v2TagVersion.ID3v24) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x40 : 0) + (_isFileAlterPreservation ? 0x20 : 0) + (_isReadOnly ? 0x10 : 0));  	byte tmpByte2 = (byte)((_groupingIdentity != null ? 0x40 : 0) + (_isCompressed ? 0x08 : 0) + (_encryptionMethod != null ? 0x04 : 0)/* +                                   (false Unsynchronization ? 0x02 : 0) +                                   (false Data length indicator ? 0x01 : 0)*/);  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	/*TODO: unsync'DLI*/int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	// Note: ID3v2.4 uses sync safe frame sizes  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 21) & 0x7F);  	tmpRawData [5] = (byte)((tmpFrameSize >> 14) & 0x7F);  	tmpRawData [6] = (byte)((tmpFrameSize >> 7) & 0x7F);  	tmpRawData [7] = (byte)(tmpFrameSize & 0x7F);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition++] = _groupingIdentity.Value;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	/*TODO: unsync'DLI*/} else {  	throw new ArgumentOutOfRangeException ("tagVersion"' tagVersion' "Unknown tag version");  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameHeader.cs,GetBytes,The following statement contains a magic number: if (tagVersion == ID3v2TagVersion.ID3v24) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x40 : 0) + (_isFileAlterPreservation ? 0x20 : 0) + (_isReadOnly ? 0x10 : 0));  	byte tmpByte2 = (byte)((_groupingIdentity != null ? 0x40 : 0) + (_isCompressed ? 0x08 : 0) + (_encryptionMethod != null ? 0x04 : 0)/* +                                   (false Unsynchronization ? 0x02 : 0) +                                   (false Data length indicator ? 0x01 : 0)*/);  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	/*TODO: unsync'DLI*/int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	// Note: ID3v2.4 uses sync safe frame sizes  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 21) & 0x7F);  	tmpRawData [5] = (byte)((tmpFrameSize >> 14) & 0x7F);  	tmpRawData [6] = (byte)((tmpFrameSize >> 7) & 0x7F);  	tmpRawData [7] = (byte)(tmpFrameSize & 0x7F);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition++] = _groupingIdentity.Value;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	/*TODO: unsync'DLI*/} else {  	throw new ArgumentOutOfRangeException ("tagVersion"' tagVersion' "Unknown tag version");  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameHeader.cs,GetBytes,The following statement contains a magic number: if (tagVersion == ID3v2TagVersion.ID3v24) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x40 : 0) + (_isFileAlterPreservation ? 0x20 : 0) + (_isReadOnly ? 0x10 : 0));  	byte tmpByte2 = (byte)((_groupingIdentity != null ? 0x40 : 0) + (_isCompressed ? 0x08 : 0) + (_encryptionMethod != null ? 0x04 : 0)/* +                                   (false Unsynchronization ? 0x02 : 0) +                                   (false Data length indicator ? 0x01 : 0)*/);  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	/*TODO: unsync'DLI*/int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	// Note: ID3v2.4 uses sync safe frame sizes  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 21) & 0x7F);  	tmpRawData [5] = (byte)((tmpFrameSize >> 14) & 0x7F);  	tmpRawData [6] = (byte)((tmpFrameSize >> 7) & 0x7F);  	tmpRawData [7] = (byte)(tmpFrameSize & 0x7F);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition++] = _groupingIdentity.Value;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	/*TODO: unsync'DLI*/} else {  	throw new ArgumentOutOfRangeException ("tagVersion"' tagVersion' "Unknown tag version");  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameHeader.cs,GetBytes,The following statement contains a magic number: if (tagVersion == ID3v2TagVersion.ID3v24) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x40 : 0) + (_isFileAlterPreservation ? 0x20 : 0) + (_isReadOnly ? 0x10 : 0));  	byte tmpByte2 = (byte)((_groupingIdentity != null ? 0x40 : 0) + (_isCompressed ? 0x08 : 0) + (_encryptionMethod != null ? 0x04 : 0)/* +                                   (false Unsynchronization ? 0x02 : 0) +                                   (false Data length indicator ? 0x01 : 0)*/);  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	/*TODO: unsync'DLI*/int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	// Note: ID3v2.4 uses sync safe frame sizes  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 21) & 0x7F);  	tmpRawData [5] = (byte)((tmpFrameSize >> 14) & 0x7F);  	tmpRawData [6] = (byte)((tmpFrameSize >> 7) & 0x7F);  	tmpRawData [7] = (byte)(tmpFrameSize & 0x7F);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition++] = _groupingIdentity.Value;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	/*TODO: unsync'DLI*/} else {  	throw new ArgumentOutOfRangeException ("tagVersion"' tagVersion' "Unknown tag version");  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameHeader.cs,GetBytes,The following statement contains a magic number: if (tagVersion == ID3v2TagVersion.ID3v24) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x40 : 0) + (_isFileAlterPreservation ? 0x20 : 0) + (_isReadOnly ? 0x10 : 0));  	byte tmpByte2 = (byte)((_groupingIdentity != null ? 0x40 : 0) + (_isCompressed ? 0x08 : 0) + (_encryptionMethod != null ? 0x04 : 0)/* +                                   (false Unsynchronization ? 0x02 : 0) +                                   (false Data length indicator ? 0x01 : 0)*/);  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	/*TODO: unsync'DLI*/int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	// Note: ID3v2.4 uses sync safe frame sizes  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 21) & 0x7F);  	tmpRawData [5] = (byte)((tmpFrameSize >> 14) & 0x7F);  	tmpRawData [6] = (byte)((tmpFrameSize >> 7) & 0x7F);  	tmpRawData [7] = (byte)(tmpFrameSize & 0x7F);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition++] = _groupingIdentity.Value;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	/*TODO: unsync'DLI*/} else {  	throw new ArgumentOutOfRangeException ("tagVersion"' tagVersion' "Unknown tag version");  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameHeader.cs,GetBytes,The following statement contains a magic number: if (tagVersion == ID3v2TagVersion.ID3v24) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x40 : 0) + (_isFileAlterPreservation ? 0x20 : 0) + (_isReadOnly ? 0x10 : 0));  	byte tmpByte2 = (byte)((_groupingIdentity != null ? 0x40 : 0) + (_isCompressed ? 0x08 : 0) + (_encryptionMethod != null ? 0x04 : 0)/* +                                   (false Unsynchronization ? 0x02 : 0) +                                   (false Data length indicator ? 0x01 : 0)*/);  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	/*TODO: unsync'DLI*/int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	// Note: ID3v2.4 uses sync safe frame sizes  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 21) & 0x7F);  	tmpRawData [5] = (byte)((tmpFrameSize >> 14) & 0x7F);  	tmpRawData [6] = (byte)((tmpFrameSize >> 7) & 0x7F);  	tmpRawData [7] = (byte)(tmpFrameSize & 0x7F);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition++] = _groupingIdentity.Value;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	/*TODO: unsync'DLI*/} else {  	throw new ArgumentOutOfRangeException ("tagVersion"' tagVersion' "Unknown tag version");  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameHeader.cs,GetBytes,The following statement contains a magic number: if (tagVersion == ID3v2TagVersion.ID3v24) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x40 : 0) + (_isFileAlterPreservation ? 0x20 : 0) + (_isReadOnly ? 0x10 : 0));  	byte tmpByte2 = (byte)((_groupingIdentity != null ? 0x40 : 0) + (_isCompressed ? 0x08 : 0) + (_encryptionMethod != null ? 0x04 : 0)/* +                                   (false Unsynchronization ? 0x02 : 0) +                                   (false Data length indicator ? 0x01 : 0)*/);  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	/*TODO: unsync'DLI*/int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	// Note: ID3v2.4 uses sync safe frame sizes  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 21) & 0x7F);  	tmpRawData [5] = (byte)((tmpFrameSize >> 14) & 0x7F);  	tmpRawData [6] = (byte)((tmpFrameSize >> 7) & 0x7F);  	tmpRawData [7] = (byte)(tmpFrameSize & 0x7F);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition++] = _groupingIdentity.Value;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	/*TODO: unsync'DLI*/} else {  	throw new ArgumentOutOfRangeException ("tagVersion"' tagVersion' "Unknown tag version");  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameHeader.cs,GetBytes,The following statement contains a magic number: if (tagVersion == ID3v2TagVersion.ID3v24) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x40 : 0) + (_isFileAlterPreservation ? 0x20 : 0) + (_isReadOnly ? 0x10 : 0));  	byte tmpByte2 = (byte)((_groupingIdentity != null ? 0x40 : 0) + (_isCompressed ? 0x08 : 0) + (_encryptionMethod != null ? 0x04 : 0)/* +                                   (false Unsynchronization ? 0x02 : 0) +                                   (false Data length indicator ? 0x01 : 0)*/);  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	/*TODO: unsync'DLI*/int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	// Note: ID3v2.4 uses sync safe frame sizes  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 21) & 0x7F);  	tmpRawData [5] = (byte)((tmpFrameSize >> 14) & 0x7F);  	tmpRawData [6] = (byte)((tmpFrameSize >> 7) & 0x7F);  	tmpRawData [7] = (byte)(tmpFrameSize & 0x7F);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition++] = _groupingIdentity.Value;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	/*TODO: unsync'DLI*/} else {  	throw new ArgumentOutOfRangeException ("tagVersion"' tagVersion' "Unknown tag version");  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameHeader.cs,GetBytes,The following statement contains a magic number: if (tagVersion == ID3v2TagVersion.ID3v24) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x40 : 0) + (_isFileAlterPreservation ? 0x20 : 0) + (_isReadOnly ? 0x10 : 0));  	byte tmpByte2 = (byte)((_groupingIdentity != null ? 0x40 : 0) + (_isCompressed ? 0x08 : 0) + (_encryptionMethod != null ? 0x04 : 0)/* +                                   (false Unsynchronization ? 0x02 : 0) +                                   (false Data length indicator ? 0x01 : 0)*/);  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	/*TODO: unsync'DLI*/int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	// Note: ID3v2.4 uses sync safe frame sizes  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 21) & 0x7F);  	tmpRawData [5] = (byte)((tmpFrameSize >> 14) & 0x7F);  	tmpRawData [6] = (byte)((tmpFrameSize >> 7) & 0x7F);  	tmpRawData [7] = (byte)(tmpFrameSize & 0x7F);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition++] = _groupingIdentity.Value;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	/*TODO: unsync'DLI*/} else {  	throw new ArgumentOutOfRangeException ("tagVersion"' tagVersion' "Unknown tag version");  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameHeader.cs,GetBytes,The following statement contains a magic number: if (tagVersion == ID3v2TagVersion.ID3v24) {  	int tmpRawDataSize = 10;  	byte tmpByte1 = (byte)((_isTagAlterPreservation ? 0x40 : 0) + (_isFileAlterPreservation ? 0x20 : 0) + (_isReadOnly ? 0x10 : 0));  	byte tmpByte2 = (byte)((_groupingIdentity != null ? 0x40 : 0) + (_isCompressed ? 0x08 : 0) + (_encryptionMethod != null ? 0x04 : 0)/* +                                   (false Unsynchronization ? 0x02 : 0) +                                   (false Data length indicator ? 0x01 : 0)*/);  	if (_isCompressed)  		tmpRawDataSize += 4;  	if (_encryptionMethod != null)  		tmpRawDataSize++;  	if (_groupingIdentity != null)  		tmpRawDataSize++;  	/*TODO: unsync'DLI*/int tmpFrameSize = _frameSizeExcludingAdditions + (tmpRawDataSize - 10);  	tmpRawData = new byte[tmpRawDataSize];  	if (frameIDBytes.Length != 4)  		throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  	// Note: ID3v2.4 uses sync safe frame sizes  	tmpRawData [0] = frameIDBytes [0];  	tmpRawData [1] = frameIDBytes [1];  	tmpRawData [2] = frameIDBytes [2];  	tmpRawData [3] = frameIDBytes [3];  	tmpRawData [4] = (byte)((tmpFrameSize >> 21) & 0x7F);  	tmpRawData [5] = (byte)((tmpFrameSize >> 14) & 0x7F);  	tmpRawData [6] = (byte)((tmpFrameSize >> 7) & 0x7F);  	tmpRawData [7] = (byte)(tmpFrameSize & 0x7F);  	tmpRawData [8] = tmpByte1;  	tmpRawData [9] = tmpByte2;  	int tmpCurrentPosition = 10;  	if (_groupingIdentity != null)  		tmpRawData [tmpCurrentPosition++] = _groupingIdentity.Value;  	if (_isCompressed) {  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  		tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  		tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  	}  	if (_encryptionMethod != null)  		tmpRawData [tmpCurrentPosition++] = _encryptionMethod.Value;  	/*TODO: unsync'DLI*/} else {  	throw new ArgumentOutOfRangeException ("tagVersion"' tagVersion' "Unknown tag version");  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameHeader.cs,GetBytes,The following statement contains a magic number: if (_isCompressed)  	tmpRawDataSize += 4;  
Magic Number,IdSharp.Tagging.ID3v2,FrameHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameHeader.cs,GetBytes,The following statement contains a magic number: tmpRawDataSize += 4;  
Magic Number,IdSharp.Tagging.ID3v2,FrameHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameHeader.cs,GetBytes,The following statement contains a magic number: if (frameIDBytes.Length != 4)  	throw new ArgumentException (string.Format ("FrameID must be 4 bytes ({0} bytes passed)"' frameIDBytes.Length));  
Magic Number,IdSharp.Tagging.ID3v2,FrameHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameHeader.cs,GetBytes,The following statement contains a magic number: tmpRawData [2] = frameIDBytes [2];  
Magic Number,IdSharp.Tagging.ID3v2,FrameHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameHeader.cs,GetBytes,The following statement contains a magic number: tmpRawData [2] = frameIDBytes [2];  
Magic Number,IdSharp.Tagging.ID3v2,FrameHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameHeader.cs,GetBytes,The following statement contains a magic number: tmpRawData [3] = frameIDBytes [3];  
Magic Number,IdSharp.Tagging.ID3v2,FrameHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameHeader.cs,GetBytes,The following statement contains a magic number: tmpRawData [3] = frameIDBytes [3];  
Magic Number,IdSharp.Tagging.ID3v2,FrameHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameHeader.cs,GetBytes,The following statement contains a magic number: tmpRawData [4] = (byte)((tmpFrameSize >> 21) & 0x7F);  
Magic Number,IdSharp.Tagging.ID3v2,FrameHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameHeader.cs,GetBytes,The following statement contains a magic number: tmpRawData [4] = (byte)((tmpFrameSize >> 21) & 0x7F);  
Magic Number,IdSharp.Tagging.ID3v2,FrameHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameHeader.cs,GetBytes,The following statement contains a magic number: tmpRawData [5] = (byte)((tmpFrameSize >> 14) & 0x7F);  
Magic Number,IdSharp.Tagging.ID3v2,FrameHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameHeader.cs,GetBytes,The following statement contains a magic number: tmpRawData [5] = (byte)((tmpFrameSize >> 14) & 0x7F);  
Magic Number,IdSharp.Tagging.ID3v2,FrameHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameHeader.cs,GetBytes,The following statement contains a magic number: tmpRawData [6] = (byte)((tmpFrameSize >> 7) & 0x7F);  
Magic Number,IdSharp.Tagging.ID3v2,FrameHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameHeader.cs,GetBytes,The following statement contains a magic number: tmpRawData [6] = (byte)((tmpFrameSize >> 7) & 0x7F);  
Magic Number,IdSharp.Tagging.ID3v2,FrameHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameHeader.cs,GetBytes,The following statement contains a magic number: tmpRawData [7] = (byte)(tmpFrameSize & 0x7F);  
Magic Number,IdSharp.Tagging.ID3v2,FrameHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameHeader.cs,GetBytes,The following statement contains a magic number: tmpRawData [8] = tmpByte1;  
Magic Number,IdSharp.Tagging.ID3v2,FrameHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameHeader.cs,GetBytes,The following statement contains a magic number: tmpRawData [9] = tmpByte2;  
Magic Number,IdSharp.Tagging.ID3v2,FrameHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameHeader.cs,GetBytes,The following statement contains a magic number: if (_isCompressed) {  	tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  	tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  	tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  	tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameHeader.cs,GetBytes,The following statement contains a magic number: if (_isCompressed) {  	tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  	tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  	tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  	tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameHeader.cs,GetBytes,The following statement contains a magic number: if (_isCompressed) {  	tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  	tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  	tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  	tmpRawData [tmpCurrentPosition++] = (byte)DecompressedSize;  }  
Magic Number,IdSharp.Tagging.ID3v2,FrameHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameHeader.cs,GetBytes,The following statement contains a magic number: tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 24);  
Magic Number,IdSharp.Tagging.ID3v2,FrameHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameHeader.cs,GetBytes,The following statement contains a magic number: tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 16);  
Magic Number,IdSharp.Tagging.ID3v2,FrameHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\FrameHeader.cs,GetBytes,The following statement contains a magic number: tmpRawData [tmpCurrentPosition++] = (byte)(DecompressedSize >> 8);  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2ExtendedHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2ExtendedHeader.cs,ReadFrom,The following statement contains a magic number: if (size >= 0x41000000) {  	string msg = string.Format ("FrameID found when expected extended header at position {0}"' stream.Position - 4);  	Trace.WriteLine (msg);  	stream.Seek (-4' SeekOrigin.Current);  	Clear ();  	return;  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2ExtendedHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2ExtendedHeader.cs,ReadFrom,The following statement contains a magic number: if (size >= 0x41000000) {  	string msg = string.Format ("FrameID found when expected extended header at position {0}"' stream.Position - 4);  	Trace.WriteLine (msg);  	stream.Seek (-4' SeekOrigin.Current);  	Clear ();  	return;  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2ExtendedHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2ExtendedHeader.cs,ReadFrom,The following statement contains a magic number: stream.Seek (-4' SeekOrigin.Current);  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2ExtendedHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2ExtendedHeader.cs,GetBytes,The following statement contains a magic number: buf [2] = 0;  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2ExtendedHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2ExtendedHeader.cs,GetBytes,The following statement contains a magic number: buf [3] = (byte)(_isCRCDataPresent ? 10 : 6);  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2ExtendedHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2ExtendedHeader.cs,GetBytes,The following statement contains a magic number: buf [3] = (byte)(_isCRCDataPresent ? 10 : 6);  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2ExtendedHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2ExtendedHeader.cs,GetBytes,The following statement contains a magic number: buf [3] = (byte)(_isCRCDataPresent ? 10 : 6);  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2ExtendedHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2ExtendedHeader.cs,GetBytes,The following statement contains a magic number: buf [4] = (Byte)(_isCRCDataPresent ? 0x80 : 0);  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2ExtendedHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2ExtendedHeader.cs,GetBytes,The following statement contains a magic number: buf [5] = 0;  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2ExtendedHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2ExtendedHeader.cs,GetBytes,The following statement contains a magic number: buf [6] = (Byte)((_paddingSize >> 24) & 0xFF);  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2ExtendedHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2ExtendedHeader.cs,GetBytes,The following statement contains a magic number: buf [6] = (Byte)((_paddingSize >> 24) & 0xFF);  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2ExtendedHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2ExtendedHeader.cs,GetBytes,The following statement contains a magic number: buf [7] = (Byte)((_paddingSize >> 16) & 0xFF);  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2ExtendedHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2ExtendedHeader.cs,GetBytes,The following statement contains a magic number: buf [7] = (Byte)((_paddingSize >> 16) & 0xFF);  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2ExtendedHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2ExtendedHeader.cs,GetBytes,The following statement contains a magic number: buf [8] = (Byte)((_paddingSize >> 8) & 0xFF);  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2ExtendedHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2ExtendedHeader.cs,GetBytes,The following statement contains a magic number: buf [8] = (Byte)((_paddingSize >> 8) & 0xFF);  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2ExtendedHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2ExtendedHeader.cs,GetBytes,The following statement contains a magic number: buf [9] = (Byte)(_paddingSize & 0xFF);  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2ExtendedHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2ExtendedHeader.cs,GetBytes,The following statement contains a magic number: if (_isCRCDataPresent) {  	// Total Frame CRC  	buf [10] = (Byte)((_totalFrameCRC >> 24) & 0xFF);  	buf [11] = (Byte)((_totalFrameCRC >> 16) & 0xFF);  	buf [12] = (Byte)((_totalFrameCRC >> 8) & 0xFF);  	buf [13] = (Byte)(_totalFrameCRC & 0xFF);  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2ExtendedHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2ExtendedHeader.cs,GetBytes,The following statement contains a magic number: if (_isCRCDataPresent) {  	// Total Frame CRC  	buf [10] = (Byte)((_totalFrameCRC >> 24) & 0xFF);  	buf [11] = (Byte)((_totalFrameCRC >> 16) & 0xFF);  	buf [12] = (Byte)((_totalFrameCRC >> 8) & 0xFF);  	buf [13] = (Byte)(_totalFrameCRC & 0xFF);  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2ExtendedHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2ExtendedHeader.cs,GetBytes,The following statement contains a magic number: if (_isCRCDataPresent) {  	// Total Frame CRC  	buf [10] = (Byte)((_totalFrameCRC >> 24) & 0xFF);  	buf [11] = (Byte)((_totalFrameCRC >> 16) & 0xFF);  	buf [12] = (Byte)((_totalFrameCRC >> 8) & 0xFF);  	buf [13] = (Byte)(_totalFrameCRC & 0xFF);  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2ExtendedHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2ExtendedHeader.cs,GetBytes,The following statement contains a magic number: if (_isCRCDataPresent) {  	// Total Frame CRC  	buf [10] = (Byte)((_totalFrameCRC >> 24) & 0xFF);  	buf [11] = (Byte)((_totalFrameCRC >> 16) & 0xFF);  	buf [12] = (Byte)((_totalFrameCRC >> 8) & 0xFF);  	buf [13] = (Byte)(_totalFrameCRC & 0xFF);  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2ExtendedHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2ExtendedHeader.cs,GetBytes,The following statement contains a magic number: if (_isCRCDataPresent) {  	// Total Frame CRC  	buf [10] = (Byte)((_totalFrameCRC >> 24) & 0xFF);  	buf [11] = (Byte)((_totalFrameCRC >> 16) & 0xFF);  	buf [12] = (Byte)((_totalFrameCRC >> 8) & 0xFF);  	buf [13] = (Byte)(_totalFrameCRC & 0xFF);  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2ExtendedHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2ExtendedHeader.cs,GetBytes,The following statement contains a magic number: if (_isCRCDataPresent) {  	// Total Frame CRC  	buf [10] = (Byte)((_totalFrameCRC >> 24) & 0xFF);  	buf [11] = (Byte)((_totalFrameCRC >> 16) & 0xFF);  	buf [12] = (Byte)((_totalFrameCRC >> 8) & 0xFF);  	buf [13] = (Byte)(_totalFrameCRC & 0xFF);  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2ExtendedHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2ExtendedHeader.cs,GetBytes,The following statement contains a magic number: if (_isCRCDataPresent) {  	// Total Frame CRC  	buf [10] = (Byte)((_totalFrameCRC >> 24) & 0xFF);  	buf [11] = (Byte)((_totalFrameCRC >> 16) & 0xFF);  	buf [12] = (Byte)((_totalFrameCRC >> 8) & 0xFF);  	buf [13] = (Byte)(_totalFrameCRC & 0xFF);  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2ExtendedHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2ExtendedHeader.cs,GetBytes,The following statement contains a magic number: buf [10] = (Byte)((_totalFrameCRC >> 24) & 0xFF);  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2ExtendedHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2ExtendedHeader.cs,GetBytes,The following statement contains a magic number: buf [10] = (Byte)((_totalFrameCRC >> 24) & 0xFF);  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2ExtendedHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2ExtendedHeader.cs,GetBytes,The following statement contains a magic number: buf [11] = (Byte)((_totalFrameCRC >> 16) & 0xFF);  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2ExtendedHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2ExtendedHeader.cs,GetBytes,The following statement contains a magic number: buf [11] = (Byte)((_totalFrameCRC >> 16) & 0xFF);  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2ExtendedHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2ExtendedHeader.cs,GetBytes,The following statement contains a magic number: buf [12] = (Byte)((_totalFrameCRC >> 8) & 0xFF);  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2ExtendedHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2ExtendedHeader.cs,GetBytes,The following statement contains a magic number: buf [12] = (Byte)((_totalFrameCRC >> 8) & 0xFF);  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2ExtendedHeader,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2ExtendedHeader.cs,GetBytes,The following statement contains a magic number: buf [13] = (Byte)(_totalFrameCRC & 0xFF);  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Header,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2Header.cs,Read,The following statement contains a magic number: if (readIdentifier) {  	Read (stream);  } else {  	byte[] tmpHeader = stream.Read (7);  	// Version  	if (tmpHeader [0] < 2 || tmpHeader [0] > 4) {  		string msg = string.Format ("ID3 Version '{0}' not recognized (valid versions are 2' 3' and 4)"' tmpHeader [0]);  		Trace.WriteLine (msg);  		throw new InvalidDataException (msg);  	}  	_tagVersion = (ID3v2TagVersion)tmpHeader [0];  	// Version revision  	_tagVersionRevision = tmpHeader [1];  	// Flags  	switch (_tagVersion) {  	case ID3v2TagVersion.ID3v23:  		UsesUnsynchronization = ((tmpHeader [2] & 0x80) == 0x80);  		/*if (this.UsesUnsynchronization == true)                         {                             Console.WriteLine(((FileStream)stream).Name);                         }*/_hasExtendedHeader = ((tmpHeader [2] & 0x40) == 0x40);  		_isExperimental = ((tmpHeader [2] & 0x20) == 0x20);  		_isFooterPresent = false;  		_isCompressed = false;  		break;  	case ID3v2TagVersion.ID3v22:  		_usesUnsynchronization = ((tmpHeader [2] & 0x80) == 0x80);  		_isFooterPresent = false;  		_isCompressed = ((tmpHeader [2] & 0x40) == 0x40);  		break;  	case ID3v2TagVersion.ID3v24:  		_usesUnsynchronization = ((tmpHeader [2] & 0x80) == 0x80);  		_hasExtendedHeader = ((tmpHeader [2] & 0x40) == 0x40);  		_isExperimental = ((tmpHeader [2] & 0x20) == 0x20);  		_isFooterPresent = ((tmpHeader [2] & 0x10) == 0x10);  		_isCompressed = false;  		break;  	}  	// Size  	_tagSize = (tmpHeader [3] << 21);  	_tagSize += (tmpHeader [4] << 14);  	_tagSize += (tmpHeader [5] << 7);  	_tagSize += (tmpHeader [6]);  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Header,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2Header.cs,Read,The following statement contains a magic number: if (readIdentifier) {  	Read (stream);  } else {  	byte[] tmpHeader = stream.Read (7);  	// Version  	if (tmpHeader [0] < 2 || tmpHeader [0] > 4) {  		string msg = string.Format ("ID3 Version '{0}' not recognized (valid versions are 2' 3' and 4)"' tmpHeader [0]);  		Trace.WriteLine (msg);  		throw new InvalidDataException (msg);  	}  	_tagVersion = (ID3v2TagVersion)tmpHeader [0];  	// Version revision  	_tagVersionRevision = tmpHeader [1];  	// Flags  	switch (_tagVersion) {  	case ID3v2TagVersion.ID3v23:  		UsesUnsynchronization = ((tmpHeader [2] & 0x80) == 0x80);  		/*if (this.UsesUnsynchronization == true)                         {                             Console.WriteLine(((FileStream)stream).Name);                         }*/_hasExtendedHeader = ((tmpHeader [2] & 0x40) == 0x40);  		_isExperimental = ((tmpHeader [2] & 0x20) == 0x20);  		_isFooterPresent = false;  		_isCompressed = false;  		break;  	case ID3v2TagVersion.ID3v22:  		_usesUnsynchronization = ((tmpHeader [2] & 0x80) == 0x80);  		_isFooterPresent = false;  		_isCompressed = ((tmpHeader [2] & 0x40) == 0x40);  		break;  	case ID3v2TagVersion.ID3v24:  		_usesUnsynchronization = ((tmpHeader [2] & 0x80) == 0x80);  		_hasExtendedHeader = ((tmpHeader [2] & 0x40) == 0x40);  		_isExperimental = ((tmpHeader [2] & 0x20) == 0x20);  		_isFooterPresent = ((tmpHeader [2] & 0x10) == 0x10);  		_isCompressed = false;  		break;  	}  	// Size  	_tagSize = (tmpHeader [3] << 21);  	_tagSize += (tmpHeader [4] << 14);  	_tagSize += (tmpHeader [5] << 7);  	_tagSize += (tmpHeader [6]);  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Header,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2Header.cs,Read,The following statement contains a magic number: if (readIdentifier) {  	Read (stream);  } else {  	byte[] tmpHeader = stream.Read (7);  	// Version  	if (tmpHeader [0] < 2 || tmpHeader [0] > 4) {  		string msg = string.Format ("ID3 Version '{0}' not recognized (valid versions are 2' 3' and 4)"' tmpHeader [0]);  		Trace.WriteLine (msg);  		throw new InvalidDataException (msg);  	}  	_tagVersion = (ID3v2TagVersion)tmpHeader [0];  	// Version revision  	_tagVersionRevision = tmpHeader [1];  	// Flags  	switch (_tagVersion) {  	case ID3v2TagVersion.ID3v23:  		UsesUnsynchronization = ((tmpHeader [2] & 0x80) == 0x80);  		/*if (this.UsesUnsynchronization == true)                         {                             Console.WriteLine(((FileStream)stream).Name);                         }*/_hasExtendedHeader = ((tmpHeader [2] & 0x40) == 0x40);  		_isExperimental = ((tmpHeader [2] & 0x20) == 0x20);  		_isFooterPresent = false;  		_isCompressed = false;  		break;  	case ID3v2TagVersion.ID3v22:  		_usesUnsynchronization = ((tmpHeader [2] & 0x80) == 0x80);  		_isFooterPresent = false;  		_isCompressed = ((tmpHeader [2] & 0x40) == 0x40);  		break;  	case ID3v2TagVersion.ID3v24:  		_usesUnsynchronization = ((tmpHeader [2] & 0x80) == 0x80);  		_hasExtendedHeader = ((tmpHeader [2] & 0x40) == 0x40);  		_isExperimental = ((tmpHeader [2] & 0x20) == 0x20);  		_isFooterPresent = ((tmpHeader [2] & 0x10) == 0x10);  		_isCompressed = false;  		break;  	}  	// Size  	_tagSize = (tmpHeader [3] << 21);  	_tagSize += (tmpHeader [4] << 14);  	_tagSize += (tmpHeader [5] << 7);  	_tagSize += (tmpHeader [6]);  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Header,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2Header.cs,Read,The following statement contains a magic number: if (readIdentifier) {  	Read (stream);  } else {  	byte[] tmpHeader = stream.Read (7);  	// Version  	if (tmpHeader [0] < 2 || tmpHeader [0] > 4) {  		string msg = string.Format ("ID3 Version '{0}' not recognized (valid versions are 2' 3' and 4)"' tmpHeader [0]);  		Trace.WriteLine (msg);  		throw new InvalidDataException (msg);  	}  	_tagVersion = (ID3v2TagVersion)tmpHeader [0];  	// Version revision  	_tagVersionRevision = tmpHeader [1];  	// Flags  	switch (_tagVersion) {  	case ID3v2TagVersion.ID3v23:  		UsesUnsynchronization = ((tmpHeader [2] & 0x80) == 0x80);  		/*if (this.UsesUnsynchronization == true)                         {                             Console.WriteLine(((FileStream)stream).Name);                         }*/_hasExtendedHeader = ((tmpHeader [2] & 0x40) == 0x40);  		_isExperimental = ((tmpHeader [2] & 0x20) == 0x20);  		_isFooterPresent = false;  		_isCompressed = false;  		break;  	case ID3v2TagVersion.ID3v22:  		_usesUnsynchronization = ((tmpHeader [2] & 0x80) == 0x80);  		_isFooterPresent = false;  		_isCompressed = ((tmpHeader [2] & 0x40) == 0x40);  		break;  	case ID3v2TagVersion.ID3v24:  		_usesUnsynchronization = ((tmpHeader [2] & 0x80) == 0x80);  		_hasExtendedHeader = ((tmpHeader [2] & 0x40) == 0x40);  		_isExperimental = ((tmpHeader [2] & 0x20) == 0x20);  		_isFooterPresent = ((tmpHeader [2] & 0x10) == 0x10);  		_isCompressed = false;  		break;  	}  	// Size  	_tagSize = (tmpHeader [3] << 21);  	_tagSize += (tmpHeader [4] << 14);  	_tagSize += (tmpHeader [5] << 7);  	_tagSize += (tmpHeader [6]);  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Header,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2Header.cs,Read,The following statement contains a magic number: if (readIdentifier) {  	Read (stream);  } else {  	byte[] tmpHeader = stream.Read (7);  	// Version  	if (tmpHeader [0] < 2 || tmpHeader [0] > 4) {  		string msg = string.Format ("ID3 Version '{0}' not recognized (valid versions are 2' 3' and 4)"' tmpHeader [0]);  		Trace.WriteLine (msg);  		throw new InvalidDataException (msg);  	}  	_tagVersion = (ID3v2TagVersion)tmpHeader [0];  	// Version revision  	_tagVersionRevision = tmpHeader [1];  	// Flags  	switch (_tagVersion) {  	case ID3v2TagVersion.ID3v23:  		UsesUnsynchronization = ((tmpHeader [2] & 0x80) == 0x80);  		/*if (this.UsesUnsynchronization == true)                         {                             Console.WriteLine(((FileStream)stream).Name);                         }*/_hasExtendedHeader = ((tmpHeader [2] & 0x40) == 0x40);  		_isExperimental = ((tmpHeader [2] & 0x20) == 0x20);  		_isFooterPresent = false;  		_isCompressed = false;  		break;  	case ID3v2TagVersion.ID3v22:  		_usesUnsynchronization = ((tmpHeader [2] & 0x80) == 0x80);  		_isFooterPresent = false;  		_isCompressed = ((tmpHeader [2] & 0x40) == 0x40);  		break;  	case ID3v2TagVersion.ID3v24:  		_usesUnsynchronization = ((tmpHeader [2] & 0x80) == 0x80);  		_hasExtendedHeader = ((tmpHeader [2] & 0x40) == 0x40);  		_isExperimental = ((tmpHeader [2] & 0x20) == 0x20);  		_isFooterPresent = ((tmpHeader [2] & 0x10) == 0x10);  		_isCompressed = false;  		break;  	}  	// Size  	_tagSize = (tmpHeader [3] << 21);  	_tagSize += (tmpHeader [4] << 14);  	_tagSize += (tmpHeader [5] << 7);  	_tagSize += (tmpHeader [6]);  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Header,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2Header.cs,Read,The following statement contains a magic number: if (readIdentifier) {  	Read (stream);  } else {  	byte[] tmpHeader = stream.Read (7);  	// Version  	if (tmpHeader [0] < 2 || tmpHeader [0] > 4) {  		string msg = string.Format ("ID3 Version '{0}' not recognized (valid versions are 2' 3' and 4)"' tmpHeader [0]);  		Trace.WriteLine (msg);  		throw new InvalidDataException (msg);  	}  	_tagVersion = (ID3v2TagVersion)tmpHeader [0];  	// Version revision  	_tagVersionRevision = tmpHeader [1];  	// Flags  	switch (_tagVersion) {  	case ID3v2TagVersion.ID3v23:  		UsesUnsynchronization = ((tmpHeader [2] & 0x80) == 0x80);  		/*if (this.UsesUnsynchronization == true)                         {                             Console.WriteLine(((FileStream)stream).Name);                         }*/_hasExtendedHeader = ((tmpHeader [2] & 0x40) == 0x40);  		_isExperimental = ((tmpHeader [2] & 0x20) == 0x20);  		_isFooterPresent = false;  		_isCompressed = false;  		break;  	case ID3v2TagVersion.ID3v22:  		_usesUnsynchronization = ((tmpHeader [2] & 0x80) == 0x80);  		_isFooterPresent = false;  		_isCompressed = ((tmpHeader [2] & 0x40) == 0x40);  		break;  	case ID3v2TagVersion.ID3v24:  		_usesUnsynchronization = ((tmpHeader [2] & 0x80) == 0x80);  		_hasExtendedHeader = ((tmpHeader [2] & 0x40) == 0x40);  		_isExperimental = ((tmpHeader [2] & 0x20) == 0x20);  		_isFooterPresent = ((tmpHeader [2] & 0x10) == 0x10);  		_isCompressed = false;  		break;  	}  	// Size  	_tagSize = (tmpHeader [3] << 21);  	_tagSize += (tmpHeader [4] << 14);  	_tagSize += (tmpHeader [5] << 7);  	_tagSize += (tmpHeader [6]);  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Header,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2Header.cs,Read,The following statement contains a magic number: if (readIdentifier) {  	Read (stream);  } else {  	byte[] tmpHeader = stream.Read (7);  	// Version  	if (tmpHeader [0] < 2 || tmpHeader [0] > 4) {  		string msg = string.Format ("ID3 Version '{0}' not recognized (valid versions are 2' 3' and 4)"' tmpHeader [0]);  		Trace.WriteLine (msg);  		throw new InvalidDataException (msg);  	}  	_tagVersion = (ID3v2TagVersion)tmpHeader [0];  	// Version revision  	_tagVersionRevision = tmpHeader [1];  	// Flags  	switch (_tagVersion) {  	case ID3v2TagVersion.ID3v23:  		UsesUnsynchronization = ((tmpHeader [2] & 0x80) == 0x80);  		/*if (this.UsesUnsynchronization == true)                         {                             Console.WriteLine(((FileStream)stream).Name);                         }*/_hasExtendedHeader = ((tmpHeader [2] & 0x40) == 0x40);  		_isExperimental = ((tmpHeader [2] & 0x20) == 0x20);  		_isFooterPresent = false;  		_isCompressed = false;  		break;  	case ID3v2TagVersion.ID3v22:  		_usesUnsynchronization = ((tmpHeader [2] & 0x80) == 0x80);  		_isFooterPresent = false;  		_isCompressed = ((tmpHeader [2] & 0x40) == 0x40);  		break;  	case ID3v2TagVersion.ID3v24:  		_usesUnsynchronization = ((tmpHeader [2] & 0x80) == 0x80);  		_hasExtendedHeader = ((tmpHeader [2] & 0x40) == 0x40);  		_isExperimental = ((tmpHeader [2] & 0x20) == 0x20);  		_isFooterPresent = ((tmpHeader [2] & 0x10) == 0x10);  		_isCompressed = false;  		break;  	}  	// Size  	_tagSize = (tmpHeader [3] << 21);  	_tagSize += (tmpHeader [4] << 14);  	_tagSize += (tmpHeader [5] << 7);  	_tagSize += (tmpHeader [6]);  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Header,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2Header.cs,Read,The following statement contains a magic number: if (readIdentifier) {  	Read (stream);  } else {  	byte[] tmpHeader = stream.Read (7);  	// Version  	if (tmpHeader [0] < 2 || tmpHeader [0] > 4) {  		string msg = string.Format ("ID3 Version '{0}' not recognized (valid versions are 2' 3' and 4)"' tmpHeader [0]);  		Trace.WriteLine (msg);  		throw new InvalidDataException (msg);  	}  	_tagVersion = (ID3v2TagVersion)tmpHeader [0];  	// Version revision  	_tagVersionRevision = tmpHeader [1];  	// Flags  	switch (_tagVersion) {  	case ID3v2TagVersion.ID3v23:  		UsesUnsynchronization = ((tmpHeader [2] & 0x80) == 0x80);  		/*if (this.UsesUnsynchronization == true)                         {                             Console.WriteLine(((FileStream)stream).Name);                         }*/_hasExtendedHeader = ((tmpHeader [2] & 0x40) == 0x40);  		_isExperimental = ((tmpHeader [2] & 0x20) == 0x20);  		_isFooterPresent = false;  		_isCompressed = false;  		break;  	case ID3v2TagVersion.ID3v22:  		_usesUnsynchronization = ((tmpHeader [2] & 0x80) == 0x80);  		_isFooterPresent = false;  		_isCompressed = ((tmpHeader [2] & 0x40) == 0x40);  		break;  	case ID3v2TagVersion.ID3v24:  		_usesUnsynchronization = ((tmpHeader [2] & 0x80) == 0x80);  		_hasExtendedHeader = ((tmpHeader [2] & 0x40) == 0x40);  		_isExperimental = ((tmpHeader [2] & 0x20) == 0x20);  		_isFooterPresent = ((tmpHeader [2] & 0x10) == 0x10);  		_isCompressed = false;  		break;  	}  	// Size  	_tagSize = (tmpHeader [3] << 21);  	_tagSize += (tmpHeader [4] << 14);  	_tagSize += (tmpHeader [5] << 7);  	_tagSize += (tmpHeader [6]);  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Header,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2Header.cs,Read,The following statement contains a magic number: if (readIdentifier) {  	Read (stream);  } else {  	byte[] tmpHeader = stream.Read (7);  	// Version  	if (tmpHeader [0] < 2 || tmpHeader [0] > 4) {  		string msg = string.Format ("ID3 Version '{0}' not recognized (valid versions are 2' 3' and 4)"' tmpHeader [0]);  		Trace.WriteLine (msg);  		throw new InvalidDataException (msg);  	}  	_tagVersion = (ID3v2TagVersion)tmpHeader [0];  	// Version revision  	_tagVersionRevision = tmpHeader [1];  	// Flags  	switch (_tagVersion) {  	case ID3v2TagVersion.ID3v23:  		UsesUnsynchronization = ((tmpHeader [2] & 0x80) == 0x80);  		/*if (this.UsesUnsynchronization == true)                         {                             Console.WriteLine(((FileStream)stream).Name);                         }*/_hasExtendedHeader = ((tmpHeader [2] & 0x40) == 0x40);  		_isExperimental = ((tmpHeader [2] & 0x20) == 0x20);  		_isFooterPresent = false;  		_isCompressed = false;  		break;  	case ID3v2TagVersion.ID3v22:  		_usesUnsynchronization = ((tmpHeader [2] & 0x80) == 0x80);  		_isFooterPresent = false;  		_isCompressed = ((tmpHeader [2] & 0x40) == 0x40);  		break;  	case ID3v2TagVersion.ID3v24:  		_usesUnsynchronization = ((tmpHeader [2] & 0x80) == 0x80);  		_hasExtendedHeader = ((tmpHeader [2] & 0x40) == 0x40);  		_isExperimental = ((tmpHeader [2] & 0x20) == 0x20);  		_isFooterPresent = ((tmpHeader [2] & 0x10) == 0x10);  		_isCompressed = false;  		break;  	}  	// Size  	_tagSize = (tmpHeader [3] << 21);  	_tagSize += (tmpHeader [4] << 14);  	_tagSize += (tmpHeader [5] << 7);  	_tagSize += (tmpHeader [6]);  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Header,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2Header.cs,Read,The following statement contains a magic number: if (readIdentifier) {  	Read (stream);  } else {  	byte[] tmpHeader = stream.Read (7);  	// Version  	if (tmpHeader [0] < 2 || tmpHeader [0] > 4) {  		string msg = string.Format ("ID3 Version '{0}' not recognized (valid versions are 2' 3' and 4)"' tmpHeader [0]);  		Trace.WriteLine (msg);  		throw new InvalidDataException (msg);  	}  	_tagVersion = (ID3v2TagVersion)tmpHeader [0];  	// Version revision  	_tagVersionRevision = tmpHeader [1];  	// Flags  	switch (_tagVersion) {  	case ID3v2TagVersion.ID3v23:  		UsesUnsynchronization = ((tmpHeader [2] & 0x80) == 0x80);  		/*if (this.UsesUnsynchronization == true)                         {                             Console.WriteLine(((FileStream)stream).Name);                         }*/_hasExtendedHeader = ((tmpHeader [2] & 0x40) == 0x40);  		_isExperimental = ((tmpHeader [2] & 0x20) == 0x20);  		_isFooterPresent = false;  		_isCompressed = false;  		break;  	case ID3v2TagVersion.ID3v22:  		_usesUnsynchronization = ((tmpHeader [2] & 0x80) == 0x80);  		_isFooterPresent = false;  		_isCompressed = ((tmpHeader [2] & 0x40) == 0x40);  		break;  	case ID3v2TagVersion.ID3v24:  		_usesUnsynchronization = ((tmpHeader [2] & 0x80) == 0x80);  		_hasExtendedHeader = ((tmpHeader [2] & 0x40) == 0x40);  		_isExperimental = ((tmpHeader [2] & 0x20) == 0x20);  		_isFooterPresent = ((tmpHeader [2] & 0x10) == 0x10);  		_isCompressed = false;  		break;  	}  	// Size  	_tagSize = (tmpHeader [3] << 21);  	_tagSize += (tmpHeader [4] << 14);  	_tagSize += (tmpHeader [5] << 7);  	_tagSize += (tmpHeader [6]);  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Header,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2Header.cs,Read,The following statement contains a magic number: if (readIdentifier) {  	Read (stream);  } else {  	byte[] tmpHeader = stream.Read (7);  	// Version  	if (tmpHeader [0] < 2 || tmpHeader [0] > 4) {  		string msg = string.Format ("ID3 Version '{0}' not recognized (valid versions are 2' 3' and 4)"' tmpHeader [0]);  		Trace.WriteLine (msg);  		throw new InvalidDataException (msg);  	}  	_tagVersion = (ID3v2TagVersion)tmpHeader [0];  	// Version revision  	_tagVersionRevision = tmpHeader [1];  	// Flags  	switch (_tagVersion) {  	case ID3v2TagVersion.ID3v23:  		UsesUnsynchronization = ((tmpHeader [2] & 0x80) == 0x80);  		/*if (this.UsesUnsynchronization == true)                         {                             Console.WriteLine(((FileStream)stream).Name);                         }*/_hasExtendedHeader = ((tmpHeader [2] & 0x40) == 0x40);  		_isExperimental = ((tmpHeader [2] & 0x20) == 0x20);  		_isFooterPresent = false;  		_isCompressed = false;  		break;  	case ID3v2TagVersion.ID3v22:  		_usesUnsynchronization = ((tmpHeader [2] & 0x80) == 0x80);  		_isFooterPresent = false;  		_isCompressed = ((tmpHeader [2] & 0x40) == 0x40);  		break;  	case ID3v2TagVersion.ID3v24:  		_usesUnsynchronization = ((tmpHeader [2] & 0x80) == 0x80);  		_hasExtendedHeader = ((tmpHeader [2] & 0x40) == 0x40);  		_isExperimental = ((tmpHeader [2] & 0x20) == 0x20);  		_isFooterPresent = ((tmpHeader [2] & 0x10) == 0x10);  		_isCompressed = false;  		break;  	}  	// Size  	_tagSize = (tmpHeader [3] << 21);  	_tagSize += (tmpHeader [4] << 14);  	_tagSize += (tmpHeader [5] << 7);  	_tagSize += (tmpHeader [6]);  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Header,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2Header.cs,Read,The following statement contains a magic number: if (readIdentifier) {  	Read (stream);  } else {  	byte[] tmpHeader = stream.Read (7);  	// Version  	if (tmpHeader [0] < 2 || tmpHeader [0] > 4) {  		string msg = string.Format ("ID3 Version '{0}' not recognized (valid versions are 2' 3' and 4)"' tmpHeader [0]);  		Trace.WriteLine (msg);  		throw new InvalidDataException (msg);  	}  	_tagVersion = (ID3v2TagVersion)tmpHeader [0];  	// Version revision  	_tagVersionRevision = tmpHeader [1];  	// Flags  	switch (_tagVersion) {  	case ID3v2TagVersion.ID3v23:  		UsesUnsynchronization = ((tmpHeader [2] & 0x80) == 0x80);  		/*if (this.UsesUnsynchronization == true)                         {                             Console.WriteLine(((FileStream)stream).Name);                         }*/_hasExtendedHeader = ((tmpHeader [2] & 0x40) == 0x40);  		_isExperimental = ((tmpHeader [2] & 0x20) == 0x20);  		_isFooterPresent = false;  		_isCompressed = false;  		break;  	case ID3v2TagVersion.ID3v22:  		_usesUnsynchronization = ((tmpHeader [2] & 0x80) == 0x80);  		_isFooterPresent = false;  		_isCompressed = ((tmpHeader [2] & 0x40) == 0x40);  		break;  	case ID3v2TagVersion.ID3v24:  		_usesUnsynchronization = ((tmpHeader [2] & 0x80) == 0x80);  		_hasExtendedHeader = ((tmpHeader [2] & 0x40) == 0x40);  		_isExperimental = ((tmpHeader [2] & 0x20) == 0x20);  		_isFooterPresent = ((tmpHeader [2] & 0x10) == 0x10);  		_isCompressed = false;  		break;  	}  	// Size  	_tagSize = (tmpHeader [3] << 21);  	_tagSize += (tmpHeader [4] << 14);  	_tagSize += (tmpHeader [5] << 7);  	_tagSize += (tmpHeader [6]);  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Header,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2Header.cs,Read,The following statement contains a magic number: if (readIdentifier) {  	Read (stream);  } else {  	byte[] tmpHeader = stream.Read (7);  	// Version  	if (tmpHeader [0] < 2 || tmpHeader [0] > 4) {  		string msg = string.Format ("ID3 Version '{0}' not recognized (valid versions are 2' 3' and 4)"' tmpHeader [0]);  		Trace.WriteLine (msg);  		throw new InvalidDataException (msg);  	}  	_tagVersion = (ID3v2TagVersion)tmpHeader [0];  	// Version revision  	_tagVersionRevision = tmpHeader [1];  	// Flags  	switch (_tagVersion) {  	case ID3v2TagVersion.ID3v23:  		UsesUnsynchronization = ((tmpHeader [2] & 0x80) == 0x80);  		/*if (this.UsesUnsynchronization == true)                         {                             Console.WriteLine(((FileStream)stream).Name);                         }*/_hasExtendedHeader = ((tmpHeader [2] & 0x40) == 0x40);  		_isExperimental = ((tmpHeader [2] & 0x20) == 0x20);  		_isFooterPresent = false;  		_isCompressed = false;  		break;  	case ID3v2TagVersion.ID3v22:  		_usesUnsynchronization = ((tmpHeader [2] & 0x80) == 0x80);  		_isFooterPresent = false;  		_isCompressed = ((tmpHeader [2] & 0x40) == 0x40);  		break;  	case ID3v2TagVersion.ID3v24:  		_usesUnsynchronization = ((tmpHeader [2] & 0x80) == 0x80);  		_hasExtendedHeader = ((tmpHeader [2] & 0x40) == 0x40);  		_isExperimental = ((tmpHeader [2] & 0x20) == 0x20);  		_isFooterPresent = ((tmpHeader [2] & 0x10) == 0x10);  		_isCompressed = false;  		break;  	}  	// Size  	_tagSize = (tmpHeader [3] << 21);  	_tagSize += (tmpHeader [4] << 14);  	_tagSize += (tmpHeader [5] << 7);  	_tagSize += (tmpHeader [6]);  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Header,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2Header.cs,Read,The following statement contains a magic number: if (readIdentifier) {  	Read (stream);  } else {  	byte[] tmpHeader = stream.Read (7);  	// Version  	if (tmpHeader [0] < 2 || tmpHeader [0] > 4) {  		string msg = string.Format ("ID3 Version '{0}' not recognized (valid versions are 2' 3' and 4)"' tmpHeader [0]);  		Trace.WriteLine (msg);  		throw new InvalidDataException (msg);  	}  	_tagVersion = (ID3v2TagVersion)tmpHeader [0];  	// Version revision  	_tagVersionRevision = tmpHeader [1];  	// Flags  	switch (_tagVersion) {  	case ID3v2TagVersion.ID3v23:  		UsesUnsynchronization = ((tmpHeader [2] & 0x80) == 0x80);  		/*if (this.UsesUnsynchronization == true)                         {                             Console.WriteLine(((FileStream)stream).Name);                         }*/_hasExtendedHeader = ((tmpHeader [2] & 0x40) == 0x40);  		_isExperimental = ((tmpHeader [2] & 0x20) == 0x20);  		_isFooterPresent = false;  		_isCompressed = false;  		break;  	case ID3v2TagVersion.ID3v22:  		_usesUnsynchronization = ((tmpHeader [2] & 0x80) == 0x80);  		_isFooterPresent = false;  		_isCompressed = ((tmpHeader [2] & 0x40) == 0x40);  		break;  	case ID3v2TagVersion.ID3v24:  		_usesUnsynchronization = ((tmpHeader [2] & 0x80) == 0x80);  		_hasExtendedHeader = ((tmpHeader [2] & 0x40) == 0x40);  		_isExperimental = ((tmpHeader [2] & 0x20) == 0x20);  		_isFooterPresent = ((tmpHeader [2] & 0x10) == 0x10);  		_isCompressed = false;  		break;  	}  	// Size  	_tagSize = (tmpHeader [3] << 21);  	_tagSize += (tmpHeader [4] << 14);  	_tagSize += (tmpHeader [5] << 7);  	_tagSize += (tmpHeader [6]);  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Header,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2Header.cs,Read,The following statement contains a magic number: if (readIdentifier) {  	Read (stream);  } else {  	byte[] tmpHeader = stream.Read (7);  	// Version  	if (tmpHeader [0] < 2 || tmpHeader [0] > 4) {  		string msg = string.Format ("ID3 Version '{0}' not recognized (valid versions are 2' 3' and 4)"' tmpHeader [0]);  		Trace.WriteLine (msg);  		throw new InvalidDataException (msg);  	}  	_tagVersion = (ID3v2TagVersion)tmpHeader [0];  	// Version revision  	_tagVersionRevision = tmpHeader [1];  	// Flags  	switch (_tagVersion) {  	case ID3v2TagVersion.ID3v23:  		UsesUnsynchronization = ((tmpHeader [2] & 0x80) == 0x80);  		/*if (this.UsesUnsynchronization == true)                         {                             Console.WriteLine(((FileStream)stream).Name);                         }*/_hasExtendedHeader = ((tmpHeader [2] & 0x40) == 0x40);  		_isExperimental = ((tmpHeader [2] & 0x20) == 0x20);  		_isFooterPresent = false;  		_isCompressed = false;  		break;  	case ID3v2TagVersion.ID3v22:  		_usesUnsynchronization = ((tmpHeader [2] & 0x80) == 0x80);  		_isFooterPresent = false;  		_isCompressed = ((tmpHeader [2] & 0x40) == 0x40);  		break;  	case ID3v2TagVersion.ID3v24:  		_usesUnsynchronization = ((tmpHeader [2] & 0x80) == 0x80);  		_hasExtendedHeader = ((tmpHeader [2] & 0x40) == 0x40);  		_isExperimental = ((tmpHeader [2] & 0x20) == 0x20);  		_isFooterPresent = ((tmpHeader [2] & 0x10) == 0x10);  		_isCompressed = false;  		break;  	}  	// Size  	_tagSize = (tmpHeader [3] << 21);  	_tagSize += (tmpHeader [4] << 14);  	_tagSize += (tmpHeader [5] << 7);  	_tagSize += (tmpHeader [6]);  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Header,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2Header.cs,Read,The following statement contains a magic number: if (readIdentifier) {  	Read (stream);  } else {  	byte[] tmpHeader = stream.Read (7);  	// Version  	if (tmpHeader [0] < 2 || tmpHeader [0] > 4) {  		string msg = string.Format ("ID3 Version '{0}' not recognized (valid versions are 2' 3' and 4)"' tmpHeader [0]);  		Trace.WriteLine (msg);  		throw new InvalidDataException (msg);  	}  	_tagVersion = (ID3v2TagVersion)tmpHeader [0];  	// Version revision  	_tagVersionRevision = tmpHeader [1];  	// Flags  	switch (_tagVersion) {  	case ID3v2TagVersion.ID3v23:  		UsesUnsynchronization = ((tmpHeader [2] & 0x80) == 0x80);  		/*if (this.UsesUnsynchronization == true)                         {                             Console.WriteLine(((FileStream)stream).Name);                         }*/_hasExtendedHeader = ((tmpHeader [2] & 0x40) == 0x40);  		_isExperimental = ((tmpHeader [2] & 0x20) == 0x20);  		_isFooterPresent = false;  		_isCompressed = false;  		break;  	case ID3v2TagVersion.ID3v22:  		_usesUnsynchronization = ((tmpHeader [2] & 0x80) == 0x80);  		_isFooterPresent = false;  		_isCompressed = ((tmpHeader [2] & 0x40) == 0x40);  		break;  	case ID3v2TagVersion.ID3v24:  		_usesUnsynchronization = ((tmpHeader [2] & 0x80) == 0x80);  		_hasExtendedHeader = ((tmpHeader [2] & 0x40) == 0x40);  		_isExperimental = ((tmpHeader [2] & 0x20) == 0x20);  		_isFooterPresent = ((tmpHeader [2] & 0x10) == 0x10);  		_isCompressed = false;  		break;  	}  	// Size  	_tagSize = (tmpHeader [3] << 21);  	_tagSize += (tmpHeader [4] << 14);  	_tagSize += (tmpHeader [5] << 7);  	_tagSize += (tmpHeader [6]);  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Header,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2Header.cs,Read,The following statement contains a magic number: if (readIdentifier) {  	Read (stream);  } else {  	byte[] tmpHeader = stream.Read (7);  	// Version  	if (tmpHeader [0] < 2 || tmpHeader [0] > 4) {  		string msg = string.Format ("ID3 Version '{0}' not recognized (valid versions are 2' 3' and 4)"' tmpHeader [0]);  		Trace.WriteLine (msg);  		throw new InvalidDataException (msg);  	}  	_tagVersion = (ID3v2TagVersion)tmpHeader [0];  	// Version revision  	_tagVersionRevision = tmpHeader [1];  	// Flags  	switch (_tagVersion) {  	case ID3v2TagVersion.ID3v23:  		UsesUnsynchronization = ((tmpHeader [2] & 0x80) == 0x80);  		/*if (this.UsesUnsynchronization == true)                         {                             Console.WriteLine(((FileStream)stream).Name);                         }*/_hasExtendedHeader = ((tmpHeader [2] & 0x40) == 0x40);  		_isExperimental = ((tmpHeader [2] & 0x20) == 0x20);  		_isFooterPresent = false;  		_isCompressed = false;  		break;  	case ID3v2TagVersion.ID3v22:  		_usesUnsynchronization = ((tmpHeader [2] & 0x80) == 0x80);  		_isFooterPresent = false;  		_isCompressed = ((tmpHeader [2] & 0x40) == 0x40);  		break;  	case ID3v2TagVersion.ID3v24:  		_usesUnsynchronization = ((tmpHeader [2] & 0x80) == 0x80);  		_hasExtendedHeader = ((tmpHeader [2] & 0x40) == 0x40);  		_isExperimental = ((tmpHeader [2] & 0x20) == 0x20);  		_isFooterPresent = ((tmpHeader [2] & 0x10) == 0x10);  		_isCompressed = false;  		break;  	}  	// Size  	_tagSize = (tmpHeader [3] << 21);  	_tagSize += (tmpHeader [4] << 14);  	_tagSize += (tmpHeader [5] << 7);  	_tagSize += (tmpHeader [6]);  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Header,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2Header.cs,Read,The following statement contains a magic number: if (readIdentifier) {  	Read (stream);  } else {  	byte[] tmpHeader = stream.Read (7);  	// Version  	if (tmpHeader [0] < 2 || tmpHeader [0] > 4) {  		string msg = string.Format ("ID3 Version '{0}' not recognized (valid versions are 2' 3' and 4)"' tmpHeader [0]);  		Trace.WriteLine (msg);  		throw new InvalidDataException (msg);  	}  	_tagVersion = (ID3v2TagVersion)tmpHeader [0];  	// Version revision  	_tagVersionRevision = tmpHeader [1];  	// Flags  	switch (_tagVersion) {  	case ID3v2TagVersion.ID3v23:  		UsesUnsynchronization = ((tmpHeader [2] & 0x80) == 0x80);  		/*if (this.UsesUnsynchronization == true)                         {                             Console.WriteLine(((FileStream)stream).Name);                         }*/_hasExtendedHeader = ((tmpHeader [2] & 0x40) == 0x40);  		_isExperimental = ((tmpHeader [2] & 0x20) == 0x20);  		_isFooterPresent = false;  		_isCompressed = false;  		break;  	case ID3v2TagVersion.ID3v22:  		_usesUnsynchronization = ((tmpHeader [2] & 0x80) == 0x80);  		_isFooterPresent = false;  		_isCompressed = ((tmpHeader [2] & 0x40) == 0x40);  		break;  	case ID3v2TagVersion.ID3v24:  		_usesUnsynchronization = ((tmpHeader [2] & 0x80) == 0x80);  		_hasExtendedHeader = ((tmpHeader [2] & 0x40) == 0x40);  		_isExperimental = ((tmpHeader [2] & 0x20) == 0x20);  		_isFooterPresent = ((tmpHeader [2] & 0x10) == 0x10);  		_isCompressed = false;  		break;  	}  	// Size  	_tagSize = (tmpHeader [3] << 21);  	_tagSize += (tmpHeader [4] << 14);  	_tagSize += (tmpHeader [5] << 7);  	_tagSize += (tmpHeader [6]);  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Header,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2Header.cs,Read,The following statement contains a magic number: if (readIdentifier) {  	Read (stream);  } else {  	byte[] tmpHeader = stream.Read (7);  	// Version  	if (tmpHeader [0] < 2 || tmpHeader [0] > 4) {  		string msg = string.Format ("ID3 Version '{0}' not recognized (valid versions are 2' 3' and 4)"' tmpHeader [0]);  		Trace.WriteLine (msg);  		throw new InvalidDataException (msg);  	}  	_tagVersion = (ID3v2TagVersion)tmpHeader [0];  	// Version revision  	_tagVersionRevision = tmpHeader [1];  	// Flags  	switch (_tagVersion) {  	case ID3v2TagVersion.ID3v23:  		UsesUnsynchronization = ((tmpHeader [2] & 0x80) == 0x80);  		/*if (this.UsesUnsynchronization == true)                         {                             Console.WriteLine(((FileStream)stream).Name);                         }*/_hasExtendedHeader = ((tmpHeader [2] & 0x40) == 0x40);  		_isExperimental = ((tmpHeader [2] & 0x20) == 0x20);  		_isFooterPresent = false;  		_isCompressed = false;  		break;  	case ID3v2TagVersion.ID3v22:  		_usesUnsynchronization = ((tmpHeader [2] & 0x80) == 0x80);  		_isFooterPresent = false;  		_isCompressed = ((tmpHeader [2] & 0x40) == 0x40);  		break;  	case ID3v2TagVersion.ID3v24:  		_usesUnsynchronization = ((tmpHeader [2] & 0x80) == 0x80);  		_hasExtendedHeader = ((tmpHeader [2] & 0x40) == 0x40);  		_isExperimental = ((tmpHeader [2] & 0x20) == 0x20);  		_isFooterPresent = ((tmpHeader [2] & 0x10) == 0x10);  		_isCompressed = false;  		break;  	}  	// Size  	_tagSize = (tmpHeader [3] << 21);  	_tagSize += (tmpHeader [4] << 14);  	_tagSize += (tmpHeader [5] << 7);  	_tagSize += (tmpHeader [6]);  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Header,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2Header.cs,Read,The following statement contains a magic number: if (tmpHeader [0] < 2 || tmpHeader [0] > 4) {  	string msg = string.Format ("ID3 Version '{0}' not recognized (valid versions are 2' 3' and 4)"' tmpHeader [0]);  	Trace.WriteLine (msg);  	throw new InvalidDataException (msg);  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Header,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2Header.cs,Read,The following statement contains a magic number: if (tmpHeader [0] < 2 || tmpHeader [0] > 4) {  	string msg = string.Format ("ID3 Version '{0}' not recognized (valid versions are 2' 3' and 4)"' tmpHeader [0]);  	Trace.WriteLine (msg);  	throw new InvalidDataException (msg);  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Header,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2Header.cs,Read,The following statement contains a magic number: switch (_tagVersion) {  case ID3v2TagVersion.ID3v23:  	UsesUnsynchronization = ((tmpHeader [2] & 0x80) == 0x80);  	/*if (this.UsesUnsynchronization == true)                         {                             Console.WriteLine(((FileStream)stream).Name);                         }*/_hasExtendedHeader = ((tmpHeader [2] & 0x40) == 0x40);  	_isExperimental = ((tmpHeader [2] & 0x20) == 0x20);  	_isFooterPresent = false;  	_isCompressed = false;  	break;  case ID3v2TagVersion.ID3v22:  	_usesUnsynchronization = ((tmpHeader [2] & 0x80) == 0x80);  	_isFooterPresent = false;  	_isCompressed = ((tmpHeader [2] & 0x40) == 0x40);  	break;  case ID3v2TagVersion.ID3v24:  	_usesUnsynchronization = ((tmpHeader [2] & 0x80) == 0x80);  	_hasExtendedHeader = ((tmpHeader [2] & 0x40) == 0x40);  	_isExperimental = ((tmpHeader [2] & 0x20) == 0x20);  	_isFooterPresent = ((tmpHeader [2] & 0x10) == 0x10);  	_isCompressed = false;  	break;  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Header,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2Header.cs,Read,The following statement contains a magic number: switch (_tagVersion) {  case ID3v2TagVersion.ID3v23:  	UsesUnsynchronization = ((tmpHeader [2] & 0x80) == 0x80);  	/*if (this.UsesUnsynchronization == true)                         {                             Console.WriteLine(((FileStream)stream).Name);                         }*/_hasExtendedHeader = ((tmpHeader [2] & 0x40) == 0x40);  	_isExperimental = ((tmpHeader [2] & 0x20) == 0x20);  	_isFooterPresent = false;  	_isCompressed = false;  	break;  case ID3v2TagVersion.ID3v22:  	_usesUnsynchronization = ((tmpHeader [2] & 0x80) == 0x80);  	_isFooterPresent = false;  	_isCompressed = ((tmpHeader [2] & 0x40) == 0x40);  	break;  case ID3v2TagVersion.ID3v24:  	_usesUnsynchronization = ((tmpHeader [2] & 0x80) == 0x80);  	_hasExtendedHeader = ((tmpHeader [2] & 0x40) == 0x40);  	_isExperimental = ((tmpHeader [2] & 0x20) == 0x20);  	_isFooterPresent = ((tmpHeader [2] & 0x10) == 0x10);  	_isCompressed = false;  	break;  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Header,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2Header.cs,Read,The following statement contains a magic number: switch (_tagVersion) {  case ID3v2TagVersion.ID3v23:  	UsesUnsynchronization = ((tmpHeader [2] & 0x80) == 0x80);  	/*if (this.UsesUnsynchronization == true)                         {                             Console.WriteLine(((FileStream)stream).Name);                         }*/_hasExtendedHeader = ((tmpHeader [2] & 0x40) == 0x40);  	_isExperimental = ((tmpHeader [2] & 0x20) == 0x20);  	_isFooterPresent = false;  	_isCompressed = false;  	break;  case ID3v2TagVersion.ID3v22:  	_usesUnsynchronization = ((tmpHeader [2] & 0x80) == 0x80);  	_isFooterPresent = false;  	_isCompressed = ((tmpHeader [2] & 0x40) == 0x40);  	break;  case ID3v2TagVersion.ID3v24:  	_usesUnsynchronization = ((tmpHeader [2] & 0x80) == 0x80);  	_hasExtendedHeader = ((tmpHeader [2] & 0x40) == 0x40);  	_isExperimental = ((tmpHeader [2] & 0x20) == 0x20);  	_isFooterPresent = ((tmpHeader [2] & 0x10) == 0x10);  	_isCompressed = false;  	break;  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Header,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2Header.cs,Read,The following statement contains a magic number: switch (_tagVersion) {  case ID3v2TagVersion.ID3v23:  	UsesUnsynchronization = ((tmpHeader [2] & 0x80) == 0x80);  	/*if (this.UsesUnsynchronization == true)                         {                             Console.WriteLine(((FileStream)stream).Name);                         }*/_hasExtendedHeader = ((tmpHeader [2] & 0x40) == 0x40);  	_isExperimental = ((tmpHeader [2] & 0x20) == 0x20);  	_isFooterPresent = false;  	_isCompressed = false;  	break;  case ID3v2TagVersion.ID3v22:  	_usesUnsynchronization = ((tmpHeader [2] & 0x80) == 0x80);  	_isFooterPresent = false;  	_isCompressed = ((tmpHeader [2] & 0x40) == 0x40);  	break;  case ID3v2TagVersion.ID3v24:  	_usesUnsynchronization = ((tmpHeader [2] & 0x80) == 0x80);  	_hasExtendedHeader = ((tmpHeader [2] & 0x40) == 0x40);  	_isExperimental = ((tmpHeader [2] & 0x20) == 0x20);  	_isFooterPresent = ((tmpHeader [2] & 0x10) == 0x10);  	_isCompressed = false;  	break;  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Header,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2Header.cs,Read,The following statement contains a magic number: switch (_tagVersion) {  case ID3v2TagVersion.ID3v23:  	UsesUnsynchronization = ((tmpHeader [2] & 0x80) == 0x80);  	/*if (this.UsesUnsynchronization == true)                         {                             Console.WriteLine(((FileStream)stream).Name);                         }*/_hasExtendedHeader = ((tmpHeader [2] & 0x40) == 0x40);  	_isExperimental = ((tmpHeader [2] & 0x20) == 0x20);  	_isFooterPresent = false;  	_isCompressed = false;  	break;  case ID3v2TagVersion.ID3v22:  	_usesUnsynchronization = ((tmpHeader [2] & 0x80) == 0x80);  	_isFooterPresent = false;  	_isCompressed = ((tmpHeader [2] & 0x40) == 0x40);  	break;  case ID3v2TagVersion.ID3v24:  	_usesUnsynchronization = ((tmpHeader [2] & 0x80) == 0x80);  	_hasExtendedHeader = ((tmpHeader [2] & 0x40) == 0x40);  	_isExperimental = ((tmpHeader [2] & 0x20) == 0x20);  	_isFooterPresent = ((tmpHeader [2] & 0x10) == 0x10);  	_isCompressed = false;  	break;  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Header,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2Header.cs,Read,The following statement contains a magic number: switch (_tagVersion) {  case ID3v2TagVersion.ID3v23:  	UsesUnsynchronization = ((tmpHeader [2] & 0x80) == 0x80);  	/*if (this.UsesUnsynchronization == true)                         {                             Console.WriteLine(((FileStream)stream).Name);                         }*/_hasExtendedHeader = ((tmpHeader [2] & 0x40) == 0x40);  	_isExperimental = ((tmpHeader [2] & 0x20) == 0x20);  	_isFooterPresent = false;  	_isCompressed = false;  	break;  case ID3v2TagVersion.ID3v22:  	_usesUnsynchronization = ((tmpHeader [2] & 0x80) == 0x80);  	_isFooterPresent = false;  	_isCompressed = ((tmpHeader [2] & 0x40) == 0x40);  	break;  case ID3v2TagVersion.ID3v24:  	_usesUnsynchronization = ((tmpHeader [2] & 0x80) == 0x80);  	_hasExtendedHeader = ((tmpHeader [2] & 0x40) == 0x40);  	_isExperimental = ((tmpHeader [2] & 0x20) == 0x20);  	_isFooterPresent = ((tmpHeader [2] & 0x10) == 0x10);  	_isCompressed = false;  	break;  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Header,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2Header.cs,Read,The following statement contains a magic number: switch (_tagVersion) {  case ID3v2TagVersion.ID3v23:  	UsesUnsynchronization = ((tmpHeader [2] & 0x80) == 0x80);  	/*if (this.UsesUnsynchronization == true)                         {                             Console.WriteLine(((FileStream)stream).Name);                         }*/_hasExtendedHeader = ((tmpHeader [2] & 0x40) == 0x40);  	_isExperimental = ((tmpHeader [2] & 0x20) == 0x20);  	_isFooterPresent = false;  	_isCompressed = false;  	break;  case ID3v2TagVersion.ID3v22:  	_usesUnsynchronization = ((tmpHeader [2] & 0x80) == 0x80);  	_isFooterPresent = false;  	_isCompressed = ((tmpHeader [2] & 0x40) == 0x40);  	break;  case ID3v2TagVersion.ID3v24:  	_usesUnsynchronization = ((tmpHeader [2] & 0x80) == 0x80);  	_hasExtendedHeader = ((tmpHeader [2] & 0x40) == 0x40);  	_isExperimental = ((tmpHeader [2] & 0x20) == 0x20);  	_isFooterPresent = ((tmpHeader [2] & 0x10) == 0x10);  	_isCompressed = false;  	break;  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Header,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2Header.cs,Read,The following statement contains a magic number: switch (_tagVersion) {  case ID3v2TagVersion.ID3v23:  	UsesUnsynchronization = ((tmpHeader [2] & 0x80) == 0x80);  	/*if (this.UsesUnsynchronization == true)                         {                             Console.WriteLine(((FileStream)stream).Name);                         }*/_hasExtendedHeader = ((tmpHeader [2] & 0x40) == 0x40);  	_isExperimental = ((tmpHeader [2] & 0x20) == 0x20);  	_isFooterPresent = false;  	_isCompressed = false;  	break;  case ID3v2TagVersion.ID3v22:  	_usesUnsynchronization = ((tmpHeader [2] & 0x80) == 0x80);  	_isFooterPresent = false;  	_isCompressed = ((tmpHeader [2] & 0x40) == 0x40);  	break;  case ID3v2TagVersion.ID3v24:  	_usesUnsynchronization = ((tmpHeader [2] & 0x80) == 0x80);  	_hasExtendedHeader = ((tmpHeader [2] & 0x40) == 0x40);  	_isExperimental = ((tmpHeader [2] & 0x20) == 0x20);  	_isFooterPresent = ((tmpHeader [2] & 0x10) == 0x10);  	_isCompressed = false;  	break;  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Header,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2Header.cs,Read,The following statement contains a magic number: switch (_tagVersion) {  case ID3v2TagVersion.ID3v23:  	UsesUnsynchronization = ((tmpHeader [2] & 0x80) == 0x80);  	/*if (this.UsesUnsynchronization == true)                         {                             Console.WriteLine(((FileStream)stream).Name);                         }*/_hasExtendedHeader = ((tmpHeader [2] & 0x40) == 0x40);  	_isExperimental = ((tmpHeader [2] & 0x20) == 0x20);  	_isFooterPresent = false;  	_isCompressed = false;  	break;  case ID3v2TagVersion.ID3v22:  	_usesUnsynchronization = ((tmpHeader [2] & 0x80) == 0x80);  	_isFooterPresent = false;  	_isCompressed = ((tmpHeader [2] & 0x40) == 0x40);  	break;  case ID3v2TagVersion.ID3v24:  	_usesUnsynchronization = ((tmpHeader [2] & 0x80) == 0x80);  	_hasExtendedHeader = ((tmpHeader [2] & 0x40) == 0x40);  	_isExperimental = ((tmpHeader [2] & 0x20) == 0x20);  	_isFooterPresent = ((tmpHeader [2] & 0x10) == 0x10);  	_isCompressed = false;  	break;  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Header,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2Header.cs,Read,The following statement contains a magic number: UsesUnsynchronization = ((tmpHeader [2] & 0x80) == 0x80);  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Header,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2Header.cs,Read,The following statement contains a magic number: _hasExtendedHeader = ((tmpHeader [2] & 0x40) == 0x40);  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Header,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2Header.cs,Read,The following statement contains a magic number: _isExperimental = ((tmpHeader [2] & 0x20) == 0x20);  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Header,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2Header.cs,Read,The following statement contains a magic number: _usesUnsynchronization = ((tmpHeader [2] & 0x80) == 0x80);  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Header,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2Header.cs,Read,The following statement contains a magic number: _isCompressed = ((tmpHeader [2] & 0x40) == 0x40);  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Header,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2Header.cs,Read,The following statement contains a magic number: _usesUnsynchronization = ((tmpHeader [2] & 0x80) == 0x80);  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Header,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2Header.cs,Read,The following statement contains a magic number: _hasExtendedHeader = ((tmpHeader [2] & 0x40) == 0x40);  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Header,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2Header.cs,Read,The following statement contains a magic number: _isExperimental = ((tmpHeader [2] & 0x20) == 0x20);  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Header,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2Header.cs,Read,The following statement contains a magic number: _isFooterPresent = ((tmpHeader [2] & 0x10) == 0x10);  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Header,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2Header.cs,Read,The following statement contains a magic number: _tagSize = (tmpHeader [3] << 21);  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Header,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2Header.cs,Read,The following statement contains a magic number: _tagSize = (tmpHeader [3] << 21);  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Header,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2Header.cs,Read,The following statement contains a magic number: _tagSize += (tmpHeader [4] << 14);  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Header,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2Header.cs,Read,The following statement contains a magic number: _tagSize += (tmpHeader [4] << 14);  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Header,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2Header.cs,Read,The following statement contains a magic number: _tagSize += (tmpHeader [5] << 7);  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Header,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2Header.cs,Read,The following statement contains a magic number: _tagSize += (tmpHeader [5] << 7);  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Header,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2Header.cs,Read,The following statement contains a magic number: _tagSize += (tmpHeader [6]);  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Header,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2Header.cs,Read,The following statement contains a magic number: if (!(header [0] == 0x49 && header [1] == 0x44 && header [2] == 0x33)) {  	const string msg = "'ID3' marker not found";  	Trace.WriteLine (msg);  	throw new InvalidDataException (msg);  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Header,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2Header.cs,GetBytes,The following statement contains a magic number: header [2] = 0x33;  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Header,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2Header.cs,GetBytes,The following statement contains a magic number: header [3] = (byte)_tagVersion;  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Header,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2Header.cs,GetBytes,The following statement contains a magic number: header [4] = _tagVersionRevision;  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Header,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2Header.cs,GetBytes,The following statement contains a magic number: header [5] = 0;  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Header,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2Header.cs,GetBytes,The following statement contains a magic number: if (_usesUnsynchronization)  	header [5] += 0x80;  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Header,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2Header.cs,GetBytes,The following statement contains a magic number: header [5] += 0x80;  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Header,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2Header.cs,GetBytes,The following statement contains a magic number: if (_hasExtendedHeader)  	header [5] += 0x40;  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Header,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2Header.cs,GetBytes,The following statement contains a magic number: header [5] += 0x40;  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Header,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2Header.cs,GetBytes,The following statement contains a magic number: if (_isExperimental)  	header [5] += 0x20;  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Header,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2Header.cs,GetBytes,The following statement contains a magic number: header [5] += 0x20;  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Header,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2Header.cs,GetBytes,The following statement contains a magic number: header [6] = (byte)((_tagSize >> 21) & 0x7F);  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Header,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2Header.cs,GetBytes,The following statement contains a magic number: header [6] = (byte)((_tagSize >> 21) & 0x7F);  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Header,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2Header.cs,GetBytes,The following statement contains a magic number: header [7] = (byte)((_tagSize >> 14) & 0x7F);  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Header,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2Header.cs,GetBytes,The following statement contains a magic number: header [7] = (byte)((_tagSize >> 14) & 0x7F);  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Header,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2Header.cs,GetBytes,The following statement contains a magic number: header [8] = (byte)((_tagSize >> 7) & 0x7F);  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Header,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2Header.cs,GetBytes,The following statement contains a magic number: header [8] = (byte)((_tagSize >> 7) & 0x7F);  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Header,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2Header.cs,GetBytes,The following statement contains a magic number: header [9] = (byte)(_tagSize & 0x7F);  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Utils,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\ID3v2Utils.cs,ConvertToUnsynchronized,The following statement contains a magic number: using (MemoryStream newStream = new MemoryStream ((int)(data.Length * 1.05))) {  	for (int i = 0; i < data.Length; i++) {  		newStream.WriteByte (data [i]);  		if (data [i] == 0xFF) {  			if (i != data.Length - 1) {  				if (data [i + 1] == 0x00 || ((data [i + 1] & 0xE0) == 0xE0))// 0xE0 = 1110 0000  				 {  					newStream.WriteByte (0);  				}  			}  		}  	}  	return newStream.ToArray ();  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Utils,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\ID3v2Utils.cs,ReadString,The following statement contains a magic number: if (textEncoding == EncodingType.ISO88591) {  	returnValue = ByteUtils.ISO88591GetString (byteArray);  } else if (textEncoding == EncodingType.Unicode) {  	if (length > 2) {  		if (byteArray.Length >= 2) {  			// If BOM is part of the string' decode as the appropriate Unicode type.  			// If no BOM is present use Little Endian Unicode.  			if (byteArray [0] == 0xFF && byteArray [1] == 0xFE)  				returnValue = Encoding.Unicode.GetString (byteArray' 2' byteArray.Length - 2);  			else if (byteArray [0] == 0xFE && byteArray [1] == 0xFF)  				returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 2' byteArray.Length - 2);  			else  				returnValue = Encoding.Unicode.GetString (byteArray' 0' byteArray.Length);  		} else {  			returnValue = Encoding.Unicode.GetString (byteArray' 0' byteArray.Length);  		}  	}  } else if (textEncoding == EncodingType.UTF16BE) {  	if (byteArray.Length >= 2) {  		// If BOM is part of the string' remove before decoding.  		if (byteArray [0] == 0xFE && byteArray [1] == 0xFF)  			returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 2' byteArray.Length - 2);  		else  			returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 0' byteArray.Length);  	} else {  		returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 0' byteArray.Length);  	}  } else if (textEncoding == EncodingType.UTF8) {  	returnValue = Encoding.UTF8.GetString (byteArray' 0' length);  } else {  	// Most likely bad data  	string msg = string.Format ("Text Encoding '{0}' unknown at position {1}"' textEncoding' stream.Position);  	Trace.WriteLine (msg);  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Utils,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\ID3v2Utils.cs,ReadString,The following statement contains a magic number: if (textEncoding == EncodingType.ISO88591) {  	returnValue = ByteUtils.ISO88591GetString (byteArray);  } else if (textEncoding == EncodingType.Unicode) {  	if (length > 2) {  		if (byteArray.Length >= 2) {  			// If BOM is part of the string' decode as the appropriate Unicode type.  			// If no BOM is present use Little Endian Unicode.  			if (byteArray [0] == 0xFF && byteArray [1] == 0xFE)  				returnValue = Encoding.Unicode.GetString (byteArray' 2' byteArray.Length - 2);  			else if (byteArray [0] == 0xFE && byteArray [1] == 0xFF)  				returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 2' byteArray.Length - 2);  			else  				returnValue = Encoding.Unicode.GetString (byteArray' 0' byteArray.Length);  		} else {  			returnValue = Encoding.Unicode.GetString (byteArray' 0' byteArray.Length);  		}  	}  } else if (textEncoding == EncodingType.UTF16BE) {  	if (byteArray.Length >= 2) {  		// If BOM is part of the string' remove before decoding.  		if (byteArray [0] == 0xFE && byteArray [1] == 0xFF)  			returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 2' byteArray.Length - 2);  		else  			returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 0' byteArray.Length);  	} else {  		returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 0' byteArray.Length);  	}  } else if (textEncoding == EncodingType.UTF8) {  	returnValue = Encoding.UTF8.GetString (byteArray' 0' length);  } else {  	// Most likely bad data  	string msg = string.Format ("Text Encoding '{0}' unknown at position {1}"' textEncoding' stream.Position);  	Trace.WriteLine (msg);  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Utils,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\ID3v2Utils.cs,ReadString,The following statement contains a magic number: if (textEncoding == EncodingType.ISO88591) {  	returnValue = ByteUtils.ISO88591GetString (byteArray);  } else if (textEncoding == EncodingType.Unicode) {  	if (length > 2) {  		if (byteArray.Length >= 2) {  			// If BOM is part of the string' decode as the appropriate Unicode type.  			// If no BOM is present use Little Endian Unicode.  			if (byteArray [0] == 0xFF && byteArray [1] == 0xFE)  				returnValue = Encoding.Unicode.GetString (byteArray' 2' byteArray.Length - 2);  			else if (byteArray [0] == 0xFE && byteArray [1] == 0xFF)  				returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 2' byteArray.Length - 2);  			else  				returnValue = Encoding.Unicode.GetString (byteArray' 0' byteArray.Length);  		} else {  			returnValue = Encoding.Unicode.GetString (byteArray' 0' byteArray.Length);  		}  	}  } else if (textEncoding == EncodingType.UTF16BE) {  	if (byteArray.Length >= 2) {  		// If BOM is part of the string' remove before decoding.  		if (byteArray [0] == 0xFE && byteArray [1] == 0xFF)  			returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 2' byteArray.Length - 2);  		else  			returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 0' byteArray.Length);  	} else {  		returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 0' byteArray.Length);  	}  } else if (textEncoding == EncodingType.UTF8) {  	returnValue = Encoding.UTF8.GetString (byteArray' 0' length);  } else {  	// Most likely bad data  	string msg = string.Format ("Text Encoding '{0}' unknown at position {1}"' textEncoding' stream.Position);  	Trace.WriteLine (msg);  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Utils,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\ID3v2Utils.cs,ReadString,The following statement contains a magic number: if (textEncoding == EncodingType.ISO88591) {  	returnValue = ByteUtils.ISO88591GetString (byteArray);  } else if (textEncoding == EncodingType.Unicode) {  	if (length > 2) {  		if (byteArray.Length >= 2) {  			// If BOM is part of the string' decode as the appropriate Unicode type.  			// If no BOM is present use Little Endian Unicode.  			if (byteArray [0] == 0xFF && byteArray [1] == 0xFE)  				returnValue = Encoding.Unicode.GetString (byteArray' 2' byteArray.Length - 2);  			else if (byteArray [0] == 0xFE && byteArray [1] == 0xFF)  				returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 2' byteArray.Length - 2);  			else  				returnValue = Encoding.Unicode.GetString (byteArray' 0' byteArray.Length);  		} else {  			returnValue = Encoding.Unicode.GetString (byteArray' 0' byteArray.Length);  		}  	}  } else if (textEncoding == EncodingType.UTF16BE) {  	if (byteArray.Length >= 2) {  		// If BOM is part of the string' remove before decoding.  		if (byteArray [0] == 0xFE && byteArray [1] == 0xFF)  			returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 2' byteArray.Length - 2);  		else  			returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 0' byteArray.Length);  	} else {  		returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 0' byteArray.Length);  	}  } else if (textEncoding == EncodingType.UTF8) {  	returnValue = Encoding.UTF8.GetString (byteArray' 0' length);  } else {  	// Most likely bad data  	string msg = string.Format ("Text Encoding '{0}' unknown at position {1}"' textEncoding' stream.Position);  	Trace.WriteLine (msg);  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Utils,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\ID3v2Utils.cs,ReadString,The following statement contains a magic number: if (textEncoding == EncodingType.ISO88591) {  	returnValue = ByteUtils.ISO88591GetString (byteArray);  } else if (textEncoding == EncodingType.Unicode) {  	if (length > 2) {  		if (byteArray.Length >= 2) {  			// If BOM is part of the string' decode as the appropriate Unicode type.  			// If no BOM is present use Little Endian Unicode.  			if (byteArray [0] == 0xFF && byteArray [1] == 0xFE)  				returnValue = Encoding.Unicode.GetString (byteArray' 2' byteArray.Length - 2);  			else if (byteArray [0] == 0xFE && byteArray [1] == 0xFF)  				returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 2' byteArray.Length - 2);  			else  				returnValue = Encoding.Unicode.GetString (byteArray' 0' byteArray.Length);  		} else {  			returnValue = Encoding.Unicode.GetString (byteArray' 0' byteArray.Length);  		}  	}  } else if (textEncoding == EncodingType.UTF16BE) {  	if (byteArray.Length >= 2) {  		// If BOM is part of the string' remove before decoding.  		if (byteArray [0] == 0xFE && byteArray [1] == 0xFF)  			returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 2' byteArray.Length - 2);  		else  			returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 0' byteArray.Length);  	} else {  		returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 0' byteArray.Length);  	}  } else if (textEncoding == EncodingType.UTF8) {  	returnValue = Encoding.UTF8.GetString (byteArray' 0' length);  } else {  	// Most likely bad data  	string msg = string.Format ("Text Encoding '{0}' unknown at position {1}"' textEncoding' stream.Position);  	Trace.WriteLine (msg);  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Utils,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\ID3v2Utils.cs,ReadString,The following statement contains a magic number: if (textEncoding == EncodingType.ISO88591) {  	returnValue = ByteUtils.ISO88591GetString (byteArray);  } else if (textEncoding == EncodingType.Unicode) {  	if (length > 2) {  		if (byteArray.Length >= 2) {  			// If BOM is part of the string' decode as the appropriate Unicode type.  			// If no BOM is present use Little Endian Unicode.  			if (byteArray [0] == 0xFF && byteArray [1] == 0xFE)  				returnValue = Encoding.Unicode.GetString (byteArray' 2' byteArray.Length - 2);  			else if (byteArray [0] == 0xFE && byteArray [1] == 0xFF)  				returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 2' byteArray.Length - 2);  			else  				returnValue = Encoding.Unicode.GetString (byteArray' 0' byteArray.Length);  		} else {  			returnValue = Encoding.Unicode.GetString (byteArray' 0' byteArray.Length);  		}  	}  } else if (textEncoding == EncodingType.UTF16BE) {  	if (byteArray.Length >= 2) {  		// If BOM is part of the string' remove before decoding.  		if (byteArray [0] == 0xFE && byteArray [1] == 0xFF)  			returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 2' byteArray.Length - 2);  		else  			returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 0' byteArray.Length);  	} else {  		returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 0' byteArray.Length);  	}  } else if (textEncoding == EncodingType.UTF8) {  	returnValue = Encoding.UTF8.GetString (byteArray' 0' length);  } else {  	// Most likely bad data  	string msg = string.Format ("Text Encoding '{0}' unknown at position {1}"' textEncoding' stream.Position);  	Trace.WriteLine (msg);  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Utils,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\ID3v2Utils.cs,ReadString,The following statement contains a magic number: if (textEncoding == EncodingType.ISO88591) {  	returnValue = ByteUtils.ISO88591GetString (byteArray);  } else if (textEncoding == EncodingType.Unicode) {  	if (length > 2) {  		if (byteArray.Length >= 2) {  			// If BOM is part of the string' decode as the appropriate Unicode type.  			// If no BOM is present use Little Endian Unicode.  			if (byteArray [0] == 0xFF && byteArray [1] == 0xFE)  				returnValue = Encoding.Unicode.GetString (byteArray' 2' byteArray.Length - 2);  			else if (byteArray [0] == 0xFE && byteArray [1] == 0xFF)  				returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 2' byteArray.Length - 2);  			else  				returnValue = Encoding.Unicode.GetString (byteArray' 0' byteArray.Length);  		} else {  			returnValue = Encoding.Unicode.GetString (byteArray' 0' byteArray.Length);  		}  	}  } else if (textEncoding == EncodingType.UTF16BE) {  	if (byteArray.Length >= 2) {  		// If BOM is part of the string' remove before decoding.  		if (byteArray [0] == 0xFE && byteArray [1] == 0xFF)  			returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 2' byteArray.Length - 2);  		else  			returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 0' byteArray.Length);  	} else {  		returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 0' byteArray.Length);  	}  } else if (textEncoding == EncodingType.UTF8) {  	returnValue = Encoding.UTF8.GetString (byteArray' 0' length);  } else {  	// Most likely bad data  	string msg = string.Format ("Text Encoding '{0}' unknown at position {1}"' textEncoding' stream.Position);  	Trace.WriteLine (msg);  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Utils,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\ID3v2Utils.cs,ReadString,The following statement contains a magic number: if (textEncoding == EncodingType.ISO88591) {  	returnValue = ByteUtils.ISO88591GetString (byteArray);  } else if (textEncoding == EncodingType.Unicode) {  	if (length > 2) {  		if (byteArray.Length >= 2) {  			// If BOM is part of the string' decode as the appropriate Unicode type.  			// If no BOM is present use Little Endian Unicode.  			if (byteArray [0] == 0xFF && byteArray [1] == 0xFE)  				returnValue = Encoding.Unicode.GetString (byteArray' 2' byteArray.Length - 2);  			else if (byteArray [0] == 0xFE && byteArray [1] == 0xFF)  				returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 2' byteArray.Length - 2);  			else  				returnValue = Encoding.Unicode.GetString (byteArray' 0' byteArray.Length);  		} else {  			returnValue = Encoding.Unicode.GetString (byteArray' 0' byteArray.Length);  		}  	}  } else if (textEncoding == EncodingType.UTF16BE) {  	if (byteArray.Length >= 2) {  		// If BOM is part of the string' remove before decoding.  		if (byteArray [0] == 0xFE && byteArray [1] == 0xFF)  			returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 2' byteArray.Length - 2);  		else  			returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 0' byteArray.Length);  	} else {  		returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 0' byteArray.Length);  	}  } else if (textEncoding == EncodingType.UTF8) {  	returnValue = Encoding.UTF8.GetString (byteArray' 0' length);  } else {  	// Most likely bad data  	string msg = string.Format ("Text Encoding '{0}' unknown at position {1}"' textEncoding' stream.Position);  	Trace.WriteLine (msg);  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Utils,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\ID3v2Utils.cs,ReadString,The following statement contains a magic number: if (textEncoding == EncodingType.ISO88591) {  	returnValue = ByteUtils.ISO88591GetString (byteArray);  } else if (textEncoding == EncodingType.Unicode) {  	if (length > 2) {  		if (byteArray.Length >= 2) {  			// If BOM is part of the string' decode as the appropriate Unicode type.  			// If no BOM is present use Little Endian Unicode.  			if (byteArray [0] == 0xFF && byteArray [1] == 0xFE)  				returnValue = Encoding.Unicode.GetString (byteArray' 2' byteArray.Length - 2);  			else if (byteArray [0] == 0xFE && byteArray [1] == 0xFF)  				returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 2' byteArray.Length - 2);  			else  				returnValue = Encoding.Unicode.GetString (byteArray' 0' byteArray.Length);  		} else {  			returnValue = Encoding.Unicode.GetString (byteArray' 0' byteArray.Length);  		}  	}  } else if (textEncoding == EncodingType.UTF16BE) {  	if (byteArray.Length >= 2) {  		// If BOM is part of the string' remove before decoding.  		if (byteArray [0] == 0xFE && byteArray [1] == 0xFF)  			returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 2' byteArray.Length - 2);  		else  			returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 0' byteArray.Length);  	} else {  		returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 0' byteArray.Length);  	}  } else if (textEncoding == EncodingType.UTF8) {  	returnValue = Encoding.UTF8.GetString (byteArray' 0' length);  } else {  	// Most likely bad data  	string msg = string.Format ("Text Encoding '{0}' unknown at position {1}"' textEncoding' stream.Position);  	Trace.WriteLine (msg);  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Utils,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\ID3v2Utils.cs,ReadString,The following statement contains a magic number: if (textEncoding == EncodingType.Unicode) {  	if (length > 2) {  		if (byteArray.Length >= 2) {  			// If BOM is part of the string' decode as the appropriate Unicode type.  			// If no BOM is present use Little Endian Unicode.  			if (byteArray [0] == 0xFF && byteArray [1] == 0xFE)  				returnValue = Encoding.Unicode.GetString (byteArray' 2' byteArray.Length - 2);  			else if (byteArray [0] == 0xFE && byteArray [1] == 0xFF)  				returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 2' byteArray.Length - 2);  			else  				returnValue = Encoding.Unicode.GetString (byteArray' 0' byteArray.Length);  		} else {  			returnValue = Encoding.Unicode.GetString (byteArray' 0' byteArray.Length);  		}  	}  } else if (textEncoding == EncodingType.UTF16BE) {  	if (byteArray.Length >= 2) {  		// If BOM is part of the string' remove before decoding.  		if (byteArray [0] == 0xFE && byteArray [1] == 0xFF)  			returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 2' byteArray.Length - 2);  		else  			returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 0' byteArray.Length);  	} else {  		returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 0' byteArray.Length);  	}  } else if (textEncoding == EncodingType.UTF8) {  	returnValue = Encoding.UTF8.GetString (byteArray' 0' length);  } else {  	// Most likely bad data  	string msg = string.Format ("Text Encoding '{0}' unknown at position {1}"' textEncoding' stream.Position);  	Trace.WriteLine (msg);  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Utils,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\ID3v2Utils.cs,ReadString,The following statement contains a magic number: if (textEncoding == EncodingType.Unicode) {  	if (length > 2) {  		if (byteArray.Length >= 2) {  			// If BOM is part of the string' decode as the appropriate Unicode type.  			// If no BOM is present use Little Endian Unicode.  			if (byteArray [0] == 0xFF && byteArray [1] == 0xFE)  				returnValue = Encoding.Unicode.GetString (byteArray' 2' byteArray.Length - 2);  			else if (byteArray [0] == 0xFE && byteArray [1] == 0xFF)  				returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 2' byteArray.Length - 2);  			else  				returnValue = Encoding.Unicode.GetString (byteArray' 0' byteArray.Length);  		} else {  			returnValue = Encoding.Unicode.GetString (byteArray' 0' byteArray.Length);  		}  	}  } else if (textEncoding == EncodingType.UTF16BE) {  	if (byteArray.Length >= 2) {  		// If BOM is part of the string' remove before decoding.  		if (byteArray [0] == 0xFE && byteArray [1] == 0xFF)  			returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 2' byteArray.Length - 2);  		else  			returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 0' byteArray.Length);  	} else {  		returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 0' byteArray.Length);  	}  } else if (textEncoding == EncodingType.UTF8) {  	returnValue = Encoding.UTF8.GetString (byteArray' 0' length);  } else {  	// Most likely bad data  	string msg = string.Format ("Text Encoding '{0}' unknown at position {1}"' textEncoding' stream.Position);  	Trace.WriteLine (msg);  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Utils,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\ID3v2Utils.cs,ReadString,The following statement contains a magic number: if (textEncoding == EncodingType.Unicode) {  	if (length > 2) {  		if (byteArray.Length >= 2) {  			// If BOM is part of the string' decode as the appropriate Unicode type.  			// If no BOM is present use Little Endian Unicode.  			if (byteArray [0] == 0xFF && byteArray [1] == 0xFE)  				returnValue = Encoding.Unicode.GetString (byteArray' 2' byteArray.Length - 2);  			else if (byteArray [0] == 0xFE && byteArray [1] == 0xFF)  				returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 2' byteArray.Length - 2);  			else  				returnValue = Encoding.Unicode.GetString (byteArray' 0' byteArray.Length);  		} else {  			returnValue = Encoding.Unicode.GetString (byteArray' 0' byteArray.Length);  		}  	}  } else if (textEncoding == EncodingType.UTF16BE) {  	if (byteArray.Length >= 2) {  		// If BOM is part of the string' remove before decoding.  		if (byteArray [0] == 0xFE && byteArray [1] == 0xFF)  			returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 2' byteArray.Length - 2);  		else  			returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 0' byteArray.Length);  	} else {  		returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 0' byteArray.Length);  	}  } else if (textEncoding == EncodingType.UTF8) {  	returnValue = Encoding.UTF8.GetString (byteArray' 0' length);  } else {  	// Most likely bad data  	string msg = string.Format ("Text Encoding '{0}' unknown at position {1}"' textEncoding' stream.Position);  	Trace.WriteLine (msg);  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Utils,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\ID3v2Utils.cs,ReadString,The following statement contains a magic number: if (textEncoding == EncodingType.Unicode) {  	if (length > 2) {  		if (byteArray.Length >= 2) {  			// If BOM is part of the string' decode as the appropriate Unicode type.  			// If no BOM is present use Little Endian Unicode.  			if (byteArray [0] == 0xFF && byteArray [1] == 0xFE)  				returnValue = Encoding.Unicode.GetString (byteArray' 2' byteArray.Length - 2);  			else if (byteArray [0] == 0xFE && byteArray [1] == 0xFF)  				returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 2' byteArray.Length - 2);  			else  				returnValue = Encoding.Unicode.GetString (byteArray' 0' byteArray.Length);  		} else {  			returnValue = Encoding.Unicode.GetString (byteArray' 0' byteArray.Length);  		}  	}  } else if (textEncoding == EncodingType.UTF16BE) {  	if (byteArray.Length >= 2) {  		// If BOM is part of the string' remove before decoding.  		if (byteArray [0] == 0xFE && byteArray [1] == 0xFF)  			returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 2' byteArray.Length - 2);  		else  			returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 0' byteArray.Length);  	} else {  		returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 0' byteArray.Length);  	}  } else if (textEncoding == EncodingType.UTF8) {  	returnValue = Encoding.UTF8.GetString (byteArray' 0' length);  } else {  	// Most likely bad data  	string msg = string.Format ("Text Encoding '{0}' unknown at position {1}"' textEncoding' stream.Position);  	Trace.WriteLine (msg);  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Utils,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\ID3v2Utils.cs,ReadString,The following statement contains a magic number: if (textEncoding == EncodingType.Unicode) {  	if (length > 2) {  		if (byteArray.Length >= 2) {  			// If BOM is part of the string' decode as the appropriate Unicode type.  			// If no BOM is present use Little Endian Unicode.  			if (byteArray [0] == 0xFF && byteArray [1] == 0xFE)  				returnValue = Encoding.Unicode.GetString (byteArray' 2' byteArray.Length - 2);  			else if (byteArray [0] == 0xFE && byteArray [1] == 0xFF)  				returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 2' byteArray.Length - 2);  			else  				returnValue = Encoding.Unicode.GetString (byteArray' 0' byteArray.Length);  		} else {  			returnValue = Encoding.Unicode.GetString (byteArray' 0' byteArray.Length);  		}  	}  } else if (textEncoding == EncodingType.UTF16BE) {  	if (byteArray.Length >= 2) {  		// If BOM is part of the string' remove before decoding.  		if (byteArray [0] == 0xFE && byteArray [1] == 0xFF)  			returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 2' byteArray.Length - 2);  		else  			returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 0' byteArray.Length);  	} else {  		returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 0' byteArray.Length);  	}  } else if (textEncoding == EncodingType.UTF8) {  	returnValue = Encoding.UTF8.GetString (byteArray' 0' length);  } else {  	// Most likely bad data  	string msg = string.Format ("Text Encoding '{0}' unknown at position {1}"' textEncoding' stream.Position);  	Trace.WriteLine (msg);  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Utils,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\ID3v2Utils.cs,ReadString,The following statement contains a magic number: if (textEncoding == EncodingType.Unicode) {  	if (length > 2) {  		if (byteArray.Length >= 2) {  			// If BOM is part of the string' decode as the appropriate Unicode type.  			// If no BOM is present use Little Endian Unicode.  			if (byteArray [0] == 0xFF && byteArray [1] == 0xFE)  				returnValue = Encoding.Unicode.GetString (byteArray' 2' byteArray.Length - 2);  			else if (byteArray [0] == 0xFE && byteArray [1] == 0xFF)  				returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 2' byteArray.Length - 2);  			else  				returnValue = Encoding.Unicode.GetString (byteArray' 0' byteArray.Length);  		} else {  			returnValue = Encoding.Unicode.GetString (byteArray' 0' byteArray.Length);  		}  	}  } else if (textEncoding == EncodingType.UTF16BE) {  	if (byteArray.Length >= 2) {  		// If BOM is part of the string' remove before decoding.  		if (byteArray [0] == 0xFE && byteArray [1] == 0xFF)  			returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 2' byteArray.Length - 2);  		else  			returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 0' byteArray.Length);  	} else {  		returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 0' byteArray.Length);  	}  } else if (textEncoding == EncodingType.UTF8) {  	returnValue = Encoding.UTF8.GetString (byteArray' 0' length);  } else {  	// Most likely bad data  	string msg = string.Format ("Text Encoding '{0}' unknown at position {1}"' textEncoding' stream.Position);  	Trace.WriteLine (msg);  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Utils,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\ID3v2Utils.cs,ReadString,The following statement contains a magic number: if (textEncoding == EncodingType.Unicode) {  	if (length > 2) {  		if (byteArray.Length >= 2) {  			// If BOM is part of the string' decode as the appropriate Unicode type.  			// If no BOM is present use Little Endian Unicode.  			if (byteArray [0] == 0xFF && byteArray [1] == 0xFE)  				returnValue = Encoding.Unicode.GetString (byteArray' 2' byteArray.Length - 2);  			else if (byteArray [0] == 0xFE && byteArray [1] == 0xFF)  				returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 2' byteArray.Length - 2);  			else  				returnValue = Encoding.Unicode.GetString (byteArray' 0' byteArray.Length);  		} else {  			returnValue = Encoding.Unicode.GetString (byteArray' 0' byteArray.Length);  		}  	}  } else if (textEncoding == EncodingType.UTF16BE) {  	if (byteArray.Length >= 2) {  		// If BOM is part of the string' remove before decoding.  		if (byteArray [0] == 0xFE && byteArray [1] == 0xFF)  			returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 2' byteArray.Length - 2);  		else  			returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 0' byteArray.Length);  	} else {  		returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 0' byteArray.Length);  	}  } else if (textEncoding == EncodingType.UTF8) {  	returnValue = Encoding.UTF8.GetString (byteArray' 0' length);  } else {  	// Most likely bad data  	string msg = string.Format ("Text Encoding '{0}' unknown at position {1}"' textEncoding' stream.Position);  	Trace.WriteLine (msg);  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Utils,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\ID3v2Utils.cs,ReadString,The following statement contains a magic number: if (textEncoding == EncodingType.Unicode) {  	if (length > 2) {  		if (byteArray.Length >= 2) {  			// If BOM is part of the string' decode as the appropriate Unicode type.  			// If no BOM is present use Little Endian Unicode.  			if (byteArray [0] == 0xFF && byteArray [1] == 0xFE)  				returnValue = Encoding.Unicode.GetString (byteArray' 2' byteArray.Length - 2);  			else if (byteArray [0] == 0xFE && byteArray [1] == 0xFF)  				returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 2' byteArray.Length - 2);  			else  				returnValue = Encoding.Unicode.GetString (byteArray' 0' byteArray.Length);  		} else {  			returnValue = Encoding.Unicode.GetString (byteArray' 0' byteArray.Length);  		}  	}  } else if (textEncoding == EncodingType.UTF16BE) {  	if (byteArray.Length >= 2) {  		// If BOM is part of the string' remove before decoding.  		if (byteArray [0] == 0xFE && byteArray [1] == 0xFF)  			returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 2' byteArray.Length - 2);  		else  			returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 0' byteArray.Length);  	} else {  		returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 0' byteArray.Length);  	}  } else if (textEncoding == EncodingType.UTF8) {  	returnValue = Encoding.UTF8.GetString (byteArray' 0' length);  } else {  	// Most likely bad data  	string msg = string.Format ("Text Encoding '{0}' unknown at position {1}"' textEncoding' stream.Position);  	Trace.WriteLine (msg);  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Utils,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\ID3v2Utils.cs,ReadString,The following statement contains a magic number: if (textEncoding == EncodingType.Unicode) {  	if (length > 2) {  		if (byteArray.Length >= 2) {  			// If BOM is part of the string' decode as the appropriate Unicode type.  			// If no BOM is present use Little Endian Unicode.  			if (byteArray [0] == 0xFF && byteArray [1] == 0xFE)  				returnValue = Encoding.Unicode.GetString (byteArray' 2' byteArray.Length - 2);  			else if (byteArray [0] == 0xFE && byteArray [1] == 0xFF)  				returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 2' byteArray.Length - 2);  			else  				returnValue = Encoding.Unicode.GetString (byteArray' 0' byteArray.Length);  		} else {  			returnValue = Encoding.Unicode.GetString (byteArray' 0' byteArray.Length);  		}  	}  } else if (textEncoding == EncodingType.UTF16BE) {  	if (byteArray.Length >= 2) {  		// If BOM is part of the string' remove before decoding.  		if (byteArray [0] == 0xFE && byteArray [1] == 0xFF)  			returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 2' byteArray.Length - 2);  		else  			returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 0' byteArray.Length);  	} else {  		returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 0' byteArray.Length);  	}  } else if (textEncoding == EncodingType.UTF8) {  	returnValue = Encoding.UTF8.GetString (byteArray' 0' length);  } else {  	// Most likely bad data  	string msg = string.Format ("Text Encoding '{0}' unknown at position {1}"' textEncoding' stream.Position);  	Trace.WriteLine (msg);  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Utils,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\ID3v2Utils.cs,ReadString,The following statement contains a magic number: if (length > 2) {  	if (byteArray.Length >= 2) {  		// If BOM is part of the string' decode as the appropriate Unicode type.  		// If no BOM is present use Little Endian Unicode.  		if (byteArray [0] == 0xFF && byteArray [1] == 0xFE)  			returnValue = Encoding.Unicode.GetString (byteArray' 2' byteArray.Length - 2);  		else if (byteArray [0] == 0xFE && byteArray [1] == 0xFF)  			returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 2' byteArray.Length - 2);  		else  			returnValue = Encoding.Unicode.GetString (byteArray' 0' byteArray.Length);  	} else {  		returnValue = Encoding.Unicode.GetString (byteArray' 0' byteArray.Length);  	}  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Utils,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\ID3v2Utils.cs,ReadString,The following statement contains a magic number: if (length > 2) {  	if (byteArray.Length >= 2) {  		// If BOM is part of the string' decode as the appropriate Unicode type.  		// If no BOM is present use Little Endian Unicode.  		if (byteArray [0] == 0xFF && byteArray [1] == 0xFE)  			returnValue = Encoding.Unicode.GetString (byteArray' 2' byteArray.Length - 2);  		else if (byteArray [0] == 0xFE && byteArray [1] == 0xFF)  			returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 2' byteArray.Length - 2);  		else  			returnValue = Encoding.Unicode.GetString (byteArray' 0' byteArray.Length);  	} else {  		returnValue = Encoding.Unicode.GetString (byteArray' 0' byteArray.Length);  	}  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Utils,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\ID3v2Utils.cs,ReadString,The following statement contains a magic number: if (length > 2) {  	if (byteArray.Length >= 2) {  		// If BOM is part of the string' decode as the appropriate Unicode type.  		// If no BOM is present use Little Endian Unicode.  		if (byteArray [0] == 0xFF && byteArray [1] == 0xFE)  			returnValue = Encoding.Unicode.GetString (byteArray' 2' byteArray.Length - 2);  		else if (byteArray [0] == 0xFE && byteArray [1] == 0xFF)  			returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 2' byteArray.Length - 2);  		else  			returnValue = Encoding.Unicode.GetString (byteArray' 0' byteArray.Length);  	} else {  		returnValue = Encoding.Unicode.GetString (byteArray' 0' byteArray.Length);  	}  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Utils,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\ID3v2Utils.cs,ReadString,The following statement contains a magic number: if (length > 2) {  	if (byteArray.Length >= 2) {  		// If BOM is part of the string' decode as the appropriate Unicode type.  		// If no BOM is present use Little Endian Unicode.  		if (byteArray [0] == 0xFF && byteArray [1] == 0xFE)  			returnValue = Encoding.Unicode.GetString (byteArray' 2' byteArray.Length - 2);  		else if (byteArray [0] == 0xFE && byteArray [1] == 0xFF)  			returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 2' byteArray.Length - 2);  		else  			returnValue = Encoding.Unicode.GetString (byteArray' 0' byteArray.Length);  	} else {  		returnValue = Encoding.Unicode.GetString (byteArray' 0' byteArray.Length);  	}  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Utils,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\ID3v2Utils.cs,ReadString,The following statement contains a magic number: if (length > 2) {  	if (byteArray.Length >= 2) {  		// If BOM is part of the string' decode as the appropriate Unicode type.  		// If no BOM is present use Little Endian Unicode.  		if (byteArray [0] == 0xFF && byteArray [1] == 0xFE)  			returnValue = Encoding.Unicode.GetString (byteArray' 2' byteArray.Length - 2);  		else if (byteArray [0] == 0xFE && byteArray [1] == 0xFF)  			returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 2' byteArray.Length - 2);  		else  			returnValue = Encoding.Unicode.GetString (byteArray' 0' byteArray.Length);  	} else {  		returnValue = Encoding.Unicode.GetString (byteArray' 0' byteArray.Length);  	}  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Utils,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\ID3v2Utils.cs,ReadString,The following statement contains a magic number: if (length > 2) {  	if (byteArray.Length >= 2) {  		// If BOM is part of the string' decode as the appropriate Unicode type.  		// If no BOM is present use Little Endian Unicode.  		if (byteArray [0] == 0xFF && byteArray [1] == 0xFE)  			returnValue = Encoding.Unicode.GetString (byteArray' 2' byteArray.Length - 2);  		else if (byteArray [0] == 0xFE && byteArray [1] == 0xFF)  			returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 2' byteArray.Length - 2);  		else  			returnValue = Encoding.Unicode.GetString (byteArray' 0' byteArray.Length);  	} else {  		returnValue = Encoding.Unicode.GetString (byteArray' 0' byteArray.Length);  	}  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Utils,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\ID3v2Utils.cs,ReadString,The following statement contains a magic number: if (byteArray.Length >= 2) {  	// If BOM is part of the string' decode as the appropriate Unicode type.  	// If no BOM is present use Little Endian Unicode.  	if (byteArray [0] == 0xFF && byteArray [1] == 0xFE)  		returnValue = Encoding.Unicode.GetString (byteArray' 2' byteArray.Length - 2);  	else if (byteArray [0] == 0xFE && byteArray [1] == 0xFF)  		returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 2' byteArray.Length - 2);  	else  		returnValue = Encoding.Unicode.GetString (byteArray' 0' byteArray.Length);  } else {  	returnValue = Encoding.Unicode.GetString (byteArray' 0' byteArray.Length);  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Utils,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\ID3v2Utils.cs,ReadString,The following statement contains a magic number: if (byteArray.Length >= 2) {  	// If BOM is part of the string' decode as the appropriate Unicode type.  	// If no BOM is present use Little Endian Unicode.  	if (byteArray [0] == 0xFF && byteArray [1] == 0xFE)  		returnValue = Encoding.Unicode.GetString (byteArray' 2' byteArray.Length - 2);  	else if (byteArray [0] == 0xFE && byteArray [1] == 0xFF)  		returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 2' byteArray.Length - 2);  	else  		returnValue = Encoding.Unicode.GetString (byteArray' 0' byteArray.Length);  } else {  	returnValue = Encoding.Unicode.GetString (byteArray' 0' byteArray.Length);  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Utils,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\ID3v2Utils.cs,ReadString,The following statement contains a magic number: if (byteArray.Length >= 2) {  	// If BOM is part of the string' decode as the appropriate Unicode type.  	// If no BOM is present use Little Endian Unicode.  	if (byteArray [0] == 0xFF && byteArray [1] == 0xFE)  		returnValue = Encoding.Unicode.GetString (byteArray' 2' byteArray.Length - 2);  	else if (byteArray [0] == 0xFE && byteArray [1] == 0xFF)  		returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 2' byteArray.Length - 2);  	else  		returnValue = Encoding.Unicode.GetString (byteArray' 0' byteArray.Length);  } else {  	returnValue = Encoding.Unicode.GetString (byteArray' 0' byteArray.Length);  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Utils,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\ID3v2Utils.cs,ReadString,The following statement contains a magic number: if (byteArray.Length >= 2) {  	// If BOM is part of the string' decode as the appropriate Unicode type.  	// If no BOM is present use Little Endian Unicode.  	if (byteArray [0] == 0xFF && byteArray [1] == 0xFE)  		returnValue = Encoding.Unicode.GetString (byteArray' 2' byteArray.Length - 2);  	else if (byteArray [0] == 0xFE && byteArray [1] == 0xFF)  		returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 2' byteArray.Length - 2);  	else  		returnValue = Encoding.Unicode.GetString (byteArray' 0' byteArray.Length);  } else {  	returnValue = Encoding.Unicode.GetString (byteArray' 0' byteArray.Length);  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Utils,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\ID3v2Utils.cs,ReadString,The following statement contains a magic number: if (byteArray.Length >= 2) {  	// If BOM is part of the string' decode as the appropriate Unicode type.  	// If no BOM is present use Little Endian Unicode.  	if (byteArray [0] == 0xFF && byteArray [1] == 0xFE)  		returnValue = Encoding.Unicode.GetString (byteArray' 2' byteArray.Length - 2);  	else if (byteArray [0] == 0xFE && byteArray [1] == 0xFF)  		returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 2' byteArray.Length - 2);  	else  		returnValue = Encoding.Unicode.GetString (byteArray' 0' byteArray.Length);  } else {  	returnValue = Encoding.Unicode.GetString (byteArray' 0' byteArray.Length);  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Utils,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\ID3v2Utils.cs,ReadString,The following statement contains a magic number: if (byteArray [0] == 0xFF && byteArray [1] == 0xFE)  	returnValue = Encoding.Unicode.GetString (byteArray' 2' byteArray.Length - 2);  else if (byteArray [0] == 0xFE && byteArray [1] == 0xFF)  	returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 2' byteArray.Length - 2);  else  	returnValue = Encoding.Unicode.GetString (byteArray' 0' byteArray.Length);  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Utils,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\ID3v2Utils.cs,ReadString,The following statement contains a magic number: if (byteArray [0] == 0xFF && byteArray [1] == 0xFE)  	returnValue = Encoding.Unicode.GetString (byteArray' 2' byteArray.Length - 2);  else if (byteArray [0] == 0xFE && byteArray [1] == 0xFF)  	returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 2' byteArray.Length - 2);  else  	returnValue = Encoding.Unicode.GetString (byteArray' 0' byteArray.Length);  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Utils,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\ID3v2Utils.cs,ReadString,The following statement contains a magic number: if (byteArray [0] == 0xFF && byteArray [1] == 0xFE)  	returnValue = Encoding.Unicode.GetString (byteArray' 2' byteArray.Length - 2);  else if (byteArray [0] == 0xFE && byteArray [1] == 0xFF)  	returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 2' byteArray.Length - 2);  else  	returnValue = Encoding.Unicode.GetString (byteArray' 0' byteArray.Length);  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Utils,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\ID3v2Utils.cs,ReadString,The following statement contains a magic number: if (byteArray [0] == 0xFF && byteArray [1] == 0xFE)  	returnValue = Encoding.Unicode.GetString (byteArray' 2' byteArray.Length - 2);  else if (byteArray [0] == 0xFE && byteArray [1] == 0xFF)  	returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 2' byteArray.Length - 2);  else  	returnValue = Encoding.Unicode.GetString (byteArray' 0' byteArray.Length);  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Utils,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\ID3v2Utils.cs,ReadString,The following statement contains a magic number: returnValue = Encoding.Unicode.GetString (byteArray' 2' byteArray.Length - 2);  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Utils,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\ID3v2Utils.cs,ReadString,The following statement contains a magic number: returnValue = Encoding.Unicode.GetString (byteArray' 2' byteArray.Length - 2);  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Utils,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\ID3v2Utils.cs,ReadString,The following statement contains a magic number: if (byteArray [0] == 0xFE && byteArray [1] == 0xFF)  	returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 2' byteArray.Length - 2);  else  	returnValue = Encoding.Unicode.GetString (byteArray' 0' byteArray.Length);  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Utils,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\ID3v2Utils.cs,ReadString,The following statement contains a magic number: if (byteArray [0] == 0xFE && byteArray [1] == 0xFF)  	returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 2' byteArray.Length - 2);  else  	returnValue = Encoding.Unicode.GetString (byteArray' 0' byteArray.Length);  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Utils,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\ID3v2Utils.cs,ReadString,The following statement contains a magic number: returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 2' byteArray.Length - 2);  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Utils,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\ID3v2Utils.cs,ReadString,The following statement contains a magic number: returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 2' byteArray.Length - 2);  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Utils,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\ID3v2Utils.cs,ReadString,The following statement contains a magic number: if (textEncoding == EncodingType.UTF16BE) {  	if (byteArray.Length >= 2) {  		// If BOM is part of the string' remove before decoding.  		if (byteArray [0] == 0xFE && byteArray [1] == 0xFF)  			returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 2' byteArray.Length - 2);  		else  			returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 0' byteArray.Length);  	} else {  		returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 0' byteArray.Length);  	}  } else if (textEncoding == EncodingType.UTF8) {  	returnValue = Encoding.UTF8.GetString (byteArray' 0' length);  } else {  	// Most likely bad data  	string msg = string.Format ("Text Encoding '{0}' unknown at position {1}"' textEncoding' stream.Position);  	Trace.WriteLine (msg);  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Utils,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\ID3v2Utils.cs,ReadString,The following statement contains a magic number: if (textEncoding == EncodingType.UTF16BE) {  	if (byteArray.Length >= 2) {  		// If BOM is part of the string' remove before decoding.  		if (byteArray [0] == 0xFE && byteArray [1] == 0xFF)  			returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 2' byteArray.Length - 2);  		else  			returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 0' byteArray.Length);  	} else {  		returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 0' byteArray.Length);  	}  } else if (textEncoding == EncodingType.UTF8) {  	returnValue = Encoding.UTF8.GetString (byteArray' 0' length);  } else {  	// Most likely bad data  	string msg = string.Format ("Text Encoding '{0}' unknown at position {1}"' textEncoding' stream.Position);  	Trace.WriteLine (msg);  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Utils,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\ID3v2Utils.cs,ReadString,The following statement contains a magic number: if (textEncoding == EncodingType.UTF16BE) {  	if (byteArray.Length >= 2) {  		// If BOM is part of the string' remove before decoding.  		if (byteArray [0] == 0xFE && byteArray [1] == 0xFF)  			returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 2' byteArray.Length - 2);  		else  			returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 0' byteArray.Length);  	} else {  		returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 0' byteArray.Length);  	}  } else if (textEncoding == EncodingType.UTF8) {  	returnValue = Encoding.UTF8.GetString (byteArray' 0' length);  } else {  	// Most likely bad data  	string msg = string.Format ("Text Encoding '{0}' unknown at position {1}"' textEncoding' stream.Position);  	Trace.WriteLine (msg);  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Utils,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\ID3v2Utils.cs,ReadString,The following statement contains a magic number: if (byteArray.Length >= 2) {  	// If BOM is part of the string' remove before decoding.  	if (byteArray [0] == 0xFE && byteArray [1] == 0xFF)  		returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 2' byteArray.Length - 2);  	else  		returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 0' byteArray.Length);  } else {  	returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 0' byteArray.Length);  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Utils,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\ID3v2Utils.cs,ReadString,The following statement contains a magic number: if (byteArray.Length >= 2) {  	// If BOM is part of the string' remove before decoding.  	if (byteArray [0] == 0xFE && byteArray [1] == 0xFF)  		returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 2' byteArray.Length - 2);  	else  		returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 0' byteArray.Length);  } else {  	returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 0' byteArray.Length);  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Utils,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\ID3v2Utils.cs,ReadString,The following statement contains a magic number: if (byteArray.Length >= 2) {  	// If BOM is part of the string' remove before decoding.  	if (byteArray [0] == 0xFE && byteArray [1] == 0xFF)  		returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 2' byteArray.Length - 2);  	else  		returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 0' byteArray.Length);  } else {  	returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 0' byteArray.Length);  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Utils,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\ID3v2Utils.cs,ReadString,The following statement contains a magic number: if (byteArray [0] == 0xFE && byteArray [1] == 0xFF)  	returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 2' byteArray.Length - 2);  else  	returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 0' byteArray.Length);  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Utils,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\ID3v2Utils.cs,ReadString,The following statement contains a magic number: if (byteArray [0] == 0xFE && byteArray [1] == 0xFF)  	returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 2' byteArray.Length - 2);  else  	returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 0' byteArray.Length);  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Utils,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\ID3v2Utils.cs,ReadString,The following statement contains a magic number: returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 2' byteArray.Length - 2);  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Utils,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\ID3v2Utils.cs,ReadString,The following statement contains a magic number: returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 2' byteArray.Length - 2);  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Utils,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\ID3v2Utils.cs,ReadString,The following statement contains a magic number: if (textEncoding == EncodingType.ISO88591) {  	byte readByte = stream.Read1 ();  	while (readByte != 0) {  		byteList.Add (readByte);  		readByte = stream.Read1 ();  	}  	returnValue = ByteUtils.ISO88591GetString (byteList.ToArray ());  } else if (textEncoding == EncodingType.Unicode) {  	byte byte1;  	byte byte2;  	do {  		byte1 = stream.Read1 ();  		byteList.Add (byte1);  		byte2 = stream.Read1 ();  		byteList.Add (byte2);  	} while (byte1 != 0 || byte2 != 0);  	byte[] byteArray = byteList.ToArray ();  	if (byteArray.Length >= 2) {  		// If BOM is part of the string' decode as the appropriate Unicode type.  		// If no BOM is present use Little Endian Unicode.  		if (byteArray [0] == 0xFF && byteArray [1] == 0xFE)  			returnValue = Encoding.Unicode.GetString (byteArray' 2' byteArray.Length - 2);  		else if (byteArray [0] == 0xFE && byteArray [1] == 0xFF)  			returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 2' byteArray.Length - 2);  		else  			returnValue = Encoding.Unicode.GetString (byteArray' 0' byteArray.Length);  	} else {  		returnValue = Encoding.Unicode.GetString (byteArray' 0' byteArray.Length);  	}  } else if (textEncoding == EncodingType.UTF16BE) {  	byte byte1;  	byte byte2;  	do {  		byte1 = stream.Read1 ();  		byteList.Add (byte1);  		byte2 = stream.Read1 ();  		byteList.Add (byte2);  	} while (byte1 != 0 || byte2 != 0);  	byte[] byteArray = byteList.ToArray ();  	if (byteArray.Length >= 2) {  		// If BOM is part of the string' remove before decoding.  		if (byteArray [0] == 0xFE && byteArray [1] == 0xFF)  			returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 2' byteArray.Length - 2);  		else  			returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 0' byteArray.Length);  	} else {  		returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 0' byteArray.Length);  	}  } else if (textEncoding == EncodingType.UTF8) {  	byte readByte = stream.Read1 ();  	while (readByte != 0) {  		byteList.Add (readByte);  		readByte = stream.Read1 ();  	}  	returnValue = Encoding.UTF8.GetString (byteList.ToArray ());  } else {  	// Most likely bad data  	string msg = string.Format ("Text Encoding '{0}' unknown at position {1}"' textEncoding' stream.Position);  	Trace.WriteLine (msg);  	return "";  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Utils,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\ID3v2Utils.cs,ReadString,The following statement contains a magic number: if (textEncoding == EncodingType.ISO88591) {  	byte readByte = stream.Read1 ();  	while (readByte != 0) {  		byteList.Add (readByte);  		readByte = stream.Read1 ();  	}  	returnValue = ByteUtils.ISO88591GetString (byteList.ToArray ());  } else if (textEncoding == EncodingType.Unicode) {  	byte byte1;  	byte byte2;  	do {  		byte1 = stream.Read1 ();  		byteList.Add (byte1);  		byte2 = stream.Read1 ();  		byteList.Add (byte2);  	} while (byte1 != 0 || byte2 != 0);  	byte[] byteArray = byteList.ToArray ();  	if (byteArray.Length >= 2) {  		// If BOM is part of the string' decode as the appropriate Unicode type.  		// If no BOM is present use Little Endian Unicode.  		if (byteArray [0] == 0xFF && byteArray [1] == 0xFE)  			returnValue = Encoding.Unicode.GetString (byteArray' 2' byteArray.Length - 2);  		else if (byteArray [0] == 0xFE && byteArray [1] == 0xFF)  			returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 2' byteArray.Length - 2);  		else  			returnValue = Encoding.Unicode.GetString (byteArray' 0' byteArray.Length);  	} else {  		returnValue = Encoding.Unicode.GetString (byteArray' 0' byteArray.Length);  	}  } else if (textEncoding == EncodingType.UTF16BE) {  	byte byte1;  	byte byte2;  	do {  		byte1 = stream.Read1 ();  		byteList.Add (byte1);  		byte2 = stream.Read1 ();  		byteList.Add (byte2);  	} while (byte1 != 0 || byte2 != 0);  	byte[] byteArray = byteList.ToArray ();  	if (byteArray.Length >= 2) {  		// If BOM is part of the string' remove before decoding.  		if (byteArray [0] == 0xFE && byteArray [1] == 0xFF)  			returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 2' byteArray.Length - 2);  		else  			returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 0' byteArray.Length);  	} else {  		returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 0' byteArray.Length);  	}  } else if (textEncoding == EncodingType.UTF8) {  	byte readByte = stream.Read1 ();  	while (readByte != 0) {  		byteList.Add (readByte);  		readByte = stream.Read1 ();  	}  	returnValue = Encoding.UTF8.GetString (byteList.ToArray ());  } else {  	// Most likely bad data  	string msg = string.Format ("Text Encoding '{0}' unknown at position {1}"' textEncoding' stream.Position);  	Trace.WriteLine (msg);  	return "";  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Utils,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\ID3v2Utils.cs,ReadString,The following statement contains a magic number: if (textEncoding == EncodingType.ISO88591) {  	byte readByte = stream.Read1 ();  	while (readByte != 0) {  		byteList.Add (readByte);  		readByte = stream.Read1 ();  	}  	returnValue = ByteUtils.ISO88591GetString (byteList.ToArray ());  } else if (textEncoding == EncodingType.Unicode) {  	byte byte1;  	byte byte2;  	do {  		byte1 = stream.Read1 ();  		byteList.Add (byte1);  		byte2 = stream.Read1 ();  		byteList.Add (byte2);  	} while (byte1 != 0 || byte2 != 0);  	byte[] byteArray = byteList.ToArray ();  	if (byteArray.Length >= 2) {  		// If BOM is part of the string' decode as the appropriate Unicode type.  		// If no BOM is present use Little Endian Unicode.  		if (byteArray [0] == 0xFF && byteArray [1] == 0xFE)  			returnValue = Encoding.Unicode.GetString (byteArray' 2' byteArray.Length - 2);  		else if (byteArray [0] == 0xFE && byteArray [1] == 0xFF)  			returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 2' byteArray.Length - 2);  		else  			returnValue = Encoding.Unicode.GetString (byteArray' 0' byteArray.Length);  	} else {  		returnValue = Encoding.Unicode.GetString (byteArray' 0' byteArray.Length);  	}  } else if (textEncoding == EncodingType.UTF16BE) {  	byte byte1;  	byte byte2;  	do {  		byte1 = stream.Read1 ();  		byteList.Add (byte1);  		byte2 = stream.Read1 ();  		byteList.Add (byte2);  	} while (byte1 != 0 || byte2 != 0);  	byte[] byteArray = byteList.ToArray ();  	if (byteArray.Length >= 2) {  		// If BOM is part of the string' remove before decoding.  		if (byteArray [0] == 0xFE && byteArray [1] == 0xFF)  			returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 2' byteArray.Length - 2);  		else  			returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 0' byteArray.Length);  	} else {  		returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 0' byteArray.Length);  	}  } else if (textEncoding == EncodingType.UTF8) {  	byte readByte = stream.Read1 ();  	while (readByte != 0) {  		byteList.Add (readByte);  		readByte = stream.Read1 ();  	}  	returnValue = Encoding.UTF8.GetString (byteList.ToArray ());  } else {  	// Most likely bad data  	string msg = string.Format ("Text Encoding '{0}' unknown at position {1}"' textEncoding' stream.Position);  	Trace.WriteLine (msg);  	return "";  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Utils,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\ID3v2Utils.cs,ReadString,The following statement contains a magic number: if (textEncoding == EncodingType.ISO88591) {  	byte readByte = stream.Read1 ();  	while (readByte != 0) {  		byteList.Add (readByte);  		readByte = stream.Read1 ();  	}  	returnValue = ByteUtils.ISO88591GetString (byteList.ToArray ());  } else if (textEncoding == EncodingType.Unicode) {  	byte byte1;  	byte byte2;  	do {  		byte1 = stream.Read1 ();  		byteList.Add (byte1);  		byte2 = stream.Read1 ();  		byteList.Add (byte2);  	} while (byte1 != 0 || byte2 != 0);  	byte[] byteArray = byteList.ToArray ();  	if (byteArray.Length >= 2) {  		// If BOM is part of the string' decode as the appropriate Unicode type.  		// If no BOM is present use Little Endian Unicode.  		if (byteArray [0] == 0xFF && byteArray [1] == 0xFE)  			returnValue = Encoding.Unicode.GetString (byteArray' 2' byteArray.Length - 2);  		else if (byteArray [0] == 0xFE && byteArray [1] == 0xFF)  			returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 2' byteArray.Length - 2);  		else  			returnValue = Encoding.Unicode.GetString (byteArray' 0' byteArray.Length);  	} else {  		returnValue = Encoding.Unicode.GetString (byteArray' 0' byteArray.Length);  	}  } else if (textEncoding == EncodingType.UTF16BE) {  	byte byte1;  	byte byte2;  	do {  		byte1 = stream.Read1 ();  		byteList.Add (byte1);  		byte2 = stream.Read1 ();  		byteList.Add (byte2);  	} while (byte1 != 0 || byte2 != 0);  	byte[] byteArray = byteList.ToArray ();  	if (byteArray.Length >= 2) {  		// If BOM is part of the string' remove before decoding.  		if (byteArray [0] == 0xFE && byteArray [1] == 0xFF)  			returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 2' byteArray.Length - 2);  		else  			returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 0' byteArray.Length);  	} else {  		returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 0' byteArray.Length);  	}  } else if (textEncoding == EncodingType.UTF8) {  	byte readByte = stream.Read1 ();  	while (readByte != 0) {  		byteList.Add (readByte);  		readByte = stream.Read1 ();  	}  	returnValue = Encoding.UTF8.GetString (byteList.ToArray ());  } else {  	// Most likely bad data  	string msg = string.Format ("Text Encoding '{0}' unknown at position {1}"' textEncoding' stream.Position);  	Trace.WriteLine (msg);  	return "";  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Utils,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\ID3v2Utils.cs,ReadString,The following statement contains a magic number: if (textEncoding == EncodingType.ISO88591) {  	byte readByte = stream.Read1 ();  	while (readByte != 0) {  		byteList.Add (readByte);  		readByte = stream.Read1 ();  	}  	returnValue = ByteUtils.ISO88591GetString (byteList.ToArray ());  } else if (textEncoding == EncodingType.Unicode) {  	byte byte1;  	byte byte2;  	do {  		byte1 = stream.Read1 ();  		byteList.Add (byte1);  		byte2 = stream.Read1 ();  		byteList.Add (byte2);  	} while (byte1 != 0 || byte2 != 0);  	byte[] byteArray = byteList.ToArray ();  	if (byteArray.Length >= 2) {  		// If BOM is part of the string' decode as the appropriate Unicode type.  		// If no BOM is present use Little Endian Unicode.  		if (byteArray [0] == 0xFF && byteArray [1] == 0xFE)  			returnValue = Encoding.Unicode.GetString (byteArray' 2' byteArray.Length - 2);  		else if (byteArray [0] == 0xFE && byteArray [1] == 0xFF)  			returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 2' byteArray.Length - 2);  		else  			returnValue = Encoding.Unicode.GetString (byteArray' 0' byteArray.Length);  	} else {  		returnValue = Encoding.Unicode.GetString (byteArray' 0' byteArray.Length);  	}  } else if (textEncoding == EncodingType.UTF16BE) {  	byte byte1;  	byte byte2;  	do {  		byte1 = stream.Read1 ();  		byteList.Add (byte1);  		byte2 = stream.Read1 ();  		byteList.Add (byte2);  	} while (byte1 != 0 || byte2 != 0);  	byte[] byteArray = byteList.ToArray ();  	if (byteArray.Length >= 2) {  		// If BOM is part of the string' remove before decoding.  		if (byteArray [0] == 0xFE && byteArray [1] == 0xFF)  			returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 2' byteArray.Length - 2);  		else  			returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 0' byteArray.Length);  	} else {  		returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 0' byteArray.Length);  	}  } else if (textEncoding == EncodingType.UTF8) {  	byte readByte = stream.Read1 ();  	while (readByte != 0) {  		byteList.Add (readByte);  		readByte = stream.Read1 ();  	}  	returnValue = Encoding.UTF8.GetString (byteList.ToArray ());  } else {  	// Most likely bad data  	string msg = string.Format ("Text Encoding '{0}' unknown at position {1}"' textEncoding' stream.Position);  	Trace.WriteLine (msg);  	return "";  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Utils,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\ID3v2Utils.cs,ReadString,The following statement contains a magic number: if (textEncoding == EncodingType.ISO88591) {  	byte readByte = stream.Read1 ();  	while (readByte != 0) {  		byteList.Add (readByte);  		readByte = stream.Read1 ();  	}  	returnValue = ByteUtils.ISO88591GetString (byteList.ToArray ());  } else if (textEncoding == EncodingType.Unicode) {  	byte byte1;  	byte byte2;  	do {  		byte1 = stream.Read1 ();  		byteList.Add (byte1);  		byte2 = stream.Read1 ();  		byteList.Add (byte2);  	} while (byte1 != 0 || byte2 != 0);  	byte[] byteArray = byteList.ToArray ();  	if (byteArray.Length >= 2) {  		// If BOM is part of the string' decode as the appropriate Unicode type.  		// If no BOM is present use Little Endian Unicode.  		if (byteArray [0] == 0xFF && byteArray [1] == 0xFE)  			returnValue = Encoding.Unicode.GetString (byteArray' 2' byteArray.Length - 2);  		else if (byteArray [0] == 0xFE && byteArray [1] == 0xFF)  			returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 2' byteArray.Length - 2);  		else  			returnValue = Encoding.Unicode.GetString (byteArray' 0' byteArray.Length);  	} else {  		returnValue = Encoding.Unicode.GetString (byteArray' 0' byteArray.Length);  	}  } else if (textEncoding == EncodingType.UTF16BE) {  	byte byte1;  	byte byte2;  	do {  		byte1 = stream.Read1 ();  		byteList.Add (byte1);  		byte2 = stream.Read1 ();  		byteList.Add (byte2);  	} while (byte1 != 0 || byte2 != 0);  	byte[] byteArray = byteList.ToArray ();  	if (byteArray.Length >= 2) {  		// If BOM is part of the string' remove before decoding.  		if (byteArray [0] == 0xFE && byteArray [1] == 0xFF)  			returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 2' byteArray.Length - 2);  		else  			returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 0' byteArray.Length);  	} else {  		returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 0' byteArray.Length);  	}  } else if (textEncoding == EncodingType.UTF8) {  	byte readByte = stream.Read1 ();  	while (readByte != 0) {  		byteList.Add (readByte);  		readByte = stream.Read1 ();  	}  	returnValue = Encoding.UTF8.GetString (byteList.ToArray ());  } else {  	// Most likely bad data  	string msg = string.Format ("Text Encoding '{0}' unknown at position {1}"' textEncoding' stream.Position);  	Trace.WriteLine (msg);  	return "";  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Utils,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\ID3v2Utils.cs,ReadString,The following statement contains a magic number: if (textEncoding == EncodingType.ISO88591) {  	byte readByte = stream.Read1 ();  	while (readByte != 0) {  		byteList.Add (readByte);  		readByte = stream.Read1 ();  	}  	returnValue = ByteUtils.ISO88591GetString (byteList.ToArray ());  } else if (textEncoding == EncodingType.Unicode) {  	byte byte1;  	byte byte2;  	do {  		byte1 = stream.Read1 ();  		byteList.Add (byte1);  		byte2 = stream.Read1 ();  		byteList.Add (byte2);  	} while (byte1 != 0 || byte2 != 0);  	byte[] byteArray = byteList.ToArray ();  	if (byteArray.Length >= 2) {  		// If BOM is part of the string' decode as the appropriate Unicode type.  		// If no BOM is present use Little Endian Unicode.  		if (byteArray [0] == 0xFF && byteArray [1] == 0xFE)  			returnValue = Encoding.Unicode.GetString (byteArray' 2' byteArray.Length - 2);  		else if (byteArray [0] == 0xFE && byteArray [1] == 0xFF)  			returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 2' byteArray.Length - 2);  		else  			returnValue = Encoding.Unicode.GetString (byteArray' 0' byteArray.Length);  	} else {  		returnValue = Encoding.Unicode.GetString (byteArray' 0' byteArray.Length);  	}  } else if (textEncoding == EncodingType.UTF16BE) {  	byte byte1;  	byte byte2;  	do {  		byte1 = stream.Read1 ();  		byteList.Add (byte1);  		byte2 = stream.Read1 ();  		byteList.Add (byte2);  	} while (byte1 != 0 || byte2 != 0);  	byte[] byteArray = byteList.ToArray ();  	if (byteArray.Length >= 2) {  		// If BOM is part of the string' remove before decoding.  		if (byteArray [0] == 0xFE && byteArray [1] == 0xFF)  			returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 2' byteArray.Length - 2);  		else  			returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 0' byteArray.Length);  	} else {  		returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 0' byteArray.Length);  	}  } else if (textEncoding == EncodingType.UTF8) {  	byte readByte = stream.Read1 ();  	while (readByte != 0) {  		byteList.Add (readByte);  		readByte = stream.Read1 ();  	}  	returnValue = Encoding.UTF8.GetString (byteList.ToArray ());  } else {  	// Most likely bad data  	string msg = string.Format ("Text Encoding '{0}' unknown at position {1}"' textEncoding' stream.Position);  	Trace.WriteLine (msg);  	return "";  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Utils,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\ID3v2Utils.cs,ReadString,The following statement contains a magic number: if (textEncoding == EncodingType.ISO88591) {  	byte readByte = stream.Read1 ();  	while (readByte != 0) {  		byteList.Add (readByte);  		readByte = stream.Read1 ();  	}  	returnValue = ByteUtils.ISO88591GetString (byteList.ToArray ());  } else if (textEncoding == EncodingType.Unicode) {  	byte byte1;  	byte byte2;  	do {  		byte1 = stream.Read1 ();  		byteList.Add (byte1);  		byte2 = stream.Read1 ();  		byteList.Add (byte2);  	} while (byte1 != 0 || byte2 != 0);  	byte[] byteArray = byteList.ToArray ();  	if (byteArray.Length >= 2) {  		// If BOM is part of the string' decode as the appropriate Unicode type.  		// If no BOM is present use Little Endian Unicode.  		if (byteArray [0] == 0xFF && byteArray [1] == 0xFE)  			returnValue = Encoding.Unicode.GetString (byteArray' 2' byteArray.Length - 2);  		else if (byteArray [0] == 0xFE && byteArray [1] == 0xFF)  			returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 2' byteArray.Length - 2);  		else  			returnValue = Encoding.Unicode.GetString (byteArray' 0' byteArray.Length);  	} else {  		returnValue = Encoding.Unicode.GetString (byteArray' 0' byteArray.Length);  	}  } else if (textEncoding == EncodingType.UTF16BE) {  	byte byte1;  	byte byte2;  	do {  		byte1 = stream.Read1 ();  		byteList.Add (byte1);  		byte2 = stream.Read1 ();  		byteList.Add (byte2);  	} while (byte1 != 0 || byte2 != 0);  	byte[] byteArray = byteList.ToArray ();  	if (byteArray.Length >= 2) {  		// If BOM is part of the string' remove before decoding.  		if (byteArray [0] == 0xFE && byteArray [1] == 0xFF)  			returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 2' byteArray.Length - 2);  		else  			returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 0' byteArray.Length);  	} else {  		returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 0' byteArray.Length);  	}  } else if (textEncoding == EncodingType.UTF8) {  	byte readByte = stream.Read1 ();  	while (readByte != 0) {  		byteList.Add (readByte);  		readByte = stream.Read1 ();  	}  	returnValue = Encoding.UTF8.GetString (byteList.ToArray ());  } else {  	// Most likely bad data  	string msg = string.Format ("Text Encoding '{0}' unknown at position {1}"' textEncoding' stream.Position);  	Trace.WriteLine (msg);  	return "";  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Utils,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\ID3v2Utils.cs,ReadString,The following statement contains a magic number: if (textEncoding == EncodingType.Unicode) {  	byte byte1;  	byte byte2;  	do {  		byte1 = stream.Read1 ();  		byteList.Add (byte1);  		byte2 = stream.Read1 ();  		byteList.Add (byte2);  	} while (byte1 != 0 || byte2 != 0);  	byte[] byteArray = byteList.ToArray ();  	if (byteArray.Length >= 2) {  		// If BOM is part of the string' decode as the appropriate Unicode type.  		// If no BOM is present use Little Endian Unicode.  		if (byteArray [0] == 0xFF && byteArray [1] == 0xFE)  			returnValue = Encoding.Unicode.GetString (byteArray' 2' byteArray.Length - 2);  		else if (byteArray [0] == 0xFE && byteArray [1] == 0xFF)  			returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 2' byteArray.Length - 2);  		else  			returnValue = Encoding.Unicode.GetString (byteArray' 0' byteArray.Length);  	} else {  		returnValue = Encoding.Unicode.GetString (byteArray' 0' byteArray.Length);  	}  } else if (textEncoding == EncodingType.UTF16BE) {  	byte byte1;  	byte byte2;  	do {  		byte1 = stream.Read1 ();  		byteList.Add (byte1);  		byte2 = stream.Read1 ();  		byteList.Add (byte2);  	} while (byte1 != 0 || byte2 != 0);  	byte[] byteArray = byteList.ToArray ();  	if (byteArray.Length >= 2) {  		// If BOM is part of the string' remove before decoding.  		if (byteArray [0] == 0xFE && byteArray [1] == 0xFF)  			returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 2' byteArray.Length - 2);  		else  			returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 0' byteArray.Length);  	} else {  		returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 0' byteArray.Length);  	}  } else if (textEncoding == EncodingType.UTF8) {  	byte readByte = stream.Read1 ();  	while (readByte != 0) {  		byteList.Add (readByte);  		readByte = stream.Read1 ();  	}  	returnValue = Encoding.UTF8.GetString (byteList.ToArray ());  } else {  	// Most likely bad data  	string msg = string.Format ("Text Encoding '{0}' unknown at position {1}"' textEncoding' stream.Position);  	Trace.WriteLine (msg);  	return "";  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Utils,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\ID3v2Utils.cs,ReadString,The following statement contains a magic number: if (textEncoding == EncodingType.Unicode) {  	byte byte1;  	byte byte2;  	do {  		byte1 = stream.Read1 ();  		byteList.Add (byte1);  		byte2 = stream.Read1 ();  		byteList.Add (byte2);  	} while (byte1 != 0 || byte2 != 0);  	byte[] byteArray = byteList.ToArray ();  	if (byteArray.Length >= 2) {  		// If BOM is part of the string' decode as the appropriate Unicode type.  		// If no BOM is present use Little Endian Unicode.  		if (byteArray [0] == 0xFF && byteArray [1] == 0xFE)  			returnValue = Encoding.Unicode.GetString (byteArray' 2' byteArray.Length - 2);  		else if (byteArray [0] == 0xFE && byteArray [1] == 0xFF)  			returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 2' byteArray.Length - 2);  		else  			returnValue = Encoding.Unicode.GetString (byteArray' 0' byteArray.Length);  	} else {  		returnValue = Encoding.Unicode.GetString (byteArray' 0' byteArray.Length);  	}  } else if (textEncoding == EncodingType.UTF16BE) {  	byte byte1;  	byte byte2;  	do {  		byte1 = stream.Read1 ();  		byteList.Add (byte1);  		byte2 = stream.Read1 ();  		byteList.Add (byte2);  	} while (byte1 != 0 || byte2 != 0);  	byte[] byteArray = byteList.ToArray ();  	if (byteArray.Length >= 2) {  		// If BOM is part of the string' remove before decoding.  		if (byteArray [0] == 0xFE && byteArray [1] == 0xFF)  			returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 2' byteArray.Length - 2);  		else  			returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 0' byteArray.Length);  	} else {  		returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 0' byteArray.Length);  	}  } else if (textEncoding == EncodingType.UTF8) {  	byte readByte = stream.Read1 ();  	while (readByte != 0) {  		byteList.Add (readByte);  		readByte = stream.Read1 ();  	}  	returnValue = Encoding.UTF8.GetString (byteList.ToArray ());  } else {  	// Most likely bad data  	string msg = string.Format ("Text Encoding '{0}' unknown at position {1}"' textEncoding' stream.Position);  	Trace.WriteLine (msg);  	return "";  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Utils,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\ID3v2Utils.cs,ReadString,The following statement contains a magic number: if (textEncoding == EncodingType.Unicode) {  	byte byte1;  	byte byte2;  	do {  		byte1 = stream.Read1 ();  		byteList.Add (byte1);  		byte2 = stream.Read1 ();  		byteList.Add (byte2);  	} while (byte1 != 0 || byte2 != 0);  	byte[] byteArray = byteList.ToArray ();  	if (byteArray.Length >= 2) {  		// If BOM is part of the string' decode as the appropriate Unicode type.  		// If no BOM is present use Little Endian Unicode.  		if (byteArray [0] == 0xFF && byteArray [1] == 0xFE)  			returnValue = Encoding.Unicode.GetString (byteArray' 2' byteArray.Length - 2);  		else if (byteArray [0] == 0xFE && byteArray [1] == 0xFF)  			returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 2' byteArray.Length - 2);  		else  			returnValue = Encoding.Unicode.GetString (byteArray' 0' byteArray.Length);  	} else {  		returnValue = Encoding.Unicode.GetString (byteArray' 0' byteArray.Length);  	}  } else if (textEncoding == EncodingType.UTF16BE) {  	byte byte1;  	byte byte2;  	do {  		byte1 = stream.Read1 ();  		byteList.Add (byte1);  		byte2 = stream.Read1 ();  		byteList.Add (byte2);  	} while (byte1 != 0 || byte2 != 0);  	byte[] byteArray = byteList.ToArray ();  	if (byteArray.Length >= 2) {  		// If BOM is part of the string' remove before decoding.  		if (byteArray [0] == 0xFE && byteArray [1] == 0xFF)  			returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 2' byteArray.Length - 2);  		else  			returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 0' byteArray.Length);  	} else {  		returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 0' byteArray.Length);  	}  } else if (textEncoding == EncodingType.UTF8) {  	byte readByte = stream.Read1 ();  	while (readByte != 0) {  		byteList.Add (readByte);  		readByte = stream.Read1 ();  	}  	returnValue = Encoding.UTF8.GetString (byteList.ToArray ());  } else {  	// Most likely bad data  	string msg = string.Format ("Text Encoding '{0}' unknown at position {1}"' textEncoding' stream.Position);  	Trace.WriteLine (msg);  	return "";  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Utils,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\ID3v2Utils.cs,ReadString,The following statement contains a magic number: if (textEncoding == EncodingType.Unicode) {  	byte byte1;  	byte byte2;  	do {  		byte1 = stream.Read1 ();  		byteList.Add (byte1);  		byte2 = stream.Read1 ();  		byteList.Add (byte2);  	} while (byte1 != 0 || byte2 != 0);  	byte[] byteArray = byteList.ToArray ();  	if (byteArray.Length >= 2) {  		// If BOM is part of the string' decode as the appropriate Unicode type.  		// If no BOM is present use Little Endian Unicode.  		if (byteArray [0] == 0xFF && byteArray [1] == 0xFE)  			returnValue = Encoding.Unicode.GetString (byteArray' 2' byteArray.Length - 2);  		else if (byteArray [0] == 0xFE && byteArray [1] == 0xFF)  			returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 2' byteArray.Length - 2);  		else  			returnValue = Encoding.Unicode.GetString (byteArray' 0' byteArray.Length);  	} else {  		returnValue = Encoding.Unicode.GetString (byteArray' 0' byteArray.Length);  	}  } else if (textEncoding == EncodingType.UTF16BE) {  	byte byte1;  	byte byte2;  	do {  		byte1 = stream.Read1 ();  		byteList.Add (byte1);  		byte2 = stream.Read1 ();  		byteList.Add (byte2);  	} while (byte1 != 0 || byte2 != 0);  	byte[] byteArray = byteList.ToArray ();  	if (byteArray.Length >= 2) {  		// If BOM is part of the string' remove before decoding.  		if (byteArray [0] == 0xFE && byteArray [1] == 0xFF)  			returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 2' byteArray.Length - 2);  		else  			returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 0' byteArray.Length);  	} else {  		returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 0' byteArray.Length);  	}  } else if (textEncoding == EncodingType.UTF8) {  	byte readByte = stream.Read1 ();  	while (readByte != 0) {  		byteList.Add (readByte);  		readByte = stream.Read1 ();  	}  	returnValue = Encoding.UTF8.GetString (byteList.ToArray ());  } else {  	// Most likely bad data  	string msg = string.Format ("Text Encoding '{0}' unknown at position {1}"' textEncoding' stream.Position);  	Trace.WriteLine (msg);  	return "";  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Utils,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\ID3v2Utils.cs,ReadString,The following statement contains a magic number: if (textEncoding == EncodingType.Unicode) {  	byte byte1;  	byte byte2;  	do {  		byte1 = stream.Read1 ();  		byteList.Add (byte1);  		byte2 = stream.Read1 ();  		byteList.Add (byte2);  	} while (byte1 != 0 || byte2 != 0);  	byte[] byteArray = byteList.ToArray ();  	if (byteArray.Length >= 2) {  		// If BOM is part of the string' decode as the appropriate Unicode type.  		// If no BOM is present use Little Endian Unicode.  		if (byteArray [0] == 0xFF && byteArray [1] == 0xFE)  			returnValue = Encoding.Unicode.GetString (byteArray' 2' byteArray.Length - 2);  		else if (byteArray [0] == 0xFE && byteArray [1] == 0xFF)  			returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 2' byteArray.Length - 2);  		else  			returnValue = Encoding.Unicode.GetString (byteArray' 0' byteArray.Length);  	} else {  		returnValue = Encoding.Unicode.GetString (byteArray' 0' byteArray.Length);  	}  } else if (textEncoding == EncodingType.UTF16BE) {  	byte byte1;  	byte byte2;  	do {  		byte1 = stream.Read1 ();  		byteList.Add (byte1);  		byte2 = stream.Read1 ();  		byteList.Add (byte2);  	} while (byte1 != 0 || byte2 != 0);  	byte[] byteArray = byteList.ToArray ();  	if (byteArray.Length >= 2) {  		// If BOM is part of the string' remove before decoding.  		if (byteArray [0] == 0xFE && byteArray [1] == 0xFF)  			returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 2' byteArray.Length - 2);  		else  			returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 0' byteArray.Length);  	} else {  		returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 0' byteArray.Length);  	}  } else if (textEncoding == EncodingType.UTF8) {  	byte readByte = stream.Read1 ();  	while (readByte != 0) {  		byteList.Add (readByte);  		readByte = stream.Read1 ();  	}  	returnValue = Encoding.UTF8.GetString (byteList.ToArray ());  } else {  	// Most likely bad data  	string msg = string.Format ("Text Encoding '{0}' unknown at position {1}"' textEncoding' stream.Position);  	Trace.WriteLine (msg);  	return "";  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Utils,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\ID3v2Utils.cs,ReadString,The following statement contains a magic number: if (textEncoding == EncodingType.Unicode) {  	byte byte1;  	byte byte2;  	do {  		byte1 = stream.Read1 ();  		byteList.Add (byte1);  		byte2 = stream.Read1 ();  		byteList.Add (byte2);  	} while (byte1 != 0 || byte2 != 0);  	byte[] byteArray = byteList.ToArray ();  	if (byteArray.Length >= 2) {  		// If BOM is part of the string' decode as the appropriate Unicode type.  		// If no BOM is present use Little Endian Unicode.  		if (byteArray [0] == 0xFF && byteArray [1] == 0xFE)  			returnValue = Encoding.Unicode.GetString (byteArray' 2' byteArray.Length - 2);  		else if (byteArray [0] == 0xFE && byteArray [1] == 0xFF)  			returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 2' byteArray.Length - 2);  		else  			returnValue = Encoding.Unicode.GetString (byteArray' 0' byteArray.Length);  	} else {  		returnValue = Encoding.Unicode.GetString (byteArray' 0' byteArray.Length);  	}  } else if (textEncoding == EncodingType.UTF16BE) {  	byte byte1;  	byte byte2;  	do {  		byte1 = stream.Read1 ();  		byteList.Add (byte1);  		byte2 = stream.Read1 ();  		byteList.Add (byte2);  	} while (byte1 != 0 || byte2 != 0);  	byte[] byteArray = byteList.ToArray ();  	if (byteArray.Length >= 2) {  		// If BOM is part of the string' remove before decoding.  		if (byteArray [0] == 0xFE && byteArray [1] == 0xFF)  			returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 2' byteArray.Length - 2);  		else  			returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 0' byteArray.Length);  	} else {  		returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 0' byteArray.Length);  	}  } else if (textEncoding == EncodingType.UTF8) {  	byte readByte = stream.Read1 ();  	while (readByte != 0) {  		byteList.Add (readByte);  		readByte = stream.Read1 ();  	}  	returnValue = Encoding.UTF8.GetString (byteList.ToArray ());  } else {  	// Most likely bad data  	string msg = string.Format ("Text Encoding '{0}' unknown at position {1}"' textEncoding' stream.Position);  	Trace.WriteLine (msg);  	return "";  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Utils,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\ID3v2Utils.cs,ReadString,The following statement contains a magic number: if (textEncoding == EncodingType.Unicode) {  	byte byte1;  	byte byte2;  	do {  		byte1 = stream.Read1 ();  		byteList.Add (byte1);  		byte2 = stream.Read1 ();  		byteList.Add (byte2);  	} while (byte1 != 0 || byte2 != 0);  	byte[] byteArray = byteList.ToArray ();  	if (byteArray.Length >= 2) {  		// If BOM is part of the string' decode as the appropriate Unicode type.  		// If no BOM is present use Little Endian Unicode.  		if (byteArray [0] == 0xFF && byteArray [1] == 0xFE)  			returnValue = Encoding.Unicode.GetString (byteArray' 2' byteArray.Length - 2);  		else if (byteArray [0] == 0xFE && byteArray [1] == 0xFF)  			returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 2' byteArray.Length - 2);  		else  			returnValue = Encoding.Unicode.GetString (byteArray' 0' byteArray.Length);  	} else {  		returnValue = Encoding.Unicode.GetString (byteArray' 0' byteArray.Length);  	}  } else if (textEncoding == EncodingType.UTF16BE) {  	byte byte1;  	byte byte2;  	do {  		byte1 = stream.Read1 ();  		byteList.Add (byte1);  		byte2 = stream.Read1 ();  		byteList.Add (byte2);  	} while (byte1 != 0 || byte2 != 0);  	byte[] byteArray = byteList.ToArray ();  	if (byteArray.Length >= 2) {  		// If BOM is part of the string' remove before decoding.  		if (byteArray [0] == 0xFE && byteArray [1] == 0xFF)  			returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 2' byteArray.Length - 2);  		else  			returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 0' byteArray.Length);  	} else {  		returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 0' byteArray.Length);  	}  } else if (textEncoding == EncodingType.UTF8) {  	byte readByte = stream.Read1 ();  	while (readByte != 0) {  		byteList.Add (readByte);  		readByte = stream.Read1 ();  	}  	returnValue = Encoding.UTF8.GetString (byteList.ToArray ());  } else {  	// Most likely bad data  	string msg = string.Format ("Text Encoding '{0}' unknown at position {1}"' textEncoding' stream.Position);  	Trace.WriteLine (msg);  	return "";  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Utils,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\ID3v2Utils.cs,ReadString,The following statement contains a magic number: if (textEncoding == EncodingType.Unicode) {  	byte byte1;  	byte byte2;  	do {  		byte1 = stream.Read1 ();  		byteList.Add (byte1);  		byte2 = stream.Read1 ();  		byteList.Add (byte2);  	} while (byte1 != 0 || byte2 != 0);  	byte[] byteArray = byteList.ToArray ();  	if (byteArray.Length >= 2) {  		// If BOM is part of the string' decode as the appropriate Unicode type.  		// If no BOM is present use Little Endian Unicode.  		if (byteArray [0] == 0xFF && byteArray [1] == 0xFE)  			returnValue = Encoding.Unicode.GetString (byteArray' 2' byteArray.Length - 2);  		else if (byteArray [0] == 0xFE && byteArray [1] == 0xFF)  			returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 2' byteArray.Length - 2);  		else  			returnValue = Encoding.Unicode.GetString (byteArray' 0' byteArray.Length);  	} else {  		returnValue = Encoding.Unicode.GetString (byteArray' 0' byteArray.Length);  	}  } else if (textEncoding == EncodingType.UTF16BE) {  	byte byte1;  	byte byte2;  	do {  		byte1 = stream.Read1 ();  		byteList.Add (byte1);  		byte2 = stream.Read1 ();  		byteList.Add (byte2);  	} while (byte1 != 0 || byte2 != 0);  	byte[] byteArray = byteList.ToArray ();  	if (byteArray.Length >= 2) {  		// If BOM is part of the string' remove before decoding.  		if (byteArray [0] == 0xFE && byteArray [1] == 0xFF)  			returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 2' byteArray.Length - 2);  		else  			returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 0' byteArray.Length);  	} else {  		returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 0' byteArray.Length);  	}  } else if (textEncoding == EncodingType.UTF8) {  	byte readByte = stream.Read1 ();  	while (readByte != 0) {  		byteList.Add (readByte);  		readByte = stream.Read1 ();  	}  	returnValue = Encoding.UTF8.GetString (byteList.ToArray ());  } else {  	// Most likely bad data  	string msg = string.Format ("Text Encoding '{0}' unknown at position {1}"' textEncoding' stream.Position);  	Trace.WriteLine (msg);  	return "";  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Utils,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\ID3v2Utils.cs,ReadString,The following statement contains a magic number: if (byteArray.Length >= 2) {  	// If BOM is part of the string' decode as the appropriate Unicode type.  	// If no BOM is present use Little Endian Unicode.  	if (byteArray [0] == 0xFF && byteArray [1] == 0xFE)  		returnValue = Encoding.Unicode.GetString (byteArray' 2' byteArray.Length - 2);  	else if (byteArray [0] == 0xFE && byteArray [1] == 0xFF)  		returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 2' byteArray.Length - 2);  	else  		returnValue = Encoding.Unicode.GetString (byteArray' 0' byteArray.Length);  } else {  	returnValue = Encoding.Unicode.GetString (byteArray' 0' byteArray.Length);  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Utils,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\ID3v2Utils.cs,ReadString,The following statement contains a magic number: if (byteArray.Length >= 2) {  	// If BOM is part of the string' decode as the appropriate Unicode type.  	// If no BOM is present use Little Endian Unicode.  	if (byteArray [0] == 0xFF && byteArray [1] == 0xFE)  		returnValue = Encoding.Unicode.GetString (byteArray' 2' byteArray.Length - 2);  	else if (byteArray [0] == 0xFE && byteArray [1] == 0xFF)  		returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 2' byteArray.Length - 2);  	else  		returnValue = Encoding.Unicode.GetString (byteArray' 0' byteArray.Length);  } else {  	returnValue = Encoding.Unicode.GetString (byteArray' 0' byteArray.Length);  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Utils,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\ID3v2Utils.cs,ReadString,The following statement contains a magic number: if (byteArray.Length >= 2) {  	// If BOM is part of the string' decode as the appropriate Unicode type.  	// If no BOM is present use Little Endian Unicode.  	if (byteArray [0] == 0xFF && byteArray [1] == 0xFE)  		returnValue = Encoding.Unicode.GetString (byteArray' 2' byteArray.Length - 2);  	else if (byteArray [0] == 0xFE && byteArray [1] == 0xFF)  		returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 2' byteArray.Length - 2);  	else  		returnValue = Encoding.Unicode.GetString (byteArray' 0' byteArray.Length);  } else {  	returnValue = Encoding.Unicode.GetString (byteArray' 0' byteArray.Length);  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Utils,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\ID3v2Utils.cs,ReadString,The following statement contains a magic number: if (byteArray.Length >= 2) {  	// If BOM is part of the string' decode as the appropriate Unicode type.  	// If no BOM is present use Little Endian Unicode.  	if (byteArray [0] == 0xFF && byteArray [1] == 0xFE)  		returnValue = Encoding.Unicode.GetString (byteArray' 2' byteArray.Length - 2);  	else if (byteArray [0] == 0xFE && byteArray [1] == 0xFF)  		returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 2' byteArray.Length - 2);  	else  		returnValue = Encoding.Unicode.GetString (byteArray' 0' byteArray.Length);  } else {  	returnValue = Encoding.Unicode.GetString (byteArray' 0' byteArray.Length);  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Utils,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\ID3v2Utils.cs,ReadString,The following statement contains a magic number: if (byteArray.Length >= 2) {  	// If BOM is part of the string' decode as the appropriate Unicode type.  	// If no BOM is present use Little Endian Unicode.  	if (byteArray [0] == 0xFF && byteArray [1] == 0xFE)  		returnValue = Encoding.Unicode.GetString (byteArray' 2' byteArray.Length - 2);  	else if (byteArray [0] == 0xFE && byteArray [1] == 0xFF)  		returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 2' byteArray.Length - 2);  	else  		returnValue = Encoding.Unicode.GetString (byteArray' 0' byteArray.Length);  } else {  	returnValue = Encoding.Unicode.GetString (byteArray' 0' byteArray.Length);  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Utils,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\ID3v2Utils.cs,ReadString,The following statement contains a magic number: if (byteArray [0] == 0xFF && byteArray [1] == 0xFE)  	returnValue = Encoding.Unicode.GetString (byteArray' 2' byteArray.Length - 2);  else if (byteArray [0] == 0xFE && byteArray [1] == 0xFF)  	returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 2' byteArray.Length - 2);  else  	returnValue = Encoding.Unicode.GetString (byteArray' 0' byteArray.Length);  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Utils,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\ID3v2Utils.cs,ReadString,The following statement contains a magic number: if (byteArray [0] == 0xFF && byteArray [1] == 0xFE)  	returnValue = Encoding.Unicode.GetString (byteArray' 2' byteArray.Length - 2);  else if (byteArray [0] == 0xFE && byteArray [1] == 0xFF)  	returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 2' byteArray.Length - 2);  else  	returnValue = Encoding.Unicode.GetString (byteArray' 0' byteArray.Length);  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Utils,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\ID3v2Utils.cs,ReadString,The following statement contains a magic number: if (byteArray [0] == 0xFF && byteArray [1] == 0xFE)  	returnValue = Encoding.Unicode.GetString (byteArray' 2' byteArray.Length - 2);  else if (byteArray [0] == 0xFE && byteArray [1] == 0xFF)  	returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 2' byteArray.Length - 2);  else  	returnValue = Encoding.Unicode.GetString (byteArray' 0' byteArray.Length);  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Utils,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\ID3v2Utils.cs,ReadString,The following statement contains a magic number: if (byteArray [0] == 0xFF && byteArray [1] == 0xFE)  	returnValue = Encoding.Unicode.GetString (byteArray' 2' byteArray.Length - 2);  else if (byteArray [0] == 0xFE && byteArray [1] == 0xFF)  	returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 2' byteArray.Length - 2);  else  	returnValue = Encoding.Unicode.GetString (byteArray' 0' byteArray.Length);  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Utils,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\ID3v2Utils.cs,ReadString,The following statement contains a magic number: returnValue = Encoding.Unicode.GetString (byteArray' 2' byteArray.Length - 2);  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Utils,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\ID3v2Utils.cs,ReadString,The following statement contains a magic number: returnValue = Encoding.Unicode.GetString (byteArray' 2' byteArray.Length - 2);  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Utils,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\ID3v2Utils.cs,ReadString,The following statement contains a magic number: if (byteArray [0] == 0xFE && byteArray [1] == 0xFF)  	returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 2' byteArray.Length - 2);  else  	returnValue = Encoding.Unicode.GetString (byteArray' 0' byteArray.Length);  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Utils,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\ID3v2Utils.cs,ReadString,The following statement contains a magic number: if (byteArray [0] == 0xFE && byteArray [1] == 0xFF)  	returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 2' byteArray.Length - 2);  else  	returnValue = Encoding.Unicode.GetString (byteArray' 0' byteArray.Length);  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Utils,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\ID3v2Utils.cs,ReadString,The following statement contains a magic number: returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 2' byteArray.Length - 2);  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Utils,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\ID3v2Utils.cs,ReadString,The following statement contains a magic number: returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 2' byteArray.Length - 2);  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Utils,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\ID3v2Utils.cs,ReadString,The following statement contains a magic number: if (textEncoding == EncodingType.UTF16BE) {  	byte byte1;  	byte byte2;  	do {  		byte1 = stream.Read1 ();  		byteList.Add (byte1);  		byte2 = stream.Read1 ();  		byteList.Add (byte2);  	} while (byte1 != 0 || byte2 != 0);  	byte[] byteArray = byteList.ToArray ();  	if (byteArray.Length >= 2) {  		// If BOM is part of the string' remove before decoding.  		if (byteArray [0] == 0xFE && byteArray [1] == 0xFF)  			returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 2' byteArray.Length - 2);  		else  			returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 0' byteArray.Length);  	} else {  		returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 0' byteArray.Length);  	}  } else if (textEncoding == EncodingType.UTF8) {  	byte readByte = stream.Read1 ();  	while (readByte != 0) {  		byteList.Add (readByte);  		readByte = stream.Read1 ();  	}  	returnValue = Encoding.UTF8.GetString (byteList.ToArray ());  } else {  	// Most likely bad data  	string msg = string.Format ("Text Encoding '{0}' unknown at position {1}"' textEncoding' stream.Position);  	Trace.WriteLine (msg);  	return "";  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Utils,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\ID3v2Utils.cs,ReadString,The following statement contains a magic number: if (textEncoding == EncodingType.UTF16BE) {  	byte byte1;  	byte byte2;  	do {  		byte1 = stream.Read1 ();  		byteList.Add (byte1);  		byte2 = stream.Read1 ();  		byteList.Add (byte2);  	} while (byte1 != 0 || byte2 != 0);  	byte[] byteArray = byteList.ToArray ();  	if (byteArray.Length >= 2) {  		// If BOM is part of the string' remove before decoding.  		if (byteArray [0] == 0xFE && byteArray [1] == 0xFF)  			returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 2' byteArray.Length - 2);  		else  			returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 0' byteArray.Length);  	} else {  		returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 0' byteArray.Length);  	}  } else if (textEncoding == EncodingType.UTF8) {  	byte readByte = stream.Read1 ();  	while (readByte != 0) {  		byteList.Add (readByte);  		readByte = stream.Read1 ();  	}  	returnValue = Encoding.UTF8.GetString (byteList.ToArray ());  } else {  	// Most likely bad data  	string msg = string.Format ("Text Encoding '{0}' unknown at position {1}"' textEncoding' stream.Position);  	Trace.WriteLine (msg);  	return "";  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Utils,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\ID3v2Utils.cs,ReadString,The following statement contains a magic number: if (textEncoding == EncodingType.UTF16BE) {  	byte byte1;  	byte byte2;  	do {  		byte1 = stream.Read1 ();  		byteList.Add (byte1);  		byte2 = stream.Read1 ();  		byteList.Add (byte2);  	} while (byte1 != 0 || byte2 != 0);  	byte[] byteArray = byteList.ToArray ();  	if (byteArray.Length >= 2) {  		// If BOM is part of the string' remove before decoding.  		if (byteArray [0] == 0xFE && byteArray [1] == 0xFF)  			returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 2' byteArray.Length - 2);  		else  			returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 0' byteArray.Length);  	} else {  		returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 0' byteArray.Length);  	}  } else if (textEncoding == EncodingType.UTF8) {  	byte readByte = stream.Read1 ();  	while (readByte != 0) {  		byteList.Add (readByte);  		readByte = stream.Read1 ();  	}  	returnValue = Encoding.UTF8.GetString (byteList.ToArray ());  } else {  	// Most likely bad data  	string msg = string.Format ("Text Encoding '{0}' unknown at position {1}"' textEncoding' stream.Position);  	Trace.WriteLine (msg);  	return "";  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Utils,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\ID3v2Utils.cs,ReadString,The following statement contains a magic number: if (byteArray.Length >= 2) {  	// If BOM is part of the string' remove before decoding.  	if (byteArray [0] == 0xFE && byteArray [1] == 0xFF)  		returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 2' byteArray.Length - 2);  	else  		returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 0' byteArray.Length);  } else {  	returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 0' byteArray.Length);  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Utils,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\ID3v2Utils.cs,ReadString,The following statement contains a magic number: if (byteArray.Length >= 2) {  	// If BOM is part of the string' remove before decoding.  	if (byteArray [0] == 0xFE && byteArray [1] == 0xFF)  		returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 2' byteArray.Length - 2);  	else  		returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 0' byteArray.Length);  } else {  	returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 0' byteArray.Length);  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Utils,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\ID3v2Utils.cs,ReadString,The following statement contains a magic number: if (byteArray.Length >= 2) {  	// If BOM is part of the string' remove before decoding.  	if (byteArray [0] == 0xFE && byteArray [1] == 0xFF)  		returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 2' byteArray.Length - 2);  	else  		returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 0' byteArray.Length);  } else {  	returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 0' byteArray.Length);  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Utils,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\ID3v2Utils.cs,ReadString,The following statement contains a magic number: if (byteArray [0] == 0xFE && byteArray [1] == 0xFF)  	returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 2' byteArray.Length - 2);  else  	returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 0' byteArray.Length);  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Utils,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\ID3v2Utils.cs,ReadString,The following statement contains a magic number: if (byteArray [0] == 0xFE && byteArray [1] == 0xFF)  	returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 2' byteArray.Length - 2);  else  	returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 0' byteArray.Length);  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Utils,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\ID3v2Utils.cs,ReadString,The following statement contains a magic number: returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 2' byteArray.Length - 2);  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Utils,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\ID3v2Utils.cs,ReadString,The following statement contains a magic number: returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 2' byteArray.Length - 2);  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Utils,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\ID3v2Utils.cs,ReadString,The following statement contains a magic number: if (textEncoding == EncodingType.ISO88591) {  	byte readByte = stream.Read1 ();  	--bytesLeft;  	if (bytesLeft == 0) {  		//String msg = String.Format("End of frame reached while reading unknown length string at position {0}"' stream.Position);  		//Trace.WriteLine(msg);  		return "";  	}  	while (readByte != 0) {  		byteList.Add (readByte);  		readByte = stream.Read1 ();  		--bytesLeft;  		if (bytesLeft == 0) {  			//String msg = String.Format("End of frame reached while reading unknown length string at position {0}"' stream.Position);  			//Trace.WriteLine(msg);  			if (readByte != 0)  				byteList.Add (readByte);  			return ByteUtils.ISO88591GetString (byteList.ToArray ());  		}  	}  	returnValue = ByteUtils.ISO88591GetString (byteList.ToArray ());  } else if (textEncoding == EncodingType.Unicode) {  	byte byte1;  	byte byte2;  	do {  		byte1 = stream.Read1 ();  		byteList.Add (byte1);  		--bytesLeft;  		if (bytesLeft == 0) {  			//String msg = String.Format("End of frame reached while reading unknown length string at position {0}"' stream.Position);  			//Trace.WriteLine(msg);  			return "";  		}  		byte2 = stream.Read1 ();  		byteList.Add (byte2);  		--bytesLeft;  		if (bytesLeft == 0) {  			//String msg = String.Format("End of frame reached while reading unknown length string at position {0}"' stream.Position);  			//Trace.WriteLine(msg);  			break;  			//return "";  		}  	} while (byte1 != 0 || byte2 != 0);  	byte[] byteArray = byteList.ToArray ();  	if (byteArray.Length >= 2) {  		// If BOM is part of the string' decode as the appropriate Unicode type.  		// If no BOM is present use Little Endian Unicode.  		if (byteArray [0] == 0xFF && byteArray [1] == 0xFE)  			returnValue = Encoding.Unicode.GetString (byteArray' 2' byteArray.Length - 2);  		else if (byteArray [0] == 0xFE && byteArray [1] == 0xFF)  			returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 2' byteArray.Length - 2);  		else  			returnValue = Encoding.Unicode.GetString (byteArray' 0' byteArray.Length);  	} else {  		returnValue = Encoding.Unicode.GetString (byteArray' 0' byteArray.Length);  	}  } else if (textEncoding == EncodingType.UTF16BE) {  	byte byte1;  	byte byte2;  	do {  		byte1 = stream.Read1 ();  		byteList.Add (byte1);  		--bytesLeft;  		if (bytesLeft == 0) {  			//String msg = String.Format("End of frame reached while reading unknown length string at position {0}"' stream.Position);  			//Trace.WriteLine(msg);  			return "";  		}  		byte2 = stream.Read1 ();  		byteList.Add (byte2);  		--bytesLeft;  		if (bytesLeft == 0) {  			//String msg = String.Format("End of frame reached while reading unknown length string at position {0}"' stream.Position);  			//Trace.WriteLine(msg);  			break;  			//return "";  		}  	} while (byte1 != 0 || byte2 != 0);  	byte[] byteArray = byteList.ToArray ();  	if (byteArray.Length >= 2) {  		// If BOM is part of the string' remove before decoding.  		if (byteArray [0] == 0xFE && byteArray [1] == 0xFF)  			returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 2' byteArray.Length - 2);  		else  			returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 0' byteArray.Length);  	} else {  		returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 0' byteArray.Length);  	}  } else if (textEncoding == EncodingType.UTF8) {  	byte readByte = stream.Read1 ();  	--bytesLeft;  	if (bytesLeft == 0) {  		//String msg = String.Format("End of frame reached while reading unknown length string at position {0}"' stream.Position);  		//Trace.WriteLine(msg);  		return "";  	}  	while (readByte != 0) {  		byteList.Add (readByte);  		readByte = stream.Read1 ();  		--bytesLeft;  		if (bytesLeft == 0) {  			//String msg = String.Format("End of frame reached while reading unknown length string at position {0}"' stream.Position);  			//Trace.WriteLine(msg);  			return "";  		}  	}  	returnValue = Encoding.UTF8.GetString (byteList.ToArray ());  } else {  	// Most likely bad data  	string msg = string.Format ("Text Encoding '{0}' unknown at position {1}"' textEncoding' stream.Position);  	Trace.WriteLine (msg);  	return "";  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Utils,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\ID3v2Utils.cs,ReadString,The following statement contains a magic number: if (textEncoding == EncodingType.ISO88591) {  	byte readByte = stream.Read1 ();  	--bytesLeft;  	if (bytesLeft == 0) {  		//String msg = String.Format("End of frame reached while reading unknown length string at position {0}"' stream.Position);  		//Trace.WriteLine(msg);  		return "";  	}  	while (readByte != 0) {  		byteList.Add (readByte);  		readByte = stream.Read1 ();  		--bytesLeft;  		if (bytesLeft == 0) {  			//String msg = String.Format("End of frame reached while reading unknown length string at position {0}"' stream.Position);  			//Trace.WriteLine(msg);  			if (readByte != 0)  				byteList.Add (readByte);  			return ByteUtils.ISO88591GetString (byteList.ToArray ());  		}  	}  	returnValue = ByteUtils.ISO88591GetString (byteList.ToArray ());  } else if (textEncoding == EncodingType.Unicode) {  	byte byte1;  	byte byte2;  	do {  		byte1 = stream.Read1 ();  		byteList.Add (byte1);  		--bytesLeft;  		if (bytesLeft == 0) {  			//String msg = String.Format("End of frame reached while reading unknown length string at position {0}"' stream.Position);  			//Trace.WriteLine(msg);  			return "";  		}  		byte2 = stream.Read1 ();  		byteList.Add (byte2);  		--bytesLeft;  		if (bytesLeft == 0) {  			//String msg = String.Format("End of frame reached while reading unknown length string at position {0}"' stream.Position);  			//Trace.WriteLine(msg);  			break;  			//return "";  		}  	} while (byte1 != 0 || byte2 != 0);  	byte[] byteArray = byteList.ToArray ();  	if (byteArray.Length >= 2) {  		// If BOM is part of the string' decode as the appropriate Unicode type.  		// If no BOM is present use Little Endian Unicode.  		if (byteArray [0] == 0xFF && byteArray [1] == 0xFE)  			returnValue = Encoding.Unicode.GetString (byteArray' 2' byteArray.Length - 2);  		else if (byteArray [0] == 0xFE && byteArray [1] == 0xFF)  			returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 2' byteArray.Length - 2);  		else  			returnValue = Encoding.Unicode.GetString (byteArray' 0' byteArray.Length);  	} else {  		returnValue = Encoding.Unicode.GetString (byteArray' 0' byteArray.Length);  	}  } else if (textEncoding == EncodingType.UTF16BE) {  	byte byte1;  	byte byte2;  	do {  		byte1 = stream.Read1 ();  		byteList.Add (byte1);  		--bytesLeft;  		if (bytesLeft == 0) {  			//String msg = String.Format("End of frame reached while reading unknown length string at position {0}"' stream.Position);  			//Trace.WriteLine(msg);  			return "";  		}  		byte2 = stream.Read1 ();  		byteList.Add (byte2);  		--bytesLeft;  		if (bytesLeft == 0) {  			//String msg = String.Format("End of frame reached while reading unknown length string at position {0}"' stream.Position);  			//Trace.WriteLine(msg);  			break;  			//return "";  		}  	} while (byte1 != 0 || byte2 != 0);  	byte[] byteArray = byteList.ToArray ();  	if (byteArray.Length >= 2) {  		// If BOM is part of the string' remove before decoding.  		if (byteArray [0] == 0xFE && byteArray [1] == 0xFF)  			returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 2' byteArray.Length - 2);  		else  			returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 0' byteArray.Length);  	} else {  		returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 0' byteArray.Length);  	}  } else if (textEncoding == EncodingType.UTF8) {  	byte readByte = stream.Read1 ();  	--bytesLeft;  	if (bytesLeft == 0) {  		//String msg = String.Format("End of frame reached while reading unknown length string at position {0}"' stream.Position);  		//Trace.WriteLine(msg);  		return "";  	}  	while (readByte != 0) {  		byteList.Add (readByte);  		readByte = stream.Read1 ();  		--bytesLeft;  		if (bytesLeft == 0) {  			//String msg = String.Format("End of frame reached while reading unknown length string at position {0}"' stream.Position);  			//Trace.WriteLine(msg);  			return "";  		}  	}  	returnValue = Encoding.UTF8.GetString (byteList.ToArray ());  } else {  	// Most likely bad data  	string msg = string.Format ("Text Encoding '{0}' unknown at position {1}"' textEncoding' stream.Position);  	Trace.WriteLine (msg);  	return "";  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Utils,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\ID3v2Utils.cs,ReadString,The following statement contains a magic number: if (textEncoding == EncodingType.ISO88591) {  	byte readByte = stream.Read1 ();  	--bytesLeft;  	if (bytesLeft == 0) {  		//String msg = String.Format("End of frame reached while reading unknown length string at position {0}"' stream.Position);  		//Trace.WriteLine(msg);  		return "";  	}  	while (readByte != 0) {  		byteList.Add (readByte);  		readByte = stream.Read1 ();  		--bytesLeft;  		if (bytesLeft == 0) {  			//String msg = String.Format("End of frame reached while reading unknown length string at position {0}"' stream.Position);  			//Trace.WriteLine(msg);  			if (readByte != 0)  				byteList.Add (readByte);  			return ByteUtils.ISO88591GetString (byteList.ToArray ());  		}  	}  	returnValue = ByteUtils.ISO88591GetString (byteList.ToArray ());  } else if (textEncoding == EncodingType.Unicode) {  	byte byte1;  	byte byte2;  	do {  		byte1 = stream.Read1 ();  		byteList.Add (byte1);  		--bytesLeft;  		if (bytesLeft == 0) {  			//String msg = String.Format("End of frame reached while reading unknown length string at position {0}"' stream.Position);  			//Trace.WriteLine(msg);  			return "";  		}  		byte2 = stream.Read1 ();  		byteList.Add (byte2);  		--bytesLeft;  		if (bytesLeft == 0) {  			//String msg = String.Format("End of frame reached while reading unknown length string at position {0}"' stream.Position);  			//Trace.WriteLine(msg);  			break;  			//return "";  		}  	} while (byte1 != 0 || byte2 != 0);  	byte[] byteArray = byteList.ToArray ();  	if (byteArray.Length >= 2) {  		// If BOM is part of the string' decode as the appropriate Unicode type.  		// If no BOM is present use Little Endian Unicode.  		if (byteArray [0] == 0xFF && byteArray [1] == 0xFE)  			returnValue = Encoding.Unicode.GetString (byteArray' 2' byteArray.Length - 2);  		else if (byteArray [0] == 0xFE && byteArray [1] == 0xFF)  			returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 2' byteArray.Length - 2);  		else  			returnValue = Encoding.Unicode.GetString (byteArray' 0' byteArray.Length);  	} else {  		returnValue = Encoding.Unicode.GetString (byteArray' 0' byteArray.Length);  	}  } else if (textEncoding == EncodingType.UTF16BE) {  	byte byte1;  	byte byte2;  	do {  		byte1 = stream.Read1 ();  		byteList.Add (byte1);  		--bytesLeft;  		if (bytesLeft == 0) {  			//String msg = String.Format("End of frame reached while reading unknown length string at position {0}"' stream.Position);  			//Trace.WriteLine(msg);  			return "";  		}  		byte2 = stream.Read1 ();  		byteList.Add (byte2);  		--bytesLeft;  		if (bytesLeft == 0) {  			//String msg = String.Format("End of frame reached while reading unknown length string at position {0}"' stream.Position);  			//Trace.WriteLine(msg);  			break;  			//return "";  		}  	} while (byte1 != 0 || byte2 != 0);  	byte[] byteArray = byteList.ToArray ();  	if (byteArray.Length >= 2) {  		// If BOM is part of the string' remove before decoding.  		if (byteArray [0] == 0xFE && byteArray [1] == 0xFF)  			returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 2' byteArray.Length - 2);  		else  			returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 0' byteArray.Length);  	} else {  		returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 0' byteArray.Length);  	}  } else if (textEncoding == EncodingType.UTF8) {  	byte readByte = stream.Read1 ();  	--bytesLeft;  	if (bytesLeft == 0) {  		//String msg = String.Format("End of frame reached while reading unknown length string at position {0}"' stream.Position);  		//Trace.WriteLine(msg);  		return "";  	}  	while (readByte != 0) {  		byteList.Add (readByte);  		readByte = stream.Read1 ();  		--bytesLeft;  		if (bytesLeft == 0) {  			//String msg = String.Format("End of frame reached while reading unknown length string at position {0}"' stream.Position);  			//Trace.WriteLine(msg);  			return "";  		}  	}  	returnValue = Encoding.UTF8.GetString (byteList.ToArray ());  } else {  	// Most likely bad data  	string msg = string.Format ("Text Encoding '{0}' unknown at position {1}"' textEncoding' stream.Position);  	Trace.WriteLine (msg);  	return "";  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Utils,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\ID3v2Utils.cs,ReadString,The following statement contains a magic number: if (textEncoding == EncodingType.ISO88591) {  	byte readByte = stream.Read1 ();  	--bytesLeft;  	if (bytesLeft == 0) {  		//String msg = String.Format("End of frame reached while reading unknown length string at position {0}"' stream.Position);  		//Trace.WriteLine(msg);  		return "";  	}  	while (readByte != 0) {  		byteList.Add (readByte);  		readByte = stream.Read1 ();  		--bytesLeft;  		if (bytesLeft == 0) {  			//String msg = String.Format("End of frame reached while reading unknown length string at position {0}"' stream.Position);  			//Trace.WriteLine(msg);  			if (readByte != 0)  				byteList.Add (readByte);  			return ByteUtils.ISO88591GetString (byteList.ToArray ());  		}  	}  	returnValue = ByteUtils.ISO88591GetString (byteList.ToArray ());  } else if (textEncoding == EncodingType.Unicode) {  	byte byte1;  	byte byte2;  	do {  		byte1 = stream.Read1 ();  		byteList.Add (byte1);  		--bytesLeft;  		if (bytesLeft == 0) {  			//String msg = String.Format("End of frame reached while reading unknown length string at position {0}"' stream.Position);  			//Trace.WriteLine(msg);  			return "";  		}  		byte2 = stream.Read1 ();  		byteList.Add (byte2);  		--bytesLeft;  		if (bytesLeft == 0) {  			//String msg = String.Format("End of frame reached while reading unknown length string at position {0}"' stream.Position);  			//Trace.WriteLine(msg);  			break;  			//return "";  		}  	} while (byte1 != 0 || byte2 != 0);  	byte[] byteArray = byteList.ToArray ();  	if (byteArray.Length >= 2) {  		// If BOM is part of the string' decode as the appropriate Unicode type.  		// If no BOM is present use Little Endian Unicode.  		if (byteArray [0] == 0xFF && byteArray [1] == 0xFE)  			returnValue = Encoding.Unicode.GetString (byteArray' 2' byteArray.Length - 2);  		else if (byteArray [0] == 0xFE && byteArray [1] == 0xFF)  			returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 2' byteArray.Length - 2);  		else  			returnValue = Encoding.Unicode.GetString (byteArray' 0' byteArray.Length);  	} else {  		returnValue = Encoding.Unicode.GetString (byteArray' 0' byteArray.Length);  	}  } else if (textEncoding == EncodingType.UTF16BE) {  	byte byte1;  	byte byte2;  	do {  		byte1 = stream.Read1 ();  		byteList.Add (byte1);  		--bytesLeft;  		if (bytesLeft == 0) {  			//String msg = String.Format("End of frame reached while reading unknown length string at position {0}"' stream.Position);  			//Trace.WriteLine(msg);  			return "";  		}  		byte2 = stream.Read1 ();  		byteList.Add (byte2);  		--bytesLeft;  		if (bytesLeft == 0) {  			//String msg = String.Format("End of frame reached while reading unknown length string at position {0}"' stream.Position);  			//Trace.WriteLine(msg);  			break;  			//return "";  		}  	} while (byte1 != 0 || byte2 != 0);  	byte[] byteArray = byteList.ToArray ();  	if (byteArray.Length >= 2) {  		// If BOM is part of the string' remove before decoding.  		if (byteArray [0] == 0xFE && byteArray [1] == 0xFF)  			returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 2' byteArray.Length - 2);  		else  			returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 0' byteArray.Length);  	} else {  		returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 0' byteArray.Length);  	}  } else if (textEncoding == EncodingType.UTF8) {  	byte readByte = stream.Read1 ();  	--bytesLeft;  	if (bytesLeft == 0) {  		//String msg = String.Format("End of frame reached while reading unknown length string at position {0}"' stream.Position);  		//Trace.WriteLine(msg);  		return "";  	}  	while (readByte != 0) {  		byteList.Add (readByte);  		readByte = stream.Read1 ();  		--bytesLeft;  		if (bytesLeft == 0) {  			//String msg = String.Format("End of frame reached while reading unknown length string at position {0}"' stream.Position);  			//Trace.WriteLine(msg);  			return "";  		}  	}  	returnValue = Encoding.UTF8.GetString (byteList.ToArray ());  } else {  	// Most likely bad data  	string msg = string.Format ("Text Encoding '{0}' unknown at position {1}"' textEncoding' stream.Position);  	Trace.WriteLine (msg);  	return "";  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Utils,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\ID3v2Utils.cs,ReadString,The following statement contains a magic number: if (textEncoding == EncodingType.ISO88591) {  	byte readByte = stream.Read1 ();  	--bytesLeft;  	if (bytesLeft == 0) {  		//String msg = String.Format("End of frame reached while reading unknown length string at position {0}"' stream.Position);  		//Trace.WriteLine(msg);  		return "";  	}  	while (readByte != 0) {  		byteList.Add (readByte);  		readByte = stream.Read1 ();  		--bytesLeft;  		if (bytesLeft == 0) {  			//String msg = String.Format("End of frame reached while reading unknown length string at position {0}"' stream.Position);  			//Trace.WriteLine(msg);  			if (readByte != 0)  				byteList.Add (readByte);  			return ByteUtils.ISO88591GetString (byteList.ToArray ());  		}  	}  	returnValue = ByteUtils.ISO88591GetString (byteList.ToArray ());  } else if (textEncoding == EncodingType.Unicode) {  	byte byte1;  	byte byte2;  	do {  		byte1 = stream.Read1 ();  		byteList.Add (byte1);  		--bytesLeft;  		if (bytesLeft == 0) {  			//String msg = String.Format("End of frame reached while reading unknown length string at position {0}"' stream.Position);  			//Trace.WriteLine(msg);  			return "";  		}  		byte2 = stream.Read1 ();  		byteList.Add (byte2);  		--bytesLeft;  		if (bytesLeft == 0) {  			//String msg = String.Format("End of frame reached while reading unknown length string at position {0}"' stream.Position);  			//Trace.WriteLine(msg);  			break;  			//return "";  		}  	} while (byte1 != 0 || byte2 != 0);  	byte[] byteArray = byteList.ToArray ();  	if (byteArray.Length >= 2) {  		// If BOM is part of the string' decode as the appropriate Unicode type.  		// If no BOM is present use Little Endian Unicode.  		if (byteArray [0] == 0xFF && byteArray [1] == 0xFE)  			returnValue = Encoding.Unicode.GetString (byteArray' 2' byteArray.Length - 2);  		else if (byteArray [0] == 0xFE && byteArray [1] == 0xFF)  			returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 2' byteArray.Length - 2);  		else  			returnValue = Encoding.Unicode.GetString (byteArray' 0' byteArray.Length);  	} else {  		returnValue = Encoding.Unicode.GetString (byteArray' 0' byteArray.Length);  	}  } else if (textEncoding == EncodingType.UTF16BE) {  	byte byte1;  	byte byte2;  	do {  		byte1 = stream.Read1 ();  		byteList.Add (byte1);  		--bytesLeft;  		if (bytesLeft == 0) {  			//String msg = String.Format("End of frame reached while reading unknown length string at position {0}"' stream.Position);  			//Trace.WriteLine(msg);  			return "";  		}  		byte2 = stream.Read1 ();  		byteList.Add (byte2);  		--bytesLeft;  		if (bytesLeft == 0) {  			//String msg = String.Format("End of frame reached while reading unknown length string at position {0}"' stream.Position);  			//Trace.WriteLine(msg);  			break;  			//return "";  		}  	} while (byte1 != 0 || byte2 != 0);  	byte[] byteArray = byteList.ToArray ();  	if (byteArray.Length >= 2) {  		// If BOM is part of the string' remove before decoding.  		if (byteArray [0] == 0xFE && byteArray [1] == 0xFF)  			returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 2' byteArray.Length - 2);  		else  			returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 0' byteArray.Length);  	} else {  		returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 0' byteArray.Length);  	}  } else if (textEncoding == EncodingType.UTF8) {  	byte readByte = stream.Read1 ();  	--bytesLeft;  	if (bytesLeft == 0) {  		//String msg = String.Format("End of frame reached while reading unknown length string at position {0}"' stream.Position);  		//Trace.WriteLine(msg);  		return "";  	}  	while (readByte != 0) {  		byteList.Add (readByte);  		readByte = stream.Read1 ();  		--bytesLeft;  		if (bytesLeft == 0) {  			//String msg = String.Format("End of frame reached while reading unknown length string at position {0}"' stream.Position);  			//Trace.WriteLine(msg);  			return "";  		}  	}  	returnValue = Encoding.UTF8.GetString (byteList.ToArray ());  } else {  	// Most likely bad data  	string msg = string.Format ("Text Encoding '{0}' unknown at position {1}"' textEncoding' stream.Position);  	Trace.WriteLine (msg);  	return "";  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Utils,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\ID3v2Utils.cs,ReadString,The following statement contains a magic number: if (textEncoding == EncodingType.ISO88591) {  	byte readByte = stream.Read1 ();  	--bytesLeft;  	if (bytesLeft == 0) {  		//String msg = String.Format("End of frame reached while reading unknown length string at position {0}"' stream.Position);  		//Trace.WriteLine(msg);  		return "";  	}  	while (readByte != 0) {  		byteList.Add (readByte);  		readByte = stream.Read1 ();  		--bytesLeft;  		if (bytesLeft == 0) {  			//String msg = String.Format("End of frame reached while reading unknown length string at position {0}"' stream.Position);  			//Trace.WriteLine(msg);  			if (readByte != 0)  				byteList.Add (readByte);  			return ByteUtils.ISO88591GetString (byteList.ToArray ());  		}  	}  	returnValue = ByteUtils.ISO88591GetString (byteList.ToArray ());  } else if (textEncoding == EncodingType.Unicode) {  	byte byte1;  	byte byte2;  	do {  		byte1 = stream.Read1 ();  		byteList.Add (byte1);  		--bytesLeft;  		if (bytesLeft == 0) {  			//String msg = String.Format("End of frame reached while reading unknown length string at position {0}"' stream.Position);  			//Trace.WriteLine(msg);  			return "";  		}  		byte2 = stream.Read1 ();  		byteList.Add (byte2);  		--bytesLeft;  		if (bytesLeft == 0) {  			//String msg = String.Format("End of frame reached while reading unknown length string at position {0}"' stream.Position);  			//Trace.WriteLine(msg);  			break;  			//return "";  		}  	} while (byte1 != 0 || byte2 != 0);  	byte[] byteArray = byteList.ToArray ();  	if (byteArray.Length >= 2) {  		// If BOM is part of the string' decode as the appropriate Unicode type.  		// If no BOM is present use Little Endian Unicode.  		if (byteArray [0] == 0xFF && byteArray [1] == 0xFE)  			returnValue = Encoding.Unicode.GetString (byteArray' 2' byteArray.Length - 2);  		else if (byteArray [0] == 0xFE && byteArray [1] == 0xFF)  			returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 2' byteArray.Length - 2);  		else  			returnValue = Encoding.Unicode.GetString (byteArray' 0' byteArray.Length);  	} else {  		returnValue = Encoding.Unicode.GetString (byteArray' 0' byteArray.Length);  	}  } else if (textEncoding == EncodingType.UTF16BE) {  	byte byte1;  	byte byte2;  	do {  		byte1 = stream.Read1 ();  		byteList.Add (byte1);  		--bytesLeft;  		if (bytesLeft == 0) {  			//String msg = String.Format("End of frame reached while reading unknown length string at position {0}"' stream.Position);  			//Trace.WriteLine(msg);  			return "";  		}  		byte2 = stream.Read1 ();  		byteList.Add (byte2);  		--bytesLeft;  		if (bytesLeft == 0) {  			//String msg = String.Format("End of frame reached while reading unknown length string at position {0}"' stream.Position);  			//Trace.WriteLine(msg);  			break;  			//return "";  		}  	} while (byte1 != 0 || byte2 != 0);  	byte[] byteArray = byteList.ToArray ();  	if (byteArray.Length >= 2) {  		// If BOM is part of the string' remove before decoding.  		if (byteArray [0] == 0xFE && byteArray [1] == 0xFF)  			returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 2' byteArray.Length - 2);  		else  			returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 0' byteArray.Length);  	} else {  		returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 0' byteArray.Length);  	}  } else if (textEncoding == EncodingType.UTF8) {  	byte readByte = stream.Read1 ();  	--bytesLeft;  	if (bytesLeft == 0) {  		//String msg = String.Format("End of frame reached while reading unknown length string at position {0}"' stream.Position);  		//Trace.WriteLine(msg);  		return "";  	}  	while (readByte != 0) {  		byteList.Add (readByte);  		readByte = stream.Read1 ();  		--bytesLeft;  		if (bytesLeft == 0) {  			//String msg = String.Format("End of frame reached while reading unknown length string at position {0}"' stream.Position);  			//Trace.WriteLine(msg);  			return "";  		}  	}  	returnValue = Encoding.UTF8.GetString (byteList.ToArray ());  } else {  	// Most likely bad data  	string msg = string.Format ("Text Encoding '{0}' unknown at position {1}"' textEncoding' stream.Position);  	Trace.WriteLine (msg);  	return "";  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Utils,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\ID3v2Utils.cs,ReadString,The following statement contains a magic number: if (textEncoding == EncodingType.ISO88591) {  	byte readByte = stream.Read1 ();  	--bytesLeft;  	if (bytesLeft == 0) {  		//String msg = String.Format("End of frame reached while reading unknown length string at position {0}"' stream.Position);  		//Trace.WriteLine(msg);  		return "";  	}  	while (readByte != 0) {  		byteList.Add (readByte);  		readByte = stream.Read1 ();  		--bytesLeft;  		if (bytesLeft == 0) {  			//String msg = String.Format("End of frame reached while reading unknown length string at position {0}"' stream.Position);  			//Trace.WriteLine(msg);  			if (readByte != 0)  				byteList.Add (readByte);  			return ByteUtils.ISO88591GetString (byteList.ToArray ());  		}  	}  	returnValue = ByteUtils.ISO88591GetString (byteList.ToArray ());  } else if (textEncoding == EncodingType.Unicode) {  	byte byte1;  	byte byte2;  	do {  		byte1 = stream.Read1 ();  		byteList.Add (byte1);  		--bytesLeft;  		if (bytesLeft == 0) {  			//String msg = String.Format("End of frame reached while reading unknown length string at position {0}"' stream.Position);  			//Trace.WriteLine(msg);  			return "";  		}  		byte2 = stream.Read1 ();  		byteList.Add (byte2);  		--bytesLeft;  		if (bytesLeft == 0) {  			//String msg = String.Format("End of frame reached while reading unknown length string at position {0}"' stream.Position);  			//Trace.WriteLine(msg);  			break;  			//return "";  		}  	} while (byte1 != 0 || byte2 != 0);  	byte[] byteArray = byteList.ToArray ();  	if (byteArray.Length >= 2) {  		// If BOM is part of the string' decode as the appropriate Unicode type.  		// If no BOM is present use Little Endian Unicode.  		if (byteArray [0] == 0xFF && byteArray [1] == 0xFE)  			returnValue = Encoding.Unicode.GetString (byteArray' 2' byteArray.Length - 2);  		else if (byteArray [0] == 0xFE && byteArray [1] == 0xFF)  			returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 2' byteArray.Length - 2);  		else  			returnValue = Encoding.Unicode.GetString (byteArray' 0' byteArray.Length);  	} else {  		returnValue = Encoding.Unicode.GetString (byteArray' 0' byteArray.Length);  	}  } else if (textEncoding == EncodingType.UTF16BE) {  	byte byte1;  	byte byte2;  	do {  		byte1 = stream.Read1 ();  		byteList.Add (byte1);  		--bytesLeft;  		if (bytesLeft == 0) {  			//String msg = String.Format("End of frame reached while reading unknown length string at position {0}"' stream.Position);  			//Trace.WriteLine(msg);  			return "";  		}  		byte2 = stream.Read1 ();  		byteList.Add (byte2);  		--bytesLeft;  		if (bytesLeft == 0) {  			//String msg = String.Format("End of frame reached while reading unknown length string at position {0}"' stream.Position);  			//Trace.WriteLine(msg);  			break;  			//return "";  		}  	} while (byte1 != 0 || byte2 != 0);  	byte[] byteArray = byteList.ToArray ();  	if (byteArray.Length >= 2) {  		// If BOM is part of the string' remove before decoding.  		if (byteArray [0] == 0xFE && byteArray [1] == 0xFF)  			returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 2' byteArray.Length - 2);  		else  			returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 0' byteArray.Length);  	} else {  		returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 0' byteArray.Length);  	}  } else if (textEncoding == EncodingType.UTF8) {  	byte readByte = stream.Read1 ();  	--bytesLeft;  	if (bytesLeft == 0) {  		//String msg = String.Format("End of frame reached while reading unknown length string at position {0}"' stream.Position);  		//Trace.WriteLine(msg);  		return "";  	}  	while (readByte != 0) {  		byteList.Add (readByte);  		readByte = stream.Read1 ();  		--bytesLeft;  		if (bytesLeft == 0) {  			//String msg = String.Format("End of frame reached while reading unknown length string at position {0}"' stream.Position);  			//Trace.WriteLine(msg);  			return "";  		}  	}  	returnValue = Encoding.UTF8.GetString (byteList.ToArray ());  } else {  	// Most likely bad data  	string msg = string.Format ("Text Encoding '{0}' unknown at position {1}"' textEncoding' stream.Position);  	Trace.WriteLine (msg);  	return "";  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Utils,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\ID3v2Utils.cs,ReadString,The following statement contains a magic number: if (textEncoding == EncodingType.ISO88591) {  	byte readByte = stream.Read1 ();  	--bytesLeft;  	if (bytesLeft == 0) {  		//String msg = String.Format("End of frame reached while reading unknown length string at position {0}"' stream.Position);  		//Trace.WriteLine(msg);  		return "";  	}  	while (readByte != 0) {  		byteList.Add (readByte);  		readByte = stream.Read1 ();  		--bytesLeft;  		if (bytesLeft == 0) {  			//String msg = String.Format("End of frame reached while reading unknown length string at position {0}"' stream.Position);  			//Trace.WriteLine(msg);  			if (readByte != 0)  				byteList.Add (readByte);  			return ByteUtils.ISO88591GetString (byteList.ToArray ());  		}  	}  	returnValue = ByteUtils.ISO88591GetString (byteList.ToArray ());  } else if (textEncoding == EncodingType.Unicode) {  	byte byte1;  	byte byte2;  	do {  		byte1 = stream.Read1 ();  		byteList.Add (byte1);  		--bytesLeft;  		if (bytesLeft == 0) {  			//String msg = String.Format("End of frame reached while reading unknown length string at position {0}"' stream.Position);  			//Trace.WriteLine(msg);  			return "";  		}  		byte2 = stream.Read1 ();  		byteList.Add (byte2);  		--bytesLeft;  		if (bytesLeft == 0) {  			//String msg = String.Format("End of frame reached while reading unknown length string at position {0}"' stream.Position);  			//Trace.WriteLine(msg);  			break;  			//return "";  		}  	} while (byte1 != 0 || byte2 != 0);  	byte[] byteArray = byteList.ToArray ();  	if (byteArray.Length >= 2) {  		// If BOM is part of the string' decode as the appropriate Unicode type.  		// If no BOM is present use Little Endian Unicode.  		if (byteArray [0] == 0xFF && byteArray [1] == 0xFE)  			returnValue = Encoding.Unicode.GetString (byteArray' 2' byteArray.Length - 2);  		else if (byteArray [0] == 0xFE && byteArray [1] == 0xFF)  			returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 2' byteArray.Length - 2);  		else  			returnValue = Encoding.Unicode.GetString (byteArray' 0' byteArray.Length);  	} else {  		returnValue = Encoding.Unicode.GetString (byteArray' 0' byteArray.Length);  	}  } else if (textEncoding == EncodingType.UTF16BE) {  	byte byte1;  	byte byte2;  	do {  		byte1 = stream.Read1 ();  		byteList.Add (byte1);  		--bytesLeft;  		if (bytesLeft == 0) {  			//String msg = String.Format("End of frame reached while reading unknown length string at position {0}"' stream.Position);  			//Trace.WriteLine(msg);  			return "";  		}  		byte2 = stream.Read1 ();  		byteList.Add (byte2);  		--bytesLeft;  		if (bytesLeft == 0) {  			//String msg = String.Format("End of frame reached while reading unknown length string at position {0}"' stream.Position);  			//Trace.WriteLine(msg);  			break;  			//return "";  		}  	} while (byte1 != 0 || byte2 != 0);  	byte[] byteArray = byteList.ToArray ();  	if (byteArray.Length >= 2) {  		// If BOM is part of the string' remove before decoding.  		if (byteArray [0] == 0xFE && byteArray [1] == 0xFF)  			returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 2' byteArray.Length - 2);  		else  			returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 0' byteArray.Length);  	} else {  		returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 0' byteArray.Length);  	}  } else if (textEncoding == EncodingType.UTF8) {  	byte readByte = stream.Read1 ();  	--bytesLeft;  	if (bytesLeft == 0) {  		//String msg = String.Format("End of frame reached while reading unknown length string at position {0}"' stream.Position);  		//Trace.WriteLine(msg);  		return "";  	}  	while (readByte != 0) {  		byteList.Add (readByte);  		readByte = stream.Read1 ();  		--bytesLeft;  		if (bytesLeft == 0) {  			//String msg = String.Format("End of frame reached while reading unknown length string at position {0}"' stream.Position);  			//Trace.WriteLine(msg);  			return "";  		}  	}  	returnValue = Encoding.UTF8.GetString (byteList.ToArray ());  } else {  	// Most likely bad data  	string msg = string.Format ("Text Encoding '{0}' unknown at position {1}"' textEncoding' stream.Position);  	Trace.WriteLine (msg);  	return "";  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Utils,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\ID3v2Utils.cs,ReadString,The following statement contains a magic number: if (textEncoding == EncodingType.Unicode) {  	byte byte1;  	byte byte2;  	do {  		byte1 = stream.Read1 ();  		byteList.Add (byte1);  		--bytesLeft;  		if (bytesLeft == 0) {  			//String msg = String.Format("End of frame reached while reading unknown length string at position {0}"' stream.Position);  			//Trace.WriteLine(msg);  			return "";  		}  		byte2 = stream.Read1 ();  		byteList.Add (byte2);  		--bytesLeft;  		if (bytesLeft == 0) {  			//String msg = String.Format("End of frame reached while reading unknown length string at position {0}"' stream.Position);  			//Trace.WriteLine(msg);  			break;  			//return "";  		}  	} while (byte1 != 0 || byte2 != 0);  	byte[] byteArray = byteList.ToArray ();  	if (byteArray.Length >= 2) {  		// If BOM is part of the string' decode as the appropriate Unicode type.  		// If no BOM is present use Little Endian Unicode.  		if (byteArray [0] == 0xFF && byteArray [1] == 0xFE)  			returnValue = Encoding.Unicode.GetString (byteArray' 2' byteArray.Length - 2);  		else if (byteArray [0] == 0xFE && byteArray [1] == 0xFF)  			returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 2' byteArray.Length - 2);  		else  			returnValue = Encoding.Unicode.GetString (byteArray' 0' byteArray.Length);  	} else {  		returnValue = Encoding.Unicode.GetString (byteArray' 0' byteArray.Length);  	}  } else if (textEncoding == EncodingType.UTF16BE) {  	byte byte1;  	byte byte2;  	do {  		byte1 = stream.Read1 ();  		byteList.Add (byte1);  		--bytesLeft;  		if (bytesLeft == 0) {  			//String msg = String.Format("End of frame reached while reading unknown length string at position {0}"' stream.Position);  			//Trace.WriteLine(msg);  			return "";  		}  		byte2 = stream.Read1 ();  		byteList.Add (byte2);  		--bytesLeft;  		if (bytesLeft == 0) {  			//String msg = String.Format("End of frame reached while reading unknown length string at position {0}"' stream.Position);  			//Trace.WriteLine(msg);  			break;  			//return "";  		}  	} while (byte1 != 0 || byte2 != 0);  	byte[] byteArray = byteList.ToArray ();  	if (byteArray.Length >= 2) {  		// If BOM is part of the string' remove before decoding.  		if (byteArray [0] == 0xFE && byteArray [1] == 0xFF)  			returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 2' byteArray.Length - 2);  		else  			returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 0' byteArray.Length);  	} else {  		returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 0' byteArray.Length);  	}  } else if (textEncoding == EncodingType.UTF8) {  	byte readByte = stream.Read1 ();  	--bytesLeft;  	if (bytesLeft == 0) {  		//String msg = String.Format("End of frame reached while reading unknown length string at position {0}"' stream.Position);  		//Trace.WriteLine(msg);  		return "";  	}  	while (readByte != 0) {  		byteList.Add (readByte);  		readByte = stream.Read1 ();  		--bytesLeft;  		if (bytesLeft == 0) {  			//String msg = String.Format("End of frame reached while reading unknown length string at position {0}"' stream.Position);  			//Trace.WriteLine(msg);  			return "";  		}  	}  	returnValue = Encoding.UTF8.GetString (byteList.ToArray ());  } else {  	// Most likely bad data  	string msg = string.Format ("Text Encoding '{0}' unknown at position {1}"' textEncoding' stream.Position);  	Trace.WriteLine (msg);  	return "";  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Utils,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\ID3v2Utils.cs,ReadString,The following statement contains a magic number: if (textEncoding == EncodingType.Unicode) {  	byte byte1;  	byte byte2;  	do {  		byte1 = stream.Read1 ();  		byteList.Add (byte1);  		--bytesLeft;  		if (bytesLeft == 0) {  			//String msg = String.Format("End of frame reached while reading unknown length string at position {0}"' stream.Position);  			//Trace.WriteLine(msg);  			return "";  		}  		byte2 = stream.Read1 ();  		byteList.Add (byte2);  		--bytesLeft;  		if (bytesLeft == 0) {  			//String msg = String.Format("End of frame reached while reading unknown length string at position {0}"' stream.Position);  			//Trace.WriteLine(msg);  			break;  			//return "";  		}  	} while (byte1 != 0 || byte2 != 0);  	byte[] byteArray = byteList.ToArray ();  	if (byteArray.Length >= 2) {  		// If BOM is part of the string' decode as the appropriate Unicode type.  		// If no BOM is present use Little Endian Unicode.  		if (byteArray [0] == 0xFF && byteArray [1] == 0xFE)  			returnValue = Encoding.Unicode.GetString (byteArray' 2' byteArray.Length - 2);  		else if (byteArray [0] == 0xFE && byteArray [1] == 0xFF)  			returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 2' byteArray.Length - 2);  		else  			returnValue = Encoding.Unicode.GetString (byteArray' 0' byteArray.Length);  	} else {  		returnValue = Encoding.Unicode.GetString (byteArray' 0' byteArray.Length);  	}  } else if (textEncoding == EncodingType.UTF16BE) {  	byte byte1;  	byte byte2;  	do {  		byte1 = stream.Read1 ();  		byteList.Add (byte1);  		--bytesLeft;  		if (bytesLeft == 0) {  			//String msg = String.Format("End of frame reached while reading unknown length string at position {0}"' stream.Position);  			//Trace.WriteLine(msg);  			return "";  		}  		byte2 = stream.Read1 ();  		byteList.Add (byte2);  		--bytesLeft;  		if (bytesLeft == 0) {  			//String msg = String.Format("End of frame reached while reading unknown length string at position {0}"' stream.Position);  			//Trace.WriteLine(msg);  			break;  			//return "";  		}  	} while (byte1 != 0 || byte2 != 0);  	byte[] byteArray = byteList.ToArray ();  	if (byteArray.Length >= 2) {  		// If BOM is part of the string' remove before decoding.  		if (byteArray [0] == 0xFE && byteArray [1] == 0xFF)  			returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 2' byteArray.Length - 2);  		else  			returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 0' byteArray.Length);  	} else {  		returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 0' byteArray.Length);  	}  } else if (textEncoding == EncodingType.UTF8) {  	byte readByte = stream.Read1 ();  	--bytesLeft;  	if (bytesLeft == 0) {  		//String msg = String.Format("End of frame reached while reading unknown length string at position {0}"' stream.Position);  		//Trace.WriteLine(msg);  		return "";  	}  	while (readByte != 0) {  		byteList.Add (readByte);  		readByte = stream.Read1 ();  		--bytesLeft;  		if (bytesLeft == 0) {  			//String msg = String.Format("End of frame reached while reading unknown length string at position {0}"' stream.Position);  			//Trace.WriteLine(msg);  			return "";  		}  	}  	returnValue = Encoding.UTF8.GetString (byteList.ToArray ());  } else {  	// Most likely bad data  	string msg = string.Format ("Text Encoding '{0}' unknown at position {1}"' textEncoding' stream.Position);  	Trace.WriteLine (msg);  	return "";  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Utils,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\ID3v2Utils.cs,ReadString,The following statement contains a magic number: if (textEncoding == EncodingType.Unicode) {  	byte byte1;  	byte byte2;  	do {  		byte1 = stream.Read1 ();  		byteList.Add (byte1);  		--bytesLeft;  		if (bytesLeft == 0) {  			//String msg = String.Format("End of frame reached while reading unknown length string at position {0}"' stream.Position);  			//Trace.WriteLine(msg);  			return "";  		}  		byte2 = stream.Read1 ();  		byteList.Add (byte2);  		--bytesLeft;  		if (bytesLeft == 0) {  			//String msg = String.Format("End of frame reached while reading unknown length string at position {0}"' stream.Position);  			//Trace.WriteLine(msg);  			break;  			//return "";  		}  	} while (byte1 != 0 || byte2 != 0);  	byte[] byteArray = byteList.ToArray ();  	if (byteArray.Length >= 2) {  		// If BOM is part of the string' decode as the appropriate Unicode type.  		// If no BOM is present use Little Endian Unicode.  		if (byteArray [0] == 0xFF && byteArray [1] == 0xFE)  			returnValue = Encoding.Unicode.GetString (byteArray' 2' byteArray.Length - 2);  		else if (byteArray [0] == 0xFE && byteArray [1] == 0xFF)  			returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 2' byteArray.Length - 2);  		else  			returnValue = Encoding.Unicode.GetString (byteArray' 0' byteArray.Length);  	} else {  		returnValue = Encoding.Unicode.GetString (byteArray' 0' byteArray.Length);  	}  } else if (textEncoding == EncodingType.UTF16BE) {  	byte byte1;  	byte byte2;  	do {  		byte1 = stream.Read1 ();  		byteList.Add (byte1);  		--bytesLeft;  		if (bytesLeft == 0) {  			//String msg = String.Format("End of frame reached while reading unknown length string at position {0}"' stream.Position);  			//Trace.WriteLine(msg);  			return "";  		}  		byte2 = stream.Read1 ();  		byteList.Add (byte2);  		--bytesLeft;  		if (bytesLeft == 0) {  			//String msg = String.Format("End of frame reached while reading unknown length string at position {0}"' stream.Position);  			//Trace.WriteLine(msg);  			break;  			//return "";  		}  	} while (byte1 != 0 || byte2 != 0);  	byte[] byteArray = byteList.ToArray ();  	if (byteArray.Length >= 2) {  		// If BOM is part of the string' remove before decoding.  		if (byteArray [0] == 0xFE && byteArray [1] == 0xFF)  			returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 2' byteArray.Length - 2);  		else  			returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 0' byteArray.Length);  	} else {  		returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 0' byteArray.Length);  	}  } else if (textEncoding == EncodingType.UTF8) {  	byte readByte = stream.Read1 ();  	--bytesLeft;  	if (bytesLeft == 0) {  		//String msg = String.Format("End of frame reached while reading unknown length string at position {0}"' stream.Position);  		//Trace.WriteLine(msg);  		return "";  	}  	while (readByte != 0) {  		byteList.Add (readByte);  		readByte = stream.Read1 ();  		--bytesLeft;  		if (bytesLeft == 0) {  			//String msg = String.Format("End of frame reached while reading unknown length string at position {0}"' stream.Position);  			//Trace.WriteLine(msg);  			return "";  		}  	}  	returnValue = Encoding.UTF8.GetString (byteList.ToArray ());  } else {  	// Most likely bad data  	string msg = string.Format ("Text Encoding '{0}' unknown at position {1}"' textEncoding' stream.Position);  	Trace.WriteLine (msg);  	return "";  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Utils,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\ID3v2Utils.cs,ReadString,The following statement contains a magic number: if (textEncoding == EncodingType.Unicode) {  	byte byte1;  	byte byte2;  	do {  		byte1 = stream.Read1 ();  		byteList.Add (byte1);  		--bytesLeft;  		if (bytesLeft == 0) {  			//String msg = String.Format("End of frame reached while reading unknown length string at position {0}"' stream.Position);  			//Trace.WriteLine(msg);  			return "";  		}  		byte2 = stream.Read1 ();  		byteList.Add (byte2);  		--bytesLeft;  		if (bytesLeft == 0) {  			//String msg = String.Format("End of frame reached while reading unknown length string at position {0}"' stream.Position);  			//Trace.WriteLine(msg);  			break;  			//return "";  		}  	} while (byte1 != 0 || byte2 != 0);  	byte[] byteArray = byteList.ToArray ();  	if (byteArray.Length >= 2) {  		// If BOM is part of the string' decode as the appropriate Unicode type.  		// If no BOM is present use Little Endian Unicode.  		if (byteArray [0] == 0xFF && byteArray [1] == 0xFE)  			returnValue = Encoding.Unicode.GetString (byteArray' 2' byteArray.Length - 2);  		else if (byteArray [0] == 0xFE && byteArray [1] == 0xFF)  			returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 2' byteArray.Length - 2);  		else  			returnValue = Encoding.Unicode.GetString (byteArray' 0' byteArray.Length);  	} else {  		returnValue = Encoding.Unicode.GetString (byteArray' 0' byteArray.Length);  	}  } else if (textEncoding == EncodingType.UTF16BE) {  	byte byte1;  	byte byte2;  	do {  		byte1 = stream.Read1 ();  		byteList.Add (byte1);  		--bytesLeft;  		if (bytesLeft == 0) {  			//String msg = String.Format("End of frame reached while reading unknown length string at position {0}"' stream.Position);  			//Trace.WriteLine(msg);  			return "";  		}  		byte2 = stream.Read1 ();  		byteList.Add (byte2);  		--bytesLeft;  		if (bytesLeft == 0) {  			//String msg = String.Format("End of frame reached while reading unknown length string at position {0}"' stream.Position);  			//Trace.WriteLine(msg);  			break;  			//return "";  		}  	} while (byte1 != 0 || byte2 != 0);  	byte[] byteArray = byteList.ToArray ();  	if (byteArray.Length >= 2) {  		// If BOM is part of the string' remove before decoding.  		if (byteArray [0] == 0xFE && byteArray [1] == 0xFF)  			returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 2' byteArray.Length - 2);  		else  			returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 0' byteArray.Length);  	} else {  		returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 0' byteArray.Length);  	}  } else if (textEncoding == EncodingType.UTF8) {  	byte readByte = stream.Read1 ();  	--bytesLeft;  	if (bytesLeft == 0) {  		//String msg = String.Format("End of frame reached while reading unknown length string at position {0}"' stream.Position);  		//Trace.WriteLine(msg);  		return "";  	}  	while (readByte != 0) {  		byteList.Add (readByte);  		readByte = stream.Read1 ();  		--bytesLeft;  		if (bytesLeft == 0) {  			//String msg = String.Format("End of frame reached while reading unknown length string at position {0}"' stream.Position);  			//Trace.WriteLine(msg);  			return "";  		}  	}  	returnValue = Encoding.UTF8.GetString (byteList.ToArray ());  } else {  	// Most likely bad data  	string msg = string.Format ("Text Encoding '{0}' unknown at position {1}"' textEncoding' stream.Position);  	Trace.WriteLine (msg);  	return "";  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Utils,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\ID3v2Utils.cs,ReadString,The following statement contains a magic number: if (textEncoding == EncodingType.Unicode) {  	byte byte1;  	byte byte2;  	do {  		byte1 = stream.Read1 ();  		byteList.Add (byte1);  		--bytesLeft;  		if (bytesLeft == 0) {  			//String msg = String.Format("End of frame reached while reading unknown length string at position {0}"' stream.Position);  			//Trace.WriteLine(msg);  			return "";  		}  		byte2 = stream.Read1 ();  		byteList.Add (byte2);  		--bytesLeft;  		if (bytesLeft == 0) {  			//String msg = String.Format("End of frame reached while reading unknown length string at position {0}"' stream.Position);  			//Trace.WriteLine(msg);  			break;  			//return "";  		}  	} while (byte1 != 0 || byte2 != 0);  	byte[] byteArray = byteList.ToArray ();  	if (byteArray.Length >= 2) {  		// If BOM is part of the string' decode as the appropriate Unicode type.  		// If no BOM is present use Little Endian Unicode.  		if (byteArray [0] == 0xFF && byteArray [1] == 0xFE)  			returnValue = Encoding.Unicode.GetString (byteArray' 2' byteArray.Length - 2);  		else if (byteArray [0] == 0xFE && byteArray [1] == 0xFF)  			returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 2' byteArray.Length - 2);  		else  			returnValue = Encoding.Unicode.GetString (byteArray' 0' byteArray.Length);  	} else {  		returnValue = Encoding.Unicode.GetString (byteArray' 0' byteArray.Length);  	}  } else if (textEncoding == EncodingType.UTF16BE) {  	byte byte1;  	byte byte2;  	do {  		byte1 = stream.Read1 ();  		byteList.Add (byte1);  		--bytesLeft;  		if (bytesLeft == 0) {  			//String msg = String.Format("End of frame reached while reading unknown length string at position {0}"' stream.Position);  			//Trace.WriteLine(msg);  			return "";  		}  		byte2 = stream.Read1 ();  		byteList.Add (byte2);  		--bytesLeft;  		if (bytesLeft == 0) {  			//String msg = String.Format("End of frame reached while reading unknown length string at position {0}"' stream.Position);  			//Trace.WriteLine(msg);  			break;  			//return "";  		}  	} while (byte1 != 0 || byte2 != 0);  	byte[] byteArray = byteList.ToArray ();  	if (byteArray.Length >= 2) {  		// If BOM is part of the string' remove before decoding.  		if (byteArray [0] == 0xFE && byteArray [1] == 0xFF)  			returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 2' byteArray.Length - 2);  		else  			returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 0' byteArray.Length);  	} else {  		returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 0' byteArray.Length);  	}  } else if (textEncoding == EncodingType.UTF8) {  	byte readByte = stream.Read1 ();  	--bytesLeft;  	if (bytesLeft == 0) {  		//String msg = String.Format("End of frame reached while reading unknown length string at position {0}"' stream.Position);  		//Trace.WriteLine(msg);  		return "";  	}  	while (readByte != 0) {  		byteList.Add (readByte);  		readByte = stream.Read1 ();  		--bytesLeft;  		if (bytesLeft == 0) {  			//String msg = String.Format("End of frame reached while reading unknown length string at position {0}"' stream.Position);  			//Trace.WriteLine(msg);  			return "";  		}  	}  	returnValue = Encoding.UTF8.GetString (byteList.ToArray ());  } else {  	// Most likely bad data  	string msg = string.Format ("Text Encoding '{0}' unknown at position {1}"' textEncoding' stream.Position);  	Trace.WriteLine (msg);  	return "";  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Utils,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\ID3v2Utils.cs,ReadString,The following statement contains a magic number: if (textEncoding == EncodingType.Unicode) {  	byte byte1;  	byte byte2;  	do {  		byte1 = stream.Read1 ();  		byteList.Add (byte1);  		--bytesLeft;  		if (bytesLeft == 0) {  			//String msg = String.Format("End of frame reached while reading unknown length string at position {0}"' stream.Position);  			//Trace.WriteLine(msg);  			return "";  		}  		byte2 = stream.Read1 ();  		byteList.Add (byte2);  		--bytesLeft;  		if (bytesLeft == 0) {  			//String msg = String.Format("End of frame reached while reading unknown length string at position {0}"' stream.Position);  			//Trace.WriteLine(msg);  			break;  			//return "";  		}  	} while (byte1 != 0 || byte2 != 0);  	byte[] byteArray = byteList.ToArray ();  	if (byteArray.Length >= 2) {  		// If BOM is part of the string' decode as the appropriate Unicode type.  		// If no BOM is present use Little Endian Unicode.  		if (byteArray [0] == 0xFF && byteArray [1] == 0xFE)  			returnValue = Encoding.Unicode.GetString (byteArray' 2' byteArray.Length - 2);  		else if (byteArray [0] == 0xFE && byteArray [1] == 0xFF)  			returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 2' byteArray.Length - 2);  		else  			returnValue = Encoding.Unicode.GetString (byteArray' 0' byteArray.Length);  	} else {  		returnValue = Encoding.Unicode.GetString (byteArray' 0' byteArray.Length);  	}  } else if (textEncoding == EncodingType.UTF16BE) {  	byte byte1;  	byte byte2;  	do {  		byte1 = stream.Read1 ();  		byteList.Add (byte1);  		--bytesLeft;  		if (bytesLeft == 0) {  			//String msg = String.Format("End of frame reached while reading unknown length string at position {0}"' stream.Position);  			//Trace.WriteLine(msg);  			return "";  		}  		byte2 = stream.Read1 ();  		byteList.Add (byte2);  		--bytesLeft;  		if (bytesLeft == 0) {  			//String msg = String.Format("End of frame reached while reading unknown length string at position {0}"' stream.Position);  			//Trace.WriteLine(msg);  			break;  			//return "";  		}  	} while (byte1 != 0 || byte2 != 0);  	byte[] byteArray = byteList.ToArray ();  	if (byteArray.Length >= 2) {  		// If BOM is part of the string' remove before decoding.  		if (byteArray [0] == 0xFE && byteArray [1] == 0xFF)  			returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 2' byteArray.Length - 2);  		else  			returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 0' byteArray.Length);  	} else {  		returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 0' byteArray.Length);  	}  } else if (textEncoding == EncodingType.UTF8) {  	byte readByte = stream.Read1 ();  	--bytesLeft;  	if (bytesLeft == 0) {  		//String msg = String.Format("End of frame reached while reading unknown length string at position {0}"' stream.Position);  		//Trace.WriteLine(msg);  		return "";  	}  	while (readByte != 0) {  		byteList.Add (readByte);  		readByte = stream.Read1 ();  		--bytesLeft;  		if (bytesLeft == 0) {  			//String msg = String.Format("End of frame reached while reading unknown length string at position {0}"' stream.Position);  			//Trace.WriteLine(msg);  			return "";  		}  	}  	returnValue = Encoding.UTF8.GetString (byteList.ToArray ());  } else {  	// Most likely bad data  	string msg = string.Format ("Text Encoding '{0}' unknown at position {1}"' textEncoding' stream.Position);  	Trace.WriteLine (msg);  	return "";  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Utils,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\ID3v2Utils.cs,ReadString,The following statement contains a magic number: if (textEncoding == EncodingType.Unicode) {  	byte byte1;  	byte byte2;  	do {  		byte1 = stream.Read1 ();  		byteList.Add (byte1);  		--bytesLeft;  		if (bytesLeft == 0) {  			//String msg = String.Format("End of frame reached while reading unknown length string at position {0}"' stream.Position);  			//Trace.WriteLine(msg);  			return "";  		}  		byte2 = stream.Read1 ();  		byteList.Add (byte2);  		--bytesLeft;  		if (bytesLeft == 0) {  			//String msg = String.Format("End of frame reached while reading unknown length string at position {0}"' stream.Position);  			//Trace.WriteLine(msg);  			break;  			//return "";  		}  	} while (byte1 != 0 || byte2 != 0);  	byte[] byteArray = byteList.ToArray ();  	if (byteArray.Length >= 2) {  		// If BOM is part of the string' decode as the appropriate Unicode type.  		// If no BOM is present use Little Endian Unicode.  		if (byteArray [0] == 0xFF && byteArray [1] == 0xFE)  			returnValue = Encoding.Unicode.GetString (byteArray' 2' byteArray.Length - 2);  		else if (byteArray [0] == 0xFE && byteArray [1] == 0xFF)  			returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 2' byteArray.Length - 2);  		else  			returnValue = Encoding.Unicode.GetString (byteArray' 0' byteArray.Length);  	} else {  		returnValue = Encoding.Unicode.GetString (byteArray' 0' byteArray.Length);  	}  } else if (textEncoding == EncodingType.UTF16BE) {  	byte byte1;  	byte byte2;  	do {  		byte1 = stream.Read1 ();  		byteList.Add (byte1);  		--bytesLeft;  		if (bytesLeft == 0) {  			//String msg = String.Format("End of frame reached while reading unknown length string at position {0}"' stream.Position);  			//Trace.WriteLine(msg);  			return "";  		}  		byte2 = stream.Read1 ();  		byteList.Add (byte2);  		--bytesLeft;  		if (bytesLeft == 0) {  			//String msg = String.Format("End of frame reached while reading unknown length string at position {0}"' stream.Position);  			//Trace.WriteLine(msg);  			break;  			//return "";  		}  	} while (byte1 != 0 || byte2 != 0);  	byte[] byteArray = byteList.ToArray ();  	if (byteArray.Length >= 2) {  		// If BOM is part of the string' remove before decoding.  		if (byteArray [0] == 0xFE && byteArray [1] == 0xFF)  			returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 2' byteArray.Length - 2);  		else  			returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 0' byteArray.Length);  	} else {  		returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 0' byteArray.Length);  	}  } else if (textEncoding == EncodingType.UTF8) {  	byte readByte = stream.Read1 ();  	--bytesLeft;  	if (bytesLeft == 0) {  		//String msg = String.Format("End of frame reached while reading unknown length string at position {0}"' stream.Position);  		//Trace.WriteLine(msg);  		return "";  	}  	while (readByte != 0) {  		byteList.Add (readByte);  		readByte = stream.Read1 ();  		--bytesLeft;  		if (bytesLeft == 0) {  			//String msg = String.Format("End of frame reached while reading unknown length string at position {0}"' stream.Position);  			//Trace.WriteLine(msg);  			return "";  		}  	}  	returnValue = Encoding.UTF8.GetString (byteList.ToArray ());  } else {  	// Most likely bad data  	string msg = string.Format ("Text Encoding '{0}' unknown at position {1}"' textEncoding' stream.Position);  	Trace.WriteLine (msg);  	return "";  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Utils,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\ID3v2Utils.cs,ReadString,The following statement contains a magic number: if (textEncoding == EncodingType.Unicode) {  	byte byte1;  	byte byte2;  	do {  		byte1 = stream.Read1 ();  		byteList.Add (byte1);  		--bytesLeft;  		if (bytesLeft == 0) {  			//String msg = String.Format("End of frame reached while reading unknown length string at position {0}"' stream.Position);  			//Trace.WriteLine(msg);  			return "";  		}  		byte2 = stream.Read1 ();  		byteList.Add (byte2);  		--bytesLeft;  		if (bytesLeft == 0) {  			//String msg = String.Format("End of frame reached while reading unknown length string at position {0}"' stream.Position);  			//Trace.WriteLine(msg);  			break;  			//return "";  		}  	} while (byte1 != 0 || byte2 != 0);  	byte[] byteArray = byteList.ToArray ();  	if (byteArray.Length >= 2) {  		// If BOM is part of the string' decode as the appropriate Unicode type.  		// If no BOM is present use Little Endian Unicode.  		if (byteArray [0] == 0xFF && byteArray [1] == 0xFE)  			returnValue = Encoding.Unicode.GetString (byteArray' 2' byteArray.Length - 2);  		else if (byteArray [0] == 0xFE && byteArray [1] == 0xFF)  			returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 2' byteArray.Length - 2);  		else  			returnValue = Encoding.Unicode.GetString (byteArray' 0' byteArray.Length);  	} else {  		returnValue = Encoding.Unicode.GetString (byteArray' 0' byteArray.Length);  	}  } else if (textEncoding == EncodingType.UTF16BE) {  	byte byte1;  	byte byte2;  	do {  		byte1 = stream.Read1 ();  		byteList.Add (byte1);  		--bytesLeft;  		if (bytesLeft == 0) {  			//String msg = String.Format("End of frame reached while reading unknown length string at position {0}"' stream.Position);  			//Trace.WriteLine(msg);  			return "";  		}  		byte2 = stream.Read1 ();  		byteList.Add (byte2);  		--bytesLeft;  		if (bytesLeft == 0) {  			//String msg = String.Format("End of frame reached while reading unknown length string at position {0}"' stream.Position);  			//Trace.WriteLine(msg);  			break;  			//return "";  		}  	} while (byte1 != 0 || byte2 != 0);  	byte[] byteArray = byteList.ToArray ();  	if (byteArray.Length >= 2) {  		// If BOM is part of the string' remove before decoding.  		if (byteArray [0] == 0xFE && byteArray [1] == 0xFF)  			returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 2' byteArray.Length - 2);  		else  			returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 0' byteArray.Length);  	} else {  		returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 0' byteArray.Length);  	}  } else if (textEncoding == EncodingType.UTF8) {  	byte readByte = stream.Read1 ();  	--bytesLeft;  	if (bytesLeft == 0) {  		//String msg = String.Format("End of frame reached while reading unknown length string at position {0}"' stream.Position);  		//Trace.WriteLine(msg);  		return "";  	}  	while (readByte != 0) {  		byteList.Add (readByte);  		readByte = stream.Read1 ();  		--bytesLeft;  		if (bytesLeft == 0) {  			//String msg = String.Format("End of frame reached while reading unknown length string at position {0}"' stream.Position);  			//Trace.WriteLine(msg);  			return "";  		}  	}  	returnValue = Encoding.UTF8.GetString (byteList.ToArray ());  } else {  	// Most likely bad data  	string msg = string.Format ("Text Encoding '{0}' unknown at position {1}"' textEncoding' stream.Position);  	Trace.WriteLine (msg);  	return "";  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Utils,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\ID3v2Utils.cs,ReadString,The following statement contains a magic number: if (byteArray.Length >= 2) {  	// If BOM is part of the string' decode as the appropriate Unicode type.  	// If no BOM is present use Little Endian Unicode.  	if (byteArray [0] == 0xFF && byteArray [1] == 0xFE)  		returnValue = Encoding.Unicode.GetString (byteArray' 2' byteArray.Length - 2);  	else if (byteArray [0] == 0xFE && byteArray [1] == 0xFF)  		returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 2' byteArray.Length - 2);  	else  		returnValue = Encoding.Unicode.GetString (byteArray' 0' byteArray.Length);  } else {  	returnValue = Encoding.Unicode.GetString (byteArray' 0' byteArray.Length);  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Utils,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\ID3v2Utils.cs,ReadString,The following statement contains a magic number: if (byteArray.Length >= 2) {  	// If BOM is part of the string' decode as the appropriate Unicode type.  	// If no BOM is present use Little Endian Unicode.  	if (byteArray [0] == 0xFF && byteArray [1] == 0xFE)  		returnValue = Encoding.Unicode.GetString (byteArray' 2' byteArray.Length - 2);  	else if (byteArray [0] == 0xFE && byteArray [1] == 0xFF)  		returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 2' byteArray.Length - 2);  	else  		returnValue = Encoding.Unicode.GetString (byteArray' 0' byteArray.Length);  } else {  	returnValue = Encoding.Unicode.GetString (byteArray' 0' byteArray.Length);  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Utils,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\ID3v2Utils.cs,ReadString,The following statement contains a magic number: if (byteArray.Length >= 2) {  	// If BOM is part of the string' decode as the appropriate Unicode type.  	// If no BOM is present use Little Endian Unicode.  	if (byteArray [0] == 0xFF && byteArray [1] == 0xFE)  		returnValue = Encoding.Unicode.GetString (byteArray' 2' byteArray.Length - 2);  	else if (byteArray [0] == 0xFE && byteArray [1] == 0xFF)  		returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 2' byteArray.Length - 2);  	else  		returnValue = Encoding.Unicode.GetString (byteArray' 0' byteArray.Length);  } else {  	returnValue = Encoding.Unicode.GetString (byteArray' 0' byteArray.Length);  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Utils,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\ID3v2Utils.cs,ReadString,The following statement contains a magic number: if (byteArray.Length >= 2) {  	// If BOM is part of the string' decode as the appropriate Unicode type.  	// If no BOM is present use Little Endian Unicode.  	if (byteArray [0] == 0xFF && byteArray [1] == 0xFE)  		returnValue = Encoding.Unicode.GetString (byteArray' 2' byteArray.Length - 2);  	else if (byteArray [0] == 0xFE && byteArray [1] == 0xFF)  		returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 2' byteArray.Length - 2);  	else  		returnValue = Encoding.Unicode.GetString (byteArray' 0' byteArray.Length);  } else {  	returnValue = Encoding.Unicode.GetString (byteArray' 0' byteArray.Length);  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Utils,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\ID3v2Utils.cs,ReadString,The following statement contains a magic number: if (byteArray.Length >= 2) {  	// If BOM is part of the string' decode as the appropriate Unicode type.  	// If no BOM is present use Little Endian Unicode.  	if (byteArray [0] == 0xFF && byteArray [1] == 0xFE)  		returnValue = Encoding.Unicode.GetString (byteArray' 2' byteArray.Length - 2);  	else if (byteArray [0] == 0xFE && byteArray [1] == 0xFF)  		returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 2' byteArray.Length - 2);  	else  		returnValue = Encoding.Unicode.GetString (byteArray' 0' byteArray.Length);  } else {  	returnValue = Encoding.Unicode.GetString (byteArray' 0' byteArray.Length);  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Utils,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\ID3v2Utils.cs,ReadString,The following statement contains a magic number: if (byteArray [0] == 0xFF && byteArray [1] == 0xFE)  	returnValue = Encoding.Unicode.GetString (byteArray' 2' byteArray.Length - 2);  else if (byteArray [0] == 0xFE && byteArray [1] == 0xFF)  	returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 2' byteArray.Length - 2);  else  	returnValue = Encoding.Unicode.GetString (byteArray' 0' byteArray.Length);  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Utils,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\ID3v2Utils.cs,ReadString,The following statement contains a magic number: if (byteArray [0] == 0xFF && byteArray [1] == 0xFE)  	returnValue = Encoding.Unicode.GetString (byteArray' 2' byteArray.Length - 2);  else if (byteArray [0] == 0xFE && byteArray [1] == 0xFF)  	returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 2' byteArray.Length - 2);  else  	returnValue = Encoding.Unicode.GetString (byteArray' 0' byteArray.Length);  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Utils,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\ID3v2Utils.cs,ReadString,The following statement contains a magic number: if (byteArray [0] == 0xFF && byteArray [1] == 0xFE)  	returnValue = Encoding.Unicode.GetString (byteArray' 2' byteArray.Length - 2);  else if (byteArray [0] == 0xFE && byteArray [1] == 0xFF)  	returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 2' byteArray.Length - 2);  else  	returnValue = Encoding.Unicode.GetString (byteArray' 0' byteArray.Length);  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Utils,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\ID3v2Utils.cs,ReadString,The following statement contains a magic number: if (byteArray [0] == 0xFF && byteArray [1] == 0xFE)  	returnValue = Encoding.Unicode.GetString (byteArray' 2' byteArray.Length - 2);  else if (byteArray [0] == 0xFE && byteArray [1] == 0xFF)  	returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 2' byteArray.Length - 2);  else  	returnValue = Encoding.Unicode.GetString (byteArray' 0' byteArray.Length);  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Utils,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\ID3v2Utils.cs,ReadString,The following statement contains a magic number: returnValue = Encoding.Unicode.GetString (byteArray' 2' byteArray.Length - 2);  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Utils,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\ID3v2Utils.cs,ReadString,The following statement contains a magic number: returnValue = Encoding.Unicode.GetString (byteArray' 2' byteArray.Length - 2);  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Utils,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\ID3v2Utils.cs,ReadString,The following statement contains a magic number: if (byteArray [0] == 0xFE && byteArray [1] == 0xFF)  	returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 2' byteArray.Length - 2);  else  	returnValue = Encoding.Unicode.GetString (byteArray' 0' byteArray.Length);  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Utils,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\ID3v2Utils.cs,ReadString,The following statement contains a magic number: if (byteArray [0] == 0xFE && byteArray [1] == 0xFF)  	returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 2' byteArray.Length - 2);  else  	returnValue = Encoding.Unicode.GetString (byteArray' 0' byteArray.Length);  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Utils,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\ID3v2Utils.cs,ReadString,The following statement contains a magic number: returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 2' byteArray.Length - 2);  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Utils,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\ID3v2Utils.cs,ReadString,The following statement contains a magic number: returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 2' byteArray.Length - 2);  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Utils,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\ID3v2Utils.cs,ReadString,The following statement contains a magic number: if (textEncoding == EncodingType.UTF16BE) {  	byte byte1;  	byte byte2;  	do {  		byte1 = stream.Read1 ();  		byteList.Add (byte1);  		--bytesLeft;  		if (bytesLeft == 0) {  			//String msg = String.Format("End of frame reached while reading unknown length string at position {0}"' stream.Position);  			//Trace.WriteLine(msg);  			return "";  		}  		byte2 = stream.Read1 ();  		byteList.Add (byte2);  		--bytesLeft;  		if (bytesLeft == 0) {  			//String msg = String.Format("End of frame reached while reading unknown length string at position {0}"' stream.Position);  			//Trace.WriteLine(msg);  			break;  			//return "";  		}  	} while (byte1 != 0 || byte2 != 0);  	byte[] byteArray = byteList.ToArray ();  	if (byteArray.Length >= 2) {  		// If BOM is part of the string' remove before decoding.  		if (byteArray [0] == 0xFE && byteArray [1] == 0xFF)  			returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 2' byteArray.Length - 2);  		else  			returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 0' byteArray.Length);  	} else {  		returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 0' byteArray.Length);  	}  } else if (textEncoding == EncodingType.UTF8) {  	byte readByte = stream.Read1 ();  	--bytesLeft;  	if (bytesLeft == 0) {  		//String msg = String.Format("End of frame reached while reading unknown length string at position {0}"' stream.Position);  		//Trace.WriteLine(msg);  		return "";  	}  	while (readByte != 0) {  		byteList.Add (readByte);  		readByte = stream.Read1 ();  		--bytesLeft;  		if (bytesLeft == 0) {  			//String msg = String.Format("End of frame reached while reading unknown length string at position {0}"' stream.Position);  			//Trace.WriteLine(msg);  			return "";  		}  	}  	returnValue = Encoding.UTF8.GetString (byteList.ToArray ());  } else {  	// Most likely bad data  	string msg = string.Format ("Text Encoding '{0}' unknown at position {1}"' textEncoding' stream.Position);  	Trace.WriteLine (msg);  	return "";  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Utils,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\ID3v2Utils.cs,ReadString,The following statement contains a magic number: if (textEncoding == EncodingType.UTF16BE) {  	byte byte1;  	byte byte2;  	do {  		byte1 = stream.Read1 ();  		byteList.Add (byte1);  		--bytesLeft;  		if (bytesLeft == 0) {  			//String msg = String.Format("End of frame reached while reading unknown length string at position {0}"' stream.Position);  			//Trace.WriteLine(msg);  			return "";  		}  		byte2 = stream.Read1 ();  		byteList.Add (byte2);  		--bytesLeft;  		if (bytesLeft == 0) {  			//String msg = String.Format("End of frame reached while reading unknown length string at position {0}"' stream.Position);  			//Trace.WriteLine(msg);  			break;  			//return "";  		}  	} while (byte1 != 0 || byte2 != 0);  	byte[] byteArray = byteList.ToArray ();  	if (byteArray.Length >= 2) {  		// If BOM is part of the string' remove before decoding.  		if (byteArray [0] == 0xFE && byteArray [1] == 0xFF)  			returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 2' byteArray.Length - 2);  		else  			returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 0' byteArray.Length);  	} else {  		returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 0' byteArray.Length);  	}  } else if (textEncoding == EncodingType.UTF8) {  	byte readByte = stream.Read1 ();  	--bytesLeft;  	if (bytesLeft == 0) {  		//String msg = String.Format("End of frame reached while reading unknown length string at position {0}"' stream.Position);  		//Trace.WriteLine(msg);  		return "";  	}  	while (readByte != 0) {  		byteList.Add (readByte);  		readByte = stream.Read1 ();  		--bytesLeft;  		if (bytesLeft == 0) {  			//String msg = String.Format("End of frame reached while reading unknown length string at position {0}"' stream.Position);  			//Trace.WriteLine(msg);  			return "";  		}  	}  	returnValue = Encoding.UTF8.GetString (byteList.ToArray ());  } else {  	// Most likely bad data  	string msg = string.Format ("Text Encoding '{0}' unknown at position {1}"' textEncoding' stream.Position);  	Trace.WriteLine (msg);  	return "";  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Utils,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\ID3v2Utils.cs,ReadString,The following statement contains a magic number: if (textEncoding == EncodingType.UTF16BE) {  	byte byte1;  	byte byte2;  	do {  		byte1 = stream.Read1 ();  		byteList.Add (byte1);  		--bytesLeft;  		if (bytesLeft == 0) {  			//String msg = String.Format("End of frame reached while reading unknown length string at position {0}"' stream.Position);  			//Trace.WriteLine(msg);  			return "";  		}  		byte2 = stream.Read1 ();  		byteList.Add (byte2);  		--bytesLeft;  		if (bytesLeft == 0) {  			//String msg = String.Format("End of frame reached while reading unknown length string at position {0}"' stream.Position);  			//Trace.WriteLine(msg);  			break;  			//return "";  		}  	} while (byte1 != 0 || byte2 != 0);  	byte[] byteArray = byteList.ToArray ();  	if (byteArray.Length >= 2) {  		// If BOM is part of the string' remove before decoding.  		if (byteArray [0] == 0xFE && byteArray [1] == 0xFF)  			returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 2' byteArray.Length - 2);  		else  			returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 0' byteArray.Length);  	} else {  		returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 0' byteArray.Length);  	}  } else if (textEncoding == EncodingType.UTF8) {  	byte readByte = stream.Read1 ();  	--bytesLeft;  	if (bytesLeft == 0) {  		//String msg = String.Format("End of frame reached while reading unknown length string at position {0}"' stream.Position);  		//Trace.WriteLine(msg);  		return "";  	}  	while (readByte != 0) {  		byteList.Add (readByte);  		readByte = stream.Read1 ();  		--bytesLeft;  		if (bytesLeft == 0) {  			//String msg = String.Format("End of frame reached while reading unknown length string at position {0}"' stream.Position);  			//Trace.WriteLine(msg);  			return "";  		}  	}  	returnValue = Encoding.UTF8.GetString (byteList.ToArray ());  } else {  	// Most likely bad data  	string msg = string.Format ("Text Encoding '{0}' unknown at position {1}"' textEncoding' stream.Position);  	Trace.WriteLine (msg);  	return "";  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Utils,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\ID3v2Utils.cs,ReadString,The following statement contains a magic number: if (byteArray.Length >= 2) {  	// If BOM is part of the string' remove before decoding.  	if (byteArray [0] == 0xFE && byteArray [1] == 0xFF)  		returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 2' byteArray.Length - 2);  	else  		returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 0' byteArray.Length);  } else {  	returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 0' byteArray.Length);  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Utils,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\ID3v2Utils.cs,ReadString,The following statement contains a magic number: if (byteArray.Length >= 2) {  	// If BOM is part of the string' remove before decoding.  	if (byteArray [0] == 0xFE && byteArray [1] == 0xFF)  		returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 2' byteArray.Length - 2);  	else  		returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 0' byteArray.Length);  } else {  	returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 0' byteArray.Length);  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Utils,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\ID3v2Utils.cs,ReadString,The following statement contains a magic number: if (byteArray.Length >= 2) {  	// If BOM is part of the string' remove before decoding.  	if (byteArray [0] == 0xFE && byteArray [1] == 0xFF)  		returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 2' byteArray.Length - 2);  	else  		returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 0' byteArray.Length);  } else {  	returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 0' byteArray.Length);  }  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Utils,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\ID3v2Utils.cs,ReadString,The following statement contains a magic number: if (byteArray [0] == 0xFE && byteArray [1] == 0xFF)  	returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 2' byteArray.Length - 2);  else  	returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 0' byteArray.Length);  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Utils,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\ID3v2Utils.cs,ReadString,The following statement contains a magic number: if (byteArray [0] == 0xFE && byteArray [1] == 0xFF)  	returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 2' byteArray.Length - 2);  else  	returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 0' byteArray.Length);  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Utils,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\ID3v2Utils.cs,ReadString,The following statement contains a magic number: returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 2' byteArray.Length - 2);  
Magic Number,IdSharp.Tagging.ID3v2,ID3v2Utils,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\ID3v2Utils.cs,ReadString,The following statement contains a magic number: returnValue = Encoding.BigEndianUnicode.GetString (byteArray' 2' byteArray.Length - 2);  
Magic Number,IdSharp.Tagging.ID3v2.Frames,AudioEncryption,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\Frames\AudioEncryption.cs,Read,The following statement contains a magic number: if (bytesLeft > 0) {  	OwnerIdentifier = ID3v2Utils.ReadString (EncodingType.ISO88591' stream' ref bytesLeft);  	if (bytesLeft >= 4) {  		PreviewStart = stream.ReadInt16 (ref bytesLeft);  		PreviewLength = stream.ReadInt16 (ref bytesLeft);  		if (bytesLeft > 0) {  			EncryptionInfo = stream.Read (bytesLeft);  			bytesLeft = 0;  		} else {  			// Incomplete frame  			EncryptionInfo = null;  		}  	} else {  		// Incomplete frame  		PreviewStart = 0;  		PreviewLength = 0;  		EncryptionInfo = null;  	}  } else {  	// Incomplete frame  	OwnerIdentifier = null;  	PreviewStart = 0;  	PreviewLength = 0;  	EncryptionInfo = null;  }  
Magic Number,IdSharp.Tagging.ID3v2.Frames,AudioEncryption,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\Frames\AudioEncryption.cs,Read,The following statement contains a magic number: if (bytesLeft >= 4) {  	PreviewStart = stream.ReadInt16 (ref bytesLeft);  	PreviewLength = stream.ReadInt16 (ref bytesLeft);  	if (bytesLeft > 0) {  		EncryptionInfo = stream.Read (bytesLeft);  		bytesLeft = 0;  	} else {  		// Incomplete frame  		EncryptionInfo = null;  	}  } else {  	// Incomplete frame  	PreviewStart = 0;  	PreviewLength = 0;  	EncryptionInfo = null;  }  
Magic Number,IdSharp.Tagging.ID3v2.Frames,AudioText,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\Frames\AudioText.cs,AudioText,The following statement contains a magic number: _scrambleTable = new byte[127];  
Magic Number,IdSharp.Tagging.ID3v2.Frames,AudioText,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\Frames\AudioText.cs,Scramble,The following statement contains a magic number: for (int i = 0' j = 0; i < audioData.Length; i++' j++) {  	newAudioData [i] = (byte)(audioData [i] ^ _scrambleTable [j]);  	if (j == 126)  		j = -1;  }  
Magic Number,IdSharp.Tagging.ID3v2.Frames,AudioText,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\Frames\AudioText.cs,Scramble,The following statement contains a magic number: if (j == 126)  	j = -1;  
Magic Number,IdSharp.Tagging.ID3v2.Frames,Comments,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\Frames\Comments.cs,Read,The following statement contains a magic number: if (_frameHeader.FrameSizeExcludingAdditions >= 1) {  	TextEncoding = (EncodingType)stream.Read1 ();  	// TODO: A common mis-implementation is to exclude the language code and description  	// Haven't decided how to handle this yet.  Maybe if a lookup to the language table fails'  	// the rest of the frame should be treated as suspicious.  	if (_frameHeader.FrameSizeExcludingAdditions >= 4) {  		string languageCode = ID3v2Utils.ReadString (EncodingType.ISO88591' stream' 3);  		int bytesLeft = _frameHeader.FrameSizeExcludingAdditions - 1 - 3;  		string description = ID3v2Utils.ReadString (TextEncoding' stream' ref bytesLeft);  		bool invalidFrame = false;  		if (LanguageHelper.Languages.ContainsKey (languageCode.ToLower ()) == false && languageCode.ToLower () != "xxx") {  			// most likely' it's en\0' or some other funk  			if (languageCode.StartsWith ("en")) {  				languageCode = "";  			}  			invalidFrame = true;  			if (bytesLeft == 0) {  				Description = "";  			} else {  				Description = languageCode + description;  			}  			LanguageCode = "eng";  		} else {  			LanguageCode = languageCode;  			Description = description;  		}  		if (bytesLeft > 0) {  			Value = ID3v2Utils.ReadString (TextEncoding' stream' bytesLeft);  		} else {  			if (invalidFrame) {  				if (languageCode.Contains ("\0")) {  					// forget it' too messed up.  					Value = "";  				} else {  					Value = languageCode + description;  				}  			} else {  				Value = "";  			}  		}  	} else {  		string msg = string.Format ("Under-sized ({0} bytes) COMM frame at position {1}"' _frameHeader.FrameSizeExcludingAdditions' stream.Position);  		Trace.WriteLine (msg);  		LanguageCode = "eng";  		Value = "";  	}  } else {  	string msg = string.Format ("Under-sized ({0} bytes) COMM frame at position {1}"' _frameHeader.FrameSizeExcludingAdditions' stream.Position);  	Trace.WriteLine (msg);  	LanguageCode = "eng";  	Value = "";  }  
Magic Number,IdSharp.Tagging.ID3v2.Frames,Comments,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\Frames\Comments.cs,Read,The following statement contains a magic number: if (_frameHeader.FrameSizeExcludingAdditions >= 1) {  	TextEncoding = (EncodingType)stream.Read1 ();  	// TODO: A common mis-implementation is to exclude the language code and description  	// Haven't decided how to handle this yet.  Maybe if a lookup to the language table fails'  	// the rest of the frame should be treated as suspicious.  	if (_frameHeader.FrameSizeExcludingAdditions >= 4) {  		string languageCode = ID3v2Utils.ReadString (EncodingType.ISO88591' stream' 3);  		int bytesLeft = _frameHeader.FrameSizeExcludingAdditions - 1 - 3;  		string description = ID3v2Utils.ReadString (TextEncoding' stream' ref bytesLeft);  		bool invalidFrame = false;  		if (LanguageHelper.Languages.ContainsKey (languageCode.ToLower ()) == false && languageCode.ToLower () != "xxx") {  			// most likely' it's en\0' or some other funk  			if (languageCode.StartsWith ("en")) {  				languageCode = "";  			}  			invalidFrame = true;  			if (bytesLeft == 0) {  				Description = "";  			} else {  				Description = languageCode + description;  			}  			LanguageCode = "eng";  		} else {  			LanguageCode = languageCode;  			Description = description;  		}  		if (bytesLeft > 0) {  			Value = ID3v2Utils.ReadString (TextEncoding' stream' bytesLeft);  		} else {  			if (invalidFrame) {  				if (languageCode.Contains ("\0")) {  					// forget it' too messed up.  					Value = "";  				} else {  					Value = languageCode + description;  				}  			} else {  				Value = "";  			}  		}  	} else {  		string msg = string.Format ("Under-sized ({0} bytes) COMM frame at position {1}"' _frameHeader.FrameSizeExcludingAdditions' stream.Position);  		Trace.WriteLine (msg);  		LanguageCode = "eng";  		Value = "";  	}  } else {  	string msg = string.Format ("Under-sized ({0} bytes) COMM frame at position {1}"' _frameHeader.FrameSizeExcludingAdditions' stream.Position);  	Trace.WriteLine (msg);  	LanguageCode = "eng";  	Value = "";  }  
Magic Number,IdSharp.Tagging.ID3v2.Frames,Comments,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\Frames\Comments.cs,Read,The following statement contains a magic number: if (_frameHeader.FrameSizeExcludingAdditions >= 1) {  	TextEncoding = (EncodingType)stream.Read1 ();  	// TODO: A common mis-implementation is to exclude the language code and description  	// Haven't decided how to handle this yet.  Maybe if a lookup to the language table fails'  	// the rest of the frame should be treated as suspicious.  	if (_frameHeader.FrameSizeExcludingAdditions >= 4) {  		string languageCode = ID3v2Utils.ReadString (EncodingType.ISO88591' stream' 3);  		int bytesLeft = _frameHeader.FrameSizeExcludingAdditions - 1 - 3;  		string description = ID3v2Utils.ReadString (TextEncoding' stream' ref bytesLeft);  		bool invalidFrame = false;  		if (LanguageHelper.Languages.ContainsKey (languageCode.ToLower ()) == false && languageCode.ToLower () != "xxx") {  			// most likely' it's en\0' or some other funk  			if (languageCode.StartsWith ("en")) {  				languageCode = "";  			}  			invalidFrame = true;  			if (bytesLeft == 0) {  				Description = "";  			} else {  				Description = languageCode + description;  			}  			LanguageCode = "eng";  		} else {  			LanguageCode = languageCode;  			Description = description;  		}  		if (bytesLeft > 0) {  			Value = ID3v2Utils.ReadString (TextEncoding' stream' bytesLeft);  		} else {  			if (invalidFrame) {  				if (languageCode.Contains ("\0")) {  					// forget it' too messed up.  					Value = "";  				} else {  					Value = languageCode + description;  				}  			} else {  				Value = "";  			}  		}  	} else {  		string msg = string.Format ("Under-sized ({0} bytes) COMM frame at position {1}"' _frameHeader.FrameSizeExcludingAdditions' stream.Position);  		Trace.WriteLine (msg);  		LanguageCode = "eng";  		Value = "";  	}  } else {  	string msg = string.Format ("Under-sized ({0} bytes) COMM frame at position {1}"' _frameHeader.FrameSizeExcludingAdditions' stream.Position);  	Trace.WriteLine (msg);  	LanguageCode = "eng";  	Value = "";  }  
Magic Number,IdSharp.Tagging.ID3v2.Frames,Comments,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\Frames\Comments.cs,Read,The following statement contains a magic number: if (_frameHeader.FrameSizeExcludingAdditions >= 4) {  	string languageCode = ID3v2Utils.ReadString (EncodingType.ISO88591' stream' 3);  	int bytesLeft = _frameHeader.FrameSizeExcludingAdditions - 1 - 3;  	string description = ID3v2Utils.ReadString (TextEncoding' stream' ref bytesLeft);  	bool invalidFrame = false;  	if (LanguageHelper.Languages.ContainsKey (languageCode.ToLower ()) == false && languageCode.ToLower () != "xxx") {  		// most likely' it's en\0' or some other funk  		if (languageCode.StartsWith ("en")) {  			languageCode = "";  		}  		invalidFrame = true;  		if (bytesLeft == 0) {  			Description = "";  		} else {  			Description = languageCode + description;  		}  		LanguageCode = "eng";  	} else {  		LanguageCode = languageCode;  		Description = description;  	}  	if (bytesLeft > 0) {  		Value = ID3v2Utils.ReadString (TextEncoding' stream' bytesLeft);  	} else {  		if (invalidFrame) {  			if (languageCode.Contains ("\0")) {  				// forget it' too messed up.  				Value = "";  			} else {  				Value = languageCode + description;  			}  		} else {  			Value = "";  		}  	}  } else {  	string msg = string.Format ("Under-sized ({0} bytes) COMM frame at position {1}"' _frameHeader.FrameSizeExcludingAdditions' stream.Position);  	Trace.WriteLine (msg);  	LanguageCode = "eng";  	Value = "";  }  
Magic Number,IdSharp.Tagging.ID3v2.Frames,Comments,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\Frames\Comments.cs,Read,The following statement contains a magic number: if (_frameHeader.FrameSizeExcludingAdditions >= 4) {  	string languageCode = ID3v2Utils.ReadString (EncodingType.ISO88591' stream' 3);  	int bytesLeft = _frameHeader.FrameSizeExcludingAdditions - 1 - 3;  	string description = ID3v2Utils.ReadString (TextEncoding' stream' ref bytesLeft);  	bool invalidFrame = false;  	if (LanguageHelper.Languages.ContainsKey (languageCode.ToLower ()) == false && languageCode.ToLower () != "xxx") {  		// most likely' it's en\0' or some other funk  		if (languageCode.StartsWith ("en")) {  			languageCode = "";  		}  		invalidFrame = true;  		if (bytesLeft == 0) {  			Description = "";  		} else {  			Description = languageCode + description;  		}  		LanguageCode = "eng";  	} else {  		LanguageCode = languageCode;  		Description = description;  	}  	if (bytesLeft > 0) {  		Value = ID3v2Utils.ReadString (TextEncoding' stream' bytesLeft);  	} else {  		if (invalidFrame) {  			if (languageCode.Contains ("\0")) {  				// forget it' too messed up.  				Value = "";  			} else {  				Value = languageCode + description;  			}  		} else {  			Value = "";  		}  	}  } else {  	string msg = string.Format ("Under-sized ({0} bytes) COMM frame at position {1}"' _frameHeader.FrameSizeExcludingAdditions' stream.Position);  	Trace.WriteLine (msg);  	LanguageCode = "eng";  	Value = "";  }  
Magic Number,IdSharp.Tagging.ID3v2.Frames,Comments,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\Frames\Comments.cs,Read,The following statement contains a magic number: if (_frameHeader.FrameSizeExcludingAdditions >= 4) {  	string languageCode = ID3v2Utils.ReadString (EncodingType.ISO88591' stream' 3);  	int bytesLeft = _frameHeader.FrameSizeExcludingAdditions - 1 - 3;  	string description = ID3v2Utils.ReadString (TextEncoding' stream' ref bytesLeft);  	bool invalidFrame = false;  	if (LanguageHelper.Languages.ContainsKey (languageCode.ToLower ()) == false && languageCode.ToLower () != "xxx") {  		// most likely' it's en\0' or some other funk  		if (languageCode.StartsWith ("en")) {  			languageCode = "";  		}  		invalidFrame = true;  		if (bytesLeft == 0) {  			Description = "";  		} else {  			Description = languageCode + description;  		}  		LanguageCode = "eng";  	} else {  		LanguageCode = languageCode;  		Description = description;  	}  	if (bytesLeft > 0) {  		Value = ID3v2Utils.ReadString (TextEncoding' stream' bytesLeft);  	} else {  		if (invalidFrame) {  			if (languageCode.Contains ("\0")) {  				// forget it' too messed up.  				Value = "";  			} else {  				Value = languageCode + description;  			}  		} else {  			Value = "";  		}  	}  } else {  	string msg = string.Format ("Under-sized ({0} bytes) COMM frame at position {1}"' _frameHeader.FrameSizeExcludingAdditions' stream.Position);  	Trace.WriteLine (msg);  	LanguageCode = "eng";  	Value = "";  }  
Magic Number,IdSharp.Tagging.ID3v2.Frames,Comments,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\Frames\Comments.cs,GetBytes,The following statement contains a magic number: if (LanguageCode == null || LanguageCode.Length != 3)  	LanguageCode = "eng";  
Magic Number,IdSharp.Tagging.ID3v2.Frames,Commercial,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\Frames\Commercial.cs,Read,The following statement contains a magic number: if (bytesLeft > 1) {  	TextEncoding = (EncodingType)stream.Read1 (ref bytesLeft);  	string priceString = ID3v2Utils.ReadString (EncodingType.ISO88591' stream' ref bytesLeft);  	if (!string.IsNullOrEmpty (priceString)) {  		foreach (string priceItem in priceString.Split ('/')) {  			if (priceItem.Length > 3) {  				decimal price;  				string pricePart = priceItem.Substring (3' priceItem.Length - 3);  				if (decimal.TryParse (pricePart' System.Globalization.NumberStyles.Any' System.Globalization.NumberFormatInfo.InvariantInfo' out price)) {  					IPriceInformation priceInfo = new PriceInformation ();  					priceInfo.CurrencyCode = priceItem.Substring (0' 3);  					priceInfo.Price = price;  					_priceList.Add (priceInfo);  				}  			}  		}  	}  	if (bytesLeft > 0) {  		string validUntil = ID3v2Utils.ReadString (EncodingType.ISO88591' stream' 8);  		bytesLeft -= 8;  		if (validUntil.Length == 8) {  			validUntil = string.Format ("{0}-{1}-{2}"' validUntil.Substring (0' 4)' validUntil.Substring (4' 2)' validUntil.Substring (6' 2));  			DateTime.TryParse (validUntil' out _validUntil);  		}  		if (bytesLeft > 0) {  			ContactUrl = ID3v2Utils.ReadString (EncodingType.ISO88591' stream' ref bytesLeft);  			if (bytesLeft > 0) {  				ReceivedAs = (ReceivedAs)stream.Read1 (ref bytesLeft);  				NameOfSeller = ID3v2Utils.ReadString (TextEncoding' stream' ref bytesLeft);  				Description = ID3v2Utils.ReadString (TextEncoding' stream' ref bytesLeft);  				SellerLogoMimeType = ID3v2Utils.ReadString (EncodingType.ISO88591' stream' ref bytesLeft);  				if (bytesLeft > 0) {  					SellerLogo = stream.Read (bytesLeft);  					bytesLeft = 0;  				}  			}  		}  	}  }  
Magic Number,IdSharp.Tagging.ID3v2.Frames,Commercial,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\Frames\Commercial.cs,Read,The following statement contains a magic number: if (bytesLeft > 1) {  	TextEncoding = (EncodingType)stream.Read1 (ref bytesLeft);  	string priceString = ID3v2Utils.ReadString (EncodingType.ISO88591' stream' ref bytesLeft);  	if (!string.IsNullOrEmpty (priceString)) {  		foreach (string priceItem in priceString.Split ('/')) {  			if (priceItem.Length > 3) {  				decimal price;  				string pricePart = priceItem.Substring (3' priceItem.Length - 3);  				if (decimal.TryParse (pricePart' System.Globalization.NumberStyles.Any' System.Globalization.NumberFormatInfo.InvariantInfo' out price)) {  					IPriceInformation priceInfo = new PriceInformation ();  					priceInfo.CurrencyCode = priceItem.Substring (0' 3);  					priceInfo.Price = price;  					_priceList.Add (priceInfo);  				}  			}  		}  	}  	if (bytesLeft > 0) {  		string validUntil = ID3v2Utils.ReadString (EncodingType.ISO88591' stream' 8);  		bytesLeft -= 8;  		if (validUntil.Length == 8) {  			validUntil = string.Format ("{0}-{1}-{2}"' validUntil.Substring (0' 4)' validUntil.Substring (4' 2)' validUntil.Substring (6' 2));  			DateTime.TryParse (validUntil' out _validUntil);  		}  		if (bytesLeft > 0) {  			ContactUrl = ID3v2Utils.ReadString (EncodingType.ISO88591' stream' ref bytesLeft);  			if (bytesLeft > 0) {  				ReceivedAs = (ReceivedAs)stream.Read1 (ref bytesLeft);  				NameOfSeller = ID3v2Utils.ReadString (TextEncoding' stream' ref bytesLeft);  				Description = ID3v2Utils.ReadString (TextEncoding' stream' ref bytesLeft);  				SellerLogoMimeType = ID3v2Utils.ReadString (EncodingType.ISO88591' stream' ref bytesLeft);  				if (bytesLeft > 0) {  					SellerLogo = stream.Read (bytesLeft);  					bytesLeft = 0;  				}  			}  		}  	}  }  
Magic Number,IdSharp.Tagging.ID3v2.Frames,Commercial,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\Frames\Commercial.cs,Read,The following statement contains a magic number: if (bytesLeft > 1) {  	TextEncoding = (EncodingType)stream.Read1 (ref bytesLeft);  	string priceString = ID3v2Utils.ReadString (EncodingType.ISO88591' stream' ref bytesLeft);  	if (!string.IsNullOrEmpty (priceString)) {  		foreach (string priceItem in priceString.Split ('/')) {  			if (priceItem.Length > 3) {  				decimal price;  				string pricePart = priceItem.Substring (3' priceItem.Length - 3);  				if (decimal.TryParse (pricePart' System.Globalization.NumberStyles.Any' System.Globalization.NumberFormatInfo.InvariantInfo' out price)) {  					IPriceInformation priceInfo = new PriceInformation ();  					priceInfo.CurrencyCode = priceItem.Substring (0' 3);  					priceInfo.Price = price;  					_priceList.Add (priceInfo);  				}  			}  		}  	}  	if (bytesLeft > 0) {  		string validUntil = ID3v2Utils.ReadString (EncodingType.ISO88591' stream' 8);  		bytesLeft -= 8;  		if (validUntil.Length == 8) {  			validUntil = string.Format ("{0}-{1}-{2}"' validUntil.Substring (0' 4)' validUntil.Substring (4' 2)' validUntil.Substring (6' 2));  			DateTime.TryParse (validUntil' out _validUntil);  		}  		if (bytesLeft > 0) {  			ContactUrl = ID3v2Utils.ReadString (EncodingType.ISO88591' stream' ref bytesLeft);  			if (bytesLeft > 0) {  				ReceivedAs = (ReceivedAs)stream.Read1 (ref bytesLeft);  				NameOfSeller = ID3v2Utils.ReadString (TextEncoding' stream' ref bytesLeft);  				Description = ID3v2Utils.ReadString (TextEncoding' stream' ref bytesLeft);  				SellerLogoMimeType = ID3v2Utils.ReadString (EncodingType.ISO88591' stream' ref bytesLeft);  				if (bytesLeft > 0) {  					SellerLogo = stream.Read (bytesLeft);  					bytesLeft = 0;  				}  			}  		}  	}  }  
Magic Number,IdSharp.Tagging.ID3v2.Frames,Commercial,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\Frames\Commercial.cs,Read,The following statement contains a magic number: if (bytesLeft > 1) {  	TextEncoding = (EncodingType)stream.Read1 (ref bytesLeft);  	string priceString = ID3v2Utils.ReadString (EncodingType.ISO88591' stream' ref bytesLeft);  	if (!string.IsNullOrEmpty (priceString)) {  		foreach (string priceItem in priceString.Split ('/')) {  			if (priceItem.Length > 3) {  				decimal price;  				string pricePart = priceItem.Substring (3' priceItem.Length - 3);  				if (decimal.TryParse (pricePart' System.Globalization.NumberStyles.Any' System.Globalization.NumberFormatInfo.InvariantInfo' out price)) {  					IPriceInformation priceInfo = new PriceInformation ();  					priceInfo.CurrencyCode = priceItem.Substring (0' 3);  					priceInfo.Price = price;  					_priceList.Add (priceInfo);  				}  			}  		}  	}  	if (bytesLeft > 0) {  		string validUntil = ID3v2Utils.ReadString (EncodingType.ISO88591' stream' 8);  		bytesLeft -= 8;  		if (validUntil.Length == 8) {  			validUntil = string.Format ("{0}-{1}-{2}"' validUntil.Substring (0' 4)' validUntil.Substring (4' 2)' validUntil.Substring (6' 2));  			DateTime.TryParse (validUntil' out _validUntil);  		}  		if (bytesLeft > 0) {  			ContactUrl = ID3v2Utils.ReadString (EncodingType.ISO88591' stream' ref bytesLeft);  			if (bytesLeft > 0) {  				ReceivedAs = (ReceivedAs)stream.Read1 (ref bytesLeft);  				NameOfSeller = ID3v2Utils.ReadString (TextEncoding' stream' ref bytesLeft);  				Description = ID3v2Utils.ReadString (TextEncoding' stream' ref bytesLeft);  				SellerLogoMimeType = ID3v2Utils.ReadString (EncodingType.ISO88591' stream' ref bytesLeft);  				if (bytesLeft > 0) {  					SellerLogo = stream.Read (bytesLeft);  					bytesLeft = 0;  				}  			}  		}  	}  }  
Magic Number,IdSharp.Tagging.ID3v2.Frames,Commercial,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\Frames\Commercial.cs,Read,The following statement contains a magic number: if (bytesLeft > 1) {  	TextEncoding = (EncodingType)stream.Read1 (ref bytesLeft);  	string priceString = ID3v2Utils.ReadString (EncodingType.ISO88591' stream' ref bytesLeft);  	if (!string.IsNullOrEmpty (priceString)) {  		foreach (string priceItem in priceString.Split ('/')) {  			if (priceItem.Length > 3) {  				decimal price;  				string pricePart = priceItem.Substring (3' priceItem.Length - 3);  				if (decimal.TryParse (pricePart' System.Globalization.NumberStyles.Any' System.Globalization.NumberFormatInfo.InvariantInfo' out price)) {  					IPriceInformation priceInfo = new PriceInformation ();  					priceInfo.CurrencyCode = priceItem.Substring (0' 3);  					priceInfo.Price = price;  					_priceList.Add (priceInfo);  				}  			}  		}  	}  	if (bytesLeft > 0) {  		string validUntil = ID3v2Utils.ReadString (EncodingType.ISO88591' stream' 8);  		bytesLeft -= 8;  		if (validUntil.Length == 8) {  			validUntil = string.Format ("{0}-{1}-{2}"' validUntil.Substring (0' 4)' validUntil.Substring (4' 2)' validUntil.Substring (6' 2));  			DateTime.TryParse (validUntil' out _validUntil);  		}  		if (bytesLeft > 0) {  			ContactUrl = ID3v2Utils.ReadString (EncodingType.ISO88591' stream' ref bytesLeft);  			if (bytesLeft > 0) {  				ReceivedAs = (ReceivedAs)stream.Read1 (ref bytesLeft);  				NameOfSeller = ID3v2Utils.ReadString (TextEncoding' stream' ref bytesLeft);  				Description = ID3v2Utils.ReadString (TextEncoding' stream' ref bytesLeft);  				SellerLogoMimeType = ID3v2Utils.ReadString (EncodingType.ISO88591' stream' ref bytesLeft);  				if (bytesLeft > 0) {  					SellerLogo = stream.Read (bytesLeft);  					bytesLeft = 0;  				}  			}  		}  	}  }  
Magic Number,IdSharp.Tagging.ID3v2.Frames,Commercial,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\Frames\Commercial.cs,Read,The following statement contains a magic number: if (bytesLeft > 1) {  	TextEncoding = (EncodingType)stream.Read1 (ref bytesLeft);  	string priceString = ID3v2Utils.ReadString (EncodingType.ISO88591' stream' ref bytesLeft);  	if (!string.IsNullOrEmpty (priceString)) {  		foreach (string priceItem in priceString.Split ('/')) {  			if (priceItem.Length > 3) {  				decimal price;  				string pricePart = priceItem.Substring (3' priceItem.Length - 3);  				if (decimal.TryParse (pricePart' System.Globalization.NumberStyles.Any' System.Globalization.NumberFormatInfo.InvariantInfo' out price)) {  					IPriceInformation priceInfo = new PriceInformation ();  					priceInfo.CurrencyCode = priceItem.Substring (0' 3);  					priceInfo.Price = price;  					_priceList.Add (priceInfo);  				}  			}  		}  	}  	if (bytesLeft > 0) {  		string validUntil = ID3v2Utils.ReadString (EncodingType.ISO88591' stream' 8);  		bytesLeft -= 8;  		if (validUntil.Length == 8) {  			validUntil = string.Format ("{0}-{1}-{2}"' validUntil.Substring (0' 4)' validUntil.Substring (4' 2)' validUntil.Substring (6' 2));  			DateTime.TryParse (validUntil' out _validUntil);  		}  		if (bytesLeft > 0) {  			ContactUrl = ID3v2Utils.ReadString (EncodingType.ISO88591' stream' ref bytesLeft);  			if (bytesLeft > 0) {  				ReceivedAs = (ReceivedAs)stream.Read1 (ref bytesLeft);  				NameOfSeller = ID3v2Utils.ReadString (TextEncoding' stream' ref bytesLeft);  				Description = ID3v2Utils.ReadString (TextEncoding' stream' ref bytesLeft);  				SellerLogoMimeType = ID3v2Utils.ReadString (EncodingType.ISO88591' stream' ref bytesLeft);  				if (bytesLeft > 0) {  					SellerLogo = stream.Read (bytesLeft);  					bytesLeft = 0;  				}  			}  		}  	}  }  
Magic Number,IdSharp.Tagging.ID3v2.Frames,Commercial,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\Frames\Commercial.cs,Read,The following statement contains a magic number: if (bytesLeft > 1) {  	TextEncoding = (EncodingType)stream.Read1 (ref bytesLeft);  	string priceString = ID3v2Utils.ReadString (EncodingType.ISO88591' stream' ref bytesLeft);  	if (!string.IsNullOrEmpty (priceString)) {  		foreach (string priceItem in priceString.Split ('/')) {  			if (priceItem.Length > 3) {  				decimal price;  				string pricePart = priceItem.Substring (3' priceItem.Length - 3);  				if (decimal.TryParse (pricePart' System.Globalization.NumberStyles.Any' System.Globalization.NumberFormatInfo.InvariantInfo' out price)) {  					IPriceInformation priceInfo = new PriceInformation ();  					priceInfo.CurrencyCode = priceItem.Substring (0' 3);  					priceInfo.Price = price;  					_priceList.Add (priceInfo);  				}  			}  		}  	}  	if (bytesLeft > 0) {  		string validUntil = ID3v2Utils.ReadString (EncodingType.ISO88591' stream' 8);  		bytesLeft -= 8;  		if (validUntil.Length == 8) {  			validUntil = string.Format ("{0}-{1}-{2}"' validUntil.Substring (0' 4)' validUntil.Substring (4' 2)' validUntil.Substring (6' 2));  			DateTime.TryParse (validUntil' out _validUntil);  		}  		if (bytesLeft > 0) {  			ContactUrl = ID3v2Utils.ReadString (EncodingType.ISO88591' stream' ref bytesLeft);  			if (bytesLeft > 0) {  				ReceivedAs = (ReceivedAs)stream.Read1 (ref bytesLeft);  				NameOfSeller = ID3v2Utils.ReadString (TextEncoding' stream' ref bytesLeft);  				Description = ID3v2Utils.ReadString (TextEncoding' stream' ref bytesLeft);  				SellerLogoMimeType = ID3v2Utils.ReadString (EncodingType.ISO88591' stream' ref bytesLeft);  				if (bytesLeft > 0) {  					SellerLogo = stream.Read (bytesLeft);  					bytesLeft = 0;  				}  			}  		}  	}  }  
Magic Number,IdSharp.Tagging.ID3v2.Frames,Commercial,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\Frames\Commercial.cs,Read,The following statement contains a magic number: if (bytesLeft > 1) {  	TextEncoding = (EncodingType)stream.Read1 (ref bytesLeft);  	string priceString = ID3v2Utils.ReadString (EncodingType.ISO88591' stream' ref bytesLeft);  	if (!string.IsNullOrEmpty (priceString)) {  		foreach (string priceItem in priceString.Split ('/')) {  			if (priceItem.Length > 3) {  				decimal price;  				string pricePart = priceItem.Substring (3' priceItem.Length - 3);  				if (decimal.TryParse (pricePart' System.Globalization.NumberStyles.Any' System.Globalization.NumberFormatInfo.InvariantInfo' out price)) {  					IPriceInformation priceInfo = new PriceInformation ();  					priceInfo.CurrencyCode = priceItem.Substring (0' 3);  					priceInfo.Price = price;  					_priceList.Add (priceInfo);  				}  			}  		}  	}  	if (bytesLeft > 0) {  		string validUntil = ID3v2Utils.ReadString (EncodingType.ISO88591' stream' 8);  		bytesLeft -= 8;  		if (validUntil.Length == 8) {  			validUntil = string.Format ("{0}-{1}-{2}"' validUntil.Substring (0' 4)' validUntil.Substring (4' 2)' validUntil.Substring (6' 2));  			DateTime.TryParse (validUntil' out _validUntil);  		}  		if (bytesLeft > 0) {  			ContactUrl = ID3v2Utils.ReadString (EncodingType.ISO88591' stream' ref bytesLeft);  			if (bytesLeft > 0) {  				ReceivedAs = (ReceivedAs)stream.Read1 (ref bytesLeft);  				NameOfSeller = ID3v2Utils.ReadString (TextEncoding' stream' ref bytesLeft);  				Description = ID3v2Utils.ReadString (TextEncoding' stream' ref bytesLeft);  				SellerLogoMimeType = ID3v2Utils.ReadString (EncodingType.ISO88591' stream' ref bytesLeft);  				if (bytesLeft > 0) {  					SellerLogo = stream.Read (bytesLeft);  					bytesLeft = 0;  				}  			}  		}  	}  }  
Magic Number,IdSharp.Tagging.ID3v2.Frames,Commercial,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\Frames\Commercial.cs,Read,The following statement contains a magic number: if (bytesLeft > 1) {  	TextEncoding = (EncodingType)stream.Read1 (ref bytesLeft);  	string priceString = ID3v2Utils.ReadString (EncodingType.ISO88591' stream' ref bytesLeft);  	if (!string.IsNullOrEmpty (priceString)) {  		foreach (string priceItem in priceString.Split ('/')) {  			if (priceItem.Length > 3) {  				decimal price;  				string pricePart = priceItem.Substring (3' priceItem.Length - 3);  				if (decimal.TryParse (pricePart' System.Globalization.NumberStyles.Any' System.Globalization.NumberFormatInfo.InvariantInfo' out price)) {  					IPriceInformation priceInfo = new PriceInformation ();  					priceInfo.CurrencyCode = priceItem.Substring (0' 3);  					priceInfo.Price = price;  					_priceList.Add (priceInfo);  				}  			}  		}  	}  	if (bytesLeft > 0) {  		string validUntil = ID3v2Utils.ReadString (EncodingType.ISO88591' stream' 8);  		bytesLeft -= 8;  		if (validUntil.Length == 8) {  			validUntil = string.Format ("{0}-{1}-{2}"' validUntil.Substring (0' 4)' validUntil.Substring (4' 2)' validUntil.Substring (6' 2));  			DateTime.TryParse (validUntil' out _validUntil);  		}  		if (bytesLeft > 0) {  			ContactUrl = ID3v2Utils.ReadString (EncodingType.ISO88591' stream' ref bytesLeft);  			if (bytesLeft > 0) {  				ReceivedAs = (ReceivedAs)stream.Read1 (ref bytesLeft);  				NameOfSeller = ID3v2Utils.ReadString (TextEncoding' stream' ref bytesLeft);  				Description = ID3v2Utils.ReadString (TextEncoding' stream' ref bytesLeft);  				SellerLogoMimeType = ID3v2Utils.ReadString (EncodingType.ISO88591' stream' ref bytesLeft);  				if (bytesLeft > 0) {  					SellerLogo = stream.Read (bytesLeft);  					bytesLeft = 0;  				}  			}  		}  	}  }  
Magic Number,IdSharp.Tagging.ID3v2.Frames,Commercial,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\Frames\Commercial.cs,Read,The following statement contains a magic number: if (bytesLeft > 1) {  	TextEncoding = (EncodingType)stream.Read1 (ref bytesLeft);  	string priceString = ID3v2Utils.ReadString (EncodingType.ISO88591' stream' ref bytesLeft);  	if (!string.IsNullOrEmpty (priceString)) {  		foreach (string priceItem in priceString.Split ('/')) {  			if (priceItem.Length > 3) {  				decimal price;  				string pricePart = priceItem.Substring (3' priceItem.Length - 3);  				if (decimal.TryParse (pricePart' System.Globalization.NumberStyles.Any' System.Globalization.NumberFormatInfo.InvariantInfo' out price)) {  					IPriceInformation priceInfo = new PriceInformation ();  					priceInfo.CurrencyCode = priceItem.Substring (0' 3);  					priceInfo.Price = price;  					_priceList.Add (priceInfo);  				}  			}  		}  	}  	if (bytesLeft > 0) {  		string validUntil = ID3v2Utils.ReadString (EncodingType.ISO88591' stream' 8);  		bytesLeft -= 8;  		if (validUntil.Length == 8) {  			validUntil = string.Format ("{0}-{1}-{2}"' validUntil.Substring (0' 4)' validUntil.Substring (4' 2)' validUntil.Substring (6' 2));  			DateTime.TryParse (validUntil' out _validUntil);  		}  		if (bytesLeft > 0) {  			ContactUrl = ID3v2Utils.ReadString (EncodingType.ISO88591' stream' ref bytesLeft);  			if (bytesLeft > 0) {  				ReceivedAs = (ReceivedAs)stream.Read1 (ref bytesLeft);  				NameOfSeller = ID3v2Utils.ReadString (TextEncoding' stream' ref bytesLeft);  				Description = ID3v2Utils.ReadString (TextEncoding' stream' ref bytesLeft);  				SellerLogoMimeType = ID3v2Utils.ReadString (EncodingType.ISO88591' stream' ref bytesLeft);  				if (bytesLeft > 0) {  					SellerLogo = stream.Read (bytesLeft);  					bytesLeft = 0;  				}  			}  		}  	}  }  
Magic Number,IdSharp.Tagging.ID3v2.Frames,Commercial,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\Frames\Commercial.cs,Read,The following statement contains a magic number: if (bytesLeft > 1) {  	TextEncoding = (EncodingType)stream.Read1 (ref bytesLeft);  	string priceString = ID3v2Utils.ReadString (EncodingType.ISO88591' stream' ref bytesLeft);  	if (!string.IsNullOrEmpty (priceString)) {  		foreach (string priceItem in priceString.Split ('/')) {  			if (priceItem.Length > 3) {  				decimal price;  				string pricePart = priceItem.Substring (3' priceItem.Length - 3);  				if (decimal.TryParse (pricePart' System.Globalization.NumberStyles.Any' System.Globalization.NumberFormatInfo.InvariantInfo' out price)) {  					IPriceInformation priceInfo = new PriceInformation ();  					priceInfo.CurrencyCode = priceItem.Substring (0' 3);  					priceInfo.Price = price;  					_priceList.Add (priceInfo);  				}  			}  		}  	}  	if (bytesLeft > 0) {  		string validUntil = ID3v2Utils.ReadString (EncodingType.ISO88591' stream' 8);  		bytesLeft -= 8;  		if (validUntil.Length == 8) {  			validUntil = string.Format ("{0}-{1}-{2}"' validUntil.Substring (0' 4)' validUntil.Substring (4' 2)' validUntil.Substring (6' 2));  			DateTime.TryParse (validUntil' out _validUntil);  		}  		if (bytesLeft > 0) {  			ContactUrl = ID3v2Utils.ReadString (EncodingType.ISO88591' stream' ref bytesLeft);  			if (bytesLeft > 0) {  				ReceivedAs = (ReceivedAs)stream.Read1 (ref bytesLeft);  				NameOfSeller = ID3v2Utils.ReadString (TextEncoding' stream' ref bytesLeft);  				Description = ID3v2Utils.ReadString (TextEncoding' stream' ref bytesLeft);  				SellerLogoMimeType = ID3v2Utils.ReadString (EncodingType.ISO88591' stream' ref bytesLeft);  				if (bytesLeft > 0) {  					SellerLogo = stream.Read (bytesLeft);  					bytesLeft = 0;  				}  			}  		}  	}  }  
Magic Number,IdSharp.Tagging.ID3v2.Frames,Commercial,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\Frames\Commercial.cs,Read,The following statement contains a magic number: if (bytesLeft > 1) {  	TextEncoding = (EncodingType)stream.Read1 (ref bytesLeft);  	string priceString = ID3v2Utils.ReadString (EncodingType.ISO88591' stream' ref bytesLeft);  	if (!string.IsNullOrEmpty (priceString)) {  		foreach (string priceItem in priceString.Split ('/')) {  			if (priceItem.Length > 3) {  				decimal price;  				string pricePart = priceItem.Substring (3' priceItem.Length - 3);  				if (decimal.TryParse (pricePart' System.Globalization.NumberStyles.Any' System.Globalization.NumberFormatInfo.InvariantInfo' out price)) {  					IPriceInformation priceInfo = new PriceInformation ();  					priceInfo.CurrencyCode = priceItem.Substring (0' 3);  					priceInfo.Price = price;  					_priceList.Add (priceInfo);  				}  			}  		}  	}  	if (bytesLeft > 0) {  		string validUntil = ID3v2Utils.ReadString (EncodingType.ISO88591' stream' 8);  		bytesLeft -= 8;  		if (validUntil.Length == 8) {  			validUntil = string.Format ("{0}-{1}-{2}"' validUntil.Substring (0' 4)' validUntil.Substring (4' 2)' validUntil.Substring (6' 2));  			DateTime.TryParse (validUntil' out _validUntil);  		}  		if (bytesLeft > 0) {  			ContactUrl = ID3v2Utils.ReadString (EncodingType.ISO88591' stream' ref bytesLeft);  			if (bytesLeft > 0) {  				ReceivedAs = (ReceivedAs)stream.Read1 (ref bytesLeft);  				NameOfSeller = ID3v2Utils.ReadString (TextEncoding' stream' ref bytesLeft);  				Description = ID3v2Utils.ReadString (TextEncoding' stream' ref bytesLeft);  				SellerLogoMimeType = ID3v2Utils.ReadString (EncodingType.ISO88591' stream' ref bytesLeft);  				if (bytesLeft > 0) {  					SellerLogo = stream.Read (bytesLeft);  					bytesLeft = 0;  				}  			}  		}  	}  }  
Magic Number,IdSharp.Tagging.ID3v2.Frames,Commercial,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\Frames\Commercial.cs,Read,The following statement contains a magic number: if (!string.IsNullOrEmpty (priceString)) {  	foreach (string priceItem in priceString.Split ('/')) {  		if (priceItem.Length > 3) {  			decimal price;  			string pricePart = priceItem.Substring (3' priceItem.Length - 3);  			if (decimal.TryParse (pricePart' System.Globalization.NumberStyles.Any' System.Globalization.NumberFormatInfo.InvariantInfo' out price)) {  				IPriceInformation priceInfo = new PriceInformation ();  				priceInfo.CurrencyCode = priceItem.Substring (0' 3);  				priceInfo.Price = price;  				_priceList.Add (priceInfo);  			}  		}  	}  }  
Magic Number,IdSharp.Tagging.ID3v2.Frames,Commercial,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\Frames\Commercial.cs,Read,The following statement contains a magic number: if (!string.IsNullOrEmpty (priceString)) {  	foreach (string priceItem in priceString.Split ('/')) {  		if (priceItem.Length > 3) {  			decimal price;  			string pricePart = priceItem.Substring (3' priceItem.Length - 3);  			if (decimal.TryParse (pricePart' System.Globalization.NumberStyles.Any' System.Globalization.NumberFormatInfo.InvariantInfo' out price)) {  				IPriceInformation priceInfo = new PriceInformation ();  				priceInfo.CurrencyCode = priceItem.Substring (0' 3);  				priceInfo.Price = price;  				_priceList.Add (priceInfo);  			}  		}  	}  }  
Magic Number,IdSharp.Tagging.ID3v2.Frames,Commercial,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\Frames\Commercial.cs,Read,The following statement contains a magic number: if (!string.IsNullOrEmpty (priceString)) {  	foreach (string priceItem in priceString.Split ('/')) {  		if (priceItem.Length > 3) {  			decimal price;  			string pricePart = priceItem.Substring (3' priceItem.Length - 3);  			if (decimal.TryParse (pricePart' System.Globalization.NumberStyles.Any' System.Globalization.NumberFormatInfo.InvariantInfo' out price)) {  				IPriceInformation priceInfo = new PriceInformation ();  				priceInfo.CurrencyCode = priceItem.Substring (0' 3);  				priceInfo.Price = price;  				_priceList.Add (priceInfo);  			}  		}  	}  }  
Magic Number,IdSharp.Tagging.ID3v2.Frames,Commercial,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\Frames\Commercial.cs,Read,The following statement contains a magic number: if (!string.IsNullOrEmpty (priceString)) {  	foreach (string priceItem in priceString.Split ('/')) {  		if (priceItem.Length > 3) {  			decimal price;  			string pricePart = priceItem.Substring (3' priceItem.Length - 3);  			if (decimal.TryParse (pricePart' System.Globalization.NumberStyles.Any' System.Globalization.NumberFormatInfo.InvariantInfo' out price)) {  				IPriceInformation priceInfo = new PriceInformation ();  				priceInfo.CurrencyCode = priceItem.Substring (0' 3);  				priceInfo.Price = price;  				_priceList.Add (priceInfo);  			}  		}  	}  }  
Magic Number,IdSharp.Tagging.ID3v2.Frames,Commercial,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\Frames\Commercial.cs,Read,The following statement contains a magic number: foreach (string priceItem in priceString.Split ('/')) {  	if (priceItem.Length > 3) {  		decimal price;  		string pricePart = priceItem.Substring (3' priceItem.Length - 3);  		if (decimal.TryParse (pricePart' System.Globalization.NumberStyles.Any' System.Globalization.NumberFormatInfo.InvariantInfo' out price)) {  			IPriceInformation priceInfo = new PriceInformation ();  			priceInfo.CurrencyCode = priceItem.Substring (0' 3);  			priceInfo.Price = price;  			_priceList.Add (priceInfo);  		}  	}  }  
Magic Number,IdSharp.Tagging.ID3v2.Frames,Commercial,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\Frames\Commercial.cs,Read,The following statement contains a magic number: foreach (string priceItem in priceString.Split ('/')) {  	if (priceItem.Length > 3) {  		decimal price;  		string pricePart = priceItem.Substring (3' priceItem.Length - 3);  		if (decimal.TryParse (pricePart' System.Globalization.NumberStyles.Any' System.Globalization.NumberFormatInfo.InvariantInfo' out price)) {  			IPriceInformation priceInfo = new PriceInformation ();  			priceInfo.CurrencyCode = priceItem.Substring (0' 3);  			priceInfo.Price = price;  			_priceList.Add (priceInfo);  		}  	}  }  
Magic Number,IdSharp.Tagging.ID3v2.Frames,Commercial,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\Frames\Commercial.cs,Read,The following statement contains a magic number: foreach (string priceItem in priceString.Split ('/')) {  	if (priceItem.Length > 3) {  		decimal price;  		string pricePart = priceItem.Substring (3' priceItem.Length - 3);  		if (decimal.TryParse (pricePart' System.Globalization.NumberStyles.Any' System.Globalization.NumberFormatInfo.InvariantInfo' out price)) {  			IPriceInformation priceInfo = new PriceInformation ();  			priceInfo.CurrencyCode = priceItem.Substring (0' 3);  			priceInfo.Price = price;  			_priceList.Add (priceInfo);  		}  	}  }  
Magic Number,IdSharp.Tagging.ID3v2.Frames,Commercial,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\Frames\Commercial.cs,Read,The following statement contains a magic number: foreach (string priceItem in priceString.Split ('/')) {  	if (priceItem.Length > 3) {  		decimal price;  		string pricePart = priceItem.Substring (3' priceItem.Length - 3);  		if (decimal.TryParse (pricePart' System.Globalization.NumberStyles.Any' System.Globalization.NumberFormatInfo.InvariantInfo' out price)) {  			IPriceInformation priceInfo = new PriceInformation ();  			priceInfo.CurrencyCode = priceItem.Substring (0' 3);  			priceInfo.Price = price;  			_priceList.Add (priceInfo);  		}  	}  }  
Magic Number,IdSharp.Tagging.ID3v2.Frames,Commercial,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\Frames\Commercial.cs,Read,The following statement contains a magic number: if (priceItem.Length > 3) {  	decimal price;  	string pricePart = priceItem.Substring (3' priceItem.Length - 3);  	if (decimal.TryParse (pricePart' System.Globalization.NumberStyles.Any' System.Globalization.NumberFormatInfo.InvariantInfo' out price)) {  		IPriceInformation priceInfo = new PriceInformation ();  		priceInfo.CurrencyCode = priceItem.Substring (0' 3);  		priceInfo.Price = price;  		_priceList.Add (priceInfo);  	}  }  
Magic Number,IdSharp.Tagging.ID3v2.Frames,Commercial,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\Frames\Commercial.cs,Read,The following statement contains a magic number: if (priceItem.Length > 3) {  	decimal price;  	string pricePart = priceItem.Substring (3' priceItem.Length - 3);  	if (decimal.TryParse (pricePart' System.Globalization.NumberStyles.Any' System.Globalization.NumberFormatInfo.InvariantInfo' out price)) {  		IPriceInformation priceInfo = new PriceInformation ();  		priceInfo.CurrencyCode = priceItem.Substring (0' 3);  		priceInfo.Price = price;  		_priceList.Add (priceInfo);  	}  }  
Magic Number,IdSharp.Tagging.ID3v2.Frames,Commercial,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\Frames\Commercial.cs,Read,The following statement contains a magic number: if (priceItem.Length > 3) {  	decimal price;  	string pricePart = priceItem.Substring (3' priceItem.Length - 3);  	if (decimal.TryParse (pricePart' System.Globalization.NumberStyles.Any' System.Globalization.NumberFormatInfo.InvariantInfo' out price)) {  		IPriceInformation priceInfo = new PriceInformation ();  		priceInfo.CurrencyCode = priceItem.Substring (0' 3);  		priceInfo.Price = price;  		_priceList.Add (priceInfo);  	}  }  
Magic Number,IdSharp.Tagging.ID3v2.Frames,Commercial,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\Frames\Commercial.cs,Read,The following statement contains a magic number: if (priceItem.Length > 3) {  	decimal price;  	string pricePart = priceItem.Substring (3' priceItem.Length - 3);  	if (decimal.TryParse (pricePart' System.Globalization.NumberStyles.Any' System.Globalization.NumberFormatInfo.InvariantInfo' out price)) {  		IPriceInformation priceInfo = new PriceInformation ();  		priceInfo.CurrencyCode = priceItem.Substring (0' 3);  		priceInfo.Price = price;  		_priceList.Add (priceInfo);  	}  }  
Magic Number,IdSharp.Tagging.ID3v2.Frames,Commercial,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\Frames\Commercial.cs,Read,The following statement contains a magic number: if (decimal.TryParse (pricePart' System.Globalization.NumberStyles.Any' System.Globalization.NumberFormatInfo.InvariantInfo' out price)) {  	IPriceInformation priceInfo = new PriceInformation ();  	priceInfo.CurrencyCode = priceItem.Substring (0' 3);  	priceInfo.Price = price;  	_priceList.Add (priceInfo);  }  
Magic Number,IdSharp.Tagging.ID3v2.Frames,Commercial,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\Frames\Commercial.cs,Read,The following statement contains a magic number: priceInfo.CurrencyCode = priceItem.Substring (0' 3);  
Magic Number,IdSharp.Tagging.ID3v2.Frames,Commercial,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\Frames\Commercial.cs,Read,The following statement contains a magic number: if (bytesLeft > 0) {  	string validUntil = ID3v2Utils.ReadString (EncodingType.ISO88591' stream' 8);  	bytesLeft -= 8;  	if (validUntil.Length == 8) {  		validUntil = string.Format ("{0}-{1}-{2}"' validUntil.Substring (0' 4)' validUntil.Substring (4' 2)' validUntil.Substring (6' 2));  		DateTime.TryParse (validUntil' out _validUntil);  	}  	if (bytesLeft > 0) {  		ContactUrl = ID3v2Utils.ReadString (EncodingType.ISO88591' stream' ref bytesLeft);  		if (bytesLeft > 0) {  			ReceivedAs = (ReceivedAs)stream.Read1 (ref bytesLeft);  			NameOfSeller = ID3v2Utils.ReadString (TextEncoding' stream' ref bytesLeft);  			Description = ID3v2Utils.ReadString (TextEncoding' stream' ref bytesLeft);  			SellerLogoMimeType = ID3v2Utils.ReadString (EncodingType.ISO88591' stream' ref bytesLeft);  			if (bytesLeft > 0) {  				SellerLogo = stream.Read (bytesLeft);  				bytesLeft = 0;  			}  		}  	}  }  
Magic Number,IdSharp.Tagging.ID3v2.Frames,Commercial,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\Frames\Commercial.cs,Read,The following statement contains a magic number: if (bytesLeft > 0) {  	string validUntil = ID3v2Utils.ReadString (EncodingType.ISO88591' stream' 8);  	bytesLeft -= 8;  	if (validUntil.Length == 8) {  		validUntil = string.Format ("{0}-{1}-{2}"' validUntil.Substring (0' 4)' validUntil.Substring (4' 2)' validUntil.Substring (6' 2));  		DateTime.TryParse (validUntil' out _validUntil);  	}  	if (bytesLeft > 0) {  		ContactUrl = ID3v2Utils.ReadString (EncodingType.ISO88591' stream' ref bytesLeft);  		if (bytesLeft > 0) {  			ReceivedAs = (ReceivedAs)stream.Read1 (ref bytesLeft);  			NameOfSeller = ID3v2Utils.ReadString (TextEncoding' stream' ref bytesLeft);  			Description = ID3v2Utils.ReadString (TextEncoding' stream' ref bytesLeft);  			SellerLogoMimeType = ID3v2Utils.ReadString (EncodingType.ISO88591' stream' ref bytesLeft);  			if (bytesLeft > 0) {  				SellerLogo = stream.Read (bytesLeft);  				bytesLeft = 0;  			}  		}  	}  }  
Magic Number,IdSharp.Tagging.ID3v2.Frames,Commercial,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\Frames\Commercial.cs,Read,The following statement contains a magic number: if (bytesLeft > 0) {  	string validUntil = ID3v2Utils.ReadString (EncodingType.ISO88591' stream' 8);  	bytesLeft -= 8;  	if (validUntil.Length == 8) {  		validUntil = string.Format ("{0}-{1}-{2}"' validUntil.Substring (0' 4)' validUntil.Substring (4' 2)' validUntil.Substring (6' 2));  		DateTime.TryParse (validUntil' out _validUntil);  	}  	if (bytesLeft > 0) {  		ContactUrl = ID3v2Utils.ReadString (EncodingType.ISO88591' stream' ref bytesLeft);  		if (bytesLeft > 0) {  			ReceivedAs = (ReceivedAs)stream.Read1 (ref bytesLeft);  			NameOfSeller = ID3v2Utils.ReadString (TextEncoding' stream' ref bytesLeft);  			Description = ID3v2Utils.ReadString (TextEncoding' stream' ref bytesLeft);  			SellerLogoMimeType = ID3v2Utils.ReadString (EncodingType.ISO88591' stream' ref bytesLeft);  			if (bytesLeft > 0) {  				SellerLogo = stream.Read (bytesLeft);  				bytesLeft = 0;  			}  		}  	}  }  
Magic Number,IdSharp.Tagging.ID3v2.Frames,Commercial,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\Frames\Commercial.cs,Read,The following statement contains a magic number: if (bytesLeft > 0) {  	string validUntil = ID3v2Utils.ReadString (EncodingType.ISO88591' stream' 8);  	bytesLeft -= 8;  	if (validUntil.Length == 8) {  		validUntil = string.Format ("{0}-{1}-{2}"' validUntil.Substring (0' 4)' validUntil.Substring (4' 2)' validUntil.Substring (6' 2));  		DateTime.TryParse (validUntil' out _validUntil);  	}  	if (bytesLeft > 0) {  		ContactUrl = ID3v2Utils.ReadString (EncodingType.ISO88591' stream' ref bytesLeft);  		if (bytesLeft > 0) {  			ReceivedAs = (ReceivedAs)stream.Read1 (ref bytesLeft);  			NameOfSeller = ID3v2Utils.ReadString (TextEncoding' stream' ref bytesLeft);  			Description = ID3v2Utils.ReadString (TextEncoding' stream' ref bytesLeft);  			SellerLogoMimeType = ID3v2Utils.ReadString (EncodingType.ISO88591' stream' ref bytesLeft);  			if (bytesLeft > 0) {  				SellerLogo = stream.Read (bytesLeft);  				bytesLeft = 0;  			}  		}  	}  }  
Magic Number,IdSharp.Tagging.ID3v2.Frames,Commercial,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\Frames\Commercial.cs,Read,The following statement contains a magic number: if (bytesLeft > 0) {  	string validUntil = ID3v2Utils.ReadString (EncodingType.ISO88591' stream' 8);  	bytesLeft -= 8;  	if (validUntil.Length == 8) {  		validUntil = string.Format ("{0}-{1}-{2}"' validUntil.Substring (0' 4)' validUntil.Substring (4' 2)' validUntil.Substring (6' 2));  		DateTime.TryParse (validUntil' out _validUntil);  	}  	if (bytesLeft > 0) {  		ContactUrl = ID3v2Utils.ReadString (EncodingType.ISO88591' stream' ref bytesLeft);  		if (bytesLeft > 0) {  			ReceivedAs = (ReceivedAs)stream.Read1 (ref bytesLeft);  			NameOfSeller = ID3v2Utils.ReadString (TextEncoding' stream' ref bytesLeft);  			Description = ID3v2Utils.ReadString (TextEncoding' stream' ref bytesLeft);  			SellerLogoMimeType = ID3v2Utils.ReadString (EncodingType.ISO88591' stream' ref bytesLeft);  			if (bytesLeft > 0) {  				SellerLogo = stream.Read (bytesLeft);  				bytesLeft = 0;  			}  		}  	}  }  
Magic Number,IdSharp.Tagging.ID3v2.Frames,Commercial,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\Frames\Commercial.cs,Read,The following statement contains a magic number: if (bytesLeft > 0) {  	string validUntil = ID3v2Utils.ReadString (EncodingType.ISO88591' stream' 8);  	bytesLeft -= 8;  	if (validUntil.Length == 8) {  		validUntil = string.Format ("{0}-{1}-{2}"' validUntil.Substring (0' 4)' validUntil.Substring (4' 2)' validUntil.Substring (6' 2));  		DateTime.TryParse (validUntil' out _validUntil);  	}  	if (bytesLeft > 0) {  		ContactUrl = ID3v2Utils.ReadString (EncodingType.ISO88591' stream' ref bytesLeft);  		if (bytesLeft > 0) {  			ReceivedAs = (ReceivedAs)stream.Read1 (ref bytesLeft);  			NameOfSeller = ID3v2Utils.ReadString (TextEncoding' stream' ref bytesLeft);  			Description = ID3v2Utils.ReadString (TextEncoding' stream' ref bytesLeft);  			SellerLogoMimeType = ID3v2Utils.ReadString (EncodingType.ISO88591' stream' ref bytesLeft);  			if (bytesLeft > 0) {  				SellerLogo = stream.Read (bytesLeft);  				bytesLeft = 0;  			}  		}  	}  }  
Magic Number,IdSharp.Tagging.ID3v2.Frames,Commercial,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\Frames\Commercial.cs,Read,The following statement contains a magic number: if (bytesLeft > 0) {  	string validUntil = ID3v2Utils.ReadString (EncodingType.ISO88591' stream' 8);  	bytesLeft -= 8;  	if (validUntil.Length == 8) {  		validUntil = string.Format ("{0}-{1}-{2}"' validUntil.Substring (0' 4)' validUntil.Substring (4' 2)' validUntil.Substring (6' 2));  		DateTime.TryParse (validUntil' out _validUntil);  	}  	if (bytesLeft > 0) {  		ContactUrl = ID3v2Utils.ReadString (EncodingType.ISO88591' stream' ref bytesLeft);  		if (bytesLeft > 0) {  			ReceivedAs = (ReceivedAs)stream.Read1 (ref bytesLeft);  			NameOfSeller = ID3v2Utils.ReadString (TextEncoding' stream' ref bytesLeft);  			Description = ID3v2Utils.ReadString (TextEncoding' stream' ref bytesLeft);  			SellerLogoMimeType = ID3v2Utils.ReadString (EncodingType.ISO88591' stream' ref bytesLeft);  			if (bytesLeft > 0) {  				SellerLogo = stream.Read (bytesLeft);  				bytesLeft = 0;  			}  		}  	}  }  
Magic Number,IdSharp.Tagging.ID3v2.Frames,Commercial,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\Frames\Commercial.cs,Read,The following statement contains a magic number: if (bytesLeft > 0) {  	string validUntil = ID3v2Utils.ReadString (EncodingType.ISO88591' stream' 8);  	bytesLeft -= 8;  	if (validUntil.Length == 8) {  		validUntil = string.Format ("{0}-{1}-{2}"' validUntil.Substring (0' 4)' validUntil.Substring (4' 2)' validUntil.Substring (6' 2));  		DateTime.TryParse (validUntil' out _validUntil);  	}  	if (bytesLeft > 0) {  		ContactUrl = ID3v2Utils.ReadString (EncodingType.ISO88591' stream' ref bytesLeft);  		if (bytesLeft > 0) {  			ReceivedAs = (ReceivedAs)stream.Read1 (ref bytesLeft);  			NameOfSeller = ID3v2Utils.ReadString (TextEncoding' stream' ref bytesLeft);  			Description = ID3v2Utils.ReadString (TextEncoding' stream' ref bytesLeft);  			SellerLogoMimeType = ID3v2Utils.ReadString (EncodingType.ISO88591' stream' ref bytesLeft);  			if (bytesLeft > 0) {  				SellerLogo = stream.Read (bytesLeft);  				bytesLeft = 0;  			}  		}  	}  }  
Magic Number,IdSharp.Tagging.ID3v2.Frames,Commercial,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\Frames\Commercial.cs,Read,The following statement contains a magic number: bytesLeft -= 8;  
Magic Number,IdSharp.Tagging.ID3v2.Frames,Commercial,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\Frames\Commercial.cs,Read,The following statement contains a magic number: if (validUntil.Length == 8) {  	validUntil = string.Format ("{0}-{1}-{2}"' validUntil.Substring (0' 4)' validUntil.Substring (4' 2)' validUntil.Substring (6' 2));  	DateTime.TryParse (validUntil' out _validUntil);  }  
Magic Number,IdSharp.Tagging.ID3v2.Frames,Commercial,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\Frames\Commercial.cs,Read,The following statement contains a magic number: if (validUntil.Length == 8) {  	validUntil = string.Format ("{0}-{1}-{2}"' validUntil.Substring (0' 4)' validUntil.Substring (4' 2)' validUntil.Substring (6' 2));  	DateTime.TryParse (validUntil' out _validUntil);  }  
Magic Number,IdSharp.Tagging.ID3v2.Frames,Commercial,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\Frames\Commercial.cs,Read,The following statement contains a magic number: if (validUntil.Length == 8) {  	validUntil = string.Format ("{0}-{1}-{2}"' validUntil.Substring (0' 4)' validUntil.Substring (4' 2)' validUntil.Substring (6' 2));  	DateTime.TryParse (validUntil' out _validUntil);  }  
Magic Number,IdSharp.Tagging.ID3v2.Frames,Commercial,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\Frames\Commercial.cs,Read,The following statement contains a magic number: if (validUntil.Length == 8) {  	validUntil = string.Format ("{0}-{1}-{2}"' validUntil.Substring (0' 4)' validUntil.Substring (4' 2)' validUntil.Substring (6' 2));  	DateTime.TryParse (validUntil' out _validUntil);  }  
Magic Number,IdSharp.Tagging.ID3v2.Frames,Commercial,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\Frames\Commercial.cs,Read,The following statement contains a magic number: if (validUntil.Length == 8) {  	validUntil = string.Format ("{0}-{1}-{2}"' validUntil.Substring (0' 4)' validUntil.Substring (4' 2)' validUntil.Substring (6' 2));  	DateTime.TryParse (validUntil' out _validUntil);  }  
Magic Number,IdSharp.Tagging.ID3v2.Frames,Commercial,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\Frames\Commercial.cs,Read,The following statement contains a magic number: if (validUntil.Length == 8) {  	validUntil = string.Format ("{0}-{1}-{2}"' validUntil.Substring (0' 4)' validUntil.Substring (4' 2)' validUntil.Substring (6' 2));  	DateTime.TryParse (validUntil' out _validUntil);  }  
Magic Number,IdSharp.Tagging.ID3v2.Frames,Commercial,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\Frames\Commercial.cs,Read,The following statement contains a magic number: validUntil = string.Format ("{0}-{1}-{2}"' validUntil.Substring (0' 4)' validUntil.Substring (4' 2)' validUntil.Substring (6' 2));  
Magic Number,IdSharp.Tagging.ID3v2.Frames,Commercial,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\Frames\Commercial.cs,Read,The following statement contains a magic number: validUntil = string.Format ("{0}-{1}-{2}"' validUntil.Substring (0' 4)' validUntil.Substring (4' 2)' validUntil.Substring (6' 2));  
Magic Number,IdSharp.Tagging.ID3v2.Frames,Commercial,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\Frames\Commercial.cs,Read,The following statement contains a magic number: validUntil = string.Format ("{0}-{1}-{2}"' validUntil.Substring (0' 4)' validUntil.Substring (4' 2)' validUntil.Substring (6' 2));  
Magic Number,IdSharp.Tagging.ID3v2.Frames,Commercial,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\Frames\Commercial.cs,Read,The following statement contains a magic number: validUntil = string.Format ("{0}-{1}-{2}"' validUntil.Substring (0' 4)' validUntil.Substring (4' 2)' validUntil.Substring (6' 2));  
Magic Number,IdSharp.Tagging.ID3v2.Frames,Commercial,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\Frames\Commercial.cs,Read,The following statement contains a magic number: validUntil = string.Format ("{0}-{1}-{2}"' validUntil.Substring (0' 4)' validUntil.Substring (4' 2)' validUntil.Substring (6' 2));  
Magic Number,IdSharp.Tagging.ID3v2.Frames,Commercial,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\Frames\Commercial.cs,GetBytes,The following statement contains a magic number: using (MemoryStream frameData = new MemoryStream ()) {  	byte[] nameOfSellerData;  	byte[] descriptionData;  	do {  		nameOfSellerData = ID3v2Utils.GetStringBytes (tagVersion' _textEncoding' _nameOfSeller' true);  		descriptionData = ID3v2Utils.GetStringBytes (tagVersion' _textEncoding' _description' true);  	} while (this.RequiresFix (tagVersion' _nameOfSeller' nameOfSellerData) || this.RequiresFix (tagVersion' _description' descriptionData));  	frameData.WriteByte ((byte)_textEncoding);  	string priceString = string.Empty;  	foreach (IPriceInformation priceInfo in _priceList) {  		if (priceInfo.CurrencyCode != null && priceInfo.CurrencyCode.Length == 3) {  			if (priceString != string.Empty)  				priceString += "/";  			priceString += string.Format ("{0}{1:0.00}"' priceInfo.CurrencyCode' priceInfo.Price);  		}  	}  	// No valid price items  	if (priceString == string.Empty)  		return new byte[0];  	frameData.Write (ByteUtils.ISO88591GetBytes (priceString));  	frameData.WriteByte (0);  	// terminator  	frameData.Write (ByteUtils.ISO88591GetBytes (_validUntil.ToString ("yyyyMMdd")));  	frameData.Write (ByteUtils.ISO88591GetBytes (_contactUrl));  	frameData.WriteByte (0);  	// terminator  	frameData.WriteByte ((byte)_receivedAs);  	frameData.Write (nameOfSellerData);  	frameData.Write (descriptionData);  	// This section is optional  	if (_sellerLogo != null && _sellerLogo.Length != 0) {  		frameData.Write (ByteUtils.ISO88591GetBytes (_sellerLogoMimeType));  		frameData.WriteByte (0);  		// terminator  		frameData.Write (_sellerLogo);  	}  	return _frameHeader.GetBytes (frameData' tagVersion' GetFrameID (tagVersion));  }  
Magic Number,IdSharp.Tagging.ID3v2.Frames,Commercial,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\Frames\Commercial.cs,GetBytes,The following statement contains a magic number: foreach (IPriceInformation priceInfo in _priceList) {  	if (priceInfo.CurrencyCode != null && priceInfo.CurrencyCode.Length == 3) {  		if (priceString != string.Empty)  			priceString += "/";  		priceString += string.Format ("{0}{1:0.00}"' priceInfo.CurrencyCode' priceInfo.Price);  	}  }  
Magic Number,IdSharp.Tagging.ID3v2.Frames,Commercial,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\Frames\Commercial.cs,GetBytes,The following statement contains a magic number: if (priceInfo.CurrencyCode != null && priceInfo.CurrencyCode.Length == 3) {  	if (priceString != string.Empty)  		priceString += "/";  	priceString += string.Format ("{0}{1:0.00}"' priceInfo.CurrencyCode' priceInfo.Price);  }  
Magic Number,IdSharp.Tagging.ID3v2.Frames,GeneralEncapsulatedObject,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\Frames\GeneralEncapsulatedObject.cs,Read,The following statement contains a magic number: if (bytesLeft >= 4) {  	TextEncoding = (EncodingType)stream.Read1 (ref bytesLeft);  	MimeType = ID3v2Utils.ReadString (EncodingType.ISO88591' stream' ref bytesLeft);  	if (bytesLeft > 0) {  		FileName = ID3v2Utils.ReadString (TextEncoding' stream' ref bytesLeft);  		if (bytesLeft > 0) {  			Description = ID3v2Utils.ReadString (TextEncoding' stream' ref bytesLeft);  			if (bytesLeft > 0) {  				EncapsulatedObject = stream.Read (bytesLeft);  				bytesLeft = 0;  			}  		}  	}  }  
Magic Number,IdSharp.Tagging.ID3v2.Frames,LanguageFrame,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\Frames\LanguageFrame.cs,Read,The following statement contains a magic number: if (bytesLeft >= 4) {  	TextEncoding = (EncodingType)stream.Read1 (ref bytesLeft);  	// This could be implemented many ways  	// engfraspa etc  	// eng 0x00 fra 0x00 spa 0x00 etc  	// English  	// English 0x00 French 0x00 Spanish 0x00  	// TODO: Finish implementation  	string languageCode = ID3v2Utils.ReadString (TextEncoding' stream' ref bytesLeft);  	if (languageCode.Length != 3) {  		if (languageCode.ToLower () == "english" || languageCode.ToLower () == "en") {  			Items.AddNew ().LanguageCode = "eng";  		} else {  			foreach (KeyValuePair<string' string> kvp in LanguageHelper.Languages) {  				if (kvp.Value.ToLower () == languageCode.ToLower ()) {  					Items.AddNew ().LanguageCode = kvp.Key;  					break;  				}  			}  		}  	} else {  		Items.AddNew ().LanguageCode = languageCode;  	}  }  
Magic Number,IdSharp.Tagging.ID3v2.Frames,LanguageFrame,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\Frames\LanguageFrame.cs,Read,The following statement contains a magic number: if (bytesLeft >= 4) {  	TextEncoding = (EncodingType)stream.Read1 (ref bytesLeft);  	// This could be implemented many ways  	// engfraspa etc  	// eng 0x00 fra 0x00 spa 0x00 etc  	// English  	// English 0x00 French 0x00 Spanish 0x00  	// TODO: Finish implementation  	string languageCode = ID3v2Utils.ReadString (TextEncoding' stream' ref bytesLeft);  	if (languageCode.Length != 3) {  		if (languageCode.ToLower () == "english" || languageCode.ToLower () == "en") {  			Items.AddNew ().LanguageCode = "eng";  		} else {  			foreach (KeyValuePair<string' string> kvp in LanguageHelper.Languages) {  				if (kvp.Value.ToLower () == languageCode.ToLower ()) {  					Items.AddNew ().LanguageCode = kvp.Key;  					break;  				}  			}  		}  	} else {  		Items.AddNew ().LanguageCode = languageCode;  	}  }  
Magic Number,IdSharp.Tagging.ID3v2.Frames,LanguageFrame,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\Frames\LanguageFrame.cs,Read,The following statement contains a magic number: if (languageCode.Length != 3) {  	if (languageCode.ToLower () == "english" || languageCode.ToLower () == "en") {  		Items.AddNew ().LanguageCode = "eng";  	} else {  		foreach (KeyValuePair<string' string> kvp in LanguageHelper.Languages) {  			if (kvp.Value.ToLower () == languageCode.ToLower ()) {  				Items.AddNew ().LanguageCode = kvp.Key;  				break;  			}  		}  	}  } else {  	Items.AddNew ().LanguageCode = languageCode;  }  
Magic Number,IdSharp.Tagging.ID3v2.Frames,LinkedInformation,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\Frames\LinkedInformation.cs,GetBytes,The following statement contains a magic number: if (tagVersion == ID3v2TagVersion.ID3v22) {  	if (_frameIdentifier == null || _frameIdentifier.Length != 3)  		return new byte[0];  } else {  	if (_frameIdentifier == null || _frameIdentifier.Length != 4)  		return new byte[0];  }  
Magic Number,IdSharp.Tagging.ID3v2.Frames,LinkedInformation,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\Frames\LinkedInformation.cs,GetBytes,The following statement contains a magic number: if (tagVersion == ID3v2TagVersion.ID3v22) {  	if (_frameIdentifier == null || _frameIdentifier.Length != 3)  		return new byte[0];  } else {  	if (_frameIdentifier == null || _frameIdentifier.Length != 4)  		return new byte[0];  }  
Magic Number,IdSharp.Tagging.ID3v2.Frames,LinkedInformation,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\Frames\LinkedInformation.cs,GetBytes,The following statement contains a magic number: if (_frameIdentifier == null || _frameIdentifier.Length != 3)  	return new byte[0];  
Magic Number,IdSharp.Tagging.ID3v2.Frames,LinkedInformation,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\Frames\LinkedInformation.cs,GetBytes,The following statement contains a magic number: if (_frameIdentifier == null || _frameIdentifier.Length != 4)  	return new byte[0];  
Magic Number,IdSharp.Tagging.ID3v2.Frames,PlayCount,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\Frames\PlayCount.cs,Read,The following statement contains a magic number: while (bytesLeft > 0) {  	playCount <<= 8;  	playCount += stream.Read1 (ref bytesLeft);  }  
Magic Number,IdSharp.Tagging.ID3v2.Frames,PlayCount,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\Frames\PlayCount.cs,Read,The following statement contains a magic number: playCount <<= 8;  
Magic Number,IdSharp.Tagging.ID3v2.Frames,SynchronizedText,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\Frames\SynchronizedText.cs,Read,The following statement contains a magic number: if (bytesLeft >= 1) {  	TextEncoding = (EncodingType)stream.Read1 (ref bytesLeft);  	if (bytesLeft >= 3) {  		LanguageCode = ID3v2Utils.ReadString (EncodingType.ISO88591' stream' 3);  		bytesLeft -= 3;  		if (bytesLeft >= 2) {  			TimestampFormat = (TimestampFormat)stream.Read1 (ref bytesLeft);  			ContentType = (TextContentType)stream.Read1 (ref bytesLeft);  			if (bytesLeft > 0) {  				ContentDescriptor = ID3v2Utils.ReadString (TextEncoding' stream' ref bytesLeft);  				while (bytesLeft > 0) {  					string lyrics = ID3v2Utils.ReadString (TextEncoding' stream' ref bytesLeft);  					if (bytesLeft >= 4) {  						SynchronizedTextItem textItem = new SynchronizedTextItem ();  						textItem.Text = lyrics;  						textItem.Timestamp = stream.ReadInt32 ();  						bytesLeft -= 4;  						Items.Add (textItem);  					}  				}  			} else {  				// Incomplete frame  				ContentDescriptor = "";  			}  		} else {  			// Incomplete frame  			TimestampFormat = TimestampFormat.Milliseconds;  			ContentType = TextContentType.Other;  			ContentDescriptor = "";  		}  	} else {  		// Incomplete frame  		LanguageCode = "eng";  		TimestampFormat = TimestampFormat.Milliseconds;  		ContentType = TextContentType.Other;  		ContentDescriptor = "";  	}  } else {  	// Incomplete frame  	TextEncoding = EncodingType.ISO88591;  	LanguageCode = "eng";  	TimestampFormat = TimestampFormat.Milliseconds;  	ContentType = TextContentType.Other;  	ContentDescriptor = "";  }  
Magic Number,IdSharp.Tagging.ID3v2.Frames,SynchronizedText,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\Frames\SynchronizedText.cs,Read,The following statement contains a magic number: if (bytesLeft >= 1) {  	TextEncoding = (EncodingType)stream.Read1 (ref bytesLeft);  	if (bytesLeft >= 3) {  		LanguageCode = ID3v2Utils.ReadString (EncodingType.ISO88591' stream' 3);  		bytesLeft -= 3;  		if (bytesLeft >= 2) {  			TimestampFormat = (TimestampFormat)stream.Read1 (ref bytesLeft);  			ContentType = (TextContentType)stream.Read1 (ref bytesLeft);  			if (bytesLeft > 0) {  				ContentDescriptor = ID3v2Utils.ReadString (TextEncoding' stream' ref bytesLeft);  				while (bytesLeft > 0) {  					string lyrics = ID3v2Utils.ReadString (TextEncoding' stream' ref bytesLeft);  					if (bytesLeft >= 4) {  						SynchronizedTextItem textItem = new SynchronizedTextItem ();  						textItem.Text = lyrics;  						textItem.Timestamp = stream.ReadInt32 ();  						bytesLeft -= 4;  						Items.Add (textItem);  					}  				}  			} else {  				// Incomplete frame  				ContentDescriptor = "";  			}  		} else {  			// Incomplete frame  			TimestampFormat = TimestampFormat.Milliseconds;  			ContentType = TextContentType.Other;  			ContentDescriptor = "";  		}  	} else {  		// Incomplete frame  		LanguageCode = "eng";  		TimestampFormat = TimestampFormat.Milliseconds;  		ContentType = TextContentType.Other;  		ContentDescriptor = "";  	}  } else {  	// Incomplete frame  	TextEncoding = EncodingType.ISO88591;  	LanguageCode = "eng";  	TimestampFormat = TimestampFormat.Milliseconds;  	ContentType = TextContentType.Other;  	ContentDescriptor = "";  }  
Magic Number,IdSharp.Tagging.ID3v2.Frames,SynchronizedText,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\Frames\SynchronizedText.cs,Read,The following statement contains a magic number: if (bytesLeft >= 1) {  	TextEncoding = (EncodingType)stream.Read1 (ref bytesLeft);  	if (bytesLeft >= 3) {  		LanguageCode = ID3v2Utils.ReadString (EncodingType.ISO88591' stream' 3);  		bytesLeft -= 3;  		if (bytesLeft >= 2) {  			TimestampFormat = (TimestampFormat)stream.Read1 (ref bytesLeft);  			ContentType = (TextContentType)stream.Read1 (ref bytesLeft);  			if (bytesLeft > 0) {  				ContentDescriptor = ID3v2Utils.ReadString (TextEncoding' stream' ref bytesLeft);  				while (bytesLeft > 0) {  					string lyrics = ID3v2Utils.ReadString (TextEncoding' stream' ref bytesLeft);  					if (bytesLeft >= 4) {  						SynchronizedTextItem textItem = new SynchronizedTextItem ();  						textItem.Text = lyrics;  						textItem.Timestamp = stream.ReadInt32 ();  						bytesLeft -= 4;  						Items.Add (textItem);  					}  				}  			} else {  				// Incomplete frame  				ContentDescriptor = "";  			}  		} else {  			// Incomplete frame  			TimestampFormat = TimestampFormat.Milliseconds;  			ContentType = TextContentType.Other;  			ContentDescriptor = "";  		}  	} else {  		// Incomplete frame  		LanguageCode = "eng";  		TimestampFormat = TimestampFormat.Milliseconds;  		ContentType = TextContentType.Other;  		ContentDescriptor = "";  	}  } else {  	// Incomplete frame  	TextEncoding = EncodingType.ISO88591;  	LanguageCode = "eng";  	TimestampFormat = TimestampFormat.Milliseconds;  	ContentType = TextContentType.Other;  	ContentDescriptor = "";  }  
Magic Number,IdSharp.Tagging.ID3v2.Frames,SynchronizedText,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\Frames\SynchronizedText.cs,Read,The following statement contains a magic number: if (bytesLeft >= 1) {  	TextEncoding = (EncodingType)stream.Read1 (ref bytesLeft);  	if (bytesLeft >= 3) {  		LanguageCode = ID3v2Utils.ReadString (EncodingType.ISO88591' stream' 3);  		bytesLeft -= 3;  		if (bytesLeft >= 2) {  			TimestampFormat = (TimestampFormat)stream.Read1 (ref bytesLeft);  			ContentType = (TextContentType)stream.Read1 (ref bytesLeft);  			if (bytesLeft > 0) {  				ContentDescriptor = ID3v2Utils.ReadString (TextEncoding' stream' ref bytesLeft);  				while (bytesLeft > 0) {  					string lyrics = ID3v2Utils.ReadString (TextEncoding' stream' ref bytesLeft);  					if (bytesLeft >= 4) {  						SynchronizedTextItem textItem = new SynchronizedTextItem ();  						textItem.Text = lyrics;  						textItem.Timestamp = stream.ReadInt32 ();  						bytesLeft -= 4;  						Items.Add (textItem);  					}  				}  			} else {  				// Incomplete frame  				ContentDescriptor = "";  			}  		} else {  			// Incomplete frame  			TimestampFormat = TimestampFormat.Milliseconds;  			ContentType = TextContentType.Other;  			ContentDescriptor = "";  		}  	} else {  		// Incomplete frame  		LanguageCode = "eng";  		TimestampFormat = TimestampFormat.Milliseconds;  		ContentType = TextContentType.Other;  		ContentDescriptor = "";  	}  } else {  	// Incomplete frame  	TextEncoding = EncodingType.ISO88591;  	LanguageCode = "eng";  	TimestampFormat = TimestampFormat.Milliseconds;  	ContentType = TextContentType.Other;  	ContentDescriptor = "";  }  
Magic Number,IdSharp.Tagging.ID3v2.Frames,SynchronizedText,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\Frames\SynchronizedText.cs,Read,The following statement contains a magic number: if (bytesLeft >= 1) {  	TextEncoding = (EncodingType)stream.Read1 (ref bytesLeft);  	if (bytesLeft >= 3) {  		LanguageCode = ID3v2Utils.ReadString (EncodingType.ISO88591' stream' 3);  		bytesLeft -= 3;  		if (bytesLeft >= 2) {  			TimestampFormat = (TimestampFormat)stream.Read1 (ref bytesLeft);  			ContentType = (TextContentType)stream.Read1 (ref bytesLeft);  			if (bytesLeft > 0) {  				ContentDescriptor = ID3v2Utils.ReadString (TextEncoding' stream' ref bytesLeft);  				while (bytesLeft > 0) {  					string lyrics = ID3v2Utils.ReadString (TextEncoding' stream' ref bytesLeft);  					if (bytesLeft >= 4) {  						SynchronizedTextItem textItem = new SynchronizedTextItem ();  						textItem.Text = lyrics;  						textItem.Timestamp = stream.ReadInt32 ();  						bytesLeft -= 4;  						Items.Add (textItem);  					}  				}  			} else {  				// Incomplete frame  				ContentDescriptor = "";  			}  		} else {  			// Incomplete frame  			TimestampFormat = TimestampFormat.Milliseconds;  			ContentType = TextContentType.Other;  			ContentDescriptor = "";  		}  	} else {  		// Incomplete frame  		LanguageCode = "eng";  		TimestampFormat = TimestampFormat.Milliseconds;  		ContentType = TextContentType.Other;  		ContentDescriptor = "";  	}  } else {  	// Incomplete frame  	TextEncoding = EncodingType.ISO88591;  	LanguageCode = "eng";  	TimestampFormat = TimestampFormat.Milliseconds;  	ContentType = TextContentType.Other;  	ContentDescriptor = "";  }  
Magic Number,IdSharp.Tagging.ID3v2.Frames,SynchronizedText,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\Frames\SynchronizedText.cs,Read,The following statement contains a magic number: if (bytesLeft >= 1) {  	TextEncoding = (EncodingType)stream.Read1 (ref bytesLeft);  	if (bytesLeft >= 3) {  		LanguageCode = ID3v2Utils.ReadString (EncodingType.ISO88591' stream' 3);  		bytesLeft -= 3;  		if (bytesLeft >= 2) {  			TimestampFormat = (TimestampFormat)stream.Read1 (ref bytesLeft);  			ContentType = (TextContentType)stream.Read1 (ref bytesLeft);  			if (bytesLeft > 0) {  				ContentDescriptor = ID3v2Utils.ReadString (TextEncoding' stream' ref bytesLeft);  				while (bytesLeft > 0) {  					string lyrics = ID3v2Utils.ReadString (TextEncoding' stream' ref bytesLeft);  					if (bytesLeft >= 4) {  						SynchronizedTextItem textItem = new SynchronizedTextItem ();  						textItem.Text = lyrics;  						textItem.Timestamp = stream.ReadInt32 ();  						bytesLeft -= 4;  						Items.Add (textItem);  					}  				}  			} else {  				// Incomplete frame  				ContentDescriptor = "";  			}  		} else {  			// Incomplete frame  			TimestampFormat = TimestampFormat.Milliseconds;  			ContentType = TextContentType.Other;  			ContentDescriptor = "";  		}  	} else {  		// Incomplete frame  		LanguageCode = "eng";  		TimestampFormat = TimestampFormat.Milliseconds;  		ContentType = TextContentType.Other;  		ContentDescriptor = "";  	}  } else {  	// Incomplete frame  	TextEncoding = EncodingType.ISO88591;  	LanguageCode = "eng";  	TimestampFormat = TimestampFormat.Milliseconds;  	ContentType = TextContentType.Other;  	ContentDescriptor = "";  }  
Magic Number,IdSharp.Tagging.ID3v2.Frames,SynchronizedText,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\Frames\SynchronizedText.cs,Read,The following statement contains a magic number: if (bytesLeft >= 3) {  	LanguageCode = ID3v2Utils.ReadString (EncodingType.ISO88591' stream' 3);  	bytesLeft -= 3;  	if (bytesLeft >= 2) {  		TimestampFormat = (TimestampFormat)stream.Read1 (ref bytesLeft);  		ContentType = (TextContentType)stream.Read1 (ref bytesLeft);  		if (bytesLeft > 0) {  			ContentDescriptor = ID3v2Utils.ReadString (TextEncoding' stream' ref bytesLeft);  			while (bytesLeft > 0) {  				string lyrics = ID3v2Utils.ReadString (TextEncoding' stream' ref bytesLeft);  				if (bytesLeft >= 4) {  					SynchronizedTextItem textItem = new SynchronizedTextItem ();  					textItem.Text = lyrics;  					textItem.Timestamp = stream.ReadInt32 ();  					bytesLeft -= 4;  					Items.Add (textItem);  				}  			}  		} else {  			// Incomplete frame  			ContentDescriptor = "";  		}  	} else {  		// Incomplete frame  		TimestampFormat = TimestampFormat.Milliseconds;  		ContentType = TextContentType.Other;  		ContentDescriptor = "";  	}  } else {  	// Incomplete frame  	LanguageCode = "eng";  	TimestampFormat = TimestampFormat.Milliseconds;  	ContentType = TextContentType.Other;  	ContentDescriptor = "";  }  
Magic Number,IdSharp.Tagging.ID3v2.Frames,SynchronizedText,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\Frames\SynchronizedText.cs,Read,The following statement contains a magic number: if (bytesLeft >= 3) {  	LanguageCode = ID3v2Utils.ReadString (EncodingType.ISO88591' stream' 3);  	bytesLeft -= 3;  	if (bytesLeft >= 2) {  		TimestampFormat = (TimestampFormat)stream.Read1 (ref bytesLeft);  		ContentType = (TextContentType)stream.Read1 (ref bytesLeft);  		if (bytesLeft > 0) {  			ContentDescriptor = ID3v2Utils.ReadString (TextEncoding' stream' ref bytesLeft);  			while (bytesLeft > 0) {  				string lyrics = ID3v2Utils.ReadString (TextEncoding' stream' ref bytesLeft);  				if (bytesLeft >= 4) {  					SynchronizedTextItem textItem = new SynchronizedTextItem ();  					textItem.Text = lyrics;  					textItem.Timestamp = stream.ReadInt32 ();  					bytesLeft -= 4;  					Items.Add (textItem);  				}  			}  		} else {  			// Incomplete frame  			ContentDescriptor = "";  		}  	} else {  		// Incomplete frame  		TimestampFormat = TimestampFormat.Milliseconds;  		ContentType = TextContentType.Other;  		ContentDescriptor = "";  	}  } else {  	// Incomplete frame  	LanguageCode = "eng";  	TimestampFormat = TimestampFormat.Milliseconds;  	ContentType = TextContentType.Other;  	ContentDescriptor = "";  }  
Magic Number,IdSharp.Tagging.ID3v2.Frames,SynchronizedText,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\Frames\SynchronizedText.cs,Read,The following statement contains a magic number: if (bytesLeft >= 3) {  	LanguageCode = ID3v2Utils.ReadString (EncodingType.ISO88591' stream' 3);  	bytesLeft -= 3;  	if (bytesLeft >= 2) {  		TimestampFormat = (TimestampFormat)stream.Read1 (ref bytesLeft);  		ContentType = (TextContentType)stream.Read1 (ref bytesLeft);  		if (bytesLeft > 0) {  			ContentDescriptor = ID3v2Utils.ReadString (TextEncoding' stream' ref bytesLeft);  			while (bytesLeft > 0) {  				string lyrics = ID3v2Utils.ReadString (TextEncoding' stream' ref bytesLeft);  				if (bytesLeft >= 4) {  					SynchronizedTextItem textItem = new SynchronizedTextItem ();  					textItem.Text = lyrics;  					textItem.Timestamp = stream.ReadInt32 ();  					bytesLeft -= 4;  					Items.Add (textItem);  				}  			}  		} else {  			// Incomplete frame  			ContentDescriptor = "";  		}  	} else {  		// Incomplete frame  		TimestampFormat = TimestampFormat.Milliseconds;  		ContentType = TextContentType.Other;  		ContentDescriptor = "";  	}  } else {  	// Incomplete frame  	LanguageCode = "eng";  	TimestampFormat = TimestampFormat.Milliseconds;  	ContentType = TextContentType.Other;  	ContentDescriptor = "";  }  
Magic Number,IdSharp.Tagging.ID3v2.Frames,SynchronizedText,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\Frames\SynchronizedText.cs,Read,The following statement contains a magic number: if (bytesLeft >= 3) {  	LanguageCode = ID3v2Utils.ReadString (EncodingType.ISO88591' stream' 3);  	bytesLeft -= 3;  	if (bytesLeft >= 2) {  		TimestampFormat = (TimestampFormat)stream.Read1 (ref bytesLeft);  		ContentType = (TextContentType)stream.Read1 (ref bytesLeft);  		if (bytesLeft > 0) {  			ContentDescriptor = ID3v2Utils.ReadString (TextEncoding' stream' ref bytesLeft);  			while (bytesLeft > 0) {  				string lyrics = ID3v2Utils.ReadString (TextEncoding' stream' ref bytesLeft);  				if (bytesLeft >= 4) {  					SynchronizedTextItem textItem = new SynchronizedTextItem ();  					textItem.Text = lyrics;  					textItem.Timestamp = stream.ReadInt32 ();  					bytesLeft -= 4;  					Items.Add (textItem);  				}  			}  		} else {  			// Incomplete frame  			ContentDescriptor = "";  		}  	} else {  		// Incomplete frame  		TimestampFormat = TimestampFormat.Milliseconds;  		ContentType = TextContentType.Other;  		ContentDescriptor = "";  	}  } else {  	// Incomplete frame  	LanguageCode = "eng";  	TimestampFormat = TimestampFormat.Milliseconds;  	ContentType = TextContentType.Other;  	ContentDescriptor = "";  }  
Magic Number,IdSharp.Tagging.ID3v2.Frames,SynchronizedText,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\Frames\SynchronizedText.cs,Read,The following statement contains a magic number: if (bytesLeft >= 3) {  	LanguageCode = ID3v2Utils.ReadString (EncodingType.ISO88591' stream' 3);  	bytesLeft -= 3;  	if (bytesLeft >= 2) {  		TimestampFormat = (TimestampFormat)stream.Read1 (ref bytesLeft);  		ContentType = (TextContentType)stream.Read1 (ref bytesLeft);  		if (bytesLeft > 0) {  			ContentDescriptor = ID3v2Utils.ReadString (TextEncoding' stream' ref bytesLeft);  			while (bytesLeft > 0) {  				string lyrics = ID3v2Utils.ReadString (TextEncoding' stream' ref bytesLeft);  				if (bytesLeft >= 4) {  					SynchronizedTextItem textItem = new SynchronizedTextItem ();  					textItem.Text = lyrics;  					textItem.Timestamp = stream.ReadInt32 ();  					bytesLeft -= 4;  					Items.Add (textItem);  				}  			}  		} else {  			// Incomplete frame  			ContentDescriptor = "";  		}  	} else {  		// Incomplete frame  		TimestampFormat = TimestampFormat.Milliseconds;  		ContentType = TextContentType.Other;  		ContentDescriptor = "";  	}  } else {  	// Incomplete frame  	LanguageCode = "eng";  	TimestampFormat = TimestampFormat.Milliseconds;  	ContentType = TextContentType.Other;  	ContentDescriptor = "";  }  
Magic Number,IdSharp.Tagging.ID3v2.Frames,SynchronizedText,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\Frames\SynchronizedText.cs,Read,The following statement contains a magic number: if (bytesLeft >= 3) {  	LanguageCode = ID3v2Utils.ReadString (EncodingType.ISO88591' stream' 3);  	bytesLeft -= 3;  	if (bytesLeft >= 2) {  		TimestampFormat = (TimestampFormat)stream.Read1 (ref bytesLeft);  		ContentType = (TextContentType)stream.Read1 (ref bytesLeft);  		if (bytesLeft > 0) {  			ContentDescriptor = ID3v2Utils.ReadString (TextEncoding' stream' ref bytesLeft);  			while (bytesLeft > 0) {  				string lyrics = ID3v2Utils.ReadString (TextEncoding' stream' ref bytesLeft);  				if (bytesLeft >= 4) {  					SynchronizedTextItem textItem = new SynchronizedTextItem ();  					textItem.Text = lyrics;  					textItem.Timestamp = stream.ReadInt32 ();  					bytesLeft -= 4;  					Items.Add (textItem);  				}  			}  		} else {  			// Incomplete frame  			ContentDescriptor = "";  		}  	} else {  		// Incomplete frame  		TimestampFormat = TimestampFormat.Milliseconds;  		ContentType = TextContentType.Other;  		ContentDescriptor = "";  	}  } else {  	// Incomplete frame  	LanguageCode = "eng";  	TimestampFormat = TimestampFormat.Milliseconds;  	ContentType = TextContentType.Other;  	ContentDescriptor = "";  }  
Magic Number,IdSharp.Tagging.ID3v2.Frames,SynchronizedText,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\Frames\SynchronizedText.cs,Read,The following statement contains a magic number: LanguageCode = ID3v2Utils.ReadString (EncodingType.ISO88591' stream' 3);  
Magic Number,IdSharp.Tagging.ID3v2.Frames,SynchronizedText,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\Frames\SynchronizedText.cs,Read,The following statement contains a magic number: bytesLeft -= 3;  
Magic Number,IdSharp.Tagging.ID3v2.Frames,SynchronizedText,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\Frames\SynchronizedText.cs,Read,The following statement contains a magic number: if (bytesLeft >= 2) {  	TimestampFormat = (TimestampFormat)stream.Read1 (ref bytesLeft);  	ContentType = (TextContentType)stream.Read1 (ref bytesLeft);  	if (bytesLeft > 0) {  		ContentDescriptor = ID3v2Utils.ReadString (TextEncoding' stream' ref bytesLeft);  		while (bytesLeft > 0) {  			string lyrics = ID3v2Utils.ReadString (TextEncoding' stream' ref bytesLeft);  			if (bytesLeft >= 4) {  				SynchronizedTextItem textItem = new SynchronizedTextItem ();  				textItem.Text = lyrics;  				textItem.Timestamp = stream.ReadInt32 ();  				bytesLeft -= 4;  				Items.Add (textItem);  			}  		}  	} else {  		// Incomplete frame  		ContentDescriptor = "";  	}  } else {  	// Incomplete frame  	TimestampFormat = TimestampFormat.Milliseconds;  	ContentType = TextContentType.Other;  	ContentDescriptor = "";  }  
Magic Number,IdSharp.Tagging.ID3v2.Frames,SynchronizedText,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\Frames\SynchronizedText.cs,Read,The following statement contains a magic number: if (bytesLeft >= 2) {  	TimestampFormat = (TimestampFormat)stream.Read1 (ref bytesLeft);  	ContentType = (TextContentType)stream.Read1 (ref bytesLeft);  	if (bytesLeft > 0) {  		ContentDescriptor = ID3v2Utils.ReadString (TextEncoding' stream' ref bytesLeft);  		while (bytesLeft > 0) {  			string lyrics = ID3v2Utils.ReadString (TextEncoding' stream' ref bytesLeft);  			if (bytesLeft >= 4) {  				SynchronizedTextItem textItem = new SynchronizedTextItem ();  				textItem.Text = lyrics;  				textItem.Timestamp = stream.ReadInt32 ();  				bytesLeft -= 4;  				Items.Add (textItem);  			}  		}  	} else {  		// Incomplete frame  		ContentDescriptor = "";  	}  } else {  	// Incomplete frame  	TimestampFormat = TimestampFormat.Milliseconds;  	ContentType = TextContentType.Other;  	ContentDescriptor = "";  }  
Magic Number,IdSharp.Tagging.ID3v2.Frames,SynchronizedText,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\Frames\SynchronizedText.cs,Read,The following statement contains a magic number: if (bytesLeft >= 2) {  	TimestampFormat = (TimestampFormat)stream.Read1 (ref bytesLeft);  	ContentType = (TextContentType)stream.Read1 (ref bytesLeft);  	if (bytesLeft > 0) {  		ContentDescriptor = ID3v2Utils.ReadString (TextEncoding' stream' ref bytesLeft);  		while (bytesLeft > 0) {  			string lyrics = ID3v2Utils.ReadString (TextEncoding' stream' ref bytesLeft);  			if (bytesLeft >= 4) {  				SynchronizedTextItem textItem = new SynchronizedTextItem ();  				textItem.Text = lyrics;  				textItem.Timestamp = stream.ReadInt32 ();  				bytesLeft -= 4;  				Items.Add (textItem);  			}  		}  	} else {  		// Incomplete frame  		ContentDescriptor = "";  	}  } else {  	// Incomplete frame  	TimestampFormat = TimestampFormat.Milliseconds;  	ContentType = TextContentType.Other;  	ContentDescriptor = "";  }  
Magic Number,IdSharp.Tagging.ID3v2.Frames,SynchronizedText,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\Frames\SynchronizedText.cs,Read,The following statement contains a magic number: if (bytesLeft > 0) {  	ContentDescriptor = ID3v2Utils.ReadString (TextEncoding' stream' ref bytesLeft);  	while (bytesLeft > 0) {  		string lyrics = ID3v2Utils.ReadString (TextEncoding' stream' ref bytesLeft);  		if (bytesLeft >= 4) {  			SynchronizedTextItem textItem = new SynchronizedTextItem ();  			textItem.Text = lyrics;  			textItem.Timestamp = stream.ReadInt32 ();  			bytesLeft -= 4;  			Items.Add (textItem);  		}  	}  } else {  	// Incomplete frame  	ContentDescriptor = "";  }  
Magic Number,IdSharp.Tagging.ID3v2.Frames,SynchronizedText,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\Frames\SynchronizedText.cs,Read,The following statement contains a magic number: if (bytesLeft > 0) {  	ContentDescriptor = ID3v2Utils.ReadString (TextEncoding' stream' ref bytesLeft);  	while (bytesLeft > 0) {  		string lyrics = ID3v2Utils.ReadString (TextEncoding' stream' ref bytesLeft);  		if (bytesLeft >= 4) {  			SynchronizedTextItem textItem = new SynchronizedTextItem ();  			textItem.Text = lyrics;  			textItem.Timestamp = stream.ReadInt32 ();  			bytesLeft -= 4;  			Items.Add (textItem);  		}  	}  } else {  	// Incomplete frame  	ContentDescriptor = "";  }  
Magic Number,IdSharp.Tagging.ID3v2.Frames,SynchronizedText,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\Frames\SynchronizedText.cs,Read,The following statement contains a magic number: while (bytesLeft > 0) {  	string lyrics = ID3v2Utils.ReadString (TextEncoding' stream' ref bytesLeft);  	if (bytesLeft >= 4) {  		SynchronizedTextItem textItem = new SynchronizedTextItem ();  		textItem.Text = lyrics;  		textItem.Timestamp = stream.ReadInt32 ();  		bytesLeft -= 4;  		Items.Add (textItem);  	}  }  
Magic Number,IdSharp.Tagging.ID3v2.Frames,SynchronizedText,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\Frames\SynchronizedText.cs,Read,The following statement contains a magic number: while (bytesLeft > 0) {  	string lyrics = ID3v2Utils.ReadString (TextEncoding' stream' ref bytesLeft);  	if (bytesLeft >= 4) {  		SynchronizedTextItem textItem = new SynchronizedTextItem ();  		textItem.Text = lyrics;  		textItem.Timestamp = stream.ReadInt32 ();  		bytesLeft -= 4;  		Items.Add (textItem);  	}  }  
Magic Number,IdSharp.Tagging.ID3v2.Frames,SynchronizedText,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\Frames\SynchronizedText.cs,Read,The following statement contains a magic number: if (bytesLeft >= 4) {  	SynchronizedTextItem textItem = new SynchronizedTextItem ();  	textItem.Text = lyrics;  	textItem.Timestamp = stream.ReadInt32 ();  	bytesLeft -= 4;  	Items.Add (textItem);  }  
Magic Number,IdSharp.Tagging.ID3v2.Frames,SynchronizedText,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\Frames\SynchronizedText.cs,Read,The following statement contains a magic number: if (bytesLeft >= 4) {  	SynchronizedTextItem textItem = new SynchronizedTextItem ();  	textItem.Text = lyrics;  	textItem.Timestamp = stream.ReadInt32 ();  	bytesLeft -= 4;  	Items.Add (textItem);  }  
Magic Number,IdSharp.Tagging.ID3v2.Frames,SynchronizedText,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\Frames\SynchronizedText.cs,Read,The following statement contains a magic number: bytesLeft -= 4;  
Magic Number,IdSharp.Tagging.ID3v2.Frames,TermsOfUse,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\Frames\TermsOfUse.cs,Read,The following statement contains a magic number: if (bytesLeft >= 1) {  	TextEncoding = (EncodingType)stream.Read1 (ref bytesLeft);  	if (bytesLeft >= 3) {  		LanguageCode = ID3v2Utils.ReadString (EncodingType.ISO88591' stream' 3);  		bytesLeft -= 3;  		if (bytesLeft > 0) {  			Value = ID3v2Utils.ReadString (TextEncoding' stream' bytesLeft);  			bytesLeft = 0;  		}  	} else {  		LanguageCode = "eng";  	}  } else {  	TextEncoding = EncodingType.ISO88591;  	LanguageCode = "eng";  }  
Magic Number,IdSharp.Tagging.ID3v2.Frames,TermsOfUse,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\Frames\TermsOfUse.cs,Read,The following statement contains a magic number: if (bytesLeft >= 1) {  	TextEncoding = (EncodingType)stream.Read1 (ref bytesLeft);  	if (bytesLeft >= 3) {  		LanguageCode = ID3v2Utils.ReadString (EncodingType.ISO88591' stream' 3);  		bytesLeft -= 3;  		if (bytesLeft > 0) {  			Value = ID3v2Utils.ReadString (TextEncoding' stream' bytesLeft);  			bytesLeft = 0;  		}  	} else {  		LanguageCode = "eng";  	}  } else {  	TextEncoding = EncodingType.ISO88591;  	LanguageCode = "eng";  }  
Magic Number,IdSharp.Tagging.ID3v2.Frames,TermsOfUse,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\Frames\TermsOfUse.cs,Read,The following statement contains a magic number: if (bytesLeft >= 1) {  	TextEncoding = (EncodingType)stream.Read1 (ref bytesLeft);  	if (bytesLeft >= 3) {  		LanguageCode = ID3v2Utils.ReadString (EncodingType.ISO88591' stream' 3);  		bytesLeft -= 3;  		if (bytesLeft > 0) {  			Value = ID3v2Utils.ReadString (TextEncoding' stream' bytesLeft);  			bytesLeft = 0;  		}  	} else {  		LanguageCode = "eng";  	}  } else {  	TextEncoding = EncodingType.ISO88591;  	LanguageCode = "eng";  }  
Magic Number,IdSharp.Tagging.ID3v2.Frames,TermsOfUse,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\Frames\TermsOfUse.cs,Read,The following statement contains a magic number: if (bytesLeft >= 3) {  	LanguageCode = ID3v2Utils.ReadString (EncodingType.ISO88591' stream' 3);  	bytesLeft -= 3;  	if (bytesLeft > 0) {  		Value = ID3v2Utils.ReadString (TextEncoding' stream' bytesLeft);  		bytesLeft = 0;  	}  } else {  	LanguageCode = "eng";  }  
Magic Number,IdSharp.Tagging.ID3v2.Frames,TermsOfUse,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\Frames\TermsOfUse.cs,Read,The following statement contains a magic number: if (bytesLeft >= 3) {  	LanguageCode = ID3v2Utils.ReadString (EncodingType.ISO88591' stream' 3);  	bytesLeft -= 3;  	if (bytesLeft > 0) {  		Value = ID3v2Utils.ReadString (TextEncoding' stream' bytesLeft);  		bytesLeft = 0;  	}  } else {  	LanguageCode = "eng";  }  
Magic Number,IdSharp.Tagging.ID3v2.Frames,TermsOfUse,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\Frames\TermsOfUse.cs,Read,The following statement contains a magic number: if (bytesLeft >= 3) {  	LanguageCode = ID3v2Utils.ReadString (EncodingType.ISO88591' stream' 3);  	bytesLeft -= 3;  	if (bytesLeft > 0) {  		Value = ID3v2Utils.ReadString (TextEncoding' stream' bytesLeft);  		bytesLeft = 0;  	}  } else {  	LanguageCode = "eng";  }  
Magic Number,IdSharp.Tagging.ID3v2.Frames,TermsOfUse,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\Frames\TermsOfUse.cs,Read,The following statement contains a magic number: LanguageCode = ID3v2Utils.ReadString (EncodingType.ISO88591' stream' 3);  
Magic Number,IdSharp.Tagging.ID3v2.Frames,TermsOfUse,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\Frames\TermsOfUse.cs,Read,The following statement contains a magic number: bytesLeft -= 3;  
Magic Number,IdSharp.Tagging.ID3v2.Frames,RelativeVolumeAdjustment,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\Frames\RelativeVolumeAdjustment.cs,Read,The following statement contains a magic number: if (bytesLeft > 0) {  	// todo: there needs to be some kind of a test to see if this is RVAD/RVA2 format' too  	// much varying implementation in 2.3 and 2.4  	bool isRVA2 = (_frameHeader.TagVersion == ID3v2TagVersion.ID3v24);  	if (isRVA2) {  		// sometimes "identification" is completely ommitted... grr  		Identification = ID3v2Utils.ReadString (EncodingType.ISO88591' stream' ref bytesLeft);  		while (bytesLeft >= 3) {  			// TODO: Implementation not complete  			byte channelType = stream.Read1 (ref bytesLeft);  			//if (channelType == 16) break; // Invalid' probably stored as an ID3v2.3 RVAD frame  			// TODO: some kind of switch.. maybe a new internal enum  			short volumeAdjustment = stream.ReadInt16 (ref bytesLeft);  			if (bytesLeft > 0) {  				// sometimes represented as BITS representing peak.. seriously.  				byte bytesRepresentingPeak = stream.Read1 (ref bytesLeft);  				if (bytesRepresentingPeak == 0)  					break;  				if (bytesLeft >= bytesRepresentingPeak) {  					// TODO: Finish implementation  					byte[] peakVolume = stream.Read (bytesRepresentingPeak);  					bytesLeft -= peakVolume.Length;  				} else {  					break;  				}  			}  		}  		if (bytesLeft > 0) {  			//Trace.WriteLine("Invalid RVA2 frame");  			//stream.Seek(bytesLeft' SeekOrigin.Current);  			//bytesLeft = 0;  			// Try to read it like an ID3v2.3 RVAD frame  			stream.Seek (bytesLeft - _frameHeader.FrameSizeExcludingAdditions' SeekOrigin.Current);  			bytesLeft = _frameHeader.FrameSizeExcludingAdditions;  			isRVA2 = false;  		} else {  			// TODO  			//MessageBox.Show("valid RVA2 frame' omg!");  		}  	}  	// ID3v2.2' ID3v2.3' or mal-formed ID3v2.4  	if (isRVA2 == false) {  		byte incrementDecrement = stream.Read1 (ref bytesLeft);  		if (bytesLeft > 0) {  			byte bitsUsedForVolumeDescription = stream.Read1 (ref bytesLeft);  			int bytesUsedForVolumeDescription = bitsUsedForVolumeDescription / 8;  			// TODO: (may be useful for testing which implementation)  			// if bits used for volume description is > 64' don't bother  			// Relative volume change' right  			if (bytesLeft >= bytesUsedForVolumeDescription) {  				byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  				FrontRightAdjustment = ByteUtils.ConvertToInt64 (byteArray) * (ByteUtils.IsBitSet (incrementDecrement' 0) ? 1 : -1);  			}  			// Relative volume change' left  			if (bytesLeft >= bytesUsedForVolumeDescription) {  				byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  				FrontLeftAdjustment = ByteUtils.ConvertToInt64 (byteArray) * (ByteUtils.IsBitSet (incrementDecrement' 1) ? 1 : -1);  			}  			// Peak volume right  			if (bytesLeft >= bytesUsedForVolumeDescription) {  				byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  				FrontRightPeak = ByteUtils.ConvertToInt64 (byteArray);  			}  			// Peak volume left  			if (bytesLeft >= bytesUsedForVolumeDescription) {  				byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  				FrontLeftPeak = ByteUtils.ConvertToInt64 (byteArray);  			}  			// Relative volume change' right back  			if (bytesLeft >= bytesUsedForVolumeDescription) {  				byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  				BackRightAdjustment = ByteUtils.ConvertToInt64 (byteArray) * (ByteUtils.IsBitSet (incrementDecrement' 2) ? 1 : -1);  			}  			// Relative volume change' left back  			if (bytesLeft >= bytesUsedForVolumeDescription) {  				byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  				BackLeftAdjustment = ByteUtils.ConvertToInt64 (byteArray) * (ByteUtils.IsBitSet (incrementDecrement' 3) ? 1 : -1);  			}  			// Peak volume right back  			if (bytesLeft >= bytesUsedForVolumeDescription) {  				byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  				BackRightPeak = ByteUtils.ConvertToInt64 (byteArray);  			}  			// Peak volume left back  			if (bytesLeft >= bytesUsedForVolumeDescription) {  				byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  				BackLeftPeak = ByteUtils.ConvertToInt64 (byteArray);  			}  			// Relative volume change' center  			if (bytesLeft >= bytesUsedForVolumeDescription) {  				byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  				FrontCenterAdjustment = ByteUtils.ConvertToInt64 (byteArray) * (ByteUtils.IsBitSet (incrementDecrement' 4) ? 1 : -1);  			}  			// Peak volume center  			if (bytesLeft >= bytesUsedForVolumeDescription) {  				byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  				FrontCenterPeak = ByteUtils.ConvertToInt64 (byteArray);  			}  			// Relative volume change' bass  			if (bytesLeft >= bytesUsedForVolumeDescription) {  				byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  				SubwooferAdjustment = ByteUtils.ConvertToInt64 (byteArray) * (ByteUtils.IsBitSet (incrementDecrement' 5) ? 1 : -1);  			}  			// Peak volume bass  			if (bytesLeft >= bytesUsedForVolumeDescription) {  				byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  				SubwooferPeak = ByteUtils.ConvertToInt64 (byteArray);  			}  		}  	}  	// Skip past the rest of the frame  	if (bytesLeft > 0) {  		Trace.WriteLine ("Invalid RVA2/RVAD/RVA frame");  		stream.Seek (bytesLeft' SeekOrigin.Current);  		//bytesLeft = 0;  	}  }  
Magic Number,IdSharp.Tagging.ID3v2.Frames,RelativeVolumeAdjustment,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\Frames\RelativeVolumeAdjustment.cs,Read,The following statement contains a magic number: if (bytesLeft > 0) {  	// todo: there needs to be some kind of a test to see if this is RVAD/RVA2 format' too  	// much varying implementation in 2.3 and 2.4  	bool isRVA2 = (_frameHeader.TagVersion == ID3v2TagVersion.ID3v24);  	if (isRVA2) {  		// sometimes "identification" is completely ommitted... grr  		Identification = ID3v2Utils.ReadString (EncodingType.ISO88591' stream' ref bytesLeft);  		while (bytesLeft >= 3) {  			// TODO: Implementation not complete  			byte channelType = stream.Read1 (ref bytesLeft);  			//if (channelType == 16) break; // Invalid' probably stored as an ID3v2.3 RVAD frame  			// TODO: some kind of switch.. maybe a new internal enum  			short volumeAdjustment = stream.ReadInt16 (ref bytesLeft);  			if (bytesLeft > 0) {  				// sometimes represented as BITS representing peak.. seriously.  				byte bytesRepresentingPeak = stream.Read1 (ref bytesLeft);  				if (bytesRepresentingPeak == 0)  					break;  				if (bytesLeft >= bytesRepresentingPeak) {  					// TODO: Finish implementation  					byte[] peakVolume = stream.Read (bytesRepresentingPeak);  					bytesLeft -= peakVolume.Length;  				} else {  					break;  				}  			}  		}  		if (bytesLeft > 0) {  			//Trace.WriteLine("Invalid RVA2 frame");  			//stream.Seek(bytesLeft' SeekOrigin.Current);  			//bytesLeft = 0;  			// Try to read it like an ID3v2.3 RVAD frame  			stream.Seek (bytesLeft - _frameHeader.FrameSizeExcludingAdditions' SeekOrigin.Current);  			bytesLeft = _frameHeader.FrameSizeExcludingAdditions;  			isRVA2 = false;  		} else {  			// TODO  			//MessageBox.Show("valid RVA2 frame' omg!");  		}  	}  	// ID3v2.2' ID3v2.3' or mal-formed ID3v2.4  	if (isRVA2 == false) {  		byte incrementDecrement = stream.Read1 (ref bytesLeft);  		if (bytesLeft > 0) {  			byte bitsUsedForVolumeDescription = stream.Read1 (ref bytesLeft);  			int bytesUsedForVolumeDescription = bitsUsedForVolumeDescription / 8;  			// TODO: (may be useful for testing which implementation)  			// if bits used for volume description is > 64' don't bother  			// Relative volume change' right  			if (bytesLeft >= bytesUsedForVolumeDescription) {  				byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  				FrontRightAdjustment = ByteUtils.ConvertToInt64 (byteArray) * (ByteUtils.IsBitSet (incrementDecrement' 0) ? 1 : -1);  			}  			// Relative volume change' left  			if (bytesLeft >= bytesUsedForVolumeDescription) {  				byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  				FrontLeftAdjustment = ByteUtils.ConvertToInt64 (byteArray) * (ByteUtils.IsBitSet (incrementDecrement' 1) ? 1 : -1);  			}  			// Peak volume right  			if (bytesLeft >= bytesUsedForVolumeDescription) {  				byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  				FrontRightPeak = ByteUtils.ConvertToInt64 (byteArray);  			}  			// Peak volume left  			if (bytesLeft >= bytesUsedForVolumeDescription) {  				byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  				FrontLeftPeak = ByteUtils.ConvertToInt64 (byteArray);  			}  			// Relative volume change' right back  			if (bytesLeft >= bytesUsedForVolumeDescription) {  				byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  				BackRightAdjustment = ByteUtils.ConvertToInt64 (byteArray) * (ByteUtils.IsBitSet (incrementDecrement' 2) ? 1 : -1);  			}  			// Relative volume change' left back  			if (bytesLeft >= bytesUsedForVolumeDescription) {  				byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  				BackLeftAdjustment = ByteUtils.ConvertToInt64 (byteArray) * (ByteUtils.IsBitSet (incrementDecrement' 3) ? 1 : -1);  			}  			// Peak volume right back  			if (bytesLeft >= bytesUsedForVolumeDescription) {  				byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  				BackRightPeak = ByteUtils.ConvertToInt64 (byteArray);  			}  			// Peak volume left back  			if (bytesLeft >= bytesUsedForVolumeDescription) {  				byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  				BackLeftPeak = ByteUtils.ConvertToInt64 (byteArray);  			}  			// Relative volume change' center  			if (bytesLeft >= bytesUsedForVolumeDescription) {  				byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  				FrontCenterAdjustment = ByteUtils.ConvertToInt64 (byteArray) * (ByteUtils.IsBitSet (incrementDecrement' 4) ? 1 : -1);  			}  			// Peak volume center  			if (bytesLeft >= bytesUsedForVolumeDescription) {  				byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  				FrontCenterPeak = ByteUtils.ConvertToInt64 (byteArray);  			}  			// Relative volume change' bass  			if (bytesLeft >= bytesUsedForVolumeDescription) {  				byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  				SubwooferAdjustment = ByteUtils.ConvertToInt64 (byteArray) * (ByteUtils.IsBitSet (incrementDecrement' 5) ? 1 : -1);  			}  			// Peak volume bass  			if (bytesLeft >= bytesUsedForVolumeDescription) {  				byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  				SubwooferPeak = ByteUtils.ConvertToInt64 (byteArray);  			}  		}  	}  	// Skip past the rest of the frame  	if (bytesLeft > 0) {  		Trace.WriteLine ("Invalid RVA2/RVAD/RVA frame");  		stream.Seek (bytesLeft' SeekOrigin.Current);  		//bytesLeft = 0;  	}  }  
Magic Number,IdSharp.Tagging.ID3v2.Frames,RelativeVolumeAdjustment,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\Frames\RelativeVolumeAdjustment.cs,Read,The following statement contains a magic number: if (bytesLeft > 0) {  	// todo: there needs to be some kind of a test to see if this is RVAD/RVA2 format' too  	// much varying implementation in 2.3 and 2.4  	bool isRVA2 = (_frameHeader.TagVersion == ID3v2TagVersion.ID3v24);  	if (isRVA2) {  		// sometimes "identification" is completely ommitted... grr  		Identification = ID3v2Utils.ReadString (EncodingType.ISO88591' stream' ref bytesLeft);  		while (bytesLeft >= 3) {  			// TODO: Implementation not complete  			byte channelType = stream.Read1 (ref bytesLeft);  			//if (channelType == 16) break; // Invalid' probably stored as an ID3v2.3 RVAD frame  			// TODO: some kind of switch.. maybe a new internal enum  			short volumeAdjustment = stream.ReadInt16 (ref bytesLeft);  			if (bytesLeft > 0) {  				// sometimes represented as BITS representing peak.. seriously.  				byte bytesRepresentingPeak = stream.Read1 (ref bytesLeft);  				if (bytesRepresentingPeak == 0)  					break;  				if (bytesLeft >= bytesRepresentingPeak) {  					// TODO: Finish implementation  					byte[] peakVolume = stream.Read (bytesRepresentingPeak);  					bytesLeft -= peakVolume.Length;  				} else {  					break;  				}  			}  		}  		if (bytesLeft > 0) {  			//Trace.WriteLine("Invalid RVA2 frame");  			//stream.Seek(bytesLeft' SeekOrigin.Current);  			//bytesLeft = 0;  			// Try to read it like an ID3v2.3 RVAD frame  			stream.Seek (bytesLeft - _frameHeader.FrameSizeExcludingAdditions' SeekOrigin.Current);  			bytesLeft = _frameHeader.FrameSizeExcludingAdditions;  			isRVA2 = false;  		} else {  			// TODO  			//MessageBox.Show("valid RVA2 frame' omg!");  		}  	}  	// ID3v2.2' ID3v2.3' or mal-formed ID3v2.4  	if (isRVA2 == false) {  		byte incrementDecrement = stream.Read1 (ref bytesLeft);  		if (bytesLeft > 0) {  			byte bitsUsedForVolumeDescription = stream.Read1 (ref bytesLeft);  			int bytesUsedForVolumeDescription = bitsUsedForVolumeDescription / 8;  			// TODO: (may be useful for testing which implementation)  			// if bits used for volume description is > 64' don't bother  			// Relative volume change' right  			if (bytesLeft >= bytesUsedForVolumeDescription) {  				byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  				FrontRightAdjustment = ByteUtils.ConvertToInt64 (byteArray) * (ByteUtils.IsBitSet (incrementDecrement' 0) ? 1 : -1);  			}  			// Relative volume change' left  			if (bytesLeft >= bytesUsedForVolumeDescription) {  				byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  				FrontLeftAdjustment = ByteUtils.ConvertToInt64 (byteArray) * (ByteUtils.IsBitSet (incrementDecrement' 1) ? 1 : -1);  			}  			// Peak volume right  			if (bytesLeft >= bytesUsedForVolumeDescription) {  				byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  				FrontRightPeak = ByteUtils.ConvertToInt64 (byteArray);  			}  			// Peak volume left  			if (bytesLeft >= bytesUsedForVolumeDescription) {  				byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  				FrontLeftPeak = ByteUtils.ConvertToInt64 (byteArray);  			}  			// Relative volume change' right back  			if (bytesLeft >= bytesUsedForVolumeDescription) {  				byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  				BackRightAdjustment = ByteUtils.ConvertToInt64 (byteArray) * (ByteUtils.IsBitSet (incrementDecrement' 2) ? 1 : -1);  			}  			// Relative volume change' left back  			if (bytesLeft >= bytesUsedForVolumeDescription) {  				byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  				BackLeftAdjustment = ByteUtils.ConvertToInt64 (byteArray) * (ByteUtils.IsBitSet (incrementDecrement' 3) ? 1 : -1);  			}  			// Peak volume right back  			if (bytesLeft >= bytesUsedForVolumeDescription) {  				byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  				BackRightPeak = ByteUtils.ConvertToInt64 (byteArray);  			}  			// Peak volume left back  			if (bytesLeft >= bytesUsedForVolumeDescription) {  				byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  				BackLeftPeak = ByteUtils.ConvertToInt64 (byteArray);  			}  			// Relative volume change' center  			if (bytesLeft >= bytesUsedForVolumeDescription) {  				byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  				FrontCenterAdjustment = ByteUtils.ConvertToInt64 (byteArray) * (ByteUtils.IsBitSet (incrementDecrement' 4) ? 1 : -1);  			}  			// Peak volume center  			if (bytesLeft >= bytesUsedForVolumeDescription) {  				byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  				FrontCenterPeak = ByteUtils.ConvertToInt64 (byteArray);  			}  			// Relative volume change' bass  			if (bytesLeft >= bytesUsedForVolumeDescription) {  				byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  				SubwooferAdjustment = ByteUtils.ConvertToInt64 (byteArray) * (ByteUtils.IsBitSet (incrementDecrement' 5) ? 1 : -1);  			}  			// Peak volume bass  			if (bytesLeft >= bytesUsedForVolumeDescription) {  				byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  				SubwooferPeak = ByteUtils.ConvertToInt64 (byteArray);  			}  		}  	}  	// Skip past the rest of the frame  	if (bytesLeft > 0) {  		Trace.WriteLine ("Invalid RVA2/RVAD/RVA frame");  		stream.Seek (bytesLeft' SeekOrigin.Current);  		//bytesLeft = 0;  	}  }  
Magic Number,IdSharp.Tagging.ID3v2.Frames,RelativeVolumeAdjustment,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\Frames\RelativeVolumeAdjustment.cs,Read,The following statement contains a magic number: if (bytesLeft > 0) {  	// todo: there needs to be some kind of a test to see if this is RVAD/RVA2 format' too  	// much varying implementation in 2.3 and 2.4  	bool isRVA2 = (_frameHeader.TagVersion == ID3v2TagVersion.ID3v24);  	if (isRVA2) {  		// sometimes "identification" is completely ommitted... grr  		Identification = ID3v2Utils.ReadString (EncodingType.ISO88591' stream' ref bytesLeft);  		while (bytesLeft >= 3) {  			// TODO: Implementation not complete  			byte channelType = stream.Read1 (ref bytesLeft);  			//if (channelType == 16) break; // Invalid' probably stored as an ID3v2.3 RVAD frame  			// TODO: some kind of switch.. maybe a new internal enum  			short volumeAdjustment = stream.ReadInt16 (ref bytesLeft);  			if (bytesLeft > 0) {  				// sometimes represented as BITS representing peak.. seriously.  				byte bytesRepresentingPeak = stream.Read1 (ref bytesLeft);  				if (bytesRepresentingPeak == 0)  					break;  				if (bytesLeft >= bytesRepresentingPeak) {  					// TODO: Finish implementation  					byte[] peakVolume = stream.Read (bytesRepresentingPeak);  					bytesLeft -= peakVolume.Length;  				} else {  					break;  				}  			}  		}  		if (bytesLeft > 0) {  			//Trace.WriteLine("Invalid RVA2 frame");  			//stream.Seek(bytesLeft' SeekOrigin.Current);  			//bytesLeft = 0;  			// Try to read it like an ID3v2.3 RVAD frame  			stream.Seek (bytesLeft - _frameHeader.FrameSizeExcludingAdditions' SeekOrigin.Current);  			bytesLeft = _frameHeader.FrameSizeExcludingAdditions;  			isRVA2 = false;  		} else {  			// TODO  			//MessageBox.Show("valid RVA2 frame' omg!");  		}  	}  	// ID3v2.2' ID3v2.3' or mal-formed ID3v2.4  	if (isRVA2 == false) {  		byte incrementDecrement = stream.Read1 (ref bytesLeft);  		if (bytesLeft > 0) {  			byte bitsUsedForVolumeDescription = stream.Read1 (ref bytesLeft);  			int bytesUsedForVolumeDescription = bitsUsedForVolumeDescription / 8;  			// TODO: (may be useful for testing which implementation)  			// if bits used for volume description is > 64' don't bother  			// Relative volume change' right  			if (bytesLeft >= bytesUsedForVolumeDescription) {  				byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  				FrontRightAdjustment = ByteUtils.ConvertToInt64 (byteArray) * (ByteUtils.IsBitSet (incrementDecrement' 0) ? 1 : -1);  			}  			// Relative volume change' left  			if (bytesLeft >= bytesUsedForVolumeDescription) {  				byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  				FrontLeftAdjustment = ByteUtils.ConvertToInt64 (byteArray) * (ByteUtils.IsBitSet (incrementDecrement' 1) ? 1 : -1);  			}  			// Peak volume right  			if (bytesLeft >= bytesUsedForVolumeDescription) {  				byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  				FrontRightPeak = ByteUtils.ConvertToInt64 (byteArray);  			}  			// Peak volume left  			if (bytesLeft >= bytesUsedForVolumeDescription) {  				byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  				FrontLeftPeak = ByteUtils.ConvertToInt64 (byteArray);  			}  			// Relative volume change' right back  			if (bytesLeft >= bytesUsedForVolumeDescription) {  				byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  				BackRightAdjustment = ByteUtils.ConvertToInt64 (byteArray) * (ByteUtils.IsBitSet (incrementDecrement' 2) ? 1 : -1);  			}  			// Relative volume change' left back  			if (bytesLeft >= bytesUsedForVolumeDescription) {  				byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  				BackLeftAdjustment = ByteUtils.ConvertToInt64 (byteArray) * (ByteUtils.IsBitSet (incrementDecrement' 3) ? 1 : -1);  			}  			// Peak volume right back  			if (bytesLeft >= bytesUsedForVolumeDescription) {  				byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  				BackRightPeak = ByteUtils.ConvertToInt64 (byteArray);  			}  			// Peak volume left back  			if (bytesLeft >= bytesUsedForVolumeDescription) {  				byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  				BackLeftPeak = ByteUtils.ConvertToInt64 (byteArray);  			}  			// Relative volume change' center  			if (bytesLeft >= bytesUsedForVolumeDescription) {  				byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  				FrontCenterAdjustment = ByteUtils.ConvertToInt64 (byteArray) * (ByteUtils.IsBitSet (incrementDecrement' 4) ? 1 : -1);  			}  			// Peak volume center  			if (bytesLeft >= bytesUsedForVolumeDescription) {  				byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  				FrontCenterPeak = ByteUtils.ConvertToInt64 (byteArray);  			}  			// Relative volume change' bass  			if (bytesLeft >= bytesUsedForVolumeDescription) {  				byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  				SubwooferAdjustment = ByteUtils.ConvertToInt64 (byteArray) * (ByteUtils.IsBitSet (incrementDecrement' 5) ? 1 : -1);  			}  			// Peak volume bass  			if (bytesLeft >= bytesUsedForVolumeDescription) {  				byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  				SubwooferPeak = ByteUtils.ConvertToInt64 (byteArray);  			}  		}  	}  	// Skip past the rest of the frame  	if (bytesLeft > 0) {  		Trace.WriteLine ("Invalid RVA2/RVAD/RVA frame");  		stream.Seek (bytesLeft' SeekOrigin.Current);  		//bytesLeft = 0;  	}  }  
Magic Number,IdSharp.Tagging.ID3v2.Frames,RelativeVolumeAdjustment,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\Frames\RelativeVolumeAdjustment.cs,Read,The following statement contains a magic number: if (bytesLeft > 0) {  	// todo: there needs to be some kind of a test to see if this is RVAD/RVA2 format' too  	// much varying implementation in 2.3 and 2.4  	bool isRVA2 = (_frameHeader.TagVersion == ID3v2TagVersion.ID3v24);  	if (isRVA2) {  		// sometimes "identification" is completely ommitted... grr  		Identification = ID3v2Utils.ReadString (EncodingType.ISO88591' stream' ref bytesLeft);  		while (bytesLeft >= 3) {  			// TODO: Implementation not complete  			byte channelType = stream.Read1 (ref bytesLeft);  			//if (channelType == 16) break; // Invalid' probably stored as an ID3v2.3 RVAD frame  			// TODO: some kind of switch.. maybe a new internal enum  			short volumeAdjustment = stream.ReadInt16 (ref bytesLeft);  			if (bytesLeft > 0) {  				// sometimes represented as BITS representing peak.. seriously.  				byte bytesRepresentingPeak = stream.Read1 (ref bytesLeft);  				if (bytesRepresentingPeak == 0)  					break;  				if (bytesLeft >= bytesRepresentingPeak) {  					// TODO: Finish implementation  					byte[] peakVolume = stream.Read (bytesRepresentingPeak);  					bytesLeft -= peakVolume.Length;  				} else {  					break;  				}  			}  		}  		if (bytesLeft > 0) {  			//Trace.WriteLine("Invalid RVA2 frame");  			//stream.Seek(bytesLeft' SeekOrigin.Current);  			//bytesLeft = 0;  			// Try to read it like an ID3v2.3 RVAD frame  			stream.Seek (bytesLeft - _frameHeader.FrameSizeExcludingAdditions' SeekOrigin.Current);  			bytesLeft = _frameHeader.FrameSizeExcludingAdditions;  			isRVA2 = false;  		} else {  			// TODO  			//MessageBox.Show("valid RVA2 frame' omg!");  		}  	}  	// ID3v2.2' ID3v2.3' or mal-formed ID3v2.4  	if (isRVA2 == false) {  		byte incrementDecrement = stream.Read1 (ref bytesLeft);  		if (bytesLeft > 0) {  			byte bitsUsedForVolumeDescription = stream.Read1 (ref bytesLeft);  			int bytesUsedForVolumeDescription = bitsUsedForVolumeDescription / 8;  			// TODO: (may be useful for testing which implementation)  			// if bits used for volume description is > 64' don't bother  			// Relative volume change' right  			if (bytesLeft >= bytesUsedForVolumeDescription) {  				byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  				FrontRightAdjustment = ByteUtils.ConvertToInt64 (byteArray) * (ByteUtils.IsBitSet (incrementDecrement' 0) ? 1 : -1);  			}  			// Relative volume change' left  			if (bytesLeft >= bytesUsedForVolumeDescription) {  				byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  				FrontLeftAdjustment = ByteUtils.ConvertToInt64 (byteArray) * (ByteUtils.IsBitSet (incrementDecrement' 1) ? 1 : -1);  			}  			// Peak volume right  			if (bytesLeft >= bytesUsedForVolumeDescription) {  				byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  				FrontRightPeak = ByteUtils.ConvertToInt64 (byteArray);  			}  			// Peak volume left  			if (bytesLeft >= bytesUsedForVolumeDescription) {  				byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  				FrontLeftPeak = ByteUtils.ConvertToInt64 (byteArray);  			}  			// Relative volume change' right back  			if (bytesLeft >= bytesUsedForVolumeDescription) {  				byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  				BackRightAdjustment = ByteUtils.ConvertToInt64 (byteArray) * (ByteUtils.IsBitSet (incrementDecrement' 2) ? 1 : -1);  			}  			// Relative volume change' left back  			if (bytesLeft >= bytesUsedForVolumeDescription) {  				byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  				BackLeftAdjustment = ByteUtils.ConvertToInt64 (byteArray) * (ByteUtils.IsBitSet (incrementDecrement' 3) ? 1 : -1);  			}  			// Peak volume right back  			if (bytesLeft >= bytesUsedForVolumeDescription) {  				byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  				BackRightPeak = ByteUtils.ConvertToInt64 (byteArray);  			}  			// Peak volume left back  			if (bytesLeft >= bytesUsedForVolumeDescription) {  				byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  				BackLeftPeak = ByteUtils.ConvertToInt64 (byteArray);  			}  			// Relative volume change' center  			if (bytesLeft >= bytesUsedForVolumeDescription) {  				byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  				FrontCenterAdjustment = ByteUtils.ConvertToInt64 (byteArray) * (ByteUtils.IsBitSet (incrementDecrement' 4) ? 1 : -1);  			}  			// Peak volume center  			if (bytesLeft >= bytesUsedForVolumeDescription) {  				byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  				FrontCenterPeak = ByteUtils.ConvertToInt64 (byteArray);  			}  			// Relative volume change' bass  			if (bytesLeft >= bytesUsedForVolumeDescription) {  				byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  				SubwooferAdjustment = ByteUtils.ConvertToInt64 (byteArray) * (ByteUtils.IsBitSet (incrementDecrement' 5) ? 1 : -1);  			}  			// Peak volume bass  			if (bytesLeft >= bytesUsedForVolumeDescription) {  				byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  				SubwooferPeak = ByteUtils.ConvertToInt64 (byteArray);  			}  		}  	}  	// Skip past the rest of the frame  	if (bytesLeft > 0) {  		Trace.WriteLine ("Invalid RVA2/RVAD/RVA frame");  		stream.Seek (bytesLeft' SeekOrigin.Current);  		//bytesLeft = 0;  	}  }  
Magic Number,IdSharp.Tagging.ID3v2.Frames,RelativeVolumeAdjustment,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\Frames\RelativeVolumeAdjustment.cs,Read,The following statement contains a magic number: if (bytesLeft > 0) {  	// todo: there needs to be some kind of a test to see if this is RVAD/RVA2 format' too  	// much varying implementation in 2.3 and 2.4  	bool isRVA2 = (_frameHeader.TagVersion == ID3v2TagVersion.ID3v24);  	if (isRVA2) {  		// sometimes "identification" is completely ommitted... grr  		Identification = ID3v2Utils.ReadString (EncodingType.ISO88591' stream' ref bytesLeft);  		while (bytesLeft >= 3) {  			// TODO: Implementation not complete  			byte channelType = stream.Read1 (ref bytesLeft);  			//if (channelType == 16) break; // Invalid' probably stored as an ID3v2.3 RVAD frame  			// TODO: some kind of switch.. maybe a new internal enum  			short volumeAdjustment = stream.ReadInt16 (ref bytesLeft);  			if (bytesLeft > 0) {  				// sometimes represented as BITS representing peak.. seriously.  				byte bytesRepresentingPeak = stream.Read1 (ref bytesLeft);  				if (bytesRepresentingPeak == 0)  					break;  				if (bytesLeft >= bytesRepresentingPeak) {  					// TODO: Finish implementation  					byte[] peakVolume = stream.Read (bytesRepresentingPeak);  					bytesLeft -= peakVolume.Length;  				} else {  					break;  				}  			}  		}  		if (bytesLeft > 0) {  			//Trace.WriteLine("Invalid RVA2 frame");  			//stream.Seek(bytesLeft' SeekOrigin.Current);  			//bytesLeft = 0;  			// Try to read it like an ID3v2.3 RVAD frame  			stream.Seek (bytesLeft - _frameHeader.FrameSizeExcludingAdditions' SeekOrigin.Current);  			bytesLeft = _frameHeader.FrameSizeExcludingAdditions;  			isRVA2 = false;  		} else {  			// TODO  			//MessageBox.Show("valid RVA2 frame' omg!");  		}  	}  	// ID3v2.2' ID3v2.3' or mal-formed ID3v2.4  	if (isRVA2 == false) {  		byte incrementDecrement = stream.Read1 (ref bytesLeft);  		if (bytesLeft > 0) {  			byte bitsUsedForVolumeDescription = stream.Read1 (ref bytesLeft);  			int bytesUsedForVolumeDescription = bitsUsedForVolumeDescription / 8;  			// TODO: (may be useful for testing which implementation)  			// if bits used for volume description is > 64' don't bother  			// Relative volume change' right  			if (bytesLeft >= bytesUsedForVolumeDescription) {  				byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  				FrontRightAdjustment = ByteUtils.ConvertToInt64 (byteArray) * (ByteUtils.IsBitSet (incrementDecrement' 0) ? 1 : -1);  			}  			// Relative volume change' left  			if (bytesLeft >= bytesUsedForVolumeDescription) {  				byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  				FrontLeftAdjustment = ByteUtils.ConvertToInt64 (byteArray) * (ByteUtils.IsBitSet (incrementDecrement' 1) ? 1 : -1);  			}  			// Peak volume right  			if (bytesLeft >= bytesUsedForVolumeDescription) {  				byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  				FrontRightPeak = ByteUtils.ConvertToInt64 (byteArray);  			}  			// Peak volume left  			if (bytesLeft >= bytesUsedForVolumeDescription) {  				byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  				FrontLeftPeak = ByteUtils.ConvertToInt64 (byteArray);  			}  			// Relative volume change' right back  			if (bytesLeft >= bytesUsedForVolumeDescription) {  				byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  				BackRightAdjustment = ByteUtils.ConvertToInt64 (byteArray) * (ByteUtils.IsBitSet (incrementDecrement' 2) ? 1 : -1);  			}  			// Relative volume change' left back  			if (bytesLeft >= bytesUsedForVolumeDescription) {  				byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  				BackLeftAdjustment = ByteUtils.ConvertToInt64 (byteArray) * (ByteUtils.IsBitSet (incrementDecrement' 3) ? 1 : -1);  			}  			// Peak volume right back  			if (bytesLeft >= bytesUsedForVolumeDescription) {  				byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  				BackRightPeak = ByteUtils.ConvertToInt64 (byteArray);  			}  			// Peak volume left back  			if (bytesLeft >= bytesUsedForVolumeDescription) {  				byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  				BackLeftPeak = ByteUtils.ConvertToInt64 (byteArray);  			}  			// Relative volume change' center  			if (bytesLeft >= bytesUsedForVolumeDescription) {  				byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  				FrontCenterAdjustment = ByteUtils.ConvertToInt64 (byteArray) * (ByteUtils.IsBitSet (incrementDecrement' 4) ? 1 : -1);  			}  			// Peak volume center  			if (bytesLeft >= bytesUsedForVolumeDescription) {  				byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  				FrontCenterPeak = ByteUtils.ConvertToInt64 (byteArray);  			}  			// Relative volume change' bass  			if (bytesLeft >= bytesUsedForVolumeDescription) {  				byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  				SubwooferAdjustment = ByteUtils.ConvertToInt64 (byteArray) * (ByteUtils.IsBitSet (incrementDecrement' 5) ? 1 : -1);  			}  			// Peak volume bass  			if (bytesLeft >= bytesUsedForVolumeDescription) {  				byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  				SubwooferPeak = ByteUtils.ConvertToInt64 (byteArray);  			}  		}  	}  	// Skip past the rest of the frame  	if (bytesLeft > 0) {  		Trace.WriteLine ("Invalid RVA2/RVAD/RVA frame");  		stream.Seek (bytesLeft' SeekOrigin.Current);  		//bytesLeft = 0;  	}  }  
Magic Number,IdSharp.Tagging.ID3v2.Frames,RelativeVolumeAdjustment,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\Frames\RelativeVolumeAdjustment.cs,Read,The following statement contains a magic number: if (isRVA2) {  	// sometimes "identification" is completely ommitted... grr  	Identification = ID3v2Utils.ReadString (EncodingType.ISO88591' stream' ref bytesLeft);  	while (bytesLeft >= 3) {  		// TODO: Implementation not complete  		byte channelType = stream.Read1 (ref bytesLeft);  		//if (channelType == 16) break; // Invalid' probably stored as an ID3v2.3 RVAD frame  		// TODO: some kind of switch.. maybe a new internal enum  		short volumeAdjustment = stream.ReadInt16 (ref bytesLeft);  		if (bytesLeft > 0) {  			// sometimes represented as BITS representing peak.. seriously.  			byte bytesRepresentingPeak = stream.Read1 (ref bytesLeft);  			if (bytesRepresentingPeak == 0)  				break;  			if (bytesLeft >= bytesRepresentingPeak) {  				// TODO: Finish implementation  				byte[] peakVolume = stream.Read (bytesRepresentingPeak);  				bytesLeft -= peakVolume.Length;  			} else {  				break;  			}  		}  	}  	if (bytesLeft > 0) {  		//Trace.WriteLine("Invalid RVA2 frame");  		//stream.Seek(bytesLeft' SeekOrigin.Current);  		//bytesLeft = 0;  		// Try to read it like an ID3v2.3 RVAD frame  		stream.Seek (bytesLeft - _frameHeader.FrameSizeExcludingAdditions' SeekOrigin.Current);  		bytesLeft = _frameHeader.FrameSizeExcludingAdditions;  		isRVA2 = false;  	} else {  		// TODO  		//MessageBox.Show("valid RVA2 frame' omg!");  	}  }  
Magic Number,IdSharp.Tagging.ID3v2.Frames,RelativeVolumeAdjustment,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\Frames\RelativeVolumeAdjustment.cs,Read,The following statement contains a magic number: while (bytesLeft >= 3) {  	// TODO: Implementation not complete  	byte channelType = stream.Read1 (ref bytesLeft);  	//if (channelType == 16) break; // Invalid' probably stored as an ID3v2.3 RVAD frame  	// TODO: some kind of switch.. maybe a new internal enum  	short volumeAdjustment = stream.ReadInt16 (ref bytesLeft);  	if (bytesLeft > 0) {  		// sometimes represented as BITS representing peak.. seriously.  		byte bytesRepresentingPeak = stream.Read1 (ref bytesLeft);  		if (bytesRepresentingPeak == 0)  			break;  		if (bytesLeft >= bytesRepresentingPeak) {  			// TODO: Finish implementation  			byte[] peakVolume = stream.Read (bytesRepresentingPeak);  			bytesLeft -= peakVolume.Length;  		} else {  			break;  		}  	}  }  
Magic Number,IdSharp.Tagging.ID3v2.Frames,RelativeVolumeAdjustment,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\Frames\RelativeVolumeAdjustment.cs,Read,The following statement contains a magic number: if (isRVA2 == false) {  	byte incrementDecrement = stream.Read1 (ref bytesLeft);  	if (bytesLeft > 0) {  		byte bitsUsedForVolumeDescription = stream.Read1 (ref bytesLeft);  		int bytesUsedForVolumeDescription = bitsUsedForVolumeDescription / 8;  		// TODO: (may be useful for testing which implementation)  		// if bits used for volume description is > 64' don't bother  		// Relative volume change' right  		if (bytesLeft >= bytesUsedForVolumeDescription) {  			byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  			FrontRightAdjustment = ByteUtils.ConvertToInt64 (byteArray) * (ByteUtils.IsBitSet (incrementDecrement' 0) ? 1 : -1);  		}  		// Relative volume change' left  		if (bytesLeft >= bytesUsedForVolumeDescription) {  			byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  			FrontLeftAdjustment = ByteUtils.ConvertToInt64 (byteArray) * (ByteUtils.IsBitSet (incrementDecrement' 1) ? 1 : -1);  		}  		// Peak volume right  		if (bytesLeft >= bytesUsedForVolumeDescription) {  			byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  			FrontRightPeak = ByteUtils.ConvertToInt64 (byteArray);  		}  		// Peak volume left  		if (bytesLeft >= bytesUsedForVolumeDescription) {  			byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  			FrontLeftPeak = ByteUtils.ConvertToInt64 (byteArray);  		}  		// Relative volume change' right back  		if (bytesLeft >= bytesUsedForVolumeDescription) {  			byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  			BackRightAdjustment = ByteUtils.ConvertToInt64 (byteArray) * (ByteUtils.IsBitSet (incrementDecrement' 2) ? 1 : -1);  		}  		// Relative volume change' left back  		if (bytesLeft >= bytesUsedForVolumeDescription) {  			byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  			BackLeftAdjustment = ByteUtils.ConvertToInt64 (byteArray) * (ByteUtils.IsBitSet (incrementDecrement' 3) ? 1 : -1);  		}  		// Peak volume right back  		if (bytesLeft >= bytesUsedForVolumeDescription) {  			byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  			BackRightPeak = ByteUtils.ConvertToInt64 (byteArray);  		}  		// Peak volume left back  		if (bytesLeft >= bytesUsedForVolumeDescription) {  			byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  			BackLeftPeak = ByteUtils.ConvertToInt64 (byteArray);  		}  		// Relative volume change' center  		if (bytesLeft >= bytesUsedForVolumeDescription) {  			byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  			FrontCenterAdjustment = ByteUtils.ConvertToInt64 (byteArray) * (ByteUtils.IsBitSet (incrementDecrement' 4) ? 1 : -1);  		}  		// Peak volume center  		if (bytesLeft >= bytesUsedForVolumeDescription) {  			byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  			FrontCenterPeak = ByteUtils.ConvertToInt64 (byteArray);  		}  		// Relative volume change' bass  		if (bytesLeft >= bytesUsedForVolumeDescription) {  			byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  			SubwooferAdjustment = ByteUtils.ConvertToInt64 (byteArray) * (ByteUtils.IsBitSet (incrementDecrement' 5) ? 1 : -1);  		}  		// Peak volume bass  		if (bytesLeft >= bytesUsedForVolumeDescription) {  			byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  			SubwooferPeak = ByteUtils.ConvertToInt64 (byteArray);  		}  	}  }  
Magic Number,IdSharp.Tagging.ID3v2.Frames,RelativeVolumeAdjustment,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\Frames\RelativeVolumeAdjustment.cs,Read,The following statement contains a magic number: if (isRVA2 == false) {  	byte incrementDecrement = stream.Read1 (ref bytesLeft);  	if (bytesLeft > 0) {  		byte bitsUsedForVolumeDescription = stream.Read1 (ref bytesLeft);  		int bytesUsedForVolumeDescription = bitsUsedForVolumeDescription / 8;  		// TODO: (may be useful for testing which implementation)  		// if bits used for volume description is > 64' don't bother  		// Relative volume change' right  		if (bytesLeft >= bytesUsedForVolumeDescription) {  			byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  			FrontRightAdjustment = ByteUtils.ConvertToInt64 (byteArray) * (ByteUtils.IsBitSet (incrementDecrement' 0) ? 1 : -1);  		}  		// Relative volume change' left  		if (bytesLeft >= bytesUsedForVolumeDescription) {  			byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  			FrontLeftAdjustment = ByteUtils.ConvertToInt64 (byteArray) * (ByteUtils.IsBitSet (incrementDecrement' 1) ? 1 : -1);  		}  		// Peak volume right  		if (bytesLeft >= bytesUsedForVolumeDescription) {  			byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  			FrontRightPeak = ByteUtils.ConvertToInt64 (byteArray);  		}  		// Peak volume left  		if (bytesLeft >= bytesUsedForVolumeDescription) {  			byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  			FrontLeftPeak = ByteUtils.ConvertToInt64 (byteArray);  		}  		// Relative volume change' right back  		if (bytesLeft >= bytesUsedForVolumeDescription) {  			byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  			BackRightAdjustment = ByteUtils.ConvertToInt64 (byteArray) * (ByteUtils.IsBitSet (incrementDecrement' 2) ? 1 : -1);  		}  		// Relative volume change' left back  		if (bytesLeft >= bytesUsedForVolumeDescription) {  			byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  			BackLeftAdjustment = ByteUtils.ConvertToInt64 (byteArray) * (ByteUtils.IsBitSet (incrementDecrement' 3) ? 1 : -1);  		}  		// Peak volume right back  		if (bytesLeft >= bytesUsedForVolumeDescription) {  			byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  			BackRightPeak = ByteUtils.ConvertToInt64 (byteArray);  		}  		// Peak volume left back  		if (bytesLeft >= bytesUsedForVolumeDescription) {  			byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  			BackLeftPeak = ByteUtils.ConvertToInt64 (byteArray);  		}  		// Relative volume change' center  		if (bytesLeft >= bytesUsedForVolumeDescription) {  			byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  			FrontCenterAdjustment = ByteUtils.ConvertToInt64 (byteArray) * (ByteUtils.IsBitSet (incrementDecrement' 4) ? 1 : -1);  		}  		// Peak volume center  		if (bytesLeft >= bytesUsedForVolumeDescription) {  			byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  			FrontCenterPeak = ByteUtils.ConvertToInt64 (byteArray);  		}  		// Relative volume change' bass  		if (bytesLeft >= bytesUsedForVolumeDescription) {  			byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  			SubwooferAdjustment = ByteUtils.ConvertToInt64 (byteArray) * (ByteUtils.IsBitSet (incrementDecrement' 5) ? 1 : -1);  		}  		// Peak volume bass  		if (bytesLeft >= bytesUsedForVolumeDescription) {  			byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  			SubwooferPeak = ByteUtils.ConvertToInt64 (byteArray);  		}  	}  }  
Magic Number,IdSharp.Tagging.ID3v2.Frames,RelativeVolumeAdjustment,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\Frames\RelativeVolumeAdjustment.cs,Read,The following statement contains a magic number: if (isRVA2 == false) {  	byte incrementDecrement = stream.Read1 (ref bytesLeft);  	if (bytesLeft > 0) {  		byte bitsUsedForVolumeDescription = stream.Read1 (ref bytesLeft);  		int bytesUsedForVolumeDescription = bitsUsedForVolumeDescription / 8;  		// TODO: (may be useful for testing which implementation)  		// if bits used for volume description is > 64' don't bother  		// Relative volume change' right  		if (bytesLeft >= bytesUsedForVolumeDescription) {  			byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  			FrontRightAdjustment = ByteUtils.ConvertToInt64 (byteArray) * (ByteUtils.IsBitSet (incrementDecrement' 0) ? 1 : -1);  		}  		// Relative volume change' left  		if (bytesLeft >= bytesUsedForVolumeDescription) {  			byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  			FrontLeftAdjustment = ByteUtils.ConvertToInt64 (byteArray) * (ByteUtils.IsBitSet (incrementDecrement' 1) ? 1 : -1);  		}  		// Peak volume right  		if (bytesLeft >= bytesUsedForVolumeDescription) {  			byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  			FrontRightPeak = ByteUtils.ConvertToInt64 (byteArray);  		}  		// Peak volume left  		if (bytesLeft >= bytesUsedForVolumeDescription) {  			byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  			FrontLeftPeak = ByteUtils.ConvertToInt64 (byteArray);  		}  		// Relative volume change' right back  		if (bytesLeft >= bytesUsedForVolumeDescription) {  			byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  			BackRightAdjustment = ByteUtils.ConvertToInt64 (byteArray) * (ByteUtils.IsBitSet (incrementDecrement' 2) ? 1 : -1);  		}  		// Relative volume change' left back  		if (bytesLeft >= bytesUsedForVolumeDescription) {  			byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  			BackLeftAdjustment = ByteUtils.ConvertToInt64 (byteArray) * (ByteUtils.IsBitSet (incrementDecrement' 3) ? 1 : -1);  		}  		// Peak volume right back  		if (bytesLeft >= bytesUsedForVolumeDescription) {  			byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  			BackRightPeak = ByteUtils.ConvertToInt64 (byteArray);  		}  		// Peak volume left back  		if (bytesLeft >= bytesUsedForVolumeDescription) {  			byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  			BackLeftPeak = ByteUtils.ConvertToInt64 (byteArray);  		}  		// Relative volume change' center  		if (bytesLeft >= bytesUsedForVolumeDescription) {  			byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  			FrontCenterAdjustment = ByteUtils.ConvertToInt64 (byteArray) * (ByteUtils.IsBitSet (incrementDecrement' 4) ? 1 : -1);  		}  		// Peak volume center  		if (bytesLeft >= bytesUsedForVolumeDescription) {  			byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  			FrontCenterPeak = ByteUtils.ConvertToInt64 (byteArray);  		}  		// Relative volume change' bass  		if (bytesLeft >= bytesUsedForVolumeDescription) {  			byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  			SubwooferAdjustment = ByteUtils.ConvertToInt64 (byteArray) * (ByteUtils.IsBitSet (incrementDecrement' 5) ? 1 : -1);  		}  		// Peak volume bass  		if (bytesLeft >= bytesUsedForVolumeDescription) {  			byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  			SubwooferPeak = ByteUtils.ConvertToInt64 (byteArray);  		}  	}  }  
Magic Number,IdSharp.Tagging.ID3v2.Frames,RelativeVolumeAdjustment,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\Frames\RelativeVolumeAdjustment.cs,Read,The following statement contains a magic number: if (isRVA2 == false) {  	byte incrementDecrement = stream.Read1 (ref bytesLeft);  	if (bytesLeft > 0) {  		byte bitsUsedForVolumeDescription = stream.Read1 (ref bytesLeft);  		int bytesUsedForVolumeDescription = bitsUsedForVolumeDescription / 8;  		// TODO: (may be useful for testing which implementation)  		// if bits used for volume description is > 64' don't bother  		// Relative volume change' right  		if (bytesLeft >= bytesUsedForVolumeDescription) {  			byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  			FrontRightAdjustment = ByteUtils.ConvertToInt64 (byteArray) * (ByteUtils.IsBitSet (incrementDecrement' 0) ? 1 : -1);  		}  		// Relative volume change' left  		if (bytesLeft >= bytesUsedForVolumeDescription) {  			byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  			FrontLeftAdjustment = ByteUtils.ConvertToInt64 (byteArray) * (ByteUtils.IsBitSet (incrementDecrement' 1) ? 1 : -1);  		}  		// Peak volume right  		if (bytesLeft >= bytesUsedForVolumeDescription) {  			byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  			FrontRightPeak = ByteUtils.ConvertToInt64 (byteArray);  		}  		// Peak volume left  		if (bytesLeft >= bytesUsedForVolumeDescription) {  			byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  			FrontLeftPeak = ByteUtils.ConvertToInt64 (byteArray);  		}  		// Relative volume change' right back  		if (bytesLeft >= bytesUsedForVolumeDescription) {  			byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  			BackRightAdjustment = ByteUtils.ConvertToInt64 (byteArray) * (ByteUtils.IsBitSet (incrementDecrement' 2) ? 1 : -1);  		}  		// Relative volume change' left back  		if (bytesLeft >= bytesUsedForVolumeDescription) {  			byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  			BackLeftAdjustment = ByteUtils.ConvertToInt64 (byteArray) * (ByteUtils.IsBitSet (incrementDecrement' 3) ? 1 : -1);  		}  		// Peak volume right back  		if (bytesLeft >= bytesUsedForVolumeDescription) {  			byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  			BackRightPeak = ByteUtils.ConvertToInt64 (byteArray);  		}  		// Peak volume left back  		if (bytesLeft >= bytesUsedForVolumeDescription) {  			byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  			BackLeftPeak = ByteUtils.ConvertToInt64 (byteArray);  		}  		// Relative volume change' center  		if (bytesLeft >= bytesUsedForVolumeDescription) {  			byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  			FrontCenterAdjustment = ByteUtils.ConvertToInt64 (byteArray) * (ByteUtils.IsBitSet (incrementDecrement' 4) ? 1 : -1);  		}  		// Peak volume center  		if (bytesLeft >= bytesUsedForVolumeDescription) {  			byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  			FrontCenterPeak = ByteUtils.ConvertToInt64 (byteArray);  		}  		// Relative volume change' bass  		if (bytesLeft >= bytesUsedForVolumeDescription) {  			byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  			SubwooferAdjustment = ByteUtils.ConvertToInt64 (byteArray) * (ByteUtils.IsBitSet (incrementDecrement' 5) ? 1 : -1);  		}  		// Peak volume bass  		if (bytesLeft >= bytesUsedForVolumeDescription) {  			byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  			SubwooferPeak = ByteUtils.ConvertToInt64 (byteArray);  		}  	}  }  
Magic Number,IdSharp.Tagging.ID3v2.Frames,RelativeVolumeAdjustment,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\Frames\RelativeVolumeAdjustment.cs,Read,The following statement contains a magic number: if (isRVA2 == false) {  	byte incrementDecrement = stream.Read1 (ref bytesLeft);  	if (bytesLeft > 0) {  		byte bitsUsedForVolumeDescription = stream.Read1 (ref bytesLeft);  		int bytesUsedForVolumeDescription = bitsUsedForVolumeDescription / 8;  		// TODO: (may be useful for testing which implementation)  		// if bits used for volume description is > 64' don't bother  		// Relative volume change' right  		if (bytesLeft >= bytesUsedForVolumeDescription) {  			byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  			FrontRightAdjustment = ByteUtils.ConvertToInt64 (byteArray) * (ByteUtils.IsBitSet (incrementDecrement' 0) ? 1 : -1);  		}  		// Relative volume change' left  		if (bytesLeft >= bytesUsedForVolumeDescription) {  			byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  			FrontLeftAdjustment = ByteUtils.ConvertToInt64 (byteArray) * (ByteUtils.IsBitSet (incrementDecrement' 1) ? 1 : -1);  		}  		// Peak volume right  		if (bytesLeft >= bytesUsedForVolumeDescription) {  			byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  			FrontRightPeak = ByteUtils.ConvertToInt64 (byteArray);  		}  		// Peak volume left  		if (bytesLeft >= bytesUsedForVolumeDescription) {  			byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  			FrontLeftPeak = ByteUtils.ConvertToInt64 (byteArray);  		}  		// Relative volume change' right back  		if (bytesLeft >= bytesUsedForVolumeDescription) {  			byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  			BackRightAdjustment = ByteUtils.ConvertToInt64 (byteArray) * (ByteUtils.IsBitSet (incrementDecrement' 2) ? 1 : -1);  		}  		// Relative volume change' left back  		if (bytesLeft >= bytesUsedForVolumeDescription) {  			byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  			BackLeftAdjustment = ByteUtils.ConvertToInt64 (byteArray) * (ByteUtils.IsBitSet (incrementDecrement' 3) ? 1 : -1);  		}  		// Peak volume right back  		if (bytesLeft >= bytesUsedForVolumeDescription) {  			byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  			BackRightPeak = ByteUtils.ConvertToInt64 (byteArray);  		}  		// Peak volume left back  		if (bytesLeft >= bytesUsedForVolumeDescription) {  			byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  			BackLeftPeak = ByteUtils.ConvertToInt64 (byteArray);  		}  		// Relative volume change' center  		if (bytesLeft >= bytesUsedForVolumeDescription) {  			byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  			FrontCenterAdjustment = ByteUtils.ConvertToInt64 (byteArray) * (ByteUtils.IsBitSet (incrementDecrement' 4) ? 1 : -1);  		}  		// Peak volume center  		if (bytesLeft >= bytesUsedForVolumeDescription) {  			byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  			FrontCenterPeak = ByteUtils.ConvertToInt64 (byteArray);  		}  		// Relative volume change' bass  		if (bytesLeft >= bytesUsedForVolumeDescription) {  			byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  			SubwooferAdjustment = ByteUtils.ConvertToInt64 (byteArray) * (ByteUtils.IsBitSet (incrementDecrement' 5) ? 1 : -1);  		}  		// Peak volume bass  		if (bytesLeft >= bytesUsedForVolumeDescription) {  			byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  			SubwooferPeak = ByteUtils.ConvertToInt64 (byteArray);  		}  	}  }  
Magic Number,IdSharp.Tagging.ID3v2.Frames,RelativeVolumeAdjustment,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\Frames\RelativeVolumeAdjustment.cs,Read,The following statement contains a magic number: if (bytesLeft > 0) {  	byte bitsUsedForVolumeDescription = stream.Read1 (ref bytesLeft);  	int bytesUsedForVolumeDescription = bitsUsedForVolumeDescription / 8;  	// TODO: (may be useful for testing which implementation)  	// if bits used for volume description is > 64' don't bother  	// Relative volume change' right  	if (bytesLeft >= bytesUsedForVolumeDescription) {  		byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  		FrontRightAdjustment = ByteUtils.ConvertToInt64 (byteArray) * (ByteUtils.IsBitSet (incrementDecrement' 0) ? 1 : -1);  	}  	// Relative volume change' left  	if (bytesLeft >= bytesUsedForVolumeDescription) {  		byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  		FrontLeftAdjustment = ByteUtils.ConvertToInt64 (byteArray) * (ByteUtils.IsBitSet (incrementDecrement' 1) ? 1 : -1);  	}  	// Peak volume right  	if (bytesLeft >= bytesUsedForVolumeDescription) {  		byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  		FrontRightPeak = ByteUtils.ConvertToInt64 (byteArray);  	}  	// Peak volume left  	if (bytesLeft >= bytesUsedForVolumeDescription) {  		byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  		FrontLeftPeak = ByteUtils.ConvertToInt64 (byteArray);  	}  	// Relative volume change' right back  	if (bytesLeft >= bytesUsedForVolumeDescription) {  		byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  		BackRightAdjustment = ByteUtils.ConvertToInt64 (byteArray) * (ByteUtils.IsBitSet (incrementDecrement' 2) ? 1 : -1);  	}  	// Relative volume change' left back  	if (bytesLeft >= bytesUsedForVolumeDescription) {  		byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  		BackLeftAdjustment = ByteUtils.ConvertToInt64 (byteArray) * (ByteUtils.IsBitSet (incrementDecrement' 3) ? 1 : -1);  	}  	// Peak volume right back  	if (bytesLeft >= bytesUsedForVolumeDescription) {  		byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  		BackRightPeak = ByteUtils.ConvertToInt64 (byteArray);  	}  	// Peak volume left back  	if (bytesLeft >= bytesUsedForVolumeDescription) {  		byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  		BackLeftPeak = ByteUtils.ConvertToInt64 (byteArray);  	}  	// Relative volume change' center  	if (bytesLeft >= bytesUsedForVolumeDescription) {  		byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  		FrontCenterAdjustment = ByteUtils.ConvertToInt64 (byteArray) * (ByteUtils.IsBitSet (incrementDecrement' 4) ? 1 : -1);  	}  	// Peak volume center  	if (bytesLeft >= bytesUsedForVolumeDescription) {  		byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  		FrontCenterPeak = ByteUtils.ConvertToInt64 (byteArray);  	}  	// Relative volume change' bass  	if (bytesLeft >= bytesUsedForVolumeDescription) {  		byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  		SubwooferAdjustment = ByteUtils.ConvertToInt64 (byteArray) * (ByteUtils.IsBitSet (incrementDecrement' 5) ? 1 : -1);  	}  	// Peak volume bass  	if (bytesLeft >= bytesUsedForVolumeDescription) {  		byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  		SubwooferPeak = ByteUtils.ConvertToInt64 (byteArray);  	}  }  
Magic Number,IdSharp.Tagging.ID3v2.Frames,RelativeVolumeAdjustment,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\Frames\RelativeVolumeAdjustment.cs,Read,The following statement contains a magic number: if (bytesLeft > 0) {  	byte bitsUsedForVolumeDescription = stream.Read1 (ref bytesLeft);  	int bytesUsedForVolumeDescription = bitsUsedForVolumeDescription / 8;  	// TODO: (may be useful for testing which implementation)  	// if bits used for volume description is > 64' don't bother  	// Relative volume change' right  	if (bytesLeft >= bytesUsedForVolumeDescription) {  		byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  		FrontRightAdjustment = ByteUtils.ConvertToInt64 (byteArray) * (ByteUtils.IsBitSet (incrementDecrement' 0) ? 1 : -1);  	}  	// Relative volume change' left  	if (bytesLeft >= bytesUsedForVolumeDescription) {  		byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  		FrontLeftAdjustment = ByteUtils.ConvertToInt64 (byteArray) * (ByteUtils.IsBitSet (incrementDecrement' 1) ? 1 : -1);  	}  	// Peak volume right  	if (bytesLeft >= bytesUsedForVolumeDescription) {  		byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  		FrontRightPeak = ByteUtils.ConvertToInt64 (byteArray);  	}  	// Peak volume left  	if (bytesLeft >= bytesUsedForVolumeDescription) {  		byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  		FrontLeftPeak = ByteUtils.ConvertToInt64 (byteArray);  	}  	// Relative volume change' right back  	if (bytesLeft >= bytesUsedForVolumeDescription) {  		byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  		BackRightAdjustment = ByteUtils.ConvertToInt64 (byteArray) * (ByteUtils.IsBitSet (incrementDecrement' 2) ? 1 : -1);  	}  	// Relative volume change' left back  	if (bytesLeft >= bytesUsedForVolumeDescription) {  		byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  		BackLeftAdjustment = ByteUtils.ConvertToInt64 (byteArray) * (ByteUtils.IsBitSet (incrementDecrement' 3) ? 1 : -1);  	}  	// Peak volume right back  	if (bytesLeft >= bytesUsedForVolumeDescription) {  		byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  		BackRightPeak = ByteUtils.ConvertToInt64 (byteArray);  	}  	// Peak volume left back  	if (bytesLeft >= bytesUsedForVolumeDescription) {  		byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  		BackLeftPeak = ByteUtils.ConvertToInt64 (byteArray);  	}  	// Relative volume change' center  	if (bytesLeft >= bytesUsedForVolumeDescription) {  		byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  		FrontCenterAdjustment = ByteUtils.ConvertToInt64 (byteArray) * (ByteUtils.IsBitSet (incrementDecrement' 4) ? 1 : -1);  	}  	// Peak volume center  	if (bytesLeft >= bytesUsedForVolumeDescription) {  		byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  		FrontCenterPeak = ByteUtils.ConvertToInt64 (byteArray);  	}  	// Relative volume change' bass  	if (bytesLeft >= bytesUsedForVolumeDescription) {  		byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  		SubwooferAdjustment = ByteUtils.ConvertToInt64 (byteArray) * (ByteUtils.IsBitSet (incrementDecrement' 5) ? 1 : -1);  	}  	// Peak volume bass  	if (bytesLeft >= bytesUsedForVolumeDescription) {  		byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  		SubwooferPeak = ByteUtils.ConvertToInt64 (byteArray);  	}  }  
Magic Number,IdSharp.Tagging.ID3v2.Frames,RelativeVolumeAdjustment,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\Frames\RelativeVolumeAdjustment.cs,Read,The following statement contains a magic number: if (bytesLeft > 0) {  	byte bitsUsedForVolumeDescription = stream.Read1 (ref bytesLeft);  	int bytesUsedForVolumeDescription = bitsUsedForVolumeDescription / 8;  	// TODO: (may be useful for testing which implementation)  	// if bits used for volume description is > 64' don't bother  	// Relative volume change' right  	if (bytesLeft >= bytesUsedForVolumeDescription) {  		byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  		FrontRightAdjustment = ByteUtils.ConvertToInt64 (byteArray) * (ByteUtils.IsBitSet (incrementDecrement' 0) ? 1 : -1);  	}  	// Relative volume change' left  	if (bytesLeft >= bytesUsedForVolumeDescription) {  		byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  		FrontLeftAdjustment = ByteUtils.ConvertToInt64 (byteArray) * (ByteUtils.IsBitSet (incrementDecrement' 1) ? 1 : -1);  	}  	// Peak volume right  	if (bytesLeft >= bytesUsedForVolumeDescription) {  		byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  		FrontRightPeak = ByteUtils.ConvertToInt64 (byteArray);  	}  	// Peak volume left  	if (bytesLeft >= bytesUsedForVolumeDescription) {  		byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  		FrontLeftPeak = ByteUtils.ConvertToInt64 (byteArray);  	}  	// Relative volume change' right back  	if (bytesLeft >= bytesUsedForVolumeDescription) {  		byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  		BackRightAdjustment = ByteUtils.ConvertToInt64 (byteArray) * (ByteUtils.IsBitSet (incrementDecrement' 2) ? 1 : -1);  	}  	// Relative volume change' left back  	if (bytesLeft >= bytesUsedForVolumeDescription) {  		byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  		BackLeftAdjustment = ByteUtils.ConvertToInt64 (byteArray) * (ByteUtils.IsBitSet (incrementDecrement' 3) ? 1 : -1);  	}  	// Peak volume right back  	if (bytesLeft >= bytesUsedForVolumeDescription) {  		byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  		BackRightPeak = ByteUtils.ConvertToInt64 (byteArray);  	}  	// Peak volume left back  	if (bytesLeft >= bytesUsedForVolumeDescription) {  		byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  		BackLeftPeak = ByteUtils.ConvertToInt64 (byteArray);  	}  	// Relative volume change' center  	if (bytesLeft >= bytesUsedForVolumeDescription) {  		byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  		FrontCenterAdjustment = ByteUtils.ConvertToInt64 (byteArray) * (ByteUtils.IsBitSet (incrementDecrement' 4) ? 1 : -1);  	}  	// Peak volume center  	if (bytesLeft >= bytesUsedForVolumeDescription) {  		byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  		FrontCenterPeak = ByteUtils.ConvertToInt64 (byteArray);  	}  	// Relative volume change' bass  	if (bytesLeft >= bytesUsedForVolumeDescription) {  		byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  		SubwooferAdjustment = ByteUtils.ConvertToInt64 (byteArray) * (ByteUtils.IsBitSet (incrementDecrement' 5) ? 1 : -1);  	}  	// Peak volume bass  	if (bytesLeft >= bytesUsedForVolumeDescription) {  		byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  		SubwooferPeak = ByteUtils.ConvertToInt64 (byteArray);  	}  }  
Magic Number,IdSharp.Tagging.ID3v2.Frames,RelativeVolumeAdjustment,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\Frames\RelativeVolumeAdjustment.cs,Read,The following statement contains a magic number: if (bytesLeft > 0) {  	byte bitsUsedForVolumeDescription = stream.Read1 (ref bytesLeft);  	int bytesUsedForVolumeDescription = bitsUsedForVolumeDescription / 8;  	// TODO: (may be useful for testing which implementation)  	// if bits used for volume description is > 64' don't bother  	// Relative volume change' right  	if (bytesLeft >= bytesUsedForVolumeDescription) {  		byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  		FrontRightAdjustment = ByteUtils.ConvertToInt64 (byteArray) * (ByteUtils.IsBitSet (incrementDecrement' 0) ? 1 : -1);  	}  	// Relative volume change' left  	if (bytesLeft >= bytesUsedForVolumeDescription) {  		byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  		FrontLeftAdjustment = ByteUtils.ConvertToInt64 (byteArray) * (ByteUtils.IsBitSet (incrementDecrement' 1) ? 1 : -1);  	}  	// Peak volume right  	if (bytesLeft >= bytesUsedForVolumeDescription) {  		byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  		FrontRightPeak = ByteUtils.ConvertToInt64 (byteArray);  	}  	// Peak volume left  	if (bytesLeft >= bytesUsedForVolumeDescription) {  		byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  		FrontLeftPeak = ByteUtils.ConvertToInt64 (byteArray);  	}  	// Relative volume change' right back  	if (bytesLeft >= bytesUsedForVolumeDescription) {  		byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  		BackRightAdjustment = ByteUtils.ConvertToInt64 (byteArray) * (ByteUtils.IsBitSet (incrementDecrement' 2) ? 1 : -1);  	}  	// Relative volume change' left back  	if (bytesLeft >= bytesUsedForVolumeDescription) {  		byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  		BackLeftAdjustment = ByteUtils.ConvertToInt64 (byteArray) * (ByteUtils.IsBitSet (incrementDecrement' 3) ? 1 : -1);  	}  	// Peak volume right back  	if (bytesLeft >= bytesUsedForVolumeDescription) {  		byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  		BackRightPeak = ByteUtils.ConvertToInt64 (byteArray);  	}  	// Peak volume left back  	if (bytesLeft >= bytesUsedForVolumeDescription) {  		byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  		BackLeftPeak = ByteUtils.ConvertToInt64 (byteArray);  	}  	// Relative volume change' center  	if (bytesLeft >= bytesUsedForVolumeDescription) {  		byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  		FrontCenterAdjustment = ByteUtils.ConvertToInt64 (byteArray) * (ByteUtils.IsBitSet (incrementDecrement' 4) ? 1 : -1);  	}  	// Peak volume center  	if (bytesLeft >= bytesUsedForVolumeDescription) {  		byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  		FrontCenterPeak = ByteUtils.ConvertToInt64 (byteArray);  	}  	// Relative volume change' bass  	if (bytesLeft >= bytesUsedForVolumeDescription) {  		byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  		SubwooferAdjustment = ByteUtils.ConvertToInt64 (byteArray) * (ByteUtils.IsBitSet (incrementDecrement' 5) ? 1 : -1);  	}  	// Peak volume bass  	if (bytesLeft >= bytesUsedForVolumeDescription) {  		byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  		SubwooferPeak = ByteUtils.ConvertToInt64 (byteArray);  	}  }  
Magic Number,IdSharp.Tagging.ID3v2.Frames,RelativeVolumeAdjustment,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\Frames\RelativeVolumeAdjustment.cs,Read,The following statement contains a magic number: if (bytesLeft > 0) {  	byte bitsUsedForVolumeDescription = stream.Read1 (ref bytesLeft);  	int bytesUsedForVolumeDescription = bitsUsedForVolumeDescription / 8;  	// TODO: (may be useful for testing which implementation)  	// if bits used for volume description is > 64' don't bother  	// Relative volume change' right  	if (bytesLeft >= bytesUsedForVolumeDescription) {  		byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  		FrontRightAdjustment = ByteUtils.ConvertToInt64 (byteArray) * (ByteUtils.IsBitSet (incrementDecrement' 0) ? 1 : -1);  	}  	// Relative volume change' left  	if (bytesLeft >= bytesUsedForVolumeDescription) {  		byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  		FrontLeftAdjustment = ByteUtils.ConvertToInt64 (byteArray) * (ByteUtils.IsBitSet (incrementDecrement' 1) ? 1 : -1);  	}  	// Peak volume right  	if (bytesLeft >= bytesUsedForVolumeDescription) {  		byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  		FrontRightPeak = ByteUtils.ConvertToInt64 (byteArray);  	}  	// Peak volume left  	if (bytesLeft >= bytesUsedForVolumeDescription) {  		byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  		FrontLeftPeak = ByteUtils.ConvertToInt64 (byteArray);  	}  	// Relative volume change' right back  	if (bytesLeft >= bytesUsedForVolumeDescription) {  		byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  		BackRightAdjustment = ByteUtils.ConvertToInt64 (byteArray) * (ByteUtils.IsBitSet (incrementDecrement' 2) ? 1 : -1);  	}  	// Relative volume change' left back  	if (bytesLeft >= bytesUsedForVolumeDescription) {  		byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  		BackLeftAdjustment = ByteUtils.ConvertToInt64 (byteArray) * (ByteUtils.IsBitSet (incrementDecrement' 3) ? 1 : -1);  	}  	// Peak volume right back  	if (bytesLeft >= bytesUsedForVolumeDescription) {  		byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  		BackRightPeak = ByteUtils.ConvertToInt64 (byteArray);  	}  	// Peak volume left back  	if (bytesLeft >= bytesUsedForVolumeDescription) {  		byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  		BackLeftPeak = ByteUtils.ConvertToInt64 (byteArray);  	}  	// Relative volume change' center  	if (bytesLeft >= bytesUsedForVolumeDescription) {  		byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  		FrontCenterAdjustment = ByteUtils.ConvertToInt64 (byteArray) * (ByteUtils.IsBitSet (incrementDecrement' 4) ? 1 : -1);  	}  	// Peak volume center  	if (bytesLeft >= bytesUsedForVolumeDescription) {  		byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  		FrontCenterPeak = ByteUtils.ConvertToInt64 (byteArray);  	}  	// Relative volume change' bass  	if (bytesLeft >= bytesUsedForVolumeDescription) {  		byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  		SubwooferAdjustment = ByteUtils.ConvertToInt64 (byteArray) * (ByteUtils.IsBitSet (incrementDecrement' 5) ? 1 : -1);  	}  	// Peak volume bass  	if (bytesLeft >= bytesUsedForVolumeDescription) {  		byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  		SubwooferPeak = ByteUtils.ConvertToInt64 (byteArray);  	}  }  
Magic Number,IdSharp.Tagging.ID3v2.Frames,RelativeVolumeAdjustment,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\Frames\RelativeVolumeAdjustment.cs,Read,The following statement contains a magic number: if (bytesLeft >= bytesUsedForVolumeDescription) {  	byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  	BackRightAdjustment = ByteUtils.ConvertToInt64 (byteArray) * (ByteUtils.IsBitSet (incrementDecrement' 2) ? 1 : -1);  }  
Magic Number,IdSharp.Tagging.ID3v2.Frames,RelativeVolumeAdjustment,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\Frames\RelativeVolumeAdjustment.cs,Read,The following statement contains a magic number: BackRightAdjustment = ByteUtils.ConvertToInt64 (byteArray) * (ByteUtils.IsBitSet (incrementDecrement' 2) ? 1 : -1);  
Magic Number,IdSharp.Tagging.ID3v2.Frames,RelativeVolumeAdjustment,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\Frames\RelativeVolumeAdjustment.cs,Read,The following statement contains a magic number: if (bytesLeft >= bytesUsedForVolumeDescription) {  	byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  	BackLeftAdjustment = ByteUtils.ConvertToInt64 (byteArray) * (ByteUtils.IsBitSet (incrementDecrement' 3) ? 1 : -1);  }  
Magic Number,IdSharp.Tagging.ID3v2.Frames,RelativeVolumeAdjustment,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\Frames\RelativeVolumeAdjustment.cs,Read,The following statement contains a magic number: BackLeftAdjustment = ByteUtils.ConvertToInt64 (byteArray) * (ByteUtils.IsBitSet (incrementDecrement' 3) ? 1 : -1);  
Magic Number,IdSharp.Tagging.ID3v2.Frames,RelativeVolumeAdjustment,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\Frames\RelativeVolumeAdjustment.cs,Read,The following statement contains a magic number: if (bytesLeft >= bytesUsedForVolumeDescription) {  	byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  	FrontCenterAdjustment = ByteUtils.ConvertToInt64 (byteArray) * (ByteUtils.IsBitSet (incrementDecrement' 4) ? 1 : -1);  }  
Magic Number,IdSharp.Tagging.ID3v2.Frames,RelativeVolumeAdjustment,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\Frames\RelativeVolumeAdjustment.cs,Read,The following statement contains a magic number: FrontCenterAdjustment = ByteUtils.ConvertToInt64 (byteArray) * (ByteUtils.IsBitSet (incrementDecrement' 4) ? 1 : -1);  
Magic Number,IdSharp.Tagging.ID3v2.Frames,RelativeVolumeAdjustment,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\Frames\RelativeVolumeAdjustment.cs,Read,The following statement contains a magic number: if (bytesLeft >= bytesUsedForVolumeDescription) {  	byte[] byteArray = stream.Read (bytesUsedForVolumeDescription' ref bytesLeft);  	SubwooferAdjustment = ByteUtils.ConvertToInt64 (byteArray) * (ByteUtils.IsBitSet (incrementDecrement' 5) ? 1 : -1);  }  
Magic Number,IdSharp.Tagging.ID3v2.Frames,RelativeVolumeAdjustment,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\Frames\RelativeVolumeAdjustment.cs,Read,The following statement contains a magic number: SubwooferAdjustment = ByteUtils.ConvertToInt64 (byteArray) * (ByteUtils.IsBitSet (incrementDecrement' 5) ? 1 : -1);  
Magic Number,IdSharp.Tagging.ID3v2.Frames,RelativeVolumeAdjustment,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\Frames\RelativeVolumeAdjustment.cs,WriteID3v24ChannelItem,The following statement contains a magic number: if (adjustment != 0 || peak != 0) {  	memoryStream.WriteByte ((byte)channelType);  	// TODO                  	//Utils.Write(memoryStream' ByteUtils.ConvertDecimalToByteArray(adjustment));  	if (adjustment <= 64 && adjustment >= -64) {  	} else {  	}  	throw new NotImplementedException ();  	/*                 memoryStream.WriteByte(_iD3v24BitsRepresentingPeak);                 ByteUtils.Write(memoryStream' ByteUtils.ConvertToByteArray(Math.Abs(peak)' _iD3v24BitsRepresentingPeak/8));                 */}  
Magic Number,IdSharp.Tagging.ID3v2.Frames,RelativeVolumeAdjustment,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\Frames\RelativeVolumeAdjustment.cs,WriteID3v24ChannelItem,The following statement contains a magic number: if (adjustment != 0 || peak != 0) {  	memoryStream.WriteByte ((byte)channelType);  	// TODO                  	//Utils.Write(memoryStream' ByteUtils.ConvertDecimalToByteArray(adjustment));  	if (adjustment <= 64 && adjustment >= -64) {  	} else {  	}  	throw new NotImplementedException ();  	/*                 memoryStream.WriteByte(_iD3v24BitsRepresentingPeak);                 ByteUtils.Write(memoryStream' ByteUtils.ConvertToByteArray(Math.Abs(peak)' _iD3v24BitsRepresentingPeak/8));                 */}  
Magic Number,IdSharp.Tagging.ID3v2.Frames,RelativeVolumeAdjustment,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\Frames\RelativeVolumeAdjustment.cs,WriteID3v24ChannelItem,The following statement contains a magic number: if (adjustment <= 64 && adjustment >= -64) {  } else {  }  
Magic Number,IdSharp.Tagging.ID3v2.Frames,RelativeVolumeAdjustment,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\Frames\RelativeVolumeAdjustment.cs,WriteID3v24ChannelItem,The following statement contains a magic number: if (adjustment <= 64 && adjustment >= -64) {  } else {  }  
Magic Number,IdSharp.Tagging.ID3v2.Frames,UnsynchronizedText,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\Frames\UnsynchronizedText.cs,Read,The following statement contains a magic number: if (_frameHeader.FrameSizeExcludingAdditions >= 4) {  	TextEncoding = (EncodingType)stream.Read1 ();  	LanguageCode = ID3v2Utils.ReadString (EncodingType.ISO88591' stream' 3);  	int tmpBytesLeft = _frameHeader.FrameSizeExcludingAdditions - 1 /*encoding*/- 3/*language code*/;  	ContentDescriptor = ID3v2Utils.ReadString (TextEncoding' stream' ref tmpBytesLeft);  	Text = ID3v2Utils.ReadString (_textEncoding' stream' tmpBytesLeft);  } else {  	string msg = string.Format ("Under-sized ({0} bytes) unsynchronized text frame at position {1}"' _frameHeader.FrameSizeExcludingAdditions' stream.Position);  	Trace.WriteLine (msg);  	LanguageCode = "eng";  	ContentDescriptor = "";  	Text = "";  }  
Magic Number,IdSharp.Tagging.ID3v2.Frames,UnsynchronizedText,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\Frames\UnsynchronizedText.cs,Read,The following statement contains a magic number: if (_frameHeader.FrameSizeExcludingAdditions >= 4) {  	TextEncoding = (EncodingType)stream.Read1 ();  	LanguageCode = ID3v2Utils.ReadString (EncodingType.ISO88591' stream' 3);  	int tmpBytesLeft = _frameHeader.FrameSizeExcludingAdditions - 1 /*encoding*/- 3/*language code*/;  	ContentDescriptor = ID3v2Utils.ReadString (TextEncoding' stream' ref tmpBytesLeft);  	Text = ID3v2Utils.ReadString (_textEncoding' stream' tmpBytesLeft);  } else {  	string msg = string.Format ("Under-sized ({0} bytes) unsynchronized text frame at position {1}"' _frameHeader.FrameSizeExcludingAdditions' stream.Position);  	Trace.WriteLine (msg);  	LanguageCode = "eng";  	ContentDescriptor = "";  	Text = "";  }  
Magic Number,IdSharp.Tagging.ID3v2.Frames,UnsynchronizedText,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\Frames\UnsynchronizedText.cs,Read,The following statement contains a magic number: if (_frameHeader.FrameSizeExcludingAdditions >= 4) {  	TextEncoding = (EncodingType)stream.Read1 ();  	LanguageCode = ID3v2Utils.ReadString (EncodingType.ISO88591' stream' 3);  	int tmpBytesLeft = _frameHeader.FrameSizeExcludingAdditions - 1 /*encoding*/- 3/*language code*/;  	ContentDescriptor = ID3v2Utils.ReadString (TextEncoding' stream' ref tmpBytesLeft);  	Text = ID3v2Utils.ReadString (_textEncoding' stream' tmpBytesLeft);  } else {  	string msg = string.Format ("Under-sized ({0} bytes) unsynchronized text frame at position {1}"' _frameHeader.FrameSizeExcludingAdditions' stream.Position);  	Trace.WriteLine (msg);  	LanguageCode = "eng";  	ContentDescriptor = "";  	Text = "";  }  
Magic Number,IdSharp.Tagging.ID3v2.Frames,UnsynchronizedText,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\Frames\UnsynchronizedText.cs,Read,The following statement contains a magic number: LanguageCode = ID3v2Utils.ReadString (EncodingType.ISO88591' stream' 3);  
Magic Number,IdSharp.Tagging.ID3v2.Frames,AttachedPicture,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\Frames\AttachedPicture.cs,Read,The following statement contains a magic number: if (bytesLeft >= 6)// note: 6 was chosen arbitrarily   {  	// Read text encoding  	TextEncoding = (EncodingType)stream.Read1 (ref bytesLeft);  	if (tagReadingInfo.TagVersion == ID3v2TagVersion.ID3v22) {  		// TODO: Do something with this?  		string imageFormat = ID3v2Utils.ReadString (EncodingType.ISO88591' stream' 3);  		bytesLeft -= 3;  	} else {  		// Read MIME type  		MimeType = ID3v2Utils.ReadString (EncodingType.ISO88591' stream' ref bytesLeft);  	}  	// Read picture type  	PictureType = (PictureType)stream.Read1 (ref bytesLeft);  	// Short description  	Description = ID3v2Utils.ReadString (TextEncoding' stream' ref bytesLeft);  	// Picture data  	if (bytesLeft > 0) {  		byte[] pictureData = stream.Read (bytesLeft);  		bytesLeft = 0;  		_readingTag = true;  		try {  			_pictureCached = false;  			PictureData = pictureData;  		} finally {  			_readingTag = false;  		}  	} else {  		// Incomplete frame  		PictureData = null;  	}  } else {  	// Incomplete frame  	TextEncoding = EncodingType.ISO88591;  	Description = null;  	MimeType = null;  	PictureType = PictureType.CoverFront;  	PictureData = null;  }  
Magic Number,IdSharp.Tagging.ID3v2.Frames,AttachedPicture,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\Frames\AttachedPicture.cs,Read,The following statement contains a magic number: if (bytesLeft >= 6)// note: 6 was chosen arbitrarily   {  	// Read text encoding  	TextEncoding = (EncodingType)stream.Read1 (ref bytesLeft);  	if (tagReadingInfo.TagVersion == ID3v2TagVersion.ID3v22) {  		// TODO: Do something with this?  		string imageFormat = ID3v2Utils.ReadString (EncodingType.ISO88591' stream' 3);  		bytesLeft -= 3;  	} else {  		// Read MIME type  		MimeType = ID3v2Utils.ReadString (EncodingType.ISO88591' stream' ref bytesLeft);  	}  	// Read picture type  	PictureType = (PictureType)stream.Read1 (ref bytesLeft);  	// Short description  	Description = ID3v2Utils.ReadString (TextEncoding' stream' ref bytesLeft);  	// Picture data  	if (bytesLeft > 0) {  		byte[] pictureData = stream.Read (bytesLeft);  		bytesLeft = 0;  		_readingTag = true;  		try {  			_pictureCached = false;  			PictureData = pictureData;  		} finally {  			_readingTag = false;  		}  	} else {  		// Incomplete frame  		PictureData = null;  	}  } else {  	// Incomplete frame  	TextEncoding = EncodingType.ISO88591;  	Description = null;  	MimeType = null;  	PictureType = PictureType.CoverFront;  	PictureData = null;  }  
Magic Number,IdSharp.Tagging.ID3v2.Frames,AttachedPicture,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\Frames\AttachedPicture.cs,Read,The following statement contains a magic number: if (bytesLeft >= 6)// note: 6 was chosen arbitrarily   {  	// Read text encoding  	TextEncoding = (EncodingType)stream.Read1 (ref bytesLeft);  	if (tagReadingInfo.TagVersion == ID3v2TagVersion.ID3v22) {  		// TODO: Do something with this?  		string imageFormat = ID3v2Utils.ReadString (EncodingType.ISO88591' stream' 3);  		bytesLeft -= 3;  	} else {  		// Read MIME type  		MimeType = ID3v2Utils.ReadString (EncodingType.ISO88591' stream' ref bytesLeft);  	}  	// Read picture type  	PictureType = (PictureType)stream.Read1 (ref bytesLeft);  	// Short description  	Description = ID3v2Utils.ReadString (TextEncoding' stream' ref bytesLeft);  	// Picture data  	if (bytesLeft > 0) {  		byte[] pictureData = stream.Read (bytesLeft);  		bytesLeft = 0;  		_readingTag = true;  		try {  			_pictureCached = false;  			PictureData = pictureData;  		} finally {  			_readingTag = false;  		}  	} else {  		// Incomplete frame  		PictureData = null;  	}  } else {  	// Incomplete frame  	TextEncoding = EncodingType.ISO88591;  	Description = null;  	MimeType = null;  	PictureType = PictureType.CoverFront;  	PictureData = null;  }  
Magic Number,IdSharp.Tagging.ID3v2.Frames,AttachedPicture,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\Frames\AttachedPicture.cs,Read,The following statement contains a magic number: if (tagReadingInfo.TagVersion == ID3v2TagVersion.ID3v22) {  	// TODO: Do something with this?  	string imageFormat = ID3v2Utils.ReadString (EncodingType.ISO88591' stream' 3);  	bytesLeft -= 3;  } else {  	// Read MIME type  	MimeType = ID3v2Utils.ReadString (EncodingType.ISO88591' stream' ref bytesLeft);  }  
Magic Number,IdSharp.Tagging.ID3v2.Frames,AttachedPicture,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\Frames\AttachedPicture.cs,Read,The following statement contains a magic number: if (tagReadingInfo.TagVersion == ID3v2TagVersion.ID3v22) {  	// TODO: Do something with this?  	string imageFormat = ID3v2Utils.ReadString (EncodingType.ISO88591' stream' 3);  	bytesLeft -= 3;  } else {  	// Read MIME type  	MimeType = ID3v2Utils.ReadString (EncodingType.ISO88591' stream' ref bytesLeft);  }  
Magic Number,IdSharp.Tagging.ID3v2.Frames,AttachedPicture,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\Frames\AttachedPicture.cs,Read,The following statement contains a magic number: bytesLeft -= 3;  
Magic Number,IdSharp.Tagging.ID3v2.Frames,AttachedPicture,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\Frames\AttachedPicture.cs,GetBytes,The following statement contains a magic number: using (MemoryStream stream = new MemoryStream ()) {  	byte[] descriptionData;  	do {  		descriptionData = ID3v2Utils.GetStringBytes (tagVersion' _textEncoding' _description' true);  	} while (this.RequiresFix (tagVersion' _description' descriptionData));  	stream.WriteByte ((byte)_textEncoding);  	if (tagVersion == ID3v2TagVersion.ID3v22) {  		string format = PictureExtension;  		if (string.IsNullOrEmpty (format) || format.Length < 3)  			format = "   ";  		else if (format.Length > 3)  			format = format.Substring (0' 3);  		stream.Write (Encoding.ASCII.GetBytes (format));  	} else {  		SetMimeType ();  		// iTunes needs this set properly  		stream.Write (ByteUtils.ISO88591GetBytes (_mimeType));  		stream.WriteByte (0);  		// terminator  	}  	stream.WriteByte ((byte)_pictureType);  	stream.Write (descriptionData);  	stream.Write (_pictureData);  	return _frameHeader.GetBytes (stream' tagVersion' GetFrameID (tagVersion));  }  
Magic Number,IdSharp.Tagging.ID3v2.Frames,AttachedPicture,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\Frames\AttachedPicture.cs,GetBytes,The following statement contains a magic number: using (MemoryStream stream = new MemoryStream ()) {  	byte[] descriptionData;  	do {  		descriptionData = ID3v2Utils.GetStringBytes (tagVersion' _textEncoding' _description' true);  	} while (this.RequiresFix (tagVersion' _description' descriptionData));  	stream.WriteByte ((byte)_textEncoding);  	if (tagVersion == ID3v2TagVersion.ID3v22) {  		string format = PictureExtension;  		if (string.IsNullOrEmpty (format) || format.Length < 3)  			format = "   ";  		else if (format.Length > 3)  			format = format.Substring (0' 3);  		stream.Write (Encoding.ASCII.GetBytes (format));  	} else {  		SetMimeType ();  		// iTunes needs this set properly  		stream.Write (ByteUtils.ISO88591GetBytes (_mimeType));  		stream.WriteByte (0);  		// terminator  	}  	stream.WriteByte ((byte)_pictureType);  	stream.Write (descriptionData);  	stream.Write (_pictureData);  	return _frameHeader.GetBytes (stream' tagVersion' GetFrameID (tagVersion));  }  
Magic Number,IdSharp.Tagging.ID3v2.Frames,AttachedPicture,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\Frames\AttachedPicture.cs,GetBytes,The following statement contains a magic number: using (MemoryStream stream = new MemoryStream ()) {  	byte[] descriptionData;  	do {  		descriptionData = ID3v2Utils.GetStringBytes (tagVersion' _textEncoding' _description' true);  	} while (this.RequiresFix (tagVersion' _description' descriptionData));  	stream.WriteByte ((byte)_textEncoding);  	if (tagVersion == ID3v2TagVersion.ID3v22) {  		string format = PictureExtension;  		if (string.IsNullOrEmpty (format) || format.Length < 3)  			format = "   ";  		else if (format.Length > 3)  			format = format.Substring (0' 3);  		stream.Write (Encoding.ASCII.GetBytes (format));  	} else {  		SetMimeType ();  		// iTunes needs this set properly  		stream.Write (ByteUtils.ISO88591GetBytes (_mimeType));  		stream.WriteByte (0);  		// terminator  	}  	stream.WriteByte ((byte)_pictureType);  	stream.Write (descriptionData);  	stream.Write (_pictureData);  	return _frameHeader.GetBytes (stream' tagVersion' GetFrameID (tagVersion));  }  
Magic Number,IdSharp.Tagging.ID3v2.Frames,AttachedPicture,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\Frames\AttachedPicture.cs,GetBytes,The following statement contains a magic number: if (tagVersion == ID3v2TagVersion.ID3v22) {  	string format = PictureExtension;  	if (string.IsNullOrEmpty (format) || format.Length < 3)  		format = "   ";  	else if (format.Length > 3)  		format = format.Substring (0' 3);  	stream.Write (Encoding.ASCII.GetBytes (format));  } else {  	SetMimeType ();  	// iTunes needs this set properly  	stream.Write (ByteUtils.ISO88591GetBytes (_mimeType));  	stream.WriteByte (0);  	// terminator  }  
Magic Number,IdSharp.Tagging.ID3v2.Frames,AttachedPicture,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\Frames\AttachedPicture.cs,GetBytes,The following statement contains a magic number: if (tagVersion == ID3v2TagVersion.ID3v22) {  	string format = PictureExtension;  	if (string.IsNullOrEmpty (format) || format.Length < 3)  		format = "   ";  	else if (format.Length > 3)  		format = format.Substring (0' 3);  	stream.Write (Encoding.ASCII.GetBytes (format));  } else {  	SetMimeType ();  	// iTunes needs this set properly  	stream.Write (ByteUtils.ISO88591GetBytes (_mimeType));  	stream.WriteByte (0);  	// terminator  }  
Magic Number,IdSharp.Tagging.ID3v2.Frames,AttachedPicture,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\Frames\AttachedPicture.cs,GetBytes,The following statement contains a magic number: if (tagVersion == ID3v2TagVersion.ID3v22) {  	string format = PictureExtension;  	if (string.IsNullOrEmpty (format) || format.Length < 3)  		format = "   ";  	else if (format.Length > 3)  		format = format.Substring (0' 3);  	stream.Write (Encoding.ASCII.GetBytes (format));  } else {  	SetMimeType ();  	// iTunes needs this set properly  	stream.Write (ByteUtils.ISO88591GetBytes (_mimeType));  	stream.WriteByte (0);  	// terminator  }  
Magic Number,IdSharp.Tagging.ID3v2.Frames,AttachedPicture,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\Frames\AttachedPicture.cs,GetBytes,The following statement contains a magic number: if (string.IsNullOrEmpty (format) || format.Length < 3)  	format = "   ";  else if (format.Length > 3)  	format = format.Substring (0' 3);  
Magic Number,IdSharp.Tagging.ID3v2.Frames,AttachedPicture,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\Frames\AttachedPicture.cs,GetBytes,The following statement contains a magic number: if (string.IsNullOrEmpty (format) || format.Length < 3)  	format = "   ";  else if (format.Length > 3)  	format = format.Substring (0' 3);  
Magic Number,IdSharp.Tagging.ID3v2.Frames,AttachedPicture,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\Frames\AttachedPicture.cs,GetBytes,The following statement contains a magic number: if (string.IsNullOrEmpty (format) || format.Length < 3)  	format = "   ";  else if (format.Length > 3)  	format = format.Substring (0' 3);  
Magic Number,IdSharp.Tagging.ID3v2.Frames,AttachedPicture,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\Frames\AttachedPicture.cs,GetBytes,The following statement contains a magic number: if (format.Length > 3)  	format = format.Substring (0' 3);  
Magic Number,IdSharp.Tagging.ID3v2.Frames,AttachedPicture,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\Frames\AttachedPicture.cs,GetBytes,The following statement contains a magic number: if (format.Length > 3)  	format = format.Substring (0' 3);  
Magic Number,IdSharp.Tagging.ID3v2.Frames,AttachedPicture,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\Frames\AttachedPicture.cs,GetBytes,The following statement contains a magic number: format = format.Substring (0' 3);  
Magic Number,IdSharp.Tagging.ID3v2.Frames,UnknownFrame,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\Frames\UnknownFrame.cs,GetFrameID,The following statement contains a magic number: switch (tagVersion) {  case ID3v2TagVersion.ID3v24:  case ID3v2TagVersion.ID3v23:  	return (_frameID.Length != 4 ? null : _frameID);  case ID3v2TagVersion.ID3v22:  	return (_frameID.Length != 3 ? null : _frameID);  default:  	throw new ArgumentException ("Unknown tag version");  }  
Magic Number,IdSharp.Tagging.ID3v2.Frames,UnknownFrame,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\Frames\UnknownFrame.cs,GetFrameID,The following statement contains a magic number: switch (tagVersion) {  case ID3v2TagVersion.ID3v24:  case ID3v2TagVersion.ID3v23:  	return (_frameID.Length != 4 ? null : _frameID);  case ID3v2TagVersion.ID3v22:  	return (_frameID.Length != 3 ? null : _frameID);  default:  	throw new ArgumentException ("Unknown tag version");  }  
Magic Number,IdSharp.Tagging.ID3v2.Frames,UnknownFrame,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\Frames\UnknownFrame.cs,GetFrameID,The following statement contains a magic number: return (_frameID.Length != 4 ? null : _frameID);  
Magic Number,IdSharp.Tagging.ID3v2.Frames,UnknownFrame,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\Frames\UnknownFrame.cs,GetFrameID,The following statement contains a magic number: return (_frameID.Length != 3 ? null : _frameID);  
Magic Number,IdSharp.Tagging.Lyrics3,Lyrics3Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Lyrics3\Lyrics3Tag.cs,Read,The following statement contains a magic number: stream.Seek (-128 - 9' SeekOrigin.End);  
Magic Number,IdSharp.Tagging.Lyrics3,Lyrics3Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Lyrics3\Lyrics3Tag.cs,Read,The following statement contains a magic number: stream.Seek (-128 - 9' SeekOrigin.End);  
Magic Number,IdSharp.Tagging.Lyrics3,Lyrics3Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Lyrics3\Lyrics3Tag.cs,Read,The following statement contains a magic number: stream.Seek (-9 - 6' SeekOrigin.Current);  
Magic Number,IdSharp.Tagging.Lyrics3,Lyrics3Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Lyrics3\Lyrics3Tag.cs,Read,The following statement contains a magic number: stream.Seek (-9 - 6' SeekOrigin.Current);  
Magic Number,IdSharp.Tagging.Lyrics3,Lyrics3Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Lyrics3\Lyrics3Tag.cs,Read,The following statement contains a magic number: if (lsz <= 11 + 3 + 5 + 1) {  	// invalid' lsz is too small  	return;  }  
Magic Number,IdSharp.Tagging.Lyrics3,Lyrics3Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Lyrics3\Lyrics3Tag.cs,Read,The following statement contains a magic number: if (lsz <= 11 + 3 + 5 + 1) {  	// invalid' lsz is too small  	return;  }  
Magic Number,IdSharp.Tagging.Lyrics3,Lyrics3Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Lyrics3\Lyrics3Tag.cs,Read,The following statement contains a magic number: if (lsz <= 11 + 3 + 5 + 1) {  	// invalid' lsz is too small  	return;  }  
Magic Number,IdSharp.Tagging.Lyrics3,Lyrics3Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Lyrics3\Lyrics3Tag.cs,Read,The following statement contains a magic number: stream.Seek (-6 - lsz' SeekOrigin.Current);  
Magic Number,IdSharp.Tagging.Lyrics3,Lyrics3Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Lyrics3\Lyrics3Tag.cs,Read,The following statement contains a magic number: while (totalRead < lsz) {  	byte[] fieldIDBytes = stream.Read (3);  	string fieldID = Encoding.ASCII.GetString (fieldIDBytes);  	byte[] fszBytes = stream.Read (5);  	int fsz = GetLengthFromByteArray (fszBytes);  	totalRead += 3 + 5;  	// TODO: Indicate error reading Lyrics3 tag  	if (fsz <= 0)  		break;  	if ((totalRead + fsz) > lsz)  		break;  	byte[] valueBytes = stream.Read (fsz);  	string value = Encoding.ASCII.GetString (valueBytes);  	totalRead += fsz;  	SetValue (fieldID' value);  }  
Magic Number,IdSharp.Tagging.Lyrics3,Lyrics3Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Lyrics3\Lyrics3Tag.cs,Read,The following statement contains a magic number: while (totalRead < lsz) {  	byte[] fieldIDBytes = stream.Read (3);  	string fieldID = Encoding.ASCII.GetString (fieldIDBytes);  	byte[] fszBytes = stream.Read (5);  	int fsz = GetLengthFromByteArray (fszBytes);  	totalRead += 3 + 5;  	// TODO: Indicate error reading Lyrics3 tag  	if (fsz <= 0)  		break;  	if ((totalRead + fsz) > lsz)  		break;  	byte[] valueBytes = stream.Read (fsz);  	string value = Encoding.ASCII.GetString (valueBytes);  	totalRead += fsz;  	SetValue (fieldID' value);  }  
Magic Number,IdSharp.Tagging.Lyrics3,Lyrics3Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Lyrics3\Lyrics3Tag.cs,Read,The following statement contains a magic number: while (totalRead < lsz) {  	byte[] fieldIDBytes = stream.Read (3);  	string fieldID = Encoding.ASCII.GetString (fieldIDBytes);  	byte[] fszBytes = stream.Read (5);  	int fsz = GetLengthFromByteArray (fszBytes);  	totalRead += 3 + 5;  	// TODO: Indicate error reading Lyrics3 tag  	if (fsz <= 0)  		break;  	if ((totalRead + fsz) > lsz)  		break;  	byte[] valueBytes = stream.Read (fsz);  	string value = Encoding.ASCII.GetString (valueBytes);  	totalRead += fsz;  	SetValue (fieldID' value);  }  
Magic Number,IdSharp.Tagging.Lyrics3,Lyrics3Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Lyrics3\Lyrics3Tag.cs,Read,The following statement contains a magic number: while (totalRead < lsz) {  	byte[] fieldIDBytes = stream.Read (3);  	string fieldID = Encoding.ASCII.GetString (fieldIDBytes);  	byte[] fszBytes = stream.Read (5);  	int fsz = GetLengthFromByteArray (fszBytes);  	totalRead += 3 + 5;  	// TODO: Indicate error reading Lyrics3 tag  	if (fsz <= 0)  		break;  	if ((totalRead + fsz) > lsz)  		break;  	byte[] valueBytes = stream.Read (fsz);  	string value = Encoding.ASCII.GetString (valueBytes);  	totalRead += fsz;  	SetValue (fieldID' value);  }  
Magic Number,IdSharp.Tagging.Lyrics3,Lyrics3Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Lyrics3\Lyrics3Tag.cs,Read,The following statement contains a magic number: totalRead += 3 + 5;  
Magic Number,IdSharp.Tagging.Lyrics3,Lyrics3Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Lyrics3\Lyrics3Tag.cs,Read,The following statement contains a magic number: totalRead += 3 + 5;  
Magic Number,IdSharp.Tagging.Lyrics3,Lyrics3Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Lyrics3\Lyrics3Tag.cs,Read,The following statement contains a magic number: TotalTagSize = lsz + 15;  
Magic Number,IdSharp.Tagging.Lyrics3,Lyrics3Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Lyrics3\Lyrics3Tag.cs,Read,The following statement contains a magic number: TagOffset = stream.Length - 128 - TotalTagSize;  
Magic Number,IdSharp.Tagging.Lyrics3,Lyrics3Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Lyrics3\Lyrics3Tag.cs,GetLengthFromByteArray,The following statement contains a magic number: for (int i = byteArray.Length - 1' j = 1; i >= 0; i--' j *= 10) {  	int val = byteArray [i] - '0';  	if (val < 0 || val > 9) {  		// invalid;  		return 0;  	}  	length += j * val;  }  
Magic Number,IdSharp.Tagging.Lyrics3,Lyrics3Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Lyrics3\Lyrics3Tag.cs,GetLengthFromByteArray,The following statement contains a magic number: for (int i = byteArray.Length - 1' j = 1; i >= 0; i--' j *= 10) {  	int val = byteArray [i] - '0';  	if (val < 0 || val > 9) {  		// invalid;  		return 0;  	}  	length += j * val;  }  
Magic Number,IdSharp.Tagging.Lyrics3,Lyrics3Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Lyrics3\Lyrics3Tag.cs,GetLengthFromByteArray,The following statement contains a magic number: j *= 10
Magic Number,IdSharp.Tagging.Lyrics3,Lyrics3Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Lyrics3\Lyrics3Tag.cs,GetLengthFromByteArray,The following statement contains a magic number: if (val < 0 || val > 9) {  	// invalid;  	return 0;  }  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ParseTag,The following statement contains a magic number: if (string.Compare (key' "nam"' true) == 0) {  	Title = Encoding.UTF8.GetString (data' 0' size);  } else if (string.Compare (key' "ART"' true) == 0) {  	Artist = Encoding.UTF8.GetString (data' 0' size);  } else if (string.Compare (key' "alb"' true) == 0) {  	Album = Encoding.UTF8.GetString (data' 0' size);  } else if (string.Compare (key' "cmt"' true) == 0) {  	Comment = Encoding.UTF8.GetString (data' 0' size);  } else if (string.Compare (key' "day"' true) == 0) {  	Year = Encoding.UTF8.GetString (data' 0' size);  } else if (string.Compare (key' "too"' true) == 0) {  	Tool = Encoding.UTF8.GetString (data' 0' size);  } else if (string.Compare (key' "gnre"' true) == 0) {  	if (string.IsNullOrEmpty (Genre)) {  		int genreIndex = data [1];  		if (genreIndex != 0) {  			Genre = GenreHelper.GenreByIndex [genreIndex - 1];  		}  	}  } else if (string.Compare (key' "gen"' true) == 0) {  	Genre = Encoding.UTF8.GetString (data' 0' size);  } else if (string.Compare (key' "trkn"' true) == 0) {  	TrackNumber = data [3];  	TotalTracks = data [5];  } else if (string.Compare (key' "disk"' true) == 0) {  	Disc = data [3];  	TotalDiscs = data [5];  } else if (string.Compare (key' "wrt"' true) == 0) {  	Composer = Encoding.UTF8.GetString (data' 0' size);  } else if (string.Compare (key' "cpil"' true) == 0) {  	IsPartOfCompilation = (data [0] == 1);  } else if (string.Compare (key' "tmpo"' true) == 0) {  	BPM = data [1] + (data [0] << 8);  } else {  	// TODO: Save unknown keys  	Console.WriteLine (key);  }  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ParseTag,The following statement contains a magic number: if (string.Compare (key' "nam"' true) == 0) {  	Title = Encoding.UTF8.GetString (data' 0' size);  } else if (string.Compare (key' "ART"' true) == 0) {  	Artist = Encoding.UTF8.GetString (data' 0' size);  } else if (string.Compare (key' "alb"' true) == 0) {  	Album = Encoding.UTF8.GetString (data' 0' size);  } else if (string.Compare (key' "cmt"' true) == 0) {  	Comment = Encoding.UTF8.GetString (data' 0' size);  } else if (string.Compare (key' "day"' true) == 0) {  	Year = Encoding.UTF8.GetString (data' 0' size);  } else if (string.Compare (key' "too"' true) == 0) {  	Tool = Encoding.UTF8.GetString (data' 0' size);  } else if (string.Compare (key' "gnre"' true) == 0) {  	if (string.IsNullOrEmpty (Genre)) {  		int genreIndex = data [1];  		if (genreIndex != 0) {  			Genre = GenreHelper.GenreByIndex [genreIndex - 1];  		}  	}  } else if (string.Compare (key' "gen"' true) == 0) {  	Genre = Encoding.UTF8.GetString (data' 0' size);  } else if (string.Compare (key' "trkn"' true) == 0) {  	TrackNumber = data [3];  	TotalTracks = data [5];  } else if (string.Compare (key' "disk"' true) == 0) {  	Disc = data [3];  	TotalDiscs = data [5];  } else if (string.Compare (key' "wrt"' true) == 0) {  	Composer = Encoding.UTF8.GetString (data' 0' size);  } else if (string.Compare (key' "cpil"' true) == 0) {  	IsPartOfCompilation = (data [0] == 1);  } else if (string.Compare (key' "tmpo"' true) == 0) {  	BPM = data [1] + (data [0] << 8);  } else {  	// TODO: Save unknown keys  	Console.WriteLine (key);  }  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ParseTag,The following statement contains a magic number: if (string.Compare (key' "nam"' true) == 0) {  	Title = Encoding.UTF8.GetString (data' 0' size);  } else if (string.Compare (key' "ART"' true) == 0) {  	Artist = Encoding.UTF8.GetString (data' 0' size);  } else if (string.Compare (key' "alb"' true) == 0) {  	Album = Encoding.UTF8.GetString (data' 0' size);  } else if (string.Compare (key' "cmt"' true) == 0) {  	Comment = Encoding.UTF8.GetString (data' 0' size);  } else if (string.Compare (key' "day"' true) == 0) {  	Year = Encoding.UTF8.GetString (data' 0' size);  } else if (string.Compare (key' "too"' true) == 0) {  	Tool = Encoding.UTF8.GetString (data' 0' size);  } else if (string.Compare (key' "gnre"' true) == 0) {  	if (string.IsNullOrEmpty (Genre)) {  		int genreIndex = data [1];  		if (genreIndex != 0) {  			Genre = GenreHelper.GenreByIndex [genreIndex - 1];  		}  	}  } else if (string.Compare (key' "gen"' true) == 0) {  	Genre = Encoding.UTF8.GetString (data' 0' size);  } else if (string.Compare (key' "trkn"' true) == 0) {  	TrackNumber = data [3];  	TotalTracks = data [5];  } else if (string.Compare (key' "disk"' true) == 0) {  	Disc = data [3];  	TotalDiscs = data [5];  } else if (string.Compare (key' "wrt"' true) == 0) {  	Composer = Encoding.UTF8.GetString (data' 0' size);  } else if (string.Compare (key' "cpil"' true) == 0) {  	IsPartOfCompilation = (data [0] == 1);  } else if (string.Compare (key' "tmpo"' true) == 0) {  	BPM = data [1] + (data [0] << 8);  } else {  	// TODO: Save unknown keys  	Console.WriteLine (key);  }  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ParseTag,The following statement contains a magic number: if (string.Compare (key' "nam"' true) == 0) {  	Title = Encoding.UTF8.GetString (data' 0' size);  } else if (string.Compare (key' "ART"' true) == 0) {  	Artist = Encoding.UTF8.GetString (data' 0' size);  } else if (string.Compare (key' "alb"' true) == 0) {  	Album = Encoding.UTF8.GetString (data' 0' size);  } else if (string.Compare (key' "cmt"' true) == 0) {  	Comment = Encoding.UTF8.GetString (data' 0' size);  } else if (string.Compare (key' "day"' true) == 0) {  	Year = Encoding.UTF8.GetString (data' 0' size);  } else if (string.Compare (key' "too"' true) == 0) {  	Tool = Encoding.UTF8.GetString (data' 0' size);  } else if (string.Compare (key' "gnre"' true) == 0) {  	if (string.IsNullOrEmpty (Genre)) {  		int genreIndex = data [1];  		if (genreIndex != 0) {  			Genre = GenreHelper.GenreByIndex [genreIndex - 1];  		}  	}  } else if (string.Compare (key' "gen"' true) == 0) {  	Genre = Encoding.UTF8.GetString (data' 0' size);  } else if (string.Compare (key' "trkn"' true) == 0) {  	TrackNumber = data [3];  	TotalTracks = data [5];  } else if (string.Compare (key' "disk"' true) == 0) {  	Disc = data [3];  	TotalDiscs = data [5];  } else if (string.Compare (key' "wrt"' true) == 0) {  	Composer = Encoding.UTF8.GetString (data' 0' size);  } else if (string.Compare (key' "cpil"' true) == 0) {  	IsPartOfCompilation = (data [0] == 1);  } else if (string.Compare (key' "tmpo"' true) == 0) {  	BPM = data [1] + (data [0] << 8);  } else {  	// TODO: Save unknown keys  	Console.WriteLine (key);  }  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ParseTag,The following statement contains a magic number: if (string.Compare (key' "nam"' true) == 0) {  	Title = Encoding.UTF8.GetString (data' 0' size);  } else if (string.Compare (key' "ART"' true) == 0) {  	Artist = Encoding.UTF8.GetString (data' 0' size);  } else if (string.Compare (key' "alb"' true) == 0) {  	Album = Encoding.UTF8.GetString (data' 0' size);  } else if (string.Compare (key' "cmt"' true) == 0) {  	Comment = Encoding.UTF8.GetString (data' 0' size);  } else if (string.Compare (key' "day"' true) == 0) {  	Year = Encoding.UTF8.GetString (data' 0' size);  } else if (string.Compare (key' "too"' true) == 0) {  	Tool = Encoding.UTF8.GetString (data' 0' size);  } else if (string.Compare (key' "gnre"' true) == 0) {  	if (string.IsNullOrEmpty (Genre)) {  		int genreIndex = data [1];  		if (genreIndex != 0) {  			Genre = GenreHelper.GenreByIndex [genreIndex - 1];  		}  	}  } else if (string.Compare (key' "gen"' true) == 0) {  	Genre = Encoding.UTF8.GetString (data' 0' size);  } else if (string.Compare (key' "trkn"' true) == 0) {  	TrackNumber = data [3];  	TotalTracks = data [5];  } else if (string.Compare (key' "disk"' true) == 0) {  	Disc = data [3];  	TotalDiscs = data [5];  } else if (string.Compare (key' "wrt"' true) == 0) {  	Composer = Encoding.UTF8.GetString (data' 0' size);  } else if (string.Compare (key' "cpil"' true) == 0) {  	IsPartOfCompilation = (data [0] == 1);  } else if (string.Compare (key' "tmpo"' true) == 0) {  	BPM = data [1] + (data [0] << 8);  } else {  	// TODO: Save unknown keys  	Console.WriteLine (key);  }  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ParseTag,The following statement contains a magic number: if (string.Compare (key' "ART"' true) == 0) {  	Artist = Encoding.UTF8.GetString (data' 0' size);  } else if (string.Compare (key' "alb"' true) == 0) {  	Album = Encoding.UTF8.GetString (data' 0' size);  } else if (string.Compare (key' "cmt"' true) == 0) {  	Comment = Encoding.UTF8.GetString (data' 0' size);  } else if (string.Compare (key' "day"' true) == 0) {  	Year = Encoding.UTF8.GetString (data' 0' size);  } else if (string.Compare (key' "too"' true) == 0) {  	Tool = Encoding.UTF8.GetString (data' 0' size);  } else if (string.Compare (key' "gnre"' true) == 0) {  	if (string.IsNullOrEmpty (Genre)) {  		int genreIndex = data [1];  		if (genreIndex != 0) {  			Genre = GenreHelper.GenreByIndex [genreIndex - 1];  		}  	}  } else if (string.Compare (key' "gen"' true) == 0) {  	Genre = Encoding.UTF8.GetString (data' 0' size);  } else if (string.Compare (key' "trkn"' true) == 0) {  	TrackNumber = data [3];  	TotalTracks = data [5];  } else if (string.Compare (key' "disk"' true) == 0) {  	Disc = data [3];  	TotalDiscs = data [5];  } else if (string.Compare (key' "wrt"' true) == 0) {  	Composer = Encoding.UTF8.GetString (data' 0' size);  } else if (string.Compare (key' "cpil"' true) == 0) {  	IsPartOfCompilation = (data [0] == 1);  } else if (string.Compare (key' "tmpo"' true) == 0) {  	BPM = data [1] + (data [0] << 8);  } else {  	// TODO: Save unknown keys  	Console.WriteLine (key);  }  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ParseTag,The following statement contains a magic number: if (string.Compare (key' "ART"' true) == 0) {  	Artist = Encoding.UTF8.GetString (data' 0' size);  } else if (string.Compare (key' "alb"' true) == 0) {  	Album = Encoding.UTF8.GetString (data' 0' size);  } else if (string.Compare (key' "cmt"' true) == 0) {  	Comment = Encoding.UTF8.GetString (data' 0' size);  } else if (string.Compare (key' "day"' true) == 0) {  	Year = Encoding.UTF8.GetString (data' 0' size);  } else if (string.Compare (key' "too"' true) == 0) {  	Tool = Encoding.UTF8.GetString (data' 0' size);  } else if (string.Compare (key' "gnre"' true) == 0) {  	if (string.IsNullOrEmpty (Genre)) {  		int genreIndex = data [1];  		if (genreIndex != 0) {  			Genre = GenreHelper.GenreByIndex [genreIndex - 1];  		}  	}  } else if (string.Compare (key' "gen"' true) == 0) {  	Genre = Encoding.UTF8.GetString (data' 0' size);  } else if (string.Compare (key' "trkn"' true) == 0) {  	TrackNumber = data [3];  	TotalTracks = data [5];  } else if (string.Compare (key' "disk"' true) == 0) {  	Disc = data [3];  	TotalDiscs = data [5];  } else if (string.Compare (key' "wrt"' true) == 0) {  	Composer = Encoding.UTF8.GetString (data' 0' size);  } else if (string.Compare (key' "cpil"' true) == 0) {  	IsPartOfCompilation = (data [0] == 1);  } else if (string.Compare (key' "tmpo"' true) == 0) {  	BPM = data [1] + (data [0] << 8);  } else {  	// TODO: Save unknown keys  	Console.WriteLine (key);  }  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ParseTag,The following statement contains a magic number: if (string.Compare (key' "ART"' true) == 0) {  	Artist = Encoding.UTF8.GetString (data' 0' size);  } else if (string.Compare (key' "alb"' true) == 0) {  	Album = Encoding.UTF8.GetString (data' 0' size);  } else if (string.Compare (key' "cmt"' true) == 0) {  	Comment = Encoding.UTF8.GetString (data' 0' size);  } else if (string.Compare (key' "day"' true) == 0) {  	Year = Encoding.UTF8.GetString (data' 0' size);  } else if (string.Compare (key' "too"' true) == 0) {  	Tool = Encoding.UTF8.GetString (data' 0' size);  } else if (string.Compare (key' "gnre"' true) == 0) {  	if (string.IsNullOrEmpty (Genre)) {  		int genreIndex = data [1];  		if (genreIndex != 0) {  			Genre = GenreHelper.GenreByIndex [genreIndex - 1];  		}  	}  } else if (string.Compare (key' "gen"' true) == 0) {  	Genre = Encoding.UTF8.GetString (data' 0' size);  } else if (string.Compare (key' "trkn"' true) == 0) {  	TrackNumber = data [3];  	TotalTracks = data [5];  } else if (string.Compare (key' "disk"' true) == 0) {  	Disc = data [3];  	TotalDiscs = data [5];  } else if (string.Compare (key' "wrt"' true) == 0) {  	Composer = Encoding.UTF8.GetString (data' 0' size);  } else if (string.Compare (key' "cpil"' true) == 0) {  	IsPartOfCompilation = (data [0] == 1);  } else if (string.Compare (key' "tmpo"' true) == 0) {  	BPM = data [1] + (data [0] << 8);  } else {  	// TODO: Save unknown keys  	Console.WriteLine (key);  }  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ParseTag,The following statement contains a magic number: if (string.Compare (key' "ART"' true) == 0) {  	Artist = Encoding.UTF8.GetString (data' 0' size);  } else if (string.Compare (key' "alb"' true) == 0) {  	Album = Encoding.UTF8.GetString (data' 0' size);  } else if (string.Compare (key' "cmt"' true) == 0) {  	Comment = Encoding.UTF8.GetString (data' 0' size);  } else if (string.Compare (key' "day"' true) == 0) {  	Year = Encoding.UTF8.GetString (data' 0' size);  } else if (string.Compare (key' "too"' true) == 0) {  	Tool = Encoding.UTF8.GetString (data' 0' size);  } else if (string.Compare (key' "gnre"' true) == 0) {  	if (string.IsNullOrEmpty (Genre)) {  		int genreIndex = data [1];  		if (genreIndex != 0) {  			Genre = GenreHelper.GenreByIndex [genreIndex - 1];  		}  	}  } else if (string.Compare (key' "gen"' true) == 0) {  	Genre = Encoding.UTF8.GetString (data' 0' size);  } else if (string.Compare (key' "trkn"' true) == 0) {  	TrackNumber = data [3];  	TotalTracks = data [5];  } else if (string.Compare (key' "disk"' true) == 0) {  	Disc = data [3];  	TotalDiscs = data [5];  } else if (string.Compare (key' "wrt"' true) == 0) {  	Composer = Encoding.UTF8.GetString (data' 0' size);  } else if (string.Compare (key' "cpil"' true) == 0) {  	IsPartOfCompilation = (data [0] == 1);  } else if (string.Compare (key' "tmpo"' true) == 0) {  	BPM = data [1] + (data [0] << 8);  } else {  	// TODO: Save unknown keys  	Console.WriteLine (key);  }  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ParseTag,The following statement contains a magic number: if (string.Compare (key' "ART"' true) == 0) {  	Artist = Encoding.UTF8.GetString (data' 0' size);  } else if (string.Compare (key' "alb"' true) == 0) {  	Album = Encoding.UTF8.GetString (data' 0' size);  } else if (string.Compare (key' "cmt"' true) == 0) {  	Comment = Encoding.UTF8.GetString (data' 0' size);  } else if (string.Compare (key' "day"' true) == 0) {  	Year = Encoding.UTF8.GetString (data' 0' size);  } else if (string.Compare (key' "too"' true) == 0) {  	Tool = Encoding.UTF8.GetString (data' 0' size);  } else if (string.Compare (key' "gnre"' true) == 0) {  	if (string.IsNullOrEmpty (Genre)) {  		int genreIndex = data [1];  		if (genreIndex != 0) {  			Genre = GenreHelper.GenreByIndex [genreIndex - 1];  		}  	}  } else if (string.Compare (key' "gen"' true) == 0) {  	Genre = Encoding.UTF8.GetString (data' 0' size);  } else if (string.Compare (key' "trkn"' true) == 0) {  	TrackNumber = data [3];  	TotalTracks = data [5];  } else if (string.Compare (key' "disk"' true) == 0) {  	Disc = data [3];  	TotalDiscs = data [5];  } else if (string.Compare (key' "wrt"' true) == 0) {  	Composer = Encoding.UTF8.GetString (data' 0' size);  } else if (string.Compare (key' "cpil"' true) == 0) {  	IsPartOfCompilation = (data [0] == 1);  } else if (string.Compare (key' "tmpo"' true) == 0) {  	BPM = data [1] + (data [0] << 8);  } else {  	// TODO: Save unknown keys  	Console.WriteLine (key);  }  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ParseTag,The following statement contains a magic number: if (string.Compare (key' "alb"' true) == 0) {  	Album = Encoding.UTF8.GetString (data' 0' size);  } else if (string.Compare (key' "cmt"' true) == 0) {  	Comment = Encoding.UTF8.GetString (data' 0' size);  } else if (string.Compare (key' "day"' true) == 0) {  	Year = Encoding.UTF8.GetString (data' 0' size);  } else if (string.Compare (key' "too"' true) == 0) {  	Tool = Encoding.UTF8.GetString (data' 0' size);  } else if (string.Compare (key' "gnre"' true) == 0) {  	if (string.IsNullOrEmpty (Genre)) {  		int genreIndex = data [1];  		if (genreIndex != 0) {  			Genre = GenreHelper.GenreByIndex [genreIndex - 1];  		}  	}  } else if (string.Compare (key' "gen"' true) == 0) {  	Genre = Encoding.UTF8.GetString (data' 0' size);  } else if (string.Compare (key' "trkn"' true) == 0) {  	TrackNumber = data [3];  	TotalTracks = data [5];  } else if (string.Compare (key' "disk"' true) == 0) {  	Disc = data [3];  	TotalDiscs = data [5];  } else if (string.Compare (key' "wrt"' true) == 0) {  	Composer = Encoding.UTF8.GetString (data' 0' size);  } else if (string.Compare (key' "cpil"' true) == 0) {  	IsPartOfCompilation = (data [0] == 1);  } else if (string.Compare (key' "tmpo"' true) == 0) {  	BPM = data [1] + (data [0] << 8);  } else {  	// TODO: Save unknown keys  	Console.WriteLine (key);  }  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ParseTag,The following statement contains a magic number: if (string.Compare (key' "alb"' true) == 0) {  	Album = Encoding.UTF8.GetString (data' 0' size);  } else if (string.Compare (key' "cmt"' true) == 0) {  	Comment = Encoding.UTF8.GetString (data' 0' size);  } else if (string.Compare (key' "day"' true) == 0) {  	Year = Encoding.UTF8.GetString (data' 0' size);  } else if (string.Compare (key' "too"' true) == 0) {  	Tool = Encoding.UTF8.GetString (data' 0' size);  } else if (string.Compare (key' "gnre"' true) == 0) {  	if (string.IsNullOrEmpty (Genre)) {  		int genreIndex = data [1];  		if (genreIndex != 0) {  			Genre = GenreHelper.GenreByIndex [genreIndex - 1];  		}  	}  } else if (string.Compare (key' "gen"' true) == 0) {  	Genre = Encoding.UTF8.GetString (data' 0' size);  } else if (string.Compare (key' "trkn"' true) == 0) {  	TrackNumber = data [3];  	TotalTracks = data [5];  } else if (string.Compare (key' "disk"' true) == 0) {  	Disc = data [3];  	TotalDiscs = data [5];  } else if (string.Compare (key' "wrt"' true) == 0) {  	Composer = Encoding.UTF8.GetString (data' 0' size);  } else if (string.Compare (key' "cpil"' true) == 0) {  	IsPartOfCompilation = (data [0] == 1);  } else if (string.Compare (key' "tmpo"' true) == 0) {  	BPM = data [1] + (data [0] << 8);  } else {  	// TODO: Save unknown keys  	Console.WriteLine (key);  }  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ParseTag,The following statement contains a magic number: if (string.Compare (key' "alb"' true) == 0) {  	Album = Encoding.UTF8.GetString (data' 0' size);  } else if (string.Compare (key' "cmt"' true) == 0) {  	Comment = Encoding.UTF8.GetString (data' 0' size);  } else if (string.Compare (key' "day"' true) == 0) {  	Year = Encoding.UTF8.GetString (data' 0' size);  } else if (string.Compare (key' "too"' true) == 0) {  	Tool = Encoding.UTF8.GetString (data' 0' size);  } else if (string.Compare (key' "gnre"' true) == 0) {  	if (string.IsNullOrEmpty (Genre)) {  		int genreIndex = data [1];  		if (genreIndex != 0) {  			Genre = GenreHelper.GenreByIndex [genreIndex - 1];  		}  	}  } else if (string.Compare (key' "gen"' true) == 0) {  	Genre = Encoding.UTF8.GetString (data' 0' size);  } else if (string.Compare (key' "trkn"' true) == 0) {  	TrackNumber = data [3];  	TotalTracks = data [5];  } else if (string.Compare (key' "disk"' true) == 0) {  	Disc = data [3];  	TotalDiscs = data [5];  } else if (string.Compare (key' "wrt"' true) == 0) {  	Composer = Encoding.UTF8.GetString (data' 0' size);  } else if (string.Compare (key' "cpil"' true) == 0) {  	IsPartOfCompilation = (data [0] == 1);  } else if (string.Compare (key' "tmpo"' true) == 0) {  	BPM = data [1] + (data [0] << 8);  } else {  	// TODO: Save unknown keys  	Console.WriteLine (key);  }  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ParseTag,The following statement contains a magic number: if (string.Compare (key' "alb"' true) == 0) {  	Album = Encoding.UTF8.GetString (data' 0' size);  } else if (string.Compare (key' "cmt"' true) == 0) {  	Comment = Encoding.UTF8.GetString (data' 0' size);  } else if (string.Compare (key' "day"' true) == 0) {  	Year = Encoding.UTF8.GetString (data' 0' size);  } else if (string.Compare (key' "too"' true) == 0) {  	Tool = Encoding.UTF8.GetString (data' 0' size);  } else if (string.Compare (key' "gnre"' true) == 0) {  	if (string.IsNullOrEmpty (Genre)) {  		int genreIndex = data [1];  		if (genreIndex != 0) {  			Genre = GenreHelper.GenreByIndex [genreIndex - 1];  		}  	}  } else if (string.Compare (key' "gen"' true) == 0) {  	Genre = Encoding.UTF8.GetString (data' 0' size);  } else if (string.Compare (key' "trkn"' true) == 0) {  	TrackNumber = data [3];  	TotalTracks = data [5];  } else if (string.Compare (key' "disk"' true) == 0) {  	Disc = data [3];  	TotalDiscs = data [5];  } else if (string.Compare (key' "wrt"' true) == 0) {  	Composer = Encoding.UTF8.GetString (data' 0' size);  } else if (string.Compare (key' "cpil"' true) == 0) {  	IsPartOfCompilation = (data [0] == 1);  } else if (string.Compare (key' "tmpo"' true) == 0) {  	BPM = data [1] + (data [0] << 8);  } else {  	// TODO: Save unknown keys  	Console.WriteLine (key);  }  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ParseTag,The following statement contains a magic number: if (string.Compare (key' "alb"' true) == 0) {  	Album = Encoding.UTF8.GetString (data' 0' size);  } else if (string.Compare (key' "cmt"' true) == 0) {  	Comment = Encoding.UTF8.GetString (data' 0' size);  } else if (string.Compare (key' "day"' true) == 0) {  	Year = Encoding.UTF8.GetString (data' 0' size);  } else if (string.Compare (key' "too"' true) == 0) {  	Tool = Encoding.UTF8.GetString (data' 0' size);  } else if (string.Compare (key' "gnre"' true) == 0) {  	if (string.IsNullOrEmpty (Genre)) {  		int genreIndex = data [1];  		if (genreIndex != 0) {  			Genre = GenreHelper.GenreByIndex [genreIndex - 1];  		}  	}  } else if (string.Compare (key' "gen"' true) == 0) {  	Genre = Encoding.UTF8.GetString (data' 0' size);  } else if (string.Compare (key' "trkn"' true) == 0) {  	TrackNumber = data [3];  	TotalTracks = data [5];  } else if (string.Compare (key' "disk"' true) == 0) {  	Disc = data [3];  	TotalDiscs = data [5];  } else if (string.Compare (key' "wrt"' true) == 0) {  	Composer = Encoding.UTF8.GetString (data' 0' size);  } else if (string.Compare (key' "cpil"' true) == 0) {  	IsPartOfCompilation = (data [0] == 1);  } else if (string.Compare (key' "tmpo"' true) == 0) {  	BPM = data [1] + (data [0] << 8);  } else {  	// TODO: Save unknown keys  	Console.WriteLine (key);  }  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ParseTag,The following statement contains a magic number: if (string.Compare (key' "cmt"' true) == 0) {  	Comment = Encoding.UTF8.GetString (data' 0' size);  } else if (string.Compare (key' "day"' true) == 0) {  	Year = Encoding.UTF8.GetString (data' 0' size);  } else if (string.Compare (key' "too"' true) == 0) {  	Tool = Encoding.UTF8.GetString (data' 0' size);  } else if (string.Compare (key' "gnre"' true) == 0) {  	if (string.IsNullOrEmpty (Genre)) {  		int genreIndex = data [1];  		if (genreIndex != 0) {  			Genre = GenreHelper.GenreByIndex [genreIndex - 1];  		}  	}  } else if (string.Compare (key' "gen"' true) == 0) {  	Genre = Encoding.UTF8.GetString (data' 0' size);  } else if (string.Compare (key' "trkn"' true) == 0) {  	TrackNumber = data [3];  	TotalTracks = data [5];  } else if (string.Compare (key' "disk"' true) == 0) {  	Disc = data [3];  	TotalDiscs = data [5];  } else if (string.Compare (key' "wrt"' true) == 0) {  	Composer = Encoding.UTF8.GetString (data' 0' size);  } else if (string.Compare (key' "cpil"' true) == 0) {  	IsPartOfCompilation = (data [0] == 1);  } else if (string.Compare (key' "tmpo"' true) == 0) {  	BPM = data [1] + (data [0] << 8);  } else {  	// TODO: Save unknown keys  	Console.WriteLine (key);  }  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ParseTag,The following statement contains a magic number: if (string.Compare (key' "cmt"' true) == 0) {  	Comment = Encoding.UTF8.GetString (data' 0' size);  } else if (string.Compare (key' "day"' true) == 0) {  	Year = Encoding.UTF8.GetString (data' 0' size);  } else if (string.Compare (key' "too"' true) == 0) {  	Tool = Encoding.UTF8.GetString (data' 0' size);  } else if (string.Compare (key' "gnre"' true) == 0) {  	if (string.IsNullOrEmpty (Genre)) {  		int genreIndex = data [1];  		if (genreIndex != 0) {  			Genre = GenreHelper.GenreByIndex [genreIndex - 1];  		}  	}  } else if (string.Compare (key' "gen"' true) == 0) {  	Genre = Encoding.UTF8.GetString (data' 0' size);  } else if (string.Compare (key' "trkn"' true) == 0) {  	TrackNumber = data [3];  	TotalTracks = data [5];  } else if (string.Compare (key' "disk"' true) == 0) {  	Disc = data [3];  	TotalDiscs = data [5];  } else if (string.Compare (key' "wrt"' true) == 0) {  	Composer = Encoding.UTF8.GetString (data' 0' size);  } else if (string.Compare (key' "cpil"' true) == 0) {  	IsPartOfCompilation = (data [0] == 1);  } else if (string.Compare (key' "tmpo"' true) == 0) {  	BPM = data [1] + (data [0] << 8);  } else {  	// TODO: Save unknown keys  	Console.WriteLine (key);  }  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ParseTag,The following statement contains a magic number: if (string.Compare (key' "cmt"' true) == 0) {  	Comment = Encoding.UTF8.GetString (data' 0' size);  } else if (string.Compare (key' "day"' true) == 0) {  	Year = Encoding.UTF8.GetString (data' 0' size);  } else if (string.Compare (key' "too"' true) == 0) {  	Tool = Encoding.UTF8.GetString (data' 0' size);  } else if (string.Compare (key' "gnre"' true) == 0) {  	if (string.IsNullOrEmpty (Genre)) {  		int genreIndex = data [1];  		if (genreIndex != 0) {  			Genre = GenreHelper.GenreByIndex [genreIndex - 1];  		}  	}  } else if (string.Compare (key' "gen"' true) == 0) {  	Genre = Encoding.UTF8.GetString (data' 0' size);  } else if (string.Compare (key' "trkn"' true) == 0) {  	TrackNumber = data [3];  	TotalTracks = data [5];  } else if (string.Compare (key' "disk"' true) == 0) {  	Disc = data [3];  	TotalDiscs = data [5];  } else if (string.Compare (key' "wrt"' true) == 0) {  	Composer = Encoding.UTF8.GetString (data' 0' size);  } else if (string.Compare (key' "cpil"' true) == 0) {  	IsPartOfCompilation = (data [0] == 1);  } else if (string.Compare (key' "tmpo"' true) == 0) {  	BPM = data [1] + (data [0] << 8);  } else {  	// TODO: Save unknown keys  	Console.WriteLine (key);  }  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ParseTag,The following statement contains a magic number: if (string.Compare (key' "cmt"' true) == 0) {  	Comment = Encoding.UTF8.GetString (data' 0' size);  } else if (string.Compare (key' "day"' true) == 0) {  	Year = Encoding.UTF8.GetString (data' 0' size);  } else if (string.Compare (key' "too"' true) == 0) {  	Tool = Encoding.UTF8.GetString (data' 0' size);  } else if (string.Compare (key' "gnre"' true) == 0) {  	if (string.IsNullOrEmpty (Genre)) {  		int genreIndex = data [1];  		if (genreIndex != 0) {  			Genre = GenreHelper.GenreByIndex [genreIndex - 1];  		}  	}  } else if (string.Compare (key' "gen"' true) == 0) {  	Genre = Encoding.UTF8.GetString (data' 0' size);  } else if (string.Compare (key' "trkn"' true) == 0) {  	TrackNumber = data [3];  	TotalTracks = data [5];  } else if (string.Compare (key' "disk"' true) == 0) {  	Disc = data [3];  	TotalDiscs = data [5];  } else if (string.Compare (key' "wrt"' true) == 0) {  	Composer = Encoding.UTF8.GetString (data' 0' size);  } else if (string.Compare (key' "cpil"' true) == 0) {  	IsPartOfCompilation = (data [0] == 1);  } else if (string.Compare (key' "tmpo"' true) == 0) {  	BPM = data [1] + (data [0] << 8);  } else {  	// TODO: Save unknown keys  	Console.WriteLine (key);  }  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ParseTag,The following statement contains a magic number: if (string.Compare (key' "cmt"' true) == 0) {  	Comment = Encoding.UTF8.GetString (data' 0' size);  } else if (string.Compare (key' "day"' true) == 0) {  	Year = Encoding.UTF8.GetString (data' 0' size);  } else if (string.Compare (key' "too"' true) == 0) {  	Tool = Encoding.UTF8.GetString (data' 0' size);  } else if (string.Compare (key' "gnre"' true) == 0) {  	if (string.IsNullOrEmpty (Genre)) {  		int genreIndex = data [1];  		if (genreIndex != 0) {  			Genre = GenreHelper.GenreByIndex [genreIndex - 1];  		}  	}  } else if (string.Compare (key' "gen"' true) == 0) {  	Genre = Encoding.UTF8.GetString (data' 0' size);  } else if (string.Compare (key' "trkn"' true) == 0) {  	TrackNumber = data [3];  	TotalTracks = data [5];  } else if (string.Compare (key' "disk"' true) == 0) {  	Disc = data [3];  	TotalDiscs = data [5];  } else if (string.Compare (key' "wrt"' true) == 0) {  	Composer = Encoding.UTF8.GetString (data' 0' size);  } else if (string.Compare (key' "cpil"' true) == 0) {  	IsPartOfCompilation = (data [0] == 1);  } else if (string.Compare (key' "tmpo"' true) == 0) {  	BPM = data [1] + (data [0] << 8);  } else {  	// TODO: Save unknown keys  	Console.WriteLine (key);  }  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ParseTag,The following statement contains a magic number: if (string.Compare (key' "day"' true) == 0) {  	Year = Encoding.UTF8.GetString (data' 0' size);  } else if (string.Compare (key' "too"' true) == 0) {  	Tool = Encoding.UTF8.GetString (data' 0' size);  } else if (string.Compare (key' "gnre"' true) == 0) {  	if (string.IsNullOrEmpty (Genre)) {  		int genreIndex = data [1];  		if (genreIndex != 0) {  			Genre = GenreHelper.GenreByIndex [genreIndex - 1];  		}  	}  } else if (string.Compare (key' "gen"' true) == 0) {  	Genre = Encoding.UTF8.GetString (data' 0' size);  } else if (string.Compare (key' "trkn"' true) == 0) {  	TrackNumber = data [3];  	TotalTracks = data [5];  } else if (string.Compare (key' "disk"' true) == 0) {  	Disc = data [3];  	TotalDiscs = data [5];  } else if (string.Compare (key' "wrt"' true) == 0) {  	Composer = Encoding.UTF8.GetString (data' 0' size);  } else if (string.Compare (key' "cpil"' true) == 0) {  	IsPartOfCompilation = (data [0] == 1);  } else if (string.Compare (key' "tmpo"' true) == 0) {  	BPM = data [1] + (data [0] << 8);  } else {  	// TODO: Save unknown keys  	Console.WriteLine (key);  }  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ParseTag,The following statement contains a magic number: if (string.Compare (key' "day"' true) == 0) {  	Year = Encoding.UTF8.GetString (data' 0' size);  } else if (string.Compare (key' "too"' true) == 0) {  	Tool = Encoding.UTF8.GetString (data' 0' size);  } else if (string.Compare (key' "gnre"' true) == 0) {  	if (string.IsNullOrEmpty (Genre)) {  		int genreIndex = data [1];  		if (genreIndex != 0) {  			Genre = GenreHelper.GenreByIndex [genreIndex - 1];  		}  	}  } else if (string.Compare (key' "gen"' true) == 0) {  	Genre = Encoding.UTF8.GetString (data' 0' size);  } else if (string.Compare (key' "trkn"' true) == 0) {  	TrackNumber = data [3];  	TotalTracks = data [5];  } else if (string.Compare (key' "disk"' true) == 0) {  	Disc = data [3];  	TotalDiscs = data [5];  } else if (string.Compare (key' "wrt"' true) == 0) {  	Composer = Encoding.UTF8.GetString (data' 0' size);  } else if (string.Compare (key' "cpil"' true) == 0) {  	IsPartOfCompilation = (data [0] == 1);  } else if (string.Compare (key' "tmpo"' true) == 0) {  	BPM = data [1] + (data [0] << 8);  } else {  	// TODO: Save unknown keys  	Console.WriteLine (key);  }  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ParseTag,The following statement contains a magic number: if (string.Compare (key' "day"' true) == 0) {  	Year = Encoding.UTF8.GetString (data' 0' size);  } else if (string.Compare (key' "too"' true) == 0) {  	Tool = Encoding.UTF8.GetString (data' 0' size);  } else if (string.Compare (key' "gnre"' true) == 0) {  	if (string.IsNullOrEmpty (Genre)) {  		int genreIndex = data [1];  		if (genreIndex != 0) {  			Genre = GenreHelper.GenreByIndex [genreIndex - 1];  		}  	}  } else if (string.Compare (key' "gen"' true) == 0) {  	Genre = Encoding.UTF8.GetString (data' 0' size);  } else if (string.Compare (key' "trkn"' true) == 0) {  	TrackNumber = data [3];  	TotalTracks = data [5];  } else if (string.Compare (key' "disk"' true) == 0) {  	Disc = data [3];  	TotalDiscs = data [5];  } else if (string.Compare (key' "wrt"' true) == 0) {  	Composer = Encoding.UTF8.GetString (data' 0' size);  } else if (string.Compare (key' "cpil"' true) == 0) {  	IsPartOfCompilation = (data [0] == 1);  } else if (string.Compare (key' "tmpo"' true) == 0) {  	BPM = data [1] + (data [0] << 8);  } else {  	// TODO: Save unknown keys  	Console.WriteLine (key);  }  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ParseTag,The following statement contains a magic number: if (string.Compare (key' "day"' true) == 0) {  	Year = Encoding.UTF8.GetString (data' 0' size);  } else if (string.Compare (key' "too"' true) == 0) {  	Tool = Encoding.UTF8.GetString (data' 0' size);  } else if (string.Compare (key' "gnre"' true) == 0) {  	if (string.IsNullOrEmpty (Genre)) {  		int genreIndex = data [1];  		if (genreIndex != 0) {  			Genre = GenreHelper.GenreByIndex [genreIndex - 1];  		}  	}  } else if (string.Compare (key' "gen"' true) == 0) {  	Genre = Encoding.UTF8.GetString (data' 0' size);  } else if (string.Compare (key' "trkn"' true) == 0) {  	TrackNumber = data [3];  	TotalTracks = data [5];  } else if (string.Compare (key' "disk"' true) == 0) {  	Disc = data [3];  	TotalDiscs = data [5];  } else if (string.Compare (key' "wrt"' true) == 0) {  	Composer = Encoding.UTF8.GetString (data' 0' size);  } else if (string.Compare (key' "cpil"' true) == 0) {  	IsPartOfCompilation = (data [0] == 1);  } else if (string.Compare (key' "tmpo"' true) == 0) {  	BPM = data [1] + (data [0] << 8);  } else {  	// TODO: Save unknown keys  	Console.WriteLine (key);  }  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ParseTag,The following statement contains a magic number: if (string.Compare (key' "day"' true) == 0) {  	Year = Encoding.UTF8.GetString (data' 0' size);  } else if (string.Compare (key' "too"' true) == 0) {  	Tool = Encoding.UTF8.GetString (data' 0' size);  } else if (string.Compare (key' "gnre"' true) == 0) {  	if (string.IsNullOrEmpty (Genre)) {  		int genreIndex = data [1];  		if (genreIndex != 0) {  			Genre = GenreHelper.GenreByIndex [genreIndex - 1];  		}  	}  } else if (string.Compare (key' "gen"' true) == 0) {  	Genre = Encoding.UTF8.GetString (data' 0' size);  } else if (string.Compare (key' "trkn"' true) == 0) {  	TrackNumber = data [3];  	TotalTracks = data [5];  } else if (string.Compare (key' "disk"' true) == 0) {  	Disc = data [3];  	TotalDiscs = data [5];  } else if (string.Compare (key' "wrt"' true) == 0) {  	Composer = Encoding.UTF8.GetString (data' 0' size);  } else if (string.Compare (key' "cpil"' true) == 0) {  	IsPartOfCompilation = (data [0] == 1);  } else if (string.Compare (key' "tmpo"' true) == 0) {  	BPM = data [1] + (data [0] << 8);  } else {  	// TODO: Save unknown keys  	Console.WriteLine (key);  }  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ParseTag,The following statement contains a magic number: if (string.Compare (key' "too"' true) == 0) {  	Tool = Encoding.UTF8.GetString (data' 0' size);  } else if (string.Compare (key' "gnre"' true) == 0) {  	if (string.IsNullOrEmpty (Genre)) {  		int genreIndex = data [1];  		if (genreIndex != 0) {  			Genre = GenreHelper.GenreByIndex [genreIndex - 1];  		}  	}  } else if (string.Compare (key' "gen"' true) == 0) {  	Genre = Encoding.UTF8.GetString (data' 0' size);  } else if (string.Compare (key' "trkn"' true) == 0) {  	TrackNumber = data [3];  	TotalTracks = data [5];  } else if (string.Compare (key' "disk"' true) == 0) {  	Disc = data [3];  	TotalDiscs = data [5];  } else if (string.Compare (key' "wrt"' true) == 0) {  	Composer = Encoding.UTF8.GetString (data' 0' size);  } else if (string.Compare (key' "cpil"' true) == 0) {  	IsPartOfCompilation = (data [0] == 1);  } else if (string.Compare (key' "tmpo"' true) == 0) {  	BPM = data [1] + (data [0] << 8);  } else {  	// TODO: Save unknown keys  	Console.WriteLine (key);  }  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ParseTag,The following statement contains a magic number: if (string.Compare (key' "too"' true) == 0) {  	Tool = Encoding.UTF8.GetString (data' 0' size);  } else if (string.Compare (key' "gnre"' true) == 0) {  	if (string.IsNullOrEmpty (Genre)) {  		int genreIndex = data [1];  		if (genreIndex != 0) {  			Genre = GenreHelper.GenreByIndex [genreIndex - 1];  		}  	}  } else if (string.Compare (key' "gen"' true) == 0) {  	Genre = Encoding.UTF8.GetString (data' 0' size);  } else if (string.Compare (key' "trkn"' true) == 0) {  	TrackNumber = data [3];  	TotalTracks = data [5];  } else if (string.Compare (key' "disk"' true) == 0) {  	Disc = data [3];  	TotalDiscs = data [5];  } else if (string.Compare (key' "wrt"' true) == 0) {  	Composer = Encoding.UTF8.GetString (data' 0' size);  } else if (string.Compare (key' "cpil"' true) == 0) {  	IsPartOfCompilation = (data [0] == 1);  } else if (string.Compare (key' "tmpo"' true) == 0) {  	BPM = data [1] + (data [0] << 8);  } else {  	// TODO: Save unknown keys  	Console.WriteLine (key);  }  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ParseTag,The following statement contains a magic number: if (string.Compare (key' "too"' true) == 0) {  	Tool = Encoding.UTF8.GetString (data' 0' size);  } else if (string.Compare (key' "gnre"' true) == 0) {  	if (string.IsNullOrEmpty (Genre)) {  		int genreIndex = data [1];  		if (genreIndex != 0) {  			Genre = GenreHelper.GenreByIndex [genreIndex - 1];  		}  	}  } else if (string.Compare (key' "gen"' true) == 0) {  	Genre = Encoding.UTF8.GetString (data' 0' size);  } else if (string.Compare (key' "trkn"' true) == 0) {  	TrackNumber = data [3];  	TotalTracks = data [5];  } else if (string.Compare (key' "disk"' true) == 0) {  	Disc = data [3];  	TotalDiscs = data [5];  } else if (string.Compare (key' "wrt"' true) == 0) {  	Composer = Encoding.UTF8.GetString (data' 0' size);  } else if (string.Compare (key' "cpil"' true) == 0) {  	IsPartOfCompilation = (data [0] == 1);  } else if (string.Compare (key' "tmpo"' true) == 0) {  	BPM = data [1] + (data [0] << 8);  } else {  	// TODO: Save unknown keys  	Console.WriteLine (key);  }  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ParseTag,The following statement contains a magic number: if (string.Compare (key' "too"' true) == 0) {  	Tool = Encoding.UTF8.GetString (data' 0' size);  } else if (string.Compare (key' "gnre"' true) == 0) {  	if (string.IsNullOrEmpty (Genre)) {  		int genreIndex = data [1];  		if (genreIndex != 0) {  			Genre = GenreHelper.GenreByIndex [genreIndex - 1];  		}  	}  } else if (string.Compare (key' "gen"' true) == 0) {  	Genre = Encoding.UTF8.GetString (data' 0' size);  } else if (string.Compare (key' "trkn"' true) == 0) {  	TrackNumber = data [3];  	TotalTracks = data [5];  } else if (string.Compare (key' "disk"' true) == 0) {  	Disc = data [3];  	TotalDiscs = data [5];  } else if (string.Compare (key' "wrt"' true) == 0) {  	Composer = Encoding.UTF8.GetString (data' 0' size);  } else if (string.Compare (key' "cpil"' true) == 0) {  	IsPartOfCompilation = (data [0] == 1);  } else if (string.Compare (key' "tmpo"' true) == 0) {  	BPM = data [1] + (data [0] << 8);  } else {  	// TODO: Save unknown keys  	Console.WriteLine (key);  }  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ParseTag,The following statement contains a magic number: if (string.Compare (key' "too"' true) == 0) {  	Tool = Encoding.UTF8.GetString (data' 0' size);  } else if (string.Compare (key' "gnre"' true) == 0) {  	if (string.IsNullOrEmpty (Genre)) {  		int genreIndex = data [1];  		if (genreIndex != 0) {  			Genre = GenreHelper.GenreByIndex [genreIndex - 1];  		}  	}  } else if (string.Compare (key' "gen"' true) == 0) {  	Genre = Encoding.UTF8.GetString (data' 0' size);  } else if (string.Compare (key' "trkn"' true) == 0) {  	TrackNumber = data [3];  	TotalTracks = data [5];  } else if (string.Compare (key' "disk"' true) == 0) {  	Disc = data [3];  	TotalDiscs = data [5];  } else if (string.Compare (key' "wrt"' true) == 0) {  	Composer = Encoding.UTF8.GetString (data' 0' size);  } else if (string.Compare (key' "cpil"' true) == 0) {  	IsPartOfCompilation = (data [0] == 1);  } else if (string.Compare (key' "tmpo"' true) == 0) {  	BPM = data [1] + (data [0] << 8);  } else {  	// TODO: Save unknown keys  	Console.WriteLine (key);  }  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ParseTag,The following statement contains a magic number: if (string.Compare (key' "gnre"' true) == 0) {  	if (string.IsNullOrEmpty (Genre)) {  		int genreIndex = data [1];  		if (genreIndex != 0) {  			Genre = GenreHelper.GenreByIndex [genreIndex - 1];  		}  	}  } else if (string.Compare (key' "gen"' true) == 0) {  	Genre = Encoding.UTF8.GetString (data' 0' size);  } else if (string.Compare (key' "trkn"' true) == 0) {  	TrackNumber = data [3];  	TotalTracks = data [5];  } else if (string.Compare (key' "disk"' true) == 0) {  	Disc = data [3];  	TotalDiscs = data [5];  } else if (string.Compare (key' "wrt"' true) == 0) {  	Composer = Encoding.UTF8.GetString (data' 0' size);  } else if (string.Compare (key' "cpil"' true) == 0) {  	IsPartOfCompilation = (data [0] == 1);  } else if (string.Compare (key' "tmpo"' true) == 0) {  	BPM = data [1] + (data [0] << 8);  } else {  	// TODO: Save unknown keys  	Console.WriteLine (key);  }  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ParseTag,The following statement contains a magic number: if (string.Compare (key' "gnre"' true) == 0) {  	if (string.IsNullOrEmpty (Genre)) {  		int genreIndex = data [1];  		if (genreIndex != 0) {  			Genre = GenreHelper.GenreByIndex [genreIndex - 1];  		}  	}  } else if (string.Compare (key' "gen"' true) == 0) {  	Genre = Encoding.UTF8.GetString (data' 0' size);  } else if (string.Compare (key' "trkn"' true) == 0) {  	TrackNumber = data [3];  	TotalTracks = data [5];  } else if (string.Compare (key' "disk"' true) == 0) {  	Disc = data [3];  	TotalDiscs = data [5];  } else if (string.Compare (key' "wrt"' true) == 0) {  	Composer = Encoding.UTF8.GetString (data' 0' size);  } else if (string.Compare (key' "cpil"' true) == 0) {  	IsPartOfCompilation = (data [0] == 1);  } else if (string.Compare (key' "tmpo"' true) == 0) {  	BPM = data [1] + (data [0] << 8);  } else {  	// TODO: Save unknown keys  	Console.WriteLine (key);  }  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ParseTag,The following statement contains a magic number: if (string.Compare (key' "gnre"' true) == 0) {  	if (string.IsNullOrEmpty (Genre)) {  		int genreIndex = data [1];  		if (genreIndex != 0) {  			Genre = GenreHelper.GenreByIndex [genreIndex - 1];  		}  	}  } else if (string.Compare (key' "gen"' true) == 0) {  	Genre = Encoding.UTF8.GetString (data' 0' size);  } else if (string.Compare (key' "trkn"' true) == 0) {  	TrackNumber = data [3];  	TotalTracks = data [5];  } else if (string.Compare (key' "disk"' true) == 0) {  	Disc = data [3];  	TotalDiscs = data [5];  } else if (string.Compare (key' "wrt"' true) == 0) {  	Composer = Encoding.UTF8.GetString (data' 0' size);  } else if (string.Compare (key' "cpil"' true) == 0) {  	IsPartOfCompilation = (data [0] == 1);  } else if (string.Compare (key' "tmpo"' true) == 0) {  	BPM = data [1] + (data [0] << 8);  } else {  	// TODO: Save unknown keys  	Console.WriteLine (key);  }  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ParseTag,The following statement contains a magic number: if (string.Compare (key' "gnre"' true) == 0) {  	if (string.IsNullOrEmpty (Genre)) {  		int genreIndex = data [1];  		if (genreIndex != 0) {  			Genre = GenreHelper.GenreByIndex [genreIndex - 1];  		}  	}  } else if (string.Compare (key' "gen"' true) == 0) {  	Genre = Encoding.UTF8.GetString (data' 0' size);  } else if (string.Compare (key' "trkn"' true) == 0) {  	TrackNumber = data [3];  	TotalTracks = data [5];  } else if (string.Compare (key' "disk"' true) == 0) {  	Disc = data [3];  	TotalDiscs = data [5];  } else if (string.Compare (key' "wrt"' true) == 0) {  	Composer = Encoding.UTF8.GetString (data' 0' size);  } else if (string.Compare (key' "cpil"' true) == 0) {  	IsPartOfCompilation = (data [0] == 1);  } else if (string.Compare (key' "tmpo"' true) == 0) {  	BPM = data [1] + (data [0] << 8);  } else {  	// TODO: Save unknown keys  	Console.WriteLine (key);  }  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ParseTag,The following statement contains a magic number: if (string.Compare (key' "gnre"' true) == 0) {  	if (string.IsNullOrEmpty (Genre)) {  		int genreIndex = data [1];  		if (genreIndex != 0) {  			Genre = GenreHelper.GenreByIndex [genreIndex - 1];  		}  	}  } else if (string.Compare (key' "gen"' true) == 0) {  	Genre = Encoding.UTF8.GetString (data' 0' size);  } else if (string.Compare (key' "trkn"' true) == 0) {  	TrackNumber = data [3];  	TotalTracks = data [5];  } else if (string.Compare (key' "disk"' true) == 0) {  	Disc = data [3];  	TotalDiscs = data [5];  } else if (string.Compare (key' "wrt"' true) == 0) {  	Composer = Encoding.UTF8.GetString (data' 0' size);  } else if (string.Compare (key' "cpil"' true) == 0) {  	IsPartOfCompilation = (data [0] == 1);  } else if (string.Compare (key' "tmpo"' true) == 0) {  	BPM = data [1] + (data [0] << 8);  } else {  	// TODO: Save unknown keys  	Console.WriteLine (key);  }  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ParseTag,The following statement contains a magic number: if (string.Compare (key' "gen"' true) == 0) {  	Genre = Encoding.UTF8.GetString (data' 0' size);  } else if (string.Compare (key' "trkn"' true) == 0) {  	TrackNumber = data [3];  	TotalTracks = data [5];  } else if (string.Compare (key' "disk"' true) == 0) {  	Disc = data [3];  	TotalDiscs = data [5];  } else if (string.Compare (key' "wrt"' true) == 0) {  	Composer = Encoding.UTF8.GetString (data' 0' size);  } else if (string.Compare (key' "cpil"' true) == 0) {  	IsPartOfCompilation = (data [0] == 1);  } else if (string.Compare (key' "tmpo"' true) == 0) {  	BPM = data [1] + (data [0] << 8);  } else {  	// TODO: Save unknown keys  	Console.WriteLine (key);  }  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ParseTag,The following statement contains a magic number: if (string.Compare (key' "gen"' true) == 0) {  	Genre = Encoding.UTF8.GetString (data' 0' size);  } else if (string.Compare (key' "trkn"' true) == 0) {  	TrackNumber = data [3];  	TotalTracks = data [5];  } else if (string.Compare (key' "disk"' true) == 0) {  	Disc = data [3];  	TotalDiscs = data [5];  } else if (string.Compare (key' "wrt"' true) == 0) {  	Composer = Encoding.UTF8.GetString (data' 0' size);  } else if (string.Compare (key' "cpil"' true) == 0) {  	IsPartOfCompilation = (data [0] == 1);  } else if (string.Compare (key' "tmpo"' true) == 0) {  	BPM = data [1] + (data [0] << 8);  } else {  	// TODO: Save unknown keys  	Console.WriteLine (key);  }  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ParseTag,The following statement contains a magic number: if (string.Compare (key' "gen"' true) == 0) {  	Genre = Encoding.UTF8.GetString (data' 0' size);  } else if (string.Compare (key' "trkn"' true) == 0) {  	TrackNumber = data [3];  	TotalTracks = data [5];  } else if (string.Compare (key' "disk"' true) == 0) {  	Disc = data [3];  	TotalDiscs = data [5];  } else if (string.Compare (key' "wrt"' true) == 0) {  	Composer = Encoding.UTF8.GetString (data' 0' size);  } else if (string.Compare (key' "cpil"' true) == 0) {  	IsPartOfCompilation = (data [0] == 1);  } else if (string.Compare (key' "tmpo"' true) == 0) {  	BPM = data [1] + (data [0] << 8);  } else {  	// TODO: Save unknown keys  	Console.WriteLine (key);  }  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ParseTag,The following statement contains a magic number: if (string.Compare (key' "gen"' true) == 0) {  	Genre = Encoding.UTF8.GetString (data' 0' size);  } else if (string.Compare (key' "trkn"' true) == 0) {  	TrackNumber = data [3];  	TotalTracks = data [5];  } else if (string.Compare (key' "disk"' true) == 0) {  	Disc = data [3];  	TotalDiscs = data [5];  } else if (string.Compare (key' "wrt"' true) == 0) {  	Composer = Encoding.UTF8.GetString (data' 0' size);  } else if (string.Compare (key' "cpil"' true) == 0) {  	IsPartOfCompilation = (data [0] == 1);  } else if (string.Compare (key' "tmpo"' true) == 0) {  	BPM = data [1] + (data [0] << 8);  } else {  	// TODO: Save unknown keys  	Console.WriteLine (key);  }  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ParseTag,The following statement contains a magic number: if (string.Compare (key' "gen"' true) == 0) {  	Genre = Encoding.UTF8.GetString (data' 0' size);  } else if (string.Compare (key' "trkn"' true) == 0) {  	TrackNumber = data [3];  	TotalTracks = data [5];  } else if (string.Compare (key' "disk"' true) == 0) {  	Disc = data [3];  	TotalDiscs = data [5];  } else if (string.Compare (key' "wrt"' true) == 0) {  	Composer = Encoding.UTF8.GetString (data' 0' size);  } else if (string.Compare (key' "cpil"' true) == 0) {  	IsPartOfCompilation = (data [0] == 1);  } else if (string.Compare (key' "tmpo"' true) == 0) {  	BPM = data [1] + (data [0] << 8);  } else {  	// TODO: Save unknown keys  	Console.WriteLine (key);  }  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ParseTag,The following statement contains a magic number: if (string.Compare (key' "trkn"' true) == 0) {  	TrackNumber = data [3];  	TotalTracks = data [5];  } else if (string.Compare (key' "disk"' true) == 0) {  	Disc = data [3];  	TotalDiscs = data [5];  } else if (string.Compare (key' "wrt"' true) == 0) {  	Composer = Encoding.UTF8.GetString (data' 0' size);  } else if (string.Compare (key' "cpil"' true) == 0) {  	IsPartOfCompilation = (data [0] == 1);  } else if (string.Compare (key' "tmpo"' true) == 0) {  	BPM = data [1] + (data [0] << 8);  } else {  	// TODO: Save unknown keys  	Console.WriteLine (key);  }  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ParseTag,The following statement contains a magic number: if (string.Compare (key' "trkn"' true) == 0) {  	TrackNumber = data [3];  	TotalTracks = data [5];  } else if (string.Compare (key' "disk"' true) == 0) {  	Disc = data [3];  	TotalDiscs = data [5];  } else if (string.Compare (key' "wrt"' true) == 0) {  	Composer = Encoding.UTF8.GetString (data' 0' size);  } else if (string.Compare (key' "cpil"' true) == 0) {  	IsPartOfCompilation = (data [0] == 1);  } else if (string.Compare (key' "tmpo"' true) == 0) {  	BPM = data [1] + (data [0] << 8);  } else {  	// TODO: Save unknown keys  	Console.WriteLine (key);  }  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ParseTag,The following statement contains a magic number: if (string.Compare (key' "trkn"' true) == 0) {  	TrackNumber = data [3];  	TotalTracks = data [5];  } else if (string.Compare (key' "disk"' true) == 0) {  	Disc = data [3];  	TotalDiscs = data [5];  } else if (string.Compare (key' "wrt"' true) == 0) {  	Composer = Encoding.UTF8.GetString (data' 0' size);  } else if (string.Compare (key' "cpil"' true) == 0) {  	IsPartOfCompilation = (data [0] == 1);  } else if (string.Compare (key' "tmpo"' true) == 0) {  	BPM = data [1] + (data [0] << 8);  } else {  	// TODO: Save unknown keys  	Console.WriteLine (key);  }  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ParseTag,The following statement contains a magic number: if (string.Compare (key' "trkn"' true) == 0) {  	TrackNumber = data [3];  	TotalTracks = data [5];  } else if (string.Compare (key' "disk"' true) == 0) {  	Disc = data [3];  	TotalDiscs = data [5];  } else if (string.Compare (key' "wrt"' true) == 0) {  	Composer = Encoding.UTF8.GetString (data' 0' size);  } else if (string.Compare (key' "cpil"' true) == 0) {  	IsPartOfCompilation = (data [0] == 1);  } else if (string.Compare (key' "tmpo"' true) == 0) {  	BPM = data [1] + (data [0] << 8);  } else {  	// TODO: Save unknown keys  	Console.WriteLine (key);  }  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ParseTag,The following statement contains a magic number: if (string.Compare (key' "trkn"' true) == 0) {  	TrackNumber = data [3];  	TotalTracks = data [5];  } else if (string.Compare (key' "disk"' true) == 0) {  	Disc = data [3];  	TotalDiscs = data [5];  } else if (string.Compare (key' "wrt"' true) == 0) {  	Composer = Encoding.UTF8.GetString (data' 0' size);  } else if (string.Compare (key' "cpil"' true) == 0) {  	IsPartOfCompilation = (data [0] == 1);  } else if (string.Compare (key' "tmpo"' true) == 0) {  	BPM = data [1] + (data [0] << 8);  } else {  	// TODO: Save unknown keys  	Console.WriteLine (key);  }  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ParseTag,The following statement contains a magic number: TrackNumber = data [3];  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ParseTag,The following statement contains a magic number: TotalTracks = data [5];  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ParseTag,The following statement contains a magic number: if (string.Compare (key' "disk"' true) == 0) {  	Disc = data [3];  	TotalDiscs = data [5];  } else if (string.Compare (key' "wrt"' true) == 0) {  	Composer = Encoding.UTF8.GetString (data' 0' size);  } else if (string.Compare (key' "cpil"' true) == 0) {  	IsPartOfCompilation = (data [0] == 1);  } else if (string.Compare (key' "tmpo"' true) == 0) {  	BPM = data [1] + (data [0] << 8);  } else {  	// TODO: Save unknown keys  	Console.WriteLine (key);  }  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ParseTag,The following statement contains a magic number: if (string.Compare (key' "disk"' true) == 0) {  	Disc = data [3];  	TotalDiscs = data [5];  } else if (string.Compare (key' "wrt"' true) == 0) {  	Composer = Encoding.UTF8.GetString (data' 0' size);  } else if (string.Compare (key' "cpil"' true) == 0) {  	IsPartOfCompilation = (data [0] == 1);  } else if (string.Compare (key' "tmpo"' true) == 0) {  	BPM = data [1] + (data [0] << 8);  } else {  	// TODO: Save unknown keys  	Console.WriteLine (key);  }  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ParseTag,The following statement contains a magic number: if (string.Compare (key' "disk"' true) == 0) {  	Disc = data [3];  	TotalDiscs = data [5];  } else if (string.Compare (key' "wrt"' true) == 0) {  	Composer = Encoding.UTF8.GetString (data' 0' size);  } else if (string.Compare (key' "cpil"' true) == 0) {  	IsPartOfCompilation = (data [0] == 1);  } else if (string.Compare (key' "tmpo"' true) == 0) {  	BPM = data [1] + (data [0] << 8);  } else {  	// TODO: Save unknown keys  	Console.WriteLine (key);  }  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ParseTag,The following statement contains a magic number: Disc = data [3];  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ParseTag,The following statement contains a magic number: TotalDiscs = data [5];  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ParseTag,The following statement contains a magic number: if (string.Compare (key' "wrt"' true) == 0) {  	Composer = Encoding.UTF8.GetString (data' 0' size);  } else if (string.Compare (key' "cpil"' true) == 0) {  	IsPartOfCompilation = (data [0] == 1);  } else if (string.Compare (key' "tmpo"' true) == 0) {  	BPM = data [1] + (data [0] << 8);  } else {  	// TODO: Save unknown keys  	Console.WriteLine (key);  }  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ParseTag,The following statement contains a magic number: if (string.Compare (key' "cpil"' true) == 0) {  	IsPartOfCompilation = (data [0] == 1);  } else if (string.Compare (key' "tmpo"' true) == 0) {  	BPM = data [1] + (data [0] << 8);  } else {  	// TODO: Save unknown keys  	Console.WriteLine (key);  }  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ParseTag,The following statement contains a magic number: if (string.Compare (key' "tmpo"' true) == 0) {  	BPM = data [1] + (data [0] << 8);  } else {  	// TODO: Save unknown keys  	Console.WriteLine (key);  }  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ParseTag,The following statement contains a magic number: BPM = data [1] + (data [0] << 8);  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ReadInt32,The following statement contains a magic number: n = (data [offset] & 0xff) << 24;  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ReadInt32,The following statement contains a magic number: n += (data [offset + 1] & 0xff) << 16;  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ReadInt32,The following statement contains a magic number: n += (data [offset + 2] & 0xff) << 8;  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ReadInt32,The following statement contains a magic number: n += (data [offset + 2] & 0xff) << 8;  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ReadInt32,The following statement contains a magic number: n += (data [offset + 3] & 0xff);  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ParseStsdAtom,The following statement contains a magic number: for (int i = 0; i < num; i++) {  	int size = ReadInt32 (atomdata' stsdOff);  	stsdOff += 4;  	Buffer.BlockCopy (atomdata' stsdOff' data_format' 0' 4);  	stsdOff += 12;  	byte[] data = new byte[size - 4 - 12];  	Buffer.BlockCopy (atomdata' stsdOff' data' 0' (size - 4 - 12));  	stsdOff += (size - 4 - 12);  	Buffer.BlockCopy (data' 4' encoder_vendor' 0' 4);  	if (encoder_vendor [0] == 0) {  		Frequency = ((data [16] & 0xff) << 8) + (data [17] & 0xff);  		Channels = (data [8] << 8) + data [9];  		if (ByteUtils.Compare (data_format' Encoding.ASCII.GetBytes ("mp4a"))) {  			Codec = "AAC";  		} else {  			Codec = Encoding.UTF8.GetString (data_format);  		}  	}  }  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ParseStsdAtom,The following statement contains a magic number: for (int i = 0; i < num; i++) {  	int size = ReadInt32 (atomdata' stsdOff);  	stsdOff += 4;  	Buffer.BlockCopy (atomdata' stsdOff' data_format' 0' 4);  	stsdOff += 12;  	byte[] data = new byte[size - 4 - 12];  	Buffer.BlockCopy (atomdata' stsdOff' data' 0' (size - 4 - 12));  	stsdOff += (size - 4 - 12);  	Buffer.BlockCopy (data' 4' encoder_vendor' 0' 4);  	if (encoder_vendor [0] == 0) {  		Frequency = ((data [16] & 0xff) << 8) + (data [17] & 0xff);  		Channels = (data [8] << 8) + data [9];  		if (ByteUtils.Compare (data_format' Encoding.ASCII.GetBytes ("mp4a"))) {  			Codec = "AAC";  		} else {  			Codec = Encoding.UTF8.GetString (data_format);  		}  	}  }  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ParseStsdAtom,The following statement contains a magic number: for (int i = 0; i < num; i++) {  	int size = ReadInt32 (atomdata' stsdOff);  	stsdOff += 4;  	Buffer.BlockCopy (atomdata' stsdOff' data_format' 0' 4);  	stsdOff += 12;  	byte[] data = new byte[size - 4 - 12];  	Buffer.BlockCopy (atomdata' stsdOff' data' 0' (size - 4 - 12));  	stsdOff += (size - 4 - 12);  	Buffer.BlockCopy (data' 4' encoder_vendor' 0' 4);  	if (encoder_vendor [0] == 0) {  		Frequency = ((data [16] & 0xff) << 8) + (data [17] & 0xff);  		Channels = (data [8] << 8) + data [9];  		if (ByteUtils.Compare (data_format' Encoding.ASCII.GetBytes ("mp4a"))) {  			Codec = "AAC";  		} else {  			Codec = Encoding.UTF8.GetString (data_format);  		}  	}  }  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ParseStsdAtom,The following statement contains a magic number: for (int i = 0; i < num; i++) {  	int size = ReadInt32 (atomdata' stsdOff);  	stsdOff += 4;  	Buffer.BlockCopy (atomdata' stsdOff' data_format' 0' 4);  	stsdOff += 12;  	byte[] data = new byte[size - 4 - 12];  	Buffer.BlockCopy (atomdata' stsdOff' data' 0' (size - 4 - 12));  	stsdOff += (size - 4 - 12);  	Buffer.BlockCopy (data' 4' encoder_vendor' 0' 4);  	if (encoder_vendor [0] == 0) {  		Frequency = ((data [16] & 0xff) << 8) + (data [17] & 0xff);  		Channels = (data [8] << 8) + data [9];  		if (ByteUtils.Compare (data_format' Encoding.ASCII.GetBytes ("mp4a"))) {  			Codec = "AAC";  		} else {  			Codec = Encoding.UTF8.GetString (data_format);  		}  	}  }  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ParseStsdAtom,The following statement contains a magic number: for (int i = 0; i < num; i++) {  	int size = ReadInt32 (atomdata' stsdOff);  	stsdOff += 4;  	Buffer.BlockCopy (atomdata' stsdOff' data_format' 0' 4);  	stsdOff += 12;  	byte[] data = new byte[size - 4 - 12];  	Buffer.BlockCopy (atomdata' stsdOff' data' 0' (size - 4 - 12));  	stsdOff += (size - 4 - 12);  	Buffer.BlockCopy (data' 4' encoder_vendor' 0' 4);  	if (encoder_vendor [0] == 0) {  		Frequency = ((data [16] & 0xff) << 8) + (data [17] & 0xff);  		Channels = (data [8] << 8) + data [9];  		if (ByteUtils.Compare (data_format' Encoding.ASCII.GetBytes ("mp4a"))) {  			Codec = "AAC";  		} else {  			Codec = Encoding.UTF8.GetString (data_format);  		}  	}  }  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ParseStsdAtom,The following statement contains a magic number: for (int i = 0; i < num; i++) {  	int size = ReadInt32 (atomdata' stsdOff);  	stsdOff += 4;  	Buffer.BlockCopy (atomdata' stsdOff' data_format' 0' 4);  	stsdOff += 12;  	byte[] data = new byte[size - 4 - 12];  	Buffer.BlockCopy (atomdata' stsdOff' data' 0' (size - 4 - 12));  	stsdOff += (size - 4 - 12);  	Buffer.BlockCopy (data' 4' encoder_vendor' 0' 4);  	if (encoder_vendor [0] == 0) {  		Frequency = ((data [16] & 0xff) << 8) + (data [17] & 0xff);  		Channels = (data [8] << 8) + data [9];  		if (ByteUtils.Compare (data_format' Encoding.ASCII.GetBytes ("mp4a"))) {  			Codec = "AAC";  		} else {  			Codec = Encoding.UTF8.GetString (data_format);  		}  	}  }  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ParseStsdAtom,The following statement contains a magic number: for (int i = 0; i < num; i++) {  	int size = ReadInt32 (atomdata' stsdOff);  	stsdOff += 4;  	Buffer.BlockCopy (atomdata' stsdOff' data_format' 0' 4);  	stsdOff += 12;  	byte[] data = new byte[size - 4 - 12];  	Buffer.BlockCopy (atomdata' stsdOff' data' 0' (size - 4 - 12));  	stsdOff += (size - 4 - 12);  	Buffer.BlockCopy (data' 4' encoder_vendor' 0' 4);  	if (encoder_vendor [0] == 0) {  		Frequency = ((data [16] & 0xff) << 8) + (data [17] & 0xff);  		Channels = (data [8] << 8) + data [9];  		if (ByteUtils.Compare (data_format' Encoding.ASCII.GetBytes ("mp4a"))) {  			Codec = "AAC";  		} else {  			Codec = Encoding.UTF8.GetString (data_format);  		}  	}  }  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ParseStsdAtom,The following statement contains a magic number: for (int i = 0; i < num; i++) {  	int size = ReadInt32 (atomdata' stsdOff);  	stsdOff += 4;  	Buffer.BlockCopy (atomdata' stsdOff' data_format' 0' 4);  	stsdOff += 12;  	byte[] data = new byte[size - 4 - 12];  	Buffer.BlockCopy (atomdata' stsdOff' data' 0' (size - 4 - 12));  	stsdOff += (size - 4 - 12);  	Buffer.BlockCopy (data' 4' encoder_vendor' 0' 4);  	if (encoder_vendor [0] == 0) {  		Frequency = ((data [16] & 0xff) << 8) + (data [17] & 0xff);  		Channels = (data [8] << 8) + data [9];  		if (ByteUtils.Compare (data_format' Encoding.ASCII.GetBytes ("mp4a"))) {  			Codec = "AAC";  		} else {  			Codec = Encoding.UTF8.GetString (data_format);  		}  	}  }  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ParseStsdAtom,The following statement contains a magic number: for (int i = 0; i < num; i++) {  	int size = ReadInt32 (atomdata' stsdOff);  	stsdOff += 4;  	Buffer.BlockCopy (atomdata' stsdOff' data_format' 0' 4);  	stsdOff += 12;  	byte[] data = new byte[size - 4 - 12];  	Buffer.BlockCopy (atomdata' stsdOff' data' 0' (size - 4 - 12));  	stsdOff += (size - 4 - 12);  	Buffer.BlockCopy (data' 4' encoder_vendor' 0' 4);  	if (encoder_vendor [0] == 0) {  		Frequency = ((data [16] & 0xff) << 8) + (data [17] & 0xff);  		Channels = (data [8] << 8) + data [9];  		if (ByteUtils.Compare (data_format' Encoding.ASCII.GetBytes ("mp4a"))) {  			Codec = "AAC";  		} else {  			Codec = Encoding.UTF8.GetString (data_format);  		}  	}  }  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ParseStsdAtom,The following statement contains a magic number: for (int i = 0; i < num; i++) {  	int size = ReadInt32 (atomdata' stsdOff);  	stsdOff += 4;  	Buffer.BlockCopy (atomdata' stsdOff' data_format' 0' 4);  	stsdOff += 12;  	byte[] data = new byte[size - 4 - 12];  	Buffer.BlockCopy (atomdata' stsdOff' data' 0' (size - 4 - 12));  	stsdOff += (size - 4 - 12);  	Buffer.BlockCopy (data' 4' encoder_vendor' 0' 4);  	if (encoder_vendor [0] == 0) {  		Frequency = ((data [16] & 0xff) << 8) + (data [17] & 0xff);  		Channels = (data [8] << 8) + data [9];  		if (ByteUtils.Compare (data_format' Encoding.ASCII.GetBytes ("mp4a"))) {  			Codec = "AAC";  		} else {  			Codec = Encoding.UTF8.GetString (data_format);  		}  	}  }  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ParseStsdAtom,The following statement contains a magic number: for (int i = 0; i < num; i++) {  	int size = ReadInt32 (atomdata' stsdOff);  	stsdOff += 4;  	Buffer.BlockCopy (atomdata' stsdOff' data_format' 0' 4);  	stsdOff += 12;  	byte[] data = new byte[size - 4 - 12];  	Buffer.BlockCopy (atomdata' stsdOff' data' 0' (size - 4 - 12));  	stsdOff += (size - 4 - 12);  	Buffer.BlockCopy (data' 4' encoder_vendor' 0' 4);  	if (encoder_vendor [0] == 0) {  		Frequency = ((data [16] & 0xff) << 8) + (data [17] & 0xff);  		Channels = (data [8] << 8) + data [9];  		if (ByteUtils.Compare (data_format' Encoding.ASCII.GetBytes ("mp4a"))) {  			Codec = "AAC";  		} else {  			Codec = Encoding.UTF8.GetString (data_format);  		}  	}  }  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ParseStsdAtom,The following statement contains a magic number: for (int i = 0; i < num; i++) {  	int size = ReadInt32 (atomdata' stsdOff);  	stsdOff += 4;  	Buffer.BlockCopy (atomdata' stsdOff' data_format' 0' 4);  	stsdOff += 12;  	byte[] data = new byte[size - 4 - 12];  	Buffer.BlockCopy (atomdata' stsdOff' data' 0' (size - 4 - 12));  	stsdOff += (size - 4 - 12);  	Buffer.BlockCopy (data' 4' encoder_vendor' 0' 4);  	if (encoder_vendor [0] == 0) {  		Frequency = ((data [16] & 0xff) << 8) + (data [17] & 0xff);  		Channels = (data [8] << 8) + data [9];  		if (ByteUtils.Compare (data_format' Encoding.ASCII.GetBytes ("mp4a"))) {  			Codec = "AAC";  		} else {  			Codec = Encoding.UTF8.GetString (data_format);  		}  	}  }  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ParseStsdAtom,The following statement contains a magic number: for (int i = 0; i < num; i++) {  	int size = ReadInt32 (atomdata' stsdOff);  	stsdOff += 4;  	Buffer.BlockCopy (atomdata' stsdOff' data_format' 0' 4);  	stsdOff += 12;  	byte[] data = new byte[size - 4 - 12];  	Buffer.BlockCopy (atomdata' stsdOff' data' 0' (size - 4 - 12));  	stsdOff += (size - 4 - 12);  	Buffer.BlockCopy (data' 4' encoder_vendor' 0' 4);  	if (encoder_vendor [0] == 0) {  		Frequency = ((data [16] & 0xff) << 8) + (data [17] & 0xff);  		Channels = (data [8] << 8) + data [9];  		if (ByteUtils.Compare (data_format' Encoding.ASCII.GetBytes ("mp4a"))) {  			Codec = "AAC";  		} else {  			Codec = Encoding.UTF8.GetString (data_format);  		}  	}  }  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ParseStsdAtom,The following statement contains a magic number: for (int i = 0; i < num; i++) {  	int size = ReadInt32 (atomdata' stsdOff);  	stsdOff += 4;  	Buffer.BlockCopy (atomdata' stsdOff' data_format' 0' 4);  	stsdOff += 12;  	byte[] data = new byte[size - 4 - 12];  	Buffer.BlockCopy (atomdata' stsdOff' data' 0' (size - 4 - 12));  	stsdOff += (size - 4 - 12);  	Buffer.BlockCopy (data' 4' encoder_vendor' 0' 4);  	if (encoder_vendor [0] == 0) {  		Frequency = ((data [16] & 0xff) << 8) + (data [17] & 0xff);  		Channels = (data [8] << 8) + data [9];  		if (ByteUtils.Compare (data_format' Encoding.ASCII.GetBytes ("mp4a"))) {  			Codec = "AAC";  		} else {  			Codec = Encoding.UTF8.GetString (data_format);  		}  	}  }  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ParseStsdAtom,The following statement contains a magic number: for (int i = 0; i < num; i++) {  	int size = ReadInt32 (atomdata' stsdOff);  	stsdOff += 4;  	Buffer.BlockCopy (atomdata' stsdOff' data_format' 0' 4);  	stsdOff += 12;  	byte[] data = new byte[size - 4 - 12];  	Buffer.BlockCopy (atomdata' stsdOff' data' 0' (size - 4 - 12));  	stsdOff += (size - 4 - 12);  	Buffer.BlockCopy (data' 4' encoder_vendor' 0' 4);  	if (encoder_vendor [0] == 0) {  		Frequency = ((data [16] & 0xff) << 8) + (data [17] & 0xff);  		Channels = (data [8] << 8) + data [9];  		if (ByteUtils.Compare (data_format' Encoding.ASCII.GetBytes ("mp4a"))) {  			Codec = "AAC";  		} else {  			Codec = Encoding.UTF8.GetString (data_format);  		}  	}  }  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ParseStsdAtom,The following statement contains a magic number: for (int i = 0; i < num; i++) {  	int size = ReadInt32 (atomdata' stsdOff);  	stsdOff += 4;  	Buffer.BlockCopy (atomdata' stsdOff' data_format' 0' 4);  	stsdOff += 12;  	byte[] data = new byte[size - 4 - 12];  	Buffer.BlockCopy (atomdata' stsdOff' data' 0' (size - 4 - 12));  	stsdOff += (size - 4 - 12);  	Buffer.BlockCopy (data' 4' encoder_vendor' 0' 4);  	if (encoder_vendor [0] == 0) {  		Frequency = ((data [16] & 0xff) << 8) + (data [17] & 0xff);  		Channels = (data [8] << 8) + data [9];  		if (ByteUtils.Compare (data_format' Encoding.ASCII.GetBytes ("mp4a"))) {  			Codec = "AAC";  		} else {  			Codec = Encoding.UTF8.GetString (data_format);  		}  	}  }  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ParseStsdAtom,The following statement contains a magic number: for (int i = 0; i < num; i++) {  	int size = ReadInt32 (atomdata' stsdOff);  	stsdOff += 4;  	Buffer.BlockCopy (atomdata' stsdOff' data_format' 0' 4);  	stsdOff += 12;  	byte[] data = new byte[size - 4 - 12];  	Buffer.BlockCopy (atomdata' stsdOff' data' 0' (size - 4 - 12));  	stsdOff += (size - 4 - 12);  	Buffer.BlockCopy (data' 4' encoder_vendor' 0' 4);  	if (encoder_vendor [0] == 0) {  		Frequency = ((data [16] & 0xff) << 8) + (data [17] & 0xff);  		Channels = (data [8] << 8) + data [9];  		if (ByteUtils.Compare (data_format' Encoding.ASCII.GetBytes ("mp4a"))) {  			Codec = "AAC";  		} else {  			Codec = Encoding.UTF8.GetString (data_format);  		}  	}  }  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ParseStsdAtom,The following statement contains a magic number: stsdOff += 4;  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ParseStsdAtom,The following statement contains a magic number: Buffer.BlockCopy (atomdata' stsdOff' data_format' 0' 4);  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ParseStsdAtom,The following statement contains a magic number: stsdOff += 12;  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ParseStsdAtom,The following statement contains a magic number: Buffer.BlockCopy (atomdata' stsdOff' data' 0' (size - 4 - 12));  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ParseStsdAtom,The following statement contains a magic number: Buffer.BlockCopy (atomdata' stsdOff' data' 0' (size - 4 - 12));  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ParseStsdAtom,The following statement contains a magic number: stsdOff += (size - 4 - 12);  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ParseStsdAtom,The following statement contains a magic number: stsdOff += (size - 4 - 12);  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ParseStsdAtom,The following statement contains a magic number: Buffer.BlockCopy (data' 4' encoder_vendor' 0' 4);  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ParseStsdAtom,The following statement contains a magic number: Buffer.BlockCopy (data' 4' encoder_vendor' 0' 4);  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ParseStsdAtom,The following statement contains a magic number: if (encoder_vendor [0] == 0) {  	Frequency = ((data [16] & 0xff) << 8) + (data [17] & 0xff);  	Channels = (data [8] << 8) + data [9];  	if (ByteUtils.Compare (data_format' Encoding.ASCII.GetBytes ("mp4a"))) {  		Codec = "AAC";  	} else {  		Codec = Encoding.UTF8.GetString (data_format);  	}  }  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ParseStsdAtom,The following statement contains a magic number: if (encoder_vendor [0] == 0) {  	Frequency = ((data [16] & 0xff) << 8) + (data [17] & 0xff);  	Channels = (data [8] << 8) + data [9];  	if (ByteUtils.Compare (data_format' Encoding.ASCII.GetBytes ("mp4a"))) {  		Codec = "AAC";  	} else {  		Codec = Encoding.UTF8.GetString (data_format);  	}  }  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ParseStsdAtom,The following statement contains a magic number: if (encoder_vendor [0] == 0) {  	Frequency = ((data [16] & 0xff) << 8) + (data [17] & 0xff);  	Channels = (data [8] << 8) + data [9];  	if (ByteUtils.Compare (data_format' Encoding.ASCII.GetBytes ("mp4a"))) {  		Codec = "AAC";  	} else {  		Codec = Encoding.UTF8.GetString (data_format);  	}  }  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ParseStsdAtom,The following statement contains a magic number: if (encoder_vendor [0] == 0) {  	Frequency = ((data [16] & 0xff) << 8) + (data [17] & 0xff);  	Channels = (data [8] << 8) + data [9];  	if (ByteUtils.Compare (data_format' Encoding.ASCII.GetBytes ("mp4a"))) {  		Codec = "AAC";  	} else {  		Codec = Encoding.UTF8.GetString (data_format);  	}  }  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ParseStsdAtom,The following statement contains a magic number: if (encoder_vendor [0] == 0) {  	Frequency = ((data [16] & 0xff) << 8) + (data [17] & 0xff);  	Channels = (data [8] << 8) + data [9];  	if (ByteUtils.Compare (data_format' Encoding.ASCII.GetBytes ("mp4a"))) {  		Codec = "AAC";  	} else {  		Codec = Encoding.UTF8.GetString (data_format);  	}  }  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ParseStsdAtom,The following statement contains a magic number: if (encoder_vendor [0] == 0) {  	Frequency = ((data [16] & 0xff) << 8) + (data [17] & 0xff);  	Channels = (data [8] << 8) + data [9];  	if (ByteUtils.Compare (data_format' Encoding.ASCII.GetBytes ("mp4a"))) {  		Codec = "AAC";  	} else {  		Codec = Encoding.UTF8.GetString (data_format);  	}  }  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ParseStsdAtom,The following statement contains a magic number: Frequency = ((data [16] & 0xff) << 8) + (data [17] & 0xff);  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ParseStsdAtom,The following statement contains a magic number: Frequency = ((data [16] & 0xff) << 8) + (data [17] & 0xff);  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ParseStsdAtom,The following statement contains a magic number: Frequency = ((data [16] & 0xff) << 8) + (data [17] & 0xff);  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ParseStsdAtom,The following statement contains a magic number: Channels = (data [8] << 8) + data [9];  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ParseStsdAtom,The following statement contains a magic number: Channels = (data [8] << 8) + data [9];  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ParseStsdAtom,The following statement contains a magic number: Channels = (data [8] << 8) + data [9];  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ParseAtom,The following statement contains a magic number: while (offset < stopAt) {  	stream.Seek (offset' SeekOrigin.Begin);  	int atomsize = stream.ReadInt32 ();  	string atomname = ByteUtils.ISO88591.GetString (stream.Read (4));  	if ((offset + atomsize) > end) {  		throw new InvalidDataException (string.Format ("atom at {0} claims {1} bytes' end = {2}"' offset' atomsize' end));  	}  	Atom atom = new Atom ();  	atom.name = atomname;  	atom.size = atomsize;  	atom.pos = stream.Position - 8;  	atom.level = level;  	_atoms.Add (atom);  	if (string.Compare (atomname' "mdat"' true) == 0) {  		_mdatsize = atomsize;  	} else if (string.Compare (atomname' "moov"' true) == 0) {  		_moovpos = stream.Position - 8;  	} else if (string.Compare (atomname' "udta"' true) == 0) {  		_udtapos = stream.Position - 8;  		_udtasize = atomsize;  	} else if (string.Compare (atomname' "free"' true) == 0) {  		// we'd like a free under a moov  		// so check for level = 1  		if (atom.level == 2) {  			// go backwards through the entries  			for (int i = _atoms.Count - 1; i > 0; i--) {  				// until we hit a level 1  				if (_atoms [i].level == 1) {  					if (string.Compare (_atoms [i].name' "moov"' true) == 0) {  						if (atomsize > _freesize) {  							// is this free bigger than others?  							_freepos = stream.Position - 8;  							_freesize = atomsize;  						} else {  							break;  						}  					}  					// if moov  				}  				// if level = 1  			}  			// for  		}  		// if level = 2  	}  	// if free  	// if it's a container atom' parse the contents of the atom  	foreach (string atomType in ATOM_TYPES) {  		if (string.Compare (atomname' atomType' true) == 0) {  			ParseAtom (stream' stream.Position' offset + atomsize' level);  			break;  		}  	}  	// meta atom contains tags and some other data  	if (string.Compare (atomname' "meta"' true) == 0) {  		// read in meta atom  		byte[] atomdata = stream.Read (atomsize - 8);  		int nextTagPosition = 0;  		for (int i = 0; i < atomdata.Length - 4; i++) {  			// ilst  			if (atomdata [i] == 'i' && atomdata [i + 1] == 'l' && atomdata [i + 2] == 's' && atomdata [i + 3] == 't') {  				nextTagPosition = i + 8;  				break;  			}  		}  		while (nextTagPosition < (atomsize - 4) && nextTagPosition > 8) {  			int size = ReadInt32 (atomdata' (nextTagPosition - 4)) - 4;  			if (size < 20) {  				Console.WriteLine (stream.Position);  				// TODO: Why is this here...  			}  			byte[] keyBytes = new byte[4];  			byte[] data = new byte[size - 20];  			Buffer.BlockCopy (atomdata' nextTagPosition' keyBytes' 0' 4);  			Buffer.BlockCopy (atomdata' nextTagPosition + 20' data' 0' size - 20);  			string key = ByteUtils.ISO88591.GetString (keyBytes);  			nextTagPosition += size + 4;  			ParseTag (key' data' size - 20);  		}  	}  	// if meta  	// mdhd has data for calculating playtime  	if (string.Compare (atomname' "mdhd"' true) == 0) {  		stream.Seek (12' SeekOrigin.Current);  		Frequency = stream.ReadInt32 ();  		Samples = stream.ReadInt32 ();  	}  	// stsd has data for sample' channels and codec  	if (string.Compare (atomname' "stsd"' true) == 0) {  		byte[] atomdata = stream.Read (atomsize - 8);  		ParseStsdAtom (atomdata);  	}  	// bump offest and continue  	if (atomsize == 0) {  		// a 0 byte atom is the end  		offset = stopAt;  	} else {  		offset += atomsize;  	}  }  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ParseAtom,The following statement contains a magic number: while (offset < stopAt) {  	stream.Seek (offset' SeekOrigin.Begin);  	int atomsize = stream.ReadInt32 ();  	string atomname = ByteUtils.ISO88591.GetString (stream.Read (4));  	if ((offset + atomsize) > end) {  		throw new InvalidDataException (string.Format ("atom at {0} claims {1} bytes' end = {2}"' offset' atomsize' end));  	}  	Atom atom = new Atom ();  	atom.name = atomname;  	atom.size = atomsize;  	atom.pos = stream.Position - 8;  	atom.level = level;  	_atoms.Add (atom);  	if (string.Compare (atomname' "mdat"' true) == 0) {  		_mdatsize = atomsize;  	} else if (string.Compare (atomname' "moov"' true) == 0) {  		_moovpos = stream.Position - 8;  	} else if (string.Compare (atomname' "udta"' true) == 0) {  		_udtapos = stream.Position - 8;  		_udtasize = atomsize;  	} else if (string.Compare (atomname' "free"' true) == 0) {  		// we'd like a free under a moov  		// so check for level = 1  		if (atom.level == 2) {  			// go backwards through the entries  			for (int i = _atoms.Count - 1; i > 0; i--) {  				// until we hit a level 1  				if (_atoms [i].level == 1) {  					if (string.Compare (_atoms [i].name' "moov"' true) == 0) {  						if (atomsize > _freesize) {  							// is this free bigger than others?  							_freepos = stream.Position - 8;  							_freesize = atomsize;  						} else {  							break;  						}  					}  					// if moov  				}  				// if level = 1  			}  			// for  		}  		// if level = 2  	}  	// if free  	// if it's a container atom' parse the contents of the atom  	foreach (string atomType in ATOM_TYPES) {  		if (string.Compare (atomname' atomType' true) == 0) {  			ParseAtom (stream' stream.Position' offset + atomsize' level);  			break;  		}  	}  	// meta atom contains tags and some other data  	if (string.Compare (atomname' "meta"' true) == 0) {  		// read in meta atom  		byte[] atomdata = stream.Read (atomsize - 8);  		int nextTagPosition = 0;  		for (int i = 0; i < atomdata.Length - 4; i++) {  			// ilst  			if (atomdata [i] == 'i' && atomdata [i + 1] == 'l' && atomdata [i + 2] == 's' && atomdata [i + 3] == 't') {  				nextTagPosition = i + 8;  				break;  			}  		}  		while (nextTagPosition < (atomsize - 4) && nextTagPosition > 8) {  			int size = ReadInt32 (atomdata' (nextTagPosition - 4)) - 4;  			if (size < 20) {  				Console.WriteLine (stream.Position);  				// TODO: Why is this here...  			}  			byte[] keyBytes = new byte[4];  			byte[] data = new byte[size - 20];  			Buffer.BlockCopy (atomdata' nextTagPosition' keyBytes' 0' 4);  			Buffer.BlockCopy (atomdata' nextTagPosition + 20' data' 0' size - 20);  			string key = ByteUtils.ISO88591.GetString (keyBytes);  			nextTagPosition += size + 4;  			ParseTag (key' data' size - 20);  		}  	}  	// if meta  	// mdhd has data for calculating playtime  	if (string.Compare (atomname' "mdhd"' true) == 0) {  		stream.Seek (12' SeekOrigin.Current);  		Frequency = stream.ReadInt32 ();  		Samples = stream.ReadInt32 ();  	}  	// stsd has data for sample' channels and codec  	if (string.Compare (atomname' "stsd"' true) == 0) {  		byte[] atomdata = stream.Read (atomsize - 8);  		ParseStsdAtom (atomdata);  	}  	// bump offest and continue  	if (atomsize == 0) {  		// a 0 byte atom is the end  		offset = stopAt;  	} else {  		offset += atomsize;  	}  }  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ParseAtom,The following statement contains a magic number: while (offset < stopAt) {  	stream.Seek (offset' SeekOrigin.Begin);  	int atomsize = stream.ReadInt32 ();  	string atomname = ByteUtils.ISO88591.GetString (stream.Read (4));  	if ((offset + atomsize) > end) {  		throw new InvalidDataException (string.Format ("atom at {0} claims {1} bytes' end = {2}"' offset' atomsize' end));  	}  	Atom atom = new Atom ();  	atom.name = atomname;  	atom.size = atomsize;  	atom.pos = stream.Position - 8;  	atom.level = level;  	_atoms.Add (atom);  	if (string.Compare (atomname' "mdat"' true) == 0) {  		_mdatsize = atomsize;  	} else if (string.Compare (atomname' "moov"' true) == 0) {  		_moovpos = stream.Position - 8;  	} else if (string.Compare (atomname' "udta"' true) == 0) {  		_udtapos = stream.Position - 8;  		_udtasize = atomsize;  	} else if (string.Compare (atomname' "free"' true) == 0) {  		// we'd like a free under a moov  		// so check for level = 1  		if (atom.level == 2) {  			// go backwards through the entries  			for (int i = _atoms.Count - 1; i > 0; i--) {  				// until we hit a level 1  				if (_atoms [i].level == 1) {  					if (string.Compare (_atoms [i].name' "moov"' true) == 0) {  						if (atomsize > _freesize) {  							// is this free bigger than others?  							_freepos = stream.Position - 8;  							_freesize = atomsize;  						} else {  							break;  						}  					}  					// if moov  				}  				// if level = 1  			}  			// for  		}  		// if level = 2  	}  	// if free  	// if it's a container atom' parse the contents of the atom  	foreach (string atomType in ATOM_TYPES) {  		if (string.Compare (atomname' atomType' true) == 0) {  			ParseAtom (stream' stream.Position' offset + atomsize' level);  			break;  		}  	}  	// meta atom contains tags and some other data  	if (string.Compare (atomname' "meta"' true) == 0) {  		// read in meta atom  		byte[] atomdata = stream.Read (atomsize - 8);  		int nextTagPosition = 0;  		for (int i = 0; i < atomdata.Length - 4; i++) {  			// ilst  			if (atomdata [i] == 'i' && atomdata [i + 1] == 'l' && atomdata [i + 2] == 's' && atomdata [i + 3] == 't') {  				nextTagPosition = i + 8;  				break;  			}  		}  		while (nextTagPosition < (atomsize - 4) && nextTagPosition > 8) {  			int size = ReadInt32 (atomdata' (nextTagPosition - 4)) - 4;  			if (size < 20) {  				Console.WriteLine (stream.Position);  				// TODO: Why is this here...  			}  			byte[] keyBytes = new byte[4];  			byte[] data = new byte[size - 20];  			Buffer.BlockCopy (atomdata' nextTagPosition' keyBytes' 0' 4);  			Buffer.BlockCopy (atomdata' nextTagPosition + 20' data' 0' size - 20);  			string key = ByteUtils.ISO88591.GetString (keyBytes);  			nextTagPosition += size + 4;  			ParseTag (key' data' size - 20);  		}  	}  	// if meta  	// mdhd has data for calculating playtime  	if (string.Compare (atomname' "mdhd"' true) == 0) {  		stream.Seek (12' SeekOrigin.Current);  		Frequency = stream.ReadInt32 ();  		Samples = stream.ReadInt32 ();  	}  	// stsd has data for sample' channels and codec  	if (string.Compare (atomname' "stsd"' true) == 0) {  		byte[] atomdata = stream.Read (atomsize - 8);  		ParseStsdAtom (atomdata);  	}  	// bump offest and continue  	if (atomsize == 0) {  		// a 0 byte atom is the end  		offset = stopAt;  	} else {  		offset += atomsize;  	}  }  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ParseAtom,The following statement contains a magic number: while (offset < stopAt) {  	stream.Seek (offset' SeekOrigin.Begin);  	int atomsize = stream.ReadInt32 ();  	string atomname = ByteUtils.ISO88591.GetString (stream.Read (4));  	if ((offset + atomsize) > end) {  		throw new InvalidDataException (string.Format ("atom at {0} claims {1} bytes' end = {2}"' offset' atomsize' end));  	}  	Atom atom = new Atom ();  	atom.name = atomname;  	atom.size = atomsize;  	atom.pos = stream.Position - 8;  	atom.level = level;  	_atoms.Add (atom);  	if (string.Compare (atomname' "mdat"' true) == 0) {  		_mdatsize = atomsize;  	} else if (string.Compare (atomname' "moov"' true) == 0) {  		_moovpos = stream.Position - 8;  	} else if (string.Compare (atomname' "udta"' true) == 0) {  		_udtapos = stream.Position - 8;  		_udtasize = atomsize;  	} else if (string.Compare (atomname' "free"' true) == 0) {  		// we'd like a free under a moov  		// so check for level = 1  		if (atom.level == 2) {  			// go backwards through the entries  			for (int i = _atoms.Count - 1; i > 0; i--) {  				// until we hit a level 1  				if (_atoms [i].level == 1) {  					if (string.Compare (_atoms [i].name' "moov"' true) == 0) {  						if (atomsize > _freesize) {  							// is this free bigger than others?  							_freepos = stream.Position - 8;  							_freesize = atomsize;  						} else {  							break;  						}  					}  					// if moov  				}  				// if level = 1  			}  			// for  		}  		// if level = 2  	}  	// if free  	// if it's a container atom' parse the contents of the atom  	foreach (string atomType in ATOM_TYPES) {  		if (string.Compare (atomname' atomType' true) == 0) {  			ParseAtom (stream' stream.Position' offset + atomsize' level);  			break;  		}  	}  	// meta atom contains tags and some other data  	if (string.Compare (atomname' "meta"' true) == 0) {  		// read in meta atom  		byte[] atomdata = stream.Read (atomsize - 8);  		int nextTagPosition = 0;  		for (int i = 0; i < atomdata.Length - 4; i++) {  			// ilst  			if (atomdata [i] == 'i' && atomdata [i + 1] == 'l' && atomdata [i + 2] == 's' && atomdata [i + 3] == 't') {  				nextTagPosition = i + 8;  				break;  			}  		}  		while (nextTagPosition < (atomsize - 4) && nextTagPosition > 8) {  			int size = ReadInt32 (atomdata' (nextTagPosition - 4)) - 4;  			if (size < 20) {  				Console.WriteLine (stream.Position);  				// TODO: Why is this here...  			}  			byte[] keyBytes = new byte[4];  			byte[] data = new byte[size - 20];  			Buffer.BlockCopy (atomdata' nextTagPosition' keyBytes' 0' 4);  			Buffer.BlockCopy (atomdata' nextTagPosition + 20' data' 0' size - 20);  			string key = ByteUtils.ISO88591.GetString (keyBytes);  			nextTagPosition += size + 4;  			ParseTag (key' data' size - 20);  		}  	}  	// if meta  	// mdhd has data for calculating playtime  	if (string.Compare (atomname' "mdhd"' true) == 0) {  		stream.Seek (12' SeekOrigin.Current);  		Frequency = stream.ReadInt32 ();  		Samples = stream.ReadInt32 ();  	}  	// stsd has data for sample' channels and codec  	if (string.Compare (atomname' "stsd"' true) == 0) {  		byte[] atomdata = stream.Read (atomsize - 8);  		ParseStsdAtom (atomdata);  	}  	// bump offest and continue  	if (atomsize == 0) {  		// a 0 byte atom is the end  		offset = stopAt;  	} else {  		offset += atomsize;  	}  }  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ParseAtom,The following statement contains a magic number: while (offset < stopAt) {  	stream.Seek (offset' SeekOrigin.Begin);  	int atomsize = stream.ReadInt32 ();  	string atomname = ByteUtils.ISO88591.GetString (stream.Read (4));  	if ((offset + atomsize) > end) {  		throw new InvalidDataException (string.Format ("atom at {0} claims {1} bytes' end = {2}"' offset' atomsize' end));  	}  	Atom atom = new Atom ();  	atom.name = atomname;  	atom.size = atomsize;  	atom.pos = stream.Position - 8;  	atom.level = level;  	_atoms.Add (atom);  	if (string.Compare (atomname' "mdat"' true) == 0) {  		_mdatsize = atomsize;  	} else if (string.Compare (atomname' "moov"' true) == 0) {  		_moovpos = stream.Position - 8;  	} else if (string.Compare (atomname' "udta"' true) == 0) {  		_udtapos = stream.Position - 8;  		_udtasize = atomsize;  	} else if (string.Compare (atomname' "free"' true) == 0) {  		// we'd like a free under a moov  		// so check for level = 1  		if (atom.level == 2) {  			// go backwards through the entries  			for (int i = _atoms.Count - 1; i > 0; i--) {  				// until we hit a level 1  				if (_atoms [i].level == 1) {  					if (string.Compare (_atoms [i].name' "moov"' true) == 0) {  						if (atomsize > _freesize) {  							// is this free bigger than others?  							_freepos = stream.Position - 8;  							_freesize = atomsize;  						} else {  							break;  						}  					}  					// if moov  				}  				// if level = 1  			}  			// for  		}  		// if level = 2  	}  	// if free  	// if it's a container atom' parse the contents of the atom  	foreach (string atomType in ATOM_TYPES) {  		if (string.Compare (atomname' atomType' true) == 0) {  			ParseAtom (stream' stream.Position' offset + atomsize' level);  			break;  		}  	}  	// meta atom contains tags and some other data  	if (string.Compare (atomname' "meta"' true) == 0) {  		// read in meta atom  		byte[] atomdata = stream.Read (atomsize - 8);  		int nextTagPosition = 0;  		for (int i = 0; i < atomdata.Length - 4; i++) {  			// ilst  			if (atomdata [i] == 'i' && atomdata [i + 1] == 'l' && atomdata [i + 2] == 's' && atomdata [i + 3] == 't') {  				nextTagPosition = i + 8;  				break;  			}  		}  		while (nextTagPosition < (atomsize - 4) && nextTagPosition > 8) {  			int size = ReadInt32 (atomdata' (nextTagPosition - 4)) - 4;  			if (size < 20) {  				Console.WriteLine (stream.Position);  				// TODO: Why is this here...  			}  			byte[] keyBytes = new byte[4];  			byte[] data = new byte[size - 20];  			Buffer.BlockCopy (atomdata' nextTagPosition' keyBytes' 0' 4);  			Buffer.BlockCopy (atomdata' nextTagPosition + 20' data' 0' size - 20);  			string key = ByteUtils.ISO88591.GetString (keyBytes);  			nextTagPosition += size + 4;  			ParseTag (key' data' size - 20);  		}  	}  	// if meta  	// mdhd has data for calculating playtime  	if (string.Compare (atomname' "mdhd"' true) == 0) {  		stream.Seek (12' SeekOrigin.Current);  		Frequency = stream.ReadInt32 ();  		Samples = stream.ReadInt32 ();  	}  	// stsd has data for sample' channels and codec  	if (string.Compare (atomname' "stsd"' true) == 0) {  		byte[] atomdata = stream.Read (atomsize - 8);  		ParseStsdAtom (atomdata);  	}  	// bump offest and continue  	if (atomsize == 0) {  		// a 0 byte atom is the end  		offset = stopAt;  	} else {  		offset += atomsize;  	}  }  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ParseAtom,The following statement contains a magic number: while (offset < stopAt) {  	stream.Seek (offset' SeekOrigin.Begin);  	int atomsize = stream.ReadInt32 ();  	string atomname = ByteUtils.ISO88591.GetString (stream.Read (4));  	if ((offset + atomsize) > end) {  		throw new InvalidDataException (string.Format ("atom at {0} claims {1} bytes' end = {2}"' offset' atomsize' end));  	}  	Atom atom = new Atom ();  	atom.name = atomname;  	atom.size = atomsize;  	atom.pos = stream.Position - 8;  	atom.level = level;  	_atoms.Add (atom);  	if (string.Compare (atomname' "mdat"' true) == 0) {  		_mdatsize = atomsize;  	} else if (string.Compare (atomname' "moov"' true) == 0) {  		_moovpos = stream.Position - 8;  	} else if (string.Compare (atomname' "udta"' true) == 0) {  		_udtapos = stream.Position - 8;  		_udtasize = atomsize;  	} else if (string.Compare (atomname' "free"' true) == 0) {  		// we'd like a free under a moov  		// so check for level = 1  		if (atom.level == 2) {  			// go backwards through the entries  			for (int i = _atoms.Count - 1; i > 0; i--) {  				// until we hit a level 1  				if (_atoms [i].level == 1) {  					if (string.Compare (_atoms [i].name' "moov"' true) == 0) {  						if (atomsize > _freesize) {  							// is this free bigger than others?  							_freepos = stream.Position - 8;  							_freesize = atomsize;  						} else {  							break;  						}  					}  					// if moov  				}  				// if level = 1  			}  			// for  		}  		// if level = 2  	}  	// if free  	// if it's a container atom' parse the contents of the atom  	foreach (string atomType in ATOM_TYPES) {  		if (string.Compare (atomname' atomType' true) == 0) {  			ParseAtom (stream' stream.Position' offset + atomsize' level);  			break;  		}  	}  	// meta atom contains tags and some other data  	if (string.Compare (atomname' "meta"' true) == 0) {  		// read in meta atom  		byte[] atomdata = stream.Read (atomsize - 8);  		int nextTagPosition = 0;  		for (int i = 0; i < atomdata.Length - 4; i++) {  			// ilst  			if (atomdata [i] == 'i' && atomdata [i + 1] == 'l' && atomdata [i + 2] == 's' && atomdata [i + 3] == 't') {  				nextTagPosition = i + 8;  				break;  			}  		}  		while (nextTagPosition < (atomsize - 4) && nextTagPosition > 8) {  			int size = ReadInt32 (atomdata' (nextTagPosition - 4)) - 4;  			if (size < 20) {  				Console.WriteLine (stream.Position);  				// TODO: Why is this here...  			}  			byte[] keyBytes = new byte[4];  			byte[] data = new byte[size - 20];  			Buffer.BlockCopy (atomdata' nextTagPosition' keyBytes' 0' 4);  			Buffer.BlockCopy (atomdata' nextTagPosition + 20' data' 0' size - 20);  			string key = ByteUtils.ISO88591.GetString (keyBytes);  			nextTagPosition += size + 4;  			ParseTag (key' data' size - 20);  		}  	}  	// if meta  	// mdhd has data for calculating playtime  	if (string.Compare (atomname' "mdhd"' true) == 0) {  		stream.Seek (12' SeekOrigin.Current);  		Frequency = stream.ReadInt32 ();  		Samples = stream.ReadInt32 ();  	}  	// stsd has data for sample' channels and codec  	if (string.Compare (atomname' "stsd"' true) == 0) {  		byte[] atomdata = stream.Read (atomsize - 8);  		ParseStsdAtom (atomdata);  	}  	// bump offest and continue  	if (atomsize == 0) {  		// a 0 byte atom is the end  		offset = stopAt;  	} else {  		offset += atomsize;  	}  }  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ParseAtom,The following statement contains a magic number: while (offset < stopAt) {  	stream.Seek (offset' SeekOrigin.Begin);  	int atomsize = stream.ReadInt32 ();  	string atomname = ByteUtils.ISO88591.GetString (stream.Read (4));  	if ((offset + atomsize) > end) {  		throw new InvalidDataException (string.Format ("atom at {0} claims {1} bytes' end = {2}"' offset' atomsize' end));  	}  	Atom atom = new Atom ();  	atom.name = atomname;  	atom.size = atomsize;  	atom.pos = stream.Position - 8;  	atom.level = level;  	_atoms.Add (atom);  	if (string.Compare (atomname' "mdat"' true) == 0) {  		_mdatsize = atomsize;  	} else if (string.Compare (atomname' "moov"' true) == 0) {  		_moovpos = stream.Position - 8;  	} else if (string.Compare (atomname' "udta"' true) == 0) {  		_udtapos = stream.Position - 8;  		_udtasize = atomsize;  	} else if (string.Compare (atomname' "free"' true) == 0) {  		// we'd like a free under a moov  		// so check for level = 1  		if (atom.level == 2) {  			// go backwards through the entries  			for (int i = _atoms.Count - 1; i > 0; i--) {  				// until we hit a level 1  				if (_atoms [i].level == 1) {  					if (string.Compare (_atoms [i].name' "moov"' true) == 0) {  						if (atomsize > _freesize) {  							// is this free bigger than others?  							_freepos = stream.Position - 8;  							_freesize = atomsize;  						} else {  							break;  						}  					}  					// if moov  				}  				// if level = 1  			}  			// for  		}  		// if level = 2  	}  	// if free  	// if it's a container atom' parse the contents of the atom  	foreach (string atomType in ATOM_TYPES) {  		if (string.Compare (atomname' atomType' true) == 0) {  			ParseAtom (stream' stream.Position' offset + atomsize' level);  			break;  		}  	}  	// meta atom contains tags and some other data  	if (string.Compare (atomname' "meta"' true) == 0) {  		// read in meta atom  		byte[] atomdata = stream.Read (atomsize - 8);  		int nextTagPosition = 0;  		for (int i = 0; i < atomdata.Length - 4; i++) {  			// ilst  			if (atomdata [i] == 'i' && atomdata [i + 1] == 'l' && atomdata [i + 2] == 's' && atomdata [i + 3] == 't') {  				nextTagPosition = i + 8;  				break;  			}  		}  		while (nextTagPosition < (atomsize - 4) && nextTagPosition > 8) {  			int size = ReadInt32 (atomdata' (nextTagPosition - 4)) - 4;  			if (size < 20) {  				Console.WriteLine (stream.Position);  				// TODO: Why is this here...  			}  			byte[] keyBytes = new byte[4];  			byte[] data = new byte[size - 20];  			Buffer.BlockCopy (atomdata' nextTagPosition' keyBytes' 0' 4);  			Buffer.BlockCopy (atomdata' nextTagPosition + 20' data' 0' size - 20);  			string key = ByteUtils.ISO88591.GetString (keyBytes);  			nextTagPosition += size + 4;  			ParseTag (key' data' size - 20);  		}  	}  	// if meta  	// mdhd has data for calculating playtime  	if (string.Compare (atomname' "mdhd"' true) == 0) {  		stream.Seek (12' SeekOrigin.Current);  		Frequency = stream.ReadInt32 ();  		Samples = stream.ReadInt32 ();  	}  	// stsd has data for sample' channels and codec  	if (string.Compare (atomname' "stsd"' true) == 0) {  		byte[] atomdata = stream.Read (atomsize - 8);  		ParseStsdAtom (atomdata);  	}  	// bump offest and continue  	if (atomsize == 0) {  		// a 0 byte atom is the end  		offset = stopAt;  	} else {  		offset += atomsize;  	}  }  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ParseAtom,The following statement contains a magic number: while (offset < stopAt) {  	stream.Seek (offset' SeekOrigin.Begin);  	int atomsize = stream.ReadInt32 ();  	string atomname = ByteUtils.ISO88591.GetString (stream.Read (4));  	if ((offset + atomsize) > end) {  		throw new InvalidDataException (string.Format ("atom at {0} claims {1} bytes' end = {2}"' offset' atomsize' end));  	}  	Atom atom = new Atom ();  	atom.name = atomname;  	atom.size = atomsize;  	atom.pos = stream.Position - 8;  	atom.level = level;  	_atoms.Add (atom);  	if (string.Compare (atomname' "mdat"' true) == 0) {  		_mdatsize = atomsize;  	} else if (string.Compare (atomname' "moov"' true) == 0) {  		_moovpos = stream.Position - 8;  	} else if (string.Compare (atomname' "udta"' true) == 0) {  		_udtapos = stream.Position - 8;  		_udtasize = atomsize;  	} else if (string.Compare (atomname' "free"' true) == 0) {  		// we'd like a free under a moov  		// so check for level = 1  		if (atom.level == 2) {  			// go backwards through the entries  			for (int i = _atoms.Count - 1; i > 0; i--) {  				// until we hit a level 1  				if (_atoms [i].level == 1) {  					if (string.Compare (_atoms [i].name' "moov"' true) == 0) {  						if (atomsize > _freesize) {  							// is this free bigger than others?  							_freepos = stream.Position - 8;  							_freesize = atomsize;  						} else {  							break;  						}  					}  					// if moov  				}  				// if level = 1  			}  			// for  		}  		// if level = 2  	}  	// if free  	// if it's a container atom' parse the contents of the atom  	foreach (string atomType in ATOM_TYPES) {  		if (string.Compare (atomname' atomType' true) == 0) {  			ParseAtom (stream' stream.Position' offset + atomsize' level);  			break;  		}  	}  	// meta atom contains tags and some other data  	if (string.Compare (atomname' "meta"' true) == 0) {  		// read in meta atom  		byte[] atomdata = stream.Read (atomsize - 8);  		int nextTagPosition = 0;  		for (int i = 0; i < atomdata.Length - 4; i++) {  			// ilst  			if (atomdata [i] == 'i' && atomdata [i + 1] == 'l' && atomdata [i + 2] == 's' && atomdata [i + 3] == 't') {  				nextTagPosition = i + 8;  				break;  			}  		}  		while (nextTagPosition < (atomsize - 4) && nextTagPosition > 8) {  			int size = ReadInt32 (atomdata' (nextTagPosition - 4)) - 4;  			if (size < 20) {  				Console.WriteLine (stream.Position);  				// TODO: Why is this here...  			}  			byte[] keyBytes = new byte[4];  			byte[] data = new byte[size - 20];  			Buffer.BlockCopy (atomdata' nextTagPosition' keyBytes' 0' 4);  			Buffer.BlockCopy (atomdata' nextTagPosition + 20' data' 0' size - 20);  			string key = ByteUtils.ISO88591.GetString (keyBytes);  			nextTagPosition += size + 4;  			ParseTag (key' data' size - 20);  		}  	}  	// if meta  	// mdhd has data for calculating playtime  	if (string.Compare (atomname' "mdhd"' true) == 0) {  		stream.Seek (12' SeekOrigin.Current);  		Frequency = stream.ReadInt32 ();  		Samples = stream.ReadInt32 ();  	}  	// stsd has data for sample' channels and codec  	if (string.Compare (atomname' "stsd"' true) == 0) {  		byte[] atomdata = stream.Read (atomsize - 8);  		ParseStsdAtom (atomdata);  	}  	// bump offest and continue  	if (atomsize == 0) {  		// a 0 byte atom is the end  		offset = stopAt;  	} else {  		offset += atomsize;  	}  }  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ParseAtom,The following statement contains a magic number: while (offset < stopAt) {  	stream.Seek (offset' SeekOrigin.Begin);  	int atomsize = stream.ReadInt32 ();  	string atomname = ByteUtils.ISO88591.GetString (stream.Read (4));  	if ((offset + atomsize) > end) {  		throw new InvalidDataException (string.Format ("atom at {0} claims {1} bytes' end = {2}"' offset' atomsize' end));  	}  	Atom atom = new Atom ();  	atom.name = atomname;  	atom.size = atomsize;  	atom.pos = stream.Position - 8;  	atom.level = level;  	_atoms.Add (atom);  	if (string.Compare (atomname' "mdat"' true) == 0) {  		_mdatsize = atomsize;  	} else if (string.Compare (atomname' "moov"' true) == 0) {  		_moovpos = stream.Position - 8;  	} else if (string.Compare (atomname' "udta"' true) == 0) {  		_udtapos = stream.Position - 8;  		_udtasize = atomsize;  	} else if (string.Compare (atomname' "free"' true) == 0) {  		// we'd like a free under a moov  		// so check for level = 1  		if (atom.level == 2) {  			// go backwards through the entries  			for (int i = _atoms.Count - 1; i > 0; i--) {  				// until we hit a level 1  				if (_atoms [i].level == 1) {  					if (string.Compare (_atoms [i].name' "moov"' true) == 0) {  						if (atomsize > _freesize) {  							// is this free bigger than others?  							_freepos = stream.Position - 8;  							_freesize = atomsize;  						} else {  							break;  						}  					}  					// if moov  				}  				// if level = 1  			}  			// for  		}  		// if level = 2  	}  	// if free  	// if it's a container atom' parse the contents of the atom  	foreach (string atomType in ATOM_TYPES) {  		if (string.Compare (atomname' atomType' true) == 0) {  			ParseAtom (stream' stream.Position' offset + atomsize' level);  			break;  		}  	}  	// meta atom contains tags and some other data  	if (string.Compare (atomname' "meta"' true) == 0) {  		// read in meta atom  		byte[] atomdata = stream.Read (atomsize - 8);  		int nextTagPosition = 0;  		for (int i = 0; i < atomdata.Length - 4; i++) {  			// ilst  			if (atomdata [i] == 'i' && atomdata [i + 1] == 'l' && atomdata [i + 2] == 's' && atomdata [i + 3] == 't') {  				nextTagPosition = i + 8;  				break;  			}  		}  		while (nextTagPosition < (atomsize - 4) && nextTagPosition > 8) {  			int size = ReadInt32 (atomdata' (nextTagPosition - 4)) - 4;  			if (size < 20) {  				Console.WriteLine (stream.Position);  				// TODO: Why is this here...  			}  			byte[] keyBytes = new byte[4];  			byte[] data = new byte[size - 20];  			Buffer.BlockCopy (atomdata' nextTagPosition' keyBytes' 0' 4);  			Buffer.BlockCopy (atomdata' nextTagPosition + 20' data' 0' size - 20);  			string key = ByteUtils.ISO88591.GetString (keyBytes);  			nextTagPosition += size + 4;  			ParseTag (key' data' size - 20);  		}  	}  	// if meta  	// mdhd has data for calculating playtime  	if (string.Compare (atomname' "mdhd"' true) == 0) {  		stream.Seek (12' SeekOrigin.Current);  		Frequency = stream.ReadInt32 ();  		Samples = stream.ReadInt32 ();  	}  	// stsd has data for sample' channels and codec  	if (string.Compare (atomname' "stsd"' true) == 0) {  		byte[] atomdata = stream.Read (atomsize - 8);  		ParseStsdAtom (atomdata);  	}  	// bump offest and continue  	if (atomsize == 0) {  		// a 0 byte atom is the end  		offset = stopAt;  	} else {  		offset += atomsize;  	}  }  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ParseAtom,The following statement contains a magic number: while (offset < stopAt) {  	stream.Seek (offset' SeekOrigin.Begin);  	int atomsize = stream.ReadInt32 ();  	string atomname = ByteUtils.ISO88591.GetString (stream.Read (4));  	if ((offset + atomsize) > end) {  		throw new InvalidDataException (string.Format ("atom at {0} claims {1} bytes' end = {2}"' offset' atomsize' end));  	}  	Atom atom = new Atom ();  	atom.name = atomname;  	atom.size = atomsize;  	atom.pos = stream.Position - 8;  	atom.level = level;  	_atoms.Add (atom);  	if (string.Compare (atomname' "mdat"' true) == 0) {  		_mdatsize = atomsize;  	} else if (string.Compare (atomname' "moov"' true) == 0) {  		_moovpos = stream.Position - 8;  	} else if (string.Compare (atomname' "udta"' true) == 0) {  		_udtapos = stream.Position - 8;  		_udtasize = atomsize;  	} else if (string.Compare (atomname' "free"' true) == 0) {  		// we'd like a free under a moov  		// so check for level = 1  		if (atom.level == 2) {  			// go backwards through the entries  			for (int i = _atoms.Count - 1; i > 0; i--) {  				// until we hit a level 1  				if (_atoms [i].level == 1) {  					if (string.Compare (_atoms [i].name' "moov"' true) == 0) {  						if (atomsize > _freesize) {  							// is this free bigger than others?  							_freepos = stream.Position - 8;  							_freesize = atomsize;  						} else {  							break;  						}  					}  					// if moov  				}  				// if level = 1  			}  			// for  		}  		// if level = 2  	}  	// if free  	// if it's a container atom' parse the contents of the atom  	foreach (string atomType in ATOM_TYPES) {  		if (string.Compare (atomname' atomType' true) == 0) {  			ParseAtom (stream' stream.Position' offset + atomsize' level);  			break;  		}  	}  	// meta atom contains tags and some other data  	if (string.Compare (atomname' "meta"' true) == 0) {  		// read in meta atom  		byte[] atomdata = stream.Read (atomsize - 8);  		int nextTagPosition = 0;  		for (int i = 0; i < atomdata.Length - 4; i++) {  			// ilst  			if (atomdata [i] == 'i' && atomdata [i + 1] == 'l' && atomdata [i + 2] == 's' && atomdata [i + 3] == 't') {  				nextTagPosition = i + 8;  				break;  			}  		}  		while (nextTagPosition < (atomsize - 4) && nextTagPosition > 8) {  			int size = ReadInt32 (atomdata' (nextTagPosition - 4)) - 4;  			if (size < 20) {  				Console.WriteLine (stream.Position);  				// TODO: Why is this here...  			}  			byte[] keyBytes = new byte[4];  			byte[] data = new byte[size - 20];  			Buffer.BlockCopy (atomdata' nextTagPosition' keyBytes' 0' 4);  			Buffer.BlockCopy (atomdata' nextTagPosition + 20' data' 0' size - 20);  			string key = ByteUtils.ISO88591.GetString (keyBytes);  			nextTagPosition += size + 4;  			ParseTag (key' data' size - 20);  		}  	}  	// if meta  	// mdhd has data for calculating playtime  	if (string.Compare (atomname' "mdhd"' true) == 0) {  		stream.Seek (12' SeekOrigin.Current);  		Frequency = stream.ReadInt32 ();  		Samples = stream.ReadInt32 ();  	}  	// stsd has data for sample' channels and codec  	if (string.Compare (atomname' "stsd"' true) == 0) {  		byte[] atomdata = stream.Read (atomsize - 8);  		ParseStsdAtom (atomdata);  	}  	// bump offest and continue  	if (atomsize == 0) {  		// a 0 byte atom is the end  		offset = stopAt;  	} else {  		offset += atomsize;  	}  }  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ParseAtom,The following statement contains a magic number: while (offset < stopAt) {  	stream.Seek (offset' SeekOrigin.Begin);  	int atomsize = stream.ReadInt32 ();  	string atomname = ByteUtils.ISO88591.GetString (stream.Read (4));  	if ((offset + atomsize) > end) {  		throw new InvalidDataException (string.Format ("atom at {0} claims {1} bytes' end = {2}"' offset' atomsize' end));  	}  	Atom atom = new Atom ();  	atom.name = atomname;  	atom.size = atomsize;  	atom.pos = stream.Position - 8;  	atom.level = level;  	_atoms.Add (atom);  	if (string.Compare (atomname' "mdat"' true) == 0) {  		_mdatsize = atomsize;  	} else if (string.Compare (atomname' "moov"' true) == 0) {  		_moovpos = stream.Position - 8;  	} else if (string.Compare (atomname' "udta"' true) == 0) {  		_udtapos = stream.Position - 8;  		_udtasize = atomsize;  	} else if (string.Compare (atomname' "free"' true) == 0) {  		// we'd like a free under a moov  		// so check for level = 1  		if (atom.level == 2) {  			// go backwards through the entries  			for (int i = _atoms.Count - 1; i > 0; i--) {  				// until we hit a level 1  				if (_atoms [i].level == 1) {  					if (string.Compare (_atoms [i].name' "moov"' true) == 0) {  						if (atomsize > _freesize) {  							// is this free bigger than others?  							_freepos = stream.Position - 8;  							_freesize = atomsize;  						} else {  							break;  						}  					}  					// if moov  				}  				// if level = 1  			}  			// for  		}  		// if level = 2  	}  	// if free  	// if it's a container atom' parse the contents of the atom  	foreach (string atomType in ATOM_TYPES) {  		if (string.Compare (atomname' atomType' true) == 0) {  			ParseAtom (stream' stream.Position' offset + atomsize' level);  			break;  		}  	}  	// meta atom contains tags and some other data  	if (string.Compare (atomname' "meta"' true) == 0) {  		// read in meta atom  		byte[] atomdata = stream.Read (atomsize - 8);  		int nextTagPosition = 0;  		for (int i = 0; i < atomdata.Length - 4; i++) {  			// ilst  			if (atomdata [i] == 'i' && atomdata [i + 1] == 'l' && atomdata [i + 2] == 's' && atomdata [i + 3] == 't') {  				nextTagPosition = i + 8;  				break;  			}  		}  		while (nextTagPosition < (atomsize - 4) && nextTagPosition > 8) {  			int size = ReadInt32 (atomdata' (nextTagPosition - 4)) - 4;  			if (size < 20) {  				Console.WriteLine (stream.Position);  				// TODO: Why is this here...  			}  			byte[] keyBytes = new byte[4];  			byte[] data = new byte[size - 20];  			Buffer.BlockCopy (atomdata' nextTagPosition' keyBytes' 0' 4);  			Buffer.BlockCopy (atomdata' nextTagPosition + 20' data' 0' size - 20);  			string key = ByteUtils.ISO88591.GetString (keyBytes);  			nextTagPosition += size + 4;  			ParseTag (key' data' size - 20);  		}  	}  	// if meta  	// mdhd has data for calculating playtime  	if (string.Compare (atomname' "mdhd"' true) == 0) {  		stream.Seek (12' SeekOrigin.Current);  		Frequency = stream.ReadInt32 ();  		Samples = stream.ReadInt32 ();  	}  	// stsd has data for sample' channels and codec  	if (string.Compare (atomname' "stsd"' true) == 0) {  		byte[] atomdata = stream.Read (atomsize - 8);  		ParseStsdAtom (atomdata);  	}  	// bump offest and continue  	if (atomsize == 0) {  		// a 0 byte atom is the end  		offset = stopAt;  	} else {  		offset += atomsize;  	}  }  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ParseAtom,The following statement contains a magic number: while (offset < stopAt) {  	stream.Seek (offset' SeekOrigin.Begin);  	int atomsize = stream.ReadInt32 ();  	string atomname = ByteUtils.ISO88591.GetString (stream.Read (4));  	if ((offset + atomsize) > end) {  		throw new InvalidDataException (string.Format ("atom at {0} claims {1} bytes' end = {2}"' offset' atomsize' end));  	}  	Atom atom = new Atom ();  	atom.name = atomname;  	atom.size = atomsize;  	atom.pos = stream.Position - 8;  	atom.level = level;  	_atoms.Add (atom);  	if (string.Compare (atomname' "mdat"' true) == 0) {  		_mdatsize = atomsize;  	} else if (string.Compare (atomname' "moov"' true) == 0) {  		_moovpos = stream.Position - 8;  	} else if (string.Compare (atomname' "udta"' true) == 0) {  		_udtapos = stream.Position - 8;  		_udtasize = atomsize;  	} else if (string.Compare (atomname' "free"' true) == 0) {  		// we'd like a free under a moov  		// so check for level = 1  		if (atom.level == 2) {  			// go backwards through the entries  			for (int i = _atoms.Count - 1; i > 0; i--) {  				// until we hit a level 1  				if (_atoms [i].level == 1) {  					if (string.Compare (_atoms [i].name' "moov"' true) == 0) {  						if (atomsize > _freesize) {  							// is this free bigger than others?  							_freepos = stream.Position - 8;  							_freesize = atomsize;  						} else {  							break;  						}  					}  					// if moov  				}  				// if level = 1  			}  			// for  		}  		// if level = 2  	}  	// if free  	// if it's a container atom' parse the contents of the atom  	foreach (string atomType in ATOM_TYPES) {  		if (string.Compare (atomname' atomType' true) == 0) {  			ParseAtom (stream' stream.Position' offset + atomsize' level);  			break;  		}  	}  	// meta atom contains tags and some other data  	if (string.Compare (atomname' "meta"' true) == 0) {  		// read in meta atom  		byte[] atomdata = stream.Read (atomsize - 8);  		int nextTagPosition = 0;  		for (int i = 0; i < atomdata.Length - 4; i++) {  			// ilst  			if (atomdata [i] == 'i' && atomdata [i + 1] == 'l' && atomdata [i + 2] == 's' && atomdata [i + 3] == 't') {  				nextTagPosition = i + 8;  				break;  			}  		}  		while (nextTagPosition < (atomsize - 4) && nextTagPosition > 8) {  			int size = ReadInt32 (atomdata' (nextTagPosition - 4)) - 4;  			if (size < 20) {  				Console.WriteLine (stream.Position);  				// TODO: Why is this here...  			}  			byte[] keyBytes = new byte[4];  			byte[] data = new byte[size - 20];  			Buffer.BlockCopy (atomdata' nextTagPosition' keyBytes' 0' 4);  			Buffer.BlockCopy (atomdata' nextTagPosition + 20' data' 0' size - 20);  			string key = ByteUtils.ISO88591.GetString (keyBytes);  			nextTagPosition += size + 4;  			ParseTag (key' data' size - 20);  		}  	}  	// if meta  	// mdhd has data for calculating playtime  	if (string.Compare (atomname' "mdhd"' true) == 0) {  		stream.Seek (12' SeekOrigin.Current);  		Frequency = stream.ReadInt32 ();  		Samples = stream.ReadInt32 ();  	}  	// stsd has data for sample' channels and codec  	if (string.Compare (atomname' "stsd"' true) == 0) {  		byte[] atomdata = stream.Read (atomsize - 8);  		ParseStsdAtom (atomdata);  	}  	// bump offest and continue  	if (atomsize == 0) {  		// a 0 byte atom is the end  		offset = stopAt;  	} else {  		offset += atomsize;  	}  }  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ParseAtom,The following statement contains a magic number: while (offset < stopAt) {  	stream.Seek (offset' SeekOrigin.Begin);  	int atomsize = stream.ReadInt32 ();  	string atomname = ByteUtils.ISO88591.GetString (stream.Read (4));  	if ((offset + atomsize) > end) {  		throw new InvalidDataException (string.Format ("atom at {0} claims {1} bytes' end = {2}"' offset' atomsize' end));  	}  	Atom atom = new Atom ();  	atom.name = atomname;  	atom.size = atomsize;  	atom.pos = stream.Position - 8;  	atom.level = level;  	_atoms.Add (atom);  	if (string.Compare (atomname' "mdat"' true) == 0) {  		_mdatsize = atomsize;  	} else if (string.Compare (atomname' "moov"' true) == 0) {  		_moovpos = stream.Position - 8;  	} else if (string.Compare (atomname' "udta"' true) == 0) {  		_udtapos = stream.Position - 8;  		_udtasize = atomsize;  	} else if (string.Compare (atomname' "free"' true) == 0) {  		// we'd like a free under a moov  		// so check for level = 1  		if (atom.level == 2) {  			// go backwards through the entries  			for (int i = _atoms.Count - 1; i > 0; i--) {  				// until we hit a level 1  				if (_atoms [i].level == 1) {  					if (string.Compare (_atoms [i].name' "moov"' true) == 0) {  						if (atomsize > _freesize) {  							// is this free bigger than others?  							_freepos = stream.Position - 8;  							_freesize = atomsize;  						} else {  							break;  						}  					}  					// if moov  				}  				// if level = 1  			}  			// for  		}  		// if level = 2  	}  	// if free  	// if it's a container atom' parse the contents of the atom  	foreach (string atomType in ATOM_TYPES) {  		if (string.Compare (atomname' atomType' true) == 0) {  			ParseAtom (stream' stream.Position' offset + atomsize' level);  			break;  		}  	}  	// meta atom contains tags and some other data  	if (string.Compare (atomname' "meta"' true) == 0) {  		// read in meta atom  		byte[] atomdata = stream.Read (atomsize - 8);  		int nextTagPosition = 0;  		for (int i = 0; i < atomdata.Length - 4; i++) {  			// ilst  			if (atomdata [i] == 'i' && atomdata [i + 1] == 'l' && atomdata [i + 2] == 's' && atomdata [i + 3] == 't') {  				nextTagPosition = i + 8;  				break;  			}  		}  		while (nextTagPosition < (atomsize - 4) && nextTagPosition > 8) {  			int size = ReadInt32 (atomdata' (nextTagPosition - 4)) - 4;  			if (size < 20) {  				Console.WriteLine (stream.Position);  				// TODO: Why is this here...  			}  			byte[] keyBytes = new byte[4];  			byte[] data = new byte[size - 20];  			Buffer.BlockCopy (atomdata' nextTagPosition' keyBytes' 0' 4);  			Buffer.BlockCopy (atomdata' nextTagPosition + 20' data' 0' size - 20);  			string key = ByteUtils.ISO88591.GetString (keyBytes);  			nextTagPosition += size + 4;  			ParseTag (key' data' size - 20);  		}  	}  	// if meta  	// mdhd has data for calculating playtime  	if (string.Compare (atomname' "mdhd"' true) == 0) {  		stream.Seek (12' SeekOrigin.Current);  		Frequency = stream.ReadInt32 ();  		Samples = stream.ReadInt32 ();  	}  	// stsd has data for sample' channels and codec  	if (string.Compare (atomname' "stsd"' true) == 0) {  		byte[] atomdata = stream.Read (atomsize - 8);  		ParseStsdAtom (atomdata);  	}  	// bump offest and continue  	if (atomsize == 0) {  		// a 0 byte atom is the end  		offset = stopAt;  	} else {  		offset += atomsize;  	}  }  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ParseAtom,The following statement contains a magic number: while (offset < stopAt) {  	stream.Seek (offset' SeekOrigin.Begin);  	int atomsize = stream.ReadInt32 ();  	string atomname = ByteUtils.ISO88591.GetString (stream.Read (4));  	if ((offset + atomsize) > end) {  		throw new InvalidDataException (string.Format ("atom at {0} claims {1} bytes' end = {2}"' offset' atomsize' end));  	}  	Atom atom = new Atom ();  	atom.name = atomname;  	atom.size = atomsize;  	atom.pos = stream.Position - 8;  	atom.level = level;  	_atoms.Add (atom);  	if (string.Compare (atomname' "mdat"' true) == 0) {  		_mdatsize = atomsize;  	} else if (string.Compare (atomname' "moov"' true) == 0) {  		_moovpos = stream.Position - 8;  	} else if (string.Compare (atomname' "udta"' true) == 0) {  		_udtapos = stream.Position - 8;  		_udtasize = atomsize;  	} else if (string.Compare (atomname' "free"' true) == 0) {  		// we'd like a free under a moov  		// so check for level = 1  		if (atom.level == 2) {  			// go backwards through the entries  			for (int i = _atoms.Count - 1; i > 0; i--) {  				// until we hit a level 1  				if (_atoms [i].level == 1) {  					if (string.Compare (_atoms [i].name' "moov"' true) == 0) {  						if (atomsize > _freesize) {  							// is this free bigger than others?  							_freepos = stream.Position - 8;  							_freesize = atomsize;  						} else {  							break;  						}  					}  					// if moov  				}  				// if level = 1  			}  			// for  		}  		// if level = 2  	}  	// if free  	// if it's a container atom' parse the contents of the atom  	foreach (string atomType in ATOM_TYPES) {  		if (string.Compare (atomname' atomType' true) == 0) {  			ParseAtom (stream' stream.Position' offset + atomsize' level);  			break;  		}  	}  	// meta atom contains tags and some other data  	if (string.Compare (atomname' "meta"' true) == 0) {  		// read in meta atom  		byte[] atomdata = stream.Read (atomsize - 8);  		int nextTagPosition = 0;  		for (int i = 0; i < atomdata.Length - 4; i++) {  			// ilst  			if (atomdata [i] == 'i' && atomdata [i + 1] == 'l' && atomdata [i + 2] == 's' && atomdata [i + 3] == 't') {  				nextTagPosition = i + 8;  				break;  			}  		}  		while (nextTagPosition < (atomsize - 4) && nextTagPosition > 8) {  			int size = ReadInt32 (atomdata' (nextTagPosition - 4)) - 4;  			if (size < 20) {  				Console.WriteLine (stream.Position);  				// TODO: Why is this here...  			}  			byte[] keyBytes = new byte[4];  			byte[] data = new byte[size - 20];  			Buffer.BlockCopy (atomdata' nextTagPosition' keyBytes' 0' 4);  			Buffer.BlockCopy (atomdata' nextTagPosition + 20' data' 0' size - 20);  			string key = ByteUtils.ISO88591.GetString (keyBytes);  			nextTagPosition += size + 4;  			ParseTag (key' data' size - 20);  		}  	}  	// if meta  	// mdhd has data for calculating playtime  	if (string.Compare (atomname' "mdhd"' true) == 0) {  		stream.Seek (12' SeekOrigin.Current);  		Frequency = stream.ReadInt32 ();  		Samples = stream.ReadInt32 ();  	}  	// stsd has data for sample' channels and codec  	if (string.Compare (atomname' "stsd"' true) == 0) {  		byte[] atomdata = stream.Read (atomsize - 8);  		ParseStsdAtom (atomdata);  	}  	// bump offest and continue  	if (atomsize == 0) {  		// a 0 byte atom is the end  		offset = stopAt;  	} else {  		offset += atomsize;  	}  }  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ParseAtom,The following statement contains a magic number: while (offset < stopAt) {  	stream.Seek (offset' SeekOrigin.Begin);  	int atomsize = stream.ReadInt32 ();  	string atomname = ByteUtils.ISO88591.GetString (stream.Read (4));  	if ((offset + atomsize) > end) {  		throw new InvalidDataException (string.Format ("atom at {0} claims {1} bytes' end = {2}"' offset' atomsize' end));  	}  	Atom atom = new Atom ();  	atom.name = atomname;  	atom.size = atomsize;  	atom.pos = stream.Position - 8;  	atom.level = level;  	_atoms.Add (atom);  	if (string.Compare (atomname' "mdat"' true) == 0) {  		_mdatsize = atomsize;  	} else if (string.Compare (atomname' "moov"' true) == 0) {  		_moovpos = stream.Position - 8;  	} else if (string.Compare (atomname' "udta"' true) == 0) {  		_udtapos = stream.Position - 8;  		_udtasize = atomsize;  	} else if (string.Compare (atomname' "free"' true) == 0) {  		// we'd like a free under a moov  		// so check for level = 1  		if (atom.level == 2) {  			// go backwards through the entries  			for (int i = _atoms.Count - 1; i > 0; i--) {  				// until we hit a level 1  				if (_atoms [i].level == 1) {  					if (string.Compare (_atoms [i].name' "moov"' true) == 0) {  						if (atomsize > _freesize) {  							// is this free bigger than others?  							_freepos = stream.Position - 8;  							_freesize = atomsize;  						} else {  							break;  						}  					}  					// if moov  				}  				// if level = 1  			}  			// for  		}  		// if level = 2  	}  	// if free  	// if it's a container atom' parse the contents of the atom  	foreach (string atomType in ATOM_TYPES) {  		if (string.Compare (atomname' atomType' true) == 0) {  			ParseAtom (stream' stream.Position' offset + atomsize' level);  			break;  		}  	}  	// meta atom contains tags and some other data  	if (string.Compare (atomname' "meta"' true) == 0) {  		// read in meta atom  		byte[] atomdata = stream.Read (atomsize - 8);  		int nextTagPosition = 0;  		for (int i = 0; i < atomdata.Length - 4; i++) {  			// ilst  			if (atomdata [i] == 'i' && atomdata [i + 1] == 'l' && atomdata [i + 2] == 's' && atomdata [i + 3] == 't') {  				nextTagPosition = i + 8;  				break;  			}  		}  		while (nextTagPosition < (atomsize - 4) && nextTagPosition > 8) {  			int size = ReadInt32 (atomdata' (nextTagPosition - 4)) - 4;  			if (size < 20) {  				Console.WriteLine (stream.Position);  				// TODO: Why is this here...  			}  			byte[] keyBytes = new byte[4];  			byte[] data = new byte[size - 20];  			Buffer.BlockCopy (atomdata' nextTagPosition' keyBytes' 0' 4);  			Buffer.BlockCopy (atomdata' nextTagPosition + 20' data' 0' size - 20);  			string key = ByteUtils.ISO88591.GetString (keyBytes);  			nextTagPosition += size + 4;  			ParseTag (key' data' size - 20);  		}  	}  	// if meta  	// mdhd has data for calculating playtime  	if (string.Compare (atomname' "mdhd"' true) == 0) {  		stream.Seek (12' SeekOrigin.Current);  		Frequency = stream.ReadInt32 ();  		Samples = stream.ReadInt32 ();  	}  	// stsd has data for sample' channels and codec  	if (string.Compare (atomname' "stsd"' true) == 0) {  		byte[] atomdata = stream.Read (atomsize - 8);  		ParseStsdAtom (atomdata);  	}  	// bump offest and continue  	if (atomsize == 0) {  		// a 0 byte atom is the end  		offset = stopAt;  	} else {  		offset += atomsize;  	}  }  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ParseAtom,The following statement contains a magic number: while (offset < stopAt) {  	stream.Seek (offset' SeekOrigin.Begin);  	int atomsize = stream.ReadInt32 ();  	string atomname = ByteUtils.ISO88591.GetString (stream.Read (4));  	if ((offset + atomsize) > end) {  		throw new InvalidDataException (string.Format ("atom at {0} claims {1} bytes' end = {2}"' offset' atomsize' end));  	}  	Atom atom = new Atom ();  	atom.name = atomname;  	atom.size = atomsize;  	atom.pos = stream.Position - 8;  	atom.level = level;  	_atoms.Add (atom);  	if (string.Compare (atomname' "mdat"' true) == 0) {  		_mdatsize = atomsize;  	} else if (string.Compare (atomname' "moov"' true) == 0) {  		_moovpos = stream.Position - 8;  	} else if (string.Compare (atomname' "udta"' true) == 0) {  		_udtapos = stream.Position - 8;  		_udtasize = atomsize;  	} else if (string.Compare (atomname' "free"' true) == 0) {  		// we'd like a free under a moov  		// so check for level = 1  		if (atom.level == 2) {  			// go backwards through the entries  			for (int i = _atoms.Count - 1; i > 0; i--) {  				// until we hit a level 1  				if (_atoms [i].level == 1) {  					if (string.Compare (_atoms [i].name' "moov"' true) == 0) {  						if (atomsize > _freesize) {  							// is this free bigger than others?  							_freepos = stream.Position - 8;  							_freesize = atomsize;  						} else {  							break;  						}  					}  					// if moov  				}  				// if level = 1  			}  			// for  		}  		// if level = 2  	}  	// if free  	// if it's a container atom' parse the contents of the atom  	foreach (string atomType in ATOM_TYPES) {  		if (string.Compare (atomname' atomType' true) == 0) {  			ParseAtom (stream' stream.Position' offset + atomsize' level);  			break;  		}  	}  	// meta atom contains tags and some other data  	if (string.Compare (atomname' "meta"' true) == 0) {  		// read in meta atom  		byte[] atomdata = stream.Read (atomsize - 8);  		int nextTagPosition = 0;  		for (int i = 0; i < atomdata.Length - 4; i++) {  			// ilst  			if (atomdata [i] == 'i' && atomdata [i + 1] == 'l' && atomdata [i + 2] == 's' && atomdata [i + 3] == 't') {  				nextTagPosition = i + 8;  				break;  			}  		}  		while (nextTagPosition < (atomsize - 4) && nextTagPosition > 8) {  			int size = ReadInt32 (atomdata' (nextTagPosition - 4)) - 4;  			if (size < 20) {  				Console.WriteLine (stream.Position);  				// TODO: Why is this here...  			}  			byte[] keyBytes = new byte[4];  			byte[] data = new byte[size - 20];  			Buffer.BlockCopy (atomdata' nextTagPosition' keyBytes' 0' 4);  			Buffer.BlockCopy (atomdata' nextTagPosition + 20' data' 0' size - 20);  			string key = ByteUtils.ISO88591.GetString (keyBytes);  			nextTagPosition += size + 4;  			ParseTag (key' data' size - 20);  		}  	}  	// if meta  	// mdhd has data for calculating playtime  	if (string.Compare (atomname' "mdhd"' true) == 0) {  		stream.Seek (12' SeekOrigin.Current);  		Frequency = stream.ReadInt32 ();  		Samples = stream.ReadInt32 ();  	}  	// stsd has data for sample' channels and codec  	if (string.Compare (atomname' "stsd"' true) == 0) {  		byte[] atomdata = stream.Read (atomsize - 8);  		ParseStsdAtom (atomdata);  	}  	// bump offest and continue  	if (atomsize == 0) {  		// a 0 byte atom is the end  		offset = stopAt;  	} else {  		offset += atomsize;  	}  }  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ParseAtom,The following statement contains a magic number: while (offset < stopAt) {  	stream.Seek (offset' SeekOrigin.Begin);  	int atomsize = stream.ReadInt32 ();  	string atomname = ByteUtils.ISO88591.GetString (stream.Read (4));  	if ((offset + atomsize) > end) {  		throw new InvalidDataException (string.Format ("atom at {0} claims {1} bytes' end = {2}"' offset' atomsize' end));  	}  	Atom atom = new Atom ();  	atom.name = atomname;  	atom.size = atomsize;  	atom.pos = stream.Position - 8;  	atom.level = level;  	_atoms.Add (atom);  	if (string.Compare (atomname' "mdat"' true) == 0) {  		_mdatsize = atomsize;  	} else if (string.Compare (atomname' "moov"' true) == 0) {  		_moovpos = stream.Position - 8;  	} else if (string.Compare (atomname' "udta"' true) == 0) {  		_udtapos = stream.Position - 8;  		_udtasize = atomsize;  	} else if (string.Compare (atomname' "free"' true) == 0) {  		// we'd like a free under a moov  		// so check for level = 1  		if (atom.level == 2) {  			// go backwards through the entries  			for (int i = _atoms.Count - 1; i > 0; i--) {  				// until we hit a level 1  				if (_atoms [i].level == 1) {  					if (string.Compare (_atoms [i].name' "moov"' true) == 0) {  						if (atomsize > _freesize) {  							// is this free bigger than others?  							_freepos = stream.Position - 8;  							_freesize = atomsize;  						} else {  							break;  						}  					}  					// if moov  				}  				// if level = 1  			}  			// for  		}  		// if level = 2  	}  	// if free  	// if it's a container atom' parse the contents of the atom  	foreach (string atomType in ATOM_TYPES) {  		if (string.Compare (atomname' atomType' true) == 0) {  			ParseAtom (stream' stream.Position' offset + atomsize' level);  			break;  		}  	}  	// meta atom contains tags and some other data  	if (string.Compare (atomname' "meta"' true) == 0) {  		// read in meta atom  		byte[] atomdata = stream.Read (atomsize - 8);  		int nextTagPosition = 0;  		for (int i = 0; i < atomdata.Length - 4; i++) {  			// ilst  			if (atomdata [i] == 'i' && atomdata [i + 1] == 'l' && atomdata [i + 2] == 's' && atomdata [i + 3] == 't') {  				nextTagPosition = i + 8;  				break;  			}  		}  		while (nextTagPosition < (atomsize - 4) && nextTagPosition > 8) {  			int size = ReadInt32 (atomdata' (nextTagPosition - 4)) - 4;  			if (size < 20) {  				Console.WriteLine (stream.Position);  				// TODO: Why is this here...  			}  			byte[] keyBytes = new byte[4];  			byte[] data = new byte[size - 20];  			Buffer.BlockCopy (atomdata' nextTagPosition' keyBytes' 0' 4);  			Buffer.BlockCopy (atomdata' nextTagPosition + 20' data' 0' size - 20);  			string key = ByteUtils.ISO88591.GetString (keyBytes);  			nextTagPosition += size + 4;  			ParseTag (key' data' size - 20);  		}  	}  	// if meta  	// mdhd has data for calculating playtime  	if (string.Compare (atomname' "mdhd"' true) == 0) {  		stream.Seek (12' SeekOrigin.Current);  		Frequency = stream.ReadInt32 ();  		Samples = stream.ReadInt32 ();  	}  	// stsd has data for sample' channels and codec  	if (string.Compare (atomname' "stsd"' true) == 0) {  		byte[] atomdata = stream.Read (atomsize - 8);  		ParseStsdAtom (atomdata);  	}  	// bump offest and continue  	if (atomsize == 0) {  		// a 0 byte atom is the end  		offset = stopAt;  	} else {  		offset += atomsize;  	}  }  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ParseAtom,The following statement contains a magic number: while (offset < stopAt) {  	stream.Seek (offset' SeekOrigin.Begin);  	int atomsize = stream.ReadInt32 ();  	string atomname = ByteUtils.ISO88591.GetString (stream.Read (4));  	if ((offset + atomsize) > end) {  		throw new InvalidDataException (string.Format ("atom at {0} claims {1} bytes' end = {2}"' offset' atomsize' end));  	}  	Atom atom = new Atom ();  	atom.name = atomname;  	atom.size = atomsize;  	atom.pos = stream.Position - 8;  	atom.level = level;  	_atoms.Add (atom);  	if (string.Compare (atomname' "mdat"' true) == 0) {  		_mdatsize = atomsize;  	} else if (string.Compare (atomname' "moov"' true) == 0) {  		_moovpos = stream.Position - 8;  	} else if (string.Compare (atomname' "udta"' true) == 0) {  		_udtapos = stream.Position - 8;  		_udtasize = atomsize;  	} else if (string.Compare (atomname' "free"' true) == 0) {  		// we'd like a free under a moov  		// so check for level = 1  		if (atom.level == 2) {  			// go backwards through the entries  			for (int i = _atoms.Count - 1; i > 0; i--) {  				// until we hit a level 1  				if (_atoms [i].level == 1) {  					if (string.Compare (_atoms [i].name' "moov"' true) == 0) {  						if (atomsize > _freesize) {  							// is this free bigger than others?  							_freepos = stream.Position - 8;  							_freesize = atomsize;  						} else {  							break;  						}  					}  					// if moov  				}  				// if level = 1  			}  			// for  		}  		// if level = 2  	}  	// if free  	// if it's a container atom' parse the contents of the atom  	foreach (string atomType in ATOM_TYPES) {  		if (string.Compare (atomname' atomType' true) == 0) {  			ParseAtom (stream' stream.Position' offset + atomsize' level);  			break;  		}  	}  	// meta atom contains tags and some other data  	if (string.Compare (atomname' "meta"' true) == 0) {  		// read in meta atom  		byte[] atomdata = stream.Read (atomsize - 8);  		int nextTagPosition = 0;  		for (int i = 0; i < atomdata.Length - 4; i++) {  			// ilst  			if (atomdata [i] == 'i' && atomdata [i + 1] == 'l' && atomdata [i + 2] == 's' && atomdata [i + 3] == 't') {  				nextTagPosition = i + 8;  				break;  			}  		}  		while (nextTagPosition < (atomsize - 4) && nextTagPosition > 8) {  			int size = ReadInt32 (atomdata' (nextTagPosition - 4)) - 4;  			if (size < 20) {  				Console.WriteLine (stream.Position);  				// TODO: Why is this here...  			}  			byte[] keyBytes = new byte[4];  			byte[] data = new byte[size - 20];  			Buffer.BlockCopy (atomdata' nextTagPosition' keyBytes' 0' 4);  			Buffer.BlockCopy (atomdata' nextTagPosition + 20' data' 0' size - 20);  			string key = ByteUtils.ISO88591.GetString (keyBytes);  			nextTagPosition += size + 4;  			ParseTag (key' data' size - 20);  		}  	}  	// if meta  	// mdhd has data for calculating playtime  	if (string.Compare (atomname' "mdhd"' true) == 0) {  		stream.Seek (12' SeekOrigin.Current);  		Frequency = stream.ReadInt32 ();  		Samples = stream.ReadInt32 ();  	}  	// stsd has data for sample' channels and codec  	if (string.Compare (atomname' "stsd"' true) == 0) {  		byte[] atomdata = stream.Read (atomsize - 8);  		ParseStsdAtom (atomdata);  	}  	// bump offest and continue  	if (atomsize == 0) {  		// a 0 byte atom is the end  		offset = stopAt;  	} else {  		offset += atomsize;  	}  }  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ParseAtom,The following statement contains a magic number: while (offset < stopAt) {  	stream.Seek (offset' SeekOrigin.Begin);  	int atomsize = stream.ReadInt32 ();  	string atomname = ByteUtils.ISO88591.GetString (stream.Read (4));  	if ((offset + atomsize) > end) {  		throw new InvalidDataException (string.Format ("atom at {0} claims {1} bytes' end = {2}"' offset' atomsize' end));  	}  	Atom atom = new Atom ();  	atom.name = atomname;  	atom.size = atomsize;  	atom.pos = stream.Position - 8;  	atom.level = level;  	_atoms.Add (atom);  	if (string.Compare (atomname' "mdat"' true) == 0) {  		_mdatsize = atomsize;  	} else if (string.Compare (atomname' "moov"' true) == 0) {  		_moovpos = stream.Position - 8;  	} else if (string.Compare (atomname' "udta"' true) == 0) {  		_udtapos = stream.Position - 8;  		_udtasize = atomsize;  	} else if (string.Compare (atomname' "free"' true) == 0) {  		// we'd like a free under a moov  		// so check for level = 1  		if (atom.level == 2) {  			// go backwards through the entries  			for (int i = _atoms.Count - 1; i > 0; i--) {  				// until we hit a level 1  				if (_atoms [i].level == 1) {  					if (string.Compare (_atoms [i].name' "moov"' true) == 0) {  						if (atomsize > _freesize) {  							// is this free bigger than others?  							_freepos = stream.Position - 8;  							_freesize = atomsize;  						} else {  							break;  						}  					}  					// if moov  				}  				// if level = 1  			}  			// for  		}  		// if level = 2  	}  	// if free  	// if it's a container atom' parse the contents of the atom  	foreach (string atomType in ATOM_TYPES) {  		if (string.Compare (atomname' atomType' true) == 0) {  			ParseAtom (stream' stream.Position' offset + atomsize' level);  			break;  		}  	}  	// meta atom contains tags and some other data  	if (string.Compare (atomname' "meta"' true) == 0) {  		// read in meta atom  		byte[] atomdata = stream.Read (atomsize - 8);  		int nextTagPosition = 0;  		for (int i = 0; i < atomdata.Length - 4; i++) {  			// ilst  			if (atomdata [i] == 'i' && atomdata [i + 1] == 'l' && atomdata [i + 2] == 's' && atomdata [i + 3] == 't') {  				nextTagPosition = i + 8;  				break;  			}  		}  		while (nextTagPosition < (atomsize - 4) && nextTagPosition > 8) {  			int size = ReadInt32 (atomdata' (nextTagPosition - 4)) - 4;  			if (size < 20) {  				Console.WriteLine (stream.Position);  				// TODO: Why is this here...  			}  			byte[] keyBytes = new byte[4];  			byte[] data = new byte[size - 20];  			Buffer.BlockCopy (atomdata' nextTagPosition' keyBytes' 0' 4);  			Buffer.BlockCopy (atomdata' nextTagPosition + 20' data' 0' size - 20);  			string key = ByteUtils.ISO88591.GetString (keyBytes);  			nextTagPosition += size + 4;  			ParseTag (key' data' size - 20);  		}  	}  	// if meta  	// mdhd has data for calculating playtime  	if (string.Compare (atomname' "mdhd"' true) == 0) {  		stream.Seek (12' SeekOrigin.Current);  		Frequency = stream.ReadInt32 ();  		Samples = stream.ReadInt32 ();  	}  	// stsd has data for sample' channels and codec  	if (string.Compare (atomname' "stsd"' true) == 0) {  		byte[] atomdata = stream.Read (atomsize - 8);  		ParseStsdAtom (atomdata);  	}  	// bump offest and continue  	if (atomsize == 0) {  		// a 0 byte atom is the end  		offset = stopAt;  	} else {  		offset += atomsize;  	}  }  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ParseAtom,The following statement contains a magic number: while (offset < stopAt) {  	stream.Seek (offset' SeekOrigin.Begin);  	int atomsize = stream.ReadInt32 ();  	string atomname = ByteUtils.ISO88591.GetString (stream.Read (4));  	if ((offset + atomsize) > end) {  		throw new InvalidDataException (string.Format ("atom at {0} claims {1} bytes' end = {2}"' offset' atomsize' end));  	}  	Atom atom = new Atom ();  	atom.name = atomname;  	atom.size = atomsize;  	atom.pos = stream.Position - 8;  	atom.level = level;  	_atoms.Add (atom);  	if (string.Compare (atomname' "mdat"' true) == 0) {  		_mdatsize = atomsize;  	} else if (string.Compare (atomname' "moov"' true) == 0) {  		_moovpos = stream.Position - 8;  	} else if (string.Compare (atomname' "udta"' true) == 0) {  		_udtapos = stream.Position - 8;  		_udtasize = atomsize;  	} else if (string.Compare (atomname' "free"' true) == 0) {  		// we'd like a free under a moov  		// so check for level = 1  		if (atom.level == 2) {  			// go backwards through the entries  			for (int i = _atoms.Count - 1; i > 0; i--) {  				// until we hit a level 1  				if (_atoms [i].level == 1) {  					if (string.Compare (_atoms [i].name' "moov"' true) == 0) {  						if (atomsize > _freesize) {  							// is this free bigger than others?  							_freepos = stream.Position - 8;  							_freesize = atomsize;  						} else {  							break;  						}  					}  					// if moov  				}  				// if level = 1  			}  			// for  		}  		// if level = 2  	}  	// if free  	// if it's a container atom' parse the contents of the atom  	foreach (string atomType in ATOM_TYPES) {  		if (string.Compare (atomname' atomType' true) == 0) {  			ParseAtom (stream' stream.Position' offset + atomsize' level);  			break;  		}  	}  	// meta atom contains tags and some other data  	if (string.Compare (atomname' "meta"' true) == 0) {  		// read in meta atom  		byte[] atomdata = stream.Read (atomsize - 8);  		int nextTagPosition = 0;  		for (int i = 0; i < atomdata.Length - 4; i++) {  			// ilst  			if (atomdata [i] == 'i' && atomdata [i + 1] == 'l' && atomdata [i + 2] == 's' && atomdata [i + 3] == 't') {  				nextTagPosition = i + 8;  				break;  			}  		}  		while (nextTagPosition < (atomsize - 4) && nextTagPosition > 8) {  			int size = ReadInt32 (atomdata' (nextTagPosition - 4)) - 4;  			if (size < 20) {  				Console.WriteLine (stream.Position);  				// TODO: Why is this here...  			}  			byte[] keyBytes = new byte[4];  			byte[] data = new byte[size - 20];  			Buffer.BlockCopy (atomdata' nextTagPosition' keyBytes' 0' 4);  			Buffer.BlockCopy (atomdata' nextTagPosition + 20' data' 0' size - 20);  			string key = ByteUtils.ISO88591.GetString (keyBytes);  			nextTagPosition += size + 4;  			ParseTag (key' data' size - 20);  		}  	}  	// if meta  	// mdhd has data for calculating playtime  	if (string.Compare (atomname' "mdhd"' true) == 0) {  		stream.Seek (12' SeekOrigin.Current);  		Frequency = stream.ReadInt32 ();  		Samples = stream.ReadInt32 ();  	}  	// stsd has data for sample' channels and codec  	if (string.Compare (atomname' "stsd"' true) == 0) {  		byte[] atomdata = stream.Read (atomsize - 8);  		ParseStsdAtom (atomdata);  	}  	// bump offest and continue  	if (atomsize == 0) {  		// a 0 byte atom is the end  		offset = stopAt;  	} else {  		offset += atomsize;  	}  }  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ParseAtom,The following statement contains a magic number: while (offset < stopAt) {  	stream.Seek (offset' SeekOrigin.Begin);  	int atomsize = stream.ReadInt32 ();  	string atomname = ByteUtils.ISO88591.GetString (stream.Read (4));  	if ((offset + atomsize) > end) {  		throw new InvalidDataException (string.Format ("atom at {0} claims {1} bytes' end = {2}"' offset' atomsize' end));  	}  	Atom atom = new Atom ();  	atom.name = atomname;  	atom.size = atomsize;  	atom.pos = stream.Position - 8;  	atom.level = level;  	_atoms.Add (atom);  	if (string.Compare (atomname' "mdat"' true) == 0) {  		_mdatsize = atomsize;  	} else if (string.Compare (atomname' "moov"' true) == 0) {  		_moovpos = stream.Position - 8;  	} else if (string.Compare (atomname' "udta"' true) == 0) {  		_udtapos = stream.Position - 8;  		_udtasize = atomsize;  	} else if (string.Compare (atomname' "free"' true) == 0) {  		// we'd like a free under a moov  		// so check for level = 1  		if (atom.level == 2) {  			// go backwards through the entries  			for (int i = _atoms.Count - 1; i > 0; i--) {  				// until we hit a level 1  				if (_atoms [i].level == 1) {  					if (string.Compare (_atoms [i].name' "moov"' true) == 0) {  						if (atomsize > _freesize) {  							// is this free bigger than others?  							_freepos = stream.Position - 8;  							_freesize = atomsize;  						} else {  							break;  						}  					}  					// if moov  				}  				// if level = 1  			}  			// for  		}  		// if level = 2  	}  	// if free  	// if it's a container atom' parse the contents of the atom  	foreach (string atomType in ATOM_TYPES) {  		if (string.Compare (atomname' atomType' true) == 0) {  			ParseAtom (stream' stream.Position' offset + atomsize' level);  			break;  		}  	}  	// meta atom contains tags and some other data  	if (string.Compare (atomname' "meta"' true) == 0) {  		// read in meta atom  		byte[] atomdata = stream.Read (atomsize - 8);  		int nextTagPosition = 0;  		for (int i = 0; i < atomdata.Length - 4; i++) {  			// ilst  			if (atomdata [i] == 'i' && atomdata [i + 1] == 'l' && atomdata [i + 2] == 's' && atomdata [i + 3] == 't') {  				nextTagPosition = i + 8;  				break;  			}  		}  		while (nextTagPosition < (atomsize - 4) && nextTagPosition > 8) {  			int size = ReadInt32 (atomdata' (nextTagPosition - 4)) - 4;  			if (size < 20) {  				Console.WriteLine (stream.Position);  				// TODO: Why is this here...  			}  			byte[] keyBytes = new byte[4];  			byte[] data = new byte[size - 20];  			Buffer.BlockCopy (atomdata' nextTagPosition' keyBytes' 0' 4);  			Buffer.BlockCopy (atomdata' nextTagPosition + 20' data' 0' size - 20);  			string key = ByteUtils.ISO88591.GetString (keyBytes);  			nextTagPosition += size + 4;  			ParseTag (key' data' size - 20);  		}  	}  	// if meta  	// mdhd has data for calculating playtime  	if (string.Compare (atomname' "mdhd"' true) == 0) {  		stream.Seek (12' SeekOrigin.Current);  		Frequency = stream.ReadInt32 ();  		Samples = stream.ReadInt32 ();  	}  	// stsd has data for sample' channels and codec  	if (string.Compare (atomname' "stsd"' true) == 0) {  		byte[] atomdata = stream.Read (atomsize - 8);  		ParseStsdAtom (atomdata);  	}  	// bump offest and continue  	if (atomsize == 0) {  		// a 0 byte atom is the end  		offset = stopAt;  	} else {  		offset += atomsize;  	}  }  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ParseAtom,The following statement contains a magic number: while (offset < stopAt) {  	stream.Seek (offset' SeekOrigin.Begin);  	int atomsize = stream.ReadInt32 ();  	string atomname = ByteUtils.ISO88591.GetString (stream.Read (4));  	if ((offset + atomsize) > end) {  		throw new InvalidDataException (string.Format ("atom at {0} claims {1} bytes' end = {2}"' offset' atomsize' end));  	}  	Atom atom = new Atom ();  	atom.name = atomname;  	atom.size = atomsize;  	atom.pos = stream.Position - 8;  	atom.level = level;  	_atoms.Add (atom);  	if (string.Compare (atomname' "mdat"' true) == 0) {  		_mdatsize = atomsize;  	} else if (string.Compare (atomname' "moov"' true) == 0) {  		_moovpos = stream.Position - 8;  	} else if (string.Compare (atomname' "udta"' true) == 0) {  		_udtapos = stream.Position - 8;  		_udtasize = atomsize;  	} else if (string.Compare (atomname' "free"' true) == 0) {  		// we'd like a free under a moov  		// so check for level = 1  		if (atom.level == 2) {  			// go backwards through the entries  			for (int i = _atoms.Count - 1; i > 0; i--) {  				// until we hit a level 1  				if (_atoms [i].level == 1) {  					if (string.Compare (_atoms [i].name' "moov"' true) == 0) {  						if (atomsize > _freesize) {  							// is this free bigger than others?  							_freepos = stream.Position - 8;  							_freesize = atomsize;  						} else {  							break;  						}  					}  					// if moov  				}  				// if level = 1  			}  			// for  		}  		// if level = 2  	}  	// if free  	// if it's a container atom' parse the contents of the atom  	foreach (string atomType in ATOM_TYPES) {  		if (string.Compare (atomname' atomType' true) == 0) {  			ParseAtom (stream' stream.Position' offset + atomsize' level);  			break;  		}  	}  	// meta atom contains tags and some other data  	if (string.Compare (atomname' "meta"' true) == 0) {  		// read in meta atom  		byte[] atomdata = stream.Read (atomsize - 8);  		int nextTagPosition = 0;  		for (int i = 0; i < atomdata.Length - 4; i++) {  			// ilst  			if (atomdata [i] == 'i' && atomdata [i + 1] == 'l' && atomdata [i + 2] == 's' && atomdata [i + 3] == 't') {  				nextTagPosition = i + 8;  				break;  			}  		}  		while (nextTagPosition < (atomsize - 4) && nextTagPosition > 8) {  			int size = ReadInt32 (atomdata' (nextTagPosition - 4)) - 4;  			if (size < 20) {  				Console.WriteLine (stream.Position);  				// TODO: Why is this here...  			}  			byte[] keyBytes = new byte[4];  			byte[] data = new byte[size - 20];  			Buffer.BlockCopy (atomdata' nextTagPosition' keyBytes' 0' 4);  			Buffer.BlockCopy (atomdata' nextTagPosition + 20' data' 0' size - 20);  			string key = ByteUtils.ISO88591.GetString (keyBytes);  			nextTagPosition += size + 4;  			ParseTag (key' data' size - 20);  		}  	}  	// if meta  	// mdhd has data for calculating playtime  	if (string.Compare (atomname' "mdhd"' true) == 0) {  		stream.Seek (12' SeekOrigin.Current);  		Frequency = stream.ReadInt32 ();  		Samples = stream.ReadInt32 ();  	}  	// stsd has data for sample' channels and codec  	if (string.Compare (atomname' "stsd"' true) == 0) {  		byte[] atomdata = stream.Read (atomsize - 8);  		ParseStsdAtom (atomdata);  	}  	// bump offest and continue  	if (atomsize == 0) {  		// a 0 byte atom is the end  		offset = stopAt;  	} else {  		offset += atomsize;  	}  }  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ParseAtom,The following statement contains a magic number: while (offset < stopAt) {  	stream.Seek (offset' SeekOrigin.Begin);  	int atomsize = stream.ReadInt32 ();  	string atomname = ByteUtils.ISO88591.GetString (stream.Read (4));  	if ((offset + atomsize) > end) {  		throw new InvalidDataException (string.Format ("atom at {0} claims {1} bytes' end = {2}"' offset' atomsize' end));  	}  	Atom atom = new Atom ();  	atom.name = atomname;  	atom.size = atomsize;  	atom.pos = stream.Position - 8;  	atom.level = level;  	_atoms.Add (atom);  	if (string.Compare (atomname' "mdat"' true) == 0) {  		_mdatsize = atomsize;  	} else if (string.Compare (atomname' "moov"' true) == 0) {  		_moovpos = stream.Position - 8;  	} else if (string.Compare (atomname' "udta"' true) == 0) {  		_udtapos = stream.Position - 8;  		_udtasize = atomsize;  	} else if (string.Compare (atomname' "free"' true) == 0) {  		// we'd like a free under a moov  		// so check for level = 1  		if (atom.level == 2) {  			// go backwards through the entries  			for (int i = _atoms.Count - 1; i > 0; i--) {  				// until we hit a level 1  				if (_atoms [i].level == 1) {  					if (string.Compare (_atoms [i].name' "moov"' true) == 0) {  						if (atomsize > _freesize) {  							// is this free bigger than others?  							_freepos = stream.Position - 8;  							_freesize = atomsize;  						} else {  							break;  						}  					}  					// if moov  				}  				// if level = 1  			}  			// for  		}  		// if level = 2  	}  	// if free  	// if it's a container atom' parse the contents of the atom  	foreach (string atomType in ATOM_TYPES) {  		if (string.Compare (atomname' atomType' true) == 0) {  			ParseAtom (stream' stream.Position' offset + atomsize' level);  			break;  		}  	}  	// meta atom contains tags and some other data  	if (string.Compare (atomname' "meta"' true) == 0) {  		// read in meta atom  		byte[] atomdata = stream.Read (atomsize - 8);  		int nextTagPosition = 0;  		for (int i = 0; i < atomdata.Length - 4; i++) {  			// ilst  			if (atomdata [i] == 'i' && atomdata [i + 1] == 'l' && atomdata [i + 2] == 's' && atomdata [i + 3] == 't') {  				nextTagPosition = i + 8;  				break;  			}  		}  		while (nextTagPosition < (atomsize - 4) && nextTagPosition > 8) {  			int size = ReadInt32 (atomdata' (nextTagPosition - 4)) - 4;  			if (size < 20) {  				Console.WriteLine (stream.Position);  				// TODO: Why is this here...  			}  			byte[] keyBytes = new byte[4];  			byte[] data = new byte[size - 20];  			Buffer.BlockCopy (atomdata' nextTagPosition' keyBytes' 0' 4);  			Buffer.BlockCopy (atomdata' nextTagPosition + 20' data' 0' size - 20);  			string key = ByteUtils.ISO88591.GetString (keyBytes);  			nextTagPosition += size + 4;  			ParseTag (key' data' size - 20);  		}  	}  	// if meta  	// mdhd has data for calculating playtime  	if (string.Compare (atomname' "mdhd"' true) == 0) {  		stream.Seek (12' SeekOrigin.Current);  		Frequency = stream.ReadInt32 ();  		Samples = stream.ReadInt32 ();  	}  	// stsd has data for sample' channels and codec  	if (string.Compare (atomname' "stsd"' true) == 0) {  		byte[] atomdata = stream.Read (atomsize - 8);  		ParseStsdAtom (atomdata);  	}  	// bump offest and continue  	if (atomsize == 0) {  		// a 0 byte atom is the end  		offset = stopAt;  	} else {  		offset += atomsize;  	}  }  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ParseAtom,The following statement contains a magic number: while (offset < stopAt) {  	stream.Seek (offset' SeekOrigin.Begin);  	int atomsize = stream.ReadInt32 ();  	string atomname = ByteUtils.ISO88591.GetString (stream.Read (4));  	if ((offset + atomsize) > end) {  		throw new InvalidDataException (string.Format ("atom at {0} claims {1} bytes' end = {2}"' offset' atomsize' end));  	}  	Atom atom = new Atom ();  	atom.name = atomname;  	atom.size = atomsize;  	atom.pos = stream.Position - 8;  	atom.level = level;  	_atoms.Add (atom);  	if (string.Compare (atomname' "mdat"' true) == 0) {  		_mdatsize = atomsize;  	} else if (string.Compare (atomname' "moov"' true) == 0) {  		_moovpos = stream.Position - 8;  	} else if (string.Compare (atomname' "udta"' true) == 0) {  		_udtapos = stream.Position - 8;  		_udtasize = atomsize;  	} else if (string.Compare (atomname' "free"' true) == 0) {  		// we'd like a free under a moov  		// so check for level = 1  		if (atom.level == 2) {  			// go backwards through the entries  			for (int i = _atoms.Count - 1; i > 0; i--) {  				// until we hit a level 1  				if (_atoms [i].level == 1) {  					if (string.Compare (_atoms [i].name' "moov"' true) == 0) {  						if (atomsize > _freesize) {  							// is this free bigger than others?  							_freepos = stream.Position - 8;  							_freesize = atomsize;  						} else {  							break;  						}  					}  					// if moov  				}  				// if level = 1  			}  			// for  		}  		// if level = 2  	}  	// if free  	// if it's a container atom' parse the contents of the atom  	foreach (string atomType in ATOM_TYPES) {  		if (string.Compare (atomname' atomType' true) == 0) {  			ParseAtom (stream' stream.Position' offset + atomsize' level);  			break;  		}  	}  	// meta atom contains tags and some other data  	if (string.Compare (atomname' "meta"' true) == 0) {  		// read in meta atom  		byte[] atomdata = stream.Read (atomsize - 8);  		int nextTagPosition = 0;  		for (int i = 0; i < atomdata.Length - 4; i++) {  			// ilst  			if (atomdata [i] == 'i' && atomdata [i + 1] == 'l' && atomdata [i + 2] == 's' && atomdata [i + 3] == 't') {  				nextTagPosition = i + 8;  				break;  			}  		}  		while (nextTagPosition < (atomsize - 4) && nextTagPosition > 8) {  			int size = ReadInt32 (atomdata' (nextTagPosition - 4)) - 4;  			if (size < 20) {  				Console.WriteLine (stream.Position);  				// TODO: Why is this here...  			}  			byte[] keyBytes = new byte[4];  			byte[] data = new byte[size - 20];  			Buffer.BlockCopy (atomdata' nextTagPosition' keyBytes' 0' 4);  			Buffer.BlockCopy (atomdata' nextTagPosition + 20' data' 0' size - 20);  			string key = ByteUtils.ISO88591.GetString (keyBytes);  			nextTagPosition += size + 4;  			ParseTag (key' data' size - 20);  		}  	}  	// if meta  	// mdhd has data for calculating playtime  	if (string.Compare (atomname' "mdhd"' true) == 0) {  		stream.Seek (12' SeekOrigin.Current);  		Frequency = stream.ReadInt32 ();  		Samples = stream.ReadInt32 ();  	}  	// stsd has data for sample' channels and codec  	if (string.Compare (atomname' "stsd"' true) == 0) {  		byte[] atomdata = stream.Read (atomsize - 8);  		ParseStsdAtom (atomdata);  	}  	// bump offest and continue  	if (atomsize == 0) {  		// a 0 byte atom is the end  		offset = stopAt;  	} else {  		offset += atomsize;  	}  }  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ParseAtom,The following statement contains a magic number: while (offset < stopAt) {  	stream.Seek (offset' SeekOrigin.Begin);  	int atomsize = stream.ReadInt32 ();  	string atomname = ByteUtils.ISO88591.GetString (stream.Read (4));  	if ((offset + atomsize) > end) {  		throw new InvalidDataException (string.Format ("atom at {0} claims {1} bytes' end = {2}"' offset' atomsize' end));  	}  	Atom atom = new Atom ();  	atom.name = atomname;  	atom.size = atomsize;  	atom.pos = stream.Position - 8;  	atom.level = level;  	_atoms.Add (atom);  	if (string.Compare (atomname' "mdat"' true) == 0) {  		_mdatsize = atomsize;  	} else if (string.Compare (atomname' "moov"' true) == 0) {  		_moovpos = stream.Position - 8;  	} else if (string.Compare (atomname' "udta"' true) == 0) {  		_udtapos = stream.Position - 8;  		_udtasize = atomsize;  	} else if (string.Compare (atomname' "free"' true) == 0) {  		// we'd like a free under a moov  		// so check for level = 1  		if (atom.level == 2) {  			// go backwards through the entries  			for (int i = _atoms.Count - 1; i > 0; i--) {  				// until we hit a level 1  				if (_atoms [i].level == 1) {  					if (string.Compare (_atoms [i].name' "moov"' true) == 0) {  						if (atomsize > _freesize) {  							// is this free bigger than others?  							_freepos = stream.Position - 8;  							_freesize = atomsize;  						} else {  							break;  						}  					}  					// if moov  				}  				// if level = 1  			}  			// for  		}  		// if level = 2  	}  	// if free  	// if it's a container atom' parse the contents of the atom  	foreach (string atomType in ATOM_TYPES) {  		if (string.Compare (atomname' atomType' true) == 0) {  			ParseAtom (stream' stream.Position' offset + atomsize' level);  			break;  		}  	}  	// meta atom contains tags and some other data  	if (string.Compare (atomname' "meta"' true) == 0) {  		// read in meta atom  		byte[] atomdata = stream.Read (atomsize - 8);  		int nextTagPosition = 0;  		for (int i = 0; i < atomdata.Length - 4; i++) {  			// ilst  			if (atomdata [i] == 'i' && atomdata [i + 1] == 'l' && atomdata [i + 2] == 's' && atomdata [i + 3] == 't') {  				nextTagPosition = i + 8;  				break;  			}  		}  		while (nextTagPosition < (atomsize - 4) && nextTagPosition > 8) {  			int size = ReadInt32 (atomdata' (nextTagPosition - 4)) - 4;  			if (size < 20) {  				Console.WriteLine (stream.Position);  				// TODO: Why is this here...  			}  			byte[] keyBytes = new byte[4];  			byte[] data = new byte[size - 20];  			Buffer.BlockCopy (atomdata' nextTagPosition' keyBytes' 0' 4);  			Buffer.BlockCopy (atomdata' nextTagPosition + 20' data' 0' size - 20);  			string key = ByteUtils.ISO88591.GetString (keyBytes);  			nextTagPosition += size + 4;  			ParseTag (key' data' size - 20);  		}  	}  	// if meta  	// mdhd has data for calculating playtime  	if (string.Compare (atomname' "mdhd"' true) == 0) {  		stream.Seek (12' SeekOrigin.Current);  		Frequency = stream.ReadInt32 ();  		Samples = stream.ReadInt32 ();  	}  	// stsd has data for sample' channels and codec  	if (string.Compare (atomname' "stsd"' true) == 0) {  		byte[] atomdata = stream.Read (atomsize - 8);  		ParseStsdAtom (atomdata);  	}  	// bump offest and continue  	if (atomsize == 0) {  		// a 0 byte atom is the end  		offset = stopAt;  	} else {  		offset += atomsize;  	}  }  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ParseAtom,The following statement contains a magic number: atom.pos = stream.Position - 8;  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ParseAtom,The following statement contains a magic number: if (string.Compare (atomname' "mdat"' true) == 0) {  	_mdatsize = atomsize;  } else if (string.Compare (atomname' "moov"' true) == 0) {  	_moovpos = stream.Position - 8;  } else if (string.Compare (atomname' "udta"' true) == 0) {  	_udtapos = stream.Position - 8;  	_udtasize = atomsize;  } else if (string.Compare (atomname' "free"' true) == 0) {  	// we'd like a free under a moov  	// so check for level = 1  	if (atom.level == 2) {  		// go backwards through the entries  		for (int i = _atoms.Count - 1; i > 0; i--) {  			// until we hit a level 1  			if (_atoms [i].level == 1) {  				if (string.Compare (_atoms [i].name' "moov"' true) == 0) {  					if (atomsize > _freesize) {  						// is this free bigger than others?  						_freepos = stream.Position - 8;  						_freesize = atomsize;  					} else {  						break;  					}  				}  				// if moov  			}  			// if level = 1  		}  		// for  	}  	// if level = 2  }  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ParseAtom,The following statement contains a magic number: if (string.Compare (atomname' "mdat"' true) == 0) {  	_mdatsize = atomsize;  } else if (string.Compare (atomname' "moov"' true) == 0) {  	_moovpos = stream.Position - 8;  } else if (string.Compare (atomname' "udta"' true) == 0) {  	_udtapos = stream.Position - 8;  	_udtasize = atomsize;  } else if (string.Compare (atomname' "free"' true) == 0) {  	// we'd like a free under a moov  	// so check for level = 1  	if (atom.level == 2) {  		// go backwards through the entries  		for (int i = _atoms.Count - 1; i > 0; i--) {  			// until we hit a level 1  			if (_atoms [i].level == 1) {  				if (string.Compare (_atoms [i].name' "moov"' true) == 0) {  					if (atomsize > _freesize) {  						// is this free bigger than others?  						_freepos = stream.Position - 8;  						_freesize = atomsize;  					} else {  						break;  					}  				}  				// if moov  			}  			// if level = 1  		}  		// for  	}  	// if level = 2  }  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ParseAtom,The following statement contains a magic number: if (string.Compare (atomname' "mdat"' true) == 0) {  	_mdatsize = atomsize;  } else if (string.Compare (atomname' "moov"' true) == 0) {  	_moovpos = stream.Position - 8;  } else if (string.Compare (atomname' "udta"' true) == 0) {  	_udtapos = stream.Position - 8;  	_udtasize = atomsize;  } else if (string.Compare (atomname' "free"' true) == 0) {  	// we'd like a free under a moov  	// so check for level = 1  	if (atom.level == 2) {  		// go backwards through the entries  		for (int i = _atoms.Count - 1; i > 0; i--) {  			// until we hit a level 1  			if (_atoms [i].level == 1) {  				if (string.Compare (_atoms [i].name' "moov"' true) == 0) {  					if (atomsize > _freesize) {  						// is this free bigger than others?  						_freepos = stream.Position - 8;  						_freesize = atomsize;  					} else {  						break;  					}  				}  				// if moov  			}  			// if level = 1  		}  		// for  	}  	// if level = 2  }  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ParseAtom,The following statement contains a magic number: if (string.Compare (atomname' "mdat"' true) == 0) {  	_mdatsize = atomsize;  } else if (string.Compare (atomname' "moov"' true) == 0) {  	_moovpos = stream.Position - 8;  } else if (string.Compare (atomname' "udta"' true) == 0) {  	_udtapos = stream.Position - 8;  	_udtasize = atomsize;  } else if (string.Compare (atomname' "free"' true) == 0) {  	// we'd like a free under a moov  	// so check for level = 1  	if (atom.level == 2) {  		// go backwards through the entries  		for (int i = _atoms.Count - 1; i > 0; i--) {  			// until we hit a level 1  			if (_atoms [i].level == 1) {  				if (string.Compare (_atoms [i].name' "moov"' true) == 0) {  					if (atomsize > _freesize) {  						// is this free bigger than others?  						_freepos = stream.Position - 8;  						_freesize = atomsize;  					} else {  						break;  					}  				}  				// if moov  			}  			// if level = 1  		}  		// for  	}  	// if level = 2  }  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ParseAtom,The following statement contains a magic number: if (string.Compare (atomname' "moov"' true) == 0) {  	_moovpos = stream.Position - 8;  } else if (string.Compare (atomname' "udta"' true) == 0) {  	_udtapos = stream.Position - 8;  	_udtasize = atomsize;  } else if (string.Compare (atomname' "free"' true) == 0) {  	// we'd like a free under a moov  	// so check for level = 1  	if (atom.level == 2) {  		// go backwards through the entries  		for (int i = _atoms.Count - 1; i > 0; i--) {  			// until we hit a level 1  			if (_atoms [i].level == 1) {  				if (string.Compare (_atoms [i].name' "moov"' true) == 0) {  					if (atomsize > _freesize) {  						// is this free bigger than others?  						_freepos = stream.Position - 8;  						_freesize = atomsize;  					} else {  						break;  					}  				}  				// if moov  			}  			// if level = 1  		}  		// for  	}  	// if level = 2  }  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ParseAtom,The following statement contains a magic number: if (string.Compare (atomname' "moov"' true) == 0) {  	_moovpos = stream.Position - 8;  } else if (string.Compare (atomname' "udta"' true) == 0) {  	_udtapos = stream.Position - 8;  	_udtasize = atomsize;  } else if (string.Compare (atomname' "free"' true) == 0) {  	// we'd like a free under a moov  	// so check for level = 1  	if (atom.level == 2) {  		// go backwards through the entries  		for (int i = _atoms.Count - 1; i > 0; i--) {  			// until we hit a level 1  			if (_atoms [i].level == 1) {  				if (string.Compare (_atoms [i].name' "moov"' true) == 0) {  					if (atomsize > _freesize) {  						// is this free bigger than others?  						_freepos = stream.Position - 8;  						_freesize = atomsize;  					} else {  						break;  					}  				}  				// if moov  			}  			// if level = 1  		}  		// for  	}  	// if level = 2  }  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ParseAtom,The following statement contains a magic number: if (string.Compare (atomname' "moov"' true) == 0) {  	_moovpos = stream.Position - 8;  } else if (string.Compare (atomname' "udta"' true) == 0) {  	_udtapos = stream.Position - 8;  	_udtasize = atomsize;  } else if (string.Compare (atomname' "free"' true) == 0) {  	// we'd like a free under a moov  	// so check for level = 1  	if (atom.level == 2) {  		// go backwards through the entries  		for (int i = _atoms.Count - 1; i > 0; i--) {  			// until we hit a level 1  			if (_atoms [i].level == 1) {  				if (string.Compare (_atoms [i].name' "moov"' true) == 0) {  					if (atomsize > _freesize) {  						// is this free bigger than others?  						_freepos = stream.Position - 8;  						_freesize = atomsize;  					} else {  						break;  					}  				}  				// if moov  			}  			// if level = 1  		}  		// for  	}  	// if level = 2  }  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ParseAtom,The following statement contains a magic number: if (string.Compare (atomname' "moov"' true) == 0) {  	_moovpos = stream.Position - 8;  } else if (string.Compare (atomname' "udta"' true) == 0) {  	_udtapos = stream.Position - 8;  	_udtasize = atomsize;  } else if (string.Compare (atomname' "free"' true) == 0) {  	// we'd like a free under a moov  	// so check for level = 1  	if (atom.level == 2) {  		// go backwards through the entries  		for (int i = _atoms.Count - 1; i > 0; i--) {  			// until we hit a level 1  			if (_atoms [i].level == 1) {  				if (string.Compare (_atoms [i].name' "moov"' true) == 0) {  					if (atomsize > _freesize) {  						// is this free bigger than others?  						_freepos = stream.Position - 8;  						_freesize = atomsize;  					} else {  						break;  					}  				}  				// if moov  			}  			// if level = 1  		}  		// for  	}  	// if level = 2  }  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ParseAtom,The following statement contains a magic number: _moovpos = stream.Position - 8;  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ParseAtom,The following statement contains a magic number: if (string.Compare (atomname' "udta"' true) == 0) {  	_udtapos = stream.Position - 8;  	_udtasize = atomsize;  } else if (string.Compare (atomname' "free"' true) == 0) {  	// we'd like a free under a moov  	// so check for level = 1  	if (atom.level == 2) {  		// go backwards through the entries  		for (int i = _atoms.Count - 1; i > 0; i--) {  			// until we hit a level 1  			if (_atoms [i].level == 1) {  				if (string.Compare (_atoms [i].name' "moov"' true) == 0) {  					if (atomsize > _freesize) {  						// is this free bigger than others?  						_freepos = stream.Position - 8;  						_freesize = atomsize;  					} else {  						break;  					}  				}  				// if moov  			}  			// if level = 1  		}  		// for  	}  	// if level = 2  }  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ParseAtom,The following statement contains a magic number: if (string.Compare (atomname' "udta"' true) == 0) {  	_udtapos = stream.Position - 8;  	_udtasize = atomsize;  } else if (string.Compare (atomname' "free"' true) == 0) {  	// we'd like a free under a moov  	// so check for level = 1  	if (atom.level == 2) {  		// go backwards through the entries  		for (int i = _atoms.Count - 1; i > 0; i--) {  			// until we hit a level 1  			if (_atoms [i].level == 1) {  				if (string.Compare (_atoms [i].name' "moov"' true) == 0) {  					if (atomsize > _freesize) {  						// is this free bigger than others?  						_freepos = stream.Position - 8;  						_freesize = atomsize;  					} else {  						break;  					}  				}  				// if moov  			}  			// if level = 1  		}  		// for  	}  	// if level = 2  }  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ParseAtom,The following statement contains a magic number: if (string.Compare (atomname' "udta"' true) == 0) {  	_udtapos = stream.Position - 8;  	_udtasize = atomsize;  } else if (string.Compare (atomname' "free"' true) == 0) {  	// we'd like a free under a moov  	// so check for level = 1  	if (atom.level == 2) {  		// go backwards through the entries  		for (int i = _atoms.Count - 1; i > 0; i--) {  			// until we hit a level 1  			if (_atoms [i].level == 1) {  				if (string.Compare (_atoms [i].name' "moov"' true) == 0) {  					if (atomsize > _freesize) {  						// is this free bigger than others?  						_freepos = stream.Position - 8;  						_freesize = atomsize;  					} else {  						break;  					}  				}  				// if moov  			}  			// if level = 1  		}  		// for  	}  	// if level = 2  }  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ParseAtom,The following statement contains a magic number: _udtapos = stream.Position - 8;  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ParseAtom,The following statement contains a magic number: if (string.Compare (atomname' "free"' true) == 0) {  	// we'd like a free under a moov  	// so check for level = 1  	if (atom.level == 2) {  		// go backwards through the entries  		for (int i = _atoms.Count - 1; i > 0; i--) {  			// until we hit a level 1  			if (_atoms [i].level == 1) {  				if (string.Compare (_atoms [i].name' "moov"' true) == 0) {  					if (atomsize > _freesize) {  						// is this free bigger than others?  						_freepos = stream.Position - 8;  						_freesize = atomsize;  					} else {  						break;  					}  				}  				// if moov  			}  			// if level = 1  		}  		// for  	}  	// if level = 2  }  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ParseAtom,The following statement contains a magic number: if (string.Compare (atomname' "free"' true) == 0) {  	// we'd like a free under a moov  	// so check for level = 1  	if (atom.level == 2) {  		// go backwards through the entries  		for (int i = _atoms.Count - 1; i > 0; i--) {  			// until we hit a level 1  			if (_atoms [i].level == 1) {  				if (string.Compare (_atoms [i].name' "moov"' true) == 0) {  					if (atomsize > _freesize) {  						// is this free bigger than others?  						_freepos = stream.Position - 8;  						_freesize = atomsize;  					} else {  						break;  					}  				}  				// if moov  			}  			// if level = 1  		}  		// for  	}  	// if level = 2  }  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ParseAtom,The following statement contains a magic number: if (atom.level == 2) {  	// go backwards through the entries  	for (int i = _atoms.Count - 1; i > 0; i--) {  		// until we hit a level 1  		if (_atoms [i].level == 1) {  			if (string.Compare (_atoms [i].name' "moov"' true) == 0) {  				if (atomsize > _freesize) {  					// is this free bigger than others?  					_freepos = stream.Position - 8;  					_freesize = atomsize;  				} else {  					break;  				}  			}  			// if moov  		}  		// if level = 1  	}  	// for  }  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ParseAtom,The following statement contains a magic number: if (atom.level == 2) {  	// go backwards through the entries  	for (int i = _atoms.Count - 1; i > 0; i--) {  		// until we hit a level 1  		if (_atoms [i].level == 1) {  			if (string.Compare (_atoms [i].name' "moov"' true) == 0) {  				if (atomsize > _freesize) {  					// is this free bigger than others?  					_freepos = stream.Position - 8;  					_freesize = atomsize;  				} else {  					break;  				}  			}  			// if moov  		}  		// if level = 1  	}  	// for  }  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ParseAtom,The following statement contains a magic number: for (int i = _atoms.Count - 1; i > 0; i--) {  	// until we hit a level 1  	if (_atoms [i].level == 1) {  		if (string.Compare (_atoms [i].name' "moov"' true) == 0) {  			if (atomsize > _freesize) {  				// is this free bigger than others?  				_freepos = stream.Position - 8;  				_freesize = atomsize;  			} else {  				break;  			}  		}  		// if moov  	}  	// if level = 1  }  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ParseAtom,The following statement contains a magic number: if (_atoms [i].level == 1) {  	if (string.Compare (_atoms [i].name' "moov"' true) == 0) {  		if (atomsize > _freesize) {  			// is this free bigger than others?  			_freepos = stream.Position - 8;  			_freesize = atomsize;  		} else {  			break;  		}  	}  	// if moov  }  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ParseAtom,The following statement contains a magic number: if (string.Compare (_atoms [i].name' "moov"' true) == 0) {  	if (atomsize > _freesize) {  		// is this free bigger than others?  		_freepos = stream.Position - 8;  		_freesize = atomsize;  	} else {  		break;  	}  }  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ParseAtom,The following statement contains a magic number: if (atomsize > _freesize) {  	// is this free bigger than others?  	_freepos = stream.Position - 8;  	_freesize = atomsize;  } else {  	break;  }  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ParseAtom,The following statement contains a magic number: _freepos = stream.Position - 8;  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ParseAtom,The following statement contains a magic number: if (string.Compare (atomname' "meta"' true) == 0) {  	// read in meta atom  	byte[] atomdata = stream.Read (atomsize - 8);  	int nextTagPosition = 0;  	for (int i = 0; i < atomdata.Length - 4; i++) {  		// ilst  		if (atomdata [i] == 'i' && atomdata [i + 1] == 'l' && atomdata [i + 2] == 's' && atomdata [i + 3] == 't') {  			nextTagPosition = i + 8;  			break;  		}  	}  	while (nextTagPosition < (atomsize - 4) && nextTagPosition > 8) {  		int size = ReadInt32 (atomdata' (nextTagPosition - 4)) - 4;  		if (size < 20) {  			Console.WriteLine (stream.Position);  			// TODO: Why is this here...  		}  		byte[] keyBytes = new byte[4];  		byte[] data = new byte[size - 20];  		Buffer.BlockCopy (atomdata' nextTagPosition' keyBytes' 0' 4);  		Buffer.BlockCopy (atomdata' nextTagPosition + 20' data' 0' size - 20);  		string key = ByteUtils.ISO88591.GetString (keyBytes);  		nextTagPosition += size + 4;  		ParseTag (key' data' size - 20);  	}  }  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ParseAtom,The following statement contains a magic number: if (string.Compare (atomname' "meta"' true) == 0) {  	// read in meta atom  	byte[] atomdata = stream.Read (atomsize - 8);  	int nextTagPosition = 0;  	for (int i = 0; i < atomdata.Length - 4; i++) {  		// ilst  		if (atomdata [i] == 'i' && atomdata [i + 1] == 'l' && atomdata [i + 2] == 's' && atomdata [i + 3] == 't') {  			nextTagPosition = i + 8;  			break;  		}  	}  	while (nextTagPosition < (atomsize - 4) && nextTagPosition > 8) {  		int size = ReadInt32 (atomdata' (nextTagPosition - 4)) - 4;  		if (size < 20) {  			Console.WriteLine (stream.Position);  			// TODO: Why is this here...  		}  		byte[] keyBytes = new byte[4];  		byte[] data = new byte[size - 20];  		Buffer.BlockCopy (atomdata' nextTagPosition' keyBytes' 0' 4);  		Buffer.BlockCopy (atomdata' nextTagPosition + 20' data' 0' size - 20);  		string key = ByteUtils.ISO88591.GetString (keyBytes);  		nextTagPosition += size + 4;  		ParseTag (key' data' size - 20);  	}  }  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ParseAtom,The following statement contains a magic number: if (string.Compare (atomname' "meta"' true) == 0) {  	// read in meta atom  	byte[] atomdata = stream.Read (atomsize - 8);  	int nextTagPosition = 0;  	for (int i = 0; i < atomdata.Length - 4; i++) {  		// ilst  		if (atomdata [i] == 'i' && atomdata [i + 1] == 'l' && atomdata [i + 2] == 's' && atomdata [i + 3] == 't') {  			nextTagPosition = i + 8;  			break;  		}  	}  	while (nextTagPosition < (atomsize - 4) && nextTagPosition > 8) {  		int size = ReadInt32 (atomdata' (nextTagPosition - 4)) - 4;  		if (size < 20) {  			Console.WriteLine (stream.Position);  			// TODO: Why is this here...  		}  		byte[] keyBytes = new byte[4];  		byte[] data = new byte[size - 20];  		Buffer.BlockCopy (atomdata' nextTagPosition' keyBytes' 0' 4);  		Buffer.BlockCopy (atomdata' nextTagPosition + 20' data' 0' size - 20);  		string key = ByteUtils.ISO88591.GetString (keyBytes);  		nextTagPosition += size + 4;  		ParseTag (key' data' size - 20);  	}  }  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ParseAtom,The following statement contains a magic number: if (string.Compare (atomname' "meta"' true) == 0) {  	// read in meta atom  	byte[] atomdata = stream.Read (atomsize - 8);  	int nextTagPosition = 0;  	for (int i = 0; i < atomdata.Length - 4; i++) {  		// ilst  		if (atomdata [i] == 'i' && atomdata [i + 1] == 'l' && atomdata [i + 2] == 's' && atomdata [i + 3] == 't') {  			nextTagPosition = i + 8;  			break;  		}  	}  	while (nextTagPosition < (atomsize - 4) && nextTagPosition > 8) {  		int size = ReadInt32 (atomdata' (nextTagPosition - 4)) - 4;  		if (size < 20) {  			Console.WriteLine (stream.Position);  			// TODO: Why is this here...  		}  		byte[] keyBytes = new byte[4];  		byte[] data = new byte[size - 20];  		Buffer.BlockCopy (atomdata' nextTagPosition' keyBytes' 0' 4);  		Buffer.BlockCopy (atomdata' nextTagPosition + 20' data' 0' size - 20);  		string key = ByteUtils.ISO88591.GetString (keyBytes);  		nextTagPosition += size + 4;  		ParseTag (key' data' size - 20);  	}  }  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ParseAtom,The following statement contains a magic number: if (string.Compare (atomname' "meta"' true) == 0) {  	// read in meta atom  	byte[] atomdata = stream.Read (atomsize - 8);  	int nextTagPosition = 0;  	for (int i = 0; i < atomdata.Length - 4; i++) {  		// ilst  		if (atomdata [i] == 'i' && atomdata [i + 1] == 'l' && atomdata [i + 2] == 's' && atomdata [i + 3] == 't') {  			nextTagPosition = i + 8;  			break;  		}  	}  	while (nextTagPosition < (atomsize - 4) && nextTagPosition > 8) {  		int size = ReadInt32 (atomdata' (nextTagPosition - 4)) - 4;  		if (size < 20) {  			Console.WriteLine (stream.Position);  			// TODO: Why is this here...  		}  		byte[] keyBytes = new byte[4];  		byte[] data = new byte[size - 20];  		Buffer.BlockCopy (atomdata' nextTagPosition' keyBytes' 0' 4);  		Buffer.BlockCopy (atomdata' nextTagPosition + 20' data' 0' size - 20);  		string key = ByteUtils.ISO88591.GetString (keyBytes);  		nextTagPosition += size + 4;  		ParseTag (key' data' size - 20);  	}  }  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ParseAtom,The following statement contains a magic number: if (string.Compare (atomname' "meta"' true) == 0) {  	// read in meta atom  	byte[] atomdata = stream.Read (atomsize - 8);  	int nextTagPosition = 0;  	for (int i = 0; i < atomdata.Length - 4; i++) {  		// ilst  		if (atomdata [i] == 'i' && atomdata [i + 1] == 'l' && atomdata [i + 2] == 's' && atomdata [i + 3] == 't') {  			nextTagPosition = i + 8;  			break;  		}  	}  	while (nextTagPosition < (atomsize - 4) && nextTagPosition > 8) {  		int size = ReadInt32 (atomdata' (nextTagPosition - 4)) - 4;  		if (size < 20) {  			Console.WriteLine (stream.Position);  			// TODO: Why is this here...  		}  		byte[] keyBytes = new byte[4];  		byte[] data = new byte[size - 20];  		Buffer.BlockCopy (atomdata' nextTagPosition' keyBytes' 0' 4);  		Buffer.BlockCopy (atomdata' nextTagPosition + 20' data' 0' size - 20);  		string key = ByteUtils.ISO88591.GetString (keyBytes);  		nextTagPosition += size + 4;  		ParseTag (key' data' size - 20);  	}  }  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ParseAtom,The following statement contains a magic number: if (string.Compare (atomname' "meta"' true) == 0) {  	// read in meta atom  	byte[] atomdata = stream.Read (atomsize - 8);  	int nextTagPosition = 0;  	for (int i = 0; i < atomdata.Length - 4; i++) {  		// ilst  		if (atomdata [i] == 'i' && atomdata [i + 1] == 'l' && atomdata [i + 2] == 's' && atomdata [i + 3] == 't') {  			nextTagPosition = i + 8;  			break;  		}  	}  	while (nextTagPosition < (atomsize - 4) && nextTagPosition > 8) {  		int size = ReadInt32 (atomdata' (nextTagPosition - 4)) - 4;  		if (size < 20) {  			Console.WriteLine (stream.Position);  			// TODO: Why is this here...  		}  		byte[] keyBytes = new byte[4];  		byte[] data = new byte[size - 20];  		Buffer.BlockCopy (atomdata' nextTagPosition' keyBytes' 0' 4);  		Buffer.BlockCopy (atomdata' nextTagPosition + 20' data' 0' size - 20);  		string key = ByteUtils.ISO88591.GetString (keyBytes);  		nextTagPosition += size + 4;  		ParseTag (key' data' size - 20);  	}  }  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ParseAtom,The following statement contains a magic number: if (string.Compare (atomname' "meta"' true) == 0) {  	// read in meta atom  	byte[] atomdata = stream.Read (atomsize - 8);  	int nextTagPosition = 0;  	for (int i = 0; i < atomdata.Length - 4; i++) {  		// ilst  		if (atomdata [i] == 'i' && atomdata [i + 1] == 'l' && atomdata [i + 2] == 's' && atomdata [i + 3] == 't') {  			nextTagPosition = i + 8;  			break;  		}  	}  	while (nextTagPosition < (atomsize - 4) && nextTagPosition > 8) {  		int size = ReadInt32 (atomdata' (nextTagPosition - 4)) - 4;  		if (size < 20) {  			Console.WriteLine (stream.Position);  			// TODO: Why is this here...  		}  		byte[] keyBytes = new byte[4];  		byte[] data = new byte[size - 20];  		Buffer.BlockCopy (atomdata' nextTagPosition' keyBytes' 0' 4);  		Buffer.BlockCopy (atomdata' nextTagPosition + 20' data' 0' size - 20);  		string key = ByteUtils.ISO88591.GetString (keyBytes);  		nextTagPosition += size + 4;  		ParseTag (key' data' size - 20);  	}  }  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ParseAtom,The following statement contains a magic number: if (string.Compare (atomname' "meta"' true) == 0) {  	// read in meta atom  	byte[] atomdata = stream.Read (atomsize - 8);  	int nextTagPosition = 0;  	for (int i = 0; i < atomdata.Length - 4; i++) {  		// ilst  		if (atomdata [i] == 'i' && atomdata [i + 1] == 'l' && atomdata [i + 2] == 's' && atomdata [i + 3] == 't') {  			nextTagPosition = i + 8;  			break;  		}  	}  	while (nextTagPosition < (atomsize - 4) && nextTagPosition > 8) {  		int size = ReadInt32 (atomdata' (nextTagPosition - 4)) - 4;  		if (size < 20) {  			Console.WriteLine (stream.Position);  			// TODO: Why is this here...  		}  		byte[] keyBytes = new byte[4];  		byte[] data = new byte[size - 20];  		Buffer.BlockCopy (atomdata' nextTagPosition' keyBytes' 0' 4);  		Buffer.BlockCopy (atomdata' nextTagPosition + 20' data' 0' size - 20);  		string key = ByteUtils.ISO88591.GetString (keyBytes);  		nextTagPosition += size + 4;  		ParseTag (key' data' size - 20);  	}  }  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ParseAtom,The following statement contains a magic number: if (string.Compare (atomname' "meta"' true) == 0) {  	// read in meta atom  	byte[] atomdata = stream.Read (atomsize - 8);  	int nextTagPosition = 0;  	for (int i = 0; i < atomdata.Length - 4; i++) {  		// ilst  		if (atomdata [i] == 'i' && atomdata [i + 1] == 'l' && atomdata [i + 2] == 's' && atomdata [i + 3] == 't') {  			nextTagPosition = i + 8;  			break;  		}  	}  	while (nextTagPosition < (atomsize - 4) && nextTagPosition > 8) {  		int size = ReadInt32 (atomdata' (nextTagPosition - 4)) - 4;  		if (size < 20) {  			Console.WriteLine (stream.Position);  			// TODO: Why is this here...  		}  		byte[] keyBytes = new byte[4];  		byte[] data = new byte[size - 20];  		Buffer.BlockCopy (atomdata' nextTagPosition' keyBytes' 0' 4);  		Buffer.BlockCopy (atomdata' nextTagPosition + 20' data' 0' size - 20);  		string key = ByteUtils.ISO88591.GetString (keyBytes);  		nextTagPosition += size + 4;  		ParseTag (key' data' size - 20);  	}  }  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ParseAtom,The following statement contains a magic number: if (string.Compare (atomname' "meta"' true) == 0) {  	// read in meta atom  	byte[] atomdata = stream.Read (atomsize - 8);  	int nextTagPosition = 0;  	for (int i = 0; i < atomdata.Length - 4; i++) {  		// ilst  		if (atomdata [i] == 'i' && atomdata [i + 1] == 'l' && atomdata [i + 2] == 's' && atomdata [i + 3] == 't') {  			nextTagPosition = i + 8;  			break;  		}  	}  	while (nextTagPosition < (atomsize - 4) && nextTagPosition > 8) {  		int size = ReadInt32 (atomdata' (nextTagPosition - 4)) - 4;  		if (size < 20) {  			Console.WriteLine (stream.Position);  			// TODO: Why is this here...  		}  		byte[] keyBytes = new byte[4];  		byte[] data = new byte[size - 20];  		Buffer.BlockCopy (atomdata' nextTagPosition' keyBytes' 0' 4);  		Buffer.BlockCopy (atomdata' nextTagPosition + 20' data' 0' size - 20);  		string key = ByteUtils.ISO88591.GetString (keyBytes);  		nextTagPosition += size + 4;  		ParseTag (key' data' size - 20);  	}  }  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ParseAtom,The following statement contains a magic number: if (string.Compare (atomname' "meta"' true) == 0) {  	// read in meta atom  	byte[] atomdata = stream.Read (atomsize - 8);  	int nextTagPosition = 0;  	for (int i = 0; i < atomdata.Length - 4; i++) {  		// ilst  		if (atomdata [i] == 'i' && atomdata [i + 1] == 'l' && atomdata [i + 2] == 's' && atomdata [i + 3] == 't') {  			nextTagPosition = i + 8;  			break;  		}  	}  	while (nextTagPosition < (atomsize - 4) && nextTagPosition > 8) {  		int size = ReadInt32 (atomdata' (nextTagPosition - 4)) - 4;  		if (size < 20) {  			Console.WriteLine (stream.Position);  			// TODO: Why is this here...  		}  		byte[] keyBytes = new byte[4];  		byte[] data = new byte[size - 20];  		Buffer.BlockCopy (atomdata' nextTagPosition' keyBytes' 0' 4);  		Buffer.BlockCopy (atomdata' nextTagPosition + 20' data' 0' size - 20);  		string key = ByteUtils.ISO88591.GetString (keyBytes);  		nextTagPosition += size + 4;  		ParseTag (key' data' size - 20);  	}  }  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ParseAtom,The following statement contains a magic number: if (string.Compare (atomname' "meta"' true) == 0) {  	// read in meta atom  	byte[] atomdata = stream.Read (atomsize - 8);  	int nextTagPosition = 0;  	for (int i = 0; i < atomdata.Length - 4; i++) {  		// ilst  		if (atomdata [i] == 'i' && atomdata [i + 1] == 'l' && atomdata [i + 2] == 's' && atomdata [i + 3] == 't') {  			nextTagPosition = i + 8;  			break;  		}  	}  	while (nextTagPosition < (atomsize - 4) && nextTagPosition > 8) {  		int size = ReadInt32 (atomdata' (nextTagPosition - 4)) - 4;  		if (size < 20) {  			Console.WriteLine (stream.Position);  			// TODO: Why is this here...  		}  		byte[] keyBytes = new byte[4];  		byte[] data = new byte[size - 20];  		Buffer.BlockCopy (atomdata' nextTagPosition' keyBytes' 0' 4);  		Buffer.BlockCopy (atomdata' nextTagPosition + 20' data' 0' size - 20);  		string key = ByteUtils.ISO88591.GetString (keyBytes);  		nextTagPosition += size + 4;  		ParseTag (key' data' size - 20);  	}  }  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ParseAtom,The following statement contains a magic number: if (string.Compare (atomname' "meta"' true) == 0) {  	// read in meta atom  	byte[] atomdata = stream.Read (atomsize - 8);  	int nextTagPosition = 0;  	for (int i = 0; i < atomdata.Length - 4; i++) {  		// ilst  		if (atomdata [i] == 'i' && atomdata [i + 1] == 'l' && atomdata [i + 2] == 's' && atomdata [i + 3] == 't') {  			nextTagPosition = i + 8;  			break;  		}  	}  	while (nextTagPosition < (atomsize - 4) && nextTagPosition > 8) {  		int size = ReadInt32 (atomdata' (nextTagPosition - 4)) - 4;  		if (size < 20) {  			Console.WriteLine (stream.Position);  			// TODO: Why is this here...  		}  		byte[] keyBytes = new byte[4];  		byte[] data = new byte[size - 20];  		Buffer.BlockCopy (atomdata' nextTagPosition' keyBytes' 0' 4);  		Buffer.BlockCopy (atomdata' nextTagPosition + 20' data' 0' size - 20);  		string key = ByteUtils.ISO88591.GetString (keyBytes);  		nextTagPosition += size + 4;  		ParseTag (key' data' size - 20);  	}  }  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ParseAtom,The following statement contains a magic number: if (string.Compare (atomname' "meta"' true) == 0) {  	// read in meta atom  	byte[] atomdata = stream.Read (atomsize - 8);  	int nextTagPosition = 0;  	for (int i = 0; i < atomdata.Length - 4; i++) {  		// ilst  		if (atomdata [i] == 'i' && atomdata [i + 1] == 'l' && atomdata [i + 2] == 's' && atomdata [i + 3] == 't') {  			nextTagPosition = i + 8;  			break;  		}  	}  	while (nextTagPosition < (atomsize - 4) && nextTagPosition > 8) {  		int size = ReadInt32 (atomdata' (nextTagPosition - 4)) - 4;  		if (size < 20) {  			Console.WriteLine (stream.Position);  			// TODO: Why is this here...  		}  		byte[] keyBytes = new byte[4];  		byte[] data = new byte[size - 20];  		Buffer.BlockCopy (atomdata' nextTagPosition' keyBytes' 0' 4);  		Buffer.BlockCopy (atomdata' nextTagPosition + 20' data' 0' size - 20);  		string key = ByteUtils.ISO88591.GetString (keyBytes);  		nextTagPosition += size + 4;  		ParseTag (key' data' size - 20);  	}  }  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ParseAtom,The following statement contains a magic number: if (string.Compare (atomname' "meta"' true) == 0) {  	// read in meta atom  	byte[] atomdata = stream.Read (atomsize - 8);  	int nextTagPosition = 0;  	for (int i = 0; i < atomdata.Length - 4; i++) {  		// ilst  		if (atomdata [i] == 'i' && atomdata [i + 1] == 'l' && atomdata [i + 2] == 's' && atomdata [i + 3] == 't') {  			nextTagPosition = i + 8;  			break;  		}  	}  	while (nextTagPosition < (atomsize - 4) && nextTagPosition > 8) {  		int size = ReadInt32 (atomdata' (nextTagPosition - 4)) - 4;  		if (size < 20) {  			Console.WriteLine (stream.Position);  			// TODO: Why is this here...  		}  		byte[] keyBytes = new byte[4];  		byte[] data = new byte[size - 20];  		Buffer.BlockCopy (atomdata' nextTagPosition' keyBytes' 0' 4);  		Buffer.BlockCopy (atomdata' nextTagPosition + 20' data' 0' size - 20);  		string key = ByteUtils.ISO88591.GetString (keyBytes);  		nextTagPosition += size + 4;  		ParseTag (key' data' size - 20);  	}  }  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ParseAtom,The following statement contains a magic number: if (string.Compare (atomname' "meta"' true) == 0) {  	// read in meta atom  	byte[] atomdata = stream.Read (atomsize - 8);  	int nextTagPosition = 0;  	for (int i = 0; i < atomdata.Length - 4; i++) {  		// ilst  		if (atomdata [i] == 'i' && atomdata [i + 1] == 'l' && atomdata [i + 2] == 's' && atomdata [i + 3] == 't') {  			nextTagPosition = i + 8;  			break;  		}  	}  	while (nextTagPosition < (atomsize - 4) && nextTagPosition > 8) {  		int size = ReadInt32 (atomdata' (nextTagPosition - 4)) - 4;  		if (size < 20) {  			Console.WriteLine (stream.Position);  			// TODO: Why is this here...  		}  		byte[] keyBytes = new byte[4];  		byte[] data = new byte[size - 20];  		Buffer.BlockCopy (atomdata' nextTagPosition' keyBytes' 0' 4);  		Buffer.BlockCopy (atomdata' nextTagPosition + 20' data' 0' size - 20);  		string key = ByteUtils.ISO88591.GetString (keyBytes);  		nextTagPosition += size + 4;  		ParseTag (key' data' size - 20);  	}  }  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ParseAtom,The following statement contains a magic number: for (int i = 0; i < atomdata.Length - 4; i++) {  	// ilst  	if (atomdata [i] == 'i' && atomdata [i + 1] == 'l' && atomdata [i + 2] == 's' && atomdata [i + 3] == 't') {  		nextTagPosition = i + 8;  		break;  	}  }  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ParseAtom,The following statement contains a magic number: for (int i = 0; i < atomdata.Length - 4; i++) {  	// ilst  	if (atomdata [i] == 'i' && atomdata [i + 1] == 'l' && atomdata [i + 2] == 's' && atomdata [i + 3] == 't') {  		nextTagPosition = i + 8;  		break;  	}  }  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ParseAtom,The following statement contains a magic number: for (int i = 0; i < atomdata.Length - 4; i++) {  	// ilst  	if (atomdata [i] == 'i' && atomdata [i + 1] == 'l' && atomdata [i + 2] == 's' && atomdata [i + 3] == 't') {  		nextTagPosition = i + 8;  		break;  	}  }  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ParseAtom,The following statement contains a magic number: for (int i = 0; i < atomdata.Length - 4; i++) {  	// ilst  	if (atomdata [i] == 'i' && atomdata [i + 1] == 'l' && atomdata [i + 2] == 's' && atomdata [i + 3] == 't') {  		nextTagPosition = i + 8;  		break;  	}  }  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ParseAtom,The following statement contains a magic number: if (atomdata [i] == 'i' && atomdata [i + 1] == 'l' && atomdata [i + 2] == 's' && atomdata [i + 3] == 't') {  	nextTagPosition = i + 8;  	break;  }  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ParseAtom,The following statement contains a magic number: if (atomdata [i] == 'i' && atomdata [i + 1] == 'l' && atomdata [i + 2] == 's' && atomdata [i + 3] == 't') {  	nextTagPosition = i + 8;  	break;  }  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ParseAtom,The following statement contains a magic number: if (atomdata [i] == 'i' && atomdata [i + 1] == 'l' && atomdata [i + 2] == 's' && atomdata [i + 3] == 't') {  	nextTagPosition = i + 8;  	break;  }  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ParseAtom,The following statement contains a magic number: nextTagPosition = i + 8;  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ParseAtom,The following statement contains a magic number: while (nextTagPosition < (atomsize - 4) && nextTagPosition > 8) {  	int size = ReadInt32 (atomdata' (nextTagPosition - 4)) - 4;  	if (size < 20) {  		Console.WriteLine (stream.Position);  		// TODO: Why is this here...  	}  	byte[] keyBytes = new byte[4];  	byte[] data = new byte[size - 20];  	Buffer.BlockCopy (atomdata' nextTagPosition' keyBytes' 0' 4);  	Buffer.BlockCopy (atomdata' nextTagPosition + 20' data' 0' size - 20);  	string key = ByteUtils.ISO88591.GetString (keyBytes);  	nextTagPosition += size + 4;  	ParseTag (key' data' size - 20);  }  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ParseAtom,The following statement contains a magic number: while (nextTagPosition < (atomsize - 4) && nextTagPosition > 8) {  	int size = ReadInt32 (atomdata' (nextTagPosition - 4)) - 4;  	if (size < 20) {  		Console.WriteLine (stream.Position);  		// TODO: Why is this here...  	}  	byte[] keyBytes = new byte[4];  	byte[] data = new byte[size - 20];  	Buffer.BlockCopy (atomdata' nextTagPosition' keyBytes' 0' 4);  	Buffer.BlockCopy (atomdata' nextTagPosition + 20' data' 0' size - 20);  	string key = ByteUtils.ISO88591.GetString (keyBytes);  	nextTagPosition += size + 4;  	ParseTag (key' data' size - 20);  }  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ParseAtom,The following statement contains a magic number: while (nextTagPosition < (atomsize - 4) && nextTagPosition > 8) {  	int size = ReadInt32 (atomdata' (nextTagPosition - 4)) - 4;  	if (size < 20) {  		Console.WriteLine (stream.Position);  		// TODO: Why is this here...  	}  	byte[] keyBytes = new byte[4];  	byte[] data = new byte[size - 20];  	Buffer.BlockCopy (atomdata' nextTagPosition' keyBytes' 0' 4);  	Buffer.BlockCopy (atomdata' nextTagPosition + 20' data' 0' size - 20);  	string key = ByteUtils.ISO88591.GetString (keyBytes);  	nextTagPosition += size + 4;  	ParseTag (key' data' size - 20);  }  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ParseAtom,The following statement contains a magic number: while (nextTagPosition < (atomsize - 4) && nextTagPosition > 8) {  	int size = ReadInt32 (atomdata' (nextTagPosition - 4)) - 4;  	if (size < 20) {  		Console.WriteLine (stream.Position);  		// TODO: Why is this here...  	}  	byte[] keyBytes = new byte[4];  	byte[] data = new byte[size - 20];  	Buffer.BlockCopy (atomdata' nextTagPosition' keyBytes' 0' 4);  	Buffer.BlockCopy (atomdata' nextTagPosition + 20' data' 0' size - 20);  	string key = ByteUtils.ISO88591.GetString (keyBytes);  	nextTagPosition += size + 4;  	ParseTag (key' data' size - 20);  }  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ParseAtom,The following statement contains a magic number: while (nextTagPosition < (atomsize - 4) && nextTagPosition > 8) {  	int size = ReadInt32 (atomdata' (nextTagPosition - 4)) - 4;  	if (size < 20) {  		Console.WriteLine (stream.Position);  		// TODO: Why is this here...  	}  	byte[] keyBytes = new byte[4];  	byte[] data = new byte[size - 20];  	Buffer.BlockCopy (atomdata' nextTagPosition' keyBytes' 0' 4);  	Buffer.BlockCopy (atomdata' nextTagPosition + 20' data' 0' size - 20);  	string key = ByteUtils.ISO88591.GetString (keyBytes);  	nextTagPosition += size + 4;  	ParseTag (key' data' size - 20);  }  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ParseAtom,The following statement contains a magic number: while (nextTagPosition < (atomsize - 4) && nextTagPosition > 8) {  	int size = ReadInt32 (atomdata' (nextTagPosition - 4)) - 4;  	if (size < 20) {  		Console.WriteLine (stream.Position);  		// TODO: Why is this here...  	}  	byte[] keyBytes = new byte[4];  	byte[] data = new byte[size - 20];  	Buffer.BlockCopy (atomdata' nextTagPosition' keyBytes' 0' 4);  	Buffer.BlockCopy (atomdata' nextTagPosition + 20' data' 0' size - 20);  	string key = ByteUtils.ISO88591.GetString (keyBytes);  	nextTagPosition += size + 4;  	ParseTag (key' data' size - 20);  }  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ParseAtom,The following statement contains a magic number: while (nextTagPosition < (atomsize - 4) && nextTagPosition > 8) {  	int size = ReadInt32 (atomdata' (nextTagPosition - 4)) - 4;  	if (size < 20) {  		Console.WriteLine (stream.Position);  		// TODO: Why is this here...  	}  	byte[] keyBytes = new byte[4];  	byte[] data = new byte[size - 20];  	Buffer.BlockCopy (atomdata' nextTagPosition' keyBytes' 0' 4);  	Buffer.BlockCopy (atomdata' nextTagPosition + 20' data' 0' size - 20);  	string key = ByteUtils.ISO88591.GetString (keyBytes);  	nextTagPosition += size + 4;  	ParseTag (key' data' size - 20);  }  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ParseAtom,The following statement contains a magic number: while (nextTagPosition < (atomsize - 4) && nextTagPosition > 8) {  	int size = ReadInt32 (atomdata' (nextTagPosition - 4)) - 4;  	if (size < 20) {  		Console.WriteLine (stream.Position);  		// TODO: Why is this here...  	}  	byte[] keyBytes = new byte[4];  	byte[] data = new byte[size - 20];  	Buffer.BlockCopy (atomdata' nextTagPosition' keyBytes' 0' 4);  	Buffer.BlockCopy (atomdata' nextTagPosition + 20' data' 0' size - 20);  	string key = ByteUtils.ISO88591.GetString (keyBytes);  	nextTagPosition += size + 4;  	ParseTag (key' data' size - 20);  }  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ParseAtom,The following statement contains a magic number: while (nextTagPosition < (atomsize - 4) && nextTagPosition > 8) {  	int size = ReadInt32 (atomdata' (nextTagPosition - 4)) - 4;  	if (size < 20) {  		Console.WriteLine (stream.Position);  		// TODO: Why is this here...  	}  	byte[] keyBytes = new byte[4];  	byte[] data = new byte[size - 20];  	Buffer.BlockCopy (atomdata' nextTagPosition' keyBytes' 0' 4);  	Buffer.BlockCopy (atomdata' nextTagPosition + 20' data' 0' size - 20);  	string key = ByteUtils.ISO88591.GetString (keyBytes);  	nextTagPosition += size + 4;  	ParseTag (key' data' size - 20);  }  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ParseAtom,The following statement contains a magic number: while (nextTagPosition < (atomsize - 4) && nextTagPosition > 8) {  	int size = ReadInt32 (atomdata' (nextTagPosition - 4)) - 4;  	if (size < 20) {  		Console.WriteLine (stream.Position);  		// TODO: Why is this here...  	}  	byte[] keyBytes = new byte[4];  	byte[] data = new byte[size - 20];  	Buffer.BlockCopy (atomdata' nextTagPosition' keyBytes' 0' 4);  	Buffer.BlockCopy (atomdata' nextTagPosition + 20' data' 0' size - 20);  	string key = ByteUtils.ISO88591.GetString (keyBytes);  	nextTagPosition += size + 4;  	ParseTag (key' data' size - 20);  }  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ParseAtom,The following statement contains a magic number: while (nextTagPosition < (atomsize - 4) && nextTagPosition > 8) {  	int size = ReadInt32 (atomdata' (nextTagPosition - 4)) - 4;  	if (size < 20) {  		Console.WriteLine (stream.Position);  		// TODO: Why is this here...  	}  	byte[] keyBytes = new byte[4];  	byte[] data = new byte[size - 20];  	Buffer.BlockCopy (atomdata' nextTagPosition' keyBytes' 0' 4);  	Buffer.BlockCopy (atomdata' nextTagPosition + 20' data' 0' size - 20);  	string key = ByteUtils.ISO88591.GetString (keyBytes);  	nextTagPosition += size + 4;  	ParseTag (key' data' size - 20);  }  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ParseAtom,The following statement contains a magic number: while (nextTagPosition < (atomsize - 4) && nextTagPosition > 8) {  	int size = ReadInt32 (atomdata' (nextTagPosition - 4)) - 4;  	if (size < 20) {  		Console.WriteLine (stream.Position);  		// TODO: Why is this here...  	}  	byte[] keyBytes = new byte[4];  	byte[] data = new byte[size - 20];  	Buffer.BlockCopy (atomdata' nextTagPosition' keyBytes' 0' 4);  	Buffer.BlockCopy (atomdata' nextTagPosition + 20' data' 0' size - 20);  	string key = ByteUtils.ISO88591.GetString (keyBytes);  	nextTagPosition += size + 4;  	ParseTag (key' data' size - 20);  }  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ParseAtom,The following statement contains a magic number: if (size < 20) {  	Console.WriteLine (stream.Position);  	// TODO: Why is this here...  }  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ParseAtom,The following statement contains a magic number: Buffer.BlockCopy (atomdata' nextTagPosition' keyBytes' 0' 4);  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ParseAtom,The following statement contains a magic number: Buffer.BlockCopy (atomdata' nextTagPosition + 20' data' 0' size - 20);  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ParseAtom,The following statement contains a magic number: Buffer.BlockCopy (atomdata' nextTagPosition + 20' data' 0' size - 20);  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ParseAtom,The following statement contains a magic number: nextTagPosition += size + 4;  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ParseAtom,The following statement contains a magic number: ParseTag (key' data' size - 20);  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ParseAtom,The following statement contains a magic number: if (string.Compare (atomname' "mdhd"' true) == 0) {  	stream.Seek (12' SeekOrigin.Current);  	Frequency = stream.ReadInt32 ();  	Samples = stream.ReadInt32 ();  }  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ParseAtom,The following statement contains a magic number: stream.Seek (12' SeekOrigin.Current);  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,ParseAtom,The following statement contains a magic number: if (string.Compare (atomname' "stsd"' true) == 0) {  	byte[] atomdata = stream.Read (atomsize - 8);  	ParseStsdAtom (atomdata);  }  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,WriteInt32,The following statement contains a magic number: stream.WriteByte ((byte)((num >> 24) & 0xff));  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,WriteInt32,The following statement contains a magic number: stream.WriteByte ((byte)((num >> 16) & 0xff));  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,WriteInt32,The following statement contains a magic number: stream.WriteByte ((byte)((num >> 8) & 0xff));  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,WriteInt32,The following statement contains a magic number: data [offset] = (byte)((num >> 24) & 0xff);  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,WriteInt32,The following statement contains a magic number: data [offset + 1] = (byte)((num >> 16) & 0xff);  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,WriteInt32,The following statement contains a magic number: data [offset + 2] = (byte)((num >> 8) & 0xff);  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,WriteInt32,The following statement contains a magic number: data [offset + 2] = (byte)((num >> 8) & 0xff);  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,WriteInt32,The following statement contains a magic number: data [offset + 3] = (byte)((num >> 0) & 0xff);  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,WriteAtom,The following statement contains a magic number: if (!string.IsNullOrEmpty (value)) {  	byte[] byteValue = Encoding.UTF8.GetBytes (value);  	WriteInt32 (atom.Length + byteValue.Length' atom' 0);  	WriteInt32 (atom.Length + byteValue.Length - 8' atom' 8);  	stream.Write (atom);  	stream.Write (byteValue);  }  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,WriteAtom,The following statement contains a magic number: if (!string.IsNullOrEmpty (value)) {  	byte[] byteValue = Encoding.UTF8.GetBytes (value);  	WriteInt32 (atom.Length + byteValue.Length' atom' 0);  	WriteInt32 (atom.Length + byteValue.Length - 8' atom' 8);  	stream.Write (atom);  	stream.Write (byteValue);  }  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,WriteAtom,The following statement contains a magic number: WriteInt32 (atom.Length + byteValue.Length - 8' atom' 8);  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,WriteAtom,The following statement contains a magic number: WriteInt32 (atom.Length + byteValue.Length - 8' atom' 8);  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,WriteTrackAtom,The following statement contains a magic number: if (_trackNumber > 0 || _totalTracks > 0) {  	WriteInt32 (trkn.Length' trkn' 0);  	WriteInt32 (trkn.Length - 8' trkn' 8);  	trkn [trkn.Length - 5] = (byte)_trackNumber;  	trkn [trkn.Length - 3] = (byte)_totalTracks;  	stream.Write (trkn);  }  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,WriteTrackAtom,The following statement contains a magic number: if (_trackNumber > 0 || _totalTracks > 0) {  	WriteInt32 (trkn.Length' trkn' 0);  	WriteInt32 (trkn.Length - 8' trkn' 8);  	trkn [trkn.Length - 5] = (byte)_trackNumber;  	trkn [trkn.Length - 3] = (byte)_totalTracks;  	stream.Write (trkn);  }  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,WriteTrackAtom,The following statement contains a magic number: if (_trackNumber > 0 || _totalTracks > 0) {  	WriteInt32 (trkn.Length' trkn' 0);  	WriteInt32 (trkn.Length - 8' trkn' 8);  	trkn [trkn.Length - 5] = (byte)_trackNumber;  	trkn [trkn.Length - 3] = (byte)_totalTracks;  	stream.Write (trkn);  }  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,WriteTrackAtom,The following statement contains a magic number: if (_trackNumber > 0 || _totalTracks > 0) {  	WriteInt32 (trkn.Length' trkn' 0);  	WriteInt32 (trkn.Length - 8' trkn' 8);  	trkn [trkn.Length - 5] = (byte)_trackNumber;  	trkn [trkn.Length - 3] = (byte)_totalTracks;  	stream.Write (trkn);  }  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,WriteTrackAtom,The following statement contains a magic number: WriteInt32 (trkn.Length - 8' trkn' 8);  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,WriteTrackAtom,The following statement contains a magic number: WriteInt32 (trkn.Length - 8' trkn' 8);  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,WriteTrackAtom,The following statement contains a magic number: trkn [trkn.Length - 5] = (byte)_trackNumber;  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,WriteTrackAtom,The following statement contains a magic number: trkn [trkn.Length - 3] = (byte)_totalTracks;  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,WriteDiscAtom,The following statement contains a magic number: if (_disc > 0 || _totalDiscs > 0) {  	WriteInt32 (disk.Length' disk' 0);  	WriteInt32 (disk.Length - 8' disk' 8);  	disk [disk.Length - 3] = (byte)_disc;  	disk [disk.Length - 1] = (byte)_totalDiscs;  	stream.Write (disk);  }  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,WriteDiscAtom,The following statement contains a magic number: if (_disc > 0 || _totalDiscs > 0) {  	WriteInt32 (disk.Length' disk' 0);  	WriteInt32 (disk.Length - 8' disk' 8);  	disk [disk.Length - 3] = (byte)_disc;  	disk [disk.Length - 1] = (byte)_totalDiscs;  	stream.Write (disk);  }  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,WriteDiscAtom,The following statement contains a magic number: if (_disc > 0 || _totalDiscs > 0) {  	WriteInt32 (disk.Length' disk' 0);  	WriteInt32 (disk.Length - 8' disk' 8);  	disk [disk.Length - 3] = (byte)_disc;  	disk [disk.Length - 1] = (byte)_totalDiscs;  	stream.Write (disk);  }  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,WriteDiscAtom,The following statement contains a magic number: WriteInt32 (disk.Length - 8' disk' 8);  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,WriteDiscAtom,The following statement contains a magic number: WriteInt32 (disk.Length - 8' disk' 8);  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,WriteDiscAtom,The following statement contains a magic number: disk [disk.Length - 3] = (byte)_disc;  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,WriteCompilationAtom,The following statement contains a magic number: if (_isPartOfCompilation) {  	WriteInt32 (cpil.Length' cpil' 0);  	WriteInt32 (cpil.Length - 8' cpil' 8);  	cpil [cpil.Length - 1] = 1;  	stream.Write (cpil);  }  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,WriteCompilationAtom,The following statement contains a magic number: if (_isPartOfCompilation) {  	WriteInt32 (cpil.Length' cpil' 0);  	WriteInt32 (cpil.Length - 8' cpil' 8);  	cpil [cpil.Length - 1] = 1;  	stream.Write (cpil);  }  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,WriteCompilationAtom,The following statement contains a magic number: WriteInt32 (cpil.Length - 8' cpil' 8);  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,WriteCompilationAtom,The following statement contains a magic number: WriteInt32 (cpil.Length - 8' cpil' 8);  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,WriteBpmAtom,The following statement contains a magic number: if (_bpm > 0) {  	WriteInt32 (tmpo.Length' tmpo' 0);  	WriteInt32 (tmpo.Length - 8' tmpo' 8);  	WriteInt32 (_bpm' tmpo' tmpo.Length - 4);  	stream.Write (tmpo);  }  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,WriteBpmAtom,The following statement contains a magic number: if (_bpm > 0) {  	WriteInt32 (tmpo.Length' tmpo' 0);  	WriteInt32 (tmpo.Length - 8' tmpo' 8);  	WriteInt32 (_bpm' tmpo' tmpo.Length - 4);  	stream.Write (tmpo);  }  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,WriteBpmAtom,The following statement contains a magic number: if (_bpm > 0) {  	WriteInt32 (tmpo.Length' tmpo' 0);  	WriteInt32 (tmpo.Length - 8' tmpo' 8);  	WriteInt32 (_bpm' tmpo' tmpo.Length - 4);  	stream.Write (tmpo);  }  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,WriteBpmAtom,The following statement contains a magic number: WriteInt32 (tmpo.Length - 8' tmpo' 8);  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,WriteBpmAtom,The following statement contains a magic number: WriteInt32 (tmpo.Length - 8' tmpo' 8);  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,WriteBpmAtom,The following statement contains a magic number: WriteInt32 (_bpm' tmpo' tmpo.Length - 4);  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,CreateUDTA,The following statement contains a magic number: WriteInt32 (pos - 20 - hdlr.Length' fulltag' 20 + hdlr.Length);  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,CreateUDTA,The following statement contains a magic number: WriteInt32 (pos - 20 - hdlr.Length' fulltag' 20 + hdlr.Length);  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,CreateUDTA,The following statement contains a magic number: if (pos < (len + 8)) {  	WriteInt32 (len - pos' fulltag' pos);  	fulltag.Position = pos + 4;  	fulltag.Write (FREE_BYTES);  	fulltag.Write (new byte[len - pos - 8]);  	pos = len;  }  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,CreateUDTA,The following statement contains a magic number: if (pos < (len + 8)) {  	WriteInt32 (len - pos' fulltag' pos);  	fulltag.Position = pos + 4;  	fulltag.Write (FREE_BYTES);  	fulltag.Write (new byte[len - pos - 8]);  	pos = len;  }  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,CreateUDTA,The following statement contains a magic number: if (pos < (len + 8)) {  	WriteInt32 (len - pos' fulltag' pos);  	fulltag.Position = pos + 4;  	fulltag.Write (FREE_BYTES);  	fulltag.Write (new byte[len - pos - 8]);  	pos = len;  }  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,CreateUDTA,The following statement contains a magic number: fulltag.Position = pos + 4;  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,CreateUDTA,The following statement contains a magic number: fulltag.Write (new byte[len - pos - 8]);  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,CreateUDTA,The following statement contains a magic number: WriteInt32 (pos - 8' fulltag' 8);  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,CreateUDTA,The following statement contains a magic number: WriteInt32 (pos - 8' fulltag' 8);  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,CreateUDTA,The following statement contains a magic number: WriteInt32 (hdlr.Length' fulltag' 20);  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,MoovToEnd,The following statement contains a magic number: f.Seek (moovpos + 4' SeekOrigin.Begin);  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,Remove,The following statement contains a magic number: using (FileStream outf = File.Open (path' FileMode.Open' FileAccess.Write' FileShare.None)) {  	foreach (Atom atom in tag._atoms) {  		if (string.Compare (atom.name' "udta"' true) == 0) {  			outf.Seek (atom.pos + 4' SeekOrigin.Begin);  			outf.Write (FREE_BYTES);  		}  	}  }  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,Remove,The following statement contains a magic number: foreach (Atom atom in tag._atoms) {  	if (string.Compare (atom.name' "udta"' true) == 0) {  		outf.Seek (atom.pos + 4' SeekOrigin.Begin);  		outf.Write (FREE_BYTES);  	}  }  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,Remove,The following statement contains a magic number: if (string.Compare (atom.name' "udta"' true) == 0) {  	outf.Seek (atom.pos + 4' SeekOrigin.Begin);  	outf.Write (FREE_BYTES);  }  
Magic Number,IdSharp.Tagging.Mpeg4,Mpeg4Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\Mpeg4Tag\Mpeg4Tag.cs,Remove,The following statement contains a magic number: outf.Seek (atom.pos + 4' SeekOrigin.Begin);  
Magic Number,IdSharp.Tagging.VorbisComment,FlacMetaDataBlock,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\VorbisComment\FlacMetaDataBlock.cs,FlacMetaDataBlock,The following statement contains a magic number: if ((int)blockType > 6 || (int)blockType < 0) {  	throw new Exception (string.Format ("BlockType ({0}) out of range"' (int)blockType));  }  
Magic Number,IdSharp.Tagging.VorbisComment,VorbisComment,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\VorbisComment\VorbisComment.cs,WriteTagFlac,The following statement contains a magic number: foreach (FlacMetaDataBlock metaDataBlock in targetFile.MetaDataBlockList) {  	origMetaDataSize += 4;  	// Identifier + Size  	origMetaDataSize += metaDataBlock.Size;  	if (metaDataBlock.BlockType == FlacMetaDataBlockType.Padding) {  		paddingBlock = metaDataBlock;  	} else if (metaDataBlock.BlockType == FlacMetaDataBlockType.StreamInfo) {  		if (streamInfoBlock != null)  			throw new InvalidDataException ("Multiple stream info blocks");  		streamInfoBlock = metaDataBlock;  	} else if (metaDataBlock.BlockType == FlacMetaDataBlockType.SeekTable) {  		if (seekTableBlock != null)  			throw new InvalidDataException ("Multiple seek tables");  		seekTableBlock = metaDataBlock;  	}  }  
Magic Number,IdSharp.Tagging.VorbisComment,VorbisComment,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\VorbisComment\VorbisComment.cs,WriteTagFlac,The following statement contains a magic number: origMetaDataSize += 4;  
Magic Number,IdSharp.Tagging.VorbisComment,VorbisComment,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\VorbisComment\VorbisComment.cs,WriteTagFlac,The following statement contains a magic number: if (paddingBlock == null) {  	paddingBlock = new FlacMetaDataBlock (FlacMetaDataBlockType.Padding);  	paddingBlock.SetBlockDataZeroed (2000);  } // Padding block found' adjust size  else {  	// TODO: This is not entirely accurate' since we may be reading from one file  	// and writing to another.  The other blocks need to be accounted for' however for  	// same file read/write this works.  Not high priority.  	int adjustPadding = targetFile.OrigVorbisCommentSize - newTagArray.Length;  	int newSize = paddingBlock.Size + adjustPadding;  	if (newSize < 10)  		paddingBlock.SetBlockDataZeroed (2000);  	else  		paddingBlock.SetBlockDataZeroed (newSize);  }  
Magic Number,IdSharp.Tagging.VorbisComment,VorbisComment,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\VorbisComment\VorbisComment.cs,WriteTagFlac,The following statement contains a magic number: if (paddingBlock == null) {  	paddingBlock = new FlacMetaDataBlock (FlacMetaDataBlockType.Padding);  	paddingBlock.SetBlockDataZeroed (2000);  } // Padding block found' adjust size  else {  	// TODO: This is not entirely accurate' since we may be reading from one file  	// and writing to another.  The other blocks need to be accounted for' however for  	// same file read/write this works.  Not high priority.  	int adjustPadding = targetFile.OrigVorbisCommentSize - newTagArray.Length;  	int newSize = paddingBlock.Size + adjustPadding;  	if (newSize < 10)  		paddingBlock.SetBlockDataZeroed (2000);  	else  		paddingBlock.SetBlockDataZeroed (newSize);  }  
Magic Number,IdSharp.Tagging.VorbisComment,VorbisComment,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\VorbisComment\VorbisComment.cs,WriteTagFlac,The following statement contains a magic number: if (paddingBlock == null) {  	paddingBlock = new FlacMetaDataBlock (FlacMetaDataBlockType.Padding);  	paddingBlock.SetBlockDataZeroed (2000);  } // Padding block found' adjust size  else {  	// TODO: This is not entirely accurate' since we may be reading from one file  	// and writing to another.  The other blocks need to be accounted for' however for  	// same file read/write this works.  Not high priority.  	int adjustPadding = targetFile.OrigVorbisCommentSize - newTagArray.Length;  	int newSize = paddingBlock.Size + adjustPadding;  	if (newSize < 10)  		paddingBlock.SetBlockDataZeroed (2000);  	else  		paddingBlock.SetBlockDataZeroed (newSize);  }  
Magic Number,IdSharp.Tagging.VorbisComment,VorbisComment,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\VorbisComment\VorbisComment.cs,WriteTagFlac,The following statement contains a magic number: paddingBlock.SetBlockDataZeroed (2000);  
Magic Number,IdSharp.Tagging.VorbisComment,VorbisComment,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\VorbisComment\VorbisComment.cs,WriteTagFlac,The following statement contains a magic number: if (newSize < 10)  	paddingBlock.SetBlockDataZeroed (2000);  else  	paddingBlock.SetBlockDataZeroed (newSize);  
Magic Number,IdSharp.Tagging.VorbisComment,VorbisComment,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\VorbisComment\VorbisComment.cs,WriteTagFlac,The following statement contains a magic number: if (newSize < 10)  	paddingBlock.SetBlockDataZeroed (2000);  else  	paddingBlock.SetBlockDataZeroed (newSize);  
Magic Number,IdSharp.Tagging.VorbisComment,VorbisComment,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\VorbisComment\VorbisComment.cs,WriteTagFlac,The following statement contains a magic number: paddingBlock.SetBlockDataZeroed (2000);  
Magic Number,IdSharp.Tagging.VorbisComment,VorbisComment,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\VorbisComment\VorbisComment.cs,WriteTagFlac,The following statement contains a magic number: foreach (FlacMetaDataBlock metaDataBlock in myMetaDataBlocks) {  	newMetaDataSize += 4;  	// Identifier + Size  	newMetaDataSize += metaDataBlock.Size;  }  
Magic Number,IdSharp.Tagging.VorbisComment,VorbisComment,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\VorbisComment\VorbisComment.cs,WriteTagFlac,The following statement contains a magic number: newMetaDataSize += 4;  
Magic Number,IdSharp.Tagging.VorbisComment,VorbisComment,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\VorbisComment\VorbisComment.cs,WriteTagFlac,The following statement contains a magic number: if (newMetaDataSize != origMetaDataSize) {  	int newPaddingSize = paddingBlock.Size + (int)(origMetaDataSize - newMetaDataSize);  	if (newPaddingSize > 0) {  		paddingBlock.SetBlockDataZeroed (newPaddingSize);  		// Get new size of metadata blocks  		newMetaDataSize = 0;  		foreach (FlacMetaDataBlock metaDataBlock in myMetaDataBlocks) {  			newMetaDataSize += 4;  			// Identifier + Size  			newMetaDataSize += metaDataBlock.Size;  		}  	}  }  
Magic Number,IdSharp.Tagging.VorbisComment,VorbisComment,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\VorbisComment\VorbisComment.cs,WriteTagFlac,The following statement contains a magic number: if (newPaddingSize > 0) {  	paddingBlock.SetBlockDataZeroed (newPaddingSize);  	// Get new size of metadata blocks  	newMetaDataSize = 0;  	foreach (FlacMetaDataBlock metaDataBlock in myMetaDataBlocks) {  		newMetaDataSize += 4;  		// Identifier + Size  		newMetaDataSize += metaDataBlock.Size;  	}  }  
Magic Number,IdSharp.Tagging.VorbisComment,VorbisComment,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\VorbisComment\VorbisComment.cs,WriteTagFlac,The following statement contains a magic number: foreach (FlacMetaDataBlock metaDataBlock in myMetaDataBlocks) {  	newMetaDataSize += 4;  	// Identifier + Size  	newMetaDataSize += metaDataBlock.Size;  }  
Magic Number,IdSharp.Tagging.VorbisComment,VorbisComment,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\VorbisComment\VorbisComment.cs,WriteTagFlac,The following statement contains a magic number: newMetaDataSize += 4;  
Magic Number,IdSharp.Tagging.VorbisComment,VorbisComment,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\VorbisComment\VorbisComment.cs,WriteTagFlac,The following statement contains a magic number: if (newMetaDataSize == origMetaDataSize) {  	//  } // rewrite necessary - grab a snickers.  else if (newMetaDataSize > origMetaDataSize) {  	// rename  	tempFilename = PathUtils.GetTemporaryFileNameBasedOnFileName (path);  	File.Move (path' tempFilename);  	// open for read' open for write  	using (FileStream fsRead = File.Open (tempFilename' FileMode.Open' FileAccess.Read' FileShare.None))  		using (FileStream fsWrite = File.Open (path' FileMode.CreateNew' FileAccess.Write' FileShare.None)) {  			// copy ID3v2 tag.. technically there shouldn't be one' but we don't want to destroy data  			int tmpID3v2TagSize = ID3v2.ID3v2Tag.GetTagSize (fsRead);  			if (tmpID3v2TagSize != 0) {  				byte[] id3v2 = fsRead.Read (tmpID3v2TagSize);  				fsWrite.Write (id3v2);  			}  			fsWrite.Write (FLAC_MARKER);  			// create blankspace  			byte[] blankSpace = new Byte[newMetaDataSize];  			fsWrite.Write (blankSpace);  			fsRead.Seek (4 + origMetaDataSize' SeekOrigin.Current);  			byte[] buf = new byte[32768];  			int bytesRead = fsRead.Read (buf' 0' 32768);  			while (bytesRead != 0) {  				fsWrite.Write (buf' 0' bytesRead);  				bytesRead = fsRead.Read (buf' 0' 32768);  			}  		}  } // newMetaDataSize < origMetaDataSize is an error  else {  	throw new Exception (String.Format ("Internal Error: newMetaDataSize ({0}) < origMetaDataSize ({1})"' newMetaDataSize' origMetaDataSize));  }  
Magic Number,IdSharp.Tagging.VorbisComment,VorbisComment,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\VorbisComment\VorbisComment.cs,WriteTagFlac,The following statement contains a magic number: if (newMetaDataSize == origMetaDataSize) {  	//  } // rewrite necessary - grab a snickers.  else if (newMetaDataSize > origMetaDataSize) {  	// rename  	tempFilename = PathUtils.GetTemporaryFileNameBasedOnFileName (path);  	File.Move (path' tempFilename);  	// open for read' open for write  	using (FileStream fsRead = File.Open (tempFilename' FileMode.Open' FileAccess.Read' FileShare.None))  		using (FileStream fsWrite = File.Open (path' FileMode.CreateNew' FileAccess.Write' FileShare.None)) {  			// copy ID3v2 tag.. technically there shouldn't be one' but we don't want to destroy data  			int tmpID3v2TagSize = ID3v2.ID3v2Tag.GetTagSize (fsRead);  			if (tmpID3v2TagSize != 0) {  				byte[] id3v2 = fsRead.Read (tmpID3v2TagSize);  				fsWrite.Write (id3v2);  			}  			fsWrite.Write (FLAC_MARKER);  			// create blankspace  			byte[] blankSpace = new Byte[newMetaDataSize];  			fsWrite.Write (blankSpace);  			fsRead.Seek (4 + origMetaDataSize' SeekOrigin.Current);  			byte[] buf = new byte[32768];  			int bytesRead = fsRead.Read (buf' 0' 32768);  			while (bytesRead != 0) {  				fsWrite.Write (buf' 0' bytesRead);  				bytesRead = fsRead.Read (buf' 0' 32768);  			}  		}  } // newMetaDataSize < origMetaDataSize is an error  else {  	throw new Exception (String.Format ("Internal Error: newMetaDataSize ({0}) < origMetaDataSize ({1})"' newMetaDataSize' origMetaDataSize));  }  
Magic Number,IdSharp.Tagging.VorbisComment,VorbisComment,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\VorbisComment\VorbisComment.cs,WriteTagFlac,The following statement contains a magic number: if (newMetaDataSize == origMetaDataSize) {  	//  } // rewrite necessary - grab a snickers.  else if (newMetaDataSize > origMetaDataSize) {  	// rename  	tempFilename = PathUtils.GetTemporaryFileNameBasedOnFileName (path);  	File.Move (path' tempFilename);  	// open for read' open for write  	using (FileStream fsRead = File.Open (tempFilename' FileMode.Open' FileAccess.Read' FileShare.None))  		using (FileStream fsWrite = File.Open (path' FileMode.CreateNew' FileAccess.Write' FileShare.None)) {  			// copy ID3v2 tag.. technically there shouldn't be one' but we don't want to destroy data  			int tmpID3v2TagSize = ID3v2.ID3v2Tag.GetTagSize (fsRead);  			if (tmpID3v2TagSize != 0) {  				byte[] id3v2 = fsRead.Read (tmpID3v2TagSize);  				fsWrite.Write (id3v2);  			}  			fsWrite.Write (FLAC_MARKER);  			// create blankspace  			byte[] blankSpace = new Byte[newMetaDataSize];  			fsWrite.Write (blankSpace);  			fsRead.Seek (4 + origMetaDataSize' SeekOrigin.Current);  			byte[] buf = new byte[32768];  			int bytesRead = fsRead.Read (buf' 0' 32768);  			while (bytesRead != 0) {  				fsWrite.Write (buf' 0' bytesRead);  				bytesRead = fsRead.Read (buf' 0' 32768);  			}  		}  } // newMetaDataSize < origMetaDataSize is an error  else {  	throw new Exception (String.Format ("Internal Error: newMetaDataSize ({0}) < origMetaDataSize ({1})"' newMetaDataSize' origMetaDataSize));  }  
Magic Number,IdSharp.Tagging.VorbisComment,VorbisComment,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\VorbisComment\VorbisComment.cs,WriteTagFlac,The following statement contains a magic number: if (newMetaDataSize == origMetaDataSize) {  	//  } // rewrite necessary - grab a snickers.  else if (newMetaDataSize > origMetaDataSize) {  	// rename  	tempFilename = PathUtils.GetTemporaryFileNameBasedOnFileName (path);  	File.Move (path' tempFilename);  	// open for read' open for write  	using (FileStream fsRead = File.Open (tempFilename' FileMode.Open' FileAccess.Read' FileShare.None))  		using (FileStream fsWrite = File.Open (path' FileMode.CreateNew' FileAccess.Write' FileShare.None)) {  			// copy ID3v2 tag.. technically there shouldn't be one' but we don't want to destroy data  			int tmpID3v2TagSize = ID3v2.ID3v2Tag.GetTagSize (fsRead);  			if (tmpID3v2TagSize != 0) {  				byte[] id3v2 = fsRead.Read (tmpID3v2TagSize);  				fsWrite.Write (id3v2);  			}  			fsWrite.Write (FLAC_MARKER);  			// create blankspace  			byte[] blankSpace = new Byte[newMetaDataSize];  			fsWrite.Write (blankSpace);  			fsRead.Seek (4 + origMetaDataSize' SeekOrigin.Current);  			byte[] buf = new byte[32768];  			int bytesRead = fsRead.Read (buf' 0' 32768);  			while (bytesRead != 0) {  				fsWrite.Write (buf' 0' bytesRead);  				bytesRead = fsRead.Read (buf' 0' 32768);  			}  		}  } // newMetaDataSize < origMetaDataSize is an error  else {  	throw new Exception (String.Format ("Internal Error: newMetaDataSize ({0}) < origMetaDataSize ({1})"' newMetaDataSize' origMetaDataSize));  }  
Magic Number,IdSharp.Tagging.VorbisComment,VorbisComment,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\VorbisComment\VorbisComment.cs,WriteTagFlac,The following statement contains a magic number: if (newMetaDataSize > origMetaDataSize) {  	// rename  	tempFilename = PathUtils.GetTemporaryFileNameBasedOnFileName (path);  	File.Move (path' tempFilename);  	// open for read' open for write  	using (FileStream fsRead = File.Open (tempFilename' FileMode.Open' FileAccess.Read' FileShare.None))  		using (FileStream fsWrite = File.Open (path' FileMode.CreateNew' FileAccess.Write' FileShare.None)) {  			// copy ID3v2 tag.. technically there shouldn't be one' but we don't want to destroy data  			int tmpID3v2TagSize = ID3v2.ID3v2Tag.GetTagSize (fsRead);  			if (tmpID3v2TagSize != 0) {  				byte[] id3v2 = fsRead.Read (tmpID3v2TagSize);  				fsWrite.Write (id3v2);  			}  			fsWrite.Write (FLAC_MARKER);  			// create blankspace  			byte[] blankSpace = new Byte[newMetaDataSize];  			fsWrite.Write (blankSpace);  			fsRead.Seek (4 + origMetaDataSize' SeekOrigin.Current);  			byte[] buf = new byte[32768];  			int bytesRead = fsRead.Read (buf' 0' 32768);  			while (bytesRead != 0) {  				fsWrite.Write (buf' 0' bytesRead);  				bytesRead = fsRead.Read (buf' 0' 32768);  			}  		}  } // newMetaDataSize < origMetaDataSize is an error  else {  	throw new Exception (String.Format ("Internal Error: newMetaDataSize ({0}) < origMetaDataSize ({1})"' newMetaDataSize' origMetaDataSize));  }  
Magic Number,IdSharp.Tagging.VorbisComment,VorbisComment,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\VorbisComment\VorbisComment.cs,WriteTagFlac,The following statement contains a magic number: if (newMetaDataSize > origMetaDataSize) {  	// rename  	tempFilename = PathUtils.GetTemporaryFileNameBasedOnFileName (path);  	File.Move (path' tempFilename);  	// open for read' open for write  	using (FileStream fsRead = File.Open (tempFilename' FileMode.Open' FileAccess.Read' FileShare.None))  		using (FileStream fsWrite = File.Open (path' FileMode.CreateNew' FileAccess.Write' FileShare.None)) {  			// copy ID3v2 tag.. technically there shouldn't be one' but we don't want to destroy data  			int tmpID3v2TagSize = ID3v2.ID3v2Tag.GetTagSize (fsRead);  			if (tmpID3v2TagSize != 0) {  				byte[] id3v2 = fsRead.Read (tmpID3v2TagSize);  				fsWrite.Write (id3v2);  			}  			fsWrite.Write (FLAC_MARKER);  			// create blankspace  			byte[] blankSpace = new Byte[newMetaDataSize];  			fsWrite.Write (blankSpace);  			fsRead.Seek (4 + origMetaDataSize' SeekOrigin.Current);  			byte[] buf = new byte[32768];  			int bytesRead = fsRead.Read (buf' 0' 32768);  			while (bytesRead != 0) {  				fsWrite.Write (buf' 0' bytesRead);  				bytesRead = fsRead.Read (buf' 0' 32768);  			}  		}  } // newMetaDataSize < origMetaDataSize is an error  else {  	throw new Exception (String.Format ("Internal Error: newMetaDataSize ({0}) < origMetaDataSize ({1})"' newMetaDataSize' origMetaDataSize));  }  
Magic Number,IdSharp.Tagging.VorbisComment,VorbisComment,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\VorbisComment\VorbisComment.cs,WriteTagFlac,The following statement contains a magic number: if (newMetaDataSize > origMetaDataSize) {  	// rename  	tempFilename = PathUtils.GetTemporaryFileNameBasedOnFileName (path);  	File.Move (path' tempFilename);  	// open for read' open for write  	using (FileStream fsRead = File.Open (tempFilename' FileMode.Open' FileAccess.Read' FileShare.None))  		using (FileStream fsWrite = File.Open (path' FileMode.CreateNew' FileAccess.Write' FileShare.None)) {  			// copy ID3v2 tag.. technically there shouldn't be one' but we don't want to destroy data  			int tmpID3v2TagSize = ID3v2.ID3v2Tag.GetTagSize (fsRead);  			if (tmpID3v2TagSize != 0) {  				byte[] id3v2 = fsRead.Read (tmpID3v2TagSize);  				fsWrite.Write (id3v2);  			}  			fsWrite.Write (FLAC_MARKER);  			// create blankspace  			byte[] blankSpace = new Byte[newMetaDataSize];  			fsWrite.Write (blankSpace);  			fsRead.Seek (4 + origMetaDataSize' SeekOrigin.Current);  			byte[] buf = new byte[32768];  			int bytesRead = fsRead.Read (buf' 0' 32768);  			while (bytesRead != 0) {  				fsWrite.Write (buf' 0' bytesRead);  				bytesRead = fsRead.Read (buf' 0' 32768);  			}  		}  } // newMetaDataSize < origMetaDataSize is an error  else {  	throw new Exception (String.Format ("Internal Error: newMetaDataSize ({0}) < origMetaDataSize ({1})"' newMetaDataSize' origMetaDataSize));  }  
Magic Number,IdSharp.Tagging.VorbisComment,VorbisComment,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\VorbisComment\VorbisComment.cs,WriteTagFlac,The following statement contains a magic number: if (newMetaDataSize > origMetaDataSize) {  	// rename  	tempFilename = PathUtils.GetTemporaryFileNameBasedOnFileName (path);  	File.Move (path' tempFilename);  	// open for read' open for write  	using (FileStream fsRead = File.Open (tempFilename' FileMode.Open' FileAccess.Read' FileShare.None))  		using (FileStream fsWrite = File.Open (path' FileMode.CreateNew' FileAccess.Write' FileShare.None)) {  			// copy ID3v2 tag.. technically there shouldn't be one' but we don't want to destroy data  			int tmpID3v2TagSize = ID3v2.ID3v2Tag.GetTagSize (fsRead);  			if (tmpID3v2TagSize != 0) {  				byte[] id3v2 = fsRead.Read (tmpID3v2TagSize);  				fsWrite.Write (id3v2);  			}  			fsWrite.Write (FLAC_MARKER);  			// create blankspace  			byte[] blankSpace = new Byte[newMetaDataSize];  			fsWrite.Write (blankSpace);  			fsRead.Seek (4 + origMetaDataSize' SeekOrigin.Current);  			byte[] buf = new byte[32768];  			int bytesRead = fsRead.Read (buf' 0' 32768);  			while (bytesRead != 0) {  				fsWrite.Write (buf' 0' bytesRead);  				bytesRead = fsRead.Read (buf' 0' 32768);  			}  		}  } // newMetaDataSize < origMetaDataSize is an error  else {  	throw new Exception (String.Format ("Internal Error: newMetaDataSize ({0}) < origMetaDataSize ({1})"' newMetaDataSize' origMetaDataSize));  }  
Magic Number,IdSharp.Tagging.VorbisComment,VorbisComment,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\VorbisComment\VorbisComment.cs,WriteTagFlac,The following statement contains a magic number: using (FileStream fsRead = File.Open (tempFilename' FileMode.Open' FileAccess.Read' FileShare.None))  	using (FileStream fsWrite = File.Open (path' FileMode.CreateNew' FileAccess.Write' FileShare.None)) {  		// copy ID3v2 tag.. technically there shouldn't be one' but we don't want to destroy data  		int tmpID3v2TagSize = ID3v2.ID3v2Tag.GetTagSize (fsRead);  		if (tmpID3v2TagSize != 0) {  			byte[] id3v2 = fsRead.Read (tmpID3v2TagSize);  			fsWrite.Write (id3v2);  		}  		fsWrite.Write (FLAC_MARKER);  		// create blankspace  		byte[] blankSpace = new Byte[newMetaDataSize];  		fsWrite.Write (blankSpace);  		fsRead.Seek (4 + origMetaDataSize' SeekOrigin.Current);  		byte[] buf = new byte[32768];  		int bytesRead = fsRead.Read (buf' 0' 32768);  		while (bytesRead != 0) {  			fsWrite.Write (buf' 0' bytesRead);  			bytesRead = fsRead.Read (buf' 0' 32768);  		}  	}  
Magic Number,IdSharp.Tagging.VorbisComment,VorbisComment,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\VorbisComment\VorbisComment.cs,WriteTagFlac,The following statement contains a magic number: using (FileStream fsRead = File.Open (tempFilename' FileMode.Open' FileAccess.Read' FileShare.None))  	using (FileStream fsWrite = File.Open (path' FileMode.CreateNew' FileAccess.Write' FileShare.None)) {  		// copy ID3v2 tag.. technically there shouldn't be one' but we don't want to destroy data  		int tmpID3v2TagSize = ID3v2.ID3v2Tag.GetTagSize (fsRead);  		if (tmpID3v2TagSize != 0) {  			byte[] id3v2 = fsRead.Read (tmpID3v2TagSize);  			fsWrite.Write (id3v2);  		}  		fsWrite.Write (FLAC_MARKER);  		// create blankspace  		byte[] blankSpace = new Byte[newMetaDataSize];  		fsWrite.Write (blankSpace);  		fsRead.Seek (4 + origMetaDataSize' SeekOrigin.Current);  		byte[] buf = new byte[32768];  		int bytesRead = fsRead.Read (buf' 0' 32768);  		while (bytesRead != 0) {  			fsWrite.Write (buf' 0' bytesRead);  			bytesRead = fsRead.Read (buf' 0' 32768);  		}  	}  
Magic Number,IdSharp.Tagging.VorbisComment,VorbisComment,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\VorbisComment\VorbisComment.cs,WriteTagFlac,The following statement contains a magic number: using (FileStream fsRead = File.Open (tempFilename' FileMode.Open' FileAccess.Read' FileShare.None))  	using (FileStream fsWrite = File.Open (path' FileMode.CreateNew' FileAccess.Write' FileShare.None)) {  		// copy ID3v2 tag.. technically there shouldn't be one' but we don't want to destroy data  		int tmpID3v2TagSize = ID3v2.ID3v2Tag.GetTagSize (fsRead);  		if (tmpID3v2TagSize != 0) {  			byte[] id3v2 = fsRead.Read (tmpID3v2TagSize);  			fsWrite.Write (id3v2);  		}  		fsWrite.Write (FLAC_MARKER);  		// create blankspace  		byte[] blankSpace = new Byte[newMetaDataSize];  		fsWrite.Write (blankSpace);  		fsRead.Seek (4 + origMetaDataSize' SeekOrigin.Current);  		byte[] buf = new byte[32768];  		int bytesRead = fsRead.Read (buf' 0' 32768);  		while (bytesRead != 0) {  			fsWrite.Write (buf' 0' bytesRead);  			bytesRead = fsRead.Read (buf' 0' 32768);  		}  	}  
Magic Number,IdSharp.Tagging.VorbisComment,VorbisComment,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\VorbisComment\VorbisComment.cs,WriteTagFlac,The following statement contains a magic number: using (FileStream fsRead = File.Open (tempFilename' FileMode.Open' FileAccess.Read' FileShare.None))  	using (FileStream fsWrite = File.Open (path' FileMode.CreateNew' FileAccess.Write' FileShare.None)) {  		// copy ID3v2 tag.. technically there shouldn't be one' but we don't want to destroy data  		int tmpID3v2TagSize = ID3v2.ID3v2Tag.GetTagSize (fsRead);  		if (tmpID3v2TagSize != 0) {  			byte[] id3v2 = fsRead.Read (tmpID3v2TagSize);  			fsWrite.Write (id3v2);  		}  		fsWrite.Write (FLAC_MARKER);  		// create blankspace  		byte[] blankSpace = new Byte[newMetaDataSize];  		fsWrite.Write (blankSpace);  		fsRead.Seek (4 + origMetaDataSize' SeekOrigin.Current);  		byte[] buf = new byte[32768];  		int bytesRead = fsRead.Read (buf' 0' 32768);  		while (bytesRead != 0) {  			fsWrite.Write (buf' 0' bytesRead);  			bytesRead = fsRead.Read (buf' 0' 32768);  		}  	}  
Magic Number,IdSharp.Tagging.VorbisComment,VorbisComment,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\VorbisComment\VorbisComment.cs,WriteTagFlac,The following statement contains a magic number: using (FileStream fsWrite = File.Open (path' FileMode.CreateNew' FileAccess.Write' FileShare.None)) {  	// copy ID3v2 tag.. technically there shouldn't be one' but we don't want to destroy data  	int tmpID3v2TagSize = ID3v2.ID3v2Tag.GetTagSize (fsRead);  	if (tmpID3v2TagSize != 0) {  		byte[] id3v2 = fsRead.Read (tmpID3v2TagSize);  		fsWrite.Write (id3v2);  	}  	fsWrite.Write (FLAC_MARKER);  	// create blankspace  	byte[] blankSpace = new Byte[newMetaDataSize];  	fsWrite.Write (blankSpace);  	fsRead.Seek (4 + origMetaDataSize' SeekOrigin.Current);  	byte[] buf = new byte[32768];  	int bytesRead = fsRead.Read (buf' 0' 32768);  	while (bytesRead != 0) {  		fsWrite.Write (buf' 0' bytesRead);  		bytesRead = fsRead.Read (buf' 0' 32768);  	}  }  
Magic Number,IdSharp.Tagging.VorbisComment,VorbisComment,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\VorbisComment\VorbisComment.cs,WriteTagFlac,The following statement contains a magic number: using (FileStream fsWrite = File.Open (path' FileMode.CreateNew' FileAccess.Write' FileShare.None)) {  	// copy ID3v2 tag.. technically there shouldn't be one' but we don't want to destroy data  	int tmpID3v2TagSize = ID3v2.ID3v2Tag.GetTagSize (fsRead);  	if (tmpID3v2TagSize != 0) {  		byte[] id3v2 = fsRead.Read (tmpID3v2TagSize);  		fsWrite.Write (id3v2);  	}  	fsWrite.Write (FLAC_MARKER);  	// create blankspace  	byte[] blankSpace = new Byte[newMetaDataSize];  	fsWrite.Write (blankSpace);  	fsRead.Seek (4 + origMetaDataSize' SeekOrigin.Current);  	byte[] buf = new byte[32768];  	int bytesRead = fsRead.Read (buf' 0' 32768);  	while (bytesRead != 0) {  		fsWrite.Write (buf' 0' bytesRead);  		bytesRead = fsRead.Read (buf' 0' 32768);  	}  }  
Magic Number,IdSharp.Tagging.VorbisComment,VorbisComment,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\VorbisComment\VorbisComment.cs,WriteTagFlac,The following statement contains a magic number: using (FileStream fsWrite = File.Open (path' FileMode.CreateNew' FileAccess.Write' FileShare.None)) {  	// copy ID3v2 tag.. technically there shouldn't be one' but we don't want to destroy data  	int tmpID3v2TagSize = ID3v2.ID3v2Tag.GetTagSize (fsRead);  	if (tmpID3v2TagSize != 0) {  		byte[] id3v2 = fsRead.Read (tmpID3v2TagSize);  		fsWrite.Write (id3v2);  	}  	fsWrite.Write (FLAC_MARKER);  	// create blankspace  	byte[] blankSpace = new Byte[newMetaDataSize];  	fsWrite.Write (blankSpace);  	fsRead.Seek (4 + origMetaDataSize' SeekOrigin.Current);  	byte[] buf = new byte[32768];  	int bytesRead = fsRead.Read (buf' 0' 32768);  	while (bytesRead != 0) {  		fsWrite.Write (buf' 0' bytesRead);  		bytesRead = fsRead.Read (buf' 0' 32768);  	}  }  
Magic Number,IdSharp.Tagging.VorbisComment,VorbisComment,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\VorbisComment\VorbisComment.cs,WriteTagFlac,The following statement contains a magic number: using (FileStream fsWrite = File.Open (path' FileMode.CreateNew' FileAccess.Write' FileShare.None)) {  	// copy ID3v2 tag.. technically there shouldn't be one' but we don't want to destroy data  	int tmpID3v2TagSize = ID3v2.ID3v2Tag.GetTagSize (fsRead);  	if (tmpID3v2TagSize != 0) {  		byte[] id3v2 = fsRead.Read (tmpID3v2TagSize);  		fsWrite.Write (id3v2);  	}  	fsWrite.Write (FLAC_MARKER);  	// create blankspace  	byte[] blankSpace = new Byte[newMetaDataSize];  	fsWrite.Write (blankSpace);  	fsRead.Seek (4 + origMetaDataSize' SeekOrigin.Current);  	byte[] buf = new byte[32768];  	int bytesRead = fsRead.Read (buf' 0' 32768);  	while (bytesRead != 0) {  		fsWrite.Write (buf' 0' bytesRead);  		bytesRead = fsRead.Read (buf' 0' 32768);  	}  }  
Magic Number,IdSharp.Tagging.VorbisComment,VorbisComment,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\VorbisComment\VorbisComment.cs,WriteTagFlac,The following statement contains a magic number: fsRead.Seek (4 + origMetaDataSize' SeekOrigin.Current);  
Magic Number,IdSharp.Tagging.VorbisComment,VorbisComment,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\VorbisComment\VorbisComment.cs,WriteTagFlac,The following statement contains a magic number: while (bytesRead != 0) {  	fsWrite.Write (buf' 0' bytesRead);  	bytesRead = fsRead.Read (buf' 0' 32768);  }  
Magic Number,IdSharp.Tagging.VorbisComment,VorbisComment,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\VorbisComment\VorbisComment.cs,WriteTagFlac,The following statement contains a magic number: bytesRead = fsRead.Read (buf' 0' 32768);  
Magic Number,IdSharp.Tagging.VorbisComment,VorbisComment,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\VorbisComment\VorbisComment.cs,WriteTagFlac,The following statement contains a magic number: using (FileStream fs = File.Open (path' FileMode.Open' FileAccess.ReadWrite' FileShare.None)) {  	// skip fLaC marker and ID3v2 tag size  	int tmpID3v2TagSize = ID3v2.ID3v2Tag.GetTagSize (fs);  	fs.Position = tmpID3v2TagSize + 4;  	byte blockType;  	foreach (FlacMetaDataBlock metaDataBlock in myMetaDataBlocks) {  		// always write padding last  		if (metaDataBlock == paddingBlock)  			continue;  		blockType = (byte)metaDataBlock.BlockType;  		fs.WriteByte (blockType);  		fs.WriteInt24 (metaDataBlock.Size);  		fs.Write (metaDataBlock.BlockData);  	}  	// write padding' add stop bit to block type  	blockType = (byte)(paddingBlock.BlockType + 0x80);  	fs.WriteByte (blockType);  	fs.WriteInt24 (paddingBlock.Size);  	fs.Write (paddingBlock.BlockData);  }  
Magic Number,IdSharp.Tagging.VorbisComment,VorbisComment,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\VorbisComment\VorbisComment.cs,WriteTagFlac,The following statement contains a magic number: fs.Position = tmpID3v2TagSize + 4;  
Magic Number,IdSharp.Tagging.VorbisComment,VorbisComment,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\VorbisComment\VorbisComment.cs,ReadTag_VorbisComment,The following statement contains a magic number: for (; elements > 0; elements--) {  	size = stream.ReadInt32LittleEndian ();  	string text = stream.ReadUTF8 (size);  	string[] nameValue = text.Split ("=".ToCharArray ()' 2' StringSplitOptions.RemoveEmptyEntries);  	if (nameValue.Length == 2) {  		string name = nameValue [0];  		string value = nameValue [1];  		_items.Add (new NameValueItem (name' value));  	}  }  
Magic Number,IdSharp.Tagging.VorbisComment,VorbisComment,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\VorbisComment\VorbisComment.cs,ReadTag_VorbisComment,The following statement contains a magic number: for (; elements > 0; elements--) {  	size = stream.ReadInt32LittleEndian ();  	string text = stream.ReadUTF8 (size);  	string[] nameValue = text.Split ("=".ToCharArray ()' 2' StringSplitOptions.RemoveEmptyEntries);  	if (nameValue.Length == 2) {  		string name = nameValue [0];  		string value = nameValue [1];  		_items.Add (new NameValueItem (name' value));  	}  }  
Magic Number,IdSharp.Tagging.VorbisComment,VorbisComment,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\VorbisComment\VorbisComment.cs,ReadTag_VorbisComment,The following statement contains a magic number: if (nameValue.Length == 2) {  	string name = nameValue [0];  	string value = nameValue [1];  	_items.Add (new NameValueItem (name' value));  }  
Magic Number,IdSharp.Tagging.VorbisComment,VorbisComment,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\VorbisComment\VorbisComment.cs,ReadTag_FLAC,The following statement contains a magic number: stream.Seek (4' SeekOrigin.Current);  
Magic Number,IdSharp.Tagging.VorbisComment,VorbisComment,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\VorbisComment\VorbisComment.cs,ReadTag_FLAC,The following statement contains a magic number: do {  	int c = stream.ReadByte ();  	isLastMetaDataBlock = (((c >> 7) & 0x01) == 1);  	int blocksize = stream.ReadInt24 ();  	FlacMetaDataBlockType blockType = (FlacMetaDataBlockType)(c & 0x07);  	if (blockType == FlacMetaDataBlockType.VorbisComment)// Vorbis comment  	 {  		info.OrigVorbisCommentSize = blocksize;  		long mvcoffset = stream.Position - 4;  		ReadTag_VorbisComment (stream);  		stream.Seek (mvcoffset + 4' SeekOrigin.Begin);  	}  	FlacMetaDataBlock metaDataBlock = new FlacMetaDataBlock (blockType);  	metaDataBlock.SetBlockData (stream' blocksize);  	metaDataBlockList.Add (metaDataBlock);  } while (isLastMetaDataBlock == false);  
Magic Number,IdSharp.Tagging.VorbisComment,VorbisComment,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\VorbisComment\VorbisComment.cs,ReadTag_FLAC,The following statement contains a magic number: do {  	int c = stream.ReadByte ();  	isLastMetaDataBlock = (((c >> 7) & 0x01) == 1);  	int blocksize = stream.ReadInt24 ();  	FlacMetaDataBlockType blockType = (FlacMetaDataBlockType)(c & 0x07);  	if (blockType == FlacMetaDataBlockType.VorbisComment)// Vorbis comment  	 {  		info.OrigVorbisCommentSize = blocksize;  		long mvcoffset = stream.Position - 4;  		ReadTag_VorbisComment (stream);  		stream.Seek (mvcoffset + 4' SeekOrigin.Begin);  	}  	FlacMetaDataBlock metaDataBlock = new FlacMetaDataBlock (blockType);  	metaDataBlock.SetBlockData (stream' blocksize);  	metaDataBlockList.Add (metaDataBlock);  } while (isLastMetaDataBlock == false);  
Magic Number,IdSharp.Tagging.VorbisComment,VorbisComment,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\VorbisComment\VorbisComment.cs,ReadTag_FLAC,The following statement contains a magic number: do {  	int c = stream.ReadByte ();  	isLastMetaDataBlock = (((c >> 7) & 0x01) == 1);  	int blocksize = stream.ReadInt24 ();  	FlacMetaDataBlockType blockType = (FlacMetaDataBlockType)(c & 0x07);  	if (blockType == FlacMetaDataBlockType.VorbisComment)// Vorbis comment  	 {  		info.OrigVorbisCommentSize = blocksize;  		long mvcoffset = stream.Position - 4;  		ReadTag_VorbisComment (stream);  		stream.Seek (mvcoffset + 4' SeekOrigin.Begin);  	}  	FlacMetaDataBlock metaDataBlock = new FlacMetaDataBlock (blockType);  	metaDataBlock.SetBlockData (stream' blocksize);  	metaDataBlockList.Add (metaDataBlock);  } while (isLastMetaDataBlock == false);  
Magic Number,IdSharp.Tagging.VorbisComment,VorbisComment,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\VorbisComment\VorbisComment.cs,ReadTag_FLAC,The following statement contains a magic number: isLastMetaDataBlock = (((c >> 7) & 0x01) == 1);  
Magic Number,IdSharp.Tagging.VorbisComment,VorbisComment,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\VorbisComment\VorbisComment.cs,ReadTag_FLAC,The following statement contains a magic number: if (blockType == FlacMetaDataBlockType.VorbisComment)// Vorbis comment   {  	info.OrigVorbisCommentSize = blocksize;  	long mvcoffset = stream.Position - 4;  	ReadTag_VorbisComment (stream);  	stream.Seek (mvcoffset + 4' SeekOrigin.Begin);  }  
Magic Number,IdSharp.Tagging.VorbisComment,VorbisComment,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\VorbisComment\VorbisComment.cs,ReadTag_FLAC,The following statement contains a magic number: if (blockType == FlacMetaDataBlockType.VorbisComment)// Vorbis comment   {  	info.OrigVorbisCommentSize = blocksize;  	long mvcoffset = stream.Position - 4;  	ReadTag_VorbisComment (stream);  	stream.Seek (mvcoffset + 4' SeekOrigin.Begin);  }  
Magic Number,IdSharp.Tagging.VorbisComment,VorbisComment,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\VorbisComment\VorbisComment.cs,ReadTag_FLAC,The following statement contains a magic number: stream.Seek (mvcoffset + 4' SeekOrigin.Begin);  
Magic Number,IdSharp.Tagging.VorbisComment,VorbisComment,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\VorbisComment\VorbisComment.cs,IsFlac,The following statement contains a magic number: stream.Read (flacMarker' 0' 4);  
Magic Number,IdSharp.Tagging.VorbisComment,VorbisComment,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\VorbisComment\VorbisComment.cs,IsFlac,The following statement contains a magic number: stream.Seek (-4' SeekOrigin.Current);  
Duplicate Code,IdSharp.Tagging.ID3v2,ID3v2Utils,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\ID3v2Utils.cs,GetStringBytes,The method contains a code clone-set at the following line numbers (starting from the method definition): ((5' 25)' (27' 47))
Duplicate Code,IdSharp.Tagging.ID3v2,ID3v2Utils,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\ID3v2Utils.cs,GetStringBytes,The method contains a code clone-set at the following line numbers (starting from the method definition): ((6' 25)' (68' 87)' (28' 47))
Duplicate Code,IdSharp.Tagging.ID3v2,ID3v2Utils,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\ID3v2Utils.cs,ReadString,The method contains a code clone-set at the following line numbers (starting from the method definition): ((31' 53)' (66' 88))
Missing Default,IdSharp.Tagging.APEv2,APEv2Tag,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\APEv2\APEv2Tag.cs,ReadField,The following switch statement is missing a default case: switch (itemKey) {  case "TITLE":  	Title = itemValue;  	break;  case "ARTIST":  	Artist = itemValue;  	break;  case "ALBUM":  	Album = itemValue;  	break;  case "PUBLISHER":  	Publisher = itemValue;  	break;  case "TRACK":  	TrackNumber = itemValue;  	break;  case "COMMENT":  	Comment = itemValue;  	break;  case "CATALOG":  	Catalog = itemValue;  	break;  case "YEAR":  	Year = itemValue;  	break;  case "RECORD DATE":  	RecordDate = itemValue;  	break;  case "GENRE":  	Genre = itemValue;  	break;  case "MEDIA":  	Media = itemValue;  	break;  case "LANGUAGE":  	Language = itemValue;  	break;  }  
Missing Default,IdSharp.Tagging.ID3v2,ID3v2Header,F:\newReposMay17\judwhite_IdSharp\IdSharp.Tagging\ID3v2\Classes\ID3v2Header.cs,Read,The following switch statement is missing a default case: switch (_tagVersion) {  case ID3v2TagVersion.ID3v23:  	UsesUnsynchronization = ((tmpHeader [2] & 0x80) == 0x80);  	/*if (this.UsesUnsynchronization == true)                         {                             Console.WriteLine(((FileStream)stream).Name);                         }*/_hasExtendedHeader = ((tmpHeader [2] & 0x40) == 0x40);  	_isExperimental = ((tmpHeader [2] & 0x20) == 0x20);  	_isFooterPresent = false;  	_isCompressed = false;  	break;  case ID3v2TagVersion.ID3v22:  	_usesUnsynchronization = ((tmpHeader [2] & 0x80) == 0x80);  	_isFooterPresent = false;  	_isCompressed = ((tmpHeader [2] & 0x40) == 0x40);  	break;  case ID3v2TagVersion.ID3v24:  	_usesUnsynchronization = ((tmpHeader [2] & 0x80) == 0x80);  	_hasExtendedHeader = ((tmpHeader [2] & 0x40) == 0x40);  	_isExperimental = ((tmpHeader [2] & 0x20) == 0x20);  	_isFooterPresent = ((tmpHeader [2] & 0x10) == 0x10);  	_isCompressed = false;  	break;  }  
