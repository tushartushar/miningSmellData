Implementation smell,Namespace,Class,File,Method,Description
Long Method,LWF,Movie,C:\repos\ycchiu_Unity\FuseSparxDemo\Assets\Scripts\UI\Flash\lwf\core\lwf_movie.cs,PostExec,The method has 184 lines of code.
Long Method,BitmapFont,Renderer,C:\repos\ycchiu_Unity\FuseSparxDemo\Assets\Scripts\UI\Flash\lwf\renderer\bitmapfont\bitmapfont_renderer.cs,SetText,The method has 176 lines of code.
Complex Method,LWF,LWF,C:\repos\ycchiu_Unity\FuseSparxDemo\Assets\Scripts\UI\Flash\lwf\core\lwf_animation.cs,PlayAnimation,Cyclomatic complexity of the method is 43
Complex Method,LWF,ButtonEventHandlers,C:\repos\ycchiu_Unity\FuseSparxDemo\Assets\Scripts\UI\Flash\lwf\core\lwf_eventbutton.cs,Clear,Cyclomatic complexity of the method is 30
Complex Method,LWF,ButtonEventHandlers,C:\repos\ycchiu_Unity\FuseSparxDemo\Assets\Scripts\UI\Flash\lwf\core\lwf_eventbutton.cs,Add,Cyclomatic complexity of the method is 11
Complex Method,LWF,ButtonEventHandlers,C:\repos\ycchiu_Unity\FuseSparxDemo\Assets\Scripts\UI\Flash\lwf\core\lwf_eventbutton.cs,Remove,Cyclomatic complexity of the method is 11
Complex Method,LWF,ButtonEventHandlers,C:\repos\ycchiu_Unity\FuseSparxDemo\Assets\Scripts\UI\Flash\lwf\core\lwf_eventbutton.cs,Call,Cyclomatic complexity of the method is 29
Complex Method,LWF,MovieEventHandlers,C:\repos\ycchiu_Unity\FuseSparxDemo\Assets\Scripts\UI\Flash\lwf\core\lwf_eventmovie.cs,Clear,Cyclomatic complexity of the method is 18
Complex Method,LWF,MovieEventHandlers,C:\repos\ycchiu_Unity\FuseSparxDemo\Assets\Scripts\UI\Flash\lwf\core\lwf_eventmovie.cs,Call,Cyclomatic complexity of the method is 20
Complex Method,LWF,Graphic,C:\repos\ycchiu_Unity\FuseSparxDemo\Assets\Scripts\UI\Flash\lwf\core\lwf_graphic.cs,Graphic,Cyclomatic complexity of the method is 11
Complex Method,LWF,Movie,C:\repos\ycchiu_Unity\FuseSparxDemo\Assets\Scripts\UI\Flash\lwf\core\lwf_movie.cs,ExecObject,Cyclomatic complexity of the method is 32
Complex Method,LWF,Movie,C:\repos\ycchiu_Unity\FuseSparxDemo\Assets\Scripts\UI\Flash\lwf\core\lwf_movie.cs,PostExec,Cyclomatic complexity of the method is 55
Complex Method,LWF,Movie,C:\repos\ycchiu_Unity\FuseSparxDemo\Assets\Scripts\UI\Flash\lwf\core\lwf_movie.cs,Update,Cyclomatic complexity of the method is 16
Complex Method,LWF,Movie,C:\repos\ycchiu_Unity\FuseSparxDemo\Assets\Scripts\UI\Flash\lwf\core\lwf_movie.cs,LinkButton,Cyclomatic complexity of the method is 14
Complex Method,LWF,Movie,C:\repos\ycchiu_Unity\FuseSparxDemo\Assets\Scripts\UI\Flash\lwf\core\lwf_movie.cs,Render,Cyclomatic complexity of the method is 26
Complex Method,LWF,Movie,C:\repos\ycchiu_Unity\FuseSparxDemo\Assets\Scripts\UI\Flash\lwf\core\lwf_movie.cs,RenderNow,Cyclomatic complexity of the method is 10
Complex Method,LWF,Movie,C:\repos\ycchiu_Unity\FuseSparxDemo\Assets\Scripts\UI\Flash\lwf\core\lwf_movie.cs,Inspect,Cyclomatic complexity of the method is 12
Complex Method,LWF,Movie,C:\repos\ycchiu_Unity\FuseSparxDemo\Assets\Scripts\UI\Flash\lwf\core\lwf_movie.cs,Destroy,Cyclomatic complexity of the method is 11
Complex Method,LWF,Movie,C:\repos\ycchiu_Unity\FuseSparxDemo\Assets\Scripts\UI\Flash\lwf\core\lwf_movie.cs,SearchMovieInstance,Cyclomatic complexity of the method is 10
Complex Method,BitmapFont,Renderer,C:\repos\ycchiu_Unity\FuseSparxDemo\Assets\Scripts\UI\Flash\lwf\renderer\bitmapfont\bitmapfont_renderer.cs,SearchMetric,Cyclomatic complexity of the method is 8
Complex Method,BitmapFont,Renderer,C:\repos\ycchiu_Unity\FuseSparxDemo\Assets\Scripts\UI\Flash\lwf\renderer\bitmapfont\bitmapfont_renderer.cs,SetText,Cyclomatic complexity of the method is 30
Complex Method,CombinedMeshRenderer,BitmapRenderer,C:\repos\ycchiu_Unity\FuseSparxDemo\Assets\Scripts\UI\Flash\lwf\renderer\combinedmesh\lwf_combinedmesh_bitmap.cs,Render,Cyclomatic complexity of the method is 13
Complex Method,UnityRenderer,ResourceCache,C:\repos\ycchiu_Unity\FuseSparxDemo\Assets\Scripts\UI\Flash\lwf\renderer\common\lwf_unity_resourcecache.cs,LoadTexture,Cyclomatic complexity of the method is 10
Complex Method,UnityRenderer,ResourceCache,C:\repos\ycchiu_Unity\FuseSparxDemo\Assets\Scripts\UI\Flash\lwf\renderer\common\lwf_unity_resourcecache.cs,UnloadAll,Cyclomatic complexity of the method is 8
Complex Method,UnityRenderer,TextContext,C:\repos\ycchiu_Unity\FuseSparxDemo\Assets\Scripts\UI\Flash\lwf\renderer\common\lwf_unity_text.cs,TextContext,Cyclomatic complexity of the method is 39
Complex Method,NGUIRenderer,TextContext,C:\repos\ycchiu_Unity\FuseSparxDemo\Assets\Scripts\UI\Flash\lwf\renderer\ngui\lwf_ngui_text.cs,TextContext,Cyclomatic complexity of the method is 18
Complex Method,NGUIRenderer,TextContext,C:\repos\ycchiu_Unity\FuseSparxDemo\Assets\Scripts\UI\Flash\lwf\renderer\ngui\lwf_ngui_text.cs,Fill,Cyclomatic complexity of the method is 12
Long Parameter List,LWF,Button,C:\repos\ycchiu_Unity\FuseSparxDemo\Assets\Scripts\UI\Flash\lwf\core\lwf_button.cs,Button,The method has 6 parameters.
Long Parameter List,LWF,ButtonEventHandlers,C:\repos\ycchiu_Unity\FuseSparxDemo\Assets\Scripts\UI\Flash\lwf\core\lwf_eventbutton.cs,Add,The method has 10 parameters.
Long Parameter List,LWF,ButtonEventHandlers,C:\repos\ycchiu_Unity\FuseSparxDemo\Assets\Scripts\UI\Flash\lwf\core\lwf_eventbutton.cs,Remove,The method has 20 parameters.
Long Parameter List,LWF,MovieEventHandlers,C:\repos\ycchiu_Unity\FuseSparxDemo\Assets\Scripts\UI\Flash\lwf\core\lwf_eventmovie.cs,Add,The method has 6 parameters.
Long Parameter List,LWF,MovieEventHandlers,C:\repos\ycchiu_Unity\FuseSparxDemo\Assets\Scripts\UI\Flash\lwf\core\lwf_eventmovie.cs,Remove,The method has 12 parameters.
Long Parameter List,LWF,IObject,C:\repos\ycchiu_Unity\FuseSparxDemo\Assets\Scripts\UI\Flash\lwf\core\lwf_iobject.cs,IObject,The method has 5 parameters.
Long Parameter List,LWF,IObject,C:\repos\ycchiu_Unity\FuseSparxDemo\Assets\Scripts\UI\Flash\lwf\core\lwf_iobject.cs,IObject,The method has 5 parameters.
Long Parameter List,LWF,Movie,C:\repos\ycchiu_Unity\FuseSparxDemo\Assets\Scripts\UI\Flash\lwf\core\lwf_movie.cs,Movie,The method has 9 parameters.
Long Parameter List,LWF,Movie,C:\repos\ycchiu_Unity\FuseSparxDemo\Assets\Scripts\UI\Flash\lwf\core\lwf_movie.cs,ExecObject,The method has 6 parameters.
Long Parameter List,LWF,Movie,C:\repos\ycchiu_Unity\FuseSparxDemo\Assets\Scripts\UI\Flash\lwf\core\lwf_movie.cs,UpdateObject,The method has 5 parameters.
Long Parameter List,LWF,Renderer,C:\repos\ycchiu_Unity\FuseSparxDemo\Assets\Scripts\UI\Flash\lwf\core\lwf_renderer.cs,Render,The method has 5 parameters.
Long Parameter List,LWF,Utility,C:\repos\ycchiu_Unity\FuseSparxDemo\Assets\Scripts\UI\Flash\lwf\core\lwf_utility.cs,CalcMatrixToPoint,The method has 5 parameters.
Long Parameter List,LWF,IFontAdapter,C:\repos\ycchiu_Unity\FuseSparxDemo\Assets\Scripts\UI\Flash\lwf\wrapper\LWFAdapters.cs,PrintText,The method has 5 parameters.
Long Parameter List,Format,TextureReplacement,C:\repos\ycchiu_Unity\FuseSparxDemo\Assets\Scripts\UI\Flash\lwf\core\lwf_format.cs,TextureReplacement,The method has 5 parameters.
Long Parameter List,Format,TextureFragmentReplacement,C:\repos\ycchiu_Unity\FuseSparxDemo\Assets\Scripts\UI\Flash\lwf\core\lwf_format.cs,TextureFragmentReplacement,The method has 9 parameters.
Long Parameter List,BitmapFont,Renderer,C:\repos\ycchiu_Unity\FuseSparxDemo\Assets\Scripts\UI\Flash\lwf\renderer\bitmapfont\bitmapfont_renderer.cs,Renderer,The method has 12 parameters.
Long Parameter List,BitmapFont,Renderer,C:\repos\ycchiu_Unity\FuseSparxDemo\Assets\Scripts\UI\Flash\lwf\renderer\bitmapfont\bitmapfont_renderer.cs,Init,The method has 12 parameters.
Long Parameter List,BitmapFont,Renderer,C:\repos\ycchiu_Unity\FuseSparxDemo\Assets\Scripts\UI\Flash\lwf\renderer\bitmapfont\bitmapfont_renderer.cs,FeedLine,The method has 5 parameters.
Long Parameter List,BitmapFont,ResourceCache,C:\repos\ycchiu_Unity\FuseSparxDemo\Assets\Scripts\UI\Flash\lwf\renderer\bitmapfont\bitmapfont_resourcecache.cs,SetLoader,The method has 6 parameters.
Long Parameter List,CombinedMeshRenderer,BitmapRenderer,C:\repos\ycchiu_Unity\FuseSparxDemo\Assets\Scripts\UI\Flash\lwf\renderer\combinedmesh\lwf_combinedmesh_bitmap.cs,Render,The method has 5 parameters.
Long Parameter List,UnityRenderer,Factory,C:\repos\ycchiu_Unity\FuseSparxDemo\Assets\Scripts\UI\Flash\lwf\renderer\common\lwf_unity_factory.cs,Factory,The method has 9 parameters.
Long Parameter List,UnityRenderer,Factory,C:\repos\ycchiu_Unity\FuseSparxDemo\Assets\Scripts\UI\Flash\lwf\renderer\common\lwf_unity_factory.cs,ConvertMatrix,The method has 7 parameters.
Long Parameter List,UnityRenderer,Factory,C:\repos\ycchiu_Unity\FuseSparxDemo\Assets\Scripts\UI\Flash\lwf\renderer\common\lwf_unity_factory.cs,ConvertMatrix,The method has 5 parameters.
Long Parameter List,UnityRenderer,ResourceCache,C:\repos\ycchiu_Unity\FuseSparxDemo\Assets\Scripts\UI\Flash\lwf\renderer\common\lwf_unity_resourcecache.cs,SetLoader,The method has 6 parameters.
Long Parameter List,UnityRenderer,ResourceCache,C:\repos\ycchiu_Unity\FuseSparxDemo\Assets\Scripts\UI\Flash\lwf\renderer\common\lwf_unity_resourcecache.cs,LoadTexture,The method has 5 parameters.
Long Parameter List,UnityRenderer,ISystemFontRenderer,C:\repos\ycchiu_Unity\FuseSparxDemo\Assets\Scripts\UI\Flash\lwf\renderer\common\lwf_unity_systemfontrenderer.cs,Init,The method has 10 parameters.
Long Parameter List,UnityRenderer,UnityTextRenderer,C:\repos\ycchiu_Unity\FuseSparxDemo\Assets\Scripts\UI\Flash\lwf\renderer\common\lwf_unity_text.cs,Render,The method has 5 parameters.
Long Parameter List,DrawMeshRenderer,BitmapRenderer,C:\repos\ycchiu_Unity\FuseSparxDemo\Assets\Scripts\UI\Flash\lwf\renderer\drawmesh\lwf_drawmesh_bitmap.cs,Render,The method has 5 parameters.
Long Parameter List,NGUIRenderer,BitmapContext,C:\repos\ycchiu_Unity\FuseSparxDemo\Assets\Scripts\UI\Flash\lwf\renderer\ngui\lwf_ngui_bitmap.cs,FillTextureData,The method has 11 parameters.
Long Parameter List,NGUIRenderer,BitmapContext,C:\repos\ycchiu_Unity\FuseSparxDemo\Assets\Scripts\UI\Flash\lwf\renderer\ngui\lwf_ngui_bitmap.cs,Fill,The method has 5 parameters.
Long Parameter List,NGUIRenderer,BitmapRenderer,C:\repos\ycchiu_Unity\FuseSparxDemo\Assets\Scripts\UI\Flash\lwf\renderer\ngui\lwf_ngui_bitmap.cs,Render,The method has 5 parameters.
Long Parameter List,NGUIRenderer,TextContext,C:\repos\ycchiu_Unity\FuseSparxDemo\Assets\Scripts\UI\Flash\lwf\renderer\ngui\lwf_ngui_text.cs,Fill,The method has 5 parameters.
Long Parameter List,NGUIRenderer,NGUITextRenderer,C:\repos\ycchiu_Unity\FuseSparxDemo\Assets\Scripts\UI\Flash\lwf\renderer\ngui\lwf_ngui_text.cs,Render,The method has 5 parameters.
Long Statement,LWF,Data,C:\repos\ycchiu_Unity\FuseSparxDemo\Assets\Scripts\UI\Flash\lwf\core\lwf_data.cs,Check,The length of the statement  "	if (header != null && header.id0 == 'L' && header.id1 == 'W' && header.id2 == 'F' && header.id3 == (byte)Constant.FORMAT_TYPE && ((v0 == (byte)Constant.FORMAT_VERSION_0 && v1 == (byte)Constant.FORMAT_VERSION_1 && v2 == (byte)Constant.FORMAT_VERSION_2) || (v0 == (byte)Constant.FORMAT_VERSION_COMPAT_0 && v1 == (byte)Constant.FORMAT_VERSION_COMPAT_1 && v2 == (byte)Constant.FORMAT_VERSION_COMPAT_2))) { " is 401.
Long Statement,LWF,Movie,C:\repos\ycchiu_Unity\FuseSparxDemo\Assets\Scripts\UI\Flash\lwf\core\lwf_movie.cs,ExecObject,The length of the statement  "	if (obj != null && (obj.type != (Type)dataObject.objectType || obj.objectId != dataObjectId || (obj.IsMovie () && ((IObject)obj).instanceId != instId))) { " is 154.
Long Statement,DrawMeshRenderer,BitmapRenderer,C:\repos\ycchiu_Unity\FuseSparxDemo\Assets\Scripts\UI\Flash\lwf\renderer\drawmesh\lwf_drawmesh_bitmap.cs,Render,The length of the statement  "		Graphics.DrawMesh (m_context.mesh' m_renderMatrix' m_additiveMaterial' factory.gameObject.layer' factory.camera' 0' m_property); " is 128.
Long Statement,DrawMeshRenderer,BitmapRenderer,C:\repos\ycchiu_Unity\FuseSparxDemo\Assets\Scripts\UI\Flash\lwf\renderer\drawmesh\lwf_drawmesh_bitmap.cs,Render,The length of the statement  "		Graphics.DrawMesh (m_context.mesh' m_renderMatrix' m_context.material' factory.gameObject.layer' factory.camera' 0' m_property); " is 128.
Long Statement,NGUIRenderer,BitmapContext,C:\repos\ycchiu_Unity\FuseSparxDemo\Assets\Scripts\UI\Flash\lwf\renderer\ngui\lwf_ngui_bitmap.cs,Load,The length of the statement  "		// where {Hyphen-Separated-Directory-Path} is assumed to be under Resources' plus some root texture location that is optionally defined by our texture adapter. " is 159.
Long Statement,NGUIRenderer,BitmapContext,C:\repos\ycchiu_Unity\FuseSparxDemo\Assets\Scripts\UI\Flash\lwf\renderer\ngui\lwf_ngui_bitmap.cs,Load,The length of the statement  "		// the following string crap should resolve to a path something like Bundles/UITextures/SomeDir/SomeChildDir/TextureName " is 120.
Long Statement,NGUIRenderer,BitmapContext,C:\repos\ycchiu_Unity\FuseSparxDemo\Assets\Scripts\UI\Flash\lwf\renderer\ngui\lwf_ngui_bitmap.cs,LoadBitmapFromTexture,The length of the statement  "				float texScale = factory.textureAdapter != null ? GetLWFTextureScale (factory.textureAdapter.GetPixelSize ()) : GetLWFTextureScale (1.0f); " is 138.
Long Statement,NGUIRenderer,BitmapContext,C:\repos\ycchiu_Unity\FuseSparxDemo\Assets\Scripts\UI\Flash\lwf\renderer\ngui\lwf_ngui_bitmap.cs,LoadBitmapFromTexture,The length of the statement  "				//Debug.Log ("KL: loaded texture H/W: [" + tex.height + "/" + tex.width + "]' fragment H/W: [" + m_fragmentData.w + "/" + m_fragmentData.h + "]"); " is 146.
Long Statement,NGUIRenderer,BitmapContext,C:\repos\ycchiu_Unity\FuseSparxDemo\Assets\Scripts\UI\Flash\lwf\renderer\ngui\lwf_ngui_bitmap.cs,LoadBitmapFromTexture,The length of the statement  "				// attempt to force the in-game texture to the same size as what we are expecting had this texture come from spritesheet " is 120.
Long Statement,NGUIRenderer,BitmapContext,C:\repos\ycchiu_Unity\FuseSparxDemo\Assets\Scripts\UI\Flash\lwf\renderer\ngui\lwf_ngui_bitmap.cs,LoadBitmapFromTexture,The length of the statement  "				FillTextureData (m_fragmentData.w' m_fragmentData.h' texScale' 0f' 0f' 0f' 0f' m_fragmentData.w' m_fragmentData.h' m_bitmapEx); " is 127.
Long Statement,NGUIRenderer,BitmapContext,C:\repos\ycchiu_Unity\FuseSparxDemo\Assets\Scripts\UI\Flash\lwf\renderer\ngui\lwf_ngui_bitmap.cs,LoadBitmapFromTexture,The length of the statement  "		m_material = ResourceCache.SharedInstance ().LoadTexture (m_data.name' m_textureName' m_textureData.format' factory.textureLoader' factory.textureUnloader); " is 156.
Long Statement,NGUIRenderer,BitmapContext,C:\repos\ycchiu_Unity\FuseSparxDemo\Assets\Scripts\UI\Flash\lwf\renderer\ngui\lwf_ngui_bitmap.cs,LoadBitmapFromTexture,The length of the statement  "		FillTextureData (m_textureData.width' m_textureData.height' m_textureData.scale' m_fragmentData.x' m_fragmentData.y' m_fragmentData.u' m_fragmentData.v' m_fragmentData.w' m_fragmentData.h' m_bitmapEx' m_fragmentData.rotated); " is 225.
Long Statement,NGUIRenderer,BitmapContext,C:\repos\ycchiu_Unity\FuseSparxDemo\Assets\Scripts\UI\Flash\lwf\renderer\ngui\lwf_ngui_bitmap.cs,LoadFromLWF,The length of the statement  "			FillTextureData (m_textureData.width' m_textureData.height' m_textureData.scale' m_fragmentData.x' m_fragmentData.y' m_fragmentData.u' m_fragmentData.v' m_fragmentData.w' m_fragmentData.h' m_bitmapEx' m_fragmentData.rotated); " is 225.
Long Statement,NGUIRenderer,BitmapContext,C:\repos\ycchiu_Unity\FuseSparxDemo\Assets\Scripts\UI\Flash\lwf\renderer\ngui\lwf_ngui_bitmap.cs,LoadFromLWF,The length of the statement  "		m_material = ResourceCache.SharedInstance ().LoadTexture (m_data.name' m_textureName' m_textureData.format' factory.textureLoader' factory.textureUnloader); " is 156.
Long Statement,NGUIRenderer,BitmapContext,C:\repos\ycchiu_Unity\FuseSparxDemo\Assets\Scripts\UI\Flash\lwf\renderer\ngui\lwf_ngui_bitmap.cs,LoadFromLWF,The length of the statement  "		FillTextureData (m_textureData.width' m_textureData.height' m_textureData.scale' m_fragmentData.x' m_fragmentData.y' m_fragmentData.u' m_fragmentData.v' m_fragmentData.w' m_fragmentData.h' m_bitmapEx' m_fragmentData.rotated); " is 225.
Long Statement,NGUIRenderer,TextContext,C:\repos\ycchiu_Unity\FuseSparxDemo\Assets\Scripts\UI\Flash\lwf\renderer\ngui\lwf_ngui_text.cs,Fill,The length of the statement  "	UnityEngine.Color renderColor = new UnityEngine.Color (this.color.r * color.r' this.color.g * color.g' this.color.b * color.b' this.color.a * color.a); " is 151.
Complex Conditional,LWF,Button,C:\repos\ycchiu_Unity\FuseSparxDemo\Assets\Scripts\UI\Flash\lwf\core\lwf_button.cs,CheckHit,The conditional expression  "x >= 0.0f && x < (float)m_data.width && y >= 0.0f && y < (float)m_data.height"  is complex.
Complex Conditional,LWF,Data,C:\repos\ycchiu_Unity\FuseSparxDemo\Assets\Scripts\UI\Flash\lwf\core\lwf_data.cs,Check,The conditional expression  "header != null && header.id0 == 'L' && header.id1 == 'W' && header.id2 == 'F' && header.id3 == (byte)Constant.FORMAT_TYPE && ((v0 == (byte)Constant.FORMAT_VERSION_0 && v1 == (byte)Constant.FORMAT_VERSION_1 && v2 == (byte)Constant.FORMAT_VERSION_2) || (v0 == (byte)Constant.FORMAT_VERSION_COMPAT_0 && v1 == (byte)Constant.FORMAT_VERSION_COMPAT_1 && v2 == (byte)Constant.FORMAT_VERSION_COMPAT_2))"  is complex.
Complex Conditional,LWF,Movie,C:\repos\ycchiu_Unity\FuseSparxDemo\Assets\Scripts\UI\Flash\lwf\core\lwf_movie.cs,ExecObject,The conditional expression  "obj != null && (obj.type != (Type)dataObject.objectType || obj.objectId != dataObjectId || (obj.IsMovie () && ((IObject)obj).instanceId != instId))"  is complex.
Complex Conditional,LWF,Movie,C:\repos\ycchiu_Unity\FuseSparxDemo\Assets\Scripts\UI\Flash\lwf\core\lwf_movie.cs,PostExec,The conditional expression  "progressing && m_playing && !m_jumped && !postExeced"  is complex.
Complex Conditional,CombinedMeshRenderer,BitmapRenderer,C:\repos\ycchiu_Unity\FuseSparxDemo\Assets\Scripts\UI\Flash\lwf\renderer\combinedmesh\lwf_combinedmesh_bitmap.cs,Render,The conditional expression  "bc.r != color32.r || bc.g != color32.g || bc.b != color32.b || bc.a != color32.a"  is complex.
Virtual Method Call from Constructor,LWF,Graphic,C:\repos\ycchiu_Unity\FuseSparxDemo\Assets\Scripts\UI\Flash\lwf\core\lwf_graphic.cs,Graphic,The constructor "Graphic" calls a virtual method "Exec".
Virtual Method Call from Constructor,LWF,Text,C:\repos\ycchiu_Unity\FuseSparxDemo\Assets\Scripts\UI\Flash\lwf\core\lwf_text.cs,Text,The constructor "Text" calls a virtual method "SetText".
Magic Number,BitmapFont,Data,C:\repos\ycchiu_Unity\FuseSparxDemo\Assets\Scripts\UI\Flash\lwf\renderer\bitmapfont\bitmapfont_loader.cs,Data,The following statement contains a magic number: indecies = new short[256];  
Magic Number,BitmapFont,Data,C:\repos\ycchiu_Unity\FuseSparxDemo\Assets\Scripts\UI\Flash\lwf\renderer\bitmapfont\bitmapfont_loader.cs,Data,The following statement contains a magic number: for (int i = 0; i < 256; ++i)  	indecies [i] = br.ReadInt16 ();  
Magic Number,BitmapFont,Renderer,C:\repos\ycchiu_Unity\FuseSparxDemo\Assets\Scripts\UI\Flash\lwf\renderer\bitmapfont\bitmapfont_renderer.cs,SetText,The following statement contains a magic number: for (int i = 0; i < text.Length; ++i) {  	char c = text [i];  	if (c == '\n') {  		// LINEFEED  		x = mLeftMargin;  		y -= mLineSpacing;  		lastAscii = -1;  		FeedLine (lines' ref vertexBegin' i' ref left' ref right);  		continue;  	}  	else if (c == ' ') {  		// SPACE  		x += mAsciiSpaceAdvance;  		lastAscii = -1;  		continue;  	}  	else if (c == '\t') {  		// TAB  		x += mTabSpacing;  		lastAscii = -1;  		continue;  	}  	else if (c == '\u3000') {  		// JIS X 0208 SPACE  		x += mNonAsciiSpaceAdvance;  		lastAscii = -1;  		continue;  	}  	if (IsAscii (c)) {  		// ASCII  		if (lastAscii == -1) {  			// Save index for Auto linefeed  			lastAscii = i;  		}  	}  	else {  		// non-ASCII  		lastAscii = -1;  	}  	Metric metric = SearchMetric (c);  	if (metric == null) {  		// not found  		result = false;  		continue;  	}  	float advance = metric.advance * mSize + mLetterSpacing;  	float px = x + advance;  	if (mWidth != 0 && px > mWidth - mRightMargin) {  		// Auto linefeed.  		int index = lastAscii;  		lastAscii = -1;  		x = mLeftMargin;  		y -= mLineSpacing;  		if (index != -1 && IsAscii (c)) {  			// ASCII  			int nextIndex = index - 1;  			if (lastIndex != nextIndex) {  				i = nextIndex;  				lastIndex = i;  				right = vertices [(i - 1) * 4].x;  				FeedLine (lines' ref vertexBegin' i' ref left' ref right);  				continue;  			}  		}  		else {  			FeedLine (lines' ref vertexBegin' i' ref left' ref right);  		}  	}  	float x0 = x + (float)metric.bearingX * scale;  	float x1 = x0 + (float)metric.width * scale;  	float y0 = y + (float)metric.bearingY * scale;  	float y1 = y0 - (float)metric.height * scale;  	if (left > x0)  		left = x0;  	if (right < x1)  		right = x1;  	if (top > y0)  		top = y0;  	if (bottom < y1)  		bottom = y1;  	x += advance;  	float w = 2.0f * sheetWidth;  	float u0 = (float)(2 * metric.u + 1) / w;  	float u1 = u0 + (float)(metric.width * 2 - 2) / w;  	float h = 2.0f * sheetHeight;  	float v0 = (float)(2 * (sheetHeight - metric.v) + 1) / h;  	float v1 = (v0 - (float)(metric.height * 2 + 2) / h);  	int vertexOffset = i * 4;  	vertices [vertexOffset + 0] = new Vector3 (x1' y0' 0);  	vertices [vertexOffset + 1] = new Vector3 (x1' y1' 0);  	vertices [vertexOffset + 2] = new Vector3 (x0' y0' 0);  	vertices [vertexOffset + 3] = new Vector3 (x0' y1' 0);  	uv [vertexOffset + 0] = new Vector2 (u1' v0);  	uv [vertexOffset + 1] = new Vector2 (u1' v1);  	uv [vertexOffset + 2] = new Vector2 (u0' v0);  	uv [vertexOffset + 3] = new Vector2 (u0' v1);  	int triangleOffset = i * 6;  	triangles [triangleOffset + 0] = 0 + vertexOffset;  	triangles [triangleOffset + 1] = 1 + vertexOffset;  	triangles [triangleOffset + 2] = 2 + vertexOffset;  	triangles [triangleOffset + 3] = 2 + vertexOffset;  	triangles [triangleOffset + 4] = 1 + vertexOffset;  	triangles [triangleOffset + 5] = 3 + vertexOffset;  	for (int n = 0; n < 4; ++n)  		vertexColors [vertexOffset + n] = colors [i];  }  
Magic Number,BitmapFont,Renderer,C:\repos\ycchiu_Unity\FuseSparxDemo\Assets\Scripts\UI\Flash\lwf\renderer\bitmapfont\bitmapfont_renderer.cs,SetText,The following statement contains a magic number: for (int i = 0; i < text.Length; ++i) {  	char c = text [i];  	if (c == '\n') {  		// LINEFEED  		x = mLeftMargin;  		y -= mLineSpacing;  		lastAscii = -1;  		FeedLine (lines' ref vertexBegin' i' ref left' ref right);  		continue;  	}  	else if (c == ' ') {  		// SPACE  		x += mAsciiSpaceAdvance;  		lastAscii = -1;  		continue;  	}  	else if (c == '\t') {  		// TAB  		x += mTabSpacing;  		lastAscii = -1;  		continue;  	}  	else if (c == '\u3000') {  		// JIS X 0208 SPACE  		x += mNonAsciiSpaceAdvance;  		lastAscii = -1;  		continue;  	}  	if (IsAscii (c)) {  		// ASCII  		if (lastAscii == -1) {  			// Save index for Auto linefeed  			lastAscii = i;  		}  	}  	else {  		// non-ASCII  		lastAscii = -1;  	}  	Metric metric = SearchMetric (c);  	if (metric == null) {  		// not found  		result = false;  		continue;  	}  	float advance = metric.advance * mSize + mLetterSpacing;  	float px = x + advance;  	if (mWidth != 0 && px > mWidth - mRightMargin) {  		// Auto linefeed.  		int index = lastAscii;  		lastAscii = -1;  		x = mLeftMargin;  		y -= mLineSpacing;  		if (index != -1 && IsAscii (c)) {  			// ASCII  			int nextIndex = index - 1;  			if (lastIndex != nextIndex) {  				i = nextIndex;  				lastIndex = i;  				right = vertices [(i - 1) * 4].x;  				FeedLine (lines' ref vertexBegin' i' ref left' ref right);  				continue;  			}  		}  		else {  			FeedLine (lines' ref vertexBegin' i' ref left' ref right);  		}  	}  	float x0 = x + (float)metric.bearingX * scale;  	float x1 = x0 + (float)metric.width * scale;  	float y0 = y + (float)metric.bearingY * scale;  	float y1 = y0 - (float)metric.height * scale;  	if (left > x0)  		left = x0;  	if (right < x1)  		right = x1;  	if (top > y0)  		top = y0;  	if (bottom < y1)  		bottom = y1;  	x += advance;  	float w = 2.0f * sheetWidth;  	float u0 = (float)(2 * metric.u + 1) / w;  	float u1 = u0 + (float)(metric.width * 2 - 2) / w;  	float h = 2.0f * sheetHeight;  	float v0 = (float)(2 * (sheetHeight - metric.v) + 1) / h;  	float v1 = (v0 - (float)(metric.height * 2 + 2) / h);  	int vertexOffset = i * 4;  	vertices [vertexOffset + 0] = new Vector3 (x1' y0' 0);  	vertices [vertexOffset + 1] = new Vector3 (x1' y1' 0);  	vertices [vertexOffset + 2] = new Vector3 (x0' y0' 0);  	vertices [vertexOffset + 3] = new Vector3 (x0' y1' 0);  	uv [vertexOffset + 0] = new Vector2 (u1' v0);  	uv [vertexOffset + 1] = new Vector2 (u1' v1);  	uv [vertexOffset + 2] = new Vector2 (u0' v0);  	uv [vertexOffset + 3] = new Vector2 (u0' v1);  	int triangleOffset = i * 6;  	triangles [triangleOffset + 0] = 0 + vertexOffset;  	triangles [triangleOffset + 1] = 1 + vertexOffset;  	triangles [triangleOffset + 2] = 2 + vertexOffset;  	triangles [triangleOffset + 3] = 2 + vertexOffset;  	triangles [triangleOffset + 4] = 1 + vertexOffset;  	triangles [triangleOffset + 5] = 3 + vertexOffset;  	for (int n = 0; n < 4; ++n)  		vertexColors [vertexOffset + n] = colors [i];  }  
Magic Number,BitmapFont,Renderer,C:\repos\ycchiu_Unity\FuseSparxDemo\Assets\Scripts\UI\Flash\lwf\renderer\bitmapfont\bitmapfont_renderer.cs,SetText,The following statement contains a magic number: for (int i = 0; i < text.Length; ++i) {  	char c = text [i];  	if (c == '\n') {  		// LINEFEED  		x = mLeftMargin;  		y -= mLineSpacing;  		lastAscii = -1;  		FeedLine (lines' ref vertexBegin' i' ref left' ref right);  		continue;  	}  	else if (c == ' ') {  		// SPACE  		x += mAsciiSpaceAdvance;  		lastAscii = -1;  		continue;  	}  	else if (c == '\t') {  		// TAB  		x += mTabSpacing;  		lastAscii = -1;  		continue;  	}  	else if (c == '\u3000') {  		// JIS X 0208 SPACE  		x += mNonAsciiSpaceAdvance;  		lastAscii = -1;  		continue;  	}  	if (IsAscii (c)) {  		// ASCII  		if (lastAscii == -1) {  			// Save index for Auto linefeed  			lastAscii = i;  		}  	}  	else {  		// non-ASCII  		lastAscii = -1;  	}  	Metric metric = SearchMetric (c);  	if (metric == null) {  		// not found  		result = false;  		continue;  	}  	float advance = metric.advance * mSize + mLetterSpacing;  	float px = x + advance;  	if (mWidth != 0 && px > mWidth - mRightMargin) {  		// Auto linefeed.  		int index = lastAscii;  		lastAscii = -1;  		x = mLeftMargin;  		y -= mLineSpacing;  		if (index != -1 && IsAscii (c)) {  			// ASCII  			int nextIndex = index - 1;  			if (lastIndex != nextIndex) {  				i = nextIndex;  				lastIndex = i;  				right = vertices [(i - 1) * 4].x;  				FeedLine (lines' ref vertexBegin' i' ref left' ref right);  				continue;  			}  		}  		else {  			FeedLine (lines' ref vertexBegin' i' ref left' ref right);  		}  	}  	float x0 = x + (float)metric.bearingX * scale;  	float x1 = x0 + (float)metric.width * scale;  	float y0 = y + (float)metric.bearingY * scale;  	float y1 = y0 - (float)metric.height * scale;  	if (left > x0)  		left = x0;  	if (right < x1)  		right = x1;  	if (top > y0)  		top = y0;  	if (bottom < y1)  		bottom = y1;  	x += advance;  	float w = 2.0f * sheetWidth;  	float u0 = (float)(2 * metric.u + 1) / w;  	float u1 = u0 + (float)(metric.width * 2 - 2) / w;  	float h = 2.0f * sheetHeight;  	float v0 = (float)(2 * (sheetHeight - metric.v) + 1) / h;  	float v1 = (v0 - (float)(metric.height * 2 + 2) / h);  	int vertexOffset = i * 4;  	vertices [vertexOffset + 0] = new Vector3 (x1' y0' 0);  	vertices [vertexOffset + 1] = new Vector3 (x1' y1' 0);  	vertices [vertexOffset + 2] = new Vector3 (x0' y0' 0);  	vertices [vertexOffset + 3] = new Vector3 (x0' y1' 0);  	uv [vertexOffset + 0] = new Vector2 (u1' v0);  	uv [vertexOffset + 1] = new Vector2 (u1' v1);  	uv [vertexOffset + 2] = new Vector2 (u0' v0);  	uv [vertexOffset + 3] = new Vector2 (u0' v1);  	int triangleOffset = i * 6;  	triangles [triangleOffset + 0] = 0 + vertexOffset;  	triangles [triangleOffset + 1] = 1 + vertexOffset;  	triangles [triangleOffset + 2] = 2 + vertexOffset;  	triangles [triangleOffset + 3] = 2 + vertexOffset;  	triangles [triangleOffset + 4] = 1 + vertexOffset;  	triangles [triangleOffset + 5] = 3 + vertexOffset;  	for (int n = 0; n < 4; ++n)  		vertexColors [vertexOffset + n] = colors [i];  }  
Magic Number,BitmapFont,Renderer,C:\repos\ycchiu_Unity\FuseSparxDemo\Assets\Scripts\UI\Flash\lwf\renderer\bitmapfont\bitmapfont_renderer.cs,SetText,The following statement contains a magic number: for (int i = 0; i < text.Length; ++i) {  	char c = text [i];  	if (c == '\n') {  		// LINEFEED  		x = mLeftMargin;  		y -= mLineSpacing;  		lastAscii = -1;  		FeedLine (lines' ref vertexBegin' i' ref left' ref right);  		continue;  	}  	else if (c == ' ') {  		// SPACE  		x += mAsciiSpaceAdvance;  		lastAscii = -1;  		continue;  	}  	else if (c == '\t') {  		// TAB  		x += mTabSpacing;  		lastAscii = -1;  		continue;  	}  	else if (c == '\u3000') {  		// JIS X 0208 SPACE  		x += mNonAsciiSpaceAdvance;  		lastAscii = -1;  		continue;  	}  	if (IsAscii (c)) {  		// ASCII  		if (lastAscii == -1) {  			// Save index for Auto linefeed  			lastAscii = i;  		}  	}  	else {  		// non-ASCII  		lastAscii = -1;  	}  	Metric metric = SearchMetric (c);  	if (metric == null) {  		// not found  		result = false;  		continue;  	}  	float advance = metric.advance * mSize + mLetterSpacing;  	float px = x + advance;  	if (mWidth != 0 && px > mWidth - mRightMargin) {  		// Auto linefeed.  		int index = lastAscii;  		lastAscii = -1;  		x = mLeftMargin;  		y -= mLineSpacing;  		if (index != -1 && IsAscii (c)) {  			// ASCII  			int nextIndex = index - 1;  			if (lastIndex != nextIndex) {  				i = nextIndex;  				lastIndex = i;  				right = vertices [(i - 1) * 4].x;  				FeedLine (lines' ref vertexBegin' i' ref left' ref right);  				continue;  			}  		}  		else {  			FeedLine (lines' ref vertexBegin' i' ref left' ref right);  		}  	}  	float x0 = x + (float)metric.bearingX * scale;  	float x1 = x0 + (float)metric.width * scale;  	float y0 = y + (float)metric.bearingY * scale;  	float y1 = y0 - (float)metric.height * scale;  	if (left > x0)  		left = x0;  	if (right < x1)  		right = x1;  	if (top > y0)  		top = y0;  	if (bottom < y1)  		bottom = y1;  	x += advance;  	float w = 2.0f * sheetWidth;  	float u0 = (float)(2 * metric.u + 1) / w;  	float u1 = u0 + (float)(metric.width * 2 - 2) / w;  	float h = 2.0f * sheetHeight;  	float v0 = (float)(2 * (sheetHeight - metric.v) + 1) / h;  	float v1 = (v0 - (float)(metric.height * 2 + 2) / h);  	int vertexOffset = i * 4;  	vertices [vertexOffset + 0] = new Vector3 (x1' y0' 0);  	vertices [vertexOffset + 1] = new Vector3 (x1' y1' 0);  	vertices [vertexOffset + 2] = new Vector3 (x0' y0' 0);  	vertices [vertexOffset + 3] = new Vector3 (x0' y1' 0);  	uv [vertexOffset + 0] = new Vector2 (u1' v0);  	uv [vertexOffset + 1] = new Vector2 (u1' v1);  	uv [vertexOffset + 2] = new Vector2 (u0' v0);  	uv [vertexOffset + 3] = new Vector2 (u0' v1);  	int triangleOffset = i * 6;  	triangles [triangleOffset + 0] = 0 + vertexOffset;  	triangles [triangleOffset + 1] = 1 + vertexOffset;  	triangles [triangleOffset + 2] = 2 + vertexOffset;  	triangles [triangleOffset + 3] = 2 + vertexOffset;  	triangles [triangleOffset + 4] = 1 + vertexOffset;  	triangles [triangleOffset + 5] = 3 + vertexOffset;  	for (int n = 0; n < 4; ++n)  		vertexColors [vertexOffset + n] = colors [i];  }  
Magic Number,BitmapFont,Renderer,C:\repos\ycchiu_Unity\FuseSparxDemo\Assets\Scripts\UI\Flash\lwf\renderer\bitmapfont\bitmapfont_renderer.cs,SetText,The following statement contains a magic number: for (int i = 0; i < text.Length; ++i) {  	char c = text [i];  	if (c == '\n') {  		// LINEFEED  		x = mLeftMargin;  		y -= mLineSpacing;  		lastAscii = -1;  		FeedLine (lines' ref vertexBegin' i' ref left' ref right);  		continue;  	}  	else if (c == ' ') {  		// SPACE  		x += mAsciiSpaceAdvance;  		lastAscii = -1;  		continue;  	}  	else if (c == '\t') {  		// TAB  		x += mTabSpacing;  		lastAscii = -1;  		continue;  	}  	else if (c == '\u3000') {  		// JIS X 0208 SPACE  		x += mNonAsciiSpaceAdvance;  		lastAscii = -1;  		continue;  	}  	if (IsAscii (c)) {  		// ASCII  		if (lastAscii == -1) {  			// Save index for Auto linefeed  			lastAscii = i;  		}  	}  	else {  		// non-ASCII  		lastAscii = -1;  	}  	Metric metric = SearchMetric (c);  	if (metric == null) {  		// not found  		result = false;  		continue;  	}  	float advance = metric.advance * mSize + mLetterSpacing;  	float px = x + advance;  	if (mWidth != 0 && px > mWidth - mRightMargin) {  		// Auto linefeed.  		int index = lastAscii;  		lastAscii = -1;  		x = mLeftMargin;  		y -= mLineSpacing;  		if (index != -1 && IsAscii (c)) {  			// ASCII  			int nextIndex = index - 1;  			if (lastIndex != nextIndex) {  				i = nextIndex;  				lastIndex = i;  				right = vertices [(i - 1) * 4].x;  				FeedLine (lines' ref vertexBegin' i' ref left' ref right);  				continue;  			}  		}  		else {  			FeedLine (lines' ref vertexBegin' i' ref left' ref right);  		}  	}  	float x0 = x + (float)metric.bearingX * scale;  	float x1 = x0 + (float)metric.width * scale;  	float y0 = y + (float)metric.bearingY * scale;  	float y1 = y0 - (float)metric.height * scale;  	if (left > x0)  		left = x0;  	if (right < x1)  		right = x1;  	if (top > y0)  		top = y0;  	if (bottom < y1)  		bottom = y1;  	x += advance;  	float w = 2.0f * sheetWidth;  	float u0 = (float)(2 * metric.u + 1) / w;  	float u1 = u0 + (float)(metric.width * 2 - 2) / w;  	float h = 2.0f * sheetHeight;  	float v0 = (float)(2 * (sheetHeight - metric.v) + 1) / h;  	float v1 = (v0 - (float)(metric.height * 2 + 2) / h);  	int vertexOffset = i * 4;  	vertices [vertexOffset + 0] = new Vector3 (x1' y0' 0);  	vertices [vertexOffset + 1] = new Vector3 (x1' y1' 0);  	vertices [vertexOffset + 2] = new Vector3 (x0' y0' 0);  	vertices [vertexOffset + 3] = new Vector3 (x0' y1' 0);  	uv [vertexOffset + 0] = new Vector2 (u1' v0);  	uv [vertexOffset + 1] = new Vector2 (u1' v1);  	uv [vertexOffset + 2] = new Vector2 (u0' v0);  	uv [vertexOffset + 3] = new Vector2 (u0' v1);  	int triangleOffset = i * 6;  	triangles [triangleOffset + 0] = 0 + vertexOffset;  	triangles [triangleOffset + 1] = 1 + vertexOffset;  	triangles [triangleOffset + 2] = 2 + vertexOffset;  	triangles [triangleOffset + 3] = 2 + vertexOffset;  	triangles [triangleOffset + 4] = 1 + vertexOffset;  	triangles [triangleOffset + 5] = 3 + vertexOffset;  	for (int n = 0; n < 4; ++n)  		vertexColors [vertexOffset + n] = colors [i];  }  
Magic Number,BitmapFont,Renderer,C:\repos\ycchiu_Unity\FuseSparxDemo\Assets\Scripts\UI\Flash\lwf\renderer\bitmapfont\bitmapfont_renderer.cs,SetText,The following statement contains a magic number: for (int i = 0; i < text.Length; ++i) {  	char c = text [i];  	if (c == '\n') {  		// LINEFEED  		x = mLeftMargin;  		y -= mLineSpacing;  		lastAscii = -1;  		FeedLine (lines' ref vertexBegin' i' ref left' ref right);  		continue;  	}  	else if (c == ' ') {  		// SPACE  		x += mAsciiSpaceAdvance;  		lastAscii = -1;  		continue;  	}  	else if (c == '\t') {  		// TAB  		x += mTabSpacing;  		lastAscii = -1;  		continue;  	}  	else if (c == '\u3000') {  		// JIS X 0208 SPACE  		x += mNonAsciiSpaceAdvance;  		lastAscii = -1;  		continue;  	}  	if (IsAscii (c)) {  		// ASCII  		if (lastAscii == -1) {  			// Save index for Auto linefeed  			lastAscii = i;  		}  	}  	else {  		// non-ASCII  		lastAscii = -1;  	}  	Metric metric = SearchMetric (c);  	if (metric == null) {  		// not found  		result = false;  		continue;  	}  	float advance = metric.advance * mSize + mLetterSpacing;  	float px = x + advance;  	if (mWidth != 0 && px > mWidth - mRightMargin) {  		// Auto linefeed.  		int index = lastAscii;  		lastAscii = -1;  		x = mLeftMargin;  		y -= mLineSpacing;  		if (index != -1 && IsAscii (c)) {  			// ASCII  			int nextIndex = index - 1;  			if (lastIndex != nextIndex) {  				i = nextIndex;  				lastIndex = i;  				right = vertices [(i - 1) * 4].x;  				FeedLine (lines' ref vertexBegin' i' ref left' ref right);  				continue;  			}  		}  		else {  			FeedLine (lines' ref vertexBegin' i' ref left' ref right);  		}  	}  	float x0 = x + (float)metric.bearingX * scale;  	float x1 = x0 + (float)metric.width * scale;  	float y0 = y + (float)metric.bearingY * scale;  	float y1 = y0 - (float)metric.height * scale;  	if (left > x0)  		left = x0;  	if (right < x1)  		right = x1;  	if (top > y0)  		top = y0;  	if (bottom < y1)  		bottom = y1;  	x += advance;  	float w = 2.0f * sheetWidth;  	float u0 = (float)(2 * metric.u + 1) / w;  	float u1 = u0 + (float)(metric.width * 2 - 2) / w;  	float h = 2.0f * sheetHeight;  	float v0 = (float)(2 * (sheetHeight - metric.v) + 1) / h;  	float v1 = (v0 - (float)(metric.height * 2 + 2) / h);  	int vertexOffset = i * 4;  	vertices [vertexOffset + 0] = new Vector3 (x1' y0' 0);  	vertices [vertexOffset + 1] = new Vector3 (x1' y1' 0);  	vertices [vertexOffset + 2] = new Vector3 (x0' y0' 0);  	vertices [vertexOffset + 3] = new Vector3 (x0' y1' 0);  	uv [vertexOffset + 0] = new Vector2 (u1' v0);  	uv [vertexOffset + 1] = new Vector2 (u1' v1);  	uv [vertexOffset + 2] = new Vector2 (u0' v0);  	uv [vertexOffset + 3] = new Vector2 (u0' v1);  	int triangleOffset = i * 6;  	triangles [triangleOffset + 0] = 0 + vertexOffset;  	triangles [triangleOffset + 1] = 1 + vertexOffset;  	triangles [triangleOffset + 2] = 2 + vertexOffset;  	triangles [triangleOffset + 3] = 2 + vertexOffset;  	triangles [triangleOffset + 4] = 1 + vertexOffset;  	triangles [triangleOffset + 5] = 3 + vertexOffset;  	for (int n = 0; n < 4; ++n)  		vertexColors [vertexOffset + n] = colors [i];  }  
Magic Number,BitmapFont,Renderer,C:\repos\ycchiu_Unity\FuseSparxDemo\Assets\Scripts\UI\Flash\lwf\renderer\bitmapfont\bitmapfont_renderer.cs,SetText,The following statement contains a magic number: for (int i = 0; i < text.Length; ++i) {  	char c = text [i];  	if (c == '\n') {  		// LINEFEED  		x = mLeftMargin;  		y -= mLineSpacing;  		lastAscii = -1;  		FeedLine (lines' ref vertexBegin' i' ref left' ref right);  		continue;  	}  	else if (c == ' ') {  		// SPACE  		x += mAsciiSpaceAdvance;  		lastAscii = -1;  		continue;  	}  	else if (c == '\t') {  		// TAB  		x += mTabSpacing;  		lastAscii = -1;  		continue;  	}  	else if (c == '\u3000') {  		// JIS X 0208 SPACE  		x += mNonAsciiSpaceAdvance;  		lastAscii = -1;  		continue;  	}  	if (IsAscii (c)) {  		// ASCII  		if (lastAscii == -1) {  			// Save index for Auto linefeed  			lastAscii = i;  		}  	}  	else {  		// non-ASCII  		lastAscii = -1;  	}  	Metric metric = SearchMetric (c);  	if (metric == null) {  		// not found  		result = false;  		continue;  	}  	float advance = metric.advance * mSize + mLetterSpacing;  	float px = x + advance;  	if (mWidth != 0 && px > mWidth - mRightMargin) {  		// Auto linefeed.  		int index = lastAscii;  		lastAscii = -1;  		x = mLeftMargin;  		y -= mLineSpacing;  		if (index != -1 && IsAscii (c)) {  			// ASCII  			int nextIndex = index - 1;  			if (lastIndex != nextIndex) {  				i = nextIndex;  				lastIndex = i;  				right = vertices [(i - 1) * 4].x;  				FeedLine (lines' ref vertexBegin' i' ref left' ref right);  				continue;  			}  		}  		else {  			FeedLine (lines' ref vertexBegin' i' ref left' ref right);  		}  	}  	float x0 = x + (float)metric.bearingX * scale;  	float x1 = x0 + (float)metric.width * scale;  	float y0 = y + (float)metric.bearingY * scale;  	float y1 = y0 - (float)metric.height * scale;  	if (left > x0)  		left = x0;  	if (right < x1)  		right = x1;  	if (top > y0)  		top = y0;  	if (bottom < y1)  		bottom = y1;  	x += advance;  	float w = 2.0f * sheetWidth;  	float u0 = (float)(2 * metric.u + 1) / w;  	float u1 = u0 + (float)(metric.width * 2 - 2) / w;  	float h = 2.0f * sheetHeight;  	float v0 = (float)(2 * (sheetHeight - metric.v) + 1) / h;  	float v1 = (v0 - (float)(metric.height * 2 + 2) / h);  	int vertexOffset = i * 4;  	vertices [vertexOffset + 0] = new Vector3 (x1' y0' 0);  	vertices [vertexOffset + 1] = new Vector3 (x1' y1' 0);  	vertices [vertexOffset + 2] = new Vector3 (x0' y0' 0);  	vertices [vertexOffset + 3] = new Vector3 (x0' y1' 0);  	uv [vertexOffset + 0] = new Vector2 (u1' v0);  	uv [vertexOffset + 1] = new Vector2 (u1' v1);  	uv [vertexOffset + 2] = new Vector2 (u0' v0);  	uv [vertexOffset + 3] = new Vector2 (u0' v1);  	int triangleOffset = i * 6;  	triangles [triangleOffset + 0] = 0 + vertexOffset;  	triangles [triangleOffset + 1] = 1 + vertexOffset;  	triangles [triangleOffset + 2] = 2 + vertexOffset;  	triangles [triangleOffset + 3] = 2 + vertexOffset;  	triangles [triangleOffset + 4] = 1 + vertexOffset;  	triangles [triangleOffset + 5] = 3 + vertexOffset;  	for (int n = 0; n < 4; ++n)  		vertexColors [vertexOffset + n] = colors [i];  }  
Magic Number,BitmapFont,Renderer,C:\repos\ycchiu_Unity\FuseSparxDemo\Assets\Scripts\UI\Flash\lwf\renderer\bitmapfont\bitmapfont_renderer.cs,SetText,The following statement contains a magic number: for (int i = 0; i < text.Length; ++i) {  	char c = text [i];  	if (c == '\n') {  		// LINEFEED  		x = mLeftMargin;  		y -= mLineSpacing;  		lastAscii = -1;  		FeedLine (lines' ref vertexBegin' i' ref left' ref right);  		continue;  	}  	else if (c == ' ') {  		// SPACE  		x += mAsciiSpaceAdvance;  		lastAscii = -1;  		continue;  	}  	else if (c == '\t') {  		// TAB  		x += mTabSpacing;  		lastAscii = -1;  		continue;  	}  	else if (c == '\u3000') {  		// JIS X 0208 SPACE  		x += mNonAsciiSpaceAdvance;  		lastAscii = -1;  		continue;  	}  	if (IsAscii (c)) {  		// ASCII  		if (lastAscii == -1) {  			// Save index for Auto linefeed  			lastAscii = i;  		}  	}  	else {  		// non-ASCII  		lastAscii = -1;  	}  	Metric metric = SearchMetric (c);  	if (metric == null) {  		// not found  		result = false;  		continue;  	}  	float advance = metric.advance * mSize + mLetterSpacing;  	float px = x + advance;  	if (mWidth != 0 && px > mWidth - mRightMargin) {  		// Auto linefeed.  		int index = lastAscii;  		lastAscii = -1;  		x = mLeftMargin;  		y -= mLineSpacing;  		if (index != -1 && IsAscii (c)) {  			// ASCII  			int nextIndex = index - 1;  			if (lastIndex != nextIndex) {  				i = nextIndex;  				lastIndex = i;  				right = vertices [(i - 1) * 4].x;  				FeedLine (lines' ref vertexBegin' i' ref left' ref right);  				continue;  			}  		}  		else {  			FeedLine (lines' ref vertexBegin' i' ref left' ref right);  		}  	}  	float x0 = x + (float)metric.bearingX * scale;  	float x1 = x0 + (float)metric.width * scale;  	float y0 = y + (float)metric.bearingY * scale;  	float y1 = y0 - (float)metric.height * scale;  	if (left > x0)  		left = x0;  	if (right < x1)  		right = x1;  	if (top > y0)  		top = y0;  	if (bottom < y1)  		bottom = y1;  	x += advance;  	float w = 2.0f * sheetWidth;  	float u0 = (float)(2 * metric.u + 1) / w;  	float u1 = u0 + (float)(metric.width * 2 - 2) / w;  	float h = 2.0f * sheetHeight;  	float v0 = (float)(2 * (sheetHeight - metric.v) + 1) / h;  	float v1 = (v0 - (float)(metric.height * 2 + 2) / h);  	int vertexOffset = i * 4;  	vertices [vertexOffset + 0] = new Vector3 (x1' y0' 0);  	vertices [vertexOffset + 1] = new Vector3 (x1' y1' 0);  	vertices [vertexOffset + 2] = new Vector3 (x0' y0' 0);  	vertices [vertexOffset + 3] = new Vector3 (x0' y1' 0);  	uv [vertexOffset + 0] = new Vector2 (u1' v0);  	uv [vertexOffset + 1] = new Vector2 (u1' v1);  	uv [vertexOffset + 2] = new Vector2 (u0' v0);  	uv [vertexOffset + 3] = new Vector2 (u0' v1);  	int triangleOffset = i * 6;  	triangles [triangleOffset + 0] = 0 + vertexOffset;  	triangles [triangleOffset + 1] = 1 + vertexOffset;  	triangles [triangleOffset + 2] = 2 + vertexOffset;  	triangles [triangleOffset + 3] = 2 + vertexOffset;  	triangles [triangleOffset + 4] = 1 + vertexOffset;  	triangles [triangleOffset + 5] = 3 + vertexOffset;  	for (int n = 0; n < 4; ++n)  		vertexColors [vertexOffset + n] = colors [i];  }  
Magic Number,BitmapFont,Renderer,C:\repos\ycchiu_Unity\FuseSparxDemo\Assets\Scripts\UI\Flash\lwf\renderer\bitmapfont\bitmapfont_renderer.cs,SetText,The following statement contains a magic number: for (int i = 0; i < text.Length; ++i) {  	char c = text [i];  	if (c == '\n') {  		// LINEFEED  		x = mLeftMargin;  		y -= mLineSpacing;  		lastAscii = -1;  		FeedLine (lines' ref vertexBegin' i' ref left' ref right);  		continue;  	}  	else if (c == ' ') {  		// SPACE  		x += mAsciiSpaceAdvance;  		lastAscii = -1;  		continue;  	}  	else if (c == '\t') {  		// TAB  		x += mTabSpacing;  		lastAscii = -1;  		continue;  	}  	else if (c == '\u3000') {  		// JIS X 0208 SPACE  		x += mNonAsciiSpaceAdvance;  		lastAscii = -1;  		continue;  	}  	if (IsAscii (c)) {  		// ASCII  		if (lastAscii == -1) {  			// Save index for Auto linefeed  			lastAscii = i;  		}  	}  	else {  		// non-ASCII  		lastAscii = -1;  	}  	Metric metric = SearchMetric (c);  	if (metric == null) {  		// not found  		result = false;  		continue;  	}  	float advance = metric.advance * mSize + mLetterSpacing;  	float px = x + advance;  	if (mWidth != 0 && px > mWidth - mRightMargin) {  		// Auto linefeed.  		int index = lastAscii;  		lastAscii = -1;  		x = mLeftMargin;  		y -= mLineSpacing;  		if (index != -1 && IsAscii (c)) {  			// ASCII  			int nextIndex = index - 1;  			if (lastIndex != nextIndex) {  				i = nextIndex;  				lastIndex = i;  				right = vertices [(i - 1) * 4].x;  				FeedLine (lines' ref vertexBegin' i' ref left' ref right);  				continue;  			}  		}  		else {  			FeedLine (lines' ref vertexBegin' i' ref left' ref right);  		}  	}  	float x0 = x + (float)metric.bearingX * scale;  	float x1 = x0 + (float)metric.width * scale;  	float y0 = y + (float)metric.bearingY * scale;  	float y1 = y0 - (float)metric.height * scale;  	if (left > x0)  		left = x0;  	if (right < x1)  		right = x1;  	if (top > y0)  		top = y0;  	if (bottom < y1)  		bottom = y1;  	x += advance;  	float w = 2.0f * sheetWidth;  	float u0 = (float)(2 * metric.u + 1) / w;  	float u1 = u0 + (float)(metric.width * 2 - 2) / w;  	float h = 2.0f * sheetHeight;  	float v0 = (float)(2 * (sheetHeight - metric.v) + 1) / h;  	float v1 = (v0 - (float)(metric.height * 2 + 2) / h);  	int vertexOffset = i * 4;  	vertices [vertexOffset + 0] = new Vector3 (x1' y0' 0);  	vertices [vertexOffset + 1] = new Vector3 (x1' y1' 0);  	vertices [vertexOffset + 2] = new Vector3 (x0' y0' 0);  	vertices [vertexOffset + 3] = new Vector3 (x0' y1' 0);  	uv [vertexOffset + 0] = new Vector2 (u1' v0);  	uv [vertexOffset + 1] = new Vector2 (u1' v1);  	uv [vertexOffset + 2] = new Vector2 (u0' v0);  	uv [vertexOffset + 3] = new Vector2 (u0' v1);  	int triangleOffset = i * 6;  	triangles [triangleOffset + 0] = 0 + vertexOffset;  	triangles [triangleOffset + 1] = 1 + vertexOffset;  	triangles [triangleOffset + 2] = 2 + vertexOffset;  	triangles [triangleOffset + 3] = 2 + vertexOffset;  	triangles [triangleOffset + 4] = 1 + vertexOffset;  	triangles [triangleOffset + 5] = 3 + vertexOffset;  	for (int n = 0; n < 4; ++n)  		vertexColors [vertexOffset + n] = colors [i];  }  
Magic Number,BitmapFont,Renderer,C:\repos\ycchiu_Unity\FuseSparxDemo\Assets\Scripts\UI\Flash\lwf\renderer\bitmapfont\bitmapfont_renderer.cs,SetText,The following statement contains a magic number: for (int i = 0; i < text.Length; ++i) {  	char c = text [i];  	if (c == '\n') {  		// LINEFEED  		x = mLeftMargin;  		y -= mLineSpacing;  		lastAscii = -1;  		FeedLine (lines' ref vertexBegin' i' ref left' ref right);  		continue;  	}  	else if (c == ' ') {  		// SPACE  		x += mAsciiSpaceAdvance;  		lastAscii = -1;  		continue;  	}  	else if (c == '\t') {  		// TAB  		x += mTabSpacing;  		lastAscii = -1;  		continue;  	}  	else if (c == '\u3000') {  		// JIS X 0208 SPACE  		x += mNonAsciiSpaceAdvance;  		lastAscii = -1;  		continue;  	}  	if (IsAscii (c)) {  		// ASCII  		if (lastAscii == -1) {  			// Save index for Auto linefeed  			lastAscii = i;  		}  	}  	else {  		// non-ASCII  		lastAscii = -1;  	}  	Metric metric = SearchMetric (c);  	if (metric == null) {  		// not found  		result = false;  		continue;  	}  	float advance = metric.advance * mSize + mLetterSpacing;  	float px = x + advance;  	if (mWidth != 0 && px > mWidth - mRightMargin) {  		// Auto linefeed.  		int index = lastAscii;  		lastAscii = -1;  		x = mLeftMargin;  		y -= mLineSpacing;  		if (index != -1 && IsAscii (c)) {  			// ASCII  			int nextIndex = index - 1;  			if (lastIndex != nextIndex) {  				i = nextIndex;  				lastIndex = i;  				right = vertices [(i - 1) * 4].x;  				FeedLine (lines' ref vertexBegin' i' ref left' ref right);  				continue;  			}  		}  		else {  			FeedLine (lines' ref vertexBegin' i' ref left' ref right);  		}  	}  	float x0 = x + (float)metric.bearingX * scale;  	float x1 = x0 + (float)metric.width * scale;  	float y0 = y + (float)metric.bearingY * scale;  	float y1 = y0 - (float)metric.height * scale;  	if (left > x0)  		left = x0;  	if (right < x1)  		right = x1;  	if (top > y0)  		top = y0;  	if (bottom < y1)  		bottom = y1;  	x += advance;  	float w = 2.0f * sheetWidth;  	float u0 = (float)(2 * metric.u + 1) / w;  	float u1 = u0 + (float)(metric.width * 2 - 2) / w;  	float h = 2.0f * sheetHeight;  	float v0 = (float)(2 * (sheetHeight - metric.v) + 1) / h;  	float v1 = (v0 - (float)(metric.height * 2 + 2) / h);  	int vertexOffset = i * 4;  	vertices [vertexOffset + 0] = new Vector3 (x1' y0' 0);  	vertices [vertexOffset + 1] = new Vector3 (x1' y1' 0);  	vertices [vertexOffset + 2] = new Vector3 (x0' y0' 0);  	vertices [vertexOffset + 3] = new Vector3 (x0' y1' 0);  	uv [vertexOffset + 0] = new Vector2 (u1' v0);  	uv [vertexOffset + 1] = new Vector2 (u1' v1);  	uv [vertexOffset + 2] = new Vector2 (u0' v0);  	uv [vertexOffset + 3] = new Vector2 (u0' v1);  	int triangleOffset = i * 6;  	triangles [triangleOffset + 0] = 0 + vertexOffset;  	triangles [triangleOffset + 1] = 1 + vertexOffset;  	triangles [triangleOffset + 2] = 2 + vertexOffset;  	triangles [triangleOffset + 3] = 2 + vertexOffset;  	triangles [triangleOffset + 4] = 1 + vertexOffset;  	triangles [triangleOffset + 5] = 3 + vertexOffset;  	for (int n = 0; n < 4; ++n)  		vertexColors [vertexOffset + n] = colors [i];  }  
Magic Number,BitmapFont,Renderer,C:\repos\ycchiu_Unity\FuseSparxDemo\Assets\Scripts\UI\Flash\lwf\renderer\bitmapfont\bitmapfont_renderer.cs,SetText,The following statement contains a magic number: for (int i = 0; i < text.Length; ++i) {  	char c = text [i];  	if (c == '\n') {  		// LINEFEED  		x = mLeftMargin;  		y -= mLineSpacing;  		lastAscii = -1;  		FeedLine (lines' ref vertexBegin' i' ref left' ref right);  		continue;  	}  	else if (c == ' ') {  		// SPACE  		x += mAsciiSpaceAdvance;  		lastAscii = -1;  		continue;  	}  	else if (c == '\t') {  		// TAB  		x += mTabSpacing;  		lastAscii = -1;  		continue;  	}  	else if (c == '\u3000') {  		// JIS X 0208 SPACE  		x += mNonAsciiSpaceAdvance;  		lastAscii = -1;  		continue;  	}  	if (IsAscii (c)) {  		// ASCII  		if (lastAscii == -1) {  			// Save index for Auto linefeed  			lastAscii = i;  		}  	}  	else {  		// non-ASCII  		lastAscii = -1;  	}  	Metric metric = SearchMetric (c);  	if (metric == null) {  		// not found  		result = false;  		continue;  	}  	float advance = metric.advance * mSize + mLetterSpacing;  	float px = x + advance;  	if (mWidth != 0 && px > mWidth - mRightMargin) {  		// Auto linefeed.  		int index = lastAscii;  		lastAscii = -1;  		x = mLeftMargin;  		y -= mLineSpacing;  		if (index != -1 && IsAscii (c)) {  			// ASCII  			int nextIndex = index - 1;  			if (lastIndex != nextIndex) {  				i = nextIndex;  				lastIndex = i;  				right = vertices [(i - 1) * 4].x;  				FeedLine (lines' ref vertexBegin' i' ref left' ref right);  				continue;  			}  		}  		else {  			FeedLine (lines' ref vertexBegin' i' ref left' ref right);  		}  	}  	float x0 = x + (float)metric.bearingX * scale;  	float x1 = x0 + (float)metric.width * scale;  	float y0 = y + (float)metric.bearingY * scale;  	float y1 = y0 - (float)metric.height * scale;  	if (left > x0)  		left = x0;  	if (right < x1)  		right = x1;  	if (top > y0)  		top = y0;  	if (bottom < y1)  		bottom = y1;  	x += advance;  	float w = 2.0f * sheetWidth;  	float u0 = (float)(2 * metric.u + 1) / w;  	float u1 = u0 + (float)(metric.width * 2 - 2) / w;  	float h = 2.0f * sheetHeight;  	float v0 = (float)(2 * (sheetHeight - metric.v) + 1) / h;  	float v1 = (v0 - (float)(metric.height * 2 + 2) / h);  	int vertexOffset = i * 4;  	vertices [vertexOffset + 0] = new Vector3 (x1' y0' 0);  	vertices [vertexOffset + 1] = new Vector3 (x1' y1' 0);  	vertices [vertexOffset + 2] = new Vector3 (x0' y0' 0);  	vertices [vertexOffset + 3] = new Vector3 (x0' y1' 0);  	uv [vertexOffset + 0] = new Vector2 (u1' v0);  	uv [vertexOffset + 1] = new Vector2 (u1' v1);  	uv [vertexOffset + 2] = new Vector2 (u0' v0);  	uv [vertexOffset + 3] = new Vector2 (u0' v1);  	int triangleOffset = i * 6;  	triangles [triangleOffset + 0] = 0 + vertexOffset;  	triangles [triangleOffset + 1] = 1 + vertexOffset;  	triangles [triangleOffset + 2] = 2 + vertexOffset;  	triangles [triangleOffset + 3] = 2 + vertexOffset;  	triangles [triangleOffset + 4] = 1 + vertexOffset;  	triangles [triangleOffset + 5] = 3 + vertexOffset;  	for (int n = 0; n < 4; ++n)  		vertexColors [vertexOffset + n] = colors [i];  }  
Magic Number,BitmapFont,Renderer,C:\repos\ycchiu_Unity\FuseSparxDemo\Assets\Scripts\UI\Flash\lwf\renderer\bitmapfont\bitmapfont_renderer.cs,SetText,The following statement contains a magic number: for (int i = 0; i < text.Length; ++i) {  	char c = text [i];  	if (c == '\n') {  		// LINEFEED  		x = mLeftMargin;  		y -= mLineSpacing;  		lastAscii = -1;  		FeedLine (lines' ref vertexBegin' i' ref left' ref right);  		continue;  	}  	else if (c == ' ') {  		// SPACE  		x += mAsciiSpaceAdvance;  		lastAscii = -1;  		continue;  	}  	else if (c == '\t') {  		// TAB  		x += mTabSpacing;  		lastAscii = -1;  		continue;  	}  	else if (c == '\u3000') {  		// JIS X 0208 SPACE  		x += mNonAsciiSpaceAdvance;  		lastAscii = -1;  		continue;  	}  	if (IsAscii (c)) {  		// ASCII  		if (lastAscii == -1) {  			// Save index for Auto linefeed  			lastAscii = i;  		}  	}  	else {  		// non-ASCII  		lastAscii = -1;  	}  	Metric metric = SearchMetric (c);  	if (metric == null) {  		// not found  		result = false;  		continue;  	}  	float advance = metric.advance * mSize + mLetterSpacing;  	float px = x + advance;  	if (mWidth != 0 && px > mWidth - mRightMargin) {  		// Auto linefeed.  		int index = lastAscii;  		lastAscii = -1;  		x = mLeftMargin;  		y -= mLineSpacing;  		if (index != -1 && IsAscii (c)) {  			// ASCII  			int nextIndex = index - 1;  			if (lastIndex != nextIndex) {  				i = nextIndex;  				lastIndex = i;  				right = vertices [(i - 1) * 4].x;  				FeedLine (lines' ref vertexBegin' i' ref left' ref right);  				continue;  			}  		}  		else {  			FeedLine (lines' ref vertexBegin' i' ref left' ref right);  		}  	}  	float x0 = x + (float)metric.bearingX * scale;  	float x1 = x0 + (float)metric.width * scale;  	float y0 = y + (float)metric.bearingY * scale;  	float y1 = y0 - (float)metric.height * scale;  	if (left > x0)  		left = x0;  	if (right < x1)  		right = x1;  	if (top > y0)  		top = y0;  	if (bottom < y1)  		bottom = y1;  	x += advance;  	float w = 2.0f * sheetWidth;  	float u0 = (float)(2 * metric.u + 1) / w;  	float u1 = u0 + (float)(metric.width * 2 - 2) / w;  	float h = 2.0f * sheetHeight;  	float v0 = (float)(2 * (sheetHeight - metric.v) + 1) / h;  	float v1 = (v0 - (float)(metric.height * 2 + 2) / h);  	int vertexOffset = i * 4;  	vertices [vertexOffset + 0] = new Vector3 (x1' y0' 0);  	vertices [vertexOffset + 1] = new Vector3 (x1' y1' 0);  	vertices [vertexOffset + 2] = new Vector3 (x0' y0' 0);  	vertices [vertexOffset + 3] = new Vector3 (x0' y1' 0);  	uv [vertexOffset + 0] = new Vector2 (u1' v0);  	uv [vertexOffset + 1] = new Vector2 (u1' v1);  	uv [vertexOffset + 2] = new Vector2 (u0' v0);  	uv [vertexOffset + 3] = new Vector2 (u0' v1);  	int triangleOffset = i * 6;  	triangles [triangleOffset + 0] = 0 + vertexOffset;  	triangles [triangleOffset + 1] = 1 + vertexOffset;  	triangles [triangleOffset + 2] = 2 + vertexOffset;  	triangles [triangleOffset + 3] = 2 + vertexOffset;  	triangles [triangleOffset + 4] = 1 + vertexOffset;  	triangles [triangleOffset + 5] = 3 + vertexOffset;  	for (int n = 0; n < 4; ++n)  		vertexColors [vertexOffset + n] = colors [i];  }  
Magic Number,BitmapFont,Renderer,C:\repos\ycchiu_Unity\FuseSparxDemo\Assets\Scripts\UI\Flash\lwf\renderer\bitmapfont\bitmapfont_renderer.cs,SetText,The following statement contains a magic number: for (int i = 0; i < text.Length; ++i) {  	char c = text [i];  	if (c == '\n') {  		// LINEFEED  		x = mLeftMargin;  		y -= mLineSpacing;  		lastAscii = -1;  		FeedLine (lines' ref vertexBegin' i' ref left' ref right);  		continue;  	}  	else if (c == ' ') {  		// SPACE  		x += mAsciiSpaceAdvance;  		lastAscii = -1;  		continue;  	}  	else if (c == '\t') {  		// TAB  		x += mTabSpacing;  		lastAscii = -1;  		continue;  	}  	else if (c == '\u3000') {  		// JIS X 0208 SPACE  		x += mNonAsciiSpaceAdvance;  		lastAscii = -1;  		continue;  	}  	if (IsAscii (c)) {  		// ASCII  		if (lastAscii == -1) {  			// Save index for Auto linefeed  			lastAscii = i;  		}  	}  	else {  		// non-ASCII  		lastAscii = -1;  	}  	Metric metric = SearchMetric (c);  	if (metric == null) {  		// not found  		result = false;  		continue;  	}  	float advance = metric.advance * mSize + mLetterSpacing;  	float px = x + advance;  	if (mWidth != 0 && px > mWidth - mRightMargin) {  		// Auto linefeed.  		int index = lastAscii;  		lastAscii = -1;  		x = mLeftMargin;  		y -= mLineSpacing;  		if (index != -1 && IsAscii (c)) {  			// ASCII  			int nextIndex = index - 1;  			if (lastIndex != nextIndex) {  				i = nextIndex;  				lastIndex = i;  				right = vertices [(i - 1) * 4].x;  				FeedLine (lines' ref vertexBegin' i' ref left' ref right);  				continue;  			}  		}  		else {  			FeedLine (lines' ref vertexBegin' i' ref left' ref right);  		}  	}  	float x0 = x + (float)metric.bearingX * scale;  	float x1 = x0 + (float)metric.width * scale;  	float y0 = y + (float)metric.bearingY * scale;  	float y1 = y0 - (float)metric.height * scale;  	if (left > x0)  		left = x0;  	if (right < x1)  		right = x1;  	if (top > y0)  		top = y0;  	if (bottom < y1)  		bottom = y1;  	x += advance;  	float w = 2.0f * sheetWidth;  	float u0 = (float)(2 * metric.u + 1) / w;  	float u1 = u0 + (float)(metric.width * 2 - 2) / w;  	float h = 2.0f * sheetHeight;  	float v0 = (float)(2 * (sheetHeight - metric.v) + 1) / h;  	float v1 = (v0 - (float)(metric.height * 2 + 2) / h);  	int vertexOffset = i * 4;  	vertices [vertexOffset + 0] = new Vector3 (x1' y0' 0);  	vertices [vertexOffset + 1] = new Vector3 (x1' y1' 0);  	vertices [vertexOffset + 2] = new Vector3 (x0' y0' 0);  	vertices [vertexOffset + 3] = new Vector3 (x0' y1' 0);  	uv [vertexOffset + 0] = new Vector2 (u1' v0);  	uv [vertexOffset + 1] = new Vector2 (u1' v1);  	uv [vertexOffset + 2] = new Vector2 (u0' v0);  	uv [vertexOffset + 3] = new Vector2 (u0' v1);  	int triangleOffset = i * 6;  	triangles [triangleOffset + 0] = 0 + vertexOffset;  	triangles [triangleOffset + 1] = 1 + vertexOffset;  	triangles [triangleOffset + 2] = 2 + vertexOffset;  	triangles [triangleOffset + 3] = 2 + vertexOffset;  	triangles [triangleOffset + 4] = 1 + vertexOffset;  	triangles [triangleOffset + 5] = 3 + vertexOffset;  	for (int n = 0; n < 4; ++n)  		vertexColors [vertexOffset + n] = colors [i];  }  
Magic Number,BitmapFont,Renderer,C:\repos\ycchiu_Unity\FuseSparxDemo\Assets\Scripts\UI\Flash\lwf\renderer\bitmapfont\bitmapfont_renderer.cs,SetText,The following statement contains a magic number: for (int i = 0; i < text.Length; ++i) {  	char c = text [i];  	if (c == '\n') {  		// LINEFEED  		x = mLeftMargin;  		y -= mLineSpacing;  		lastAscii = -1;  		FeedLine (lines' ref vertexBegin' i' ref left' ref right);  		continue;  	}  	else if (c == ' ') {  		// SPACE  		x += mAsciiSpaceAdvance;  		lastAscii = -1;  		continue;  	}  	else if (c == '\t') {  		// TAB  		x += mTabSpacing;  		lastAscii = -1;  		continue;  	}  	else if (c == '\u3000') {  		// JIS X 0208 SPACE  		x += mNonAsciiSpaceAdvance;  		lastAscii = -1;  		continue;  	}  	if (IsAscii (c)) {  		// ASCII  		if (lastAscii == -1) {  			// Save index for Auto linefeed  			lastAscii = i;  		}  	}  	else {  		// non-ASCII  		lastAscii = -1;  	}  	Metric metric = SearchMetric (c);  	if (metric == null) {  		// not found  		result = false;  		continue;  	}  	float advance = metric.advance * mSize + mLetterSpacing;  	float px = x + advance;  	if (mWidth != 0 && px > mWidth - mRightMargin) {  		// Auto linefeed.  		int index = lastAscii;  		lastAscii = -1;  		x = mLeftMargin;  		y -= mLineSpacing;  		if (index != -1 && IsAscii (c)) {  			// ASCII  			int nextIndex = index - 1;  			if (lastIndex != nextIndex) {  				i = nextIndex;  				lastIndex = i;  				right = vertices [(i - 1) * 4].x;  				FeedLine (lines' ref vertexBegin' i' ref left' ref right);  				continue;  			}  		}  		else {  			FeedLine (lines' ref vertexBegin' i' ref left' ref right);  		}  	}  	float x0 = x + (float)metric.bearingX * scale;  	float x1 = x0 + (float)metric.width * scale;  	float y0 = y + (float)metric.bearingY * scale;  	float y1 = y0 - (float)metric.height * scale;  	if (left > x0)  		left = x0;  	if (right < x1)  		right = x1;  	if (top > y0)  		top = y0;  	if (bottom < y1)  		bottom = y1;  	x += advance;  	float w = 2.0f * sheetWidth;  	float u0 = (float)(2 * metric.u + 1) / w;  	float u1 = u0 + (float)(metric.width * 2 - 2) / w;  	float h = 2.0f * sheetHeight;  	float v0 = (float)(2 * (sheetHeight - metric.v) + 1) / h;  	float v1 = (v0 - (float)(metric.height * 2 + 2) / h);  	int vertexOffset = i * 4;  	vertices [vertexOffset + 0] = new Vector3 (x1' y0' 0);  	vertices [vertexOffset + 1] = new Vector3 (x1' y1' 0);  	vertices [vertexOffset + 2] = new Vector3 (x0' y0' 0);  	vertices [vertexOffset + 3] = new Vector3 (x0' y1' 0);  	uv [vertexOffset + 0] = new Vector2 (u1' v0);  	uv [vertexOffset + 1] = new Vector2 (u1' v1);  	uv [vertexOffset + 2] = new Vector2 (u0' v0);  	uv [vertexOffset + 3] = new Vector2 (u0' v1);  	int triangleOffset = i * 6;  	triangles [triangleOffset + 0] = 0 + vertexOffset;  	triangles [triangleOffset + 1] = 1 + vertexOffset;  	triangles [triangleOffset + 2] = 2 + vertexOffset;  	triangles [triangleOffset + 3] = 2 + vertexOffset;  	triangles [triangleOffset + 4] = 1 + vertexOffset;  	triangles [triangleOffset + 5] = 3 + vertexOffset;  	for (int n = 0; n < 4; ++n)  		vertexColors [vertexOffset + n] = colors [i];  }  
Magic Number,BitmapFont,Renderer,C:\repos\ycchiu_Unity\FuseSparxDemo\Assets\Scripts\UI\Flash\lwf\renderer\bitmapfont\bitmapfont_renderer.cs,SetText,The following statement contains a magic number: for (int i = 0; i < text.Length; ++i) {  	char c = text [i];  	if (c == '\n') {  		// LINEFEED  		x = mLeftMargin;  		y -= mLineSpacing;  		lastAscii = -1;  		FeedLine (lines' ref vertexBegin' i' ref left' ref right);  		continue;  	}  	else if (c == ' ') {  		// SPACE  		x += mAsciiSpaceAdvance;  		lastAscii = -1;  		continue;  	}  	else if (c == '\t') {  		// TAB  		x += mTabSpacing;  		lastAscii = -1;  		continue;  	}  	else if (c == '\u3000') {  		// JIS X 0208 SPACE  		x += mNonAsciiSpaceAdvance;  		lastAscii = -1;  		continue;  	}  	if (IsAscii (c)) {  		// ASCII  		if (lastAscii == -1) {  			// Save index for Auto linefeed  			lastAscii = i;  		}  	}  	else {  		// non-ASCII  		lastAscii = -1;  	}  	Metric metric = SearchMetric (c);  	if (metric == null) {  		// not found  		result = false;  		continue;  	}  	float advance = metric.advance * mSize + mLetterSpacing;  	float px = x + advance;  	if (mWidth != 0 && px > mWidth - mRightMargin) {  		// Auto linefeed.  		int index = lastAscii;  		lastAscii = -1;  		x = mLeftMargin;  		y -= mLineSpacing;  		if (index != -1 && IsAscii (c)) {  			// ASCII  			int nextIndex = index - 1;  			if (lastIndex != nextIndex) {  				i = nextIndex;  				lastIndex = i;  				right = vertices [(i - 1) * 4].x;  				FeedLine (lines' ref vertexBegin' i' ref left' ref right);  				continue;  			}  		}  		else {  			FeedLine (lines' ref vertexBegin' i' ref left' ref right);  		}  	}  	float x0 = x + (float)metric.bearingX * scale;  	float x1 = x0 + (float)metric.width * scale;  	float y0 = y + (float)metric.bearingY * scale;  	float y1 = y0 - (float)metric.height * scale;  	if (left > x0)  		left = x0;  	if (right < x1)  		right = x1;  	if (top > y0)  		top = y0;  	if (bottom < y1)  		bottom = y1;  	x += advance;  	float w = 2.0f * sheetWidth;  	float u0 = (float)(2 * metric.u + 1) / w;  	float u1 = u0 + (float)(metric.width * 2 - 2) / w;  	float h = 2.0f * sheetHeight;  	float v0 = (float)(2 * (sheetHeight - metric.v) + 1) / h;  	float v1 = (v0 - (float)(metric.height * 2 + 2) / h);  	int vertexOffset = i * 4;  	vertices [vertexOffset + 0] = new Vector3 (x1' y0' 0);  	vertices [vertexOffset + 1] = new Vector3 (x1' y1' 0);  	vertices [vertexOffset + 2] = new Vector3 (x0' y0' 0);  	vertices [vertexOffset + 3] = new Vector3 (x0' y1' 0);  	uv [vertexOffset + 0] = new Vector2 (u1' v0);  	uv [vertexOffset + 1] = new Vector2 (u1' v1);  	uv [vertexOffset + 2] = new Vector2 (u0' v0);  	uv [vertexOffset + 3] = new Vector2 (u0' v1);  	int triangleOffset = i * 6;  	triangles [triangleOffset + 0] = 0 + vertexOffset;  	triangles [triangleOffset + 1] = 1 + vertexOffset;  	triangles [triangleOffset + 2] = 2 + vertexOffset;  	triangles [triangleOffset + 3] = 2 + vertexOffset;  	triangles [triangleOffset + 4] = 1 + vertexOffset;  	triangles [triangleOffset + 5] = 3 + vertexOffset;  	for (int n = 0; n < 4; ++n)  		vertexColors [vertexOffset + n] = colors [i];  }  
Magic Number,BitmapFont,Renderer,C:\repos\ycchiu_Unity\FuseSparxDemo\Assets\Scripts\UI\Flash\lwf\renderer\bitmapfont\bitmapfont_renderer.cs,SetText,The following statement contains a magic number: for (int i = 0; i < text.Length; ++i) {  	char c = text [i];  	if (c == '\n') {  		// LINEFEED  		x = mLeftMargin;  		y -= mLineSpacing;  		lastAscii = -1;  		FeedLine (lines' ref vertexBegin' i' ref left' ref right);  		continue;  	}  	else if (c == ' ') {  		// SPACE  		x += mAsciiSpaceAdvance;  		lastAscii = -1;  		continue;  	}  	else if (c == '\t') {  		// TAB  		x += mTabSpacing;  		lastAscii = -1;  		continue;  	}  	else if (c == '\u3000') {  		// JIS X 0208 SPACE  		x += mNonAsciiSpaceAdvance;  		lastAscii = -1;  		continue;  	}  	if (IsAscii (c)) {  		// ASCII  		if (lastAscii == -1) {  			// Save index for Auto linefeed  			lastAscii = i;  		}  	}  	else {  		// non-ASCII  		lastAscii = -1;  	}  	Metric metric = SearchMetric (c);  	if (metric == null) {  		// not found  		result = false;  		continue;  	}  	float advance = metric.advance * mSize + mLetterSpacing;  	float px = x + advance;  	if (mWidth != 0 && px > mWidth - mRightMargin) {  		// Auto linefeed.  		int index = lastAscii;  		lastAscii = -1;  		x = mLeftMargin;  		y -= mLineSpacing;  		if (index != -1 && IsAscii (c)) {  			// ASCII  			int nextIndex = index - 1;  			if (lastIndex != nextIndex) {  				i = nextIndex;  				lastIndex = i;  				right = vertices [(i - 1) * 4].x;  				FeedLine (lines' ref vertexBegin' i' ref left' ref right);  				continue;  			}  		}  		else {  			FeedLine (lines' ref vertexBegin' i' ref left' ref right);  		}  	}  	float x0 = x + (float)metric.bearingX * scale;  	float x1 = x0 + (float)metric.width * scale;  	float y0 = y + (float)metric.bearingY * scale;  	float y1 = y0 - (float)metric.height * scale;  	if (left > x0)  		left = x0;  	if (right < x1)  		right = x1;  	if (top > y0)  		top = y0;  	if (bottom < y1)  		bottom = y1;  	x += advance;  	float w = 2.0f * sheetWidth;  	float u0 = (float)(2 * metric.u + 1) / w;  	float u1 = u0 + (float)(metric.width * 2 - 2) / w;  	float h = 2.0f * sheetHeight;  	float v0 = (float)(2 * (sheetHeight - metric.v) + 1) / h;  	float v1 = (v0 - (float)(metric.height * 2 + 2) / h);  	int vertexOffset = i * 4;  	vertices [vertexOffset + 0] = new Vector3 (x1' y0' 0);  	vertices [vertexOffset + 1] = new Vector3 (x1' y1' 0);  	vertices [vertexOffset + 2] = new Vector3 (x0' y0' 0);  	vertices [vertexOffset + 3] = new Vector3 (x0' y1' 0);  	uv [vertexOffset + 0] = new Vector2 (u1' v0);  	uv [vertexOffset + 1] = new Vector2 (u1' v1);  	uv [vertexOffset + 2] = new Vector2 (u0' v0);  	uv [vertexOffset + 3] = new Vector2 (u0' v1);  	int triangleOffset = i * 6;  	triangles [triangleOffset + 0] = 0 + vertexOffset;  	triangles [triangleOffset + 1] = 1 + vertexOffset;  	triangles [triangleOffset + 2] = 2 + vertexOffset;  	triangles [triangleOffset + 3] = 2 + vertexOffset;  	triangles [triangleOffset + 4] = 1 + vertexOffset;  	triangles [triangleOffset + 5] = 3 + vertexOffset;  	for (int n = 0; n < 4; ++n)  		vertexColors [vertexOffset + n] = colors [i];  }  
Magic Number,BitmapFont,Renderer,C:\repos\ycchiu_Unity\FuseSparxDemo\Assets\Scripts\UI\Flash\lwf\renderer\bitmapfont\bitmapfont_renderer.cs,SetText,The following statement contains a magic number: for (int i = 0; i < text.Length; ++i) {  	char c = text [i];  	if (c == '\n') {  		// LINEFEED  		x = mLeftMargin;  		y -= mLineSpacing;  		lastAscii = -1;  		FeedLine (lines' ref vertexBegin' i' ref left' ref right);  		continue;  	}  	else if (c == ' ') {  		// SPACE  		x += mAsciiSpaceAdvance;  		lastAscii = -1;  		continue;  	}  	else if (c == '\t') {  		// TAB  		x += mTabSpacing;  		lastAscii = -1;  		continue;  	}  	else if (c == '\u3000') {  		// JIS X 0208 SPACE  		x += mNonAsciiSpaceAdvance;  		lastAscii = -1;  		continue;  	}  	if (IsAscii (c)) {  		// ASCII  		if (lastAscii == -1) {  			// Save index for Auto linefeed  			lastAscii = i;  		}  	}  	else {  		// non-ASCII  		lastAscii = -1;  	}  	Metric metric = SearchMetric (c);  	if (metric == null) {  		// not found  		result = false;  		continue;  	}  	float advance = metric.advance * mSize + mLetterSpacing;  	float px = x + advance;  	if (mWidth != 0 && px > mWidth - mRightMargin) {  		// Auto linefeed.  		int index = lastAscii;  		lastAscii = -1;  		x = mLeftMargin;  		y -= mLineSpacing;  		if (index != -1 && IsAscii (c)) {  			// ASCII  			int nextIndex = index - 1;  			if (lastIndex != nextIndex) {  				i = nextIndex;  				lastIndex = i;  				right = vertices [(i - 1) * 4].x;  				FeedLine (lines' ref vertexBegin' i' ref left' ref right);  				continue;  			}  		}  		else {  			FeedLine (lines' ref vertexBegin' i' ref left' ref right);  		}  	}  	float x0 = x + (float)metric.bearingX * scale;  	float x1 = x0 + (float)metric.width * scale;  	float y0 = y + (float)metric.bearingY * scale;  	float y1 = y0 - (float)metric.height * scale;  	if (left > x0)  		left = x0;  	if (right < x1)  		right = x1;  	if (top > y0)  		top = y0;  	if (bottom < y1)  		bottom = y1;  	x += advance;  	float w = 2.0f * sheetWidth;  	float u0 = (float)(2 * metric.u + 1) / w;  	float u1 = u0 + (float)(metric.width * 2 - 2) / w;  	float h = 2.0f * sheetHeight;  	float v0 = (float)(2 * (sheetHeight - metric.v) + 1) / h;  	float v1 = (v0 - (float)(metric.height * 2 + 2) / h);  	int vertexOffset = i * 4;  	vertices [vertexOffset + 0] = new Vector3 (x1' y0' 0);  	vertices [vertexOffset + 1] = new Vector3 (x1' y1' 0);  	vertices [vertexOffset + 2] = new Vector3 (x0' y0' 0);  	vertices [vertexOffset + 3] = new Vector3 (x0' y1' 0);  	uv [vertexOffset + 0] = new Vector2 (u1' v0);  	uv [vertexOffset + 1] = new Vector2 (u1' v1);  	uv [vertexOffset + 2] = new Vector2 (u0' v0);  	uv [vertexOffset + 3] = new Vector2 (u0' v1);  	int triangleOffset = i * 6;  	triangles [triangleOffset + 0] = 0 + vertexOffset;  	triangles [triangleOffset + 1] = 1 + vertexOffset;  	triangles [triangleOffset + 2] = 2 + vertexOffset;  	triangles [triangleOffset + 3] = 2 + vertexOffset;  	triangles [triangleOffset + 4] = 1 + vertexOffset;  	triangles [triangleOffset + 5] = 3 + vertexOffset;  	for (int n = 0; n < 4; ++n)  		vertexColors [vertexOffset + n] = colors [i];  }  
Magic Number,BitmapFont,Renderer,C:\repos\ycchiu_Unity\FuseSparxDemo\Assets\Scripts\UI\Flash\lwf\renderer\bitmapfont\bitmapfont_renderer.cs,SetText,The following statement contains a magic number: for (int i = 0; i < text.Length; ++i) {  	char c = text [i];  	if (c == '\n') {  		// LINEFEED  		x = mLeftMargin;  		y -= mLineSpacing;  		lastAscii = -1;  		FeedLine (lines' ref vertexBegin' i' ref left' ref right);  		continue;  	}  	else if (c == ' ') {  		// SPACE  		x += mAsciiSpaceAdvance;  		lastAscii = -1;  		continue;  	}  	else if (c == '\t') {  		// TAB  		x += mTabSpacing;  		lastAscii = -1;  		continue;  	}  	else if (c == '\u3000') {  		// JIS X 0208 SPACE  		x += mNonAsciiSpaceAdvance;  		lastAscii = -1;  		continue;  	}  	if (IsAscii (c)) {  		// ASCII  		if (lastAscii == -1) {  			// Save index for Auto linefeed  			lastAscii = i;  		}  	}  	else {  		// non-ASCII  		lastAscii = -1;  	}  	Metric metric = SearchMetric (c);  	if (metric == null) {  		// not found  		result = false;  		continue;  	}  	float advance = metric.advance * mSize + mLetterSpacing;  	float px = x + advance;  	if (mWidth != 0 && px > mWidth - mRightMargin) {  		// Auto linefeed.  		int index = lastAscii;  		lastAscii = -1;  		x = mLeftMargin;  		y -= mLineSpacing;  		if (index != -1 && IsAscii (c)) {  			// ASCII  			int nextIndex = index - 1;  			if (lastIndex != nextIndex) {  				i = nextIndex;  				lastIndex = i;  				right = vertices [(i - 1) * 4].x;  				FeedLine (lines' ref vertexBegin' i' ref left' ref right);  				continue;  			}  		}  		else {  			FeedLine (lines' ref vertexBegin' i' ref left' ref right);  		}  	}  	float x0 = x + (float)metric.bearingX * scale;  	float x1 = x0 + (float)metric.width * scale;  	float y0 = y + (float)metric.bearingY * scale;  	float y1 = y0 - (float)metric.height * scale;  	if (left > x0)  		left = x0;  	if (right < x1)  		right = x1;  	if (top > y0)  		top = y0;  	if (bottom < y1)  		bottom = y1;  	x += advance;  	float w = 2.0f * sheetWidth;  	float u0 = (float)(2 * metric.u + 1) / w;  	float u1 = u0 + (float)(metric.width * 2 - 2) / w;  	float h = 2.0f * sheetHeight;  	float v0 = (float)(2 * (sheetHeight - metric.v) + 1) / h;  	float v1 = (v0 - (float)(metric.height * 2 + 2) / h);  	int vertexOffset = i * 4;  	vertices [vertexOffset + 0] = new Vector3 (x1' y0' 0);  	vertices [vertexOffset + 1] = new Vector3 (x1' y1' 0);  	vertices [vertexOffset + 2] = new Vector3 (x0' y0' 0);  	vertices [vertexOffset + 3] = new Vector3 (x0' y1' 0);  	uv [vertexOffset + 0] = new Vector2 (u1' v0);  	uv [vertexOffset + 1] = new Vector2 (u1' v1);  	uv [vertexOffset + 2] = new Vector2 (u0' v0);  	uv [vertexOffset + 3] = new Vector2 (u0' v1);  	int triangleOffset = i * 6;  	triangles [triangleOffset + 0] = 0 + vertexOffset;  	triangles [triangleOffset + 1] = 1 + vertexOffset;  	triangles [triangleOffset + 2] = 2 + vertexOffset;  	triangles [triangleOffset + 3] = 2 + vertexOffset;  	triangles [triangleOffset + 4] = 1 + vertexOffset;  	triangles [triangleOffset + 5] = 3 + vertexOffset;  	for (int n = 0; n < 4; ++n)  		vertexColors [vertexOffset + n] = colors [i];  }  
Magic Number,BitmapFont,Renderer,C:\repos\ycchiu_Unity\FuseSparxDemo\Assets\Scripts\UI\Flash\lwf\renderer\bitmapfont\bitmapfont_renderer.cs,SetText,The following statement contains a magic number: for (int i = 0; i < text.Length; ++i) {  	char c = text [i];  	if (c == '\n') {  		// LINEFEED  		x = mLeftMargin;  		y -= mLineSpacing;  		lastAscii = -1;  		FeedLine (lines' ref vertexBegin' i' ref left' ref right);  		continue;  	}  	else if (c == ' ') {  		// SPACE  		x += mAsciiSpaceAdvance;  		lastAscii = -1;  		continue;  	}  	else if (c == '\t') {  		// TAB  		x += mTabSpacing;  		lastAscii = -1;  		continue;  	}  	else if (c == '\u3000') {  		// JIS X 0208 SPACE  		x += mNonAsciiSpaceAdvance;  		lastAscii = -1;  		continue;  	}  	if (IsAscii (c)) {  		// ASCII  		if (lastAscii == -1) {  			// Save index for Auto linefeed  			lastAscii = i;  		}  	}  	else {  		// non-ASCII  		lastAscii = -1;  	}  	Metric metric = SearchMetric (c);  	if (metric == null) {  		// not found  		result = false;  		continue;  	}  	float advance = metric.advance * mSize + mLetterSpacing;  	float px = x + advance;  	if (mWidth != 0 && px > mWidth - mRightMargin) {  		// Auto linefeed.  		int index = lastAscii;  		lastAscii = -1;  		x = mLeftMargin;  		y -= mLineSpacing;  		if (index != -1 && IsAscii (c)) {  			// ASCII  			int nextIndex = index - 1;  			if (lastIndex != nextIndex) {  				i = nextIndex;  				lastIndex = i;  				right = vertices [(i - 1) * 4].x;  				FeedLine (lines' ref vertexBegin' i' ref left' ref right);  				continue;  			}  		}  		else {  			FeedLine (lines' ref vertexBegin' i' ref left' ref right);  		}  	}  	float x0 = x + (float)metric.bearingX * scale;  	float x1 = x0 + (float)metric.width * scale;  	float y0 = y + (float)metric.bearingY * scale;  	float y1 = y0 - (float)metric.height * scale;  	if (left > x0)  		left = x0;  	if (right < x1)  		right = x1;  	if (top > y0)  		top = y0;  	if (bottom < y1)  		bottom = y1;  	x += advance;  	float w = 2.0f * sheetWidth;  	float u0 = (float)(2 * metric.u + 1) / w;  	float u1 = u0 + (float)(metric.width * 2 - 2) / w;  	float h = 2.0f * sheetHeight;  	float v0 = (float)(2 * (sheetHeight - metric.v) + 1) / h;  	float v1 = (v0 - (float)(metric.height * 2 + 2) / h);  	int vertexOffset = i * 4;  	vertices [vertexOffset + 0] = new Vector3 (x1' y0' 0);  	vertices [vertexOffset + 1] = new Vector3 (x1' y1' 0);  	vertices [vertexOffset + 2] = new Vector3 (x0' y0' 0);  	vertices [vertexOffset + 3] = new Vector3 (x0' y1' 0);  	uv [vertexOffset + 0] = new Vector2 (u1' v0);  	uv [vertexOffset + 1] = new Vector2 (u1' v1);  	uv [vertexOffset + 2] = new Vector2 (u0' v0);  	uv [vertexOffset + 3] = new Vector2 (u0' v1);  	int triangleOffset = i * 6;  	triangles [triangleOffset + 0] = 0 + vertexOffset;  	triangles [triangleOffset + 1] = 1 + vertexOffset;  	triangles [triangleOffset + 2] = 2 + vertexOffset;  	triangles [triangleOffset + 3] = 2 + vertexOffset;  	triangles [triangleOffset + 4] = 1 + vertexOffset;  	triangles [triangleOffset + 5] = 3 + vertexOffset;  	for (int n = 0; n < 4; ++n)  		vertexColors [vertexOffset + n] = colors [i];  }  
Magic Number,BitmapFont,Renderer,C:\repos\ycchiu_Unity\FuseSparxDemo\Assets\Scripts\UI\Flash\lwf\renderer\bitmapfont\bitmapfont_renderer.cs,SetText,The following statement contains a magic number: for (int i = 0; i < text.Length; ++i) {  	char c = text [i];  	if (c == '\n') {  		// LINEFEED  		x = mLeftMargin;  		y -= mLineSpacing;  		lastAscii = -1;  		FeedLine (lines' ref vertexBegin' i' ref left' ref right);  		continue;  	}  	else if (c == ' ') {  		// SPACE  		x += mAsciiSpaceAdvance;  		lastAscii = -1;  		continue;  	}  	else if (c == '\t') {  		// TAB  		x += mTabSpacing;  		lastAscii = -1;  		continue;  	}  	else if (c == '\u3000') {  		// JIS X 0208 SPACE  		x += mNonAsciiSpaceAdvance;  		lastAscii = -1;  		continue;  	}  	if (IsAscii (c)) {  		// ASCII  		if (lastAscii == -1) {  			// Save index for Auto linefeed  			lastAscii = i;  		}  	}  	else {  		// non-ASCII  		lastAscii = -1;  	}  	Metric metric = SearchMetric (c);  	if (metric == null) {  		// not found  		result = false;  		continue;  	}  	float advance = metric.advance * mSize + mLetterSpacing;  	float px = x + advance;  	if (mWidth != 0 && px > mWidth - mRightMargin) {  		// Auto linefeed.  		int index = lastAscii;  		lastAscii = -1;  		x = mLeftMargin;  		y -= mLineSpacing;  		if (index != -1 && IsAscii (c)) {  			// ASCII  			int nextIndex = index - 1;  			if (lastIndex != nextIndex) {  				i = nextIndex;  				lastIndex = i;  				right = vertices [(i - 1) * 4].x;  				FeedLine (lines' ref vertexBegin' i' ref left' ref right);  				continue;  			}  		}  		else {  			FeedLine (lines' ref vertexBegin' i' ref left' ref right);  		}  	}  	float x0 = x + (float)metric.bearingX * scale;  	float x1 = x0 + (float)metric.width * scale;  	float y0 = y + (float)metric.bearingY * scale;  	float y1 = y0 - (float)metric.height * scale;  	if (left > x0)  		left = x0;  	if (right < x1)  		right = x1;  	if (top > y0)  		top = y0;  	if (bottom < y1)  		bottom = y1;  	x += advance;  	float w = 2.0f * sheetWidth;  	float u0 = (float)(2 * metric.u + 1) / w;  	float u1 = u0 + (float)(metric.width * 2 - 2) / w;  	float h = 2.0f * sheetHeight;  	float v0 = (float)(2 * (sheetHeight - metric.v) + 1) / h;  	float v1 = (v0 - (float)(metric.height * 2 + 2) / h);  	int vertexOffset = i * 4;  	vertices [vertexOffset + 0] = new Vector3 (x1' y0' 0);  	vertices [vertexOffset + 1] = new Vector3 (x1' y1' 0);  	vertices [vertexOffset + 2] = new Vector3 (x0' y0' 0);  	vertices [vertexOffset + 3] = new Vector3 (x0' y1' 0);  	uv [vertexOffset + 0] = new Vector2 (u1' v0);  	uv [vertexOffset + 1] = new Vector2 (u1' v1);  	uv [vertexOffset + 2] = new Vector2 (u0' v0);  	uv [vertexOffset + 3] = new Vector2 (u0' v1);  	int triangleOffset = i * 6;  	triangles [triangleOffset + 0] = 0 + vertexOffset;  	triangles [triangleOffset + 1] = 1 + vertexOffset;  	triangles [triangleOffset + 2] = 2 + vertexOffset;  	triangles [triangleOffset + 3] = 2 + vertexOffset;  	triangles [triangleOffset + 4] = 1 + vertexOffset;  	triangles [triangleOffset + 5] = 3 + vertexOffset;  	for (int n = 0; n < 4; ++n)  		vertexColors [vertexOffset + n] = colors [i];  }  
Magic Number,BitmapFont,Renderer,C:\repos\ycchiu_Unity\FuseSparxDemo\Assets\Scripts\UI\Flash\lwf\renderer\bitmapfont\bitmapfont_renderer.cs,SetText,The following statement contains a magic number: for (int i = 0; i < text.Length; ++i) {  	char c = text [i];  	if (c == '\n') {  		// LINEFEED  		x = mLeftMargin;  		y -= mLineSpacing;  		lastAscii = -1;  		FeedLine (lines' ref vertexBegin' i' ref left' ref right);  		continue;  	}  	else if (c == ' ') {  		// SPACE  		x += mAsciiSpaceAdvance;  		lastAscii = -1;  		continue;  	}  	else if (c == '\t') {  		// TAB  		x += mTabSpacing;  		lastAscii = -1;  		continue;  	}  	else if (c == '\u3000') {  		// JIS X 0208 SPACE  		x += mNonAsciiSpaceAdvance;  		lastAscii = -1;  		continue;  	}  	if (IsAscii (c)) {  		// ASCII  		if (lastAscii == -1) {  			// Save index for Auto linefeed  			lastAscii = i;  		}  	}  	else {  		// non-ASCII  		lastAscii = -1;  	}  	Metric metric = SearchMetric (c);  	if (metric == null) {  		// not found  		result = false;  		continue;  	}  	float advance = metric.advance * mSize + mLetterSpacing;  	float px = x + advance;  	if (mWidth != 0 && px > mWidth - mRightMargin) {  		// Auto linefeed.  		int index = lastAscii;  		lastAscii = -1;  		x = mLeftMargin;  		y -= mLineSpacing;  		if (index != -1 && IsAscii (c)) {  			// ASCII  			int nextIndex = index - 1;  			if (lastIndex != nextIndex) {  				i = nextIndex;  				lastIndex = i;  				right = vertices [(i - 1) * 4].x;  				FeedLine (lines' ref vertexBegin' i' ref left' ref right);  				continue;  			}  		}  		else {  			FeedLine (lines' ref vertexBegin' i' ref left' ref right);  		}  	}  	float x0 = x + (float)metric.bearingX * scale;  	float x1 = x0 + (float)metric.width * scale;  	float y0 = y + (float)metric.bearingY * scale;  	float y1 = y0 - (float)metric.height * scale;  	if (left > x0)  		left = x0;  	if (right < x1)  		right = x1;  	if (top > y0)  		top = y0;  	if (bottom < y1)  		bottom = y1;  	x += advance;  	float w = 2.0f * sheetWidth;  	float u0 = (float)(2 * metric.u + 1) / w;  	float u1 = u0 + (float)(metric.width * 2 - 2) / w;  	float h = 2.0f * sheetHeight;  	float v0 = (float)(2 * (sheetHeight - metric.v) + 1) / h;  	float v1 = (v0 - (float)(metric.height * 2 + 2) / h);  	int vertexOffset = i * 4;  	vertices [vertexOffset + 0] = new Vector3 (x1' y0' 0);  	vertices [vertexOffset + 1] = new Vector3 (x1' y1' 0);  	vertices [vertexOffset + 2] = new Vector3 (x0' y0' 0);  	vertices [vertexOffset + 3] = new Vector3 (x0' y1' 0);  	uv [vertexOffset + 0] = new Vector2 (u1' v0);  	uv [vertexOffset + 1] = new Vector2 (u1' v1);  	uv [vertexOffset + 2] = new Vector2 (u0' v0);  	uv [vertexOffset + 3] = new Vector2 (u0' v1);  	int triangleOffset = i * 6;  	triangles [triangleOffset + 0] = 0 + vertexOffset;  	triangles [triangleOffset + 1] = 1 + vertexOffset;  	triangles [triangleOffset + 2] = 2 + vertexOffset;  	triangles [triangleOffset + 3] = 2 + vertexOffset;  	triangles [triangleOffset + 4] = 1 + vertexOffset;  	triangles [triangleOffset + 5] = 3 + vertexOffset;  	for (int n = 0; n < 4; ++n)  		vertexColors [vertexOffset + n] = colors [i];  }  
Magic Number,BitmapFont,Renderer,C:\repos\ycchiu_Unity\FuseSparxDemo\Assets\Scripts\UI\Flash\lwf\renderer\bitmapfont\bitmapfont_renderer.cs,SetText,The following statement contains a magic number: if (mWidth != 0 && px > mWidth - mRightMargin) {  	// Auto linefeed.  	int index = lastAscii;  	lastAscii = -1;  	x = mLeftMargin;  	y -= mLineSpacing;  	if (index != -1 && IsAscii (c)) {  		// ASCII  		int nextIndex = index - 1;  		if (lastIndex != nextIndex) {  			i = nextIndex;  			lastIndex = i;  			right = vertices [(i - 1) * 4].x;  			FeedLine (lines' ref vertexBegin' i' ref left' ref right);  			continue;  		}  	}  	else {  		FeedLine (lines' ref vertexBegin' i' ref left' ref right);  	}  }  
Magic Number,BitmapFont,Renderer,C:\repos\ycchiu_Unity\FuseSparxDemo\Assets\Scripts\UI\Flash\lwf\renderer\bitmapfont\bitmapfont_renderer.cs,SetText,The following statement contains a magic number: if (index != -1 && IsAscii (c)) {  	// ASCII  	int nextIndex = index - 1;  	if (lastIndex != nextIndex) {  		i = nextIndex;  		lastIndex = i;  		right = vertices [(i - 1) * 4].x;  		FeedLine (lines' ref vertexBegin' i' ref left' ref right);  		continue;  	}  }  else {  	FeedLine (lines' ref vertexBegin' i' ref left' ref right);  }  
Magic Number,BitmapFont,Renderer,C:\repos\ycchiu_Unity\FuseSparxDemo\Assets\Scripts\UI\Flash\lwf\renderer\bitmapfont\bitmapfont_renderer.cs,SetText,The following statement contains a magic number: if (lastIndex != nextIndex) {  	i = nextIndex;  	lastIndex = i;  	right = vertices [(i - 1) * 4].x;  	FeedLine (lines' ref vertexBegin' i' ref left' ref right);  	continue;  }  
Magic Number,BitmapFont,Renderer,C:\repos\ycchiu_Unity\FuseSparxDemo\Assets\Scripts\UI\Flash\lwf\renderer\bitmapfont\bitmapfont_renderer.cs,SetText,The following statement contains a magic number: right = vertices [(i - 1) * 4].x;  
Magic Number,BitmapFont,Renderer,C:\repos\ycchiu_Unity\FuseSparxDemo\Assets\Scripts\UI\Flash\lwf\renderer\bitmapfont\bitmapfont_renderer.cs,SetText,The following statement contains a magic number: vertices [vertexOffset + 2] = new Vector3 (x0' y0' 0);  
Magic Number,BitmapFont,Renderer,C:\repos\ycchiu_Unity\FuseSparxDemo\Assets\Scripts\UI\Flash\lwf\renderer\bitmapfont\bitmapfont_renderer.cs,SetText,The following statement contains a magic number: vertices [vertexOffset + 3] = new Vector3 (x0' y1' 0);  
Magic Number,BitmapFont,Renderer,C:\repos\ycchiu_Unity\FuseSparxDemo\Assets\Scripts\UI\Flash\lwf\renderer\bitmapfont\bitmapfont_renderer.cs,SetText,The following statement contains a magic number: uv [vertexOffset + 2] = new Vector2 (u0' v0);  
Magic Number,BitmapFont,Renderer,C:\repos\ycchiu_Unity\FuseSparxDemo\Assets\Scripts\UI\Flash\lwf\renderer\bitmapfont\bitmapfont_renderer.cs,SetText,The following statement contains a magic number: uv [vertexOffset + 3] = new Vector2 (u0' v1);  
Magic Number,BitmapFont,Renderer,C:\repos\ycchiu_Unity\FuseSparxDemo\Assets\Scripts\UI\Flash\lwf\renderer\bitmapfont\bitmapfont_renderer.cs,SetText,The following statement contains a magic number: triangles [triangleOffset + 2] = 2 + vertexOffset;  
Magic Number,BitmapFont,Renderer,C:\repos\ycchiu_Unity\FuseSparxDemo\Assets\Scripts\UI\Flash\lwf\renderer\bitmapfont\bitmapfont_renderer.cs,SetText,The following statement contains a magic number: triangles [triangleOffset + 2] = 2 + vertexOffset;  
Magic Number,BitmapFont,Renderer,C:\repos\ycchiu_Unity\FuseSparxDemo\Assets\Scripts\UI\Flash\lwf\renderer\bitmapfont\bitmapfont_renderer.cs,SetText,The following statement contains a magic number: triangles [triangleOffset + 3] = 2 + vertexOffset;  
Magic Number,BitmapFont,Renderer,C:\repos\ycchiu_Unity\FuseSparxDemo\Assets\Scripts\UI\Flash\lwf\renderer\bitmapfont\bitmapfont_renderer.cs,SetText,The following statement contains a magic number: triangles [triangleOffset + 3] = 2 + vertexOffset;  
Magic Number,BitmapFont,Renderer,C:\repos\ycchiu_Unity\FuseSparxDemo\Assets\Scripts\UI\Flash\lwf\renderer\bitmapfont\bitmapfont_renderer.cs,SetText,The following statement contains a magic number: triangles [triangleOffset + 4] = 1 + vertexOffset;  
Magic Number,BitmapFont,Renderer,C:\repos\ycchiu_Unity\FuseSparxDemo\Assets\Scripts\UI\Flash\lwf\renderer\bitmapfont\bitmapfont_renderer.cs,SetText,The following statement contains a magic number: triangles [triangleOffset + 5] = 3 + vertexOffset;  
Magic Number,BitmapFont,Renderer,C:\repos\ycchiu_Unity\FuseSparxDemo\Assets\Scripts\UI\Flash\lwf\renderer\bitmapfont\bitmapfont_renderer.cs,SetText,The following statement contains a magic number: triangles [triangleOffset + 5] = 3 + vertexOffset;  
Magic Number,BitmapFont,Renderer,C:\repos\ycchiu_Unity\FuseSparxDemo\Assets\Scripts\UI\Flash\lwf\renderer\bitmapfont\bitmapfont_renderer.cs,SetText,The following statement contains a magic number: for (int n = 0; n < 4; ++n)  	vertexColors [vertexOffset + n] = colors [i];  
Magic Number,BitmapFont,Renderer,C:\repos\ycchiu_Unity\FuseSparxDemo\Assets\Scripts\UI\Flash\lwf\renderer\bitmapfont\bitmapfont_renderer.cs,SetText,The following statement contains a magic number: if (mWidth != 0 && mAlign != Align.LEFT) {  	// EBG START - GC OPTIM  	//foreach (LineContext line in lines) {  	for (int j = 0; j < lines.Count; ++j) {  		LineContext line = lines [j];  		// EBG END  		float tw = line.right - line.left;  		float offset;  		if (mAlign == Align.CENTER) {  			offset = (mWidth - mRightMargin - tw) / 2.0f;  		}  		else {  			// Align.RIGHT  			offset = mWidth - mRightMargin - tw;  		}  		for (int i = line.vertexBegin; i < line.vertexEnd; ++i)  			for (int n = 0; n < 4; ++n)  				vertices [i * 4 + n].x += offset;  	}  }  
Magic Number,BitmapFont,Renderer,C:\repos\ycchiu_Unity\FuseSparxDemo\Assets\Scripts\UI\Flash\lwf\renderer\bitmapfont\bitmapfont_renderer.cs,SetText,The following statement contains a magic number: if (mWidth != 0 && mAlign != Align.LEFT) {  	// EBG START - GC OPTIM  	//foreach (LineContext line in lines) {  	for (int j = 0; j < lines.Count; ++j) {  		LineContext line = lines [j];  		// EBG END  		float tw = line.right - line.left;  		float offset;  		if (mAlign == Align.CENTER) {  			offset = (mWidth - mRightMargin - tw) / 2.0f;  		}  		else {  			// Align.RIGHT  			offset = mWidth - mRightMargin - tw;  		}  		for (int i = line.vertexBegin; i < line.vertexEnd; ++i)  			for (int n = 0; n < 4; ++n)  				vertices [i * 4 + n].x += offset;  	}  }  
Magic Number,BitmapFont,Renderer,C:\repos\ycchiu_Unity\FuseSparxDemo\Assets\Scripts\UI\Flash\lwf\renderer\bitmapfont\bitmapfont_renderer.cs,SetText,The following statement contains a magic number: for (int j = 0; j < lines.Count; ++j) {  	LineContext line = lines [j];  	// EBG END  	float tw = line.right - line.left;  	float offset;  	if (mAlign == Align.CENTER) {  		offset = (mWidth - mRightMargin - tw) / 2.0f;  	}  	else {  		// Align.RIGHT  		offset = mWidth - mRightMargin - tw;  	}  	for (int i = line.vertexBegin; i < line.vertexEnd; ++i)  		for (int n = 0; n < 4; ++n)  			vertices [i * 4 + n].x += offset;  }  
Magic Number,BitmapFont,Renderer,C:\repos\ycchiu_Unity\FuseSparxDemo\Assets\Scripts\UI\Flash\lwf\renderer\bitmapfont\bitmapfont_renderer.cs,SetText,The following statement contains a magic number: for (int j = 0; j < lines.Count; ++j) {  	LineContext line = lines [j];  	// EBG END  	float tw = line.right - line.left;  	float offset;  	if (mAlign == Align.CENTER) {  		offset = (mWidth - mRightMargin - tw) / 2.0f;  	}  	else {  		// Align.RIGHT  		offset = mWidth - mRightMargin - tw;  	}  	for (int i = line.vertexBegin; i < line.vertexEnd; ++i)  		for (int n = 0; n < 4; ++n)  			vertices [i * 4 + n].x += offset;  }  
Magic Number,BitmapFont,Renderer,C:\repos\ycchiu_Unity\FuseSparxDemo\Assets\Scripts\UI\Flash\lwf\renderer\bitmapfont\bitmapfont_renderer.cs,SetText,The following statement contains a magic number: for (int i = line.vertexBegin; i < line.vertexEnd; ++i)  	for (int n = 0; n < 4; ++n)  		vertices [i * 4 + n].x += offset;  
Magic Number,BitmapFont,Renderer,C:\repos\ycchiu_Unity\FuseSparxDemo\Assets\Scripts\UI\Flash\lwf\renderer\bitmapfont\bitmapfont_renderer.cs,SetText,The following statement contains a magic number: for (int i = line.vertexBegin; i < line.vertexEnd; ++i)  	for (int n = 0; n < 4; ++n)  		vertices [i * 4 + n].x += offset;  
Magic Number,BitmapFont,Renderer,C:\repos\ycchiu_Unity\FuseSparxDemo\Assets\Scripts\UI\Flash\lwf\renderer\bitmapfont\bitmapfont_renderer.cs,SetText,The following statement contains a magic number: for (int n = 0; n < 4; ++n)  	vertices [i * 4 + n].x += offset;  
Magic Number,BitmapFont,Renderer,C:\repos\ycchiu_Unity\FuseSparxDemo\Assets\Scripts\UI\Flash\lwf\renderer\bitmapfont\bitmapfont_renderer.cs,SetText,The following statement contains a magic number: for (int n = 0; n < 4; ++n)  	vertices [i * 4 + n].x += offset;  
Magic Number,BitmapFont,Renderer,C:\repos\ycchiu_Unity\FuseSparxDemo\Assets\Scripts\UI\Flash\lwf\renderer\bitmapfont\bitmapfont_renderer.cs,SetText,The following statement contains a magic number: vertices [i * 4 + n].x += offset;  
Magic Number,CombinedMeshRenderer,BitmapContext,C:\repos\ycchiu_Unity\FuseSparxDemo\Assets\Scripts\UI\Flash\lwf\renderer\combinedmesh\lwf_combinedmesh_bitmap.cs,BitmapContext,The following statement contains a magic number: triangles = new int[] {  	0'  	1'  	2'  	2'  	1'  	3'  };  
Magic Number,CombinedMeshRenderer,BitmapContext,C:\repos\ycchiu_Unity\FuseSparxDemo\Assets\Scripts\UI\Flash\lwf\renderer\combinedmesh\lwf_combinedmesh_bitmap.cs,BitmapContext,The following statement contains a magic number: triangles = new int[] {  	0'  	1'  	2'  	2'  	1'  	3'  };  
Magic Number,CombinedMeshRenderer,BitmapContext,C:\repos\ycchiu_Unity\FuseSparxDemo\Assets\Scripts\UI\Flash\lwf\renderer\combinedmesh\lwf_combinedmesh_bitmap.cs,BitmapContext,The following statement contains a magic number: triangles = new int[] {  	0'  	1'  	2'  	2'  	1'  	3'  };  
Magic Number,CombinedMeshRenderer,BitmapRenderer,C:\repos\ycchiu_Unity\FuseSparxDemo\Assets\Scripts\UI\Flash\lwf\renderer\combinedmesh\lwf_combinedmesh_bitmap.cs,Render,The following statement contains a magic number: if (bc.r != color32.r || bc.g != color32.g || bc.b != color32.b || bc.a != color32.a) {  	for (int i = 0; i < 4; ++i)  		buffer.colors32 [index + i] = color32;  }  
Magic Number,CombinedMeshRenderer,BitmapRenderer,C:\repos\ycchiu_Unity\FuseSparxDemo\Assets\Scripts\UI\Flash\lwf\renderer\combinedmesh\lwf_combinedmesh_bitmap.cs,Render,The following statement contains a magic number: for (int i = 0; i < 4; ++i)  	buffer.colors32 [index + i] = color32;  
Magic Number,CombinedMeshRenderer,BitmapRenderer,C:\repos\ycchiu_Unity\FuseSparxDemo\Assets\Scripts\UI\Flash\lwf\renderer\combinedmesh\lwf_combinedmesh_bitmap.cs,Render,The following statement contains a magic number: if (!buffer.clean && m_available && buffer.objects [bufferIndex] == m_context.objectId) {  	index = bufferIndex * 4;  	for (int i = 0; i < 4; ++i) {  		buffer.vertices [index + i] = m_matrix.MultiplyPoint3x4 (m_context.vertices [i]);  	}  	return;  }  
Magic Number,CombinedMeshRenderer,BitmapRenderer,C:\repos\ycchiu_Unity\FuseSparxDemo\Assets\Scripts\UI\Flash\lwf\renderer\combinedmesh\lwf_combinedmesh_bitmap.cs,Render,The following statement contains a magic number: if (!buffer.clean && m_available && buffer.objects [bufferIndex] == m_context.objectId) {  	index = bufferIndex * 4;  	for (int i = 0; i < 4; ++i) {  		buffer.vertices [index + i] = m_matrix.MultiplyPoint3x4 (m_context.vertices [i]);  	}  	return;  }  
Magic Number,CombinedMeshRenderer,BitmapRenderer,C:\repos\ycchiu_Unity\FuseSparxDemo\Assets\Scripts\UI\Flash\lwf\renderer\combinedmesh\lwf_combinedmesh_bitmap.cs,Render,The following statement contains a magic number: index = bufferIndex * 4;  
Magic Number,CombinedMeshRenderer,BitmapRenderer,C:\repos\ycchiu_Unity\FuseSparxDemo\Assets\Scripts\UI\Flash\lwf\renderer\combinedmesh\lwf_combinedmesh_bitmap.cs,Render,The following statement contains a magic number: for (int i = 0; i < 4; ++i) {  	buffer.vertices [index + i] = m_matrix.MultiplyPoint3x4 (m_context.vertices [i]);  }  
Magic Number,CombinedMeshRenderer,BitmapRenderer,C:\repos\ycchiu_Unity\FuseSparxDemo\Assets\Scripts\UI\Flash\lwf\renderer\combinedmesh\lwf_combinedmesh_bitmap.cs,Render,The following statement contains a magic number: index = bufferIndex * 4;  
Magic Number,CombinedMeshRenderer,BitmapRenderer,C:\repos\ycchiu_Unity\FuseSparxDemo\Assets\Scripts\UI\Flash\lwf\renderer\combinedmesh\lwf_combinedmesh_bitmap.cs,Render,The following statement contains a magic number: for (int i = 0; i < 4; ++i) {  	buffer.vertices [index + i] = m_matrix.MultiplyPoint3x4 (m_context.vertices [i]);  	buffer.uv [index + i] = m_context.uv [i];  }  
Magic Number,CombinedMeshRenderer,BitmapRenderer,C:\repos\ycchiu_Unity\FuseSparxDemo\Assets\Scripts\UI\Flash\lwf\renderer\combinedmesh\lwf_combinedmesh_bitmap.cs,Render,The following statement contains a magic number: index = bufferIndex * 6;  
Magic Number,CombinedMeshRenderer,BitmapRenderer,C:\repos\ycchiu_Unity\FuseSparxDemo\Assets\Scripts\UI\Flash\lwf\renderer\combinedmesh\lwf_combinedmesh_bitmap.cs,Render,The following statement contains a magic number: for (int i = 0; i < 6; ++i)  	buffer.triangles [index + i] = m_context.triangles [i] + offset;  
Magic Number,CombinedMeshRenderer,BitmapRenderer,C:\repos\ycchiu_Unity\FuseSparxDemo\Assets\Scripts\UI\Flash\lwf\renderer\combinedmesh\lwf_combinedmesh_bitmap.cs,Render,The following statement contains a magic number: index = bufferIndex * 4;  
Magic Number,CombinedMeshRenderer,BitmapRenderer,C:\repos\ycchiu_Unity\FuseSparxDemo\Assets\Scripts\UI\Flash\lwf\renderer\combinedmesh\lwf_combinedmesh_bitmap.cs,Render,The following statement contains a magic number: for (int i = 0; i < 4; ++i) {  	buffer.vertices [index + i] = v;  	buffer.colors32 [index + i] = s_clearColor;  }  
Magic Number,CombinedMeshRenderer,CombinedMeshBuffer,C:\repos\ycchiu_Unity\FuseSparxDemo\Assets\Scripts\UI\Flash\lwf\renderer\combinedmesh\lwf_combinedmesh_factory.cs,Alloc,The following statement contains a magic number: vertices = new Vector3[n * 4];  
Magic Number,CombinedMeshRenderer,CombinedMeshBuffer,C:\repos\ycchiu_Unity\FuseSparxDemo\Assets\Scripts\UI\Flash\lwf\renderer\combinedmesh\lwf_combinedmesh_factory.cs,Alloc,The following statement contains a magic number: uv = new Vector2[n * 4];  
Magic Number,CombinedMeshRenderer,CombinedMeshBuffer,C:\repos\ycchiu_Unity\FuseSparxDemo\Assets\Scripts\UI\Flash\lwf\renderer\combinedmesh\lwf_combinedmesh_factory.cs,Alloc,The following statement contains a magic number: triangles = new int[n * 6];  
Magic Number,CombinedMeshRenderer,CombinedMeshBuffer,C:\repos\ycchiu_Unity\FuseSparxDemo\Assets\Scripts\UI\Flash\lwf\renderer\combinedmesh\lwf_combinedmesh_factory.cs,Alloc,The following statement contains a magic number: colors32 = new Color32[n * 4];  
Magic Number,UnityRenderer,ResourceCache,C:\repos\ycchiu_Unity\FuseSparxDemo\Assets\Scripts\UI\Flash\lwf\renderer\common\lwf_unity_resourcecache.cs,LoadMesh,The following statement contains a magic number: if (!m_meshCache.TryGetValue (cacheName' out item)) {  	Format.TextureFragment fragment = data.textureFragments [bitmapEx.textureFragmentId];  	Format.Texture texture = data.textures [fragment.textureId];  	float tw = (float)texture.width;  	float th = (float)texture.height;  	float x = (float)fragment.x;  	float y = -(float)fragment.y;  	float u = (float)fragment.u;  	float v = th - (float)fragment.v;  	float w = (float)fragment.w;  	float h = (float)fragment.h;  	float bu = bitmapEx.u * w;  	float bv = bitmapEx.v * h;  	float bw = bitmapEx.w;  	float bh = bitmapEx.h;  	x += bu;  	y += bv;  	u += bu;  	v += bv;  	w *= bw;  	h *= bh;  	float height = h / texture.scale;  	float x0 = x / texture.scale;  	float y0 = y / texture.scale;  	float x1 = (x + w) / texture.scale;  	float y1 = (y + h) / texture.scale;  	Mesh mesh = new Mesh ();  	mesh.name = "LWF/" + cacheName;  	mesh.vertices = new Vector3[] {  		new Vector3 (x1' y1' 0)'  		new Vector3 (x1' y0' 0)'  		new Vector3 (x0' y1' 0)'  		new Vector3 (x0' y0' 0)'  	};  	if (fragment.rotated == 0) {  		float u0 = u / tw;  		float v0 = (v - h) / th;  		float u1 = (u + w) / tw;  		float v1 = v / th;  		mesh.uv = new Vector2[] {  			new Vector2 (u1' v1)'  			new Vector2 (u1' v0)'  			new Vector2 (u0' v1)'  			new Vector2 (u0' v0)'  		};  	}  	else {  		float u0 = u / tw;  		float v0 = (v - w) / th;  		float u1 = (u + h) / tw;  		float v1 = v / th;  		mesh.uv = new Vector2[] {  			new Vector2 (u1' v0)'  			new Vector2 (u0' v0)'  			new Vector2 (u1' v1)'  			new Vector2 (u0' v1)'  		};  	}  	mesh.triangles = new int[] {  		0'  		1'  		2'  		2'  		1'  		3'  	};  	mesh.RecalculateBounds ();  	//mesh.Optimize();  	MeshContext context = new MeshContext (mesh' height);  	item = new MeshItem (context);  	m_meshCache [cacheName] = item;  }  
Magic Number,UnityRenderer,ResourceCache,C:\repos\ycchiu_Unity\FuseSparxDemo\Assets\Scripts\UI\Flash\lwf\renderer\common\lwf_unity_resourcecache.cs,LoadMesh,The following statement contains a magic number: if (!m_meshCache.TryGetValue (cacheName' out item)) {  	Format.TextureFragment fragment = data.textureFragments [bitmapEx.textureFragmentId];  	Format.Texture texture = data.textures [fragment.textureId];  	float tw = (float)texture.width;  	float th = (float)texture.height;  	float x = (float)fragment.x;  	float y = -(float)fragment.y;  	float u = (float)fragment.u;  	float v = th - (float)fragment.v;  	float w = (float)fragment.w;  	float h = (float)fragment.h;  	float bu = bitmapEx.u * w;  	float bv = bitmapEx.v * h;  	float bw = bitmapEx.w;  	float bh = bitmapEx.h;  	x += bu;  	y += bv;  	u += bu;  	v += bv;  	w *= bw;  	h *= bh;  	float height = h / texture.scale;  	float x0 = x / texture.scale;  	float y0 = y / texture.scale;  	float x1 = (x + w) / texture.scale;  	float y1 = (y + h) / texture.scale;  	Mesh mesh = new Mesh ();  	mesh.name = "LWF/" + cacheName;  	mesh.vertices = new Vector3[] {  		new Vector3 (x1' y1' 0)'  		new Vector3 (x1' y0' 0)'  		new Vector3 (x0' y1' 0)'  		new Vector3 (x0' y0' 0)'  	};  	if (fragment.rotated == 0) {  		float u0 = u / tw;  		float v0 = (v - h) / th;  		float u1 = (u + w) / tw;  		float v1 = v / th;  		mesh.uv = new Vector2[] {  			new Vector2 (u1' v1)'  			new Vector2 (u1' v0)'  			new Vector2 (u0' v1)'  			new Vector2 (u0' v0)'  		};  	}  	else {  		float u0 = u / tw;  		float v0 = (v - w) / th;  		float u1 = (u + h) / tw;  		float v1 = v / th;  		mesh.uv = new Vector2[] {  			new Vector2 (u1' v0)'  			new Vector2 (u0' v0)'  			new Vector2 (u1' v1)'  			new Vector2 (u0' v1)'  		};  	}  	mesh.triangles = new int[] {  		0'  		1'  		2'  		2'  		1'  		3'  	};  	mesh.RecalculateBounds ();  	//mesh.Optimize();  	MeshContext context = new MeshContext (mesh' height);  	item = new MeshItem (context);  	m_meshCache [cacheName] = item;  }  
Magic Number,UnityRenderer,ResourceCache,C:\repos\ycchiu_Unity\FuseSparxDemo\Assets\Scripts\UI\Flash\lwf\renderer\common\lwf_unity_resourcecache.cs,LoadMesh,The following statement contains a magic number: if (!m_meshCache.TryGetValue (cacheName' out item)) {  	Format.TextureFragment fragment = data.textureFragments [bitmapEx.textureFragmentId];  	Format.Texture texture = data.textures [fragment.textureId];  	float tw = (float)texture.width;  	float th = (float)texture.height;  	float x = (float)fragment.x;  	float y = -(float)fragment.y;  	float u = (float)fragment.u;  	float v = th - (float)fragment.v;  	float w = (float)fragment.w;  	float h = (float)fragment.h;  	float bu = bitmapEx.u * w;  	float bv = bitmapEx.v * h;  	float bw = bitmapEx.w;  	float bh = bitmapEx.h;  	x += bu;  	y += bv;  	u += bu;  	v += bv;  	w *= bw;  	h *= bh;  	float height = h / texture.scale;  	float x0 = x / texture.scale;  	float y0 = y / texture.scale;  	float x1 = (x + w) / texture.scale;  	float y1 = (y + h) / texture.scale;  	Mesh mesh = new Mesh ();  	mesh.name = "LWF/" + cacheName;  	mesh.vertices = new Vector3[] {  		new Vector3 (x1' y1' 0)'  		new Vector3 (x1' y0' 0)'  		new Vector3 (x0' y1' 0)'  		new Vector3 (x0' y0' 0)'  	};  	if (fragment.rotated == 0) {  		float u0 = u / tw;  		float v0 = (v - h) / th;  		float u1 = (u + w) / tw;  		float v1 = v / th;  		mesh.uv = new Vector2[] {  			new Vector2 (u1' v1)'  			new Vector2 (u1' v0)'  			new Vector2 (u0' v1)'  			new Vector2 (u0' v0)'  		};  	}  	else {  		float u0 = u / tw;  		float v0 = (v - w) / th;  		float u1 = (u + h) / tw;  		float v1 = v / th;  		mesh.uv = new Vector2[] {  			new Vector2 (u1' v0)'  			new Vector2 (u0' v0)'  			new Vector2 (u1' v1)'  			new Vector2 (u0' v1)'  		};  	}  	mesh.triangles = new int[] {  		0'  		1'  		2'  		2'  		1'  		3'  	};  	mesh.RecalculateBounds ();  	//mesh.Optimize();  	MeshContext context = new MeshContext (mesh' height);  	item = new MeshItem (context);  	m_meshCache [cacheName] = item;  }  
Magic Number,UnityRenderer,ResourceCache,C:\repos\ycchiu_Unity\FuseSparxDemo\Assets\Scripts\UI\Flash\lwf\renderer\common\lwf_unity_resourcecache.cs,LoadMesh,The following statement contains a magic number: mesh.triangles = new int[] {  	0'  	1'  	2'  	2'  	1'  	3'  };  
Magic Number,UnityRenderer,ResourceCache,C:\repos\ycchiu_Unity\FuseSparxDemo\Assets\Scripts\UI\Flash\lwf\renderer\common\lwf_unity_resourcecache.cs,LoadMesh,The following statement contains a magic number: mesh.triangles = new int[] {  	0'  	1'  	2'  	2'  	1'  	3'  };  
Magic Number,UnityRenderer,ResourceCache,C:\repos\ycchiu_Unity\FuseSparxDemo\Assets\Scripts\UI\Flash\lwf\renderer\common\lwf_unity_resourcecache.cs,LoadMesh,The following statement contains a magic number: mesh.triangles = new int[] {  	0'  	1'  	2'  	2'  	1'  	3'  };  
Missing Default,LWF,ButtonEventHandlers,C:\repos\ycchiu_Unity\FuseSparxDemo\Assets\Scripts\UI\Flash\lwf\core\lwf_eventbutton.cs,Clear,The following switch statement is missing a default case: switch (type) {  case Type.LOAD:  	load.Clear ();  	break;  case Type.UNLOAD:  	unload.Clear ();  	break;  case Type.ENTERFRAME:  	enterFrame.Clear ();  	break;  case Type.UPDATE:  	update.Clear ();  	break;  case Type.RENDER:  	render.Clear ();  	break;  case Type.PRESS:  	press.Clear ();  	break;  case Type.RELEASE:  	release.Clear ();  	break;  case Type.ROLLOVER:  	rollOver.Clear ();  	break;  case Type.ROLLOUT:  	rollOut.Clear ();  	break;  case Type.KEYPRESS:  	keyPress.Clear ();  	break;  }  
Missing Default,LWF,ButtonEventHandlers,C:\repos\ycchiu_Unity\FuseSparxDemo\Assets\Scripts\UI\Flash\lwf\core\lwf_eventbutton.cs,Call,The following switch statement is missing a default case: switch (type) {  case Type.LOAD:  	list = load;  	break;  case Type.UNLOAD:  	list = unload;  	break;  case Type.ENTERFRAME:  	list = enterFrame;  	break;  case Type.UPDATE:  	list = update;  	break;  case Type.RENDER:  	list = render;  	break;  case Type.PRESS:  	list = press;  	break;  case Type.RELEASE:  	list = release;  	break;  case Type.ROLLOVER:  	list = rollOver;  	break;  case Type.ROLLOUT:  	list = rollOut;  	break;  }  
Missing Default,LWF,MovieEventHandlers,C:\repos\ycchiu_Unity\FuseSparxDemo\Assets\Scripts\UI\Flash\lwf\core\lwf_eventmovie.cs,Clear,The following switch statement is missing a default case: switch (type) {  case Type.LOAD:  	load.Clear ();  	break;  case Type.POSTLOAD:  	postLoad.Clear ();  	break;  case Type.UNLOAD:  	unload.Clear ();  	break;  case Type.ENTERFRAME:  	enterFrame.Clear ();  	break;  case Type.UPDATE:  	update.Clear ();  	break;  case Type.RENDER:  	render.Clear ();  	break;  }  
Missing Default,LWF,MovieEventHandlers,C:\repos\ycchiu_Unity\FuseSparxDemo\Assets\Scripts\UI\Flash\lwf\core\lwf_eventmovie.cs,Call,The following switch statement is missing a default case: switch (type) {  case Type.LOAD:  	list = load;  	break;  case Type.POSTLOAD:  	list = postLoad;  	break;  case Type.UNLOAD:  	list = unload;  	break;  case Type.ENTERFRAME:  	list = enterFrame;  	break;  case Type.UPDATE:  	list = update;  	break;  case Type.RENDER:  	list = render;  	break;  }  
Missing Default,LWF,Graphic,C:\repos\ycchiu_Unity\FuseSparxDemo\Assets\Scripts\UI\Flash\lwf\core\lwf_graphic.cs,Graphic,The following switch statement is missing a default case: switch ((Type)gobj.graphicObjectType) {  case Type.BITMAP:  	obj = new Bitmap (lwf' parent' graphicObjectId);  	break;  case Type.BITMAPEX:  	obj = new BitmapEx (lwf' parent' graphicObjectId);  	break;  case Type.TEXT:  	obj = new Text (lwf' parent' graphicObjectId);  	break;  }  
Missing Default,LWF,Movie,C:\repos\ycchiu_Unity\FuseSparxDemo\Assets\Scripts\UI\Flash\lwf\core\lwf_movie.cs,ExecObject,The following switch statement is missing a default case: switch ((Type)dataObject.objectType) {  case Type.BUTTON:  	obj = new Button (m_lwf' this' dataObjectId' instId' matrixId' colorTransformId);  	break;  case Type.GRAPHIC:  	obj = new Graphic (m_lwf' this' dataObjectId);  	break;  case Type.MOVIE:  	obj = new Movie (m_lwf' this' dataObjectId' instId' matrixId' colorTransformId);  	((Movie)obj).blendMode = dlBlendMode;  	break;  case Type.BITMAP:  	obj = new Bitmap (m_lwf' this' dataObjectId);  	break;  case Type.BITMAPEX:  	obj = new BitmapEx (m_lwf' this' dataObjectId);  	break;  case Type.TEXT:  	obj = new Text (m_lwf' this' dataObjectId' instId);  	break;  case Type.PARTICLE:  	obj = new Particle (m_lwf' this' dataObjectId);  	break;  case Type.PROGRAMOBJECT:  	obj = new ProgramObject (m_lwf' this' dataObjectId);  	break;  }  
Missing Default,LWF,Movie,C:\repos\ycchiu_Unity\FuseSparxDemo\Assets\Scripts\UI\Flash\lwf\core\lwf_movie.cs,PostExec,The following switch statement is missing a default case: switch ((Format.Control.Type)control.controlType) {  case Format.Control.Type.MOVE:  	{  		Format.Place p = data.places [control.controlId];  		ExecObject (p.depth' p.objectId' p.matrixId' 0' p.instanceId' p.blendMode);  	}  	break;  case Format.Control.Type.MOVEM:  	{  		Format.ControlMoveM ctrl = data.controlMoveMs [control.controlId];  		Format.Place p = data.places [ctrl.placeId];  		ExecObject (p.depth' p.objectId' ctrl.matrixId' 0' p.instanceId' p.blendMode);  	}  	break;  case Format.Control.Type.MOVEC:  	{  		Format.ControlMoveC ctrl = data.controlMoveCs [control.controlId];  		Format.Place p = data.places [ctrl.placeId];  		ExecObject (p.depth' p.objectId' p.matrixId' ctrl.colorTransformId' p.instanceId' p.blendMode);  	}  	break;  case Format.Control.Type.MOVEMC:  	{  		Format.ControlMoveMC ctrl = data.controlMoveMCs [control.controlId];  		Format.Place p = data.places [ctrl.placeId];  		ExecObject (p.depth' p.objectId' ctrl.matrixId' ctrl.colorTransformId' p.instanceId' p.blendMode);  	}  	break;  case Format.Control.Type.ANIMATION:  	if (controlAnimationOffset == -1)  		controlAnimationOffset = i;  	break;  }  
Missing Default,LWF,Movie,C:\repos\ycchiu_Unity\FuseSparxDemo\Assets\Scripts\UI\Flash\lwf\core\lwf_movie.cs,Render,The following switch statement is missing a default case: switch (m_blendMode) {  case (int)Constant.BLEND_MODE_ADD:  	m_lwf.BeginBlendMode (m_blendMode);  	useBlendMode = true;  	break;  case (int)Constant.BLEND_MODE_ERASE:  case (int)Constant.BLEND_MODE_LAYER:  case (int)Constant.BLEND_MODE_MASK:  	m_lwf.BeginMaskMode (m_blendMode);  	useMaskMode = true;  	break;  }  
