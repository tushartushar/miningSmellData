Implementation smell,Namespace,Class,File,Method,Description
Long Method,RegExpose,GroupingContainerNode,C:\research\architectureSmells\repos\QuickenLoans_RegExpose\RegExpose\GroupingContainerNode.cs,Parse,The method has 134 lines of code.
Long Method,RegExpose,RegexCompiler,C:\research\architectureSmells\repos\QuickenLoans_RegExpose\RegExpose\RegexCompiler.cs,GetContainer,The method has 241 lines of code.
Complex Method,RegExpose,GroupingContainerNode,C:\research\architectureSmells\repos\QuickenLoans_RegExpose\RegExpose\GroupingContainerNode.cs,Parse,Cyclomatic complexity of the method is 20
Complex Method,RegExpose,RegexCompiler,C:\research\architectureSmells\repos\QuickenLoans_RegExpose\RegExpose\RegexCompiler.cs,CreateQuantifier,Cyclomatic complexity of the method is 12
Complex Method,RegExpose,RegexCompiler,C:\research\architectureSmells\repos\QuickenLoans_RegExpose\RegExpose\RegexCompiler.cs,GetContainer,Cyclomatic complexity of the method is 25
Complex Method,RegExpose.Nodes.Alternation,Alternation,C:\research\architectureSmells\repos\QuickenLoans_RegExpose\RegExpose\Nodes\Alternation\Alternation.cs,Parse,Cyclomatic complexity of the method is 9
Complex Method,RegExpose.Nodes.Parens,LookAround,C:\research\architectureSmells\repos\QuickenLoans_RegExpose\RegExpose\Nodes\Parens\LookAround.cs,Parse,Cyclomatic complexity of the method is 12
Complex Method,RegExpose.Nodes,RegexNodeCollection<TRegexNode>,C:\research\architectureSmells\repos\QuickenLoans_RegExpose\RegExpose\Nodes\RegexNodeCollection.cs,FindNodeBy,Cyclomatic complexity of the method is 8
Complex Method,RegExpose.Nodes.Quantifiers,GreedyQuantifier,C:\research\architectureSmells\repos\QuickenLoans_RegExpose\RegExpose\Nodes\Quantifiers\GreedyQuantifier.cs,ParseSpecific,Cyclomatic complexity of the method is 15
Long Parameter List,RegExpose,Group,C:\research\architectureSmells\repos\QuickenLoans_RegExpose\RegExpose\Group.cs,Group,The method has 5 parameters. Parameters: number' index' length' value' success
Long Parameter List,RegExpose,ParseStep,C:\research\architectureSmells\repos\QuickenLoans_RegExpose\RegExpose\ParseStep.cs,Capture,The method has 5 parameters. Parameters: node' capturedText' captureNumber' initialState' currentState
Long Parameter List,RegExpose,ParseStep,C:\research\architectureSmells\repos\QuickenLoans_RegExpose\RegExpose\ParseStep.cs,ConvertToOuterContext,The method has 5 parameters. Parameters: input' indexModifier' regexNode' changeNodePredicate' modifyMessageFunction
Long Parameter List,RegExpose.Nodes.Character,CharacterClass,C:\research\architectureSmells\repos\QuickenLoans_RegExpose\RegExpose\Nodes\Character\CharacterClass.cs,CharacterClass,The method has 5 parameters. Parameters: characterClassParts' negated' ignoreCase' index' pattern
Long Parameter List,RegExpose.Nodes.Quantifiers,GreedyQuantifier,C:\research\architectureSmells\repos\QuickenLoans_RegExpose\RegExpose\Nodes\Quantifiers\GreedyQuantifier.cs,GreedyQuantifier,The method has 5 parameters. Parameters: min' max' child' index' pattern
Long Parameter List,RegExpose.Nodes.Quantifiers,LazyQuantifier,C:\research\architectureSmells\repos\QuickenLoans_RegExpose\RegExpose\Nodes\Quantifiers\LazyQuantifier.cs,LazyQuantifier,The method has 5 parameters. Parameters: min' max' child' index' pattern
Long Parameter List,RegExpose.Nodes.Quantifiers,PossessiveQuantifier,C:\research\architectureSmells\repos\QuickenLoans_RegExpose\RegExpose\Nodes\Quantifiers\PossessiveQuantifier.cs,PossessiveQuantifier,The method has 5 parameters. Parameters: min' max' child' index' pattern
Long Parameter List,RegExpose.Nodes.Quantifiers,Quantifier,C:\research\architectureSmells\repos\QuickenLoans_RegExpose\RegExpose\Nodes\Quantifiers\Quantifier.cs,Quantifier,The method has 5 parameters. Parameters: min' max' child' index' pattern
Long Identifier,RegExpose,RegexCompiler,C:\research\architectureSmells\repos\QuickenLoans_RegExpose\RegExpose\RegexCompiler.cs,CreateCharacterClassParser,The length of the parameter characterClassAlwaysLegalCharacter is 34.
Long Identifier,RegExpose,RegexCompiler,C:\research\architectureSmells\repos\QuickenLoans_RegExpose\RegExpose\RegexCompiler.cs,CreateCharacterClassParser,The length of the parameter characterClassEscapedCharacters is 31.
Long Identifier,RegExpose,RegexCompiler,C:\research\architectureSmells\repos\QuickenLoans_RegExpose\RegExpose\RegexCompiler.cs,CreateCharacterClassParser,The length of the parameter characterClassLiteralCharacters is 31.
Long Identifier,RegExpose,RegexCompiler,C:\research\architectureSmells\repos\QuickenLoans_RegExpose\RegExpose\RegexCompiler.cs,CreateBackreferenceParser,The length of the parameter angleBracketNamedBackreferenceParser is 36.
Long Statement,RegExpose,GroupingContainerNode,C:\research\architectureSmells\repos\QuickenLoans_RegExpose\RegExpose\GroupingContainerNode.cs,Parse,The length of the statement  "            // Attempt the regex at every location in the input' starting at the beginning and going until just past the last position." is 123.
Long Statement,RegExpose,ParseStep,C:\research\architectureSmells\repos\QuickenLoans_RegExpose\RegExpose\ParseStep.cs,Fail,The length of the statement  "            }.WithMessage(step => (additionalMessage != null ? additionalMessage + ": " : "") + node.GetFailMessage(step.InitialState));" is 124.
Long Statement,RegExpose,RegexCompiler,C:\research\architectureSmells\repos\QuickenLoans_RegExpose\RegExpose\RegexCompiler.cs,Compile,The length of the statement  "                            "Unable to consume entire pattern (possible unmatched parentheses). Provided pattern was: /{0}/' parsed pattern was: /{1}/"'" is 124.
Long Statement,RegExpose,RegexCompiler,C:\research\architectureSmells\repos\QuickenLoans_RegExpose\RegExpose\RegexCompiler.cs,CreateAlternationChoice,The length of the statement  "            return new AlternationChoice(choiceNodesList' choiceNodesList.First().Index' choiceNodesList.Aggregate(""' (s' child) => s + child.Pattern));" is 141.
Long Statement,RegExpose,RegexCompiler,C:\research\architectureSmells\repos\QuickenLoans_RegExpose\RegExpose\RegexCompiler.cs,CreateBackreferenceParser,The length of the statement  "                    .ToRegexNode((number' index' pattern) => Parse.Return(new Backreference(int.Parse(number)' ignoreCase' index' pattern)));" is 121.
Long Statement,RegExpose,RegexCompiler,C:\research\architectureSmells\repos\QuickenLoans_RegExpose\RegExpose\RegexCompiler.cs,GetContainer,The length of the statement  "                        var quantifierPattern = input.Source.Substring(input.Position' quantifierParamsSuccess.Remainder.Position - input.Position);" is 124.
Long Statement,RegExpose.Nodes.Backreferences,Backreference,C:\research\architectureSmells\repos\QuickenLoans_RegExpose\RegExpose\Nodes\Backreferences\Backreference.cs,Parse,The length of the statement  "                var literals = capture.Value.Select((c' i) => new CharacterLiteral(c' _ignoreCase' capture.Index + i' new string(new[] { c })));" is 128.
Long Statement,RegExpose.Nodes.Parens,LookAround,C:\research\architectureSmells\repos\QuickenLoans_RegExpose\RegExpose\Nodes\Parens\LookAround.cs,Parse,The length of the statement  "                        .ConvertToOuterContext(outerEngine.Input' modifier' this' n => ReferenceEquals(n' _regex)' message => message.Replace(_regex.NodeType' NodeType))" is 145.
Long Statement,RegExpose.Nodes.Parens,LookAround,C:\research\architectureSmells\repos\QuickenLoans_RegExpose\RegExpose\Nodes\Parens\LookAround.cs,Parse,The length of the statement  "                    yield return ParseStep.Pass(this' ""' outerEngine.State' engine.State.Plus(modifier)).WithSkipAdvanceOnFail(ShouldSkipAdvance);" is 127.
Long Statement,RegExpose.Nodes.Parens,LookAround,C:\research\architectureSmells\repos\QuickenLoans_RegExpose\RegExpose\Nodes\Parens\LookAround.cs,Parse,The length of the statement  "                    yield return ParseStep.Fail(this' outerEngine.State' engine.State.Plus(modifier)).WithSkipAdvanceOnFail(ShouldSkipAdvance);" is 123.
Long Statement,RegExpose.Nodes.Parens,LookAround,C:\research\architectureSmells\repos\QuickenLoans_RegExpose\RegExpose\Nodes\Parens\LookAround.cs,Parse,The length of the statement  "                    yield return ParseStep.Fail(this' outerEngine.State' engine.State.Plus(modifier)).WithSkipAdvanceOnFail(ShouldSkipAdvance);" is 123.
Long Statement,RegExpose.Nodes.Parens,LookAround,C:\research\architectureSmells\repos\QuickenLoans_RegExpose\RegExpose\Nodes\Parens\LookAround.cs,Parse,The length of the statement  "                    yield return ParseStep.Pass(this' ""' outerEngine.State' engine.State.Plus(modifier)).WithSkipAdvanceOnFail(ShouldSkipAdvance);" is 127.
Long Statement,RegExpose.Nodes.Quantifiers,GreedyQuantifier,C:\research\architectureSmells\repos\QuickenLoans_RegExpose\RegExpose\Nodes\Quantifiers\GreedyQuantifier.cs,ParseSpecific,The length of the statement  "            // At this point' we know we'll match. Attempt to match everything else' until we hit max' a non-match' or the end of the string." is 129.
Long Statement,RegExpose.Nodes.Quantifiers,GreedyQuantifier,C:\research\architectureSmells\repos\QuickenLoans_RegExpose\RegExpose\Nodes\Quantifiers\GreedyQuantifier.cs,ParseSpecific,The length of the statement  "                    // We're not at the end of the string' so save state before attempting a match - since we're greedy' we leave breadcrumbs before doing anything." is 144.
Long Statement,RegExpose.Nodes.Quantifiers,GreedyQuantifier,C:\research\architectureSmells\repos\QuickenLoans_RegExpose\RegExpose\Nodes\Quantifiers\GreedyQuantifier.cs,ParseSpecific,The length of the statement  "                // TODO: I think that we're going to need to use an enumerator here so we can initiate backtracking in our child and its descendants." is 133.
Long Statement,RegExpose.Nodes.Quantifiers,LazyQuantifier,C:\research\architectureSmells\repos\QuickenLoans_RegExpose\RegExpose\Nodes\Quantifiers\LazyQuantifier.cs,ParseSpecific,The length of the statement  "                // However' if we make it to here' it indicates that we need to match more' in order to (attempt to) get the overall regex to match." is 132.
Complex Conditional,RegExpose.Nodes.Boundries,WordBoundry,C:\research\architectureSmells\repos\QuickenLoans_RegExpose\RegExpose\Nodes\Boundries\WordBoundry.cs,Matches,The conditional expression  "IsAtBeginningOfInput(state)                 || IsAtBeginningOfLine(state)                 || IsAtEndOfInput(state)                 || IsAtEndOfLine(state)"  is complex.
Magic Number,RegExpose,ParseStep,C:\research\architectureSmells\repos\QuickenLoans_RegExpose\RegExpose\ParseStep.cs,ToString,The following statement contains a magic number: return string.Format("{0}{1}{2}{3}"'                 Type.ToString().PadRight(15)'                 NodeType.PadRight(25)'                 Pattern.PadRight(35)'                 Message);
Magic Number,RegExpose,ParseStep,C:\research\architectureSmells\repos\QuickenLoans_RegExpose\RegExpose\ParseStep.cs,ToString,The following statement contains a magic number: return string.Format("{0}{1}{2}{3}"'                 Type.ToString().PadRight(15)'                 NodeType.PadRight(25)'                 Pattern.PadRight(35)'                 Message);
Magic Number,RegExpose,ParseStep,C:\research\architectureSmells\repos\QuickenLoans_RegExpose\RegExpose\ParseStep.cs,ToString,The following statement contains a magic number: return string.Format("{0}{1}{2}{3}"'                 Type.ToString().PadRight(15)'                 NodeType.PadRight(25)'                 Pattern.PadRight(35)'                 Message);
Magic Number,RegExpose.Nodes.Parens,ParenCapture,C:\research\architectureSmells\repos\QuickenLoans_RegExpose\RegExpose\Nodes\Parens\ParenCapture.cs,GetHashCode,The following statement contains a magic number: hashCode = (hashCode * 397) ^ _index;
Magic Number,RegExpose.Nodes.Parens,ParenCapture,C:\research\architectureSmells\repos\QuickenLoans_RegExpose\RegExpose\Nodes\Parens\ParenCapture.cs,GetHashCode,The following statement contains a magic number: hashCode = (hashCode * 397) ^ (_value != null ? _value.GetHashCode() : 0);
Missing Default,RegExpose,RegexCompiler,C:\research\architectureSmells\repos\QuickenLoans_RegExpose\RegExpose\RegexCompiler.cs,CreateQuantifier,The following switch statement is missing a default case: switch (quantifierParams.Shorthand)                 {                     case '?':                         if (quantifierParams.Optional != null)                         {                             if (quantifierParams.Optional == '?')                             {                                 return new LazyQuestionMark(child' index' pattern);                             }                             return new PossessiveQuestionMark(child' index' pattern);                         }                         return new GreedyQuestionMark(child' index' pattern);                     case '*':                         if (quantifierParams.Optional != null)                         {                             if (quantifierParams.Optional == '?')                             {                                 return new LazyStar(child' index' pattern);                             }                             return new PossessiveStar(child' index' pattern);                         }                         return new GreedyStar(child' index' pattern);                     case '+':                         if (quantifierParams.Optional != null)                         {                             if (quantifierParams.Optional == '?')                             {                                 return new LazyPlus(child' index' pattern);                             }                             return new PossessivePlus(child' index' pattern);                         }                         return new GreedyPlus(child' index' pattern);                 }
