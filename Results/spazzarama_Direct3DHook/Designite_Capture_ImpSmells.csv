Implementation smell,Namespace,Class,File,Method,Description
Long Method,Capture,EntryPoint,C:\repos\spazzarama_Direct3DHook\Capture\EntryPoint.cs,InitialiseDirectXHook,The method has 108 lines of code.
Long Method,Capture.Hook.DX11,DXSprite,C:\repos\spazzarama_Direct3DHook\Capture\Hook\DX11\DXSprite.cs,Initialize,The method has 111 lines of code.
Long Method,Capture.Hook.DX11,ScreenAlignedQuadRenderer,C:\repos\spazzarama_Direct3DHook\Capture\Hook\DX11\ScreenAlignedQuadRenderer.cs,CreateDeviceDependentResources,The method has 105 lines of code.
Long Method,Capture.Hook,DXHookD3D10,C:\repos\spazzarama_Direct3DHook\Capture\Hook\DXHookD3D10.cs,PresentHook,The method has 155 lines of code.
Long Method,Capture.Hook,DXHookD3D10_1,C:\repos\spazzarama_Direct3DHook\Capture\Hook\DXHookD3D10_1.cs,PresentHook,The method has 155 lines of code.
Long Method,Capture.Hook,DXHookD3D11,C:\repos\spazzarama_Direct3DHook\Capture\Hook\DXHookD3D11.cs,PresentHook,The method has 204 lines of code.
Long Method,Capture.Hook,DXHookD3D9,C:\repos\spazzarama_Direct3DHook\Capture\Hook\DXHookD3D9.cs,DoCaptureRenderTarget,The method has 140 lines of code.
Complex Method,Capture,EntryPoint,C:\repos\spazzarama_Direct3DHook\Capture\EntryPoint.cs,InitialiseDirectXHook,Cyclomatic complexity of the method is 11
Long Parameter List,Capture.Hook.DX11,DXSprite,C:\repos\spazzarama_Direct3DHook\Capture\Hook\DX11\DXSprite.cs,DrawImage,The method has 6 parameters. Parameters: x' y' scale' angle' color' image
Long Parameter List,Capture.Hook.DX11,DXSprite,C:\repos\spazzarama_Direct3DHook\Capture\Hook\DX11\DXSprite.cs,DrawString,The method has 5 parameters. Parameters: X' Y' text' color' F
Long Parameter List,Capture.Hook.DX11,DXSprite,C:\repos\spazzarama_Direct3DHook\Capture\Hook\DX11\DXSprite.cs,Draw,The method has 6 parameters. Parameters: destinationRect' sourceRect' color' scale' angle' z
Long Parameter List,Capture.Hook,BaseDXHook,C:\repos\spazzarama_Direct3DHook\Capture\Hook\BaseDXHook.cs,ProcessCapture,The method has 6 parameters. Parameters: width' height' pitch' format' pBits' request
Long Parameter List,Capture.Hook,DXHookD3D9,C:\repos\spazzarama_Direct3DHook\Capture\Hook\DXHookD3D9.cs,PresentExHook,The method has 6 parameters. Parameters: devicePtr' pSourceRect' pDestRect' hDestWindowOverride' pDirtyRegion' dwFlags
Long Parameter List,Capture.Hook,DXHookD3D9,C:\repos\spazzarama_Direct3DHook\Capture\Hook\DXHookD3D9.cs,PresentHook,The method has 5 parameters. Parameters: devicePtr' pSourceRect' pDestRect' hDestWindowOverride' pDirtyRegion
Long Parameter List,Capture.Interface,ScreenshotExtensions,C:\repos\spazzarama_Direct3DHook\Capture\Interface\ScreenshotExtensions.cs,ToBitmap,The method has 5 parameters. Parameters: data' width' height' stride' pixelFormat
Long Parameter List,Capture.Interface,CaptureInterface,C:\repos\spazzarama_Direct3DHook\Capture\Interface\CaptureInterface.cs,BeginGetScreenshot,The method has 5 parameters. Parameters: region' timeout' callback' resize' format
Long Identifier,Capture.Hook,DXHookD3D10,C:\repos\spazzarama_Direct3DHook\Capture\Hook\DXHookD3D10.cs,,The length of the parameter DXGISwapChain_ResizeTargetHook is 30.
Long Identifier,Capture.Hook,DXHookD3D10_1,C:\repos\spazzarama_Direct3DHook\Capture\Hook\DXHookD3D10_1.cs,,The length of the parameter DXGISwapChain_ResizeTargetHook is 30.
Long Identifier,Capture.Hook,DXHookD3D11,C:\repos\spazzarama_Direct3DHook\Capture\Hook\DXHookD3D11.cs,,The length of the parameter DXGISwapChain_ResizeTargetHook is 30.
Long Identifier,Capture.Hook,DXHookD3D9,C:\repos\spazzarama_Direct3DHook\Capture\Hook\DXHookD3D9.cs,,The length of the parameter Direct3DDeviceEx_PresentExHook is 30.
Long Statement,Capture,EntryPoint,C:\repos\spazzarama_Direct3DHook\Capture\EntryPoint.cs,Run,The length of the statement  "            _interface.Message(MessageType.Information' "Injected into process Id:{0}."' EasyHook.RemoteHooking.GetCurrentProcessId()); " is 123.
Long Statement,Capture,EntryPoint,C:\repos\spazzarama_Direct3DHook\Capture\EntryPoint.cs,Run,The length of the statement  "                    _interface.Message(MessageType.Information' "Disconnecting from process {0}"' EasyHook.RemoteHooking.GetCurrentProcessId()); " is 124.
Long Statement,Capture,EntryPoint,C:\repos\spazzarama_Direct3DHook\Capture\EntryPoint.cs,InitialiseDirectXHook,The length of the statement  "                    // In most cases this will work fine' however it is perfectly ok for an application to use a D3D10 device along with D3D11 devices " is 130.
Long Statement,Capture,EntryPoint,C:\repos\spazzarama_Direct3DHook\Capture\EntryPoint.cs,InitialiseDirectXHook,The length of the statement  "                    while (d3D9Loaded == IntPtr.Zero && d3D10Loaded == IntPtr.Zero && d3D10_1Loaded == IntPtr.Zero && d3D11Loaded == IntPtr.Zero && d3D11_1Loaded == IntPtr.Zero) " is 157.
Long Statement,Capture.Hook.DX11,DXImage,C:\repos\spazzarama_Direct3DHook\Capture\Hook\DX11\DXImage.cs,Initialise,The length of the statement  "            bmData = bitmap.LockBits(new System.Drawing.Rectangle(0' 0' _texWidth' _texHeight)' System.Drawing.Imaging.ImageLockMode.ReadOnly' System.Drawing.Imaging.PixelFormat.Format32bppArgb); " is 183.
Long Statement,Capture.Hook.DX11,DXOverlayEngine,C:\repos\spazzarama_Direct3DHook\Capture\Hook\DX11\DXOverlayEngine.cs,Initialise,The length of the statement  "                //    ViewportF[] viewportf = { new ViewportF(0' 0' _renderTarget.Description.Width' _renderTarget.Description.Height' 0' 1) }; " is 127.
Long Statement,Capture.Hook.DX11,DXOverlayEngine,C:\repos\spazzarama_Direct3DHook\Capture\Hook\DX11\DXOverlayEngine.cs,Begin,The length of the statement  "                ViewportF[] viewportf = { new ViewportF(0' 0' _renderTarget.Description.Width' _renderTarget.Description.Height' 0' 1) }; " is 121.
Long Statement,Capture.Hook.DX11,DXOverlayEngine,C:\repos\spazzarama_Direct3DHook\Capture\Hook\DX11\DXOverlayEngine.cs,Draw,The length of the statement  "                            _spriteEngine.DrawImage(imageElement.Location.X' imageElement.Location.Y' imageElement.Scale' imageElement.Angle' imageElement.Tint' image); " is 140.
Long Statement,Capture.Hook.DX11,DXOverlayEngine,C:\repos\spazzarama_Direct3DHook\Capture\Hook\DX11\DXOverlayEngine.cs,GetFontForTextElement,The length of the statement  "            string fontKey = String.Format("{0}{1}{2}"' element.Font.Name' element.Font.Size' element.Font.Style' element.AntiAliased); " is 123.
Long Statement,Capture.Hook.DX11,DXFont,C:\repos\spazzarama_Direct3DHook\Capture\Hook\DX11\DXFont.cs,Initialize,The length of the statement  "            System.Drawing.Text.TextRenderingHint hint = AntiAliased ? System.Drawing.Text.TextRenderingHint.AntiAlias : System.Drawing.Text.TextRenderingHint.SystemDefault; " is 161.
Long Statement,Capture.Hook.DX11,DXFont,C:\repos\spazzarama_Direct3DHook\Capture\Hook\DX11\DXFont.cs,Initialize,The length of the statement  "            using (System.Drawing.Bitmap charBitmap = new System.Drawing.Bitmap(tempSize' tempSize' System.Drawing.Imaging.PixelFormat.Format32bppArgb)) " is 140.
Long Statement,Capture.Hook.DX11,DXFont,C:\repos\spazzarama_Direct3DHook\Capture\Hook\DX11\DXFont.cs,Initialize,The length of the statement  "                    using (var fontSheetBitmap = new System.Drawing.Bitmap(_texWidth' _texHeight' System.Drawing.Imaging.PixelFormat.Format32bppArgb)) " is 130.
Long Statement,Capture.Hook.DX11,DXFont,C:\repos\spazzarama_Direct3DHook\Capture\Hook\DX11\DXFont.cs,BuildFontSheetTexture,The length of the statement  "            bmData = fontSheetBitmap.LockBits(new System.Drawing.Rectangle(0' 0' _texWidth' _texHeight)' System.Drawing.Imaging.ImageLockMode.ReadOnly' System.Drawing.Imaging.PixelFormat.Format32bppArgb); " is 192.
Long Statement,Capture.Hook.DX11,DXFont,C:\repos\spazzarama_Direct3DHook\Capture\Hook\DX11\DXFont.cs,MeasureChars,The length of the statement  "            size = charGraphics.MeasureString(new String(allChars)' font' new System.Drawing.PointF(0' 0)' System.Drawing.StringFormat.GenericDefault); " is 139.
Long Statement,Capture.Hook.DX11,DXFont,C:\repos\spazzarama_Direct3DHook\Capture\Hook\DX11\DXFont.cs,BuildFontSheetBitmap,The length of the statement  "                fontSheetGraphics.DrawImage(charBitmap' fontSheetX' fontSheetY' new System.Drawing.Rectangle(minX' 0' charWidth' _charHeight)' System.Drawing.GraphicsUnit.Pixel); " is 162.
Long Statement,Capture.Hook.DX11,DXSprite,C:\repos\spazzarama_Direct3DHook\Capture\Hook\DX11\DXSprite.cs,ToColor4,The length of the statement  "            Vector4 Vec = new Vector4(color.R > 0 ? (float)(color.R / 255.0f) : 0.0f' color.G > 0 ? (float)(color.G / 255.0f) : 0.0f' color.B > 0 ? (float)(color.B / 255.0f) : 0.0f' color.A > 0 ? (float)(color.A / 255.0f) : 0.0f); " is 218.
Long Statement,Capture.Hook.DX11,DXSprite,C:\repos\spazzarama_Direct3DHook\Capture\Hook\DX11\DXSprite.cs,DrawImage,The length of the statement  "                Draw(new Rectangle(x' y' (int)(scale * image.Width)' (int)(scale * image.Height))' new Rectangle(0' 0' image.Width' image.Height)' color.HasValue ? ToColor4(color.Value) : Color4.White' 1.0f' angle); " is 199.
Long Statement,Capture.Hook.DX11,ScreenAlignedQuadRenderer,C:\repos\spazzarama_Direct3DHook\Capture\Hook\DX11\ScreenAlignedQuadRenderer.cs,CreateDeviceDependentResources,The length of the statement  "            //var includeHandler = new HLSLFileIncludeHandler(System.IO.Path.Combine(System.IO.Path.GetDirectoryName(System.Reflection.Assembly.GetEntryAssembly().Location)' "Shaders")); " is 174.
Long Statement,Capture.Hook.DX11,ScreenAlignedQuadRenderer,C:\repos\spazzarama_Direct3DHook\Capture\Hook\DX11\ScreenAlignedQuadRenderer.cs,CreateDeviceDependentResources,The length of the statement  "            using (var vertexShaderBytecode = ToDispose(ShaderBytecode.Compile(shaderCode' "VSMain"' "vs_4_0"' shaderFlags' EffectFlags.None' null' null))) " is 143.
Long Statement,Capture.Hook.DX11,ScreenAlignedQuadRenderer,C:\repos\spazzarama_Direct3DHook\Capture\Hook\DX11\ScreenAlignedQuadRenderer.cs,CreateDeviceDependentResources,The length of the statement  "            using (var bytecode = ToDispose(ShaderBytecode.Compile(shaderCode' "PSMain"' "ps_5_0"' shaderFlags' EffectFlags.None' null' null))) " is 131.
Long Statement,Capture.Hook.DX9,DXOverlayEngine,C:\repos\spazzarama_Direct3DHook\Capture\Hook\DX9\DXOverlayEngine.cs,Draw,The length of the statement  "                            font.DrawText(_sprite' textElement.Text' textElement.Location.X' textElement.Location.Y' new SharpDX.ColorBGRA(textElement.Color.R' textElement.Color.G' textElement.Color.B' textElement.Color.A)); " is 196.
Long Statement,Capture.Hook.DX9,DXOverlayEngine,C:\repos\spazzarama_Direct3DHook\Capture\Hook\DX9\DXOverlayEngine.cs,Draw,The length of the statement  "                            _sprite.Draw(image' new SharpDX.ColorBGRA(imageElement.Tint.R' imageElement.Tint.G' imageElement.Tint.B' imageElement.Tint.A)' null' null' new Vector3(imageElement.Location.X' imageElement.Location.Y' 0)); " is 205.
Long Statement,Capture.Hook.DX9,DXOverlayEngine,C:\repos\spazzarama_Direct3DHook\Capture\Hook\DX9\DXOverlayEngine.cs,GetFontForTextElement,The length of the statement  "            string fontKey = String.Format("{0}{1}{2}"' element.Font.Name' element.Font.Size' element.Font.Style' element.AntiAliased); " is 123.
Long Statement,Capture.Hook.DX9,DXOverlayEngine,C:\repos\spazzarama_Direct3DHook\Capture\Hook\DX9\DXOverlayEngine.cs,GetFontForTextElement,The length of the statement  "                    Weight = ((element.Font.Style & System.Drawing.FontStyle.Bold) == System.Drawing.FontStyle.Bold) ? FontWeight.Bold : FontWeight.Normal' " is 135.
Long Statement,Capture.Hook,DX9FormatExtension,C:\repos\spazzarama_Direct3DHook\Capture\Hook\DX9FormatExtension.cs,ToPixelDepth,The length of the statement  "            // Only support the DX9 BackBuffer formats: http://msdn.microsoft.com/en-us/library/windows/desktop/bb172558(v=vs.85).aspx " is 122.
Long Statement,Capture.Hook,BaseDXHook,C:\repos\spazzarama_Direct3DHook\Capture\Hook\BaseDXHook.cs,GetVTblAddresses,The length of the statement  "                vtblAddresses.Add(Marshal.ReadIntPtr(vTable' i * IntPtr.Size)); // using IntPtr.Size allows us to support both 32 and 64-bit processes " is 134.
Long Statement,Capture.Hook,DXHookD3D10,C:\repos\spazzarama_Direct3DHook\Capture\Hook\DXHookD3D10.cs,Hook,The length of the statement  "                            using (SharpDX.DXGI.SwapChain sc = new SharpDX.DXGI.SwapChain(factory' device' DXGI.CreateSwapChainDescription(renderForm.Handle))) " is 131.
Long Statement,Capture.Hook,DXHookD3D10,C:\repos\spazzarama_Direct3DHook\Capture\Hook\DXHookD3D10.cs,PresentHook,The length of the statement  "                            System.Drawing.Rectangle regionToCapture = new System.Drawing.Rectangle(0' 0' texture.Description.Width' texture.Description.Height); " is 133.
Long Statement,Capture.Hook,DXHookD3D10,C:\repos\spazzarama_Direct3DHook\Capture\Hook\DXHookD3D10.cs,PresentHook,The length of the statement  "                            // Copy to memory and send back to host process on a background thread so that we do not cause any delay in the rendering pipeline " is 130.
Long Statement,Capture.Hook,DXHookD3D10,C:\repos\spazzarama_Direct3DHook\Capture\Hook\DXHookD3D10.cs,PresentHook,The length of the statement  "                                    DrawText(font' new Vector2(5' 25)' this.TextDisplay.Text' new Color4(Color.Red.ToColor3()' (Math.Abs(1.0f - TextDisplay.Remaining)))); " is 134.
Long Statement,Capture.Hook,DXHookD3D10,C:\repos\spazzarama_Direct3DHook\Capture\Hook\DXHookD3D10.cs,DrawText,The length of the statement  "            font.DrawText(null' text' new SharpDX.Rectangle((int)pos.X' (int)pos.Y' 0' 0)' SharpDX.Direct3D10.FontDrawFlags.NoClip' color); " is 127.
Long Statement,Capture.Hook,DXHookD3D10_1,C:\repos\spazzarama_Direct3DHook\Capture\Hook\DXHookD3D10_1.cs,Hook,The length of the statement  "                    using (var device = new SharpDX.Direct3D10.Device1(factory.GetAdapter(0)' SharpDX.Direct3D10.DeviceCreationFlags.None' SharpDX.Direct3D10.FeatureLevel.Level_10_1)) " is 163.
Long Statement,Capture.Hook,DXHookD3D10_1,C:\repos\spazzarama_Direct3DHook\Capture\Hook\DXHookD3D10_1.cs,PresentHook,The length of the statement  "                                System.Drawing.Rectangle regionToCapture = new System.Drawing.Rectangle(0' 0' texture.Description.Width' texture.Description.Height); " is 133.
Long Statement,Capture.Hook,DXHookD3D10_1,C:\repos\spazzarama_Direct3DHook\Capture\Hook\DXHookD3D10_1.cs,PresentHook,The length of the statement  "                                // Copy to memory and send back to host process on a background thread so that we do not cause any delay in the rendering pipeline " is 130.
Long Statement,Capture.Hook,DXHookD3D10_1,C:\repos\spazzarama_Direct3DHook\Capture\Hook\DXHookD3D10_1.cs,PresentHook,The length of the statement  "                                        DrawText(font' new Vector2(5' 25)' this.TextDisplay.Text' new Color4(Color.Red.ToColor3()' (Math.Abs(1.0f - TextDisplay.Remaining)))); " is 134.
Long Statement,Capture.Hook,DXHookD3D11,C:\repos\spazzarama_Direct3DHook\Capture\Hook\DXHookD3D11.cs,EnsureResources,The length of the statement  "            if (_device != null && request.Resize != null && (_resizedRT == null || (_resizedRT.Device.NativePointer != _device.NativePointer || _resizedRT.Description.Width != request.Resize.Value.Width || _resizedRT.Description.Height != request.Resize.Value.Height))) " is 258.
Long Statement,Capture.Hook,DXHookD3D11,C:\repos\spazzarama_Direct3DHook\Capture\Hook\DXHookD3D11.cs,EnsureResources,The length of the statement  "                _resolvedRT != null && _resolvedRT.Description.Height == description.Height && _resolvedRT.Description.Width == description.Width && " is 132.
Long Statement,Capture.Hook,DXHookD3D11,C:\repos\spazzarama_Direct3DHook\Capture\Hook\DXHookD3D11.cs,PresentHook,The length of the statement  "                            captureRegion = new Rectangle(this.Request.RegionToCapture.Left' this.Request.RegionToCapture.Top' this.Request.RegionToCapture.Right' this.Request.RegionToCapture.Bottom); " is 172.
Long Statement,Capture.Hook,DXHookD3D11,C:\repos\spazzarama_Direct3DHook\Capture\Hook\DXHookD3D11.cs,PresentHook,The length of the statement  "                        // Copy to memory and send back to host process on a background thread so that we do not cause any delay in the rendering pipeline " is 130.
Long Statement,Capture.Hook,DXHookD3D11,C:\repos\spazzarama_Direct3DHook\Capture\Hook\DXHookD3D11.cs,PresentHook,The length of the statement  "                                                        ProcessCapture(_finalRT.Description.Width' _finalRT.Description.Height' db.RowPitch' System.Drawing.Imaging.PixelFormat.Format32bppArgb' db.DataPointer' _requestCopy); " is 167.
Long Statement,Capture.Hook,DXHookD3D11,C:\repos\spazzarama_Direct3DHook\Capture\Hook\DXHookD3D11.cs,PresentHook,The length of the statement  "                                //new Capture.Hook.Common.TextElement(new System.Drawing.Font("Times New Roman"' 22)) { Text = "Test"' Location = new System.Drawing.Point(200' 200)' Color = System.Drawing.Color.Yellow' AntiAliased = false}' " is 208.
Long Statement,Capture.Hook,DXHookD3D11,C:\repos\spazzarama_Direct3DHook\Capture\Hook\DXHookD3D11.cs,PresentHook,The length of the statement  "                                new Capture.Hook.Common.FramesPerSecond(new System.Drawing.Font("Arial"' 16)) { Location = new System.Drawing.Point(5'5)' Color = System.Drawing.Color.Red' AntiAliased = true }' " is 177.
Long Statement,Capture.Hook,DXHookD3D11,C:\repos\spazzarama_Direct3DHook\Capture\Hook\DXHookD3D11.cs,PresentHook,The length of the statement  "            // As always we need to call the original method' note that EasyHook will automatically skip the hook and call the original method " is 130.
Long Statement,Capture.Hook,DXHookD3D9,C:\repos\spazzarama_Direct3DHook\Capture\Hook\DXHookD3D9.cs,Hook,The length of the statement  "                    using (device = new Device(d3d' 0' DeviceType.NullReference' IntPtr.Zero' CreateFlags.HardwareVertexProcessing' new PresentParameters() { BackBufferWidth = 1' BackBufferHeight = 1' DeviceWindowHandle = renderForm.Handle })) " is 223.
Long Statement,Capture.Hook,DXHookD3D9,C:\repos\spazzarama_Direct3DHook\Capture\Hook\DXHookD3D9.cs,Hook,The length of the statement  "                        using (var deviceEx = new DeviceEx(d3dEx' 0' DeviceType.NullReference' IntPtr.Zero' CreateFlags.HardwareVertexProcessing' new PresentParameters() { BackBufferWidth = 1' BackBufferHeight = 1' DeviceWindowHandle = renderForm.Handle }' new DisplayModeEx() { Width = 800' Height = 600 })) " is 284.
Long Statement,Capture.Hook,DXHookD3D9,C:\repos\spazzarama_Direct3DHook\Capture\Hook\DXHookD3D9.cs,Hook,The length of the statement  "                            id3dDeviceFunctionAddresses.AddRange(GetVTblAddresses(deviceEx.NativePointer' D3D9_DEVICE_METHOD_COUNT' D3D9Ex_DEVICE_METHOD_COUNT)); " is 133.
Long Statement,Capture.Hook,DXHookD3D9,C:\repos\spazzarama_Direct3DHook\Capture\Hook\DXHookD3D9.cs,PresentExHook,The length of the statement  "            return Direct3DDeviceEx_PresentExHook.Original(devicePtr' pSourceRect' pDestRect' hDestWindowOverride' pDirtyRegion' dwFlags); " is 126.
Long Statement,Capture.Hook,DXHookD3D9,C:\repos\spazzarama_Direct3DHook\Capture\Hook\DXHookD3D9.cs,DoCaptureRenderTarget,The length of the statement  "                            ProcessCapture(rect.Width' rect.Height' lockedRect.Pitch' _renderTargetCopy.Description.Format.ToPixelFormat()' lockedRect.DataPointer' _requestCopy); " is 150.
Long Statement,Capture.Hook,DXHookD3D9,C:\repos\spazzarama_Direct3DHook\Capture\Hook\DXHookD3D9.cs,DoCaptureRenderTarget,The length of the statement  "                            if (Request.Resize != null && (renderTarget.Description.Width > Request.Resize.Value.Width || renderTarget.Description.Height > Request.Resize.Value.Height)) " is 157.
Long Statement,Capture.Hook,DXHookD3D9,C:\repos\spazzarama_Direct3DHook\Capture\Hook\DXHookD3D9.cs,DoCaptureRenderTarget,The length of the statement  "                                    height = (int)Math.Round((renderTarget.Description.Height * ((double)Request.Resize.Value.Width / (double)renderTarget.Description.Width))); " is 140.
Long Statement,Capture.Hook,DXHookD3D9,C:\repos\spazzarama_Direct3DHook\Capture\Hook\DXHookD3D9.cs,DoCaptureRenderTarget,The length of the statement  "                                    width = (int)Math.Round((renderTarget.Description.Width * ((double)Request.Resize.Value.Height / (double)renderTarget.Description.Height))); " is 140.
Long Statement,Capture.Hook,DXHookD3D9,C:\repos\spazzarama_Direct3DHook\Capture\Hook\DXHookD3D9.cs,DoCaptureRenderTarget,The length of the statement  "                            if (_renderTargetCopy != null && (_renderTargetCopy.Description.Width != width || _renderTargetCopy.Description.Height != height || _renderTargetCopy.Description.Format != renderTarget.Description.Format)) " is 205.
Long Statement,Capture.Hook,DXHookD3D9,C:\repos\spazzarama_Direct3DHook\Capture\Hook\DXHookD3D9.cs,DoCaptureRenderTarget,The length of the statement  "                                new Capture.Hook.Common.FramesPerSecond(new System.Drawing.Font("Arial"' 16' FontStyle.Bold)) { Location = new System.Drawing.Point(5'5)' Color = System.Drawing.Color.Red' AntiAliased = true }' " is 193.
Long Statement,Capture.Hook,DXHookD3D9,C:\repos\spazzarama_Direct3DHook\Capture\Hook\DXHookD3D9.cs,DoCaptureRenderTarget,The length of the statement  "                                // Example of adding an image to overlay (can implement semi transparency with Tint' e.g. Ting = Color.FromArgb(127' 255' 255' 255)) " is 132.
Long Statement,Capture.Hook,DXHookD3D9,C:\repos\spazzarama_Direct3DHook\Capture\Hook\DXHookD3D9.cs,LockRenderTarget,The length of the statement  "                rect = new SharpDX.Rectangle(_requestCopy.RegionToCapture.Left' _requestCopy.RegionToCapture.Top' _requestCopy.RegionToCapture.Width' _requestCopy.RegionToCapture.Height); " is 171.
Long Statement,Capture.Interface,CaptureInterface,C:\repos\spazzarama_Direct3DHook\Capture\Interface\CaptureInterface.cs,EndGetScreenshot,The length of the statement  "            Func<Rectangle' TimeSpan' Size?' ImageFormat' Screenshot> getScreenshot = result.AsyncState as Func<Rectangle' TimeSpan' Size?' ImageFormat' Screenshot>; " is 153.
Complex Conditional,Capture,EntryPoint,C:\repos\spazzarama_Direct3DHook\Capture\EntryPoint.cs,InitialiseDirectXHook,The conditional expression  "d3D9Loaded == IntPtr.Zero && d3D10Loaded == IntPtr.Zero && d3D10_1Loaded == IntPtr.Zero && d3D11Loaded == IntPtr.Zero && d3D11_1Loaded == IntPtr.Zero"  is complex.
Complex Conditional,Capture.Hook,DXHookD3D11,C:\repos\spazzarama_Direct3DHook\Capture\Hook\DXHookD3D11.cs,EnsureResources,The conditional expression  "_device != null && request.Resize != null && (_resizedRT == null || (_resizedRT.Device.NativePointer != _device.NativePointer || _resizedRT.Description.Width != request.Resize.Value.Width || _resizedRT.Description.Height != request.Resize.Value.Height))"  is complex.
Complex Conditional,Capture.Hook,DXHookD3D11,C:\repos\spazzarama_Direct3DHook\Capture\Hook\DXHookD3D11.cs,EnsureResources,The conditional expression  "_finalRT != null && _finalRT.Device.NativePointer == _device.NativePointer &&                  _finalRT.Description.Height == captureRegion.Height && _finalRT.Description.Width == captureRegion.Width &&                  _resolvedRT != null && _resolvedRT.Description.Height == description.Height && _resolvedRT.Description.Width == description.Width &&                  _resolvedRT.Device.NativePointer == device.NativePointer && _resolvedRT.Description.Format == description.Format"  is complex.
Complex Conditional,Capture.Hook,DXHookD3D9,C:\repos\spazzarama_Direct3DHook\Capture\Hook\DXHookD3D9.cs,DoCaptureRenderTarget,The conditional expression  "_renderTargetCopy != null && (_renderTargetCopy.Description.Width != width || _renderTargetCopy.Description.Height != height || _renderTargetCopy.Description.Format != renderTarget.Description.Format)"  is complex.
Empty Catch Block,Capture,EntryPoint,C:\repos\spazzarama_Direct3DHook\Capture\EntryPoint.cs,Run,The method has an empty catch block.
Empty Catch Block,Capture,EntryPoint,C:\repos\spazzarama_Direct3DHook\Capture\EntryPoint.cs,DisposeDirectXHook,The method has an empty catch block.
Empty Catch Block,Capture.Hook.DX9,DXOverlayEngine,C:\repos\spazzarama_Direct3DHook\Capture\Hook\DX9\DXOverlayEngine.cs,BeforeDeviceReset,The method has an empty catch block.
Empty Catch Block,Capture.Hook,HookManager,C:\repos\spazzarama_Direct3DHook\Capture\Hook\HookManager.cs,EnumProcesses,The method has an empty catch block.
Empty Catch Block,Capture.Hook,BaseDXHook,C:\repos\spazzarama_Direct3DHook\Capture\Hook\BaseDXHook.cs,DebugMessage,The method has an empty catch block.
Empty Catch Block,Capture.Hook,BaseDXHook,C:\repos\spazzarama_Direct3DHook\Capture\Hook\BaseDXHook.cs,SendResponse,The method has an empty catch block.
Empty Catch Block,Capture.Hook,BaseDXHook,C:\repos\spazzarama_Direct3DHook\Capture\Hook\BaseDXHook.cs,ProcessCapture,The method has an empty catch block.
Empty Catch Block,Capture.Hook,BaseDXHook,C:\repos\spazzarama_Direct3DHook\Capture\Hook\BaseDXHook.cs,Dispose,The method has an empty catch block.
Empty Catch Block,Capture.Hook,BaseDXHook,C:\repos\spazzarama_Direct3DHook\Capture\Hook\BaseDXHook.cs,Dispose,The method has an empty catch block.
Empty Catch Block,Capture.Hook,BaseDXHook,C:\repos\spazzarama_Direct3DHook\Capture\Hook\BaseDXHook.cs,Dispose,The method has an empty catch block.
Empty Catch Block,Capture.Hook,DXHookD3D10,C:\repos\spazzarama_Direct3DHook\Capture\Hook\DXHookD3D10.cs,Cleanup,The method has an empty catch block.
Empty Catch Block,Capture.Hook,DXHookD3D10_1,C:\repos\spazzarama_Direct3DHook\Capture\Hook\DXHookD3D10_1.cs,Cleanup,The method has an empty catch block.
Empty Catch Block,Capture.Hook,DXHookD3D11,C:\repos\spazzarama_Direct3DHook\Capture\Hook\DXHookD3D11.cs,Cleanup,The method has an empty catch block.
Empty Catch Block,Capture.Hook,DXHookD3D11,C:\repos\spazzarama_Direct3DHook\Capture\Hook\DXHookD3D11.cs,PresentHook,The method has an empty catch block.
Empty Catch Block,Capture.Interface,CaptureInterface,C:\repos\spazzarama_Direct3DHook\Capture\Interface\CaptureInterface.cs,GetScreenshot,The method has an empty catch block.
Magic Number,Capture,CaptureProcess,C:\repos\spazzarama_Direct3DHook\Capture\CaptureProcess.cs,BringProcessWindowToFront,The following statement contains a magic number: while (!NativeMethods.IsWindowInForeground(handle))              {                  if (i == 0)                  {                      // Initial sleep if target window is not in foreground - just to let things settle                      Thread.Sleep(250);                  }                    if (NativeMethods.IsIconic(handle))                  {                      // Minimized so send restore                      NativeMethods.ShowWindow(handle' NativeMethods.WindowShowStyle.Restore);                  }                  else                  {                      // Already Maximized or Restored so just bring to front                      NativeMethods.SetForegroundWindow(handle);                  }                  Thread.Sleep(250);                    // Check if the target process main window is now in the foreground                  if (NativeMethods.IsWindowInForeground(handle))                  {                      // Leave enough time for screen to redraw                      Thread.Sleep(1000);                      return;                  }                    // Prevent an infinite loop                  if (i > 120) // about 30secs                  {                      throw new Exception("Could not set process window to the foreground");                  }                  i++;              }
Magic Number,Capture,CaptureProcess,C:\repos\spazzarama_Direct3DHook\Capture\CaptureProcess.cs,BringProcessWindowToFront,The following statement contains a magic number: while (!NativeMethods.IsWindowInForeground(handle))              {                  if (i == 0)                  {                      // Initial sleep if target window is not in foreground - just to let things settle                      Thread.Sleep(250);                  }                    if (NativeMethods.IsIconic(handle))                  {                      // Minimized so send restore                      NativeMethods.ShowWindow(handle' NativeMethods.WindowShowStyle.Restore);                  }                  else                  {                      // Already Maximized or Restored so just bring to front                      NativeMethods.SetForegroundWindow(handle);                  }                  Thread.Sleep(250);                    // Check if the target process main window is now in the foreground                  if (NativeMethods.IsWindowInForeground(handle))                  {                      // Leave enough time for screen to redraw                      Thread.Sleep(1000);                      return;                  }                    // Prevent an infinite loop                  if (i > 120) // about 30secs                  {                      throw new Exception("Could not set process window to the foreground");                  }                  i++;              }
Magic Number,Capture,CaptureProcess,C:\repos\spazzarama_Direct3DHook\Capture\CaptureProcess.cs,BringProcessWindowToFront,The following statement contains a magic number: while (!NativeMethods.IsWindowInForeground(handle))              {                  if (i == 0)                  {                      // Initial sleep if target window is not in foreground - just to let things settle                      Thread.Sleep(250);                  }                    if (NativeMethods.IsIconic(handle))                  {                      // Minimized so send restore                      NativeMethods.ShowWindow(handle' NativeMethods.WindowShowStyle.Restore);                  }                  else                  {                      // Already Maximized or Restored so just bring to front                      NativeMethods.SetForegroundWindow(handle);                  }                  Thread.Sleep(250);                    // Check if the target process main window is now in the foreground                  if (NativeMethods.IsWindowInForeground(handle))                  {                      // Leave enough time for screen to redraw                      Thread.Sleep(1000);                      return;                  }                    // Prevent an infinite loop                  if (i > 120) // about 30secs                  {                      throw new Exception("Could not set process window to the foreground");                  }                  i++;              }
Magic Number,Capture,CaptureProcess,C:\repos\spazzarama_Direct3DHook\Capture\CaptureProcess.cs,BringProcessWindowToFront,The following statement contains a magic number: while (!NativeMethods.IsWindowInForeground(handle))              {                  if (i == 0)                  {                      // Initial sleep if target window is not in foreground - just to let things settle                      Thread.Sleep(250);                  }                    if (NativeMethods.IsIconic(handle))                  {                      // Minimized so send restore                      NativeMethods.ShowWindow(handle' NativeMethods.WindowShowStyle.Restore);                  }                  else                  {                      // Already Maximized or Restored so just bring to front                      NativeMethods.SetForegroundWindow(handle);                  }                  Thread.Sleep(250);                    // Check if the target process main window is now in the foreground                  if (NativeMethods.IsWindowInForeground(handle))                  {                      // Leave enough time for screen to redraw                      Thread.Sleep(1000);                      return;                  }                    // Prevent an infinite loop                  if (i > 120) // about 30secs                  {                      throw new Exception("Could not set process window to the foreground");                  }                  i++;              }
Magic Number,Capture,EntryPoint,C:\repos\spazzarama_Direct3DHook\Capture\EntryPoint.cs,Run,The following statement contains a magic number: try              {                  // Initialise the Hook                  if (!InitialiseDirectXHook(config))                  {                      return;                  }                  _interface.Disconnected += _clientEventProxy.DisconnectedProxyHandler;                    // Important Note:                  // accessing the _interface from within a _clientEventProxy event handler must always                   // be done on a different thread otherwise it will cause a deadlock                    _clientEventProxy.Disconnected += () =>                  {                      // We can now signal the exit of the Run method                      _runWait.Set();                  };                    // We start a thread here to periodically check if the host is still running                  // If the host process stops then we will automatically uninstall the hooks                  StartCheckHostIsAliveThread();                    // Wait until signaled for exit either when a Disconnect message from the host                   // or if the the check is alive has failed to Ping the host.                  _runWait.WaitOne();                    // we need to tell the check host thread to exit (if it hasn't already)                  StopCheckHostIsAliveThread();                    // Dispose of the DXHook so any installed hooks are removed correctly                  DisposeDirectXHook();              }              catch (Exception e)              {                  _interface.Message(MessageType.Error' "An unexpected error occured: {0}"' e.ToString());              }              finally              {                  try                  {                      _interface.Message(MessageType.Information' "Disconnecting from process {0}"' EasyHook.RemoteHooking.GetCurrentProcessId());                  }                  catch                  {                  }                    // Remove the client server channel (that allows client event handlers)                  System.Runtime.Remoting.Channels.ChannelServices.UnregisterChannel(_clientServerChannel);                    // Always sleep long enough for any remaining messages to complete sending                  System.Threading.Thread.Sleep(100);              }
Magic Number,Capture,EntryPoint,C:\repos\spazzarama_Direct3DHook\Capture\EntryPoint.cs,InitialiseDirectXHook,The following statement contains a magic number: try              {                  if (version == Direct3DVersion.AutoDetect || version == Direct3DVersion.Unknown)                  {                      // Attempt to determine the correct version based on loaded module.                      // In most cases this will work fine' however it is perfectly ok for an application to use a D3D10 device along with D3D11 devices                      // so the version might matched might not be the one you want to use                      IntPtr d3D9Loaded = IntPtr.Zero;                      IntPtr d3D10Loaded = IntPtr.Zero;                      IntPtr d3D10_1Loaded = IntPtr.Zero;                      IntPtr d3D11Loaded = IntPtr.Zero;                      IntPtr d3D11_1Loaded = IntPtr.Zero;                        int delayTime = 100;                      int retryCount = 0;                      while (d3D9Loaded == IntPtr.Zero && d3D10Loaded == IntPtr.Zero && d3D10_1Loaded == IntPtr.Zero && d3D11Loaded == IntPtr.Zero && d3D11_1Loaded == IntPtr.Zero)                      {                          retryCount++;                          d3D9Loaded = NativeMethods.GetModuleHandle("d3d9.dll");                          d3D10Loaded = NativeMethods.GetModuleHandle("d3d10.dll");                          d3D10_1Loaded = NativeMethods.GetModuleHandle("d3d10_1.dll");                          d3D11Loaded = NativeMethods.GetModuleHandle("d3d11.dll");                          d3D11_1Loaded = NativeMethods.GetModuleHandle("d3d11_1.dll");                          System.Threading.Thread.Sleep(delayTime);                            if (retryCount * delayTime > 5000)                          {                              _interface.Message(MessageType.Error' "Unsupported Direct3D version' or Direct3D DLL not loaded within 5 seconds.");                              return false;                          }                      }                        version = Direct3DVersion.Unknown;                      if (d3D11_1Loaded != IntPtr.Zero)                      {                          _interface.Message(MessageType.Debug' "Autodetect found Direct3D 11.1");                          version = Direct3DVersion.Direct3D11_1;                          loadedVersions.Add(version);                      }                      if (d3D11Loaded != IntPtr.Zero)                      {                          _interface.Message(MessageType.Debug' "Autodetect found Direct3D 11");                          version = Direct3DVersion.Direct3D11;                          loadedVersions.Add(version);                      }                      if (d3D10_1Loaded != IntPtr.Zero)                      {                          _interface.Message(MessageType.Debug' "Autodetect found Direct3D 10.1");                          version = Direct3DVersion.Direct3D10_1;                          loadedVersions.Add(version);                      }                      if (d3D10Loaded != IntPtr.Zero)                      {                          _interface.Message(MessageType.Debug' "Autodetect found Direct3D 10");                          version = Direct3DVersion.Direct3D10;                          loadedVersions.Add(version);                      }                      if (d3D9Loaded != IntPtr.Zero)                      {                          _interface.Message(MessageType.Debug' "Autodetect found Direct3D 9");                          version = Direct3DVersion.Direct3D9;                          loadedVersions.Add(version);                      }                  }                  else                  {                      // If not autodetect' assume specified version is loaded                      loadedVersions.Add(version);                  }                    foreach (var dxVersion in loadedVersions)                  {                      version = dxVersion;                      switch (version)                      {                          case Direct3DVersion.Direct3D9:                              _directXHook = new DXHookD3D9(_interface);                              break;                          case Direct3DVersion.Direct3D10:                              _directXHook = new DXHookD3D10(_interface);                              break;                          case Direct3DVersion.Direct3D10_1:                              _directXHook = new DXHookD3D10_1(_interface);                              break;                          case Direct3DVersion.Direct3D11:                              _directXHook = new DXHookD3D11(_interface);                              break;                          //case Direct3DVersion.Direct3D11_1:                          //    _directXHook = new DXHookD3D11_1(_interface);                          //    return;                          default:                              _interface.Message(MessageType.Error' "Unsupported Direct3D version: {0}"' version);                              return false;                      }                        _directXHook.Config = config;                      _directXHook.Hook();                        _directXHooks.Add(_directXHook);                  }                    return true;                }              catch (Exception e)              {                  // Notify the host/server application about this error                  _interface.Message(MessageType.Error' "Error in InitialiseHook: {0}"' e.ToString());                  return false;              }
Magic Number,Capture,EntryPoint,C:\repos\spazzarama_Direct3DHook\Capture\EntryPoint.cs,InitialiseDirectXHook,The following statement contains a magic number: try              {                  if (version == Direct3DVersion.AutoDetect || version == Direct3DVersion.Unknown)                  {                      // Attempt to determine the correct version based on loaded module.                      // In most cases this will work fine' however it is perfectly ok for an application to use a D3D10 device along with D3D11 devices                      // so the version might matched might not be the one you want to use                      IntPtr d3D9Loaded = IntPtr.Zero;                      IntPtr d3D10Loaded = IntPtr.Zero;                      IntPtr d3D10_1Loaded = IntPtr.Zero;                      IntPtr d3D11Loaded = IntPtr.Zero;                      IntPtr d3D11_1Loaded = IntPtr.Zero;                        int delayTime = 100;                      int retryCount = 0;                      while (d3D9Loaded == IntPtr.Zero && d3D10Loaded == IntPtr.Zero && d3D10_1Loaded == IntPtr.Zero && d3D11Loaded == IntPtr.Zero && d3D11_1Loaded == IntPtr.Zero)                      {                          retryCount++;                          d3D9Loaded = NativeMethods.GetModuleHandle("d3d9.dll");                          d3D10Loaded = NativeMethods.GetModuleHandle("d3d10.dll");                          d3D10_1Loaded = NativeMethods.GetModuleHandle("d3d10_1.dll");                          d3D11Loaded = NativeMethods.GetModuleHandle("d3d11.dll");                          d3D11_1Loaded = NativeMethods.GetModuleHandle("d3d11_1.dll");                          System.Threading.Thread.Sleep(delayTime);                            if (retryCount * delayTime > 5000)                          {                              _interface.Message(MessageType.Error' "Unsupported Direct3D version' or Direct3D DLL not loaded within 5 seconds.");                              return false;                          }                      }                        version = Direct3DVersion.Unknown;                      if (d3D11_1Loaded != IntPtr.Zero)                      {                          _interface.Message(MessageType.Debug' "Autodetect found Direct3D 11.1");                          version = Direct3DVersion.Direct3D11_1;                          loadedVersions.Add(version);                      }                      if (d3D11Loaded != IntPtr.Zero)                      {                          _interface.Message(MessageType.Debug' "Autodetect found Direct3D 11");                          version = Direct3DVersion.Direct3D11;                          loadedVersions.Add(version);                      }                      if (d3D10_1Loaded != IntPtr.Zero)                      {                          _interface.Message(MessageType.Debug' "Autodetect found Direct3D 10.1");                          version = Direct3DVersion.Direct3D10_1;                          loadedVersions.Add(version);                      }                      if (d3D10Loaded != IntPtr.Zero)                      {                          _interface.Message(MessageType.Debug' "Autodetect found Direct3D 10");                          version = Direct3DVersion.Direct3D10;                          loadedVersions.Add(version);                      }                      if (d3D9Loaded != IntPtr.Zero)                      {                          _interface.Message(MessageType.Debug' "Autodetect found Direct3D 9");                          version = Direct3DVersion.Direct3D9;                          loadedVersions.Add(version);                      }                  }                  else                  {                      // If not autodetect' assume specified version is loaded                      loadedVersions.Add(version);                  }                    foreach (var dxVersion in loadedVersions)                  {                      version = dxVersion;                      switch (version)                      {                          case Direct3DVersion.Direct3D9:                              _directXHook = new DXHookD3D9(_interface);                              break;                          case Direct3DVersion.Direct3D10:                              _directXHook = new DXHookD3D10(_interface);                              break;                          case Direct3DVersion.Direct3D10_1:                              _directXHook = new DXHookD3D10_1(_interface);                              break;                          case Direct3DVersion.Direct3D11:                              _directXHook = new DXHookD3D11(_interface);                              break;                          //case Direct3DVersion.Direct3D11_1:                          //    _directXHook = new DXHookD3D11_1(_interface);                          //    return;                          default:                              _interface.Message(MessageType.Error' "Unsupported Direct3D version: {0}"' version);                              return false;                      }                        _directXHook.Config = config;                      _directXHook.Hook();                        _directXHooks.Add(_directXHook);                  }                    return true;                }              catch (Exception e)              {                  // Notify the host/server application about this error                  _interface.Message(MessageType.Error' "Error in InitialiseHook: {0}"' e.ToString());                  return false;              }
Magic Number,Capture,EntryPoint,C:\repos\spazzarama_Direct3DHook\Capture\EntryPoint.cs,StartCheckHostIsAliveThread,The following statement contains a magic number: _checkAlive = new Task(() =>              {                  try                  {                      while (System.Threading.Interlocked.Read(ref _stopCheckAlive) == 0)                      {                          System.Threading.Thread.Sleep(1000);                            // .NET Remoting exceptions will throw RemotingException                          _interface.Ping();                      }                  }                  catch // We will assume that any exception means that the hooks need to be removed.                   {                      // Signal the Run method so that it can exit                      _runWait.Set();                  }              });
Magic Number,Capture.Hook.Common,FramesPerSecond,C:\repos\spazzarama_Direct3DHook\Capture\Hook\Common\FramesPerSecond.cs,Frame,The following statement contains a magic number: if (Math.Abs(Environment.TickCount - _lastTickCount) > 1000)              {                  _lastFrameRate = (float)_frames * 1000 / Math.Abs(Environment.TickCount - _lastTickCount);                  _lastTickCount = Environment.TickCount;                  _frames = 0;              }
Magic Number,Capture.Hook.Common,FramesPerSecond,C:\repos\spazzarama_Direct3DHook\Capture\Hook\Common\FramesPerSecond.cs,Frame,The following statement contains a magic number: if (Math.Abs(Environment.TickCount - _lastTickCount) > 1000)              {                  _lastFrameRate = (float)_frames * 1000 / Math.Abs(Environment.TickCount - _lastTickCount);                  _lastTickCount = Environment.TickCount;                  _frames = 0;              }
Magic Number,Capture.Hook.DX11,DXFont,C:\repos\spazzarama_Direct3DHook\Capture\Hook\DX11\DXFont.cs,DXFont,The following statement contains a magic number: _texWidth = 1024;
Magic Number,Capture.Hook.DX11,DXFont,C:\repos\spazzarama_Direct3DHook\Capture\Hook\DX11\DXFont.cs,Initialize,The following statement contains a magic number: int tempSize = (int)(FontSize * 2);
Magic Number,Capture.Hook.DX11,DXFont,C:\repos\spazzarama_Direct3DHook\Capture\Hook\DX11\DXFont.cs,BuildFontSheetTexture,The following statement contains a magic number: data.RowPitch = _texWidth * 4;
Magic Number,Capture.Hook.DX11,DXSprite,C:\repos\spazzarama_Direct3DHook\Capture\Hook\DX11\DXSprite.cs,Initialize,The following statement contains a magic number: {                                    if (_compiledFX.HasErrors)                      return false;                    _effect = ToDispose(new Effect(_device' _compiledFX));                  {                      _spriteTech = ToDispose(_effect.GetTechniqueByName("SpriteTech"));                      _spriteMap = ToDispose(_effect.GetVariableByName("SpriteTex").AsShaderResource());                        using (var pass = _spriteTech.GetPassByIndex(0))                      {                          InputElement[] layoutDesc = {                                                          new InputElement("POSITION"' 0' SharpDX.DXGI.Format.R32G32B32_Float' 0' 0' InputClassification.PerVertexData' 0)'                                                          new InputElement("TEXCOORD"' 0' SharpDX.DXGI.Format.R32G32_Float' 12' 0' InputClassification.PerVertexData' 0)'                                                          new InputElement("COLOR"' 0' SharpDX.DXGI.Format.R32G32B32A32_Float' 20' 0' InputClassification.PerVertexData' 0)                                                      };                            _inputLayout = ToDispose(new InputLayout(_device' pass.Description.Signature' layoutDesc));                      }                      // Create Vertex Buffer                      BufferDescription vbd = new BufferDescription                      {                          SizeInBytes = 2048 * Marshal.SizeOf(typeof(SpriteVertex))'                          Usage = ResourceUsage.Dynamic'                          BindFlags = BindFlags.VertexBuffer'                          CpuAccessFlags = CpuAccessFlags.Write'                          OptionFlags = ResourceOptionFlags.None'                          StructureByteStride = 0                      };                        _VB = ToDispose(new SharpDX.Direct3D11.Buffer(_device' vbd));                        // Create and initialise Index Buffer                        short[] indices = new short[3072];                        for (ushort i = 0; i < 512; ++i)                      {                          indices[i * 6] = (short)(i * 4);                          indices[i * 6 + 1] = (short)(i * 4 + 1);                          indices[i * 6 + 2] = (short)(i * 4 + 2);                          indices[i * 6 + 3] = (short)(i * 4);                          indices[i * 6 + 4] = (short)(i * 4 + 2);                          indices[i * 6 + 5] = (short)(i * 4 + 3);                      }                        _indexBuffer = ToDispose(new SafeHGlobal(indices.Length * Marshal.SizeOf(indices[0])));                      Marshal.Copy(indices' 0' _indexBuffer.DangerousGetHandle()' indices.Length);                        BufferDescription ibd = new BufferDescription                      {                          SizeInBytes = 3072 * Marshal.SizeOf(typeof(short))'                          Usage = ResourceUsage.Immutable'                          BindFlags = BindFlags.IndexBuffer'                          CpuAccessFlags = CpuAccessFlags.None'                          OptionFlags = ResourceOptionFlags.None'                          StructureByteStride = 0                      };                                            _IB = ToDispose(new SharpDX.Direct3D11.Buffer(_device' _indexBuffer.DangerousGetHandle()' ibd));                        BlendStateDescription transparentDesc = new BlendStateDescription()                      {                          AlphaToCoverageEnable = false'                          IndependentBlendEnable = false'                      };                      transparentDesc.RenderTarget[0].IsBlendEnabled = true;                      transparentDesc.RenderTarget[0].SourceBlend = BlendOption.SourceAlpha;                      transparentDesc.RenderTarget[0].DestinationBlend = BlendOption.InverseSourceAlpha;                      transparentDesc.RenderTarget[0].BlendOperation = BlendOperation.Add;                      transparentDesc.RenderTarget[0].SourceAlphaBlend = BlendOption.One;                      transparentDesc.RenderTarget[0].DestinationAlphaBlend = BlendOption.Zero;                      transparentDesc.RenderTarget[0].AlphaBlendOperation = BlendOperation.Add;                      transparentDesc.RenderTarget[0].RenderTargetWriteMask = ColorWriteMaskFlags.All;                        _transparentBS = ToDispose(new BlendState(_device' transparentDesc));                  }              }
Magic Number,Capture.Hook.DX11,DXSprite,C:\repos\spazzarama_Direct3DHook\Capture\Hook\DX11\DXSprite.cs,Initialize,The following statement contains a magic number: {                                    if (_compiledFX.HasErrors)                      return false;                    _effect = ToDispose(new Effect(_device' _compiledFX));                  {                      _spriteTech = ToDispose(_effect.GetTechniqueByName("SpriteTech"));                      _spriteMap = ToDispose(_effect.GetVariableByName("SpriteTex").AsShaderResource());                        using (var pass = _spriteTech.GetPassByIndex(0))                      {                          InputElement[] layoutDesc = {                                                          new InputElement("POSITION"' 0' SharpDX.DXGI.Format.R32G32B32_Float' 0' 0' InputClassification.PerVertexData' 0)'                                                          new InputElement("TEXCOORD"' 0' SharpDX.DXGI.Format.R32G32_Float' 12' 0' InputClassification.PerVertexData' 0)'                                                          new InputElement("COLOR"' 0' SharpDX.DXGI.Format.R32G32B32A32_Float' 20' 0' InputClassification.PerVertexData' 0)                                                      };                            _inputLayout = ToDispose(new InputLayout(_device' pass.Description.Signature' layoutDesc));                      }                      // Create Vertex Buffer                      BufferDescription vbd = new BufferDescription                      {                          SizeInBytes = 2048 * Marshal.SizeOf(typeof(SpriteVertex))'                          Usage = ResourceUsage.Dynamic'                          BindFlags = BindFlags.VertexBuffer'                          CpuAccessFlags = CpuAccessFlags.Write'                          OptionFlags = ResourceOptionFlags.None'                          StructureByteStride = 0                      };                        _VB = ToDispose(new SharpDX.Direct3D11.Buffer(_device' vbd));                        // Create and initialise Index Buffer                        short[] indices = new short[3072];                        for (ushort i = 0; i < 512; ++i)                      {                          indices[i * 6] = (short)(i * 4);                          indices[i * 6 + 1] = (short)(i * 4 + 1);                          indices[i * 6 + 2] = (short)(i * 4 + 2);                          indices[i * 6 + 3] = (short)(i * 4);                          indices[i * 6 + 4] = (short)(i * 4 + 2);                          indices[i * 6 + 5] = (short)(i * 4 + 3);                      }                        _indexBuffer = ToDispose(new SafeHGlobal(indices.Length * Marshal.SizeOf(indices[0])));                      Marshal.Copy(indices' 0' _indexBuffer.DangerousGetHandle()' indices.Length);                        BufferDescription ibd = new BufferDescription                      {                          SizeInBytes = 3072 * Marshal.SizeOf(typeof(short))'                          Usage = ResourceUsage.Immutable'                          BindFlags = BindFlags.IndexBuffer'                          CpuAccessFlags = CpuAccessFlags.None'                          OptionFlags = ResourceOptionFlags.None'                          StructureByteStride = 0                      };                                            _IB = ToDispose(new SharpDX.Direct3D11.Buffer(_device' _indexBuffer.DangerousGetHandle()' ibd));                        BlendStateDescription transparentDesc = new BlendStateDescription()                      {                          AlphaToCoverageEnable = false'                          IndependentBlendEnable = false'                      };                      transparentDesc.RenderTarget[0].IsBlendEnabled = true;                      transparentDesc.RenderTarget[0].SourceBlend = BlendOption.SourceAlpha;                      transparentDesc.RenderTarget[0].DestinationBlend = BlendOption.InverseSourceAlpha;                      transparentDesc.RenderTarget[0].BlendOperation = BlendOperation.Add;                      transparentDesc.RenderTarget[0].SourceAlphaBlend = BlendOption.One;                      transparentDesc.RenderTarget[0].DestinationAlphaBlend = BlendOption.Zero;                      transparentDesc.RenderTarget[0].AlphaBlendOperation = BlendOperation.Add;                      transparentDesc.RenderTarget[0].RenderTargetWriteMask = ColorWriteMaskFlags.All;                        _transparentBS = ToDispose(new BlendState(_device' transparentDesc));                  }              }
Magic Number,Capture.Hook.DX11,DXSprite,C:\repos\spazzarama_Direct3DHook\Capture\Hook\DX11\DXSprite.cs,Initialize,The following statement contains a magic number: {                                    if (_compiledFX.HasErrors)                      return false;                    _effect = ToDispose(new Effect(_device' _compiledFX));                  {                      _spriteTech = ToDispose(_effect.GetTechniqueByName("SpriteTech"));                      _spriteMap = ToDispose(_effect.GetVariableByName("SpriteTex").AsShaderResource());                        using (var pass = _spriteTech.GetPassByIndex(0))                      {                          InputElement[] layoutDesc = {                                                          new InputElement("POSITION"' 0' SharpDX.DXGI.Format.R32G32B32_Float' 0' 0' InputClassification.PerVertexData' 0)'                                                          new InputElement("TEXCOORD"' 0' SharpDX.DXGI.Format.R32G32_Float' 12' 0' InputClassification.PerVertexData' 0)'                                                          new InputElement("COLOR"' 0' SharpDX.DXGI.Format.R32G32B32A32_Float' 20' 0' InputClassification.PerVertexData' 0)                                                      };                            _inputLayout = ToDispose(new InputLayout(_device' pass.Description.Signature' layoutDesc));                      }                      // Create Vertex Buffer                      BufferDescription vbd = new BufferDescription                      {                          SizeInBytes = 2048 * Marshal.SizeOf(typeof(SpriteVertex))'                          Usage = ResourceUsage.Dynamic'                          BindFlags = BindFlags.VertexBuffer'                          CpuAccessFlags = CpuAccessFlags.Write'                          OptionFlags = ResourceOptionFlags.None'                          StructureByteStride = 0                      };                        _VB = ToDispose(new SharpDX.Direct3D11.Buffer(_device' vbd));                        // Create and initialise Index Buffer                        short[] indices = new short[3072];                        for (ushort i = 0; i < 512; ++i)                      {                          indices[i * 6] = (short)(i * 4);                          indices[i * 6 + 1] = (short)(i * 4 + 1);                          indices[i * 6 + 2] = (short)(i * 4 + 2);                          indices[i * 6 + 3] = (short)(i * 4);                          indices[i * 6 + 4] = (short)(i * 4 + 2);                          indices[i * 6 + 5] = (short)(i * 4 + 3);                      }                        _indexBuffer = ToDispose(new SafeHGlobal(indices.Length * Marshal.SizeOf(indices[0])));                      Marshal.Copy(indices' 0' _indexBuffer.DangerousGetHandle()' indices.Length);                        BufferDescription ibd = new BufferDescription                      {                          SizeInBytes = 3072 * Marshal.SizeOf(typeof(short))'                          Usage = ResourceUsage.Immutable'                          BindFlags = BindFlags.IndexBuffer'                          CpuAccessFlags = CpuAccessFlags.None'                          OptionFlags = ResourceOptionFlags.None'                          StructureByteStride = 0                      };                                            _IB = ToDispose(new SharpDX.Direct3D11.Buffer(_device' _indexBuffer.DangerousGetHandle()' ibd));                        BlendStateDescription transparentDesc = new BlendStateDescription()                      {                          AlphaToCoverageEnable = false'                          IndependentBlendEnable = false'                      };                      transparentDesc.RenderTarget[0].IsBlendEnabled = true;                      transparentDesc.RenderTarget[0].SourceBlend = BlendOption.SourceAlpha;                      transparentDesc.RenderTarget[0].DestinationBlend = BlendOption.InverseSourceAlpha;                      transparentDesc.RenderTarget[0].BlendOperation = BlendOperation.Add;                      transparentDesc.RenderTarget[0].SourceAlphaBlend = BlendOption.One;                      transparentDesc.RenderTarget[0].DestinationAlphaBlend = BlendOption.Zero;                      transparentDesc.RenderTarget[0].AlphaBlendOperation = BlendOperation.Add;                      transparentDesc.RenderTarget[0].RenderTargetWriteMask = ColorWriteMaskFlags.All;                        _transparentBS = ToDispose(new BlendState(_device' transparentDesc));                  }              }
Magic Number,Capture.Hook.DX11,DXSprite,C:\repos\spazzarama_Direct3DHook\Capture\Hook\DX11\DXSprite.cs,Initialize,The following statement contains a magic number: {                                    if (_compiledFX.HasErrors)                      return false;                    _effect = ToDispose(new Effect(_device' _compiledFX));                  {                      _spriteTech = ToDispose(_effect.GetTechniqueByName("SpriteTech"));                      _spriteMap = ToDispose(_effect.GetVariableByName("SpriteTex").AsShaderResource());                        using (var pass = _spriteTech.GetPassByIndex(0))                      {                          InputElement[] layoutDesc = {                                                          new InputElement("POSITION"' 0' SharpDX.DXGI.Format.R32G32B32_Float' 0' 0' InputClassification.PerVertexData' 0)'                                                          new InputElement("TEXCOORD"' 0' SharpDX.DXGI.Format.R32G32_Float' 12' 0' InputClassification.PerVertexData' 0)'                                                          new InputElement("COLOR"' 0' SharpDX.DXGI.Format.R32G32B32A32_Float' 20' 0' InputClassification.PerVertexData' 0)                                                      };                            _inputLayout = ToDispose(new InputLayout(_device' pass.Description.Signature' layoutDesc));                      }                      // Create Vertex Buffer                      BufferDescription vbd = new BufferDescription                      {                          SizeInBytes = 2048 * Marshal.SizeOf(typeof(SpriteVertex))'                          Usage = ResourceUsage.Dynamic'                          BindFlags = BindFlags.VertexBuffer'                          CpuAccessFlags = CpuAccessFlags.Write'                          OptionFlags = ResourceOptionFlags.None'                          StructureByteStride = 0                      };                        _VB = ToDispose(new SharpDX.Direct3D11.Buffer(_device' vbd));                        // Create and initialise Index Buffer                        short[] indices = new short[3072];                        for (ushort i = 0; i < 512; ++i)                      {                          indices[i * 6] = (short)(i * 4);                          indices[i * 6 + 1] = (short)(i * 4 + 1);                          indices[i * 6 + 2] = (short)(i * 4 + 2);                          indices[i * 6 + 3] = (short)(i * 4);                          indices[i * 6 + 4] = (short)(i * 4 + 2);                          indices[i * 6 + 5] = (short)(i * 4 + 3);                      }                        _indexBuffer = ToDispose(new SafeHGlobal(indices.Length * Marshal.SizeOf(indices[0])));                      Marshal.Copy(indices' 0' _indexBuffer.DangerousGetHandle()' indices.Length);                        BufferDescription ibd = new BufferDescription                      {                          SizeInBytes = 3072 * Marshal.SizeOf(typeof(short))'                          Usage = ResourceUsage.Immutable'                          BindFlags = BindFlags.IndexBuffer'                          CpuAccessFlags = CpuAccessFlags.None'                          OptionFlags = ResourceOptionFlags.None'                          StructureByteStride = 0                      };                                            _IB = ToDispose(new SharpDX.Direct3D11.Buffer(_device' _indexBuffer.DangerousGetHandle()' ibd));                        BlendStateDescription transparentDesc = new BlendStateDescription()                      {                          AlphaToCoverageEnable = false'                          IndependentBlendEnable = false'                      };                      transparentDesc.RenderTarget[0].IsBlendEnabled = true;                      transparentDesc.RenderTarget[0].SourceBlend = BlendOption.SourceAlpha;                      transparentDesc.RenderTarget[0].DestinationBlend = BlendOption.InverseSourceAlpha;                      transparentDesc.RenderTarget[0].BlendOperation = BlendOperation.Add;                      transparentDesc.RenderTarget[0].SourceAlphaBlend = BlendOption.One;                      transparentDesc.RenderTarget[0].DestinationAlphaBlend = BlendOption.Zero;                      transparentDesc.RenderTarget[0].AlphaBlendOperation = BlendOperation.Add;                      transparentDesc.RenderTarget[0].RenderTargetWriteMask = ColorWriteMaskFlags.All;                        _transparentBS = ToDispose(new BlendState(_device' transparentDesc));                  }              }
Magic Number,Capture.Hook.DX11,DXSprite,C:\repos\spazzarama_Direct3DHook\Capture\Hook\DX11\DXSprite.cs,Initialize,The following statement contains a magic number: {                                    if (_compiledFX.HasErrors)                      return false;                    _effect = ToDispose(new Effect(_device' _compiledFX));                  {                      _spriteTech = ToDispose(_effect.GetTechniqueByName("SpriteTech"));                      _spriteMap = ToDispose(_effect.GetVariableByName("SpriteTex").AsShaderResource());                        using (var pass = _spriteTech.GetPassByIndex(0))                      {                          InputElement[] layoutDesc = {                                                          new InputElement("POSITION"' 0' SharpDX.DXGI.Format.R32G32B32_Float' 0' 0' InputClassification.PerVertexData' 0)'                                                          new InputElement("TEXCOORD"' 0' SharpDX.DXGI.Format.R32G32_Float' 12' 0' InputClassification.PerVertexData' 0)'                                                          new InputElement("COLOR"' 0' SharpDX.DXGI.Format.R32G32B32A32_Float' 20' 0' InputClassification.PerVertexData' 0)                                                      };                            _inputLayout = ToDispose(new InputLayout(_device' pass.Description.Signature' layoutDesc));                      }                      // Create Vertex Buffer                      BufferDescription vbd = new BufferDescription                      {                          SizeInBytes = 2048 * Marshal.SizeOf(typeof(SpriteVertex))'                          Usage = ResourceUsage.Dynamic'                          BindFlags = BindFlags.VertexBuffer'                          CpuAccessFlags = CpuAccessFlags.Write'                          OptionFlags = ResourceOptionFlags.None'                          StructureByteStride = 0                      };                        _VB = ToDispose(new SharpDX.Direct3D11.Buffer(_device' vbd));                        // Create and initialise Index Buffer                        short[] indices = new short[3072];                        for (ushort i = 0; i < 512; ++i)                      {                          indices[i * 6] = (short)(i * 4);                          indices[i * 6 + 1] = (short)(i * 4 + 1);                          indices[i * 6 + 2] = (short)(i * 4 + 2);                          indices[i * 6 + 3] = (short)(i * 4);                          indices[i * 6 + 4] = (short)(i * 4 + 2);                          indices[i * 6 + 5] = (short)(i * 4 + 3);                      }                        _indexBuffer = ToDispose(new SafeHGlobal(indices.Length * Marshal.SizeOf(indices[0])));                      Marshal.Copy(indices' 0' _indexBuffer.DangerousGetHandle()' indices.Length);                        BufferDescription ibd = new BufferDescription                      {                          SizeInBytes = 3072 * Marshal.SizeOf(typeof(short))'                          Usage = ResourceUsage.Immutable'                          BindFlags = BindFlags.IndexBuffer'                          CpuAccessFlags = CpuAccessFlags.None'                          OptionFlags = ResourceOptionFlags.None'                          StructureByteStride = 0                      };                                            _IB = ToDispose(new SharpDX.Direct3D11.Buffer(_device' _indexBuffer.DangerousGetHandle()' ibd));                        BlendStateDescription transparentDesc = new BlendStateDescription()                      {                          AlphaToCoverageEnable = false'                          IndependentBlendEnable = false'                      };                      transparentDesc.RenderTarget[0].IsBlendEnabled = true;                      transparentDesc.RenderTarget[0].SourceBlend = BlendOption.SourceAlpha;                      transparentDesc.RenderTarget[0].DestinationBlend = BlendOption.InverseSourceAlpha;                      transparentDesc.RenderTarget[0].BlendOperation = BlendOperation.Add;                      transparentDesc.RenderTarget[0].SourceAlphaBlend = BlendOption.One;                      transparentDesc.RenderTarget[0].DestinationAlphaBlend = BlendOption.Zero;                      transparentDesc.RenderTarget[0].AlphaBlendOperation = BlendOperation.Add;                      transparentDesc.RenderTarget[0].RenderTargetWriteMask = ColorWriteMaskFlags.All;                        _transparentBS = ToDispose(new BlendState(_device' transparentDesc));                  }              }
Magic Number,Capture.Hook.DX11,DXSprite,C:\repos\spazzarama_Direct3DHook\Capture\Hook\DX11\DXSprite.cs,Initialize,The following statement contains a magic number: {                                    if (_compiledFX.HasErrors)                      return false;                    _effect = ToDispose(new Effect(_device' _compiledFX));                  {                      _spriteTech = ToDispose(_effect.GetTechniqueByName("SpriteTech"));                      _spriteMap = ToDispose(_effect.GetVariableByName("SpriteTex").AsShaderResource());                        using (var pass = _spriteTech.GetPassByIndex(0))                      {                          InputElement[] layoutDesc = {                                                          new InputElement("POSITION"' 0' SharpDX.DXGI.Format.R32G32B32_Float' 0' 0' InputClassification.PerVertexData' 0)'                                                          new InputElement("TEXCOORD"' 0' SharpDX.DXGI.Format.R32G32_Float' 12' 0' InputClassification.PerVertexData' 0)'                                                          new InputElement("COLOR"' 0' SharpDX.DXGI.Format.R32G32B32A32_Float' 20' 0' InputClassification.PerVertexData' 0)                                                      };                            _inputLayout = ToDispose(new InputLayout(_device' pass.Description.Signature' layoutDesc));                      }                      // Create Vertex Buffer                      BufferDescription vbd = new BufferDescription                      {                          SizeInBytes = 2048 * Marshal.SizeOf(typeof(SpriteVertex))'                          Usage = ResourceUsage.Dynamic'                          BindFlags = BindFlags.VertexBuffer'                          CpuAccessFlags = CpuAccessFlags.Write'                          OptionFlags = ResourceOptionFlags.None'                          StructureByteStride = 0                      };                        _VB = ToDispose(new SharpDX.Direct3D11.Buffer(_device' vbd));                        // Create and initialise Index Buffer                        short[] indices = new short[3072];                        for (ushort i = 0; i < 512; ++i)                      {                          indices[i * 6] = (short)(i * 4);                          indices[i * 6 + 1] = (short)(i * 4 + 1);                          indices[i * 6 + 2] = (short)(i * 4 + 2);                          indices[i * 6 + 3] = (short)(i * 4);                          indices[i * 6 + 4] = (short)(i * 4 + 2);                          indices[i * 6 + 5] = (short)(i * 4 + 3);                      }                        _indexBuffer = ToDispose(new SafeHGlobal(indices.Length * Marshal.SizeOf(indices[0])));                      Marshal.Copy(indices' 0' _indexBuffer.DangerousGetHandle()' indices.Length);                        BufferDescription ibd = new BufferDescription                      {                          SizeInBytes = 3072 * Marshal.SizeOf(typeof(short))'                          Usage = ResourceUsage.Immutable'                          BindFlags = BindFlags.IndexBuffer'                          CpuAccessFlags = CpuAccessFlags.None'                          OptionFlags = ResourceOptionFlags.None'                          StructureByteStride = 0                      };                                            _IB = ToDispose(new SharpDX.Direct3D11.Buffer(_device' _indexBuffer.DangerousGetHandle()' ibd));                        BlendStateDescription transparentDesc = new BlendStateDescription()                      {                          AlphaToCoverageEnable = false'                          IndependentBlendEnable = false'                      };                      transparentDesc.RenderTarget[0].IsBlendEnabled = true;                      transparentDesc.RenderTarget[0].SourceBlend = BlendOption.SourceAlpha;                      transparentDesc.RenderTarget[0].DestinationBlend = BlendOption.InverseSourceAlpha;                      transparentDesc.RenderTarget[0].BlendOperation = BlendOperation.Add;                      transparentDesc.RenderTarget[0].SourceAlphaBlend = BlendOption.One;                      transparentDesc.RenderTarget[0].DestinationAlphaBlend = BlendOption.Zero;                      transparentDesc.RenderTarget[0].AlphaBlendOperation = BlendOperation.Add;                      transparentDesc.RenderTarget[0].RenderTargetWriteMask = ColorWriteMaskFlags.All;                        _transparentBS = ToDispose(new BlendState(_device' transparentDesc));                  }              }
Magic Number,Capture.Hook.DX11,DXSprite,C:\repos\spazzarama_Direct3DHook\Capture\Hook\DX11\DXSprite.cs,Initialize,The following statement contains a magic number: {                                    if (_compiledFX.HasErrors)                      return false;                    _effect = ToDispose(new Effect(_device' _compiledFX));                  {                      _spriteTech = ToDispose(_effect.GetTechniqueByName("SpriteTech"));                      _spriteMap = ToDispose(_effect.GetVariableByName("SpriteTex").AsShaderResource());                        using (var pass = _spriteTech.GetPassByIndex(0))                      {                          InputElement[] layoutDesc = {                                                          new InputElement("POSITION"' 0' SharpDX.DXGI.Format.R32G32B32_Float' 0' 0' InputClassification.PerVertexData' 0)'                                                          new InputElement("TEXCOORD"' 0' SharpDX.DXGI.Format.R32G32_Float' 12' 0' InputClassification.PerVertexData' 0)'                                                          new InputElement("COLOR"' 0' SharpDX.DXGI.Format.R32G32B32A32_Float' 20' 0' InputClassification.PerVertexData' 0)                                                      };                            _inputLayout = ToDispose(new InputLayout(_device' pass.Description.Signature' layoutDesc));                      }                      // Create Vertex Buffer                      BufferDescription vbd = new BufferDescription                      {                          SizeInBytes = 2048 * Marshal.SizeOf(typeof(SpriteVertex))'                          Usage = ResourceUsage.Dynamic'                          BindFlags = BindFlags.VertexBuffer'                          CpuAccessFlags = CpuAccessFlags.Write'                          OptionFlags = ResourceOptionFlags.None'                          StructureByteStride = 0                      };                        _VB = ToDispose(new SharpDX.Direct3D11.Buffer(_device' vbd));                        // Create and initialise Index Buffer                        short[] indices = new short[3072];                        for (ushort i = 0; i < 512; ++i)                      {                          indices[i * 6] = (short)(i * 4);                          indices[i * 6 + 1] = (short)(i * 4 + 1);                          indices[i * 6 + 2] = (short)(i * 4 + 2);                          indices[i * 6 + 3] = (short)(i * 4);                          indices[i * 6 + 4] = (short)(i * 4 + 2);                          indices[i * 6 + 5] = (short)(i * 4 + 3);                      }                        _indexBuffer = ToDispose(new SafeHGlobal(indices.Length * Marshal.SizeOf(indices[0])));                      Marshal.Copy(indices' 0' _indexBuffer.DangerousGetHandle()' indices.Length);                        BufferDescription ibd = new BufferDescription                      {                          SizeInBytes = 3072 * Marshal.SizeOf(typeof(short))'                          Usage = ResourceUsage.Immutable'                          BindFlags = BindFlags.IndexBuffer'                          CpuAccessFlags = CpuAccessFlags.None'                          OptionFlags = ResourceOptionFlags.None'                          StructureByteStride = 0                      };                                            _IB = ToDispose(new SharpDX.Direct3D11.Buffer(_device' _indexBuffer.DangerousGetHandle()' ibd));                        BlendStateDescription transparentDesc = new BlendStateDescription()                      {                          AlphaToCoverageEnable = false'                          IndependentBlendEnable = false'                      };                      transparentDesc.RenderTarget[0].IsBlendEnabled = true;                      transparentDesc.RenderTarget[0].SourceBlend = BlendOption.SourceAlpha;                      transparentDesc.RenderTarget[0].DestinationBlend = BlendOption.InverseSourceAlpha;                      transparentDesc.RenderTarget[0].BlendOperation = BlendOperation.Add;                      transparentDesc.RenderTarget[0].SourceAlphaBlend = BlendOption.One;                      transparentDesc.RenderTarget[0].DestinationAlphaBlend = BlendOption.Zero;                      transparentDesc.RenderTarget[0].AlphaBlendOperation = BlendOperation.Add;                      transparentDesc.RenderTarget[0].RenderTargetWriteMask = ColorWriteMaskFlags.All;                        _transparentBS = ToDispose(new BlendState(_device' transparentDesc));                  }              }
Magic Number,Capture.Hook.DX11,DXSprite,C:\repos\spazzarama_Direct3DHook\Capture\Hook\DX11\DXSprite.cs,Initialize,The following statement contains a magic number: {                                    if (_compiledFX.HasErrors)                      return false;                    _effect = ToDispose(new Effect(_device' _compiledFX));                  {                      _spriteTech = ToDispose(_effect.GetTechniqueByName("SpriteTech"));                      _spriteMap = ToDispose(_effect.GetVariableByName("SpriteTex").AsShaderResource());                        using (var pass = _spriteTech.GetPassByIndex(0))                      {                          InputElement[] layoutDesc = {                                                          new InputElement("POSITION"' 0' SharpDX.DXGI.Format.R32G32B32_Float' 0' 0' InputClassification.PerVertexData' 0)'                                                          new InputElement("TEXCOORD"' 0' SharpDX.DXGI.Format.R32G32_Float' 12' 0' InputClassification.PerVertexData' 0)'                                                          new InputElement("COLOR"' 0' SharpDX.DXGI.Format.R32G32B32A32_Float' 20' 0' InputClassification.PerVertexData' 0)                                                      };                            _inputLayout = ToDispose(new InputLayout(_device' pass.Description.Signature' layoutDesc));                      }                      // Create Vertex Buffer                      BufferDescription vbd = new BufferDescription                      {                          SizeInBytes = 2048 * Marshal.SizeOf(typeof(SpriteVertex))'                          Usage = ResourceUsage.Dynamic'                          BindFlags = BindFlags.VertexBuffer'                          CpuAccessFlags = CpuAccessFlags.Write'                          OptionFlags = ResourceOptionFlags.None'                          StructureByteStride = 0                      };                        _VB = ToDispose(new SharpDX.Direct3D11.Buffer(_device' vbd));                        // Create and initialise Index Buffer                        short[] indices = new short[3072];                        for (ushort i = 0; i < 512; ++i)                      {                          indices[i * 6] = (short)(i * 4);                          indices[i * 6 + 1] = (short)(i * 4 + 1);                          indices[i * 6 + 2] = (short)(i * 4 + 2);                          indices[i * 6 + 3] = (short)(i * 4);                          indices[i * 6 + 4] = (short)(i * 4 + 2);                          indices[i * 6 + 5] = (short)(i * 4 + 3);                      }                        _indexBuffer = ToDispose(new SafeHGlobal(indices.Length * Marshal.SizeOf(indices[0])));                      Marshal.Copy(indices' 0' _indexBuffer.DangerousGetHandle()' indices.Length);                        BufferDescription ibd = new BufferDescription                      {                          SizeInBytes = 3072 * Marshal.SizeOf(typeof(short))'                          Usage = ResourceUsage.Immutable'                          BindFlags = BindFlags.IndexBuffer'                          CpuAccessFlags = CpuAccessFlags.None'                          OptionFlags = ResourceOptionFlags.None'                          StructureByteStride = 0                      };                                            _IB = ToDispose(new SharpDX.Direct3D11.Buffer(_device' _indexBuffer.DangerousGetHandle()' ibd));                        BlendStateDescription transparentDesc = new BlendStateDescription()                      {                          AlphaToCoverageEnable = false'                          IndependentBlendEnable = false'                      };                      transparentDesc.RenderTarget[0].IsBlendEnabled = true;                      transparentDesc.RenderTarget[0].SourceBlend = BlendOption.SourceAlpha;                      transparentDesc.RenderTarget[0].DestinationBlend = BlendOption.InverseSourceAlpha;                      transparentDesc.RenderTarget[0].BlendOperation = BlendOperation.Add;                      transparentDesc.RenderTarget[0].SourceAlphaBlend = BlendOption.One;                      transparentDesc.RenderTarget[0].DestinationAlphaBlend = BlendOption.Zero;                      transparentDesc.RenderTarget[0].AlphaBlendOperation = BlendOperation.Add;                      transparentDesc.RenderTarget[0].RenderTargetWriteMask = ColorWriteMaskFlags.All;                        _transparentBS = ToDispose(new BlendState(_device' transparentDesc));                  }              }
Magic Number,Capture.Hook.DX11,DXSprite,C:\repos\spazzarama_Direct3DHook\Capture\Hook\DX11\DXSprite.cs,Initialize,The following statement contains a magic number: {                                    if (_compiledFX.HasErrors)                      return false;                    _effect = ToDispose(new Effect(_device' _compiledFX));                  {                      _spriteTech = ToDispose(_effect.GetTechniqueByName("SpriteTech"));                      _spriteMap = ToDispose(_effect.GetVariableByName("SpriteTex").AsShaderResource());                        using (var pass = _spriteTech.GetPassByIndex(0))                      {                          InputElement[] layoutDesc = {                                                          new InputElement("POSITION"' 0' SharpDX.DXGI.Format.R32G32B32_Float' 0' 0' InputClassification.PerVertexData' 0)'                                                          new InputElement("TEXCOORD"' 0' SharpDX.DXGI.Format.R32G32_Float' 12' 0' InputClassification.PerVertexData' 0)'                                                          new InputElement("COLOR"' 0' SharpDX.DXGI.Format.R32G32B32A32_Float' 20' 0' InputClassification.PerVertexData' 0)                                                      };                            _inputLayout = ToDispose(new InputLayout(_device' pass.Description.Signature' layoutDesc));                      }                      // Create Vertex Buffer                      BufferDescription vbd = new BufferDescription                      {                          SizeInBytes = 2048 * Marshal.SizeOf(typeof(SpriteVertex))'                          Usage = ResourceUsage.Dynamic'                          BindFlags = BindFlags.VertexBuffer'                          CpuAccessFlags = CpuAccessFlags.Write'                          OptionFlags = ResourceOptionFlags.None'                          StructureByteStride = 0                      };                        _VB = ToDispose(new SharpDX.Direct3D11.Buffer(_device' vbd));                        // Create and initialise Index Buffer                        short[] indices = new short[3072];                        for (ushort i = 0; i < 512; ++i)                      {                          indices[i * 6] = (short)(i * 4);                          indices[i * 6 + 1] = (short)(i * 4 + 1);                          indices[i * 6 + 2] = (short)(i * 4 + 2);                          indices[i * 6 + 3] = (short)(i * 4);                          indices[i * 6 + 4] = (short)(i * 4 + 2);                          indices[i * 6 + 5] = (short)(i * 4 + 3);                      }                        _indexBuffer = ToDispose(new SafeHGlobal(indices.Length * Marshal.SizeOf(indices[0])));                      Marshal.Copy(indices' 0' _indexBuffer.DangerousGetHandle()' indices.Length);                        BufferDescription ibd = new BufferDescription                      {                          SizeInBytes = 3072 * Marshal.SizeOf(typeof(short))'                          Usage = ResourceUsage.Immutable'                          BindFlags = BindFlags.IndexBuffer'                          CpuAccessFlags = CpuAccessFlags.None'                          OptionFlags = ResourceOptionFlags.None'                          StructureByteStride = 0                      };                                            _IB = ToDispose(new SharpDX.Direct3D11.Buffer(_device' _indexBuffer.DangerousGetHandle()' ibd));                        BlendStateDescription transparentDesc = new BlendStateDescription()                      {                          AlphaToCoverageEnable = false'                          IndependentBlendEnable = false'                      };                      transparentDesc.RenderTarget[0].IsBlendEnabled = true;                      transparentDesc.RenderTarget[0].SourceBlend = BlendOption.SourceAlpha;                      transparentDesc.RenderTarget[0].DestinationBlend = BlendOption.InverseSourceAlpha;                      transparentDesc.RenderTarget[0].BlendOperation = BlendOperation.Add;                      transparentDesc.RenderTarget[0].SourceAlphaBlend = BlendOption.One;                      transparentDesc.RenderTarget[0].DestinationAlphaBlend = BlendOption.Zero;                      transparentDesc.RenderTarget[0].AlphaBlendOperation = BlendOperation.Add;                      transparentDesc.RenderTarget[0].RenderTargetWriteMask = ColorWriteMaskFlags.All;                        _transparentBS = ToDispose(new BlendState(_device' transparentDesc));                  }              }
Magic Number,Capture.Hook.DX11,DXSprite,C:\repos\spazzarama_Direct3DHook\Capture\Hook\DX11\DXSprite.cs,Initialize,The following statement contains a magic number: {                                    if (_compiledFX.HasErrors)                      return false;                    _effect = ToDispose(new Effect(_device' _compiledFX));                  {                      _spriteTech = ToDispose(_effect.GetTechniqueByName("SpriteTech"));                      _spriteMap = ToDispose(_effect.GetVariableByName("SpriteTex").AsShaderResource());                        using (var pass = _spriteTech.GetPassByIndex(0))                      {                          InputElement[] layoutDesc = {                                                          new InputElement("POSITION"' 0' SharpDX.DXGI.Format.R32G32B32_Float' 0' 0' InputClassification.PerVertexData' 0)'                                                          new InputElement("TEXCOORD"' 0' SharpDX.DXGI.Format.R32G32_Float' 12' 0' InputClassification.PerVertexData' 0)'                                                          new InputElement("COLOR"' 0' SharpDX.DXGI.Format.R32G32B32A32_Float' 20' 0' InputClassification.PerVertexData' 0)                                                      };                            _inputLayout = ToDispose(new InputLayout(_device' pass.Description.Signature' layoutDesc));                      }                      // Create Vertex Buffer                      BufferDescription vbd = new BufferDescription                      {                          SizeInBytes = 2048 * Marshal.SizeOf(typeof(SpriteVertex))'                          Usage = ResourceUsage.Dynamic'                          BindFlags = BindFlags.VertexBuffer'                          CpuAccessFlags = CpuAccessFlags.Write'                          OptionFlags = ResourceOptionFlags.None'                          StructureByteStride = 0                      };                        _VB = ToDispose(new SharpDX.Direct3D11.Buffer(_device' vbd));                        // Create and initialise Index Buffer                        short[] indices = new short[3072];                        for (ushort i = 0; i < 512; ++i)                      {                          indices[i * 6] = (short)(i * 4);                          indices[i * 6 + 1] = (short)(i * 4 + 1);                          indices[i * 6 + 2] = (short)(i * 4 + 2);                          indices[i * 6 + 3] = (short)(i * 4);                          indices[i * 6 + 4] = (short)(i * 4 + 2);                          indices[i * 6 + 5] = (short)(i * 4 + 3);                      }                        _indexBuffer = ToDispose(new SafeHGlobal(indices.Length * Marshal.SizeOf(indices[0])));                      Marshal.Copy(indices' 0' _indexBuffer.DangerousGetHandle()' indices.Length);                        BufferDescription ibd = new BufferDescription                      {                          SizeInBytes = 3072 * Marshal.SizeOf(typeof(short))'                          Usage = ResourceUsage.Immutable'                          BindFlags = BindFlags.IndexBuffer'                          CpuAccessFlags = CpuAccessFlags.None'                          OptionFlags = ResourceOptionFlags.None'                          StructureByteStride = 0                      };                                            _IB = ToDispose(new SharpDX.Direct3D11.Buffer(_device' _indexBuffer.DangerousGetHandle()' ibd));                        BlendStateDescription transparentDesc = new BlendStateDescription()                      {                          AlphaToCoverageEnable = false'                          IndependentBlendEnable = false'                      };                      transparentDesc.RenderTarget[0].IsBlendEnabled = true;                      transparentDesc.RenderTarget[0].SourceBlend = BlendOption.SourceAlpha;                      transparentDesc.RenderTarget[0].DestinationBlend = BlendOption.InverseSourceAlpha;                      transparentDesc.RenderTarget[0].BlendOperation = BlendOperation.Add;                      transparentDesc.RenderTarget[0].SourceAlphaBlend = BlendOption.One;                      transparentDesc.RenderTarget[0].DestinationAlphaBlend = BlendOption.Zero;                      transparentDesc.RenderTarget[0].AlphaBlendOperation = BlendOperation.Add;                      transparentDesc.RenderTarget[0].RenderTargetWriteMask = ColorWriteMaskFlags.All;                        _transparentBS = ToDispose(new BlendState(_device' transparentDesc));                  }              }
Magic Number,Capture.Hook.DX11,DXSprite,C:\repos\spazzarama_Direct3DHook\Capture\Hook\DX11\DXSprite.cs,Initialize,The following statement contains a magic number: {                                    if (_compiledFX.HasErrors)                      return false;                    _effect = ToDispose(new Effect(_device' _compiledFX));                  {                      _spriteTech = ToDispose(_effect.GetTechniqueByName("SpriteTech"));                      _spriteMap = ToDispose(_effect.GetVariableByName("SpriteTex").AsShaderResource());                        using (var pass = _spriteTech.GetPassByIndex(0))                      {                          InputElement[] layoutDesc = {                                                          new InputElement("POSITION"' 0' SharpDX.DXGI.Format.R32G32B32_Float' 0' 0' InputClassification.PerVertexData' 0)'                                                          new InputElement("TEXCOORD"' 0' SharpDX.DXGI.Format.R32G32_Float' 12' 0' InputClassification.PerVertexData' 0)'                                                          new InputElement("COLOR"' 0' SharpDX.DXGI.Format.R32G32B32A32_Float' 20' 0' InputClassification.PerVertexData' 0)                                                      };                            _inputLayout = ToDispose(new InputLayout(_device' pass.Description.Signature' layoutDesc));                      }                      // Create Vertex Buffer                      BufferDescription vbd = new BufferDescription                      {                          SizeInBytes = 2048 * Marshal.SizeOf(typeof(SpriteVertex))'                          Usage = ResourceUsage.Dynamic'                          BindFlags = BindFlags.VertexBuffer'                          CpuAccessFlags = CpuAccessFlags.Write'                          OptionFlags = ResourceOptionFlags.None'                          StructureByteStride = 0                      };                        _VB = ToDispose(new SharpDX.Direct3D11.Buffer(_device' vbd));                        // Create and initialise Index Buffer                        short[] indices = new short[3072];                        for (ushort i = 0; i < 512; ++i)                      {                          indices[i * 6] = (short)(i * 4);                          indices[i * 6 + 1] = (short)(i * 4 + 1);                          indices[i * 6 + 2] = (short)(i * 4 + 2);                          indices[i * 6 + 3] = (short)(i * 4);                          indices[i * 6 + 4] = (short)(i * 4 + 2);                          indices[i * 6 + 5] = (short)(i * 4 + 3);                      }                        _indexBuffer = ToDispose(new SafeHGlobal(indices.Length * Marshal.SizeOf(indices[0])));                      Marshal.Copy(indices' 0' _indexBuffer.DangerousGetHandle()' indices.Length);                        BufferDescription ibd = new BufferDescription                      {                          SizeInBytes = 3072 * Marshal.SizeOf(typeof(short))'                          Usage = ResourceUsage.Immutable'                          BindFlags = BindFlags.IndexBuffer'                          CpuAccessFlags = CpuAccessFlags.None'                          OptionFlags = ResourceOptionFlags.None'                          StructureByteStride = 0                      };                                            _IB = ToDispose(new SharpDX.Direct3D11.Buffer(_device' _indexBuffer.DangerousGetHandle()' ibd));                        BlendStateDescription transparentDesc = new BlendStateDescription()                      {                          AlphaToCoverageEnable = false'                          IndependentBlendEnable = false'                      };                      transparentDesc.RenderTarget[0].IsBlendEnabled = true;                      transparentDesc.RenderTarget[0].SourceBlend = BlendOption.SourceAlpha;                      transparentDesc.RenderTarget[0].DestinationBlend = BlendOption.InverseSourceAlpha;                      transparentDesc.RenderTarget[0].BlendOperation = BlendOperation.Add;                      transparentDesc.RenderTarget[0].SourceAlphaBlend = BlendOption.One;                      transparentDesc.RenderTarget[0].DestinationAlphaBlend = BlendOption.Zero;                      transparentDesc.RenderTarget[0].AlphaBlendOperation = BlendOperation.Add;                      transparentDesc.RenderTarget[0].RenderTargetWriteMask = ColorWriteMaskFlags.All;                        _transparentBS = ToDispose(new BlendState(_device' transparentDesc));                  }              }
Magic Number,Capture.Hook.DX11,DXSprite,C:\repos\spazzarama_Direct3DHook\Capture\Hook\DX11\DXSprite.cs,Initialize,The following statement contains a magic number: {                                    if (_compiledFX.HasErrors)                      return false;                    _effect = ToDispose(new Effect(_device' _compiledFX));                  {                      _spriteTech = ToDispose(_effect.GetTechniqueByName("SpriteTech"));                      _spriteMap = ToDispose(_effect.GetVariableByName("SpriteTex").AsShaderResource());                        using (var pass = _spriteTech.GetPassByIndex(0))                      {                          InputElement[] layoutDesc = {                                                          new InputElement("POSITION"' 0' SharpDX.DXGI.Format.R32G32B32_Float' 0' 0' InputClassification.PerVertexData' 0)'                                                          new InputElement("TEXCOORD"' 0' SharpDX.DXGI.Format.R32G32_Float' 12' 0' InputClassification.PerVertexData' 0)'                                                          new InputElement("COLOR"' 0' SharpDX.DXGI.Format.R32G32B32A32_Float' 20' 0' InputClassification.PerVertexData' 0)                                                      };                            _inputLayout = ToDispose(new InputLayout(_device' pass.Description.Signature' layoutDesc));                      }                      // Create Vertex Buffer                      BufferDescription vbd = new BufferDescription                      {                          SizeInBytes = 2048 * Marshal.SizeOf(typeof(SpriteVertex))'                          Usage = ResourceUsage.Dynamic'                          BindFlags = BindFlags.VertexBuffer'                          CpuAccessFlags = CpuAccessFlags.Write'                          OptionFlags = ResourceOptionFlags.None'                          StructureByteStride = 0                      };                        _VB = ToDispose(new SharpDX.Direct3D11.Buffer(_device' vbd));                        // Create and initialise Index Buffer                        short[] indices = new short[3072];                        for (ushort i = 0; i < 512; ++i)                      {                          indices[i * 6] = (short)(i * 4);                          indices[i * 6 + 1] = (short)(i * 4 + 1);                          indices[i * 6 + 2] = (short)(i * 4 + 2);                          indices[i * 6 + 3] = (short)(i * 4);                          indices[i * 6 + 4] = (short)(i * 4 + 2);                          indices[i * 6 + 5] = (short)(i * 4 + 3);                      }                        _indexBuffer = ToDispose(new SafeHGlobal(indices.Length * Marshal.SizeOf(indices[0])));                      Marshal.Copy(indices' 0' _indexBuffer.DangerousGetHandle()' indices.Length);                        BufferDescription ibd = new BufferDescription                      {                          SizeInBytes = 3072 * Marshal.SizeOf(typeof(short))'                          Usage = ResourceUsage.Immutable'                          BindFlags = BindFlags.IndexBuffer'                          CpuAccessFlags = CpuAccessFlags.None'                          OptionFlags = ResourceOptionFlags.None'                          StructureByteStride = 0                      };                                            _IB = ToDispose(new SharpDX.Direct3D11.Buffer(_device' _indexBuffer.DangerousGetHandle()' ibd));                        BlendStateDescription transparentDesc = new BlendStateDescription()                      {                          AlphaToCoverageEnable = false'                          IndependentBlendEnable = false'                      };                      transparentDesc.RenderTarget[0].IsBlendEnabled = true;                      transparentDesc.RenderTarget[0].SourceBlend = BlendOption.SourceAlpha;                      transparentDesc.RenderTarget[0].DestinationBlend = BlendOption.InverseSourceAlpha;                      transparentDesc.RenderTarget[0].BlendOperation = BlendOperation.Add;                      transparentDesc.RenderTarget[0].SourceAlphaBlend = BlendOption.One;                      transparentDesc.RenderTarget[0].DestinationAlphaBlend = BlendOption.Zero;                      transparentDesc.RenderTarget[0].AlphaBlendOperation = BlendOperation.Add;                      transparentDesc.RenderTarget[0].RenderTargetWriteMask = ColorWriteMaskFlags.All;                        _transparentBS = ToDispose(new BlendState(_device' transparentDesc));                  }              }
Magic Number,Capture.Hook.DX11,DXSprite,C:\repos\spazzarama_Direct3DHook\Capture\Hook\DX11\DXSprite.cs,Initialize,The following statement contains a magic number: {                                    if (_compiledFX.HasErrors)                      return false;                    _effect = ToDispose(new Effect(_device' _compiledFX));                  {                      _spriteTech = ToDispose(_effect.GetTechniqueByName("SpriteTech"));                      _spriteMap = ToDispose(_effect.GetVariableByName("SpriteTex").AsShaderResource());                        using (var pass = _spriteTech.GetPassByIndex(0))                      {                          InputElement[] layoutDesc = {                                                          new InputElement("POSITION"' 0' SharpDX.DXGI.Format.R32G32B32_Float' 0' 0' InputClassification.PerVertexData' 0)'                                                          new InputElement("TEXCOORD"' 0' SharpDX.DXGI.Format.R32G32_Float' 12' 0' InputClassification.PerVertexData' 0)'                                                          new InputElement("COLOR"' 0' SharpDX.DXGI.Format.R32G32B32A32_Float' 20' 0' InputClassification.PerVertexData' 0)                                                      };                            _inputLayout = ToDispose(new InputLayout(_device' pass.Description.Signature' layoutDesc));                      }                      // Create Vertex Buffer                      BufferDescription vbd = new BufferDescription                      {                          SizeInBytes = 2048 * Marshal.SizeOf(typeof(SpriteVertex))'                          Usage = ResourceUsage.Dynamic'                          BindFlags = BindFlags.VertexBuffer'                          CpuAccessFlags = CpuAccessFlags.Write'                          OptionFlags = ResourceOptionFlags.None'                          StructureByteStride = 0                      };                        _VB = ToDispose(new SharpDX.Direct3D11.Buffer(_device' vbd));                        // Create and initialise Index Buffer                        short[] indices = new short[3072];                        for (ushort i = 0; i < 512; ++i)                      {                          indices[i * 6] = (short)(i * 4);                          indices[i * 6 + 1] = (short)(i * 4 + 1);                          indices[i * 6 + 2] = (short)(i * 4 + 2);                          indices[i * 6 + 3] = (short)(i * 4);                          indices[i * 6 + 4] = (short)(i * 4 + 2);                          indices[i * 6 + 5] = (short)(i * 4 + 3);                      }                        _indexBuffer = ToDispose(new SafeHGlobal(indices.Length * Marshal.SizeOf(indices[0])));                      Marshal.Copy(indices' 0' _indexBuffer.DangerousGetHandle()' indices.Length);                        BufferDescription ibd = new BufferDescription                      {                          SizeInBytes = 3072 * Marshal.SizeOf(typeof(short))'                          Usage = ResourceUsage.Immutable'                          BindFlags = BindFlags.IndexBuffer'                          CpuAccessFlags = CpuAccessFlags.None'                          OptionFlags = ResourceOptionFlags.None'                          StructureByteStride = 0                      };                                            _IB = ToDispose(new SharpDX.Direct3D11.Buffer(_device' _indexBuffer.DangerousGetHandle()' ibd));                        BlendStateDescription transparentDesc = new BlendStateDescription()                      {                          AlphaToCoverageEnable = false'                          IndependentBlendEnable = false'                      };                      transparentDesc.RenderTarget[0].IsBlendEnabled = true;                      transparentDesc.RenderTarget[0].SourceBlend = BlendOption.SourceAlpha;                      transparentDesc.RenderTarget[0].DestinationBlend = BlendOption.InverseSourceAlpha;                      transparentDesc.RenderTarget[0].BlendOperation = BlendOperation.Add;                      transparentDesc.RenderTarget[0].SourceAlphaBlend = BlendOption.One;                      transparentDesc.RenderTarget[0].DestinationAlphaBlend = BlendOption.Zero;                      transparentDesc.RenderTarget[0].AlphaBlendOperation = BlendOperation.Add;                      transparentDesc.RenderTarget[0].RenderTargetWriteMask = ColorWriteMaskFlags.All;                        _transparentBS = ToDispose(new BlendState(_device' transparentDesc));                  }              }
Magic Number,Capture.Hook.DX11,DXSprite,C:\repos\spazzarama_Direct3DHook\Capture\Hook\DX11\DXSprite.cs,Initialize,The following statement contains a magic number: {                                    if (_compiledFX.HasErrors)                      return false;                    _effect = ToDispose(new Effect(_device' _compiledFX));                  {                      _spriteTech = ToDispose(_effect.GetTechniqueByName("SpriteTech"));                      _spriteMap = ToDispose(_effect.GetVariableByName("SpriteTex").AsShaderResource());                        using (var pass = _spriteTech.GetPassByIndex(0))                      {                          InputElement[] layoutDesc = {                                                          new InputElement("POSITION"' 0' SharpDX.DXGI.Format.R32G32B32_Float' 0' 0' InputClassification.PerVertexData' 0)'                                                          new InputElement("TEXCOORD"' 0' SharpDX.DXGI.Format.R32G32_Float' 12' 0' InputClassification.PerVertexData' 0)'                                                          new InputElement("COLOR"' 0' SharpDX.DXGI.Format.R32G32B32A32_Float' 20' 0' InputClassification.PerVertexData' 0)                                                      };                            _inputLayout = ToDispose(new InputLayout(_device' pass.Description.Signature' layoutDesc));                      }                      // Create Vertex Buffer                      BufferDescription vbd = new BufferDescription                      {                          SizeInBytes = 2048 * Marshal.SizeOf(typeof(SpriteVertex))'                          Usage = ResourceUsage.Dynamic'                          BindFlags = BindFlags.VertexBuffer'                          CpuAccessFlags = CpuAccessFlags.Write'                          OptionFlags = ResourceOptionFlags.None'                          StructureByteStride = 0                      };                        _VB = ToDispose(new SharpDX.Direct3D11.Buffer(_device' vbd));                        // Create and initialise Index Buffer                        short[] indices = new short[3072];                        for (ushort i = 0; i < 512; ++i)                      {                          indices[i * 6] = (short)(i * 4);                          indices[i * 6 + 1] = (short)(i * 4 + 1);                          indices[i * 6 + 2] = (short)(i * 4 + 2);                          indices[i * 6 + 3] = (short)(i * 4);                          indices[i * 6 + 4] = (short)(i * 4 + 2);                          indices[i * 6 + 5] = (short)(i * 4 + 3);                      }                        _indexBuffer = ToDispose(new SafeHGlobal(indices.Length * Marshal.SizeOf(indices[0])));                      Marshal.Copy(indices' 0' _indexBuffer.DangerousGetHandle()' indices.Length);                        BufferDescription ibd = new BufferDescription                      {                          SizeInBytes = 3072 * Marshal.SizeOf(typeof(short))'                          Usage = ResourceUsage.Immutable'                          BindFlags = BindFlags.IndexBuffer'                          CpuAccessFlags = CpuAccessFlags.None'                          OptionFlags = ResourceOptionFlags.None'                          StructureByteStride = 0                      };                                            _IB = ToDispose(new SharpDX.Direct3D11.Buffer(_device' _indexBuffer.DangerousGetHandle()' ibd));                        BlendStateDescription transparentDesc = new BlendStateDescription()                      {                          AlphaToCoverageEnable = false'                          IndependentBlendEnable = false'                      };                      transparentDesc.RenderTarget[0].IsBlendEnabled = true;                      transparentDesc.RenderTarget[0].SourceBlend = BlendOption.SourceAlpha;                      transparentDesc.RenderTarget[0].DestinationBlend = BlendOption.InverseSourceAlpha;                      transparentDesc.RenderTarget[0].BlendOperation = BlendOperation.Add;                      transparentDesc.RenderTarget[0].SourceAlphaBlend = BlendOption.One;                      transparentDesc.RenderTarget[0].DestinationAlphaBlend = BlendOption.Zero;                      transparentDesc.RenderTarget[0].AlphaBlendOperation = BlendOperation.Add;                      transparentDesc.RenderTarget[0].RenderTargetWriteMask = ColorWriteMaskFlags.All;                        _transparentBS = ToDispose(new BlendState(_device' transparentDesc));                  }              }
Magic Number,Capture.Hook.DX11,DXSprite,C:\repos\spazzarama_Direct3DHook\Capture\Hook\DX11\DXSprite.cs,Initialize,The following statement contains a magic number: {                                    if (_compiledFX.HasErrors)                      return false;                    _effect = ToDispose(new Effect(_device' _compiledFX));                  {                      _spriteTech = ToDispose(_effect.GetTechniqueByName("SpriteTech"));                      _spriteMap = ToDispose(_effect.GetVariableByName("SpriteTex").AsShaderResource());                        using (var pass = _spriteTech.GetPassByIndex(0))                      {                          InputElement[] layoutDesc = {                                                          new InputElement("POSITION"' 0' SharpDX.DXGI.Format.R32G32B32_Float' 0' 0' InputClassification.PerVertexData' 0)'                                                          new InputElement("TEXCOORD"' 0' SharpDX.DXGI.Format.R32G32_Float' 12' 0' InputClassification.PerVertexData' 0)'                                                          new InputElement("COLOR"' 0' SharpDX.DXGI.Format.R32G32B32A32_Float' 20' 0' InputClassification.PerVertexData' 0)                                                      };                            _inputLayout = ToDispose(new InputLayout(_device' pass.Description.Signature' layoutDesc));                      }                      // Create Vertex Buffer                      BufferDescription vbd = new BufferDescription                      {                          SizeInBytes = 2048 * Marshal.SizeOf(typeof(SpriteVertex))'                          Usage = ResourceUsage.Dynamic'                          BindFlags = BindFlags.VertexBuffer'                          CpuAccessFlags = CpuAccessFlags.Write'                          OptionFlags = ResourceOptionFlags.None'                          StructureByteStride = 0                      };                        _VB = ToDispose(new SharpDX.Direct3D11.Buffer(_device' vbd));                        // Create and initialise Index Buffer                        short[] indices = new short[3072];                        for (ushort i = 0; i < 512; ++i)                      {                          indices[i * 6] = (short)(i * 4);                          indices[i * 6 + 1] = (short)(i * 4 + 1);                          indices[i * 6 + 2] = (short)(i * 4 + 2);                          indices[i * 6 + 3] = (short)(i * 4);                          indices[i * 6 + 4] = (short)(i * 4 + 2);                          indices[i * 6 + 5] = (short)(i * 4 + 3);                      }                        _indexBuffer = ToDispose(new SafeHGlobal(indices.Length * Marshal.SizeOf(indices[0])));                      Marshal.Copy(indices' 0' _indexBuffer.DangerousGetHandle()' indices.Length);                        BufferDescription ibd = new BufferDescription                      {                          SizeInBytes = 3072 * Marshal.SizeOf(typeof(short))'                          Usage = ResourceUsage.Immutable'                          BindFlags = BindFlags.IndexBuffer'                          CpuAccessFlags = CpuAccessFlags.None'                          OptionFlags = ResourceOptionFlags.None'                          StructureByteStride = 0                      };                                            _IB = ToDispose(new SharpDX.Direct3D11.Buffer(_device' _indexBuffer.DangerousGetHandle()' ibd));                        BlendStateDescription transparentDesc = new BlendStateDescription()                      {                          AlphaToCoverageEnable = false'                          IndependentBlendEnable = false'                      };                      transparentDesc.RenderTarget[0].IsBlendEnabled = true;                      transparentDesc.RenderTarget[0].SourceBlend = BlendOption.SourceAlpha;                      transparentDesc.RenderTarget[0].DestinationBlend = BlendOption.InverseSourceAlpha;                      transparentDesc.RenderTarget[0].BlendOperation = BlendOperation.Add;                      transparentDesc.RenderTarget[0].SourceAlphaBlend = BlendOption.One;                      transparentDesc.RenderTarget[0].DestinationAlphaBlend = BlendOption.Zero;                      transparentDesc.RenderTarget[0].AlphaBlendOperation = BlendOperation.Add;                      transparentDesc.RenderTarget[0].RenderTargetWriteMask = ColorWriteMaskFlags.All;                        _transparentBS = ToDispose(new BlendState(_device' transparentDesc));                  }              }
Magic Number,Capture.Hook.DX11,DXSprite,C:\repos\spazzarama_Direct3DHook\Capture\Hook\DX11\DXSprite.cs,Initialize,The following statement contains a magic number: {                                    if (_compiledFX.HasErrors)                      return false;                    _effect = ToDispose(new Effect(_device' _compiledFX));                  {                      _spriteTech = ToDispose(_effect.GetTechniqueByName("SpriteTech"));                      _spriteMap = ToDispose(_effect.GetVariableByName("SpriteTex").AsShaderResource());                        using (var pass = _spriteTech.GetPassByIndex(0))                      {                          InputElement[] layoutDesc = {                                                          new InputElement("POSITION"' 0' SharpDX.DXGI.Format.R32G32B32_Float' 0' 0' InputClassification.PerVertexData' 0)'                                                          new InputElement("TEXCOORD"' 0' SharpDX.DXGI.Format.R32G32_Float' 12' 0' InputClassification.PerVertexData' 0)'                                                          new InputElement("COLOR"' 0' SharpDX.DXGI.Format.R32G32B32A32_Float' 20' 0' InputClassification.PerVertexData' 0)                                                      };                            _inputLayout = ToDispose(new InputLayout(_device' pass.Description.Signature' layoutDesc));                      }                      // Create Vertex Buffer                      BufferDescription vbd = new BufferDescription                      {                          SizeInBytes = 2048 * Marshal.SizeOf(typeof(SpriteVertex))'                          Usage = ResourceUsage.Dynamic'                          BindFlags = BindFlags.VertexBuffer'                          CpuAccessFlags = CpuAccessFlags.Write'                          OptionFlags = ResourceOptionFlags.None'                          StructureByteStride = 0                      };                        _VB = ToDispose(new SharpDX.Direct3D11.Buffer(_device' vbd));                        // Create and initialise Index Buffer                        short[] indices = new short[3072];                        for (ushort i = 0; i < 512; ++i)                      {                          indices[i * 6] = (short)(i * 4);                          indices[i * 6 + 1] = (short)(i * 4 + 1);                          indices[i * 6 + 2] = (short)(i * 4 + 2);                          indices[i * 6 + 3] = (short)(i * 4);                          indices[i * 6 + 4] = (short)(i * 4 + 2);                          indices[i * 6 + 5] = (short)(i * 4 + 3);                      }                        _indexBuffer = ToDispose(new SafeHGlobal(indices.Length * Marshal.SizeOf(indices[0])));                      Marshal.Copy(indices' 0' _indexBuffer.DangerousGetHandle()' indices.Length);                        BufferDescription ibd = new BufferDescription                      {                          SizeInBytes = 3072 * Marshal.SizeOf(typeof(short))'                          Usage = ResourceUsage.Immutable'                          BindFlags = BindFlags.IndexBuffer'                          CpuAccessFlags = CpuAccessFlags.None'                          OptionFlags = ResourceOptionFlags.None'                          StructureByteStride = 0                      };                                            _IB = ToDispose(new SharpDX.Direct3D11.Buffer(_device' _indexBuffer.DangerousGetHandle()' ibd));                        BlendStateDescription transparentDesc = new BlendStateDescription()                      {                          AlphaToCoverageEnable = false'                          IndependentBlendEnable = false'                      };                      transparentDesc.RenderTarget[0].IsBlendEnabled = true;                      transparentDesc.RenderTarget[0].SourceBlend = BlendOption.SourceAlpha;                      transparentDesc.RenderTarget[0].DestinationBlend = BlendOption.InverseSourceAlpha;                      transparentDesc.RenderTarget[0].BlendOperation = BlendOperation.Add;                      transparentDesc.RenderTarget[0].SourceAlphaBlend = BlendOption.One;                      transparentDesc.RenderTarget[0].DestinationAlphaBlend = BlendOption.Zero;                      transparentDesc.RenderTarget[0].AlphaBlendOperation = BlendOperation.Add;                      transparentDesc.RenderTarget[0].RenderTargetWriteMask = ColorWriteMaskFlags.All;                        _transparentBS = ToDispose(new BlendState(_device' transparentDesc));                  }              }
Magic Number,Capture.Hook.DX11,DXSprite,C:\repos\spazzarama_Direct3DHook\Capture\Hook\DX11\DXSprite.cs,Initialize,The following statement contains a magic number: {                                    if (_compiledFX.HasErrors)                      return false;                    _effect = ToDispose(new Effect(_device' _compiledFX));                  {                      _spriteTech = ToDispose(_effect.GetTechniqueByName("SpriteTech"));                      _spriteMap = ToDispose(_effect.GetVariableByName("SpriteTex").AsShaderResource());                        using (var pass = _spriteTech.GetPassByIndex(0))                      {                          InputElement[] layoutDesc = {                                                          new InputElement("POSITION"' 0' SharpDX.DXGI.Format.R32G32B32_Float' 0' 0' InputClassification.PerVertexData' 0)'                                                          new InputElement("TEXCOORD"' 0' SharpDX.DXGI.Format.R32G32_Float' 12' 0' InputClassification.PerVertexData' 0)'                                                          new InputElement("COLOR"' 0' SharpDX.DXGI.Format.R32G32B32A32_Float' 20' 0' InputClassification.PerVertexData' 0)                                                      };                            _inputLayout = ToDispose(new InputLayout(_device' pass.Description.Signature' layoutDesc));                      }                      // Create Vertex Buffer                      BufferDescription vbd = new BufferDescription                      {                          SizeInBytes = 2048 * Marshal.SizeOf(typeof(SpriteVertex))'                          Usage = ResourceUsage.Dynamic'                          BindFlags = BindFlags.VertexBuffer'                          CpuAccessFlags = CpuAccessFlags.Write'                          OptionFlags = ResourceOptionFlags.None'                          StructureByteStride = 0                      };                        _VB = ToDispose(new SharpDX.Direct3D11.Buffer(_device' vbd));                        // Create and initialise Index Buffer                        short[] indices = new short[3072];                        for (ushort i = 0; i < 512; ++i)                      {                          indices[i * 6] = (short)(i * 4);                          indices[i * 6 + 1] = (short)(i * 4 + 1);                          indices[i * 6 + 2] = (short)(i * 4 + 2);                          indices[i * 6 + 3] = (short)(i * 4);                          indices[i * 6 + 4] = (short)(i * 4 + 2);                          indices[i * 6 + 5] = (short)(i * 4 + 3);                      }                        _indexBuffer = ToDispose(new SafeHGlobal(indices.Length * Marshal.SizeOf(indices[0])));                      Marshal.Copy(indices' 0' _indexBuffer.DangerousGetHandle()' indices.Length);                        BufferDescription ibd = new BufferDescription                      {                          SizeInBytes = 3072 * Marshal.SizeOf(typeof(short))'                          Usage = ResourceUsage.Immutable'                          BindFlags = BindFlags.IndexBuffer'                          CpuAccessFlags = CpuAccessFlags.None'                          OptionFlags = ResourceOptionFlags.None'                          StructureByteStride = 0                      };                                            _IB = ToDispose(new SharpDX.Direct3D11.Buffer(_device' _indexBuffer.DangerousGetHandle()' ibd));                        BlendStateDescription transparentDesc = new BlendStateDescription()                      {                          AlphaToCoverageEnable = false'                          IndependentBlendEnable = false'                      };                      transparentDesc.RenderTarget[0].IsBlendEnabled = true;                      transparentDesc.RenderTarget[0].SourceBlend = BlendOption.SourceAlpha;                      transparentDesc.RenderTarget[0].DestinationBlend = BlendOption.InverseSourceAlpha;                      transparentDesc.RenderTarget[0].BlendOperation = BlendOperation.Add;                      transparentDesc.RenderTarget[0].SourceAlphaBlend = BlendOption.One;                      transparentDesc.RenderTarget[0].DestinationAlphaBlend = BlendOption.Zero;                      transparentDesc.RenderTarget[0].AlphaBlendOperation = BlendOperation.Add;                      transparentDesc.RenderTarget[0].RenderTargetWriteMask = ColorWriteMaskFlags.All;                        _transparentBS = ToDispose(new BlendState(_device' transparentDesc));                  }              }
Magic Number,Capture.Hook.DX11,DXSprite,C:\repos\spazzarama_Direct3DHook\Capture\Hook\DX11\DXSprite.cs,Initialize,The following statement contains a magic number: {                                    if (_compiledFX.HasErrors)                      return false;                    _effect = ToDispose(new Effect(_device' _compiledFX));                  {                      _spriteTech = ToDispose(_effect.GetTechniqueByName("SpriteTech"));                      _spriteMap = ToDispose(_effect.GetVariableByName("SpriteTex").AsShaderResource());                        using (var pass = _spriteTech.GetPassByIndex(0))                      {                          InputElement[] layoutDesc = {                                                          new InputElement("POSITION"' 0' SharpDX.DXGI.Format.R32G32B32_Float' 0' 0' InputClassification.PerVertexData' 0)'                                                          new InputElement("TEXCOORD"' 0' SharpDX.DXGI.Format.R32G32_Float' 12' 0' InputClassification.PerVertexData' 0)'                                                          new InputElement("COLOR"' 0' SharpDX.DXGI.Format.R32G32B32A32_Float' 20' 0' InputClassification.PerVertexData' 0)                                                      };                            _inputLayout = ToDispose(new InputLayout(_device' pass.Description.Signature' layoutDesc));                      }                      // Create Vertex Buffer                      BufferDescription vbd = new BufferDescription                      {                          SizeInBytes = 2048 * Marshal.SizeOf(typeof(SpriteVertex))'                          Usage = ResourceUsage.Dynamic'                          BindFlags = BindFlags.VertexBuffer'                          CpuAccessFlags = CpuAccessFlags.Write'                          OptionFlags = ResourceOptionFlags.None'                          StructureByteStride = 0                      };                        _VB = ToDispose(new SharpDX.Direct3D11.Buffer(_device' vbd));                        // Create and initialise Index Buffer                        short[] indices = new short[3072];                        for (ushort i = 0; i < 512; ++i)                      {                          indices[i * 6] = (short)(i * 4);                          indices[i * 6 + 1] = (short)(i * 4 + 1);                          indices[i * 6 + 2] = (short)(i * 4 + 2);                          indices[i * 6 + 3] = (short)(i * 4);                          indices[i * 6 + 4] = (short)(i * 4 + 2);                          indices[i * 6 + 5] = (short)(i * 4 + 3);                      }                        _indexBuffer = ToDispose(new SafeHGlobal(indices.Length * Marshal.SizeOf(indices[0])));                      Marshal.Copy(indices' 0' _indexBuffer.DangerousGetHandle()' indices.Length);                        BufferDescription ibd = new BufferDescription                      {                          SizeInBytes = 3072 * Marshal.SizeOf(typeof(short))'                          Usage = ResourceUsage.Immutable'                          BindFlags = BindFlags.IndexBuffer'                          CpuAccessFlags = CpuAccessFlags.None'                          OptionFlags = ResourceOptionFlags.None'                          StructureByteStride = 0                      };                                            _IB = ToDispose(new SharpDX.Direct3D11.Buffer(_device' _indexBuffer.DangerousGetHandle()' ibd));                        BlendStateDescription transparentDesc = new BlendStateDescription()                      {                          AlphaToCoverageEnable = false'                          IndependentBlendEnable = false'                      };                      transparentDesc.RenderTarget[0].IsBlendEnabled = true;                      transparentDesc.RenderTarget[0].SourceBlend = BlendOption.SourceAlpha;                      transparentDesc.RenderTarget[0].DestinationBlend = BlendOption.InverseSourceAlpha;                      transparentDesc.RenderTarget[0].BlendOperation = BlendOperation.Add;                      transparentDesc.RenderTarget[0].SourceAlphaBlend = BlendOption.One;                      transparentDesc.RenderTarget[0].DestinationAlphaBlend = BlendOption.Zero;                      transparentDesc.RenderTarget[0].AlphaBlendOperation = BlendOperation.Add;                      transparentDesc.RenderTarget[0].RenderTargetWriteMask = ColorWriteMaskFlags.All;                        _transparentBS = ToDispose(new BlendState(_device' transparentDesc));                  }              }
Magic Number,Capture.Hook.DX11,DXSprite,C:\repos\spazzarama_Direct3DHook\Capture\Hook\DX11\DXSprite.cs,Initialize,The following statement contains a magic number: {                                    if (_compiledFX.HasErrors)                      return false;                    _effect = ToDispose(new Effect(_device' _compiledFX));                  {                      _spriteTech = ToDispose(_effect.GetTechniqueByName("SpriteTech"));                      _spriteMap = ToDispose(_effect.GetVariableByName("SpriteTex").AsShaderResource());                        using (var pass = _spriteTech.GetPassByIndex(0))                      {                          InputElement[] layoutDesc = {                                                          new InputElement("POSITION"' 0' SharpDX.DXGI.Format.R32G32B32_Float' 0' 0' InputClassification.PerVertexData' 0)'                                                          new InputElement("TEXCOORD"' 0' SharpDX.DXGI.Format.R32G32_Float' 12' 0' InputClassification.PerVertexData' 0)'                                                          new InputElement("COLOR"' 0' SharpDX.DXGI.Format.R32G32B32A32_Float' 20' 0' InputClassification.PerVertexData' 0)                                                      };                            _inputLayout = ToDispose(new InputLayout(_device' pass.Description.Signature' layoutDesc));                      }                      // Create Vertex Buffer                      BufferDescription vbd = new BufferDescription                      {                          SizeInBytes = 2048 * Marshal.SizeOf(typeof(SpriteVertex))'                          Usage = ResourceUsage.Dynamic'                          BindFlags = BindFlags.VertexBuffer'                          CpuAccessFlags = CpuAccessFlags.Write'                          OptionFlags = ResourceOptionFlags.None'                          StructureByteStride = 0                      };                        _VB = ToDispose(new SharpDX.Direct3D11.Buffer(_device' vbd));                        // Create and initialise Index Buffer                        short[] indices = new short[3072];                        for (ushort i = 0; i < 512; ++i)                      {                          indices[i * 6] = (short)(i * 4);                          indices[i * 6 + 1] = (short)(i * 4 + 1);                          indices[i * 6 + 2] = (short)(i * 4 + 2);                          indices[i * 6 + 3] = (short)(i * 4);                          indices[i * 6 + 4] = (short)(i * 4 + 2);                          indices[i * 6 + 5] = (short)(i * 4 + 3);                      }                        _indexBuffer = ToDispose(new SafeHGlobal(indices.Length * Marshal.SizeOf(indices[0])));                      Marshal.Copy(indices' 0' _indexBuffer.DangerousGetHandle()' indices.Length);                        BufferDescription ibd = new BufferDescription                      {                          SizeInBytes = 3072 * Marshal.SizeOf(typeof(short))'                          Usage = ResourceUsage.Immutable'                          BindFlags = BindFlags.IndexBuffer'                          CpuAccessFlags = CpuAccessFlags.None'                          OptionFlags = ResourceOptionFlags.None'                          StructureByteStride = 0                      };                                            _IB = ToDispose(new SharpDX.Direct3D11.Buffer(_device' _indexBuffer.DangerousGetHandle()' ibd));                        BlendStateDescription transparentDesc = new BlendStateDescription()                      {                          AlphaToCoverageEnable = false'                          IndependentBlendEnable = false'                      };                      transparentDesc.RenderTarget[0].IsBlendEnabled = true;                      transparentDesc.RenderTarget[0].SourceBlend = BlendOption.SourceAlpha;                      transparentDesc.RenderTarget[0].DestinationBlend = BlendOption.InverseSourceAlpha;                      transparentDesc.RenderTarget[0].BlendOperation = BlendOperation.Add;                      transparentDesc.RenderTarget[0].SourceAlphaBlend = BlendOption.One;                      transparentDesc.RenderTarget[0].DestinationAlphaBlend = BlendOption.Zero;                      transparentDesc.RenderTarget[0].AlphaBlendOperation = BlendOperation.Add;                      transparentDesc.RenderTarget[0].RenderTargetWriteMask = ColorWriteMaskFlags.All;                        _transparentBS = ToDispose(new BlendState(_device' transparentDesc));                  }              }
Magic Number,Capture.Hook.DX11,DXSprite,C:\repos\spazzarama_Direct3DHook\Capture\Hook\DX11\DXSprite.cs,Initialize,The following statement contains a magic number: {                                    if (_compiledFX.HasErrors)                      return false;                    _effect = ToDispose(new Effect(_device' _compiledFX));                  {                      _spriteTech = ToDispose(_effect.GetTechniqueByName("SpriteTech"));                      _spriteMap = ToDispose(_effect.GetVariableByName("SpriteTex").AsShaderResource());                        using (var pass = _spriteTech.GetPassByIndex(0))                      {                          InputElement[] layoutDesc = {                                                          new InputElement("POSITION"' 0' SharpDX.DXGI.Format.R32G32B32_Float' 0' 0' InputClassification.PerVertexData' 0)'                                                          new InputElement("TEXCOORD"' 0' SharpDX.DXGI.Format.R32G32_Float' 12' 0' InputClassification.PerVertexData' 0)'                                                          new InputElement("COLOR"' 0' SharpDX.DXGI.Format.R32G32B32A32_Float' 20' 0' InputClassification.PerVertexData' 0)                                                      };                            _inputLayout = ToDispose(new InputLayout(_device' pass.Description.Signature' layoutDesc));                      }                      // Create Vertex Buffer                      BufferDescription vbd = new BufferDescription                      {                          SizeInBytes = 2048 * Marshal.SizeOf(typeof(SpriteVertex))'                          Usage = ResourceUsage.Dynamic'                          BindFlags = BindFlags.VertexBuffer'                          CpuAccessFlags = CpuAccessFlags.Write'                          OptionFlags = ResourceOptionFlags.None'                          StructureByteStride = 0                      };                        _VB = ToDispose(new SharpDX.Direct3D11.Buffer(_device' vbd));                        // Create and initialise Index Buffer                        short[] indices = new short[3072];                        for (ushort i = 0; i < 512; ++i)                      {                          indices[i * 6] = (short)(i * 4);                          indices[i * 6 + 1] = (short)(i * 4 + 1);                          indices[i * 6 + 2] = (short)(i * 4 + 2);                          indices[i * 6 + 3] = (short)(i * 4);                          indices[i * 6 + 4] = (short)(i * 4 + 2);                          indices[i * 6 + 5] = (short)(i * 4 + 3);                      }                        _indexBuffer = ToDispose(new SafeHGlobal(indices.Length * Marshal.SizeOf(indices[0])));                      Marshal.Copy(indices' 0' _indexBuffer.DangerousGetHandle()' indices.Length);                        BufferDescription ibd = new BufferDescription                      {                          SizeInBytes = 3072 * Marshal.SizeOf(typeof(short))'                          Usage = ResourceUsage.Immutable'                          BindFlags = BindFlags.IndexBuffer'                          CpuAccessFlags = CpuAccessFlags.None'                          OptionFlags = ResourceOptionFlags.None'                          StructureByteStride = 0                      };                                            _IB = ToDispose(new SharpDX.Direct3D11.Buffer(_device' _indexBuffer.DangerousGetHandle()' ibd));                        BlendStateDescription transparentDesc = new BlendStateDescription()                      {                          AlphaToCoverageEnable = false'                          IndependentBlendEnable = false'                      };                      transparentDesc.RenderTarget[0].IsBlendEnabled = true;                      transparentDesc.RenderTarget[0].SourceBlend = BlendOption.SourceAlpha;                      transparentDesc.RenderTarget[0].DestinationBlend = BlendOption.InverseSourceAlpha;                      transparentDesc.RenderTarget[0].BlendOperation = BlendOperation.Add;                      transparentDesc.RenderTarget[0].SourceAlphaBlend = BlendOption.One;                      transparentDesc.RenderTarget[0].DestinationAlphaBlend = BlendOption.Zero;                      transparentDesc.RenderTarget[0].AlphaBlendOperation = BlendOperation.Add;                      transparentDesc.RenderTarget[0].RenderTargetWriteMask = ColorWriteMaskFlags.All;                        _transparentBS = ToDispose(new BlendState(_device' transparentDesc));                  }              }
Magic Number,Capture.Hook.DX11,DXSprite,C:\repos\spazzarama_Direct3DHook\Capture\Hook\DX11\DXSprite.cs,Initialize,The following statement contains a magic number: {                                    if (_compiledFX.HasErrors)                      return false;                    _effect = ToDispose(new Effect(_device' _compiledFX));                  {                      _spriteTech = ToDispose(_effect.GetTechniqueByName("SpriteTech"));                      _spriteMap = ToDispose(_effect.GetVariableByName("SpriteTex").AsShaderResource());                        using (var pass = _spriteTech.GetPassByIndex(0))                      {                          InputElement[] layoutDesc = {                                                          new InputElement("POSITION"' 0' SharpDX.DXGI.Format.R32G32B32_Float' 0' 0' InputClassification.PerVertexData' 0)'                                                          new InputElement("TEXCOORD"' 0' SharpDX.DXGI.Format.R32G32_Float' 12' 0' InputClassification.PerVertexData' 0)'                                                          new InputElement("COLOR"' 0' SharpDX.DXGI.Format.R32G32B32A32_Float' 20' 0' InputClassification.PerVertexData' 0)                                                      };                            _inputLayout = ToDispose(new InputLayout(_device' pass.Description.Signature' layoutDesc));                      }                      // Create Vertex Buffer                      BufferDescription vbd = new BufferDescription                      {                          SizeInBytes = 2048 * Marshal.SizeOf(typeof(SpriteVertex))'                          Usage = ResourceUsage.Dynamic'                          BindFlags = BindFlags.VertexBuffer'                          CpuAccessFlags = CpuAccessFlags.Write'                          OptionFlags = ResourceOptionFlags.None'                          StructureByteStride = 0                      };                        _VB = ToDispose(new SharpDX.Direct3D11.Buffer(_device' vbd));                        // Create and initialise Index Buffer                        short[] indices = new short[3072];                        for (ushort i = 0; i < 512; ++i)                      {                          indices[i * 6] = (short)(i * 4);                          indices[i * 6 + 1] = (short)(i * 4 + 1);                          indices[i * 6 + 2] = (short)(i * 4 + 2);                          indices[i * 6 + 3] = (short)(i * 4);                          indices[i * 6 + 4] = (short)(i * 4 + 2);                          indices[i * 6 + 5] = (short)(i * 4 + 3);                      }                        _indexBuffer = ToDispose(new SafeHGlobal(indices.Length * Marshal.SizeOf(indices[0])));                      Marshal.Copy(indices' 0' _indexBuffer.DangerousGetHandle()' indices.Length);                        BufferDescription ibd = new BufferDescription                      {                          SizeInBytes = 3072 * Marshal.SizeOf(typeof(short))'                          Usage = ResourceUsage.Immutable'                          BindFlags = BindFlags.IndexBuffer'                          CpuAccessFlags = CpuAccessFlags.None'                          OptionFlags = ResourceOptionFlags.None'                          StructureByteStride = 0                      };                                            _IB = ToDispose(new SharpDX.Direct3D11.Buffer(_device' _indexBuffer.DangerousGetHandle()' ibd));                        BlendStateDescription transparentDesc = new BlendStateDescription()                      {                          AlphaToCoverageEnable = false'                          IndependentBlendEnable = false'                      };                      transparentDesc.RenderTarget[0].IsBlendEnabled = true;                      transparentDesc.RenderTarget[0].SourceBlend = BlendOption.SourceAlpha;                      transparentDesc.RenderTarget[0].DestinationBlend = BlendOption.InverseSourceAlpha;                      transparentDesc.RenderTarget[0].BlendOperation = BlendOperation.Add;                      transparentDesc.RenderTarget[0].SourceAlphaBlend = BlendOption.One;                      transparentDesc.RenderTarget[0].DestinationAlphaBlend = BlendOption.Zero;                      transparentDesc.RenderTarget[0].AlphaBlendOperation = BlendOperation.Add;                      transparentDesc.RenderTarget[0].RenderTargetWriteMask = ColorWriteMaskFlags.All;                        _transparentBS = ToDispose(new BlendState(_device' transparentDesc));                  }              }
Magic Number,Capture.Hook.DX11,DXSprite,C:\repos\spazzarama_Direct3DHook\Capture\Hook\DX11\DXSprite.cs,Initialize,The following statement contains a magic number: {                                    if (_compiledFX.HasErrors)                      return false;                    _effect = ToDispose(new Effect(_device' _compiledFX));                  {                      _spriteTech = ToDispose(_effect.GetTechniqueByName("SpriteTech"));                      _spriteMap = ToDispose(_effect.GetVariableByName("SpriteTex").AsShaderResource());                        using (var pass = _spriteTech.GetPassByIndex(0))                      {                          InputElement[] layoutDesc = {                                                          new InputElement("POSITION"' 0' SharpDX.DXGI.Format.R32G32B32_Float' 0' 0' InputClassification.PerVertexData' 0)'                                                          new InputElement("TEXCOORD"' 0' SharpDX.DXGI.Format.R32G32_Float' 12' 0' InputClassification.PerVertexData' 0)'                                                          new InputElement("COLOR"' 0' SharpDX.DXGI.Format.R32G32B32A32_Float' 20' 0' InputClassification.PerVertexData' 0)                                                      };                            _inputLayout = ToDispose(new InputLayout(_device' pass.Description.Signature' layoutDesc));                      }                      // Create Vertex Buffer                      BufferDescription vbd = new BufferDescription                      {                          SizeInBytes = 2048 * Marshal.SizeOf(typeof(SpriteVertex))'                          Usage = ResourceUsage.Dynamic'                          BindFlags = BindFlags.VertexBuffer'                          CpuAccessFlags = CpuAccessFlags.Write'                          OptionFlags = ResourceOptionFlags.None'                          StructureByteStride = 0                      };                        _VB = ToDispose(new SharpDX.Direct3D11.Buffer(_device' vbd));                        // Create and initialise Index Buffer                        short[] indices = new short[3072];                        for (ushort i = 0; i < 512; ++i)                      {                          indices[i * 6] = (short)(i * 4);                          indices[i * 6 + 1] = (short)(i * 4 + 1);                          indices[i * 6 + 2] = (short)(i * 4 + 2);                          indices[i * 6 + 3] = (short)(i * 4);                          indices[i * 6 + 4] = (short)(i * 4 + 2);                          indices[i * 6 + 5] = (short)(i * 4 + 3);                      }                        _indexBuffer = ToDispose(new SafeHGlobal(indices.Length * Marshal.SizeOf(indices[0])));                      Marshal.Copy(indices' 0' _indexBuffer.DangerousGetHandle()' indices.Length);                        BufferDescription ibd = new BufferDescription                      {                          SizeInBytes = 3072 * Marshal.SizeOf(typeof(short))'                          Usage = ResourceUsage.Immutable'                          BindFlags = BindFlags.IndexBuffer'                          CpuAccessFlags = CpuAccessFlags.None'                          OptionFlags = ResourceOptionFlags.None'                          StructureByteStride = 0                      };                                            _IB = ToDispose(new SharpDX.Direct3D11.Buffer(_device' _indexBuffer.DangerousGetHandle()' ibd));                        BlendStateDescription transparentDesc = new BlendStateDescription()                      {                          AlphaToCoverageEnable = false'                          IndependentBlendEnable = false'                      };                      transparentDesc.RenderTarget[0].IsBlendEnabled = true;                      transparentDesc.RenderTarget[0].SourceBlend = BlendOption.SourceAlpha;                      transparentDesc.RenderTarget[0].DestinationBlend = BlendOption.InverseSourceAlpha;                      transparentDesc.RenderTarget[0].BlendOperation = BlendOperation.Add;                      transparentDesc.RenderTarget[0].SourceAlphaBlend = BlendOption.One;                      transparentDesc.RenderTarget[0].DestinationAlphaBlend = BlendOption.Zero;                      transparentDesc.RenderTarget[0].AlphaBlendOperation = BlendOperation.Add;                      transparentDesc.RenderTarget[0].RenderTargetWriteMask = ColorWriteMaskFlags.All;                        _transparentBS = ToDispose(new BlendState(_device' transparentDesc));                  }              }
Magic Number,Capture.Hook.DX11,DXSprite,C:\repos\spazzarama_Direct3DHook\Capture\Hook\DX11\DXSprite.cs,Initialize,The following statement contains a magic number: {                                    if (_compiledFX.HasErrors)                      return false;                    _effect = ToDispose(new Effect(_device' _compiledFX));                  {                      _spriteTech = ToDispose(_effect.GetTechniqueByName("SpriteTech"));                      _spriteMap = ToDispose(_effect.GetVariableByName("SpriteTex").AsShaderResource());                        using (var pass = _spriteTech.GetPassByIndex(0))                      {                          InputElement[] layoutDesc = {                                                          new InputElement("POSITION"' 0' SharpDX.DXGI.Format.R32G32B32_Float' 0' 0' InputClassification.PerVertexData' 0)'                                                          new InputElement("TEXCOORD"' 0' SharpDX.DXGI.Format.R32G32_Float' 12' 0' InputClassification.PerVertexData' 0)'                                                          new InputElement("COLOR"' 0' SharpDX.DXGI.Format.R32G32B32A32_Float' 20' 0' InputClassification.PerVertexData' 0)                                                      };                            _inputLayout = ToDispose(new InputLayout(_device' pass.Description.Signature' layoutDesc));                      }                      // Create Vertex Buffer                      BufferDescription vbd = new BufferDescription                      {                          SizeInBytes = 2048 * Marshal.SizeOf(typeof(SpriteVertex))'                          Usage = ResourceUsage.Dynamic'                          BindFlags = BindFlags.VertexBuffer'                          CpuAccessFlags = CpuAccessFlags.Write'                          OptionFlags = ResourceOptionFlags.None'                          StructureByteStride = 0                      };                        _VB = ToDispose(new SharpDX.Direct3D11.Buffer(_device' vbd));                        // Create and initialise Index Buffer                        short[] indices = new short[3072];                        for (ushort i = 0; i < 512; ++i)                      {                          indices[i * 6] = (short)(i * 4);                          indices[i * 6 + 1] = (short)(i * 4 + 1);                          indices[i * 6 + 2] = (short)(i * 4 + 2);                          indices[i * 6 + 3] = (short)(i * 4);                          indices[i * 6 + 4] = (short)(i * 4 + 2);                          indices[i * 6 + 5] = (short)(i * 4 + 3);                      }                        _indexBuffer = ToDispose(new SafeHGlobal(indices.Length * Marshal.SizeOf(indices[0])));                      Marshal.Copy(indices' 0' _indexBuffer.DangerousGetHandle()' indices.Length);                        BufferDescription ibd = new BufferDescription                      {                          SizeInBytes = 3072 * Marshal.SizeOf(typeof(short))'                          Usage = ResourceUsage.Immutable'                          BindFlags = BindFlags.IndexBuffer'                          CpuAccessFlags = CpuAccessFlags.None'                          OptionFlags = ResourceOptionFlags.None'                          StructureByteStride = 0                      };                                            _IB = ToDispose(new SharpDX.Direct3D11.Buffer(_device' _indexBuffer.DangerousGetHandle()' ibd));                        BlendStateDescription transparentDesc = new BlendStateDescription()                      {                          AlphaToCoverageEnable = false'                          IndependentBlendEnable = false'                      };                      transparentDesc.RenderTarget[0].IsBlendEnabled = true;                      transparentDesc.RenderTarget[0].SourceBlend = BlendOption.SourceAlpha;                      transparentDesc.RenderTarget[0].DestinationBlend = BlendOption.InverseSourceAlpha;                      transparentDesc.RenderTarget[0].BlendOperation = BlendOperation.Add;                      transparentDesc.RenderTarget[0].SourceAlphaBlend = BlendOption.One;                      transparentDesc.RenderTarget[0].DestinationAlphaBlend = BlendOption.Zero;                      transparentDesc.RenderTarget[0].AlphaBlendOperation = BlendOperation.Add;                      transparentDesc.RenderTarget[0].RenderTargetWriteMask = ColorWriteMaskFlags.All;                        _transparentBS = ToDispose(new BlendState(_device' transparentDesc));                  }              }
Magic Number,Capture.Hook.DX11,DXSprite,C:\repos\spazzarama_Direct3DHook\Capture\Hook\DX11\DXSprite.cs,Initialize,The following statement contains a magic number: {                                    if (_compiledFX.HasErrors)                      return false;                    _effect = ToDispose(new Effect(_device' _compiledFX));                  {                      _spriteTech = ToDispose(_effect.GetTechniqueByName("SpriteTech"));                      _spriteMap = ToDispose(_effect.GetVariableByName("SpriteTex").AsShaderResource());                        using (var pass = _spriteTech.GetPassByIndex(0))                      {                          InputElement[] layoutDesc = {                                                          new InputElement("POSITION"' 0' SharpDX.DXGI.Format.R32G32B32_Float' 0' 0' InputClassification.PerVertexData' 0)'                                                          new InputElement("TEXCOORD"' 0' SharpDX.DXGI.Format.R32G32_Float' 12' 0' InputClassification.PerVertexData' 0)'                                                          new InputElement("COLOR"' 0' SharpDX.DXGI.Format.R32G32B32A32_Float' 20' 0' InputClassification.PerVertexData' 0)                                                      };                            _inputLayout = ToDispose(new InputLayout(_device' pass.Description.Signature' layoutDesc));                      }                      // Create Vertex Buffer                      BufferDescription vbd = new BufferDescription                      {                          SizeInBytes = 2048 * Marshal.SizeOf(typeof(SpriteVertex))'                          Usage = ResourceUsage.Dynamic'                          BindFlags = BindFlags.VertexBuffer'                          CpuAccessFlags = CpuAccessFlags.Write'                          OptionFlags = ResourceOptionFlags.None'                          StructureByteStride = 0                      };                        _VB = ToDispose(new SharpDX.Direct3D11.Buffer(_device' vbd));                        // Create and initialise Index Buffer                        short[] indices = new short[3072];                        for (ushort i = 0; i < 512; ++i)                      {                          indices[i * 6] = (short)(i * 4);                          indices[i * 6 + 1] = (short)(i * 4 + 1);                          indices[i * 6 + 2] = (short)(i * 4 + 2);                          indices[i * 6 + 3] = (short)(i * 4);                          indices[i * 6 + 4] = (short)(i * 4 + 2);                          indices[i * 6 + 5] = (short)(i * 4 + 3);                      }                        _indexBuffer = ToDispose(new SafeHGlobal(indices.Length * Marshal.SizeOf(indices[0])));                      Marshal.Copy(indices' 0' _indexBuffer.DangerousGetHandle()' indices.Length);                        BufferDescription ibd = new BufferDescription                      {                          SizeInBytes = 3072 * Marshal.SizeOf(typeof(short))'                          Usage = ResourceUsage.Immutable'                          BindFlags = BindFlags.IndexBuffer'                          CpuAccessFlags = CpuAccessFlags.None'                          OptionFlags = ResourceOptionFlags.None'                          StructureByteStride = 0                      };                                            _IB = ToDispose(new SharpDX.Direct3D11.Buffer(_device' _indexBuffer.DangerousGetHandle()' ibd));                        BlendStateDescription transparentDesc = new BlendStateDescription()                      {                          AlphaToCoverageEnable = false'                          IndependentBlendEnable = false'                      };                      transparentDesc.RenderTarget[0].IsBlendEnabled = true;                      transparentDesc.RenderTarget[0].SourceBlend = BlendOption.SourceAlpha;                      transparentDesc.RenderTarget[0].DestinationBlend = BlendOption.InverseSourceAlpha;                      transparentDesc.RenderTarget[0].BlendOperation = BlendOperation.Add;                      transparentDesc.RenderTarget[0].SourceAlphaBlend = BlendOption.One;                      transparentDesc.RenderTarget[0].DestinationAlphaBlend = BlendOption.Zero;                      transparentDesc.RenderTarget[0].AlphaBlendOperation = BlendOperation.Add;                      transparentDesc.RenderTarget[0].RenderTargetWriteMask = ColorWriteMaskFlags.All;                        _transparentBS = ToDispose(new BlendState(_device' transparentDesc));                  }              }
Magic Number,Capture.Hook.DX11,DXSprite,C:\repos\spazzarama_Direct3DHook\Capture\Hook\DX11\DXSprite.cs,Initialize,The following statement contains a magic number: {                                    if (_compiledFX.HasErrors)                      return false;                    _effect = ToDispose(new Effect(_device' _compiledFX));                  {                      _spriteTech = ToDispose(_effect.GetTechniqueByName("SpriteTech"));                      _spriteMap = ToDispose(_effect.GetVariableByName("SpriteTex").AsShaderResource());                        using (var pass = _spriteTech.GetPassByIndex(0))                      {                          InputElement[] layoutDesc = {                                                          new InputElement("POSITION"' 0' SharpDX.DXGI.Format.R32G32B32_Float' 0' 0' InputClassification.PerVertexData' 0)'                                                          new InputElement("TEXCOORD"' 0' SharpDX.DXGI.Format.R32G32_Float' 12' 0' InputClassification.PerVertexData' 0)'                                                          new InputElement("COLOR"' 0' SharpDX.DXGI.Format.R32G32B32A32_Float' 20' 0' InputClassification.PerVertexData' 0)                                                      };                            _inputLayout = ToDispose(new InputLayout(_device' pass.Description.Signature' layoutDesc));                      }                      // Create Vertex Buffer                      BufferDescription vbd = new BufferDescription                      {                          SizeInBytes = 2048 * Marshal.SizeOf(typeof(SpriteVertex))'                          Usage = ResourceUsage.Dynamic'                          BindFlags = BindFlags.VertexBuffer'                          CpuAccessFlags = CpuAccessFlags.Write'                          OptionFlags = ResourceOptionFlags.None'                          StructureByteStride = 0                      };                        _VB = ToDispose(new SharpDX.Direct3D11.Buffer(_device' vbd));                        // Create and initialise Index Buffer                        short[] indices = new short[3072];                        for (ushort i = 0; i < 512; ++i)                      {                          indices[i * 6] = (short)(i * 4);                          indices[i * 6 + 1] = (short)(i * 4 + 1);                          indices[i * 6 + 2] = (short)(i * 4 + 2);                          indices[i * 6 + 3] = (short)(i * 4);                          indices[i * 6 + 4] = (short)(i * 4 + 2);                          indices[i * 6 + 5] = (short)(i * 4 + 3);                      }                        _indexBuffer = ToDispose(new SafeHGlobal(indices.Length * Marshal.SizeOf(indices[0])));                      Marshal.Copy(indices' 0' _indexBuffer.DangerousGetHandle()' indices.Length);                        BufferDescription ibd = new BufferDescription                      {                          SizeInBytes = 3072 * Marshal.SizeOf(typeof(short))'                          Usage = ResourceUsage.Immutable'                          BindFlags = BindFlags.IndexBuffer'                          CpuAccessFlags = CpuAccessFlags.None'                          OptionFlags = ResourceOptionFlags.None'                          StructureByteStride = 0                      };                                            _IB = ToDispose(new SharpDX.Direct3D11.Buffer(_device' _indexBuffer.DangerousGetHandle()' ibd));                        BlendStateDescription transparentDesc = new BlendStateDescription()                      {                          AlphaToCoverageEnable = false'                          IndependentBlendEnable = false'                      };                      transparentDesc.RenderTarget[0].IsBlendEnabled = true;                      transparentDesc.RenderTarget[0].SourceBlend = BlendOption.SourceAlpha;                      transparentDesc.RenderTarget[0].DestinationBlend = BlendOption.InverseSourceAlpha;                      transparentDesc.RenderTarget[0].BlendOperation = BlendOperation.Add;                      transparentDesc.RenderTarget[0].SourceAlphaBlend = BlendOption.One;                      transparentDesc.RenderTarget[0].DestinationAlphaBlend = BlendOption.Zero;                      transparentDesc.RenderTarget[0].AlphaBlendOperation = BlendOperation.Add;                      transparentDesc.RenderTarget[0].RenderTargetWriteMask = ColorWriteMaskFlags.All;                        _transparentBS = ToDispose(new BlendState(_device' transparentDesc));                  }              }
Magic Number,Capture.Hook.DX11,DXSprite,C:\repos\spazzarama_Direct3DHook\Capture\Hook\DX11\DXSprite.cs,EndBatch,The following statement contains a magic number: using (EffectPass pass = _spriteTech.GetPassByIndex(0))              {                  pass.Apply(_deviceContext);                  var spritesToDraw = _spriteList.Count;                  int startIndex = 0;                  while (spritesToDraw > 0)                  {                      if (spritesToDraw <= 512)                      {                          DrawBatch(startIndex' spritesToDraw);                          spritesToDraw = 0;                      }                      else                      {                          DrawBatch(startIndex' 512);                          startIndex += 512;                          spritesToDraw -= 512;                      }                  }              }
Magic Number,Capture.Hook.DX11,DXSprite,C:\repos\spazzarama_Direct3DHook\Capture\Hook\DX11\DXSprite.cs,EndBatch,The following statement contains a magic number: using (EffectPass pass = _spriteTech.GetPassByIndex(0))              {                  pass.Apply(_deviceContext);                  var spritesToDraw = _spriteList.Count;                  int startIndex = 0;                  while (spritesToDraw > 0)                  {                      if (spritesToDraw <= 512)                      {                          DrawBatch(startIndex' spritesToDraw);                          spritesToDraw = 0;                      }                      else                      {                          DrawBatch(startIndex' 512);                          startIndex += 512;                          spritesToDraw -= 512;                      }                  }              }
Magic Number,Capture.Hook.DX11,DXSprite,C:\repos\spazzarama_Direct3DHook\Capture\Hook\DX11\DXSprite.cs,EndBatch,The following statement contains a magic number: using (EffectPass pass = _spriteTech.GetPassByIndex(0))              {                  pass.Apply(_deviceContext);                  var spritesToDraw = _spriteList.Count;                  int startIndex = 0;                  while (spritesToDraw > 0)                  {                      if (spritesToDraw <= 512)                      {                          DrawBatch(startIndex' spritesToDraw);                          spritesToDraw = 0;                      }                      else                      {                          DrawBatch(startIndex' 512);                          startIndex += 512;                          spritesToDraw -= 512;                      }                  }              }
Magic Number,Capture.Hook.DX11,DXSprite,C:\repos\spazzarama_Direct3DHook\Capture\Hook\DX11\DXSprite.cs,EndBatch,The following statement contains a magic number: using (EffectPass pass = _spriteTech.GetPassByIndex(0))              {                  pass.Apply(_deviceContext);                  var spritesToDraw = _spriteList.Count;                  int startIndex = 0;                  while (spritesToDraw > 0)                  {                      if (spritesToDraw <= 512)                      {                          DrawBatch(startIndex' spritesToDraw);                          spritesToDraw = 0;                      }                      else                      {                          DrawBatch(startIndex' 512);                          startIndex += 512;                          spritesToDraw -= 512;                      }                  }              }
Magic Number,Capture.Hook.DX11,DXSprite,C:\repos\spazzarama_Direct3DHook\Capture\Hook\DX11\DXSprite.cs,DrawBatch,The following statement contains a magic number: unsafe              {                  SpriteVertex* v = (SpriteVertex*)mappedData.DataPointer.ToPointer();                    for (int i = 0; i < spriteCount; ++i)                  {                      Sprite sprite = _spriteList[startSpriteIndex + i];                        SpriteVertex[] quad = new SpriteVertex[4];                        BuildSpriteQuad(sprite' ref quad);                        v[i * 4] = quad[0];                      v[i * 4 + 1] = quad[1];                      v[i * 4 + 2] = quad[2];                      v[i * 4 + 3] = quad[3];                  }              }
Magic Number,Capture.Hook.DX11,DXSprite,C:\repos\spazzarama_Direct3DHook\Capture\Hook\DX11\DXSprite.cs,DrawBatch,The following statement contains a magic number: unsafe              {                  SpriteVertex* v = (SpriteVertex*)mappedData.DataPointer.ToPointer();                    for (int i = 0; i < spriteCount; ++i)                  {                      Sprite sprite = _spriteList[startSpriteIndex + i];                        SpriteVertex[] quad = new SpriteVertex[4];                        BuildSpriteQuad(sprite' ref quad);                        v[i * 4] = quad[0];                      v[i * 4 + 1] = quad[1];                      v[i * 4 + 2] = quad[2];                      v[i * 4 + 3] = quad[3];                  }              }
Magic Number,Capture.Hook.DX11,DXSprite,C:\repos\spazzarama_Direct3DHook\Capture\Hook\DX11\DXSprite.cs,DrawBatch,The following statement contains a magic number: unsafe              {                  SpriteVertex* v = (SpriteVertex*)mappedData.DataPointer.ToPointer();                    for (int i = 0; i < spriteCount; ++i)                  {                      Sprite sprite = _spriteList[startSpriteIndex + i];                        SpriteVertex[] quad = new SpriteVertex[4];                        BuildSpriteQuad(sprite' ref quad);                        v[i * 4] = quad[0];                      v[i * 4 + 1] = quad[1];                      v[i * 4 + 2] = quad[2];                      v[i * 4 + 3] = quad[3];                  }              }
Magic Number,Capture.Hook.DX11,DXSprite,C:\repos\spazzarama_Direct3DHook\Capture\Hook\DX11\DXSprite.cs,DrawBatch,The following statement contains a magic number: unsafe              {                  SpriteVertex* v = (SpriteVertex*)mappedData.DataPointer.ToPointer();                    for (int i = 0; i < spriteCount; ++i)                  {                      Sprite sprite = _spriteList[startSpriteIndex + i];                        SpriteVertex[] quad = new SpriteVertex[4];                        BuildSpriteQuad(sprite' ref quad);                        v[i * 4] = quad[0];                      v[i * 4 + 1] = quad[1];                      v[i * 4 + 2] = quad[2];                      v[i * 4 + 3] = quad[3];                  }              }
Magic Number,Capture.Hook.DX11,DXSprite,C:\repos\spazzarama_Direct3DHook\Capture\Hook\DX11\DXSprite.cs,DrawBatch,The following statement contains a magic number: unsafe              {                  SpriteVertex* v = (SpriteVertex*)mappedData.DataPointer.ToPointer();                    for (int i = 0; i < spriteCount; ++i)                  {                      Sprite sprite = _spriteList[startSpriteIndex + i];                        SpriteVertex[] quad = new SpriteVertex[4];                        BuildSpriteQuad(sprite' ref quad);                        v[i * 4] = quad[0];                      v[i * 4 + 1] = quad[1];                      v[i * 4 + 2] = quad[2];                      v[i * 4 + 3] = quad[3];                  }              }
Magic Number,Capture.Hook.DX11,DXSprite,C:\repos\spazzarama_Direct3DHook\Capture\Hook\DX11\DXSprite.cs,DrawBatch,The following statement contains a magic number: unsafe              {                  SpriteVertex* v = (SpriteVertex*)mappedData.DataPointer.ToPointer();                    for (int i = 0; i < spriteCount; ++i)                  {                      Sprite sprite = _spriteList[startSpriteIndex + i];                        SpriteVertex[] quad = new SpriteVertex[4];                        BuildSpriteQuad(sprite' ref quad);                        v[i * 4] = quad[0];                      v[i * 4 + 1] = quad[1];                      v[i * 4 + 2] = quad[2];                      v[i * 4 + 3] = quad[3];                  }              }
Magic Number,Capture.Hook.DX11,DXSprite,C:\repos\spazzarama_Direct3DHook\Capture\Hook\DX11\DXSprite.cs,DrawBatch,The following statement contains a magic number: unsafe              {                  SpriteVertex* v = (SpriteVertex*)mappedData.DataPointer.ToPointer();                    for (int i = 0; i < spriteCount; ++i)                  {                      Sprite sprite = _spriteList[startSpriteIndex + i];                        SpriteVertex[] quad = new SpriteVertex[4];                        BuildSpriteQuad(sprite' ref quad);                        v[i * 4] = quad[0];                      v[i * 4 + 1] = quad[1];                      v[i * 4 + 2] = quad[2];                      v[i * 4 + 3] = quad[3];                  }              }
Magic Number,Capture.Hook.DX11,DXSprite,C:\repos\spazzarama_Direct3DHook\Capture\Hook\DX11\DXSprite.cs,DrawBatch,The following statement contains a magic number: unsafe              {                  SpriteVertex* v = (SpriteVertex*)mappedData.DataPointer.ToPointer();                    for (int i = 0; i < spriteCount; ++i)                  {                      Sprite sprite = _spriteList[startSpriteIndex + i];                        SpriteVertex[] quad = new SpriteVertex[4];                        BuildSpriteQuad(sprite' ref quad);                        v[i * 4] = quad[0];                      v[i * 4 + 1] = quad[1];                      v[i * 4 + 2] = quad[2];                      v[i * 4 + 3] = quad[3];                  }              }
Magic Number,Capture.Hook.DX11,DXSprite,C:\repos\spazzarama_Direct3DHook\Capture\Hook\DX11\DXSprite.cs,DrawBatch,The following statement contains a magic number: unsafe              {                  SpriteVertex* v = (SpriteVertex*)mappedData.DataPointer.ToPointer();                    for (int i = 0; i < spriteCount; ++i)                  {                      Sprite sprite = _spriteList[startSpriteIndex + i];                        SpriteVertex[] quad = new SpriteVertex[4];                        BuildSpriteQuad(sprite' ref quad);                        v[i * 4] = quad[0];                      v[i * 4 + 1] = quad[1];                      v[i * 4 + 2] = quad[2];                      v[i * 4 + 3] = quad[3];                  }              }
Magic Number,Capture.Hook.DX11,DXSprite,C:\repos\spazzarama_Direct3DHook\Capture\Hook\DX11\DXSprite.cs,DrawBatch,The following statement contains a magic number: _deviceContext.DrawIndexed(spriteCount * 6' 0' 0);
Magic Number,Capture.Hook.DX11,DXSprite,C:\repos\spazzarama_Direct3DHook\Capture\Hook\DX11\DXSprite.cs,BuildSpriteQuad,The following statement contains a magic number: if (v.Length < 4)                  throw new ArgumentException("must have 4 sprite vertices"' "v");
Magic Number,Capture.Hook.DX11,DXSprite,C:\repos\spazzarama_Direct3DHook\Capture\Hook\DX11\DXSprite.cs,BuildSpriteQuad,The following statement contains a magic number: v[2].Pos = PointToNdc(dest.Right' dest.Top' sprite.Z);
Magic Number,Capture.Hook.DX11,DXSprite,C:\repos\spazzarama_Direct3DHook\Capture\Hook\DX11\DXSprite.cs,BuildSpriteQuad,The following statement contains a magic number: v[3].Pos = PointToNdc(dest.Right' dest.Bottom' sprite.Z);
Magic Number,Capture.Hook.DX11,DXSprite,C:\repos\spazzarama_Direct3DHook\Capture\Hook\DX11\DXSprite.cs,BuildSpriteQuad,The following statement contains a magic number: v[2].Tex = new Vector2((float)src.Right / _texWidth' (float)src.Top / _texHeight);
Magic Number,Capture.Hook.DX11,DXSprite,C:\repos\spazzarama_Direct3DHook\Capture\Hook\DX11\DXSprite.cs,BuildSpriteQuad,The following statement contains a magic number: v[3].Tex = new Vector2((float)src.Right / _texWidth' (float)src.Bottom / _texHeight);
Magic Number,Capture.Hook.DX11,DXSprite,C:\repos\spazzarama_Direct3DHook\Capture\Hook\DX11\DXSprite.cs,BuildSpriteQuad,The following statement contains a magic number: v[2].Color = sprite.Color;
Magic Number,Capture.Hook.DX11,DXSprite,C:\repos\spazzarama_Direct3DHook\Capture\Hook\DX11\DXSprite.cs,BuildSpriteQuad,The following statement contains a magic number: v[3].Color = sprite.Color;
Magic Number,Capture.Hook.DX11,DXSprite,C:\repos\spazzarama_Direct3DHook\Capture\Hook\DX11\DXSprite.cs,BuildSpriteQuad,The following statement contains a magic number: float tx = 0.5f * (v[0].Pos.X + v[3].Pos.X);
Magic Number,Capture.Hook.DX11,DXSprite,C:\repos\spazzarama_Direct3DHook\Capture\Hook\DX11\DXSprite.cs,BuildSpriteQuad,The following statement contains a magic number: for (int i = 0; i < 4; ++i)              {                  Vector3 p = v[i].Pos;                  p = Vector3.TransformCoordinate(p' T);                  v[i].Pos = p;              }
Magic Number,Capture.Hook.DX11,ScreenAlignedQuadRenderer,C:\repos\spazzarama_Direct3DHook\Capture\Hook\DX11\ScreenAlignedQuadRenderer.cs,DoRender,The following statement contains a magic number: {                  context.ClearRenderTargetView(RenderTargetView' Color.CornflowerBlue);                                    // Set sampler                  ViewportF[] viewportf = { new ViewportF(0' 0' RenderTarget.Description.Width' RenderTarget.Description.Height' 0' 1) };                  context.Rasterizer.SetViewports(viewportf);                  context.PixelShader.SetSampler(0' (UseLinearSampling ? linearSampleState : pointSamplerState));                    // Set shader resource                  //bool isMultisampledSRV = false;                  if (ShaderResource != null && !ShaderResource.IsDisposed)                  {                      context.PixelShader.SetShaderResource(0' ShaderResource);                        //if (ShaderResource.Description.Dimension == SharpDX.Direct3D.ShaderResourceViewDimension.Texture2DMultisampled)                      //{                      //    isMultisampledSRV = true;                      //}                  }                    // Set pixel shader                  //if (isMultisampledSRV)                  //    context.PixelShader.Set(pixelShaderMS);                  //else                  context.PixelShader.Set(pixelShader);                    // Set vertex shader                  context.VertexShader.Set(vertexShader);                    // Update vertex layout to use                  context.InputAssembler.InputLayout = null;                    // Tell the IA we are using a triangle strip                  context.InputAssembler.PrimitiveTopology = SharpDX.Direct3D.PrimitiveTopology.TriangleStrip;                  // No vertices to pass (note: null as we will use SV_VertexId)                  //context.InputAssembler.SetVertexBuffers(0' vertexBuffer);                    // Set the render target                  context.OutputMerger.SetTargets(RenderTargetView);                    // Draw the 4 vertices that make up the triangle strip                  context.Draw(4' 0);                    // Remove the render target from the pipeline so that we can read from it if necessary                  context.OutputMerger.SetTargets((RenderTargetView)null);                    // Restore previous shader and IA settings                  //context.PixelShader.SetSampler(0' oldSampler);                  //context.PixelShader.Set(oldPixelShader);                  //context.VertexShader.Set(oldVertexShader);                  //context.InputAssembler.InputLayout = oldVertexLayout;                  //context.OutputMerger.SetTargets(oldRenderTarget);              }
Magic Number,Capture.Hook,DX9FormatExtension,C:\repos\spazzarama_Direct3DHook\Capture\Hook\DX9FormatExtension.cs,ToPixelDepth,The following statement contains a magic number: switch (format)              {                  case SharpDX.Direct3D9.Format.A2R10G10B10:                  case SharpDX.Direct3D9.Format.A8R8G8B8:                  case SharpDX.Direct3D9.Format.X8R8G8B8:                      return 32;                  case SharpDX.Direct3D9.Format.R5G6B5:                  case SharpDX.Direct3D9.Format.A1R5G5B5:                  case SharpDX.Direct3D9.Format.X1R5G5B5:                      return 16;                  default:                      return -1;              }
Magic Number,Capture.Hook,DX9FormatExtension,C:\repos\spazzarama_Direct3DHook\Capture\Hook\DX9FormatExtension.cs,ToPixelDepth,The following statement contains a magic number: switch (format)              {                  case SharpDX.Direct3D9.Format.A2R10G10B10:                  case SharpDX.Direct3D9.Format.A8R8G8B8:                  case SharpDX.Direct3D9.Format.X8R8G8B8:                      return 32;                  case SharpDX.Direct3D9.Format.R5G6B5:                  case SharpDX.Direct3D9.Format.A1R5G5B5:                  case SharpDX.Direct3D9.Format.X1R5G5B5:                      return 16;                  default:                      return -1;              }
Magic Number,Capture.Hook,FramesPerSecond,C:\repos\spazzarama_Direct3DHook\Capture\Hook\FramesPerSecond.cs,Frame,The following statement contains a magic number: if (Math.Abs(Environment.TickCount - _lastTickCount) > 1000)              {                  _lastFrameRate = (float)_frames * 1000 / Math.Abs(Environment.TickCount - _lastTickCount);                  _lastTickCount = Environment.TickCount;                  _frames = 0;              }
Magic Number,Capture.Hook,FramesPerSecond,C:\repos\spazzarama_Direct3DHook\Capture\Hook\FramesPerSecond.cs,Frame,The following statement contains a magic number: if (Math.Abs(Environment.TickCount - _lastTickCount) > 1000)              {                  _lastFrameRate = (float)_frames * 1000 / Math.Abs(Environment.TickCount - _lastTickCount);                  _lastTickCount = Environment.TickCount;                  _frames = 0;              }
Magic Number,Capture.Hook,BaseDXHook,C:\repos\spazzarama_Direct3DHook\Capture\Hook\BaseDXHook.cs,CopyStream,The following statement contains a magic number: int bufferSize = 32768;
Magic Number,Capture.Hook,BaseDXHook,C:\repos\spazzarama_Direct3DHook\Capture\Hook\BaseDXHook.cs,ReadFullStream,The following statement contains a magic number: if (stream is MemoryStream)              {                  return ((MemoryStream)stream).ToArray();              }              else              {                  byte[] buffer = new byte[32768];                  using (MemoryStream ms = new MemoryStream())                  {                      while (true)                      {                          int read = stream.Read(buffer' 0' buffer.Length);                          if (read > 0)                              ms.Write(buffer' 0' read);                          if (read < buffer.Length)                          {                              return ms.ToArray();                          }                      }                  }              }
Magic Number,Capture.Hook,BaseDXHook,C:\repos\spazzarama_Direct3DHook\Capture\Hook\BaseDXHook.cs,Dispose,The following statement contains a magic number: if (disposeManagedResources)              {                  try                  {                      Cleanup();                  }                  catch { }                    try                  {                      // Uninstall Hooks                      if (Hooks.Count > 0)                      {                          // First disable the hook (by excluding all threads) and wait long enough to ensure that all hooks are not active                          foreach (var hook in Hooks)                          {                              // Lets ensure that no threads will be intercepted again                              hook.Deactivate();                          }                            System.Threading.Thread.Sleep(100);                            // Now we can dispose of the hooks (which triggers the removal of the hook)                          foreach (var hook in Hooks)                          {                              hook.Dispose();                          }                            Hooks.Clear();                      }                        try                      {                          // Remove the event handlers                          Interface.ScreenshotRequested -= InterfaceEventProxy.ScreenshotRequestedProxyHandler;                          Interface.DisplayText -= InterfaceEventProxy.DisplayTextProxyHandler;                      }                      catch (RemotingException) { } // Ignore remoting exceptions (host process may have been closed)                  }                  catch                  {                  }              }
Magic Number,Capture.Hook,DXGI,C:\repos\spazzarama_Direct3DHook\Capture\Hook\DXGI.cs,CreateSwapChainDescription,The following statement contains a magic number: return new SharpDX.DXGI.SwapChainDescription              {                  BufferCount = 1'                  Flags = SharpDX.DXGI.SwapChainFlags.None'                  IsWindowed = true'                  ModeDescription = new SharpDX.DXGI.ModeDescription(100' 100' new Rational(60' 1)' SharpDX.DXGI.Format.R8G8B8A8_UNorm)'                  OutputHandle = windowHandle'                  SampleDescription = new SharpDX.DXGI.SampleDescription(1' 0)'                  SwapEffect = SharpDX.DXGI.SwapEffect.Discard'                  Usage = SharpDX.DXGI.Usage.RenderTargetOutput              };
Magic Number,Capture.Hook,DXGI,C:\repos\spazzarama_Direct3DHook\Capture\Hook\DXGI.cs,CreateSwapChainDescription,The following statement contains a magic number: return new SharpDX.DXGI.SwapChainDescription              {                  BufferCount = 1'                  Flags = SharpDX.DXGI.SwapChainFlags.None'                  IsWindowed = true'                  ModeDescription = new SharpDX.DXGI.ModeDescription(100' 100' new Rational(60' 1)' SharpDX.DXGI.Format.R8G8B8A8_UNorm)'                  OutputHandle = windowHandle'                  SampleDescription = new SharpDX.DXGI.SampleDescription(1' 0)'                  SwapEffect = SharpDX.DXGI.SwapEffect.Discard'                  Usage = SharpDX.DXGI.Usage.RenderTargetOutput              };
Magic Number,Capture.Hook,DXGI,C:\repos\spazzarama_Direct3DHook\Capture\Hook\DXGI.cs,CreateSwapChainDescription,The following statement contains a magic number: return new SharpDX.DXGI.SwapChainDescription              {                  BufferCount = 1'                  Flags = SharpDX.DXGI.SwapChainFlags.None'                  IsWindowed = true'                  ModeDescription = new SharpDX.DXGI.ModeDescription(100' 100' new Rational(60' 1)' SharpDX.DXGI.Format.R8G8B8A8_UNorm)'                  OutputHandle = windowHandle'                  SampleDescription = new SharpDX.DXGI.SampleDescription(1' 0)'                  SwapEffect = SharpDX.DXGI.SwapEffect.Discard'                  Usage = SharpDX.DXGI.Usage.RenderTargetOutput              };
Magic Number,Capture.Hook,DXHookD3D10,C:\repos\spazzarama_Direct3DHook\Capture\Hook\DXHookD3D10.cs,PresentHook,The following statement contains a magic number: try              {                  #region Screenshot Request                  if (this.Request != null)                  {                      try                      {                          this.DebugMessage("PresentHook: Request Start");                          DateTime startTime = DateTime.Now;                          using (Texture2D texture = Texture2D.FromSwapChain<SharpDX.Direct3D10.Texture2D>(swapChain' 0))                          {                              #region Determine region to capture                              System.Drawing.Rectangle regionToCapture = new System.Drawing.Rectangle(0' 0' texture.Description.Width' texture.Description.Height);                                if (this.Request.RegionToCapture.Width > 0)                              {                                  regionToCapture = this.Request.RegionToCapture;                              }                              #endregion                                var theTexture = texture;                                // If texture is multisampled' then we can use ResolveSubresource to copy it into a non-multisampled texture                              Texture2D textureResolved = null;                              if (texture.Description.SampleDescription.Count > 1)                              {                                  this.DebugMessage("PresentHook: resolving multi-sampled texture");                                  // texture is multi-sampled' lets resolve it down to single sample                                  textureResolved = new Texture2D(texture.Device' new Texture2DDescription()                                  {                                      CpuAccessFlags = CpuAccessFlags.None'                                      Format = texture.Description.Format'                                      Height = texture.Description.Height'                                      Usage = ResourceUsage.Default'                                      Width = texture.Description.Width'                                      ArraySize = 1'                                      SampleDescription = new SharpDX.DXGI.SampleDescription(1' 0)' // Ensure single sample                                      BindFlags = BindFlags.None'                                      MipLevels = 1'                                      OptionFlags = texture.Description.OptionFlags                                  });                                  // Resolve into textureResolved                                  texture.Device.ResolveSubresource(texture' 0' textureResolved' 0' texture.Description.Format);                                    // Make "theTexture" be the resolved texture                                  theTexture = textureResolved;                              }                                // Create destination texture                              Texture2D textureDest = new Texture2D(texture.Device' new Texture2DDescription()                                  {                                      CpuAccessFlags = CpuAccessFlags.None'// CpuAccessFlags.Write | CpuAccessFlags.Read'                                      Format = SharpDX.DXGI.Format.R8G8B8A8_UNorm' // Supports BMP/PNG                                      Height = regionToCapture.Height'                                      Usage = ResourceUsage.Default'// ResourceUsage.Staging'                                      Width = regionToCapture.Width'                                      ArraySize = 1'//texture.Description.ArraySize'                                      SampleDescription = new SharpDX.DXGI.SampleDescription(1' 0)'// texture.Description.SampleDescription'                                      BindFlags = BindFlags.None'                                      MipLevels = 1'//texture.Description.MipLevels'                                      OptionFlags = texture.Description.OptionFlags                                  });                                // Copy the subresource region' we are dealing with a flat 2D texture with no MipMapping' so 0 is the subresource index                              theTexture.Device.CopySubresourceRegion(theTexture' 0' new ResourceRegion()                              {                                  Top = regionToCapture.Top'                                  Bottom = regionToCapture.Bottom'                                  Left = regionToCapture.Left'                                  Right = regionToCapture.Right'                                  Front = 0'                                  Back = 1 // Must be 1 or only black will be copied                              }' textureDest' 0' 0' 0' 0);                                // Note: it would be possible to capture multiple frames and process them in a background thread                                // Copy to memory and send back to host process on a background thread so that we do not cause any delay in the rendering pipeline                              var request = this.Request.Clone(); // this.Request gets set to null' so copy the Request for use in the thread                              ThreadPool.QueueUserWorkItem(delegate                              {                                  //FileStream fs = new FileStream(@"c:\temp\temp.bmp"' FileMode.Create);                                  //Texture2D.ToStream(testSubResourceCopy' ImageFileFormat.Bmp' fs);                                    DateTime startCopyToSystemMemory = DateTime.Now;                                  using (MemoryStream ms = new MemoryStream())                                  {                                      Texture2D.ToStream(textureDest' ImageFileFormat.Bmp' ms);                                      ms.Position = 0;                                      this.DebugMessage("PresentHook: Copy to System Memory time: " + (DateTime.Now - startCopyToSystemMemory).ToString());                                        DateTime startSendResponse = DateTime.Now;                                      ProcessCapture(ms' request);                                      this.DebugMessage("PresentHook: Send response time: " + (DateTime.Now - startSendResponse).ToString());                                  }                                    // Free the textureDest as we no longer need it.                                  textureDest.Dispose();                                  textureDest = null;                                  this.DebugMessage("PresentHook: Full Capture time: " + (DateTime.Now - startTime).ToString());                              });                                                            // Make sure we free up the resolved texture if it was created                              if (textureResolved != null)                              {                                  textureResolved.Dispose();                                  textureResolved = null;                              }                          }                            this.DebugMessage("PresentHook: Copy BackBuffer time: " + (DateTime.Now - startTime).ToString());                          this.DebugMessage("PresentHook: Request End");                      }                      finally                      {                          // Prevent the request from being processed a second time                          this.Request = null;                      }                    }                  #endregion                    #region Example: Draw overlay (after screenshot so we don't capture overlay as well)                  if (this.Config.ShowOverlay)                  {                      using (Texture2D texture = Texture2D.FromSwapChain<SharpDX.Direct3D10.Texture2D>(swapChain' 0))                      {                          if (FPS.GetFPS() >= 1)                          {                              FontDescription fd = new SharpDX.Direct3D10.FontDescription()                              {                                  Height = 16'                                  FaceName = "Arial"'                                  Italic = false'                                  Width = 0'                                  MipLevels = 1'                                  CharacterSet = SharpDX.Direct3D10.FontCharacterSet.Default'                                  OutputPrecision = SharpDX.Direct3D10.FontPrecision.Default'                                  Quality = SharpDX.Direct3D10.FontQuality.Antialiased'                                  PitchAndFamily = FontPitchAndFamily.Default | FontPitchAndFamily.DontCare'                                  Weight = FontWeight.Bold                              };                                // TODO: Font should not be created every frame!                              using (Font font = new Font(texture.Device' fd))                              {                                  DrawText(font' new Vector2(5' 5)' String.Format("{0:N0} fps"' FPS.GetFPS())' new Color4(SharpDX.Color.Red.ToColor3()));                                    if (this.TextDisplay != null && this.TextDisplay.Display)                                  {                                      DrawText(font' new Vector2(5' 25)' this.TextDisplay.Text' new Color4(Color.Red.ToColor3()' (Math.Abs(1.0f - TextDisplay.Remaining))));                                  }                              }                          }                        }                  }                  #endregion              }              catch (Exception e)              {                  // If there is an error we do not want to crash the hooked application' so swallow the exception                  this.DebugMessage("PresentHook: Exeception: " + e.GetType().FullName + ": " + e.Message);              }
Magic Number,Capture.Hook,DXHookD3D10,C:\repos\spazzarama_Direct3DHook\Capture\Hook\DXHookD3D10.cs,PresentHook,The following statement contains a magic number: try              {                  #region Screenshot Request                  if (this.Request != null)                  {                      try                      {                          this.DebugMessage("PresentHook: Request Start");                          DateTime startTime = DateTime.Now;                          using (Texture2D texture = Texture2D.FromSwapChain<SharpDX.Direct3D10.Texture2D>(swapChain' 0))                          {                              #region Determine region to capture                              System.Drawing.Rectangle regionToCapture = new System.Drawing.Rectangle(0' 0' texture.Description.Width' texture.Description.Height);                                if (this.Request.RegionToCapture.Width > 0)                              {                                  regionToCapture = this.Request.RegionToCapture;                              }                              #endregion                                var theTexture = texture;                                // If texture is multisampled' then we can use ResolveSubresource to copy it into a non-multisampled texture                              Texture2D textureResolved = null;                              if (texture.Description.SampleDescription.Count > 1)                              {                                  this.DebugMessage("PresentHook: resolving multi-sampled texture");                                  // texture is multi-sampled' lets resolve it down to single sample                                  textureResolved = new Texture2D(texture.Device' new Texture2DDescription()                                  {                                      CpuAccessFlags = CpuAccessFlags.None'                                      Format = texture.Description.Format'                                      Height = texture.Description.Height'                                      Usage = ResourceUsage.Default'                                      Width = texture.Description.Width'                                      ArraySize = 1'                                      SampleDescription = new SharpDX.DXGI.SampleDescription(1' 0)' // Ensure single sample                                      BindFlags = BindFlags.None'                                      MipLevels = 1'                                      OptionFlags = texture.Description.OptionFlags                                  });                                  // Resolve into textureResolved                                  texture.Device.ResolveSubresource(texture' 0' textureResolved' 0' texture.Description.Format);                                    // Make "theTexture" be the resolved texture                                  theTexture = textureResolved;                              }                                // Create destination texture                              Texture2D textureDest = new Texture2D(texture.Device' new Texture2DDescription()                                  {                                      CpuAccessFlags = CpuAccessFlags.None'// CpuAccessFlags.Write | CpuAccessFlags.Read'                                      Format = SharpDX.DXGI.Format.R8G8B8A8_UNorm' // Supports BMP/PNG                                      Height = regionToCapture.Height'                                      Usage = ResourceUsage.Default'// ResourceUsage.Staging'                                      Width = regionToCapture.Width'                                      ArraySize = 1'//texture.Description.ArraySize'                                      SampleDescription = new SharpDX.DXGI.SampleDescription(1' 0)'// texture.Description.SampleDescription'                                      BindFlags = BindFlags.None'                                      MipLevels = 1'//texture.Description.MipLevels'                                      OptionFlags = texture.Description.OptionFlags                                  });                                // Copy the subresource region' we are dealing with a flat 2D texture with no MipMapping' so 0 is the subresource index                              theTexture.Device.CopySubresourceRegion(theTexture' 0' new ResourceRegion()                              {                                  Top = regionToCapture.Top'                                  Bottom = regionToCapture.Bottom'                                  Left = regionToCapture.Left'                                  Right = regionToCapture.Right'                                  Front = 0'                                  Back = 1 // Must be 1 or only black will be copied                              }' textureDest' 0' 0' 0' 0);                                // Note: it would be possible to capture multiple frames and process them in a background thread                                // Copy to memory and send back to host process on a background thread so that we do not cause any delay in the rendering pipeline                              var request = this.Request.Clone(); // this.Request gets set to null' so copy the Request for use in the thread                              ThreadPool.QueueUserWorkItem(delegate                              {                                  //FileStream fs = new FileStream(@"c:\temp\temp.bmp"' FileMode.Create);                                  //Texture2D.ToStream(testSubResourceCopy' ImageFileFormat.Bmp' fs);                                    DateTime startCopyToSystemMemory = DateTime.Now;                                  using (MemoryStream ms = new MemoryStream())                                  {                                      Texture2D.ToStream(textureDest' ImageFileFormat.Bmp' ms);                                      ms.Position = 0;                                      this.DebugMessage("PresentHook: Copy to System Memory time: " + (DateTime.Now - startCopyToSystemMemory).ToString());                                        DateTime startSendResponse = DateTime.Now;                                      ProcessCapture(ms' request);                                      this.DebugMessage("PresentHook: Send response time: " + (DateTime.Now - startSendResponse).ToString());                                  }                                    // Free the textureDest as we no longer need it.                                  textureDest.Dispose();                                  textureDest = null;                                  this.DebugMessage("PresentHook: Full Capture time: " + (DateTime.Now - startTime).ToString());                              });                                                            // Make sure we free up the resolved texture if it was created                              if (textureResolved != null)                              {                                  textureResolved.Dispose();                                  textureResolved = null;                              }                          }                            this.DebugMessage("PresentHook: Copy BackBuffer time: " + (DateTime.Now - startTime).ToString());                          this.DebugMessage("PresentHook: Request End");                      }                      finally                      {                          // Prevent the request from being processed a second time                          this.Request = null;                      }                    }                  #endregion                    #region Example: Draw overlay (after screenshot so we don't capture overlay as well)                  if (this.Config.ShowOverlay)                  {                      using (Texture2D texture = Texture2D.FromSwapChain<SharpDX.Direct3D10.Texture2D>(swapChain' 0))                      {                          if (FPS.GetFPS() >= 1)                          {                              FontDescription fd = new SharpDX.Direct3D10.FontDescription()                              {                                  Height = 16'                                  FaceName = "Arial"'                                  Italic = false'                                  Width = 0'                                  MipLevels = 1'                                  CharacterSet = SharpDX.Direct3D10.FontCharacterSet.Default'                                  OutputPrecision = SharpDX.Direct3D10.FontPrecision.Default'                                  Quality = SharpDX.Direct3D10.FontQuality.Antialiased'                                  PitchAndFamily = FontPitchAndFamily.Default | FontPitchAndFamily.DontCare'                                  Weight = FontWeight.Bold                              };                                // TODO: Font should not be created every frame!                              using (Font font = new Font(texture.Device' fd))                              {                                  DrawText(font' new Vector2(5' 5)' String.Format("{0:N0} fps"' FPS.GetFPS())' new Color4(SharpDX.Color.Red.ToColor3()));                                    if (this.TextDisplay != null && this.TextDisplay.Display)                                  {                                      DrawText(font' new Vector2(5' 25)' this.TextDisplay.Text' new Color4(Color.Red.ToColor3()' (Math.Abs(1.0f - TextDisplay.Remaining))));                                  }                              }                          }                        }                  }                  #endregion              }              catch (Exception e)              {                  // If there is an error we do not want to crash the hooked application' so swallow the exception                  this.DebugMessage("PresentHook: Exeception: " + e.GetType().FullName + ": " + e.Message);              }
Magic Number,Capture.Hook,DXHookD3D10,C:\repos\spazzarama_Direct3DHook\Capture\Hook\DXHookD3D10.cs,PresentHook,The following statement contains a magic number: try              {                  #region Screenshot Request                  if (this.Request != null)                  {                      try                      {                          this.DebugMessage("PresentHook: Request Start");                          DateTime startTime = DateTime.Now;                          using (Texture2D texture = Texture2D.FromSwapChain<SharpDX.Direct3D10.Texture2D>(swapChain' 0))                          {                              #region Determine region to capture                              System.Drawing.Rectangle regionToCapture = new System.Drawing.Rectangle(0' 0' texture.Description.Width' texture.Description.Height);                                if (this.Request.RegionToCapture.Width > 0)                              {                                  regionToCapture = this.Request.RegionToCapture;                              }                              #endregion                                var theTexture = texture;                                // If texture is multisampled' then we can use ResolveSubresource to copy it into a non-multisampled texture                              Texture2D textureResolved = null;                              if (texture.Description.SampleDescription.Count > 1)                              {                                  this.DebugMessage("PresentHook: resolving multi-sampled texture");                                  // texture is multi-sampled' lets resolve it down to single sample                                  textureResolved = new Texture2D(texture.Device' new Texture2DDescription()                                  {                                      CpuAccessFlags = CpuAccessFlags.None'                                      Format = texture.Description.Format'                                      Height = texture.Description.Height'                                      Usage = ResourceUsage.Default'                                      Width = texture.Description.Width'                                      ArraySize = 1'                                      SampleDescription = new SharpDX.DXGI.SampleDescription(1' 0)' // Ensure single sample                                      BindFlags = BindFlags.None'                                      MipLevels = 1'                                      OptionFlags = texture.Description.OptionFlags                                  });                                  // Resolve into textureResolved                                  texture.Device.ResolveSubresource(texture' 0' textureResolved' 0' texture.Description.Format);                                    // Make "theTexture" be the resolved texture                                  theTexture = textureResolved;                              }                                // Create destination texture                              Texture2D textureDest = new Texture2D(texture.Device' new Texture2DDescription()                                  {                                      CpuAccessFlags = CpuAccessFlags.None'// CpuAccessFlags.Write | CpuAccessFlags.Read'                                      Format = SharpDX.DXGI.Format.R8G8B8A8_UNorm' // Supports BMP/PNG                                      Height = regionToCapture.Height'                                      Usage = ResourceUsage.Default'// ResourceUsage.Staging'                                      Width = regionToCapture.Width'                                      ArraySize = 1'//texture.Description.ArraySize'                                      SampleDescription = new SharpDX.DXGI.SampleDescription(1' 0)'// texture.Description.SampleDescription'                                      BindFlags = BindFlags.None'                                      MipLevels = 1'//texture.Description.MipLevels'                                      OptionFlags = texture.Description.OptionFlags                                  });                                // Copy the subresource region' we are dealing with a flat 2D texture with no MipMapping' so 0 is the subresource index                              theTexture.Device.CopySubresourceRegion(theTexture' 0' new ResourceRegion()                              {                                  Top = regionToCapture.Top'                                  Bottom = regionToCapture.Bottom'                                  Left = regionToCapture.Left'                                  Right = regionToCapture.Right'                                  Front = 0'                                  Back = 1 // Must be 1 or only black will be copied                              }' textureDest' 0' 0' 0' 0);                                // Note: it would be possible to capture multiple frames and process them in a background thread                                // Copy to memory and send back to host process on a background thread so that we do not cause any delay in the rendering pipeline                              var request = this.Request.Clone(); // this.Request gets set to null' so copy the Request for use in the thread                              ThreadPool.QueueUserWorkItem(delegate                              {                                  //FileStream fs = new FileStream(@"c:\temp\temp.bmp"' FileMode.Create);                                  //Texture2D.ToStream(testSubResourceCopy' ImageFileFormat.Bmp' fs);                                    DateTime startCopyToSystemMemory = DateTime.Now;                                  using (MemoryStream ms = new MemoryStream())                                  {                                      Texture2D.ToStream(textureDest' ImageFileFormat.Bmp' ms);                                      ms.Position = 0;                                      this.DebugMessage("PresentHook: Copy to System Memory time: " + (DateTime.Now - startCopyToSystemMemory).ToString());                                        DateTime startSendResponse = DateTime.Now;                                      ProcessCapture(ms' request);                                      this.DebugMessage("PresentHook: Send response time: " + (DateTime.Now - startSendResponse).ToString());                                  }                                    // Free the textureDest as we no longer need it.                                  textureDest.Dispose();                                  textureDest = null;                                  this.DebugMessage("PresentHook: Full Capture time: " + (DateTime.Now - startTime).ToString());                              });                                                            // Make sure we free up the resolved texture if it was created                              if (textureResolved != null)                              {                                  textureResolved.Dispose();                                  textureResolved = null;                              }                          }                            this.DebugMessage("PresentHook: Copy BackBuffer time: " + (DateTime.Now - startTime).ToString());                          this.DebugMessage("PresentHook: Request End");                      }                      finally                      {                          // Prevent the request from being processed a second time                          this.Request = null;                      }                    }                  #endregion                    #region Example: Draw overlay (after screenshot so we don't capture overlay as well)                  if (this.Config.ShowOverlay)                  {                      using (Texture2D texture = Texture2D.FromSwapChain<SharpDX.Direct3D10.Texture2D>(swapChain' 0))                      {                          if (FPS.GetFPS() >= 1)                          {                              FontDescription fd = new SharpDX.Direct3D10.FontDescription()                              {                                  Height = 16'                                  FaceName = "Arial"'                                  Italic = false'                                  Width = 0'                                  MipLevels = 1'                                  CharacterSet = SharpDX.Direct3D10.FontCharacterSet.Default'                                  OutputPrecision = SharpDX.Direct3D10.FontPrecision.Default'                                  Quality = SharpDX.Direct3D10.FontQuality.Antialiased'                                  PitchAndFamily = FontPitchAndFamily.Default | FontPitchAndFamily.DontCare'                                  Weight = FontWeight.Bold                              };                                // TODO: Font should not be created every frame!                              using (Font font = new Font(texture.Device' fd))                              {                                  DrawText(font' new Vector2(5' 5)' String.Format("{0:N0} fps"' FPS.GetFPS())' new Color4(SharpDX.Color.Red.ToColor3()));                                    if (this.TextDisplay != null && this.TextDisplay.Display)                                  {                                      DrawText(font' new Vector2(5' 25)' this.TextDisplay.Text' new Color4(Color.Red.ToColor3()' (Math.Abs(1.0f - TextDisplay.Remaining))));                                  }                              }                          }                        }                  }                  #endregion              }              catch (Exception e)              {                  // If there is an error we do not want to crash the hooked application' so swallow the exception                  this.DebugMessage("PresentHook: Exeception: " + e.GetType().FullName + ": " + e.Message);              }
Magic Number,Capture.Hook,DXHookD3D10,C:\repos\spazzarama_Direct3DHook\Capture\Hook\DXHookD3D10.cs,PresentHook,The following statement contains a magic number: try              {                  #region Screenshot Request                  if (this.Request != null)                  {                      try                      {                          this.DebugMessage("PresentHook: Request Start");                          DateTime startTime = DateTime.Now;                          using (Texture2D texture = Texture2D.FromSwapChain<SharpDX.Direct3D10.Texture2D>(swapChain' 0))                          {                              #region Determine region to capture                              System.Drawing.Rectangle regionToCapture = new System.Drawing.Rectangle(0' 0' texture.Description.Width' texture.Description.Height);                                if (this.Request.RegionToCapture.Width > 0)                              {                                  regionToCapture = this.Request.RegionToCapture;                              }                              #endregion                                var theTexture = texture;                                // If texture is multisampled' then we can use ResolveSubresource to copy it into a non-multisampled texture                              Texture2D textureResolved = null;                              if (texture.Description.SampleDescription.Count > 1)                              {                                  this.DebugMessage("PresentHook: resolving multi-sampled texture");                                  // texture is multi-sampled' lets resolve it down to single sample                                  textureResolved = new Texture2D(texture.Device' new Texture2DDescription()                                  {                                      CpuAccessFlags = CpuAccessFlags.None'                                      Format = texture.Description.Format'                                      Height = texture.Description.Height'                                      Usage = ResourceUsage.Default'                                      Width = texture.Description.Width'                                      ArraySize = 1'                                      SampleDescription = new SharpDX.DXGI.SampleDescription(1' 0)' // Ensure single sample                                      BindFlags = BindFlags.None'                                      MipLevels = 1'                                      OptionFlags = texture.Description.OptionFlags                                  });                                  // Resolve into textureResolved                                  texture.Device.ResolveSubresource(texture' 0' textureResolved' 0' texture.Description.Format);                                    // Make "theTexture" be the resolved texture                                  theTexture = textureResolved;                              }                                // Create destination texture                              Texture2D textureDest = new Texture2D(texture.Device' new Texture2DDescription()                                  {                                      CpuAccessFlags = CpuAccessFlags.None'// CpuAccessFlags.Write | CpuAccessFlags.Read'                                      Format = SharpDX.DXGI.Format.R8G8B8A8_UNorm' // Supports BMP/PNG                                      Height = regionToCapture.Height'                                      Usage = ResourceUsage.Default'// ResourceUsage.Staging'                                      Width = regionToCapture.Width'                                      ArraySize = 1'//texture.Description.ArraySize'                                      SampleDescription = new SharpDX.DXGI.SampleDescription(1' 0)'// texture.Description.SampleDescription'                                      BindFlags = BindFlags.None'                                      MipLevels = 1'//texture.Description.MipLevels'                                      OptionFlags = texture.Description.OptionFlags                                  });                                // Copy the subresource region' we are dealing with a flat 2D texture with no MipMapping' so 0 is the subresource index                              theTexture.Device.CopySubresourceRegion(theTexture' 0' new ResourceRegion()                              {                                  Top = regionToCapture.Top'                                  Bottom = regionToCapture.Bottom'                                  Left = regionToCapture.Left'                                  Right = regionToCapture.Right'                                  Front = 0'                                  Back = 1 // Must be 1 or only black will be copied                              }' textureDest' 0' 0' 0' 0);                                // Note: it would be possible to capture multiple frames and process them in a background thread                                // Copy to memory and send back to host process on a background thread so that we do not cause any delay in the rendering pipeline                              var request = this.Request.Clone(); // this.Request gets set to null' so copy the Request for use in the thread                              ThreadPool.QueueUserWorkItem(delegate                              {                                  //FileStream fs = new FileStream(@"c:\temp\temp.bmp"' FileMode.Create);                                  //Texture2D.ToStream(testSubResourceCopy' ImageFileFormat.Bmp' fs);                                    DateTime startCopyToSystemMemory = DateTime.Now;                                  using (MemoryStream ms = new MemoryStream())                                  {                                      Texture2D.ToStream(textureDest' ImageFileFormat.Bmp' ms);                                      ms.Position = 0;                                      this.DebugMessage("PresentHook: Copy to System Memory time: " + (DateTime.Now - startCopyToSystemMemory).ToString());                                        DateTime startSendResponse = DateTime.Now;                                      ProcessCapture(ms' request);                                      this.DebugMessage("PresentHook: Send response time: " + (DateTime.Now - startSendResponse).ToString());                                  }                                    // Free the textureDest as we no longer need it.                                  textureDest.Dispose();                                  textureDest = null;                                  this.DebugMessage("PresentHook: Full Capture time: " + (DateTime.Now - startTime).ToString());                              });                                                            // Make sure we free up the resolved texture if it was created                              if (textureResolved != null)                              {                                  textureResolved.Dispose();                                  textureResolved = null;                              }                          }                            this.DebugMessage("PresentHook: Copy BackBuffer time: " + (DateTime.Now - startTime).ToString());                          this.DebugMessage("PresentHook: Request End");                      }                      finally                      {                          // Prevent the request from being processed a second time                          this.Request = null;                      }                    }                  #endregion                    #region Example: Draw overlay (after screenshot so we don't capture overlay as well)                  if (this.Config.ShowOverlay)                  {                      using (Texture2D texture = Texture2D.FromSwapChain<SharpDX.Direct3D10.Texture2D>(swapChain' 0))                      {                          if (FPS.GetFPS() >= 1)                          {                              FontDescription fd = new SharpDX.Direct3D10.FontDescription()                              {                                  Height = 16'                                  FaceName = "Arial"'                                  Italic = false'                                  Width = 0'                                  MipLevels = 1'                                  CharacterSet = SharpDX.Direct3D10.FontCharacterSet.Default'                                  OutputPrecision = SharpDX.Direct3D10.FontPrecision.Default'                                  Quality = SharpDX.Direct3D10.FontQuality.Antialiased'                                  PitchAndFamily = FontPitchAndFamily.Default | FontPitchAndFamily.DontCare'                                  Weight = FontWeight.Bold                              };                                // TODO: Font should not be created every frame!                              using (Font font = new Font(texture.Device' fd))                              {                                  DrawText(font' new Vector2(5' 5)' String.Format("{0:N0} fps"' FPS.GetFPS())' new Color4(SharpDX.Color.Red.ToColor3()));                                    if (this.TextDisplay != null && this.TextDisplay.Display)                                  {                                      DrawText(font' new Vector2(5' 25)' this.TextDisplay.Text' new Color4(Color.Red.ToColor3()' (Math.Abs(1.0f - TextDisplay.Remaining))));                                  }                              }                          }                        }                  }                  #endregion              }              catch (Exception e)              {                  // If there is an error we do not want to crash the hooked application' so swallow the exception                  this.DebugMessage("PresentHook: Exeception: " + e.GetType().FullName + ": " + e.Message);              }
Magic Number,Capture.Hook,DXHookD3D10,C:\repos\spazzarama_Direct3DHook\Capture\Hook\DXHookD3D10.cs,PresentHook,The following statement contains a magic number: try              {                  #region Screenshot Request                  if (this.Request != null)                  {                      try                      {                          this.DebugMessage("PresentHook: Request Start");                          DateTime startTime = DateTime.Now;                          using (Texture2D texture = Texture2D.FromSwapChain<SharpDX.Direct3D10.Texture2D>(swapChain' 0))                          {                              #region Determine region to capture                              System.Drawing.Rectangle regionToCapture = new System.Drawing.Rectangle(0' 0' texture.Description.Width' texture.Description.Height);                                if (this.Request.RegionToCapture.Width > 0)                              {                                  regionToCapture = this.Request.RegionToCapture;                              }                              #endregion                                var theTexture = texture;                                // If texture is multisampled' then we can use ResolveSubresource to copy it into a non-multisampled texture                              Texture2D textureResolved = null;                              if (texture.Description.SampleDescription.Count > 1)                              {                                  this.DebugMessage("PresentHook: resolving multi-sampled texture");                                  // texture is multi-sampled' lets resolve it down to single sample                                  textureResolved = new Texture2D(texture.Device' new Texture2DDescription()                                  {                                      CpuAccessFlags = CpuAccessFlags.None'                                      Format = texture.Description.Format'                                      Height = texture.Description.Height'                                      Usage = ResourceUsage.Default'                                      Width = texture.Description.Width'                                      ArraySize = 1'                                      SampleDescription = new SharpDX.DXGI.SampleDescription(1' 0)' // Ensure single sample                                      BindFlags = BindFlags.None'                                      MipLevels = 1'                                      OptionFlags = texture.Description.OptionFlags                                  });                                  // Resolve into textureResolved                                  texture.Device.ResolveSubresource(texture' 0' textureResolved' 0' texture.Description.Format);                                    // Make "theTexture" be the resolved texture                                  theTexture = textureResolved;                              }                                // Create destination texture                              Texture2D textureDest = new Texture2D(texture.Device' new Texture2DDescription()                                  {                                      CpuAccessFlags = CpuAccessFlags.None'// CpuAccessFlags.Write | CpuAccessFlags.Read'                                      Format = SharpDX.DXGI.Format.R8G8B8A8_UNorm' // Supports BMP/PNG                                      Height = regionToCapture.Height'                                      Usage = ResourceUsage.Default'// ResourceUsage.Staging'                                      Width = regionToCapture.Width'                                      ArraySize = 1'//texture.Description.ArraySize'                                      SampleDescription = new SharpDX.DXGI.SampleDescription(1' 0)'// texture.Description.SampleDescription'                                      BindFlags = BindFlags.None'                                      MipLevels = 1'//texture.Description.MipLevels'                                      OptionFlags = texture.Description.OptionFlags                                  });                                // Copy the subresource region' we are dealing with a flat 2D texture with no MipMapping' so 0 is the subresource index                              theTexture.Device.CopySubresourceRegion(theTexture' 0' new ResourceRegion()                              {                                  Top = regionToCapture.Top'                                  Bottom = regionToCapture.Bottom'                                  Left = regionToCapture.Left'                                  Right = regionToCapture.Right'                                  Front = 0'                                  Back = 1 // Must be 1 or only black will be copied                              }' textureDest' 0' 0' 0' 0);                                // Note: it would be possible to capture multiple frames and process them in a background thread                                // Copy to memory and send back to host process on a background thread so that we do not cause any delay in the rendering pipeline                              var request = this.Request.Clone(); // this.Request gets set to null' so copy the Request for use in the thread                              ThreadPool.QueueUserWorkItem(delegate                              {                                  //FileStream fs = new FileStream(@"c:\temp\temp.bmp"' FileMode.Create);                                  //Texture2D.ToStream(testSubResourceCopy' ImageFileFormat.Bmp' fs);                                    DateTime startCopyToSystemMemory = DateTime.Now;                                  using (MemoryStream ms = new MemoryStream())                                  {                                      Texture2D.ToStream(textureDest' ImageFileFormat.Bmp' ms);                                      ms.Position = 0;                                      this.DebugMessage("PresentHook: Copy to System Memory time: " + (DateTime.Now - startCopyToSystemMemory).ToString());                                        DateTime startSendResponse = DateTime.Now;                                      ProcessCapture(ms' request);                                      this.DebugMessage("PresentHook: Send response time: " + (DateTime.Now - startSendResponse).ToString());                                  }                                    // Free the textureDest as we no longer need it.                                  textureDest.Dispose();                                  textureDest = null;                                  this.DebugMessage("PresentHook: Full Capture time: " + (DateTime.Now - startTime).ToString());                              });                                                            // Make sure we free up the resolved texture if it was created                              if (textureResolved != null)                              {                                  textureResolved.Dispose();                                  textureResolved = null;                              }                          }                            this.DebugMessage("PresentHook: Copy BackBuffer time: " + (DateTime.Now - startTime).ToString());                          this.DebugMessage("PresentHook: Request End");                      }                      finally                      {                          // Prevent the request from being processed a second time                          this.Request = null;                      }                    }                  #endregion                    #region Example: Draw overlay (after screenshot so we don't capture overlay as well)                  if (this.Config.ShowOverlay)                  {                      using (Texture2D texture = Texture2D.FromSwapChain<SharpDX.Direct3D10.Texture2D>(swapChain' 0))                      {                          if (FPS.GetFPS() >= 1)                          {                              FontDescription fd = new SharpDX.Direct3D10.FontDescription()                              {                                  Height = 16'                                  FaceName = "Arial"'                                  Italic = false'                                  Width = 0'                                  MipLevels = 1'                                  CharacterSet = SharpDX.Direct3D10.FontCharacterSet.Default'                                  OutputPrecision = SharpDX.Direct3D10.FontPrecision.Default'                                  Quality = SharpDX.Direct3D10.FontQuality.Antialiased'                                  PitchAndFamily = FontPitchAndFamily.Default | FontPitchAndFamily.DontCare'                                  Weight = FontWeight.Bold                              };                                // TODO: Font should not be created every frame!                              using (Font font = new Font(texture.Device' fd))                              {                                  DrawText(font' new Vector2(5' 5)' String.Format("{0:N0} fps"' FPS.GetFPS())' new Color4(SharpDX.Color.Red.ToColor3()));                                    if (this.TextDisplay != null && this.TextDisplay.Display)                                  {                                      DrawText(font' new Vector2(5' 25)' this.TextDisplay.Text' new Color4(Color.Red.ToColor3()' (Math.Abs(1.0f - TextDisplay.Remaining))));                                  }                              }                          }                        }                  }                  #endregion              }              catch (Exception e)              {                  // If there is an error we do not want to crash the hooked application' so swallow the exception                  this.DebugMessage("PresentHook: Exeception: " + e.GetType().FullName + ": " + e.Message);              }
Magic Number,Capture.Hook,DXHookD3D10_1,C:\repos\spazzarama_Direct3DHook\Capture\Hook\DXHookD3D10_1.cs,PresentHook,The following statement contains a magic number: {                  try                  {                      #region Screenshot Request                      if (this.Request != null)                      {                          try                          {                              this.DebugMessage("PresentHook: Request Start");                              DateTime startTime = DateTime.Now;                              using (Texture2D texture = Texture2D.FromSwapChain<SharpDX.Direct3D10.Texture2D>(swapChain' 0))                              {                                  #region Determine region to capture                                  System.Drawing.Rectangle regionToCapture = new System.Drawing.Rectangle(0' 0' texture.Description.Width' texture.Description.Height);                                    if (this.Request.RegionToCapture.Width > 0)                                  {                                      regionToCapture = this.Request.RegionToCapture;                                  }                                  #endregion                                    var theTexture = texture;                                    // If texture is multisampled' then we can use ResolveSubresource to copy it into a non-multisampled texture                                  Texture2D textureResolved = null;                                  if (texture.Description.SampleDescription.Count > 1)                                  {                                      this.DebugMessage("PresentHook: resolving multi-sampled texture");                                      // texture is multi-sampled' lets resolve it down to single sample                                      textureResolved = new Texture2D(texture.Device' new Texture2DDescription()                                      {                                          CpuAccessFlags = CpuAccessFlags.None'                                          Format = texture.Description.Format'                                          Height = texture.Description.Height'                                          Usage = ResourceUsage.Default'                                          Width = texture.Description.Width'                                          ArraySize = 1'                                          SampleDescription = new SharpDX.DXGI.SampleDescription(1' 0)' // Ensure single sample                                          BindFlags = BindFlags.None'                                          MipLevels = 1'                                          OptionFlags = texture.Description.OptionFlags                                      });                                      // Resolve into textureResolved                                      texture.Device.ResolveSubresource(texture' 0' textureResolved' 0' texture.Description.Format);                                        // Make "theTexture" be the resolved texture                                      theTexture = textureResolved;                                  }                                    // Create destination texture                                  Texture2D textureDest = new Texture2D(texture.Device' new Texture2DDescription()                                      {                                          CpuAccessFlags = CpuAccessFlags.None'// CpuAccessFlags.Write | CpuAccessFlags.Read'                                          Format = SharpDX.DXGI.Format.R8G8B8A8_UNorm' // Supports BMP/PNG                                          Height = regionToCapture.Height'                                          Usage = ResourceUsage.Default'// ResourceUsage.Staging'                                          Width = regionToCapture.Width'                                          ArraySize = 1'//texture.Description.ArraySize'                                          SampleDescription = new SharpDX.DXGI.SampleDescription(1' 0)'// texture.Description.SampleDescription'                                          BindFlags = BindFlags.None'                                          MipLevels = 1'//texture.Description.MipLevels'                                          OptionFlags = texture.Description.OptionFlags                                      });                                    // Copy the subresource region' we are dealing with a flat 2D texture with no MipMapping' so 0 is the subresource index                                  theTexture.Device.CopySubresourceRegion(theTexture' 0' new ResourceRegion()                                  {                                      Top = regionToCapture.Top'                                      Bottom = regionToCapture.Bottom'                                      Left = regionToCapture.Left'                                      Right = regionToCapture.Right'                                      Front = 0'                                      Back = 1 // Must be 1 or only black will be copied                                  }' textureDest' 0' 0' 0' 0);                                    // Note: it would be possible to capture multiple frames and process them in a background thread                                    // Copy to memory and send back to host process on a background thread so that we do not cause any delay in the rendering pipeline                                  var request = this.Request.Clone(); // this.Request gets set to null' so copy the Request for use in the thread                                  ThreadPool.QueueUserWorkItem(delegate                                  {                                      //FileStream fs = new FileStream(@"c:\temp\temp.bmp"' FileMode.Create);                                      //Texture2D.ToStream(testSubResourceCopy' ImageFileFormat.Bmp' fs);                                        DateTime startCopyToSystemMemory = DateTime.Now;                                      using (MemoryStream ms = new MemoryStream())                                      {                                          Texture2D.ToStream(textureDest' ImageFileFormat.Bmp' ms);                                          ms.Position = 0;                                          this.DebugMessage("PresentHook: Copy to System Memory time: " + (DateTime.Now - startCopyToSystemMemory).ToString());                                            DateTime startSendResponse = DateTime.Now;                                          ProcessCapture(ms' request);                                          this.DebugMessage("PresentHook: Send response time: " + (DateTime.Now - startSendResponse).ToString());                                      }                                        // Free the textureDest as we no longer need it.                                      textureDest.Dispose();                                      textureDest = null;                                      this.DebugMessage("PresentHook: Full Capture time: " + (DateTime.Now - startTime).ToString());                                  });                                    // Make sure we free up the resolved texture if it was created                                  if (textureResolved != null)                                  {                                      textureResolved.Dispose();                                      textureResolved = null;                                  }                              }                                this.DebugMessage("PresentHook: Copy BackBuffer time: " + (DateTime.Now - startTime).ToString());                              this.DebugMessage("PresentHook: Request End");                          }                          finally                          {                              // Prevent the request from being processed a second time                              this.Request = null;                          }                        }                      #endregion                        #region Example: Draw overlay (after screenshot so we don't capture overlay as well)                      if (this.Config.ShowOverlay)                      {                          using (Texture2D texture = Texture2D.FromSwapChain<SharpDX.Direct3D10.Texture2D>(swapChain' 0))                          {                              if (FPS.GetFPS() >= 1)                              {                                  FontDescription fd = new SharpDX.Direct3D10.FontDescription()                                  {                                      Height = 16'                                      FaceName = "Arial"'                                      Italic = false'                                      Width = 0'                                      MipLevels = 1'                                      CharacterSet = SharpDX.Direct3D10.FontCharacterSet.Default'                                      OutputPrecision = SharpDX.Direct3D10.FontPrecision.Default'                                      Quality = SharpDX.Direct3D10.FontQuality.Antialiased'                                      PitchAndFamily = FontPitchAndFamily.Default | FontPitchAndFamily.DontCare'                                      Weight = FontWeight.Bold                                  };                                    // TODO: do not create font every frame!                                  using (Font font = new Font(texture.Device' fd))                                  {                                      DrawText(font' new Vector2(5' 5)' String.Format("{0:N0} fps"' FPS.GetFPS())' new Color4(Color.Red.ToColor3()));                                        if (this.TextDisplay != null && this.TextDisplay.Display)                                      {                                          DrawText(font' new Vector2(5' 25)' this.TextDisplay.Text' new Color4(Color.Red.ToColor3()' (Math.Abs(1.0f - TextDisplay.Remaining))));                                      }                                  }                              }                          }                      }                      #endregion                  }                  catch (Exception e)                  {                      // If there is an error we do not want to crash the hooked application' so swallow the exception                      this.DebugMessage("PresentHook: Exeception: " + e.GetType().FullName + ": " + e.Message);                  }                    // As always we need to call the original method' note that EasyHook has already repatched the original method                  // so calling it here will not cause an endless recursion to this function                  swapChain.Present(syncInterval' flags);                  return SharpDX.Result.Ok.Code;              }
Magic Number,Capture.Hook,DXHookD3D10_1,C:\repos\spazzarama_Direct3DHook\Capture\Hook\DXHookD3D10_1.cs,PresentHook,The following statement contains a magic number: {                  try                  {                      #region Screenshot Request                      if (this.Request != null)                      {                          try                          {                              this.DebugMessage("PresentHook: Request Start");                              DateTime startTime = DateTime.Now;                              using (Texture2D texture = Texture2D.FromSwapChain<SharpDX.Direct3D10.Texture2D>(swapChain' 0))                              {                                  #region Determine region to capture                                  System.Drawing.Rectangle regionToCapture = new System.Drawing.Rectangle(0' 0' texture.Description.Width' texture.Description.Height);                                    if (this.Request.RegionToCapture.Width > 0)                                  {                                      regionToCapture = this.Request.RegionToCapture;                                  }                                  #endregion                                    var theTexture = texture;                                    // If texture is multisampled' then we can use ResolveSubresource to copy it into a non-multisampled texture                                  Texture2D textureResolved = null;                                  if (texture.Description.SampleDescription.Count > 1)                                  {                                      this.DebugMessage("PresentHook: resolving multi-sampled texture");                                      // texture is multi-sampled' lets resolve it down to single sample                                      textureResolved = new Texture2D(texture.Device' new Texture2DDescription()                                      {                                          CpuAccessFlags = CpuAccessFlags.None'                                          Format = texture.Description.Format'                                          Height = texture.Description.Height'                                          Usage = ResourceUsage.Default'                                          Width = texture.Description.Width'                                          ArraySize = 1'                                          SampleDescription = new SharpDX.DXGI.SampleDescription(1' 0)' // Ensure single sample                                          BindFlags = BindFlags.None'                                          MipLevels = 1'                                          OptionFlags = texture.Description.OptionFlags                                      });                                      // Resolve into textureResolved                                      texture.Device.ResolveSubresource(texture' 0' textureResolved' 0' texture.Description.Format);                                        // Make "theTexture" be the resolved texture                                      theTexture = textureResolved;                                  }                                    // Create destination texture                                  Texture2D textureDest = new Texture2D(texture.Device' new Texture2DDescription()                                      {                                          CpuAccessFlags = CpuAccessFlags.None'// CpuAccessFlags.Write | CpuAccessFlags.Read'                                          Format = SharpDX.DXGI.Format.R8G8B8A8_UNorm' // Supports BMP/PNG                                          Height = regionToCapture.Height'                                          Usage = ResourceUsage.Default'// ResourceUsage.Staging'                                          Width = regionToCapture.Width'                                          ArraySize = 1'//texture.Description.ArraySize'                                          SampleDescription = new SharpDX.DXGI.SampleDescription(1' 0)'// texture.Description.SampleDescription'                                          BindFlags = BindFlags.None'                                          MipLevels = 1'//texture.Description.MipLevels'                                          OptionFlags = texture.Description.OptionFlags                                      });                                    // Copy the subresource region' we are dealing with a flat 2D texture with no MipMapping' so 0 is the subresource index                                  theTexture.Device.CopySubresourceRegion(theTexture' 0' new ResourceRegion()                                  {                                      Top = regionToCapture.Top'                                      Bottom = regionToCapture.Bottom'                                      Left = regionToCapture.Left'                                      Right = regionToCapture.Right'                                      Front = 0'                                      Back = 1 // Must be 1 or only black will be copied                                  }' textureDest' 0' 0' 0' 0);                                    // Note: it would be possible to capture multiple frames and process them in a background thread                                    // Copy to memory and send back to host process on a background thread so that we do not cause any delay in the rendering pipeline                                  var request = this.Request.Clone(); // this.Request gets set to null' so copy the Request for use in the thread                                  ThreadPool.QueueUserWorkItem(delegate                                  {                                      //FileStream fs = new FileStream(@"c:\temp\temp.bmp"' FileMode.Create);                                      //Texture2D.ToStream(testSubResourceCopy' ImageFileFormat.Bmp' fs);                                        DateTime startCopyToSystemMemory = DateTime.Now;                                      using (MemoryStream ms = new MemoryStream())                                      {                                          Texture2D.ToStream(textureDest' ImageFileFormat.Bmp' ms);                                          ms.Position = 0;                                          this.DebugMessage("PresentHook: Copy to System Memory time: " + (DateTime.Now - startCopyToSystemMemory).ToString());                                            DateTime startSendResponse = DateTime.Now;                                          ProcessCapture(ms' request);                                          this.DebugMessage("PresentHook: Send response time: " + (DateTime.Now - startSendResponse).ToString());                                      }                                        // Free the textureDest as we no longer need it.                                      textureDest.Dispose();                                      textureDest = null;                                      this.DebugMessage("PresentHook: Full Capture time: " + (DateTime.Now - startTime).ToString());                                  });                                    // Make sure we free up the resolved texture if it was created                                  if (textureResolved != null)                                  {                                      textureResolved.Dispose();                                      textureResolved = null;                                  }                              }                                this.DebugMessage("PresentHook: Copy BackBuffer time: " + (DateTime.Now - startTime).ToString());                              this.DebugMessage("PresentHook: Request End");                          }                          finally                          {                              // Prevent the request from being processed a second time                              this.Request = null;                          }                        }                      #endregion                        #region Example: Draw overlay (after screenshot so we don't capture overlay as well)                      if (this.Config.ShowOverlay)                      {                          using (Texture2D texture = Texture2D.FromSwapChain<SharpDX.Direct3D10.Texture2D>(swapChain' 0))                          {                              if (FPS.GetFPS() >= 1)                              {                                  FontDescription fd = new SharpDX.Direct3D10.FontDescription()                                  {                                      Height = 16'                                      FaceName = "Arial"'                                      Italic = false'                                      Width = 0'                                      MipLevels = 1'                                      CharacterSet = SharpDX.Direct3D10.FontCharacterSet.Default'                                      OutputPrecision = SharpDX.Direct3D10.FontPrecision.Default'                                      Quality = SharpDX.Direct3D10.FontQuality.Antialiased'                                      PitchAndFamily = FontPitchAndFamily.Default | FontPitchAndFamily.DontCare'                                      Weight = FontWeight.Bold                                  };                                    // TODO: do not create font every frame!                                  using (Font font = new Font(texture.Device' fd))                                  {                                      DrawText(font' new Vector2(5' 5)' String.Format("{0:N0} fps"' FPS.GetFPS())' new Color4(Color.Red.ToColor3()));                                        if (this.TextDisplay != null && this.TextDisplay.Display)                                      {                                          DrawText(font' new Vector2(5' 25)' this.TextDisplay.Text' new Color4(Color.Red.ToColor3()' (Math.Abs(1.0f - TextDisplay.Remaining))));                                      }                                  }                              }                          }                      }                      #endregion                  }                  catch (Exception e)                  {                      // If there is an error we do not want to crash the hooked application' so swallow the exception                      this.DebugMessage("PresentHook: Exeception: " + e.GetType().FullName + ": " + e.Message);                  }                    // As always we need to call the original method' note that EasyHook has already repatched the original method                  // so calling it here will not cause an endless recursion to this function                  swapChain.Present(syncInterval' flags);                  return SharpDX.Result.Ok.Code;              }
Magic Number,Capture.Hook,DXHookD3D10_1,C:\repos\spazzarama_Direct3DHook\Capture\Hook\DXHookD3D10_1.cs,PresentHook,The following statement contains a magic number: {                  try                  {                      #region Screenshot Request                      if (this.Request != null)                      {                          try                          {                              this.DebugMessage("PresentHook: Request Start");                              DateTime startTime = DateTime.Now;                              using (Texture2D texture = Texture2D.FromSwapChain<SharpDX.Direct3D10.Texture2D>(swapChain' 0))                              {                                  #region Determine region to capture                                  System.Drawing.Rectangle regionToCapture = new System.Drawing.Rectangle(0' 0' texture.Description.Width' texture.Description.Height);                                    if (this.Request.RegionToCapture.Width > 0)                                  {                                      regionToCapture = this.Request.RegionToCapture;                                  }                                  #endregion                                    var theTexture = texture;                                    // If texture is multisampled' then we can use ResolveSubresource to copy it into a non-multisampled texture                                  Texture2D textureResolved = null;                                  if (texture.Description.SampleDescription.Count > 1)                                  {                                      this.DebugMessage("PresentHook: resolving multi-sampled texture");                                      // texture is multi-sampled' lets resolve it down to single sample                                      textureResolved = new Texture2D(texture.Device' new Texture2DDescription()                                      {                                          CpuAccessFlags = CpuAccessFlags.None'                                          Format = texture.Description.Format'                                          Height = texture.Description.Height'                                          Usage = ResourceUsage.Default'                                          Width = texture.Description.Width'                                          ArraySize = 1'                                          SampleDescription = new SharpDX.DXGI.SampleDescription(1' 0)' // Ensure single sample                                          BindFlags = BindFlags.None'                                          MipLevels = 1'                                          OptionFlags = texture.Description.OptionFlags                                      });                                      // Resolve into textureResolved                                      texture.Device.ResolveSubresource(texture' 0' textureResolved' 0' texture.Description.Format);                                        // Make "theTexture" be the resolved texture                                      theTexture = textureResolved;                                  }                                    // Create destination texture                                  Texture2D textureDest = new Texture2D(texture.Device' new Texture2DDescription()                                      {                                          CpuAccessFlags = CpuAccessFlags.None'// CpuAccessFlags.Write | CpuAccessFlags.Read'                                          Format = SharpDX.DXGI.Format.R8G8B8A8_UNorm' // Supports BMP/PNG                                          Height = regionToCapture.Height'                                          Usage = ResourceUsage.Default'// ResourceUsage.Staging'                                          Width = regionToCapture.Width'                                          ArraySize = 1'//texture.Description.ArraySize'                                          SampleDescription = new SharpDX.DXGI.SampleDescription(1' 0)'// texture.Description.SampleDescription'                                          BindFlags = BindFlags.None'                                          MipLevels = 1'//texture.Description.MipLevels'                                          OptionFlags = texture.Description.OptionFlags                                      });                                    // Copy the subresource region' we are dealing with a flat 2D texture with no MipMapping' so 0 is the subresource index                                  theTexture.Device.CopySubresourceRegion(theTexture' 0' new ResourceRegion()                                  {                                      Top = regionToCapture.Top'                                      Bottom = regionToCapture.Bottom'                                      Left = regionToCapture.Left'                                      Right = regionToCapture.Right'                                      Front = 0'                                      Back = 1 // Must be 1 or only black will be copied                                  }' textureDest' 0' 0' 0' 0);                                    // Note: it would be possible to capture multiple frames and process them in a background thread                                    // Copy to memory and send back to host process on a background thread so that we do not cause any delay in the rendering pipeline                                  var request = this.Request.Clone(); // this.Request gets set to null' so copy the Request for use in the thread                                  ThreadPool.QueueUserWorkItem(delegate                                  {                                      //FileStream fs = new FileStream(@"c:\temp\temp.bmp"' FileMode.Create);                                      //Texture2D.ToStream(testSubResourceCopy' ImageFileFormat.Bmp' fs);                                        DateTime startCopyToSystemMemory = DateTime.Now;                                      using (MemoryStream ms = new MemoryStream())                                      {                                          Texture2D.ToStream(textureDest' ImageFileFormat.Bmp' ms);                                          ms.Position = 0;                                          this.DebugMessage("PresentHook: Copy to System Memory time: " + (DateTime.Now - startCopyToSystemMemory).ToString());                                            DateTime startSendResponse = DateTime.Now;                                          ProcessCapture(ms' request);                                          this.DebugMessage("PresentHook: Send response time: " + (DateTime.Now - startSendResponse).ToString());                                      }                                        // Free the textureDest as we no longer need it.                                      textureDest.Dispose();                                      textureDest = null;                                      this.DebugMessage("PresentHook: Full Capture time: " + (DateTime.Now - startTime).ToString());                                  });                                    // Make sure we free up the resolved texture if it was created                                  if (textureResolved != null)                                  {                                      textureResolved.Dispose();                                      textureResolved = null;                                  }                              }                                this.DebugMessage("PresentHook: Copy BackBuffer time: " + (DateTime.Now - startTime).ToString());                              this.DebugMessage("PresentHook: Request End");                          }                          finally                          {                              // Prevent the request from being processed a second time                              this.Request = null;                          }                        }                      #endregion                        #region Example: Draw overlay (after screenshot so we don't capture overlay as well)                      if (this.Config.ShowOverlay)                      {                          using (Texture2D texture = Texture2D.FromSwapChain<SharpDX.Direct3D10.Texture2D>(swapChain' 0))                          {                              if (FPS.GetFPS() >= 1)                              {                                  FontDescription fd = new SharpDX.Direct3D10.FontDescription()                                  {                                      Height = 16'                                      FaceName = "Arial"'                                      Italic = false'                                      Width = 0'                                      MipLevels = 1'                                      CharacterSet = SharpDX.Direct3D10.FontCharacterSet.Default'                                      OutputPrecision = SharpDX.Direct3D10.FontPrecision.Default'                                      Quality = SharpDX.Direct3D10.FontQuality.Antialiased'                                      PitchAndFamily = FontPitchAndFamily.Default | FontPitchAndFamily.DontCare'                                      Weight = FontWeight.Bold                                  };                                    // TODO: do not create font every frame!                                  using (Font font = new Font(texture.Device' fd))                                  {                                      DrawText(font' new Vector2(5' 5)' String.Format("{0:N0} fps"' FPS.GetFPS())' new Color4(Color.Red.ToColor3()));                                        if (this.TextDisplay != null && this.TextDisplay.Display)                                      {                                          DrawText(font' new Vector2(5' 25)' this.TextDisplay.Text' new Color4(Color.Red.ToColor3()' (Math.Abs(1.0f - TextDisplay.Remaining))));                                      }                                  }                              }                          }                      }                      #endregion                  }                  catch (Exception e)                  {                      // If there is an error we do not want to crash the hooked application' so swallow the exception                      this.DebugMessage("PresentHook: Exeception: " + e.GetType().FullName + ": " + e.Message);                  }                    // As always we need to call the original method' note that EasyHook has already repatched the original method                  // so calling it here will not cause an endless recursion to this function                  swapChain.Present(syncInterval' flags);                  return SharpDX.Result.Ok.Code;              }
Magic Number,Capture.Hook,DXHookD3D10_1,C:\repos\spazzarama_Direct3DHook\Capture\Hook\DXHookD3D10_1.cs,PresentHook,The following statement contains a magic number: {                  try                  {                      #region Screenshot Request                      if (this.Request != null)                      {                          try                          {                              this.DebugMessage("PresentHook: Request Start");                              DateTime startTime = DateTime.Now;                              using (Texture2D texture = Texture2D.FromSwapChain<SharpDX.Direct3D10.Texture2D>(swapChain' 0))                              {                                  #region Determine region to capture                                  System.Drawing.Rectangle regionToCapture = new System.Drawing.Rectangle(0' 0' texture.Description.Width' texture.Description.Height);                                    if (this.Request.RegionToCapture.Width > 0)                                  {                                      regionToCapture = this.Request.RegionToCapture;                                  }                                  #endregion                                    var theTexture = texture;                                    // If texture is multisampled' then we can use ResolveSubresource to copy it into a non-multisampled texture                                  Texture2D textureResolved = null;                                  if (texture.Description.SampleDescription.Count > 1)                                  {                                      this.DebugMessage("PresentHook: resolving multi-sampled texture");                                      // texture is multi-sampled' lets resolve it down to single sample                                      textureResolved = new Texture2D(texture.Device' new Texture2DDescription()                                      {                                          CpuAccessFlags = CpuAccessFlags.None'                                          Format = texture.Description.Format'                                          Height = texture.Description.Height'                                          Usage = ResourceUsage.Default'                                          Width = texture.Description.Width'                                          ArraySize = 1'                                          SampleDescription = new SharpDX.DXGI.SampleDescription(1' 0)' // Ensure single sample                                          BindFlags = BindFlags.None'                                          MipLevels = 1'                                          OptionFlags = texture.Description.OptionFlags                                      });                                      // Resolve into textureResolved                                      texture.Device.ResolveSubresource(texture' 0' textureResolved' 0' texture.Description.Format);                                        // Make "theTexture" be the resolved texture                                      theTexture = textureResolved;                                  }                                    // Create destination texture                                  Texture2D textureDest = new Texture2D(texture.Device' new Texture2DDescription()                                      {                                          CpuAccessFlags = CpuAccessFlags.None'// CpuAccessFlags.Write | CpuAccessFlags.Read'                                          Format = SharpDX.DXGI.Format.R8G8B8A8_UNorm' // Supports BMP/PNG                                          Height = regionToCapture.Height'                                          Usage = ResourceUsage.Default'// ResourceUsage.Staging'                                          Width = regionToCapture.Width'                                          ArraySize = 1'//texture.Description.ArraySize'                                          SampleDescription = new SharpDX.DXGI.SampleDescription(1' 0)'// texture.Description.SampleDescription'                                          BindFlags = BindFlags.None'                                          MipLevels = 1'//texture.Description.MipLevels'                                          OptionFlags = texture.Description.OptionFlags                                      });                                    // Copy the subresource region' we are dealing with a flat 2D texture with no MipMapping' so 0 is the subresource index                                  theTexture.Device.CopySubresourceRegion(theTexture' 0' new ResourceRegion()                                  {                                      Top = regionToCapture.Top'                                      Bottom = regionToCapture.Bottom'                                      Left = regionToCapture.Left'                                      Right = regionToCapture.Right'                                      Front = 0'                                      Back = 1 // Must be 1 or only black will be copied                                  }' textureDest' 0' 0' 0' 0);                                    // Note: it would be possible to capture multiple frames and process them in a background thread                                    // Copy to memory and send back to host process on a background thread so that we do not cause any delay in the rendering pipeline                                  var request = this.Request.Clone(); // this.Request gets set to null' so copy the Request for use in the thread                                  ThreadPool.QueueUserWorkItem(delegate                                  {                                      //FileStream fs = new FileStream(@"c:\temp\temp.bmp"' FileMode.Create);                                      //Texture2D.ToStream(testSubResourceCopy' ImageFileFormat.Bmp' fs);                                        DateTime startCopyToSystemMemory = DateTime.Now;                                      using (MemoryStream ms = new MemoryStream())                                      {                                          Texture2D.ToStream(textureDest' ImageFileFormat.Bmp' ms);                                          ms.Position = 0;                                          this.DebugMessage("PresentHook: Copy to System Memory time: " + (DateTime.Now - startCopyToSystemMemory).ToString());                                            DateTime startSendResponse = DateTime.Now;                                          ProcessCapture(ms' request);                                          this.DebugMessage("PresentHook: Send response time: " + (DateTime.Now - startSendResponse).ToString());                                      }                                        // Free the textureDest as we no longer need it.                                      textureDest.Dispose();                                      textureDest = null;                                      this.DebugMessage("PresentHook: Full Capture time: " + (DateTime.Now - startTime).ToString());                                  });                                    // Make sure we free up the resolved texture if it was created                                  if (textureResolved != null)                                  {                                      textureResolved.Dispose();                                      textureResolved = null;                                  }                              }                                this.DebugMessage("PresentHook: Copy BackBuffer time: " + (DateTime.Now - startTime).ToString());                              this.DebugMessage("PresentHook: Request End");                          }                          finally                          {                              // Prevent the request from being processed a second time                              this.Request = null;                          }                        }                      #endregion                        #region Example: Draw overlay (after screenshot so we don't capture overlay as well)                      if (this.Config.ShowOverlay)                      {                          using (Texture2D texture = Texture2D.FromSwapChain<SharpDX.Direct3D10.Texture2D>(swapChain' 0))                          {                              if (FPS.GetFPS() >= 1)                              {                                  FontDescription fd = new SharpDX.Direct3D10.FontDescription()                                  {                                      Height = 16'                                      FaceName = "Arial"'                                      Italic = false'                                      Width = 0'                                      MipLevels = 1'                                      CharacterSet = SharpDX.Direct3D10.FontCharacterSet.Default'                                      OutputPrecision = SharpDX.Direct3D10.FontPrecision.Default'                                      Quality = SharpDX.Direct3D10.FontQuality.Antialiased'                                      PitchAndFamily = FontPitchAndFamily.Default | FontPitchAndFamily.DontCare'                                      Weight = FontWeight.Bold                                  };                                    // TODO: do not create font every frame!                                  using (Font font = new Font(texture.Device' fd))                                  {                                      DrawText(font' new Vector2(5' 5)' String.Format("{0:N0} fps"' FPS.GetFPS())' new Color4(Color.Red.ToColor3()));                                        if (this.TextDisplay != null && this.TextDisplay.Display)                                      {                                          DrawText(font' new Vector2(5' 25)' this.TextDisplay.Text' new Color4(Color.Red.ToColor3()' (Math.Abs(1.0f - TextDisplay.Remaining))));                                      }                                  }                              }                          }                      }                      #endregion                  }                  catch (Exception e)                  {                      // If there is an error we do not want to crash the hooked application' so swallow the exception                      this.DebugMessage("PresentHook: Exeception: " + e.GetType().FullName + ": " + e.Message);                  }                    // As always we need to call the original method' note that EasyHook has already repatched the original method                  // so calling it here will not cause an endless recursion to this function                  swapChain.Present(syncInterval' flags);                  return SharpDX.Result.Ok.Code;              }
Magic Number,Capture.Hook,DXHookD3D10_1,C:\repos\spazzarama_Direct3DHook\Capture\Hook\DXHookD3D10_1.cs,PresentHook,The following statement contains a magic number: {                  try                  {                      #region Screenshot Request                      if (this.Request != null)                      {                          try                          {                              this.DebugMessage("PresentHook: Request Start");                              DateTime startTime = DateTime.Now;                              using (Texture2D texture = Texture2D.FromSwapChain<SharpDX.Direct3D10.Texture2D>(swapChain' 0))                              {                                  #region Determine region to capture                                  System.Drawing.Rectangle regionToCapture = new System.Drawing.Rectangle(0' 0' texture.Description.Width' texture.Description.Height);                                    if (this.Request.RegionToCapture.Width > 0)                                  {                                      regionToCapture = this.Request.RegionToCapture;                                  }                                  #endregion                                    var theTexture = texture;                                    // If texture is multisampled' then we can use ResolveSubresource to copy it into a non-multisampled texture                                  Texture2D textureResolved = null;                                  if (texture.Description.SampleDescription.Count > 1)                                  {                                      this.DebugMessage("PresentHook: resolving multi-sampled texture");                                      // texture is multi-sampled' lets resolve it down to single sample                                      textureResolved = new Texture2D(texture.Device' new Texture2DDescription()                                      {                                          CpuAccessFlags = CpuAccessFlags.None'                                          Format = texture.Description.Format'                                          Height = texture.Description.Height'                                          Usage = ResourceUsage.Default'                                          Width = texture.Description.Width'                                          ArraySize = 1'                                          SampleDescription = new SharpDX.DXGI.SampleDescription(1' 0)' // Ensure single sample                                          BindFlags = BindFlags.None'                                          MipLevels = 1'                                          OptionFlags = texture.Description.OptionFlags                                      });                                      // Resolve into textureResolved                                      texture.Device.ResolveSubresource(texture' 0' textureResolved' 0' texture.Description.Format);                                        // Make "theTexture" be the resolved texture                                      theTexture = textureResolved;                                  }                                    // Create destination texture                                  Texture2D textureDest = new Texture2D(texture.Device' new Texture2DDescription()                                      {                                          CpuAccessFlags = CpuAccessFlags.None'// CpuAccessFlags.Write | CpuAccessFlags.Read'                                          Format = SharpDX.DXGI.Format.R8G8B8A8_UNorm' // Supports BMP/PNG                                          Height = regionToCapture.Height'                                          Usage = ResourceUsage.Default'// ResourceUsage.Staging'                                          Width = regionToCapture.Width'                                          ArraySize = 1'//texture.Description.ArraySize'                                          SampleDescription = new SharpDX.DXGI.SampleDescription(1' 0)'// texture.Description.SampleDescription'                                          BindFlags = BindFlags.None'                                          MipLevels = 1'//texture.Description.MipLevels'                                          OptionFlags = texture.Description.OptionFlags                                      });                                    // Copy the subresource region' we are dealing with a flat 2D texture with no MipMapping' so 0 is the subresource index                                  theTexture.Device.CopySubresourceRegion(theTexture' 0' new ResourceRegion()                                  {                                      Top = regionToCapture.Top'                                      Bottom = regionToCapture.Bottom'                                      Left = regionToCapture.Left'                                      Right = regionToCapture.Right'                                      Front = 0'                                      Back = 1 // Must be 1 or only black will be copied                                  }' textureDest' 0' 0' 0' 0);                                    // Note: it would be possible to capture multiple frames and process them in a background thread                                    // Copy to memory and send back to host process on a background thread so that we do not cause any delay in the rendering pipeline                                  var request = this.Request.Clone(); // this.Request gets set to null' so copy the Request for use in the thread                                  ThreadPool.QueueUserWorkItem(delegate                                  {                                      //FileStream fs = new FileStream(@"c:\temp\temp.bmp"' FileMode.Create);                                      //Texture2D.ToStream(testSubResourceCopy' ImageFileFormat.Bmp' fs);                                        DateTime startCopyToSystemMemory = DateTime.Now;                                      using (MemoryStream ms = new MemoryStream())                                      {                                          Texture2D.ToStream(textureDest' ImageFileFormat.Bmp' ms);                                          ms.Position = 0;                                          this.DebugMessage("PresentHook: Copy to System Memory time: " + (DateTime.Now - startCopyToSystemMemory).ToString());                                            DateTime startSendResponse = DateTime.Now;                                          ProcessCapture(ms' request);                                          this.DebugMessage("PresentHook: Send response time: " + (DateTime.Now - startSendResponse).ToString());                                      }                                        // Free the textureDest as we no longer need it.                                      textureDest.Dispose();                                      textureDest = null;                                      this.DebugMessage("PresentHook: Full Capture time: " + (DateTime.Now - startTime).ToString());                                  });                                    // Make sure we free up the resolved texture if it was created                                  if (textureResolved != null)                                  {                                      textureResolved.Dispose();                                      textureResolved = null;                                  }                              }                                this.DebugMessage("PresentHook: Copy BackBuffer time: " + (DateTime.Now - startTime).ToString());                              this.DebugMessage("PresentHook: Request End");                          }                          finally                          {                              // Prevent the request from being processed a second time                              this.Request = null;                          }                        }                      #endregion                        #region Example: Draw overlay (after screenshot so we don't capture overlay as well)                      if (this.Config.ShowOverlay)                      {                          using (Texture2D texture = Texture2D.FromSwapChain<SharpDX.Direct3D10.Texture2D>(swapChain' 0))                          {                              if (FPS.GetFPS() >= 1)                              {                                  FontDescription fd = new SharpDX.Direct3D10.FontDescription()                                  {                                      Height = 16'                                      FaceName = "Arial"'                                      Italic = false'                                      Width = 0'                                      MipLevels = 1'                                      CharacterSet = SharpDX.Direct3D10.FontCharacterSet.Default'                                      OutputPrecision = SharpDX.Direct3D10.FontPrecision.Default'                                      Quality = SharpDX.Direct3D10.FontQuality.Antialiased'                                      PitchAndFamily = FontPitchAndFamily.Default | FontPitchAndFamily.DontCare'                                      Weight = FontWeight.Bold                                  };                                    // TODO: do not create font every frame!                                  using (Font font = new Font(texture.Device' fd))                                  {                                      DrawText(font' new Vector2(5' 5)' String.Format("{0:N0} fps"' FPS.GetFPS())' new Color4(Color.Red.ToColor3()));                                        if (this.TextDisplay != null && this.TextDisplay.Display)                                      {                                          DrawText(font' new Vector2(5' 25)' this.TextDisplay.Text' new Color4(Color.Red.ToColor3()' (Math.Abs(1.0f - TextDisplay.Remaining))));                                      }                                  }                              }                          }                      }                      #endregion                  }                  catch (Exception e)                  {                      // If there is an error we do not want to crash the hooked application' so swallow the exception                      this.DebugMessage("PresentHook: Exeception: " + e.GetType().FullName + ": " + e.Message);                  }                    // As always we need to call the original method' note that EasyHook has already repatched the original method                  // so calling it here will not cause an endless recursion to this function                  swapChain.Present(syncInterval' flags);                  return SharpDX.Result.Ok.Code;              }
Magic Number,Capture.Hook,DXHookD3D11,C:\repos\spazzarama_Direct3DHook\Capture\Hook\DXHookD3D11.cs,PresentHook,The following statement contains a magic number: try              {                  #region Screenshot Request                  if (this.Request != null)                  {                      this.DebugMessage("PresentHook: Request Start");                      DateTime startTime = DateTime.Now;                      using (Texture2D currentRT = Texture2D.FromSwapChain<Texture2D>(swapChain' 0))                      {                          #region Determine region to capture                          Rectangle captureRegion = new Rectangle(0' 0' currentRT.Description.Width' currentRT.Description.Height);                            if (this.Request.RegionToCapture.Width > 0)                          {                              captureRegion = new Rectangle(this.Request.RegionToCapture.Left' this.Request.RegionToCapture.Top' this.Request.RegionToCapture.Right' this.Request.RegionToCapture.Bottom);                          }                          else if (this.Request.Resize.HasValue)                          {                              captureRegion = new Rectangle(0' 0' this.Request.Resize.Value.Width' this.Request.Resize.Value.Height);                          }                          #endregion                            // Create / Recreate resources as necessary                          EnsureResources(currentRT.Device' currentRT.Description' captureRegion' Request);                            Texture2D sourceTexture = null;                            // If texture is multisampled' then we can use ResolveSubresource to copy it into a non-multisampled texture                          if (currentRT.Description.SampleDescription.Count > 1 || Request.Resize.HasValue)                          {                              if (Request.Resize.HasValue)                                  this.DebugMessage("PresentHook: resizing texture");                              else                                  this.DebugMessage("PresentHook: resolving multi-sampled texture");                                // Resolve into _resolvedRT                              if (_resolvedRTKeyedMutex != null)                                  _resolvedRTKeyedMutex.Acquire(0' int.MaxValue);                              currentRT.Device.ImmediateContext.ResolveSubresource(currentRT' 0' _resolvedRT' 0' _resolvedRT.Description.Format);                              if (_resolvedRTKeyedMutex != null)                                  _resolvedRTKeyedMutex.Release(1);                                if (Request.Resize.HasValue)                              {                                  lock(_lock)                                  {                                      if (_resolvedRTKeyedMutex_Dev2 != null)                                          _resolvedRTKeyedMutex_Dev2.Acquire(1' int.MaxValue);                                      _saQuad.ShaderResource = _resolvedSharedSRV;                                      _saQuad.RenderTargetView = _resizedRTV;                                      _saQuad.RenderTarget = _resizedRT;                                      _saQuad.Render();                                      if (_resolvedRTKeyedMutex_Dev2 != null)                                          _resolvedRTKeyedMutex_Dev2.Release(0);                                  }                                    // set sourceTexture to the resized RT                                  sourceTexture = _resizedRT;                              }                              else                              {                                  // Make sourceTexture be the resolved texture                                  sourceTexture = _resolvedRTShared;                              }                          }                          else                          {                              // Copy the resource into the shared texture                              if (_resolvedRTKeyedMutex != null) _resolvedRTKeyedMutex.Acquire(0' int.MaxValue);                              currentRT.Device.ImmediateContext.CopySubresourceRegion(currentRT' 0' null' _resolvedRT' 0);                              if (_resolvedRTKeyedMutex != null) _resolvedRTKeyedMutex.Release(1);                              sourceTexture = _resolvedRTShared;                          }                            // Copy to memory and send back to host process on a background thread so that we do not cause any delay in the rendering pipeline                          _requestCopy = this.Request.Clone(); // this.Request gets set to null' so copy the Request for use in the thread                            // Prevent the request from being processed a second time                          this.Request = null;                            bool acquireLock = sourceTexture == _resolvedRTShared;                            ThreadPool.QueueUserWorkItem(new WaitCallback((o) =>                          {                              // Acquire lock on second device                              if (acquireLock && _resolvedRTKeyedMutex_Dev2 != null)                                  _resolvedRTKeyedMutex_Dev2.Acquire(1' int.MaxValue);                                lock (_lock)                              {                                  // Copy the subresource region' we are dealing with a flat 2D texture with no MipMapping' so 0 is the subresource index                                  sourceTexture.Device.ImmediateContext.CopySubresourceRegion(sourceTexture' 0' new ResourceRegion()                                  {                                      Top = captureRegion.Top'                                      Bottom = captureRegion.Bottom'                                      Left = captureRegion.Left'                                      Right = captureRegion.Right'                                      Front = 0'                                      Back = 1 // Must be 1 or only black will be copied                                  }' _finalRT' 0' 0' 0' 0);                                    // Release lock upon shared surface on second device                                  if (acquireLock && _resolvedRTKeyedMutex_Dev2 != null)                                      _resolvedRTKeyedMutex_Dev2.Release(0);                                    _finalRT.Device.ImmediateContext.End(_query);                                  _queryIssued = true;                                  while (!_finalRT.Device.ImmediateContext.GetData(_query).ReadBoolean())                                  {                                      // Spin (usually no spin takes place)                                  }                                    DateTime startCopyToSystemMemory = DateTime.Now;                                  try                                  {                                      DataBox db = default(DataBox);                                      if (_requestCopy.Format == ImageFormat.PixelData)                                      {                                          db = _finalRT.Device.ImmediateContext.MapSubresource(_finalRT' 0' MapMode.Read' SharpDX.Direct3D11.MapFlags.DoNotWait);                                          _finalRTMapped = true;                                      }                                      _queryIssued = false;                                        try                                      {                                          using (MemoryStream ms = new MemoryStream())                                          {                                              switch (_requestCopy.Format)                                              {                                                  case ImageFormat.Bitmap:                                                      Texture2D.ToStream(_finalRT.Device.ImmediateContext' _finalRT' ImageFileFormat.Bmp' ms);                                                      break;                                                  case ImageFormat.Jpeg:                                                      Texture2D.ToStream(_finalRT.Device.ImmediateContext' _finalRT' ImageFileFormat.Jpg' ms);                                                      break;                                                  case ImageFormat.Png:                                                      Texture2D.ToStream(_finalRT.Device.ImmediateContext' _finalRT' ImageFileFormat.Png' ms);                                                      break;                                                  case ImageFormat.PixelData:                                                      if (db.DataPointer != IntPtr.Zero)                                                      {                                                          ProcessCapture(_finalRT.Description.Width' _finalRT.Description.Height' db.RowPitch' System.Drawing.Imaging.PixelFormat.Format32bppArgb' db.DataPointer' _requestCopy);                                                      }                                                      return;                                              }                                              ms.Position = 0;                                              ProcessCapture(ms' _requestCopy);                                          }                                      }                                      finally                                      {                                          this.DebugMessage("PresentHook: Copy to System Memory time: " + (DateTime.Now - startCopyToSystemMemory).ToString());                                                                                    if (_finalRTMapped)                                          {                                              lock (_lock)                                              {                                                  _finalRT.Device.ImmediateContext.UnmapSubresource(_finalRT' 0);                                                  _finalRTMapped = false;                                              }                                          }                                      }                                  }                                  catch (SharpDX.SharpDXException exc)                                  {                                      // Catch DXGI_ERROR_WAS_STILL_DRAWING and ignore - the data isn't available yet                                  }                              }                          }));                                                      // Note: it would be possible to capture multiple frames and process them in a background thread                      }                      this.DebugMessage("PresentHook: Copy BackBuffer time: " + (DateTime.Now - startTime).ToString());                      this.DebugMessage("PresentHook: Request End");                  }                  #endregion                    #region Draw overlay (after screenshot so we don't capture overlay as well)                  if (this.Config.ShowOverlay)                  {                      // Initialise Overlay Engine                      if (_swapChainPointer != swapChain.NativePointer || _overlayEngine == null)                      {                          if (_overlayEngine != null)                              _overlayEngine.Dispose();                            _overlayEngine = new DX11.DXOverlayEngine();                          _overlayEngine.Overlays.Add(new Capture.Hook.Common.Overlay                          {                              Elements =                              {                                  //new Capture.Hook.Common.TextElement(new System.Drawing.Font("Times New Roman"' 22)) { Text = "Test"' Location = new System.Drawing.Point(200' 200)' Color = System.Drawing.Color.Yellow' AntiAliased = false}'                                  new Capture.Hook.Common.FramesPerSecond(new System.Drawing.Font("Arial"' 16)) { Location = new System.Drawing.Point(5'5)' Color = System.Drawing.Color.Red' AntiAliased = true }'                                  //new Capture.Hook.Common.ImageElement(@"C:\Temp\test.bmp") { Location = new System.Drawing.Point(20' 20) }                              }                          });                          _overlayEngine.Initialise(swapChain);                            _swapChainPointer = swapChain.NativePointer;                      }                      // Draw Overlay(s)                      else if (_overlayEngine != null)                      {                          foreach (var overlay in _overlayEngine.Overlays)                              overlay.Frame();                          _overlayEngine.Draw();                      }                  }                  #endregion              }              catch (Exception e)              {                  // If there is an error we do not want to crash the hooked application' so swallow the exception                  this.DebugMessage("PresentHook: Exeception: " + e.GetType().FullName + ": " + e.ToString());                  //return unchecked((int)0x8000FFFF); //E_UNEXPECTED              }
Magic Number,Capture.Hook,DXHookD3D11,C:\repos\spazzarama_Direct3DHook\Capture\Hook\DXHookD3D11.cs,PresentHook,The following statement contains a magic number: try              {                  #region Screenshot Request                  if (this.Request != null)                  {                      this.DebugMessage("PresentHook: Request Start");                      DateTime startTime = DateTime.Now;                      using (Texture2D currentRT = Texture2D.FromSwapChain<Texture2D>(swapChain' 0))                      {                          #region Determine region to capture                          Rectangle captureRegion = new Rectangle(0' 0' currentRT.Description.Width' currentRT.Description.Height);                            if (this.Request.RegionToCapture.Width > 0)                          {                              captureRegion = new Rectangle(this.Request.RegionToCapture.Left' this.Request.RegionToCapture.Top' this.Request.RegionToCapture.Right' this.Request.RegionToCapture.Bottom);                          }                          else if (this.Request.Resize.HasValue)                          {                              captureRegion = new Rectangle(0' 0' this.Request.Resize.Value.Width' this.Request.Resize.Value.Height);                          }                          #endregion                            // Create / Recreate resources as necessary                          EnsureResources(currentRT.Device' currentRT.Description' captureRegion' Request);                            Texture2D sourceTexture = null;                            // If texture is multisampled' then we can use ResolveSubresource to copy it into a non-multisampled texture                          if (currentRT.Description.SampleDescription.Count > 1 || Request.Resize.HasValue)                          {                              if (Request.Resize.HasValue)                                  this.DebugMessage("PresentHook: resizing texture");                              else                                  this.DebugMessage("PresentHook: resolving multi-sampled texture");                                // Resolve into _resolvedRT                              if (_resolvedRTKeyedMutex != null)                                  _resolvedRTKeyedMutex.Acquire(0' int.MaxValue);                              currentRT.Device.ImmediateContext.ResolveSubresource(currentRT' 0' _resolvedRT' 0' _resolvedRT.Description.Format);                              if (_resolvedRTKeyedMutex != null)                                  _resolvedRTKeyedMutex.Release(1);                                if (Request.Resize.HasValue)                              {                                  lock(_lock)                                  {                                      if (_resolvedRTKeyedMutex_Dev2 != null)                                          _resolvedRTKeyedMutex_Dev2.Acquire(1' int.MaxValue);                                      _saQuad.ShaderResource = _resolvedSharedSRV;                                      _saQuad.RenderTargetView = _resizedRTV;                                      _saQuad.RenderTarget = _resizedRT;                                      _saQuad.Render();                                      if (_resolvedRTKeyedMutex_Dev2 != null)                                          _resolvedRTKeyedMutex_Dev2.Release(0);                                  }                                    // set sourceTexture to the resized RT                                  sourceTexture = _resizedRT;                              }                              else                              {                                  // Make sourceTexture be the resolved texture                                  sourceTexture = _resolvedRTShared;                              }                          }                          else                          {                              // Copy the resource into the shared texture                              if (_resolvedRTKeyedMutex != null) _resolvedRTKeyedMutex.Acquire(0' int.MaxValue);                              currentRT.Device.ImmediateContext.CopySubresourceRegion(currentRT' 0' null' _resolvedRT' 0);                              if (_resolvedRTKeyedMutex != null) _resolvedRTKeyedMutex.Release(1);                              sourceTexture = _resolvedRTShared;                          }                            // Copy to memory and send back to host process on a background thread so that we do not cause any delay in the rendering pipeline                          _requestCopy = this.Request.Clone(); // this.Request gets set to null' so copy the Request for use in the thread                            // Prevent the request from being processed a second time                          this.Request = null;                            bool acquireLock = sourceTexture == _resolvedRTShared;                            ThreadPool.QueueUserWorkItem(new WaitCallback((o) =>                          {                              // Acquire lock on second device                              if (acquireLock && _resolvedRTKeyedMutex_Dev2 != null)                                  _resolvedRTKeyedMutex_Dev2.Acquire(1' int.MaxValue);                                lock (_lock)                              {                                  // Copy the subresource region' we are dealing with a flat 2D texture with no MipMapping' so 0 is the subresource index                                  sourceTexture.Device.ImmediateContext.CopySubresourceRegion(sourceTexture' 0' new ResourceRegion()                                  {                                      Top = captureRegion.Top'                                      Bottom = captureRegion.Bottom'                                      Left = captureRegion.Left'                                      Right = captureRegion.Right'                                      Front = 0'                                      Back = 1 // Must be 1 or only black will be copied                                  }' _finalRT' 0' 0' 0' 0);                                    // Release lock upon shared surface on second device                                  if (acquireLock && _resolvedRTKeyedMutex_Dev2 != null)                                      _resolvedRTKeyedMutex_Dev2.Release(0);                                    _finalRT.Device.ImmediateContext.End(_query);                                  _queryIssued = true;                                  while (!_finalRT.Device.ImmediateContext.GetData(_query).ReadBoolean())                                  {                                      // Spin (usually no spin takes place)                                  }                                    DateTime startCopyToSystemMemory = DateTime.Now;                                  try                                  {                                      DataBox db = default(DataBox);                                      if (_requestCopy.Format == ImageFormat.PixelData)                                      {                                          db = _finalRT.Device.ImmediateContext.MapSubresource(_finalRT' 0' MapMode.Read' SharpDX.Direct3D11.MapFlags.DoNotWait);                                          _finalRTMapped = true;                                      }                                      _queryIssued = false;                                        try                                      {                                          using (MemoryStream ms = new MemoryStream())                                          {                                              switch (_requestCopy.Format)                                              {                                                  case ImageFormat.Bitmap:                                                      Texture2D.ToStream(_finalRT.Device.ImmediateContext' _finalRT' ImageFileFormat.Bmp' ms);                                                      break;                                                  case ImageFormat.Jpeg:                                                      Texture2D.ToStream(_finalRT.Device.ImmediateContext' _finalRT' ImageFileFormat.Jpg' ms);                                                      break;                                                  case ImageFormat.Png:                                                      Texture2D.ToStream(_finalRT.Device.ImmediateContext' _finalRT' ImageFileFormat.Png' ms);                                                      break;                                                  case ImageFormat.PixelData:                                                      if (db.DataPointer != IntPtr.Zero)                                                      {                                                          ProcessCapture(_finalRT.Description.Width' _finalRT.Description.Height' db.RowPitch' System.Drawing.Imaging.PixelFormat.Format32bppArgb' db.DataPointer' _requestCopy);                                                      }                                                      return;                                              }                                              ms.Position = 0;                                              ProcessCapture(ms' _requestCopy);                                          }                                      }                                      finally                                      {                                          this.DebugMessage("PresentHook: Copy to System Memory time: " + (DateTime.Now - startCopyToSystemMemory).ToString());                                                                                    if (_finalRTMapped)                                          {                                              lock (_lock)                                              {                                                  _finalRT.Device.ImmediateContext.UnmapSubresource(_finalRT' 0);                                                  _finalRTMapped = false;                                              }                                          }                                      }                                  }                                  catch (SharpDX.SharpDXException exc)                                  {                                      // Catch DXGI_ERROR_WAS_STILL_DRAWING and ignore - the data isn't available yet                                  }                              }                          }));                                                      // Note: it would be possible to capture multiple frames and process them in a background thread                      }                      this.DebugMessage("PresentHook: Copy BackBuffer time: " + (DateTime.Now - startTime).ToString());                      this.DebugMessage("PresentHook: Request End");                  }                  #endregion                    #region Draw overlay (after screenshot so we don't capture overlay as well)                  if (this.Config.ShowOverlay)                  {                      // Initialise Overlay Engine                      if (_swapChainPointer != swapChain.NativePointer || _overlayEngine == null)                      {                          if (_overlayEngine != null)                              _overlayEngine.Dispose();                            _overlayEngine = new DX11.DXOverlayEngine();                          _overlayEngine.Overlays.Add(new Capture.Hook.Common.Overlay                          {                              Elements =                              {                                  //new Capture.Hook.Common.TextElement(new System.Drawing.Font("Times New Roman"' 22)) { Text = "Test"' Location = new System.Drawing.Point(200' 200)' Color = System.Drawing.Color.Yellow' AntiAliased = false}'                                  new Capture.Hook.Common.FramesPerSecond(new System.Drawing.Font("Arial"' 16)) { Location = new System.Drawing.Point(5'5)' Color = System.Drawing.Color.Red' AntiAliased = true }'                                  //new Capture.Hook.Common.ImageElement(@"C:\Temp\test.bmp") { Location = new System.Drawing.Point(20' 20) }                              }                          });                          _overlayEngine.Initialise(swapChain);                            _swapChainPointer = swapChain.NativePointer;                      }                      // Draw Overlay(s)                      else if (_overlayEngine != null)                      {                          foreach (var overlay in _overlayEngine.Overlays)                              overlay.Frame();                          _overlayEngine.Draw();                      }                  }                  #endregion              }              catch (Exception e)              {                  // If there is an error we do not want to crash the hooked application' so swallow the exception                  this.DebugMessage("PresentHook: Exeception: " + e.GetType().FullName + ": " + e.ToString());                  //return unchecked((int)0x8000FFFF); //E_UNEXPECTED              }
Magic Number,Capture.Hook,DXHookD3D11,C:\repos\spazzarama_Direct3DHook\Capture\Hook\DXHookD3D11.cs,PresentHook,The following statement contains a magic number: try              {                  #region Screenshot Request                  if (this.Request != null)                  {                      this.DebugMessage("PresentHook: Request Start");                      DateTime startTime = DateTime.Now;                      using (Texture2D currentRT = Texture2D.FromSwapChain<Texture2D>(swapChain' 0))                      {                          #region Determine region to capture                          Rectangle captureRegion = new Rectangle(0' 0' currentRT.Description.Width' currentRT.Description.Height);                            if (this.Request.RegionToCapture.Width > 0)                          {                              captureRegion = new Rectangle(this.Request.RegionToCapture.Left' this.Request.RegionToCapture.Top' this.Request.RegionToCapture.Right' this.Request.RegionToCapture.Bottom);                          }                          else if (this.Request.Resize.HasValue)                          {                              captureRegion = new Rectangle(0' 0' this.Request.Resize.Value.Width' this.Request.Resize.Value.Height);                          }                          #endregion                            // Create / Recreate resources as necessary                          EnsureResources(currentRT.Device' currentRT.Description' captureRegion' Request);                            Texture2D sourceTexture = null;                            // If texture is multisampled' then we can use ResolveSubresource to copy it into a non-multisampled texture                          if (currentRT.Description.SampleDescription.Count > 1 || Request.Resize.HasValue)                          {                              if (Request.Resize.HasValue)                                  this.DebugMessage("PresentHook: resizing texture");                              else                                  this.DebugMessage("PresentHook: resolving multi-sampled texture");                                // Resolve into _resolvedRT                              if (_resolvedRTKeyedMutex != null)                                  _resolvedRTKeyedMutex.Acquire(0' int.MaxValue);                              currentRT.Device.ImmediateContext.ResolveSubresource(currentRT' 0' _resolvedRT' 0' _resolvedRT.Description.Format);                              if (_resolvedRTKeyedMutex != null)                                  _resolvedRTKeyedMutex.Release(1);                                if (Request.Resize.HasValue)                              {                                  lock(_lock)                                  {                                      if (_resolvedRTKeyedMutex_Dev2 != null)                                          _resolvedRTKeyedMutex_Dev2.Acquire(1' int.MaxValue);                                      _saQuad.ShaderResource = _resolvedSharedSRV;                                      _saQuad.RenderTargetView = _resizedRTV;                                      _saQuad.RenderTarget = _resizedRT;                                      _saQuad.Render();                                      if (_resolvedRTKeyedMutex_Dev2 != null)                                          _resolvedRTKeyedMutex_Dev2.Release(0);                                  }                                    // set sourceTexture to the resized RT                                  sourceTexture = _resizedRT;                              }                              else                              {                                  // Make sourceTexture be the resolved texture                                  sourceTexture = _resolvedRTShared;                              }                          }                          else                          {                              // Copy the resource into the shared texture                              if (_resolvedRTKeyedMutex != null) _resolvedRTKeyedMutex.Acquire(0' int.MaxValue);                              currentRT.Device.ImmediateContext.CopySubresourceRegion(currentRT' 0' null' _resolvedRT' 0);                              if (_resolvedRTKeyedMutex != null) _resolvedRTKeyedMutex.Release(1);                              sourceTexture = _resolvedRTShared;                          }                            // Copy to memory and send back to host process on a background thread so that we do not cause any delay in the rendering pipeline                          _requestCopy = this.Request.Clone(); // this.Request gets set to null' so copy the Request for use in the thread                            // Prevent the request from being processed a second time                          this.Request = null;                            bool acquireLock = sourceTexture == _resolvedRTShared;                            ThreadPool.QueueUserWorkItem(new WaitCallback((o) =>                          {                              // Acquire lock on second device                              if (acquireLock && _resolvedRTKeyedMutex_Dev2 != null)                                  _resolvedRTKeyedMutex_Dev2.Acquire(1' int.MaxValue);                                lock (_lock)                              {                                  // Copy the subresource region' we are dealing with a flat 2D texture with no MipMapping' so 0 is the subresource index                                  sourceTexture.Device.ImmediateContext.CopySubresourceRegion(sourceTexture' 0' new ResourceRegion()                                  {                                      Top = captureRegion.Top'                                      Bottom = captureRegion.Bottom'                                      Left = captureRegion.Left'                                      Right = captureRegion.Right'                                      Front = 0'                                      Back = 1 // Must be 1 or only black will be copied                                  }' _finalRT' 0' 0' 0' 0);                                    // Release lock upon shared surface on second device                                  if (acquireLock && _resolvedRTKeyedMutex_Dev2 != null)                                      _resolvedRTKeyedMutex_Dev2.Release(0);                                    _finalRT.Device.ImmediateContext.End(_query);                                  _queryIssued = true;                                  while (!_finalRT.Device.ImmediateContext.GetData(_query).ReadBoolean())                                  {                                      // Spin (usually no spin takes place)                                  }                                    DateTime startCopyToSystemMemory = DateTime.Now;                                  try                                  {                                      DataBox db = default(DataBox);                                      if (_requestCopy.Format == ImageFormat.PixelData)                                      {                                          db = _finalRT.Device.ImmediateContext.MapSubresource(_finalRT' 0' MapMode.Read' SharpDX.Direct3D11.MapFlags.DoNotWait);                                          _finalRTMapped = true;                                      }                                      _queryIssued = false;                                        try                                      {                                          using (MemoryStream ms = new MemoryStream())                                          {                                              switch (_requestCopy.Format)                                              {                                                  case ImageFormat.Bitmap:                                                      Texture2D.ToStream(_finalRT.Device.ImmediateContext' _finalRT' ImageFileFormat.Bmp' ms);                                                      break;                                                  case ImageFormat.Jpeg:                                                      Texture2D.ToStream(_finalRT.Device.ImmediateContext' _finalRT' ImageFileFormat.Jpg' ms);                                                      break;                                                  case ImageFormat.Png:                                                      Texture2D.ToStream(_finalRT.Device.ImmediateContext' _finalRT' ImageFileFormat.Png' ms);                                                      break;                                                  case ImageFormat.PixelData:                                                      if (db.DataPointer != IntPtr.Zero)                                                      {                                                          ProcessCapture(_finalRT.Description.Width' _finalRT.Description.Height' db.RowPitch' System.Drawing.Imaging.PixelFormat.Format32bppArgb' db.DataPointer' _requestCopy);                                                      }                                                      return;                                              }                                              ms.Position = 0;                                              ProcessCapture(ms' _requestCopy);                                          }                                      }                                      finally                                      {                                          this.DebugMessage("PresentHook: Copy to System Memory time: " + (DateTime.Now - startCopyToSystemMemory).ToString());                                                                                    if (_finalRTMapped)                                          {                                              lock (_lock)                                              {                                                  _finalRT.Device.ImmediateContext.UnmapSubresource(_finalRT' 0);                                                  _finalRTMapped = false;                                              }                                          }                                      }                                  }                                  catch (SharpDX.SharpDXException exc)                                  {                                      // Catch DXGI_ERROR_WAS_STILL_DRAWING and ignore - the data isn't available yet                                  }                              }                          }));                                                      // Note: it would be possible to capture multiple frames and process them in a background thread                      }                      this.DebugMessage("PresentHook: Copy BackBuffer time: " + (DateTime.Now - startTime).ToString());                      this.DebugMessage("PresentHook: Request End");                  }                  #endregion                    #region Draw overlay (after screenshot so we don't capture overlay as well)                  if (this.Config.ShowOverlay)                  {                      // Initialise Overlay Engine                      if (_swapChainPointer != swapChain.NativePointer || _overlayEngine == null)                      {                          if (_overlayEngine != null)                              _overlayEngine.Dispose();                            _overlayEngine = new DX11.DXOverlayEngine();                          _overlayEngine.Overlays.Add(new Capture.Hook.Common.Overlay                          {                              Elements =                              {                                  //new Capture.Hook.Common.TextElement(new System.Drawing.Font("Times New Roman"' 22)) { Text = "Test"' Location = new System.Drawing.Point(200' 200)' Color = System.Drawing.Color.Yellow' AntiAliased = false}'                                  new Capture.Hook.Common.FramesPerSecond(new System.Drawing.Font("Arial"' 16)) { Location = new System.Drawing.Point(5'5)' Color = System.Drawing.Color.Red' AntiAliased = true }'                                  //new Capture.Hook.Common.ImageElement(@"C:\Temp\test.bmp") { Location = new System.Drawing.Point(20' 20) }                              }                          });                          _overlayEngine.Initialise(swapChain);                            _swapChainPointer = swapChain.NativePointer;                      }                      // Draw Overlay(s)                      else if (_overlayEngine != null)                      {                          foreach (var overlay in _overlayEngine.Overlays)                              overlay.Frame();                          _overlayEngine.Draw();                      }                  }                  #endregion              }              catch (Exception e)              {                  // If there is an error we do not want to crash the hooked application' so swallow the exception                  this.DebugMessage("PresentHook: Exeception: " + e.GetType().FullName + ": " + e.ToString());                  //return unchecked((int)0x8000FFFF); //E_UNEXPECTED              }
Magic Number,Capture.Hook,DXHookD3D9,C:\repos\spazzarama_Direct3DHook\Capture\Hook\DXHookD3D9.cs,Hook,The following statement contains a magic number: try              {                  using (Direct3DEx d3dEx = new Direct3DEx())                  {                      this.DebugMessage("Hook: Direct3DEx...");                      using (var renderForm = new System.Windows.Forms.Form())                      {                          using (var deviceEx = new DeviceEx(d3dEx' 0' DeviceType.NullReference' IntPtr.Zero' CreateFlags.HardwareVertexProcessing' new PresentParameters() { BackBufferWidth = 1' BackBufferHeight = 1' DeviceWindowHandle = renderForm.Handle }' new DisplayModeEx() { Width = 800' Height = 600 }))                          {                              this.DebugMessage("Hook: DeviceEx created - PresentEx supported");                              id3dDeviceFunctionAddresses.AddRange(GetVTblAddresses(deviceEx.NativePointer' D3D9_DEVICE_METHOD_COUNT' D3D9Ex_DEVICE_METHOD_COUNT));                              _supportsDirect3D9Ex = true;                          }                      }                  }              }              catch (Exception)              {                  _supportsDirect3D9Ex = false;              }
Magic Number,Capture.Hook,DXHookD3D9,C:\repos\spazzarama_Direct3DHook\Capture\Hook\DXHookD3D9.cs,Hook,The following statement contains a magic number: try              {                  using (Direct3DEx d3dEx = new Direct3DEx())                  {                      this.DebugMessage("Hook: Direct3DEx...");                      using (var renderForm = new System.Windows.Forms.Form())                      {                          using (var deviceEx = new DeviceEx(d3dEx' 0' DeviceType.NullReference' IntPtr.Zero' CreateFlags.HardwareVertexProcessing' new PresentParameters() { BackBufferWidth = 1' BackBufferHeight = 1' DeviceWindowHandle = renderForm.Handle }' new DisplayModeEx() { Width = 800' Height = 600 }))                          {                              this.DebugMessage("Hook: DeviceEx created - PresentEx supported");                              id3dDeviceFunctionAddresses.AddRange(GetVTblAddresses(deviceEx.NativePointer' D3D9_DEVICE_METHOD_COUNT' D3D9Ex_DEVICE_METHOD_COUNT));                              _supportsDirect3D9Ex = true;                          }                      }                  }              }              catch (Exception)              {                  _supportsDirect3D9Ex = false;              }
Magic Number,Capture.Hook,DXHookD3D9,C:\repos\spazzarama_Direct3DHook\Capture\Hook\DXHookD3D9.cs,DoCaptureRenderTarget,The following statement contains a magic number: try              {                  #region Screenshot Request                    // If we have issued the command to copy data to our render target' check if it is complete                  bool qryResult;                  if (_queryIssued && _requestCopy != null && _query.GetData(out qryResult' false))                  {                      // The GPU has finished copying data to _renderTargetCopy' we can now lock                      // the data and access it on another thread.                        _queryIssued = false;                                            // Lock the render target                      SharpDX.Rectangle rect;                      SharpDX.DataRectangle lockedRect = LockRenderTarget(_renderTargetCopy' out rect);                      _renderTargetCopyLocked = true;                        // Copy the data from the render target                      System.Threading.Tasks.Task.Factory.StartNew(() =>                      {                          lock (_lockRenderTarget)                          {                              ProcessCapture(rect.Width' rect.Height' lockedRect.Pitch' _renderTargetCopy.Description.Format.ToPixelFormat()' lockedRect.DataPointer' _requestCopy);                          }                      });                  }                    // Single frame capture request                  if (this.Request != null)                  {                      DateTime start = DateTime.Now;                      try                      {                          using (Surface renderTarget = device.GetRenderTarget(0))                          {                              int width' height;                                // If resizing of the captured image' determine correct dimensions                              if (Request.Resize != null && (renderTarget.Description.Width > Request.Resize.Value.Width || renderTarget.Description.Height > Request.Resize.Value.Height))                              {                                  if (renderTarget.Description.Width > Request.Resize.Value.Width)                                  {                                      width = Request.Resize.Value.Width;                                      height = (int)Math.Round((renderTarget.Description.Height * ((double)Request.Resize.Value.Width / (double)renderTarget.Description.Width)));                                  }                                  else                                  {                                      height = Request.Resize.Value.Height;                                      width = (int)Math.Round((renderTarget.Description.Width * ((double)Request.Resize.Value.Height / (double)renderTarget.Description.Height)));                                  }                              }                              else                              {                                  width = renderTarget.Description.Width;                                  height = renderTarget.Description.Height;                              }                                // If existing _renderTargetCopy' ensure that it is the correct size and format                              if (_renderTargetCopy != null && (_renderTargetCopy.Description.Width != width || _renderTargetCopy.Description.Height != height || _renderTargetCopy.Description.Format != renderTarget.Description.Format))                              {                                  // Cleanup resources                                  Cleanup();                              }                                // Ensure that we have something to put the render target data into                              if (!_resourcesInitialised || _renderTargetCopy == null)                              {                                  CreateResources(device' width' height' renderTarget.Description.Format);                              }                                // Resize from render target Surface to resolvedSurface (also deals with resolving multi-sampling)                              device.StretchRectangle(renderTarget' _resolvedTarget' TextureFilter.None);                          }                            // If the render target is locked from a previous request unlock it                          if (_renderTargetCopyLocked)                          {                              // Wait for the the ProcessCapture thread to finish with it                              lock (_lockRenderTarget)                              {                                  if (_renderTargetCopyLocked)                                  {                                      _renderTargetCopy.UnlockRectangle();                                      _renderTargetCopyLocked = false;                                  }                              }                          }                                                        // Copy data from resolved target to our render target copy                          device.GetRenderTargetData(_resolvedTarget' _renderTargetCopy);                            _requestCopy = Request.Clone();                          _query.Issue(Issue.End);                          _queryIssued = true;                                                }                      finally                      {                          // We have completed the request - mark it as null so we do not continue to try to capture the same request                          // Note: If you are after high frame rates' consider implementing buffers here to capture more frequently                          //         and send back to the host application as needed. The IPC overhead significantly slows down                           //         the whole process if sending frame by frame.                          Request = null;                      }                      DateTime end = DateTime.Now;                      this.DebugMessage(hook + ": Capture time: " + (end - start).ToString());                  }                    #endregion                    if (this.Config.ShowOverlay)                  {                      #region Draw Overlay                        // Check if overlay needs to be initialised                      if (_overlayEngine == null || _overlayEngine.Device.NativePointer != device.NativePointer)                      {                          // Cleanup if necessary                          if (_overlayEngine != null)                              RemoveAndDispose(ref _overlayEngine);                            _overlayEngine = ToDispose(new DX9.DXOverlayEngine());                          // Create Overlay                          _overlayEngine.Overlays.Add(new Capture.Hook.Common.Overlay                          {                              Elements =                              {                                  // Add frame rate                                  new Capture.Hook.Common.FramesPerSecond(new System.Drawing.Font("Arial"' 16' FontStyle.Bold)) { Location = new System.Drawing.Point(5'5)' Color = System.Drawing.Color.Red' AntiAliased = true }'                                  // Example of adding an image to overlay (can implement semi transparency with Tint' e.g. Ting = Color.FromArgb(127' 255' 255' 255))                                  //new Capture.Hook.Common.ImageElement(@"C:\Temp\test.bmp") { Location = new System.Drawing.Point(20' 20) }                              }                          });                            _overlayEngine.Initialise(device);                      }                      // Draw Overlay(s)                      else if (_overlayEngine != null)                      {                          foreach (var overlay in _overlayEngine.Overlays)                              overlay.Frame();                          _overlayEngine.Draw();                      }                        #endregion                  }              }              catch (Exception e)              {                  DebugMessage(e.ToString());              }
Magic Number,Capture.Hook,DXHookD3D9,C:\repos\spazzarama_Direct3DHook\Capture\Hook\DXHookD3D9.cs,DoCaptureRenderTarget,The following statement contains a magic number: try              {                  #region Screenshot Request                    // If we have issued the command to copy data to our render target' check if it is complete                  bool qryResult;                  if (_queryIssued && _requestCopy != null && _query.GetData(out qryResult' false))                  {                      // The GPU has finished copying data to _renderTargetCopy' we can now lock                      // the data and access it on another thread.                        _queryIssued = false;                                            // Lock the render target                      SharpDX.Rectangle rect;                      SharpDX.DataRectangle lockedRect = LockRenderTarget(_renderTargetCopy' out rect);                      _renderTargetCopyLocked = true;                        // Copy the data from the render target                      System.Threading.Tasks.Task.Factory.StartNew(() =>                      {                          lock (_lockRenderTarget)                          {                              ProcessCapture(rect.Width' rect.Height' lockedRect.Pitch' _renderTargetCopy.Description.Format.ToPixelFormat()' lockedRect.DataPointer' _requestCopy);                          }                      });                  }                    // Single frame capture request                  if (this.Request != null)                  {                      DateTime start = DateTime.Now;                      try                      {                          using (Surface renderTarget = device.GetRenderTarget(0))                          {                              int width' height;                                // If resizing of the captured image' determine correct dimensions                              if (Request.Resize != null && (renderTarget.Description.Width > Request.Resize.Value.Width || renderTarget.Description.Height > Request.Resize.Value.Height))                              {                                  if (renderTarget.Description.Width > Request.Resize.Value.Width)                                  {                                      width = Request.Resize.Value.Width;                                      height = (int)Math.Round((renderTarget.Description.Height * ((double)Request.Resize.Value.Width / (double)renderTarget.Description.Width)));                                  }                                  else                                  {                                      height = Request.Resize.Value.Height;                                      width = (int)Math.Round((renderTarget.Description.Width * ((double)Request.Resize.Value.Height / (double)renderTarget.Description.Height)));                                  }                              }                              else                              {                                  width = renderTarget.Description.Width;                                  height = renderTarget.Description.Height;                              }                                // If existing _renderTargetCopy' ensure that it is the correct size and format                              if (_renderTargetCopy != null && (_renderTargetCopy.Description.Width != width || _renderTargetCopy.Description.Height != height || _renderTargetCopy.Description.Format != renderTarget.Description.Format))                              {                                  // Cleanup resources                                  Cleanup();                              }                                // Ensure that we have something to put the render target data into                              if (!_resourcesInitialised || _renderTargetCopy == null)                              {                                  CreateResources(device' width' height' renderTarget.Description.Format);                              }                                // Resize from render target Surface to resolvedSurface (also deals with resolving multi-sampling)                              device.StretchRectangle(renderTarget' _resolvedTarget' TextureFilter.None);                          }                            // If the render target is locked from a previous request unlock it                          if (_renderTargetCopyLocked)                          {                              // Wait for the the ProcessCapture thread to finish with it                              lock (_lockRenderTarget)                              {                                  if (_renderTargetCopyLocked)                                  {                                      _renderTargetCopy.UnlockRectangle();                                      _renderTargetCopyLocked = false;                                  }                              }                          }                                                        // Copy data from resolved target to our render target copy                          device.GetRenderTargetData(_resolvedTarget' _renderTargetCopy);                            _requestCopy = Request.Clone();                          _query.Issue(Issue.End);                          _queryIssued = true;                                                }                      finally                      {                          // We have completed the request - mark it as null so we do not continue to try to capture the same request                          // Note: If you are after high frame rates' consider implementing buffers here to capture more frequently                          //         and send back to the host application as needed. The IPC overhead significantly slows down                           //         the whole process if sending frame by frame.                          Request = null;                      }                      DateTime end = DateTime.Now;                      this.DebugMessage(hook + ": Capture time: " + (end - start).ToString());                  }                    #endregion                    if (this.Config.ShowOverlay)                  {                      #region Draw Overlay                        // Check if overlay needs to be initialised                      if (_overlayEngine == null || _overlayEngine.Device.NativePointer != device.NativePointer)                      {                          // Cleanup if necessary                          if (_overlayEngine != null)                              RemoveAndDispose(ref _overlayEngine);                            _overlayEngine = ToDispose(new DX9.DXOverlayEngine());                          // Create Overlay                          _overlayEngine.Overlays.Add(new Capture.Hook.Common.Overlay                          {                              Elements =                              {                                  // Add frame rate                                  new Capture.Hook.Common.FramesPerSecond(new System.Drawing.Font("Arial"' 16' FontStyle.Bold)) { Location = new System.Drawing.Point(5'5)' Color = System.Drawing.Color.Red' AntiAliased = true }'                                  // Example of adding an image to overlay (can implement semi transparency with Tint' e.g. Ting = Color.FromArgb(127' 255' 255' 255))                                  //new Capture.Hook.Common.ImageElement(@"C:\Temp\test.bmp") { Location = new System.Drawing.Point(20' 20) }                              }                          });                            _overlayEngine.Initialise(device);                      }                      // Draw Overlay(s)                      else if (_overlayEngine != null)                      {                          foreach (var overlay in _overlayEngine.Overlays)                              overlay.Frame();                          _overlayEngine.Draw();                      }                        #endregion                  }              }              catch (Exception e)              {                  DebugMessage(e.ToString());              }
Magic Number,Capture.Hook,DXHookD3D9,C:\repos\spazzarama_Direct3DHook\Capture\Hook\DXHookD3D9.cs,DoCaptureRenderTarget,The following statement contains a magic number: try              {                  #region Screenshot Request                    // If we have issued the command to copy data to our render target' check if it is complete                  bool qryResult;                  if (_queryIssued && _requestCopy != null && _query.GetData(out qryResult' false))                  {                      // The GPU has finished copying data to _renderTargetCopy' we can now lock                      // the data and access it on another thread.                        _queryIssued = false;                                            // Lock the render target                      SharpDX.Rectangle rect;                      SharpDX.DataRectangle lockedRect = LockRenderTarget(_renderTargetCopy' out rect);                      _renderTargetCopyLocked = true;                        // Copy the data from the render target                      System.Threading.Tasks.Task.Factory.StartNew(() =>                      {                          lock (_lockRenderTarget)                          {                              ProcessCapture(rect.Width' rect.Height' lockedRect.Pitch' _renderTargetCopy.Description.Format.ToPixelFormat()' lockedRect.DataPointer' _requestCopy);                          }                      });                  }                    // Single frame capture request                  if (this.Request != null)                  {                      DateTime start = DateTime.Now;                      try                      {                          using (Surface renderTarget = device.GetRenderTarget(0))                          {                              int width' height;                                // If resizing of the captured image' determine correct dimensions                              if (Request.Resize != null && (renderTarget.Description.Width > Request.Resize.Value.Width || renderTarget.Description.Height > Request.Resize.Value.Height))                              {                                  if (renderTarget.Description.Width > Request.Resize.Value.Width)                                  {                                      width = Request.Resize.Value.Width;                                      height = (int)Math.Round((renderTarget.Description.Height * ((double)Request.Resize.Value.Width / (double)renderTarget.Description.Width)));                                  }                                  else                                  {                                      height = Request.Resize.Value.Height;                                      width = (int)Math.Round((renderTarget.Description.Width * ((double)Request.Resize.Value.Height / (double)renderTarget.Description.Height)));                                  }                              }                              else                              {                                  width = renderTarget.Description.Width;                                  height = renderTarget.Description.Height;                              }                                // If existing _renderTargetCopy' ensure that it is the correct size and format                              if (_renderTargetCopy != null && (_renderTargetCopy.Description.Width != width || _renderTargetCopy.Description.Height != height || _renderTargetCopy.Description.Format != renderTarget.Description.Format))                              {                                  // Cleanup resources                                  Cleanup();                              }                                // Ensure that we have something to put the render target data into                              if (!_resourcesInitialised || _renderTargetCopy == null)                              {                                  CreateResources(device' width' height' renderTarget.Description.Format);                              }                                // Resize from render target Surface to resolvedSurface (also deals with resolving multi-sampling)                              device.StretchRectangle(renderTarget' _resolvedTarget' TextureFilter.None);                          }                            // If the render target is locked from a previous request unlock it                          if (_renderTargetCopyLocked)                          {                              // Wait for the the ProcessCapture thread to finish with it                              lock (_lockRenderTarget)                              {                                  if (_renderTargetCopyLocked)                                  {                                      _renderTargetCopy.UnlockRectangle();                                      _renderTargetCopyLocked = false;                                  }                              }                          }                                                        // Copy data from resolved target to our render target copy                          device.GetRenderTargetData(_resolvedTarget' _renderTargetCopy);                            _requestCopy = Request.Clone();                          _query.Issue(Issue.End);                          _queryIssued = true;                                                }                      finally                      {                          // We have completed the request - mark it as null so we do not continue to try to capture the same request                          // Note: If you are after high frame rates' consider implementing buffers here to capture more frequently                          //         and send back to the host application as needed. The IPC overhead significantly slows down                           //         the whole process if sending frame by frame.                          Request = null;                      }                      DateTime end = DateTime.Now;                      this.DebugMessage(hook + ": Capture time: " + (end - start).ToString());                  }                    #endregion                    if (this.Config.ShowOverlay)                  {                      #region Draw Overlay                        // Check if overlay needs to be initialised                      if (_overlayEngine == null || _overlayEngine.Device.NativePointer != device.NativePointer)                      {                          // Cleanup if necessary                          if (_overlayEngine != null)                              RemoveAndDispose(ref _overlayEngine);                            _overlayEngine = ToDispose(new DX9.DXOverlayEngine());                          // Create Overlay                          _overlayEngine.Overlays.Add(new Capture.Hook.Common.Overlay                          {                              Elements =                              {                                  // Add frame rate                                  new Capture.Hook.Common.FramesPerSecond(new System.Drawing.Font("Arial"' 16' FontStyle.Bold)) { Location = new System.Drawing.Point(5'5)' Color = System.Drawing.Color.Red' AntiAliased = true }'                                  // Example of adding an image to overlay (can implement semi transparency with Tint' e.g. Ting = Color.FromArgb(127' 255' 255' 255))                                  //new Capture.Hook.Common.ImageElement(@"C:\Temp\test.bmp") { Location = new System.Drawing.Point(20' 20) }                              }                          });                            _overlayEngine.Initialise(device);                      }                      // Draw Overlay(s)                      else if (_overlayEngine != null)                      {                          foreach (var overlay in _overlayEngine.Overlays)                              overlay.Frame();                          _overlayEngine.Draw();                      }                        #endregion                  }              }              catch (Exception e)              {                  DebugMessage(e.ToString());              }
Magic Number,Capture.Interface,CaptureConfig,C:\repos\spazzarama_Direct3DHook\Capture\Interface\CaptureConfig.cs,CaptureConfig,The following statement contains a magic number: TargetFramesPerSecond = 5;
Magic Number,Capture.Interface,CaptureInterface,C:\repos\spazzarama_Direct3DHook\Capture\Interface\CaptureInterface.cs,GetScreenshot,The following statement contains a magic number: return GetScreenshot(Rectangle.Empty' new TimeSpan(0' 0' 2)' null' ImageFormat.Bitmap);
Magic Number,Capture.Interface,CaptureInterface,C:\repos\spazzarama_Direct3DHook\Capture\Interface\CaptureInterface.cs,DisplayInGameText,The following statement contains a magic number: DisplayInGameText(text' new TimeSpan(0' 0' 5));
Missing Default,Capture.Hook,BaseDXHook,C:\repos\spazzarama_Direct3DHook\Capture\Hook\BaseDXHook.cs,ProcessCapture,The following switch statement is missing a default case: switch (request.Format)                      {                          case Capture.Interface.ImageFormat.Jpeg:                              imgFormat = System.Drawing.Imaging.ImageFormat.Jpeg;                              break;                          case Capture.Interface.ImageFormat.Png:                              imgFormat = System.Drawing.Imaging.ImageFormat.Png;                              break;                      }
Missing Default,Capture.Hook,DXHookD3D11,C:\repos\spazzarama_Direct3DHook\Capture\Hook\DXHookD3D11.cs,PresentHook,The following switch statement is missing a default case: switch (_requestCopy.Format)                                              {                                                  case ImageFormat.Bitmap:                                                      Texture2D.ToStream(_finalRT.Device.ImmediateContext' _finalRT' ImageFileFormat.Bmp' ms);                                                      break;                                                  case ImageFormat.Jpeg:                                                      Texture2D.ToStream(_finalRT.Device.ImmediateContext' _finalRT' ImageFileFormat.Jpg' ms);                                                      break;                                                  case ImageFormat.Png:                                                      Texture2D.ToStream(_finalRT.Device.ImmediateContext' _finalRT' ImageFileFormat.Png' ms);                                                      break;                                                  case ImageFormat.PixelData:                                                      if (db.DataPointer != IntPtr.Zero)                                                      {                                                          ProcessCapture(_finalRT.Description.Width' _finalRT.Description.Height' db.RowPitch' System.Drawing.Imaging.PixelFormat.Format32bppArgb' db.DataPointer' _requestCopy);                                                      }                                                      return;                                              }
